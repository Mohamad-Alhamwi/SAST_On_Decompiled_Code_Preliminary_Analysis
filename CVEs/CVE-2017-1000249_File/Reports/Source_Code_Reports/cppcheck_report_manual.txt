src/apprentice.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/apprentice.c:3186:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[0] = s[1];
         ^
src/apprentice.c:3184:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/apprentice.c:3186:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[0] = s[1];
         ^
src/apprentice.c:3187:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[1] = s[0];
  ^
src/apprentice.c:3185:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/apprentice.c:3187:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[1] = s[0];
  ^
src/apprentice.c:3200:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[0] = s[3];
         ^
src/apprentice.c:3198:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/apprentice.c:3200:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[0] = s[3];
         ^
src/apprentice.c:3201:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[1] = s[2];
  ^
src/apprentice.c:3199:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/apprentice.c:3201:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[1] = s[2];
  ^
src/apprentice.c:3201:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[1] = s[2];
         ^
src/apprentice.c:3198:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/apprentice.c:3201:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[1] = s[2];
         ^
src/apprentice.c:3202:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[2] = s[1];
  ^
src/apprentice.c:3199:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/apprentice.c:3202:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[2] = s[1];
  ^
src/apprentice.c:3202:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[2] = s[1];
         ^
src/apprentice.c:3198:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/apprentice.c:3202:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[2] = s[1];
         ^
src/apprentice.c:3203:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[3] = s[0];
  ^
src/apprentice.c:3199:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/apprentice.c:3203:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[3] = s[0];
  ^
src/apprentice.c:3226:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[0] = s[7];
         ^
src/apprentice.c:3214:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/apprentice.c:3226:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[0] = s[7];
         ^
src/apprentice.c:3227:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[1] = s[6];
  ^
src/apprentice.c:3215:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/apprentice.c:3227:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[1] = s[6];
  ^
src/apprentice.c:3227:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[1] = s[6];
         ^
src/apprentice.c:3214:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/apprentice.c:3227:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[1] = s[6];
         ^
src/apprentice.c:3228:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[2] = s[5];
  ^
src/apprentice.c:3215:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/apprentice.c:3228:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[2] = s[5];
  ^
src/apprentice.c:3228:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[2] = s[5];
         ^
src/apprentice.c:3214:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/apprentice.c:3228:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[2] = s[5];
         ^
src/apprentice.c:3229:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[3] = s[4];
  ^
src/apprentice.c:3215:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/apprentice.c:3229:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[3] = s[4];
  ^
src/apprentice.c:3229:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[3] = s[4];
         ^
src/apprentice.c:3214:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/apprentice.c:3229:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[3] = s[4];
         ^
src/apprentice.c:3230:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[4] = s[3];
  ^
src/apprentice.c:3215:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/apprentice.c:3230:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[4] = s[3];
  ^
src/apprentice.c:3230:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[4] = s[3];
         ^
src/apprentice.c:3214:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/apprentice.c:3230:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[4] = s[3];
         ^
src/apprentice.c:3231:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[5] = s[2];
  ^
src/apprentice.c:3215:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/apprentice.c:3231:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[5] = s[2];
  ^
src/apprentice.c:3231:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[5] = s[2];
         ^
src/apprentice.c:3214:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/apprentice.c:3231:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[5] = s[2];
         ^
src/apprentice.c:3232:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[6] = s[1];
  ^
src/apprentice.c:3215:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/apprentice.c:3232:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[6] = s[1];
  ^
src/apprentice.c:3232:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[6] = s[1];
         ^
src/apprentice.c:3214:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/apprentice.c:3232:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[6] = s[1];
         ^
src/apprentice.c:3233:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[7] = s[0];
  ^
src/apprentice.c:3215:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/apprentice.c:3233:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[7] = s[0];
  ^
src/apprentice.c:597:10: style: Variable 'ml' is reassigned a value before the old one has been used. [redundantAssignment]
 for (ml = mlist->next; (next = ml->next) != NULL; ml = next) {
         ^
src/apprentice.c:596:5: note: ml is assigned
 ml = mlist->next;
    ^
src/apprentice.c:597:10: note: ml is overwritten
 for (ml = mlist->next; (next = ml->next) != NULL; ml = next) {
         ^
src/apprentice.c:2502:8: style: Variable '*estr' is reassigned a value before the old one has been used. [redundantAssignment]
 *estr = "too long";
       ^
src/apprentice.c:2500:8: note: *estr is assigned
 *estr = "not valid";
       ^
src/apprentice.c:2502:8: note: *estr is overwritten
 *estr = "too long";
       ^
src/apprentice.c:660:6: style: The scope of the variable 'file_err' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 int file_err, errs = -1;
     ^
src/apprentice.c:1787:10: style: The scope of the variable 'diff' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 int32_t diff;
         ^
src/apprentice.c:1214:32: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
      me[i].mp->flag & BINTEST ? binary : text);
                               ^
src/apprentice.c:434:16: style: Variable 'ml' is not assigned a value. [unassignedVariable]
 struct mlist *ml;
               ^
src/apprentice.c:613:16: style: Variable 'ml' is not assigned a value. [unassignedVariable]
 struct mlist *ml;
               ^
src/apprentice.c:963:20: style: Variable 'magindex' is assigned a value that is never used. [unreadVariable]
 uint32_t magindex = 0;
                   ^
src/apptype.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/apptype.c:52:18: style: The scope of the variable 'fp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 FILE           *fp;
                 ^
src/ascmagic.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/ascmagic.c:198:8: style: Condition 'subtype_mime' is always false [knownConditionTrueFalse]
   if (subtype_mime) {
       ^
src/ascmagic.c:108:29: note: Assignment 'subtype_mime=NULL', assigned value is 0
 const char *subtype_mime = NULL;
                            ^
src/ascmagic.c:198:8: note: Condition 'subtype_mime' is always false
   if (subtype_mime) {
       ^
src/asctime_r.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/asctime_r.c:14:12: style: Obsolete function 'asctime' called. It is recommended to use 'strftime' instead. [asctimeCalled]
 char *p = asctime(t);
           ^
src/asprintf.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/cdf.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/cdf.c:93:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[0] = s[1];
         ^
src/cdf.c:91:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/cdf.c:93:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[0] = s[1];
         ^
src/cdf.c:94:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[1] = s[0];
  ^
src/cdf.c:92:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/cdf.c:94:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[1] = s[0];
  ^
src/cdf.c:107:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[0] = s[3];
         ^
src/cdf.c:105:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/cdf.c:107:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[0] = s[3];
         ^
src/cdf.c:108:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[1] = s[2];
  ^
src/cdf.c:106:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/cdf.c:108:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[1] = s[2];
  ^
src/cdf.c:108:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[1] = s[2];
         ^
src/cdf.c:105:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/cdf.c:108:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[1] = s[2];
         ^
src/cdf.c:109:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[2] = s[1];
  ^
src/cdf.c:106:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/cdf.c:109:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[2] = s[1];
  ^
src/cdf.c:109:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[2] = s[1];
         ^
src/cdf.c:105:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/cdf.c:109:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[2] = s[1];
         ^
src/cdf.c:110:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[3] = s[0];
  ^
src/cdf.c:106:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/cdf.c:110:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[3] = s[0];
  ^
src/cdf.c:123:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[0] = s[7];
         ^
src/cdf.c:121:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/cdf.c:123:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[0] = s[7];
         ^
src/cdf.c:124:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[1] = s[6];
  ^
src/cdf.c:122:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/cdf.c:124:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[1] = s[6];
  ^
src/cdf.c:124:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[1] = s[6];
         ^
src/cdf.c:121:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/cdf.c:124:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[1] = s[6];
         ^
src/cdf.c:125:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[2] = s[5];
  ^
src/cdf.c:122:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/cdf.c:125:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[2] = s[5];
  ^
src/cdf.c:125:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[2] = s[5];
         ^
src/cdf.c:121:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/cdf.c:125:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[2] = s[5];
         ^
src/cdf.c:126:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[3] = s[4];
  ^
src/cdf.c:122:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/cdf.c:126:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[3] = s[4];
  ^
src/cdf.c:126:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[3] = s[4];
         ^
src/cdf.c:121:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/cdf.c:126:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[3] = s[4];
         ^
src/cdf.c:127:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[4] = s[3];
  ^
src/cdf.c:122:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/cdf.c:127:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[4] = s[3];
  ^
src/cdf.c:127:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[4] = s[3];
         ^
src/cdf.c:121:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/cdf.c:127:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[4] = s[3];
         ^
src/cdf.c:128:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[5] = s[2];
  ^
src/cdf.c:122:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/cdf.c:128:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[5] = s[2];
  ^
src/cdf.c:128:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[5] = s[2];
         ^
src/cdf.c:121:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/cdf.c:128:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[5] = s[2];
         ^
src/cdf.c:129:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[6] = s[1];
  ^
src/cdf.c:122:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/cdf.c:129:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[6] = s[1];
  ^
src/cdf.c:129:10: error: The address of local variable 'sv' is accessed at non-zero index. [objectIndex]
 d[6] = s[1];
         ^
src/cdf.c:121:34: note: Address of variable taken here.
 uint8_t *s = (uint8_t *)(void *)&sv;
                                 ^
src/cdf.c:129:10: note: The address of local variable 'sv' is accessed at non-zero index.
 d[6] = s[1];
         ^
src/cdf.c:130:3: error: The address of local variable 'rv' is accessed at non-zero index. [objectIndex]
 d[7] = s[0];
  ^
src/cdf.c:122:34: note: Address of variable taken here.
 uint8_t *d = (uint8_t *)(void *)&rv;
                                 ^
src/cdf.c:130:3: note: The address of local variable 'rv' is accessed at non-zero index.
 d[7] = s[0];
  ^
src/cdf.c:464:5: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
    DPRINTF(("Reading sector %d",
    ^
src/cdf.c:977:5: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
    DPRINTF(("l = %d, r = %" SIZE_T_FORMAT
    ^
src/cdf.c:1225:2: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
 DUMP("%d", num_sectors_in_sat);
 ^
src/cdf.c:1226:2: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
 DUMP("%d", secid_first_directory);
 ^
src/cdf.c:1227:2: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
 DUMP("%d", min_size_standard_stream);
 ^
src/cdf.c:1229:2: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
 DUMP("%d", num_sectors_in_short_sat);
 ^
src/cdf.c:1231:2: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
 DUMP("%d", num_sectors_in_master_sat);
 ^
src/cdf.c:1249:10: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
   (void)fprintf(stderr, "%5d, ",
         ^
src/cdf.c:1323:9: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  (void)fprintf(stderr, "Size %d\n", d->d_size);
        ^
src/cdf.c:1434:8: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
 (void)fprintf(stderr, "Count %d\n", ssi.si_count);
       ^
src/cdf.c:1453:3: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  printf("\t%d %s %s", ce[i].ce_num,
  ^
src/cdf_time.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/compress.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/compress.c:289:10: style: The scope of the variable 'rv' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 ssize_t rv;
         ^
src/compress.c:140:14: style: struct member 'Anonymous3::magic' is never used. [unusedStructMember]
 const void *magic;
             ^
src/compress.c:141:9: style: struct member 'Anonymous3::maglen' is never used. [unusedStructMember]
 size_t maglen;
        ^
src/compress.c:142:15: style: struct member 'Anonymous3::argv' is never used. [unusedStructMember]
 const char **argv;
              ^
src/compress.c:332:0: information: Skipping configuration 'FD_ZERO;FIONREAD' since the value of 'FD_ZERO' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   FD_ZERO(&check);
^
src/compress.c:324:0: information: Skipping configuration 'FD_ZERO;FIONREAD' since the value of 'FIONREAD' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (canbepipe && (ioctl(fd, FIONREAD, &t) == -1 || t == 0)) {
^
src/compress.c:349:0: information: Skipping configuration 'FD_ZERO;FIONREAD' since the value of 'FIONREAD' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  (void)ioctl(fd, FIONREAD, &t);
^
src/compress.c:324:0: information: Skipping configuration 'FIONREAD' since the value of 'FIONREAD' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (canbepipe && (ioctl(fd, FIONREAD, &t) == -1 || t == 0)) {
^
src/compress.c:349:0: information: Skipping configuration 'FIONREAD' since the value of 'FIONREAD' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  (void)ioctl(fd, FIONREAD, &t);
^
src/compress.c:732:7: style: Variable 'rv' is reassigned a value before the old one has been used. [redundantAssignment]
   rv = makeerror(newch, n, "Read failed, %s",
      ^
src/compress.c:723:6: note: rv is assigned
  rv = ERRDATA;
     ^
src/compress.c:732:7: note: rv is overwritten
   rv = makeerror(newch, n, "Read failed, %s",
      ^
src/ctime_r.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/der.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/der.c:228:2: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
 DPRINTF(("%s1: %d %zu %u\n", __func__, ms->offset, offs, m->offset));
 ^
src/der.c:233:2: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
 DPRINTF(("%s2: %d %zu %u\n", __func__, ms->offset, offs, tlen));
 ^
src/der.c:239:3: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  printf("cont_level[%zu] = %u\n", i, ms->c.li[i].off);
  ^
src/der.c:245:3: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  DPRINTF(("cont_level[%u] = %u\n", m->cont_level - 1,
  ^
src/der.c:245:3: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  DPRINTF(("cont_level[%u] = %u\n", m->cont_level - 1,
  ^
src/der.c:336:9: style: The scope of the variable 'ox' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 size_t ox;
        ^
src/dprintf.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/encoding.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/file.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/file.c:370:18: style: The scope of the variable 'nw' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  size_t j, wid, nw;
                 ^
src/file.c:457:15: style: The scope of the variable 'cwid' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 int wid = 0, cwid;
              ^
src/file.c:530:9: style: The scope of the variable 'bytesconsumed' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 size_t bytesconsumed, old_n, n, width = 0;
        ^
src/fmtcheck.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/fsmagic.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/fsmagic.c:232:0: information: Skipping configuration 'HAVE_STRUCT_STAT_ST_RDEV;S_IFBLK' since the value of 'S_IFBLK' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 case S_IFBLK:
^
src/fsmagic.c:232:0: information: Skipping configuration 'HAVE_STRUCT_STAT_ST_RDEV;S_IFBLK;dv_unit' since the value of 'S_IFBLK' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 case S_IFBLK:
^
src/fsmagic.c:249:0: information: Skipping configuration 'HAVE_STRUCT_STAT_ST_RDEV;S_IFBLK;dv_unit' since the value of 'dv_unit' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
       COMMA, major(sb->st_rdev), dv_unit(sb->st_rdev),
^
src/fsmagic.c:198:0: information: Skipping configuration 'HAVE_STRUCT_STAT_ST_RDEV;S_IFCHR' since the value of 'S_IFCHR' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 case S_IFCHR:
^
src/fsmagic.c:198:0: information: Skipping configuration 'HAVE_STRUCT_STAT_ST_RDEV;S_IFCHR;dv_unit' since the value of 'S_IFCHR' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 case S_IFCHR:
^
src/fsmagic.c:215:0: information: Skipping configuration 'HAVE_STRUCT_STAT_ST_RDEV;S_IFCHR;dv_unit' since the value of 'dv_unit' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
       COMMA, major(sb->st_rdev), dv_unit(sb->st_rdev),
^
src/funcs.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/funcs.c:438:9: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 size_t len;
        ^
src/funcs.c:390:10: style: The scope of the variable 'bytesconsumed' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  size_t bytesconsumed;
         ^
src/getline.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/getopt_long.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/getopt_long.c:143:6: style: The scope of the variable 'cstart' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
     ^
src/getopt_long.c:143:55: style: The scope of the variable 'pos' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
                                                      ^
src/gmtime_r.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/is_tar.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/localtime_r.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/magic.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/pread.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/print.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/print.c:67:10: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  (void) fprintf(stderr, "%c%u),",
         ^
src/print.c:138:11: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
   (void) fprintf(stderr, "%d", m->value.l);
          ^
src/print.c:143:11: warning: %lld in format string (no. 1) requires 'long long' but the argument type is 'unsigned long long'. [invalidPrintfArgType_sint]
   (void) fprintf(stderr, "%" INT64_T_FORMAT "d",
          ^
src/print.c:55:7: style: The scope of the variable 'tbuf' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 char tbuf[26];
      ^
src/print.c:143:11: warning: %I64d in format string (no. 1) requires '__int64' but the argument type is 'unsigned long long'. [invalidPrintfArgType_sint]
   (void) fprintf(stderr, "%" INT64_T_FORMAT "d",
          ^
src/readcdf.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/readcdf.c:267:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 size_t i;
        ^
src/readcdf.c:268:7: style: The scope of the variable 'buf' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 char buf[256];
      ^
src/readcdf.c:269:23: style: The scope of the variable 'ce' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 cdf_catalog_entry_t *ce;
                      ^
src/readcdf.c:306:15: style: The scope of the variable 'str' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  const char *str;
              ^
src/readelf.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/readelf.c:512:46: warning: Logical disjunction always evaluates to true: descsz >= 4 || descsz <= 20. Are these conditions necessary? Did you intend to use && instead? Are the numbers correct? Are you comparing the correct variables? [incorrectLogicOperator]
     type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20)) {
                                             ^
src/readelf.c:1451:7: style: The scope of the variable 'ibuf' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 char ibuf[BUFSIZ];
      ^
src/readelf.c:1452:10: style: The scope of the variable 'bufsize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 ssize_t bufsize;
         ^
src/readelf.c:1453:17: style: The scope of the variable 'align' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 size_t offset, align, len;
                ^
src/readelf.c:757:20: style: Finding the same value in both branches of ternary operator is suspicious as the same code is executed regardless of the condition. [duplicateValueTernary]
   for (i = 0; i < NOFFSETS; i++) {
                   ^
src/readelf.c:812:26: style: Finding the same value in both branches of ternary operator is suspicious as the same code is executed regardless of the condition. [duplicateValueTernary]
    for (k = i + 1 ; k < NOFFSETS; k++) {
                         ^
src/softmagic.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/softmagic.c:1168:9: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
 (void) fprintf(stderr, "mget/%" SIZE_T_FORMAT "u @%d: ", len, offset);
        ^
src/softmagic.c:95:6: style: The scope of the variable 'rv' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 int rv, printed_something = 0, need_separator = 0;
     ^
src/softmagic.c:1344:11: style: The scope of the variable 'lhs' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 intmax_t lhs;
          ^
src/softmagic.c:1346:27: style: The scope of the variable 'in_type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 int rv, oneed_separator, in_type;
                          ^
src/softmagic.c:1861:15: style: The scope of the variable 'search' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  const char *search;
              ^
src/softmagic.c:1168:9: portability: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
 (void) fprintf(stderr, "mget/%" SIZE_T_FORMAT "u @%d: ", len, offset);
        ^
src/softmagic.c:1368:3: portability: %u in format string (no. 4) requires 'unsigned int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
  fprintf(stderr, "mget(type=%d, flag=%x, offset=%u, o=%"
  ^
src/softmagic.c:1368:3: portability: %u in format string (no. 5) requires 'unsigned int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
  fprintf(stderr, "mget(type=%d, flag=%x, offset=%u, o=%"
  ^
src/softmagic.c:1168:9: portability: %I64u in format string (no. 1) requires 'unsigned __int64' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
 (void) fprintf(stderr, "mget/%" SIZE_T_FORMAT "u @%d: ", len, offset);
        ^
src/softmagic.c:1368:3: portability: %I64u in format string (no. 4) requires 'unsigned __int64' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
  fprintf(stderr, "mget(type=%d, flag=%x, offset=%u, o=%"
  ^
src/softmagic.c:1368:3: portability: %I64u in format string (no. 5) requires 'unsigned __int64' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
  fprintf(stderr, "mget(type=%d, flag=%x, offset=%u, o=%"
  ^
src/strcasestr.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/strcasestr.c:69:10: style: The scope of the variable 'sc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 char c, sc;
         ^
src/strcasestr.c:70:9: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 size_t len;
        ^
src/strlcat.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/strlcpy.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/vasprintf.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/vasprintf.c:604:14: style: Variable 'dummy_base' is reassigned a value before the old one has been used. [redundantAssignment]
  dummy_base = s->buffer_base + s->real_len;
             ^
src/vasprintf.c:602:14: note: dummy_base is assigned
  dummy_base = s->buffer_base;
             ^
src/vasprintf.c:604:14: note: dummy_base is overwritten
  dummy_base = s->buffer_base + s->real_len;
             ^
tests/test.c:71:14: style: The scope of the variable 'result' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 const char *result;
             ^
tests/test.c:72:8: style: The scope of the variable 'desired' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 char *desired;
       ^
tests/test.c:75:8: style: The scope of the variable 'fp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 FILE *fp;
       ^
tests/test.c:74:6: style: Unused variable: i [unusedVariable]
 int i;
     ^
src/cdf_time.c:147:0: style: The function 'cdf_timespec_to_timestamp' is never used. [unusedFunction]

^
src/cdf.c:158:0: style: The function 'cdf_tole4' is never used. [unusedFunction]

^
src/cdf.c:164:0: style: The function 'cdf_tole8' is never used. [unusedFunction]

^
src/apptype.c:45:0: style: The function 'file_os2_apptype' is never used. [unusedFunction]

^
src/getopt_long.c:322:0: style: The function 'getopt' is never used. [unusedFunction]

^
src/magic.c:537:0: style: The function 'magic_buffer' is never used. [unusedFunction]

^
src/magic.c:384:0: style: The function 'magic_descriptor' is never used. [unusedFunction]

^
src/magic.c:563:0: style: The function 'magic_errno' is never used. [unusedFunction]

^
src/magic.c:621:0: style: The function 'magic_getparam' is never used. [unusedFunction]

^
src/magic.c:312:0: style: The function 'magic_load_buffers' is never used. [unusedFunction]

^
src/strlcat.c:33:0: style: The function 'strlcat' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingInclude]


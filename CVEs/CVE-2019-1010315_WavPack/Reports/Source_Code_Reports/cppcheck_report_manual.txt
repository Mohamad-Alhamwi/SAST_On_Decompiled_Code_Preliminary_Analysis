CMakeFiles/3.16.3/CompilerIdC/CMakeCCompilerId.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
CMakeFiles/3.16.3/CompilerIdCXX/CMakeCXXCompilerId.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
audition/cool_wv4.c:462:30: style: The if condition is the same as the previous if condition [duplicateCondition]
            if (out->wvc_file.file)
                             ^
audition/cool_wv4.c:459:30: note: First condition
            if (out->wvc_file.file)
                             ^
audition/cool_wv4.c:462:30: note: Second condition
            if (out->wvc_file.file)
                             ^
audition/cool_wv4.c:309:17: error: Used file that is not opened. [useClosedFile]
                fclose (out->wv_file.file);
                ^
audition/cool_wv4.c:309:17: error: Resource handle 'file' freed twice. [doubleFree]
                fclose (out->wv_file.file);
                ^
audition/cool_wv4.c:305:13: note: Resource handle 'file' freed twice.
            fclose (out->wv_file.file);
            ^
audition/cool_wv4.c:309:17: note: Resource handle 'file' freed twice.
                fclose (out->wv_file.file);
                ^
audition/cool_wv4.c:149:9: warning: Either the condition 'if(wid&&wid->file&&data&&bcount)' is redundant or there is possible null pointer dereference: wid. [nullPointerRedundantCheck]
    if (wid->error)
        ^
audition/cool_wv4.c:152:8: note: Assuming that condition 'if(wid&&wid->file&&data&&bcount)' is not redundant
    if (wid && wid->file && data && bcount) {
       ^
audition/cool_wv4.c:149:9: note: Null pointer dereference
    if (wid->error)
        ^
audition/cool_wv4.c:392:19: portability: Casting from float * to signed long * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                * (long*) fPtr++ = (bits_per_sample == 24) ? temp : temp << 4;
                  ^
audition/cool_wv4.c:415:19: portability: Casting from float * to signed long * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                * (long*) fPtr++ = (bits_per_sample == 24) ? temp : temp << 4;
                  ^
audition/cool_wv4.c:634:26: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
            float *out = (float *) buffer, factor = 1.0 / 256.0;
                         ^
audition/cool_wv4.c:329:9: style: The scope of the variable 'bits_per_sample' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int bits_per_sample, bytes_per_sample, num_channels, result;
        ^
audition/cool_wv4.c:329:26: style: The scope of the variable 'bytes_per_sample' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int bits_per_sample, bytes_per_sample, num_channels, result;
                         ^
audition/cool_wv4.c:329:44: style: The scope of the variable 'num_channels' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int bits_per_sample, bytes_per_sample, num_channels, result;
                                           ^
audition/cool_wv4.c:329:58: style: The scope of the variable 'result' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int bits_per_sample, bytes_per_sample, num_channels, result;
                                                         ^
audition/cool_wv4.c:330:44: style: The scope of the variable 'samples' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t *buffer = (int32_t *) lpbData, samples;
                                           ^
audition/cool_wv4.c:332:21: style: The scope of the variable 'wpc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    WavpackContext *wpc;
                    ^
audition/cool_wv4.c:447:21: style: The scope of the variable 'wpc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    WavpackContext *wpc;
                    ^
audition/cool_wv4.c:1175:11: style: The scope of the variable 'listdp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *listdp;
          ^
audition/cool_wv4.c:197:5: style: Redundant pointer operation on 'out' - it's already a pointer. [redundantPointerOp]
    CLEAR (*out);
    ^
audition/cool_wv4.c:544:5: style: Redundant pointer operation on 'in' - it's already a pointer. [redundantPointerOp]
    CLEAR (*in);
    ^
audition/cool_wv4.c:1117:21: style: Redundant pointer operation on 'pCue' - it's already a pointer. [redundantPointerOp]
                    CLEAR (*pCue);
                    ^
audition/cool_wv4.c:1140:21: style: Redundant pointer operation on 'pPlay' - it's already a pointer. [redundantPointerOp]
                    CLEAR (*pPlay);
                    ^
audition/cool_wv4.c:351:55: style: Local variable 'out' shadows outer variable [shadowVariable]
            int32_t samcnt = samples * num_channels, *out = buffer;
                                                      ^
audition/cool_wv4.c:331:13: note: Shadowed declaration
    OUTPUT *out = hOutput;
            ^
audition/cool_wv4.c:351:55: note: Shadow variable
            int32_t samcnt = samples * num_channels, *out = buffer;
                                                      ^
audition/cool_wv4.c:358:55: style: Local variable 'out' shadows outer variable [shadowVariable]
            int32_t samcnt = samples * num_channels, *out = buffer;
                                                      ^
audition/cool_wv4.c:331:13: note: Shadowed declaration
    OUTPUT *out = hOutput;
            ^
audition/cool_wv4.c:358:55: note: Shadow variable
            int32_t samcnt = samples * num_channels, *out = buffer;
                                                      ^
audition/cool_wv4.c:633:67: style: Variable 'inp' is assigned a value that is never used. [unreadVariable]
            int32_t samcnt = samples_to_read * num_channels, *inp = buffer;
                                                                  ^
cli/caff.c:681:17: style: Local variable 'i' shadows outer variable [shadowVariable]
            int i;
                ^
cli/caff.c:576:31: note: Shadowed declaration
    int num_identified_chans, i;
                              ^
cli/caff.c:681:17: note: Shadow variable
            int i;
                ^
cli/md5.c:104:14: style: The scope of the variable 'saved_a' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 MD5_u32plus saved_a, saved_b, saved_c, saved_d;
             ^
cli/md5.c:104:23: style: The scope of the variable 'saved_b' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 MD5_u32plus saved_a, saved_b, saved_c, saved_d;
                      ^
cli/md5.c:104:32: style: The scope of the variable 'saved_c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 MD5_u32plus saved_a, saved_b, saved_c, saved_d;
                               ^
cli/md5.c:104:41: style: The scope of the variable 'saved_d' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 MD5_u32plus saved_a, saved_b, saved_c, saved_d;
                                        ^
cli/md5.c:221:22: style: The scope of the variable 'available' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 unsigned long used, available;
                     ^
cli/riff.c:430:9: style: Condition 'table_length' is always false [knownConditionTrueFalse]
    if (table_length) {
        ^
cli/riff.c:331:53: note: Assignment 'table_length=0', assigned value is 0
    int do_rf64 = 0, write_junk = 1, table_length = 0;
                                                    ^
cli/riff.c:430:9: note: Condition 'table_length' is always false
    if (table_length) {
        ^
cli/riff.c:40:10: style: struct member 'JunkChunk::junk' is never used. [unusedStructMember]
    char junk [28];
         ^
cli/utils.c:307:9: style: The scope of the variable 'key' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int key;
        ^
cli/utils.c:613:14: style: The scope of the variable 'bcount' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t bcount;
             ^
cli/utils.c:633:14: style: The scope of the variable 'bcount' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t bcount;
             ^
cli/wavpack.c:2324:13: style: Condition 'sample_count' is always true [knownConditionTrueFalse]
        if (sample_count) {
            ^
cli/wavpack.c:2321:13: note: Assuming that condition '!sample_count' is not redundant
        if (!sample_count)
            ^
cli/wavpack.c:2324:13: note: Condition 'sample_count' is always true
        if (sample_count) {
            ^
cli/wavpack.c:2488:13: style: Condition 'sample_count' is always true [knownConditionTrueFalse]
        if (sample_count) {
            ^
cli/wavpack.c:2485:13: note: Assuming that condition '!sample_count' is not redundant
        if (!sample_count)
            ^
cli/wavpack.c:2488:13: note: Condition 'sample_count' is always true
        if (sample_count) {
            ^
cli/wavpack.c:765:17: error: Common realloc mistake: 'tag_items' nulled but not freed upon failure [memleakOnRealloc]
                tag_items = realloc (tag_items, ++num_tag_items * sizeof (*tag_items));
                ^
cli/wavpack.c:1933:17: error: Common realloc mistake: 'buffer' nulled but not freed upon failure [memleakOnRealloc]
                buffer = realloc (buffer, buffer_size += 65536);
                ^
cli/wavpack.c:1381:9: warning: Either the condition 'if(wid&&wid->file&&data&&length)' is redundant or there is possible null pointer dereference: wid. [nullPointerRedundantCheck]
    if (wid->error)
        ^
cli/wavpack.c:1384:8: note: Assuming that condition 'if(wid&&wid->file&&data&&length)' is not redundant
    if (wid && wid->file && data && length) {
       ^
cli/wavpack.c:1381:9: note: Null pointer dereference
    if (wid->error)
        ^
cli/wavpack.c:2345:42: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
                        const float f = *(float *)&sample_buffer[x];
                                         ^
cli/wavpack.c:2346:26: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
                        *(float *)&sample_buffer[x] = (float) (floor(f * fquantize_scale + 0.5) * fquantize_iscale);
                         ^
cli/wavpack.c:3274:38: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
                    const float f = *(float *)&sample_buffer[x];
                                     ^
cli/wavpack.c:3275:22: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
                    *(float *)&sample_buffer[x] = (float) (floor(f * fquantize_scale + 0.5) * fquantize_iscale);
                     ^
cli/wavpack.c:1154:19: style: Variable 'c' is reassigned a value before the old one has been used. [redundantAssignment]
        while ((c = *lp++) == '\n' || c == '\r');
                  ^
cli/wavpack.c:1148:11: note: c is assigned
        c = (int) fread (listbuff, 1, sizeof (listbuff) - 1, list);   // assign c only to suppress warning
          ^
cli/wavpack.c:1154:19: note: c is overwritten
        while ((c = *lp++) == '\n' || c == '\r');
                  ^
cli/wavpack.c:319:9: style: The scope of the variable 'result' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int result, i;
        ^
cli/wavpack.c:1657:15: style: The scope of the variable 'testfile' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        FILE *testfile;
              ^
cli/wavpack.c:1824:59: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int layout = WavpackGetChannelLayout (wpc, NULL), i;
                                                          ^
cli/wavpack.c:1839:13: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i, j;
            ^
cli/wavpack.c:1839:16: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i, j;
               ^
cli/wavpack.c:2684:15: style: The scope of the variable 'testfile' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        FILE *testfile;
              ^
cli/wavpack.c:2813:23: style: The scope of the variable 'order' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        unsigned char order [256];
                      ^
cli/wavpack.c:3227:66: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int layout = WavpackGetChannelLayout (infile, NULL), i;
                                                                 ^
cli/wavpack.c:3432:19: style: The scope of the variable 'md5_digest_result' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char md5_digest_result [16];
                  ^
cli/wavpack.c:3461:59: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int layout = WavpackGetChannelLayout (wpc, NULL), i;
                                                          ^
cli/wavpack.c:4186:10: style: The scope of the variable 'title' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char title [40];
         ^
cli/wavpack.c:763:21: style: Local variable 'i' shadows outer variable [shadowVariable]
                int i = num_tag_items;
                    ^
cli/wavpack.c:319:17: note: Shadowed declaration
    int result, i;
                ^
cli/wavpack.c:763:21: note: Shadow variable
                int i = num_tag_items;
                    ^
cli/wavpack.c:1800:14: style: Local variable 'dummy' shadows outer variable [shadowVariable]
        char dummy [256];
             ^
cli/wavpack.c:1505:63: note: Shadowed declaration
    char *outfilename_temp = NULL, *out2filename_temp = NULL, dummy;
                                                              ^
cli/wavpack.c:1800:14: note: Shadow variable
        char dummy [256];
             ^
cli/wavpack.c:2897:18: style: Local variable 'error' shadows outer variable [shadowVariable]
            char error [80];
                 ^
cli/wavpack.c:2582:10: note: Shadowed declaration
    char error [80];
         ^
cli/wavpack.c:2897:18: note: Shadow variable
            char error [80];
                 ^
cli/wavpack.c:3291:39: error: Uninitialized variable: format_buffer [uninitvar]
                unsigned char *dptr = format_buffer;
                                      ^
cli/wavpack.c:3319:32: error: Uninitialized variable: format_buffer [uninitvar]
                store_samples (format_buffer, sample_buffer, qmode, bps, sample_count * num_channels);
                               ^
cli/wavpack.c:3321:39: error: Uninitialized variable: format_buffer [uninitvar]
            MD5_Update (&md5_context, format_buffer, bps * sample_count * num_channels);
                                      ^
cli/wavpack.c:808:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            outfilename = malloc (strlen (*argv) + PATH_MAX);
^
cli/wavpack.c:911:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                char *temp = malloc (strlen (matches [0]) + PATH_MAX);
^
cli/wavpack.c:920:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                char *temp = malloc (strlen (outfilename) + PATH_MAX);
^
cli/wavpack.c:1067:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    char *fname = malloc (PATH_MAX);
^
cli/wavpack.c:1072:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    while ((c = *cp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
^
cli/wavpack.c:1137:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        char listbuff [PATH_MAX * 2], *lp = listbuff;
^
cli/wavpack.c:1161:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            while ((c = *lp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
^
cli/wavpack.c:1249:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    char *temp = malloc (strlen (outfilename) + PATH_MAX);
^
cli/wavpack.c:3058:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            char in2filename [PATH_MAX];
^
cli/wavpack.c:808:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            outfilename = malloc (strlen (*argv) + PATH_MAX);
^
cli/wavpack.c:911:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                char *temp = malloc (strlen (matches [0]) + PATH_MAX);
^
cli/wavpack.c:920:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                char *temp = malloc (strlen (outfilename) + PATH_MAX);
^
cli/wavpack.c:1067:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    char *fname = malloc (PATH_MAX);
^
cli/wavpack.c:1072:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    while ((c = *cp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
^
cli/wavpack.c:1137:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        char listbuff [PATH_MAX * 2], *lp = listbuff;
^
cli/wavpack.c:1161:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            while ((c = *lp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
^
cli/wavpack.c:1249:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    char *temp = malloc (strlen (outfilename) + PATH_MAX);
^
cli/wavpack.c:3058:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            char in2filename [PATH_MAX];
^
cli/wavpack.c:2125:19: style: Local variable 'temp' shadows outer variable [shadowVariable]
            FILE *temp;
                  ^
cli/wavpack.c:2109:15: note: Shadowed declaration
        FILE *temp;
              ^
cli/wavpack.c:2125:19: note: Shadow variable
            FILE *temp;
                  ^
cli/wavpack.c:3094:19: style: Local variable 'temp' shadows outer variable [shadowVariable]
            FILE *temp;
                  ^
cli/wavpack.c:3078:15: note: Shadowed declaration
        FILE *temp;
              ^
cli/wavpack.c:3094:19: note: Shadow variable
            FILE *temp;
                  ^
cli/win32_unicode_support.c:104:6: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 int i = 0;
     ^
cli/win32_unicode_support.c:104:8: style: Variable 'i' is assigned a value that is never used. [unreadVariable]
 int i = 0;
       ^
cli/wvgain.c:665:40: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
                        float_samples ((float *) temp_buffer, temp_buffer, samples_unpacked * num_channels, 1.0 / 128.0);
                                       ^
cli/wvgain.c:669:40: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
                        float_samples ((float *) temp_buffer, temp_buffer, samples_unpacked * num_channels, 1.0 / 32768.0);
                                       ^
cli/wvgain.c:673:40: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
                        float_samples ((float *) temp_buffer, temp_buffer, samples_unpacked * num_channels, 1.0 / 8388608.0);
                                       ^
cli/wvgain.c:677:40: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
                        float_samples ((float *) temp_buffer, temp_buffer, samples_unpacked * num_channels, 1.0 / 2147483648.0);
                                       ^
cli/wvgain.c:692:31: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
            calc_stereo_peak ((float *) temp_buffer, samples_unpacked, peak);
                              ^
cli/wvgain.c:693:36: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
            filter_stereo_samples ((float *) temp_buffer, samples_unpacked);
                                   ^
cli/wvgain.c:694:61: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
            level = (int32_t) floor (100 * calc_stereo_rms ((float *) temp_buffer, samples_unpacked));
                                                            ^
cli/wvgain.c:141:9: style: The scope of the variable 'result' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int result = WAVPACK_NO_ERROR;
        ^
cli/wvgain.c:647:17: style: The scope of the variable 'level' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int32_t level;
                ^
cli/wvgain.c:759:22: style: The scope of the variable 'value' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char error [80], value [20];
                     ^
cli/wvgain.c:1155:12: style: The scope of the variable 'left' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double left, right;
           ^
cli/wvgain.c:1155:18: style: The scope of the variable 'right' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double left, right;
                 ^
cli/wvgain.c:1197:12: style: The scope of the variable 'left' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double left, right;
           ^
cli/wvgain.c:1197:18: style: The scope of the variable 'right' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double left, right;
                 ^
cli/wvgain.c:1327:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
cli/wvgain.c:1466:10: style: The scope of the variable 'title' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char title [40];
         ^
cli/wvgain.c:1368:78: warning: Division by result of sizeof(). memmove() expects a size in bytes, did you intend to multiply instead? [sizeofDivisionMemfunc]
            memmove (sp->delay, sp->delay + ratio, sizeof (sp->delay [0]) * (NUM_TERMS - ratio));
                                                                             ^
cli/wvgain.c:322:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    char *fname = malloc (PATH_MAX);
^
cli/wvgain.c:327:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    while ((c = *cp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
^
cli/wvgain.c:322:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    char *fname = malloc (PATH_MAX);
^
cli/wvgain.c:327:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    while ((c = *cp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
^
cli/wvparser.c:139:14: style: The scope of the variable 'bcount' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t bcount, total_bytes, sample_rate, first_sample, last_sample = -1L;
             ^
cli/wvparser.c:344:43: style: The scope of the variable 'meta_bc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t checksum_passed = 0, bcount, meta_bc;
                                          ^
cli/wvparser.c:345:24: style: The scope of the variable 'meta_id' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *dp, meta_id, c1, c2;
                       ^
cli/wvparser.c:345:33: style: The scope of the variable 'c1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *dp, meta_id, c1, c2;
                                ^
cli/wvtag.c:335:17: error: Common realloc mistake: 'tag_items' nulled but not freed upon failure [memleakOnRealloc]
                tag_items = realloc (tag_items, ++num_tag_items * sizeof (*tag_items));
                ^
cli/wvtag.c:360:13: error: Common realloc mistake: 'tag_items' nulled but not freed upon failure [memleakOnRealloc]
            tag_items = realloc (tag_items, ++num_tag_items * sizeof (*tag_items));
            ^
cli/wvtag.c:910:5: error: Common realloc mistake: 'tag_extractions' nulled but not freed upon failure [memleakOnRealloc]
    tag_extractions = realloc (tag_extractions, (num_tag_extractions + 1) * sizeof (*tag_extractions));
    ^
cli/wvtag.c:191:9: style: The scope of the variable 'result' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int result, i;
        ^
cli/wvtag.c:811:18: style: The scope of the variable 'error' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            char error [80];
                 ^
cli/wvtag.c:1073:38: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int item_len, value_len, j;
                                     ^
cli/wvtag.c:333:21: style: Local variable 'i' shadows outer variable [shadowVariable]
                int i = num_tag_items;
                    ^
cli/wvtag.c:191:17: note: Shadowed declaration
    int result, i;
                ^
cli/wvtag.c:333:21: note: Shadow variable
                int i = num_tag_items;
                    ^
cli/wvtag.c:353:17: style: Local variable 'i' shadows outer variable [shadowVariable]
            int i = num_tag_items;
                ^
cli/wvtag.c:191:17: note: Shadowed declaration
    int result, i;
                ^
cli/wvtag.c:353:17: note: Shadow variable
            int i = num_tag_items;
                ^
cli/wvtag.c:811:18: style: Local variable 'error' shadows outer variable [shadowVariable]
            char error [80];
                 ^
cli/wvtag.c:739:10: note: Shadowed declaration
    char error [80];
         ^
cli/wvtag.c:811:18: note: Shadow variable
            char error [80];
                 ^
cli/wvtag.c:820:21: style: Local variable 'res' shadows outer variable [shadowVariable]
                int res = ImportID3v2 (NULL, WavpackGetWrapperData (wpc), WavpackGetWrapperBytes (wpc), error, NULL);
                    ^
cli/wvtag.c:772:16: note: Shadowed declaration
        int i, res = TRUE;
               ^
cli/wvtag.c:820:21: note: Shadow variable
                int res = ImportID3v2 (NULL, WavpackGetWrapperData (wpc), WavpackGetWrapperBytes (wpc), error, NULL);
                    ^
cli/wvtag.c:1330:16: error: Memory is allocated but not initialized: temp [uninitdata]
        fputs (temp, dst);
               ^
cli/wvtag.c:772:20: style: Variable 'res' is assigned a value that is never used. [unreadVariable]
        int i, res = TRUE;
                   ^
cli/wvtag.c:430:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                char *temp = malloc (strlen (matches [0]) + PATH_MAX);
^
cli/wvtag.c:574:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    char *fname = malloc (PATH_MAX);
^
cli/wvtag.c:579:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    while ((c = *cp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
^
cli/wvtag.c:430:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                char *temp = malloc (strlen (matches [0]) + PATH_MAX);
^
cli/wvtag.c:574:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    char *fname = malloc (PATH_MAX);
^
cli/wvtag.c:579:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    while ((c = *cp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
^
cli/wvtest.c:316:27: style: Redundant condition: If 'total_samples == -1', the comparison 'total_samples < 2' is always true. [redundantCondition]
    if (total_samples < 2 || total_samples == -1) {
                          ^
cli/wvtest.c:906:31: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
 WavpackPackSamples (out_wpc, (int32_t *) destin, ENCODE_SAMPLES);
                              ^
cli/wvtest.c:907:32: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
        store_samples (destin, (int32_t *) destin, 0, wpconfig.bytes_per_sample, ENCODE_SAMPLES * num_chans);
                               ^
cli/wvtest.c:1357:10: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
        *(int32_t *)samples = isample << ishift;
         ^
cli/wvtest.c:1390:10: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
        *(int32_t *)samples = isample;
         ^
cli/wvtest.c:295:50: style: The scope of the variable 'sample_count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int64_t min_chunk_size = 256, total_samples, sample_count = 0;
                                                 ^
cli/wvtest.c:298:14: style: The scope of the variable 'decoded_samples' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t *decoded_samples, num_chans, bps, test_index, qmode;
             ^
cli/wvtest.c:301:20: style: The scope of the variable 'chunked_md5' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *chunked_md5;
                   ^
cli/wvtest.c:674:10: style: The scope of the variable 'md5_string1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char md5_string1 [] = "????????????????????????????????";
         ^
cli/wvtest.c:689:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j, k;
        ^
cli/wvtest.c:766:13: style: Local variable 'i' shadows outer variable [shadowVariable]
        int i;
            ^
cli/wvtest.c:689:9: note: Shadowed declaration
    int i, j, k;
        ^
cli/wvtest.c:766:13: note: Shadow variable
        int i;
            ^
cli/wvtest.c:295:63: style: Variable 'sample_count' is assigned a value that is never used. [unreadVariable]
    int64_t min_chunk_size = 256, total_samples, sample_count = 0;
                                                              ^
cli/wvunpack.c:1800:5: error: Common realloc mistake: 'tag_extractions' nulled but not freed upon failure [memleakOnRealloc]
    tag_extractions = realloc (tag_extractions, (num_tag_extractions + 1) * sizeof (*tag_extractions));
    ^
cli/wvunpack.c:700:19: style: Variable 'c' is reassigned a value before the old one has been used. [redundantAssignment]
        while ((c = *lp++) == '\n' || c == '\r');
                  ^
cli/wvunpack.c:694:11: note: c is assigned
        c = (int) fread (listbuff, 1, sizeof (listbuff) - 1, list);   // assign c only to suppress warning
          ^
cli/wvunpack.c:700:19: note: c is overwritten
        while ((c = *lp++) == '\n' || c == '\r');
                  ^
cli/wvunpack.c:1288:16: style: Variable 'result' is reassigned a value before the old one has been used. [redundantAssignment]
        result = unpack_dsd_audio (wpc, outfile, output_qmode, calc_md5 ? md5_unpacked : NULL, &total_unpacked_samples);
               ^
cli/wvunpack.c:1262:24: note: result is assigned
                result = WAVPACK_HARD_ERROR;
                       ^
cli/wvunpack.c:1288:16: note: result is overwritten
        result = unpack_dsd_audio (wpc, outfile, output_qmode, calc_md5 ? md5_unpacked : NULL, &total_unpacked_samples);
               ^
cli/wvunpack.c:1288:16: style: Variable 'result' is reassigned a value before the old one has been used. [redundantAssignment]
        result = unpack_dsd_audio (wpc, outfile, output_qmode, calc_md5 ? md5_unpacked : NULL, &total_unpacked_samples);
               ^
cli/wvunpack.c:1272:28: note: result is assigned
                    result = WAVPACK_HARD_ERROR;
                           ^
cli/wvunpack.c:1288:16: note: result is overwritten
        result = unpack_dsd_audio (wpc, outfile, output_qmode, calc_md5 ? md5_unpacked : NULL, &total_unpacked_samples);
               ^
cli/wvunpack.c:1288:16: style: Variable 'result' is reassigned a value before the old one has been used. [redundantAssignment]
        result = unpack_dsd_audio (wpc, outfile, output_qmode, calc_md5 ? md5_unpacked : NULL, &total_unpacked_samples);
               ^
cli/wvunpack.c:1279:20: note: result is assigned
            result = WAVPACK_HARD_ERROR;
                   ^
cli/wvunpack.c:1288:16: note: result is overwritten
        result = unpack_dsd_audio (wpc, outfile, output_qmode, calc_md5 ? md5_unpacked : NULL, &total_unpacked_samples);
               ^
cli/wvunpack.c:219:43: style: The scope of the variable 'add_extension' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int verify_only = 0, error_count = 0, add_extension = 0, output_spec = 0, c_count = 0, x_count = 0;
                                          ^
cli/wvunpack.c:220:10: style: The scope of the variable 'outpath' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char outpath, **matches = NULL, *outfilename = NULL;
         ^
cli/wvunpack.c:221:9: style: The scope of the variable 'result' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int result;
        ^
cli/wvunpack.c:1311:14: style: The scope of the variable 'md5_string1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        char md5_string1 [] = "00000000000000000000000000000000";
             ^
cli/wvunpack.c:1540:59: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int layout = WavpackGetChannelLayout (wpc, NULL), i;
                                                          ^
cli/wvunpack.c:1687:59: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int layout = WavpackGetChannelLayout (wpc, NULL), i;
                                                          ^
cli/wvunpack.c:2328:38: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int item_len, value_len, j;
                                     ^
cli/wvunpack.c:2432:9: style: The scope of the variable 'item_id' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int item_id;
        ^
cli/wvunpack.c:2828:10: style: The scope of the variable 'title' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char title [40];
         ^
cli/wvunpack.c:2485:115: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                    (long long int) WavpackGetNumSamples64 (wpc) * (WavpackGetQualifyMode (wpc) & QMODE_DSD_AUDIO ? 8 : 1));
                                                                                                                  ^
cli/wvunpack.c:2644:16: error: Memory is allocated but not initialized: temp [uninitdata]
        fputs (temp, dst);
               ^
cli/wvunpack.c:484:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                outfilename = malloc (strlen (*argv) + PATH_MAX);
^
cli/wvunpack.c:613:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    char *fname = malloc (PATH_MAX);
^
cli/wvunpack.c:618:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    while ((c = *cp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
^
cli/wvunpack.c:683:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        char listbuff [PATH_MAX * 2], *lp = listbuff;
^
cli/wvunpack.c:707:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            while ((c = *lp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
^
cli/wvunpack.c:1493:0: information: Skipping configuration 'MAXPATHLEN' since the value of 'MAXPATHLEN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            char in2filename [PATH_MAX];
^
cli/wvunpack.c:484:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                outfilename = malloc (strlen (*argv) + PATH_MAX);
^
cli/wvunpack.c:613:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    char *fname = malloc (PATH_MAX);
^
cli/wvunpack.c:618:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    while ((c = *cp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
^
cli/wvunpack.c:683:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        char listbuff [PATH_MAX * 2], *lp = listbuff;
^
cli/wvunpack.c:707:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            while ((c = *lp++) != '\n' && c != '\r' && c && ci < PATH_MAX);
^
cli/wvunpack.c:1493:0: information: Skipping configuration 'MAX_PATH' since the value of 'MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            char in2filename [PATH_MAX];
^
src/common_utils.c:592:9: style: The scope of the variable 'exp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int exp;
        ^
src/decorr_utils.c:107:53: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        if (byteptr + (wps->wphdr.flags & MONO_DATA ? 2 : 4) > endptr)
                                                    ^
src/decorr_utils.c:121:57: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
            if (byteptr + (wps->wphdr.flags & MONO_DATA ? 4 : 8) > endptr)
                                                        ^
src/decorr_utils.c:146:61: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                if (byteptr + (wps->wphdr.flags & MONO_DATA ? 2 : 4) > endptr)
                                                            ^
src/decorr_utils.c:180:65: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    else if (wpmd->byte_length >= (wps->wphdr.flags & MONO_DATA ? 4 : 8)) {
                                                                ^
src/decorr_utils.c:193:64: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        if (wpmd->byte_length == (wps->wphdr.flags & MONO_DATA ? 6 : 12)) {
                                                               ^
src/entropy_utils.c:294:26: style: The scope of the variable 'avalue' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t result = 0, avalue;
                         ^
src/entropy_utils.c:367:25: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
    return (weight + 4) >> 3;
                        ^
src/entropy_utils.c:142:53: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        if (byteptr + (wps->wphdr.flags & MONO_DATA ? 2 : 4) > endptr)
                                                    ^
src/entropy_utils.c:154:49: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    if (byteptr + (wps->wphdr.flags & MONO_DATA ? 2 : 4) > endptr)
                                                ^
src/entropy_utils.c:166:53: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        if (byteptr + (wps->wphdr.flags & MONO_DATA ? 2 : 4) > endptr)
                                                    ^
src/extra1.c:58:13: style: The scope of the variable 'cont_samples' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t cont_samples = 0;
            ^
src/extra1.c:480:9: style: The scope of the variable 'shaping_weight' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int shaping_weight, new = wps->wphdr.flags & NEW_SHAPING;
        ^
src/extra1.c:482:24: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t error = 0, temp, cnt;
                       ^
src/extra1.c:97:13: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
            update_weight (dpp->weight_A, dpp->delta, sam_A, left);
            ^
src/extra1.c:114:13: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
            update_weight (dpp->weight_A, dpp->delta, sam_A, left);
            ^
src/extra1.c:682:13: style: Local variable 'i' shadows outer variable [shadowVariable]
        int i;
            ^
src/extra1.c:528:24: note: Shadowed declaration
    int log_limit, pi, i;
                       ^
src/extra1.c:682:13: note: Shadow variable
        int i;
            ^
src/extra1.c:526:22: style: Variable 'buf_size' is assigned a value that is never used. [unreadVariable]
    int32_t buf_size = sizeof (int32_t) * num_samples;
                     ^
src/extra1.c:527:24: style: Variable 'best_size' is assigned a value that is never used. [unreadVariable]
    uint32_t best_size = (uint32_t) -1, size;
                       ^
src/extra2.c:66:13: style: The scope of the variable 'cont_samples' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t cont_samples = 0;
            ^
src/extra2.c:67:9: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int m = 0, i;
        ^
src/extra2.c:644:9: style: The scope of the variable 'shaping_weight' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int shaping_weight, new = wps->wphdr.flags & NEW_SHAPING;
        ^
src/extra2.c:646:24: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t error [2], temp, cnt;
                       ^
src/extra2.c:187:21: style: Local variable 'k' shadows outer variable [shadowVariable]
                int k;
                    ^
src/extra2.c:164:17: note: Shadowed declaration
            int k = dpp->term & (MAX_TERM - 1);
                ^
src/extra2.c:187:21: note: Shadow variable
                int k;
                    ^
src/extra2.c:104:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_A, dpp->delta, sam, tmp);
                ^
src/extra2.c:110:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_B, dpp->delta, sam, tmp);
                ^
src/extra2.c:126:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_A, dpp->delta, sam, tmp);
                ^
src/extra2.c:132:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_B, dpp->delta, sam, tmp);
                ^
src/extra2.c:148:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_A, dpp->delta, sam, tmp);
                ^
src/extra2.c:154:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_B, dpp->delta, sam, tmp);
                ^
src/extra2.c:171:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_A, dpp->delta, sam, tmp);
                ^
src/extra2.c:176:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_B, dpp->delta, sam, tmp);
                ^
src/extra2.c:208:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_A, dpp->delta, sam_A, tmp);
                ^
src/extra2.c:212:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_B, dpp->delta, sam_B, tmp);
                ^
src/extra2.c:227:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_B, dpp->delta, sam_B, tmp);
                ^
src/extra2.c:231:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_A, dpp->delta, sam_A, tmp);
                ^
src/extra2.c:249:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_B, dpp->delta, sam_B, tmp);
                ^
src/extra2.c:254:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_A, dpp->delta, sam_A, tmp);
                ^
src/extra2.c:906:13: style: Local variable 'i' shadows outer variable [shadowVariable]
        int i;
            ^
src/extra2.c:710:52: note: Shadowed declaration
    int log_limit, force_js = 0, force_ts = 0, pi, i;
                                                   ^
src/extra2.c:906:13: note: Shadow variable
        int i;
            ^
src/extra2.c:708:22: style: Variable 'buf_size' is assigned a value that is never used. [unreadVariable]
    int32_t buf_size = sizeof (int32_t) * num_samples * 2;
                     ^
src/extra2.c:709:24: style: Variable 'best_size' is assigned a value that is never used. [unreadVariable]
    uint32_t best_size = (uint32_t) -1, size;
                       ^
src/extra2.c:710:29: style: Variable 'force_js' is assigned a value that is never used. [unreadVariable]
    int log_limit, force_js = 0, force_ts = 0, pi, i;
                            ^
src/extra2.c:710:43: style: Variable 'force_ts' is assigned a value that is never used. [unreadVariable]
    int log_limit, force_js = 0, force_ts = 0, pi, i;
                                          ^
src/open_filename.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/open_filename.c:144:0: information: Skipping configuration 'S_IFMT;S_IFREG;S_ISREG;_WIN32' since the value of 'S_ISREG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    return file && !fstat (fileno (file), &statbuf) && S_ISREG(statbuf.st_mode);
^
src/open_raw.c:105:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
src/open_raw.c:144:70: style: The scope of the variable 'wphdr_flags' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        uint32_t multiple_blocks = 0, block_size, block_samples = 0, wphdr_flags, crc;
                                                                     ^
src/open_raw.c:144:83: style: The scope of the variable 'crc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        uint32_t multiple_blocks = 0, block_size, block_samples = 0, wphdr_flags, crc;
                                                                                  ^
src/open_utils.c:40:14: style: The scope of the variable 'bcount' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t bcount;
             ^
src/open_utils.c:449:38: style: The scope of the variable 'shift' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int bytecnt = wpmd->byte_length, shift = 0, mask_bits;
                                     ^
src/open_utils.c:449:49: style: The scope of the variable 'mask_bits' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int bytecnt = wpmd->byte_length, shift = 0, mask_bits;
                                                ^
src/open_utils.c:451:14: style: The scope of the variable 'mask' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t mask = 0;
             ^
src/open_utils.c:571:17: style: The scope of the variable 'nchans' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int nchans, i;
                ^
src/open_utils.c:571:25: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int nchans, i;
                        ^
src/open_utils.c:969:13: style: The scope of the variable 'bcount' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int64_t bcount, file2pos;
            ^
src/open_utils.c:969:21: style: The scope of the variable 'file2pos' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int64_t bcount, file2pos;
                    ^
src/open_utils.c:972:9: style: The scope of the variable 'compare_result' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int compare_result;
        ^
src/open_utils.c:1205:43: style: The scope of the variable 'meta_bc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t checksum_passed = 0, bcount, meta_bc;
                                          ^
src/open_utils.c:1206:24: style: The scope of the variable 'meta_id' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *dp, meta_id, c1, c2;
                       ^
src/open_utils.c:1206:33: style: The scope of the variable 'c1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *dp, meta_id, c1, c2;
                                ^
src/open_utils.c:47:5: style: Redundant pointer operation on 'wpc' - it's already a pointer. [redundantPointerOp]
    CLEAR (*wpc);
    ^
src/open_utils.c:97:5: style: Redundant pointer operation on 'wps' - it's already a pointer. [redundantPointerOp]
    CLEAR (*wps);
    ^
src/open_utils.c:842:5: style: Redundant pointer operation on 'bs' - it's already a pointer. [redundantPointerOp]
    CLEAR (*bs);
    ^
src/pack.c:466:14: style: Finding variables 'flags' and 'sflags' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
    uint32_t flags = wps->wphdr.flags, sflags = wps->wphdr.flags;
             ^
src/pack.c:466:40: note: Same expression used in consecutive assignments of 'flags' and 'sflags'.
    uint32_t flags = wps->wphdr.flags, sflags = wps->wphdr.flags;
                                       ^
src/pack.c:466:14: note: Same expression used in consecutive assignments of 'flags' and 'sflags'.
    uint32_t flags = wps->wphdr.flags, sflags = wps->wphdr.flags;
             ^
src/pack.c:501:25: style: The scope of the variable 'dptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int32_t *sptr, *dptr, i;
                        ^
src/pack.c:891:13: style: The scope of the variable 'count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t count, value, *dp;
            ^
src/pack.c:891:20: style: The scope of the variable 'value' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t count, value, *dp;
                   ^
src/pack.c:891:28: style: The scope of the variable 'dp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t count, value, *dp;
                           ^
src/pack.c:996:57: style: The scope of the variable 'data_count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t flags = wps->wphdr.flags, repack_possible, data_count, crc, crc2, i;
                                                        ^
src/pack.c:1166:31: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int32_t code, temp;
                              ^
src/pack.c:1167:21: style: The scope of the variable 'shaping_weight' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int shaping_weight;
                    ^
src/pack.c:1240:38: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int32_t left, right, temp;
                                     ^
src/pack.c:1241:21: style: The scope of the variable 'shaping_weight' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int shaping_weight;
                    ^
src/pack.c:1724:5: style: Redundant pointer operation on 'bs' - it's already a pointer. [redundantPointerOp]
    CLEAR (*bs);
    ^
src/pack.c:64:68: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
        wps->dc.shaping_acc [0] = wps->dc.shaping_acc [1] = weight << 16;
                                                                   ^
src/pack.c:1061:85: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        saved_buffer = malloc (sample_count * sizeof (int32_t) * (flags & MONO_DATA ? 1 : 2));
                                                                                    ^
src/pack.c:1062:92: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        memcpy (saved_buffer, buffer, sample_count * sizeof (int32_t) * (flags & MONO_DATA ? 1 : 2));
                                                                                           ^
src/pack.c:1441:100: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                memcpy (buffer, saved_buffer, sample_count * sizeof (int32_t) * (flags & MONO_DATA ? 1 : 2));
                                                                                                   ^
src/pack.c:1207:25: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                        update_weight (dpp->weight_A, dpp->delta, dpp->samples_A [2], code);
                        ^
src/pack.c:1214:25: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                        update_weight (dpp->weight_A, dpp->delta, sam, code);
                        ^
src/pack.c:1317:25: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                        update_weight (dpp->weight_A, dpp->delta, dpp->samples_A [2], left);
                        ^
src/pack.c:1318:25: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                        update_weight (dpp->weight_B, dpp->delta, dpp->samples_B [2], right);
                        ^
src/pack.c:1329:25: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                        update_weight (dpp->weight_A, dpp->delta, dpp->samples_A [m], left);
                        ^
src/pack.c:1332:25: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                        update_weight (dpp->weight_B, dpp->delta, dpp->samples_B [m], right);
                        ^
src/pack.c:1345:25: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                        update_weight_clip (dpp->weight_A, dpp->delta, dpp->samples_A [0], left);
                        ^
src/pack.c:1346:25: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                        update_weight_clip (dpp->weight_B, dpp->delta, dpp->samples_B [0], right);
                        ^
src/pack.c:1497:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_A, dpp->delta, sam, tmp);
                ^
src/pack.c:1502:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_B, dpp->delta, sam, tmp);
                ^
src/pack.c:1514:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_A, dpp->delta, sam, tmp);
                ^
src/pack.c:1519:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_B, dpp->delta, sam, tmp);
                ^
src/pack.c:1530:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_A, dpp->delta, sam, tmp);
                ^
src/pack.c:1534:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_B, dpp->delta, sam, tmp);
                ^
src/pack.c:1548:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_A, dpp->delta, sam_A, tmp);
                ^
src/pack.c:1551:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_B, dpp->delta, sam_B, tmp);
                ^
src/pack.c:1562:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_B, dpp->delta, sam_B, tmp);
                ^
src/pack.c:1565:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_A, dpp->delta, sam_A, tmp);
                ^
src/pack.c:1579:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_B, dpp->delta, sam_B, tmp);
                ^
src/pack.c:1583:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_A, dpp->delta, sam_A, tmp);
                ^
src/pack.c:1649:13: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
            update_weight (dpp->weight_A, dpp->delta, sam, code);
            ^
src/pack.c:551:18: style: Variable 'mag' is assigned a value that is never used. [unreadVariable]
        if ((mag -= shift) < 0)
                 ^
src/pack_dns.c:31:12: style: The scope of the variable 'swptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    short *swptr;
           ^
src/pack_dns.c:97:62: style: The scope of the variable 'trial_count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int min_samples = 0, max_samples = sample_count, trial_count;
                                                             ^
src/pack_dns.c:39:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (ap->weight_A, 2, sam, temp);
                ^
src/pack_dns.c:45:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (ap->weight_B, 2, sam, temp);
                ^
src/pack_dns.c:48:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (ap->weight_A, 2, sam, temp);
                ^
src/pack_dns.c:61:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (ap->weight_A, 2, sam, temp);
                ^
src/pack_dns.c:70:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (ap->weight_A, 2, sam, temp);
                ^
src/pack_dns.c:76:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (ap->weight_B, 2, sam, temp);
                ^
src/pack_dsd.c:68:25: style: The scope of the variable 'dptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int32_t *sptr, *dptr, i;
                        ^
src/pack_dsd.c:210:18: style: The scope of the variable 'min_value' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int divisor, min_value, max_value, sum_values;
                 ^
src/pack_dsd.c:210:29: style: The scope of the variable 'max_value' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int divisor, min_value, max_value, sum_values;
                            ^
src/pack_dsd.c:210:40: style: The scope of the variable 'sum_values' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int divisor, min_value, max_value, sum_values;
                                       ^
src/pack_dsd.c:286:46: style: The scope of the variable 'mult' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned int low = 0, high = 0xffffffff, mult;
                                             ^
src/pack_dsd.c:602:64: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
            sp [0].factor += (((sp [0].value ^ sp [0].filter0) >> 31) | 1) & ((sp [0].value ^ (sp [0].value - (sp [0].filter6 << 4))) >> 31);
                                                               ^
src/pack_dsd.c:636:64: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
            sp [1].factor += (((sp [1].value ^ sp [1].filter0) >> 31) | 1) & ((sp [1].value ^ (sp [1].value - (sp [1].filter6 << 4))) >> 31);
                                                               ^
src/pack_floats.c:48:76: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
        crc = crc * 27 + get_mantissa (*dp) * 9 + get_exponent (*dp) * 3 + get_sign (*dp);
                                                                           ^
src/pack_floats.c:105:22: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
            else if (get_sign (*dp))
                     ^
src/pack_floats.c:130:29: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
        * (int32_t *) dp = (get_sign (*dp)) ? -value : value;
                            ^
src/pack_floats.c:250:21: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                    putbit (get_sign (*dp), &wps->wvxbits);
                    ^
src/pack_floats.c:256:25: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                        putbit (get_sign (*dp), &wps->wvxbits);
                        ^
src/pack_utils.c:339:13: style: The scope of the variable 'pos' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int pos, chans = 1;
            ^
src/pack_utils.c:906:44: style: The scope of the variable 'bcount' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t max_blocksize, max_chans = 1, bcount;
                                           ^
src/pack_utils.c:1079:24: style: The scope of the variable 'meta_id' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *dp, meta_id, c1, c2;
                       ^
src/pack_utils.c:1079:33: style: The scope of the variable 'c1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *dp, meta_id, c1, c2;
                                ^
src/pack_utils.c:1080:21: style: The scope of the variable 'meta_bc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t bcount, meta_bc;
                    ^
src/pack_utils.c:1228:11: style: The scope of the variable 'block_buff' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *block_buff, *block_ptr;
          ^
src/pack_utils.c:1228:24: style: The scope of the variable 'block_ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *block_buff, *block_ptr;
                       ^
src/pack_utils.c:1229:20: style: The scope of the variable 'wphdr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    WavpackHeader *wphdr;
                   ^
src/pack_utils.c:1350:24: style: The scope of the variable 'meta_id' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *dp, meta_id, c1, c2;
                       ^
src/pack_utils.c:1350:33: style: The scope of the variable 'c1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *dp, meta_id, c1, c2;
                                ^
src/pack_utils.c:1351:22: style: The scope of the variable 'meta_bc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t bcount, meta_bc;
                     ^
src/pack_utils.c:40:5: style: Redundant pointer operation on 'wpc' - it's already a pointer. [redundantPointerOp]
    CLEAR (*wpc);
    ^
src/pack_utils.c:344:9: style: Redundant pointer operation on 'wps' - it's already a pointer. [redundantPointerOp]
        CLEAR (*wps);
        ^
src/pack_utils.c:1244:9: style: Redundant pointer operation on 'wphdr' - it's already a pointer. [redundantPointerOp]
        CLEAR (*wphdr);
        ^
src/pack_utils.c:540:87: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        wps->sample_buffer = malloc (wpc->max_samples * (wps->wphdr.flags & MONO_FLAG ? 4 : 8));
                                                                                      ^
src/pack_utils.c:591:90: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
            dptr = wps->sample_buffer + wpc->acc_samples * (wps->wphdr.flags & MONO_FLAG ? 1 : 2);
                                                                                         ^
src/pack_utils.c:1000:98: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
            memmove (wps->sample_buffer, wps->sample_buffer + block_samples * (flags & MONO_FLAG ? 1 : 2),
                                                                                                 ^
src/pack_utils.c:1001:92: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                (wpc->acc_samples - block_samples) * sizeof (int32_t) * (flags & MONO_FLAG ? 1 : 2));
                                                                                           ^
src/pack_utils.c:1134:58: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    buffer_start [0] = wpmd->id | (wpmd->byte_length & 1 ? ID_ODD_SIZE : 0);
                                                         ^
src/pack_utils.c:316:76: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour. See condition at line 316. [shiftTooManyBitsSigned]
            if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {
                                                                           ^
src/pack_utils.c:316:27: note: Assuming that condition '*chan_ids<=32' is not redundant
            if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {
                          ^
src/pack_utils.c:316:76: note: Shift
            if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {
                                                                           ^
src/pack_utils.c:317:34: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour. See condition at line 316. [shiftTooManyBitsSigned]
                mask_copy &= ~(1 << (*chan_ids-1));
                                 ^
src/pack_utils.c:316:27: note: Assuming that condition '*chan_ids<=32' is not redundant
            if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {
                          ^
src/pack_utils.c:317:34: note: Shift
                mask_copy &= ~(1 << (*chan_ids-1));
                                 ^
src/pack_utils.c:349:36: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                if (chan_mask & (1 << pos)) {
                                   ^
src/pack_utils.c:383:72: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour. See condition at line 383. [shiftTooManyBitsSigned]
                            if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))
                                                                       ^
src/pack_utils.c:383:47: note: Assuming that condition 'right_chan_id<=32' is not redundant
                            if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))
                                              ^
src/pack_utils.c:383:72: note: Shift
                            if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))
                                                                       ^
src/pack_utils.c:384:50: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour. See condition at line 383. [shiftTooManyBitsSigned]
                                chan_mask &= ~(1 << (right_chan_id-1));
                                                 ^
src/pack_utils.c:383:47: note: Assuming that condition 'right_chan_id<=32' is not redundant
                            if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))
                                              ^
src/pack_utils.c:384:50: note: Shift
                                chan_mask &= ~(1 << (right_chan_id-1));
                                                 ^
src/pack_utils.c:766:14: style: struct member 'CS64Chunk::chunkSize64' is never used. [unusedStructMember]
    uint64_t chunkSize64;
             ^
src/pack_utils.c:771:14: style: struct member 'DS64Chunk::tableLength' is never used. [unusedStructMember]
    uint32_t tableLength;
             ^
src/pack_utils.c:777:10: style: struct member 'JunkChunk::junk' is never used. [unusedStructMember]
    char junk [28];
         ^
src/read_words.c:71:13: style: The scope of the variable 'value' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t value;
            ^
src/read_words.c:81:18: style: The scope of the variable 'mask' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        uint32_t mask;
                 ^
src/read_words.c:82:13: style: The scope of the variable 'cbits' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int cbits;
            ^
src/read_words.c:191:26: style: The scope of the variable 'mask' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                uint32_t mask;
                         ^
src/read_words.c:363:22: style: The scope of the variable 'mask' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            uint32_t mask;
                     ^
src/read_words.c:364:17: style: The scope of the variable 'cbits' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int cbits;
                ^
src/read_words.c:468:26: style: The scope of the variable 'mask' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                uint32_t mask;
                         ^
src/read_words.c:596:36: error: Array 'bitmask[32]' accessed at index -1, which is out of bounds. [negativeIndex]
    if ((code = local_sr & bitmask [bitcount - 1]) >= extras)
                                   ^
src/read_words.c:578:16: note: Assignment 'bitcount=(maxcode)?32-__builtin_clz(maxcode):0', assigned value is 0
    bitcount = count_bits (maxcode);
               ^
src/read_words.c:596:36: note: Negative array index
    if ((code = local_sr & bitmask [bitcount - 1]) >= extras)
                                   ^
src/read_words.c:143:26: style: The scope of the variable 'mask' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                uint32_t mask;
                         ^
src/read_words.c:422:26: style: The scope of the variable 'mask' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                uint32_t mask;
                         ^
src/tag_utils.c:478:16: style: Variable 'result' is reassigned a value before the old one has been used. [redundantAssignment]
        result = wpc->blockout (wpc->wv_out, &m_tag->ape_tag_hdr, sizeof (m_tag->ape_tag_hdr));
               ^
src/tag_utils.c:469:20: note: result is assigned
            result = wpc->blockout (wpc->wv_out, &m_tag->ape_tag_hdr, sizeof (m_tag->ape_tag_hdr));
                   ^
src/tag_utils.c:478:16: note: result is overwritten
        result = wpc->blockout (wpc->wv_out, &m_tag->ape_tag_hdr, sizeof (m_tag->ape_tag_hdr));
               ^
src/tag_utils.c:478:16: style: Variable 'result' is reassigned a value before the old one has been used. [redundantAssignment]
        result = wpc->blockout (wpc->wv_out, &m_tag->ape_tag_hdr, sizeof (m_tag->ape_tag_hdr));
               ^
src/tag_utils.c:474:20: note: result is assigned
            result = wpc->blockout (wpc->wv_out, m_tag->ape_tag_data, m_tag->ape_tag_hdr.length - sizeof (m_tag->ape_tag_hdr));
                   ^
src/tag_utils.c:478:16: note: result is overwritten
        result = wpc->blockout (wpc->wv_out, &m_tag->ape_tag_hdr, sizeof (m_tag->ape_tag_hdr));
               ^
src/tag_utils.c:540:16: style: Variable 'result' is reassigned a value before the old one has been used. [redundantAssignment]
        result = (wpc->reader->write_bytes (wpc->wv_in, m_tag->ape_tag_data, m_tag->ape_tag_hdr.length - sizeof (m_tag->ape_tag_hdr)) == sizeof (m_tag->ape_tag_hdr));
               ^
src/tag_utils.c:536:20: note: result is assigned
            result = (wpc->reader->write_bytes (wpc->wv_in, &m_tag->ape_tag_hdr, sizeof (m_tag->ape_tag_hdr)) == sizeof (m_tag->ape_tag_hdr));
                   ^
src/tag_utils.c:540:16: note: result is overwritten
        result = (wpc->reader->write_bytes (wpc->wv_in, m_tag->ape_tag_data, m_tag->ape_tag_hdr.length - sizeof (m_tag->ape_tag_hdr)) == sizeof (m_tag->ape_tag_hdr));
               ^
src/tag_utils.c:543:16: style: Variable 'result' is reassigned a value before the old one has been used. [redundantAssignment]
        result = (wpc->reader->write_bytes (wpc->wv_in, &m_tag->ape_tag_hdr, sizeof (m_tag->ape_tag_hdr)) == sizeof (m_tag->ape_tag_hdr));
               ^
src/tag_utils.c:540:16: note: result is assigned
        result = (wpc->reader->write_bytes (wpc->wv_in, m_tag->ape_tag_data, m_tag->ape_tag_hdr.length - sizeof (m_tag->ape_tag_hdr)) == sizeof (m_tag->ape_tag_hdr));
               ^
src/tag_utils.c:543:16: note: result is overwritten
        result = (wpc->reader->write_bytes (wpc->wv_in, &m_tag->ape_tag_hdr, sizeof (m_tag->ape_tag_hdr)) == sizeof (m_tag->ape_tag_hdr));
               ^
src/tag_utils.c:384:83: style: Variable 'index' is assigned a value that is never used. [unreadVariable]
    else if (m_tag->id3_tag.comment [29] && !m_tag->id3_tag.comment [28] && !index--)
                                                                                  ^
src/tags.c:33:5: style: Redundant pointer operation on 'm_tag' - it's already a pointer. [redundantPointerOp]
    CLEAR (*m_tag);
    ^
src/tags.c:90:41: style: Redundant pointer operation on 'm_tag' - it's already a pointer. [redundantPointerOp]
                                        CLEAR (*m_tag);
                                        ^
src/tags.c:99:41: style: Redundant pointer operation on 'm_tag' - it's already a pointer. [redundantPointerOp]
                                        CLEAR (*m_tag);
                                        ^
src/tags.c:108:33: style: Redundant pointer operation on 'm_tag' - it's already a pointer. [redundantPointerOp]
                                CLEAR (*m_tag);
                                ^
src/tags.c:129:13: style: Redundant pointer operation on 'm_tag' - it's already a pointer. [redundantPointerOp]
            CLEAR (*m_tag);
            ^
src/unpack.c:293:29: style: The scope of the variable 'sam_A' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                    int32_t sam_A, sam_B;
                            ^
src/unpack.c:293:36: style: The scope of the variable 'sam_B' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                    int32_t sam_A, sam_B;
                                   ^
src/unpack.c:333:25: style: The scope of the variable 'sam_A' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int32_t sam_A, sam_B;
                        ^
src/unpack.c:333:32: style: The scope of the variable 'sam_B' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int32_t sam_A, sam_B;
                               ^
src/unpack.c:696:18: style: The scope of the variable 'data' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        uint32_t data, mask = (1 << sent_bits) - 1;
                 ^
src/unpack.c:755:49: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
                min_shifted = (min_value = -128 >> shift) << shift;
                                                ^
src/unpack.c:760:51: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
                min_shifted = (min_value = -32768 >> shift) << shift;
                                                  ^
src/unpack.c:765:53: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
                min_shifted = (min_value = -8388608 >> shift) << shift;
                                                    ^
src/unpack.c:770:65: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
                min_shifted = (min_value = (int32_t) 0x80000000 >> shift) << shift;
                                                                ^
src/unpack.c:453:62: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        memset (buffer, 0, sample_count * (flags & MONO_FLAG ? 4 : 8));
                                                             ^
src/unpack.c:245:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_A, dpp->delta, sam, read_word);
                ^
src/unpack.c:361:21: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                    update_weight (dpp->weight_A, dpp->delta, sam_A, left);
                    ^
src/unpack.c:362:21: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                    update_weight (dpp->weight_B, dpp->delta, sam_B, right);
                    ^
src/unpack.c:369:21: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                    update_weight_clip (dpp->weight_A, dpp->delta, dpp->samples_A [0], left);
                    ^
src/unpack.c:372:21: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                    update_weight_clip (dpp->weight_B, dpp->delta, left2, right);
                    ^
src/unpack.c:377:21: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                    update_weight_clip (dpp->weight_B, dpp->delta, dpp->samples_B [0], right);
                    ^
src/unpack.c:386:21: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                    update_weight_clip (dpp->weight_A, dpp->delta, right2, left);
                    ^
src/unpack.c:519:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (weight_A, delta, sam_A, bptr [0]);
                ^
src/unpack.c:530:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (weight_A, delta, sam_A, bptr [0]);
                ^
src/unpack.c:540:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (weight_A, delta, sam_A, bptr [0]);
                ^
src/unpack.c:581:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_A, dpp->delta, sam, tmp);
                ^
src/unpack.c:586:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_B, dpp->delta, sam, tmp);
                ^
src/unpack.c:598:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_A, dpp->delta, sam, tmp);
                ^
src/unpack.c:603:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_B, dpp->delta, sam, tmp);
                ^
src/unpack.c:614:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_A, dpp->delta, sam, bptr [0]);
                ^
src/unpack.c:619:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight (dpp->weight_B, dpp->delta, sam, bptr [1]);
                ^
src/unpack.c:633:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_A, dpp->delta, dpp->samples_A [0], bptr [0]);
                ^
src/unpack.c:636:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_B, dpp->delta, sam, bptr [1]);
                ^
src/unpack.c:647:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_B, dpp->delta, dpp->samples_B [0], bptr [1]);
                ^
src/unpack.c:650:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_A, dpp->delta, sam, bptr [0]);
                ^
src/unpack.c:661:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_A, dpp->delta, dpp->samples_A [0], bptr [0]);
                ^
src/unpack.c:663:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                update_weight_clip (dpp->weight_B, dpp->delta, dpp->samples_B [0], bptr [1]);
                ^
src/unpack3.c:107:49: style: The scope of the variable 'tcount' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int flags = wps->wphdr.flags, byte_sum = 0, tcount;
                                                ^
src/unpack3.c:108:25: style: The scope of the variable 'dpp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct decorr_pass *dpp;
                        ^
src/unpack3.c:167:35: style: The scope of the variable 'tcount' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int flags = wps->wphdr.flags, tcount;
                                  ^
src/unpack3.c:498:64: style: The scope of the variable 'extra_bits' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int32_t sum, left, right, diff, left2, right2, extra_bits, next_word;
                                                               ^
src/unpack3.c:498:76: style: The scope of the variable 'next_word' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int32_t sum, left, right, diff, left2, right2, extra_bits, next_word;
                                                                           ^
src/unpack3.c:681:58: style: The scope of the variable 'extra_bits' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int32_t sum, left, right, left2, right2, extra_bits;
                                                         ^
src/unpack3.c:784:25: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int32_t temp;
                        ^
src/unpack3.c:920:38: style: The scope of the variable 'left2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int32_t left, right, left2, right2, sum, diff;
                                     ^
src/unpack3.c:920:45: style: The scope of the variable 'right2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int32_t left, right, left2, right2, sum, diff;
                                            ^
src/unpack3.c:920:53: style: The scope of the variable 'sum' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int32_t left, right, left2, right2, sum, diff;
                                                    ^
src/unpack3.c:920:58: style: The scope of the variable 'diff' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int32_t left, right, left2, right2, sum, diff;
                                                         ^
src/unpack3.c:1178:22: style: The scope of the variable 'bcount' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            uint32_t bcount;
                     ^
src/unpack3.c:1243:14: style: The scope of the variable 'tmp1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t tmp1, tmp2, avalue;
             ^
src/unpack3.c:1243:20: style: The scope of the variable 'tmp2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t tmp1, tmp2, avalue;
                   ^
src/unpack3.c:1253:21: style: The scope of the variable 'mask' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int32_t mask;
                    ^
src/unpack3.c:1492:13: style: The scope of the variable 'value' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t value, low, mid, high;
            ^
src/unpack3.c:1505:17: style: The scope of the variable 'mask' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int32_t mask;
                ^
src/unpack3.c:1527:13: style: The scope of the variable 'slow_log_0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int slow_log_0, slow_log_1, balance;
            ^
src/unpack3.c:1527:25: style: The scope of the variable 'slow_log_1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int slow_log_0, slow_log_1, balance;
                        ^
src/unpack3.c:1527:37: style: The scope of the variable 'balance' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int slow_log_0, slow_log_1, balance;
                                    ^
src/unpack3.c:330:45: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
        min_shifted = (min_value = -8388608 >> shift) << shift;
                                            ^
src/unpack3.c:334:43: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
        min_shifted = (min_value = -32768 >> shift) << shift;
                                          ^
src/unpack3.c:1596:17: style: Local variable 'bitcount' shadows outer variable [shadowVariable]
            int bitcount = count_bits (maxcode);
                ^
src/unpack3.c:1493:9: note: Shadowed declaration
    int bitcount;
        ^
src/unpack3.c:1596:17: note: Shadow variable
            int bitcount = count_bits (maxcode);
                ^
src/unpack3_open.c:161:27: error: The address of local variable 'wphdr' is accessed at non-zero index. [objectIndex]
    if (((char *) &wphdr) [8] == 2 && (wpc->reader->read_bytes (wpc->wv_in, ((char *) &wphdr) + 10, 2) != 2)) {
                          ^
src/unpack3_open.c:161:19: note: Address of variable taken here.
    if (((char *) &wphdr) [8] == 2 && (wpc->reader->read_bytes (wpc->wv_in, ((char *) &wphdr) + 10, 2) != 2)) {
                  ^
src/unpack3_open.c:161:27: note: The address of local variable 'wphdr' is accessed at non-zero index.
    if (((char *) &wphdr) [8] == 2 && (wpc->reader->read_bytes (wpc->wv_in, ((char *) &wphdr) + 10, 2) != 2)) {
                          ^
src/unpack3_open.c:165:32: error: The address of local variable 'wphdr' is accessed at non-zero index. [objectIndex]
    else if (((char *) &wphdr) [8] == 3 && (wpc->reader->read_bytes (wpc->wv_in, ((char *) &wphdr) + 10,
                               ^
src/unpack3_open.c:165:24: note: Address of variable taken here.
    else if (((char *) &wphdr) [8] == 3 && (wpc->reader->read_bytes (wpc->wv_in, ((char *) &wphdr) + 10,
                       ^
src/unpack3_open.c:165:32: note: The address of local variable 'wphdr' is accessed at non-zero index.
    else if (((char *) &wphdr) [8] == 3 && (wpc->reader->read_bytes (wpc->wv_in, ((char *) &wphdr) + 10,
                               ^
src/unpack3_open.c:45:5: style: Redundant pointer operation on 'wps' - it's already a pointer. [redundantPointerOp]
    CLEAR (*wps);
    ^
src/unpack3_open.c:45:5: error: Memory is allocated but not initialized: wps [uninitdata]
    CLEAR (*wps);
    ^
src/unpack3_seek.c:87:35: style: The scope of the variable 'tcount' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int flags = wps->wphdr.flags, tcount;
                                  ^
src/unpack3_seek.c:198:65: style: The scope of the variable 'bytes_read' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t bytes_to_read = (uint32_t)(bs->end - bs->ptr - 1), bytes_read;
                                                                ^
src/unpack3_seek.c:53:84: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        int32_t *buffer = (int32_t *) malloc (1024 * (wps->wphdr.flags & MONO_FLAG ? 4 : 8));
                                                                                   ^
src/unpack_dsd.c:182:24: style: The scope of the variable 'vp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        unsigned char *vp;
                       ^
src/unpack_dsd.c:221:32: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int mult, index, code, i;
                               ^
src/unpack_dsd.c:43:108: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        if (wps->dsd.endptr - wps->dsd.byteptr != wps->wphdr.block_samples * (wps->wphdr.flags & MONO_DATA ? 1 : 2)) {
                                                                                                           ^
src/unpack_dsd.c:383:64: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
            sp [0].factor += (((sp [0].value ^ sp [0].filter0) >> 31) | 1) & ((sp [0].value ^ (sp [0].value - (sp [0].filter6 << 4))) >> 31);
                                                               ^
src/unpack_dsd.c:418:64: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
            sp [1].factor += (((sp [1].value ^ sp [1].filter0) >> 31) | 1) & ((sp [1].value ^ (sp [1].value - (sp [1].filter6 << 4))) >> 31);
                                                               ^
src/unpack_floats.c:32:13: style: The scope of the variable 'shift_count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int shift_count = 0, exp = wps->float_max_exp;
            ^
src/unpack_floats.c:101:13: style: The scope of the variable 'shift_count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int shift_count = 0, exp = wps->float_max_exp;
            ^
src/unpack_floats.c:58:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                set_sign (outval, 1);
                ^
src/unpack_floats.c:91:82: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
        crc = crc * 27 + get_mantissa (outval) * 9 + get_exponent (outval) * 3 + get_sign (outval);
                                                                                 ^
src/unpack_floats.c:109:17: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                set_sign (outval, 1);
                ^
src/unpack_seek.c:42:14: style: The scope of the variable 'buffer' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t *buffer;
             ^
src/unpack_seek.c:150:13: style: Redundant pointer operation on 'wps' - it's already a pointer. [redundantPointerOp]
            CLEAR (*wps);
            ^
src/unpack_seek.c:41:57: style: Variable 'samples_to_decode' is assigned a value that is never used. [unreadVariable]
    uint32_t bcount, samples_to_skip, samples_to_decode = 0;
                                                        ^
src/unpack_utils.c:181:86: style: The scope of the variable 'dst' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int32_t *temp_buffer = (int32_t *)malloc (samples_to_unpack * 8), *src, *dst;
                                                                                     ^
src/unpack_utils.c:183:22: style: The scope of the variable 'samcnt' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            uint32_t samcnt;
                     ^
src/unpack_utils.c:208:21: style: Redundant pointer operation on 'wps' - it's already a pointer. [redundantPointerOp]
                    CLEAR (*wps);
                    ^
src/write_words.c:335:13: style: The scope of the variable 'value' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t value, csamples;
            ^
src/write_words.c:515:14: style: The scope of the variable 'ones_count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t ones_count, low, mid, high;
             ^
src/write_words.c:581:40: style: The scope of the variable 'value' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t flags = wps->wphdr.flags, value, low;
                                       ^
src/write_words.c:583:9: style: The scope of the variable 'chan' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int chan;
        ^
winamp/in_wv.c:1043:27: portability: Casting between signed long * and float * which have an incompatible binary data representation. [invalidPointerCast]
            float *fptr = (float *) cnxt->sample_buffer;
                          ^
winamp/in_wv.c:1052:27: portability: Casting between signed long * and float * which have an incompatible binary data representation. [invalidPointerCast]
            float *fptr = (float *) cnxt->sample_buffer;
                          ^
winamp/in_wv.c:1071:27: portability: Casting between signed long * and float * which have an incompatible binary data representation. [invalidPointerCast]
            float *fptr = (float *) cnxt->sample_buffer;
                          ^
winamp/in_wv.c:1094:27: portability: Casting between signed long * and float * which have an incompatible binary data representation. [invalidPointerCast]
            float *fptr = (float *) cnxt->sample_buffer;
                          ^
winamp/in_wv.c:1113:27: portability: Casting between signed long * and float * which have an incompatible binary data representation. [invalidPointerCast]
            float *fptr = (float *) cnxt->sample_buffer;
                          ^
winamp/in_wv.c:93:7: style: The scope of the variable 'CheckGuid' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 char CheckGuid [64];
      ^
winamp/in_wv.c:607:20: style: The scope of the variable 'w_string' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned short w_string [2048];
                   ^
winamp/in_wv.c:1054:20: style: The scope of the variable 'outval' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            double outval;
                   ^
winamp/in_wv.c:1322:10: style: The scope of the variable 'error' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char error [128];
         ^
winamp/in_wv.c:1418:10: style: The scope of the variable 'error' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char error [128], res [256];
         ^
winamp/in_wv.c:1535:10: style: The scope of the variable 'error' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char error [128];
         ^
winamp/in_wv.c:1569:10: style: The scope of the variable 'error' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char error [128], utf8_val [256];
         ^
winamp/in_wv.c:1806:10: style: The scope of the variable 'error' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char error [128];
         ^
winamp/in_wv.c:2217:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
winamp/in_wv.c:2274:9: style: The scope of the variable 'num_channels' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int num_channels, ratio, i;
        ^
winamp/in_wv.c:2274:23: style: The scope of the variable 'ratio' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int num_channels, ratio, i;
                      ^
winamp/in_wv.c:2274:30: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int num_channels, ratio, i;
                             ^
winamp/in_wv.c:1107:51: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
                *cptr++ = (unsigned char) (outval >> 8);
                                                  ^
winamp/in_wv.c:1108:51: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
                *cptr++ = (unsigned char) (outval >> 16);
                                                  ^
winamp/in_wv.c:1121:40: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
                    *sptr++ = -8388608 << 8;
                                       ^
winamp/in_wv.c:2258:78: warning: Division by result of sizeof(). memmove() expects a size in bytes, did you intend to multiply instead? [sizeofDivisionMemfunc]
            memmove (sp->delay, sp->delay + ratio, sizeof (sp->delay [0]) * (NUM_TERMS - ratio));
                                                                             ^
winamp/in_wv.c:1275:0: information: Skipping configuration 'S_IFMT;S_IFREG;S_ISREG' since the value of 'S_ISREG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    return file && !fstat (fileno (file), &statbuf) && S_ISREG(statbuf.st_mode);
^
winamp/wasabi/Wasabi.cpp:24:2: style: The function '_dispatch' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
 RECVS_DISPATCH;
 ^
winamp/wasabi/bfc/dispatch.h:34:26: note: Virtual function in base class
  virtual int WASABICALL _dispatch(int msg, void *retval, void **params=0, int nparam=0)=0;
                         ^
winamp/wasabi/Wasabi.cpp:24:2: note: Function in derived class
 RECVS_DISPATCH;
 ^
winamp/wasabi/Wasabi.cpp:88:2: style: The function '_dispatch' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
 RECVS_DISPATCH;
 ^
winamp/wasabi/bfc/dispatch.h:34:26: note: Virtual function in base class
  virtual int WASABICALL _dispatch(int msg, void *retval, void **params=0, int nparam=0)=0;
                         ^
winamp/wasabi/Wasabi.cpp:88:2: note: Function in derived class
 RECVS_DISPATCH;
 ^
winamp/wasabi/Wasabi.cpp:37:19: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
 WASABI_API_SVC = (api_service *)SendMessage(mod.hMainWindow, WM_WA_IPC, 0, IPC_GET_API_SERVICE);
                  ^
winamp/wasabi/Wasabi.cpp:39:47: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
 if (WASABI_API_SVC == 0 || WASABI_API_SVC == (api_service *) 1) {
                                              ^
winamp/wasabi/Wasabi.cpp:46:25: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
 waServiceFactory *sf = (waServiceFactory *)WASABI_API_SVC->service_getServiceByGuid(AgaveConfigGUID);
                        ^
winamp/wasabi/Wasabi.cpp:48:21: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
  AGAVE_API_CONFIG= (api_config *)sf->getInterface();
                    ^
winamp/wasabi/Wasabi.cpp:49:7: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
 sf = (waServiceFactory *)WASABI_API_SVC->service_getServiceByGuid(memMgrApiServiceGuid);
      ^
winamp/wasabi/Wasabi.cpp:51:22: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
  WASABI_API_MEMMGR= (api_memmgr *)sf->getInterface();
                     ^
winamp/wasabi/Wasabi.cpp:57:26: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
  waServiceFactory *sf = (waServiceFactory *)WASABI_API_SVC->service_getServiceByGuid(AgaveConfigGUID);
                         ^
winamp/wasabi/Wasabi.cpp:60:8: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
  sf = (waServiceFactory *)WASABI_API_SVC->service_getServiceByGuid(memMgrApiServiceGuid);
       ^
winamp/wasabi/bfc/dispatch.h:556:46: performance: Parameter 'interface_guid' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
inline int Dispatchable::QueryInterface(GUID interface_guid, void **object)
                                             ^
winamp/wasabi/Agave/Config/api_config.h:49:38: performance: Parameter 'groupGUID' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
inline bool api_config::GetBool(GUID groupGUID, const wchar_t *configItem, bool defaultValue)
                                     ^
winamp/wasabi/Agave/Config/api_config.h:61:47: performance: Parameter 'groupGUID' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
inline uintptr_t api_config::GetUnsigned(GUID groupGUID, const wchar_t *configItem, uintptr_t defaultValue)
                                              ^
winamp/wasabi/Agave/Config/api_config.h:73:41: performance: Parameter 'groupGUID' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
inline intptr_t api_config::GetInt(GUID groupGUID, const wchar_t *configItem, intptr_t defaultValue)
                                        ^
winamp/wasabi/Agave/Config/api_config.h:85:40: performance: Parameter 'groupGUID' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
inline float api_config::GetFloat(GUID groupGUID, const wchar_t *configItem, float defaultValue)
                                       ^
winamp/wasabi/Agave/Config/api_config.h:97:50: performance: Parameter 'groupGUID' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
inline const wchar_t *api_config::GetString(GUID groupGUID, const wchar_t *configItem, const wchar_t *defaultValue)
                                                 ^
winamp/wasabi/Agave/Config/api_config.h:109:49: performance: Parameter 'groupGUID' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
inline ifc_configitem *api_config::GetItem(GUID groupGUID, const wchar_t *configItem)
                                                ^
xmms/src/libwavpack.cpp:114:5: warning: Member variable 'WavpackDecoder::sample_rate' is not initialized in the constructor. [uninitMemberVar]
    WavpackDecoder(InputPlugin *mod) : mod(mod)
    ^
xmms/src/libwavpack.cpp:114:5: warning: Member variable 'WavpackDecoder::num_channels' is not initialized in the constructor. [uninitMemberVar]
    WavpackDecoder(InputPlugin *mod) : mod(mod)
    ^
xmms/src/libwavpack.cpp:114:5: warning: Member variable 'WavpackDecoder::bytes_per_sample' is not initialized in the constructor. [uninitMemberVar]
    WavpackDecoder(InputPlugin *mod) : mod(mod)
    ^
xmms/src/libwavpack.cpp:114:5: warning: Member variable 'WavpackDecoder::error_buff' is not initialized in the constructor. [uninitMemberVar]
    WavpackDecoder(InputPlugin *mod) : mod(mod)
    ^
xmms/src/libwavpack.cpp:114:5: warning: Member variable 'WavpackDecoder::play_gain' is not initialized in the constructor. [uninitMemberVar]
    WavpackDecoder(InputPlugin *mod) : mod(mod)
    ^
xmms/src/libwavpack.cpp:114:5: warning: Member variable 'WavpackDecoder::shaping_error' is not initialized in the constructor. [uninitMemberVar]
    WavpackDecoder(InputPlugin *mod) : mod(mod)
    ^
xmms/src/libwavpack.cpp:114:5: style: Class 'WavpackDecoder' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    WavpackDecoder(InputPlugin *mod) : mod(mod)
    ^
xmms/src/libwavpack.cpp:171:27: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
            float *fptr = (float *) input;
                          ^
xmms/src/libwavpack.cpp:180:27: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
            float *fptr = (float *) input;
                          ^
xmms/src/libwavpack.cpp:188:27: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
            float *fptr = (float *) input;
                          ^
xmms/src/libwavpack.cpp:339:14: style: Local variable 'text' shadows outer variable [shadowVariable]
        char text[256];
             ^
xmms/src/libwavpack.cpp:323:10: note: Shadowed declaration
    char text [256];
         ^
xmms/src/libwavpack.cpp:339:14: note: Shadow variable
        char text[256];
             ^
xmms/src/libwavpack.cpp:373:16: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
    size_t err = iconv(idesc, &in, &in_left, &out, &out_left);
               ^
xmms/src/libwavpack.cpp:397:27: style: Variable 'bps_updateCounter' is assigned a value that is never used. [unreadVariable]
    int bps_updateCounter = 0;
                          ^
xmms/src/libwavpack.cpp:407:9: style: Variable 'bps' is assigned a value that is never used. [unreadVariable]
    bps = WavpackGetBytesPerSample(d.ctx) * d.num_channels;
        ^
xmms/src/libwavpack.cpp:421:19: style: Variable 'display' is assigned a value that is never used. [unreadVariable]
    char *display = generate_title(filename, d.ctx);
                  ^
xmms/src/libwavpack.cpp:422:16: style: Variable 'length' is assigned a value that is never used. [unreadVariable]
    int length = (int) (1000 * WavpackGetNumSamples(d.ctx));
               ^
xmms/src/libwavpack.cpp:395:13: style: Unused variable: tag [unusedVariable]
    ape_tag tag;
            ^
xmms/src/libwavpack.cpp:399:9: style: Unused variable: i [unusedVariable]
    int i;
        ^
xmms/src/tags.cpp:108:49: error: Null pointer dereference [nullPointer]
        if ((c = wcsrtombs(temp, &src, MAX_LEN, NULL)) == 0)
                                                ^
xmms/src/tags.cpp:209:19: style: The scope of the variable 'vsize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned long vsize;
                  ^
xmms/src/tags.cpp:210:19: style: The scope of the variable 'isize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned long isize;
                  ^
xmms/src/tags.cpp:211:19: style: The scope of the variable 'flags' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned long flags;
                  ^
xmms/src/tags.cpp:304:9: style: The scope of the variable 'fd' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int fd;
        ^
xmms/src/tags.cpp:104:53: style: The unsigned expression 'c=utf8ToUnicode(value,wValue,len)' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
        if ((c = utf8ToUnicode(value, wValue, len)) <= 0)
                                                    ^
xmms/src/tags.cpp:15:19: style: struct member 'APETagFooterStruct::Flags' is never used. [unusedStructMember]
    unsigned char Flags[4];
                  ^
xmms/src/tags.cpp:16:19: style: struct member 'APETagFooterStruct::Reserved' is never used. [unusedStructMember]
    unsigned char Reserved[8];
                  ^
xmms/src/tags.cpp:539:14: style: Variable 'TagCount' is assigned a value that is never used. [unreadVariable]
    TagCount = 0;
             ^
xmms/src/ui.cpp:137:23: style: The scope of the variable 'info_frame' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    static GtkWidget *info_frame, *info_box, *bitrate_label, *rate_label;
                      ^
xmms/src/ui.cpp:137:36: style: The scope of the variable 'info_box' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    static GtkWidget *info_frame, *info_box, *bitrate_label, *rate_label;
                                   ^
xmms/src/ui.cpp:144:51: style: Local variable 'vbox' shadows outer variable [shadowVariable]
        GtkWidget *hbox, *label, *filename_hbox, *vbox, *left_vbox;
                                                  ^
xmms/src/ui.cpp:419:19: note: Shadowed declaration
static GtkWidget *vbox, *notebook;
                  ^
xmms/src/ui.cpp:144:51: note: Shadow variable
        GtkWidget *hbox, *label, *filename_hbox, *vbox, *left_vbox;
                                                  ^
cli/wavpack.c:328:24: warning: Null pointer dereference: argv [ctunullpointer]
    strcpy (selfname, *argv);
                       ^
cli/wavpack.c:1349:8: note: Assuming that condition 'if(argv_copy)' is not redundant

       ^
cli/wavpack.c:1347:23: note: Calling function wavpack_main, 2nd argument is null
    ret = wavpack_main(argc_utf8, argv_copy);
                      ^
cli/wavpack.c:328:24: note: Dereferencing argument argv that is null
    strcpy (selfname, *argv);
                       ^
cli/wvgain.c:150:24: warning: Null pointer dereference: argv [ctunullpointer]
    strcpy (selfname, *argv);
                       ^
cli/wvgain.c:563:8: note: Assuming that condition 'if(argv_copy)' is not redundant

       ^
cli/wvgain.c:561:22: note: Calling function wvgain_main, 2nd argument is null
    ret = wvgain_main(argc_utf8, argv_copy);
                     ^
cli/wvgain.c:150:24: note: Dereferencing argument argv that is null
    strcpy (selfname, *argv);
                       ^
cli/wvtag.c:200:24: warning: Null pointer dereference: argv [ctunullpointer]
    strcpy (selfname, *argv);
                       ^
cli/wvtag.c:711:8: note: Assuming that condition 'if(argv_copy)' is not redundant

       ^
cli/wvtag.c:709:21: note: Calling function wvtag_main, 2nd argument is null
    ret = wvtag_main(argc_utf8, argv_copy);
                    ^
cli/wvtag.c:200:24: note: Dereferencing argument argv that is null
    strcpy (selfname, *argv);
                       ^
cli/wvunpack.c:230:24: warning: Null pointer dereference: argv [ctunullpointer]
    strcpy (selfname, *argv);
                       ^
cli/wvunpack.c:836:8: note: Assuming that condition 'if(argv_copy)' is not redundant

       ^
cli/wvunpack.c:834:24: note: Calling function wvunpack_main, 2nd argument is null
    ret = wvunpack_main(argc_utf8, argv_copy);
                       ^
cli/wvunpack.c:230:24: note: Dereferencing argument argv that is null
    strcpy (selfname, *argv);
                       ^
audition/cool_wv4.c:657:0: style: The function 'CloseFilterInput' is never used. [unusedFunction]

^
audition/cool_wv4.c:444:0: style: The function 'CloseFilterOutput' is never used. [unusedFunction]

^
winamp/in_wv.c:38:0: style: The function 'DllMain' is never used. [unusedFunction]

^
cli/utils.c:710:0: style: The function 'DoSetFilePositionRelative' is never used. [unusedFunction]

^
cli/utils.c:720:0: style: The function 'DoUngetc' is never used. [unusedFunction]

^
audition/cool_wv4.c:572:0: style: The function 'FilterGetFileSize' is never used. [unusedFunction]

^
audition/cool_wv4.c:1401:0: style: The function 'FilterGetFirstSpecialData' is never used. [unusedFunction]

^
audition/cool_wv4.c:973:0: style: The function 'FilterOptions' is never used. [unusedFunction]

^
audition/cool_wv4.c:1020:0: style: The function 'FilterOptionsString' is never used. [unusedFunction]

^
audition/cool_wv4.c:100:0: style: The function 'FilterUnderstandsFormat' is never used. [unusedFunction]

^
audition/cool_wv4.c:1057:0: style: The function 'FilterWriteSpecialData' is never used. [unusedFunction]

^
audition/cool_wv4.c:113:0: style: The function 'GetSuggestedSampleType' is never used. [unusedFunction]

^
audition/cool_wv4.c:534:0: style: The function 'OpenFilterInput' is never used. [unusedFunction]

^
audition/cool_wv4.c:173:0: style: The function 'OpenFilterOutput' is never used. [unusedFunction]

^
audition/cool_wv4.c:71:0: style: The function 'QueryCoolFilter' is never used. [unusedFunction]

^
xmms/src/tags.cpp:207:0: style: The function 'ReadAPE2Tag' is never used. [unusedFunction]

^
audition/cool_wv4.c:589:0: style: The function 'ReadFilterInput' is never used. [unusedFunction]

^
xmms/src/tags.cpp:165:0: style: The function 'ReadID3Tag' is never used. [unusedFunction]

^
src/common_utils.c:773:0: style: The function 'WavpackGetLibraryVersion' is never used. [unusedFunction]

^
src/open_raw.c:308:0: style: The function 'WavpackGetNumSamplesInFrame' is never used. [unusedFunction]

^
src/open_raw.c:133:0: style: The function 'WavpackOpenRawDecoder' is never used. [unusedFunction]

^
src/pack_utils.c:181:0: style: The function 'WavpackSetConfiguration' is never used. [unusedFunction]

^
xmms/src/tags.cpp:372:0: style: The function 'WriteAPE2Tag' is never used. [unusedFunction]

^
audition/cool_wv4.c:327:0: style: The function 'WriteFilterOutput' is never used. [unusedFunction]

^
xmms/src/libwavpack.cpp:219:0: style: The function 'get_iplugin_info' is never used. [unusedFunction]

^
src/common_utils.c:352:0: style: The function 'install_close_callback' is never used. [unusedFunction]

^
cli/win32_unicode_support.c:182:0: style: The function 'stat_utf8' is never used. [unusedFunction]

^
winamp/in_wv.c:1319:0: style: The function 'winampGetExtendedFileInfo' is never used. [unusedFunction]

^
winamp/in_wv.c:1416:0: style: The function 'winampGetExtendedFileInfoW' is never used. [unusedFunction]

^
winamp/in_wv.c:995:0: style: The function 'winampGetExtendedRead_close' is never used. [unusedFunction]

^
winamp/in_wv.c:946:0: style: The function 'winampGetExtendedRead_getData' is never used. [unusedFunction]

^
winamp/in_wv.c:864:0: style: The function 'winampGetExtendedRead_open' is never used. [unusedFunction]

^
winamp/in_wv.c:986:0: style: The function 'winampGetExtendedRead_setTime' is never used. [unusedFunction]

^
winamp/in_wv.c:1168:0: style: The function 'winampGetInModule2' is never used. [unusedFunction]

^
winamp/in_wv.c:1532:0: style: The function 'winampSetExtendedFileInfo' is never used. [unusedFunction]

^
winamp/in_wv.c:1566:0: style: The function 'winampSetExtendedFileInfoW' is never used. [unusedFunction]

^
winamp/in_wv.c:1635:0: style: The function 'winampUseUnifiedFileInfoDlg' is never used. [unusedFunction]

^
winamp/in_wv.c:1612:0: style: The function 'winampWriteExtendedFileInfo' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingInclude]


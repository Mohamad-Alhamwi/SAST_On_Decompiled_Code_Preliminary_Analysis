typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned char    dwfenc;
typedef unsigned int    dword;
typedef long long    longlong;
typedef unsigned long    qword;
typedef long    sqword;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long long    uint16;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned int    undefined4;
typedef unsigned long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef struct eh_frame_hdr eh_frame_hdr, *Peh_frame_hdr;

struct eh_frame_hdr {
    byte eh_frame_hdr_version; // Exception Handler Frame Header Version
    dwfenc eh_frame_pointer_encoding; // Exception Handler Frame Pointer Encoding
    dwfenc eh_frame_desc_entry_count_encoding; // Encoding of # of Exception Handler FDEs
    dwfenc eh_frame_table_encoding; // Exception Handler Table Encoding
};

typedef struct NoteGnuPropertyElement_4 NoteGnuPropertyElement_4, *PNoteGnuPropertyElement_4;

struct NoteGnuPropertyElement_4 {
    dword prType;
    dword prDatasz;
    byte data[4];
};

typedef struct fde_table_entry fde_table_entry, *Pfde_table_entry;

struct fde_table_entry {
    dword initial_loc; // Initial Location
    dword data_loc; // Data location
};

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef long __off64_t;

typedef ulong size_t;

struct _IO_FILE {
    int _flags;
    char *_IO_read_ptr;
    char *_IO_read_end;
    char *_IO_read_base;
    char *_IO_write_base;
    char *_IO_write_ptr;
    char *_IO_write_end;
    char *_IO_buf_base;
    char *_IO_buf_end;
    char *_IO_save_base;
    char *_IO_backup_base;
    char *_IO_save_end;
    struct _IO_marker *_markers;
    struct _IO_FILE *_chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t *_lock;
    __off64_t _offset;
    void *__pad1;
    void *__pad2;
    void *__pad3;
    void *__pad4;
    size_t __pad5;
    int _mode;
    char _unused2[20];
};

struct _IO_marker {
    struct _IO_marker *_next;
    struct _IO_FILE *_sbuf;
    int _pos;
};

typedef struct _IO_FILE FILE;


// WARNING! conflicting data type names: /DWARF/__off64_t - /types.h/__off64_t

typedef union BYTES2DDWORD BYTES2DDWORD, *PBYTES2DDWORD;

union BYTES2DDWORD {
    ulonglong ddword;
    uchar bytes[8];
};

typedef union BYTES2DWORD BYTES2DWORD, *PBYTES2DWORD;

union BYTES2DWORD {
    uint dword;
    uchar bytes[4];
};

typedef union BYTES2WORD BYTES2WORD, *PBYTES2WORD;

union BYTES2WORD {
    ushort word;
    uchar bytes[2];
};

typedef struct _TNEFIOStruct _TNEFIOStruct, *P_TNEFIOStruct;

typedef struct _TNEFIOStruct TNEFIOStruct;

struct _TNEFIOStruct {
    int (*InitProc)(struct _TNEFIOStruct *);
    int (*ReadProc)(struct _TNEFIOStruct *, int, int, void *);
    int (*CloseProc)(struct _TNEFIOStruct *);
    void *data;
};

typedef struct MAPIProps MAPIProps, *PMAPIProps;

typedef struct MAPIProperty MAPIProperty, *PMAPIProperty;

typedef struct variableLength variableLength, *PvariableLength;

struct MAPIProps {
    uint count;
    struct MAPIProperty *properties;
};

struct variableLength {
    uchar *data;
    int size;
};

struct MAPIProperty {
    uint custom;
    uchar guid[16];
    uint id;
    uint count;
    int namedproperty;
    struct variableLength *propnames;
    struct variableLength *data;
};

typedef struct TNEFStruct TNEFStruct, *PTNEFStruct;

typedef struct dtr dtr, *Pdtr;

typedef struct Attachment Attachment, *PAttachment;

typedef struct renddata renddata, *Prenddata;

struct dtr {
    ushort wYear;
    ushort wMonth;
    ushort wDay;
    ushort wHour;
    ushort wMinute;
    ushort wSecond;
    ushort wDayOfWeek;
};

struct renddata {
    ushort atyp;
    uint ulPosition;
    ushort dxWidth;
    ushort dyHeight;
    uint dwFlags;
};

struct Attachment {
    struct dtr Date;
    struct variableLength Title;
    struct variableLength MetaFile;
    struct dtr CreateDate;
    struct dtr ModifyDate;
    struct variableLength TransportFilename;
    struct renddata RenderData;
    struct MAPIProps MAPI;
    struct Attachment *next;
    struct variableLength FileData;
    struct variableLength IconData;
};

struct TNEFStruct {
    char version[10];
    struct variableLength from;
    struct variableLength subject;
    struct dtr dateSent;
    struct dtr dateReceived;
    char messageStatus[10];
    char messageClass[50];
    char messageID[50];
    char parentID[50];
    char conversationID[50];
    struct variableLength body;
    char priority[10];
    struct Attachment starting_attach;
    struct dtr dateModified;
    struct MAPIProps MapiProperties;
    struct variableLength CodePage;
    struct variableLength OriginalMessageClass;
    struct variableLength Owner;
    struct variableLength SentFor;
    struct variableLength Delegate;
    struct dtr DateStart;
    struct dtr DateEnd;
    struct variableLength AidOwner;
    int RequestRes;
    int Debug;
    TNEFIOStruct IO;
};

typedef struct TNEFMemInfo TNEFMemInfo, *PTNEFMemInfo;

struct TNEFMemInfo {
    uchar *dataStart;
    uchar *ptr;
    long size;
    int Debug;
};

typedef struct TNEFFileInfo TNEFFileInfo, *PTNEFFileInfo;


// WARNING! conflicting data type names: /DWARF/FILE.h/FILE - /stdio.h/FILE

struct TNEFFileInfo {
    char *filename;
    FILE *fptr;
    int Debug;
};


// WARNING! conflicting data type names: /DWARF/struct_FILE.h/_IO_FILE - /stdio.h/_IO_FILE

typedef struct _IO_wide_data _IO_wide_data, *P_IO_wide_data;

struct _IO_wide_data {
};


// WARNING! conflicting data type names: /DWARF/_UNCATEGORIZED_/_IO_marker - /libio.h/_IO_marker

typedef struct _IO_codecvt _IO_codecvt, *P_IO_codecvt;

struct _IO_codecvt {
};

typedef struct MAPIPropertyTagList MAPIPropertyTagList, *PMAPIPropertyTagList;

struct MAPIPropertyTagList {
    uint id;
    char name[128];
};

typedef struct TNEFHandler TNEFHandler, *PTNEFHandler;

struct TNEFHandler {
    uint id;
    char name[40];
    int (*handler)(struct TNEFStruct *, int, char *, int);
};

typedef enum anon_enum_32 {
    _ISblank=1,
    _IScntrl=2,
    _ISpunct=4,
    _ISalnum=8,
    _ISupper=256,
    _ISlower=512,
    _ISalpha=1024,
    _ISdigit=2048,
    _ISxdigit=4096,
    _ISspace=8192,
    _ISprint=16384,
    _ISgraph=32768
} anon_enum_32;

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

struct evp_pkey_ctx_st {
};

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;

typedef struct Elf64_Shdr Elf64_Shdr, *PElf64_Shdr;

typedef enum Elf_SectionHeaderType {
    SHT_NULL=0,
    SHT_PROGBITS=1,
    SHT_SYMTAB=2,
    SHT_STRTAB=3,
    SHT_RELA=4,
    SHT_HASH=5,
    SHT_DYNAMIC=6,
    SHT_NOTE=7,
    SHT_NOBITS=8,
    SHT_REL=9,
    SHT_SHLIB=10,
    SHT_DYNSYM=11,
    SHT_INIT_ARRAY=14,
    SHT_FINI_ARRAY=15,
    SHT_PREINIT_ARRAY=16,
    SHT_GROUP=17,
    SHT_SYMTAB_SHNDX=18,
    SHT_ANDROID_REL=1610612737,
    SHT_ANDROID_RELA=1610612738,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_CHECKSUM=1879048184,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_syminfo=1879048188,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191
} Elf_SectionHeaderType;

struct Elf64_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType sh_type;
    qword sh_flags;
    qword sh_addr;
    qword sh_offset;
    qword sh_size;
    dword sh_link;
    dword sh_info;
    qword sh_addralign;
    qword sh_entsize;
};

typedef enum Elf_ProgramHeaderType {
    PT_NULL=0,
    PT_LOAD=1,
    PT_DYNAMIC=2,
    PT_INTERP=3,
    PT_NOTE=4,
    PT_SHLIB=5,
    PT_PHDR=6,
    PT_TLS=7,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_STACK=1685382481,
    PT_GNU_RELRO=1685382482
} Elf_ProgramHeaderType;

typedef struct Elf64_Dyn Elf64_Dyn, *PElf64_Dyn;

typedef enum Elf64_DynTag {
    DT_NULL=0,
    DT_NEEDED=1,
    DT_PLTRELSZ=2,
    DT_PLTGOT=3,
    DT_HASH=4,
    DT_STRTAB=5,
    DT_SYMTAB=6,
    DT_RELA=7,
    DT_RELASZ=8,
    DT_RELAENT=9,
    DT_STRSZ=10,
    DT_SYMENT=11,
    DT_INIT=12,
    DT_FINI=13,
    DT_SONAME=14,
    DT_RPATH=15,
    DT_SYMBOLIC=16,
    DT_REL=17,
    DT_RELSZ=18,
    DT_RELENT=19,
    DT_PLTREL=20,
    DT_DEBUG=21,
    DT_TEXTREL=22,
    DT_JMPREL=23,
    DT_BIND_NOW=24,
    DT_INIT_ARRAY=25,
    DT_FINI_ARRAY=26,
    DT_INIT_ARRAYSZ=27,
    DT_FINI_ARRAYSZ=28,
    DT_RUNPATH=29,
    DT_FLAGS=30,
    DT_PREINIT_ARRAY=32,
    DT_PREINIT_ARRAYSZ=33,
    DT_RELRSZ=35,
    DT_RELR=36,
    DT_RELRENT=37,
    DT_ANDROID_REL=1610612751,
    DT_ANDROID_RELSZ=1610612752,
    DT_ANDROID_RELA=1610612753,
    DT_ANDROID_RELASZ=1610612754,
    DT_ANDROID_RELR=1879040000,
    DT_ANDROID_RELRSZ=1879040001,
    DT_ANDROID_RELRENT=1879040003,
    DT_GNU_PRELINKED=1879047669,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_CHECKSUM=1879047672,
    DT_PLTPADSZ=1879047673,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_FEATURE_1=1879047676,
    DT_POSFLAG_1=1879047677,
    DT_SYMINSZ=1879047678,
    DT_SYMINENT=1879047679,
    DT_GNU_XHASH=1879047924,
    DT_GNU_HASH=1879047925,
    DT_TLSDESC_PLT=1879047926,
    DT_TLSDESC_GOT=1879047927,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_LIBLIST=1879047929,
    DT_CONFIG=1879047930,
    DT_DEPAUDIT=1879047931,
    DT_AUDIT=1879047932,
    DT_PLTPAD=1879047933,
    DT_MOVETAB=1879047934,
    DT_SYMINFO=1879047935,
    DT_VERSYM=1879048176,
    DT_RELACOUNT=1879048185,
    DT_RELCOUNT=1879048186,
    DT_FLAGS_1=1879048187,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_AUXILIARY=2147483645,
    DT_FILTER=2147483647
} Elf64_DynTag;

struct Elf64_Dyn {
    enum Elf64_DynTag d_tag;
    qword d_val;
};

typedef struct Elf64_Rela Elf64_Rela, *PElf64_Rela;

struct Elf64_Rela {
    qword r_offset; // location to apply the relocation action
    qword r_info; // the symbol table index and the type of relocation
    qword r_addend; // a constant addend used to compute the relocatable field value
};

typedef struct Elf64_Sym Elf64_Sym, *PElf64_Sym;

struct Elf64_Sym {
    dword st_name;
    byte st_info;
    byte st_other;
    word st_shndx;
    qword st_value;
    qword st_size;
};

typedef struct GnuBuildId GnuBuildId, *PGnuBuildId;

struct GnuBuildId {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
    byte hash[20];
};

typedef struct NoteGnuProperty_4 NoteGnuProperty_4, *PNoteGnuProperty_4;

struct NoteGnuProperty_4 {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
};

typedef struct Elf64_Ehdr Elf64_Ehdr, *PElf64_Ehdr;

struct Elf64_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_osabi;
    byte e_ident_abiversion;
    byte e_ident_pad[7];
    word e_type;
    word e_machine;
    dword e_version;
    qword e_entry;
    qword e_phoff;
    qword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};

typedef struct Elf64_Phdr Elf64_Phdr, *PElf64_Phdr;

struct Elf64_Phdr {
    enum Elf_ProgramHeaderType p_type;
    dword p_flags;
    qword p_offset;
    qword p_vaddr;
    qword p_paddr;
    qword p_filesz;
    qword p_memsz;
    qword p_align;
};




int _init(EVP_PKEY_CTX *ctx)

{
  int iVar1;
  
  iVar1 = 0x119050;
  if (true) {
    iVar1 = __gmon_start__();
  }
  return iVar1;
}



void FUN_00102020(void)

{
  (*(code *)(undefined *)0x0)();
  return;
}



void FUN_00102250(void)

{
  __cxa_finalize();
  return;
}



int TNEFRawRead(TNEFStruct *TNEF,uchar *data,uint size,ushort *checksum)

{
  byte *pbVar1;
  byte bVar2;
  ushort uVar3;
  uint uVar4;
  int iVar5;
  
  uVar4 = (*(TNEF->IO).ReadProc)(&TNEF->IO,1,size,data);
  if (uVar4 < size) {
    iVar5 = -3;
    if (0 < TNEF->Debug) {
      puts("ERROR: Error reading data");
    }
  }
  else {
    if ((checksum != (ushort *)0x0) && (*checksum = 0, size != 0)) {
      pbVar1 = data + (ulong)(size - 1) + 1;
      uVar3 = 0;
      do {
        bVar2 = *data;
        data = data + 1;
        uVar3 = uVar3 + bVar2;
        *checksum = uVar3;
      } while (data != pbVar1);
    }
    iVar5 = 0;
  }
  return iVar5;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void free(void *__ptr)

{
  free(__ptr);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int putchar(int __c)

{
  int iVar1;
  
  iVar1 = putchar(__c);
  return iVar1;
}



ulonglong SwapDDWord(uchar *p,int size)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  ulonglong uStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  lVar1 = 0;
  uStack_18 = 0;
  iVar2 = 8;
  if ((uint)size < 9) {
    iVar2 = size;
  }
  if (size == 0) {
    uStack_18 = 0;
  }
  else {
    do {
      *(uchar *)((long)&uStack_18 + lVar1) = p[lVar1];
      lVar1 = lVar1 + 1;
    } while ((int)lVar1 < iVar2);
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uStack_18;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int puts(char *__s)

{
  int iVar1;
  
  iVar1 = puts(__s);
  return iVar1;
}



ushort SwapWord(uchar *p,int size)

{
  ushort uVar1;
  long in_FS_OFFSET;
  
  uVar1 = 0;
  if (size != 0) {
    uVar1 = (ushort)*p;
    if (size != 1) {
      uVar1 = CONCAT11(p[1],*p);
    }
  }
  if (*(long *)(in_FS_OFFSET + 0x28) != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}



void TNEFFillMapi(TNEFStruct *TNEF,uchar *data,uint size,MAPIProps *p)

{
  uchar uVar1;
  int iVar2;
  undefined8 uVar3;
  uint uVar4;
  uint uVar5;
  MAPIProperty *pMVar6;
  uchar *__dest;
  uchar *puVar7;
  variableLength *pvVar8;
  void *pvVar9;
  ushort uVar10;
  ulong uVar11;
  long lVar12;
  ulong uVar13;
  char *pcVar14;
  int iVar15;
  undefined8 *puVar16;
  uint uVar17;
  uchar *puVar18;
  long in_FS_OFFSET;
  bool bVar19;
  int iStack_80;
  uint uStack_7c;
  ulong uStack_70;
  ushort uStack_4e;
  uint uStack_4c;
  ulonglong uStack_48;
  long lStack_40;
  
  puVar18 = data + 4;
  lStack_40 = *(long *)(in_FS_OFFSET + 0x28);
  uVar4 = SwapDWord(data,4);
  p->count = uVar4;
  pMVar6 = (MAPIProperty *)calloc((ulong)uVar4,0x30);
  p->properties = pMVar6;
  if (uVar4 == 0) {
    lVar12 = 4;
  }
  else {
    uStack_7c = 0;
    iVar15 = -1;
    do {
      if (iVar15 == -1) {
        uVar4 = SwapDWord(puVar18,4);
        pMVar6->custom = 0;
        pMVar6->id = uVar4;
        pMVar6->count = 1;
        pMVar6->namedproperty = 0;
        if ((int)uVar4 < 0) {
          uVar3 = *(undefined8 *)(puVar18 + 0xc);
          puVar7 = puVar18 + 0x18;
          *(undefined8 *)pMVar6->guid = *(undefined8 *)(puVar18 + 4);
          *(undefined8 *)(pMVar6->guid + 8) = uVar3;
          uVar4 = SwapDWord(puVar18 + 0x14,4);
          if (uVar4 == 0) {
            uVar4 = SwapDWord(puVar7,4);
            *(short *)((long)&pMVar6->id + 2) = (short)uVar4;
            puVar7 = puVar18 + 0x1c;
          }
          else {
            pMVar6->namedproperty = uVar4;
            lVar12 = (ulong)(uVar4 - 1) << 4;
            pvVar8 = (variableLength *)calloc((ulong)uVar4,0x10);
            pMVar6->propnames = pvVar8;
            do {
              uVar4 = SwapDWord(puVar7,4);
              uVar13 = (ulong)uVar4;
              puVar16 = (undefined8 *)((long)&pMVar6->propnames->data + lVar12);
              pvVar9 = calloc(uVar13,1);
              *(uint *)(puVar16 + 1) = uVar4;
              *puVar16 = pvVar9;
              if (uVar4 >> 1 != 0) {
                uVar11 = 0;
                while( true ) {
                  *(uchar *)((long)pvVar9 + uVar11) = puVar7[uVar11 * 2 + 4];
                  if ((uVar4 >> 1) - 1 == uVar11) break;
                  pvVar9 = *(void **)((long)&pMVar6->propnames->data + lVar12);
                  uVar11 = uVar11 + 1;
                }
              }
              if ((uVar4 & 3) != 0) {
                uVar13 = (ulong)((uVar4 + 4) - (uVar4 & 3));
              }
              lVar12 = lVar12 + -0x10;
              puVar7 = puVar7 + uVar13 + 4;
            } while (lVar12 != -0x10);
          }
          pMVar6->custom = 1;
        }
        else {
          puVar7 = puVar18 + 4;
        }
        if (2 < TNEF->Debug) {
          __printf_chk(1,"DEBUG(%i/%i):",3);
          __printf_chk(1,"Type id = %04x, Prop id = %04x",pMVar6->id & 0xffff,pMVar6->id >> 0x10);
          putchar(10);
        }
        uVar4 = pMVar6->id;
        uVar10 = (ushort)uVar4;
        bVar19 = (uVar4 & 0x1000) != 0;
        if (bVar19) {
          iVar15 = 0;
          puVar18 = puVar7 + 4;
          pMVar6->id = uVar4 & 0xffff0000 | (uVar4 & 0xffff) - 0x1000;
          uVar5 = SwapDWord(puVar7,4);
          uVar4 = pMVar6->id;
          pMVar6->count = uVar5;
          iStack_80 = 0;
          uVar10 = (ushort)uVar4;
        }
        else {
          iStack_80 = -1;
          uVar5 = pMVar6->count;
          puVar18 = puVar7;
        }
        bVar19 = !bVar19;
        uVar17 = (uint)uVar10;
        pvVar8 = (variableLength *)calloc((ulong)uVar5,0x10);
        uStack_7c = uStack_7c + 1;
        pMVar6->data = pvVar8;
      }
      else {
        iVar15 = iVar15 + 1;
        uVar4 = pMVar6->id;
        bVar19 = false;
        uVar17 = uVar4 & 0xffff;
        pvVar8 = pMVar6->data + iVar15;
        iStack_80 = iVar15;
      }
      if (uVar17 < 0x49) {
        if ((1 < uVar17) && (true)) {
          switch(uVar17) {
          case 2:
            pvVar8->size = 2;
            puVar7 = (uchar *)calloc(2,2);
            pvVar8->data = puVar7;
            uStack_4e = SwapWord(puVar18,2);
            memcpy(pvVar8->data,&uStack_4e,(long)pvVar8->size);
            uVar4 = pMVar6->id;
            puVar18 = puVar18 + 4;
            break;
          case 3:
          case 4:
          case 6:
          case 7:
          case 10:
          case 0xb:
            pvVar8->size = 4;
            puVar7 = (uchar *)calloc(4,1);
            pvVar8->data = puVar7;
            uStack_4c = SwapDWord(puVar18,4);
            memcpy(pvVar8->data,&uStack_4c,(long)pvVar8->size);
            uVar4 = pMVar6->id;
            puVar18 = puVar18 + 4;
            break;
          case 5:
          case 0x14:
          case 0x40:
            pvVar8->size = 8;
            puVar7 = (uchar *)calloc(8,1);
            pvVar8->data = puVar7;
            uStack_48 = SwapDDWord(puVar18,8);
            memcpy(pvVar8->data,&uStack_48,(long)pvVar8->size);
            uVar4 = pMVar6->id;
            puVar18 = puVar18 + 8;
            break;
          case 0xd:
          case 0x1e:
          case 0x1f:
            goto switchD_0010328e_caseD_d;
          case 0x48:
            pvVar8->size = 0x10;
            puVar7 = (uchar *)calloc(0x10,1);
            pvVar8->data = puVar7;
            uVar3 = *(undefined8 *)(puVar18 + 8);
            *(undefined8 *)puVar7 = *(undefined8 *)puVar18;
            *(undefined8 *)(puVar7 + 8) = uVar3;
            puVar18 = puVar18 + 0x10;
          }
        }
      }
      else if (uVar17 == 0x102) {
switchD_0010328e_caseD_d:
        puVar7 = puVar18 + 4;
        if (iVar15 == -1) {
          uVar4 = SwapDWord(puVar18,4);
          pvVar8->size = uVar4;
          puVar7 = puVar18 + 8;
          puVar18 = puVar18 + 4;
        }
        uVar5 = SwapDWord(puVar18,4);
        pvVar8->size = uVar5;
        if (uVar5 == 0) {
          pvVar8->data = (uchar *)0x0;
          uVar4 = pMVar6->id;
          uVar13 = 0;
        }
        else {
          uVar4 = pMVar6->id;
          if ((short)uVar4 == 0x1f) {
            puVar18 = (uchar *)to_utf8(uVar5,(char *)puVar7);
            uVar4 = pMVar6->id;
            pvVar8->data = puVar18;
          }
          else {
            puVar18 = (uchar *)calloc((long)(int)uVar5,1);
            pvVar8->data = puVar18;
            memcpy(puVar18,puVar7,(long)(int)uVar5);
          }
          uVar5 = pvVar8->size;
          uVar13 = (ulong)uVar5;
          if ((uVar5 & 3) != 0) {
            uVar13 = (ulong)((uVar5 + 4) - (uVar5 & 3));
          }
        }
        puVar18 = puVar7 + uVar13;
      }
      uVar5 = uVar4 >> 0x10;
      if (uVar4 < 0x710000) {
        if ((0x36 < uVar5) && ((0x200000000040003U >> ((ulong)(uVar5 - 0x37) & 0x3f) & 1) != 0)) {
LAB_0010343b:
          if (TNEF->Debug < 3) {
            if ((TNEF->subject).size == 0) {
LAB_00103455:
              __dest = (uchar *)calloc((ulong)size,1);
              iVar2 = pvVar8->size;
              (TNEF->subject).data = __dest;
              puVar7 = pvVar8->data;
              (TNEF->subject).size = iVar2;
              puVar7 = (uchar *)memcpy(__dest,puVar7,(long)pvVar8->size);
              if (iVar2 != 0) {
                lVar12 = 0;
                while( true ) {
                  uVar1 = puVar7[lVar12];
                  if (((uVar1 == '/') || (uVar1 == '\\')) || (uVar1 == '\0')) {
                    puVar7[lVar12] = '_';
                  }
                  lVar12 = lVar12 + 1;
                  if ((TNEF->subject).size == (int)lVar12) break;
                  puVar7 = (TNEF->subject).data;
                }
              }
            }
          }
          else {
            __printf_chk(1,"DEBUG(%i/%i): %s\n",3,TNEF->Debug,"Got a Subject");
            if ((TNEF->subject).size == 0) {
              if (2 < TNEF->Debug) {
                __printf_chk(1,"DEBUG(%i/%i): %s\n",3,TNEF->Debug,"Assigning a Subject");
              }
              goto LAB_00103455;
            }
          }
        }
      }
      else if (uVar5 == 0xe1d) goto LAB_0010343b;
      if ((pMVar6->count - 1 == iStack_80) || (bVar19)) {
        pMVar6 = pMVar6 + 1;
        iVar15 = -1;
      }
    } while (uStack_7c < p->count);
    lVar12 = (long)puVar18 - (long)data;
  }
  uStack_70 = (ulong)size;
  if (lVar12 < (long)uStack_70) {
    if (0 < TNEF->Debug) {
      puts("ERROR DURING MAPI READ");
      __printf_chk(1,"Read %td bytes, Expected %u bytes\n",lVar12,size);
      if (lStack_40 == *(long *)(in_FS_OFFSET + 0x28)) {
        pcVar14 = "%td bytes missing\n";
        lVar12 = uStack_70 - lVar12;
LAB_00103829:
        __printf_chk(1,pcVar14,lVar12);
        return;
      }
      goto LAB_00103943;
    }
  }
  else if (((long)uStack_70 < lVar12) && (0 < TNEF->Debug)) {
    puts("ERROR DURING MAPI READ");
    __printf_chk(1,"Read %td bytes, Expected %u bytes\n",lVar12,size);
    if (lStack_40 == *(long *)(in_FS_OFFSET + 0x28)) {
      lVar12 = lVar12 - uStack_70;
      pcVar14 = "%li bytes extra\n";
      goto LAB_00103829;
    }
    goto LAB_00103943;
  }
  if (lStack_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
LAB_00103943:
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



void TNEFFreeMapiProps(MAPIProps *p)

{
  MAPIProperty *pMVar1;
  long lVar2;
  variableLength *pvVar3;
  long lVar4;
  long lVar5;
  
  lVar2 = 0;
  if (p->count != 0) {
    do {
      pMVar1 = p->properties;
      pvVar3 = pMVar1[lVar2].data;
      lVar4 = 0;
      if (pMVar1[lVar2].count != 0) {
        do {
          while( true ) {
            if (pvVar3[lVar4].size < 1) break;
            lVar5 = lVar4 + 1;
            free(pvVar3[lVar4].data);
            pMVar1 = p->properties;
            pvVar3 = pMVar1[lVar2].data;
            pvVar3[lVar4].size = 0;
            lVar4 = lVar5;
            if (pMVar1[lVar2].count <= (uint)lVar5) goto LAB_001047d4;
          }
          lVar4 = lVar4 + 1;
          pvVar3 = pMVar1[lVar2].data;
        } while ((uint)lVar4 < pMVar1[lVar2].count);
      }
LAB_001047d4:
      free(pvVar3);
      pMVar1 = p->properties;
      pvVar3 = pMVar1[lVar2].propnames;
      if (0 < pMVar1[lVar2].namedproperty) {
        lVar4 = 0;
        do {
          while( true ) {
            if (pvVar3[lVar4].size < 1) break;
            lVar5 = lVar4 + 1;
            free(pvVar3[lVar4].data);
            pMVar1 = p->properties;
            pvVar3 = pMVar1[lVar2].propnames;
            pvVar3[lVar4].size = 0;
            lVar4 = lVar5;
            if (pMVar1[lVar2].namedproperty <= (int)lVar5) goto LAB_00104842;
          }
          lVar4 = lVar4 + 1;
          pvVar3 = pMVar1[lVar2].propnames;
        } while ((int)lVar4 < pMVar1[lVar2].namedproperty);
      }
LAB_00104842:
      free(pvVar3);
      lVar2 = lVar2 + 1;
    } while ((uint)lVar2 < p->count);
  }
  free(p->properties);
  p->count = 0;
  return;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int TNEFGetKey(TNEFStruct *TNEF,ushort *key)

{
  ushort uVar1;
  int iVar2;
  
  iVar2 = (*(TNEF->IO).ReadProc)(&TNEF->IO,2,1,key);
  if (iVar2 < 1) {
    iVar2 = -3;
    if (0 < TNEF->Debug) {
      puts("Error reading Key");
    }
  }
  else {
    uVar1 = SwapWord((uchar *)key,2);
    iVar2 = TNEF->Debug;
    *key = uVar1;
    if (1 < iVar2) {
      __printf_chk(1,"DEBUG(%i/%i):",2);
      __printf_chk(1,"Key = 0x%X",*key);
      putchar(10);
      if (1 < TNEF->Debug) {
        __printf_chk(1,"DEBUG(%i/%i):",2);
        __printf_chk(1,"Key = %i",*key);
        putchar(10);
      }
    }
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

void TNEFInitMapi(MAPIProps *p)

{
  p->count = 0;
  p->properties = (MAPIProperty *)0x0;
  return;
}



int IsCompressedRTF(variableLength *p)

{
  uint uVar1;
  
  uVar1 = SwapDWord(p->data + 8,4);
  return (int)(uVar1 == 0x75465a4c || uVar1 == 0x414c454d);
}



char * to_utf8(int len,char *buf)

{
  uchar *puVar1;
  byte *pbVar2;
  byte bVar3;
  byte bVar4;
  ushort uVar5;
  byte *pbVar6;
  byte *pbVar7;
  int iVar8;
  
  pbVar6 = (byte *)malloc((long)((len * 3) / 2 + 1));
  pbVar7 = pbVar6;
  if (1 < len) {
    puVar1 = (uchar *)(buf + (ulong)(len - 2U >> 1) * 2 + 2);
    iVar8 = 0;
    do {
      while( true ) {
        uVar5 = SwapWord((uchar *)buf,2);
        pbVar2 = pbVar6 + iVar8;
        pbVar7 = pbVar6 + (iVar8 + 1);
        if (0x7f < uVar5) break;
        *pbVar2 = (byte)uVar5;
        iVar8 = iVar8 + 1;
LAB_001030fd:
        buf = (char *)((uchar *)buf + 2);
        if ((uchar *)buf == puVar1) goto LAB_00103164;
      }
      bVar4 = (byte)uVar5 & 0x3f | 0x80;
      bVar3 = (byte)(uVar5 >> 6);
      if (0x7fe < uVar5) {
        *pbVar2 = (byte)(uVar5 >> 0xc) | 0xe0;
        *pbVar7 = bVar3 & 0x3f | 0x80;
        pbVar6[iVar8 + 2] = bVar4;
        pbVar7 = pbVar6 + (iVar8 + 3);
        iVar8 = iVar8 + 3;
        goto LAB_001030fd;
      }
      buf = (char *)((uchar *)buf + 2);
      *pbVar2 = bVar3 | 0xc0;
      *pbVar7 = bVar4;
      pbVar7 = pbVar6 + (iVar8 + 2);
      iVar8 = iVar8 + 2;
    } while ((uchar *)buf != puVar1);
  }
LAB_00103164:
  *pbVar7 = 0;
  return (char *)pbVar6;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * calloc(size_t __nmemb,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = calloc(__nmemb,__size);
  return pvVar1;
}



void __memcpy_chk(void)

{
  __memcpy_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



uchar * DecompressRTF(variableLength *p,int *size)

{
  uint uVar1;
  byte bVar2;
  undefined uVar3;
  undefined8 uVar4;
  undefined8 uVar5;
  undefined8 uVar6;
  undefined8 uVar7;
  undefined8 uVar8;
  undefined8 uVar9;
  undefined8 uVar10;
  undefined8 uVar11;
  undefined8 uVar12;
  undefined8 uVar13;
  undefined8 uVar14;
  undefined8 uVar15;
  undefined8 uVar16;
  undefined8 uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  undefined8 *__ptr;
  undefined8 *__ptr_00;
  uchar *puVar21;
  byte bVar22;
  uint uVar23;
  ulong uVar24;
  undefined *puVar25;
  int iVar26;
  ulong uVar27;
  uint uVar28;
  uint uVar29;
  uint uVar30;
  
  __ptr = (undefined8 *)calloc(0xd0,1);
  puVar21 = p->data;
  *__ptr = 0x615c316674725c7b;
  __ptr[1] = 0x5c63616d5c69736e;
  __ptr[2] = 0x65645c3066666564;
  __ptr[3] = 0x7b30323762617466;
  __ptr[4] = 0x6c6274746e6f665c;
  __ptr[5] = 0x665c30665c7b7d3b;
  __ptr[6] = 0x6f72665c206c696e;
  __ptr[7] = 0x7773665c206e616d;
  __ptr[8] = 0x6f6d665c20737369;
  __ptr[9] = 0x73665c206e726564;
  __ptr[10] = 0x665c207470697263;
  __ptr[0xb] = 0x534d20726f636564;
  __ptr[0xc] = 0x655320736e615320;
  __ptr[0xd] = 0x6f626d7953666972;
  __ptr[0xe] = 0x69546c616972416c;
  __ptr[0xf] = 0x2077654e2073656d;
  __ptr[0x10] = 0x756f436e616d6f52;
  __ptr[0x11] = 0x6f635c7b72656972;
  __ptr[0x12] = 0x725c6c6274726f6c;
  __ptr[0x13] = 0x656572675c306465;
  __ptr[0x14] = 0x3065756c625c306e;
  __ptr[0x15] = 0x5c207261705c0d0a;
  __ptr[0x16] = 0x616c705c64726170;
  __ptr[0x17] = 0x73665c30665c6e69;
  __ptr[0x18] = 0x755c695c625c3032;
  *(undefined4 *)(__ptr + 0x19) = 0x6261745c;
  *(undefined2 *)((long)__ptr + 0xcc) = 0x745c;
  *(undefined *)((long)__ptr + 0xce) = 0x78;
  uVar18 = SwapDWord(puVar21,4);
  uVar19 = SwapDWord(puVar21 + 4,4);
  uVar20 = SwapDWord(puVar21 + 8,4);
  if (p->size - 4U == uVar18) {
    if (uVar20 != 0x414c454d) {
      if (uVar20 == 0x75465a4c) {
        uVar18 = uVar19 + 0xcf;
        __ptr_00 = (undefined8 *)calloc((ulong)uVar18,1);
        uVar4 = __ptr[1];
        uVar5 = __ptr[2];
        uVar6 = __ptr[3];
        uVar7 = __ptr[4];
        uVar8 = __ptr[5];
        uVar9 = __ptr[6];
        uVar10 = __ptr[7];
        uVar11 = __ptr[8];
        uVar12 = __ptr[9];
        *__ptr_00 = *__ptr;
        __ptr_00[1] = uVar4;
        uVar4 = __ptr[10];
        uVar13 = __ptr[0xb];
        __ptr_00[2] = uVar5;
        __ptr_00[3] = uVar6;
        uVar5 = __ptr[0xc];
        uVar6 = __ptr[0xd];
        uVar14 = __ptr[0xe];
        uVar15 = __ptr[0xf];
        __ptr_00[4] = uVar7;
        __ptr_00[5] = uVar8;
        uVar7 = __ptr[0x10];
        uVar8 = __ptr[0x11];
        uVar16 = __ptr[0x12];
        uVar17 = __ptr[0x13];
        __ptr_00[6] = uVar9;
        __ptr_00[7] = uVar10;
        uVar9 = __ptr[0x14];
        uVar10 = __ptr[0x15];
        __ptr_00[8] = uVar11;
        __ptr_00[9] = uVar12;
        uVar11 = __ptr[0x16];
        uVar12 = __ptr[0x17];
        __ptr_00[10] = uVar4;
        __ptr_00[0xb] = uVar13;
        __ptr_00[0xc] = uVar5;
        __ptr_00[0xd] = uVar6;
        __ptr_00[0xe] = uVar14;
        __ptr_00[0xf] = uVar15;
        __ptr_00[0x10] = uVar7;
        __ptr_00[0x11] = uVar8;
        __ptr_00[0x12] = uVar16;
        __ptr_00[0x13] = uVar17;
        __ptr_00[0x14] = uVar9;
        __ptr_00[0x15] = uVar10;
        __ptr_00[0x16] = uVar11;
        __ptr_00[0x17] = uVar12;
        __ptr_00[0x18] = __ptr[0x18];
        *(undefined4 *)(__ptr_00 + 0x19) = *(undefined4 *)(__ptr + 0x19);
        *(undefined2 *)((long)__ptr_00 + 0xcc) = *(undefined2 *)((long)__ptr + 0xcc);
        *(undefined *)((long)__ptr_00 + 0xce) = *(undefined *)((long)__ptr + 0xce);
        if (0xcf < uVar18) {
          uVar29 = 0;
          uVar30 = 0;
          uVar20 = 0xcf;
          uVar24 = 0x10;
          do {
            while( true ) {
              uVar23 = (uint)uVar24;
              uVar28 = uVar23 + 1;
              bVar2 = puVar21[uVar24];
              if ((uVar29 & 7) == 0) break;
              uVar30 = (int)uVar30 >> 1;
              uVar24 = (ulong)uVar28;
              bVar22 = bVar2;
              uVar28 = uVar23;
              if ((uVar30 & 1) == 0) goto LAB_001056f4;
LAB_0010572a:
              iVar26 = (puVar21[uVar24] & 0xf) + 2;
              uVar23 = ((int)(uint)puVar21[uVar24] >> 4 | (uint)bVar22 << 4) + (uVar20 & 0xfffff000)
              ;
              if (uVar20 <= uVar23) {
                uVar23 = uVar23 - 0x1000;
              }
              if ((int)uVar23 < (int)(uVar23 + iVar26)) {
                uVar1 = iVar26 + uVar20;
                puVar25 = (undefined *)((long)(int)uVar23 + (long)__ptr_00);
                do {
                  uVar3 = *puVar25;
                  uVar24 = (ulong)uVar20;
                  uVar20 = uVar20 + 1;
                  puVar25 = puVar25 + 1;
                  *(undefined *)((long)__ptr_00 + uVar24) = uVar3;
                } while (uVar1 != uVar20);
              }
              uVar24 = (ulong)(uVar28 + 2);
              uVar29 = uVar29 + 1;
              if (uVar18 <= uVar20) goto LAB_0010579d;
            }
            uVar30 = (uint)bVar2;
            uVar24 = (ulong)(uVar23 + 2);
            bVar22 = puVar21[uVar28];
            if ((bVar2 & 1) != 0) goto LAB_0010572a;
LAB_001056f4:
            uVar27 = (ulong)uVar20;
            uVar20 = uVar20 + 1;
            uVar29 = uVar29 + 1;
            *(byte *)((long)__ptr_00 + uVar27) = bVar22;
          } while (uVar20 < uVar18);
        }
LAB_0010579d:
        puVar21 = (uchar *)calloc((ulong)uVar19,1);
        memcpy(puVar21,(void *)((long)__ptr_00 + 0xcf),(ulong)uVar19);
        free(__ptr_00);
        *size = uVar19;
        free(__ptr);
        return puVar21;
      }
      __printf_chk(1,"Unknown compression type (magic number %x)\n",uVar20);
    }
    free(__ptr);
  }
  else {
    __printf_chk(1," Size Mismatch: %u != %i\n",uVar18);
    free(__ptr);
  }
  return (uchar *)0x0;
}



uint SwapDWord(uchar *p,int size)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  uint uStack_14;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  lVar1 = 0;
  uStack_14 = 0;
  iVar2 = 4;
  if ((uint)size < 5) {
    iVar2 = size;
  }
  if (size != 0) {
    do {
      *(uchar *)((long)&uStack_14 + lVar1) = p[lVar1];
      lVar1 = lVar1 + 1;
    } while ((int)lVar1 < iVar2);
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uStack_14;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



void TNEFPrintDate(dtr Date)

{
  uint uVar1;
  ushort uVar2;
  uint uVar3;
  long in_FS_OFFSET;
  ushort uStack_164;
  undefined8 uStack_158;
  undefined4 uStack_150;
  undefined2 uStack_14c;
  undefined uStack_14a;
  undefined8 uStack_149;
  undefined4 uStack_141;
  undefined2 uStack_13d;
  undefined uStack_13b;
  undefined8 uStack_13a;
  undefined4 uStack_132;
  undefined2 uStack_12e;
  undefined uStack_12c;
  undefined8 uStack_12b;
  undefined4 uStack_123;
  undefined2 uStack_11f;
  undefined uStack_11d;
  undefined8 uStack_11c;
  undefined4 uStack_114;
  undefined2 uStack_110;
  undefined uStack_10e;
  undefined8 uStack_10d;
  undefined4 uStack_105;
  undefined2 uStack_101;
  undefined uStack_ff;
  undefined8 uStack_fe;
  undefined4 uStack_f6;
  undefined2 uStack_f2;
  undefined uStack_f0;
  undefined8 uStack_e8;
  undefined4 uStack_e0;
  undefined2 uStack_dc;
  undefined uStack_da;
  undefined8 uStack_d9;
  undefined4 uStack_d1;
  undefined2 uStack_cd;
  undefined uStack_cb;
  undefined8 uStack_ca;
  undefined4 uStack_c2;
  undefined2 uStack_be;
  undefined uStack_bc;
  undefined8 uStack_bb;
  undefined4 uStack_b3;
  undefined2 uStack_af;
  undefined uStack_ad;
  undefined8 uStack_ac;
  undefined4 uStack_a4;
  undefined2 uStack_a0;
  undefined uStack_9e;
  undefined8 uStack_9d;
  undefined4 uStack_95;
  undefined2 uStack_91;
  undefined uStack_8f;
  undefined8 uStack_8e;
  undefined4 uStack_86;
  undefined2 uStack_82;
  undefined uStack_80;
  undefined8 uStack_7f;
  undefined4 uStack_77;
  undefined2 uStack_73;
  undefined uStack_71;
  undefined8 uStack_70;
  undefined4 uStack_68;
  undefined2 uStack_64;
  undefined uStack_62;
  undefined8 uStack_61;
  undefined4 uStack_59;
  undefined2 uStack_55;
  undefined uStack_53;
  undefined8 uStack_52;
  undefined4 uStack_4a;
  undefined2 uStack_46;
  undefined uStack_44;
  undefined8 uStack_43;
  undefined4 uStack_3b;
  undefined2 uStack_37;
  undefined uStack_35;
  long lStack_30;
  
  uVar3 = Date._8_4_ >> 0x10;
  lStack_30 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_158 = 0x7961646e7553;
  uStack_149 = 0x7961646e6f4d;
  uStack_13d = 0;
  uStack_12e = 0;
  uStack_14c = 0;
  uStack_13a = 0x79616473657554;
  uStack_12b = 0x616473656e646557;
  uStack_11f = 0;
  uStack_11c = 0x7961647372756854;
  uStack_110 = 0;
  uStack_10d = 0x796164697246;
  uStack_101 = 0;
  uStack_150 = 0;
  uStack_14a = 0;
  uStack_141 = 0;
  uStack_13b = 0;
  uStack_132 = 0;
  uStack_12c = 0;
  uStack_123 = 0x79;
  uStack_11d = 0;
  uStack_114 = 0;
  uStack_10e = 0;
  uStack_105 = 0;
  uStack_ff = 0;
  uStack_fe = 0x7961647275746153;
  uStack_cd = 0;
  uStack_be = 0;
  uStack_e8 = 0x797261756e614a;
  uStack_af = 0;
  uStack_d9 = 0x7972617572626546;
  uStack_ca = 0x686372614d;
  uStack_bb = 0x6c69727041;
  uStack_a0 = 0;
  uStack_f2 = 0;
  uStack_82 = 0;
  uStack_7f = 0x747375677541;
  uStack_f6 = 0;
  uStack_f0 = 0;
  uStack_e0 = 0;
  uStack_dc = 0;
  uStack_da = 0;
  uStack_d1 = 0;
  uStack_cb = 0;
  uStack_c2 = 0;
  uStack_bc = 0;
  uStack_b3 = 0;
  uStack_ad = 0;
  uStack_ac = 0x79614d;
  uStack_a4 = 0;
  uStack_9e = 0;
  uStack_9d = 0x656e754a;
  uStack_95 = 0;
  uStack_91 = 0;
  uStack_8f = 0;
  uStack_8e = 0x796c754a;
  uStack_86 = 0;
  uStack_80 = 0;
  uStack_77 = 0;
  uStack_70 = 0x65626d6574706553;
  uStack_73 = 0;
  uStack_64 = 0;
  uStack_71 = 0;
  uStack_68 = 0x72;
  uStack_62 = 0;
  uStack_61 = 0x7265626f74634f;
  uStack_59 = 0;
  uStack_55 = 0;
  uStack_53 = 0;
  uStack_52 = 0x7265626d65766f4e;
  uStack_4a = 0;
  uStack_46 = 0;
  uStack_44 = 0;
  uStack_43 = 0x7265626d65636544;
  uStack_3b = 0;
  uStack_37 = 0;
  uStack_35 = 0;
  if (Date.wDayOfWeek < 7) {
    __printf_chk(1,&DAT_00107101,(long)&uStack_158 + (ulong)Date.wDayOfWeek * 0xf);
  }
  if ((ushort)(Date.wMonth - 1) < 0xc) {
    __printf_chk(1,&DAT_00107101,(long)&uStack_e8 + (long)(int)(Date.wMonth - 1) * 0xf);
  }
  uStack_164 = Date.wDay;
  __printf_chk(1,"%hu, %hu ",uStack_164,Date._0_8_ & 0xffff);
  uVar1 = Date._8_4_ & 0xffff;
  uVar2 = Date.wHour;
  if (uVar2 < 0xd) {
    if (uVar2 == 0xc) {
      __printf_chk(1,"%hu:%02hu:%02hu pm",0xc,uVar1,uVar3);
    }
    else {
      __printf_chk(1,"%hu:%02hu:%02hu am",Date._0_8_ >> 0x30,uVar1,uVar3);
    }
  }
  else {
    __printf_chk(1,"%i:%02hu:%02hu pm",uVar2 - 0xc,uVar1,uVar3);
  }
  if (lStack_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void TNEFFreeAttachment(Attachment *p)

{
  if (0 < (p->Title).size) {
    free((p->Title).data);
    (p->Title).size = 0;
  }
  if (0 < (p->MetaFile).size) {
    free((p->MetaFile).data);
    (p->MetaFile).size = 0;
  }
  if (0 < (p->TransportFilename).size) {
    free((p->TransportFilename).data);
    (p->TransportFilename).size = 0;
  }
  if (0 < (p->FileData).size) {
    free((p->FileData).data);
    (p->FileData).size = 0;
  }
  if (0 < (p->IconData).size) {
    free((p->IconData).data);
    (p->IconData).size = 0;
  }
  TNEFFreeMapiProps(&p->MAPI);
  return;
}



int TNEFParse(TNEFStruct *TNEF)

{
  TNEFIOStruct *pTVar1;
  char *pcVar2;
  uint size;
  int iVar3;
  _func_int__TNEFIOStruct_ptr *p_Var4;
  uchar *data;
  TNEFHandler *pTVar5;
  long in_FS_OFFSET;
  ushort uStack_52;
  ushort uStack_50;
  ushort uStack_4e;
  uint uStack_4c;
  uint uStack_48;
  uint uStack_44;
  long lStack_40;
  
  lStack_40 = *(long *)(in_FS_OFFSET + 0x28);
  if ((TNEF->IO).ReadProc == (_func_int__TNEFIOStruct_ptr_int_int_void_ptr *)0x0) {
    iVar3 = -8;
    puts("ERROR: Setup incorrectly: No ReadProc");
    goto LAB_00104e79;
  }
  p_Var4 = (TNEF->IO).InitProc;
  pTVar1 = &TNEF->IO;
  iVar3 = TNEF->Debug;
  if (p_Var4 == (_func_int__TNEFIOStruct_ptr *)0x0) {
LAB_00104df4:
    if (1 < iVar3) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,iVar3,"Reading Signature");
    }
  }
  else {
    if (1 < iVar3) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,iVar3,"About to initialize");
      p_Var4 = (TNEF->IO).InitProc;
    }
    iVar3 = (*p_Var4)(&TNEF->IO);
    if (iVar3 != 0) {
      iVar3 = -1;
      goto LAB_00104e79;
    }
    if (1 < TNEF->Debug) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"Initialization finished");
      iVar3 = TNEF->Debug;
      goto LAB_00104df4;
    }
  }
  iVar3 = (*(TNEF->IO).ReadProc)(&TNEF->IO,4,1,&uStack_44);
  if (iVar3 < 1) {
    iVar3 = -3;
    puts("ERROR: Error reading signature");
    p_Var4 = (TNEF->IO).CloseProc;
  }
  else {
    if (1 < TNEF->Debug) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"Checking Signature");
    }
    iVar3 = TNEFCheckForSignature(uStack_44);
    if (iVar3 < 0) {
      iVar3 = -2;
      puts("ERROR: Signature does not match. Not TNEF.");
      p_Var4 = (TNEF->IO).CloseProc;
    }
    else {
      if (1 < TNEF->Debug) {
        __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"Reading Key.");
      }
      iVar3 = TNEFGetKey(TNEF,&uStack_52);
      if (-1 < iVar3) {
        if (1 < TNEF->Debug) {
          __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"Starting Full Processing.");
        }
        while (iVar3 = TNEFGetHeader(TNEF,&uStack_4c,&uStack_48), iVar3 == 0) {
          if (1 < TNEF->Debug) {
            __printf_chk(1,"DEBUG(%i/%i):",2);
            __printf_chk(1,"Header says type=0x%X, size=%u",uStack_4c,uStack_48);
            putchar(10);
            if (1 < TNEF->Debug) {
              __printf_chk(1,"DEBUG(%i/%i):",2);
              __printf_chk(1,"Header says type=%u, size=%u",uStack_4c,uStack_48);
              putchar(10);
            }
          }
          size = uStack_48;
          data = (uchar *)calloc((ulong)uStack_48,1);
          iVar3 = TNEFRawRead(TNEF,data,size,&uStack_4e);
          if (iVar3 < 0) {
            puts("ERROR: Unable to read data.");
            p_Var4 = (TNEF->IO).CloseProc;
joined_r0x00104ee4:
            if (p_Var4 != (_func_int__TNEFIOStruct_ptr *)0x0) {
              (*p_Var4)(pTVar1);
            }
            iVar3 = -3;
            free(data);
            goto LAB_00104e79;
          }
          iVar3 = TNEFRawRead(TNEF,(uchar *)&uStack_50,2,(ushort *)0x0);
          if (iVar3 < 0) {
            puts("ERROR: Unable to read checksum.");
            p_Var4 = (TNEF->IO).CloseProc;
            goto joined_r0x00104ee4;
          }
          uStack_50 = SwapWord((uchar *)&uStack_50,2);
          if (uStack_50 != uStack_4e) {
            puts("ERROR: Checksum mismatch. Data corruption?:");
            p_Var4 = (TNEF->IO).CloseProc;
            if (p_Var4 != (_func_int__TNEFIOStruct_ptr *)0x0) {
              (*p_Var4)(pTVar1);
            }
            iVar3 = -5;
            free(data);
            goto LAB_00104e79;
          }
          pTVar5 = TNEFList;
          iVar3 = 0;
LAB_00104c86:
          do {
            if (pTVar5->id == uStack_4c) {
              if (pTVar5->handler != (_func_int_TNEFStruct_ptr_int_char_ptr_int *)0x0) {
                iVar3 = (*pTVar5->handler)(TNEF,iVar3,(char *)data,uStack_48);
                if (iVar3 < 0) {
                  iVar3 = -6;
                  free(data);
                  p_Var4 = (TNEF->IO).CloseProc;
                  goto joined_r0x00104dbf;
                }
                break;
              }
              if (0 < TNEF->Debug) {
                __printf_chk(1,"DEBUG(%i/%i):",1);
                pcVar2 = pTVar5->name;
                iVar3 = iVar3 + 1;
                pTVar5 = pTVar5 + 1;
                __printf_chk(1,"No handler for %s: %u bytes",pcVar2,uStack_48);
                putchar(10);
                if (iVar3 == 0x21) break;
                goto LAB_00104c86;
              }
            }
            iVar3 = iVar3 + 1;
            pTVar5 = pTVar5 + 1;
          } while (iVar3 != 0x21);
          free(data);
        }
        p_Var4 = (TNEF->IO).CloseProc;
        iVar3 = 0;
        if (p_Var4 != (_func_int__TNEFIOStruct_ptr *)0x0) {
          (*p_Var4)(pTVar1);
        }
        goto LAB_00104e79;
      }
      iVar3 = -4;
      puts("ERROR: Unable to retrieve key.");
      p_Var4 = (TNEF->IO).CloseProc;
    }
  }
joined_r0x00104dbf:
  if (p_Var4 != (_func_int__TNEFIOStruct_ptr *)0x0) {
    (*p_Var4)(pTVar1);
  }
LAB_00104e79:
  if (lStack_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void __printf_chk(void)

{
  __printf_chk();
  return;
}



void TNEFInitAttachment(Attachment *p)

{
  (p->Date).wYear = 0;
  (p->Date).wMonth = 0;
  (p->Date).wDay = 0;
  (p->Date).wHour = 0;
  (p->Date).wMinute = 0;
  (p->Date).wSecond = 0;
  (p->Date).wDayOfWeek = 0;
  (p->Title).data = (uchar *)0x0;
  (p->Title).size = 0;
  (p->MetaFile).data = (uchar *)0x0;
  (p->MetaFile).size = 0;
  (p->CreateDate).wYear = 0;
  (p->CreateDate).wMonth = 0;
  (p->CreateDate).wDay = 0;
  (p->CreateDate).wHour = 0;
  *(undefined8 *)&(p->CreateDate).wMinute = 0;
  (p->ModifyDate).wMonth = 0;
  (p->ModifyDate).wDay = 0;
  (p->ModifyDate).wHour = 0;
  (p->ModifyDate).wMinute = 0;
  (p->ModifyDate).wSecond = 0;
  (p->ModifyDate).wDayOfWeek = 0;
  (p->TransportFilename).data = (uchar *)0x0;
  (p->TransportFilename).size = 0;
  (p->FileData).data = (uchar *)0x0;
  (p->FileData).size = 0;
  (p->IconData).data = (uchar *)0x0;
  (p->IconData).size = 0;
  (p->RenderData).atyp = 0;
  *(undefined2 *)&(p->RenderData).field_0x2 = 0;
  (p->RenderData).ulPosition = 0;
  (p->RenderData).dxWidth = 0;
  (p->RenderData).dyHeight = 0;
  (p->RenderData).dwFlags = 0;
  TNEFInitMapi(&p->MAPI);
  p->next = (Attachment *)0x0;
  return;
}



void MAPIPrint(MAPIProps *p)

{
  uchar *puVar1;
  undefined8 uVar2;
  bool bVar3;
  uint uVar4;
  int iVar5;
  size_t sVar6;
  ushort **ppuVar7;
  MAPIPropertyTagList *pMVar8;
  uint uVar9;
  MAPIProperty *pMVar10;
  long lVar11;
  variableLength *p_00;
  long lVar12;
  ulong uVar13;
  long in_FS_OFFSET;
  dtr Date;
  ulong uStack_90;
  dtr dStack_66;
  uchar *puStack_58;
  int aiStack_50 [4];
  long lStack_40;
  
  lStack_40 = *(long *)(in_FS_OFFSET + 0x28);
  if (p->count != 0) {
    uStack_90 = 0;
    do {
      pMVar10 = p->properties + uStack_90;
      __printf_chk(1,"   #%i: Type: [",uStack_90 & 0xffffffff);
      switch(*(short *)&pMVar10->id) {
      case 0:
        __printf_chk(1,"  NONE   ");
        break;
      case 1:
        __printf_chk(1,"  NULL   ");
        break;
      case 2:
        __printf_chk(1,&DAT_00107356);
        break;
      case 3:
        __printf_chk(1,"  LONG   ");
        break;
      case 4:
        __printf_chk(1,"   R4    ");
        break;
      case 5:
        __printf_chk(1," DOUBLE  ");
        break;
      case 6:
        __printf_chk(1,"CURRENCY ");
        break;
      case 7:
        __printf_chk(1,"APP TIME ");
        break;
      case 8:
      case 9:
      case 0xc:
      case 0xe:
      case 0xf:
      case 0x10:
      case 0x11:
      case 0x12:
      case 0x13:
      case 0x15:
      case 0x16:
      case 0x17:
      case 0x18:
      case 0x19:
      case 0x1a:
      case 0x1b:
      case 0x1c:
      case 0x1d:
      case 0x20:
      case 0x21:
      case 0x22:
      case 0x23:
      case 0x24:
      case 0x25:
      case 0x26:
      case 0x27:
      case 0x28:
      case 0x29:
      case 0x2a:
      case 0x2b:
      case 0x2c:
      case 0x2d:
      case 0x2e:
      case 0x2f:
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x3a:
      case 0x3b:
      case 0x3c:
      case 0x3d:
      case 0x3e:
      case 0x3f:
      case 0x41:
      case 0x42:
      case 0x43:
      case 0x44:
      case 0x45:
      case 0x46:
      case 0x47:
switchD_001058a0_caseD_8:
        __printf_chk(1,&DAT_001073ec);
        break;
      case 10:
        __printf_chk(1,"  ERROR  ");
        break;
      case 0xb:
        __printf_chk(1," BOOLEAN ");
        break;
      case 0xd:
        __printf_chk(1," OBJECT  ");
        break;
      case 0x14:
        __printf_chk(1,"   I8    ");
        break;
      case 0x1e:
        __printf_chk(1," STRING8 ");
        break;
      case 0x1f:
        __printf_chk(1," UNICODE ");
        break;
      case 0x40:
        __printf_chk(1,"SYS TIME ");
        break;
      case 0x48:
        __printf_chk(1,"OLE GUID ");
        break;
      default:
        if (*(short *)&pMVar10->id != 0x102) goto switchD_001058a0_caseD_8;
        __printf_chk(1," BINARY  ");
      }
      __printf_chk(1,"]  Code: [");
      if (pMVar10->custom == 1) {
        __printf_chk(1,"UD:x%04x",*(undefined2 *)((long)&pMVar10->id + 2));
      }
      else {
        pMVar8 = MPList;
        bVar3 = false;
        do {
          while ((pMVar8->id != (uint)*(ushort *)((long)&pMVar10->id + 2) || (bVar3))) {
            pMVar8 = pMVar8 + 1;
            if (pMVar8 == (MAPIPropertyTagList *)TNEFList) goto LAB_00105942;
          }
          __printf_chk(1,"%s",pMVar8->name);
          pMVar8 = pMVar8 + 1;
          bVar3 = true;
        } while (pMVar8 != (MAPIPropertyTagList *)TNEFList);
LAB_00105942:
        if (!bVar3) {
          __printf_chk(1,"0x%04x",*(undefined2 *)((long)&pMVar10->id + 2));
        }
      }
      puts("]");
      if (0 < pMVar10->namedproperty) {
        lVar11 = 0;
        do {
          lVar12 = lVar11 + 1;
          __printf_chk(1,"    Name: %s\n",pMVar10->propnames[lVar11].data);
          lVar11 = lVar12;
        } while ((int)lVar12 < pMVar10->namedproperty);
      }
      uVar9 = pMVar10->count;
      if (uVar9 != 0) {
        uVar13 = 0;
        do {
          p_00 = pMVar10->data + uVar13;
          if (uVar9 == 1) {
            __printf_chk(1,&DAT_0010735b);
          }
          else {
            __printf_chk(1,"    [%i/%u] ",uVar13 & 0xffffffff);
          }
          __printf_chk(1,"Size: %i",p_00->size);
          uVar9 = pMVar10->id;
          uVar4 = uVar9 & 0xffff;
          if (0x1e < (ushort)uVar9) {
            if (uVar4 == 0x48) {
              lVar11 = 0;
              __printf_chk(1,"    Value: ");
              __printf_chk(1,"[HEX: ");
              do {
                puVar1 = p_00->data + lVar11;
                lVar11 = lVar11 + 1;
                __printf_chk(1," %02x",*puVar1);
              } while (lVar11 != 0x10);
LAB_00105cd2:
              puts("]");
            }
            else if (uVar4 == 0x102) {
              iVar5 = IsCompressedRTF(p_00);
              if (iVar5 != 1) {
                __printf_chk(1,"    Value: [");
                if (0 < p_00->size) {
                  ppuVar7 = __ctype_b_loc();
                  lVar11 = 0;
                  do {
                    uVar9 = (uint)p_00->data[lVar11];
                    if ((*(byte *)((long)*ppuVar7 + (ulong)p_00->data[lVar11] * 2 + 1) & 0x40) == 0)
                    {
                      uVar9 = 0x2e;
                    }
                    putchar(uVar9);
                    lVar11 = lVar11 + 1;
                  } while ((int)lVar11 < p_00->size);
                  goto LAB_00105d6f;
                }
                goto LAB_00105cd2;
              }
              __printf_chk(1,"    Detected Compressed RTF. ");
              puts("Decompressed text follows");
              puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
              puStack_58 = DecompressRTF(p_00,aiStack_50);
              if (puStack_58 != (uchar *)0x0) {
                puts((char *)puStack_58);
                free(puStack_58);
              }
              puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
            }
            else {
              if (uVar4 != 0x40) goto switchD_00105a04_caseD_0;
              lVar11 = 0;
              MAPISysTimetoDTR(p_00->data,&dStack_66);
              __printf_chk(1,"    Value: ");
              uVar2 = *(undefined8 *)p_00->data;
              Date.wSecond = dStack_66.wSecond;
              Date.wMinute = dStack_66.wMinute;
              Date.wDayOfWeek = dStack_66.wDayOfWeek;
              Date.wYear = dStack_66.wYear;
              Date.wMonth = dStack_66.wMonth;
              Date.wDay = dStack_66.wDay;
              Date.wHour = dStack_66.wHour;
              TNEFPrintDate(Date);
              __printf_chk(1,&DAT_0010743e);
              do {
                puVar1 = p_00->data + lVar11;
                lVar11 = lVar11 + 1;
                __printf_chk(1," %02x",*puVar1);
              } while (lVar11 != 8);
              __printf_chk(1,"] (%llu)\n",uVar2);
            }
            goto LAB_00105a40;
          }
          if ((uVar9 & 0xfffe) == 0) {
switchD_00105a04_caseD_0:
            __printf_chk(1,"    Value: [%s]\n",p_00->data);
          }
          else {
            switch(uVar4) {
            default:
              goto switchD_00105a04_caseD_0;
            case 2:
              __printf_chk(1,"    Value: %hi\n",(int)*(short *)p_00->data);
              break;
            case 3:
              __printf_chk(1,"    Value: %li\n",*(undefined8 *)p_00->data);
              break;
            case 0xb:
              if (*pMVar10->data->data == '\0') {
                puts("    Value: False");
              }
              else {
                puts("    Value: True");
              }
              break;
            case 0xd:
              putchar(10);
              break;
            case 0x1e:
              __printf_chk(1,"    Value: [%s]\n",p_00->data);
              sVar6 = strlen((char *)p_00->data);
              if (sVar6 != (long)(p_00->size + -1)) {
                __printf_chk(1,"Detected Hidden data: [");
                if (p_00->size < 1) goto LAB_00105cd2;
                ppuVar7 = __ctype_b_loc();
                lVar11 = 0;
                do {
                  uVar9 = (uint)p_00->data[lVar11];
                  if ((*(byte *)((long)*ppuVar7 + (ulong)p_00->data[lVar11] * 2 + 1) & 0x40) == 0) {
                    uVar9 = 0x2e;
                  }
                  putchar(uVar9);
                  lVar11 = lVar11 + 1;
                } while ((int)lVar11 < p_00->size);
LAB_00105d6f:
                puts("]");
              }
            }
          }
LAB_00105a40:
          uVar13 = uVar13 + 1;
          uVar9 = pMVar10->count;
        } while ((uint)uVar13 < uVar9);
      }
      uStack_90 = uStack_90 + 1;
    } while ((uint)uStack_90 < p->count);
  }
  if (lStack_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int MAPISysTimetoDTR(uchar *data,dtr *thedate)

{
  uint uVar1;
  uint uVar2;
  ulong uVar3;
  ulong uVar4;
  int iVar5;
  ulong uVar6;
  int iVar7;
  ushort uVar8;
  long in_FS_OFFSET;
  uint auStack_48 [14];
  long lStack_10;
  
  uVar6 = *(ulong *)data;
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  auStack_48[0] = 0x1f;
  auStack_48[1] = 0x1c;
  auStack_48[2] = 0x1f;
  auStack_48[3] = 0x1e;
  auStack_48[4] = 0x1f;
  auStack_48[5] = 0x1e;
  auStack_48[6] = 0x1f;
  auStack_48[7] = 0x1f;
  auStack_48[8] = 0x1e;
  auStack_48[9] = 0x1f;
  auStack_48[10] = 0x1e;
  auStack_48[0xb] = 0x1f;
  uVar3 = uVar6 / 10000000;
  uVar4 = uVar3 / 0x3c;
  thedate->wSecond = (short)uVar3 + ((short)(uVar4 << 4) - (short)uVar4) * -4;
  uVar3 = uVar4 / 0x3c;
  thedate->wMinute = (short)uVar4 + ((short)(uVar3 << 4) - (short)uVar3) * -4;
  uVar4 = uVar3 / 0x18;
  thedate->wHour = (short)uVar3 + (short)uVar4 * -0x18;
  if (uVar6 < 0x11ed178c6c000) {
    iVar5 = 1;
    thedate->wYear = 0x641;
  }
  else {
    uVar4 = uVar4 - 0x16d;
    uVar6 = 2;
    uVar8 = 0x642;
    thedate->wYear = 0x642;
    iVar7 = 0x16d;
    while( true ) {
      iVar5 = (int)(uVar6 * 0x24924925 >> 0x20);
      iVar5 = (int)uVar6 + (((uint)((int)uVar6 - iVar5) >> 1) + iVar5 >> 2) * -7;
      if (uVar4 < (ulong)(long)iVar7) break;
      uVar8 = uVar8 + 1;
      uVar4 = uVar4 - (long)iVar7;
      uVar6 = (ulong)(iVar5 + 1);
      iVar7 = 0x16d;
      thedate->wYear = uVar8;
      if (((uVar8 & 3) == 0) &&
         ((0x28f < (ushort)((ushort)(uVar8 * 0x5c29) >> 2 | uVar8 * 0x4000) ||
          ((ushort)((ushort)(uVar8 * 0x5c29) >> 4 | uVar8 * -0x7000) < 0xa4)))) {
        uVar6 = (ulong)(iVar5 + 2);
        iVar7 = 0x16e;
      }
    }
    if ((uVar8 & 3) == 0) {
      auStack_48[0] = 0x1f;
      auStack_48[1] = 0x1d;
    }
  }
  uVar1 = (uint)uVar4;
  uVar6 = uVar4 & 0xffffffff;
  thedate->wDayOfWeek = (short)(iVar5 + uVar1) + (short)((iVar5 + uVar1) / 7) * -7;
  if (uVar4 < 0x20) {
    uVar8 = 1;
  }
  else {
    uVar8 = 1;
    uVar2 = 0x1f;
    do {
      uVar1 = (int)uVar6 - uVar2;
      uVar6 = (ulong)uVar1;
      uVar3 = (ulong)uVar8;
      uVar8 = uVar8 + 1;
      uVar2 = auStack_48[uVar3];
    } while (uVar2 < uVar1);
  }
  thedate->wMonth = uVar8;
  thedate->wDay = (short)uVar1 + 1;
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * fopen(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen(__filename,__modes);
  return pFVar1;
}



int TNEFGetHeader(TNEFStruct *TNEF,uint *type,uint *size)

{
  TNEFIOStruct *pTVar1;
  int iVar2;
  uint uVar3;
  long in_FS_OFFSET;
  undefined uStack_31;
  long lStack_30;
  
  lStack_30 = *(long *)(in_FS_OFFSET + 0x28);
  if (1 < TNEF->Debug) {
    __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"About to read Component");
  }
  pTVar1 = &TNEF->IO;
  iVar2 = (*(TNEF->IO).ReadProc)(pTVar1,1,1,&uStack_31);
  if (0 < iVar2) {
    if (1 < TNEF->Debug) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"About to read type");
    }
    iVar2 = (*(TNEF->IO).ReadProc)(pTVar1,4,1,type);
    if (iVar2 < 1) {
      if (0 < TNEF->Debug) {
        puts("ERROR: Error reading type");
      }
    }
    else {
      if (1 < TNEF->Debug) {
        __printf_chk(1,"DEBUG(%i/%i):",2);
        __printf_chk(1,"Type = 0x%X",*type);
        putchar(10);
        if (1 < TNEF->Debug) {
          __printf_chk(1,"DEBUG(%i/%i):",2);
          __printf_chk(1,"Type = %u",*type);
          putchar(10);
          if (1 < TNEF->Debug) {
            __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"About to read size");
          }
        }
      }
      iVar2 = (*(TNEF->IO).ReadProc)(pTVar1,4,1,size);
      if (0 < iVar2) {
        if (1 < TNEF->Debug) {
          __printf_chk(1,"DEBUG(%i/%i):",2);
          __printf_chk(1,"Size = %u",*size);
          putchar(10);
        }
        uVar3 = SwapDWord((uchar *)type,4);
        *type = uVar3;
        uVar3 = SwapDWord((uchar *)size,4);
        *size = uVar3;
        iVar2 = 0;
        goto LAB_00104212;
      }
      if (0 < TNEF->Debug) {
        puts("ERROR: Error reading size");
        iVar2 = -3;
        goto LAB_00104212;
      }
    }
  }
  iVar2 = -3;
LAB_00104212:
  if (lStack_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ushort ** __ctype_b_loc(void)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  return ppuVar1;
}



int TNEFCheckForSignature(uint sig)

{
  uint uVar1;
  uint auStack_c [3];
  
  auStack_c[0] = sig;
  uVar1 = SwapDWord((uchar *)auStack_c,4);
  return ((uVar1 == 0x223e9f78) - 2) + (uint)(uVar1 == 0x223e9f78);
}



void FUN_00102470(void)

{
  __sprintf_chk();
  return;
}



void processEntry deregister_tm_clones(void)

{
  if ((false) && (true)) {
    _ITM_deregisterTMCloneTable();
    return;
  }
  return;
}



void register_tm_clones(void)

{
  if ((false) && (true)) {
    _ITM_registerTMCloneTable();
    return;
  }
  return;
}



void __do_global_dtors_aux(undefined8 param_1,undefined8 param_2,undefined8 param_3)

{
  undefined8 extraout_RDX;
  
  if (completed_8061 == '\0') {
    if (true) {
      FUN_00102250(__dso_handle);
      param_3 = extraout_RDX;
    }
    deregister_tm_clones(param_3,0x10251c);
    completed_8061 = 1;
    return;
  }
  return;
}



void frame_dummy(void)

{
  register_tm_clones();
  return;
}



// WARNING: Unknown calling convention

int TNEFMemory_Open(TNEFIOStruct *IO)

{
                    // WARNING: Load size is inaccurate
  *(undefined8 *)((long)IO->data + 8) = *IO->data;
  return 0;
}



// WARNING: Unknown calling convention

int TNEFMemory_Close(TNEFIOStruct *IO)

{
  return 0;
}



int TNEFParentID(TNEFStruct *TNEF,int id,char *data,int size)

{
  uint uVar1;
  uint uVar2;
  long lVar3;
  ulong uVar4;
  ulong uVar5;
  
  if (0x31 < (uint)size) {
    size = 0x32;
  }
  if ((uint)size < 8) {
    if ((size & 4U) == 0) {
      if ((size != 0) && (TNEF->parentID[0] = *data, (size & 2U) != 0)) {
        *(undefined2 *)(TNEF->messageID + (ulong)(uint)size + 0x30) =
             *(undefined2 *)(data + ((ulong)(uint)size - 2));
      }
    }
    else {
      *(undefined4 *)TNEF->parentID = *(undefined4 *)data;
      *(undefined4 *)(TNEF->messageID + (ulong)(uint)size + 0x2e) =
           *(undefined4 *)(data + ((ulong)(uint)size - 4));
    }
  }
  else {
    *(undefined8 *)TNEF->parentID = *(undefined8 *)data;
    uVar5 = (ulong)(TNEF->parentID + 8) & 0xfffffffffffffff8;
    *(undefined8 *)(TNEF->messageID + (ulong)(uint)size + 0x2a) =
         *(undefined8 *)(data + ((ulong)(uint)size - 8));
    lVar3 = (long)TNEF + (0xba - uVar5);
    uVar2 = size + (int)lVar3 & 0xfffffff8;
    if (7 < uVar2) {
      uVar1 = 0;
      do {
        uVar4 = (ulong)uVar1;
        uVar1 = uVar1 + 8;
        *(undefined8 *)(uVar5 + uVar4) = *(undefined8 *)(data + (uVar4 - lVar3));
      } while (uVar1 < uVar2);
      return 0;
    }
  }
  return 0;
}



int TNEFMessageID(TNEFStruct *TNEF,int id,char *data,int size)

{
  uint uVar1;
  uint uVar2;
  long lVar3;
  ulong uVar4;
  ulong uVar5;
  
  if (0x31 < (uint)size) {
    size = 0x32;
  }
  if ((uint)size < 8) {
    if ((size & 4U) == 0) {
      if ((size != 0) && (TNEF->messageID[0] = *data, (size & 2U) != 0)) {
        *(undefined2 *)(TNEF->messageClass + (ulong)(uint)size + 0x30) =
             *(undefined2 *)(data + ((ulong)(uint)size - 2));
      }
    }
    else {
      *(undefined4 *)TNEF->messageID = *(undefined4 *)data;
      *(undefined4 *)(TNEF->messageClass + (ulong)(uint)size + 0x2e) =
           *(undefined4 *)(data + ((ulong)(uint)size - 4));
    }
  }
  else {
    *(undefined8 *)TNEF->messageID = *(undefined8 *)data;
    uVar5 = (ulong)(TNEF->messageID + 8) & 0xfffffffffffffff8;
    *(undefined8 *)(TNEF->messageClass + (ulong)(uint)size + 0x2a) =
         *(undefined8 *)(data + ((ulong)(uint)size - 8));
    lVar3 = (long)TNEF + (0x88 - uVar5);
    uVar2 = size + (int)lVar3 & 0xfffffff8;
    if (7 < uVar2) {
      uVar1 = 0;
      do {
        uVar4 = (ulong)uVar1;
        uVar1 = uVar1 + 8;
        *(undefined8 *)(uVar5 + uVar4) = *(undefined8 *)(data + (uVar4 - lVar3));
      } while (uVar1 < uVar2);
      return 0;
    }
  }
  return 0;
}



int TNEFMessageClass(TNEFStruct *TNEF,int id,char *data,int size)

{
  uint uVar1;
  uint uVar2;
  long lVar3;
  ulong uVar4;
  ulong uVar5;
  
  if (0x31 < (uint)size) {
    size = 0x32;
  }
  if ((uint)size < 8) {
    if ((size & 4U) == 0) {
      if ((size != 0) && (TNEF->messageClass[0] = *data, (size & 2U) != 0)) {
        *(undefined2 *)(TNEF->messageStatus + (ulong)(uint)size + 8) =
             *(undefined2 *)(data + ((ulong)(uint)size - 2));
      }
    }
    else {
      *(undefined4 *)TNEF->messageClass = *(undefined4 *)data;
      *(undefined4 *)(TNEF->messageStatus + (ulong)(uint)size + 6) =
           *(undefined4 *)(data + ((ulong)(uint)size - 4));
    }
  }
  else {
    *(undefined8 *)TNEF->messageClass = *(undefined8 *)data;
    uVar5 = (ulong)(TNEF->messageClass + 8) & 0xfffffffffffffff8;
    *(undefined8 *)(TNEF->messageStatus + (ulong)(uint)size + 2) =
         *(undefined8 *)(data + ((ulong)(uint)size - 8));
    lVar3 = (long)TNEF + (0x56 - uVar5);
    uVar2 = size + (int)lVar3 & 0xfffffff8;
    if (7 < uVar2) {
      uVar1 = 0;
      do {
        uVar4 = (ulong)uVar1;
        uVar1 = uVar1 + 8;
        *(undefined8 *)(uVar5 + uVar4) = *(undefined8 *)(data + (uVar4 - lVar3));
      } while (uVar1 < uVar2);
      return 0;
    }
  }
  return 0;
}



int TNEFMemory_Read(TNEFIOStruct *IO,int size,int count,void *dest)

{
  long *plVar1;
  void *__src;
  size_t __n;
  
  __n = (size_t)(size * count);
  plVar1 = (long *)IO->data;
  __src = (void *)plVar1[1];
  if ((plVar1[2] + *plVar1) - (long)__src < (long)__n) {
    count = -1;
  }
  else {
    if (2 < *(int *)(plVar1 + 3)) {
      __printf_chk(1,"DEBUG(%i/%i):",3);
      __printf_chk(1,"Copying %i bytes",size * count);
      putchar(10);
      __src = (void *)plVar1[1];
    }
    memcpy(dest,__src,__n);
    plVar1[1] = plVar1[1] + __n;
  }
  return count;
}



int TNEFCodePage(TNEFStruct *TNEF,int id,char *data,int size)

{
  uchar *__dest;
  
  (TNEF->CodePage).size = size;
  __dest = (uchar *)calloc((long)size,1);
  (TNEF->CodePage).data = __dest;
  memcpy(__dest,data,(long)size);
  return 0;
}



int TNEFBody(TNEFStruct *TNEF,int id,char *data,int size)

{
  uchar *__dest;
  
  (TNEF->body).size = size;
  __dest = (uchar *)calloc((long)size,1);
  (TNEF->body).data = __dest;
  memcpy(__dest,data,(long)size);
  return 0;
}



int TNEFOriginalMsgClass(TNEFStruct *TNEF,int id,char *data,int size)

{
  uchar *__dest;
  
  (TNEF->OriginalMessageClass).size = size;
  __dest = (uchar *)calloc((long)size,1);
  (TNEF->OriginalMessageClass).data = __dest;
  memcpy(__dest,data,(long)size);
  return 0;
}



int TNEFFromHandler(TNEFStruct *TNEF,int id,char *data,int size)

{
  uchar *__dest;
  
  __dest = (uchar *)calloc((long)size,1);
  (TNEF->from).size = size;
  (TNEF->from).data = __dest;
  memcpy(__dest,data,(long)size);
  return 0;
}



int TNEFIcon(TNEFStruct *TNEF,int id,char *data,int size)

{
  Attachment *pAVar1;
  uchar *__dest;
  Attachment *pAVar2;
  
  pAVar1 = &TNEF->starting_attach;
  do {
    pAVar2 = pAVar1;
    pAVar1 = pAVar2->next;
  } while (pAVar2->next != (Attachment *)0x0);
  (pAVar2->IconData).size = size;
  __dest = (uchar *)calloc((long)size,1);
  (pAVar2->IconData).data = __dest;
  memcpy(__dest,data,(long)size);
  return 0;
}



int TNEFAttachmentFilename(TNEFStruct *TNEF,int id,char *data,int size)

{
  Attachment *pAVar1;
  uchar *__dest;
  Attachment *pAVar2;
  
  pAVar1 = &TNEF->starting_attach;
  do {
    pAVar2 = pAVar1;
    pAVar1 = pAVar2->next;
  } while (pAVar2->next != (Attachment *)0x0);
  (pAVar2->Title).size = size;
  __dest = (uchar *)calloc((long)size,1);
  (pAVar2->Title).data = __dest;
  memcpy(__dest,data,(long)size);
  return 0;
}



int TNEFAttachmentSave(TNEFStruct *TNEF,int id,char *data,int size)

{
  Attachment *pAVar1;
  uchar *__dest;
  Attachment *pAVar2;
  
  pAVar1 = &TNEF->starting_attach;
  do {
    pAVar2 = pAVar1;
    pAVar1 = pAVar2->next;
  } while (pAVar2->next != (Attachment *)0x0);
  __dest = (uchar *)calloc(1,(long)size);
  (pAVar2->FileData).size = size;
  (pAVar2->FileData).data = __dest;
  memcpy(__dest,data,(long)size);
  return 0;
}



int TNEFSubjectHandler(TNEFStruct *TNEF,int id,char *data,int size)

{
  uchar *puVar1;
  
  puVar1 = (TNEF->subject).data;
  if (puVar1 != (uchar *)0x0) {
    free(puVar1);
  }
  puVar1 = (uchar *)calloc((long)size,1);
  (TNEF->subject).size = size;
  (TNEF->subject).data = puVar1;
  memcpy(puVar1,data,(long)size);
  return 0;
}



int TNEFFile_Open(TNEFIOStruct *IO)

{
  undefined8 *puVar1;
  FILE *pFVar2;
  
  puVar1 = (undefined8 *)IO->data;
  if (2 < *(int *)(puVar1 + 2)) {
    __printf_chk(1,"DEBUG(%i/%i):",3);
    __printf_chk(1,"Opening %s",*puVar1);
    putchar(10);
  }
  pFVar2 = fopen((char *)*puVar1,"rb");
  puVar1[1] = pFVar2;
  return -(uint)(pFVar2 == (FILE *)0x0);
}



int TNEFFile_Read(TNEFIOStruct *IO,int size,int count,void *dest)

{
  void *pvVar1;
  FILE *__stream;
  int iVar2;
  size_t sVar3;
  
  pvVar1 = IO->data;
  if (2 < *(int *)((long)pvVar1 + 0x10)) {
    __printf_chk(1,"DEBUG(%i/%i):",3);
    __printf_chk(1,"Reading %i blocks of %i size",count,size);
    putchar(10);
  }
  __stream = *(FILE **)((long)pvVar1 + 8);
  if (__stream == (FILE *)0x0) {
    iVar2 = -1;
  }
  else {
    sVar3 = fread(dest,(long)size,(long)count,__stream);
    iVar2 = (int)sVar3;
  }
  return iVar2;
}



int TNEFFile_Close(TNEFIOStruct *IO)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)IO->data;
  if (2 < *(int *)(puVar1 + 2)) {
    __printf_chk(1,"DEBUG(%i/%i):",3);
    __printf_chk(1,"Closing file %s",*puVar1);
    putchar(10);
  }
  if ((FILE *)puVar1[1] != (FILE *)0x0) {
    fclose((FILE *)puVar1[1]);
    puVar1[1] = 0;
  }
  return 0;
}



int TNEFDefaultHandler(TNEFStruct *TNEF,int id,char *data,int size)

{
  if (TNEF->Debug < 1) {
    return 0;
  }
  __printf_chk(1,"%s: [%i] %s\n",(long)id * 0x38 + 0x118024,size,data);
  return 0;
}



ushort SwapWord(uchar *p,int size)

{
  ushort uVar1;
  long in_FS_OFFSET;
  
  uVar1 = 0;
  if (size != 0) {
    uVar1 = (ushort)*p;
    if (size != 1) {
      uVar1 = CONCAT11(p[1],*p);
    }
  }
  if (*(long *)(in_FS_OFFSET + 0x28) != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



int TNEFVersion(TNEFStruct *TNEF,int id,char *data,int size)

{
  ushort uVar1;
  ushort uVar2;
  
  uVar1 = SwapWord((uchar *)data,size);
  uVar2 = SwapWord((uchar *)(data + 2),size + -2);
  FUN_00102470(TNEF,1,10,"TNEF%i.%i",uVar2,uVar1);
  return 0;
}



int TNEFSentFor(TNEFStruct *TNEF,int id,char *data,int size)

{
  ushort uVar1;
  uchar *p;
  uchar *puVar2;
  uchar *puVar3;
  
  p = (uchar *)data;
  if (0 < (long)size) {
    do {
      puVar2 = p + 2;
      uVar1 = SwapWord(p,2);
      if (0 < TNEF->Debug) {
        __printf_chk(1,"Sent For : %s",puVar2);
      }
      puVar2 = puVar2 + uVar1;
      puVar3 = puVar2 + 2;
      uVar1 = SwapWord(puVar2,2);
      if (0 < TNEF->Debug) {
        __printf_chk(1,"<%s>\n",puVar3);
      }
      p = puVar3 + uVar1;
    } while ((long)(puVar3 + uVar1) - (long)data < (long)size);
  }
  return 0;
}



int TNEFDateHandler(TNEFStruct *TNEF,int id,char *data,int size)

{
  uint uVar1;
  Attachment *pAVar2;
  ushort uVar3;
  Attachment *pAVar4;
  dtr *pdVar5;
  dtr *pdVar6;
  ushort *puVar7;
  int iVar8;
  
  uVar1 = TNEFList[id].id;
  if (0x38020 < uVar1) goto switchD_00102e6f_caseD_38007;
  if (uVar1 < 0x38005) {
    if (uVar1 == 0x30006) {
      pdVar5 = &TNEF->DateStart;
    }
    else {
      if (uVar1 != 0x30007) goto switchD_00102e6f_caseD_38007;
      pdVar5 = &TNEF->DateEnd;
    }
    goto LAB_00102e88;
  }
  if (uVar1 - 0x38005 < 0x1c) {
    pAVar2 = &TNEF->starting_attach;
    switch(uVar1) {
    case 0x38005:
      pdVar5 = &TNEF->dateSent;
      break;
    case 0x38006:
      pdVar5 = &TNEF->dateReceived;
      break;
    default:
      goto switchD_00102e6f_caseD_38007;
    case 0x38012:
      do {
        pAVar4 = pAVar2;
        pAVar2 = pAVar4->next;
      } while (pAVar2 != (Attachment *)0x0);
      pdVar5 = &pAVar4->CreateDate;
      break;
    case 0x38013:
      do {
        pAVar4 = pAVar2;
        pAVar2 = pAVar4->next;
      } while (pAVar2 != (Attachment *)0x0);
      pdVar5 = &pAVar4->ModifyDate;
      break;
    case 0x38020:
      pdVar5 = &TNEF->dateModified;
    }
LAB_00102e88:
    pdVar6 = pdVar5;
    do {
      puVar7 = &pdVar6->wMonth;
      uVar3 = SwapWord((uchar *)data,2);
      pdVar6->wYear = uVar3;
      pdVar6 = (dtr *)puVar7;
      data = (char *)((uchar *)data + 2);
    } while ((dtr *)puVar7 != pdVar5 + 1);
    iVar8 = 0;
  }
  else {
switchD_00102e6f_caseD_38007:
    iVar8 = -7;
    if (0 < TNEF->Debug) {
      puts("MISSING CASE");
    }
  }
  return iVar8;
}



uint SwapDWord(uchar *p,int size)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  BYTES2DWORD converter;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  lVar1 = 0;
  converter.dword = 0;
  iVar2 = 4;
  if ((uint)size < 5) {
    iVar2 = size;
  }
  if (size != 0) {
    do {
      converter.bytes[lVar1] = p[lVar1];
      lVar1 = lVar1 + 1;
    } while ((int)lVar1 < iVar2);
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return converter.dword;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int TNEFRecipTable(TNEFStruct *TNEF,int id,char *data,int size)

{
  SwapDWord((uchar *)data,4);
  return 0;
}



int TNEFPriority(TNEFStruct *TNEF,int id,char *data,int size)

{
  uint uVar1;
  undefined4 uVar2;
  
  uVar1 = SwapDWord((uchar *)data,size);
  if (uVar1 == 2) {
    *(undefined4 *)TNEF->priority = 0x6d726f6e;
    *(undefined2 *)(TNEF->priority + 4) = 0x6c61;
    TNEF->priority[6] = '\0';
    return 0;
  }
  if (uVar1 != 3) {
    uVar2 = 0x776f6c;
    if (uVar1 != 1) {
      uVar2 = 0x412f4e;
    }
    *(undefined4 *)TNEF->priority = uVar2;
    return 0;
  }
  *(undefined4 *)TNEF->priority = 0x68676968;
  TNEF->priority[4] = '\0';
  return 0;
}



ulonglong SwapDDWord(uchar *p,int size)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  BYTES2DDWORD converter;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  lVar1 = 0;
  converter.ddword = 0;
  iVar2 = 8;
  if ((uint)size < 9) {
    iVar2 = size;
  }
  if (size == 0) {
    converter.ddword = 0;
  }
  else {
    do {
      converter.bytes[lVar1] = p[lVar1];
      lVar1 = lVar1 + 1;
    } while ((int)lVar1 < iVar2);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return converter.ddword;
}



char * to_utf8(int len,char *buf)

{
  uchar *puVar1;
  byte *pbVar2;
  byte bVar3;
  byte bVar4;
  ushort uVar5;
  byte *pbVar6;
  byte *pbVar7;
  int iVar8;
  
  pbVar6 = (byte *)malloc((long)((len * 3) / 2 + 1));
  pbVar7 = pbVar6;
  if (1 < len) {
    puVar1 = (uchar *)(buf + (ulong)(len - 2U >> 1) * 2 + 2);
    iVar8 = 0;
    do {
      while( true ) {
        uVar5 = SwapWord((uchar *)buf,2);
        pbVar2 = pbVar6 + iVar8;
        pbVar7 = pbVar6 + (iVar8 + 1);
        if (0x7f < uVar5) break;
        *pbVar2 = (byte)uVar5;
        iVar8 = iVar8 + 1;
LAB_001030fd:
        buf = (char *)((uchar *)buf + 2);
        if ((uchar *)buf == puVar1) goto LAB_00103164;
      }
      bVar4 = (byte)uVar5 & 0x3f | 0x80;
      bVar3 = (byte)(uVar5 >> 6);
      if (0x7fe < uVar5) {
        *pbVar2 = (byte)(uVar5 >> 0xc) | 0xe0;
        *pbVar7 = bVar3 & 0x3f | 0x80;
        pbVar6[iVar8 + 2] = bVar4;
        pbVar7 = pbVar6 + (iVar8 + 3);
        iVar8 = iVar8 + 3;
        goto LAB_001030fd;
      }
      buf = (char *)((uchar *)buf + 2);
      *pbVar2 = bVar3 | 0xc0;
      *pbVar7 = bVar4;
      pbVar7 = pbVar6 + (iVar8 + 2);
      iVar8 = iVar8 + 2;
    } while ((uchar *)buf != puVar1);
  }
LAB_00103164:
  *pbVar7 = 0;
  return (char *)pbVar6;
}



void TNEFFillMapi(TNEFStruct *TNEF,uchar *data,uint size,MAPIProps *p)

{
  uchar uVar1;
  int iVar2;
  undefined8 uVar3;
  uint uVar4;
  uint uVar5;
  MAPIProperty *pMVar6;
  uchar *__dest;
  uchar *puVar7;
  variableLength *pvVar8;
  void *pvVar9;
  ushort uVar10;
  ulong uVar11;
  long lVar12;
  ulong uVar13;
  char *pcVar14;
  int iVar15;
  undefined8 *puVar16;
  uint uVar17;
  uchar *puVar18;
  long in_FS_OFFSET;
  bool bVar19;
  int local_80;
  uint local_7c;
  ulong local_70;
  ushort temp_word;
  uint temp_dword;
  ulonglong temp_ddword;
  long local_40;
  
  puVar18 = data + 4;
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  uVar4 = SwapDWord(data,4);
  p->count = uVar4;
  pMVar6 = (MAPIProperty *)calloc((ulong)uVar4,0x30);
  p->properties = pMVar6;
  if (uVar4 == 0) {
    lVar12 = 4;
  }
  else {
    local_7c = 0;
    iVar15 = -1;
    do {
      if (iVar15 == -1) {
        uVar4 = SwapDWord(puVar18,4);
        pMVar6->custom = 0;
        pMVar6->id = uVar4;
        pMVar6->count = 1;
        pMVar6->namedproperty = 0;
        if ((int)uVar4 < 0) {
          uVar3 = *(undefined8 *)(puVar18 + 0xc);
          puVar7 = puVar18 + 0x18;
          *(undefined8 *)pMVar6->guid = *(undefined8 *)(puVar18 + 4);
          *(undefined8 *)(pMVar6->guid + 8) = uVar3;
          uVar4 = SwapDWord(puVar18 + 0x14,4);
          if (uVar4 == 0) {
            uVar4 = SwapDWord(puVar7,4);
            *(short *)((long)&pMVar6->id + 2) = (short)uVar4;
            puVar7 = puVar18 + 0x1c;
          }
          else {
            pMVar6->namedproperty = uVar4;
            lVar12 = (ulong)(uVar4 - 1) << 4;
            pvVar8 = (variableLength *)calloc((ulong)uVar4,0x10);
            pMVar6->propnames = pvVar8;
            do {
              uVar4 = SwapDWord(puVar7,4);
              uVar13 = (ulong)uVar4;
              puVar16 = (undefined8 *)((long)&pMVar6->propnames->data + lVar12);
              pvVar9 = calloc(uVar13,1);
              *(uint *)(puVar16 + 1) = uVar4;
              *puVar16 = pvVar9;
              if (uVar4 >> 1 != 0) {
                uVar11 = 0;
                while( true ) {
                  *(uchar *)((long)pvVar9 + uVar11) = puVar7[uVar11 * 2 + 4];
                  if ((uVar4 >> 1) - 1 == uVar11) break;
                  pvVar9 = *(void **)((long)&pMVar6->propnames->data + lVar12);
                  uVar11 = uVar11 + 1;
                }
              }
              if ((uVar4 & 3) != 0) {
                uVar13 = (ulong)((uVar4 + 4) - (uVar4 & 3));
              }
              lVar12 = lVar12 + -0x10;
              puVar7 = puVar7 + uVar13 + 4;
            } while (lVar12 != -0x10);
          }
          pMVar6->custom = 1;
        }
        else {
          puVar7 = puVar18 + 4;
        }
        if (2 < TNEF->Debug) {
          __printf_chk(1,"DEBUG(%i/%i):",3);
          __printf_chk(1,"Type id = %04x, Prop id = %04x",pMVar6->id & 0xffff,pMVar6->id >> 0x10);
          putchar(10);
        }
        uVar4 = pMVar6->id;
        uVar10 = (ushort)uVar4;
        bVar19 = (uVar4 & 0x1000) != 0;
        if (bVar19) {
          iVar15 = 0;
          puVar18 = puVar7 + 4;
          pMVar6->id = uVar4 & 0xffff0000 | (uVar4 & 0xffff) - 0x1000;
          uVar5 = SwapDWord(puVar7,4);
          uVar4 = pMVar6->id;
          pMVar6->count = uVar5;
          local_80 = 0;
          uVar10 = (ushort)uVar4;
        }
        else {
          local_80 = -1;
          uVar5 = pMVar6->count;
          puVar18 = puVar7;
        }
        bVar19 = !bVar19;
        uVar17 = (uint)uVar10;
        pvVar8 = (variableLength *)calloc((ulong)uVar5,0x10);
        local_7c = local_7c + 1;
        pMVar6->data = pvVar8;
      }
      else {
        iVar15 = iVar15 + 1;
        uVar4 = pMVar6->id;
        bVar19 = false;
        uVar17 = uVar4 & 0xffff;
        pvVar8 = pMVar6->data + iVar15;
        local_80 = iVar15;
      }
      if (uVar17 < 0x49) {
        if ((1 < uVar17) && (true)) {
          switch(uVar17) {
          case 2:
            pvVar8->size = 2;
            puVar7 = (uchar *)calloc(2,2);
            pvVar8->data = puVar7;
            temp_word = SwapWord(puVar18,2);
            memcpy(pvVar8->data,&temp_word,(long)pvVar8->size);
            uVar4 = pMVar6->id;
            puVar18 = puVar18 + 4;
            break;
          case 3:
          case 4:
          case 6:
          case 7:
          case 10:
          case 0xb:
            pvVar8->size = 4;
            puVar7 = (uchar *)calloc(4,1);
            pvVar8->data = puVar7;
            temp_dword = SwapDWord(puVar18,4);
            memcpy(pvVar8->data,&temp_dword,(long)pvVar8->size);
            uVar4 = pMVar6->id;
            puVar18 = puVar18 + 4;
            break;
          case 5:
          case 0x14:
          case 0x40:
            pvVar8->size = 8;
            puVar7 = (uchar *)calloc(8,1);
            pvVar8->data = puVar7;
            temp_ddword = SwapDDWord(puVar18,8);
            memcpy(pvVar8->data,&temp_ddword,(long)pvVar8->size);
            uVar4 = pMVar6->id;
            puVar18 = puVar18 + 8;
            break;
          case 0xd:
          case 0x1e:
          case 0x1f:
            goto switchD_0010328e_caseD_d;
          case 0x48:
            pvVar8->size = 0x10;
            puVar7 = (uchar *)calloc(0x10,1);
            pvVar8->data = puVar7;
            uVar3 = *(undefined8 *)(puVar18 + 8);
            *(undefined8 *)puVar7 = *(undefined8 *)puVar18;
            *(undefined8 *)(puVar7 + 8) = uVar3;
            puVar18 = puVar18 + 0x10;
          }
        }
      }
      else if (uVar17 == 0x102) {
switchD_0010328e_caseD_d:
        puVar7 = puVar18 + 4;
        if (iVar15 == -1) {
          uVar4 = SwapDWord(puVar18,4);
          pvVar8->size = uVar4;
          puVar7 = puVar18 + 8;
          puVar18 = puVar18 + 4;
        }
        uVar5 = SwapDWord(puVar18,4);
        pvVar8->size = uVar5;
        if (uVar5 == 0) {
          pvVar8->data = (uchar *)0x0;
          uVar4 = pMVar6->id;
          uVar13 = 0;
        }
        else {
          uVar4 = pMVar6->id;
          if ((short)uVar4 == 0x1f) {
            puVar18 = (uchar *)to_utf8(uVar5,(char *)puVar7);
            uVar4 = pMVar6->id;
            pvVar8->data = puVar18;
          }
          else {
            puVar18 = (uchar *)calloc((long)(int)uVar5,1);
            pvVar8->data = puVar18;
            memcpy(puVar18,puVar7,(long)(int)uVar5);
          }
          uVar5 = pvVar8->size;
          uVar13 = (ulong)uVar5;
          if ((uVar5 & 3) != 0) {
            uVar13 = (ulong)((uVar5 + 4) - (uVar5 & 3));
          }
        }
        puVar18 = puVar7 + uVar13;
      }
      uVar5 = uVar4 >> 0x10;
      if (uVar4 < 0x710000) {
        if ((0x36 < uVar5) && ((0x200000000040003U >> ((ulong)(uVar5 - 0x37) & 0x3f) & 1) != 0)) {
LAB_0010343b:
          if (TNEF->Debug < 3) {
            if ((TNEF->subject).size == 0) {
LAB_00103455:
              __dest = (uchar *)calloc((ulong)size,1);
              iVar2 = pvVar8->size;
              (TNEF->subject).data = __dest;
              puVar7 = pvVar8->data;
              (TNEF->subject).size = iVar2;
              puVar7 = (uchar *)memcpy(__dest,puVar7,(long)pvVar8->size);
              if (iVar2 != 0) {
                lVar12 = 0;
                while( true ) {
                  uVar1 = puVar7[lVar12];
                  if (((uVar1 == '/') || (uVar1 == '\\')) || (uVar1 == '\0')) {
                    puVar7[lVar12] = '_';
                  }
                  lVar12 = lVar12 + 1;
                  if ((TNEF->subject).size == (int)lVar12) break;
                  puVar7 = (TNEF->subject).data;
                }
              }
            }
          }
          else {
            __printf_chk(1,"DEBUG(%i/%i): %s\n",3,TNEF->Debug,"Got a Subject");
            if ((TNEF->subject).size == 0) {
              if (2 < TNEF->Debug) {
                __printf_chk(1,"DEBUG(%i/%i): %s\n",3,TNEF->Debug,"Assigning a Subject");
              }
              goto LAB_00103455;
            }
          }
        }
      }
      else if (uVar5 == 0xe1d) goto LAB_0010343b;
      if ((pMVar6->count - 1 == local_80) || (bVar19)) {
        pMVar6 = pMVar6 + 1;
        iVar15 = -1;
      }
    } while (local_7c < p->count);
    lVar12 = (long)puVar18 - (long)data;
  }
  local_70 = (ulong)size;
  if (lVar12 < (long)local_70) {
    if (0 < TNEF->Debug) {
      puts("ERROR DURING MAPI READ");
      __printf_chk(1,"Read %td bytes, Expected %u bytes\n",lVar12,size);
      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
        pcVar14 = "%td bytes missing\n";
        lVar12 = local_70 - lVar12;
LAB_00103829:
        __printf_chk(1,pcVar14,lVar12);
        return;
      }
      goto LAB_00103943;
    }
  }
  else if (((long)local_70 < lVar12) && (0 < TNEF->Debug)) {
    puts("ERROR DURING MAPI READ");
    __printf_chk(1,"Read %td bytes, Expected %u bytes\n",lVar12,size);
    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
      lVar12 = lVar12 - local_70;
      pcVar14 = "%li bytes extra\n";
      goto LAB_00103829;
    }
    goto LAB_00103943;
  }
  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
LAB_00103943:
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int TNEFAttachmentMAPI(TNEFStruct *TNEF,int id,char *data,int size)

{
  Attachment *pAVar1;
  Attachment *pAVar2;
  
  pAVar1 = &TNEF->starting_attach;
  do {
    pAVar2 = pAVar1;
    pAVar1 = pAVar2->next;
  } while (pAVar1 != (Attachment *)0x0);
  TNEFFillMapi(TNEF,(uchar *)data,size,&pAVar2->MAPI);
  return 0;
}



void TNEFPrintDate(dtr Date)

{
  long lVar1;
  uint uVar2;
  ushort uVar3;
  uint uVar4;
  long in_FS_OFFSET;
  ushort uStack_164;
  char days [7] [15];
  char months [12] [15];
  
  uVar4 = Date._8_4_ >> 0x10;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  builtin_strncpy(days[0],"Sunday",7);
  days[0][7] = '\0';
  builtin_strncpy(days[1],"Monday",7);
  days[1][7] = '\0';
  days[1][0xc] = '\0';
  days[1][0xd] = '\0';
  days[2][0xc] = '\0';
  days[2][0xd] = '\0';
  days[0][0xc] = '\0';
  days[0][0xd] = '\0';
  builtin_strncpy(days[2],"Tuesday",8);
  builtin_strncpy(days[3],"Wednesday",10);
  days[3][0xc] = '\0';
  days[3][0xd] = '\0';
  builtin_strncpy(days[4],"Thursday",9);
  days[4][0xc] = '\0';
  days[4][0xd] = '\0';
  builtin_strncpy(days[5],"Friday",7);
  days[5][7] = '\0';
  days[5][0xc] = '\0';
  days[5][0xd] = '\0';
  days[0][8] = '\0';
  days[0][9] = '\0';
  days[0][10] = '\0';
  days[0][0xb] = '\0';
  days[0][0xe] = '\0';
  days[1][8] = '\0';
  days[1][9] = '\0';
  days[1][10] = '\0';
  days[1][0xb] = '\0';
  days[1][0xe] = '\0';
  days[2][8] = '\0';
  days[2][9] = '\0';
  days[2][10] = '\0';
  days[2][0xb] = '\0';
  days[2][0xe] = '\0';
  days[3][10] = '\0';
  days[3][0xb] = '\0';
  days[3][0xe] = '\0';
  days[4][9] = '\0';
  days[4][10] = '\0';
  days[4][0xb] = '\0';
  days[4][0xe] = '\0';
  days[5][8] = '\0';
  days[5][9] = '\0';
  days[5][10] = '\0';
  days[5][0xb] = '\0';
  days[5][0xe] = '\0';
  builtin_strncpy(days[6],"Saturday",9);
  months[1][0xc] = '\0';
  months[1][0xd] = '\0';
  months[2][0xc] = '\0';
  months[2][0xd] = '\0';
  builtin_strncpy(months[0],"January",8);
  months[3][0xc] = '\0';
  months[3][0xd] = '\0';
  builtin_strncpy(months[1],"February",9);
  builtin_strncpy(months[2],"March",6);
  months[2][6] = '\0';
  months[2][7] = '\0';
  builtin_strncpy(months[3],"April",6);
  months[3][6] = '\0';
  months[3][7] = '\0';
  months[4][0xc] = '\0';
  months[4][0xd] = '\0';
  days[6][0xc] = '\0';
  days[6][0xd] = '\0';
  months[6][0xc] = '\0';
  months[6][0xd] = '\0';
  builtin_strncpy(months[7],"August",7);
  months[7][7] = '\0';
  days[6][9] = '\0';
  days[6][10] = '\0';
  days[6][0xb] = '\0';
  days[6][0xe] = '\0';
  months[0][8] = '\0';
  months[0][9] = '\0';
  months[0][10] = '\0';
  months[0][0xb] = '\0';
  months[0][0xc] = '\0';
  months[0][0xd] = '\0';
  months[0][0xe] = '\0';
  months[1][9] = '\0';
  months[1][10] = '\0';
  months[1][0xb] = '\0';
  months[1][0xe] = '\0';
  months[2][8] = '\0';
  months[2][9] = '\0';
  months[2][10] = '\0';
  months[2][0xb] = '\0';
  months[2][0xe] = '\0';
  months[3][8] = '\0';
  months[3][9] = '\0';
  months[3][10] = '\0';
  months[3][0xb] = '\0';
  months[3][0xe] = '\0';
  builtin_strncpy(months[4],"May",4);
  months[4][4] = '\0';
  months[4][5] = '\0';
  months[4][6] = '\0';
  months[4][7] = '\0';
  months[4][8] = '\0';
  months[4][9] = '\0';
  months[4][10] = '\0';
  months[4][0xb] = '\0';
  months[4][0xe] = '\0';
  builtin_strncpy(months[5],"June",5);
  months[5][5] = '\0';
  months[5][6] = '\0';
  months[5][7] = '\0';
  months[5][8] = '\0';
  months[5][9] = '\0';
  months[5][10] = '\0';
  months[5][0xb] = '\0';
  months[5][0xc] = '\0';
  months[5][0xd] = '\0';
  months[5][0xe] = '\0';
  builtin_strncpy(months[6],"July",5);
  months[6][5] = '\0';
  months[6][6] = '\0';
  months[6][7] = '\0';
  months[6][8] = '\0';
  months[6][9] = '\0';
  months[6][10] = '\0';
  months[6][0xb] = '\0';
  months[6][0xe] = '\0';
  months[7][8] = '\0';
  months[7][9] = '\0';
  months[7][10] = '\0';
  months[7][0xb] = '\0';
  builtin_strncpy(months[8],"September",10);
  months[7][0xc] = '\0';
  months[7][0xd] = '\0';
  months[8][0xc] = '\0';
  months[8][0xd] = '\0';
  months[7][0xe] = '\0';
  months[8][10] = '\0';
  months[8][0xb] = '\0';
  months[8][0xe] = '\0';
  builtin_strncpy(months[9],"October",8);
  months[9][8] = '\0';
  months[9][9] = '\0';
  months[9][10] = '\0';
  months[9][0xb] = '\0';
  months[9][0xc] = '\0';
  months[9][0xd] = '\0';
  months[9][0xe] = '\0';
  builtin_strncpy(months[10],"November",9);
  months[10][9] = '\0';
  months[10][10] = '\0';
  months[10][0xb] = '\0';
  months[10][0xc] = '\0';
  months[10][0xd] = '\0';
  months[10][0xe] = '\0';
  builtin_strncpy(months[0xb],"December",9);
  months[0xb][9] = '\0';
  months[0xb][10] = '\0';
  months[0xb][0xb] = '\0';
  months[0xb][0xc] = '\0';
  months[0xb][0xd] = '\0';
  months[0xb][0xe] = '\0';
  if (Date.wDayOfWeek < 7) {
    __printf_chk(1,&DAT_00107101,days + Date.wDayOfWeek);
  }
  if ((ushort)(Date.wMonth - 1) < 0xc) {
    __printf_chk(1,&DAT_00107101,months + (int)(Date.wMonth - 1));
  }
  uStack_164 = Date.wDay;
  __printf_chk(1,"%hu, %hu ",uStack_164,Date._0_8_ & 0xffff);
  uVar2 = Date._8_4_ & 0xffff;
  uVar3 = Date.wHour;
  if (uVar3 < 0xd) {
    if (uVar3 == 0xc) {
      __printf_chk(1,"%hu:%02hu:%02hu pm",0xc,uVar2,uVar4);
    }
    else {
      __printf_chk(1,"%hu:%02hu:%02hu am",Date._0_8_ >> 0x30,uVar2,uVar4);
    }
  }
  else {
    __printf_chk(1,"%i:%02hu:%02hu pm",uVar3 - 0xc,uVar2,uVar4);
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int TNEFHexBreakdown(TNEFStruct *TNEF,int id,char *data,int size)

{
  ulong uVar1;
  
  if (TNEF->Debug == 0) {
    return 0;
  }
  __printf_chk(1,"%s: [%i bytes] \n",(long)id * 0x38 + 0x118024);
  if (0 < size) {
    __printf_chk(1,"%02x ",(int)*data);
    for (uVar1 = 2; (ulong)(size - 1) + 2 != uVar1; uVar1 = uVar1 + 1) {
      __printf_chk(1,"%02x ",(int)data[uVar1 - 1]);
      if ((uVar1 & 0xf) == 0) {
        putchar(10);
      }
    }
  }
  putchar(10);
  return 0;
}



int TNEFDetailedPrint(TNEFStruct *TNEF,int id,char *data,int size)

{
  char *pcVar1;
  char cVar2;
  
  if (TNEF->Debug == 0) {
    return 0;
  }
  __printf_chk(1,"%s: [%i bytes] \n",(long)id * 0x38 + 0x118024);
  if (0 < size) {
    pcVar1 = data + (ulong)(size - 1) + 1;
    do {
      cVar2 = *data;
      data = data + 1;
      putchar((int)cVar2);
    } while (data != pcVar1);
  }
  putchar(10);
  return 0;
}



int TNEFCheckForSignature(uint sig)

{
  uint uVar1;
  uint local_c [3];
  
  local_c[0] = sig;
  uVar1 = SwapDWord((uchar *)local_c,4);
  return ((uVar1 == 0x223e9f78) - 2) + (uint)(uVar1 == 0x223e9f78);
}



int TNEFGetKey(TNEFStruct *TNEF,ushort *key)

{
  ushort uVar1;
  int iVar2;
  
  iVar2 = (*(TNEF->IO).ReadProc)(&TNEF->IO,2,1,key);
  if (iVar2 < 1) {
    iVar2 = -3;
    if (0 < TNEF->Debug) {
      puts("Error reading Key");
    }
  }
  else {
    uVar1 = SwapWord((uchar *)key,2);
    iVar2 = TNEF->Debug;
    *key = uVar1;
    if (1 < iVar2) {
      __printf_chk(1,"DEBUG(%i/%i):",2);
      __printf_chk(1,"Key = 0x%X",*key);
      putchar(10);
      if (1 < TNEF->Debug) {
        __printf_chk(1,"DEBUG(%i/%i):",2);
        __printf_chk(1,"Key = %i",*key);
        putchar(10);
      }
    }
    iVar2 = 0;
  }
  return iVar2;
}



int TNEFGetHeader(TNEFStruct *TNEF,uint *type,uint *size)

{
  TNEFIOStruct *pTVar1;
  int iVar2;
  uint uVar3;
  long in_FS_OFFSET;
  uchar component;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  if (1 < TNEF->Debug) {
    __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"About to read Component");
  }
  pTVar1 = &TNEF->IO;
  iVar2 = (*(TNEF->IO).ReadProc)(pTVar1,1,1,&component);
  if (0 < iVar2) {
    if (1 < TNEF->Debug) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"About to read type");
    }
    iVar2 = (*(TNEF->IO).ReadProc)(pTVar1,4,1,type);
    if (iVar2 < 1) {
      if (0 < TNEF->Debug) {
        puts("ERROR: Error reading type");
      }
    }
    else {
      if (1 < TNEF->Debug) {
        __printf_chk(1,"DEBUG(%i/%i):",2);
        __printf_chk(1,"Type = 0x%X",*type);
        putchar(10);
        if (1 < TNEF->Debug) {
          __printf_chk(1,"DEBUG(%i/%i):",2);
          __printf_chk(1,"Type = %u",*type);
          putchar(10);
          if (1 < TNEF->Debug) {
            __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"About to read size");
          }
        }
      }
      iVar2 = (*(TNEF->IO).ReadProc)(pTVar1,4,1,size);
      if (0 < iVar2) {
        if (1 < TNEF->Debug) {
          __printf_chk(1,"DEBUG(%i/%i):",2);
          __printf_chk(1,"Size = %u",*size);
          putchar(10);
        }
        uVar3 = SwapDWord((uchar *)type,4);
        *type = uVar3;
        uVar3 = SwapDWord((uchar *)size,4);
        *size = uVar3;
        iVar2 = 0;
        goto LAB_00104212;
      }
      if (0 < TNEF->Debug) {
        puts("ERROR: Error reading size");
        iVar2 = -3;
        goto LAB_00104212;
      }
    }
  }
  iVar2 = -3;
LAB_00104212:
  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int TNEFRawRead(TNEFStruct *TNEF,uchar *data,uint size,ushort *checksum)

{
  byte *pbVar1;
  byte bVar2;
  ushort uVar3;
  uint uVar4;
  int iVar5;
  
  uVar4 = (*(TNEF->IO).ReadProc)(&TNEF->IO,1,size,data);
  if (uVar4 < size) {
    iVar5 = -3;
    if (0 < TNEF->Debug) {
      puts("ERROR: Error reading data");
    }
  }
  else {
    if ((checksum != (ushort *)0x0) && (*checksum = 0, size != 0)) {
      pbVar1 = data + (ulong)(size - 1) + 1;
      uVar3 = 0;
      do {
        bVar2 = *data;
        data = data + 1;
        uVar3 = uVar3 + bVar2;
        *checksum = uVar3;
      } while (data != pbVar1);
    }
    iVar5 = 0;
  }
  return iVar5;
}



// WARNING: Unknown calling convention

void TNEFInitMapi(MAPIProps *p)

{
  p->count = 0;
  p->properties = (MAPIProperty *)0x0;
  return;
}



void TNEFInitAttachment(Attachment *p)

{
  (p->Date).wYear = 0;
  (p->Date).wMonth = 0;
  (p->Date).wDay = 0;
  (p->Date).wHour = 0;
  (p->Date).wMinute = 0;
  (p->Date).wSecond = 0;
  (p->Date).wDayOfWeek = 0;
  (p->Title).data = (uchar *)0x0;
  (p->Title).size = 0;
  (p->MetaFile).data = (uchar *)0x0;
  (p->MetaFile).size = 0;
  (p->CreateDate).wYear = 0;
  (p->CreateDate).wMonth = 0;
  (p->CreateDate).wDay = 0;
  (p->CreateDate).wHour = 0;
  *(undefined8 *)&(p->CreateDate).wMinute = 0;
  (p->ModifyDate).wMonth = 0;
  (p->ModifyDate).wDay = 0;
  (p->ModifyDate).wHour = 0;
  (p->ModifyDate).wMinute = 0;
  (p->ModifyDate).wSecond = 0;
  (p->ModifyDate).wDayOfWeek = 0;
  (p->TransportFilename).data = (uchar *)0x0;
  (p->TransportFilename).size = 0;
  (p->FileData).data = (uchar *)0x0;
  (p->FileData).size = 0;
  (p->IconData).data = (uchar *)0x0;
  (p->IconData).size = 0;
  (p->RenderData).atyp = 0;
  *(undefined2 *)&(p->RenderData).field_0x2 = 0;
  (p->RenderData).ulPosition = 0;
  (p->RenderData).dxWidth = 0;
  (p->RenderData).dyHeight = 0;
  (p->RenderData).dwFlags = 0;
  TNEFInitMapi(&p->MAPI);
  p->next = (Attachment *)0x0;
  return;
}



int TNEFRendData(TNEFStruct *TNEF,int id,char *data,int size)

{
  Attachment *pAVar1;
  Attachment *pAVar2;
  
  pAVar1 = &TNEF->starting_attach;
  do {
    pAVar2 = pAVar1;
    pAVar1 = pAVar2->next;
  } while (pAVar1 != (Attachment *)0x0);
  pAVar1 = (Attachment *)calloc(1,0xa8);
  pAVar2->next = pAVar1;
  TNEFInitAttachment(pAVar1);
  if (0xf < (uint)size) {
    size = 0x10;
  }
  __memcpy_chk(&pAVar1->RenderData,data,(long)size,0x48);
  return 0;
}



void TNEFInitialize(TNEFStruct *TNEF)

{
  *(undefined2 *)(TNEF->version + 8) = 0;
  *(undefined2 *)(TNEF->messageStatus + 8) = 0;
  *(undefined2 *)(TNEF->messageClass + 0x30) = 0;
  *(undefined2 *)(TNEF->messageID + 0x30) = 0;
  *(undefined (*) [16])TNEF->messageClass = (undefined  [16])0x0;
  *(undefined (*) [16])(TNEF->messageClass + 0x10) = (undefined  [16])0x0;
  *(undefined (*) [16])(TNEF->messageClass + 0x20) = (undefined  [16])0x0;
  *(undefined (*) [16])TNEF->messageID = (undefined  [16])0x0;
  *(undefined (*) [16])(TNEF->messageID + 0x10) = (undefined  [16])0x0;
  *(undefined (*) [16])(TNEF->messageID + 0x20) = (undefined  [16])0x0;
  *(undefined (*) [16])TNEF->parentID = (undefined  [16])0x0;
  *(undefined (*) [16])(TNEF->parentID + 0x10) = (undefined  [16])0x0;
  *(undefined (*) [16])(TNEF->parentID + 0x20) = (undefined  [16])0x0;
  *(undefined8 *)TNEF->version = 0;
  (TNEF->from).data = (uchar *)0x0;
  (TNEF->from).size = 0;
  (TNEF->subject).data = (uchar *)0x0;
  (TNEF->subject).size = 0;
  (TNEF->dateSent).wYear = 0;
  (TNEF->dateSent).wMonth = 0;
  (TNEF->dateSent).wDay = 0;
  (TNEF->dateSent).wHour = 0;
  *(undefined8 *)&(TNEF->dateSent).wMinute = 0;
  (TNEF->dateReceived).wMonth = 0;
  (TNEF->dateReceived).wDay = 0;
  (TNEF->dateReceived).wHour = 0;
  (TNEF->dateReceived).wMinute = 0;
  (TNEF->dateReceived).wSecond = 0;
  (TNEF->dateReceived).wDayOfWeek = 0;
  *(undefined8 *)TNEF->messageStatus = 0;
  *(undefined2 *)(TNEF->parentID + 0x30) = 0;
  *(undefined2 *)(TNEF->conversationID + 0x30) = 0;
  *(undefined (*) [16])TNEF->conversationID = (undefined  [16])0x0;
  *(undefined (*) [16])(TNEF->conversationID + 0x10) = (undefined  [16])0x0;
  *(undefined (*) [16])(TNEF->conversationID + 0x20) = (undefined  [16])0x0;
  (TNEF->body).data = (uchar *)0x0;
  (TNEF->body).size = 0;
  *(undefined8 *)TNEF->priority = 0;
  *(undefined2 *)(TNEF->priority + 8) = 0;
  TNEFInitAttachment(&TNEF->starting_attach);
  (TNEF->dateModified).wYear = 0;
  (TNEF->dateModified).wMonth = 0;
  (TNEF->dateModified).wDay = 0;
  (TNEF->dateModified).wHour = 0;
  (TNEF->dateModified).wMinute = 0;
  (TNEF->dateModified).wSecond = 0;
  (TNEF->dateModified).wDayOfWeek = 0;
  TNEFInitMapi(&TNEF->MapiProperties);
  (TNEF->CodePage).data = (uchar *)0x0;
  (TNEF->CodePage).size = 0;
  (TNEF->OriginalMessageClass).data = (uchar *)0x0;
  (TNEF->OriginalMessageClass).size = 0;
  (TNEF->Owner).data = (uchar *)0x0;
  (TNEF->Owner).size = 0;
  (TNEF->SentFor).data = (uchar *)0x0;
  (TNEF->SentFor).size = 0;
  (TNEF->Delegate).data = (uchar *)0x0;
  (TNEF->Delegate).size = 0;
  (TNEF->DateStart).wYear = 0;
  (TNEF->DateStart).wMonth = 0;
  (TNEF->DateStart).wDay = 0;
  (TNEF->DateStart).wHour = 0;
  *(undefined8 *)&(TNEF->DateStart).wMinute = 0;
  (TNEF->DateEnd).wMonth = 0;
  (TNEF->DateEnd).wDay = 0;
  (TNEF->DateEnd).wHour = 0;
  (TNEF->DateEnd).wMinute = 0;
  (TNEF->DateEnd).wSecond = 0;
  (TNEF->DateEnd).wDayOfWeek = 0;
  (TNEF->AidOwner).data = (uchar *)0x0;
  (TNEF->AidOwner).size = 0;
  TNEF->RequestRes = 0;
  (TNEF->IO).data = (void *)0x0;
  (TNEF->IO).InitProc = (_func_int__TNEFIOStruct_ptr *)0x0;
  (TNEF->IO).ReadProc = (_func_int__TNEFIOStruct_ptr_int_int_void_ptr *)0x0;
  (TNEF->IO).CloseProc = (_func_int__TNEFIOStruct_ptr *)0x0;
  return;
}



void TNEFFreeMapiProps(MAPIProps *p)

{
  MAPIProperty *pMVar1;
  long lVar2;
  variableLength *pvVar3;
  long lVar4;
  long lVar5;
  
  lVar2 = 0;
  if (p->count != 0) {
    do {
      pMVar1 = p->properties;
      pvVar3 = pMVar1[lVar2].data;
      lVar4 = 0;
      if (pMVar1[lVar2].count != 0) {
        do {
          while( true ) {
            if (pvVar3[lVar4].size < 1) break;
            lVar5 = lVar4 + 1;
            free(pvVar3[lVar4].data);
            pMVar1 = p->properties;
            pvVar3 = pMVar1[lVar2].data;
            pvVar3[lVar4].size = 0;
            lVar4 = lVar5;
            if (pMVar1[lVar2].count <= (uint)lVar5) goto LAB_001047d4;
          }
          lVar4 = lVar4 + 1;
          pvVar3 = pMVar1[lVar2].data;
        } while ((uint)lVar4 < pMVar1[lVar2].count);
      }
LAB_001047d4:
      free(pvVar3);
      pMVar1 = p->properties;
      pvVar3 = pMVar1[lVar2].propnames;
      if (0 < pMVar1[lVar2].namedproperty) {
        lVar4 = 0;
        do {
          while( true ) {
            if (pvVar3[lVar4].size < 1) break;
            lVar5 = lVar4 + 1;
            free(pvVar3[lVar4].data);
            pMVar1 = p->properties;
            pvVar3 = pMVar1[lVar2].propnames;
            pvVar3[lVar4].size = 0;
            lVar4 = lVar5;
            if (pMVar1[lVar2].namedproperty <= (int)lVar5) goto LAB_00104842;
          }
          lVar4 = lVar4 + 1;
          pvVar3 = pMVar1[lVar2].propnames;
        } while ((int)lVar4 < pMVar1[lVar2].namedproperty);
      }
LAB_00104842:
      free(pvVar3);
      lVar2 = lVar2 + 1;
    } while ((uint)lVar2 < p->count);
  }
  free(p->properties);
  p->count = 0;
  return;
}



void TNEFFreeAttachment(Attachment *p)

{
  if (0 < (p->Title).size) {
    free((p->Title).data);
    (p->Title).size = 0;
  }
  if (0 < (p->MetaFile).size) {
    free((p->MetaFile).data);
    (p->MetaFile).size = 0;
  }
  if (0 < (p->TransportFilename).size) {
    free((p->TransportFilename).data);
    (p->TransportFilename).size = 0;
  }
  if (0 < (p->FileData).size) {
    free((p->FileData).data);
    (p->FileData).size = 0;
  }
  if (0 < (p->IconData).size) {
    free((p->IconData).data);
    (p->IconData).size = 0;
  }
  TNEFFreeMapiProps(&p->MAPI);
  return;
}



void TNEFFree(TNEFStruct *TNEF)

{
  Attachment *pAVar1;
  Attachment *p;
  
  if (0 < (TNEF->from).size) {
    free((TNEF->from).data);
    (TNEF->from).size = 0;
  }
  if (0 < (TNEF->subject).size) {
    free((TNEF->subject).data);
    (TNEF->subject).size = 0;
  }
  if (0 < (TNEF->body).size) {
    free((TNEF->body).data);
    (TNEF->body).size = 0;
  }
  if (0 < (TNEF->CodePage).size) {
    free((TNEF->CodePage).data);
    (TNEF->CodePage).size = 0;
  }
  if (0 < (TNEF->OriginalMessageClass).size) {
    free((TNEF->OriginalMessageClass).data);
    (TNEF->OriginalMessageClass).size = 0;
  }
  if (0 < (TNEF->Owner).size) {
    free((TNEF->Owner).data);
    (TNEF->Owner).size = 0;
  }
  if (0 < (TNEF->SentFor).size) {
    free((TNEF->SentFor).data);
    (TNEF->SentFor).size = 0;
  }
  if (0 < (TNEF->Delegate).size) {
    free((TNEF->Delegate).data);
    (TNEF->Delegate).size = 0;
  }
  if (0 < (TNEF->AidOwner).size) {
    free((TNEF->AidOwner).data);
    (TNEF->AidOwner).size = 0;
  }
  TNEFFreeMapiProps(&TNEF->MapiProperties);
  p = (TNEF->starting_attach).next;
  while (p != (Attachment *)0x0) {
    TNEFFreeAttachment(p);
    pAVar1 = p->next;
    free(p);
    p = pAVar1;
  }
  return;
}



int TNEFParse(TNEFStruct *TNEF)

{
  TNEFIOStruct *pTVar1;
  char *pcVar2;
  uint size_00;
  int iVar3;
  _func_int__TNEFIOStruct_ptr *p_Var4;
  uchar *data;
  TNEFHandler *pTVar5;
  long in_FS_OFFSET;
  ushort key;
  ushort checksum;
  ushort header_checksum;
  uint type;
  uint size;
  uint signature;
  long local_40;
  
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  if ((TNEF->IO).ReadProc == (_func_int__TNEFIOStruct_ptr_int_int_void_ptr *)0x0) {
    iVar3 = -8;
    puts("ERROR: Setup incorrectly: No ReadProc");
    goto LAB_00104e79;
  }
  p_Var4 = (TNEF->IO).InitProc;
  pTVar1 = &TNEF->IO;
  iVar3 = TNEF->Debug;
  if (p_Var4 == (_func_int__TNEFIOStruct_ptr *)0x0) {
LAB_00104df4:
    if (1 < iVar3) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,iVar3,"Reading Signature");
    }
  }
  else {
    if (1 < iVar3) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,iVar3,"About to initialize");
      p_Var4 = (TNEF->IO).InitProc;
    }
    iVar3 = (*p_Var4)(&TNEF->IO);
    if (iVar3 != 0) {
      iVar3 = -1;
      goto LAB_00104e79;
    }
    if (1 < TNEF->Debug) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"Initialization finished");
      iVar3 = TNEF->Debug;
      goto LAB_00104df4;
    }
  }
  iVar3 = (*(TNEF->IO).ReadProc)(&TNEF->IO,4,1,&signature);
  if (iVar3 < 1) {
    iVar3 = -3;
    puts("ERROR: Error reading signature");
    p_Var4 = (TNEF->IO).CloseProc;
  }
  else {
    if (1 < TNEF->Debug) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"Checking Signature");
    }
    iVar3 = TNEFCheckForSignature(signature);
    if (iVar3 < 0) {
      iVar3 = -2;
      puts("ERROR: Signature does not match. Not TNEF.");
      p_Var4 = (TNEF->IO).CloseProc;
    }
    else {
      if (1 < TNEF->Debug) {
        __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"Reading Key.");
      }
      iVar3 = TNEFGetKey(TNEF,&key);
      if (-1 < iVar3) {
        if (1 < TNEF->Debug) {
          __printf_chk(1,"DEBUG(%i/%i): %s\n",2,TNEF->Debug,"Starting Full Processing.");
        }
        while (iVar3 = TNEFGetHeader(TNEF,&type,&size), iVar3 == 0) {
          if (1 < TNEF->Debug) {
            __printf_chk(1,"DEBUG(%i/%i):",2);
            __printf_chk(1,"Header says type=0x%X, size=%u",type,size);
            putchar(10);
            if (1 < TNEF->Debug) {
              __printf_chk(1,"DEBUG(%i/%i):",2);
              __printf_chk(1,"Header says type=%u, size=%u",type,size);
              putchar(10);
            }
          }
          size_00 = size;
          data = (uchar *)calloc((ulong)size,1);
          iVar3 = TNEFRawRead(TNEF,data,size_00,&header_checksum);
          if (iVar3 < 0) {
            puts("ERROR: Unable to read data.");
            p_Var4 = (TNEF->IO).CloseProc;
joined_r0x00104ee4:
            if (p_Var4 != (_func_int__TNEFIOStruct_ptr *)0x0) {
              (*p_Var4)(pTVar1);
            }
            iVar3 = -3;
            free(data);
            goto LAB_00104e79;
          }
          iVar3 = TNEFRawRead(TNEF,(uchar *)&checksum,2,(ushort *)0x0);
          if (iVar3 < 0) {
            puts("ERROR: Unable to read checksum.");
            p_Var4 = (TNEF->IO).CloseProc;
            goto joined_r0x00104ee4;
          }
          checksum = SwapWord((uchar *)&checksum,2);
          if (checksum != header_checksum) {
            puts("ERROR: Checksum mismatch. Data corruption?:");
            p_Var4 = (TNEF->IO).CloseProc;
            if (p_Var4 != (_func_int__TNEFIOStruct_ptr *)0x0) {
              (*p_Var4)(pTVar1);
            }
            iVar3 = -5;
            free(data);
            goto LAB_00104e79;
          }
          pTVar5 = TNEFList;
          iVar3 = 0;
LAB_00104c86:
          do {
            if (pTVar5->id == type) {
              if (pTVar5->handler != (_func_int_TNEFStruct_ptr_int_char_ptr_int *)0x0) {
                iVar3 = (*pTVar5->handler)(TNEF,iVar3,(char *)data,size);
                if (iVar3 < 0) {
                  iVar3 = -6;
                  free(data);
                  p_Var4 = (TNEF->IO).CloseProc;
                  goto joined_r0x00104dbf;
                }
                break;
              }
              if (0 < TNEF->Debug) {
                __printf_chk(1,"DEBUG(%i/%i):",1);
                pcVar2 = pTVar5->name;
                iVar3 = iVar3 + 1;
                pTVar5 = pTVar5 + 1;
                __printf_chk(1,"No handler for %s: %u bytes",pcVar2,size);
                putchar(10);
                if (iVar3 == 0x21) break;
                goto LAB_00104c86;
              }
            }
            iVar3 = iVar3 + 1;
            pTVar5 = pTVar5 + 1;
          } while (iVar3 != 0x21);
          free(data);
        }
        p_Var4 = (TNEF->IO).CloseProc;
        iVar3 = 0;
        if (p_Var4 != (_func_int__TNEFIOStruct_ptr *)0x0) {
          (*p_Var4)(pTVar1);
        }
        goto LAB_00104e79;
      }
      iVar3 = -4;
      puts("ERROR: Unable to retrieve key.");
      p_Var4 = (TNEF->IO).CloseProc;
    }
  }
joined_r0x00104dbf:
  if (p_Var4 != (_func_int__TNEFIOStruct_ptr *)0x0) {
    (*p_Var4)(pTVar1);
  }
LAB_00104e79:
  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int TNEFParseFile(char *filename,TNEFStruct *TNEF)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  TNEFFileInfo finfo;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  finfo.Debug = TNEF->Debug;
  if (0 < finfo.Debug) {
    __printf_chk(1,"Attempting to parse %s...\n",filename);
    finfo.Debug = TNEF->Debug;
  }
  (TNEF->IO).data = &finfo;
  (TNEF->IO).InitProc = TNEFFile_Open;
  finfo.fptr = (FILE *)0x0;
  (TNEF->IO).ReadProc = TNEFFile_Read;
  (TNEF->IO).CloseProc = TNEFFile_Close;
  finfo.filename = filename;
  iVar2 = TNEFParse(TNEF);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int TNEFParseMemory(uchar *memory,long size,TNEFStruct *TNEF)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  TNEFMemInfo minfo;
  
  minfo.Debug = TNEF->Debug;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (0 < minfo.Debug) {
    __printf_chk(1,"DEBUG(%i/%i): %s\n",1,minfo.Debug,"Attempting to parse memory block...\n");
    minfo.Debug = TNEF->Debug;
  }
  (TNEF->IO).data = &minfo;
  (TNEF->IO).InitProc = TNEFMemory_Open;
  (TNEF->IO).ReadProc = TNEFMemory_Read;
  (TNEF->IO).CloseProc = TNEFMemory_Close;
  minfo.dataStart = memory;
  minfo.ptr = memory;
  minfo.size = size;
  iVar2 = TNEFParse(TNEF);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

variableLength * MAPIFindUserProp(MAPIProps *p,uint ID)

{
  MAPIProperty *pMVar1;
  MAPIProperty *pMVar2;
  
  if ((p != (MAPIProps *)0x0) && (p->count != 0)) {
    pMVar2 = p->properties;
    pMVar1 = pMVar2 + (ulong)(p->count - 1) + 1;
    do {
      if ((pMVar2->id == ID) && (pMVar2->custom == 1)) {
        return pMVar2->data;
      }
      pMVar2 = pMVar2 + 1;
    } while (pMVar2 != pMVar1);
  }
  return (variableLength *)0xffffffffffffffff;
}



// WARNING: Unknown calling convention

variableLength * MAPIFindProperty(MAPIProps *p,uint ID)

{
  MAPIProperty *pMVar1;
  MAPIProperty *pMVar2;
  
  if ((p != (MAPIProps *)0x0) && (p->count != 0)) {
    pMVar2 = p->properties;
    pMVar1 = pMVar2 + (ulong)(p->count - 1) + 1;
    do {
      if ((pMVar2->id == ID) && (pMVar2->custom == 0)) {
        return pMVar2->data;
      }
      pMVar2 = pMVar2 + 1;
    } while (pMVar2 != pMVar1);
  }
  return (variableLength *)0xffffffffffffffff;
}



int MAPISysTimetoDTR(uchar *data,dtr *thedate)

{
  long lVar1;
  uint uVar2;
  uint uVar3;
  ulong uVar4;
  ulong uVar5;
  int iVar6;
  ulong uVar7;
  int iVar8;
  ushort uVar9;
  long in_FS_OFFSET;
  uint months [12];
  
  uVar7 = *(ulong *)data;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  months[0] = 0x1f;
  months[1] = 0x1c;
  months[2] = 0x1f;
  months[3] = 0x1e;
  months[4] = 0x1f;
  months[5] = 0x1e;
  months[6] = 0x1f;
  months[7] = 0x1f;
  months[8] = 0x1e;
  months[9] = 0x1f;
  months[10] = 0x1e;
  months[0xb] = 0x1f;
  uVar4 = uVar7 / 10000000;
  uVar5 = uVar4 / 0x3c;
  thedate->wSecond = (short)uVar4 + ((short)(uVar5 << 4) - (short)uVar5) * -4;
  uVar4 = uVar5 / 0x3c;
  thedate->wMinute = (short)uVar5 + ((short)(uVar4 << 4) - (short)uVar4) * -4;
  uVar5 = uVar4 / 0x18;
  thedate->wHour = (short)uVar4 + (short)uVar5 * -0x18;
  if (uVar7 < 0x11ed178c6c000) {
    iVar6 = 1;
    thedate->wYear = 0x641;
  }
  else {
    uVar5 = uVar5 - 0x16d;
    uVar7 = 2;
    uVar9 = 0x642;
    thedate->wYear = 0x642;
    iVar8 = 0x16d;
    while( true ) {
      iVar6 = (int)(uVar7 * 0x24924925 >> 0x20);
      iVar6 = (int)uVar7 + (((uint)((int)uVar7 - iVar6) >> 1) + iVar6 >> 2) * -7;
      if (uVar5 < (ulong)(long)iVar8) break;
      uVar9 = uVar9 + 1;
      uVar5 = uVar5 - (long)iVar8;
      uVar7 = (ulong)(iVar6 + 1);
      iVar8 = 0x16d;
      thedate->wYear = uVar9;
      if (((uVar9 & 3) == 0) &&
         ((0x28f < (ushort)((ushort)(uVar9 * 0x5c29) >> 2 | uVar9 * 0x4000) ||
          ((ushort)((ushort)(uVar9 * 0x5c29) >> 4 | uVar9 * -0x7000) < 0xa4)))) {
        uVar7 = (ulong)(iVar6 + 2);
        iVar8 = 0x16e;
      }
    }
    if ((uVar9 & 3) == 0) {
      months[0] = 0x1f;
      months[1] = 0x1d;
    }
  }
  uVar2 = (uint)uVar5;
  uVar7 = uVar5 & 0xffffffff;
  thedate->wDayOfWeek = (short)(iVar6 + uVar2) + (short)((iVar6 + uVar2) / 7) * -7;
  if (uVar5 < 0x20) {
    uVar9 = 1;
  }
  else {
    uVar9 = 1;
    uVar3 = 0x1f;
    do {
      uVar2 = (int)uVar7 - uVar3;
      uVar7 = (ulong)uVar2;
      uVar4 = (ulong)uVar9;
      uVar9 = uVar9 + 1;
      uVar3 = months[uVar4];
    } while (uVar3 < uVar2);
  }
  thedate->wMonth = uVar9;
  thedate->wDay = (short)uVar2 + 1;
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



int IsCompressedRTF(variableLength *p)

{
  uint uVar1;
  
  uVar1 = SwapDWord(p->data + 8,4);
  return (int)(uVar1 == 0x75465a4c || uVar1 == 0x414c454d);
}



uchar * DecompressRTF(variableLength *p,int *size)

{
  uint uVar1;
  byte bVar2;
  undefined uVar3;
  undefined8 uVar4;
  undefined8 uVar5;
  undefined8 uVar6;
  undefined8 uVar7;
  undefined8 uVar8;
  undefined8 uVar9;
  undefined8 uVar10;
  undefined8 uVar11;
  undefined8 uVar12;
  undefined8 uVar13;
  undefined8 uVar14;
  undefined8 uVar15;
  undefined8 uVar16;
  undefined8 uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  undefined8 *__ptr;
  undefined8 *__ptr_00;
  uchar *puVar21;
  byte bVar22;
  uint uVar23;
  ulong uVar24;
  undefined *puVar25;
  int iVar26;
  ulong uVar27;
  uint uVar28;
  uint uVar29;
  uint uVar30;
  
  __ptr = (undefined8 *)calloc(0xd0,1);
  puVar21 = p->data;
  *__ptr = 0x615c316674725c7b;
  __ptr[1] = 0x5c63616d5c69736e;
  __ptr[2] = 0x65645c3066666564;
  __ptr[3] = 0x7b30323762617466;
  __ptr[4] = 0x6c6274746e6f665c;
  __ptr[5] = 0x665c30665c7b7d3b;
  __ptr[6] = 0x6f72665c206c696e;
  __ptr[7] = 0x7773665c206e616d;
  __ptr[8] = 0x6f6d665c20737369;
  __ptr[9] = 0x73665c206e726564;
  __ptr[10] = 0x665c207470697263;
  __ptr[0xb] = 0x534d20726f636564;
  __ptr[0xc] = 0x655320736e615320;
  __ptr[0xd] = 0x6f626d7953666972;
  __ptr[0xe] = 0x69546c616972416c;
  __ptr[0xf] = 0x2077654e2073656d;
  __ptr[0x10] = 0x756f436e616d6f52;
  __ptr[0x11] = 0x6f635c7b72656972;
  __ptr[0x12] = 0x725c6c6274726f6c;
  __ptr[0x13] = 0x656572675c306465;
  __ptr[0x14] = 0x3065756c625c306e;
  __ptr[0x15] = 0x5c207261705c0d0a;
  __ptr[0x16] = 0x616c705c64726170;
  __ptr[0x17] = 0x73665c30665c6e69;
  __ptr[0x18] = 0x755c695c625c3032;
  *(undefined4 *)(__ptr + 0x19) = 0x6261745c;
  *(undefined2 *)((long)__ptr + 0xcc) = 0x745c;
  *(undefined *)((long)__ptr + 0xce) = 0x78;
  uVar18 = SwapDWord(puVar21,4);
  uVar19 = SwapDWord(puVar21 + 4,4);
  uVar20 = SwapDWord(puVar21 + 8,4);
  if (p->size - 4U == uVar18) {
    if (uVar20 != 0x414c454d) {
      if (uVar20 == 0x75465a4c) {
        uVar18 = uVar19 + 0xcf;
        __ptr_00 = (undefined8 *)calloc((ulong)uVar18,1);
        uVar4 = __ptr[1];
        uVar5 = __ptr[2];
        uVar6 = __ptr[3];
        uVar7 = __ptr[4];
        uVar8 = __ptr[5];
        uVar9 = __ptr[6];
        uVar10 = __ptr[7];
        uVar11 = __ptr[8];
        uVar12 = __ptr[9];
        *__ptr_00 = *__ptr;
        __ptr_00[1] = uVar4;
        uVar4 = __ptr[10];
        uVar13 = __ptr[0xb];
        __ptr_00[2] = uVar5;
        __ptr_00[3] = uVar6;
        uVar5 = __ptr[0xc];
        uVar6 = __ptr[0xd];
        uVar14 = __ptr[0xe];
        uVar15 = __ptr[0xf];
        __ptr_00[4] = uVar7;
        __ptr_00[5] = uVar8;
        uVar7 = __ptr[0x10];
        uVar8 = __ptr[0x11];
        uVar16 = __ptr[0x12];
        uVar17 = __ptr[0x13];
        __ptr_00[6] = uVar9;
        __ptr_00[7] = uVar10;
        uVar9 = __ptr[0x14];
        uVar10 = __ptr[0x15];
        __ptr_00[8] = uVar11;
        __ptr_00[9] = uVar12;
        uVar11 = __ptr[0x16];
        uVar12 = __ptr[0x17];
        __ptr_00[10] = uVar4;
        __ptr_00[0xb] = uVar13;
        __ptr_00[0xc] = uVar5;
        __ptr_00[0xd] = uVar6;
        __ptr_00[0xe] = uVar14;
        __ptr_00[0xf] = uVar15;
        __ptr_00[0x10] = uVar7;
        __ptr_00[0x11] = uVar8;
        __ptr_00[0x12] = uVar16;
        __ptr_00[0x13] = uVar17;
        __ptr_00[0x14] = uVar9;
        __ptr_00[0x15] = uVar10;
        __ptr_00[0x16] = uVar11;
        __ptr_00[0x17] = uVar12;
        __ptr_00[0x18] = __ptr[0x18];
        *(undefined4 *)(__ptr_00 + 0x19) = *(undefined4 *)(__ptr + 0x19);
        *(undefined2 *)((long)__ptr_00 + 0xcc) = *(undefined2 *)((long)__ptr + 0xcc);
        *(undefined *)((long)__ptr_00 + 0xce) = *(undefined *)((long)__ptr + 0xce);
        if (0xcf < uVar18) {
          uVar29 = 0;
          uVar30 = 0;
          uVar20 = 0xcf;
          uVar24 = 0x10;
          do {
            while( true ) {
              uVar23 = (uint)uVar24;
              uVar28 = uVar23 + 1;
              bVar2 = puVar21[uVar24];
              if ((uVar29 & 7) == 0) break;
              uVar30 = (int)uVar30 >> 1;
              uVar24 = (ulong)uVar28;
              bVar22 = bVar2;
              uVar28 = uVar23;
              if ((uVar30 & 1) == 0) goto LAB_001056f4;
LAB_0010572a:
              iVar26 = (puVar21[uVar24] & 0xf) + 2;
              uVar23 = ((int)(uint)puVar21[uVar24] >> 4 | (uint)bVar22 << 4) + (uVar20 & 0xfffff000)
              ;
              if (uVar20 <= uVar23) {
                uVar23 = uVar23 - 0x1000;
              }
              if ((int)uVar23 < (int)(uVar23 + iVar26)) {
                uVar1 = iVar26 + uVar20;
                puVar25 = (undefined *)((long)(int)uVar23 + (long)__ptr_00);
                do {
                  uVar3 = *puVar25;
                  uVar24 = (ulong)uVar20;
                  uVar20 = uVar20 + 1;
                  puVar25 = puVar25 + 1;
                  *(undefined *)((long)__ptr_00 + uVar24) = uVar3;
                } while (uVar1 != uVar20);
              }
              uVar24 = (ulong)(uVar28 + 2);
              uVar29 = uVar29 + 1;
              if (uVar18 <= uVar20) goto LAB_0010579d;
            }
            uVar30 = (uint)bVar2;
            uVar24 = (ulong)(uVar23 + 2);
            bVar22 = puVar21[uVar28];
            if ((bVar2 & 1) != 0) goto LAB_0010572a;
LAB_001056f4:
            uVar27 = (ulong)uVar20;
            uVar20 = uVar20 + 1;
            uVar29 = uVar29 + 1;
            *(byte *)((long)__ptr_00 + uVar27) = bVar22;
          } while (uVar20 < uVar18);
        }
LAB_0010579d:
        puVar21 = (uchar *)calloc((ulong)uVar19,1);
        memcpy(puVar21,(void *)((long)__ptr_00 + 0xcf),(ulong)uVar19);
        free(__ptr_00);
        *size = uVar19;
        free(__ptr);
        return puVar21;
      }
      __printf_chk(1,"Unknown compression type (magic number %x)\n",uVar20);
    }
    free(__ptr);
  }
  else {
    __printf_chk(1," Size Mismatch: %u != %i\n",uVar18);
    free(__ptr);
  }
  return (uchar *)0x0;
}



void MAPIPrint(MAPIProps *p)

{
  uchar *puVar1;
  long lVar2;
  undefined8 uVar3;
  bool bVar4;
  uint uVar5;
  int iVar6;
  size_t sVar7;
  ushort **ppuVar8;
  MAPIPropertyTagList *pMVar9;
  uint uVar10;
  MAPIProperty *pMVar11;
  long lVar12;
  variableLength *p_00;
  long lVar13;
  ulong uVar14;
  long in_FS_OFFSET;
  dtr Date;
  ulong local_90;
  dtr thedate;
  variableLength vlTemp;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  if (p->count != 0) {
    local_90 = 0;
    do {
      pMVar11 = p->properties + local_90;
      __printf_chk(1,"   #%i: Type: [",local_90 & 0xffffffff);
      switch(*(short *)&pMVar11->id) {
      case 0:
        __printf_chk(1,"  NONE   ");
        break;
      case 1:
        __printf_chk(1,"  NULL   ");
        break;
      case 2:
        __printf_chk(1,&DAT_00107356);
        break;
      case 3:
        __printf_chk(1,"  LONG   ");
        break;
      case 4:
        __printf_chk(1,"   R4    ");
        break;
      case 5:
        __printf_chk(1," DOUBLE  ");
        break;
      case 6:
        __printf_chk(1,"CURRENCY ");
        break;
      case 7:
        __printf_chk(1,"APP TIME ");
        break;
      case 8:
      case 9:
      case 0xc:
      case 0xe:
      case 0xf:
      case 0x10:
      case 0x11:
      case 0x12:
      case 0x13:
      case 0x15:
      case 0x16:
      case 0x17:
      case 0x18:
      case 0x19:
      case 0x1a:
      case 0x1b:
      case 0x1c:
      case 0x1d:
      case 0x20:
      case 0x21:
      case 0x22:
      case 0x23:
      case 0x24:
      case 0x25:
      case 0x26:
      case 0x27:
      case 0x28:
      case 0x29:
      case 0x2a:
      case 0x2b:
      case 0x2c:
      case 0x2d:
      case 0x2e:
      case 0x2f:
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x3a:
      case 0x3b:
      case 0x3c:
      case 0x3d:
      case 0x3e:
      case 0x3f:
      case 0x41:
      case 0x42:
      case 0x43:
      case 0x44:
      case 0x45:
      case 0x46:
      case 0x47:
switchD_001058a0_caseD_8:
        __printf_chk(1,&DAT_001073ec);
        break;
      case 10:
        __printf_chk(1,"  ERROR  ");
        break;
      case 0xb:
        __printf_chk(1," BOOLEAN ");
        break;
      case 0xd:
        __printf_chk(1," OBJECT  ");
        break;
      case 0x14:
        __printf_chk(1,"   I8    ");
        break;
      case 0x1e:
        __printf_chk(1," STRING8 ");
        break;
      case 0x1f:
        __printf_chk(1," UNICODE ");
        break;
      case 0x40:
        __printf_chk(1,"SYS TIME ");
        break;
      case 0x48:
        __printf_chk(1,"OLE GUID ");
        break;
      default:
        if (*(short *)&pMVar11->id != 0x102) goto switchD_001058a0_caseD_8;
        __printf_chk(1," BINARY  ");
      }
      __printf_chk(1,"]  Code: [");
      if (pMVar11->custom == 1) {
        __printf_chk(1,"UD:x%04x",*(undefined2 *)((long)&pMVar11->id + 2));
      }
      else {
        pMVar9 = MPList;
        bVar4 = false;
        do {
          while ((pMVar9->id != (uint)*(ushort *)((long)&pMVar11->id + 2) || (bVar4))) {
            pMVar9 = pMVar9 + 1;
            if (pMVar9 == (MAPIPropertyTagList *)TNEFList) goto LAB_00105942;
          }
          __printf_chk(1,"%s",pMVar9->name);
          pMVar9 = pMVar9 + 1;
          bVar4 = true;
        } while (pMVar9 != (MAPIPropertyTagList *)TNEFList);
LAB_00105942:
        if (!bVar4) {
          __printf_chk(1,"0x%04x",*(undefined2 *)((long)&pMVar11->id + 2));
        }
      }
      puts("]");
      if (0 < pMVar11->namedproperty) {
        lVar12 = 0;
        do {
          lVar13 = lVar12 + 1;
          __printf_chk(1,"    Name: %s\n",pMVar11->propnames[lVar12].data);
          lVar12 = lVar13;
        } while ((int)lVar13 < pMVar11->namedproperty);
      }
      uVar10 = pMVar11->count;
      if (uVar10 != 0) {
        uVar14 = 0;
        do {
          p_00 = pMVar11->data + uVar14;
          if (uVar10 == 1) {
            __printf_chk(1,&DAT_0010735b);
          }
          else {
            __printf_chk(1,"    [%i/%u] ",uVar14 & 0xffffffff);
          }
          __printf_chk(1,"Size: %i",p_00->size);
          uVar10 = pMVar11->id;
          uVar5 = uVar10 & 0xffff;
          if (0x1e < (ushort)uVar10) {
            if (uVar5 == 0x48) {
              lVar12 = 0;
              __printf_chk(1,"    Value: ");
              __printf_chk(1,"[HEX: ");
              do {
                puVar1 = p_00->data + lVar12;
                lVar12 = lVar12 + 1;
                __printf_chk(1," %02x",*puVar1);
              } while (lVar12 != 0x10);
LAB_00105cd2:
              puts("]");
            }
            else if (uVar5 == 0x102) {
              iVar6 = IsCompressedRTF(p_00);
              if (iVar6 != 1) {
                __printf_chk(1,"    Value: [");
                if (0 < p_00->size) {
                  ppuVar8 = __ctype_b_loc();
                  lVar12 = 0;
                  do {
                    uVar10 = (uint)p_00->data[lVar12];
                    if ((*(byte *)((long)*ppuVar8 + (ulong)p_00->data[lVar12] * 2 + 1) & 0x40) == 0)
                    {
                      uVar10 = 0x2e;
                    }
                    putchar(uVar10);
                    lVar12 = lVar12 + 1;
                  } while ((int)lVar12 < p_00->size);
                  goto LAB_00105d6f;
                }
                goto LAB_00105cd2;
              }
              __printf_chk(1,"    Detected Compressed RTF. ");
              puts("Decompressed text follows");
              puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
              vlTemp.data = DecompressRTF(p_00,&vlTemp.size);
              if (vlTemp.data != (uchar *)0x0) {
                puts((char *)vlTemp.data);
                free(vlTemp.data);
              }
              puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
            }
            else {
              if (uVar5 != 0x40) goto switchD_00105a04_caseD_0;
              lVar12 = 0;
              MAPISysTimetoDTR(p_00->data,&thedate);
              __printf_chk(1,"    Value: ");
              uVar3 = *(undefined8 *)p_00->data;
              Date.wSecond = thedate.wSecond;
              Date.wMinute = thedate.wMinute;
              Date.wDayOfWeek = thedate.wDayOfWeek;
              Date.wYear = thedate.wYear;
              Date.wMonth = thedate.wMonth;
              Date.wDay = thedate.wDay;
              Date.wHour = thedate.wHour;
              TNEFPrintDate(Date);
              __printf_chk(1,&DAT_0010743e);
              do {
                puVar1 = p_00->data + lVar12;
                lVar12 = lVar12 + 1;
                __printf_chk(1," %02x",*puVar1);
              } while (lVar12 != 8);
              __printf_chk(1,"] (%llu)\n",uVar3);
            }
            goto LAB_00105a40;
          }
          if ((uVar10 & 0xfffe) == 0) {
switchD_00105a04_caseD_0:
            __printf_chk(1,"    Value: [%s]\n",p_00->data);
          }
          else {
            switch(uVar5) {
            default:
              goto switchD_00105a04_caseD_0;
            case 2:
              __printf_chk(1,"    Value: %hi\n",(int)*(short *)p_00->data);
              break;
            case 3:
              __printf_chk(1,"    Value: %li\n",*(undefined8 *)p_00->data);
              break;
            case 0xb:
              if (*pMVar11->data->data == '\0') {
                puts("    Value: False");
              }
              else {
                puts("    Value: True");
              }
              break;
            case 0xd:
              putchar(10);
              break;
            case 0x1e:
              __printf_chk(1,"    Value: [%s]\n",p_00->data);
              sVar7 = strlen((char *)p_00->data);
              if (sVar7 != (long)(p_00->size + -1)) {
                __printf_chk(1,"Detected Hidden data: [");
                if (p_00->size < 1) goto LAB_00105cd2;
                ppuVar8 = __ctype_b_loc();
                lVar12 = 0;
                do {
                  uVar10 = (uint)p_00->data[lVar12];
                  if ((*(byte *)((long)*ppuVar8 + (ulong)p_00->data[lVar12] * 2 + 1) & 0x40) == 0) {
                    uVar10 = 0x2e;
                  }
                  putchar(uVar10);
                  lVar12 = lVar12 + 1;
                } while ((int)lVar12 < p_00->size);
LAB_00105d6f:
                puts("]");
              }
            }
          }
LAB_00105a40:
          uVar14 = uVar14 + 1;
          uVar10 = pMVar11->count;
        } while ((uint)uVar14 < uVar10);
      }
      local_90 = local_90 + 1;
    } while ((uint)local_90 < p->count);
  }
  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int TNEFMapiProperties(TNEFStruct *TNEF,int id,char *data,int size)

{
  TNEFFillMapi(TNEF,(uchar *)data,size,&TNEF->MapiProperties);
  if (TNEF->Debug < 3) {
    return 0;
  }
  MAPIPrint(&TNEF->MapiProperties);
  return 0;
}



void _fini(void)

{
  return;
}



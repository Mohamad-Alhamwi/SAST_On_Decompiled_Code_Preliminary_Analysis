typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned char    dwfenc;
typedef unsigned int    dword;
typedef long double    longdouble;
typedef long long    longlong;
typedef unsigned long    qword;
typedef int    sdword;
typedef long    sqword;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned int    undefined4;
typedef unsigned long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef struct NoteGnuPropertyElement_4 NoteGnuPropertyElement_4, *PNoteGnuPropertyElement_4;

struct NoteGnuPropertyElement_4 {
    dword prType;
    dword prDatasz;
    byte data[4];
};

typedef struct eh_frame_hdr eh_frame_hdr, *Peh_frame_hdr;

struct eh_frame_hdr {
    byte eh_frame_hdr_version; // Exception Handler Frame Header Version
    dwfenc eh_frame_pointer_encoding; // Exception Handler Frame Pointer Encoding
    dwfenc eh_frame_desc_entry_count_encoding; // Encoding of # of Exception Handler FDEs
    dwfenc eh_frame_table_encoding; // Exception Handler Table Encoding
};

typedef struct fde_table_entry fde_table_entry, *Pfde_table_entry;

struct fde_table_entry {
    dword initial_loc; // Initial Location
    dword data_loc; // Data location
};

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef long __off64_t;

typedef ulong size_t;

struct _IO_FILE {
    int _flags;
    char *_IO_read_ptr;
    char *_IO_read_end;
    char *_IO_read_base;
    char *_IO_write_base;
    char *_IO_write_ptr;
    char *_IO_write_end;
    char *_IO_buf_base;
    char *_IO_buf_end;
    char *_IO_save_base;
    char *_IO_backup_base;
    char *_IO_save_end;
    struct _IO_marker *_markers;
    struct _IO_FILE *_chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t *_lock;
    __off64_t _offset;
    void *__pad1;
    void *__pad2;
    void *__pad3;
    void *__pad4;
    size_t __pad5;
    int _mode;
    char _unused2[20];
};

struct _IO_marker {
    struct _IO_marker *_next;
    struct _IO_FILE *_sbuf;
    int _pos;
};

typedef struct stat stat, *Pstat;

typedef ulong __dev_t;

typedef ulong __ino_t;

typedef ulong __nlink_t;

typedef uint __mode_t;

typedef uint __uid_t;

typedef uint __gid_t;

typedef long __blksize_t;

typedef long __blkcnt_t;

typedef struct timespec timespec, *Ptimespec;

typedef long __time_t;

struct timespec {
    __time_t tv_sec;
    long tv_nsec;
};

struct stat {
    __dev_t st_dev;
    __ino_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;
    __uid_t st_uid;
    __gid_t st_gid;
    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;
    __blksize_t st_blksize;
    __blkcnt_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    long __unused[3];
};

typedef struct _IO_FILE FILE;

typedef int __pid_t;

typedef int __int32_t;

typedef long __suseconds_t;

typedef long __clock_t;

typedef struct MD5state_st MD5state_st, *PMD5state_st;

typedef struct MD5state_st MD5_CTX;

struct MD5state_st {
    uint A;
    uint B;
    uint C;
    uint D;
    uint Nl;
    uint Nh;
    uint data[16];
    uint num;
};

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;

struct evp_pkey_ctx_st {
};

typedef struct dirent dirent, *Pdirent;

struct dirent {
    __ino_t d_ino;
    __off_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
};

typedef struct glob_t glob_t, *Pglob_t;

struct glob_t {
    size_t gl_pathc;
    char **gl_pathv;
    size_t gl_offs;
    int gl_flags;
    void (*gl_closedir)(void *);
    dirent * (*gl_readdir)(void *);
    void * (*gl_opendir)(char *);
    int (*gl_lstat)(char *, struct stat *);
    int (*gl_stat)(char *, struct stat *);
};

typedef union sigval sigval, *Psigval;

union sigval {
    int sival_int;
    void *sival_ptr;
};

typedef struct siginfo siginfo, *Psiginfo;

typedef union _union_1441 _union_1441, *P_union_1441;

typedef struct _struct_1442 _struct_1442, *P_struct_1442;

typedef struct _struct_1443 _struct_1443, *P_struct_1443;

typedef struct _struct_1444 _struct_1444, *P_struct_1444;

typedef struct _struct_1445 _struct_1445, *P_struct_1445;

typedef struct _struct_1446 _struct_1446, *P_struct_1446;

typedef struct _struct_1447 _struct_1447, *P_struct_1447;

typedef union sigval sigval_t;

struct _struct_1445 {
    __pid_t si_pid;
    __uid_t si_uid;
    int si_status;
    __clock_t si_utime;
    __clock_t si_stime;
};

struct _struct_1444 {
    __pid_t si_pid;
    __uid_t si_uid;
    sigval_t si_sigval;
};

struct _struct_1443 {
    int si_tid;
    int si_overrun;
    sigval_t si_sigval;
};

struct _struct_1446 {
    void *si_addr;
};

struct _struct_1442 {
    __pid_t si_pid;
    __uid_t si_uid;
};

struct _struct_1447 {
    long si_band;
    int si_fd;
};

union _union_1441 {
    int _pad[28];
    struct _struct_1442 _kill;
    struct _struct_1443 _timer;
    struct _struct_1444 _rt;
    struct _struct_1445 _sigchld;
    struct _struct_1446 _sigfault;
    struct _struct_1447 _sigpoll;
};

struct siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    union _union_1441 _sifields;
};

typedef struct siginfo siginfo_t;

typedef qword __uint64_t;

typedef long __syscall_slong_t;


// WARNING! conflicting data type names: /DWARF/__off64_t - /types.h/__off64_t

typedef sqword __int64_t;

typedef dword __uint32_t;

typedef ulong __size_t;


// WARNING! conflicting data type names: /DWARF/__int32_t - /types.h/__int32_t

typedef word __uint16_t;


// WARNING! conflicting data type names: /DWARF/stat.h/stat - /stat.h/stat

typedef union sigval __sigval_t;


// WARNING! conflicting data type names: /DWARF/struct_timespec.h/timespec - /time.h/timespec

typedef enum anon_enum_32 {
    kCAFChannelLayoutTag_UseChannelDescriptions=0,
    _ISblank=1,
    _IScntrl=2,
    _ISpunct=4,
    _ISalnum=8,
    _ISupper=256,
    _ISlower=512,
    _ISalpha=1024,
    _ISdigit=2048,
    _ISxdigit=4096,
    _ISspace=8192,
    _ISprint=16384,
    _ISgraph=32768,
    kCAFChannelLayoutTag_UseChannelBitmap=65536
} anon_enum_32;

typedef struct JunkChunk JunkChunk, *PJunkChunk;

typedef __uint32_t uint32_t;

struct JunkChunk {
    char ckID[4];
    uint32_t ckSize;
    char junk[28];
};

typedef struct CS64Chunk CS64Chunk, *PCS64Chunk;

typedef __uint64_t uint64_t;

struct CS64Chunk {
    char ckID[4];
    uint64_t chunkSize64;
};

typedef struct DS64Chunk DS64Chunk, *PDS64Chunk;

struct DS64Chunk {
    uint64_t riffSize64;
    uint64_t dataSize64;
    uint64_t sampleCount64;
    uint32_t tableLength;
};


// WARNING! conflicting data type names: /DWARF/glob.h/glob_t - /glob.h/glob_t

typedef struct _IO_wide_data _IO_wide_data, *P_IO_wide_data;

struct _IO_wide_data {
};


// WARNING! conflicting data type names: /DWARF/_UNCATEGORIZED_/_IO_marker - /libio.h/_IO_marker

typedef struct __va_list_tag __va_list_tag, *P__va_list_tag;

struct __va_list_tag {
    uint gp_offset;
    uint fp_offset;
    void *overflow_arg_area;
    void *reg_save_area;
};

typedef struct __va_list_tag __builtin_va_list[1];

typedef struct _IO_codecvt _IO_codecvt, *P_IO_codecvt;

struct _IO_codecvt {
};

typedef __builtin_va_list __gnuc_va_list;

typedef __gnuc_va_list va_list;


// WARNING! conflicting data type names: /DWARF/siginfo_t.h/siginfo_t - /siginfo.h/siginfo_t

typedef union anon_union_112_8_26c2b70a_for__sifields anon_union_112_8_26c2b70a_for__sifields, *Panon_union_112_8_26c2b70a_for__sifields;

typedef struct anon_struct_8_2_0a3d7222_for__kill anon_struct_8_2_0a3d7222_for__kill, *Panon_struct_8_2_0a3d7222_for__kill;

typedef struct anon_struct_16_3_5124685d_for__timer anon_struct_16_3_5124685d_for__timer, *Panon_struct_16_3_5124685d_for__timer;

typedef struct anon_struct_16_3_9bedbd60_for__rt anon_struct_16_3_9bedbd60_for__rt, *Panon_struct_16_3_9bedbd60_for__rt;

typedef struct anon_struct_32_5_7a6ff138_for__sigchld anon_struct_32_5_7a6ff138_for__sigchld, *Panon_struct_32_5_7a6ff138_for__sigchld;

typedef struct anon_struct_32_3_f01937af_for__sigfault anon_struct_32_3_f01937af_for__sigfault, *Panon_struct_32_3_f01937af_for__sigfault;

typedef struct anon_struct_16_2_3c0246b2_for__sigpoll anon_struct_16_2_3c0246b2_for__sigpoll, *Panon_struct_16_2_3c0246b2_for__sigpoll;

typedef struct anon_struct_16_3_349d2ff7_for__sigsys anon_struct_16_3_349d2ff7_for__sigsys, *Panon_struct_16_3_349d2ff7_for__sigsys;

typedef union anon_union_16_2_200698a6_for__bounds anon_union_16_2_200698a6_for__bounds, *Panon_union_16_2_200698a6_for__bounds;

typedef struct anon_struct_16_2_6c587c7a_for__addr_bnd anon_struct_16_2_6c587c7a_for__addr_bnd, *Panon_struct_16_2_6c587c7a_for__addr_bnd;

struct anon_struct_16_2_6c587c7a_for__addr_bnd {
    void *_lower;
    void *_upper;
};

union anon_union_16_2_200698a6_for__bounds {
    struct anon_struct_16_2_6c587c7a_for__addr_bnd _addr_bnd;
    __uint32_t _pkey;
};

struct anon_struct_16_2_3c0246b2_for__sigpoll {
    long si_band;
    int si_fd;
};

struct anon_struct_32_3_f01937af_for__sigfault {
    void *si_addr;
    short si_addr_lsb;
    union anon_union_16_2_200698a6_for__bounds _bounds;
};

struct anon_struct_16_3_349d2ff7_for__sigsys {
    void *_call_addr;
    int _syscall;
    uint _arch;
};

struct anon_struct_16_3_9bedbd60_for__rt {
    __pid_t si_pid;
    __uid_t si_uid;
    __sigval_t si_sigval;
};

struct anon_struct_16_3_5124685d_for__timer {
    int si_tid;
    int si_overrun;
    __sigval_t si_sigval;
};

struct anon_struct_32_5_7a6ff138_for__sigchld {
    __pid_t si_pid;
    __uid_t si_uid;
    int si_status;
    __clock_t si_utime;
    __clock_t si_stime;
};

struct anon_struct_8_2_0a3d7222_for__kill {
    __pid_t si_pid;
    __uid_t si_uid;
};

union anon_union_112_8_26c2b70a_for__sifields {
    int _pad[28];
    struct anon_struct_8_2_0a3d7222_for__kill _kill;
    struct anon_struct_16_3_5124685d_for__timer _timer;
    struct anon_struct_16_3_9bedbd60_for__rt _rt;
    struct anon_struct_32_5_7a6ff138_for__sigchld _sigchld;
    struct anon_struct_32_3_f01937af_for__sigfault _sigfault;
    struct anon_struct_16_2_3c0246b2_for__sigpoll _sigpoll;
    struct anon_struct_16_3_349d2ff7_for__sigsys _sigsys;
};

typedef struct sigaction sigaction, *Psigaction;

typedef union anon_union_8_2_5ad2d23e_for___sigaction_handler anon_union_8_2_5ad2d23e_for___sigaction_handler, *Panon_union_8_2_5ad2d23e_for___sigaction_handler;

typedef struct __sigset_t __sigset_t, *P__sigset_t;

typedef void (*__sighandler_t)(int);

struct __sigset_t {
    ulong __val[16];
};

union anon_union_8_2_5ad2d23e_for___sigaction_handler {
    __sighandler_t sa_handler;
    void (*sa_sigaction)(int, struct siginfo_t *, void *);
};

struct sigaction {
    union anon_union_8_2_5ad2d23e_for___sigaction_handler __sigaction_handler;
    struct __sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
};

typedef __int32_t int32_t;

typedef __int64_t int64_t;

typedef struct Wave64FileHeader Wave64FileHeader, *PWave64FileHeader;

struct Wave64FileHeader {
    char ckID[16];
    int64_t ckSize;
    char formType[16];
};

typedef struct Wave64ChunkHeader Wave64ChunkHeader, *PWave64ChunkHeader;

struct Wave64ChunkHeader {
    char ckID[16];
    int64_t ckSize;
};

typedef struct WavpackConfig WavpackConfig, *PWavpackConfig;

struct WavpackConfig {
    float bitrate;
    float shaping_weight;
    int bits_per_sample;
    int bytes_per_sample;
    int qmode;
    int flags;
    int xmode;
    int num_channels;
    int float_norm_exp;
    int32_t block_samples;
    int32_t extra_flags;
    int32_t sample_rate;
    int32_t channel_mask;
    uchar md5_checksum[16];
    uchar md5_read;
    int num_tag_strings;
    char **tag_strings;
};

typedef struct WavpackContext WavpackContext, *PWavpackContext;

struct WavpackContext {
};

typedef struct RiffChunkHeader RiffChunkHeader, *PRiffChunkHeader;

struct RiffChunkHeader {
    char ckID[4];
    uint32_t ckSize;
    char formType[4];
};

typedef struct ChunkHeader ChunkHeader, *PChunkHeader;

struct ChunkHeader {
    char ckID[4];
    uint32_t ckSize;
};

typedef struct WaveHeader WaveHeader, *PWaveHeader;

typedef __uint16_t uint16_t;

struct WaveHeader {
    uint16_t FormatTag;
    uint16_t NumChannels;
    uint32_t SampleRate;
    uint32_t BytesPerSecond;
    uint16_t BlockAlign;
    uint16_t BitsPerSample;
    uint16_t cbSize;
    uint16_t ValidBitsPerSample;
    int32_t ChannelMask;
    uint16_t SubFormat;
    char GUID[14];
};

typedef struct DSFFileChunk DSFFileChunk, *PDSFFileChunk;

struct DSFFileChunk {
    char ckID[4];
    int64_t ckSize;
    int64_t fileSize;
    int64_t metaOffset;
};

typedef struct DSFChunkHeader DSFChunkHeader, *PDSFChunkHeader;

struct DSFChunkHeader {
    char ckID[4];
    int64_t ckSize;
};

typedef struct DSFFormatChunk DSFFormatChunk, *PDSFFormatChunk;

struct DSFFormatChunk {
    char ckID[4];
    int64_t ckSize;
    uint32_t formatVersion;
    uint32_t formatID;
    uint32_t chanType;
    uint32_t numChannels;
    uint32_t sampleRate;
    uint32_t bitsPerSample;
    int64_t sampleCount;
    uint32_t blockSize;
    uint32_t reserved;
};

typedef struct timeval timeval, *Ptimeval;

struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};

typedef struct write_id write_id, *Pwrite_id;


// WARNING! conflicting data type names: /DWARF/FILE.h/FILE - /stdio.h/FILE

struct write_id {
    uint32_t bytes_written;
    uint32_t first_block_size;
    FILE *file;
    int error;
};

typedef struct tag_item tag_item, *Ptag_item;

struct tag_item {
    char *item;
    char *value;
    char *ext;
    int vsize;
    int binary;
};

typedef struct anon_struct_40_5_c3e56e25 anon_struct_40_5_c3e56e25, *Panon_struct_40_5_c3e56e25;

struct anon_struct_40_5_c3e56e25 {
    uchar id;
    char *fourcc;
    char *default_extension;
    int (*ParseHeader)(FILE *, char *, char *, struct WavpackContext *, struct WavpackConfig *);
    int chunk_alignment;
};

typedef struct CAFChunkHeader CAFChunkHeader, *PCAFChunkHeader;

struct CAFChunkHeader {
    char mChunkType[4];
    int64_t mChunkSize;
};

typedef struct CAFChannelDescription CAFChannelDescription, *PCAFChannelDescription;

struct CAFChannelDescription {
    uint32_t mChannelLabel;
    uint32_t mChannelFlags;
    float mCoordinates[3];
};

typedef struct anon_struct_24_4_3b78efaa anon_struct_24_4_3b78efaa, *Panon_struct_24_4_3b78efaa;

struct anon_struct_24_4_3b78efaa {
    uint32_t mChannelLayoutTag;
    uint32_t mChannelBitmap;
    char *mChannelReorder;
    char *mChannelIdentities;
};

typedef struct CAFAudioFormat CAFAudioFormat, *PCAFAudioFormat;

struct CAFAudioFormat {
    double mSampleRate;
    char mFormatID[4];
    uint32_t mFormatFlags;
    uint32_t mBytesPerPacket;
    uint32_t mFramesPerPacket;
    uint32_t mChannelsPerFrame;
    uint32_t mBitsPerChannel;
};

typedef struct CAFFileHeader CAFFileHeader, *PCAFFileHeader;

struct CAFFileHeader {
    char mFileType[4];
    uint16_t mFileVersion;
    uint16_t mFileFlags;
};

typedef struct CAFChannelLayout CAFChannelLayout, *PCAFChannelLayout;

struct CAFChannelLayout {
    uint32_t mChannelLayoutTag;
    uint32_t mChannelBitmap;
    uint32_t mNumberChannelDescriptions;
};

typedef struct anon_struct_16_2_68a0f6fb anon_struct_16_2_68a0f6fb, *Panon_struct_16_2_68a0f6fb;

struct anon_struct_16_2_68a0f6fb {
    char *id3_item;
    char *ape_item;
};

typedef struct timezone timezone, *Ptimezone;

struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};


// WARNING! conflicting data type names: /DWARF/struct_FILE.h/_IO_FILE - /stdio.h/_IO_FILE

typedef struct DFFChunkHeader DFFChunkHeader, *PDFFChunkHeader;

struct DFFChunkHeader {
    char ckID[4];
    int64_t ckDataSize;
};

typedef struct DFFCompressionHeader DFFCompressionHeader, *PDFFCompressionHeader;

struct DFFCompressionHeader {
    char ckID[4];
    int64_t ckDataSize;
    char compressionType[4];
};

typedef struct DFFChannelsHeader DFFChannelsHeader, *PDFFChannelsHeader;

struct DFFChannelsHeader {
    char ckID[4];
    int64_t ckDataSize;
    uint16_t numChannels;
};

typedef struct DFFFileHeader DFFFileHeader, *PDFFFileHeader;

struct DFFFileHeader {
    char ckID[4];
    int64_t ckDataSize;
    char formType[4];
};

typedef struct DFFVersionChunk DFFVersionChunk, *PDFFVersionChunk;

struct DFFVersionChunk {
    char ckID[4];
    int64_t ckDataSize;
    uint32_t version;
};

typedef struct DFFSampleRateChunk DFFSampleRateChunk, *PDFFSampleRateChunk;

struct DFFSampleRateChunk {
    char ckID[4];
    int64_t ckDataSize;
    uint32_t sampleRate;
};

typedef void *iconv_t;

typedef struct timezone *__timezone_ptr_t;

typedef union _union_1457 _union_1457, *P_union_1457;


// WARNING! conflicting data type names: /signal.h/__sighandler_t - /DWARF/signal.h/__sighandler_t

union _union_1457 {
    __sighandler_t sa_handler;
    void (*sa_sigaction)(int, siginfo_t *, void *);
};


// WARNING! conflicting data type names: /sigaction.h/sigaction - /DWARF/sigaction.h/sigaction

typedef struct __sigset_t sigset_t;

typedef enum Elf_ProgramHeaderType {
    PT_NULL=0,
    PT_LOAD=1,
    PT_DYNAMIC=2,
    PT_INTERP=3,
    PT_NOTE=4,
    PT_SHLIB=5,
    PT_PHDR=6,
    PT_TLS=7,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_STACK=1685382481,
    PT_GNU_RELRO=1685382482
} Elf_ProgramHeaderType;

typedef struct Elf64_Shdr Elf64_Shdr, *PElf64_Shdr;

typedef enum Elf_SectionHeaderType {
    SHT_NULL=0,
    SHT_PROGBITS=1,
    SHT_SYMTAB=2,
    SHT_STRTAB=3,
    SHT_RELA=4,
    SHT_HASH=5,
    SHT_DYNAMIC=6,
    SHT_NOTE=7,
    SHT_NOBITS=8,
    SHT_REL=9,
    SHT_SHLIB=10,
    SHT_DYNSYM=11,
    SHT_INIT_ARRAY=14,
    SHT_FINI_ARRAY=15,
    SHT_PREINIT_ARRAY=16,
    SHT_GROUP=17,
    SHT_SYMTAB_SHNDX=18,
    SHT_ANDROID_REL=1610612737,
    SHT_ANDROID_RELA=1610612738,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_CHECKSUM=1879048184,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_syminfo=1879048188,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191
} Elf_SectionHeaderType;

struct Elf64_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType sh_type;
    qword sh_flags;
    qword sh_addr;
    qword sh_offset;
    qword sh_size;
    dword sh_link;
    dword sh_info;
    qword sh_addralign;
    qword sh_entsize;
};

typedef struct Elf64_Rela Elf64_Rela, *PElf64_Rela;

struct Elf64_Rela {
    qword r_offset; // location to apply the relocation action
    qword r_info; // the symbol table index and the type of relocation
    qword r_addend; // a constant addend used to compute the relocatable field value
};

typedef struct Elf64_Dyn Elf64_Dyn, *PElf64_Dyn;

typedef enum Elf64_DynTag {
    DT_NULL=0,
    DT_NEEDED=1,
    DT_PLTRELSZ=2,
    DT_PLTGOT=3,
    DT_HASH=4,
    DT_STRTAB=5,
    DT_SYMTAB=6,
    DT_RELA=7,
    DT_RELASZ=8,
    DT_RELAENT=9,
    DT_STRSZ=10,
    DT_SYMENT=11,
    DT_INIT=12,
    DT_FINI=13,
    DT_SONAME=14,
    DT_RPATH=15,
    DT_SYMBOLIC=16,
    DT_REL=17,
    DT_RELSZ=18,
    DT_RELENT=19,
    DT_PLTREL=20,
    DT_DEBUG=21,
    DT_TEXTREL=22,
    DT_JMPREL=23,
    DT_BIND_NOW=24,
    DT_INIT_ARRAY=25,
    DT_FINI_ARRAY=26,
    DT_INIT_ARRAYSZ=27,
    DT_FINI_ARRAYSZ=28,
    DT_RUNPATH=29,
    DT_FLAGS=30,
    DT_PREINIT_ARRAY=32,
    DT_PREINIT_ARRAYSZ=33,
    DT_RELRSZ=35,
    DT_RELR=36,
    DT_RELRENT=37,
    DT_ANDROID_REL=1610612751,
    DT_ANDROID_RELSZ=1610612752,
    DT_ANDROID_RELA=1610612753,
    DT_ANDROID_RELASZ=1610612754,
    DT_ANDROID_RELR=1879040000,
    DT_ANDROID_RELRSZ=1879040001,
    DT_ANDROID_RELRENT=1879040003,
    DT_GNU_PRELINKED=1879047669,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_CHECKSUM=1879047672,
    DT_PLTPADSZ=1879047673,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_FEATURE_1=1879047676,
    DT_POSFLAG_1=1879047677,
    DT_SYMINSZ=1879047678,
    DT_SYMINENT=1879047679,
    DT_GNU_XHASH=1879047924,
    DT_GNU_HASH=1879047925,
    DT_TLSDESC_PLT=1879047926,
    DT_TLSDESC_GOT=1879047927,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_LIBLIST=1879047929,
    DT_CONFIG=1879047930,
    DT_DEPAUDIT=1879047931,
    DT_AUDIT=1879047932,
    DT_PLTPAD=1879047933,
    DT_MOVETAB=1879047934,
    DT_SYMINFO=1879047935,
    DT_VERSYM=1879048176,
    DT_RELACOUNT=1879048185,
    DT_RELCOUNT=1879048186,
    DT_FLAGS_1=1879048187,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_AUXILIARY=2147483645,
    DT_FILTER=2147483647
} Elf64_DynTag;

struct Elf64_Dyn {
    enum Elf64_DynTag d_tag;
    qword d_val;
};

typedef struct GnuBuildId GnuBuildId, *PGnuBuildId;

struct GnuBuildId {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
    byte hash[20];
};

typedef struct NoteGnuProperty_4 NoteGnuProperty_4, *PNoteGnuProperty_4;

struct NoteGnuProperty_4 {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
};

typedef struct Elf64_Ehdr Elf64_Ehdr, *PElf64_Ehdr;

struct Elf64_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_osabi;
    byte e_ident_abiversion;
    byte e_ident_pad[7];
    word e_type;
    word e_machine;
    dword e_version;
    qword e_entry;
    qword e_phoff;
    qword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};

typedef struct Elf64_Phdr Elf64_Phdr, *PElf64_Phdr;

struct Elf64_Phdr {
    enum Elf_ProgramHeaderType p_type;
    dword p_flags;
    qword p_offset;
    qword p_vaddr;
    qword p_paddr;
    qword p_filesz;
    qword p_memsz;
    qword p_align;
};

typedef struct Elf64_Sym Elf64_Sym, *PElf64_Sym;

struct Elf64_Sym {
    dword st_name;
    byte st_info;
    byte st_other;
    word st_shndx;
    qword st_value;
    qword st_size;
};

typedef struct NoteAbiTag NoteAbiTag, *PNoteAbiTag;

struct NoteAbiTag {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
    dword abiType; // 0 == Linux
    dword requiredKernelVersion[3]; // Major.minor.patch
};




int _init(EVP_PKEY_CTX *ctx)

{
  int iVar1;
  
  iVar1 = 0x11e058;
  if (true) {
    iVar1 = __gmon_start__();
  }
  return iVar1;
}



void FUN_00104020(void)

{
  (*(code *)(undefined *)0x0)();
  return;
}



void FUN_001047b0(void)

{
  __cxa_finalize();
  return;
}



void WavpackAppendTagItem(void)

{
  WavpackAppendTagItem();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double log10(double __x)

{
  double dVar1;
  
  dVar1 = log10(__x);
  return dVar1;
}



void WavpackBigEndianToNative(void)

{
  WavpackBigEndianToNative();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fileno(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fileno(__stream);
  return iVar1;
}



void __stpcpy_chk(void)

{
  __stpcpy_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memset(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memset(__s,__c,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long ftell(FILE *__stream)

{
  long lVar1;
  
  lVar1 = ftell(__stream);
  return lVar1;
}



void WavpackGetBinaryTagItem(void)

{
  WavpackGetBinaryTagItem();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * stpcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = stpcpy(__dest,__src);
  return pcVar1;
}



void __fprintf_chk(void)

{
  __fprintf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int utimes(char *__file,timeval *__tvp)

{
  int iVar1;
  
  iVar1 = utimes(__file,__tvp);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int puts(char *__s)

{
  int iVar1;
  
  iVar1 = puts(__s);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fseek(FILE *__stream,long __off,int __whence)

{
  int iVar1;
  
  iVar1 = fseek(__stream,__off,__whence);
  return iVar1;
}



void WavpackOpenFileInput(void)

{
  WavpackOpenFileInput();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void exit(int __status)

{
                    // WARNING: Subroutine does not return
  exit(__status);
}



void __printf_chk(void)

{
  __printf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strcasecmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcasecmp(__s1,__s2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int gettimeofday(timeval *__tv,__timezone_ptr_t __tz)

{
  int iVar1;
  
  iVar1 = gettimeofday(__tv,__tz);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strpbrk(char *__s,char *__accept)

{
  char *pcVar1;
  
  pcVar1 = strpbrk(__s,__accept);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * fopen(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen(__filename,__modes);
  return pFVar1;
}



void WavpackFreeWrapper(void)

{
  WavpackFreeWrapper();
  return;
}



void WavpackWriteTag(void)

{
  WavpackWriteTag();
  return;
}



void WavpackGetBitsPerSample(void)

{
  WavpackGetBitsPerSample();
  return;
}



void WavpackGetChannelIdentities(void)

{
  WavpackGetChannelIdentities();
  return;
}



void __memcpy_chk(void)

{
  __memcpy_chk();
  return;
}



void WavpackGetEncodedNoise(void)

{
  WavpackGetEncodedNoise();
  return;
}



void WavpackSetFileInformation(void)

{
  WavpackSetFileInformation();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

iconv_t iconv_open(char *__tocode,char *__fromcode)

{
  iconv_t pvVar1;
  
  pvVar1 = iconv_open(__tocode,__fromcode);
  return pvVar1;
}



void WavpackGetNumSamples(void)

{
  WavpackGetNumSamples();
  return;
}



void WavpackAppendBinaryTagItem(void)

{
  WavpackAppendBinaryTagItem();
  return;
}



void WavpackGetErrorMessage(void)

{
  WavpackGetErrorMessage();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ungetc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = ungetc(__c,__stream);
  return iVar1;
}



void WavpackGetTagItemIndexed(void)

{
  WavpackGetTagItemIndexed();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fputc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputc(__c,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void free(void *__ptr)

{
  free(__ptr);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



void WavpackUpdateNumSamples(void)

{
  WavpackUpdateNumSamples();
  return;
}



void WavpackGetChannelLayout(void)

{
  WavpackGetChannelLayout();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ferror(FILE *__stream)

{
  int iVar1;
  
  iVar1 = ferror(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __xstat(int __ver,char *__filename,stat *__stat_buf)

{
  int iVar1;
  
  iVar1 = __xstat(__ver,__filename,__stat_buf);
  return iVar1;
}



void WavpackGetBytesPerSample(void)

{
  WavpackGetBytesPerSample();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int MD5_Final(uchar *md,MD5_CTX *c)

{
  int iVar1;
  
  iVar1 = MD5_Final(md,c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int MD5_Update(MD5_CTX *c,void *data,size_t len)

{
  int iVar1;
  
  iVar1 = MD5_Update(c,data,len);
  return iVar1;
}



void WavpackGetProgress(void)

{
  WavpackGetProgress();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ushort ** __ctype_b_loc(void)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  return ppuVar1;
}



void __vsprintf_chk(void)

{
  __vsprintf_chk();
  return;
}



void WavpackGetNumTagItems(void)

{
  WavpackGetNumTagItems();
  return;
}



void WavpackGetAverageBitrate(void)

{
  WavpackGetAverageBitrate();
  return;
}



void WavpackNativeToBigEndian(void)

{
  WavpackNativeToBigEndian();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fgetc(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fgetc(__stream);
  return iVar1;
}



void WavpackGetLibraryVersionString(void)

{
  WavpackGetLibraryVersionString();
  return;
}



void WavpackGetBinaryTagItemIndexed(void)

{
  WavpackGetBinaryTagItemIndexed();
  return;
}



void WavpackPackInit(void)

{
  WavpackPackInit();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t iconv(iconv_t __cd,char **__inbuf,size_t *__inbytesleft,char **__outbuf,
            size_t *__outbytesleft)

{
  size_t sVar1;
  
  sVar1 = iconv(__cd,__inbuf,__inbytesleft,__outbuf,__outbytesleft);
  return sVar1;
}



void WavpackFlushSamples(void)

{
  WavpackFlushSamples();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strstr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strstr(__haystack,__needle);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigaction(int __sig,sigaction *__act,sigaction *__oact)

{
  int iVar1;
  
  iVar1 = sigaction(__sig,__act,__oact);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcat(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcat(__dest,__src);
  return pcVar1;
}



void WavpackGetFloatNormExp(void)

{
  WavpackGetFloatNormExp();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fputs(char *__s,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputs(__s,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,__endptr,__base);
  return lVar1;
}



void WavpackGetFileExtension(void)

{
  WavpackGetFileExtension();
  return;
}



void WavpackGetNumSamples64(void)

{
  WavpackGetNumSamples64();
  return;
}



void WavpackGetChannelMask(void)

{
  WavpackGetChannelMask();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double exp2(double __x)

{
  double dVar1;
  
  dVar1 = exp2(__x);
  return dVar1;
}



void WavpackPackSamples(void)

{
  WavpackPackSamples();
  return;
}



void WavpackUnpackSamples(void)

{
  WavpackUnpackSamples();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memmove(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memmove(__dest,__src,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strchr(__s,__c);
  return pcVar1;
}



void WavpackGetWrapperData(void)

{
  WavpackGetWrapperData();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __fxstat(int __ver,int __fildes,stat *__stat_buf)

{
  int iVar1;
  
  iVar1 = __fxstat(__ver,__fildes,__stat_buf);
  return iVar1;
}



void WavpackGetSampleRate(void)

{
  WavpackGetSampleRate();
  return;
}



void WavpackGetWrapperBytes(void)

{
  WavpackGetWrapperBytes();
  return;
}



void WavpackGetRatio(void)

{
  WavpackGetRatio();
  return;
}



void WavpackGetNumErrors(void)

{
  WavpackGetNumErrors();
  return;
}



void WavpackLittleEndianToNative(void)

{
  WavpackLittleEndianToNative();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strdup(char *__s)

{
  char *pcVar1;
  
  pcVar1 = strdup(__s);
  return pcVar1;
}



void WavpackNativeToLittleEndian(void)

{
  WavpackNativeToLittleEndian();
  return;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}



void WavpackGetFileFormat(void)

{
  WavpackGetFileFormat();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcpy(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int MD5_Init(MD5_CTX *c)

{
  int iVar1;
  
  iVar1 = MD5_Init(c);
  return iVar1;
}



void WavpackSetConfiguration64(void)

{
  WavpackSetConfiguration64();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int glob(char *__pattern,int __flags,__errfunc *__errfunc,glob_t *__pglob)

{
  int iVar1;
  
  iVar1 = glob(__pattern,__flags,__errfunc,__pglob);
  return iVar1;
}



void WavpackLossyBlocks(void)

{
  WavpackLossyBlocks();
  return;
}



void WavpackGetMD5Sum(void)

{
  WavpackGetMD5Sum();
  return;
}



void WavpackAddWrapper(void)

{
  WavpackAddWrapper();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__int32_t ** __ctype_tolower_loc(void)

{
  __int32_t **pp_Var1;
  
  pp_Var1 = __ctype_tolower_loc();
  return pp_Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int memcmp(void *__s1,void *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = memcmp(__s1,__s2,__n);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * calloc(size_t __nmemb,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = calloc(__nmemb,__size);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void globfree(glob_t *__pglob)

{
  globfree(__pglob);
  return;
}



void WavpackGetTagItem(void)

{
  WavpackGetTagItem();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}



void WavpackGetNumChannels(void)

{
  WavpackGetNumChannels();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int remove(char *__filename)

{
  int iVar1;
  
  iVar1 = remove(__filename);
  return iVar1;
}



void WavpackOpenFileOutput(void)

{
  WavpackOpenFileOutput();
  return;
}



void WavpackDeleteTagItem(void)

{
  WavpackDeleteTagItem();
  return;
}



void WavpackSetChannelLayout(void)

{
  WavpackSetChannelLayout();
  return;
}



void __sprintf_chk(void)

{
  __sprintf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ftruncate(int __fd,__off_t __length)

{
  int iVar1;
  
  iVar1 = ftruncate(__fd,__length);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigemptyset(sigset_t *__set)

{
  int iVar1;
  
  iVar1 = sigemptyset(__set);
  return iVar1;
}



void WavpackGetQualifyMode(void)

{
  WavpackGetQualifyMode();
  return;
}



void WavpackGetNumBinaryTagItems(void)

{
  WavpackGetNumBinaryTagItems();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}



void WavpackCloseFile(void)

{
  WavpackCloseFile();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * realloc(void *__ptr,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = realloc(__ptr,__size);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * setlocale(int __category,char *__locale)

{
  char *pcVar1;
  
  pcVar1 = setlocale(__category,__locale);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double floor(double __x)

{
  double dVar1;
  
  dVar1 = floor(__x);
  return dVar1;
}



void WavpackStoreMD5Sum(void)

{
  WavpackStoreMD5Sum();
  return;
}



void WavpackGetMode(void)

{
  WavpackGetMode();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



void WavpackGetSampleIndex64(void)

{
  WavpackGetSampleIndex64();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int iconv_close(iconv_t __cd)

{
  int iVar1;
  
  iVar1 = iconv_close(__cd);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int rename(char *__old,char *__new)

{
  int iVar1;
  
  iVar1 = rename(__old,__new);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double strtod(char *__nptr,char **__endptr)

{
  double dVar1;
  
  dVar1 = strtod(__nptr,__endptr);
  return dVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fflush(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fflush(__stream);
  return iVar1;
}



int main(int argc,char **argv)

{
  float fVar1;
  char **ppcVar2;
  ushort *puVar3;
  ushort uVar4;
  bool bVar5;
  __time_t _Var6;
  __suseconds_t _Var7;
  __time_t _Var8;
  __suseconds_t _Var9;
  undefined uVar10;
  char cVar11;
  byte bVar12;
  int iVar13;
  uint uVar14;
  undefined4 uVar15;
  int32_t iVar16;
  int iVar17;
  int iVar18;
  int iVar19;
  char *pcVar20;
  size_t sVar21;
  undefined8 uVar22;
  FILE *pFVar23;
  undefined8 *puVar24;
  char *pcVar25;
  undefined8 *puVar26;
  FILE *hFile;
  int64_t iVar27;
  char *pcVar28;
  iconv_t __cd;
  size_t sVar29;
  uint *puVar30;
  void *pvVar31;
  float *data;
  long lVar32;
  float *pfVar33;
  uint *puVar34;
  uchar *puVar35;
  ushort **ppuVar36;
  long lVar37;
  ulong uVar38;
  long lVar39;
  float *pfVar40;
  undefined *puVar41;
  uint uVar42;
  uint uVar43;
  uint *puVar44;
  undefined4 *puVar45;
  uint3 uVar46;
  uint uVar47;
  uint uVar48;
  int iVar49;
  uchar uVar50;
  int iVar51;
  WavpackConfig *pWVar52;
  byte *pbVar53;
  uint *puVar54;
  write_id *pwVar55;
  char **ppcVar56;
  void *pvVar57;
  byte *pbVar58;
  char *pcVar59;
  byte *__s1;
  char *pcVar60;
  tag_item *ptVar61;
  long lVar62;
  uint uVar63;
  tag_item *ptVar64;
  long in_FS_OFFSET;
  bool bVar65;
  bool bVar66;
  bool bVar67;
  byte bVar68;
  double dVar69;
  double dVar70;
  double dVar71;
  undefined8 *local_2358;
  WavpackContext *local_2350;
  uint *local_2340;
  WavpackConfig *local_2330;
  double local_2318;
  double local_2310;
  uint *local_22f0;
  uchar *local_22e0;
  uint *local_22c0;
  int local_22b8;
  uint *local_22a8;
  double local_2280;
  __timezone_ptr_t local_2278;
  double peak;
  timezone timez;
  timeval time1;
  timeval time2;
  write_id wv_file;
  char *long_param;
  FILE *local_2200;
  WavpackConfig config;
  WavpackConfig loc_config;
  int params [3];
  uchar md5_verify [16];
  uchar md5_display [16];
  char cratio [16];
  char error [80];
  char name [6];
  undefined local_2030 [8176];
  long local_40;
  
  bVar68 = 0;
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  pcVar20 = filespec_name(*argv);
  if (pcVar20 == (char *)0x0) {
LAB_00105031:
    if (debug_logging_mode != 0) goto LAB_00104fc1;
    pWVar52 = &config;
    for (lVar37 = 0x16; lVar37 != 0; lVar37 = lVar37 + -1) {
      pWVar52->bitrate = 0.0;
      pWVar52 = (WavpackConfig *)((long)pWVar52 + (ulong)bVar68 * -8 + 4);
    }
    if (argc == 1) goto LAB_00107d28;
LAB_0010505d:
    local_2330 = &config;
    iVar13 = 0;
    local_2358 = (undefined8 *)0x0;
    ppcVar56 = argv + (ulong)(argc - 2) + 1;
    bVar5 = false;
    local_2340 = (uint *)0x0;
    iVar51 = 0;
    do {
      while( true ) {
        pcVar20 = argv[1];
        argv = argv + 1;
        if (*pcVar20 != '-') break;
        if (pcVar20[1] == '-') {
          if (pcVar20[2] != '\0') {
            __s1 = (byte *)(pcVar20 + 2);
            pbVar58 = __s1;
            do {
              bVar67 = false;
              bVar66 = *pbVar58 == 0;
              long_param = (char *)pbVar58;
              if (bVar66) break;
              long_param = (char *)(pbVar58 + 1);
              bVar67 = *pbVar58 < 0x3d;
              bVar66 = *pbVar58 == 0x3d;
              pbVar58 = (byte *)long_param;
            } while (!bVar66);
            lVar37 = 5;
            pbVar58 = __s1;
            pbVar53 = &DAT_001152fd;
            do {
              if (lVar37 == 0) break;
              lVar37 = lVar37 + -1;
              bVar67 = *pbVar58 < *pbVar53;
              bVar66 = *pbVar58 == *pbVar53;
              pbVar58 = pbVar58 + (ulong)bVar68 * -2 + 1;
              pbVar53 = pbVar53 + (ulong)bVar68 * -2 + 1;
            } while (bVar66);
            bVar65 = false;
            bVar67 = (!bVar67 && !bVar66) == bVar67;
            if (bVar67) {
              puts(
                  " Usage:\n    WAVPACK [-options] infile[.wav]|infile.ext|- [...] [-o outfile[.wv]|outpath|-]\n\n    The default operation is lossless. Multiple input files may be specified\n    and the source file type is automatically determined (see accepted formats\n    below). Raw PCM data may also be used (see --raw-pcm option).\n\n All Utilities:             WAVPACK:  create or transcode WavPack files\n                            WVUNPACK: unpack or verify existing WavPack files\n                            WVGAIN:   apply ReplayGain to WavPack files\n                            WVTAG:    apply or edit metadata tags on WavPack files\n\n Input Formats:             .wav (default, includes bwf/rf64 varients)\n                            .wv  (transcode operation, tags copied)\n                            .caf (Core Audio Format)\n                            .w64 (Sony Wave64)\n                            .dff (Philips DSDIFF)\n                            .dsf (Sony DSD stream)\n\n Options:\n    -a                      Adobe Audition (CoolEdit) mode for 32-bit floats\n    --allow-huge-tags       allow tag data up to 16 MB (embedding > 1 MB is not\n                             recommended for portable devices and may not work\n                             with some programs including WavPack pre-4.70)\n    -bn                     enable hybrid compression\n                              n = 2.0 to 23.9 bits/sample, or\n                              n = 24-9600 kbits/second (kbps)\n                              add -c to create correction file (.wvc)\n    --blocksize=n           specify block size in samples (max = 131072 and\n                               min = 16 with --merge-blocks, otherwise 128)\n    -c                      hybrid lossless mode (use with -b to create\n                             correction file (.wvc) in hybrid mode)\n    -cc                     maximum hybrid lossless compression (but degrades\n                             decode speed and may result in lower quality)\n    --channel-order=<list>  specify (comma separated) channel order if ..." /* TRUNCATED STRING LITERAL */
                  );
              uVar48 = 0;
            }
            else {
              lVar37 = 8;
              pbVar58 = __s1;
              pbVar53 = (byte *)"version";
              do {
                if (lVar37 == 0) break;
                lVar37 = lVar37 + -1;
                bVar65 = *pbVar58 < *pbVar53;
                bVar67 = *pbVar58 == *pbVar53;
                pbVar58 = pbVar58 + (ulong)bVar68 * -2 + 1;
                pbVar53 = pbVar53 + (ulong)bVar68 * -2 + 1;
              } while (bVar67);
              bVar66 = false;
              bVar67 = (!bVar65 && !bVar67) == bVar65;
              if (!bVar67) {
                lVar37 = 0xe;
                pbVar58 = __s1;
                pbVar53 = (byte *)"optimize-mono";
                do {
                  if (lVar37 == 0) break;
                  lVar37 = lVar37 + -1;
                  bVar66 = *pbVar58 < *pbVar53;
                  bVar67 = *pbVar58 == *pbVar53;
                  pbVar58 = pbVar58 + (ulong)bVar68 * -2 + 1;
                  pbVar53 = pbVar53 + (ulong)bVar68 * -2 + 1;
                } while (bVar67);
                if ((!bVar66 && !bVar67) == bVar66) {
                  error_line("warning: --optimize-mono deprecated, now enabled by default");
                  iVar17 = num_channels_order;
                  uVar48 = config.channel_mask;
                }
                else {
                  iVar17 = strcmp((char *)__s1,"dns");
                  if (iVar17 == 0) {
                    error_line("warning: --dns deprecated, use --use-dns");
                    iVar51 = iVar51 + 1;
                    iVar17 = num_channels_order;
                    uVar48 = config.channel_mask;
                  }
                  else {
                    iVar17 = strcmp((char *)__s1,"use-dns");
                    if (iVar17 == 0) {
                      config.flags._2_1_ = config.flags._2_1_ | 2;
                      iVar17 = num_channels_order;
                      uVar48 = config.channel_mask;
                    }
                    else {
                      iVar17 = strcmp((char *)__s1,"cross-decorr");
                      if (iVar17 == 0) {
                        config.flags._0_2_ = (ushort)config.flags | 0x20;
                        iVar17 = num_channels_order;
                        uVar48 = config.channel_mask;
                      }
                      else {
                        iVar17 = strcmp((char *)__s1,"merge-blocks");
                        if (iVar17 == 0) {
                          config.flags._3_1_ = config.flags._3_1_ | 0x10;
                          iVar17 = num_channels_order;
                          uVar48 = config.channel_mask;
                        }
                        else {
                          iVar17 = strcmp((char *)__s1,"pair-unassigned-chans");
                          if (iVar17 == 0) {
                            config.flags._3_1_ = config.flags._3_1_ | 0x20;
                            iVar17 = num_channels_order;
                            uVar48 = config.channel_mask;
                          }
                          else {
                            iVar17 = strcmp((char *)__s1,"import-id3");
                            if (iVar17 == 0) {
                              import_id3 = 1;
                              iVar17 = num_channels_order;
                              uVar48 = config.channel_mask;
                            }
                            else {
                              iVar17 = strcmp((char *)__s1,"no-utf8-convert");
                              if (iVar17 == 0) {
                                no_utf8_convert = 1;
                                iVar17 = num_channels_order;
                                uVar48 = config.channel_mask;
                              }
                              else {
                                iVar17 = strcmp((char *)__s1,"allow-huge-tags");
                                if (iVar17 == 0) {
                                  allow_huge_tags = 1;
                                  iVar17 = num_channels_order;
                                  uVar48 = config.channel_mask;
                                }
                                else {
                                  iVar17 = strcmp((char *)__s1,"write-binary-tag");
                                  if (iVar17 == 0) {
                                    iVar13 = 2;
                                    iVar17 = num_channels_order;
                                    uVar48 = config.channel_mask;
                                  }
                                  else {
                                    iVar17 = strncmp((char *)__s1,"raw-pcm-skip",0xc);
                                    if (iVar17 == 0) {
                                      lVar37 = strtol(long_param,&long_param,10);
                                      iVar17 = (int)lVar37;
                                      raw_pcm_skip_bytes_begin = iVar17;
                                      if (*long_param == ',') {
                                        long_param = long_param + 1;
                                        lVar37 = strtol(long_param,&long_param,10);
                                        raw_pcm_skip_bytes_end = (int)lVar37;
                                      }
                                      if (((*long_param != '\0') || (iVar17 < 0)) ||
                                         (raw_pcm_skip_bytes_end < 0)) {
                                        error_line("syntax error in raw-pcm-skip specification!");
                                        iVar51 = iVar51 + 1;
                                      }
                                      error_line("raw_pcm_skip = %d, %d bytes",
                                                 (ulong)(uint)raw_pcm_skip_bytes_begin,
                                                 (ulong)(uint)raw_pcm_skip_bytes_end);
                                      iVar17 = num_channels_order;
                                      uVar48 = config.channel_mask;
                                    }
                                    else {
                                      iVar17 = strncmp((char *)__s1,"raw-pcm",7);
                                      if (iVar17 == 0) {
                                        lVar37 = 0;
                                        iVar18 = 0;
                                        params[0] = 0xac44;
                                        params[1] = 0x10;
                                        params[2] = 2;
                                        bVar66 = false;
                                        bVar67 = false;
                                        while( true ) {
                                          pbVar58 = (byte *)long_param;
                                          cVar11 = *long_param;
                                          bVar65 = false;
                                          if (cVar11 == '\0') break;
                                          if (lVar37 == 3) {
                                            iVar17 = strcasecmp(long_param,"be");
                                            if (iVar17 == 0) {
                                              pbVar58 = (byte *)((char *)pbVar58 + 2);
                                              bVar65 = true;
                                              long_param = (char *)pbVar58;
LAB_00109357:
                                              if (*pbVar58 == 0) break;
                                            }
                                            else {
                                              iVar17 = strcasecmp((char *)pbVar58,"le");
                                              if (iVar17 == 0) {
                                                pbVar58 = (byte *)((char *)pbVar58 + 2);
                                                bVar65 = false;
                                                long_param = (char *)pbVar58;
                                                goto LAB_00109357;
                                              }
                                            }
                                            error_line("syntax error in raw PCM specification!");
                                            iVar51 = iVar51 + 1;
                                            iVar17 = num_channels_order;
                                            uVar48 = config.channel_mask;
                                            goto LAB_00105106;
                                          }
                                          ppuVar36 = __ctype_b_loc();
                                          if ((*(byte *)((long)*ppuVar36 + (long)cVar11 * 2 + 1) & 8
                                              ) != 0) {
                                            lVar62 = strtol((char *)pbVar58,&long_param,10);
                                            params[lVar37] = (int)lVar62;
                                            pbVar58 = (byte *)long_param;
                                          }
                                          if (lVar37 == 1) {
                                            bVar12 = *pbVar58 & 0xdf;
                                            if (bVar12 == 0x46) {
                                              pbVar58 = pbVar58 + 1;
                                              iVar18 = 1;
                                              long_param = (char *)pbVar58;
                                            }
                                            else if (bVar12 == 0x55) {
                                              pbVar58 = pbVar58 + 1;
                                              bVar67 = true;
                                              long_param = (char *)pbVar58;
                                            }
                                            else if (bVar12 == 0x53) {
                                              pbVar58 = pbVar58 + 1;
                                              bVar66 = true;
                                              long_param = (char *)pbVar58;
                                            }
                                          }
                                          lVar37 = lVar37 + 1;
                                          if (*pbVar58 != 0x2c) goto LAB_00109357;
                                          long_param = (char *)(pbVar58 + 1);
                                        }
                                        if ((((params[0] - 1U < 1000000000) &&
                                             (params[1] - 1U < 0x20)) &&
                                            ((params[1] == 0x20 || (iVar18 == 0)))) &&
                                           (params[2] - 1U < 0x100)) {
                                          uVar14 = CONCAT22(config.qmode._2_2_,
                                                            CONCAT11(config.qmode._1_1_,
                                                                     (byte)config.qmode));
                                          uVar48 = config.channel_mask;
                                          iVar17 = num_channels_order;
                                          if (params[1] == 1) {
                                            config.sample_rate = params[0] >> 3;
                                            config.num_channels = params[2];
                                            config.qmode._0_1_ = (byte)(uVar14 | 0x1020);
                                            config.qmode._1_1_ = (byte)((uVar14 | 0x1020) >> 8);
                                            config.bits_per_sample = 8;
                                            config.bytes_per_sample = 1;
                                          }
                                          else {
                                            config.sample_rate = params[0];
                                            config.bytes_per_sample = params[1] + 7 >> 3;
                                            config.bits_per_sample = params[1];
                                            config.num_channels = params[2];
                                            config.float_norm_exp = iVar18;
                                            if (iVar18 != 0) {
                                              config.float_norm_exp = 0x7f;
                                            }
                                            config.qmode._1_1_ = config.qmode._1_1_ | 0x10;
                                            if (params[1] < 9) {
                                              if (bVar66) {
                                                config.qmode._0_1_ = (byte)(uVar14 | 0x1002);
                                                config.qmode._1_1_ = (byte)((uVar14 | 0x1002) >> 8);
                                              }
                                            }
                                            else {
                                              if (bVar67) {
                                                config.qmode._0_1_ = (byte)(uVar14 | 0x1004);
                                                config.qmode._1_1_ = (byte)((uVar14 | 0x1004) >> 8);
                                              }
                                              if (bVar65) {
                                                config.qmode._0_1_ = (byte)config.qmode | 1;
                                              }
                                            }
                                          }
                                        }
                                        else {
                                          error_line(
                                                  "argument range error in raw PCM specification!");
                                          iVar51 = iVar51 + 1;
                                          iVar17 = num_channels_order;
                                          uVar48 = config.channel_mask;
                                        }
                                      }
                                      else {
                                        iVar17 = strncmp((char *)__s1,"blocksize",9);
                                        if (iVar17 == 0) {
                                          lVar37 = strtol(long_param,(char **)0x0,10);
                                          config.block_samples = (int32_t)lVar37;
                                          iVar17 = num_channels_order;
                                          uVar48 = config.channel_mask;
                                          if (0x1fff0 < config.block_samples - 0x10U) {
                                            error_line("invalid blocksize!");
                                            iVar51 = iVar51 + 1;
                                            iVar17 = num_channels_order;
                                            uVar48 = config.channel_mask;
                                          }
                                        }
                                        else {
                                          iVar17 = strncmp((char *)__s1,"channel-order",0xd);
                                          if (iVar17 == 0) {
                                            puVar35 = channel_order;
                                            pcVar20 = long_param;
                                            uVar48 = 0;
                                            do {
                                              iVar17 = (int)puVar35 + -0x11d080;
                                              if (*pcVar20 == '\0') goto LAB_00105106;
                                              if (*pcVar20 == '.') {
                                                long_param = pcVar20 + 1;
                                                if (((pcVar20[1] == '.') &&
                                                    (long_param = pcVar20 + 2, pcVar20[2] == '.'))
                                                   && (pcVar28 = pcVar20 + 3, long_param = pcVar28,
                                                      pcVar20[3] == '\0')) {
                                                  config.qmode._1_1_ = config.qmode._1_1_ | 4;
                                                  goto LAB_0010917b;
                                                }
LAB_001090f8:
                                                error_line(
                                                  "syntax error in channel order specification!");
                                                iVar51 = iVar51 + 1;
                                                iVar17 = num_channels_order;
                                                uVar48 = config.channel_mask;
                                                goto LAB_00105106;
                                              }
                                              ppuVar36 = __ctype_b_loc();
                                              lVar37 = 0;
                                              puVar3 = *ppuVar36;
                                              pcVar28 = pcVar20;
                                              while( true ) {
                                                lVar62 = (long)(int)lVar37;
                                                if ((*(byte *)((long)puVar3 + (long)*pcVar28 * 2 + 1
                                                              ) & 4) == 0) break;
                                                if (lVar37 == 5) {
                                                  lVar62 = 5;
                                                  goto LAB_00109084;
                                                }
                                                long_param = pcVar28 + 1;
                                                name[lVar37] = *pcVar28;
                                                lVar37 = lVar37 + 1;
                                                pcVar28 = long_param;
                                              }
                                              if ((int)lVar37 == 0) goto LAB_001090f8;
LAB_00109084:
                                              name[lVar62] = '\0';
                                              uVar38 = 0;
                                              while (iVar17 = strcasecmp(name,speakers[uVar38]),
                                                    iVar17 != 0) {
                                                uVar38 = uVar38 + 1;
                                                if (uVar38 == 0x12) goto LAB_001090d8;
                                              }
                                              *puVar35 = (byte)uVar38;
                                              uVar14 = uVar48 | (uint)(1L << ((byte)uVar38 & 0x3f));
                                              if ((uVar48 >> (uVar38 & 0x3f) & 1) != 0) {
LAB_001090d8:
                                                error_line("unknown or repeated channel spec: %s!",
                                                           name);
                                                goto LAB_001090f8;
                                              }
                                              pcVar20 = pcVar28;
                                              if ((*pcVar28 != '\0') &&
                                                 (pcVar20 = pcVar28 + 1, long_param = pcVar20,
                                                 *pcVar28 != ',')) goto LAB_001090f8;
                                              puVar35 = puVar35 + 1;
                                              uVar48 = uVar14;
                                            } while (puVar35 != &DAT_0011d092);
                                            iVar17 = 0x12;
                                            pcVar28 = pcVar20;
LAB_0010917b:
                                            if (*pcVar28 != '\0') {
                                              error_line("too many channels specified!");
                                              iVar51 = iVar51 + 1;
                                              iVar17 = num_channels_order;
                                              uVar48 = config.channel_mask;
                                            }
                                          }
                                          else {
                                            iVar17 = strncmp((char *)__s1,"pre-quantize-round",0x12)
                                            ;
                                            if (iVar17 == 0) {
                                              lVar37 = strtol(long_param,(char **)0x0,10);
                                              quantize_bits = (int)lVar37;
                                              quantize_round = quantize_bits;
                                            }
                                            else {
                                              iVar17 = strncmp((char *)__s1,"pre-quantize",0xc);
                                              if (iVar17 != 0) {
                                                error_line("unknown option: %s !",__s1);
                                                iVar51 = iVar51 + 1;
                                                iVar17 = num_channels_order;
                                                uVar48 = config.channel_mask;
                                                goto LAB_00105106;
                                              }
                                              lVar37 = strtol(long_param,(char **)0x0,10);
                                              quantize_bits = (int)lVar37;
                                            }
                                            iVar17 = num_channels_order;
                                            uVar48 = config.channel_mask;
                                            if (0x1c < quantize_bits - 4U) {
                                              error_line("invalid quantize bits!");
                                              iVar51 = iVar51 + 1;
                                              iVar17 = num_channels_order;
                                              uVar48 = config.channel_mask;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                goto LAB_00105106;
              }
              __printf_chk(1,"wavpack %s\n","5.1.0");
              uVar22 = WavpackGetLibraryVersionString();
              __printf_chk(1,"libwavpack %s\n",uVar22);
              uVar48 = 0;
            }
            goto LAB_00106250;
          }
        }
        else if (pcVar20[1] == '\0') break;
        *argv = pcVar20 + 1;
        cVar11 = pcVar20[1];
        while (iVar17 = num_channels_order, uVar48 = config.channel_mask, cVar11 != '\0') {
          if (false) {
switchD_00105322_caseD_45:
            error_line("illegal option: %c !",(ulong)(uint)(int)cVar11);
            iVar51 = iVar51 + 1;
            goto LAB_00105340;
          }
          switch(cVar11) {
          case 'A':
          case 'a':
            config.qmode._1_1_ = config.qmode._1_1_ | 1;
            break;
          case 'B':
          case 'b':
            config.flags._0_2_ = (ushort)config.flags | 8;
            *argv = pcVar20 + 2;
            dVar70 = strtod(pcVar20 + 2,argv);
            *argv = *argv + -1;
            config.bitrate = (float)dVar70;
            if ((config.bitrate < 2.0) || (9600.0 < config.bitrate)) {
              error_line("hybrid spec must be 2.0 to 9600!");
              iVar51 = iVar51 + 1;
            }
            if (24.0 <= config.bitrate) {
              config.flags._0_2_ = (ushort)config.flags | 0x2000;
            }
            break;
          case 'C':
          case 'c':
            uVar48 = CONCAT13(config.flags._3_1_,CONCAT12(config.flags._2_1_,(ushort)config.flags));
            uVar14 = uVar48 | 0x100000;
            if ((config.flags._2_1_ & 8) == 0) {
              uVar14 = uVar48 | 0x80000;
            }
            config.flags._0_2_ = (ushort)uVar14;
            config.flags._2_1_ = (byte)(uVar14 >> 0x10);
            config.flags._3_1_ = (byte)(uVar14 >> 0x18);
            break;
          case 'D':
          case 'd':
            delete_source = 1;
            break;
          default:
            goto switchD_00105322_caseD_45;
          case 'F':
          case 'f':
            config.flags._0_2_ = (ushort)config.flags | 0x200;
            break;
          case 'H':
          case 'h':
            uVar4 = 0x1000;
            if (((ushort)config.flags & 0x800) == 0) {
              uVar4 = 0x800;
            }
            config.flags._0_2_ = (ushort)config.flags | uVar4;
            break;
          case 'I':
          case 'i':
            config.qmode._1_1_ = config.qmode._1_1_ | 8;
            break;
          case 'J':
          case 'j':
            *argv = pcVar20 + 2;
            lVar37 = strtol(pcVar20 + 2,argv,10);
            if (lVar37 == 0) {
              uVar48 = CONCAT13(config.flags._3_1_,CONCAT12(config.flags._2_1_,(ushort)config.flags)
                               ) & 0xffffffef;
              config.flags._2_1_ = (byte)(uVar48 >> 0x10) | 1;
              config.flags._0_2_ = (ushort)uVar48;
              config.flags._3_1_ = (byte)(uVar48 >> 0x18);
            }
            else if (lVar37 == 1) {
              uVar48 = CONCAT13(config.flags._3_1_,CONCAT12(config.flags._2_1_,(ushort)config.flags)
                               ) | 0x10010;
              config.flags._0_2_ = (ushort)uVar48;
              config.flags._2_1_ = (byte)(uVar48 >> 0x10);
            }
            else {
              error_line("-j0 or -j1 only!");
              iVar51 = iVar51 + 1;
            }
            goto LAB_001053b2;
          case 'M':
          case 'm':
            config.flags._3_1_ = config.flags._3_1_ | 8;
            break;
          case 'N':
          case 'n':
            config.flags._2_1_ = config.flags._2_1_ | 0x80;
            break;
          case 'O':
          case 'o':
            bVar5 = true;
            break;
          case 'Q':
          case 'q':
            quiet_mode = 1;
            break;
          case 'R':
          case 'r':
            config.qmode._1_1_ = config.qmode._1_1_ | 2;
            break;
          case 'S':
          case 's':
            *argv = pcVar20 + 2;
            dVar70 = strtod(pcVar20 + 2,argv);
            config.shaping_weight = (float)dVar70;
            if ((false) || (config.shaping_weight != 0.0)) {
              if ((config.shaping_weight < -1.0) || (1.0 < config.shaping_weight)) {
                error_line("-s-1.00 to -s1.00 only!");
                iVar51 = iVar51 + 1;
              }
              else {
                config.flags._0_2_ = (ushort)config.flags | 0x8040;
              }
            }
            else {
              uVar48 = CONCAT13(config.flags._3_1_,CONCAT12(config.flags._2_1_,(ushort)config.flags)
                               ) & 0xffffffbf;
              config.flags._0_2_ = (ushort)uVar48 | 0x8000;
              config.flags._2_1_ = (byte)(uVar48 >> 0x10);
              config.flags._3_1_ = (byte)(uVar48 >> 0x18);
            }
            goto LAB_001053b2;
          case 'T':
          case 't':
            copy_time = 1;
            break;
          case 'V':
          case 'v':
            verify_mode = 1;
            break;
          case 'W':
          case 'w':
            iVar13 = iVar13 + 1;
            if (iVar13 == 2) {
              error_line("warning: -ww deprecated, use --write-binary-tag");
              iVar51 = iVar51 + 1;
            }
            break;
          case 'X':
          case 'x':
            *argv = pcVar20 + 2;
            lVar37 = strtol(pcVar20 + 2,argv,10);
            config.xmode = (int)lVar37;
            if ((uint)config.xmode < 7) {
              config.flags._3_1_ = config.flags._3_1_ | 2;
            }
            else {
              error_line("extra mode only goes from 1 to 6!");
              iVar51 = iVar51 + 1;
            }
LAB_001053b2:
            *argv = *argv + -1;
            break;
          case 'Y':
          case 'y':
            overwrite_all = 1;
            break;
          case 'Z':
          case 'z':
            *argv = pcVar20 + 2;
            lVar37 = strtol(pcVar20 + 2,argv,10);
            *argv = *argv + -1;
            set_console_title = (int)lVar37;
          }
LAB_00105340:
          pcVar20 = *argv;
          *argv = pcVar20 + 1;
          cVar11 = pcVar20[1];
        }
LAB_00105106:
        config.channel_mask = uVar48;
        num_channels_order = iVar17;
        if (argv == ppcVar56) goto LAB_0010516d;
      }
      if (iVar13 != 0) {
        iVar17 = strcasecmp(pcVar20,"encoder");
        if (iVar17 == 0) {
          pcVar28 = (char *)malloc(0x50);
          __sprintf_chk(pcVar28,1,0x50,"%s=WavPack %s",pcVar20,"5.1.0");
          *argv = pcVar28;
        }
        else {
          iVar17 = strcasecmp(pcVar20,"settings");
          pcVar28 = pcVar20;
          if (iVar17 == 0) {
            make_settings_string(name,local_2330);
            puVar54 = (uint *)name;
            do {
              puVar34 = puVar54;
              uVar14 = *puVar34 + 0xfefefeff & ~*puVar34;
              uVar48 = uVar14 & 0x80808080;
              puVar54 = puVar34 + 1;
            } while (uVar48 == 0);
            bVar67 = (uVar14 & 0x8080) == 0;
            if (bVar67) {
              uVar48 = uVar48 >> 0x10;
            }
            if (bVar67) {
              puVar54 = (uint *)((long)puVar34 + 6);
            }
            pcVar28 = (char *)malloc((size_t)((long)puVar54 +
                                             (-(long)name - (ulong)CARRY1((byte)uVar48,(byte)uVar48)
                                             ) + 0xd));
            __sprintf_chk(pcVar28,1,0xffffffffffffffff,"%s=%s",*argv,name);
            *argv = pcVar28;
          }
        }
        pcVar20 = strchr(pcVar28,0x3d);
        if ((pcVar20 == (char *)0x0) || (pcVar20 <= pcVar28)) {
          iVar13 = 0;
          error_line("error in tag spec: %s !",pcVar28);
          iVar51 = iVar51 + 1;
          iVar17 = num_channels_order;
          uVar48 = config.channel_mask;
        }
        else {
          num_tag_items = num_tag_items + 1;
          lVar37 = (long)num_tag_items;
          tag_items = (tag_item *)realloc(tag_items,lVar37 * 0x20);
          ptVar61 = tag_items + lVar37 + -1;
          pcVar28 = (char *)malloc((size_t)(pcVar20 + (1 - (long)*argv)));
          ptVar61->item = pcVar28;
          sVar21 = (long)pcVar20 - (long)*argv;
          memcpy(pcVar28,*argv,sVar21);
          ptVar61->item[sVar21] = '\0';
          sVar21 = strlen(pcVar20 + 1);
          ptVar61->vsize = (int)sVar21;
          pcVar28 = (char *)malloc((long)((int)sVar21 + 1));
          ptVar61->value = pcVar28;
          strcpy(pcVar28,pcVar20 + 1);
          bVar67 = iVar13 == 2;
          ptVar61->ext = (char *)0x0;
          iVar13 = 0;
          ptVar61->binary = (uint)bVar67;
          iVar17 = num_channels_order;
          uVar48 = config.channel_mask;
        }
        goto LAB_00105106;
      }
      if (!bVar5) {
        iVar13 = num_files + 1;
        local_2358 = (undefined8 *)realloc(local_2358,(long)iVar13 * 8);
        sVar21 = strlen(pcVar20);
        pvVar31 = malloc(sVar21 + 10);
        local_2358[(long)iVar13 + -1] = pvVar31;
        pcVar20 = (char *)memcpy(pvVar31,pcVar20,sVar21 + 1);
        if ((*pcVar20 != '-') && (*pcVar20 != '@')) {
          pcVar20 = filespec_ext(pcVar20);
          iVar13 = num_files;
          if (pcVar20 == (char *)0x0) {
            pcVar20 = ".wav";
            if ((config.qmode._1_1_ & 0x10) != 0) {
              pcVar20 = ".raw";
            }
            strcat((char *)local_2358[num_files],pcVar20);
            iVar13 = iVar13 + 1;
          }
          else {
            iVar13 = num_files + 1;
          }
        }
        num_files = iVar13;
        iVar13 = 0;
        iVar17 = num_channels_order;
        uVar48 = config.channel_mask;
        goto LAB_00105106;
      }
      sVar21 = strlen(pcVar20);
      local_2340 = (uint *)malloc(sVar21 + 0x1000);
      memcpy(local_2340,pcVar20,sVar21 + 1);
      bVar5 = false;
    } while (argv != ppcVar56);
LAB_0010516d:
    setup_break();
    if (bVar5) {
      error_line("no output filename or path specified with -o option!");
      iVar51 = iVar51 + 1;
    }
    if (iVar13 != 0) {
      pcVar20 = "-w";
      if (iVar13 != 1) {
        pcVar20 = "--write-binary-tag";
      }
      error_line("no tag specified with %s option!",pcVar20);
      iVar51 = iVar51 + 1;
    }
  }
  else {
    pcVar20 = filespec_name(*argv);
    pcVar20 = strstr(pcVar20,"ebug");
    if (pcVar20 == (char *)0x0) {
      pcVar20 = filespec_name(*argv);
      pcVar20 = strstr(pcVar20,"DEBUG");
      if (pcVar20 == (char *)0x0) goto LAB_00105031;
    }
    debug_logging_mode = 1;
LAB_00104fc1:
    if (argc != 1) {
      uVar38 = 1;
      ppcVar56 = argv;
      do {
        ppcVar2 = ppcVar56 + 1;
        uVar48 = (int)uVar38 + 1;
        ppcVar56 = ppcVar56 + 1;
        error_line("arg %d: %s",uVar38,*ppcVar2);
        uVar38 = (ulong)uVar48;
      } while (argc != uVar48);
      pWVar52 = &config;
      for (lVar37 = 0x16; lVar37 != 0; lVar37 = lVar37 + -1) {
        pWVar52->bitrate = 0.0;
        pWVar52 = (WavpackConfig *)((long)pWVar52 + (ulong)bVar68 * -8 + 4);
      }
      goto LAB_0010505d;
    }
    pWVar52 = &config;
    for (lVar37 = 0x16; lVar37 != 0; lVar37 = lVar37 + -1) {
      pWVar52->bitrate = 0.0;
      pWVar52 = (WavpackConfig *)((long)pWVar52 + (ulong)bVar68 * -8 + 4);
    }
LAB_00107d28:
    setup_break();
    local_2358 = (undefined8 *)0x0;
    local_2340 = (uint *)0x0;
    iVar51 = 0;
  }
  local_2330 = &config;
  if ((~CONCAT13(config.flags._3_1_,CONCAT12(config.flags._2_1_,(ushort)config.flags)) & 0xa00) == 0
     ) {
    error_line("high and fast modes are mutually exclusive!");
    iVar51 = iVar51 + 1;
  }
  if ((config.qmode._1_1_ & 8) == 0) {
    if ((verify_mode != 0) && (local_2340 != (uint *)0x0)) {
LAB_00105919:
      if (*(char *)local_2340 == '-') {
        error_line("can\'t verify output file when using stdout!");
        iVar51 = iVar51 + 1;
      }
    }
LAB_001051ff:
    uVar48 = CONCAT13(config.flags._3_1_,CONCAT12(config.flags._2_1_,(ushort)config.flags));
    if (((ushort)config.flags & 8) == 0) goto LAB_001061a5;
    if ((((config.flags._2_1_ & 8) != 0) && (local_2340 != (uint *)0x0)) &&
       (*(char *)local_2340 == '-')) {
      error_line("can\'t create correction file when using stdout!");
      iVar51 = iVar51 + 1;
      uVar48 = CONCAT13(config.flags._3_1_,CONCAT12(config.flags._2_1_,(ushort)config.flags));
    }
LAB_00105228:
    if ((uVar48 & 0x10000000) != 0) {
      error_line("--merge-blocks option is for lossless mode only!");
      uVar48 = CONCAT13(config.flags._3_1_,CONCAT12(config.flags._2_1_,(ushort)config.flags));
      iVar51 = iVar51 + 1;
      if ((CONCAT12(config.flags._2_1_,(ushort)config.flags) & 0x28000) == 0x28000)
      goto LAB_00107426;
      goto LAB_001061b0;
    }
    if ((uVar48 & 0x28000) == 0x28000) {
LAB_00107426:
      error_line("-s and --use-dns options are mutually exclusive!");
      iVar51 = iVar51 + 1;
      uVar48 = (uint)config.flags._3_1_ << 0x18;
      goto LAB_001061b0;
    }
LAB_00105243:
    if ((config.block_samples == 0) || (0x7f < config.block_samples)) goto LAB_00105257;
    error_line("minimum blocksize is 128 when --merge-blocks is not specified!");
LAB_001061dc:
    iVar51 = iVar51 + 1;
    pcVar20 = (char *)WavpackGetLibraryVersionString();
    iVar13 = strcmp(pcVar20,"5.1.0");
    if (iVar13 != 0) goto LAB_00105c1b;
    if (0 < num_tag_items) goto LAB_00105c5d;
LAB_00106220:
    fwrite("\ntype \'wavpack\' for short help or \'wavpack --help\' for full help\n",1,0x41,stderr);
    fflush(stderr);
    uVar48 = 1;
    goto LAB_00106250;
  }
  if (local_2340 != (uint *)0x0) {
    if (*(char *)local_2340 == '-') {
      error_line("can\'t ignore length in header when using stdout!");
      iVar51 = iVar51 + 1;
    }
    if (verify_mode != 0) goto LAB_00105919;
    goto LAB_001051ff;
  }
  uVar48 = CONCAT13(config.flags._3_1_,CONCAT12(config.flags._2_1_,(ushort)config.flags));
  if (((ushort)config.flags & 8) != 0) goto LAB_00105228;
LAB_001061a5:
  if ((uVar48 & 0x8a8000) != 0) {
    error_line("-c, -n, -s, and --use-dns options are for hybrid mode (-b) only!");
    iVar51 = iVar51 + 1;
    uVar48 = (uint)config.flags._3_1_ << 0x18;
  }
LAB_001061b0:
  if ((uVar48 & 0x10000000) == 0) goto LAB_00105243;
  if (config.block_samples == 0) {
    error_line("--merge-blocks only makes sense when --blocksize is specified!");
    goto LAB_001061dc;
  }
LAB_00105257:
  pcVar20 = (char *)WavpackGetLibraryVersionString();
  iVar13 = strcmp(pcVar20,"5.1.0");
  if (iVar13 == 0) {
    if (iVar51 != 0 || quiet_mode != 0) goto LAB_00105c50;
    uVar22 = WavpackGetLibraryVersionString();
    __fprintf_chk(stderr,1,
                  "\n WAVPACK  Hybrid Lossless Audio Compressor  %s Version %s\n Copyright (c) 1998 - 2019 David Bryant.  All Rights Reserved.\n\n"
                  ,"Linux",uVar22);
    fflush(stderr);
    if (0 < num_tag_items) {
      iVar51 = 0;
      goto LAB_00105c5d;
    }
  }
  else {
LAB_00105c1b:
    uVar22 = WavpackGetLibraryVersionString();
    __fprintf_chk(stderr,1,
                  "\n WARNING: WAVPACK using libwavpack version %s, expected %s (see README)\n\n",
                  uVar22,"5.1.0");
    fflush(stderr);
LAB_00105c50:
    if (0 < num_tag_items) {
LAB_00105c5d:
      lVar37 = 0;
      ptVar61 = tag_items;
      do {
        ptVar64 = ptVar61 + lVar37;
        pcVar20 = ptVar64->value;
        if (*pcVar20 == '@') {
          pcVar28 = pcVar20 + 1;
          hFile = wild_fopen(pcVar28,pcVar20);
          if (hFile == (FILE *)0x0) {
            if (num_files == 0) {
LAB_00106105:
              if (local_2340 != (uint *)0x0) {
LAB_00106111:
                pcVar20 = filespec_name((char *)local_2340);
                if ((pcVar20 != (char *)0x0) && (*(char *)local_2340 != '-')) {
                  uVar38 = 0xffffffffffffffff;
                  puVar54 = local_2340;
                  do {
                    if (uVar38 == 0) break;
                    uVar38 = uVar38 - 1;
                    cVar11 = *(char *)puVar54;
                    puVar54 = (uint *)((long)puVar54 + (ulong)bVar68 * -2 + 1);
                  } while (cVar11 != '\0');
                  pcVar25 = (char *)malloc(~uVar38 + 0xfff);
                  memcpy(pcVar25,local_2340,~uVar38);
                  pcVar59 = filespec_name(pcVar25);
                  pcVar20 = pcVar28;
                  strcpy(pcVar59,pcVar28);
                  hFile = wild_fopen(pcVar25,pcVar20);
                  free(pcVar25);
                  goto LAB_00106188;
                }
              }
            }
            else {
              pcVar20 = (char *)*local_2358;
              pcVar25 = filespec_name(pcVar20);
              if ((pcVar25 == (char *)0x0) || (*pcVar20 == '-')) goto LAB_00106105;
              uVar38 = 0xffffffffffffffff;
              pcVar25 = pcVar20;
              do {
                if (uVar38 == 0) break;
                uVar38 = uVar38 - 1;
                cVar11 = *pcVar25;
                pcVar25 = pcVar25 + (ulong)bVar68 * -2 + 1;
              } while (cVar11 != '\0');
              pcVar25 = (char *)malloc(~uVar38 + 0xfff);
              memcpy(pcVar25,pcVar20,~uVar38);
              pcVar59 = filespec_name(pcVar25);
              pcVar20 = pcVar28;
              strcpy(pcVar59,pcVar28);
              hFile = wild_fopen(pcVar25,pcVar20);
              free(pcVar25);
              if (hFile != (FILE *)0x0) goto LAB_00105db0;
              if (local_2340 != (uint *)0x0) goto LAB_00106111;
LAB_00106188:
              if (hFile != (FILE *)0x0) goto LAB_00105db0;
            }
          }
          else {
LAB_00105db0:
            iVar27 = DoGetFileSize(hFile);
            tag_items[lVar37].vsize = (int)iVar27;
            pcVar20 = filespec_ext(pcVar28);
            if (pcVar20 != (char *)0x0) {
              pcVar20 = filespec_ext(pcVar28);
              ptVar61 = tag_items;
              pcVar20 = strdup(pcVar20);
              ptVar61[lVar37].ext = pcVar20;
            }
            ptVar61 = tag_items;
            if (tag_items[lVar37].vsize <
                (int)((-(uint)(allow_huge_tags == 0) & 0xff100000) + 0x1000000)) {
              pcVar20 = (char *)calloc((long)(tag_items[lVar37].vsize + 2),1);
              iVar13 = DoReadFile(hFile,pcVar20,ptVar61[lVar37].vsize,(uint32_t *)&long_param);
              if ((iVar13 != 0) && (tag_items[lVar37].vsize == (int)long_param)) {
                DoCloseHandle(hFile);
                ptVar61 = tag_items;
                free(tag_items[lVar37].value);
                ptVar61[lVar37].value = pcVar20;
                goto LAB_00105cfd;
              }
              free(pcVar20);
              DoCloseHandle(hFile);
            }
            else {
              DoCloseHandle(hFile);
            }
          }
          error_line("error in tag spec: %s !",tag_items[lVar37].value);
          iVar51 = iVar51 + 1;
LAB_00105cfd:
          ptVar61 = tag_items;
          ptVar64 = tag_items + lVar37;
          if (ptVar64->binary == 0) goto LAB_00105c78;
          sVar21 = strlen(ptVar64->item);
          iVar13 = (int)sVar21;
          if (ptVar64->ext == (char *)0x0) {
            lVar62 = 0;
            iVar17 = iVar13;
          }
          else {
            sVar21 = strlen(ptVar64->ext);
            lVar62 = (long)(int)sVar21;
            iVar17 = (int)sVar21 + iVar13;
          }
          pcVar20 = (char *)realloc(ptVar64->value,(long)(ptVar64->vsize + iVar17 + 1));
          ptVar64->value = pcVar20;
          memmove(pcVar20 + lVar62 + 1 + (long)iVar13,pcVar20,(long)ptVar64->vsize);
          strcpy(ptVar64->value,ptVar64->item);
          if (ptVar64->ext != (char *)0x0) {
            strcat(ptVar64->value,ptVar64->ext);
          }
          iVar13 = iVar17 + 1 + ptVar64->vsize;
          ptVar64->vsize = iVar13;
        }
        else {
          if (ptVar64->binary != 0) {
            error_line("binary tags must be from files: %s !");
            iVar51 = iVar51 + 1;
            goto LAB_00105cfd;
          }
LAB_00105c78:
          if (ptVar64->vsize == 0) {
            iVar13 = tag_items[lVar37].vsize;
            ptVar61 = tag_items;
          }
          else {
            pcVar20 = (char *)realloc(ptVar64->value,(long)(ptVar64->vsize * 2 + 1));
            iVar13 = no_utf8_convert;
            ptVar64->value = pcVar20;
            if (iVar13 == 0) {
              iVar13 = ptVar64->vsize * 2;
              sVar21 = (size_t)(iVar13 + 1);
              pvVar31 = calloc(sVar21,1);
              long_param = (char *)(long)iVar13;
              wv_file.bytes_written = 0;
              wv_file.first_block_size = 0;
              time1.tv_sec = (__time_t)pvVar31;
              time2.tv_sec = (__time_t)pcVar20;
              if ((((iVar13 + 1 < 4) || (*pcVar20 != -0x11)) || (pcVar20[1] != -0x45)) ||
                 (pcVar20[2] != -0x41)) {
                pcVar28 = setlocale(0,"");
                if ((*(char *)time2.tv_sec == -1) && (*(char *)(time2.tv_sec + 1) == -2)) {
                  if (*(short *)(time2.tv_sec + 2) != 0) {
                    lVar62 = time2.tv_sec - wv_file._0_8_;
                    do {
                      wv_file._0_8_ = wv_file._0_8_ + 2;
                    } while (*(short *)(lVar62 + 2 + wv_file._0_8_) != 0);
                  }
                  time2.tv_sec = time2.tv_sec + 2;
                  __cd = iconv_open("UTF-8","UTF-16LE");
                }
                else {
                  uVar38 = 0xffffffffffffffff;
                  pcVar25 = pcVar20;
                  do {
                    if (uVar38 == 0) break;
                    uVar38 = uVar38 - 1;
                    cVar11 = *pcVar25;
                    pcVar25 = pcVar25 + (ulong)bVar68 * -2 + 1;
                  } while (cVar11 != '\0');
                  wv_file._0_8_ = ~uVar38 - 1;
                  __cd = iconv_open("UTF-8","");
                }
                if (__cd == (iconv_t)0xffffffffffffffff) {
                  setlocale(0,pcVar28);
                }
                else {
                  sVar29 = iconv(__cd,(char **)&time2,(size_t *)&wv_file,(char **)&time1,
                                 (size_t *)&long_param);
                  iconv_close(__cd);
                  setlocale(0,pcVar28);
                  if ((int)sVar29 != -1) {
                    memmove(pcVar20,pvVar31,sVar21);
                  }
                }
                free(pvVar31);
              }
              else {
                memmove(pcVar20,pcVar20 + 3,(long)(iVar13 + -2));
                pcVar20[sVar21 - 3] = '\0';
              }
            }
            ptVar61 = tag_items;
            pcVar20 = tag_items[lVar37].value;
            if (((2 < tag_items[lVar37].vsize) && (*pcVar20 == -0x11)) &&
               ((pcVar20[1] == -0x45 && (pcVar20[2] == -0x41)))) {
              iVar13 = tag_items[lVar37].vsize + -3;
              tag_items[lVar37].vsize = iVar13;
              memmove(pcVar20,pcVar20 + 3,(long)iVar13);
              ptVar61[lVar37].value[ptVar61[lVar37].vsize] = '\0';
              pcVar20 = ptVar61[lVar37].value;
            }
            sVar21 = strlen(pcVar20);
            iVar13 = (int)sVar21;
            ptVar61[lVar37].vsize = iVar13;
          }
        }
        total_tag_size = iVar13 + total_tag_size;
        if ((int)((-(uint)(allow_huge_tags == 0) & 0xff100000) + 0x1000000) < total_tag_size) {
          error_line("total APEv2 tag size exceeds %d MB !",
                     (ulong)((-(uint)(allow_huge_tags == 0) & 0xfffffff1) + 0x10));
          goto LAB_00106220;
        }
        lVar37 = lVar37 + 1;
      } while ((int)lVar37 < num_tag_items);
    }
    if (iVar51 != 0) goto LAB_00106220;
  }
  pcVar20 = (char *)0x0;
  if (num_files == 0) {
    puts(
        " Usage:   WAVPACK [-options] infile[.wav]|infile.ext|- [...] [-o outfile[.wv]|outpath|-]\n             (default is lossless; multiple input files allowed)\n\n Utils:   WAVPACK:  create or transcode WavPack files\n          WVUNPACK: unpack or verify existing WavPack files\n          WVGAIN:   apply ReplayGain to WavPack files\n          WVTAG:    apply or edit metadata tags on WavPack files\n\n Formats: .wav (default, bwf/rf64 okay)  .wv (transcode, with tags)\n          .w64 (Sony Wave64)             .caf (Core Audio Format)\n          .dff (Philips DSDIFF)          .dsf (Sony DSD stream)\n\n Options: -bn = enable hybrid compression, n = 2.0 to 23.9 bits/sample, or\n                                           n = 24-9600 kbits/second (kbps)\n          -c  = create correction file (.wvc) for hybrid mode (=lossless)\n          -f  = fast mode (fast, but some compromise in compression ratio)\n          -h  = high quality (better compression ratio, but slower)\n          -v  = verify output file integrity after write (no pipes)\n          -x  = extra encode processing (no decoding speed penalty)\n          --help = complete help\n\n Web:     Visit www.wavpack.com for latest version and info"
        );
    uVar48 = 1;
    goto LAB_00106250;
  }
  file_index = 0;
  if (num_files < 1) {
    if ((local_2340 != (uint *)0x0) && (*(char *)local_2340 == '@')) goto LAB_00107847;
LAB_00105ece:
    if (verify_mode == 0) {
      encode_time_percent = 100.0;
    }
    else if ((config.flags._3_1_ & 2) == 0) {
      encode_time_percent = 50.0;
    }
    else if (config.xmode == 0) {
      encode_time_percent = 66.7;
    }
    else {
      encode_time_percent = (1.0 - 1.0 / (double)((1 << ((byte)config.xmode & 0x1f)) + 1)) * 100.0;
    }
    if (local_2340 == (uint *)0x0) {
      bVar5 = false;
      bVar67 = true;
    }
    else {
      if (*(char *)local_2340 != '-') {
        pcVar28 = filespec_path((char *)local_2340);
        if ((1 < num_files) && (pcVar28 == (char *)0x0)) {
          error_line("%s is not a valid output path",local_2340);
          free(local_2340);
          goto LAB_001083f4;
        }
        bVar5 = true;
        bVar67 = true;
        if (pcVar28 != (char *)0x0) goto LAB_00105f30;
      }
      pcVar28 = filespec_ext((char *)local_2340);
      bVar5 = false;
      bVar67 = pcVar28 == (char *)0x0;
    }
LAB_00105f30:
    iVar51 = 0;
    file_index = 0;
    if (0 < num_files) {
      do {
        iVar13 = check_break();
        puVar54 = local_2340;
        if (iVar13 != 0) break;
        if (bVar5) {
          pcVar28 = filespec_name((char *)local_2358[file_index]);
          strcat((char *)local_2340,pcVar28);
          pcVar28 = filespec_ext((char *)local_2340);
joined_r0x0010728e:
          puVar54 = local_2340;
          if (pcVar28 != (char *)0x0) {
            pcVar28 = filespec_ext((char *)local_2340);
            *pcVar28 = '\0';
          }
        }
        else if (local_2340 == (uint *)0x0) {
          uVar38 = 0xffffffffffffffff;
          pcVar28 = (char *)local_2358[file_index];
          pcVar25 = pcVar28;
          do {
            if (uVar38 == 0) break;
            uVar38 = uVar38 - 1;
            cVar11 = *pcVar25;
            pcVar25 = pcVar25 + (ulong)bVar68 * -2 + 1;
          } while (cVar11 != '\0');
          local_2340 = (uint *)malloc(~uVar38 + 9);
          memcpy(local_2340,pcVar28,~uVar38);
          pcVar28 = filespec_ext((char *)local_2340);
          goto joined_r0x0010728e;
        }
        if ((bVar67) && (puVar34 = puVar54, *(char *)puVar54 != '-')) {
          do {
            puVar30 = puVar34;
            uVar14 = *puVar30 + 0xfefefeff & ~*puVar30;
            uVar48 = uVar14 & 0x80808080;
            puVar34 = puVar30 + 1;
          } while (uVar48 == 0);
          bVar66 = (uVar14 & 0x8080) == 0;
          if (bVar66) {
            uVar48 = uVar48 >> 0x10;
          }
          if (bVar66) {
            puVar34 = (uint *)((long)puVar30 + 6);
          }
          *(undefined4 *)((long)puVar34 + (-3 - (ulong)CARRY1((byte)uVar48,(byte)uVar48))) =
               0x76772e;
        }
        puVar34 = puVar54;
        if ((config.flags._2_1_ & 8) == 0) {
          puVar30 = (uint *)0x0;
        }
        else {
          do {
            puVar30 = puVar34;
            uVar14 = *puVar30 + 0xfefefeff & ~*puVar30;
            uVar48 = uVar14 & 0x80808080;
            puVar34 = puVar30 + 1;
          } while (uVar48 == 0);
          bVar66 = (uVar14 & 0x8080) == 0;
          if (bVar66) {
            uVar48 = uVar48 >> 0x10;
          }
          if (bVar66) {
            puVar34 = (uint *)((long)puVar30 + 6);
          }
          lVar37 = (-3 - (ulong)CARRY1((byte)uVar48,(byte)uVar48)) - (long)puVar54;
          puVar30 = (uint *)malloc((long)puVar34 + lVar37 + 10);
          memcpy(puVar30,puVar54,(long)puVar34 + lVar37 + 1);
          pcVar28 = filespec_ext((char *)puVar30);
          puVar34 = puVar30;
          if (pcVar28 != (char *)0x0) {
            pcVar28 = filespec_ext((char *)puVar30);
            *pcVar28 = '\0';
          }
          do {
            puVar44 = puVar34;
            uVar14 = *puVar44 + 0xfefefeff & ~*puVar44;
            uVar48 = uVar14 & 0x80808080;
            puVar34 = puVar44 + 1;
          } while (uVar48 == 0);
          bVar66 = (uVar14 & 0x8080) == 0;
          if (bVar66) {
            uVar48 = uVar48 >> 0x10;
          }
          if (bVar66) {
            puVar34 = (uint *)((long)puVar44 + 6);
          }
          puVar45 = (undefined4 *)((long)puVar34 + (-3 - (ulong)CARRY1((byte)uVar48,(byte)uVar48)));
          *puVar45 = 0x6376772e;
          *(undefined *)(puVar45 + 1) = 0;
        }
        pcVar28 = (char *)local_2358[file_index];
        if ((1 < num_files) && (quiet_mode == 0)) {
          __fprintf_chk(stderr,1,"\n%s:\n",pcVar28);
          fflush(stderr);
          pcVar28 = (char *)local_2358[file_index];
        }
        pcVar28 = filespec_ext(pcVar28);
        if (pcVar28 == (char *)0x0) {
LAB_00106021:
          iVar13 = pack_file((char *)local_2358[file_index],(char *)puVar54,(char *)puVar30,
                             local_2330);
          if (iVar13 != 0) {
LAB_00106720:
            iVar51 = iVar51 + 1;
            if (iVar13 == 2) {
              local_2340 = puVar54;
              if (1 < num_files) goto LAB_00106740;
              goto LAB_0010676a;
            }
          }
        }
        else {
          pcVar28 = filespec_ext((char *)local_2358[file_index]);
          iVar13 = strcasecmp(pcVar28,".wv");
          if (iVar13 != 0) goto LAB_00106021;
          loc_config.shaping_weight = config.shaping_weight;
          loc_config.bitrate = config.bitrate;
          local_22f0 = (uint *)local_2358[file_index];
          loc_config.qmode._1_1_ = config.qmode._1_1_;
          loc_config.qmode._0_1_ = (byte)config.qmode;
          loc_config.qmode._2_2_ = config.qmode._2_2_;
          loc_config.flags._0_2_ = (ushort)config.flags;
          loc_config.flags._2_1_ = config.flags._2_1_;
          loc_config.flags._3_1_ = config.flags._3_1_;
          loc_config.num_channels = config.num_channels;
          loc_config.xmode = config.xmode;
          loc_config.bits_per_sample = config.bits_per_sample;
          loc_config.bytes_per_sample = config.bytes_per_sample;
          loc_config.block_samples = config.block_samples;
          loc_config.float_norm_exp = config.float_norm_exp;
          loc_config.sample_rate = config.sample_rate;
          loc_config.extra_flags = config.extra_flags;
          uVar46 = CONCAT12(config.flags._2_1_,(ushort)config.flags) & 0x80008;
          loc_config.md5_checksum[0] = config.md5_checksum[0];
          loc_config.md5_checksum[1] = config.md5_checksum[1];
          loc_config.md5_checksum[2] = config.md5_checksum[2];
          loc_config.md5_checksum[3] = config.md5_checksum[3];
          loc_config.channel_mask = config.channel_mask;
          loc_config.tag_strings = config.tag_strings;
          iVar13 = 0x507;
          loc_config.md5_checksum[4] = config.md5_checksum[4];
          loc_config.md5_checksum[5] = config.md5_checksum[5];
          loc_config.md5_checksum[6] = config.md5_checksum[6];
          loc_config.md5_checksum[7] = config.md5_checksum[7];
          loc_config.md5_checksum[8] = config.md5_checksum[8];
          loc_config.md5_checksum[9] = config.md5_checksum[9];
          loc_config.md5_checksum[10] = config.md5_checksum[10];
          loc_config.md5_checksum[0xb] = config.md5_checksum[0xb];
          loc_config.md5_checksum[0xc] = config.md5_checksum[0xc];
          loc_config.md5_checksum[0xd] = config.md5_checksum[0xd];
          loc_config.md5_checksum[0xe] = config.md5_checksum[0xe];
          loc_config.md5_checksum[0xf] = config.md5_checksum[0xf];
          loc_config.md5_read = config.md5_read;
          loc_config._69_3_ = config._69_3_;
          loc_config.num_tag_strings = config.num_tag_strings;
          loc_config._76_4_ = config._76_4_;
          if ((config.qmode._1_1_ & 2) != 0) {
            iVar13 = (-(uint)(import_id3 == 0) & 0xfffffffc) + 0x507;
          }
          lVar37 = WavpackOpenFileInput(local_22f0,error,iVar13,0);
          if (lVar37 != 0) {
            uVar48 = WavpackGetMode(lVar37);
            uVar14 = uVar48 & 2;
            if ((uVar14 == 0) && (uVar46 != 8)) {
              pcVar28 = "can\'t transcode lossy file %s to lossless...not allowed!";
LAB_0010749a:
              error_line(pcVar28,local_22f0);
              WavpackCloseFile(lVar37);
              iVar51 = iVar51 + 1;
              goto LAB_0010604a;
            }
            lVar62 = WavpackGetNumSamples64(lVar37);
            if (lVar62 == -1) {
              pcVar28 = "can\'t transcode file %s of unknown length!";
              goto LAB_0010749a;
            }
            pwVar55 = &wv_file;
            for (lVar39 = 6; lVar39 != 0; lVar39 = lVar39 + -1) {
              pwVar55->bytes_written = 0;
              pwVar55 = (write_id *)((long)pwVar55 + (ulong)bVar68 * -8 + 4);
            }
            ppcVar56 = &long_param;
            for (lVar39 = 6; lVar39 != 0; lVar39 = lVar39 + -1) {
              *(undefined4 *)ppcVar56 = 0;
              ppcVar56 = (char **)((long)ppcVar56 + (ulong)bVar68 * -8 + 4);
            }
            if (puVar30 != (uint *)0x0) {
              local_2350 = (WavpackContext *)WavpackOpenFileOutput(write_block);
              if ((*(char *)puVar54 != '-') &&
                 (wv_file.file = (FILE *)fopen((char *)puVar54,"rb"),
                 (FILE *)wv_file.file != (FILE *)0x0)) {
                DoCloseHandle(wv_file.file);
                if (overwrite_all == 0) goto LAB_00107c90;
LAB_00106941:
                uVar38 = 0xffffffffffffffff;
                puVar34 = puVar54;
                do {
                  if (uVar38 == 0) break;
                  uVar38 = uVar38 - 1;
                  cVar11 = *(char *)puVar34;
                  puVar34 = (uint *)((long)puVar34 + (ulong)bVar68 * -2 + 1);
                } while (cVar11 != '\0');
                local_22c0 = (uint *)malloc(~uVar38 + 0xf);
                uVar38 = 0xffffffffffffffff;
                puVar34 = puVar54;
                do {
                  if (uVar38 == 0) break;
                  uVar38 = uVar38 - 1;
                  cVar11 = *(char *)puVar34;
                  puVar34 = (uint *)((long)puVar34 + (ulong)bVar68 * -2 + 1);
                } while (cVar11 != '\0');
                local_22a8 = (uint *)malloc(~uVar38 + 0xf);
                goto LAB_00106980;
              }
LAB_00106934:
              if ((overwrite_all != 0) ||
                 (local_2200 = fopen((char *)puVar30,"rb"), local_2200 == (FILE *)0x0))
              goto LAB_00106941;
              DoCloseHandle((FILE *)local_2200);
              uVar38 = 0xffffffffffffffff;
              puVar34 = puVar30;
              do {
                if (uVar38 == 0) break;
                uVar38 = uVar38 - 1;
                cVar11 = *(char *)puVar34;
                puVar34 = (uint *)((long)puVar34 + (ulong)bVar68 * -2 + 1);
              } while (cVar11 != '\0');
              if (0x1e < ~uVar38 - 1) {
                filespec_name((char *)puVar30);
              }
              __fprintf_chk(stderr,1,"overwrite %s (yes/no/all)? ");
              fflush(stderr);
              if (set_console_title != 0) {
                DoSetConsoleTitle("overwrite?");
              }
              cVar11 = yna();
              if (cVar11 == 'a') {
                overwrite_all = 1;
                goto LAB_00106941;
              }
              if (cVar11 != 'n') goto LAB_00106941;
LAB_001077d3:
              WavpackCloseFile(lVar37);
LAB_001077db:
              WavpackCloseFile(local_2350);
              iVar51 = iVar51 + 1;
              goto LAB_0010604a;
            }
            local_2350 = (WavpackContext *)WavpackOpenFileOutput(write_block,&wv_file,0);
            if ((*(char *)puVar54 == '-') ||
               (wv_file.file = (FILE *)fopen((char *)puVar54,"rb"),
               (FILE *)wv_file.file == (FILE *)0x0)) {
              gettimeofday((timeval *)&time1,(__timezone_ptr_t)&timez);
              local_22a8 = (uint *)0x0;
              if (*(char *)puVar54 != '-') {
                local_22c0 = (uint *)0x0;
                local_22b8 = 0;
                puVar34 = puVar54;
                goto LAB_00106a8b;
              }
              local_22b8 = 0;
              local_22c0 = (uint *)0x0;
LAB_0010760b:
              wv_file.file = stdout;
            }
            else {
              DoCloseHandle(wv_file.file);
              if (overwrite_all == 0) {
LAB_00107c90:
                uVar38 = 0xffffffffffffffff;
                puVar34 = puVar54;
                do {
                  if (uVar38 == 0) break;
                  uVar38 = uVar38 - 1;
                  cVar11 = *(char *)puVar34;
                  puVar34 = (uint *)((long)puVar34 + (ulong)bVar68 * -2 + 1);
                } while (cVar11 != '\0');
                if (uVar46 == 8) {
                  if (0x1e < ~uVar38 - 1) {
                    filespec_name((char *)puVar54);
                  }
                  __fprintf_chk(stderr,1,"overwrite %s with lossy transcode (yes/no/all)? ");
                }
                else {
                  if (0x1e < ~uVar38 - 1) {
                    filespec_name((char *)puVar54);
                  }
                  __fprintf_chk(stderr,1,"overwrite %s (yes/no/all)? ");
                }
                fflush(stderr);
                if (set_console_title != 0) {
                  DoSetConsoleTitle("overwrite?");
                }
                cVar11 = yna();
                if (cVar11 == 'a') {
                  overwrite_all = 1;
                  if (puVar30 != (uint *)0x0) goto LAB_00106941;
                }
                else {
                  if (cVar11 == 'n') goto LAB_001077d3;
                  if (puVar30 != (uint *)0x0) goto LAB_00106934;
                }
              }
              uVar38 = 0xffffffffffffffff;
              puVar34 = puVar54;
              do {
                if (uVar38 == 0) break;
                uVar38 = uVar38 - 1;
                cVar11 = *(char *)puVar34;
                puVar34 = (uint *)((long)puVar34 + (ulong)bVar68 * -2 + 1);
              } while (cVar11 != '\0');
              local_22c0 = (uint *)malloc(~uVar38 + 0xf);
              local_22a8 = (uint *)0x0;
LAB_00106980:
              uVar47 = 0;
LAB_00106997:
              strcpy((char *)local_22c0,(char *)puVar54);
              pcVar28 = filespec_ext((char *)local_22c0);
              if (pcVar28 == (char *)0x0) {
                if (uVar47 == 0) {
                  uVar47 = 1;
                  strcat((char *)local_22c0,".tmp");
                }
                else {
                  uVar38 = 0xffffffffffffffff;
                  pcVar20 = (char *)(ulong)uVar47;
                  puVar34 = local_22c0;
                  do {
                    if (uVar38 == 0) break;
                    uVar38 = uVar38 - 1;
                    cVar11 = *(char *)puVar34;
                    puVar34 = (uint *)((long)puVar34 + (ulong)bVar68 * -2 + 1);
                  } while (cVar11 != '\0');
                  __sprintf_chk((long)local_22c0 + (~uVar38 - 1),1,0xffffffffffffffff,".tmp%d",
                                pcVar20);
                  uVar47 = uVar47 + 1;
                }
              }
              else {
                if (uVar47 == 0) {
                  pcVar28 = filespec_ext((char *)local_22c0);
                  builtin_strncpy(pcVar28,".tmp",5);
                }
                else {
                  pcVar28 = filespec_ext((char *)local_22c0);
                  pcVar20 = (char *)(ulong)uVar47;
                  __sprintf_chk(pcVar28,1,0xffffffffffffffff,".tmp%d",pcVar20);
                }
                pcVar28 = filespec_ext((char *)puVar54);
                strcat((char *)local_22c0,pcVar28);
                uVar47 = uVar47 + 1;
              }
              pFVar23 = fopen((char *)local_22c0,"rb");
              if (pFVar23 != (FILE *)0x0) {
                fclose(pFVar23);
                goto LAB_00106997;
              }
              if (puVar30 != (uint *)0x0) {
                pcVar28 = stpcpy((char *)local_22a8,(char *)local_22c0);
                pcVar28[0] = 'c';
                pcVar28[1] = '\0';
                pFVar23 = fopen((char *)local_22a8,"rb");
                if (pFVar23 == (FILE *)0x0) goto LAB_00106a43;
                fclose(pFVar23);
                goto LAB_00106997;
              }
LAB_00106a43:
              gettimeofday((timeval *)&time1,(__timezone_ptr_t)&timez);
              if (*(char *)puVar54 == '-') {
                local_22b8 = 1;
                goto LAB_0010760b;
              }
              local_22b8 = 1;
              puVar34 = local_22c0;
LAB_00106a8b:
              wv_file.file = (FILE *)fopen((char *)puVar34,"w+b");
              if ((FILE *)wv_file.file == (FILE *)0x0) {
                error_line("can\'t create file %s!",puVar34);
                goto LAB_001077d3;
              }
            }
            local_2278 = (__timezone_ptr_t)&timez;
            if (quiet_mode == 0) {
              if (*(char *)puVar54 == '-') {
                puVar34 = (uint *)"stdin";
                if (*(char *)local_22f0 != '-') {
                  uVar38 = 0xffffffffffffffff;
                  puVar34 = local_22f0;
                  do {
                    if (uVar38 == 0) break;
                    uVar38 = uVar38 - 1;
                    cVar11 = *(char *)puVar34;
                    puVar34 = (uint *)((long)puVar34 + (ulong)bVar68 * -2 + 1);
                  } while (cVar11 != '\0');
                  puVar34 = local_22f0;
                  if (0x1e < ~uVar38 - 1) {
                    puVar34 = (uint *)filespec_name((char *)local_22f0);
                  }
                }
                __fprintf_chk(stderr,1,"packing %s to stdout,",puVar34);
              }
              else if (puVar30 == (uint *)0x0) {
                uVar38 = 0xffffffffffffffff;
                puVar34 = puVar54;
                do {
                  if (uVar38 == 0) break;
                  uVar38 = uVar38 - 1;
                  cVar11 = *(char *)puVar34;
                  puVar34 = (uint *)((long)puVar34 + (ulong)bVar68 * -2 + 1);
                } while (cVar11 != '\0');
                puVar34 = puVar54;
                if (0x1e < ~uVar38 - 1) {
                  puVar34 = (uint *)filespec_name((char *)puVar54);
                }
                __fprintf_chk(stderr,1,"creating %s,",puVar34);
              }
              else {
                pcVar20 = filespec_ext((char *)puVar30);
                uVar38 = 0xffffffffffffffff;
                puVar34 = puVar54;
                do {
                  if (uVar38 == 0) break;
                  uVar38 = uVar38 - 1;
                  cVar11 = *(char *)puVar34;
                  puVar34 = (uint *)((long)puVar34 + (ulong)bVar68 * -2 + 1);
                } while (cVar11 != '\0');
                puVar34 = puVar54;
                if (0x1e < ~uVar38 - 1) {
                  puVar34 = (uint *)filespec_name((char *)puVar54);
                }
                __fprintf_chk(stderr,1,"creating %s (+%s),",puVar34,pcVar20);
              }
              fflush(stderr);
            }
            uVar10 = WavpackGetFileFormat(lVar37);
            uVar22 = WavpackGetFileExtension(lVar37);
            WavpackSetFileInformation(local_2350,uVar22,uVar10);
            iVar13 = WavpackGetWrapperBytes(lVar37);
            if (iVar13 != 0) {
              if ((loc_config._16_8_ & 0x200) != 0) {
LAB_00106b82:
                WavpackFreeWrapper(lVar37);
                goto LAB_00106b8a;
              }
              uVar15 = WavpackGetWrapperBytes(lVar37);
              uVar22 = WavpackGetWrapperData(lVar37);
              iVar13 = WavpackAddWrapper(local_2350,uVar22,uVar15);
              if (iVar13 != 0) goto LAB_00106b82;
LAB_001074bd:
              uVar22 = WavpackGetErrorMessage(local_2350);
              error_line("%s",uVar22);
              WavpackCloseFile(lVar37);
              DoCloseHandle(wv_file.file);
              if (local_22b8 == 0) {
                local_22c0 = puVar54;
              }
              DoDeleteFile((char *)local_22c0);
              WavpackCloseFile(local_2350);
              iVar51 = iVar51 + 1;
              goto LAB_0010604a;
            }
LAB_00106b8a:
            iVar13 = WavpackGetBytesPerSample(lVar37);
            loc_config.bytes_per_sample = iVar13;
            loc_config.bits_per_sample = WavpackGetBitsPerSample(lVar37);
            iVar16 = WavpackGetChannelMask(lVar37);
            loc_config.channel_mask = iVar16;
            iVar13 = WavpackGetNumChannels(lVar37);
            loc_config.num_channels = iVar13;
            iVar16 = WavpackGetSampleRate(lVar37);
            loc_config.sample_rate = iVar16;
            uVar47 = WavpackGetQualifyMode(lVar37);
            loc_config.qmode = loc_config.qmode | uVar47;
            pvVar31 = malloc((long)(loc_config.num_channels + 1));
            WavpackGetChannelIdentities(lVar37,pvVar31);
            if ((uVar48 & 8) != 0) {
              iVar13 = WavpackGetFloatNormExp(lVar37);
              loc_config.float_norm_exp = iVar13;
            }
            if ((uVar48 & 0x800) != 0) {
              loc_config._16_8_ = loc_config._16_8_ | 0x800000000000000;
            }
            iVar13 = WavpackSetConfiguration64(local_2350,&loc_config,lVar62,pvVar31);
            if (iVar13 == 0) goto LAB_001074bd;
            free(pvVar31);
            if ((loc_config._16_8_ & 8) == 0) {
              uVar15 = WavpackGetChannelLayout(lVar37,0);
              WavpackSetChannelLayout(local_2350,uVar15,0);
            }
            else {
              uVar15 = WavpackGetChannelLayout(lVar37,0);
              if ((char)uVar15 != '\0') {
                WavpackGetChannelLayout(lVar37,name);
                WavpackSetChannelLayout(local_2350,uVar15,name);
              }
            }
            if (puVar30 != (uint *)0x0) {
              if (local_22b8 == 0) {
                local_2200 = fopen((char *)puVar30,"w+b");
                if (local_2200 == (FILE *)0x0) {
                  error_line("can\'t create correction file!");
                  WavpackCloseFile(lVar37);
                  DoCloseHandle(wv_file.file);
                  local_22c0 = puVar54;
                  goto LAB_00107992;
                }
              }
              else {
                local_2200 = fopen((char *)local_22a8,"w+b");
                if (local_2200 == (FILE *)0x0) {
                  error_line("can\'t create correction file!");
                  WavpackCloseFile(lVar37);
                  DoCloseHandle(wv_file.file);
LAB_00107992:
                  DoDeleteFile((char *)local_22c0);
                  WavpackCloseFile(local_2350);
                  iVar51 = iVar51 + 1;
                  goto LAB_0010604a;
                }
              }
            }
            iVar13 = WavpackGetBytesPerSample(lVar37);
            iVar17 = WavpackGetNumChannels(lVar37);
            uVar47 = WavpackGetQualifyMode(lVar37);
            if ((uVar47 & 0x40) == 0) {
              uVar63 = 0x10000;
              while( true ) {
                iVar18 = WavpackGetNumChannels(local_2350);
                uVar38 = (ulong)uVar63;
                if ((long)iVar18 * uVar38 * 4 < 0x200001) break;
                uVar63 = uVar63 >> 1;
              }
            }
            else {
              uVar63 = 0x1000;
              uVar38 = 0x1000;
            }
            iVar18 = WavpackGetNumChannels(local_2350);
            pvVar31 = malloc((ulong)(iVar18 * iVar13 * uVar63));
            MD5_Init((MD5_CTX *)params);
            sVar21 = (size_t)iVar17;
            if (((uVar47 & 8) == 0) ||
               (bVar12 = WavpackGetChannelLayout(lVar37,0), iVar17 < (int)(uint)bVar12)) {
              local_22e0 = (uchar *)0x0;
            }
            else {
              local_22e0 = (uchar *)malloc(sVar21);
              for (lVar39 = 0; (int)lVar39 < iVar17; lVar39 = lVar39 + 1) {
                local_22e0[lVar39] = (uchar)lVar39;
              }
              WavpackGetChannelLayout(lVar37,local_22e0);
            }
            WavpackPackInit(local_2350);
            iVar18 = WavpackGetNumChannels(local_2350);
            data = (float *)malloc(uVar38 * (long)iVar18 * 4);
            uVar43 = quantize_bits;
            if (quantize_bits == 0) {
LAB_00107627:
              local_2310 = 1.0;
              local_2318 = 1.0;
            }
            else if (quantize_bits < iVar13 * 8) {
              uVar43 = -1 << ((char)(iVar13 * 8) - (char)quantize_bits & 0x1fU);
              uVar38 = WavpackGetMode(lVar37);
              if ((uVar38 & 8) == 0) goto LAB_00107627;
              iVar19 = WavpackGetFloatNormExp(lVar37);
              iVar18 = quantize_bits;
              local_2318 = exp2((double)((quantize_bits + 0x7e) - iVar19));
              local_2310 = exp2((double)((iVar19 + -0x7e) - iVar18));
            }
            else {
              uVar43 = 0;
              local_2310 = 1.0;
              local_2318 = 1.0;
            }
            lVar39 = 1 - (long)(iVar17 << 0xc);
            local_2280 = -1.0;
            dVar70 = local_2280;
            while (local_2280 = dVar70, iVar18 = WavpackUnpackSamples(lVar37,data,uVar63),
                  iVar18 != 0) {
              if (uVar43 != 0) {
                uVar42 = iVar17 * iVar18;
                uVar38 = WavpackGetMode(lVar37);
                if ((uVar38 & 8) == 0) {
                  if (quantize_round == 0) {
                    if (uVar42 != 0) {
LAB_001072ae:
                      lVar32 = 0;
                      do {
                        data[lVar32] = (float)((uint)data[lVar32] & uVar43);
                        lVar32 = lVar32 + 1;
                      } while ((uint)lVar32 < uVar42);
                    }
                  }
                  else if (uVar42 != 0) {
                    pfVar33 = data;
                    do {
                      fVar1 = (float)(((int)uVar43 >> 1 ^ uVar43) + (int)*pfVar33);
                      pcVar20 = (char *)0x0;
                      if (((int)*pfVar33 < 0) ||
                         (0 < (int)fVar1 << (('\x04' - (char)iVar13) * '\b' & 0x1fU))) {
                        *pfVar33 = fVar1;
                      }
                      pfVar33 = pfVar33 + 1;
                    } while (data + (ulong)(uVar42 - 1) + 1 != pfVar33);
                    goto LAB_001072ae;
                  }
                }
                else if (uVar42 != 0) {
                  pfVar33 = data;
                  do {
                    dVar70 = (double)*pfVar33 * local_2318 + 0.5;
                    if (ABS(dVar70) < 4503599627370496.0) {
                      dVar70 = (double)((ulong)dVar70 & 0x8000000000000000 |
                                       (ulong)((double)(long)dVar70 -
                                              (double)(-(ulong)(dVar70 < (double)(long)dVar70) &
                                                      0x3ff0000000000000)));
                    }
                    pfVar40 = pfVar33 + 1;
                    *pfVar33 = (float)(dVar70 * local_2310);
                    pfVar33 = pfVar40;
                  } while (data + (ulong)(uVar42 - 1) + 1 != pfVar40);
                }
              }
              iVar19 = WavpackPackSamples(local_2350,data,iVar18);
              if (iVar19 == 0) {
                iVar13 = 2;
                uVar22 = WavpackGetErrorMessage(local_2350);
                error_line("%s",uVar22);
                free(data);
                goto LAB_00106699;
              }
              if (local_22e0 != (uchar *)0x0) {
                unreorder_channels((int32_t *)data,local_22e0,iVar17,iVar18);
              }
              if ((uVar47 & 0x30) == 0) {
                pcVar20 = (char *)0x0;
                store_samples(pvVar31,(int32_t *)data,uVar47,iVar13,iVar17 * iVar18);
              }
              else if ((uVar47 & 0x40) == 0) {
                pcVar20 = (char *)0x0;
                if (iVar17 * iVar18 != 0) {
                  uVar38 = 0;
                  do {
                    *(char *)((long)pvVar31 + uVar38) = SUB41(data[uVar38],0);
                    bVar66 = iVar17 * iVar18 - 1 != uVar38;
                    uVar38 = uVar38 + 1;
                  } while (bVar66);
                }
              }
              else {
                pvVar57 = pvVar31;
                pfVar33 = data;
                if (iVar17 != 0) {
                  do {
                    lVar32 = 0;
                    pfVar40 = pfVar33;
                    do {
                      while (iVar18 <= (int)lVar32) {
                        *(undefined *)((long)pvVar57 + lVar32) = 0;
                        lVar32 = lVar32 + 1;
                        pfVar40 = pfVar40 + sVar21;
                        if (lVar32 == 0x1000) goto LAB_00106f7c;
                      }
                      uVar50 = SUB41(*pfVar40,0);
                      if ((uVar47 & 0x10) != 0) {
                        uVar50 = ""[(uint)*pfVar40 & 0xff];
                      }
                      *(uchar *)((long)pvVar57 + lVar32) = uVar50;
                      lVar32 = lVar32 + 1;
                      pfVar40 = pfVar40 + sVar21;
                    } while (lVar32 != 0x1000);
LAB_00106f7c:
                    pvVar57 = (void *)((long)pvVar57 + 0x1000);
                    pcVar20 = (char *)(sVar21 * 0x4000 + lVar39 * 4);
                    pfVar33 = pfVar33 + lVar39 + sVar21 * 0x1000;
                  } while ((void *)(((ulong)(iVar17 - 1) + 1) * 0x1000 + (long)pvVar31) != pvVar57);
                }
                iVar18 = 0x1000;
              }
              MD5_Update((MD5_CTX *)params,pvVar31,(long)(iVar18 * iVar13 * iVar17));
              iVar18 = check_break();
              if (iVar18 != 0) {
                iVar13 = 1;
                fputc(10,stderr);
                fflush(stderr);
                free(data);
                goto LAB_00106699;
              }
              dVar69 = (double)WavpackGetProgress(local_2350);
              dVar70 = local_2280;
              if ((false) || (dVar69 != -1.0)) {
                dVar69 = (double)WavpackGetProgress(local_2350);
                dVar69 = floor(dVar69 * encode_time_percent + 0.5);
                if ((false) || (dVar69 != local_2280)) {
                  dVar70 = (double)WavpackGetProgress(local_2350);
                  dVar70 = floor(dVar70 * encode_time_percent + 0.5);
                  if (set_console_title != 0) {
                    display_progress(dVar70 / 100.0);
                  }
                  if (quiet_mode == 0) {
                    pcVar20 = (char *)CONCAT44((int)((ulong)pcVar20 >> 0x20),(int)dVar70);
                    if ((false) || (puVar41 = &DAT_00119241, local_2280 != -1.0)) {
                      puVar41 = &DAT_00115044;
                    }
                    __fprintf_chk(stderr,1,"%s%3d%% done...",puVar41,pcVar20);
                    fflush(stderr);
                  }
                }
              }
            }
            if (local_22e0 != (uchar *)0x0) {
              free(local_22e0);
            }
            free(data);
            iVar13 = WavpackFlushSamples(local_2350);
            if (iVar13 == 0) goto LAB_00106679;
            MD5_Final(md5_verify,(MD5_CTX *)params);
            free(pvVar31);
            local_2318._0_4_ = WavpackGetNumErrors(lVar37);
            if (local_2318._0_4_ != 0) {
              uVar47 = WavpackGetNumErrors(lVar37);
              error_line("missing data or crc errors detected in %d block(s)!",(ulong)uVar47);
              local_2318._0_4_ = 1;
            }
            lVar39 = WavpackGetNumSamples64(local_2350);
            if (lVar62 != lVar39) {
              error_line("incorrect number of samples read from source file!");
              if ((uVar14 != 0) && (local_2318._0_4_ = 1, quantize_bits == 0)) goto LAB_00107dd7;
LAB_00108e3b:
              iVar13 = 1;
              goto LAB_00106699;
            }
            if ((uVar14 != 0) && (quantize_bits == 0)) {
LAB_00107dd7:
              iVar13 = WavpackGetMD5Sum(lVar37,name);
              if ((iVar13 == 0) || (iVar13 = memcmp(name,md5_verify,0x10), iVar13 == 0))
              goto LAB_00107a70;
              iVar13 = 1;
              error_line("MD5 signature in source should match, but does not!");
              goto LAB_00106699;
            }
LAB_00107a70:
            if (local_2318._0_4_ != 0) goto LAB_00108e3b;
            iVar13 = WavpackGetMD5Sum(lVar37,md5_display);
            if (iVar13 == 0) {
              if ((loc_config._16_8_ & 0x800000000000000) != 0) {
                md5_display[0] = md5_verify[0];
                md5_display[1] = md5_verify[1];
                md5_display[2] = md5_verify[2];
                md5_display[3] = md5_verify[3];
                md5_display[4] = md5_verify[4];
                md5_display[5] = md5_verify[5];
                md5_display[6] = md5_verify[6];
                md5_display[7] = md5_verify[7];
                md5_display[8] = md5_verify[8];
                md5_display[9] = md5_verify[9];
                md5_display[10] = md5_verify[10];
                md5_display[0xb] = md5_verify[0xb];
                md5_display[0xc] = md5_verify[0xc];
                md5_display[0xd] = md5_verify[0xd];
                md5_display[0xe] = md5_verify[0xe];
                md5_display[0xf] = md5_verify[0xf];
                WavpackStoreMD5Sum(local_2350,md5_verify);
              }
            }
            else {
              if ((uVar14 != 0) && (quantize_bits != 0)) {
                md5_display[0] = md5_verify[0];
                md5_display[1] = md5_verify[1];
                md5_display[2] = md5_verify[2];
                md5_display[3] = md5_verify[3];
                md5_display[4] = md5_verify[4];
                md5_display[5] = md5_verify[5];
                md5_display[6] = md5_verify[6];
                md5_display[7] = md5_verify[7];
                md5_display[8] = md5_verify[8];
                md5_display[9] = md5_verify[9];
                md5_display[10] = md5_verify[10];
                md5_display[0xb] = md5_verify[0xb];
                md5_display[0xc] = md5_verify[0xc];
                md5_display[0xd] = md5_verify[0xd];
                md5_display[0xe] = md5_verify[0xe];
                md5_display[0xf] = md5_verify[0xf];
              }
              WavpackStoreMD5Sum(local_2350,md5_display);
            }
            iVar13 = WavpackGetWrapperBytes(lVar37);
            local_2340._0_4_ = 0;
            if (iVar13 == 0) {
LAB_00107ae6:
              iVar13 = WavpackFlushSamples(local_2350);
              if (iVar13 == 0) {
LAB_00106679:
                iVar13 = 2;
                uVar22 = WavpackGetErrorMessage(local_2350);
                error_line("%s",uVar22);
                goto LAB_00106699;
              }
              uVar14 = uVar48 & 0x10 | num_tag_items | (uint)local_2340;
              if (uVar14 != 0) {
                iVar13 = WavpackGetNumBinaryTagItems(lVar37);
                iVar17 = WavpackGetNumTagItems(lVar37);
                iVar18 = 1;
                for (iVar19 = 0; iVar49 = 0, iVar19 < iVar17; iVar19 = iVar19 + 1) {
                  if (iVar18 == 0) {
                    iVar18 = 0;
                    break;
                  }
                  iVar18 = WavpackGetTagItemIndexed(lVar37,iVar19,0,0);
                  pcVar28 = (char *)malloc((long)(iVar18 + 1));
                  WavpackGetTagItemIndexed(lVar37,iVar19,pcVar28);
                  iVar18 = strcasecmp(pcVar28,"encoder");
                  if (iVar18 == 0) {
                    pcVar25 = (char *)malloc(0x50);
                    pcVar20 = (char *)0x0;
                    __sprintf_chk(pcVar25,1,0x50,"WavPack %s","5.1.0");
LAB_00107eb5:
                    lVar62 = -1;
                    pcVar59 = pcVar25;
                    do {
                      if (lVar62 == 0) break;
                      lVar62 = lVar62 + -1;
                      cVar11 = *pcVar59;
                      pcVar59 = pcVar59 + (ulong)bVar68 * -2 + 1;
                    } while (cVar11 != '\0');
                  }
                  else {
                    iVar18 = strcasecmp(pcVar28,"settings");
                    if (iVar18 == 0) {
                      pcVar25 = (char *)malloc(0x100);
                      make_settings_string(pcVar25,&loc_config);
                      goto LAB_00107eb5;
                    }
                    iVar18 = WavpackGetTagItem(lVar37,pcVar28,0,0);
                    pcVar25 = (char *)malloc((long)(iVar18 + 1));
                    WavpackGetTagItem(lVar37,pcVar28,pcVar25,iVar18 + 1);
                  }
                  iVar18 = WavpackAppendTagItem(local_2350,pcVar28,pcVar25);
                  free(pcVar25);
                  free(pcVar28);
                }
                while ((iVar49 < iVar13 && (iVar18 != 0))) {
                  iVar17 = WavpackGetBinaryTagItemIndexed(lVar37,iVar49,0,0);
                  pvVar31 = malloc((long)(iVar17 + 1));
                  WavpackGetBinaryTagItemIndexed(lVar37,iVar49,pvVar31,iVar17 + 1);
                  iVar17 = WavpackGetBinaryTagItem(lVar37,pvVar31,0,0);
                  pvVar57 = malloc((long)iVar17);
                  WavpackGetBinaryTagItem(lVar37,pvVar31,pvVar57,iVar17);
                  iVar18 = WavpackAppendBinaryTagItem(local_2350,pvVar31,pvVar57);
                  free(pvVar57);
                  free(pvVar31);
                  iVar49 = iVar49 + 1;
                }
                for (lVar62 = 0; (int)lVar62 < num_tag_items; lVar62 = lVar62 + 1) {
                  if (iVar18 == 0) goto LAB_00106679;
                  ptVar61 = tag_items + lVar62;
                  if (ptVar61->vsize == 0) {
                    WavpackDeleteTagItem(local_2350,ptVar61->item);
                  }
                  else if (ptVar61->binary == 0) {
                    iVar18 = WavpackAppendTagItem();
                  }
                  else {
                    iVar18 = WavpackAppendBinaryTagItem(local_2350,ptVar61->item,ptVar61->value);
                  }
                }
                if ((iVar18 == 0) ||
                   (iVar13 = WavpackWriteTag(local_2350), uVar14 = (uint)local_2340, iVar13 == 0))
                goto LAB_00106679;
              }
              WavpackCloseFile(lVar37);
              iVar13 = DoCloseHandle(wv_file.file);
              if (iVar13 == 0) {
                iVar13 = 1;
                error_line("can\'t close WavPack file!");
                goto LAB_001066b6;
              }
              if ((puVar30 == (uint *)0x0) ||
                 (iVar13 = DoCloseHandle((FILE *)local_2200), iVar13 != 0)) {
                puVar34 = local_22c0;
                if (verify_mode == 0) {
                  if (copy_time != 0) {
                    if (local_22b8 == 0) {
                      puVar34 = puVar54;
                    }
LAB_00108457:
                    iVar13 = copy_timestamp((char *)local_22f0,(char *)puVar34);
                    if (iVar13 == 0) {
LAB_0010848c:
                      error_line("failure copying time stamp!");
                    }
                    else if (puVar30 != (uint *)0x0) {
                      puVar34 = local_22a8;
                      if (local_22b8 == 0) {
                        puVar34 = puVar30;
                      }
                      iVar13 = copy_timestamp((char *)local_22f0,(char *)puVar34);
                      if (iVar13 == 0) goto LAB_0010848c;
                    }
                  }
LAB_0010849a:
                  if (delete_source != 0) {
                    iVar13 = strcasecmp((char *)local_22f0,(char *)puVar54);
                    if (iVar13 != 0) {
                      iVar13 = DoDeleteFile((char *)local_22f0);
                      if (quiet_mode == 0) {
                        pcVar28 = "can\'t delete";
                        if (iVar13 != 0) {
                          pcVar28 = "deleted";
                        }
                      }
                      else {
                        if (iVar13 != 0) goto LAB_001084b8;
                        pcVar28 = "can\'t delete";
                      }
                      error_line("%s source file %s",pcVar28,local_22f0);
                    }
LAB_001084b8:
                    if ((uVar48 & 1) != 0) {
                      uVar22 = __stpcpy_chk(name,local_22f0,0x1000);
                      __memcpy_chk(uVar22,"c",2);
                      if ((puVar30 == (uint *)0x0) ||
                         (iVar13 = strcasecmp(name,(char *)puVar30), iVar13 != 0)) {
                        iVar13 = DoDeleteFile(name);
                        if (quiet_mode == 0) {
                          pcVar28 = "can\'t delete";
                          if (iVar13 != 0) {
                            pcVar28 = "deleted";
                          }
                        }
                        else {
                          if (iVar13 != 0) goto LAB_001084c6;
                          pcVar28 = "can\'t delete";
                        }
                        error_line("%s source file %s",pcVar28,name);
                      }
                    }
                  }
LAB_001084c6:
                  if (local_22b8 != 0) {
                    iVar13 = rename((char *)local_22c0,(char *)puVar54);
                    if (iVar13 != 0) {
                      error_line("can not rename temp file %s to %s!",local_22c0,puVar54);
                      iVar13 = local_22b8;
                    }
                    if (puVar30 == (uint *)0x0) {
                      free(local_22c0);
                    }
                    else {
                      iVar17 = rename((char *)local_22a8,(char *)puVar30);
                      if (iVar17 != 0) {
                        error_line("can not rename temp file %s to %s!",local_22a8,puVar30);
                        iVar13 = local_22b8;
                      }
                      free(local_22c0);
                      free(local_22a8);
                    }
                    if (iVar13 != 0) goto LAB_001077db;
                  }
                  gettimeofday((timeval *)&time2,local_2278);
                  _Var9 = time2.tv_usec;
                  _Var8 = time2.tv_sec;
                  _Var7 = time1.tv_usec;
                  _Var6 = time1.tv_sec;
                  if (((loc_config._16_8_ & 0x80000000000000) != 0) &&
                     (dVar70 = (double)WavpackGetEncodedNoise(local_2350,0), 0.0 < dVar70)) {
                    iVar13 = WavpackGetBitsPerSample(local_2350);
                    dVar70 = 0.5;
                    while (iVar13 = iVar13 + -1, iVar13 != -1) {
                      dVar70 = dVar70 + dVar70;
                    }
                    dVar70 = dVar70 * (dVar70 - 1.0) * 0.5;
                    dVar69 = (double)WavpackGetEncodedNoise(local_2350,&peak);
                    dVar71 = log10(peak / dVar70);
                    uVar48 = WavpackGetNumSamples(local_2350);
                    dVar70 = log10((dVar69 / (double)uVar48) / dVar70);
                    error_line("ave noise = %.2f dB, peak noise = %.2f dB",dVar70 * 10.0,
                               dVar71 * 10.0);
                  }
                  if (quiet_mode == 0) {
                    cratio[0] = '\0';
                    cratio[1] = '\0';
                    cratio[2] = '\0';
                    cratio[3] = '\0';
                    cratio[4] = '\0';
                    cratio[5] = '\0';
                    cratio[6] = '\0';
                    cratio[7] = '\0';
                    cratio[8] = '\0';
                    cratio[9] = '\0';
                    cratio[10] = '\0';
                    cratio[0xb] = '\0';
                    cratio[0xc] = '\0';
                    cratio[0xd] = '\0';
                    cratio[0xe] = '\0';
                    cratio[0xf] = '\0';
                    if (uVar14 != 0) {
                      error_line("successfully imported %d items from ID3v2 tag",(ulong)uVar14);
                    }
                    if ((config.flags._3_1_ & 8) != 0) {
                      lVar62 = 0;
                      puVar41 = local_2030;
                      pcVar20 = "original md5 signature: 00000000000000000000000000000000";
                      pcVar28 = name;
                      for (lVar37 = 0x39; lVar37 != 0; lVar37 = lVar37 + -1) {
                        *pcVar28 = *pcVar20;
                        pcVar20 = pcVar20 + (ulong)bVar68 * -2 + 1;
                        pcVar28 = pcVar28 + (ulong)bVar68 * -2 + 1;
                      }
                      do {
                        pcVar20 = (char *)(ulong)md5_display[lVar62];
                        lVar62 = lVar62 + 1;
                        __sprintf_chk(puVar41,1,0xffffffffffffffff,&DAT_00115061,pcVar20);
                        puVar41 = puVar41 + 2;
                      } while (lVar62 != 0x10);
                      error_line(name);
                    }
                    if (*(char *)puVar54 == '-') {
                      if (*(char *)local_22f0 == '-') {
                        pcVar25 = "packed";
                        local_22f0 = (uint *)0x1150c3;
                        pcVar28 = "";
                      }
                      else {
                        uVar38 = 0xffffffffffffffff;
                        pcVar25 = "packed";
                        puVar34 = local_22f0;
                        do {
                          if (uVar38 == 0) break;
                          uVar38 = uVar38 - 1;
                          cVar11 = *(char *)puVar34;
                          puVar34 = (uint *)((long)puVar34 + (ulong)bVar68 * -2 + 1);
                        } while (cVar11 != '\0');
                        pcVar28 = "";
                        if (0x1e < ~uVar38 - 1) {
                          local_22f0 = (uint *)filespec_name((char *)local_22f0);
                        }
                      }
                    }
                    else {
                      uVar38 = 0xffffffffffffffff;
                      puVar34 = puVar54;
                      do {
                        if (uVar38 == 0) break;
                        uVar38 = uVar38 - 1;
                        cVar11 = *(char *)puVar34;
                        puVar34 = (uint *)((long)puVar34 + (ulong)bVar68 * -2 + 1);
                      } while (cVar11 != '\0');
                      local_22f0 = puVar54;
                      if (0x1e < ~uVar38 - 1) {
                        local_22f0 = (uint *)filespec_name((char *)puVar54);
                      }
                      pcVar28 = "";
                      if ((int)long_param != 0) {
                        pcVar28 = " (+.wvc)";
                      }
                      pcVar25 = "created";
                      if (verify_mode != 0) {
                        pcVar25 = "created (and verified)";
                      }
                    }
                    iVar13 = WavpackLossyBlocks(local_2350);
                    if (iVar13 == 0) {
                      dVar70 = (double)WavpackGetRatio(local_2350);
                      if ((false) || (pcVar20 = "lossless", dVar70 != 0.0)) {
                        dVar70 = (double)WavpackGetRatio(local_2350);
                        __sprintf_chk(100.0 - dVar70 * 100.0,cratio,1,0x10,", %.2f%%");
                        pcVar20 = "lossless";
                      }
                    }
                    else {
                      dVar70 = (double)WavpackGetAverageBitrate(local_2350,1);
                      if ((false) || (pcVar20 = "lossy", dVar70 != 0.0)) {
                        uVar15 = (undefined4)((ulong)pcVar20 >> 0x20);
                        dVar70 = (double)WavpackGetAverageBitrate(local_2350,1);
                        __sprintf_chk(cratio,1,0x10,", %d kbps",
                                      CONCAT44(uVar15,(int)(dVar70 / 1000.0)));
                        pcVar20 = "lossy";
                      }
                    }
                    error_line("%s %s%s in %.2f secs (%s%s)",
                               ((double)_Var9 / 1000000.0 + (double)_Var8) -
                               ((double)_Var7 / 1000000.0 + (double)_Var6),pcVar25,local_22f0,
                               pcVar28,pcVar20,cratio);
                  }
                  WavpackCloseFile(local_2350);
                  goto LAB_0010604a;
                }
                iVar13 = WavpackLossyBlocks(local_2350);
                puVar35 = (uchar *)0x0;
                if (iVar13 == 0) {
                  puVar35 = md5_verify;
                }
                if (local_22b8 != 0) {
                  iVar13 = verify_audio((char *)local_22c0,puVar35);
                  if (iVar13 != 0) goto LAB_00108ad3;
joined_r0x001088da:
                  if (copy_time != 0) goto LAB_00108457;
                  goto LAB_0010849a;
                }
                iVar13 = verify_audio((char *)puVar54,puVar35);
                puVar34 = puVar54;
                if (iVar13 == 0) goto joined_r0x001088da;
                goto LAB_001066f0;
              }
              error_line("can\'t close correction file!");
              iVar13 = local_22b8;
              if (local_22b8 == 0) {
                DoDeleteFile((char *)puVar54);
                DoDeleteFile((char *)puVar30);
                goto LAB_001077db;
              }
LAB_00108ad3:
              DoDeleteFile((char *)local_22c0);
joined_r0x00108ae3:
              if (puVar30 != (uint *)0x0) {
LAB_00106705:
                DoDeleteFile((char *)local_22a8);
              }
            }
            else {
              puVar35 = (uchar *)WavpackGetWrapperData(lVar37);
              iVar13 = WavpackGetWrapperBytes(lVar37);
              if (((loc_config._16_8_ & 0x200) == 0) &&
                 (iVar17 = WavpackAddWrapper(local_2350,puVar35,iVar13), iVar17 == 0)) {
                iVar13 = 1;
                uVar22 = WavpackGetErrorMessage(local_2350);
                error_line("%s",uVar22);
                WavpackFreeWrapper(lVar37);
              }
              else {
                if ((import_id3 == 0) ||
                   ((iVar13 < 0xb || (iVar17 = strncmp((char *)puVar35,"ID3",3), iVar17 != 0)))) {
                  WavpackFreeWrapper(lVar37);
                  local_2340._0_4_ = 0;
                  goto LAB_00107ae6;
                }
                pcVar20 = (char *)&time2;
                local_2340._0_4_ =
                     ImportID3v2((WavpackContext *)0x0,puVar35,iVar13,name,(int32_t *)pcVar20);
                if ((allow_huge_tags == 0) && (0x100000 < (int)time2.tv_sec)) {
                  error_line("imported tag items exceed 1 MB, use --allow-huge-tags to override");
                }
                else if ((int)time2.tv_sec < 0x1000001) {
                  if (0 < (int)(uint)local_2340) {
                    pcVar20 = (char *)0x0;
                    local_2340._0_4_ = ImportID3v2(local_2350,puVar35,iVar13,name,(int32_t *)0x0);
                  }
                  if (-1 < (int)(uint)local_2340) {
                    WavpackFreeWrapper(lVar37);
                    goto LAB_00107ae6;
                  }
                  error_line("ID3v2 import: %s",name);
                }
                else {
                  error_line("imported tag items exceed 16 MB");
                }
                iVar13 = 1;
                WavpackFreeWrapper(lVar37);
              }
LAB_00106699:
              WavpackCloseFile(lVar37);
              iVar17 = DoCloseHandle(wv_file.file);
              if (iVar17 == 0) {
                error_line("can\'t close WavPack file!");
              }
LAB_001066b6:
              if (puVar30 != (uint *)0x0) {
                iVar17 = DoCloseHandle((FILE *)local_2200);
                if (iVar17 == 0) {
                  error_line("can\'t close correction file!");
                  if (local_22b8 == 0) {
LAB_001066f0:
                    DoDeleteFile((char *)puVar54);
                    local_22a8 = puVar30;
                    goto joined_r0x00108ae3;
                  }
                }
                else if (local_22b8 == 0) {
                  DoDeleteFile((char *)puVar54);
                  local_22a8 = puVar30;
                  goto LAB_00106705;
                }
                DoDeleteFile((char *)local_22c0);
                goto LAB_00106705;
              }
              if (local_22b8 == 0) {
                DoDeleteFile((char *)puVar54);
              }
              else {
                DoDeleteFile((char *)local_22c0);
              }
            }
            WavpackCloseFile(local_2350);
            goto LAB_00106720;
          }
          error_line(error);
          iVar51 = iVar51 + 1;
        }
LAB_0010604a:
        if (bVar5) {
          pcVar28 = filespec_name((char *)puVar54);
          *pcVar28 = '\0';
        }
        else if (*(char *)puVar54 != '-') {
          free(puVar54);
          puVar54 = (uint *)0x0;
        }
        if (puVar30 != (uint *)0x0) {
          free(puVar30);
        }
        iVar13 = file_index + 1;
        free((void *)local_2358[file_index]);
        local_2340 = puVar54;
        file_index = iVar13;
      } while (iVar13 < num_files);
      local_2340 = puVar54;
      if (1 < num_files) {
        if (iVar51 == 0) {
          if (quiet_mode == 0) {
            __fprintf_chk(stderr,1,"\n **** %d files successfully processed ****\n",num_files);
            fflush(stderr);
          }
        }
        else {
LAB_00106740:
          __fprintf_chk(stderr,1,"\n **** warning: errors occurred in %d of %d files! ****\n",iVar51
                       );
          fflush(stderr);
        }
      }
    }
LAB_0010676a:
    free(local_2358);
  }
  else {
    do {
      pcVar28 = (char *)local_2358[file_index];
      if (*pcVar28 == '@') {
        pFVar23 = fopen(pcVar28 + 1,"rb");
        iVar51 = num_files + -1;
        if (file_index < iVar51) {
          puVar26 = local_2358 + file_index;
          do {
            puVar24 = puVar26 + 1;
            *puVar26 = puVar26[1];
            puVar26 = puVar24;
          } while (local_2358 + (long)file_index + 1 + (ulong)(uint)((num_files + -2) - file_index)
                   != puVar24);
        }
        file_index = file_index + -1;
        num_files = iVar51;
        if (pFVar23 == (FILE *)0x0) {
          error_line("file %s not found!",pcVar28 + 1);
          free(pcVar28);
          uVar48 = 1;
          goto LAB_00106250;
        }
        iVar51 = 0;
        pcVar25 = (char *)0x0;
        do {
          pcVar25 = (char *)realloc(pcVar25,(long)(iVar51 + 0x400));
          pcVar59 = pcVar25 + iVar51;
          pcVar59[0] = '\0';
          pcVar59[1] = '\0';
          pcVar59[2] = '\0';
          pcVar59[3] = '\0';
          pcVar59[4] = '\0';
          pcVar59[5] = '\0';
          pcVar59[6] = '\0';
          pcVar59[7] = '\0';
          pcVar59[0x3f8] = '\0';
          pcVar59[0x3f9] = '\0';
          pcVar59[0x3fa] = '\0';
          pcVar59[0x3fb] = '\0';
          pcVar59[0x3fc] = '\0';
          pcVar59[0x3fd] = '\0';
          pcVar59[0x3fe] = '\0';
          pcVar59[0x3ff] = '\0';
          puVar26 = (undefined8 *)((ulong)(pcVar59 + 8) & 0xfffffffffffffff8);
          for (uVar38 = (ulong)(((int)pcVar59 -
                                (int)(undefined8 *)((ulong)(pcVar59 + 8) & 0xfffffffffffffff8)) +
                                0x400U >> 3); uVar38 != 0; uVar38 = uVar38 - 1) {
            *puVar26 = 0;
            puVar26 = puVar26 + (ulong)bVar68 * -2 + 1;
          }
          sVar21 = fread(pcVar59,1,0x400,pFVar23);
          iVar51 = iVar51 + (int)sVar21;
          pcVar59 = pcVar25;
        } while (0x3ff < (int)sVar21);
        do {
          cVar11 = *pcVar59;
          pcVar60 = pcVar59 + 1;
          if (cVar11 == '\0') break;
          if ((cVar11 == '\n') || (cVar11 == '\r')) {
            do {
              do {
                cVar11 = *pcVar60;
                pcVar60 = pcVar60 + 1;
              } while (cVar11 == '\n');
            } while (cVar11 == '\r');
            if (cVar11 == '\0') break;
          }
          pvVar31 = malloc(0x1000);
          lVar37 = 1;
          do {
            *(char *)((long)pvVar31 + lVar37 + -1) = cVar11;
            iVar51 = num_files;
            cVar11 = pcVar60[lVar37 + -1];
            lVar62 = (long)(int)lVar37;
            pcVar59 = pcVar60 + lVar37;
            if (((cVar11 == '\n') || (cVar11 == '\r')) || (cVar11 == '\0')) goto LAB_00105b78;
            lVar37 = lVar37 + 1;
          } while (lVar37 != 0x1001);
          lVar62 = 0x1000;
LAB_00105b78:
          *(undefined *)((long)pvVar31 + lVar62) = 0;
          num_files = num_files + 1;
          lVar37 = (long)num_files;
          local_2358 = (undefined8 *)realloc(local_2358,lVar37 * 8);
          iVar13 = file_index + 1;
          if (iVar13 < iVar51) {
            puVar26 = local_2358 + lVar37 + -1;
            do {
              puVar24 = puVar26 + -1;
              *puVar26 = puVar26[-1];
              puVar26 = puVar24;
            } while (local_2358 + ((lVar37 + -2) - (ulong)(uint)((iVar51 + -2) - file_index)) !=
                     puVar24);
          }
          file_index = iVar13;
          local_2358[iVar13] = pvVar31;
        } while (cVar11 != '\0');
        fclose(pFVar23);
        free(pcVar25);
        free(pcVar28);
      }
      file_index = file_index + 1;
    } while (file_index < num_files);
    if ((local_2340 != (uint *)0x0) && (*(char *)local_2340 == '@')) {
LAB_00107847:
      pFVar23 = fopen((char *)((long)local_2340 + 1),"rb");
      if (pFVar23 == (FILE *)0x0) {
        error_line("file %s not found!",(char *)((long)local_2340 + 1));
        free(local_2340);
      }
      else {
        pcVar20 = name;
        for (lVar37 = 0x400; lVar37 != 0; lVar37 = lVar37 + -1) {
          pcVar20[0] = '\0';
          pcVar20[1] = '\0';
          pcVar20[2] = '\0';
          pcVar20[3] = '\0';
          pcVar20[4] = '\0';
          pcVar20[5] = '\0';
          pcVar20[6] = '\0';
          pcVar20[7] = '\0';
          pcVar20 = pcVar20 + (ulong)bVar68 * -0x10 + 8;
        }
        fread(name,1,0x1fff,pFVar23);
        pcVar20 = name;
        do {
          do {
            pcVar28 = pcVar20;
            uVar48 = (uint)*pcVar28;
            uVar38 = (ulong)uVar48;
            pcVar20 = pcVar28 + 1;
          } while (uVar48 == 0xd);
        } while (uVar48 == 10);
        if (uVar48 != 0) {
          lVar37 = 1;
          pcVar20 = (char *)0x0;
          do {
            *(char *)((long)local_2340 + lVar37 + -1) = (char)uVar38;
            uVar38 = (ulong)(uint)(int)pcVar28[lVar37];
            lVar62 = (long)(int)lVar37;
            if (((byte)pcVar28[lVar37] < 0xe) && ((0x2401UL >> (uVar38 & 0x3f) & 1) != 0))
            goto LAB_001078f3;
            lVar37 = lVar37 + 1;
          } while (lVar37 != 0x1001);
          lVar62 = 0x1000;
LAB_001078f3:
          *(undefined *)((long)local_2340 + lVar62) = 0;
          fclose(pFVar23);
          goto LAB_00105ec1;
        }
        error_line("output spec file is empty!");
        free(local_2340);
        fclose(pFVar23);
      }
LAB_001083f4:
      uVar48 = 1;
      goto LAB_00106250;
    }
LAB_00105ec1:
    if (num_files != 0) goto LAB_00105ece;
    error_line("nothing to do!");
    iVar51 = 1;
  }
  if (local_2340 != (uint *)0x0) {
    free(local_2340);
  }
  if (set_console_title != 0) {
    DoSetConsoleTitle("WavPack Completed");
  }
  uVar48 = (uint)(iVar51 != 0);
LAB_00106250:
  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar48;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void processEntry _start(undefined8 param_1,undefined8 param_2)

{
  undefined auStack_8 [8];
  
  __libc_start_main(main,param_2,&stack0x00000008,__libc_csu_init,__libc_csu_fini,param_1,auStack_8)
  ;
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void deregister_tm_clones(void)

{
  if ((false) && (true)) {
    _ITM_deregisterTMCloneTable();
    return;
  }
  return;
}



void register_tm_clones(void)

{
  if ((false) && (true)) {
    _ITM_registerTMCloneTable();
    return;
  }
  return;
}



void __do_global_dtors_aux(void)

{
  if (completed_8061 == '\0') {
    if (true) {
      FUN_001047b0(__dso_handle);
    }
    deregister_tm_clones();
    completed_8061 = 1;
    return;
  }
  return;
}



void frame_dummy(void)

{
  register_tm_clones();
  return;
}



void unreorder_channels(int32_t *data,uchar *order,int num_chans,int num_samples)

{
  long lVar1;
  ulong uVar2;
  int32_t *__src;
  size_t __size;
  int iVar3;
  long in_FS_OFFSET;
  bool bVar4;
  int32_t reorder_buffer [16];
  
  iVar3 = num_samples + -1;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (num_chans < 0x11) {
    if (num_samples == 0) goto LAB_0010977b;
    __src = reorder_buffer;
    __size = (long)num_chans * 4;
LAB_0010971e:
    do {
      uVar2 = 0;
      if (0 < num_chans) {
        do {
          __src[uVar2] = data[order[uVar2]];
          bVar4 = uVar2 != num_chans - 1;
          uVar2 = uVar2 + 1;
        } while (bVar4);
      }
      iVar3 = iVar3 + -1;
      memcpy(data,__src,__size);
      data = (int32_t *)((long)data + __size);
    } while (iVar3 != -1);
    if (num_chans < 0x11) goto LAB_0010977b;
  }
  else {
    __size = (long)num_chans * 4;
    __src = (int32_t *)malloc(__size);
    if (num_samples != 0) goto LAB_0010971e;
  }
  free(__src);
LAB_0010977b:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void reorder_channels(void *data,uchar *order,int num_chans,int num_samples,int bytes_per_sample)

{
  byte bVar1;
  long lVar2;
  ulong uVar3;
  char *__src;
  int iVar4;
  int iVar5;
  byte *pbVar6;
  void *pvVar7;
  long in_FS_OFFSET;
  bool bVar8;
  size_t local_90;
  char reorder_buffer [64];
  
  iVar5 = num_samples + -1;
  iVar4 = num_chans * bytes_per_sample;
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  if (iVar4 < 0x41) {
    if (num_samples == 0) goto LAB_001098d2;
    __src = reorder_buffer;
LAB_0010982b:
    local_90 = (size_t)iVar4;
    do {
      pvVar7 = data;
      if (0 < num_chans) {
        pbVar6 = order;
        do {
          bVar1 = *pbVar6;
          if (bytes_per_sample != 0) {
            uVar3 = 0;
            do {
              __src[uVar3 + (long)(int)((uint)bVar1 * bytes_per_sample)] =
                   *(char *)((long)pvVar7 + uVar3);
              bVar8 = uVar3 != bytes_per_sample - 1;
              uVar3 = uVar3 + 1;
            } while (bVar8);
            pvVar7 = (void *)((long)pvVar7 + (ulong)(bytes_per_sample - 1) + 1);
          }
          pbVar6 = pbVar6 + 1;
        } while (pbVar6 != order + (ulong)(num_chans - 1) + 1);
      }
      iVar5 = iVar5 + -1;
      memcpy(data,__src,local_90);
      data = pvVar7;
    } while (iVar5 != -1);
    if (iVar4 < 0x41) goto LAB_001098d2;
  }
  else {
    __src = (char *)malloc((long)iVar4);
    if (num_samples != 0) goto LAB_0010982b;
  }
  free(__src);
LAB_001098d2:
  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void make_settings_string(char *settings,WavpackConfig *config)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  undefined2 *puVar4;
  uint uVar5;
  uint *puVar6;
  undefined8 *puVar7;
  int iVar8;
  char *pcVar9;
  bool bVar10;
  
  settings[0] = '-';
  settings[1] = '\0';
  uVar2 = config->flags;
  if ((uVar2 & 0x200) == 0) {
    if ((uVar2 & 0x1000) == 0) {
      if ((uVar2 & 0x800) != 0) {
        settings[1] = 'h';
        settings[2] = '\0';
        uVar2 = config->flags;
      }
    }
    else {
      settings[3] = '\0';
      settings[1] = 'h';
      settings[2] = 'h';
      uVar2 = config->flags;
    }
  }
  else {
    settings[1] = 'f';
    settings[2] = '\0';
    uVar2 = config->flags;
  }
  puVar3 = (uint *)settings;
  if ((uVar2 & 8) != 0) {
    do {
      puVar6 = puVar3;
      uVar1 = *puVar6 + 0xfefefeff & ~*puVar6;
      uVar2 = uVar1 & 0x80808080;
      puVar3 = puVar6 + 1;
    } while (uVar2 == 0);
    bVar10 = (uVar1 & 0x8080) == 0;
    if (bVar10) {
      uVar2 = uVar2 >> 0x10;
    }
    if (bVar10) {
      puVar3 = (uint *)((long)puVar6 + 6);
    }
    __sprintf_chk((double)config->bitrate,
                  (long)puVar3 + (-3 - (ulong)CARRY1((byte)uVar2,(byte)uVar2)),1,0xffffffffffffffff,
                  &DAT_00115004);
    uVar2 = config->flags;
    puVar3 = (uint *)settings;
    if ((uVar2 & 0x100000) == 0) {
      if ((uVar2 & 0x80000) != 0) {
        do {
          puVar6 = puVar3;
          uVar1 = *puVar6 + 0xfefefeff & ~*puVar6;
          uVar2 = uVar1 & 0x80808080;
          puVar3 = puVar6 + 1;
        } while (uVar2 == 0);
        bVar10 = (uVar1 & 0x8080) == 0;
        if (bVar10) {
          uVar2 = uVar2 >> 0x10;
        }
        if (bVar10) {
          puVar3 = (uint *)((long)puVar6 + 6);
        }
        *(undefined2 *)((long)puVar3 + (-3 - (ulong)CARRY1((byte)uVar2,(byte)uVar2))) = 99;
        uVar2 = config->flags;
      }
    }
    else {
      do {
        puVar6 = puVar3;
        uVar1 = *puVar6 + 0xfefefeff & ~*puVar6;
        uVar2 = uVar1 & 0x80808080;
        puVar3 = puVar6 + 1;
      } while (uVar2 == 0);
      bVar10 = (uVar1 & 0x8080) == 0;
      if (bVar10) {
        uVar2 = uVar2 >> 0x10;
      }
      if (bVar10) {
        puVar3 = (uint *)((long)puVar6 + 6);
      }
      puVar4 = (undefined2 *)((long)puVar3 + (-3 - (ulong)CARRY1((byte)uVar2,(byte)uVar2)));
      *puVar4 = 0x6363;
      *(undefined *)(puVar4 + 1) = 0;
      uVar2 = config->flags;
    }
  }
  if ((uVar2 & 0x2000000) != 0) {
    iVar8 = config->xmode;
    puVar3 = (uint *)settings;
    if (iVar8 == 0) {
      iVar8 = 1;
    }
    do {
      puVar6 = puVar3;
      uVar1 = *puVar6 + 0xfefefeff & ~*puVar6;
      uVar2 = uVar1 & 0x80808080;
      puVar3 = puVar6 + 1;
    } while (uVar2 == 0);
    bVar10 = (uVar1 & 0x8080) == 0;
    if (bVar10) {
      uVar2 = uVar2 >> 0x10;
    }
    if (bVar10) {
      puVar3 = (uint *)((long)puVar6 + 6);
    }
    __sprintf_chk((long)puVar3 + (-3 - (ulong)CARRY1((byte)uVar2,(byte)uVar2)),1,0xffffffffffffffff,
                  &DAT_00115008,iVar8);
    uVar2 = config->flags;
  }
  puVar3 = (uint *)settings;
  if ((uVar2 & 0x10000) != 0) {
    do {
      puVar6 = puVar3;
      uVar5 = *puVar6 + 0xfefefeff & ~*puVar6;
      uVar1 = uVar5 & 0x80808080;
      puVar3 = puVar6 + 1;
    } while (uVar1 == 0);
    bVar10 = (uVar5 & 0x8080) == 0;
    if (bVar10) {
      uVar1 = uVar1 >> 0x10;
    }
    if (bVar10) {
      puVar3 = (uint *)((long)puVar6 + 6);
    }
    puVar4 = (undefined2 *)((long)puVar3 + (-3 - (ulong)CARRY1((byte)uVar1,(byte)uVar1)));
    if ((uVar2 & 0x10) == 0) {
      *(undefined *)(puVar4 + 1) = 0;
      *puVar4 = 0x306a;
      uVar2 = config->flags;
    }
    else {
      *(undefined *)(puVar4 + 1) = 0;
      *puVar4 = 0x316a;
      uVar2 = config->flags;
    }
  }
  puVar3 = (uint *)settings;
  if ((uVar2 & 0x8000) != 0) {
    do {
      puVar6 = puVar3;
      uVar1 = *puVar6 + 0xfefefeff & ~*puVar6;
      uVar2 = uVar1 & 0x80808080;
      puVar3 = puVar6 + 1;
    } while (uVar2 == 0);
    bVar10 = (uVar1 & 0x8080) == 0;
    if (bVar10) {
      uVar2 = uVar2 >> 0x10;
    }
    if (bVar10) {
      puVar3 = (uint *)((long)puVar6 + 6);
    }
    __sprintf_chk((double)config->shaping_weight,
                  (long)puVar3 + (-3 - (ulong)CARRY1((byte)uVar2,(byte)uVar2)),1,0xffffffffffffffff,
                  &DAT_0011500c);
  }
  if (quantize_bits != 0) {
    pcVar9 = "-round";
    puVar3 = (uint *)settings;
    if (quantize_round == 0) {
      pcVar9 = "";
    }
    do {
      puVar6 = puVar3;
      uVar1 = *puVar6 + 0xfefefeff & ~*puVar6;
      uVar2 = uVar1 & 0x80808080;
      puVar3 = puVar6 + 1;
    } while (uVar2 == 0);
    bVar10 = (uVar1 & 0x8080) == 0;
    if (bVar10) {
      uVar2 = uVar2 >> 0x10;
    }
    if (bVar10) {
      puVar3 = (uint *)((long)puVar6 + 6);
    }
    __sprintf_chk((long)puVar3 + (-3 - (ulong)CARRY1((byte)uVar2,(byte)uVar2)),1,0xffffffffffffffff,
                  " --pre-quantize%s=%d",pcVar9);
  }
  puVar3 = (uint *)settings;
  if (config->block_samples != 0) {
    do {
      puVar6 = puVar3;
      uVar1 = *puVar6 + 0xfefefeff & ~*puVar6;
      uVar2 = uVar1 & 0x80808080;
      puVar3 = puVar6 + 1;
    } while (uVar2 == 0);
    bVar10 = (uVar1 & 0x8080) == 0;
    if (bVar10) {
      uVar2 = uVar2 >> 0x10;
    }
    if (bVar10) {
      puVar3 = (uint *)((long)puVar6 + 6);
    }
    __sprintf_chk((long)puVar3 + (-3 - (ulong)CARRY1((byte)uVar2,(byte)uVar2)),1,0xffffffffffffffff,
                  " --blocksize=%d");
  }
  uVar2 = config->flags;
  puVar3 = (uint *)settings;
  if ((uVar2 & 0x20000) != 0) {
    do {
      puVar6 = puVar3;
      uVar1 = *puVar6 + 0xfefefeff & ~*puVar6;
      uVar2 = uVar1 & 0x80808080;
      puVar3 = puVar6 + 1;
    } while (uVar2 == 0);
    bVar10 = (uVar1 & 0x8080) == 0;
    if (bVar10) {
      uVar2 = uVar2 >> 0x10;
    }
    if (bVar10) {
      puVar3 = (uint *)((long)puVar6 + 6);
    }
    puVar7 = (undefined8 *)((long)puVar3 + (-3 - (ulong)CARRY1((byte)uVar2,(byte)uVar2)));
    *puVar7 = 0x642d6573752d2d20;
    *(undefined2 *)(puVar7 + 1) = 0x736e;
    *(undefined *)((long)puVar7 + 10) = 0;
    uVar2 = config->flags;
  }
  puVar3 = (uint *)settings;
  if ((uVar2 & 0x20) != 0) {
    do {
      puVar6 = puVar3;
      uVar1 = *puVar6 + 0xfefefeff & ~*puVar6;
      uVar2 = uVar1 & 0x80808080;
      puVar3 = puVar6 + 1;
    } while (uVar2 == 0);
    bVar10 = (uVar1 & 0x8080) == 0;
    if (bVar10) {
      uVar2 = uVar2 >> 0x10;
    }
    if (bVar10) {
      puVar3 = (uint *)((long)puVar6 + 6);
    }
    puVar7 = (undefined8 *)((long)puVar3 + (-3 - (ulong)CARRY1((byte)uVar2,(byte)uVar2)));
    *puVar7 = 0x73736f72632d2d20;
    puVar7[1] = 0x72726f6365642d;
    uVar2 = config->flags;
  }
  puVar3 = (uint *)settings;
  if ((uVar2 & 0x10000000) != 0) {
    do {
      puVar6 = puVar3;
      uVar1 = *puVar6 + 0xfefefeff & ~*puVar6;
      uVar2 = uVar1 & 0x80808080;
      puVar3 = puVar6 + 1;
    } while (uVar2 == 0);
    bVar10 = (uVar1 & 0x8080) == 0;
    if (bVar10) {
      uVar2 = uVar2 >> 0x10;
    }
    if (bVar10) {
      puVar3 = (uint *)((long)puVar6 + 6);
    }
    puVar7 = (undefined8 *)((long)puVar3 + (-3 - (ulong)CARRY1((byte)uVar2,(byte)uVar2)));
    *puVar7 = 0x656772656d2d2d20;
    puVar7[1] = 0x736b636f6c622d;
    uVar2 = config->flags;
  }
  puVar3 = (uint *)settings;
  if ((uVar2 & 0x20000000) != 0) {
    do {
      puVar6 = puVar3;
      uVar1 = *puVar6 + 0xfefefeff & ~*puVar6;
      uVar2 = uVar1 & 0x80808080;
      puVar3 = puVar6 + 1;
    } while (uVar2 == 0);
    bVar10 = (uVar1 & 0x8080) == 0;
    if (bVar10) {
      uVar2 = uVar2 >> 0x10;
    }
    if (bVar10) {
      puVar3 = (uint *)((long)puVar6 + 6);
    }
    puVar7 = (undefined8 *)((long)puVar3 + (-3 - (ulong)CARRY1((byte)uVar2,(byte)uVar2)));
    puVar7[2] = 0x736e6168632d6465;
    *(undefined *)(puVar7 + 3) = 0;
    *puVar7 = 0x2d726961702d2d20;
    puVar7[1] = 0x6e67697373616e75;
  }
  if (allow_huge_tags == 0) {
    return;
  }
  do {
    puVar3 = (uint *)settings;
    uVar1 = *puVar3 + 0xfefefeff & ~*puVar3;
    uVar2 = uVar1 & 0x80808080;
    settings = (char *)(puVar3 + 1);
  } while (uVar2 == 0);
  bVar10 = (uVar1 & 0x8080) == 0;
  if (bVar10) {
    uVar2 = uVar2 >> 0x10;
  }
  puVar6 = puVar3 + 1;
  if (bVar10) {
    puVar6 = (uint *)((long)puVar3 + 6);
  }
  puVar7 = (undefined8 *)((long)puVar6 + (-3 - (ulong)CARRY1((byte)uVar2,(byte)uVar2)));
  *(undefined2 *)(puVar7 + 2) = 0x7367;
  *(undefined *)((long)puVar7 + 0x12) = 0;
  *puVar7 = 0x776f6c6c612d2d20;
  puVar7[1] = 0x61742d656775682d;
  return;
}



void * store_samples(void *dst,int32_t *src,int qmode,int bps,int count)

{
  int32_t *piVar1;
  int *piVar2;
  int32_t iVar3;
  int iVar4;
  undefined *puVar5;
  ulong uVar6;
  ulong uVar7;
  bool bVar8;
  
  if ((qmode & 1U) == 0) {
    if ((qmode & 4U) == 0) {
      if (bps != 1) {
        if (bps != 3) {
          if (bps < 4) {
            if (bps != 2) {
              return dst;
            }
            uVar7 = (ulong)(count - 1);
            uVar6 = 0;
            if (count == 0) {
              return dst;
            }
            do {
              iVar3 = src[uVar6];
              *(char *)((long)dst + uVar6 * 2) = (char)iVar3;
              *(char *)((long)dst + uVar6 * 2 + 1) = (char)((uint)iVar3 >> 8);
              bVar8 = uVar6 != uVar7;
              uVar6 = uVar6 + 1;
            } while (bVar8);
            goto LAB_0010a016;
          }
          if (bps != 4) {
            return dst;
          }
          uVar6 = (ulong)(count - 1);
          if (count == 0) {
            return dst;
          }
          piVar1 = src + uVar6 + 1;
          puVar5 = (undefined *)dst;
          do {
            iVar3 = *src;
            src = src + 1;
            *puVar5 = (char)iVar3;
            puVar5[1] = (char)((uint)iVar3 >> 8);
            puVar5[2] = (char)((uint)iVar3 >> 0x10);
            puVar5[3] = (char)((uint)iVar3 >> 0x18);
            puVar5 = puVar5 + 4;
          } while (src != piVar1);
          goto LAB_00109fcf;
        }
        if (count == 0) {
          return dst;
        }
        uVar6 = (ulong)(count - 1);
        piVar1 = src + uVar6 + 1;
        puVar5 = (undefined *)dst;
        do {
          iVar3 = *src;
          src = src + 1;
          *puVar5 = (char)iVar3;
          puVar5[1] = (char)((uint)iVar3 >> 8);
          puVar5[2] = (char)((uint)iVar3 >> 0x10);
          puVar5 = puVar5 + 3;
        } while (src != piVar1);
LAB_0010a1ab:
        return (void *)((long)dst + uVar6 * 3 + 3);
      }
      if ((qmode & 2U) != 0) {
        uVar7 = (ulong)(count - 1);
        uVar6 = 0;
        if (count == 0) {
          return dst;
        }
        do {
          *(char *)((long)dst + uVar6) = (char)src[uVar6];
          bVar8 = uVar6 != uVar7;
          uVar6 = uVar6 + 1;
        } while (bVar8);
        goto LAB_00109f35;
      }
    }
    else {
      if (bps == 3) {
        if (count == 0) {
          return dst;
        }
        uVar6 = (ulong)(count - 1);
        piVar2 = src + uVar6 + 1;
        puVar5 = (undefined *)dst;
        do {
          iVar4 = *src;
          src = src + 1;
          iVar4 = iVar4 + 0x800000;
          *puVar5 = (char)iVar4;
          puVar5[1] = (char)((uint)iVar4 >> 8);
          puVar5[2] = (char)((uint)iVar4 >> 0x10);
          puVar5 = puVar5 + 3;
        } while (src != piVar2);
        goto LAB_0010a1ab;
      }
      if (3 < bps) {
        if (bps != 4) {
          return dst;
        }
        uVar6 = (ulong)(count - 1);
        if (count == 0) {
          return dst;
        }
        piVar2 = src + uVar6 + 1;
        puVar5 = (undefined *)dst;
        do {
          iVar4 = *src;
          src = src + 1;
          iVar4 = iVar4 + -0x80000000;
          *puVar5 = (char)iVar4;
          puVar5[1] = (char)((uint)iVar4 >> 8);
          puVar5[2] = (char)((uint)iVar4 >> 0x10);
          puVar5[3] = (char)((uint)iVar4 >> 0x18);
          puVar5 = puVar5 + 4;
        } while (src != piVar2);
        goto LAB_00109fcf;
      }
      if (bps != 1) {
        if (bps != 2) {
          return dst;
        }
        uVar7 = (ulong)(count - 1);
        uVar6 = 0;
        if (count == 0) {
          return dst;
        }
        do {
          iVar4 = src[uVar6];
          *(char *)((long)dst + uVar6 * 2) = (char)(iVar4 + 0x8000);
          *(char *)((long)dst + uVar6 * 2 + 1) = (char)((uint)(iVar4 + 0x8000) >> 8);
          bVar8 = uVar6 != uVar7;
          uVar6 = uVar6 + 1;
        } while (bVar8);
        goto LAB_0010a016;
      }
    }
    uVar7 = (ulong)(count - 1);
    uVar6 = 0;
    if (count == 0) {
      return dst;
    }
    do {
      *(char *)((long)dst + uVar6) = *(char *)(src + uVar6) + -0x80;
      bVar8 = uVar6 != uVar7;
      uVar6 = uVar6 + 1;
    } while (bVar8);
  }
  else {
    if ((qmode & 4U) == 0) {
      if (bps != 1) {
        if (bps != 3) {
          if (bps < 4) {
            if (bps != 2) {
              return dst;
            }
            uVar7 = (ulong)(count - 1);
            uVar6 = 0;
            if (count == 0) {
              return dst;
            }
            do {
              iVar3 = src[uVar6];
              *(char *)((long)dst + uVar6 * 2) = (char)((uint)iVar3 >> 8);
              *(char *)((long)dst + uVar6 * 2 + 1) = (char)iVar3;
              bVar8 = uVar7 != uVar6;
              uVar6 = uVar6 + 1;
            } while (bVar8);
LAB_0010a016:
            return (void *)((long)dst + uVar7 * 2 + 2);
          }
          if (bps != 4) {
            return dst;
          }
          uVar6 = (ulong)(count - 1);
          if (count == 0) {
            return dst;
          }
          piVar1 = src + uVar6 + 1;
          puVar5 = (undefined *)dst;
          do {
            iVar3 = *src;
            src = src + 1;
            puVar5[2] = (char)((uint)iVar3 >> 8);
            *puVar5 = (char)((uint)iVar3 >> 0x18);
            puVar5[1] = (char)((uint)iVar3 >> 0x10);
            puVar5[3] = (char)iVar3;
            puVar5 = puVar5 + 4;
          } while (src != piVar1);
LAB_00109fcf:
          return (void *)((long)dst + uVar6 * 4 + 4);
        }
        uVar6 = (ulong)(count - 1);
        if (count == 0) {
          return dst;
        }
        piVar1 = src + uVar6 + 1;
        puVar5 = (undefined *)dst;
        do {
          iVar3 = *src;
          src = src + 1;
          puVar5[1] = (char)((uint)iVar3 >> 8);
          *puVar5 = (char)((uint)iVar3 >> 0x10);
          puVar5[2] = (char)iVar3;
          puVar5 = puVar5 + 3;
        } while (src != piVar1);
LAB_0010a1ee:
        return (void *)((long)dst + uVar6 * 3 + 3);
      }
      if ((qmode & 2U) != 0) {
        uVar7 = (ulong)(count - 1);
        uVar6 = 0;
        if (count == 0) {
          return dst;
        }
        do {
          *(char *)((long)dst + uVar6) = (char)src[uVar6];
          bVar8 = uVar7 != uVar6;
          uVar6 = uVar6 + 1;
        } while (bVar8);
        goto LAB_00109f35;
      }
    }
    else {
      if (bps == 3) {
        uVar6 = (ulong)(count - 1);
        if (count == 0) {
          return dst;
        }
        piVar2 = src + uVar6 + 1;
        puVar5 = (undefined *)dst;
        do {
          iVar4 = *src;
          src = src + 1;
          iVar4 = iVar4 + 0x800000;
          puVar5[1] = (char)((uint)iVar4 >> 8);
          *puVar5 = (char)((uint)iVar4 >> 0x10);
          puVar5[2] = (char)iVar4;
          puVar5 = puVar5 + 3;
        } while (src != piVar2);
        goto LAB_0010a1ee;
      }
      if (3 < bps) {
        if (bps != 4) {
          return dst;
        }
        uVar6 = (ulong)(count - 1);
        if (count == 0) {
          return dst;
        }
        piVar2 = src + uVar6 + 1;
        puVar5 = (undefined *)dst;
        do {
          iVar4 = *src;
          src = src + 1;
          iVar4 = iVar4 + -0x80000000;
          puVar5[2] = (char)((uint)iVar4 >> 8);
          *puVar5 = (char)((uint)iVar4 >> 0x18);
          puVar5[1] = (char)((uint)iVar4 >> 0x10);
          puVar5[3] = (char)iVar4;
          puVar5 = puVar5 + 4;
        } while (src != piVar2);
        goto LAB_00109fcf;
      }
      if (bps != 1) {
        if (bps != 2) {
          return dst;
        }
        uVar7 = (ulong)(count - 1);
        uVar6 = 0;
        if (count == 0) {
          return dst;
        }
        do {
          iVar4 = src[uVar6];
          *(char *)((long)dst + uVar6 * 2) = (char)((uint)(iVar4 + 0x8000) >> 8);
          *(char *)((long)dst + uVar6 * 2 + 1) = (char)(iVar4 + 0x8000);
          bVar8 = uVar7 != uVar6;
          uVar6 = uVar6 + 1;
        } while (bVar8);
        goto LAB_0010a016;
      }
    }
    uVar7 = (ulong)(count - 1);
    uVar6 = 0;
    if (count == 0) {
      return dst;
    }
    do {
      *(char *)((long)dst + uVar6) = *(char *)(src + uVar6) + -0x80;
      bVar8 = uVar7 != uVar6;
      uVar6 = uVar6 + 1;
    } while (bVar8);
  }
LAB_00109f35:
  return (void *)((long)dst + uVar7 + 1);
}



void display_progress(double file_progress)

{
  long lVar1;
  long in_FS_OFFSET;
  char title [40];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  __sprintf_chk(title,1,0x28,"%d%% (WavPack)",
                (int)((((double)file_index + file_progress) / (double)num_files) * 100.0 + 0.5));
  DoSetConsoleTitle(title);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int verify_audio(char *infilename,uchar *md5_digest_source)

{
  long lVar1;
  long lVar2;
  byte bVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  long lVar9;
  uint *data;
  void *data_00;
  long lVar10;
  ulong uVar11;
  uchar *puVar12;
  uint *puVar13;
  uchar uVar14;
  void *pvVar15;
  uint *puVar16;
  int iVar17;
  int iVar18;
  uint uVar19;
  long in_FS_OFFSET;
  bool bVar20;
  double dVar21;
  long local_1a8;
  double local_198;
  MD5_CTX md5_context;
  uchar md5_digest_result [16];
  char md5_string1 [33];
  char md5_string2 [33];
  char error [80];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  lVar9 = WavpackOpenFileInput(infilename,error,0x501,0);
  if (lVar9 == 0) {
    iVar5 = 1;
    error_line(error);
    goto LAB_0010a82f;
  }
  if (md5_digest_source != (uchar *)0x0) {
    MD5_Init((MD5_CTX *)&md5_context);
  }
  uVar4 = WavpackGetQualifyMode(lVar9);
  iVar5 = WavpackGetNumChannels(lVar9);
  iVar6 = WavpackGetBytesPerSample(lVar9);
  data = (uint *)malloc((long)(iVar5 << 0xe));
  if ((uVar4 & 8) == 0) {
    puVar12 = (uchar *)0x0;
    uVar19 = iVar5 - 1;
  }
  else {
    puVar12 = (uchar *)0x0;
    bVar3 = WavpackGetChannelLayout(lVar9,0);
    uVar19 = iVar5 - 1;
    if ((int)(uint)bVar3 <= iVar5) {
      puVar12 = (uchar *)malloc((long)iVar5);
      uVar11 = 0;
      if (iVar5 == 0) {
        uVar19 = 0xffffffff;
      }
      else {
        do {
          puVar12[uVar11] = (uchar)uVar11;
          bVar20 = uVar19 != uVar11;
          uVar11 = uVar11 + 1;
        } while (bVar20);
      }
      WavpackGetChannelLayout(lVar9,puVar12);
    }
  }
  local_1a8 = 0;
  iVar7 = iVar5 << 0xc;
  local_198 = -1.0;
  while( true ) {
    iVar8 = WavpackUnpackSamples(lVar9,data,0x1000);
    local_1a8 = local_1a8 + iVar8;
    if (iVar8 == 0) break;
    if (md5_digest_source == (uchar *)0x0) {
LAB_0010a637:
      iVar8 = check_break();
    }
    else {
      if (puVar12 != (uchar *)0x0) {
        unreorder_channels((int32_t *)data,puVar12,iVar5,iVar8);
      }
      if ((uVar4 & 0x30) != 0) {
        data_00 = malloc((long)iVar7);
        if ((uVar4 & 0x40) == 0) {
          iVar18 = iVar8 * iVar5;
          if (iVar18 != 0) {
            uVar11 = 0;
            do {
              *(char *)((long)data_00 + uVar11) = (char)data[uVar11];
              bVar20 = iVar18 - 1 != uVar11;
              uVar11 = uVar11 + 1;
            } while (bVar20);
          }
        }
        else {
          iVar18 = iVar7;
          if (iVar5 != 0) {
            pvVar15 = data_00;
            puVar16 = data;
            do {
              lVar10 = 0;
              puVar13 = puVar16;
              do {
                while (iVar8 <= (int)lVar10) {
                  *(undefined *)((long)pvVar15 + lVar10) = 0;
                  lVar10 = lVar10 + 1;
                  puVar13 = puVar13 + iVar5;
                  if (lVar10 == 0x1000) goto LAB_0010a5fc;
                }
                uVar14 = (uchar)*puVar13;
                if ((uVar4 & 0x10) != 0) {
                  uVar14 = ""[*puVar13 & 0xff];
                }
                *(uchar *)((long)pvVar15 + lVar10) = uVar14;
                lVar10 = lVar10 + 1;
                puVar13 = puVar13 + iVar5;
              } while (lVar10 != 0x1000);
LAB_0010a5fc:
              pvVar15 = (void *)((long)pvVar15 + 0x1000);
              puVar16 = (uint *)((long)puVar16 + (long)(iVar5 << 0xe) + (1 - (long)iVar7) * 4);
            } while (pvVar15 != (void *)((long)data_00 + ((ulong)uVar19 + 1) * 0x1000));
          }
        }
        MD5_Update((MD5_CTX *)&md5_context,data_00,(long)iVar18);
        free(data_00);
        goto LAB_0010a637;
      }
      iVar18 = iVar6;
      iVar17 = iVar5;
      store_samples(data,(int32_t *)data,uVar4,iVar6,iVar5 * iVar8);
      MD5_Update((MD5_CTX *)&md5_context,data,(long)(iVar8 * iVar18 * iVar17));
      iVar8 = check_break();
    }
    if (iVar8 != 0) {
      fputc(10,stderr);
      fflush(stderr);
      free(data);
      if (puVar12 == (uchar *)0x0) goto LAB_0010a985;
      iVar5 = 1;
      free(puVar12);
      goto LAB_0010a827;
    }
    dVar21 = (double)WavpackGetProgress(lVar9);
    if ((false) || (dVar21 != -1.0)) {
      dVar21 = (double)WavpackGetProgress(lVar9);
      dVar21 = (100.0 - encode_time_percent) * dVar21 + encode_time_percent + 0.5;
      if (ABS(dVar21) < 4503599627370496.0) {
        dVar21 = (double)((ulong)dVar21 & 0x8000000000000000 |
                         (ulong)((double)(long)dVar21 -
                                (double)(-(ulong)(dVar21 < (double)(long)dVar21) &
                                        0x3ff0000000000000)));
      }
      if ((false) || (dVar21 != local_198)) {
        dVar21 = (double)WavpackGetProgress(lVar9);
        local_198 = (100.0 - encode_time_percent) * dVar21 + encode_time_percent + 0.5;
        if (ABS(local_198) < 4503599627370496.0) {
          local_198 = (double)((ulong)local_198 & 0x8000000000000000 |
                              (ulong)((double)(long)local_198 -
                                     (double)(-(ulong)(local_198 < (double)(long)local_198) &
                                             0x3ff0000000000000)));
        }
        if (set_console_title != 0) {
          display_progress(local_198 / 100.0);
        }
        if (quiet_mode == 0) {
          __fprintf_chk(stderr,1,"%s%3d%% done...",&DAT_00115044,(int)local_198);
          fflush(stderr);
        }
      }
    }
  }
  free(data);
  if (puVar12 == (uchar *)0x0) {
    if (md5_digest_source != (uchar *)0x0) goto LAB_0010a99c;
LAB_0010a917:
    lVar10 = WavpackGetNumSamples64(lVar9);
    iVar5 = 0;
    if (lVar10 != -1) {
      lVar10 = WavpackGetNumSamples64(lVar9);
      if (local_1a8 < lVar10) {
        lVar10 = WavpackGetNumSamples64(lVar9);
        iVar5 = 1;
        error_line("file is missing %llu samples!",lVar10 - local_1a8);
      }
      else {
        lVar10 = WavpackGetNumSamples64(lVar9);
        if (lVar10 < local_1a8) {
          iVar5 = 1;
          lVar10 = WavpackGetNumSamples64(lVar9);
          error_line("file has %llu extra samples!",local_1a8 - lVar10);
        }
      }
    }
    iVar6 = WavpackGetNumErrors(lVar9);
    if (iVar6 != 0) {
      uVar4 = WavpackGetNumErrors(lVar9);
      error_line("missing data or crc errors detected in %d block(s)!",(ulong)uVar4);
LAB_0010a985:
      iVar5 = 1;
    }
  }
  else {
    free(puVar12);
    if (md5_digest_source == (uchar *)0x0) goto LAB_0010a917;
LAB_0010a99c:
    MD5_Final(md5_digest_result,(MD5_CTX *)&md5_context);
    if (md5_digest_result._8_8_ == *(long *)(md5_digest_source + 8) &&
        md5_digest_result._0_8_ == *(long *)md5_digest_source) goto LAB_0010a917;
    builtin_strncpy(md5_string1,"00000000000000000000000000000000",0x21);
    lVar10 = 0;
    builtin_strncpy(md5_string2,"00000000000000000000000000000000",0x21);
    do {
      lVar2 = lVar10 * 2;
      __sprintf_chk(md5_string1 + lVar2,1,0xffffffffffffffff,&DAT_00115061,md5_digest_source[lVar10]
                   );
      puVar12 = md5_digest_result + lVar10;
      lVar10 = lVar10 + 1;
      __sprintf_chk(md5_string2 + lVar2,1,0xffffffffffffffff,&DAT_00115061,*puVar12);
    } while (lVar10 != 0x10);
    error_line("original md5: %s",md5_string1);
    error_line("verified md5: %s",md5_string2);
    iVar5 = 1;
    error_line("MD5 signatures should match, but do not!");
  }
LAB_0010a827:
  WavpackCloseFile(lVar9);
LAB_0010a82f:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar5;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int write_block(void *id,void *data,int32_t length)

{
  int iVar1;
  long in_FS_OFFSET;
  uint32_t bcount;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)((long)id + 0x10) == 0) {
    if (((*(FILE **)((long)id + 8) != (FILE *)0x0) && (data != (void *)0x0)) && (length != 0)) {
      iVar1 = DoWriteFile(*(FILE **)((long)id + 8),data,length,&bcount);
      if ((iVar1 == 0) || (length != bcount)) {
        DoTruncateFile(*(FILE **)((long)id + 8));
        DoCloseHandle(*(FILE **)((long)id + 8));
        *(undefined8 *)((long)id + 8) = 0;
        *(undefined4 *)((long)id + 0x10) = 1;
        iVar1 = 0;
        goto LAB_0010abbf;
      }
                    // WARNING: Load size is inaccurate
      *(int *)id = *id + length;
      if (*(int *)((long)id + 4) == 0) {
        *(int32_t *)((long)id + 4) = length;
      }
    }
    iVar1 = 1;
  }
  else {
    iVar1 = 0;
  }
LAB_0010abbf:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int pack_file(char *infilename,char *outfilename,char *out2filename,WavpackConfig *config)

{
  ushort *puVar1;
  uchar uVar2;
  int3 iVar3;
  FILE *hFile;
  byte bVar4;
  char cVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  uint32_t uVar9;
  int iVar10;
  uint uVar11;
  WavpackContext *wpc;
  FILE *pFVar12;
  size_t sVar13;
  uint *puVar14;
  char *pcVar15;
  int64_t iVar16;
  void *lpBuffer;
  ulong uVar17;
  uchar *puVar18;
  float *src;
  ulong uVar19;
  char *pcVar20;
  undefined8 uVar21;
  long lVar22;
  float *pfVar23;
  byte *pbVar24;
  float *pfVar25;
  undefined *puVar26;
  tag_item *ptVar27;
  write_id *pwVar28;
  uint *puVar29;
  byte *pbVar30;
  byte *pbVar31;
  uint uVar32;
  char *pcVar33;
  float fVar34;
  long lVar35;
  int iVar36;
  uint *puVar37;
  undefined4 *puVar38;
  undefined4 uVar39;
  anon_struct_40_5_c3e56e25 *paVar40;
  ulong uVar41;
  long in_FS_OFFSET;
  bool bVar42;
  bool bVar43;
  byte bVar44;
  double dVar45;
  double dVar46;
  ulong local_370;
  FILE *local_368;
  char *local_360;
  byte *local_358;
  double local_348;
  uchar *local_328;
  double local_320;
  double local_308;
  char *local_2f8;
  uint *local_2f0;
  int local_2e0;
  __timezone_ptr_t local_2d8;
  uchar *local_2d0;
  double local_2c8;
  int local_2c0;
  uint local_2bc;
  char dummy;
  uint32_t bcount;
  double peak;
  timezone timez;
  timeval time1;
  timeval time2;
  write_id wv_file;
  write_id wvc_file;
  WavpackConfig loc_config;
  MD5_CTX md5_context;
  uchar md5_digest [16];
  char cratio [16];
  char fourcc [4];
  char cStack_144;
  char cStack_143;
  char cStack_142;
  char cStack_141;
  char acStack_130 [24];
  undefined8 local_118;
  char local_110 [208];
  long local_40;
  
  bVar44 = 0;
  loc_config.bitrate = config->bitrate;
  loc_config.shaping_weight = config->shaping_weight;
  loc_config.bits_per_sample = config->bits_per_sample;
  loc_config.bytes_per_sample = config->bytes_per_sample;
  loc_config.qmode = config->qmode;
  loc_config.flags = config->flags;
  loc_config.xmode = config->xmode;
  loc_config.num_channels = config->num_channels;
  loc_config.float_norm_exp = config->float_norm_exp;
  loc_config.block_samples = config->block_samples;
  loc_config.extra_flags = config->extra_flags;
  loc_config.sample_rate = config->sample_rate;
  loc_config._64_8_ = *(undefined8 *)(config->md5_checksum + 0xc);
  loc_config.num_tag_strings = config->num_tag_strings;
  loc_config._76_4_ = *(undefined4 *)&config->field_0x4c;
  pwVar28 = &wvc_file;
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  loc_config.tag_strings = config->tag_strings;
  loc_config.channel_mask = config->channel_mask;
  loc_config.md5_checksum[0] = config->md5_checksum[0];
  loc_config.md5_checksum[1] = config->md5_checksum[1];
  loc_config.md5_checksum[2] = config->md5_checksum[2];
  loc_config.md5_checksum[3] = config->md5_checksum[3];
  loc_config.md5_checksum._4_8_ = *(undefined8 *)(config->md5_checksum + 4);
  if (out2filename == (char *)0x0) {
    pwVar28 = (write_id *)0x0;
  }
  wv_file.error = 0;
  wv_file._20_4_ = 0;
  wvc_file.error = 0;
  wvc_file._20_4_ = 0;
  wv_file.bytes_written = 0;
  wv_file.first_block_size = 0;
  wv_file.file = (FILE *)0x0;
  wvc_file.bytes_written = 0;
  wvc_file.first_block_size = 0;
  wvc_file.file = (FILE *)0x0;
  wpc = (WavpackContext *)WavpackOpenFileOutput(write_block,&wv_file,pwVar28);
  if (*infilename == '-') {
    local_368 = stdin;
  }
  else {
    local_368 = fopen(infilename,"rb");
    if (local_368 == (FILE *)0x0) {
      error_line("can\'t open file %s!",infilename);
      WavpackCloseFile(wpc);
      local_370._0_4_ = 1;
      goto LAB_0010b508;
    }
  }
  if ((loc_config._16_8_ & 0x1000) == 0) {
LAB_0010ad40:
    if (*outfilename == '-') {
LAB_0010ad4e:
      if (out2filename != (char *)0x0) {
LAB_0010ad5a:
        puVar14 = (uint *)outfilename;
        if (overwrite_all == 0) {
          pFVar12 = fopen(out2filename,"rb");
          wvc_file.file = (FILE *)pFVar12;
          if (pFVar12 == (FILE *)0x0) goto LAB_0010adc5;
          sVar13 = fread(&dummy,1,1,pFVar12);
          DoCloseHandle(wvc_file.file);
          puVar29 = (uint *)out2filename;
          if (sVar13 != 1) goto LAB_0010adc5;
          do {
            puVar14 = puVar29;
            uVar6 = *puVar14 + 0xfefefeff & ~*puVar14;
            uVar7 = uVar6 & 0x80808080;
            puVar29 = puVar14 + 1;
          } while (uVar7 == 0);
          bVar42 = (uVar6 & 0x8080) == 0;
          if (bVar42) {
            uVar7 = uVar7 >> 0x10;
          }
          if (bVar42) {
            puVar29 = (uint *)((long)puVar14 + 6);
          }
          pcVar15 = out2filename;
          if (0x1e < (long)puVar29 +
                     ((-3 - (ulong)CARRY1((byte)uVar7,(byte)uVar7)) - (long)out2filename)) {
            pcVar15 = filespec_name(out2filename);
          }
          __fprintf_chk(stderr,1,"overwrite %s (yes/no/all)? ",pcVar15);
          fflush(stderr);
          if (set_console_title != 0) {
            DoSetConsoleTitle("overwrite?");
          }
          cVar5 = yna();
          if (cVar5 == 'a') {
            overwrite_all = 1;
            puVar14 = (uint *)outfilename;
            goto LAB_0010adc5;
          }
          puVar14 = (uint *)outfilename;
          if (cVar5 == 'n') goto LAB_0010bfa5;
          do {
            puVar29 = puVar14;
            uVar6 = *puVar29 + 0xfefefeff & ~*puVar29;
            uVar7 = uVar6 & 0x80808080;
            puVar14 = puVar29 + 1;
          } while (uVar7 == 0);
          bVar42 = (uVar6 & 0x8080) == 0;
          if (bVar42) {
            uVar7 = uVar7 >> 0x10;
          }
          if (bVar42) {
            puVar14 = (uint *)((long)puVar29 + 6);
          }
          puVar14 = (uint *)malloc((long)puVar14 +
                                   (-(long)outfilename - (ulong)CARRY1((byte)uVar7,(byte)uVar7)) +
                                   0xd);
          puVar29 = (uint *)outfilename;
        }
        else {
LAB_0010adc5:
          do {
            puVar29 = puVar14;
            uVar6 = *puVar29 + 0xfefefeff & ~*puVar29;
            uVar7 = uVar6 & 0x80808080;
            puVar14 = puVar29 + 1;
          } while (uVar7 == 0);
          bVar42 = (uVar6 & 0x8080) == 0;
          if (bVar42) {
            uVar7 = uVar7 >> 0x10;
          }
          if (bVar42) {
            puVar14 = (uint *)((long)puVar29 + 6);
          }
          puVar14 = (uint *)malloc((long)puVar14 +
                                   (-(long)outfilename - (ulong)CARRY1((byte)uVar7,(byte)uVar7)) +
                                   0xd);
          puVar29 = (uint *)outfilename;
        }
        do {
          puVar37 = puVar29;
          uVar6 = *puVar37 + 0xfefefeff & ~*puVar37;
          uVar7 = uVar6 & 0x80808080;
          puVar29 = puVar37 + 1;
        } while (uVar7 == 0);
        bVar42 = (uVar6 & 0x8080) == 0;
        if (bVar42) {
          uVar7 = uVar7 >> 0x10;
        }
        if (bVar42) {
          puVar29 = (uint *)((long)puVar37 + 6);
        }
        local_2f8 = (char *)malloc((long)puVar29 +
                                   (-(long)outfilename - (ulong)CARRY1((byte)uVar7,(byte)uVar7)) +
                                   0xd);
        goto LAB_0010ae59;
      }
      gettimeofday((timeval *)&time1,(__timezone_ptr_t)&timez);
      local_2f8 = (char *)0x0;
      local_2f0 = (uint *)0x0;
      local_2e0 = 0;
      cVar5 = *outfilename;
      puVar14 = (uint *)outfilename;
    }
    else {
      pFVar12 = fopen(outfilename,"rb");
      wv_file.file = (FILE *)pFVar12;
      if (pFVar12 == (FILE *)0x0) goto LAB_0010ad4e;
      sVar13 = fread(&dummy,1,1,pFVar12);
      DoCloseHandle(wv_file.file);
      if (sVar13 != 1) goto LAB_0010ad4e;
      puVar14 = (uint *)outfilename;
      if (overwrite_all == 0) {
        do {
          puVar29 = puVar14;
          uVar6 = *puVar29 + 0xfefefeff & ~*puVar29;
          uVar7 = uVar6 & 0x80808080;
          puVar14 = puVar29 + 1;
        } while (uVar7 == 0);
        bVar42 = (uVar6 & 0x8080) == 0;
        if (bVar42) {
          uVar7 = uVar7 >> 0x10;
        }
        if (bVar42) {
          puVar14 = (uint *)((long)puVar29 + 6);
        }
        pcVar15 = outfilename;
        if (0x1e < (long)puVar14 +
                   ((-3 - (ulong)CARRY1((byte)uVar7,(byte)uVar7)) - (long)outfilename)) {
          pcVar15 = filespec_name(outfilename);
        }
        __fprintf_chk(stderr,1,"overwrite %s (yes/no/all)? ",pcVar15);
        fflush(stderr);
        if (set_console_title != 0) {
          DoSetConsoleTitle("overwrite?");
        }
        cVar5 = yna();
        if (cVar5 == 'a') {
          overwrite_all = 1;
          puVar14 = (uint *)outfilename;
          if (out2filename == (char *)0x0) goto LAB_0010d42c;
          goto LAB_0010adc5;
        }
        if (cVar5 == 'n') goto LAB_0010bfa5;
        puVar14 = (uint *)outfilename;
        if (out2filename == (char *)0x0) goto LAB_0010d42c;
        goto LAB_0010ad5a;
      }
      if (out2filename != (char *)0x0) goto LAB_0010adc5;
LAB_0010d42c:
      do {
        puVar29 = puVar14;
        uVar6 = *puVar29 + 0xfefefeff & ~*puVar29;
        uVar7 = uVar6 & 0x80808080;
        puVar14 = puVar29 + 1;
      } while (uVar7 == 0);
      bVar42 = (uVar6 & 0x8080) == 0;
      if (bVar42) {
        uVar7 = uVar7 >> 0x10;
      }
      if (bVar42) {
        puVar14 = (uint *)((long)puVar29 + 6);
      }
      puVar14 = (uint *)malloc((long)puVar14 +
                               (-(long)outfilename - (ulong)CARRY1((byte)uVar7,(byte)uVar7)) + 0xd);
      local_2f8 = (char *)0x0;
LAB_0010ae59:
      iVar8 = 0;
LAB_0010ae68:
      do {
        strcpy((char *)puVar14,outfilename);
        pcVar15 = filespec_ext((char *)puVar14);
        puVar29 = puVar14;
        if (pcVar15 == (char *)0x0) {
          do {
            puVar37 = puVar29;
            uVar6 = *puVar37 + 0xfefefeff & ~*puVar37;
            uVar7 = uVar6 & 0x80808080;
            puVar29 = puVar37 + 1;
          } while (uVar7 == 0);
          bVar42 = (uVar6 & 0x8080) == 0;
          if (bVar42) {
            uVar7 = uVar7 >> 0x10;
          }
          if (bVar42) {
            puVar29 = (uint *)((long)puVar37 + 6);
          }
          puVar38 = (undefined4 *)((long)puVar29 + (-3 - (ulong)CARRY1((byte)uVar7,(byte)uVar7)));
          if (iVar8 == 0) {
            *puVar38 = 0x706d742e;
            *(undefined *)(puVar38 + 1) = 0;
            iVar8 = 1;
          }
          else {
            __sprintf_chk(puVar38,1,0xffffffffffffffff,".tmp%d",iVar8);
            iVar8 = iVar8 + 1;
          }
        }
        else {
          if (iVar8 == 0) {
            pcVar15 = filespec_ext((char *)puVar14);
            builtin_strncpy(pcVar15,".tmp",5);
          }
          else {
            pcVar15 = filespec_ext((char *)puVar14);
            __sprintf_chk(pcVar15,1,0xffffffffffffffff,".tmp%d",iVar8);
          }
          pcVar15 = filespec_ext(outfilename);
          strcat((char *)puVar14,pcVar15);
          iVar8 = iVar8 + 1;
        }
        pFVar12 = fopen((char *)puVar14,"rb");
        if (pFVar12 != (FILE *)0x0) {
          sVar13 = fread(&dummy,1,1,pFVar12);
          fclose(pFVar12);
          if ((int)sVar13 == 1) goto LAB_0010ae68;
        }
        if (out2filename == (char *)0x0) break;
        pcVar15 = stpcpy(local_2f8,(char *)puVar14);
        pcVar15[0] = 'c';
        pcVar15[1] = '\0';
        pFVar12 = fopen(local_2f8,"rb");
        if (pFVar12 == (FILE *)0x0) break;
        sVar13 = fread(&dummy,1,1,pFVar12);
        fclose(pFVar12);
      } while ((int)sVar13 == 1);
      gettimeofday((timeval *)&time1,(__timezone_ptr_t)&timez);
      local_2e0 = 1;
      cVar5 = *outfilename;
      local_2f0 = puVar14;
    }
    if (cVar5 == '-') {
      wv_file.file = stdout;
      wv_file.bytes_written = (uint32_t)wv_file._0_8_;
      wv_file.first_block_size = SUB84(wv_file._0_8_,4);
    }
    else {
      pFVar12 = fopen((char *)puVar14,"w+b");
      wv_file.file = (FILE *)pFVar12;
      if (pFVar12 == (FILE *)0x0) {
        error_line("can\'t create file %s!",puVar14);
        goto LAB_0010bfa5;
      }
    }
    if (quiet_mode == 0) {
      if (*outfilename == '-') {
        pcVar15 = "stdin";
        if ((*infilename != '-') &&
           (sVar13 = strlen(infilename), pcVar15 = infilename, 0x1e < sVar13)) {
          pcVar15 = filespec_name(infilename);
        }
        __fprintf_chk(stderr,1,"packing %s to stdout,",pcVar15);
      }
      else {
        puVar14 = (uint *)outfilename;
        if (out2filename == (char *)0x0) {
          do {
            puVar29 = puVar14;
            uVar6 = *puVar29 + 0xfefefeff & ~*puVar29;
            uVar7 = uVar6 & 0x80808080;
            puVar14 = puVar29 + 1;
          } while (uVar7 == 0);
          bVar42 = (uVar6 & 0x8080) == 0;
          if (bVar42) {
            uVar7 = uVar7 >> 0x10;
          }
          if (bVar42) {
            puVar14 = (uint *)((long)puVar29 + 6);
          }
          pcVar15 = outfilename;
          if (0x1e < (long)puVar14 +
                     ((-3 - (ulong)CARRY1((byte)uVar7,(byte)uVar7)) - (long)outfilename)) {
            pcVar15 = filespec_name(outfilename);
          }
          __fprintf_chk(stderr,1,"creating %s,",pcVar15);
        }
        else {
          pcVar15 = filespec_ext(out2filename);
          do {
            puVar29 = puVar14;
            uVar6 = *puVar29 + 0xfefefeff & ~*puVar29;
            uVar7 = uVar6 & 0x80808080;
            puVar14 = puVar29 + 1;
          } while (uVar7 == 0);
          bVar42 = (uVar6 & 0x8080) == 0;
          if (bVar42) {
            uVar7 = uVar7 >> 0x10;
          }
          if (bVar42) {
            puVar14 = (uint *)((long)puVar29 + 6);
          }
          pcVar20 = outfilename;
          if (0x1e < (long)puVar14 +
                     ((-3 - (ulong)CARRY1((byte)uVar7,(byte)uVar7)) - (long)outfilename)) {
            pcVar20 = filespec_name(outfilename);
          }
          __fprintf_chk(stderr,1,"creating %s (+%s),",pcVar20,pcVar15);
        }
      }
      fflush(stderr);
    }
    local_2d8 = (__timezone_ptr_t)&timez;
    if ((loc_config._16_8_ & 0x1000) != 0) {
      if ((loc_config._16_8_ & 0x30) != 0) {
        WavpackSetFileInformation(wpc,&DAT_001151d1,3);
        if ((loc_config._16_8_ & 0x1000) == 0) goto LAB_0010b2d0;
      }
      if (raw_pcm_skip_bytes_begin == 0) {
        local_2c0 = 1;
        uVar7 = loc_config.qmode;
      }
      else {
        uVar7 = raw_pcm_skip_bytes_begin;
        do {
          uVar9 = 0x100;
          if (uVar7 < 0x100) {
            uVar9 = uVar7;
          }
          iVar8 = DoReadFile((FILE *)local_368,fourcc,uVar9,&bcount);
          if ((iVar8 == 0) || (bcount != uVar9)) {
            error_line("can\'t read file %s!",infilename);
            goto LAB_0010b4c2;
          }
          uVar7 = uVar7 - uVar9;
        } while (uVar7 != 0);
        local_2c0 = 1;
        uVar7 = loc_config.qmode;
      }
LAB_0010b46b:
      local_358 = (byte *)0x0;
      if ((uVar7 & 8) != 0) {
        bVar4 = WavpackGetChannelLayout(wpc);
        iVar8 = loc_config.num_channels;
        if ((int)(uint)bVar4 <= loc_config.num_channels) {
          local_358 = (byte *)malloc((long)loc_config.num_channels);
          uVar17 = 0;
          if (iVar8 != 0) {
            do {
              local_358[uVar17] = (byte)uVar17;
              bVar42 = iVar8 - 1 != uVar17;
              uVar17 = uVar17 + 1;
            } while (bVar42);
          }
          WavpackGetChannelLayout(wpc);
        }
        uVar7 = loc_config.qmode;
      }
      iVar8 = num_channels_order;
      local_370 = (ulong)uVar7;
      if (num_channels_order != 0 || (uVar7 & 0x400) != 0) {
        iVar36 = loc_config.num_channels;
        if ((loc_config.num_channels < num_channels_order) ||
           ((num_channels_order < loc_config.num_channels && ((uVar7 & 0x400) == 0)))) {
          error_line("file does not have %d channel(s)!",(ulong)(uint)num_channels_order);
          goto LAB_0010b4c2;
        }
        if (num_channels_order != 0) {
          local_358 = (byte *)malloc((long)loc_config.num_channels);
          uVar17 = 0;
          if (0 < iVar36) {
            do {
              local_358[uVar17] = (byte)uVar17;
              bVar42 = iVar36 - 1 != uVar17;
              uVar17 = uVar17 + 1;
            } while (bVar42);
          }
          memcpy(local_358,channel_order,(long)iVar8);
          uVar7 = 0;
          if (0 < iVar8) {
            do {
              uVar17 = 0;
              do {
                iVar36 = (int)uVar17;
                if (local_358[uVar17] == uVar7) {
                  uVar7 = uVar7 + 1;
                  break;
                }
                iVar36 = iVar36 + 1;
                bVar42 = iVar8 - 1 != uVar17;
                uVar17 = uVar17 + 1;
              } while (bVar42);
              pbVar24 = local_358;
              if (iVar8 == iVar36) {
                do {
                  if ((int)uVar7 < (int)(uint)*pbVar24) {
                    *pbVar24 = *pbVar24 - 1;
                  }
                  pbVar24 = pbVar24 + 1;
                } while (local_358 + (ulong)(iVar8 - 1) + 1 != pbVar24);
              }
            } while ((int)uVar7 < iVar8);
          }
        }
      }
      if (out2filename != (char *)0x0) {
        if (local_2e0 == 0) {
          pFVar12 = fopen(out2filename,"w+b");
          wvc_file.file = (FILE *)pFVar12;
          if (pFVar12 == (FILE *)0x0) {
            error_line("can\'t create correction file!");
            DoCloseHandle((FILE *)local_368);
            DoCloseHandle(wv_file.file);
            local_2f0 = (uint *)outfilename;
LAB_0010be52:
            DoDeleteFile((char *)local_2f0);
            WavpackCloseFile(wpc);
            local_370._0_4_ = 1;
            goto LAB_0010b508;
          }
        }
        else {
          pFVar12 = fopen(local_2f8,"w+b");
          wvc_file.file = (FILE *)pFVar12;
          if (pFVar12 == (FILE *)0x0) {
            error_line("can\'t create correction file!");
            DoCloseHandle((FILE *)local_368);
            DoCloseHandle(wv_file.file);
            goto LAB_0010be52;
          }
        }
        local_370 = loc_config._16_8_ & 0xffffffff;
      }
      local_2bc = (uint)local_370 & 0x30;
      if ((local_370 & 0x30) == 0) {
        bVar42 = (loc_config._16_8_ & 0x800000000000000) != 0 || verify_mode != 0;
        if (bVar42) {
          local_2d0 = md5_digest;
        }
        else {
          local_2d0 = (uchar *)0x0;
        }
        for (lVar35 = 0x10000; iVar8 = WavpackGetNumChannels(wpc),
            0x200000 < (ulong)(iVar8 * lVar35 * 4); lVar35 = lVar35 >> 1) {
        }
        if (local_2d0 != (uchar *)0x0) {
          MD5_Init((MD5_CTX *)&md5_context);
        }
        WavpackPackInit(wpc);
        iVar8 = WavpackGetBytesPerSample(wpc);
        iVar36 = WavpackGetNumChannels(wpc);
        uVar7 = iVar8 * iVar36;
        uVar6 = uVar7 * (int)lVar35;
        pbVar24 = (byte *)malloc((ulong)uVar6);
        iVar8 = WavpackGetNumChannels(wpc);
        src = (float *)malloc(iVar8 * lVar35 * 4);
        local_348 = (double)WavpackGetNumSamples64(wpc);
        if (quantize_bits == 0) {
          local_2bc = 0;
          local_320 = 1.0;
          local_328 = (uchar *)0x3ff0000000000000;
          uVar32 = 0;
        }
        else {
          iVar8 = WavpackGetBytesPerSample(wpc);
          if (quantize_bits < iVar8 * 8) {
            cVar5 = WavpackGetBytesPerSample(wpc);
            iVar8 = 1 << (cVar5 * '\b' - (char)quantize_bits & 0x1fU);
            uVar32 = -iVar8;
            uVar17 = WavpackGetMode(wpc);
            if ((uVar17 & 8) == 0) {
              local_2bc = (int)uVar32 >> 1 ^ uVar32;
              local_320 = 1.0;
              local_328 = (uchar *)0x3ff0000000000000;
              bVar42 = bVar42 && iVar8 == 0;
            }
            else {
              iVar10 = WavpackGetFloatNormExp(wpc);
              iVar36 = quantize_bits;
              local_328 = (uchar *)exp2((double)((quantize_bits + 0x7e) - iVar10));
              local_320 = exp2((double)((iVar10 + -0x7e) - iVar36));
              local_2bc = (int)uVar32 >> 1 ^ uVar32;
              bVar42 = bVar42 && iVar8 == 0;
            }
          }
          else {
            uVar32 = 0;
            local_320 = 1.0;
            local_328 = (uchar *)0x3ff0000000000000;
          }
        }
        local_2c8 = -1.0;
        dVar46 = local_2c8;
LAB_0010ba40:
        local_2c8 = dVar46;
        time2.tv_sec._0_4_ = 0;
        uVar11 = uVar6;
        if (((long)local_348 <= lVar35) && (((uint)local_370 >> 0xb & 1) == 0)) {
          uVar11 = uVar7 * SUB84(local_348,0);
        }
        uVar17 = (ulong)uVar11;
        local_348 = (double)((long)local_348 - uVar17 / uVar7);
        DoReadFile((FILE *)local_368,pbVar24,uVar11,(uint32_t *)&time2);
        uVar39 = (undefined4)(uVar17 >> 0x20);
        uVar17 = (ulong)(uint)time2.tv_sec / (ulong)uVar7;
        iVar8 = (int)uVar17;
        if (local_358 == (byte *)0x0) {
joined_r0x0010c18d:
          if (bVar42) {
            MD5_Update((MD5_CTX *)&md5_context,pbVar24,(long)(int)(uVar7 * iVar8));
          }
        }
        else {
          if ((local_370 & 8) == 0) {
            iVar36 = WavpackGetBytesPerSample(wpc);
            iVar10 = WavpackGetNumChannels(wpc);
            uVar39 = 0;
            reorder_channels(pbVar24,local_358,iVar10,iVar8,iVar36);
            goto joined_r0x0010c18d;
          }
          if (bVar42) {
            MD5_Update((MD5_CTX *)&md5_context,pbVar24,(long)(int)(uVar7 * iVar8));
          }
          iVar36 = WavpackGetBytesPerSample(wpc);
          iVar10 = WavpackGetNumChannels(wpc);
          uVar39 = 0;
          reorder_channels(pbVar24,local_358,iVar10,iVar8,iVar36);
        }
        if (iVar8 == 0) {
          free(src);
          free(pbVar24);
          iVar8 = WavpackFlushSamples(wpc);
          if (iVar8 != 0) goto joined_r0x0010d038;
          goto LAB_0010d9bd;
        }
        iVar36 = WavpackGetBytesPerSample(wpc);
        iVar10 = WavpackGetNumChannels(wpc);
        iVar10 = iVar10 * iVar8;
        if ((local_370 & 1) == 0) {
          if ((local_370 & 4) == 0) {
            if (iVar36 == 1) {
              if ((local_370 & 2) == 0) {
LAB_0010c9d0:
                uVar41 = 0;
                if (iVar10 != 0) {
                  do {
                    src[uVar41] = (float)(pbVar24[uVar41] - 0x80);
                    bVar43 = iVar10 - 1 != uVar41;
                    uVar41 = uVar41 + 1;
                  } while (bVar43);
                }
              }
              else {
                uVar41 = 0;
                if (iVar10 != 0) {
                  do {
                    src[uVar41] = (float)(int)(char)pbVar24[uVar41];
                    bVar43 = iVar10 - 1 != uVar41;
                    uVar41 = uVar41 + 1;
                  } while (bVar43);
                }
              }
            }
            else if (iVar36 == 3) {
              if (iVar10 != 0) {
                pfVar23 = src;
                pbVar31 = pbVar24;
                do {
                  iVar3 = *(int3 *)pbVar31;
                  pfVar25 = pfVar23 + 1;
                  pbVar31 = pbVar31 + 3;
                  *pfVar23 = (float)(int)iVar3;
                  pfVar23 = pfVar25;
                } while (pfVar25 != src + (ulong)(iVar10 - 1) + 1);
              }
            }
            else if (iVar36 < 4) {
              if (iVar36 == 2) {
                uVar41 = 0;
                if (iVar10 != 0) {
                  do {
                    src[uVar41] = (float)(int)CONCAT11(pbVar24[uVar41 * 2 + 1],pbVar24[uVar41 * 2]);
                    bVar43 = iVar10 - 1 != uVar41;
                    uVar41 = uVar41 + 1;
                  } while (bVar43);
                }
              }
            }
            else if (iVar36 == 4) {
              uVar41 = 0;
              if (iVar10 != 0) {
                do {
                  src[uVar41] = *(float *)(pbVar24 + uVar41 * 4);
                  bVar43 = iVar10 - 1 != uVar41;
                  uVar41 = uVar41 + 1;
                } while (bVar43);
              }
            }
          }
          else if (iVar36 == 3) {
            if (iVar10 != 0) {
              pfVar23 = src;
              pbVar31 = pbVar24;
              do {
                pfVar25 = pfVar23 + 1;
                *pfVar23 = (float)(((uint)pbVar31[1] << 8 | (uint)pbVar31[2] << 0x10 |
                                   (uint)*pbVar31) - 0x800000);
                pfVar23 = pfVar25;
                pbVar31 = pbVar31 + 3;
              } while (pfVar25 != src + (ulong)(iVar10 - 1) + 1);
            }
          }
          else if (iVar36 < 4) {
            if (iVar36 == 1) goto LAB_0010c9d0;
            if (iVar36 == 2) {
              uVar41 = 0;
              if (iVar10 != 0) {
                do {
                  src[uVar41] = (float)(*(ushort *)(pbVar24 + uVar41 * 2) - 0x8000);
                  bVar43 = iVar10 - 1 != uVar41;
                  uVar41 = uVar41 + 1;
                } while (bVar43);
              }
            }
          }
          else if (iVar36 == 4) {
            uVar41 = 0;
            if (iVar10 != 0) {
              do {
                src[uVar41] = (float)(*(int *)(pbVar24 + uVar41 * 4) + -0x80000000);
                bVar43 = iVar10 - 1 != uVar41;
                uVar41 = uVar41 + 1;
              } while (bVar43);
            }
          }
        }
        else if ((local_370 & 4) == 0) {
          if (iVar36 == 1) {
            if ((local_370 & 2) == 0) {
LAB_0010c9a0:
              uVar41 = 0;
              if (iVar10 != 0) {
                do {
                  src[uVar41] = (float)(pbVar24[uVar41] - 0x80);
                  bVar43 = uVar41 != iVar10 - 1;
                  uVar41 = uVar41 + 1;
                } while (bVar43);
              }
            }
            else {
              uVar41 = 0;
              if (iVar10 != 0) {
                do {
                  src[uVar41] = (float)(int)(char)pbVar24[uVar41];
                  bVar43 = iVar10 - 1 != uVar41;
                  uVar41 = uVar41 + 1;
                } while (bVar43);
              }
            }
          }
          else if (iVar36 == 3) {
            if (iVar10 != 0) {
              pbVar31 = pbVar24;
              pfVar23 = src;
              do {
                puVar1 = (ushort *)(pbVar31 + 1);
                bVar4 = *pbVar31;
                pbVar31 = pbVar31 + 3;
                *pfVar23 = (float)(int)CONCAT12(bVar4,*puVar1 << 8 | *puVar1 >> 8);
                pfVar23 = pfVar23 + 1;
              } while (pbVar31 != pbVar24 + (ulong)(iVar10 - 1) * 3 + 3);
            }
          }
          else if (iVar36 < 4) {
            if (iVar36 == 2) {
              uVar41 = 0;
              if (iVar10 != 0) {
                do {
                  src[uVar41] = (float)(int)CONCAT11(pbVar24[uVar41 * 2],pbVar24[uVar41 * 2 + 1]);
                  bVar43 = iVar10 - 1 != uVar41;
                  uVar41 = uVar41 + 1;
                } while (bVar43);
              }
            }
          }
          else if (iVar36 == 4) {
            uVar41 = 0;
            if (iVar10 != 0) {
              do {
                uVar11 = *(uint *)(pbVar24 + uVar41 * 4);
                src[uVar41] = (float)(uVar11 >> 0x18 | (uVar11 & 0xff0000) >> 8 |
                                      (uVar11 & 0xff00) << 8 | uVar11 << 0x18);
                bVar43 = iVar10 - 1 != uVar41;
                uVar41 = uVar41 + 1;
              } while (bVar43);
            }
          }
        }
        else if (iVar36 == 3) {
          if (iVar10 != 0) {
            pfVar23 = src;
            pbVar31 = pbVar24;
            do {
              pbVar30 = pbVar31 + 3;
              *pfVar23 = (float)(((uint)pbVar31[1] << 8 | (uint)*pbVar31 << 0x10 | (uint)pbVar31[2])
                                - 0x800000);
              pfVar23 = pfVar23 + 1;
              pbVar31 = pbVar30;
            } while (pbVar30 != pbVar24 + (ulong)(iVar10 - 1) * 3 + 3);
          }
        }
        else if (iVar36 < 4) {
          if (iVar36 == 1) goto LAB_0010c9a0;
          if (iVar36 == 2) {
            uVar41 = 0;
            if (iVar10 != 0) {
              do {
                src[uVar41] = (float)((ushort)(*(ushort *)(pbVar24 + uVar41 * 2) << 8 |
                                              *(ushort *)(pbVar24 + uVar41 * 2) >> 8) - 0x8000);
                bVar43 = iVar10 - 1 != uVar41;
                uVar41 = uVar41 + 1;
              } while (bVar43);
            }
          }
        }
        else if (iVar36 == 4) {
          uVar41 = 0;
          if (iVar10 != 0) {
            do {
              uVar11 = *(uint *)(pbVar24 + uVar41 * 4);
              src[uVar41] = (float)((uVar11 >> 0x18 | (uVar11 & 0xff0000) >> 8 |
                                     (uVar11 & 0xff00) << 8 | uVar11 << 0x18) + 0x80000000);
              bVar43 = uVar41 != iVar10 - 1;
              uVar41 = uVar41 + 1;
            } while (bVar43);
          }
        }
        if (uVar32 != 0) {
          iVar10 = WavpackGetNumChannels(wpc);
          uVar11 = iVar10 * iVar8;
          uVar41 = WavpackGetMode(wpc);
          if ((uVar41 & 8) == 0) {
            uVar39 = 0;
            if (quantize_round == 0) {
              if (uVar11 != 0) {
LAB_0010c639:
                uVar39 = 0;
                lVar22 = 0;
                do {
                  src[lVar22] = (float)((uint)src[lVar22] & uVar32);
                  lVar22 = lVar22 + 1;
                } while ((uint)lVar22 < uVar11);
              }
            }
            else {
              uVar39 = 0;
              cVar5 = WavpackGetBytesPerSample(wpc);
              if (uVar11 != 0) {
                pfVar23 = src;
                do {
                  fVar34 = (float)((int)*pfVar23 + local_2bc);
                  if (((int)*pfVar23 < 0) || (0 < (int)fVar34 << (('\x04' - cVar5) * '\b' & 0x1fU)))
                  {
                    *pfVar23 = fVar34;
                  }
                  pfVar23 = pfVar23 + 1;
                } while (src + (ulong)(uVar11 - 1) + 1 != pfVar23);
                goto LAB_0010c639;
              }
            }
          }
          else if (uVar11 != 0) {
            pfVar23 = src;
            do {
              dVar46 = (double)*pfVar23 * (double)local_328 + 0.5;
              if (ABS(dVar46) < 4503599627370496.0) {
                dVar46 = (double)((ulong)dVar46 & 0x8000000000000000 |
                                 (ulong)((double)(long)dVar46 -
                                        (double)(-(ulong)(dVar46 < (double)(long)dVar46) &
                                                0x3ff0000000000000)));
              }
              pfVar25 = pfVar23 + 1;
              *pfVar23 = (float)(dVar46 * local_320);
              pfVar23 = pfVar25;
            } while (pfVar25 != src + (ulong)(uVar11 - 1) + 1);
          }
          if (local_2d0 != (uchar *)0x0) {
            iVar10 = WavpackGetNumChannels(wpc);
            uVar39 = 0;
            store_samples(pbVar24,(int32_t *)src,(uint)local_370,iVar36,iVar10 * iVar8);
            iVar8 = WavpackGetBytesPerSample(wpc);
            MD5_Update((MD5_CTX *)&md5_context,pbVar24,(ulong)(iVar8 * uVar11));
          }
        }
        iVar8 = WavpackPackSamples(wpc,src,uVar17);
        if (iVar8 == 0) {
          WavpackGetErrorMessage(wpc);
          error_line("%s");
          free(src);
          free(pbVar24);
          iVar8 = 2;
          goto LAB_0010b848;
        }
        iVar8 = check_break();
        if (iVar8 == 0) {
          dVar45 = (double)WavpackGetProgress(wpc);
          dVar46 = local_2c8;
          if ((false) || (dVar45 != -1.0)) {
            dVar45 = (double)WavpackGetProgress(wpc);
            dVar45 = dVar45 * encode_time_percent + 0.5;
            if (ABS(dVar45) < 4503599627370496.0) {
              dVar45 = (double)((ulong)dVar45 & 0x8000000000000000 |
                               (ulong)((double)(long)dVar45 -
                                      (double)(-(ulong)(dVar45 < (double)(long)dVar45) &
                                              0x3ff0000000000000)));
            }
            if ((false) || (dVar45 != local_2c8)) {
              dVar46 = (double)WavpackGetProgress(wpc);
              dVar46 = encode_time_percent * dVar46 + 0.5;
              if (ABS(dVar46) < 4503599627370496.0) {
                dVar46 = (double)((ulong)dVar46 & 0x8000000000000000 |
                                 (ulong)((double)(long)dVar46 -
                                        (double)(-(ulong)(dVar46 < (double)(long)dVar46) &
                                                0x3ff0000000000000)));
              }
              if (set_console_title != 0) {
                display_progress(dVar46 / 100.0);
              }
              if (quiet_mode == 0) {
                if ((false) || (local_2c8 != -1.0)) {
                  puVar26 = &DAT_00115044;
                }
                else {
                  puVar26 = &DAT_00119241;
                }
                __fprintf_chk(stderr,1,"%s%3d%% done...",puVar26,CONCAT44(uVar39,(int)dVar46));
                fflush(stderr);
              }
            }
          }
          goto LAB_0010ba40;
        }
        fputc(10,stderr);
        fflush(stderr);
        free(src);
        free(pbVar24);
        iVar8 = 1;
      }
      else {
        local_328 = (uchar *)0x0;
        if ((loc_config._16_8_ & 0x800000000000000) != 0 || verify_mode != 0) {
          MD5_Init((MD5_CTX *)&md5_context);
          local_328 = md5_digest;
        }
        WavpackPackInit(wpc);
        uVar7 = WavpackGetNumChannels(wpc);
        uVar9 = uVar7 << 0xc;
        lpBuffer = malloc((long)(int)uVar9);
        puVar14 = (uint *)malloc((long)(int)uVar7 << 0xe);
        uVar17 = WavpackGetNumSamples64(wpc);
        if (uVar17 != 0) {
          local_308 = -1.0;
          do {
            time2.tv_sec._0_4_ = 0;
            if (((long)uVar17 < 0x1001) && ((local_370 & 0x40) == 0)) {
              DoReadFile((FILE *)local_368,lpBuffer,uVar7 * (int)uVar17,(uint32_t *)&time2);
LAB_0010bfd0:
              uVar41 = (ulong)(int)((uint)time2.tv_sec / uVar7);
              uVar17 = uVar17 - uVar41;
            }
            else {
              DoReadFile((FILE *)local_368,lpBuffer,uVar9,(uint32_t *)&time2);
              if ((local_370 & 0x40) == 0) goto LAB_0010bfd0;
              if (uVar9 == (uint)time2.tv_sec) {
                if ((long)uVar17 < 0x1000) {
                  uVar41 = uVar17 & 0xffffffff;
                  uVar17 = uVar17 - (long)(int)uVar17;
                }
                else {
                  uVar17 = uVar17 - 0x1000;
                  uVar41 = 0x1000;
                }
              }
              else {
                uVar17 = 0;
                uVar41 = 0;
                error_line("incomplete DSD block!");
              }
            }
            iVar8 = (int)uVar41;
            if ((local_358 != (byte *)0x0) && ((local_370 & 8) == 0)) {
              if ((local_370 & 0x40) == 0) {
                reorder_channels(lpBuffer,local_358,uVar7,iVar8,1);
              }
              else {
                reorder_channels(lpBuffer,local_358,uVar7,1,0x1000);
              }
            }
            if (local_328 != (uchar *)0x0) {
              MD5_Update((MD5_CTX *)&md5_context,lpBuffer,(ulong)(uint)time2.tv_sec);
            }
            if (iVar8 == 0) break;
            if ((local_370 & 0x40) == 0) {
              if (uVar7 * iVar8 != 0) {
                uVar19 = 0;
                do {
                  puVar14[uVar19] = (uint)*(byte *)((long)lpBuffer + uVar19);
                  bVar42 = uVar19 != uVar7 * iVar8 - 1;
                  uVar19 = uVar19 + 1;
                } while (bVar42);
              }
            }
            else {
              lVar35 = 0;
              iVar36 = 0;
              puVar29 = puVar14;
              do {
                pbVar24 = (byte *)((long)lpBuffer + lVar35);
                if (uVar7 != 0) {
                  pbVar31 = (byte *)((long)lpBuffer + lVar35 + (ulong)(uVar7 - 1) * 0x1000 + 0x1000)
                  ;
                  do {
                    while( true ) {
                      uVar6 = (uint)*pbVar24;
                      if ((int)lVar35 < iVar8) break;
                      iVar36 = (iVar36 + 1) - (uint)(*pbVar24 == 0);
                      pbVar24 = pbVar24 + 0x1000;
                      if (pbVar24 == pbVar31) goto LAB_0010b7ae;
                    }
                    if ((local_370 & 0x10) != 0) {
                      uVar6 = (uint)""[(int)uVar6];
                    }
                    pbVar24 = pbVar24 + 0x1000;
                    *puVar29 = uVar6;
                    puVar29 = puVar29 + 1;
                  } while (pbVar24 != pbVar31);
                }
LAB_0010b7ae:
                lVar35 = lVar35 + 1;
              } while (lVar35 != 0x1000);
              if (iVar36 != 0) {
                error_line("blocks not padded with NULLs, MD5 will not match!");
              }
            }
            iVar8 = WavpackPackSamples(wpc,puVar14,uVar41 & 0xffffffff);
            if (iVar8 == 0) {
              WavpackGetErrorMessage(wpc);
              error_line("%s");
              free(puVar14);
              free(lpBuffer);
              iVar8 = 2;
              goto LAB_0010b848;
            }
            iVar8 = check_break();
            if (iVar8 != 0) {
              fputc(10,stderr);
              fflush(stderr);
              free(puVar14);
              free(lpBuffer);
              iVar8 = 1;
              goto LAB_0010b848;
            }
            dVar45 = (double)WavpackGetProgress(wpc);
            dVar46 = local_308;
            if ((false) || (dVar45 != -1.0)) {
              dVar45 = (double)WavpackGetProgress(wpc);
              dVar45 = dVar45 * encode_time_percent + 0.5;
              if (ABS(dVar45) < 4503599627370496.0) {
                dVar45 = (double)((ulong)dVar45 & 0x8000000000000000 |
                                 (ulong)((double)(long)dVar45 -
                                        (double)(-(ulong)(dVar45 < (double)(long)dVar45) &
                                                0x3ff0000000000000)));
              }
              if ((false) || (dVar45 != local_308)) {
                dVar46 = (double)WavpackGetProgress(wpc);
                dVar46 = encode_time_percent * dVar46 + 0.5;
                if (ABS(dVar46) < 4503599627370496.0) {
                  dVar46 = (double)((ulong)dVar46 & 0x8000000000000000 |
                                   (ulong)((double)(long)dVar46 -
                                          (double)(-(ulong)(dVar46 < (double)(long)dVar46) &
                                                  0x3ff0000000000000)));
                }
                if (set_console_title != 0) {
                  display_progress(dVar46 / 100.0);
                }
                if (quiet_mode == 0) {
                  if ((false) || (local_308 != -1.0)) {
                    puVar26 = &DAT_00115044;
                  }
                  else {
                    puVar26 = &DAT_00119241;
                  }
                  __fprintf_chk(stderr,1,"%s%3d%% done...",puVar26,(int)dVar46);
                  fflush(stderr);
                }
              }
            }
            local_308 = dVar46;
          } while (uVar17 != 0);
        }
        free(puVar14);
        free(lpBuffer);
        iVar8 = WavpackFlushSamples(wpc);
        local_2d0 = local_328;
        if (iVar8 == 0) {
LAB_0010d9bd:
          WavpackGetErrorMessage(wpc);
          error_line("%s");
          iVar8 = 2;
        }
        else {
joined_r0x0010d038:
          iVar8 = 0;
          if (local_2d0 != (uchar *)0x0) {
            iVar8 = 0;
            MD5_Final(local_2d0,(MD5_CTX *)&md5_context);
          }
        }
      }
LAB_0010b848:
      if (local_358 != (byte *)0x0) {
        free(local_358);
      }
      if (iVar8 != 0) {
        DoCloseHandle((FILE *)local_368);
        local_358 = (byte *)0x0;
        goto LAB_0010c682;
      }
      if ((loc_config._16_8_ & 0x800000000000000) != 0) {
        WavpackStoreMD5Sum(wpc);
      }
      local_358 = (byte *)(loc_config._16_8_ & 0x1800);
      if ((loc_config._16_8_ & 0x1800) == 0) {
        if (local_2c0 != 1) {
          lVar35 = WavpackGetNumSamples64(wpc);
          iVar8 = WavpackGetNumChannels(wpc);
          iVar36 = WavpackGetBytesPerSample(wpc);
          lVar35 = ((long)iVar36 * lVar35 * iVar8) % (long)local_2c0;
          if ((lVar35 != 0) &&
             (local_2c0 = local_2c0 - (int)lVar35, iVar8 = local_2c0 + -1, local_2c0 != 0)) {
            do {
              iVar36 = DoReadFile((FILE *)local_368,&time2,1,&bcount);
              if ((iVar36 == 0) || (bcount != 1)) {
                error_line("warning: input file missing required padding byte!");
              }
              else if ((char)time2.tv_sec != '\0') {
                error_line("warning: input file has non-zero padding byte!");
              }
              iVar8 = iVar8 + -1;
            } while (iVar8 != -1);
          }
        }
        iVar36 = 0;
        iVar8 = 0x10000;
        puVar18 = (uchar *)malloc(0x10000);
        while ((iVar10 = DoReadFile((FILE *)local_368,puVar18 + iVar36,iVar8 - iVar36,&bcount),
               iVar10 != 0 && (bcount != 0))) {
          iVar36 = iVar36 + bcount;
          if (iVar8 == iVar36) {
            iVar8 = iVar8 + 0x10000;
            puVar18 = (uchar *)realloc(puVar18,(long)iVar8);
          }
        }
        if (iVar36 == 0) {
LAB_0010cce8:
          free(puVar18);
          DoCloseHandle((FILE *)local_368);
          goto LAB_0010caaa;
        }
        if (((loc_config._16_8_ & 0x200) == 0) &&
           (iVar8 = WavpackAddWrapper(wpc,puVar18,iVar36), iVar8 == 0)) {
          uVar21 = WavpackGetErrorMessage(wpc);
          error_line("%s",uVar21);
          free(puVar18);
          DoCloseHandle((FILE *)local_368);
          local_358 = (byte *)0x0;
          iVar8 = 2;
          goto LAB_0010c682;
        }
        if ((import_id3 == 0) || (iVar36 < 0xb)) goto LAB_0010cce8;
        uVar7 = ImportID3v2((WavpackContext *)0x0,puVar18,iVar36,fourcc,(int32_t *)&time2);
        if (allow_huge_tags != 0) {
          if ((int)(uint)time2.tv_sec < 0x1000001) goto LAB_0010cc88;
          error_line("imported tag items exceed 16 MB");
LAB_0010dcdd:
          free(puVar18);
          DoCloseHandle((FILE *)local_368);
          iVar8 = 1;
          goto LAB_0010c682;
        }
        if (0x100000 < (int)(uint)time2.tv_sec) {
          error_line("imported tag items exceed 1 MB, use --allow-huge-tags to override");
          free(puVar18);
          DoCloseHandle((FILE *)local_368);
          local_358 = (byte *)0x0;
          iVar8 = 1;
          goto LAB_0010c682;
        }
LAB_0010cc88:
        if (0 < (int)uVar7) {
          uVar7 = ImportID3v2(wpc,puVar18,iVar36,fourcc,(int32_t *)0x0);
        }
        if ((int)uVar7 < 0) {
          error_line("ID3v2 import: %s",fourcc);
          goto LAB_0010dcdd;
        }
        if (uVar7 == 0) {
          free(puVar18);
          goto LAB_0010caa0;
        }
        free(puVar18);
        DoCloseHandle((FILE *)local_368);
        iVar8 = WavpackFlushSamples(wpc);
        if (iVar8 != 0) goto LAB_0010cad0;
LAB_0010d69e:
        local_358 = (byte *)(ulong)uVar7;
        uVar21 = WavpackGetErrorMessage(wpc);
        error_line("%s",uVar21);
        iVar8 = 2;
LAB_0010c682:
        iVar36 = DoCloseHandle(wv_file.file);
        if (iVar36 == 0) {
          error_line("can\'t close WavPack file!");
        }
LAB_0010c697:
        if (out2filename == (char *)0x0) {
LAB_0010c6b4:
          if (iVar8 == 0) {
LAB_0010c6c0:
            if (verify_mode == 0) {
              if (local_2e0 != 0) {
LAB_0010ceb7:
                iVar8 = rename((char *)local_2f0,outfilename);
                if (iVar8 != 0) {
                  iVar8 = 1;
                  error_line("can not rename temp file %s to %s!",local_2f0,outfilename);
                }
                if (out2filename == (char *)0x0) {
                  free(local_2f0);
                }
                else {
                  iVar36 = rename(local_2f8,out2filename);
                  if (iVar36 != 0) {
                    error_line("can not rename temp file %s to %s!",local_2f8,out2filename);
                    free(local_2f0);
                    free(local_2f8);
                    goto LAB_0010b4f8;
                  }
                  free(local_2f0);
                  free(local_2f8);
                }
                if (iVar8 != 0) goto LAB_0010b4f8;
              }
            }
            else {
              iVar8 = WavpackLossyBlocks(wpc);
              puVar18 = (uchar *)0x0;
              if (iVar8 == 0) {
                puVar18 = md5_digest;
              }
              if (local_2e0 != 0) {
                local_2e0 = verify_audio((char *)local_2f0,puVar18);
                if (local_2e0 != 0) goto LAB_0010d2d6;
                goto LAB_0010ceb7;
              }
              iVar8 = verify_audio(outfilename,puVar18);
              if (iVar8 != 0) goto LAB_0010d4c6;
            }
            if ((copy_time != 0) &&
               ((iVar8 = copy_timestamp(infilename,outfilename), iVar8 == 0 ||
                ((out2filename != (char *)0x0 &&
                 (iVar8 = copy_timestamp(infilename,out2filename), iVar8 == 0)))))) {
              error_line("failure copying time stamp!");
            }
            pcVar15 = (char *)0x0;
            if (delete_source != 0) {
              iVar8 = DoDeleteFile(infilename);
              if (quiet_mode == 0) {
                pcVar20 = "can\'t delete";
                if (iVar8 != 0) {
                  pcVar20 = "deleted";
                }
              }
              else {
                if (iVar8 != 0) goto LAB_0010c6ff;
                pcVar20 = "can\'t delete";
              }
              error_line("%s source file %s",pcVar20,infilename);
            }
LAB_0010c6ff:
            gettimeofday((timeval *)&time2,local_2d8);
            lVar35 = CONCAT44(time2.tv_sec._4_4_,(uint)time2.tv_sec);
            if (((loc_config._16_8_ & 0x80000000000000) != 0) &&
               (dVar46 = (double)WavpackGetEncodedNoise(wpc,0), 0.0 < dVar46)) {
              iVar8 = WavpackGetBitsPerSample(wpc);
              iVar36 = iVar8 + -1;
              if (iVar8 == 0) {
                local_348 = -0.125;
              }
              else {
                dVar46 = 0.5;
                do {
                  iVar36 = iVar36 + -1;
                  dVar46 = dVar46 + dVar46;
                } while (iVar36 != -1);
                local_348 = dVar46 * (dVar46 - 1.0) * 0.5;
              }
              dVar46 = (double)WavpackGetEncodedNoise(wpc,&peak);
              dVar45 = log10(peak / local_348);
              lVar22 = WavpackGetNumSamples64(wpc);
              dVar46 = log10((dVar46 / (double)lVar22) / local_348);
              error_line("ave noise = %.2f dB, peak noise = %.2f dB",dVar46 * 10.0,dVar45 * 10.0);
            }
            if (quiet_mode == 0) {
              cratio[0] = '\0';
              cratio[1] = '\0';
              cratio[2] = '\0';
              cratio[3] = '\0';
              cratio[4] = '\0';
              cratio[5] = '\0';
              cratio[6] = '\0';
              cratio[7] = '\0';
              cratio[8] = '\0';
              cratio[9] = '\0';
              cratio[10] = '\0';
              cratio[0xb] = '\0';
              cratio[0xc] = '\0';
              cratio[0xd] = '\0';
              cratio[0xe] = '\0';
              cratio[0xf] = '\0';
              if ((int)local_358 != 0) {
                error_line("successfully imported %d items from ID3v2 tag",local_358);
              }
              if ((loc_config._16_8_ & 0x800000000000000) != 0) {
                local_110[0] = '\0';
                pbVar24 = md5_digest;
                local_118 = 0x3030303030303030;
                builtin_strncpy(fourcc,"orig",4);
                cStack_144 = 'i';
                cStack_143 = 'n';
                cStack_142 = 'a';
                cStack_141 = 'l';
                builtin_strncpy(acStack_130,"000000000000000000000000",0x18);
                pcVar20 = acStack_130;
                do {
                  pcVar15 = (char *)(ulong)*pbVar24;
                  pcVar33 = pcVar20 + 2;
                  pbVar24 = pbVar24 + 1;
                  __sprintf_chk(pcVar20,1,0xffffffffffffffff,&DAT_00115061,pcVar15);
                  pcVar20 = pcVar33;
                } while (local_110 != pcVar33);
                error_line(fourcc);
              }
              puVar14 = (uint *)outfilename;
              if (*outfilename == '-') {
                pcVar33 = "packed";
                local_360 = "stdin";
                pcVar20 = "";
                if ((*infilename != '-') &&
                   (sVar13 = strlen(infilename), local_360 = infilename, 0x1e < sVar13)) {
                  local_360 = filespec_name(infilename);
                }
              }
              else {
                do {
                  puVar29 = puVar14;
                  uVar6 = *puVar29 + 0xfefefeff & ~*puVar29;
                  uVar7 = uVar6 & 0x80808080;
                  puVar14 = puVar29 + 1;
                } while (uVar7 == 0);
                bVar42 = (uVar6 & 0x8080) == 0;
                if (bVar42) {
                  uVar7 = uVar7 >> 0x10;
                }
                if (bVar42) {
                  puVar14 = (uint *)((long)puVar29 + 6);
                }
                local_360 = outfilename;
                if (0x1e < (long)puVar14 +
                           ((-3 - (ulong)CARRY1((byte)uVar7,(byte)uVar7)) - (long)outfilename)) {
                  local_360 = filespec_name(outfilename);
                }
                pcVar20 = "";
                pcVar33 = "created (and verified)";
                if (wvc_file.bytes_written != 0) {
                  pcVar20 = " (+.wvc)";
                }
                if (verify_mode == 0) {
                  pcVar33 = "created";
                }
              }
              iVar8 = WavpackLossyBlocks(wpc);
              if (iVar8 == 0) {
                dVar46 = (double)WavpackGetRatio(wpc);
                if ((false) || (pcVar15 = "lossless", dVar46 != 0.0)) {
                  dVar46 = (double)WavpackGetRatio(wpc);
                  __sprintf_chk(100.0 - dVar46 * 100.0,cratio,1,0x10,", %.2f%%");
                  pcVar15 = "lossless";
                }
              }
              else {
                dVar46 = (double)WavpackGetAverageBitrate(wpc,1);
                if ((false) || (pcVar15 = "lossy", dVar46 != 0.0)) {
                  uVar39 = (undefined4)((ulong)pcVar15 >> 0x20);
                  dVar46 = (double)WavpackGetAverageBitrate(wpc,1);
                  __sprintf_chk(cratio,1,0x10,", %d kbps",CONCAT44(uVar39,(int)(dVar46 / 1000.0)));
                  pcVar15 = "lossy";
                }
              }
              error_line("%s %s%s in %.2f secs (%s%s)",
                         ((double)time2.tv_usec / 1000000.0 + (double)lVar35) -
                         ((double)time1.tv_usec / 1000000.0 + (double)time1.tv_sec),pcVar33,
                         local_360,pcVar20,pcVar15,cratio);
            }
            WavpackCloseFile(wpc);
            local_370._0_4_ = 0;
            goto LAB_0010b508;
          }
          bVar42 = local_2e0 == 0;
          local_2e0 = iVar8;
          if (bVar42) {
LAB_0010d4c6:
            DoDeleteFile(outfilename);
            local_2f8 = out2filename;
            local_370._0_4_ = iVar8;
          }
          else {
LAB_0010d2d6:
            DoDeleteFile((char *)local_2f0);
            local_370._0_4_ = local_2e0;
          }
          if (out2filename == (char *)0x0) goto LAB_0010d26b;
        }
        else {
          iVar36 = DoCloseHandle(wvc_file.file);
          if (iVar36 != 0) goto LAB_0010c6b4;
          error_line("can\'t close correction file!");
          local_370._0_4_ = 1;
          if (iVar8 != 0) {
            local_370._0_4_ = iVar8;
          }
LAB_0010d238:
          bVar42 = local_2e0 != 0;
          local_2e0 = (uint)local_370;
          if (bVar42) goto LAB_0010d2d6;
LAB_0010d247:
          DoDeleteFile(outfilename);
          local_2f8 = out2filename;
        }
LAB_0010d25e:
        DoDeleteFile(local_2f8);
      }
      else {
LAB_0010caa0:
        DoCloseHandle((FILE *)local_368);
LAB_0010caaa:
        uVar7 = WavpackFlushSamples(wpc);
        if (uVar7 == 0) goto LAB_0010d69e;
        uVar7 = 0;
        uVar6 = num_tag_items;
        if (num_tag_items != 0) {
LAB_0010cad0:
          lVar35 = 0;
          iVar8 = 1;
          if (num_tag_items < 1) {
LAB_0010cb85:
            iVar8 = WavpackWriteTag(wpc);
            uVar6 = uVar7;
            if (iVar8 != 0) goto LAB_0010cb99;
          }
          else {
            do {
              while( true ) {
                ptVar27 = tag_items + lVar35;
                if (ptVar27->vsize != 0) break;
                if (num_tag_items <= (int)lVar35 + 1) {
LAB_0010cb81:
                  if (iVar8 != 0) goto LAB_0010cb85;
                  goto LAB_0010cb2b;
                }
                lVar35 = lVar35 + 1;
              }
              if (ptVar27->binary == 0) {
                iVar8 = WavpackAppendTagItem(wpc,ptVar27->item,ptVar27->value,ptVar27->vsize);
              }
              else {
                iVar8 = WavpackAppendBinaryTagItem();
              }
              if (num_tag_items <= (int)lVar35 + 1) goto LAB_0010cb81;
              lVar35 = lVar35 + 1;
            } while (iVar8 != 0);
          }
LAB_0010cb2b:
          uVar21 = WavpackGetErrorMessage(wpc);
          error_line("%s",uVar21);
          iVar8 = 2;
          local_358 = (byte *)(ulong)uVar7;
          goto LAB_0010c682;
        }
LAB_0010cb99:
        local_358 = (byte *)(ulong)uVar6;
        lVar35 = WavpackGetNumSamples64(wpc);
        lVar22 = WavpackGetSampleIndex64(wpc);
        local_370._0_4_ = local_2e0;
        if (lVar35 != lVar22) {
          if ((loc_config._16_8_ & 0x800) == 0) {
            error_line("couldn\'t read all samples, file may be corrupt!!");
            iVar8 = 1;
            goto LAB_0010c682;
          }
          pbVar24 = (byte *)malloc((ulong)wv_file.first_block_size);
          if (pbVar24 == (byte *)0x0) {
            error_line("couldn\'t update WavPack header with actual length!!");
            iVar8 = 1;
            goto LAB_0010c682;
          }
          iVar8 = DoSetFilePositionAbsolute(wv_file.file,0);
          if (iVar8 != 0) {
LAB_0010cbf2:
            error_line("couldn\'t update WavPack header with actual length!!");
            free(pbVar24);
            iVar8 = 1;
            goto LAB_0010c682;
          }
          iVar8 = DoReadFile(wv_file.file,pbVar24,wv_file.first_block_size,&bcount);
          if (iVar8 == 0) goto LAB_0010cbf2;
          bVar42 = wv_file.first_block_size < bcount;
          bVar43 = wv_file.first_block_size == bcount;
          if (!bVar43) goto LAB_0010cbf2;
          lVar35 = 4;
          pbVar31 = pbVar24;
          pbVar30 = &DAT_00115210;
          do {
            if (lVar35 == 0) break;
            lVar35 = lVar35 + -1;
            bVar42 = *pbVar31 < *pbVar30;
            bVar43 = *pbVar31 == *pbVar30;
            pbVar31 = pbVar31 + (ulong)bVar44 * -2 + 1;
            pbVar30 = pbVar30 + (ulong)bVar44 * -2 + 1;
          } while (bVar43);
          if ((!bVar42 && !bVar43) != bVar42) goto LAB_0010cbf2;
          WavpackUpdateNumSamples(wpc);
          iVar8 = DoSetFilePositionAbsolute(wv_file.file,0);
          if (iVar8 != 0) goto LAB_0010cbf2;
          iVar8 = DoWriteFile(wv_file.file,pbVar24,wv_file.first_block_size,&bcount);
          if ((iVar8 == 0) || (wv_file.first_block_size != bcount)) goto LAB_0010cbf2;
          free(pbVar24);
          hFile = wvc_file.file;
          if (wvc_file.file == (FILE *)0x0) goto LAB_0010d278;
          pcVar15 = (char *)malloc((ulong)wvc_file.first_block_size);
          if (pcVar15 == (char *)0x0) {
            error_line("couldn\'t update WavPack header with actual length!!");
            iVar8 = 1;
          }
          else {
            iVar8 = DoSetFilePositionAbsolute(hFile,0);
            if (iVar8 == 0) {
              iVar8 = DoReadFile(wvc_file.file,pcVar15,wvc_file.first_block_size,&bcount);
              if (((iVar8 == 0) || (wvc_file.first_block_size != bcount)) ||
                 (iVar8 = strncmp(pcVar15,"wvpk",4), iVar8 != 0)) goto LAB_0010dc0b;
              WavpackUpdateNumSamples(wpc);
              iVar8 = DoSetFilePositionAbsolute(wvc_file.file,0);
              if (iVar8 != 0) goto LAB_0010dc0b;
              iVar8 = DoWriteFile(wvc_file.file,pcVar15,wvc_file.first_block_size,&bcount);
              if ((iVar8 == 0) || (wvc_file.first_block_size != bcount)) goto LAB_0010dc0b;
              iVar8 = 0;
            }
            else {
LAB_0010dc0b:
              error_line("couldn\'t update WavPack header with actual length!!");
              iVar8 = 1;
            }
            free(pcVar15);
          }
          iVar36 = DoCloseHandle(wv_file.file);
          if (iVar36 == 0) goto LAB_0010d28d;
          goto LAB_0010c697;
        }
LAB_0010d278:
        iVar8 = DoCloseHandle(wv_file.file);
        if (iVar8 != 0) {
          if (out2filename != (char *)0x0) {
            iVar8 = DoCloseHandle(wvc_file.file);
            if (iVar8 != 0) goto LAB_0010c6c0;
            error_line("can\'t close correction file!");
            if (local_2e0 != 0) {
              DoDeleteFile((char *)local_2f0);
              goto LAB_0010d25e;
            }
            local_370._0_4_ = 1;
            goto LAB_0010d247;
          }
          goto LAB_0010c6c0;
        }
LAB_0010d28d:
        error_line("can\'t close WavPack file!");
        if (out2filename != (char *)0x0) {
          iVar8 = DoCloseHandle(wvc_file.file);
          if (iVar8 == 0) {
            error_line("can\'t close correction file!");
            local_370._0_4_ = 1;
            goto LAB_0010d238;
          }
          if (local_2e0 != 0) goto LAB_0010d2d6;
          DoDeleteFile(outfilename);
          local_370._0_4_ = 1;
          local_2f8 = out2filename;
          goto LAB_0010d25e;
        }
        if (local_2e0 == 0) {
          DoDeleteFile(outfilename);
          local_370._0_4_ = 1;
        }
        else {
          DoDeleteFile((char *)local_2f0);
        }
      }
LAB_0010d26b:
      WavpackCloseFile(wpc);
      goto LAB_0010b508;
    }
LAB_0010b2d0:
    iVar8 = DoReadFile((FILE *)local_368,fourcc,4,&bcount);
    if ((iVar8 == 0) || (bcount != 4)) {
      pcVar15 = "can\'t read file %s!";
LAB_0010bef4:
      error_line(pcVar15,infilename);
    }
    else {
      pcVar15 = "RIFF";
      iVar8 = 0;
      paVar40 = file_formats;
      while (iVar36 = strncmp(fourcc,pcVar15,4), iVar36 != 0) {
        iVar8 = iVar8 + 1;
        if (iVar8 == 6) {
          pcVar15 = "%s is not a recognized file type!";
          goto LAB_0010bef4;
        }
        pcVar15 = paVar40[1].fourcc;
        paVar40 = paVar40 + 1;
      }
      uVar2 = file_formats[iVar8].id;
      pcVar15 = filespec_ext(infilename);
      if (pcVar15 == (char *)0x0) {
        pcVar15 = file_formats[iVar8].default_extension;
      }
      else {
        pcVar15 = filespec_ext(infilename);
        pcVar15 = pcVar15 + 1;
      }
      WavpackSetFileInformation(wpc,pcVar15,uVar2);
      iVar36 = (*file_formats[iVar8].ParseHeader)
                         ((FILE *)local_368,infilename,fourcc,wpc,&loc_config);
      if (iVar36 == 0) {
        local_2c0 = file_formats[iVar8].chunk_alignment;
        uVar7 = loc_config.qmode;
        goto LAB_0010b46b;
      }
    }
LAB_0010b4c2:
    DoCloseHandle((FILE *)local_368);
    DoCloseHandle(wv_file.file);
    if (local_2e0 == 0) {
      local_2f0 = (uint *)outfilename;
    }
    DoDeleteFile((char *)local_2f0);
  }
  else {
    iVar16 = DoGetFileSize((FILE *)local_368);
    if (iVar16 == 0) {
      if (raw_pcm_skip_bytes_end != 0) {
        pcVar15 = "can\'t skip trailer in raw PCM read from stdin!";
        goto LAB_0010d316;
      }
      uVar7 = loc_config.qmode;
      lVar22 = -1;
      loc_config._16_8_ = loc_config._16_8_ | 0x800;
LAB_0010b3e3:
      if ((uVar7 & 0x400) == 0 && loc_config.channel_mask == 0) {
        if (loc_config.num_channels < 3) {
          loc_config.channel_mask = 5 - loc_config.num_channels;
        }
        else if (loc_config.num_channels < 0x13) {
          loc_config.channel_mask = (1 << (SUB81(loc_config._24_8_,4) & 0x1f)) + -1;
        }
        else {
          loc_config.channel_mask = 0x3ffff;
        }
      }
      iVar8 = WavpackSetConfiguration64(wpc,&loc_config,lVar22,0);
      if (iVar8 != 0) goto LAB_0010ad40;
      uVar21 = WavpackGetErrorMessage(wpc);
      error_line("%s",uVar21);
    }
    else {
      pcVar15 = "no raw PCM data to encode!";
      lVar35 = iVar16 - (raw_pcm_skip_bytes_end + raw_pcm_skip_bytes_begin);
      lVar22 = lVar35 / (long)(loc_config.bytes_per_sample * loc_config.num_channels);
      uVar17 = lVar35 % (long)(loc_config.bytes_per_sample * loc_config.num_channels);
      if (0 < lVar22) {
        if (uVar17 != 0) {
          error_line("warning: raw PCM infile length does not divide evenly, %d bytes will be discarded"
                     ,uVar17 & 0xffffffff);
        }
        uVar7 = loc_config.qmode;
        goto LAB_0010b3e3;
      }
LAB_0010d316:
      error_line(pcVar15);
    }
LAB_0010bfa5:
    DoCloseHandle((FILE *)local_368);
  }
LAB_0010b4f8:
  WavpackCloseFile(wpc);
  local_370._0_4_ = 1;
LAB_0010b508:
  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (uint)local_370;
}



FILE * wild_fopen(char *filename,char *mode)

{
  long lVar1;
  char *__s;
  int iVar2;
  size_t sVar3;
  char *__filename;
  FILE *pFVar4;
  ulong uVar5;
  long in_FS_OFFSET;
  glob_t globbuf;
  stat statbuf;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  glob(filename,0,(__errfunc *)0x0,(glob_t *)&globbuf);
  if (globbuf.gl_pathc == 0) {
    pFVar4 = (FILE *)0x0;
    globfree((glob_t *)&globbuf);
  }
  else {
    uVar5 = 0;
    __filename = (char *)0x0;
    do {
      iVar2 = __xstat(1,globbuf.gl_pathv[uVar5],(stat *)&statbuf);
      if ((iVar2 != -1) && ((statbuf.st_mode & 0xf000) != 0x4000)) {
        if (__filename != (char *)0x0) {
          pFVar4 = (FILE *)0x0;
          free(__filename);
          globfree((glob_t *)&globbuf);
          goto LAB_0010e01c;
        }
        __s = globbuf.gl_pathv[uVar5];
        sVar3 = strlen(__s);
        __filename = (char *)malloc(sVar3 + 10);
        memcpy(__filename,__s,sVar3 + 1);
      }
      uVar5 = uVar5 + 1;
    } while (uVar5 < globbuf.gl_pathc);
    globfree((glob_t *)&globbuf);
    if (__filename == (char *)0x0) {
      pFVar4 = (FILE *)0x0;
    }
    else {
      pFVar4 = fopen(__filename,"rb");
      free(__filename);
    }
  }
LAB_0010e01c:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return (FILE *)pFVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int ParseRiffHeaderConfig
              (FILE *infile,char *infilename,char *fourcc,WavpackContext *wpc,WavpackConfig *config)

{
  ushort uVar1;
  long lVar2;
  char cVar3;
  int iVar4;
  uint32_t uVar5;
  int64_t iVar6;
  void *lpBuffer;
  undefined8 uVar7;
  int64_t iVar8;
  uint uVar9;
  long lVar10;
  uint uVar11;
  uint16_t uVar12;
  byte *pbVar13;
  char *pcVar14;
  byte *pbVar15;
  ulong uVar16;
  uint64_t uVar17;
  long in_FS_OFFSET;
  bool bVar18;
  bool bVar19;
  bool bVar20;
  bool bVar21;
  byte bVar22;
  uint local_d4;
  uint32_t bcount;
  DS64Chunk ds64_chunk;
  ChunkHeader chunk_header;
  RiffChunkHeader riff_chunk_header;
  CS64Chunk cs64_chunk;
  WaveHeader WaveHeader;
  
  bVar22 = 0;
  lVar10 = 4;
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  bVar18 = false;
  bVar20 = true;
  ds64_chunk.tableLength = 0;
  pbVar13 = (byte *)fourcc;
  pbVar15 = &DAT_00115568;
  do {
    if (lVar10 == 0) break;
    lVar10 = lVar10 + -1;
    bVar18 = *pbVar13 < *pbVar15;
    bVar20 = *pbVar13 == *pbVar15;
    pbVar13 = pbVar13 + 1;
    pbVar15 = pbVar15 + 1;
  } while (bVar20);
  WaveHeader.GUID[6] = '\0';
  WaveHeader.GUID[7] = '\0';
  WaveHeader.GUID[8] = '\0';
  WaveHeader.GUID[9] = '\0';
  WaveHeader.GUID[10] = '\0';
  WaveHeader.GUID[0xb] = '\0';
  WaveHeader.GUID[0xc] = '\0';
  WaveHeader.GUID[0xd] = '\0';
  ds64_chunk.sampleCount64 = 0;
  WaveHeader.FormatTag = 0;
  WaveHeader.NumChannels = 0;
  WaveHeader.SampleRate = 0;
  WaveHeader.BytesPerSecond = 0;
  WaveHeader.BlockAlign = 0;
  WaveHeader.BitsPerSample = 0;
  WaveHeader.cbSize = 0;
  WaveHeader.ValidBitsPerSample = 0;
  WaveHeader.ChannelMask = 0;
  WaveHeader.SubFormat = 0;
  WaveHeader.GUID[0] = '\0';
  WaveHeader.GUID[1] = '\0';
  WaveHeader.GUID[2] = '\0';
  WaveHeader.GUID[3] = '\0';
  WaveHeader.GUID[4] = '\0';
  WaveHeader.GUID[5] = '\0';
  ds64_chunk.riffSize64 = 0;
  ds64_chunk.dataSize64 = 0;
  iVar6 = DoGetFileSize(infile);
  if ((((!bVar18 && !bVar20) == bVar18) || (iVar6 < 0x100000000)) ||
     ((*(byte *)((long)&config->qmode + 1) & 8) != 0)) {
    riff_chunk_header.ckID = *(char (*) [4])fourcc;
    iVar4 = DoReadFile(infile,&riff_chunk_header.ckSize,8,&bcount);
    if (iVar4 != 0) {
      bVar19 = bcount < 8;
      bVar21 = bcount == 8;
      if (bVar21) {
        lVar10 = 4;
        pcVar14 = riff_chunk_header.formType;
        pbVar13 = &DAT_0011843c;
        do {
          if (lVar10 == 0) break;
          lVar10 = lVar10 + -1;
          bVar19 = (byte)*pcVar14 < *pbVar13;
          bVar21 = *pcVar14 == *pbVar13;
          pcVar14 = pcVar14 + (ulong)bVar22 * -2 + 1;
          pbVar13 = pbVar13 + (ulong)bVar22 * -2 + 1;
        } while (bVar21);
        cVar3 = (!bVar19 && !bVar21) - bVar19;
        local_d4 = (uint)cVar3;
        if (cVar3 == '\0') {
          if (((*(byte *)((long)&config->qmode + 1) & 2) != 0) ||
             (iVar4 = WavpackAddWrapper(wpc,&riff_chunk_header,0xc), iVar4 != 0)) {
            bVar19 = false;
LAB_0010e1fd:
            do {
              while( true ) {
                while( true ) {
                  iVar4 = DoReadFile(infile,&chunk_header,8,&bcount);
                  if ((iVar4 == 0) || (bcount != 8)) goto LAB_0010e164;
                  if (((*(byte *)((long)&config->qmode + 1) & 2) == 0) &&
                     (iVar4 = WavpackAddWrapper(wpc,&chunk_header,8), iVar4 == 0))
                  goto LAB_0010e480;
                  WavpackLittleEndianToNative(&chunk_header,&DAT_0011845e);
                  uVar5 = chunk_header.ckSize;
                  if (chunk_header.ckID != (char  [4])0x34367364) break;
                  if (chunk_header.ckSize < 0x1c) goto LAB_0010e164;
                  iVar4 = DoReadFile(infile,&ds64_chunk,0x1c,&bcount);
                  if ((iVar4 == 0) || (bcount != 0x1c)) goto LAB_0010e164;
                  if (((*(byte *)((long)&config->qmode + 1) & 2) == 0) &&
                     (iVar4 = WavpackAddWrapper(wpc,&ds64_chunk,0x1c), iVar4 == 0))
                  goto LAB_0010e480;
                  WavpackLittleEndianToNative(&ds64_chunk,&DAT_00118466);
                  if (debug_logging_mode != 0) {
                    error_line("DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d"
                               ,ds64_chunk.riffSize64,ds64_chunk.dataSize64,ds64_chunk.sampleCount64
                               ,(ulong)ds64_chunk.tableLength);
                  }
                  if ((ulong)ds64_chunk.tableLength * 0xc != (ulong)chunk_header.ckSize - 0x1c)
                  goto LAB_0010e164;
                  uVar5 = ds64_chunk.tableLength - 1;
                  bVar19 = ds64_chunk.tableLength != 0;
                  ds64_chunk.tableLength = uVar5;
                  if (bVar19) {
                    do {
                      iVar4 = DoReadFile(infile,&cs64_chunk,0xc,&bcount);
                      if (((iVar4 == 0) || (bcount != 0xc)) ||
                         (((*(byte *)((long)&config->qmode + 1) & 2) == 0 &&
                          (iVar4 = WavpackAddWrapper(wpc,&cs64_chunk,0xc), iVar4 == 0))))
                      goto LAB_0010e480;
                      uVar5 = ds64_chunk.tableLength - 1;
                      bVar19 = ds64_chunk.tableLength != 0;
                      ds64_chunk.tableLength = uVar5;
                    } while (bVar19);
                  }
                  bVar19 = true;
                }
                if (chunk_header.ckID != (char  [4])0x20746d66) break;
                if ((((local_d4 != 0) || (0x18 < chunk_header.ckSize - 0x10)) ||
                    (iVar4 = DoReadFile(infile,&WaveHeader,chunk_header.ckSize,&bcount), iVar4 == 0)
                    ) || (chunk_header.ckSize != bcount)) goto LAB_0010e164;
                if (((*(byte *)((long)&config->qmode + 1) & 2) == 0) &&
                   (iVar4 = WavpackAddWrapper(wpc,&WaveHeader), iVar4 == 0)) goto LAB_0010e480;
                WavpackLittleEndianToNative(&WaveHeader,"SSLLSSSSLS");
                if (debug_logging_mode == 0) {
LAB_0010e3a7:
                  if ((0x10 < chunk_header.ckSize) && (WaveHeader.cbSize == 2)) {
                    config->qmode = config->qmode | 0x100;
                  }
                }
                else {
                  error_line("format tag size = %d",(ulong)chunk_header.ckSize);
                  error_line("FormatTag = %x, NumChannels = %d, BitsPerSample = %d",
                             (ulong)WaveHeader.FormatTag,(ulong)WaveHeader.NumChannels,
                             (ulong)WaveHeader.BitsPerSample);
                  error_line("BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d",
                             (ulong)WaveHeader.BlockAlign,(ulong)WaveHeader.SampleRate,
                             (ulong)WaveHeader.BytesPerSecond);
                  if (0x10 < chunk_header.ckSize) {
                    error_line("cbSize = %d, ValidBitsPerSample = %d",(ulong)WaveHeader.cbSize,
                               (ulong)WaveHeader.ValidBitsPerSample);
                    if (0x14 < chunk_header.ckSize) {
                      error_line("ChannelMask = %x, SubFormat = %d",
                                 (ulong)(uint)WaveHeader.ChannelMask,(ulong)WaveHeader.SubFormat);
                    }
                    goto LAB_0010e3a7;
                  }
                }
                if ((WaveHeader.FormatTag == 0xfffe) && (chunk_header.ckSize == 0x28)) {
                  uVar12 = WaveHeader.SubFormat;
LAB_0010e623:
                  uVar1 = WaveHeader.ValidBitsPerSample;
                  if (WaveHeader.ValidBitsPerSample == 0) goto LAB_0010e3db;
                }
                else {
                  uVar12 = WaveHeader.FormatTag;
                  if (chunk_header.ckSize == 0x28) goto LAB_0010e623;
LAB_0010e3db:
                  uVar1 = WaveHeader.BitsPerSample;
                }
                config->bits_per_sample = (uint)uVar1;
                if (((uVar12 & 0xfffd) == 1) && (local_d4 = 1, uVar12 == 3)) {
                  local_d4 = (uint)(uVar1 == 0x20);
                }
                if (0xff < (ushort)(WaveHeader.NumChannels - 1)) {
LAB_0010e446:
                  error_line("%s is an unsupported .WAV format!",infilename);
                  uVar11 = 1;
                  goto LAB_0010e17c;
                }
                uVar11 = (uint)WaveHeader.BlockAlign / (uint)WaveHeader.NumChannels;
                if ((((uVar11 < (uint)((int)(uVar1 + 7) >> 3)) || (4 < (ushort)uVar11)) ||
                    (WaveHeader.BlockAlign % WaveHeader.NumChannels != 0)) ||
                   ((0x1f < uVar1 - 1 || ((local_d4 & 1) == 0)))) goto LAB_0010e446;
                if (chunk_header.ckSize < 0x28) {
                  if ((config->channel_mask == 0) &&
                     ((*(byte *)((long)&config->qmode + 1) & 4) == 0)) {
                    if (WaveHeader.NumChannels < 3) {
                      config->channel_mask = 5 - (uint)WaveHeader.NumChannels;
                    }
                    else if (WaveHeader.NumChannels < 0x13) {
                      config->channel_mask = (1 << (SUB161(WaveHeader._0_16_,2) & 0x1f)) + -1;
                    }
                    else {
                      config->channel_mask = 0x3ffff;
                    }
                  }
                }
                else if (WaveHeader.ChannelMask != 0) {
                  if ((config->channel_mask != 0) ||
                     ((*(byte *)((long)&config->qmode + 1) & 4) != 0)) {
                    error_line("this WAV file already has channel order information!");
                    uVar11 = 1;
                    goto LAB_0010e17c;
                  }
                  config->channel_mask = WaveHeader.ChannelMask;
                }
                iVar4 = debug_logging_mode;
                if (uVar12 == 3) goto LAB_0010e810;
                if (((*(byte *)((long)&config->qmode + 1) & 1) == 0) || ((ushort)uVar11 != 4)) {
LAB_0010e7a1:
                  local_d4 = 1;
                  if (debug_logging_mode != 0) {
                    iVar4 = config->float_norm_exp;
                    if (iVar4 == 0x7f) goto LAB_0010e829;
                    if (iVar4 != 0) goto LAB_0010e849;
                    error_line("data format: %d-bit integers stored in %d byte(s)",(ulong)uVar1,
                               (ulong)uVar11);
                  }
                }
                else {
                  if (WaveHeader.BitsPerSample == 0x18) {
                    config->float_norm_exp = 0x96;
                  }
                  else {
                    if (WaveHeader.BitsPerSample != 0x20) goto LAB_0010e7a1;
                    config->float_norm_exp = 0x8e;
                  }
                  if (iVar4 == 0) {
                    local_d4 = 1;
                  }
                  else {
                    iVar4 = config->float_norm_exp;
LAB_0010e849:
                    error_line("data format: 32-bit floating point (Audition %d:%d float type 1)",
                               (ulong)(iVar4 - 0x7e),(ulong)(0x96 - iVar4));
                    local_d4 = 1;
                  }
                }
              }
              uVar16 = (ulong)chunk_header.ckSize;
              if (chunk_header.ckID == (char  [4])0x61746164) {
                uVar9 = (uint)WaveHeader.NumChannels;
                if (bVar19) {
                  if (chunk_header.ckSize == 0xffffffff) {
                    uVar16 = ds64_chunk.dataSize64;
                  }
                  if (WaveHeader.NumChannels == 0) goto LAB_0010e164;
                }
                else if ((WaveHeader.NumChannels == 0) || ((!bVar18 && !bVar20) == bVar18))
                goto LAB_0010e164;
                uVar11 = config->qmode & 0x800;
                if (iVar6 == 0) {
                  if (uVar11 == 0) goto LAB_0010ea1c;
LAB_0010e971:
                  uVar9 = (uint)WaveHeader.NumChannels;
                  uVar17 = 0xffffffffffffffff;
                }
                else if (uVar11 == 0) {
                  if (0x1000000 < (long)(iVar6 - uVar16)) {
                    error_line(
                              "this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!"
                              );
                    uVar11 = 1;
                    goto LAB_0010e17c;
                  }
LAB_0010ea1c:
                  uVar17 = (long)uVar16 / (long)(ulong)WaveHeader.BlockAlign;
                  if ((bVar19) && (ds64_chunk.sampleCount64 != uVar17)) goto LAB_0010e164;
                  if (uVar17 == 0) {
                    error_line("this .WAV file has no audio samples, probably is corrupt!");
                    uVar11 = 1;
                    goto LAB_0010e17c;
                  }
                  if (0xfffffffeff < (long)uVar17) {
                    error_line("%s has too many samples for WavPack!",infilename);
                    uVar11 = 1;
                    goto LAB_0010e17c;
                  }
                }
                else {
                  iVar8 = DoGetFilePosition(infile);
                  if (iVar8 == -1) {
                    goto LAB_0010e971;
                  }
                  iVar8 = DoGetFilePosition(infile);
                  uVar17 = (iVar6 - iVar8) / (long)(ulong)WaveHeader.BlockAlign;
                  uVar9 = (uint)WaveHeader.NumChannels;
                }
                uVar11 = (uint)(chunk_header.ckID != (char  [4])0x61746164);
                config->num_channels = uVar9;
                config->bytes_per_sample = WaveHeader.BlockAlign / uVar9;
                config->sample_rate = WaveHeader.SampleRate;
                iVar4 = WavpackSetConfiguration64(wpc,config,uVar17,0);
                if (iVar4 == 0) {
                  uVar7 = WavpackGetErrorMessage(wpc);
                  error_line("%s: %s",infilename,uVar7);
                  uVar11 = 1;
                }
                goto LAB_0010e17c;
              }
              uVar11 = chunk_header.ckSize + 1 & 0xfffffffe;
              if (0x400000 < uVar11) goto LAB_0010e164;
              lpBuffer = malloc((long)(int)uVar11);
              if (debug_logging_mode != 0) {
                error_line("extra unknown chunk \"%c%c%c%c\" of %d bytes",
                           (ulong)(uint)(int)chunk_header.ckID[0],
                           (ulong)(uint)(int)chunk_header.ckID[1],
                           (ulong)(uint)(int)chunk_header.ckID[2],
                           (ulong)(uint)(int)chunk_header.ckID[3],uVar5);
              }
              iVar4 = DoReadFile(infile,lpBuffer,uVar11,&bcount);
              if (((iVar4 == 0) || (uVar11 != bcount)) ||
                 (((*(byte *)((long)&config->qmode + 1) & 2) == 0 &&
                  (iVar4 = WavpackAddWrapper(wpc,lpBuffer,uVar11), iVar4 == 0)))) {
                uVar7 = WavpackGetErrorMessage(wpc);
                error_line("%s",uVar7);
                free(lpBuffer);
                uVar11 = 1;
                goto LAB_0010e17c;
              }
              free(lpBuffer);
            } while( true );
          }
LAB_0010e480:
          uVar7 = WavpackGetErrorMessage(wpc);
          error_line("%s",uVar7);
          uVar11 = 1;
          goto LAB_0010e17c;
        }
      }
    }
LAB_0010e164:
    error_line("%s is not a valid .WAV file!",infilename);
    uVar11 = 1;
  }
  else {
    error_line("can\'t handle .WAV files larger than 4 GB (non-standard)!");
    uVar11 = 1;
  }
LAB_0010e17c:
  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar11;
LAB_0010e810:
  config->float_norm_exp = 0x7f;
  local_d4 = 1;
  if (iVar4 != 0) {
LAB_0010e829:
    error_line("data format: normalized 32-bit floating point");
    local_d4 = 1;
  }
  goto LAB_0010e1fd;
}



int WriteRiffHeader(FILE *outfile,WavpackContext *wpc,int64_t total_samples,int qmode)

{
  long lVar1;
  long lVar2;
  bool bVar3;
  uint16_t uVar4;
  int iVar5;
  int iVar6;
  uint32_t uVar7;
  int iVar8;
  int iVar9;
  ulong uVar10;
  undefined4 in_register_0000000c;
  long lVar11;
  uint64_t uVar12;
  uint16_t uVar13;
  uint64_t uVar14;
  long in_FS_OFFSET;
  uint32_t local_104;
  uint32_t bcount;
  DS64Chunk ds64_chunk;
  ChunkHeader ds64hdr;
  ChunkHeader datahdr;
  ChunkHeader fmthdr;
  RiffChunkHeader riffhdr;
  JunkChunk junkchunk;
  WaveHeader wavhdr;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  iVar5 = WavpackGetNumChannels(wpc,wpc,total_samples,CONCAT44(in_register_0000000c,qmode));
  iVar6 = WavpackGetChannelMask(wpc);
  uVar7 = WavpackGetSampleRate(wpc);
  iVar8 = WavpackGetBytesPerSample(wpc);
  uVar4 = WavpackGetBitsPerSample(wpc);
  iVar9 = WavpackGetFloatNormExp(wpc);
  uVar13 = 1;
  if (iVar9 != 0) {
    iVar9 = WavpackGetFloatNormExp(wpc);
    uVar13 = 3;
    if (iVar9 != 0x7f) {
      error_line("can\'t create valid RIFF wav header for non-normalized floating data!");
      iVar5 = 0;
      goto LAB_0010ee48;
    }
  }
  if (total_samples == -1) {
    total_samples = (int64_t)(int)(0x7ffff000 / (long)(iVar5 * iVar8));
  }
  uVar12 = iVar8 * total_samples * (long)iVar5;
  if ((long)uVar12 < 0xff000001) {
    bVar3 = true;
    iVar9 = debug_logging_mode;
    if (debug_logging_mode != 0) {
      iVar9 = 0;
      error_line("total_data_bytes = %lld, so riff",uVar12);
    }
  }
  else if (debug_logging_mode == 0) {
    bVar3 = false;
    iVar9 = 1;
  }
  else {
    iVar9 = 1;
    error_line("total_data_bytes = %lld, so rf64",uVar12);
    bVar3 = false;
  }
  wavhdr.NumChannels = (uint16_t)iVar5;
  wavhdr.BlockAlign = (short)iVar8 * wavhdr.NumChannels;
  wavhdr.GUID[6] = '\0';
  wavhdr.GUID[7] = '\0';
  wavhdr.GUID[8] = '\0';
  wavhdr.GUID[9] = '\0';
  wavhdr.GUID[10] = '\0';
  wavhdr.GUID[0xb] = '\0';
  wavhdr.GUID[0xc] = '\0';
  wavhdr.GUID[0xd] = '\0';
  wavhdr.BytesPerSecond = uVar7 * iVar5 * iVar8;
  wavhdr.cbSize = 0;
  wavhdr.ValidBitsPerSample = 0;
  wavhdr.ChannelMask = 0;
  wavhdr.SubFormat = 0;
  wavhdr.GUID[0] = '\0';
  wavhdr.GUID[1] = '\0';
  wavhdr.GUID[2] = '\0';
  wavhdr.GUID[3] = '\0';
  wavhdr.GUID[4] = '\0';
  wavhdr.GUID[5] = '\0';
  if ((iVar5 < 3) && (5 - iVar5 == iVar6)) {
    local_104 = 0x10;
    lVar11 = 0x10;
    wavhdr.FormatTag = uVar13;
    wavhdr.BitsPerSample = uVar4;
  }
  else {
    lVar11 = 0x28;
    wavhdr._20_12_ = SUB1612((undefined  [16])0x0,4);
    wavhdr.ValidBitsPerSample = uVar4;
    wavhdr.cbSize = 0x16;
    wavhdr.ChannelMask = iVar6;
    wavhdr.SubFormat = uVar13;
    wavhdr.FormatTag = 0xfffe;
    wavhdr.GUID[0] = '\0';
    wavhdr.GUID[1] = '\0';
    wavhdr.GUID[2] = '\0';
    wavhdr.GUID[3] = '\0';
    wavhdr.GUID[4] = '\x10';
    wavhdr.GUID[5] = '\0';
    wavhdr.GUID[6] = -0x80;
    wavhdr.GUID[7] = '\0';
    wavhdr.GUID[8] = '\0';
    wavhdr.GUID[9] = -0x56;
    wavhdr.GUID[10] = '\0';
    wavhdr.GUID[0xb] = '8';
    wavhdr.GUID[0xc] = -0x65;
    wavhdr.GUID[0xd] = 'q';
    local_104 = 0x28;
    wavhdr.BitsPerSample = (short)iVar8 * 8;
  }
  uVar10 = uVar12 + 1 & 0xfffffffffffffffe;
  if (iVar9 == 0) {
    builtin_strncpy(riffhdr.ckID,"RIFF",4);
    lVar1 = uVar10 + 0x14;
  }
  else {
    builtin_strncpy(riffhdr.ckID,"RF64",4);
    lVar1 = uVar10 + 0x38;
  }
  builtin_strncpy(riffhdr.formType,"WAVE",4);
  uVar14 = lVar1 + lVar11;
  wavhdr.SampleRate = uVar7;
  if (bVar3) {
    uVar14 = uVar14 + 0x24;
    builtin_strncpy(fmthdr.ckID,"fmt ",4);
    builtin_strncpy(datahdr.ckID,"data",4);
    fmthdr.ckSize = local_104;
    junkchunk.junk[0x10] = '\0';
    junkchunk.junk[0x11] = '\0';
    junkchunk.junk[0x12] = '\0';
    junkchunk.junk[0x13] = '\0';
    junkchunk.junk[0x14] = '\0';
    junkchunk.junk[0x15] = '\0';
    junkchunk.junk[0x16] = '\0';
    junkchunk.junk[0x17] = '\0';
    junkchunk.junk[0x18] = '\0';
    junkchunk.junk[0x19] = '\0';
    junkchunk.junk[0x1a] = '\0';
    junkchunk.junk[0x1b] = '\0';
    builtin_strncpy(junkchunk.ckID,"junk",4);
    junkchunk.ckSize = 0x1c;
    junkchunk.junk[0] = '\0';
    junkchunk.junk[1] = '\0';
    junkchunk.junk[2] = '\0';
    junkchunk.junk[3] = '\0';
    junkchunk.junk[4] = '\0';
    junkchunk.junk[5] = '\0';
    junkchunk.junk[6] = '\0';
    junkchunk.junk[7] = '\0';
    junkchunk.junk[8] = '\0';
    junkchunk.junk[9] = '\0';
    junkchunk.junk[10] = '\0';
    junkchunk.junk[0xb] = '\0';
    junkchunk.junk[0xc] = '\0';
    junkchunk.junk[0xd] = '\0';
    junkchunk.junk[0xe] = '\0';
    junkchunk.junk[0xf] = '\0';
    WavpackNativeToLittleEndian(&junkchunk,&DAT_0011845e);
    if (iVar9 != 0) goto LAB_0010eeb8;
LAB_0010ed75:
    riffhdr.ckSize = (uint32_t)uVar14;
    datahdr.ckSize = (uint32_t)uVar12;
  }
  else {
    fmthdr.ckSize = local_104;
    builtin_strncpy(fmthdr.ckID,"fmt ",4);
    builtin_strncpy(datahdr.ckID,"data",4);
    if (iVar9 == 0) goto LAB_0010ed75;
LAB_0010eeb8:
    builtin_strncpy(ds64hdr.ckID,"ds64",4);
    ds64hdr.ckSize = 0x1c;
    ds64_chunk.tableLength = 0;
    riffhdr.ckSize = 0xffffffff;
    datahdr.ckSize = 0xffffffff;
    ds64_chunk.riffSize64 = uVar14;
    ds64_chunk.dataSize64 = uVar12;
    ds64_chunk.sampleCount64 = total_samples;
    WavpackNativeToLittleEndian(&ds64hdr,&DAT_0011845e);
    WavpackNativeToLittleEndian(&ds64_chunk,&DAT_00118466);
  }
  WavpackNativeToLittleEndian(&riffhdr,&DAT_0011845e);
  WavpackNativeToLittleEndian(&fmthdr,&DAT_0011845e);
  WavpackNativeToLittleEndian(&wavhdr,"SSLLSSSSLS");
  WavpackNativeToLittleEndian(&datahdr,&DAT_0011845e);
  iVar5 = DoWriteFile(outfile,&riffhdr,0xc,&bcount);
  if ((((((iVar5 == 0) || (bcount != 0xc)) ||
        ((iVar9 != 0 &&
         ((((iVar5 = DoWriteFile(outfile,&ds64hdr,8,&bcount), iVar5 == 0 || (bcount != 8)) ||
           (iVar5 = DoWriteFile(outfile,&ds64_chunk,0x1c,&bcount), iVar5 == 0)) || (bcount != 0x1c))
         )))) || ((bVar3 && ((iVar5 = DoWriteFile(outfile,&junkchunk,0x24,&bcount), iVar5 == 0 ||
                             (bcount != 0x24)))))) ||
      (((iVar5 = DoWriteFile(outfile,&fmthdr,8,&bcount), iVar5 == 0 ||
        ((bcount != 8 || (iVar5 = DoWriteFile(outfile,&wavhdr,local_104,&bcount), iVar5 == 0)))) ||
       (bcount != local_104)))) ||
     ((iVar5 = DoWriteFile(outfile,&datahdr,8,&bcount), iVar5 == 0 || (iVar5 = 1, bcount != 8)))) {
    error_line("can\'t write .WAV data, disk probably full!");
    iVar5 = 0;
  }
LAB_0010ee48:
  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar5;
}



int ParseWave64HeaderConfig
              (FILE *infile,char *infilename,char *fourcc,WavpackContext *wpc,WavpackConfig *config)

{
  ulong uVar1;
  ushort uVar2;
  long lVar3;
  int iVar4;
  int iVar5;
  int64_t iVar6;
  void *lpBuffer;
  undefined8 uVar7;
  int64_t iVar8;
  uint16_t uVar9;
  long lVar10;
  uint uVar11;
  long in_FS_OFFSET;
  bool bVar12;
  uint32_t bcount;
  Wave64ChunkHeader chunk_header;
  Wave64FileHeader filehdr;
  WaveHeader WaveHeader;
  
  lVar3 = *(long *)(in_FS_OFFSET + 0x28);
  iVar6 = DoGetFileSize(infile);
  filehdr.ckID[0] = fourcc[0];
  filehdr.ckID[1] = fourcc[1];
  filehdr.ckID[2] = fourcc[2];
  filehdr.ckID[3] = fourcc[3];
  iVar4 = DoReadFile(infile,filehdr.ckID + 4,0x24,&bcount);
  uVar1 = chunk_header.ckSize;
  if ((((iVar4 != 0) && (bcount == 0x24)) &&
      (filehdr.ckID._8_8_ == 0xc104db28d6a5 &&
       CONCAT44(filehdr.ckID._4_4_,filehdr.ckID._0_4_) == 0x11cf912e66666972)) &&
     (filehdr.formType._8_8_ == -0x752471b03fff2e74 && filehdr.formType._0_8_ == 0x11d3acf365766177)
     ) {
    if (((*(byte *)((long)&config->qmode + 1) & 2) == 0) &&
       (iVar4 = WavpackAddWrapper(wpc,&filehdr,0x28), iVar4 == 0)) {
LAB_0010f838:
      iVar4 = 1;
      uVar7 = WavpackGetErrorMessage(wpc);
      error_line("%s",uVar7);
      goto LAB_0010f163;
    }
    WavpackLittleEndianToNative(&filehdr,&DAT_001188c0);
    if (((iVar6 == 0) ||
        (((*(byte *)((long)&config->qmode + 1) & 8) != 0 || (filehdr.ckSize + 1U < 2)))) ||
       (uVar1 = chunk_header.ckSize, filehdr.ckSize == iVar6)) {
      bVar12 = false;
      do {
        while( true ) {
          iVar4 = DoReadFile(infile,&chunk_header,0x18,&bcount);
          uVar1 = chunk_header.ckSize;
          if ((iVar4 == 0) || (bcount != 0x18)) goto LAB_0010f14c;
          if (((*(byte *)((long)&config->qmode + 1) & 2) == 0) &&
             (iVar4 = WavpackAddWrapper(wpc,&chunk_header,0x18), iVar4 == 0)) goto LAB_0010f838;
          WavpackLittleEndianToNative(&chunk_header,&DAT_001188c0);
          lVar10 = CONCAT44(chunk_header.ckID._4_4_,
                            CONCAT13(chunk_header.ckID[3],
                                     CONCAT12(chunk_header.ckID[2],
                                              CONCAT11(chunk_header.ckID[1],chunk_header.ckID[0]))))
          ;
          uVar1 = chunk_header.ckSize + -0x18;
          if (chunk_header.ckID._8_8_ != -0x752471b03fff2e74 || lVar10 != 0x11d3acf320746d66) break;
          if ((((bVar12) ||
               (chunk_header.ckSize = chunk_header.ckSize - 0x11U & 0xfffffffffffffff8,
               uVar1 = chunk_header.ckSize, 0x18 < chunk_header.ckSize - 0x10U)) ||
              (iVar4 = DoReadFile(infile,&WaveHeader,(uint32_t)chunk_header.ckSize,&bcount),
              uVar1 = chunk_header.ckSize, iVar4 == 0)) || ((ulong)bcount != chunk_header.ckSize))
          goto LAB_0010f14c;
          if (((*(byte *)((long)&config->qmode + 1) & 2) == 0) &&
             (iVar4 = WavpackAddWrapper(wpc,&WaveHeader), iVar4 == 0)) goto LAB_0010f838;
          WavpackLittleEndianToNative(&WaveHeader,"SSLLSSSSLS");
          if (debug_logging_mode == 0) {
LAB_0010f35b:
            if ((0x10 < chunk_header.ckSize) && (WaveHeader.cbSize == 2)) {
              config->qmode = config->qmode | 0x100;
            }
          }
          else {
            error_line("format tag size = %d",chunk_header.ckSize);
            error_line("FormatTag = %x, NumChannels = %d, BitsPerSample = %d",
                       (ulong)WaveHeader.FormatTag,(ulong)WaveHeader.NumChannels,
                       (ulong)WaveHeader.BitsPerSample);
            error_line("BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d",
                       (ulong)WaveHeader.BlockAlign,(ulong)WaveHeader.SampleRate,
                       (ulong)WaveHeader.BytesPerSecond);
            if (0x10 < chunk_header.ckSize) {
              error_line("cbSize = %d, ValidBitsPerSample = %d",(ulong)WaveHeader.cbSize,
                         (ulong)WaveHeader.ValidBitsPerSample);
              if (0x14 < chunk_header.ckSize) {
                error_line("ChannelMask = %x, SubFormat = %d",(ulong)(uint)WaveHeader.ChannelMask,
                           (ulong)WaveHeader.SubFormat);
              }
              goto LAB_0010f35b;
            }
          }
          if ((((chunk_header.ckSize != 0x28) ||
               (uVar9 = WaveHeader.SubFormat, WaveHeader.FormatTag != 0xfffe)) &&
              (uVar9 = WaveHeader.FormatTag, chunk_header.ckSize != 0x28)) ||
             (uVar2 = WaveHeader.ValidBitsPerSample, WaveHeader.ValidBitsPerSample == 0)) {
            uVar2 = WaveHeader.BitsPerSample;
          }
          config->bits_per_sample = (uint)uVar2;
          bVar12 = false;
          if (((uVar9 & 0xfffd) == 1) && (bVar12 = true, uVar9 == 3)) {
            bVar12 = uVar2 == 0x20;
          }
          if (0xff < (ushort)(WaveHeader.NumChannels - 1)) {
LAB_0010f403:
            iVar4 = 1;
            error_line("%s is an unsupported .W64 format!",infilename);
            goto LAB_0010f163;
          }
          uVar11 = (uint)WaveHeader.BlockAlign / (uint)WaveHeader.NumChannels;
          if (((uVar11 < (uint)((int)(uVar2 + 7) >> 3)) || (4 < (ushort)uVar11)) ||
             ((WaveHeader.BlockAlign % WaveHeader.NumChannels != 0 ||
              ((0x1f < uVar2 - 1 || (!bVar12)))))) goto LAB_0010f403;
          if (chunk_header.ckSize < 0x28) {
            if ((config->channel_mask == 0) && ((*(byte *)((long)&config->qmode + 1) & 4) == 0)) {
              if (WaveHeader.NumChannels < 3) {
                config->channel_mask = 5 - (uint)WaveHeader.NumChannels;
              }
              else if (WaveHeader.NumChannels < 0x13) {
                config->channel_mask = (1 << ((byte)WaveHeader.NumChannels & 0x1f)) + -1;
              }
              else {
                config->channel_mask = 0x3ffff;
              }
            }
LAB_0010f708:
            if (uVar9 == 3) goto LAB_0010f7d4;
LAB_0010f717:
            iVar4 = debug_logging_mode;
            if (((*(byte *)((long)&config->qmode + 1) & 1) == 0) || ((ushort)uVar11 != 4)) {
LAB_0010f729:
              if (debug_logging_mode == 0) goto LAB_0010f74a;
              if (config->float_norm_exp != 0x7f) goto LAB_0010f739;
              goto LAB_0010f7e5;
            }
            if (WaveHeader.BitsPerSample == 0x18) {
              config->float_norm_exp = 0x96;
            }
            else {
              if (WaveHeader.BitsPerSample != 0x20) goto LAB_0010f729;
              config->float_norm_exp = 0x8e;
            }
            if (iVar4 != 0) {
LAB_0010f739:
              error_line("data format: %d-bit integers stored in %d byte(s)",(ulong)uVar2,
                         (ulong)uVar11);
            }
LAB_0010f74a:
            bVar12 = true;
          }
          else {
            if (WaveHeader.ChannelMask == 0) goto LAB_0010f708;
            if ((config->channel_mask != 0) || ((*(byte *)((long)&config->qmode + 1) & 4) != 0)) {
              iVar4 = 1;
              error_line("this W64 file already has channel order information!");
              goto LAB_0010f163;
            }
            config->channel_mask = WaveHeader.ChannelMask;
            if (uVar9 != 3) goto LAB_0010f717;
LAB_0010f7d4:
            iVar4 = debug_logging_mode;
            config->float_norm_exp = 0x7f;
            if (iVar4 == 0) goto LAB_0010f74a;
LAB_0010f7e5:
            error_line("data format: normalized 32-bit floating point");
            bVar12 = true;
          }
        }
        chunk_header.ckSize = uVar1;
        if (chunk_header.ckID._8_8_ == -0x752471b03fff2e74 && lVar10 == 0x11d3acf361746164) {
          uVar11 = (uint)WaveHeader.NumChannels;
          iVar4 = 0;
          if (WaveHeader.NumChannels != 0) {
            if (((config->qmode & 0x800U) == 0) && (0 < (long)uVar1)) {
              if ((iVar6 != 0) && (0x1000000 < (long)(iVar6 - uVar1))) {
                iVar4 = 1;
                error_line("this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!")
                ;
                goto LAB_0010f163;
              }
              lVar10 = (long)uVar1 / (long)(ulong)WaveHeader.BlockAlign;
              if (lVar10 == 0) {
                iVar4 = 1;
                error_line("this .W64 file has no audio samples, probably is corrupt!");
                goto LAB_0010f163;
              }
              if (0xfffffffeff < lVar10) {
                iVar4 = 1;
                error_line("%s has too many samples for WavPack!",infilename);
                goto LAB_0010f163;
              }
            }
            else {
              config->qmode = config->qmode | 0x800;
              if (iVar6 == 0) {
                lVar10 = -1;
              }
              else {
                iVar8 = DoGetFilePosition(infile);
                if (iVar8 == -1) {
                  uVar11 = (uint)WaveHeader.NumChannels;
                  lVar10 = -1;
                }
                else {
                  iVar8 = DoGetFilePosition(infile);
                  lVar10 = (iVar6 - iVar8) / (long)(ulong)WaveHeader.BlockAlign;
                  uVar11 = (uint)WaveHeader.NumChannels;
                }
              }
            }
            config->num_channels = uVar11;
            config->bytes_per_sample = WaveHeader.BlockAlign / uVar11;
            config->sample_rate = WaveHeader.SampleRate;
            iVar5 = WavpackSetConfiguration64(wpc,config,lVar10,0);
            if (iVar5 == 0) {
              iVar4 = 1;
              uVar7 = WavpackGetErrorMessage(wpc);
              error_line("%s: %s",infilename,uVar7);
            }
            goto LAB_0010f163;
          }
          break;
        }
        uVar11 = (int)uVar1 + 7U & 0xfffffff8;
        if (0x400000 < uVar11) break;
        lpBuffer = malloc((long)(int)uVar11);
        if (debug_logging_mode != 0) {
          error_line("extra unknown chunk \"%c%c%c%c\" of %d bytes",
                     (ulong)(uint)(int)chunk_header.ckID[0],(ulong)(uint)(int)chunk_header.ckID[1],
                     (ulong)(uint)(int)chunk_header.ckID[2],(ulong)(uint)(int)chunk_header.ckID[3],
                     uVar1);
        }
        iVar4 = DoReadFile(infile,lpBuffer,uVar11,&bcount);
        if (((iVar4 == 0) || (uVar11 != bcount)) ||
           (((*(byte *)((long)&config->qmode + 1) & 2) == 0 &&
            (iVar4 = WavpackAddWrapper(wpc,lpBuffer,uVar11), iVar4 == 0)))) {
          iVar4 = 1;
          uVar7 = WavpackGetErrorMessage(wpc);
          error_line("%s",uVar7);
          free(lpBuffer);
          goto LAB_0010f163;
        }
        free(lpBuffer);
      } while( true );
    }
  }
LAB_0010f14c:
  chunk_header.ckSize = uVar1;
  iVar4 = 1;
  error_line("%s is not a valid .W64 file!",infilename);
LAB_0010f163:
  if (lVar3 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar4;
}



int WriteWave64Header(FILE *outfile,WavpackContext *wpc,int64_t total_samples,int qmode)

{
  long lVar1;
  undefined5 uVar2;
  undefined auVar3 [15];
  uint16_t uVar4;
  uint16_t uVar5;
  int iVar6;
  int iVar7;
  uint32_t uVar8;
  int iVar9;
  int iVar10;
  undefined4 in_register_0000000c;
  long lVar11;
  long lVar12;
  long in_FS_OFFSET;
  uint32_t local_f0;
  uint32_t bcount;
  Wave64ChunkHeader datahdr;
  Wave64ChunkHeader fmthdr;
  Wave64FileHeader filehdr;
  WaveHeader wavhdr;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar6 = WavpackGetNumChannels(wpc,wpc,total_samples,CONCAT44(in_register_0000000c,qmode));
  iVar7 = WavpackGetChannelMask(wpc);
  uVar8 = WavpackGetSampleRate(wpc);
  iVar9 = WavpackGetBytesPerSample(wpc);
  uVar5 = WavpackGetBitsPerSample(wpc);
  iVar10 = WavpackGetFloatNormExp(wpc);
  uVar4 = 1;
  if (iVar10 != 0) {
    iVar10 = WavpackGetFloatNormExp(wpc);
    uVar4 = 3;
    if (iVar10 != 0x7f) {
      error_line("can\'t create valid Wave64 header for non-normalized floating data!");
      iVar6 = 0;
      goto LAB_0010fc6c;
    }
  }
  wavhdr.FormatTag = uVar4;
  if (total_samples == -1) {
    total_samples = (int64_t)(int)(0x7ffff000 / (long)(iVar6 * iVar9));
  }
  wavhdr.cbSize = 0;
  wavhdr.ValidBitsPerSample = 0;
  wavhdr.ChannelMask = 0;
  wavhdr.SubFormat = 0;
  wavhdr.GUID[0] = '\0';
  wavhdr.GUID[1] = '\0';
  wavhdr.GUID[2] = '\0';
  wavhdr.GUID[3] = '\0';
  wavhdr.GUID[4] = '\0';
  wavhdr.GUID[5] = '\0';
  wavhdr.GUID[6] = '\0';
  wavhdr.GUID[7] = '\0';
  wavhdr.GUID[8] = '\0';
  wavhdr.GUID[9] = '\0';
  wavhdr.GUID[10] = '\0';
  wavhdr.GUID[0xb] = '\0';
  wavhdr.GUID[0xc] = '\0';
  wavhdr.GUID[0xd] = '\0';
  wavhdr.NumChannels = (uint16_t)iVar6;
  lVar11 = iVar9 * total_samples * (long)iVar6;
  wavhdr.BlockAlign = (short)iVar9 * wavhdr.NumChannels;
  wavhdr.BytesPerSecond = uVar8 * iVar6 * iVar9;
  if ((iVar6 < 3) && (5 - iVar6 == iVar7)) {
    local_f0 = 0x10;
    fmthdr.ckSize = 0x28;
    lVar12 = 0x10;
    wavhdr.BitsPerSample = uVar5;
  }
  else {
    wavhdr._16_14_ = SUB1614((undefined  [16])0x0,0);
    wavhdr.GUID[4] = '\x10';
    auVar3 = wavhdr._16_15_;
    wavhdr.ValidBitsPerSample = uVar5;
    wavhdr.cbSize = 0x16;
    wavhdr.ChannelMask = iVar7;
    local_f0 = 0x28;
    uVar2 = auVar3._10_5_;
    wavhdr.SubFormat = wavhdr.FormatTag;
    wavhdr.GUID[0] = (char)uVar2;
    wavhdr.GUID[1] = (char)((uint5)uVar2 >> 8);
    wavhdr.GUID[2] = (char)((uint5)uVar2 >> 0x10);
    wavhdr.GUID[3] = (char)((uint5)uVar2 >> 0x18);
    wavhdr.GUID[4] = (char)((uint5)uVar2 >> 0x20);
    wavhdr.GUID[5] = '\0';
    wavhdr.FormatTag = 0xfffe;
    fmthdr.ckSize = 0x40;
    wavhdr.GUID[6] = -0x80;
    wavhdr.GUID[7] = '\0';
    wavhdr.GUID[8] = '\0';
    wavhdr.GUID[9] = -0x56;
    wavhdr.GUID[10] = '\0';
    wavhdr.GUID[0xb] = '8';
    wavhdr.GUID[0xc] = -0x65;
    wavhdr.GUID[0xd] = 'q';
    lVar12 = 0x28;
    wavhdr.BitsPerSample = (short)iVar9 * 8;
  }
  datahdr.ckSize = lVar11 + 0x18;
  filehdr.ckID[0] = 'r';
  filehdr.ckID[1] = 'i';
  filehdr.ckID[2] = 'f';
  filehdr.ckID[3] = 'f';
  filehdr.ckID[4] = '.';
  filehdr.ckID[5] = -0x6f;
  filehdr.ckID[6] = -0x31;
  filehdr.ckID[7] = '\x11';
  filehdr.ckID[8] = -0x5b;
  filehdr.ckID[9] = -0x2a;
  filehdr.ckID[10] = '(';
  filehdr.ckID[0xb] = -0x25;
  filehdr.ckID[0xc] = '\x04';
  filehdr.ckID[0xd] = -0x3f;
  filehdr.ckID[0xe] = '\0';
  filehdr.ckID[0xf] = '\0';
  filehdr.ckSize = lVar12 + 0x58 + (lVar11 + 7U & 0xfffffffffffffff8);
  filehdr.formType[0] = 'w';
  filehdr.formType[1] = 'a';
  filehdr.formType[2] = 'v';
  filehdr.formType[3] = 'e';
  filehdr.formType[4] = -0xd;
  filehdr.formType[5] = -0x54;
  filehdr.formType[6] = -0x2d;
  filehdr.formType[7] = '\x11';
  filehdr.formType[8] = -0x74;
  filehdr.formType[9] = -0x2f;
  filehdr.formType[10] = '\0';
  filehdr.formType[0xb] = -0x40;
  filehdr.formType[0xc] = 'O';
  filehdr.formType[0xd] = -0x72;
  filehdr.formType[0xe] = -0x25;
  filehdr.formType[0xf] = -0x76;
  fmthdr.ckID[0] = 'f';
  fmthdr.ckID[1] = 'm';
  fmthdr.ckID[2] = 't';
  fmthdr.ckID[3] = ' ';
  fmthdr.ckID[4] = -0xd;
  fmthdr.ckID[5] = -0x54;
  fmthdr.ckID[6] = -0x2d;
  fmthdr.ckID[7] = '\x11';
  fmthdr.ckID[8] = -0x74;
  fmthdr.ckID[9] = -0x2f;
  fmthdr.ckID[10] = '\0';
  fmthdr.ckID[0xb] = -0x40;
  fmthdr.ckID[0xc] = 'O';
  fmthdr.ckID[0xd] = -0x72;
  fmthdr.ckID[0xe] = -0x25;
  fmthdr.ckID[0xf] = -0x76;
  datahdr.ckID[0] = 'd';
  datahdr.ckID[1] = 'a';
  datahdr.ckID[2] = 't';
  datahdr.ckID[3] = 'a';
  datahdr.ckID[4] = -0xd;
  datahdr.ckID[5] = -0x54;
  datahdr.ckID[6] = -0x2d;
  datahdr.ckID[7] = '\x11';
  datahdr.ckID[8] = -0x74;
  datahdr.ckID[9] = -0x2f;
  datahdr.ckID[10] = '\0';
  datahdr.ckID[0xb] = -0x40;
  datahdr.ckID[0xc] = 'O';
  datahdr.ckID[0xd] = -0x72;
  datahdr.ckID[0xe] = -0x25;
  datahdr.ckID[0xf] = -0x76;
  wavhdr.SampleRate = uVar8;
  WavpackNativeToLittleEndian(&filehdr,&DAT_001188c0);
  WavpackNativeToLittleEndian(&fmthdr,&DAT_001188c0);
  WavpackNativeToLittleEndian(&wavhdr,"SSLLSSSSLS");
  WavpackNativeToLittleEndian(&datahdr,&DAT_001188c0);
  iVar6 = DoWriteFile(outfile,&filehdr,0x28,&bcount);
  if ((iVar6 != 0) && (bcount == 0x28)) {
    iVar6 = DoWriteFile(outfile,&fmthdr,0x18,&bcount);
    if ((iVar6 != 0) && (bcount == 0x18)) {
      iVar6 = DoWriteFile(outfile,&wavhdr,local_f0,&bcount);
      if ((iVar6 != 0) && (local_f0 == bcount)) {
        iVar6 = DoWriteFile(outfile,&datahdr,0x18,&bcount);
        if ((iVar6 != 0) && (bcount == 0x18)) {
          iVar6 = 1;
          goto LAB_0010fc6c;
        }
      }
    }
  }
  error_line("can\'t write .W64 data, disk probably full!");
  iVar6 = 0;
LAB_0010fc6c:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Restarted to delay deadcode elimination for space: stack

int ParseCaffHeaderConfig
              (FILE *infile,char *infilename,char *fourcc,WavpackContext *wpc,WavpackConfig *config)

{
  long lVar1;
  double dVar2;
  int iVar3;
  int iVar4;
  int64_t iVar5;
  void *lpBuffer;
  uint *lpBuffer_00;
  long lVar6;
  undefined8 uVar7;
  uint *puVar8;
  ulong uVar9;
  int64_t iVar10;
  char *pcVar11;
  char *pcVar12;
  uint32_t uVar13;
  uint uVar14;
  anon_struct_24_4_3b78efaa *paVar15;
  uint uVar16;
  char cVar17;
  size_t __size;
  uint *puVar18;
  long in_FS_OFFSET;
  bool bVar19;
  char *local_e0;
  char *local_d8;
  uint local_d0;
  uint local_cc;
  uint32_t bcount;
  uint32_t mEditCount;
  CAFFileHeader caf_file_header;
  CAFChunkHeader caf_chunk_header;
  CAFAudioFormat caf_audio_format;
  char formatstr [5];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar5 = DoGetFileSize(infile);
  caf_file_header.mFileType = *(char (*) [4])fourcc;
  iVar3 = DoReadFile(infile,&caf_file_header.mFileVersion,4,&bcount);
  if ((iVar3 == 0) || (bcount != 4)) {
LAB_0010fded:
    iVar3 = 1;
    error_line("%s is not a valid .CAF file!",infilename);
  }
  else if (((*(byte *)((long)&config->qmode + 1) & 2) == 0) &&
          (iVar3 = WavpackAddWrapper(wpc,&caf_file_header,8), iVar3 == 0)) {
LAB_00110048:
    iVar3 = 1;
    uVar7 = WavpackGetErrorMessage(wpc);
    error_line("%s",uVar7);
  }
  else {
    WavpackBigEndianToNative(&caf_file_header,&DAT_00118adc);
    if (caf_file_header.mFileVersion == 1) {
      local_d8 = (char *)0x0;
      local_e0 = (char *)0x0;
      local_cc = 0;
      bVar19 = false;
LAB_0010fe8c:
      while( true ) {
        iVar3 = DoReadFile(infile,&caf_chunk_header,0xc,&bcount);
        if ((iVar3 == 0) || (bcount != 0xc)) goto LAB_0010fded;
        if (((*(byte *)((long)&config->qmode + 1) & 2) == 0) &&
           (iVar3 = WavpackAddWrapper(wpc,&caf_chunk_header,0xc), iVar3 == 0)) goto LAB_00110048;
        WavpackBigEndianToNative(&caf_chunk_header,&DAT_00118ae0);
        iVar10 = caf_chunk_header.mChunkSize;
        if (caf_chunk_header.mChunkType != (char  [4])0x63736564) break;
        if (caf_chunk_header.mChunkSize != 0x20) goto LAB_0010fded;
        iVar3 = DoReadFile(infile,&caf_audio_format,0x20,&bcount);
        if ((iVar3 == 0) || ((ulong)bcount != caf_chunk_header.mChunkSize)) goto LAB_0010fded;
        if (((*(byte *)((long)&config->qmode + 1) & 2) == 0) &&
           (iVar3 = WavpackAddWrapper(wpc,&caf_audio_format), iVar3 == 0)) goto LAB_00110048;
        WavpackBigEndianToNative(&caf_audio_format,&DAT_00118ae8);
        if (debug_logging_mode != 0) {
          _formatstr = CONCAT44((int)(_formatstr >> 0x20),caf_audio_format.mFormatID) &
                       0xffffff00ffffffff;
          error_line("format = %s, flags = %x, sampling rate = %g",caf_audio_format.mSampleRate,
                     formatstr,(ulong)caf_audio_format.mFormatFlags);
          error_line("packet = %d bytes and %d frames",(ulong)caf_audio_format.mBytesPerPacket,
                     (ulong)caf_audio_format.mFramesPerPacket);
          error_line("channels per frame = %d, bits per channel = %d",
                     (ulong)caf_audio_format.mChannelsPerFrame,
                     (ulong)caf_audio_format.mBitsPerChannel);
        }
        if ((((caf_audio_format.mFormatID != (char  [4])0x6d63706c) ||
             (iVar3 = 0, (caf_audio_format.mFormatFlags & 0xfffffffc) != 0)) ||
            (caf_audio_format.mSampleRate < 1.0)) || (16777215.0 < caf_audio_format.mSampleRate)) {
LAB_00110011:
          iVar3 = 1;
          error_line("%s is an unsupported .CAF format!",infilename);
          goto LAB_0010fe05;
        }
        dVar2 = caf_audio_format.mSampleRate;
        if (ABS(caf_audio_format.mSampleRate) < 4503599627370496.0) {
          dVar2 = (double)((ulong)((double)(long)caf_audio_format.mSampleRate -
                                  (double)(-(ulong)(caf_audio_format.mSampleRate <
                                                   (double)(long)caf_audio_format.mSampleRate) &
                                          0x3ff0000000000000)) |
                          (ulong)caf_audio_format.mSampleRate & 0x8000000000000000);
        }
        if (((false) || (caf_audio_format.mSampleRate != dVar2)) ||
           ((0xff < caf_audio_format.mChannelsPerFrame - 1 ||
            (0x1f < caf_audio_format.mBitsPerChannel - 1)))) goto LAB_00110011;
        if (((caf_audio_format.mBitsPerChannel != 0x20) &&
            ((caf_audio_format.mFormatFlags & 1) != 0)) || (caf_audio_format.mFramesPerPacket != 1))
        goto LAB_00110011;
        uVar16 = (uint)((ulong)caf_audio_format.mBytesPerPacket /
                       (ulong)caf_audio_format.mChannelsPerFrame);
        if (((uVar16 < caf_audio_format.mBitsPerChannel + 7 >> 3) || (4 < uVar16)) ||
           (caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame != 0))
        goto LAB_00110011;
        config->num_channels = caf_audio_format.mChannelsPerFrame;
        if ((caf_audio_format.mFormatFlags & 1) != 0) {
          iVar3 = 0x7f;
        }
        config->bytes_per_sample = uVar16;
        config->bits_per_sample = caf_audio_format.mBitsPerChannel;
        config->float_norm_exp = iVar3;
        config->sample_rate = (int)caf_audio_format.mSampleRate;
        if ((caf_audio_format.mFormatFlags & 2) == 0) {
          uVar14 = config->qmode;
          if (uVar16 == 1) {
LAB_00110418:
            config->qmode = uVar14 | 2;
          }
          else {
            config->qmode = uVar14 | 1;
          }
        }
        else if (uVar16 == 1) {
          uVar14 = config->qmode;
          goto LAB_00110418;
        }
        if (debug_logging_mode != 0) {
          uVar16 = config->qmode & 1;
          if (iVar3 == 0x7f) {
            pcVar11 = "big";
            if (uVar16 == 0) {
              pcVar11 = "little";
            }
            error_line("data format: 32-bit %s-endian floating point",pcVar11);
          }
          else {
            pcVar11 = "big";
            if (uVar16 == 0) {
              pcVar11 = "little";
            }
            error_line("data format: %d-bit %s-endian integers stored in %d byte(s)",
                       (ulong)caf_audio_format.mBitsPerChannel,pcVar11,
                       (ulong)caf_audio_format.mBytesPerPacket /
                       (ulong)caf_audio_format.mChannelsPerFrame);
          }
        }
      }
      if (caf_chunk_header.mChunkType != (char  [4])0x6e616863) {
        if (caf_chunk_header.mChunkType == (char  [4])0x61746164) {
          iVar3 = 0;
          iVar4 = DoReadFile(infile,&mEditCount,4,&bcount);
          if ((iVar4 == 0) || (bcount != 4)) {
            error_line("%s is not a valid .CAF file!",infilename);
          }
          else {
            uVar16 = config->qmode;
            if ((uVar16 & 0x200) == 0) {
              iVar4 = WavpackAddWrapper(wpc,&mEditCount,4);
              if (iVar4 == 0) {
                uVar7 = WavpackGetErrorMessage(wpc);
                error_line("%s",uVar7);
                goto LAB_001106d5;
              }
              uVar16 = config->qmode;
            }
            if (((uVar16 & 0x800) == 0) && (caf_chunk_header.mChunkSize != -1)) {
              if ((iVar5 == 0) || (iVar5 - caf_chunk_header.mChunkSize < 0x1000001)) {
                lVar6 = (caf_chunk_header.mChunkSize + -4) /
                        (long)(ulong)caf_audio_format.mBytesPerPacket;
                if ((caf_chunk_header.mChunkSize + -4) %
                    (long)(ulong)caf_audio_format.mBytesPerPacket == 0) {
                  if (lVar6 == 0) {
                    error_line("this .CAF file has no audio samples, probably is corrupt!");
                  }
                  else {
                    if (lVar6 < 0xffffffff00) goto LAB_00110563;
                    error_line("%s has too many samples for WavPack!",infilename);
                  }
                }
                else {
                  error_line(".CAF file %s has an invalid data chunk size, probably is corrupt!",
                             infilename);
                }
              }
              else {
                error_line(".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!",
                           infilename);
              }
            }
            else {
              config->qmode = uVar16 | 0x800;
              if ((iVar5 == 0) || (iVar10 = DoGetFilePosition(infile), iVar10 == -1)) {
                lVar6 = -1;
              }
              else {
                iVar10 = DoGetFilePosition(infile);
                lVar6 = (iVar5 - iVar10) / (long)(ulong)caf_audio_format.mBytesPerPacket;
              }
LAB_00110563:
              if ((((!bVar19) && (config->channel_mask == 0)) && (config->num_channels < 3)) &&
                 ((*(byte *)((long)&config->qmode + 1) & 4) == 0)) {
                config->channel_mask = 5 - config->num_channels;
              }
              iVar4 = WavpackSetConfiguration64(wpc,config,lVar6,local_e0);
              if (iVar4 == 0) goto LAB_00110048;
              if (local_e0 != (char *)0x0) {
                free(local_e0);
              }
              if ((local_cc == 0) && (local_d8 == (char *)0x0)) goto LAB_0010fe05;
              iVar4 = WavpackSetChannelLayout(wpc,local_cc,local_d8);
              if (iVar4 != 0) {
                if (local_d8 != (char *)0x0) {
                  free(local_d8);
                }
                goto LAB_0010fe05;
              }
              error_line("problem with setting channel layout (should not happen)");
            }
          }
LAB_001106d5:
          iVar3 = 1;
          goto LAB_0010fe05;
        }
        if (0x100000 < (ulong)caf_chunk_header.mChunkSize) goto LAB_0010fded;
        lpBuffer = malloc(caf_chunk_header.mChunkSize);
        if (debug_logging_mode != 0) {
          error_line("extra unknown chunk \"%c%c%c%c\" of %d bytes",
                     (ulong)(uint)(int)caf_chunk_header.mChunkType[0],
                     (ulong)(uint)(int)caf_chunk_header.mChunkType[1],
                     (ulong)(uint)(int)caf_chunk_header.mChunkType[2]);
        }
        uVar13 = (uint32_t)iVar10;
        iVar3 = DoReadFile(infile,lpBuffer,uVar13,&bcount);
        if (((iVar3 == 0) || (bcount != uVar13)) ||
           (((*(byte *)((long)&config->qmode + 1) & 2) == 0 &&
            (iVar3 = WavpackAddWrapper(wpc,lpBuffer,iVar10 & 0xffffffff), iVar3 == 0)))) {
          uVar7 = WavpackGetErrorMessage(wpc);
          error_line("%s",uVar7);
          iVar3 = 1;
          free(lpBuffer);
          goto LAB_0010fe05;
        }
        free(lpBuffer);
        goto LAB_0010fe8c;
      }
      if (0x3f4 < caf_chunk_header.mChunkSize - 0xcU) {
        iVar3 = 1;
        error_line("this .CAF file has an invalid \'chan\' chunk!");
        goto LAB_0010fe05;
      }
      if (debug_logging_mode != 0) {
        error_line("\'chan\' chunk is %d bytes",caf_chunk_header.mChunkSize & 0xffffffff);
      }
      iVar10 = caf_chunk_header.mChunkSize;
      lpBuffer_00 = (uint *)malloc(caf_chunk_header.mChunkSize);
      iVar3 = DoReadFile(infile,lpBuffer_00,(uint32_t)iVar10,&bcount);
      if ((iVar3 == 0) || ((ulong)bcount != caf_chunk_header.mChunkSize)) {
        pcVar11 = "%s is not a valid .CAF file!";
      }
      else {
        if (((*(byte *)((long)&config->qmode + 1) & 2) != 0) ||
           (iVar3 = WavpackAddWrapper(wpc,lpBuffer_00), iVar3 != 0)) {
          WavpackBigEndianToNative(lpBuffer_00,&DAT_00118aec);
          iVar3 = debug_logging_mode;
          if ((config->channel_mask != 0) || (uVar16 = config->qmode, (uVar16 & 0x400) != 0)) {
            pcVar11 = "this CAF file already has channel order information!";
LAB_00110a0b:
            iVar3 = 1;
            error_line(pcVar11);
            free(lpBuffer_00);
            goto LAB_0010fe05;
          }
          uVar14 = *lpBuffer_00;
          if (uVar14 == 0) {
            local_d0 = lpBuffer_00[2];
            __size = (size_t)(int)local_d0;
            if ((caf_chunk_header.mChunkSize != __size * 0x14 + 0xc) ||
               (config->num_channels != local_d0)) {
              pcVar11 = "channel descriptions in \'chan\' chunk are the wrong size!";
              goto LAB_00110a0b;
            }
            if ((int)local_d0 < 0x100) {
              puVar18 = lpBuffer_00 + 3;
              local_d8 = (char *)malloc(__size);
              memset(local_d8,-1,__size);
              local_e0 = (char *)malloc((long)(int)(local_d0 + 1));
              if (0 < (int)local_d0) {
                uVar16 = 0;
                puVar8 = puVar18;
                do {
                  uVar16 = uVar16 + 1;
                  WavpackBigEndianToNative(puVar8,&DAT_00118aea);
                  if (debug_logging_mode != 0) {
                    error_line("chan %d --> %d",(ulong)uVar16,(ulong)*puVar8);
                  }
                  puVar8 = puVar8 + 5;
                } while (local_d0 != uVar16);
              }
              cVar17 = '\0';
              uVar16 = 1;
              do {
                puVar8 = puVar18;
                uVar9 = 0;
                if (0 < (int)local_d0) {
                  do {
                    if (*puVar8 == uVar16) {
                      config->channel_mask = config->channel_mask | 1 << ((char)uVar16 - 1U & 0x1f);
                      local_d8[uVar9] = cVar17;
                      cVar17 = cVar17 + '\x01';
                      break;
                    }
                    puVar8 = puVar8 + 5;
                    bVar19 = local_d0 - 1 != uVar9;
                    uVar9 = uVar9 + 1;
                  } while (bVar19);
                }
                uVar16 = uVar16 + 1;
              } while (uVar16 != 0x13);
              iVar3 = 0;
              uVar16 = 0;
              if (0 < (int)local_d0) {
                iVar3 = 0;
                pcVar11 = local_d8;
                do {
                  if (*pcVar11 == -1) {
                    uVar16 = *puVar18;
                    lVar6 = (long)iVar3;
                    iVar3 = iVar3 + 1;
                    pcVar12 = local_e0 + lVar6;
                    if ((uVar16 - 1 < 0xfffffffe) && (uVar16 != 100)) {
                      if (((uVar16 - 0x21 < 0xc) || (uVar16 - 200 < 8)) || (uVar16 - 0x12d < 5)) {
                        uVar14 = uVar16 - 0x50;
                        if (uVar16 < 0x12d) {
                          uVar14 = uVar16;
                        }
                        *pcVar12 = (char)uVar14;
                      }
                      else {
                        error_line("warning: unknown channel descriptions label: %d");
                        *pcVar12 = -1;
                      }
                    }
                    else {
                      *pcVar12 = -1;
                    }
                    *pcVar11 = cVar17;
                    cVar17 = cVar17 + '\x01';
                  }
                  pcVar11 = pcVar11 + 1;
                  puVar18 = puVar18 + 5;
                } while (local_d8 + (ulong)(local_d0 - 1) + 1 != pcVar11);
                uVar9 = 0;
                do {
                  uVar16 = (uint)uVar9;
                  if ((byte)local_d8[uVar9] != uVar16) break;
                  uVar16 = (byte)local_d8[uVar9] + 1;
                  bVar19 = local_d0 - 1 != uVar9;
                  uVar9 = uVar9 + 1;
                } while (bVar19);
              }
              if (local_d0 == uVar16) {
                free(local_d8);
                local_d8 = (char *)0x0;
              }
              else {
                config->qmode = config->qmode | 8;
                local_cc = local_d0;
              }
              if (iVar3 == 0) {
                free(local_e0);
                local_e0 = (char *)0x0;
              }
              else {
                local_e0[iVar3] = '\0';
              }
              if (((debug_logging_mode != 0) &&
                  (error_line("layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS"
                              ,(ulong)*lpBuffer_00,(ulong)(uint)config->channel_mask,
                              (ulong)lpBuffer_00[2]), local_d8 != (char *)0x0)) &&
                 ((int)local_d0 < 9)) {
                _formatstr = 0x3837363534333231;
                if ((int)local_d0 < 1) {
                  local_d0 = 0;
                }
                else {
                  lVar6 = 0;
                  do {
                    formatstr[lVar6] = local_d8[lVar6] + '1';
                    lVar6 = lVar6 + 1;
                  } while ((int)lVar6 < (int)local_d0);
                }
                formatstr[(int)local_d0] = '\0';
                error_line("reordering string = \"%s\"\n",formatstr);
              }
            }
            else {
              error_line("%d channel descriptions is more than we can handle...ignoring!");
            }
          }
          else {
            paVar15 = layouts;
            uVar13 = 0x640001;
            iVar4 = 0;
            if (uVar14 == 0x10000) {
              config->channel_mask = lpBuffer_00[1];
              if (iVar3 != 0) {
                error_line("layout_tag = 0x%08x, so using supplied bitmap of 0x%08x",0x10000);
              }
            }
            else {
              while (paVar15 = paVar15 + 1, uVar14 != uVar13) {
                iVar4 = iVar4 + 1;
                if (iVar4 == 0x2f) {
                  if (debug_logging_mode != 0) {
                    error_line("layout_tag 0x%08x not found in table...all channels unassigned");
                  }
                  goto LAB_00110181;
                }
                uVar13 = paVar15->mChannelLayoutTag;
              }
              uVar14 = layouts[iVar4].mChannelBitmap;
              pcVar11 = layouts[iVar4].mChannelReorder;
              config->channel_mask = uVar14;
              if (pcVar11 != (char *)0x0) {
                local_d8 = strdup(pcVar11);
                config->qmode = uVar16 | 8;
              }
              if (layouts[iVar4].mChannelIdentities != (char *)0x0) {
                local_e0 = strdup(layouts[iVar4].mChannelIdentities);
              }
              local_cc = uVar13;
              if (debug_logging_mode != 0) {
                pcVar11 = "no";
                if (local_d8 != (char *)0x0) {
                  pcVar11 = "yes";
                }
                error_line("layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s"
                           ,(ulong)uVar13,(ulong)uVar14,pcVar11);
              }
            }
          }
LAB_00110181:
          free(lpBuffer_00);
          bVar19 = true;
          goto LAB_0010fe8c;
        }
        infilename = (char *)WavpackGetErrorMessage(wpc);
        pcVar11 = "%s";
      }
      iVar3 = 1;
      error_line(pcVar11,infilename);
      free(lpBuffer_00);
      goto LAB_0010fe05;
    }
    iVar3 = 1;
    error_line("%s: can\'t handle version %d .CAF files!",infilename);
  }
LAB_0010fe05:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int WriteCaffHeader(FILE *outfile,WavpackContext *wpc,int64_t total_samples,int qmode)

{
  char cVar1;
  byte bVar2;
  long lVar3;
  uint32_t uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  uint32_t uVar8;
  int iVar9;
  uint uVar10;
  int iVar11;
  char *__ptr;
  char *pcVar12;
  void *__ptr_00;
  ulong uVar13;
  uint uVar14;
  long in_FS_OFFSET;
  bool bVar15;
  long local_d0;
  uint32_t mEditCount;
  uint32_t bcount;
  CAFChannelLayout caf_channel_layout;
  CAFFileHeader caf_file_header;
  CAFChunkHeader caf_desc_chunk_header;
  CAFChunkHeader caf_chan_chunk_header;
  CAFChunkHeader caf_data_chunk_header;
  undefined4 uStack_7c;
  CAFAudioFormat caf_audio_format;
  
  lVar3 = *(long *)(in_FS_OFFSET + 0x28);
  uVar4 = WavpackGetNumChannels(wpc);
  uVar5 = WavpackGetChannelMask(wpc);
  iVar6 = WavpackGetSampleRate(wpc);
  iVar7 = WavpackGetBytesPerSample(wpc);
  uVar8 = WavpackGetBitsPerSample(wpc);
  iVar9 = WavpackGetFloatNormExp(wpc);
  uVar10 = WavpackGetChannelLayout(wpc,0);
  __ptr = (char *)malloc((long)(int)(uVar4 + 1));
  bVar15 = iVar9 != 0;
  if ((iVar9 != 0x7f) && (bVar15)) {
    iVar6 = 0;
    error_line("can\'t create valid CAFF header for non-normalized floating data!");
    free(__ptr);
    goto LAB_00110d88;
  }
  WavpackGetChannelIdentities(wpc,__ptr);
  if ((int)uVar4 < 1) {
    iVar9 = 0;
  }
  else {
    iVar9 = 0;
    pcVar12 = __ptr;
    do {
      cVar1 = *pcVar12;
      pcVar12 = pcVar12 + 1;
      iVar9 = iVar9 + (uint)(cVar1 != -1);
    } while (__ptr + (ulong)(uVar4 - 1) + 1 != pcVar12);
  }
  builtin_strncpy(caf_file_header.mFileType,"caff",4);
  caf_file_header.mFileVersion = 1;
  caf_file_header.mFileFlags = 0;
  WavpackNativeToBigEndian(&caf_file_header,&DAT_00118adc);
  iVar11 = DoWriteFile(outfile,&caf_file_header,8,&bcount);
  if ((iVar11 != 0) && (bcount == 8)) {
    builtin_strncpy(caf_desc_chunk_header.mChunkType,"desc",4);
    caf_desc_chunk_header.mChunkSize = 0x20;
    WavpackNativeToBigEndian(&caf_desc_chunk_header,&DAT_00118ae0);
    iVar11 = DoWriteFile(outfile,&caf_desc_chunk_header,0xc,&bcount);
    if ((iVar11 != 0) && (bcount == 0xc)) {
      builtin_strncpy(caf_audio_format.mFormatID,"lpcm",4);
      caf_audio_format.mSampleRate = (double)iVar6;
      caf_audio_format.mFramesPerPacket = 1;
      caf_audio_format.mFormatFlags = (uint)bVar15;
      if ((qmode & 1U) == 0) {
        caf_audio_format.mFormatFlags = bVar15 | 2;
      }
      caf_audio_format.mBytesPerPacket = iVar7 * uVar4;
      caf_audio_format.mChannelsPerFrame = uVar4;
      caf_audio_format.mBitsPerChannel = uVar8;
      WavpackNativeToBigEndian(&caf_audio_format,&DAT_00118ae8);
      iVar6 = DoWriteFile(outfile,&caf_audio_format,0x20,&bcount);
      if ((iVar6 != 0) && (bcount == 0x20)) {
        if (uVar10 == 0) {
          if ((int)uVar4 < 3) {
            if (5 - uVar4 != uVar5) goto LAB_00110fb1;
          }
          else if (iVar9 != 0) goto LAB_00110fb1;
        }
        else {
LAB_00110fb1:
          uVar14 = 1;
          uVar8 = 0;
          do {
            uVar8 = (uVar8 + 1) - (uint)((uVar5 & uVar14) == 0);
            uVar14 = uVar14 * 2;
          } while (uVar14 != 0);
          if ((uVar10 & 0xff0000) != 0) {
LAB_001111bf:
            builtin_strncpy(caf_chan_chunk_header.mChunkType,"chan",4);
            caf_chan_chunk_header.mChunkSize = 0xc;
            WavpackNativeToBigEndian(&caf_chan_chunk_header,&DAT_00118ae0);
            iVar6 = DoWriteFile(outfile,&caf_chan_chunk_header,0xc,&bcount);
            if ((iVar6 != 0) && (bcount == 0xc)) {
              if (uVar10 == 0) {
                if (debug_logging_mode != 0) {
                  error_line("writing \"chan\" chunk with UseChannelBitmap tag, bitmap = 0x%08x",
                             (ulong)uVar5);
                }
                caf_channel_layout.mChannelBitmap = uVar5;
                caf_channel_layout.mChannelLayoutTag = 0x10000;
              }
              else {
                if (debug_logging_mode != 0) {
                  error_line("writing \"chan\" chunk with layout tag 0x%08x",(ulong)uVar10);
                }
                caf_channel_layout.mChannelBitmap = 0;
                caf_channel_layout.mChannelLayoutTag = uVar10;
              }
              caf_channel_layout.mNumberChannelDescriptions = 0;
              WavpackNativeToBigEndian(&caf_channel_layout,&DAT_00118aec);
              iVar6 = DoWriteFile(outfile,&caf_channel_layout,0xc,&bcount);
              if ((iVar6 != 0) && (bcount == 0xc)) goto LAB_00110ed7;
            }
            goto LAB_00110d85;
          }
          if (uVar8 == uVar4) {
            if ((qmode & 8U) == 0) goto LAB_001111bf;
            pcVar12 = "yes";
            if (debug_logging_mode != 0) goto LAB_0011100b;
LAB_0011129b:
            __ptr_00 = (void *)0x0;
            if ((int)(uVar10 & 0xff) <= (int)uVar4) {
              __ptr_00 = malloc((long)(int)uVar4);
              uVar13 = 0;
              if (uVar4 != 0) {
                do {
                  *(char *)((long)__ptr_00 + uVar13) = (char)uVar13;
                  bVar15 = uVar13 != uVar4 - 1;
                  uVar13 = uVar13 + 1;
                } while (bVar15);
              }
              WavpackGetChannelLayout(wpc,__ptr_00);
            }
          }
          else {
            if (debug_logging_mode != 0) {
              pcVar12 = "yes";
              if ((qmode & 8U) == 0) {
                pcVar12 = "no";
              }
LAB_0011100b:
              error_line("writing \"chan\" chunk with UseChannelDescriptions tag, bitmap = 0x%08x, reordered = %s"
                         ,(ulong)uVar5,pcVar12);
            }
            __ptr_00 = (void *)0x0;
            if ((qmode & 8U) != 0) goto LAB_0011129b;
          }
          caf_chan_chunk_header.mChunkSize = (long)(int)uVar4 * 0x14 + 0xc;
          builtin_strncpy(caf_chan_chunk_header.mChunkType,"chan",4);
          WavpackNativeToBigEndian(&caf_chan_chunk_header,&DAT_00118ae0);
          iVar9 = DoWriteFile(outfile,&caf_chan_chunk_header,0xc,&bcount);
          iVar6 = 0;
          if ((iVar9 == 0) || (bcount != 0xc)) goto LAB_00110d88;
          caf_channel_layout.mChannelLayoutTag = 0;
          caf_channel_layout.mChannelBitmap = 0;
          caf_channel_layout.mNumberChannelDescriptions = uVar4;
          WavpackNativeToBigEndian(&caf_channel_layout,&DAT_00118aec);
          iVar9 = DoWriteFile(outfile,&caf_channel_layout,0xc,&bcount);
          if ((iVar9 == 0) || (bcount != 0xc)) goto LAB_00110d88;
          if (0 < (int)uVar4) {
            uVar13 = 1;
            do {
              if (__ptr_00 == (void *)0x0) {
                bVar2 = __ptr[uVar13 - 1];
              }
              else {
                bVar2 = __ptr[*(byte *)((long)__ptr_00 + (uVar13 - 1))];
              }
              uVar5 = (uint)bVar2;
              _caf_data_chunk_header = (undefined  [16])0x0;
              if ((((byte)(bVar2 - 1) < 0x12) || ((byte)(bVar2 - 0x21) < 0xc)) ||
                 ((byte)(bVar2 + 0x38) < 8)) {
LAB_00111194:
                stack0xffffffffffffff7c = SUB1612((undefined  [16])0x0,4);
                caf_data_chunk_header.mChunkType[0] = (char)uVar5;
                caf_data_chunk_header.mChunkType[1] = (char)(uVar5 >> 8);
                caf_data_chunk_header.mChunkType[2] = (char)(uVar5 >> 0x10);
                caf_data_chunk_header.mChunkType[3] = (char)(uVar5 >> 0x18);
              }
              else if ((byte)(bVar2 + 0x23) < 5) {
                uVar5 = uVar5 + 0x50;
                goto LAB_00111194;
              }
              if (debug_logging_mode != 0) {
                error_line("chan %d --> %d",uVar13 & 0xffffffff,
                           (ulong)(uint)caf_data_chunk_header.mChunkType);
              }
              WavpackNativeToBigEndian(&caf_data_chunk_header,&DAT_00118aea);
              iVar9 = DoWriteFile(outfile,&caf_data_chunk_header,0x14,&bcount);
              if ((iVar9 == 0) || (bcount != 0x14)) goto LAB_00110d88;
              uVar13 = uVar13 + 1;
            } while (uVar13 != (ulong)(uVar4 - 1) + 2);
          }
          if (__ptr_00 != (void *)0x0) {
            free(__ptr_00);
          }
        }
LAB_00110ed7:
        local_d0 = total_samples;
        if (total_samples != -1) {
          local_d0 = iVar7 * total_samples * (long)(int)uVar4 + 4;
        }
        caf_data_chunk_header.mChunkSize = local_d0;
        builtin_strncpy(caf_data_chunk_header.mChunkType,"data",4);
        WavpackNativeToBigEndian(&caf_data_chunk_header,&DAT_00118ae0);
        iVar6 = DoWriteFile(outfile,&caf_data_chunk_header,0xc,&bcount);
        if ((iVar6 != 0) && (bcount == 0xc)) {
          mEditCount = 0;
          WavpackNativeToBigEndian(&mEditCount,&DAT_0011845f);
          iVar6 = DoWriteFile(outfile,&mEditCount,4,&bcount);
          if ((iVar6 != 0) && (bcount == 4)) {
            iVar6 = 1;
            free(__ptr);
            goto LAB_00110d88;
          }
        }
      }
    }
  }
LAB_00110d85:
  iVar6 = 0;
LAB_00110d88:
  if (lVar3 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar6;
}



int ParseDsdiffHeaderConfig
              (FILE *infile,char *infilename,char *fourcc,WavpackContext *wpc,WavpackConfig *config)

{
  long lVar1;
  ushort uVar2;
  int iVar3;
  int iVar4;
  int64_t iVar5;
  void *lpBuffer;
  byte *pbVar6;
  undefined8 uVar7;
  long lVar8;
  long lVar9;
  long lVar10;
  size_t __size;
  byte *pbVar11;
  byte *pbVar12;
  byte *pbVar13;
  char *pcVar14;
  byte *pbVar15;
  uint uVar16;
  uint uVar17;
  long in_FS_OFFSET;
  bool bVar18;
  bool bVar19;
  bool bVar20;
  byte bVar21;
  uint16_t numChannels;
  uint32_t bcount;
  uint32_t version;
  DFFChunkHeader dff_chunk_header;
  DFFFileHeader dff_file_header;
  
  bVar21 = 0;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar5 = DoGetFileSize(infile);
  dff_file_header.ckID = *(char (*) [4])fourcc;
  iVar3 = DoReadFile(infile,&dff_file_header.ckDataSize,0xc,&bcount);
  if (iVar3 != 0) {
    bVar18 = bcount < 0xc;
    bVar20 = bcount == 0xc;
    if (bVar20) {
      lVar8 = 4;
      pcVar14 = dff_file_header.formType;
      pbVar6 = &DAT_00115584;
      do {
        if (lVar8 == 0) break;
        lVar8 = lVar8 + -1;
        bVar18 = (byte)*pcVar14 < *pbVar6;
        bVar20 = *pcVar14 == *pbVar6;
        pcVar14 = pcVar14 + (ulong)bVar21 * -2 + 1;
        pbVar6 = pbVar6 + (ulong)bVar21 * -2 + 1;
      } while (bVar20);
      if ((!bVar18 && !bVar20) == bVar18) {
        if (((*(byte *)((long)&config->qmode + 1) & 2) == 0) &&
           (iVar3 = WavpackAddWrapper(wpc,&dff_file_header,0x10), iVar3 == 0)) {
LAB_00111c10:
          iVar3 = 1;
          uVar7 = WavpackGetErrorMessage(wpc);
          error_line("%s",uVar7);
        }
        else {
          WavpackBigEndianToNative(&dff_file_header,&DAT_001191cd);
          if ((iVar5 == 0) ||
             ((((*(byte *)((long)&config->qmode + 1) & 8) != 0 ||
               (dff_file_header.ckDataSize + 1U < 2)) || (dff_file_header.ckDataSize + 0xc == iVar5)
              ))) {
            if (debug_logging_mode != 0) {
              error_line("file header indicated length = %lld",dff_file_header.ckDataSize);
            }
LAB_001114d8:
            do {
              while( true ) {
                iVar3 = DoReadFile(infile,&dff_chunk_header,0xc,&bcount);
                if ((iVar3 == 0) || (bcount != 0xc)) goto LAB_001113fe;
                if (((*(byte *)((long)&config->qmode + 1) & 2) == 0) &&
                   (iVar3 = WavpackAddWrapper(wpc,&dff_chunk_header,0xc), iVar3 == 0))
                goto LAB_00111c10;
                WavpackBigEndianToNative(&dff_chunk_header,&DAT_00118ae0);
                if (debug_logging_mode != 0) {
                  error_line("chunk header indicated length = %lld",
                             CONCAT44(dff_chunk_header.ckDataSize._4_4_,
                                      (int)dff_chunk_header.ckDataSize));
                }
                __size = CONCAT44(dff_chunk_header.ckDataSize._4_4_,(int)dff_chunk_header.ckDataSize
                                 );
                if (CONCAT13(dff_chunk_header.ckID[3],
                             CONCAT12(dff_chunk_header.ckID[2],
                                      CONCAT11(dff_chunk_header.ckID[1],dff_chunk_header.ckID[0])))
                    != 0x52455646) break;
                if (__size != 4) {
LAB_00111ca0:
                  error_line("%s is not a valid .DFF file!",infilename);
                  goto LAB_00111bf0;
                }
                iVar3 = DoReadFile(infile,&version,4,&bcount);
                if ((iVar3 == 0) || (bcount != 4)) goto LAB_00111ca0;
                if (((*(byte *)((long)&config->qmode + 1) & 2) == 0) &&
                   (iVar3 = WavpackAddWrapper(wpc,&version,4), iVar3 == 0)) {
                  uVar7 = WavpackGetErrorMessage(wpc);
                  error_line("%s",uVar7);
                  goto LAB_00111bf0;
                }
                WavpackBigEndianToNative(&version,&DAT_0011845f);
                if (debug_logging_mode != 0) {
                  error_line("dsdiff file version = 0x%08x",(ulong)version);
                }
              }
              if (CONCAT13(dff_chunk_header.ckID[3],
                           CONCAT12(dff_chunk_header.ckID[2],
                                    CONCAT11(dff_chunk_header.ckID[1],dff_chunk_header.ckID[0]))) !=
                  0x504f5250) {
                if (CONCAT13(dff_chunk_header.ckID[3],
                             CONCAT12(dff_chunk_header.ckID[2],
                                      CONCAT11(dff_chunk_header.ckID[1],dff_chunk_header.ckID[0])))
                    == 0x20445344) {
                  iVar3 = 0;
                  lVar8 = (long)__size / (long)config->num_channels;
                  if (debug_logging_mode != 0) {
                    error_line("setting configuration with %lld samples",lVar8);
                  }
                  iVar4 = WavpackSetConfiguration64(wpc,config,lVar8,0);
                  if (iVar4 == 0) {
                    uVar7 = WavpackGetErrorMessage(wpc);
                    error_line("%s: %s",infilename,uVar7);
LAB_00111bf0:
                    iVar3 = 1;
                  }
                  goto LAB_00111417;
                }
                uVar16 = (int)dff_chunk_header.ckDataSize + 1U & 0xfffffffe;
                if (0x400000 < uVar16) goto LAB_001113fe;
                lpBuffer = malloc((long)(int)uVar16);
                if (debug_logging_mode != 0) {
                  error_line("extra unknown chunk \"%c%c%c%c\" of %d bytes",
                             (ulong)(uint)(int)dff_chunk_header.ckID[0],
                             (ulong)(uint)(int)dff_chunk_header.ckID[1],
                             (ulong)(uint)(int)dff_chunk_header.ckID[2],
                             (ulong)(uint)(int)dff_chunk_header.ckID[3],__size);
                }
                iVar3 = DoReadFile(infile,lpBuffer,uVar16,&bcount);
                if (((iVar3 == 0) || (uVar16 != bcount)) ||
                   (((*(byte *)((long)&config->qmode + 1) & 2) == 0 &&
                    (iVar3 = WavpackAddWrapper(wpc,lpBuffer,uVar16), iVar3 == 0)))) {
                  iVar3 = 1;
                  uVar7 = WavpackGetErrorMessage(wpc);
                  error_line("%s",uVar7);
                  free(lpBuffer);
                  goto LAB_00111417;
                }
                free(lpBuffer);
                goto LAB_001114d8;
              }
              if (0x3fc < __size - 4) goto LAB_001113fe;
              if (debug_logging_mode != 0) {
                error_line("got PROP chunk of %d bytes total",(int)dff_chunk_header.ckDataSize);
                __size = CONCAT44(dff_chunk_header.ckDataSize._4_4_,(int)dff_chunk_header.ckDataSize
                                 );
              }
              pbVar6 = (byte *)malloc(__size);
              iVar3 = DoReadFile(infile,pbVar6,(uint32_t)__size,&bcount);
              if ((iVar3 == 0) ||
                 ((ulong)bcount !=
                  CONCAT44(dff_chunk_header.ckDataSize._4_4_,(int)dff_chunk_header.ckDataSize))) {
                pcVar14 = "%s is not a valid .DFF file!";
LAB_00111880:
                error_line(pcVar14,infilename);
                iVar3 = 1;
                free(pbVar6);
                goto LAB_00111417;
              }
              bVar18 = (*(byte *)((long)&config->qmode + 1) & 2) == 0;
              if (bVar18) {
                iVar3 = WavpackAddWrapper(wpc,pbVar6);
                bVar18 = iVar3 == 0;
                if (bVar18) {
                  infilename = (char *)WavpackGetErrorMessage(wpc);
                  pcVar14 = "%s";
                  goto LAB_00111880;
                }
              }
              bVar20 = false;
              lVar8 = 4;
              pbVar11 = pbVar6;
              pbVar12 = &DAT_001191f8;
              do {
                if (lVar8 == 0) break;
                lVar8 = lVar8 + -1;
                bVar20 = *pbVar11 < *pbVar12;
                bVar18 = *pbVar11 == *pbVar12;
                pbVar11 = pbVar11 + (ulong)bVar21 * -2 + 1;
                pbVar12 = pbVar12 + (ulong)bVar21 * -2 + 1;
              } while (bVar18);
              if ((!bVar20 && !bVar18) == bVar20) {
                lVar8 = CONCAT44(dff_chunk_header.ckDataSize._4_4_,(int)dff_chunk_header.ckDataSize)
                ;
                if (lVar8 - 4U < 0xc) {
                  uVar16 = config->qmode;
                }
                else {
                  uVar17 = 0;
                  pbVar11 = pbVar6 + 4;
                  do {
                    uVar7 = *(undefined8 *)pbVar11;
                    pbVar12 = pbVar11 + 0xc;
                    dff_chunk_header.ckID[0] = (char)uVar7;
                    dff_chunk_header.ckID[1] = (char)((ulong)uVar7 >> 8);
                    dff_chunk_header.ckID[2] = (char)((ulong)uVar7 >> 0x10);
                    dff_chunk_header.ckID[3] = (char)((ulong)uVar7 >> 0x18);
                    dff_chunk_header.ckDataSize._0_4_ = (int)((ulong)uVar7 >> 0x20);
                    dff_chunk_header.ckDataSize._4_4_ = *(undefined4 *)(pbVar11 + 8);
                    WavpackBigEndianToNative(&dff_chunk_header,&DAT_00118ae0);
                    lVar10 = CONCAT44(dff_chunk_header.ckDataSize._4_4_,
                                      (int)dff_chunk_header.ckDataSize);
                    if ((lVar10 < 1) || ((long)(pbVar6 + (lVar8 - (long)pbVar12)) < lVar10)) {
LAB_00111bd0:
                      error_line("%s is not a valid .DFF file!",infilename);
                      free(pbVar6);
                      goto LAB_00111bf0;
                    }
                    if ((CONCAT13(dff_chunk_header.ckID[3],
                                  CONCAT12(dff_chunk_header.ckID[2],
                                           CONCAT11(dff_chunk_header.ckID[1],
                                                    dff_chunk_header.ckID[0]))) == 0x20205346) &&
                       (lVar10 == 4)) {
                      version = *(uint32_t *)(pbVar11 + 0xc);
                      WavpackBigEndianToNative(&version,&DAT_0011845f);
                      pbVar12 = pbVar12 + CONCAT44(dff_chunk_header.ckDataSize._4_4_,
                                                   (int)dff_chunk_header.ckDataSize);
                      if (debug_logging_mode != 0) {
                        error_line("got sample rate of %u Hz",(ulong)version);
                      }
                    }
                    else if ((lVar10 == 1) ||
                            (CONCAT13(dff_chunk_header.ckID[3],
                                      CONCAT12(dff_chunk_header.ckID[2],
                                               CONCAT11(dff_chunk_header.ckID[1],
                                                        dff_chunk_header.ckID[0]))) != 0x4c4e4843))
                    {
                      bVar18 = CONCAT13(dff_chunk_header.ckID[3],
                                        CONCAT12(dff_chunk_header.ckID[2],
                                                 CONCAT11(dff_chunk_header.ckID[1],
                                                          dff_chunk_header.ckID[0]))) == 0x52504d43;
                      if ((lVar10 < 4) || (bVar20 = false, !bVar18)) {
                        if (debug_logging_mode != 0) {
                          error_line("got PROP/SND chunk type \"%c%c%c%c\" of %d bytes",
                                     (ulong)(uint)(int)dff_chunk_header.ckID[0],
                                     (ulong)(uint)(int)dff_chunk_header.ckID[1],
                                     (ulong)(uint)(int)dff_chunk_header.ckID[2],
                                     (ulong)(uint)(int)dff_chunk_header.ckID[3]);
                          lVar10 = CONCAT44(dff_chunk_header.ckDataSize._4_4_,
                                            (int)dff_chunk_header.ckDataSize);
                        }
                      }
                      else {
                        lVar9 = 4;
                        pbVar13 = pbVar12;
                        pbVar15 = &DAT_00115584;
                        do {
                          if (lVar9 == 0) break;
                          lVar9 = lVar9 + -1;
                          bVar20 = *pbVar13 < *pbVar15;
                          bVar18 = *pbVar13 == *pbVar15;
                          pbVar13 = pbVar13 + (ulong)bVar21 * -2 + 1;
                          pbVar15 = pbVar15 + (ulong)bVar21 * -2 + 1;
                        } while (bVar18);
                        if ((!bVar20 && !bVar18) != bVar20) {
                          error_line("DSDIFF files must be uncompressed, not \"%c%c%c%c\"!",
                                     (ulong)(uint)(int)(char)pbVar11[0xc],
                                     (ulong)(uint)(int)(char)pbVar11[0xd],
                                     (ulong)(uint)(int)(char)pbVar11[0xe],
                                     (ulong)(uint)(int)(char)pbVar11[0xf]);
                          free(pbVar6);
                          goto LAB_00111bf0;
                        }
                      }
                      pbVar12 = pbVar12 + lVar10;
                    }
                    else {
                      numChannels = *(uint16_t *)(pbVar11 + 0xc);
                      WavpackBigEndianToNative(&numChannels,&DAT_001192a3);
                      pbVar12 = pbVar11 + 0xe;
                      iVar3 = (int)dff_chunk_header.ckDataSize + 1;
                      if (-1 < (int)dff_chunk_header.ckDataSize + -2) {
                        iVar3 = (int)dff_chunk_header.ckDataSize + -2;
                      }
                      if ((numChannels == 0) || (uVar2 = (ushort)(iVar3 >> 2), numChannels < uVar2))
                      goto LAB_00111bd0;
                      bVar18 = false;
                      bVar20 = uVar2 == 0;
                      iVar3 = debug_logging_mode;
                      if (!bVar20) {
                        do {
                          lVar10 = 4;
                          pbVar13 = pbVar12;
                          pbVar15 = &DAT_00119220;
                          do {
                            if (lVar10 == 0) break;
                            lVar10 = lVar10 + -1;
                            bVar18 = *pbVar13 < *pbVar15;
                            bVar20 = *pbVar13 == *pbVar15;
                            pbVar13 = pbVar13 + (ulong)bVar21 * -2 + 1;
                            pbVar15 = pbVar15 + (ulong)bVar21 * -2 + 1;
                          } while (bVar20);
                          bVar19 = false;
                          bVar18 = (!bVar18 && !bVar20) == bVar18;
                          if (bVar18) {
LAB_00111b30:
                            uVar17 = uVar17 | 1;
                          }
                          else {
                            lVar10 = 4;
                            pbVar13 = pbVar12;
                            pbVar15 = &DAT_00119225;
                            do {
                              if (lVar10 == 0) break;
                              lVar10 = lVar10 + -1;
                              bVar19 = *pbVar13 < *pbVar15;
                              bVar18 = *pbVar13 == *pbVar15;
                              pbVar13 = pbVar13 + (ulong)bVar21 * -2 + 1;
                              pbVar15 = pbVar15 + (ulong)bVar21 * -2 + 1;
                            } while (bVar18);
                            bVar20 = false;
                            bVar18 = (!bVar19 && !bVar18) == bVar19;
                            if (bVar18) goto LAB_00111b30;
                            lVar10 = 4;
                            pbVar13 = pbVar12;
                            pbVar15 = &DAT_0011922a;
                            do {
                              if (lVar10 == 0) break;
                              lVar10 = lVar10 + -1;
                              bVar20 = *pbVar13 < *pbVar15;
                              bVar18 = *pbVar13 == *pbVar15;
                              pbVar13 = pbVar13 + (ulong)bVar21 * -2 + 1;
                              pbVar15 = pbVar15 + (ulong)bVar21 * -2 + 1;
                            } while (bVar18);
                            bVar19 = false;
                            bVar18 = (!bVar20 && !bVar18) == bVar20;
                            if (bVar18) {
LAB_00111b70:
                              uVar17 = uVar17 | 2;
                            }
                            else {
                              lVar10 = 4;
                              pbVar13 = pbVar12;
                              pbVar15 = &DAT_0011922f;
                              do {
                                if (lVar10 == 0) break;
                                lVar10 = lVar10 + -1;
                                bVar19 = *pbVar13 < *pbVar15;
                                bVar18 = *pbVar13 == *pbVar15;
                                pbVar13 = pbVar13 + (ulong)bVar21 * -2 + 1;
                                pbVar15 = pbVar15 + (ulong)bVar21 * -2 + 1;
                              } while (bVar18);
                              bVar20 = false;
                              bVar18 = (!bVar19 && !bVar18) == bVar19;
                              if (bVar18) goto LAB_00111b70;
                              lVar10 = 4;
                              pbVar13 = pbVar12;
                              pbVar15 = &DAT_00119234;
                              do {
                                if (lVar10 == 0) break;
                                lVar10 = lVar10 + -1;
                                bVar20 = *pbVar13 < *pbVar15;
                                bVar18 = *pbVar13 == *pbVar15;
                                pbVar13 = pbVar13 + (ulong)bVar21 * -2 + 1;
                                pbVar15 = pbVar15 + (ulong)bVar21 * -2 + 1;
                              } while (bVar18);
                              bVar19 = false;
                              bVar18 = (!bVar20 && !bVar18) == bVar20;
                              if (bVar18) {
                                uVar17 = uVar17 | 0x10;
                              }
                              else {
                                lVar10 = 4;
                                pbVar13 = pbVar12;
                                pbVar15 = &DAT_00119239;
                                do {
                                  if (lVar10 == 0) break;
                                  lVar10 = lVar10 + -1;
                                  bVar19 = *pbVar13 < *pbVar15;
                                  bVar18 = *pbVar13 == *pbVar15;
                                  pbVar13 = pbVar13 + (ulong)bVar21 * -2 + 1;
                                  pbVar15 = pbVar15 + (ulong)bVar21 * -2 + 1;
                                } while (bVar18);
                                bVar20 = false;
                                bVar18 = (!bVar19 && !bVar18) == bVar19;
                                if (bVar18) {
                                  uVar17 = uVar17 | 0x20;
                                }
                                else {
                                  lVar10 = 4;
                                  pbVar13 = pbVar12;
                                  pbVar15 = &DAT_0011923e;
                                  do {
                                    if (lVar10 == 0) break;
                                    lVar10 = lVar10 + -1;
                                    bVar20 = *pbVar13 < *pbVar15;
                                    bVar18 = *pbVar13 == *pbVar15;
                                    pbVar13 = pbVar13 + (ulong)bVar21 * -2 + 1;
                                    pbVar15 = pbVar15 + (ulong)bVar21 * -2 + 1;
                                  } while (bVar18);
                                  bVar19 = false;
                                  bVar18 = (!bVar20 && !bVar18) == bVar20;
                                  if (bVar18) {
                                    uVar17 = uVar17 | 4;
                                  }
                                  else {
                                    lVar10 = 4;
                                    pbVar13 = pbVar12;
                                    pbVar15 = &DAT_00119243;
                                    do {
                                      if (lVar10 == 0) break;
                                      lVar10 = lVar10 + -1;
                                      bVar19 = *pbVar13 < *pbVar15;
                                      bVar18 = *pbVar13 == *pbVar15;
                                      pbVar13 = pbVar13 + (ulong)bVar21 * -2 + 1;
                                      pbVar15 = pbVar15 + (ulong)bVar21 * -2 + 1;
                                    } while (bVar18);
                                    if ((!bVar19 && !bVar18) == bVar19) {
                                      uVar17 = uVar17 | 8;
                                    }
                                    else if (iVar3 != 0) {
                                      error_line("undefined channel ID %c%c%c%c",
                                                 (ulong)(uint)(int)(char)*pbVar12,
                                                 (ulong)(uint)(int)(char)pbVar12[1],
                                                 (ulong)(uint)(int)(char)pbVar12[2],
                                                 (ulong)(uint)(int)(char)pbVar12[3]);
                                      iVar3 = debug_logging_mode;
                                    }
                                  }
                                }
                              }
                            }
                          }
                          pbVar12 = pbVar12 + 4;
                          bVar18 = pbVar11 + (ulong)(ushort)(uVar2 - 1) * 4 + 0x12 < pbVar12;
                          bVar20 = pbVar11 + (ulong)(ushort)(uVar2 - 1) * 4 + 0x12 == pbVar12;
                        } while (!bVar20);
                        pbVar12 = pbVar11 + (ulong)(ushort)(uVar2 - 1) * 4 + 0x12;
                      }
                      if (iVar3 != 0) {
                        error_line("%d channels, mask = 0x%08x",(ulong)numChannels,(ulong)uVar17);
                      }
                    }
                    pbVar11 = pbVar12;
                  } while ((byte *)0xb < pbVar6 + (lVar8 - (long)pbVar12));
                  if ((short)uVar17 == 0) {
                    uVar16 = config->qmode;
                  }
                  else {
                    if ((config->channel_mask != 0) ||
                       (uVar16 = config->qmode, (uVar16 & 0x400) != 0)) {
                      error_line("this DSDIFF file already has channel order information!");
                      free(pbVar6);
                      goto LAB_00111bf0;
                    }
                    config->channel_mask = uVar17;
                  }
                }
                config->bits_per_sample = 8;
                config->bytes_per_sample = 1;
                config->qmode = uVar16 | 0x20;
                config->num_channels = (uint)numChannels;
                config->sample_rate = version >> 3;
              }
              else if (debug_logging_mode != 0) {
                error_line("got unknown PROP chunk type \"%c%c%c%c\" of %d bytes",
                           (ulong)(uint)(int)(char)*pbVar6,(ulong)(uint)(int)(char)pbVar6[1],
                           (ulong)(uint)(int)(char)pbVar6[2],(ulong)(uint)(int)(char)pbVar6[3],
                           CONCAT44(dff_chunk_header.ckDataSize._4_4_,
                                    (int)dff_chunk_header.ckDataSize));
              }
              free(pbVar6);
            } while( true );
          }
          iVar3 = 1;
          error_line("%s is not a valid .DFF file (by total size)!",infilename);
        }
        goto LAB_00111417;
      }
    }
  }
LAB_001113fe:
  iVar3 = 1;
  error_line("%s is not a valid .DFF file!",infilename);
LAB_00111417:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar3;
}



int WriteDsdiffHeader(FILE *outfile,WavpackContext *wpc,int64_t total_samples,int qmode)

{
  long lVar1;
  uint uVar2;
  int iVar3;
  uint32_t nNumberOfBytesToWrite;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  undefined4 *lpBuffer;
  undefined4 *puVar8;
  undefined4 *puVar9;
  undefined4 *puVar10;
  ulong uVar11;
  size_t __size;
  long in_FS_OFFSET;
  uint32_t bcount;
  DFFChunkHeader data_header;
  DFFChannelsHeader chan_header;
  DFFFileHeader file_header;
  DFFFileHeader prop_header;
  DFFVersionChunk ver_chunk;
  DFFSampleRateChunk fs_chunk;
  DFFCompressionHeader cmpr_header;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  uVar2 = WavpackGetChannelMask(wpc);
  iVar3 = WavpackGetNumChannels(wpc);
  if (debug_logging_mode != 0) {
    error_line("WriteDsdiffHeader (), total samples = %lld, qmode = 0x%02x\n",total_samples,
               (ulong)(uint)qmode);
  }
  nNumberOfBytesToWrite = iVar3 * 4;
  __size = (size_t)(int)nNumberOfBytesToWrite;
  lpBuffer = (undefined4 *)malloc(__size);
  if (lpBuffer == (undefined4 *)0x0) {
    error_line("can\'t allocate memory!");
    iVar3 = 0;
  }
  else {
    if (0 < iVar3) {
      puVar10 = (undefined4 *)&DAT_0011922a;
      puVar9 = (undefined4 *)&DAT_00119220;
      if (2 < iVar3) {
        puVar10 = (undefined4 *)&DAT_0011922f;
        puVar9 = (undefined4 *)&DAT_00119225;
      }
      uVar11 = 0;
      uVar4 = 1;
      puVar8 = lpBuffer;
LAB_00111f21:
      if (uVar4 == 0) goto LAB_00112181;
      do {
        if ((uVar2 & uVar4) == 0) {
          do {
            uVar5 = uVar4;
            uVar6 = uVar5 * 2;
            if (uVar6 == 0) {
              uVar4 = 0;
              goto LAB_00111f52;
            }
            uVar4 = uVar6;
          } while ((uVar2 & uVar6) == 0);
          uVar5 = uVar5 * 4;
LAB_001123ce:
          uVar4 = uVar5;
          if ((uVar6 & 2) == 0) {
            if ((uVar6 & 4) == 0) {
              if ((uVar6 & 8) == 0) goto LAB_00111f52;
              *puVar8 = 0x2045464c;
            }
            else {
              *puVar8 = 0x20202043;
            }
          }
          else {
            *puVar8 = *puVar10;
          }
        }
        else {
          uVar5 = uVar4 * 2;
          uVar6 = uVar4;
          if ((uVar4 & 1) == 0) goto LAB_001123ce;
          *puVar8 = *puVar9;
          uVar4 = uVar4 * 2;
        }
        while( true ) {
          puVar8 = puVar8 + 1;
          if (lpBuffer + (ulong)(iVar3 - 1) + 1 == puVar8) goto LAB_00111f70;
          if (uVar4 != 0) break;
LAB_00112181:
          uVar6 = 0;
LAB_00112184:
          if ((uVar6 & 0x20) == 0) {
            *(undefined *)puVar8 = 0x43;
            *(char *)((long)puVar8 + 1) = (char)(uVar11 / 100) + '0';
            *(char *)((long)puVar8 + 2) =
                 (char)((uint)((int)uVar11 + (int)(uVar11 / 100) * -100) / 10) + '0';
            *(char *)((long)puVar8 + 3) = (char)uVar11 + (char)(uVar11 / 10) * -10 + '0';
            uVar11 = (ulong)((int)uVar11 + 1);
          }
          else {
            *puVar8 = 0x20205352;
          }
        }
      } while( true );
    }
LAB_00111f70:
    builtin_strncpy(file_header.ckID,"FRM8",4);
    builtin_strncpy(file_header.formType,"DSD ",4);
    builtin_strncpy(prop_header.ckID,"PROP",4);
    builtin_strncpy(prop_header.formType,"SND ",4);
    builtin_strncpy(ver_chunk.ckID,"FVER",4);
    file_header.ckDataSize = __size + 0x6e + (iVar3 * total_samples + 1U & 0xfffffffffffffffe);
    ver_chunk.ckDataSize = 4;
    prop_header.ckDataSize = __size + 0x42;
    ver_chunk.version = 0x1050000;
    builtin_strncpy(fs_chunk.ckID,"FS  ",4);
    fs_chunk.ckDataSize = 4;
    iVar7 = WavpackGetSampleRate(wpc);
    fs_chunk.sampleRate = iVar7 << 3;
    chan_header.numChannels = (uint16_t)iVar3;
    builtin_strncpy(chan_header.ckID,"CHNL",4);
    builtin_strncpy(cmpr_header.ckID,"CMPR",4);
    cmpr_header.ckDataSize = 0x14;
    builtin_strncpy(cmpr_header.compressionType,"DSD ",4);
    builtin_strncpy(data_header.ckID,"DSD ",4);
    data_header.ckDataSize = iVar3 * total_samples;
    chan_header.ckDataSize = __size + 2;
    WavpackNativeToBigEndian(&file_header,&DAT_001191cd);
    WavpackNativeToBigEndian(&ver_chunk,&DAT_0011929d);
    WavpackNativeToBigEndian(&prop_header,&DAT_001191cd);
    WavpackNativeToBigEndian(&fs_chunk,&DAT_0011929d);
    WavpackNativeToBigEndian(&chan_header,&DAT_001192a1);
    WavpackNativeToBigEndian(&cmpr_header,&DAT_001191cd);
    WavpackNativeToBigEndian(&data_header,&DAT_00118ae0);
    iVar3 = DoWriteFile(outfile,&file_header,0x10,&bcount);
    if (((((((iVar3 == 0) || (bcount != 0x10)) ||
           (iVar3 = DoWriteFile(outfile,&ver_chunk,0x10,&bcount), iVar3 == 0)) ||
          ((bcount != 0x10 || (iVar3 = DoWriteFile(outfile,&prop_header,0x10,&bcount), iVar3 == 0)))
          ) || ((bcount != 0x10 ||
                ((iVar3 = DoWriteFile(outfile,&fs_chunk,0x10,&bcount), iVar3 == 0 ||
                 (bcount != 0x10)))))) ||
        (iVar3 = DoWriteFile(outfile,&chan_header,0xe,&bcount), iVar3 == 0)) ||
       (((((bcount != 0xe ||
           (iVar3 = DoWriteFile(outfile,lpBuffer,nNumberOfBytesToWrite,&bcount), iVar3 == 0)) ||
          (nNumberOfBytesToWrite != bcount)) ||
         (((iVar3 = DoWriteFile(outfile,&cmpr_header,0x10,&bcount), iVar3 == 0 || (bcount != 0x10))
          || ((iVar3 = DoWriteFile(outfile,&DAT_001192a5,0x10,&bcount), iVar3 == 0 ||
              ((bcount != 0x10 ||
               (iVar3 = DoWriteFile(outfile,&data_header,0xc,&bcount), iVar3 == 0)))))))) ||
        (bcount != 0xc)))) {
      error_line("can\'t write .DSF data, disk probably full!");
      free(lpBuffer);
      iVar3 = 0;
    }
    else {
      free(lpBuffer);
      iVar3 = 1;
    }
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_00111f52:
  if ((uVar6 & 0x10) == 0) goto LAB_00112184;
  *puVar8 = 0x2020534c;
  puVar8 = puVar8 + 1;
  if (lpBuffer + (ulong)(iVar3 - 1) + 1 == puVar8) goto LAB_00111f70;
  goto LAB_00111f21;
}



int ParseDsfHeaderConfig
              (FILE *infile,char *infilename,char *fourcc,WavpackContext *wpc,WavpackConfig *config)

{
  long lVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int64_t iVar5;
  long lVar6;
  undefined8 uVar7;
  long lVar8;
  long in_FS_OFFSET;
  uint32_t bcount;
  DSFChunkHeader chunk_header;
  DSFFileChunk file_chunk;
  DSFFormatChunk format_chunk;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar5 = DoGetFileSize(infile);
  file_chunk.ckID = *(char (*) [4])fourcc;
  iVar2 = DoReadFile(infile,&file_chunk.ckSize,0x18,&bcount);
  if ((iVar2 != 0) && (bcount == 0x18)) {
    if ((*(byte *)((long)&config->qmode + 1) & 2) == 0) {
      iVar2 = WavpackAddWrapper(wpc,&file_chunk,0x1c);
      if (iVar2 != 0) goto LAB_001124e1;
LAB_00112588:
      iVar2 = 1;
      uVar7 = WavpackGetErrorMessage(wpc);
      error_line("%s",uVar7);
      goto LAB_001124a0;
    }
LAB_001124e1:
    WavpackLittleEndianToNative(&file_chunk,&DAT_001194e8);
    if (debug_logging_mode != 0) {
      error_line("file header lengths = %lld, %lld, %lld",file_chunk.ckSize,file_chunk.fileSize,
                 file_chunk.metaOffset);
    }
    if ((iVar5 != 0) && ((*(byte *)((long)&config->qmode + 1) & 8) == 0)) {
      if ((1 < file_chunk.fileSize + 1U) && (file_chunk.fileSize != iVar5)) {
        iVar2 = 1;
        error_line("%s is not a valid .DSF file (by total size)!",infilename);
        goto LAB_001124a0;
      }
    }
    if ((config->channel_mask != 0) || ((*(byte *)((long)&config->qmode + 1) & 4) != 0)) {
      iVar2 = 1;
      error_line("this DSF file already has channel order information!");
      goto LAB_001124a0;
    }
    iVar2 = DoReadFile(infile,&format_chunk,0x34,&bcount);
    if ((iVar2 != 0) && ((bcount == 0x34 && (format_chunk.ckID == (char  [4])0x20746d66)))) {
      if ((*(byte *)((long)&config->qmode + 1) & 2) == 0) {
        iVar2 = WavpackAddWrapper(wpc,&format_chunk,0x34);
        if (iVar2 == 0) goto LAB_00112588;
      }
      WavpackLittleEndianToNative(&format_chunk,"4DLLLLLLDL4");
      if (((((format_chunk.ckSize == 0x34) && (format_chunk.formatVersion == 1)) &&
           (format_chunk.blockSize == 0x1000)) &&
          (format_chunk.formatID == 0 && format_chunk.reserved == 0)) &&
         (((format_chunk.bitsPerSample == 1 || (format_chunk.bitsPerSample == 8)) &&
          ((format_chunk.numChannels - 1 < 6 && (format_chunk.chanType - 1 < 7)))))) {
        if (debug_logging_mode != 0) {
          error_line("sampling rate = %d Hz",(ulong)format_chunk.sampleRate);
          error_line("channel type = %d, channel count = %d",(ulong)format_chunk.chanType,
                     (ulong)format_chunk.numChannels);
          error_line("block size = %d, bits per sample = %d",(ulong)format_chunk.blockSize,
                     (ulong)format_chunk.bitsPerSample);
          error_line("sample count = %lld",format_chunk.sampleCount);
        }
        iVar2 = DoReadFile(infile,&chunk_header,0xc,&bcount);
        if ((iVar2 != 0) && (bcount == 0xc)) {
          iVar2 = strncmp(chunk_header.ckID,"data",4);
          if (iVar2 == 0) {
            if ((*(byte *)((long)&config->qmode + 1) & 2) == 0) {
              iVar2 = WavpackAddWrapper(wpc,&chunk_header,0xc);
              if (iVar2 == 0) goto LAB_00112588;
            }
            WavpackLittleEndianToNative(&chunk_header,&DAT_00118ae0);
            lVar6 = format_chunk.sampleCount / (long)(ulong)(format_chunk.blockSize * 8);
            lVar8 = format_chunk.sampleCount + (ulong)format_chunk.blockSize * lVar6 * -8;
            if (debug_logging_mode != 0) {
              error_line("leftover samples = %lld, leftover bits = %d",lVar8,lVar8 % 8);
              error_line("data chunk size (specified) = %lld",chunk_header.ckSize + -0xc);
              error_line("data chunk size (calculated) = %lld",
                         (ulong)format_chunk.numChannels * ((lVar6 + 1) - (ulong)(lVar8 == 0)) *
                         0x1000);
            }
            if ((format_chunk.sampleCount & 7U) != 0) {
              error_line("warning: DSF file has partial-byte leftover samples!");
            }
            if ((format_chunk.sampleRate & 7) != 0) {
              error_line("warning: DSF file has non-integer bytes/second!");
            }
            config->sample_rate = format_chunk.sampleRate >> 3;
            config->num_channels = format_chunk.numChannels;
            config->bits_per_sample = 8;
            config->bytes_per_sample = 1;
            config->channel_mask = (uint)channel_masks[format_chunk.chanType - 1];
            uVar3 = config->qmode | 0x60;
            if (format_chunk.bitsPerSample == 1) {
              uVar3 = config->qmode | 0x50;
            }
            config->qmode = uVar3;
            iVar4 = WavpackSetConfiguration64(wpc,config,(format_chunk.sampleCount + 7) / 8,0);
            iVar2 = 0;
            if (iVar4 == 0) {
              iVar2 = 1;
              uVar7 = WavpackGetErrorMessage(wpc);
              error_line("%s: %s",infilename,uVar7);
            }
            goto LAB_001124a0;
          }
        }
      }
    }
  }
  iVar2 = 1;
  error_line("%s is not a valid .DSF file!",infilename);
LAB_001124a0:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int WriteDsfHeader(FILE *outfile,WavpackContext *wpc,int64_t total_samples,int qmode)

{
  long lVar1;
  uint uVar2;
  int iVar3;
  ulong uVar4;
  ulong uVar5;
  uint uVar6;
  long lVar7;
  long in_FS_OFFSET;
  uint32_t bcount;
  DSFChunkHeader chunk_header;
  DSFFileChunk file_chunk;
  DSFFormatChunk format_chunk;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  uVar2 = WavpackGetChannelMask(wpc);
  format_chunk.numChannels = WavpackGetNumChannels(wpc);
  if (debug_logging_mode != 0) {
    error_line("WriteDsfHeader (), total samples = %lld, qmode = 0x%02x\n",total_samples,
               (ulong)(uint)qmode);
  }
  uVar4 = 1;
  uVar6 = 4;
  uVar5 = 0;
  while( true ) {
    if (uVar6 == uVar2) {
      uVar5 = uVar4 & 0xffffffff;
    }
    format_chunk.chanType = (uint32_t)uVar5;
    if (uVar4 == 7) break;
    uVar6 = (uint)channel_masks[uVar4];
    uVar4 = uVar4 + 1;
  }
  if ((format_chunk.chanType == 0) && (format_chunk.chanType = 7, (int)format_chunk.numChannels < 7)
     ) {
    format_chunk.chanType = (4 < (int)format_chunk.numChannels) + format_chunk.numChannels;
  }
  lVar7 = total_samples + 0x1ffe;
  if (-1 < total_samples + 0xfff) {
    lVar7 = total_samples + 0xfff;
  }
  builtin_strncpy(file_chunk.ckID,"DSD ",4);
  file_chunk.ckSize = 0x1c;
  file_chunk.metaOffset = 0;
  builtin_strncpy(format_chunk.ckID,"fmt ",4);
  format_chunk.ckSize = 0x34;
  format_chunk.formatVersion = 1;
  format_chunk.formatID = 0;
  lVar7 = (lVar7 >> 0xc) * (long)(int)format_chunk.numChannels * 0x1000;
  file_chunk.fileSize = lVar7 + 0x5c;
  iVar3 = WavpackGetSampleRate(wpc);
  format_chunk.blockSize = 0x1000;
  format_chunk.reserved = 0;
  format_chunk.sampleRate = iVar3 * 8;
  builtin_strncpy(chunk_header.ckID,"data",4);
  chunk_header.ckSize = lVar7 + 0xc;
  format_chunk.sampleCount = total_samples << 3;
  format_chunk.bitsPerSample = (-(uint)((qmode & 0x10U) == 0) & 7) + 1;
  WavpackNativeToLittleEndian(&file_chunk,&DAT_001194e8);
  WavpackNativeToLittleEndian(&format_chunk,"4DLLLLLLDL4");
  WavpackNativeToLittleEndian(&chunk_header,&DAT_00118ae0);
  iVar3 = DoWriteFile(outfile,&file_chunk,0x1c,&bcount);
  if ((iVar3 != 0) && (bcount == 0x1c)) {
    iVar3 = DoWriteFile(outfile,&format_chunk,0x34,&bcount);
    if ((iVar3 != 0) && (bcount == 0x34)) {
      iVar3 = DoWriteFile(outfile,&chunk_header,0xc,&bcount);
      if ((iVar3 != 0) && (bcount == 0xc)) {
        iVar3 = 1;
        goto LAB_00112aa0;
      }
    }
  }
  error_line("can\'t write .DSF data, disk probably full!");
  iVar3 = 0;
LAB_00112aa0:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void int_handler(int s)

{
  break_flag = 1;
  return;
}



int copy_timestamp(char *src_filename,char *dst_filename)

{
  long lVar1;
  int iVar2;
  uint uVar3;
  long in_FS_OFFSET;
  timeval times [2];
  stat fileinfo;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (((*src_filename != '-') || (uVar3 = 1, src_filename[1] != '\0')) &&
     ((*dst_filename != '-' || (uVar3 = 1, dst_filename[1] != '\0')))) {
    iVar2 = stat(src_filename,(stat *)&fileinfo);
    uVar3 = 0;
    if (iVar2 == 0) {
      times[0].tv_usec = 0;
      times[1].tv_usec = 0;
      times[0].tv_sec = fileinfo.st_atim.tv_sec;
      times[1].tv_sec = fileinfo.st_mtim.tv_sec;
      iVar2 = utimes(dst_filename,(timeval *)times);
      uVar3 = (uint)(iVar2 == 0);
    }
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



char * filespec_ext(char *filespec)

{
  size_t sVar1;
  char *__s;
  char *pcVar2;
  
  sVar1 = strlen(filespec);
  pcVar2 = filespec + sVar1;
  while( true ) {
    __s = pcVar2;
    pcVar2 = __s + -1;
    if (pcVar2 < filespec) {
      return (char *)0x0;
    }
    if (*pcVar2 == '/') break;
    if (*pcVar2 == '.') {
      if (*__s == '\0') {
        return (char *)0x0;
      }
      sVar1 = strlen(__s);
      if (4 < sVar1) {
        pcVar2 = (char *)0x0;
      }
      return pcVar2;
    }
  }
  return (char *)0x0;
}



char * filespec_path(char *filespec)

{
  char *pcVar1;
  long lVar2;
  int iVar3;
  size_t sVar4;
  char *pcVar5;
  long in_FS_OFFSET;
  glob_t globs;
  stat fstats;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  sVar4 = strlen(filespec);
  pcVar1 = filespec + sVar4;
  if ((filespec == pcVar1) || (pcVar5 = strpbrk(filespec,"*?"), pcVar5 != (char *)0x0)) {
    filespec = (char *)0x0;
  }
  else if (pcVar1[-1] != '/') {
    if ((filespec == pcVar1 + -1) && (pcVar1[-1] == '.')) {
      pcVar1[0] = '/';
      pcVar1[1] = '\0';
    }
    else {
      iVar3 = glob(filespec,6,(__errfunc *)0x0,(glob_t *)&globs);
      if ((iVar3 == 0) &&
         (((globs.gl_pathc != 0 && (iVar3 = stat(*globs.gl_pathv,(stat *)&fstats), iVar3 == 0)) &&
          ((fstats.st_mode._1_1_ & 0x40) != 0)))) {
        *filespec = '\0';
        strcat(filespec,*globs.gl_pathv);
        globfree((glob_t *)&globs);
      }
      else {
        globfree((glob_t *)&globs);
        filespec = (char *)0x0;
      }
    }
  }
  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return filespec;
}



char * filespec_wild(char *filespec)

{
  char *pcVar1;
  
  pcVar1 = strpbrk(filespec,"*?");
  return pcVar1;
}



char * filespec_name(char *filespec)

{
  size_t sVar1;
  char *pcVar2;
  char *pcVar3;
  
  sVar1 = strlen(filespec);
  pcVar2 = filespec + sVar1;
  do {
    pcVar3 = pcVar2;
    pcVar2 = pcVar3 + -1;
    if (pcVar2 < filespec) break;
  } while (*pcVar2 != '/');
  if (*pcVar3 == '\0') {
    pcVar3 = (char *)0x0;
  }
  return pcVar3;
}



// WARNING: Unknown calling convention

char yna(void)

{
  uint uVar1;
  char cVar2;
  
  cVar2 = '\0';
LAB_00112e40:
  do {
    while( true ) {
      uVar1 = fgetc(stdin);
      if (uVar1 == 3) {
        fwrite(&DAT_00119741,1,3,stderr);
                    // WARNING: Subroutine does not return
        exit(1);
      }
      if (uVar1 == 0xffffffff) {
        fwrite(&DAT_00119745,1,2,stderr);
                    // WARNING: Subroutine does not return
        exit(1);
      }
      if ((uVar1 != 0xd) && (uVar1 != 10)) break;
      if (cVar2 != '\0') {
        fwrite(&DAT_00119745,1,2,stderr);
        fflush(stderr);
        return cVar2;
      }
LAB_00112e94:
      fputc(7,stderr);
      fflush(stderr);
    }
    uVar1 = uVar1 & 0xffffffdf;
    if (uVar1 == 0x59) {
      cVar2 = 'y';
      goto LAB_00112e40;
    }
    if (uVar1 == 0x4e) {
      cVar2 = 'n';
    }
    else {
      if (uVar1 != 0x41) goto LAB_00112e94;
      cVar2 = 'a';
    }
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void finish_line(void)

{
  fwrite("                                \n",1,0x21,stderr);
  fflush(stderr);
  return;
}



void error_line(char *error,...)

{
  long lVar1;
  char in_AL;
  undefined8 in_RCX;
  undefined8 in_RDX;
  undefined8 in_RSI;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  va_list argptr;
  char error_msg [512];
  undefined local_b8 [8];
  undefined8 local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  argptr[0].overflow_arg_area = &stack0x00000008;
  error_msg[0] = '\r';
  argptr[0].reg_save_area = local_b8;
  argptr[0].gp_offset = 8;
  argptr[0].fp_offset = 0x30;
  local_b0 = in_RSI;
  local_a8 = in_RDX;
  local_a0 = in_RCX;
  local_98 = in_R8;
  local_90 = in_R9;
  __vsprintf_chk(error_msg + 1,1,0x1ff,error,argptr);
  fputs(error_msg,stderr);
  finish_line();
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void setup_break(void)

{
  long lVar1;
  long in_FS_OFFSET;
  sigaction sigIntHandler;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  break_flag = 0;
  sigIntHandler.__sigaction_handler.sa_handler = int_handler;
  sigemptyset((sigset_t *)&sigIntHandler.sa_mask);
  sigIntHandler.sa_flags = 0;
  sigaction(2,(sigaction *)&sigIntHandler,(sigaction *)0x0);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int check_break(void)

{
  return break_flag;
}



int DoReadFile(FILE *hFile,void *lpBuffer,uint32_t nNumberOfBytesToRead,
              uint32_t *lpNumberOfBytesRead)

{
  int iVar1;
  size_t sVar2;
  ulong uVar3;
  
  *lpNumberOfBytesRead = 0;
  if (nNumberOfBytesToRead != 0) {
    uVar3 = 0;
    do {
      sVar2 = fread((void *)(uVar3 + (long)lpBuffer),1,(ulong)nNumberOfBytesToRead,(FILE *)hFile);
      iVar1 = (int)sVar2;
      if (iVar1 == 0) break;
      uVar3 = (ulong)(iVar1 + *lpNumberOfBytesRead);
      *lpNumberOfBytesRead = iVar1 + *lpNumberOfBytesRead;
      nNumberOfBytesToRead = nNumberOfBytesToRead - iVar1;
    } while (nNumberOfBytesToRead != 0);
  }
  iVar1 = ferror((FILE *)hFile);
  return (int)(iVar1 == 0);
}



int DoWriteFile(FILE *hFile,void *lpBuffer,uint32_t nNumberOfBytesToWrite,
               uint32_t *lpNumberOfBytesWritten)

{
  int iVar1;
  size_t sVar2;
  ulong uVar3;
  
  *lpNumberOfBytesWritten = 0;
  if (nNumberOfBytesToWrite != 0) {
    uVar3 = 0;
    do {
      sVar2 = fwrite((void *)(uVar3 + (long)lpBuffer),1,(ulong)nNumberOfBytesToWrite,(FILE *)hFile);
      iVar1 = (int)sVar2;
      if (iVar1 == 0) break;
      uVar3 = (ulong)(iVar1 + *lpNumberOfBytesWritten);
      *lpNumberOfBytesWritten = iVar1 + *lpNumberOfBytesWritten;
      nNumberOfBytesToWrite = nNumberOfBytesToWrite - iVar1;
    } while (nNumberOfBytesToWrite != 0);
  }
  iVar1 = ferror((FILE *)hFile);
  return (int)(iVar1 == 0);
}



int64_t DoGetFileSize(FILE *hFile)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  stat statbuf;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (hFile != (FILE *)0x0) {
    iVar2 = fileno((FILE *)hFile);
    iVar2 = fstat(iVar2,(stat *)&statbuf);
    if ((iVar2 == 0) && ((statbuf.st_mode & 0xf000) == 0x8000)) goto LAB_00113282;
  }
  statbuf.st_size = 0;
LAB_00113282:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return statbuf.st_size;
}



int64_t DoGetFilePosition(FILE *hFile)

{
  long lVar1;
  
  lVar1 = ftell((FILE *)hFile);
  return lVar1;
}



int DoSetFilePositionAbsolute(FILE *hFile,int64_t pos)

{
  int iVar1;
  
  iVar1 = fseek((FILE *)hFile,pos,0);
  return iVar1;
}



int DoSetFilePositionRelative(FILE *hFile,int64_t pos,int mode)

{
  int iVar1;
  
  iVar1 = fseek((FILE *)hFile,pos,mode);
  return iVar1;
}



int DoUngetc(int c,FILE *hFile)

{
  int iVar1;
  
  iVar1 = ungetc(c,(FILE *)hFile);
  return iVar1;
}



int DoCloseHandle(FILE *hFile)

{
  int iVar1;
  
  if (hFile != (FILE *)0x0) {
    iVar1 = fclose((FILE *)hFile);
    return (int)(iVar1 == 0);
  }
  return 0;
}



int DoTruncateFile(FILE *hFile)

{
  int iVar1;
  
  if (hFile == (FILE *)0x0) {
    return 0;
  }
  fflush((FILE *)hFile);
  iVar1 = fileno((FILE *)hFile);
  iVar1 = ftruncate(iVar1,0);
  return (int)(iVar1 == 0);
}



int DoDeleteFile(char *filename)

{
  int iVar1;
  
  if (filename != (char *)0x0) {
    iVar1 = remove(filename);
    return (int)(iVar1 == 0);
  }
  return 0;
}



void DoSetConsoleTitle(char *text)

{
  __fprintf_chk(stderr,1,&DAT_00119748,text);
  fflush(stderr);
  return;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

int ImportID3v2_syncsafe
              (WavpackContext *wpc,uchar *tag_data,int tag_size,char *error,int32_t *bytes_used,
              int syncsafe)

{
  byte bVar1;
  byte bVar2;
  char cVar3;
  undefined2 uVar4;
  long lVar5;
  bool bVar6;
  undefined8 uVar7;
  undefined2 uVar8;
  int iVar9;
  uint uVar10;
  ulong uVar11;
  char *pcVar12;
  uint *__dest;
  long lVar13;
  iconv_t __cd;
  size_t sVar14;
  ushort *__ptr;
  char *pcVar15;
  size_t sVar16;
  uchar *puVar17;
  char *pcVar18;
  ushort **ppuVar19;
  __int32_t **pp_Var20;
  int iVar21;
  long lVar22;
  byte *pbVar23;
  int iVar24;
  byte *pbVar25;
  uint *puVar26;
  uint *puVar27;
  uchar *puVar28;
  uint uVar29;
  int iVar30;
  char **ppcVar31;
  long lVar32;
  ushort *puVar33;
  ushort uVar34;
  ushort *puVar35;
  uint uVar36;
  ushort *puVar37;
  char *pcVar38;
  char *pcVar39;
  ulong uVar40;
  char *__s;
  long in_FS_OFFSET;
  bool bVar41;
  bool bVar42;
  ulong *local_f0;
  int local_d0;
  int local_bc;
  char *outp;
  char *inp;
  size_t insize;
  size_t outsize;
  uchar *utf8_strings [2];
  uchar id3_header [10];
  uchar frame_header [10];
  
  lVar5 = *(long *)(in_FS_OFFSET + 0x28);
  if (bytes_used != (int32_t *)0x0) {
    *bytes_used = 0;
  }
  if ((uint)tag_size < 10) {
    local_bc = -1;
    builtin_strncpy(error,"can\'t read tag header",0x16);
  }
  else {
    uVar40 = *(ulong *)tag_data;
    uVar36 = tag_size - 10;
    local_f0 = (ulong *)(tag_data + 10);
    if (((short)uVar40 == 0x4449) && (id3_header[2] = (uchar)(uVar40 >> 0x10), id3_header[2] == '3')
       ) {
      id3_header[3] = (uchar)(uVar40 >> 0x18);
      if (((id3_header[3] == '\x03') &&
          (id3_header[4] = (uchar)(uVar40 >> 0x20), id3_header[4] != 0xff)) &&
         (id3_header[5] = (uchar)(uVar40 >> 0x28), (uVar40 & 0x1f0000000000) == 0)) {
        if ((char)id3_header[5] < '\0') {
          local_bc = -1;
          builtin_strncpy(error,"unsynchonization detected",0x1a);
        }
        else if ((uVar40 & 0x400000000000) == 0) {
          if ((uVar40 & 0x200000000000) == 0) {
            id3_header[6] = (uchar)(uVar40 >> 0x30);
            id3_header[8] = (uchar)*(undefined2 *)(tag_data + 8);
            id3_header[7] = (uchar)(uVar40 >> 0x38);
            id3_header[9] = (uchar)((ushort)*(undefined2 *)(tag_data + 8) >> 8);
            if ((char)(id3_header[6] | id3_header[7] | id3_header[8] | id3_header[9]) < '\0') {
              local_bc = -1;
              builtin_strncpy(error,"not valid ID3v2.3 (bad size)",0x1d);
            }
            else if ((int)uVar36 <
                     (int)((uint)id3_header[8] * 0x80 + (uint)id3_header[9] +
                           (uint)id3_header[7] * 0x4000 + (uint)id3_header[6] * 0x200000)) {
              local_bc = -1;
              builtin_strncpy(error,"tag is truncated",0x11);
            }
            else {
              local_bc = 0;
              if (9 < uVar36) {
                bVar6 = false;
                do {
                  uVar40 = *local_f0;
                  uVar4 = *(undefined2 *)(local_f0 + 1);
                  bVar2 = (byte)uVar40;
                  frame_header[0] = (char)uVar40;
                  frame_header[1] = (char)(uVar40 >> 8);
                  frame_header[2] = (char)(uVar40 >> 0x10);
                  frame_header[3] = (char)(uVar40 >> 0x18);
                  frame_header[4] = (char)(uVar40 >> 0x20);
                  frame_header[5] = (char)(uVar40 >> 0x28);
                  frame_header[6] = (char)(uVar40 >> 0x30);
                  frame_header[7] = (char)(uVar40 >> 0x38);
                  uVar7 = frame_header._0_8_;
                  frame_header[8] = (uchar)uVar4;
                  frame_header[9] = SUB21(uVar4,1);
                  uVar8 = frame_header._8_2_;
                  if ((((char)(uVar40 >> 8) == '\0' && bVar2 == 0) && (char)(uVar40 >> 0x10) == '\0'
                      ) && (char)(uVar40 >> 0x18) == '\0') break;
                  uVar11 = uVar40 & 0xffffffff;
                  pbVar25 = frame_header;
                  bVar1 = bVar2;
                  while( true ) {
                    frame_header._0_8_ = uVar7;
                    frame_header._8_2_ = uVar8;
                    if (((byte)(bVar1 - 0x3a) < 7) || (0x2a < (byte)((char)uVar11 - 0x30U))) {
                      builtin_strncpy(error,"bad frame identity",0x13);
                      goto LAB_001135e6;
                    }
                    pbVar25 = pbVar25 + 1;
                    if (pbVar25 == frame_header + 4) break;
                    bVar1 = *pbVar25;
                    uVar11 = (ulong)bVar1;
                  }
                  frame_header[9] = SUB21(uVar4,1);
                  if (frame_header[9] != '\0') {
                    builtin_strncpy(error,"unknown frame_header flag set",0x1e);
LAB_001135e6:
                    local_bc = -1;
                    break;
                  }
                  frame_header[7] = (uchar)(uVar40 >> 0x38);
                  frame_header[6] = (uchar)(uVar40 >> 0x30);
                  frame_header[4] = (uchar)(uVar40 >> 0x20);
                  frame_header[5] = (uchar)(uVar40 >> 0x28);
                  if (syncsafe == 0) {
                    iVar21 = (uint)frame_header[7] + (uint)frame_header[6] * 0x100 +
                             (uint)frame_header[5] * 0x10000 + (uint)frame_header[4] * 0x1000000;
                  }
                  else {
                    iVar21 = (uint)frame_header[7] + (uint)frame_header[6] * 0x80 +
                             (uint)frame_header[5] * 0x4000 + (uint)frame_header[4] * 0x200000;
                  }
                  if (iVar21 == 0) {
                    builtin_strncpy(error,"empty frame not allowed",0x18);
                    goto LAB_001135e6;
                  }
                  if ((int)(uVar36 - 10) < iVar21) {
                    builtin_strncpy(error,"can\'t read frame body",0x16);
                    goto LAB_001135e6;
                  }
                  uVar40 = (ulong)iVar21;
                  uVar36 = (uVar36 - 10) - iVar21;
                  pcVar12 = (char *)malloc((long)(iVar21 + 4));
                  memcpy(pcVar12,(void *)((long)local_f0 + 10),uVar40);
                  local_f0 = (ulong *)((long)local_f0 + 10 + uVar40);
                  if (bVar2 != 0x54) {
                    if (frame_header._0_4_ != 0x43495041) goto LAB_001136b1;
                    if (*pcVar12 == '\0') {
                      uVar40 = (ulong)(iVar21 - 1);
                      pcVar38 = pcVar12 + 1;
                      lVar32 = uVar40 + 1;
                      pcVar39 = pcVar38;
                      do {
                        pcVar18 = pcVar39;
                        iVar21 = (int)uVar40;
                        uVar29 = iVar21 - 1;
                        uVar40 = (ulong)uVar29;
                        if (pcVar12 + lVar32 == pcVar18) goto LAB_00113a06;
                        pcVar39 = pcVar18 + 1;
                      } while (*pcVar18 != '\0');
                      if ((int)uVar29 < 0) {
LAB_00113a06:
                        builtin_strncpy(error,"unterminated picture mime type",0x1f);
                      }
                      else if (uVar29 == 0) {
                        builtin_strncpy(error,"no picture type",0x10);
                      }
                      else {
                        cVar3 = pcVar18[1];
                        pcVar39 = pcVar18 + 2;
                        iVar21 = iVar21 + -3;
                        do {
                          iVar9 = iVar21;
                          pcVar18 = pcVar39;
                          if (iVar9 == -1) goto LAB_00113a7a;
                          pcVar39 = pcVar18 + 1;
                          iVar21 = iVar9 + -1;
                        } while (*pcVar18 != '\0');
                        if (iVar9 < 0) {
LAB_00113a7a:
                          builtin_strncpy(error,"unterminated picture description",0x21);
                        }
                        else {
                          if (1 < iVar9) {
                            __s = ".jpg";
                            pcVar15 = strstr(pcVar38,"jpeg");
                            if ((pcVar15 == (char *)0x0) &&
                               (pcVar15 = strstr(pcVar38,"JPEG"), pcVar15 == (char *)0x0)) {
                              __s = ".png";
                              pcVar15 = strstr(pcVar38,"png");
                              if ((pcVar15 == (char *)0x0) &&
                                 (pcVar38 = strstr(pcVar38,"PNG"), pcVar38 == (char *)0x0)) {
                                if (*pcVar39 == -1) {
                                  __s = "";
                                  if (pcVar18[2] == -0x28) {
                                    __s = ".jpg";
                                  }
                                }
                                else {
                                  __s = "";
                                  if ((*pcVar39 == -0x77) && (pcVar18[2] == 'P')) {
                                    __s = ".png";
                                  }
                                }
                              }
                            }
                            if (cVar3 == '\x03') {
LAB_00113c55:
                              bVar6 = true;
                              iVar21 = 0x11;
                              pcVar38 = "Cover Art (Front)";
                            }
                            else {
                              if (cVar3 != '\x04') {
                                if (((byte)(cVar3 - 1U) < 2) || (bVar6)) goto LAB_001136b1;
                                goto LAB_00113c55;
                              }
                              iVar21 = 0x10;
                              pcVar38 = "Cover Art (Back)";
                            }
                            sVar16 = strlen(__s);
                            iVar21 = iVar21 + 1 + (int)sVar16;
                            iVar30 = iVar21 + iVar9;
                            puVar17 = (uchar *)malloc((long)iVar30);
                            pcVar18 = stpcpy((char *)puVar17,pcVar38);
                            memcpy(pcVar18,__s,sVar16 + 1);
                            memcpy(puVar17 + iVar21,pcVar39,(long)iVar9);
                            if ((wpc != (WavpackContext *)0x0) &&
                               (iVar21 = WavpackAppendBinaryTagItem(wpc,pcVar38,puVar17,iVar30),
                               iVar21 == 0)) goto LAB_00113ee2;
                            local_bc = local_bc + 1;
                            if (bytes_used != (int32_t *)0x0) {
                              sVar16 = strlen(pcVar38);
                              *bytes_used = *bytes_used + iVar30 + 1 + (int)sVar16;
                            }
                            goto LAB_0011396c;
                          }
                          builtin_strncpy(error,"no picture data",0x10);
                        }
                      }
                    }
                    else {
                      builtin_strncpy(error,"unhandled APIC character encoding",0x22);
                    }
                    goto LAB_001135e6;
                  }
                  bVar41 = frame_header._0_4_ == 0x58585854;
                  if (*pcVar12 == '\0') {
                    pcVar38 = pcVar12 + uVar40;
                    if (pcVar12 + 1 < pcVar38) {
                      lVar32 = 1;
                      sVar16 = (size_t)(iVar21 * 3);
                      pcVar39 = pcVar12 + 1;
                      do {
                        cVar3 = *pcVar39;
                        iVar30 = (int)lVar32;
                        iVar9 = iVar30 + -1;
                        if (cVar3 == '\0') goto LAB_001139b1;
                        __dest = (uint *)malloc(sVar16);
                        lVar22 = 0;
                        utf8_strings[lVar32 + -1] = (uchar *)__dest;
                        if (pcVar39 < pcVar38) {
                          *(char *)__dest = cVar3;
                          pcVar39 = pcVar39 + 1;
                          lVar13 = 1;
                          do {
                            lVar22 = (long)(int)lVar13;
                            pcVar18 = pcVar38;
                            if (pcVar38 == pcVar39) goto LAB_00113983;
                            cVar3 = *pcVar39;
                            pcVar39 = pcVar39 + 1;
                            *(char *)((long)__dest + lVar13) = cVar3;
                            lVar13 = lVar13 + 1;
                          } while (cVar3 != '\0');
                        }
                        pcVar18 = pcVar39;
                        if (pcVar39 == pcVar38) {
LAB_00113983:
                          *(char *)((long)__dest + lVar22) = '\0';
                        }
                        pcVar39 = (char *)calloc(sVar16,1);
                        puVar27 = __dest;
                        do {
                          puVar26 = puVar27;
                          uVar10 = *puVar26 + 0xfefefeff & ~*puVar26;
                          uVar29 = uVar10 & 0x80808080;
                          puVar27 = puVar26 + 1;
                        } while (uVar29 == 0);
                        bVar42 = (uVar10 & 0x8080) == 0;
                        if (bVar42) {
                          uVar29 = uVar29 >> 0x10;
                        }
                        if (bVar42) {
                          puVar27 = (uint *)((long)puVar26 + 6);
                        }
                        insize = (long)puVar27 +
                                 ((-3 - (ulong)CARRY1((byte)uVar29,(byte)uVar29)) - (long)__dest);
                        outp = pcVar39;
                        inp = (char *)__dest;
                        outsize = (long)(iVar21 * 3 + -1);
                        __cd = iconv_open("UTF-8","ISO-8859-1");
                        if (__cd != (iconv_t)0xffffffffffffffff) {
                          sVar14 = iconv(__cd,&inp,&insize,&outp,&outsize);
                          iconv_close(__cd);
                          local_d0 = (int)sVar14;
                          if (local_d0 != -1) {
                            memcpy(__dest,pcVar39,sVar16);
                          }
                        }
                        free(pcVar39);
                        lVar32 = lVar32 + 1;
                        pcVar39 = pcVar18;
                        iVar9 = iVar30;
                      } while (iVar30 < 2 && pcVar18 < pcVar38);
LAB_001138a8:
                      puVar17 = utf8_strings[0];
                      if ((bVar41) && (iVar9 == 2)) {
                        bVar2 = *utf8_strings[0];
                        uVar11 = (ulong)bVar2;
                        uVar40 = uVar11;
                        puVar28 = utf8_strings[0];
                        while (bVar2 != 0) {
                          if ((char)uVar40 < '\0') goto LAB_001138f4;
                          bVar2 = puVar28[1];
                          uVar40 = (ulong)bVar2;
                          puVar28 = puVar28 + 1;
                        }
                        ppuVar19 = __ctype_b_loc();
                        puVar33 = *ppuVar19;
                        if ((*(byte *)((long)puVar33 + uVar11 * 2 + 1) & 1) != 0) {
                          bVar2 = puVar17[1];
                          puVar28 = puVar17;
                          while (bVar2 != 0) {
                            if ((*(byte *)((long)puVar33 + (ulong)bVar2 * 2 + 1) & 1) != 0) {
                              pp_Var20 = __ctype_tolower_loc();
                              puVar28[1] = (uchar)(*pp_Var20)[bVar2];
                            }
                            bVar2 = puVar28[2];
                            puVar28 = puVar28 + 1;
                          }
                        }
LAB_001138f4:
                        puVar28 = utf8_strings[1];
                        if (wpc != (WavpackContext *)0x0) {
                          sVar16 = strlen((char *)utf8_strings[1]);
                          iVar21 = WavpackAppendTagItem(wpc,puVar17,puVar28,sVar16);
                          if (iVar21 == 0) {
LAB_00113ee2:
                            pcVar12 = (char *)WavpackGetErrorMessage(wpc);
                            strcpy(error,pcVar12);
                            goto LAB_001135e6;
                          }
                        }
                        local_bc = local_bc + 1;
                        puVar28 = utf8_strings[1];
                        if (bytes_used != (int32_t *)0x0) {
                          sVar16 = strlen((char *)puVar17);
                          puVar28 = utf8_strings[1];
                          sVar14 = strlen((char *)utf8_strings[1]);
                          *bytes_used = (int)sVar14 + *bytes_used + 1 + (int)sVar16;
                        }
                        free(puVar28);
                      }
                      else {
                        pcVar38 = "TALB";
                        ppcVar31 = &text_tag_table[0].ape_item;
                        while( true ) {
                          iVar21 = strncmp((char *)frame_header,pcVar38,4);
                          puVar17 = utf8_strings[0];
                          if (iVar21 == 0) {
                            if (wpc != (WavpackContext *)0x0) {
                              sVar16 = strlen((char *)utf8_strings[0]);
                              iVar21 = WavpackAppendTagItem(wpc,*ppcVar31,puVar17,sVar16);
                              if (iVar21 == 0) goto LAB_00113ee2;
                            }
                            local_bc = local_bc + 1;
                            if (bytes_used != (int32_t *)0x0) {
                              sVar16 = strlen((char *)utf8_strings[0]);
                              sVar14 = strlen(*ppcVar31);
                              *bytes_used = (int)sVar14 + *bytes_used + 1 + (int)sVar16;
                            }
                          }
                          if (ppcVar31 + 2 == &file_formats[0].fourcc) break;
                          pcVar38 = ppcVar31[1];
                          ppcVar31 = ppcVar31 + 2;
                        }
                        free(utf8_strings[iVar9 + -1]);
                        puVar17 = utf8_strings[0];
                        if (iVar9 + -1 == 0) goto LAB_001136b1;
                      }
LAB_0011396c:
                      free(puVar17);
                    }
                  }
                  else {
                    if (*pcVar12 != '\x01') {
                      builtin_strncpy(error,"unknown character encoding",0x1b);
                      goto LAB_001135e6;
                    }
                    iVar21 = iVar21 * 2;
                    lVar32 = 0;
                    puVar33 = (ushort *)(pcVar12 + 1);
                    __ptr = (ushort *)malloc(uVar40);
                    while (((puVar33 < (ushort *)
                                       ((long)(pcVar12 + (uVar40 & 0xfffffffffffffffe)) + -2) &&
                            (*(char *)puVar33 == -1)) && (*(char *)((long)puVar33 + 1) == -2))) {
                      pbVar25 = (byte *)malloc((long)iVar21);
                      utf8_strings[lVar32] = pbVar25;
                      puVar37 = puVar33 + 1;
                      puVar35 = __ptr;
                      while (puVar33 = puVar37, puVar37 < pcVar12 + (uVar40 & 0xfffffffffffffffe)) {
                        puVar33 = puVar37 + 1;
                        uVar34 = *puVar37;
                        *puVar35 = uVar34;
                        if (uVar34 == 0) break;
                        puVar35 = puVar35 + 1;
                        puVar37 = puVar33;
                      }
                      uVar34 = *__ptr;
                      pbVar23 = pbVar25;
                      if (uVar34 != 0) {
                        lVar22 = 0;
                        puVar37 = __ptr;
                        do {
                          puVar37 = puVar37 + 1;
                          iVar9 = (int)lVar22;
                          pbVar23 = pbVar25 + iVar9;
                          if (uVar34 < 0x80) {
                            iVar30 = iVar9 + 1;
                            if (iVar21 <= iVar30) goto LAB_00113be0;
                            *pbVar23 = (byte)uVar34;
                          }
                          else {
                            if (uVar34 < 0x800) {
LAB_00113be0:
                              iVar30 = iVar9 + 2;
                              if (iVar21 <= iVar30) goto LAB_00113b92;
                              iVar24 = iVar9 + 1;
                              *pbVar23 = (byte)(uVar34 >> 6) | 0xc0;
                            }
                            else {
LAB_00113b92:
                              iVar30 = iVar9 + 3;
                              if (iVar21 <= iVar30) goto LAB_00113994;
                              *pbVar23 = (byte)(uVar34 >> 0xc) | 0xe0;
                              iVar24 = iVar9 + 2;
                              pbVar25[iVar9 + 1] = (byte)(uVar34 >> 6) & 0x3f | 0x80;
                            }
                            pbVar25[iVar24] = (byte)uVar34 & 0x3f | 0x80;
                          }
                          lVar22 = (long)iVar30;
                          uVar34 = *puVar37;
                        } while (uVar34 != 0);
                        pbVar23 = pbVar25 + lVar22;
                      }
LAB_00113994:
                      *pbVar23 = 0;
                      if (lVar32 == 1) {
                        iVar9 = 2;
                        goto LAB_001139a9;
                      }
                      lVar32 = 1;
                    }
                    iVar9 = (int)lVar32;
LAB_001139a9:
                    free(__ptr);
LAB_001139b1:
                    if (iVar9 != 0) goto LAB_001138a8;
                  }
LAB_001136b1:
                  free(pcVar12);
                } while (9 < (int)uVar36);
              }
            }
          }
          else {
            local_bc = -1;
            builtin_strncpy(error,"experimental indicator detected",0x20);
          }
        }
        else {
          local_bc = -1;
          builtin_strncpy(error,"extended header detected",0x19);
        }
      }
      else {
        local_bc = -1;
        builtin_strncpy(error,"not valid ID3v2.3",0x12);
      }
    }
    else {
      local_bc = -1;
      builtin_strncpy(error,"no ID3v2 tag found",0x13);
    }
  }
  if (lVar5 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_bc;
}



int ImportID3v2(WavpackContext *wpc,uchar *tag_data,int tag_size,char *error,int32_t *bytes_used)

{
  uchar *puVar1;
  int iVar2;
  int iVar3;
  uchar *puVar4;
  
  if (bytes_used != (int32_t *)0x0) {
    *bytes_used = 0;
  }
  if (tag_size < 10) {
LAB_001141e4:
    iVar2 = ImportID3v2_syncsafe((WavpackContext *)0x0,tag_data,tag_size,error,bytes_used,0);
    if (iVar2 < 1) {
      iVar3 = ImportID3v2_syncsafe((WavpackContext *)0x0,tag_data,tag_size,error,bytes_used,1);
      if ((0 < iVar3) && (iVar2 = iVar3, wpc != (WavpackContext *)0x0)) {
        iVar3 = 1;
        goto LAB_00114209;
      }
    }
    else {
      iVar3 = 0;
      if (wpc != (WavpackContext *)0x0) {
LAB_00114209:
        iVar2 = ImportID3v2_syncsafe(wpc,tag_data,tag_size,error,bytes_used,iVar3);
        return iVar2;
      }
    }
  }
  else {
    puVar4 = tag_data + tag_size;
    puVar1 = puVar4 + -10;
    if (tag_data < puVar1) {
      do {
        if ((((*tag_data == 'I') && (tag_data[1] == 'D')) && (tag_data[2] == '3')) &&
           (tag_data[3] == '\x03')) {
          tag_size = (int)puVar4 - (int)tag_data;
          goto LAB_001141df;
        }
        tag_data = tag_data + 1;
      } while (puVar1 != tag_data);
    }
    else {
LAB_001141df:
      if (puVar1 != tag_data) goto LAB_001141e4;
    }
    iVar2 = 0;
  }
  return iVar2;
}



void __libc_csu_init(EVP_PKEY_CTX *param_1,undefined8 param_2,undefined8 param_3)

{
  long lVar1;
  
  _init(param_1);
  if (true) {
    lVar1 = 0;
    do {
      (*(code *)(&__frame_dummy_init_array_entry)[lVar1])
                ((ulong)param_1 & 0xffffffff,param_2,param_3);
      lVar1 = lVar1 + 1;
    } while (lVar1 != 1);
  }
  return;
}



void __libc_csu_fini(void)

{
  return;
}



int stat(char *__file,stat *__buf)

{
  int iVar1;
  
  iVar1 = __xstat(1,__file,__buf);
  return iVar1;
}



int fstat(int __fd,stat *__buf)

{
  int iVar1;
  
  iVar1 = __fxstat(1,__fd,__buf);
  return iVar1;
}



void _fini(void)

{
  return;
}



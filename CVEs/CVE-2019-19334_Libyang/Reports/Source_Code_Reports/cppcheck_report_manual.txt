build/CMakeFiles/3.16.3/CompilerIdC/CMakeCCompilerId.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
linenoise/linenoise.c:338:9: style: The scope of the variable 'nread' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int nread, nwritten, hint_len, hint_line_count, char_count;
        ^
linenoise/linenoise.c:338:16: style: The scope of the variable 'nwritten' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int nread, nwritten, hint_len, hint_line_count, char_count;
               ^
linenoise/linenoise.c:338:26: style: The scope of the variable 'hint_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int nread, nwritten, hint_len, hint_line_count, char_count;
                         ^
linenoise/linenoise.c:338:36: style: The scope of the variable 'hint_line_count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int nread, nwritten, hint_len, hint_line_count, char_count;
                                   ^
linenoise/linenoise.c:338:53: style: The scope of the variable 'char_count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int nread, nwritten, hint_len, hint_line_count, char_count;
                                                    ^
linenoise/linenoise.c:339:18: style: The scope of the variable 'common' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char c = 0, *common, *hint;
                 ^
linenoise/linenoise.c:1081:9: style: The scope of the variable 'count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int count;
        ^
src/common.c:1337:9: error: Memory pointed to by 'ptr' is freed twice. [doubleFree]
        free(ptr);
        ^
src/common.c:1335:15: note: Memory pointed to by 'ptr' is freed twice.
    new_mem = realloc(ptr, size);
              ^
src/common.c:1337:9: note: Memory pointed to by 'ptr' is freed twice.
        free(ptr);
        ^
src/common.c:813:17: warning: Either the condition '!exp' is redundant or there is possible null pointer dereference: exp. [nullPointerRedundantCheck]
    while (*i < exp->used) {
                ^
src/common.c:943:25: note: Assuming that condition '!exp' is not redundant
    LY_CHECK_ERR_RETURN(!exp, free(out), NULL);
                        ^
src/common.c:942:26: note: Assignment 'exp=lyxp_parse_expr(cur_module->ctx,expr)', assigned value is 0
    exp = lyxp_parse_expr(cur_module->ctx, expr);
                         ^
src/common.c:946:62: note: Calling function 'transform_json2xpath_subexpr', 3rd argument 'exp' value is 0
    if (transform_json2xpath_subexpr(cur_module, cur_module, exp, &i, LYXP_TOKEN_NONE, &out, &out_used, &out_size)) {
                                                             ^
src/common.c:813:17: note: Null pointer dereference
    while (*i < exp->used) {
                ^
src/common.c:1029:26: warning: Either the condition '!str' is redundant or there is possible null pointer dereference: str. [nullPointerRedundantCheck]
            col = strchr(str, ':');
                         ^
src/common.c:1027:31: note: Assuming that condition '!str' is not redundant
            LY_CHECK_ERR_GOTO(!str, LOGMEM(ctx), error);
                              ^
src/common.c:1026:26: note: Assignment 'str=strndup(exp->expr+exp->expr_pos[*cur_exp],exp->tok_len[*cur_exp])', assigned value is 0
            str = strndup(exp->expr + exp->expr_pos[*cur_exp], exp->tok_len[*cur_exp]);
                         ^
src/common.c:1029:26: note: Null pointer dereference
            col = strchr(str, ':');
                         ^
src/common.c:1271:16: warning: Either the condition '!out' is redundant or there is possible null pointer dereference: out. [nullPointerRedundantCheck]
        memcpy(out, data_path, out_used -1);
               ^
src/common.c:1270:29: note: Assuming that condition '!out' is not redundant
        LY_CHECK_ERR_RETURN(!out, LOGMEM(ctx), NULL);
                            ^
src/common.c:1269:21: note: Assignment 'out=malloc(out_used)', assigned value is 0
        out = malloc(out_used);
                    ^
src/common.c:1271:16: note: Null pointer dereference
        memcpy(out, data_path, out_used -1);
               ^
src/common.c:167:11: style: The scope of the variable 'retval' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *retval;
          ^
src/common.c:737:32: style: The scope of the variable 'id_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t out_size, out_used, id_len, rc;
                               ^
src/common.c:737:40: style: The scope of the variable 'rc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t out_size, out_used, id_len, rc;
                                       ^
src/common.c:738:30: style: The scope of the variable 'mod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const struct lys_module *mod;
                             ^
src/common.c:1218:11: style: The scope of the variable 'str' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *str;
          ^
src/common.c:1392:9: style: The scope of the variable 'ext_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int ext_len;
        ^
src/context.c:163:17: style: The scope of the variable 'name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *name, *revision;
                ^
src/context.c:163:24: style: The scope of the variable 'revision' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *name, *revision;
                       ^
src/context.c:529:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
src/context.c:568:33: style: The scope of the variable 'result' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const struct lys_submodule *result;
                                ^
src/context.c:1771:21: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t i = 0, j;
                    ^
src/context.c:1772:30: style: The scope of the variable 'mod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const struct lys_module *mod;
                             ^
src/context.c:1773:22: style: The scope of the variable 'cont' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lyd_node *cont;
                     ^
src/context.c:1774:17: style: The scope of the variable 'ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *ptr;
                ^
src/context.c:1816:22: style: The scope of the variable 'item' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lyd_node *item;
                     ^
src/context.c:481:1: style: Label 'cleanup' is not used. [unusedLabel]
cleanup:
^
src/context.c:58:17: style: struct member 'internal_modules_s::revision' is never used. [unusedStructMember]
    const char *revision;
                ^
src/context.c:436:15: style: Variable 'index' is assigned a value that is never used. [unreadVariable]
    int index = 0;
              ^
src/extensions/metadata.c:65:27: style: The scope of the variable 'submod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_submodule *submod;
                          ^
src/extensions/nacm.c:95:11: style: The scope of the variable 'path' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *path;
          ^
src/extensions/yangdata.c:59:21: style: The scope of the variable 'tmp_result' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int result = 1, tmp_result;
                    ^
src/hash_table.c:57:54: error: syntax error [syntaxError]
    LY_CHECK_ERR_RETURN(!dict->hash_tab, LOGINT(NULL), );
                                                     ^
src/log.c:129:16: error: Memory leak: prev [memleak]
        eitem->prev = last;
               ^
src/log.c:568:14: style: The scope of the variable 'step' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint16_t step;
             ^
src/log.c:856:31: style: The scope of the variable 'first' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const struct ly_err_item *first;
                              ^
src/log.c:902:31: style: The scope of the variable 'ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *path = NULL, *fmt, *ptr;
                              ^
src/log.c:903:31: style: The scope of the variable 'first' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const struct ly_err_item *first;
                              ^
src/parser.c:2685:77: error: syntax error [syntaxError]
        LY_CHECK_ERR_RETURN(!models->parsed_submodules, LOGMEM(sub_mod->ctx), );
                                                                            ^
src/parser_json.c:540:13: warning: Either the condition '!new' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
            new->parent = leaf->parent;
            ^
src/parser_json.c:538:33: note: Assuming that condition '!new' is not redundant
            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), 0);
                                ^
src/parser_json.c:537:25: note: Assignment 'new=calloc(1,sizeof(struct lyd_node_leaf_list))', assigned value is 0
            new = calloc(1, sizeof(struct lyd_node_leaf_list));
                        ^
src/parser_json.c:540:13: note: Null pointer dereference
            new->parent = leaf->parent;
            ^
src/parser_json.c:541:13: warning: Either the condition '!new' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
            new->prev = (struct lyd_node *)leaf;
            ^
src/parser_json.c:538:33: note: Assuming that condition '!new' is not redundant
            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), 0);
                                ^
src/parser_json.c:537:25: note: Assignment 'new=calloc(1,sizeof(struct lyd_node_leaf_list))', assigned value is 0
            new = calloc(1, sizeof(struct lyd_node_leaf_list));
                        ^
src/parser_json.c:541:13: note: Null pointer dereference
            new->prev = (struct lyd_node *)leaf;
            ^
src/parser_json.c:545:13: warning: Either the condition '!new' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
            new->validity = leaf->validity;
            ^
src/parser_json.c:538:33: note: Assuming that condition '!new' is not redundant
            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), 0);
                                ^
src/parser_json.c:537:25: note: Assignment 'new=calloc(1,sizeof(struct lyd_node_leaf_list))', assigned value is 0
            new = calloc(1, sizeof(struct lyd_node_leaf_list));
                        ^
src/parser_json.c:545:13: note: Null pointer dereference
            new->validity = leaf->validity;
            ^
src/parser_json.c:546:13: warning: Either the condition '!new' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
            new->when_status = leaf->when_status;
            ^
src/parser_json.c:538:33: note: Assuming that condition '!new' is not redundant
            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), 0);
                                ^
src/parser_json.c:537:25: note: Assignment 'new=calloc(1,sizeof(struct lyd_node_leaf_list))', assigned value is 0
            new = calloc(1, sizeof(struct lyd_node_leaf_list));
                        ^
src/parser_json.c:546:13: note: Null pointer dereference
            new->when_status = leaf->when_status;
            ^
src/parser_json.c:551:13: warning: Either the condition '!new' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
            new->schema = leaf->schema;
            ^
src/parser_json.c:538:33: note: Assuming that condition '!new' is not redundant
            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), 0);
                                ^
src/parser_json.c:537:25: note: Assignment 'new=calloc(1,sizeof(struct lyd_node_leaf_list))', assigned value is 0
            new = calloc(1, sizeof(struct lyd_node_leaf_list));
                        ^
src/parser_json.c:551:13: note: Null pointer dereference
            new->schema = leaf->schema;
            ^
src/parser_json.c:1054:13: warning: Either the condition '!attrs_aux' is redundant or there is possible null pointer dereference: attrs_aux. [nullPointerRedundantCheck]
            attrs_aux->attr = attr;
            ^
src/parser_json.c:1053:31: note: Assuming that condition '!attrs_aux' is not redundant
            LY_CHECK_ERR_GOTO(!attrs_aux, LOGMEM(ctx), error);
                              ^
src/parser_json.c:1052:31: note: Assignment 'attrs_aux=malloc(sizeof(*attrs_aux))', assigned value is 0
            attrs_aux = malloc(sizeof *attrs_aux);
                              ^
src/parser_json.c:1054:13: note: Null pointer dereference
            attrs_aux->attr = attr;
            ^
src/parser_json.c:1055:13: warning: Either the condition '!attrs_aux' is redundant or there is possible null pointer dereference: attrs_aux. [nullPointerRedundantCheck]
            attrs_aux->index = flag_leaflist;
            ^
src/parser_json.c:1053:31: note: Assuming that condition '!attrs_aux' is not redundant
            LY_CHECK_ERR_GOTO(!attrs_aux, LOGMEM(ctx), error);
                              ^
src/parser_json.c:1052:31: note: Assignment 'attrs_aux=malloc(sizeof(*attrs_aux))', assigned value is 0
            attrs_aux = malloc(sizeof *attrs_aux);
                              ^
src/parser_json.c:1055:13: note: Null pointer dereference
            attrs_aux->index = flag_leaflist;
            ^
src/parser_json.c:1056:13: warning: Either the condition '!attrs_aux' is redundant or there is possible null pointer dereference: attrs_aux. [nullPointerRedundantCheck]
            attrs_aux->schema = schema;
            ^
src/parser_json.c:1053:31: note: Assuming that condition '!attrs_aux' is not redundant
            LY_CHECK_ERR_GOTO(!attrs_aux, LOGMEM(ctx), error);
                              ^
src/parser_json.c:1052:31: note: Assignment 'attrs_aux=malloc(sizeof(*attrs_aux))', assigned value is 0
            attrs_aux = malloc(sizeof *attrs_aux);
                              ^
src/parser_json.c:1056:13: note: Null pointer dereference
            attrs_aux->schema = schema;
            ^
src/parser_json.c:1057:13: warning: Either the condition '!attrs_aux' is redundant or there is possible null pointer dereference: attrs_aux. [nullPointerRedundantCheck]
            attrs_aux->next = *attrs;
            ^
src/parser_json.c:1053:31: note: Assuming that condition '!attrs_aux' is not redundant
            LY_CHECK_ERR_GOTO(!attrs_aux, LOGMEM(ctx), error);
                              ^
src/parser_json.c:1052:31: note: Assignment 'attrs_aux=malloc(sizeof(*attrs_aux))', assigned value is 0
            attrs_aux = malloc(sizeof *attrs_aux);
                              ^
src/parser_json.c:1057:13: note: Null pointer dereference
            attrs_aux->next = *attrs;
            ^
src/parser_json.c:1319:17: warning: Either the condition '!new' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
                new->parent = list->parent;
                ^
src/parser_json.c:1318:35: note: Assuming that condition '!new' is not redundant
                LY_CHECK_ERR_GOTO(!new, LOGMEM(ctx), error);
                                  ^
src/parser_json.c:1317:29: note: Assignment 'new=calloc(1,sizeof(*new))', assigned value is 0
                new = calloc(1, sizeof *new);
                            ^
src/parser_json.c:1319:17: note: Null pointer dereference
                new->parent = list->parent;
                ^
src/parser_json.c:1320:17: warning: Either the condition '!new' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
                new->prev = list;
                ^
src/parser_json.c:1318:35: note: Assuming that condition '!new' is not redundant
                LY_CHECK_ERR_GOTO(!new, LOGMEM(ctx), error);
                                  ^
src/parser_json.c:1317:29: note: Assignment 'new=calloc(1,sizeof(*new))', assigned value is 0
                new = calloc(1, sizeof *new);
                            ^
src/parser_json.c:1320:17: note: Null pointer dereference
                new->prev = list;
                ^
src/parser_json.c:1324:17: warning: Either the condition '!new' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
                new->validity = list->validity;
                ^
src/parser_json.c:1318:35: note: Assuming that condition '!new' is not redundant
                LY_CHECK_ERR_GOTO(!new, LOGMEM(ctx), error);
                                  ^
src/parser_json.c:1317:29: note: Assignment 'new=calloc(1,sizeof(*new))', assigned value is 0
                new = calloc(1, sizeof *new);
                            ^
src/parser_json.c:1324:17: note: Null pointer dereference
                new->validity = list->validity;
                ^
src/parser_json.c:1325:17: warning: Either the condition '!new' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
                new->when_status = list->when_status;
                ^
src/parser_json.c:1318:35: note: Assuming that condition '!new' is not redundant
                LY_CHECK_ERR_GOTO(!new, LOGMEM(ctx), error);
                                  ^
src/parser_json.c:1317:29: note: Assignment 'new=calloc(1,sizeof(*new))', assigned value is 0
                new = calloc(1, sizeof *new);
                            ^
src/parser_json.c:1325:17: note: Null pointer dereference
                new->when_status = list->when_status;
                ^
src/parser_json.c:1330:17: warning: Either the condition '!new' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
                new->schema = list->schema;
                ^
src/parser_json.c:1318:35: note: Assuming that condition '!new' is not redundant
                LY_CHECK_ERR_GOTO(!new, LOGMEM(ctx), error);
                                  ^
src/parser_json.c:1317:29: note: Assignment 'new=calloc(1,sizeof(*new))', assigned value is 0
                new = calloc(1, sizeof *new);
                            ^
src/parser_json.c:1330:17: note: Null pointer dereference
                new->schema = list->schema;
                ^
src/parser_json.c:1545:42: warning: Either the condition 'rpc_act' is redundant or there is possible null pointer dereference: rpc_act. [nullPointerRedundantCheck]
    if ((options & LYD_OPT_RPCREPLY) && (rpc_act->schema->nodetype != LYS_RPC)) {
                                         ^
src/parser_json.c:1429:9: note: Assuming that condition 'rpc_act' is not redundant
    if (rpc_act) {
        ^
src/parser_json.c:1545:42: note: Null pointer dereference
    if ((options & LYD_OPT_RPCREPLY) && (rpc_act->schema->nodetype != LYS_RPC)) {
                                         ^
src/parser_json.c:1441:17: style: Variable 'iter' is reassigned a value before the old one has been used. [redundantAssignment]
                LY_TREE_DFS_END(reply_top, iter, reply_parent);
                ^
src/parser_json.c:1441:17: note: iter is assigned
                LY_TREE_DFS_END(reply_top, iter, reply_parent);
                ^
src/parser_json.c:1441:17: note: iter is overwritten
                LY_TREE_DFS_END(reply_top, iter, reply_parent);
                ^
src/parser_json.c:373:11: style: The scope of the variable 'str' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *str;
          ^
src/parser_json.c:1549:79: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        LOGVAL(ctx, LYE_MISSELEM, LY_VLOG_LYD, result, (options & LYD_OPT_RPC ? "action" : "notification"), result->schema->name);
                                                                              ^
src/parser_json.c:188:14: style: Variable 'size' is assigned a value that is never used. [unreadVariable]
        size = 0;
             ^
src/parser_lyb.c:116:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    LYB_HAVE_READ_RETURN(r, data, -1);
    ^
src/parser_lyb.c:353:9: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
        LYB_HAVE_READ_RETURN(r, data, -1);
        ^
src/parser_lyb.c:743:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    LYB_HAVE_READ_RETURN(r, data, -1);
    ^
src/parser_lyb.c:1195:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    LYB_HAVE_READ_RETURN(r, data, -1);
    ^
src/parser_lyb.c:503:15: warning: Possible null pointer dereference: attr [nullPointer]
        ctx = attr->annotation->module->ctx;
              ^
src/parser_lyb.c:1076:37: note: Calling function 'lyb_parse_value', 3rd argument 'NULL' value is 0
                                    NULL, data, unres, lybs));
                                    ^
src/parser_lyb.c:742:45: note: Calling function 'lyb_parse_val_2', 3rd argument 'attr' value is 0
    ret += (r = lyb_parse_val_2(type, leaf, attr, unres));
                                            ^
src/parser_lyb.c:503:15: note: Null pointer dereference
        ctx = attr->annotation->module->ctx;
              ^
src/parser_lyb.c:504:31: warning: Possible null pointer dereference: attr [nullPointer]
        mod = lys_main_module(attr->annotation->module);
                              ^
src/parser_lyb.c:1076:37: note: Calling function 'lyb_parse_value', 3rd argument 'NULL' value is 0
                                    NULL, data, unres, lybs));
                                    ^
src/parser_lyb.c:742:45: note: Calling function 'lyb_parse_val_2', 3rd argument 'attr' value is 0
    ret += (r = lyb_parse_val_2(type, leaf, attr, unres));
                                            ^
src/parser_lyb.c:504:31: note: Null pointer dereference
        mod = lys_main_module(attr->annotation->module);
                              ^
src/parser_lyb.c:509:22: warning: Possible null pointer dereference: attr [nullPointer]
        value_type = attr->value_type;
                     ^
src/parser_lyb.c:1076:37: note: Calling function 'lyb_parse_value', 3rd argument 'NULL' value is 0
                                    NULL, data, unres, lybs));
                                    ^
src/parser_lyb.c:742:45: note: Calling function 'lyb_parse_val_2', 3rd argument 'attr' value is 0
    ret += (r = lyb_parse_val_2(type, leaf, attr, unres));
                                            ^
src/parser_lyb.c:509:22: note: Null pointer dereference
        value_type = attr->value_type;
                     ^
src/parser_lyb.c:570:9: warning: Either the condition '!str' is redundant or there is possible null pointer dereference: str. [nullPointerRedundantCheck]
        str[0] = '\0';
        ^
src/parser_lyb.c:569:29: note: Assuming that condition '!str' is not redundant
        LY_CHECK_ERR_RETURN(!str, LOGMEM(ctx), -1);
                            ^
src/parser_lyb.c:568:21: note: Assignment 'str=malloc(1)', assigned value is 0
        str = malloc(1);
                    ^
src/parser_lyb.c:570:9: note: Null pointer dereference
        str[0] = '\0';
        ^
src/parser_lyb.c:860:9: warning: Either the condition '!attr' is redundant or there is possible null pointer dereference: attr. [nullPointerRedundantCheck]
        attr->annotation = ext;
        ^
src/parser_lyb.c:849:31: note: Assuming that condition '!attr' is not redundant
            LY_CHECK_ERR_GOTO(!attr, LOGMEM(lybs->ctx), error);
                              ^
src/parser_lyb.c:848:26: note: Assignment 'attr=calloc(1,sizeof(*attr))', assigned value is 0
            attr = calloc(1, sizeof *attr);
                         ^
src/parser_lyb.c:860:9: note: Null pointer dereference
        attr->annotation = ext;
        ^
src/parser_lyb.c:863:9: warning: Either the condition '!attr' is redundant or there is possible null pointer dereference: attr. [nullPointerRedundantCheck]
        attr->name = lydict_insert(lybs->ctx, attr->annotation->arg_value, 0);
        ^
src/parser_lyb.c:849:31: note: Assuming that condition '!attr' is not redundant
            LY_CHECK_ERR_GOTO(!attr, LOGMEM(lybs->ctx), error);
                              ^
src/parser_lyb.c:848:26: note: Assignment 'attr=calloc(1,sizeof(*attr))', assigned value is 0
            attr = calloc(1, sizeof *attr);
                         ^
src/parser_lyb.c:863:9: note: Null pointer dereference
        attr->name = lydict_insert(lybs->ctx, attr->annotation->arg_value, 0);
        ^
src/parser_lyb.c:866:78: warning: Either the condition '!attr' is redundant or there is possible null pointer dereference: attr. [nullPointerRedundantCheck]
        type = (struct lys_type **)lys_ext_complex_get_substmt(LY_STMT_TYPE, attr->annotation, NULL);
                                                                             ^
src/parser_lyb.c:849:31: note: Assuming that condition '!attr' is not redundant
            LY_CHECK_ERR_GOTO(!attr, LOGMEM(lybs->ctx), error);
                              ^
src/parser_lyb.c:848:26: note: Assignment 'attr=calloc(1,sizeof(*attr))', assigned value is 0
            attr = calloc(1, sizeof *attr);
                         ^
src/parser_lyb.c:866:78: note: Null pointer dereference
        type = (struct lys_type **)lys_ext_complex_get_substmt(LY_STMT_TYPE, attr->annotation, NULL);
                                                                             ^
src/parser_lyb.c:1100:17: warning: Possible null pointer dereference: first_sibling [nullPointer]
    } else if (*first_sibling) {
                ^
src/parser_lyb.c:1112:51: note: Calling function 'lyb_parse_subtree', 3rd argument 'NULL' value is 0
        ret += (r = lyb_parse_subtree(data, node, NULL, NULL, options, unres, lybs));
                                                  ^
src/parser_lyb.c:1100:17: note: Null pointer dereference
    } else if (*first_sibling) {
                ^
src/parser_lyb.c:1286:17: style: Variable 'next' is reassigned a value before the old one has been used. [redundantAssignment]
                LY_TREE_DFS_END(node, next, act_notif);
                ^
src/parser_lyb.c:1286:17: note: next is assigned
                LY_TREE_DFS_END(node, next, act_notif);
                ^
src/parser_lyb.c:1286:17: note: next is overwritten
                LY_TREE_DFS_END(node, next, act_notif);
                ^
src/parser_lyb.c:49:21: style: The scope of the variable 'empty_chunk_i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int ret = 0, i, empty_chunk_i;
                    ^
src/parser_lyb.c:50:12: style: The scope of the variable 'to_read' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t to_read;
           ^
src/parser_lyb.c:752:32: style: The scope of the variable 'k' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int r, ret = 0, pos, i, j, k;
                               ^
src/parser_lyb.c:889:14: style: The scope of the variable 'sibling_hash' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    LYB_HASH sibling_hash;
             ^
src/parser_lyb.c:997:9: style: The scope of the variable 'r' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int r, ret = 0;
        ^
src/parser_lyb.c:1154:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, r, ret = 0;
        ^
src/parser_lyb.c:123:22: error: Uninitialized variable: num [uninitvar]
        *((uint8_t *)num) = buf;
                     ^
src/parser_lyb.c:256:33: note: Calling function 'lyb_read_number', 1st argument '&rev' value is <Uninit>
    ret += (r = lyb_read_number(&rev, sizeof rev, 2, data, lybs));
                                ^
src/parser_lyb.c:123:22: note: Uninitialized variable: num
        *((uint8_t *)num) = buf;
                     ^
src/parser_lyb.c:126:23: error: Uninitialized variable: num [uninitvar]
        *((uint16_t *)num) = buf;
                      ^
src/parser_lyb.c:256:33: note: Calling function 'lyb_read_number', 1st argument '&rev' value is <Uninit>
    ret += (r = lyb_read_number(&rev, sizeof rev, 2, data, lybs));
                                ^
src/parser_lyb.c:126:23: note: Uninitialized variable: num
        *((uint16_t *)num) = buf;
                      ^
src/parser_lyb.c:129:23: error: Uninitialized variable: num [uninitvar]
        *((uint32_t *)num) = buf;
                      ^
src/parser_lyb.c:256:33: note: Calling function 'lyb_read_number', 1st argument '&rev' value is <Uninit>
    ret += (r = lyb_read_number(&rev, sizeof rev, 2, data, lybs));
                                ^
src/parser_lyb.c:129:23: note: Uninitialized variable: num
        *((uint32_t *)num) = buf;
                      ^
src/parser_lyb.c:132:23: error: Uninitialized variable: num [uninitvar]
        *((uint64_t *)num) = buf;
                      ^
src/parser_lyb.c:256:33: note: Calling function 'lyb_read_number', 1st argument '&rev' value is <Uninit>
    ret += (r = lyb_read_number(&rev, sizeof rev, 2, data, lybs));
                                ^
src/parser_lyb.c:132:23: note: Uninitialized variable: num
        *((uint64_t *)num) = buf;
                      ^
src/parser_lyb.c:350:9: style: Variable 'data' is assigned a value that is never used. [unreadVariable]
        LYB_HAVE_READ_RETURN(r, data, -1);
        ^
src/parser_lyb.c:353:9: style: Variable 'data' is assigned a value that is never used. [unreadVariable]
        LYB_HAVE_READ_RETURN(r, data, -1);
        ^
src/parser_lyb.c:731:5: style: Variable 'data' is assigned a value that is never used. [unreadVariable]
    LYB_HAVE_READ_RETURN(r, data, -1);
    ^
src/parser_lyb.c:743:5: style: Variable 'data' is assigned a value that is never used. [unreadVariable]
    LYB_HAVE_READ_RETURN(r, data, -1);
    ^
src/parser_lyb.c:758:5: style: Variable 'data' is assigned a value that is never used. [unreadVariable]
    LYB_HAVE_READ_RETURN(r, data, -1);
    ^
src/parser_lyb.c:1195:5: style: Variable 'data' is assigned a value that is never used. [unreadVariable]
    LYB_HAVE_READ_RETURN(r, data, -1);
    ^
src/parser_lyb.c:119:9: warning: Redundant assignment of 'buf' to itself. [selfAssignment]
    buf = le64toh(buf);
        ^
src/parser_xml.c:615:17: style: Variable 'iter' is reassigned a value before the old one has been used. [redundantAssignment]
                LY_TREE_DFS_END(reply_top, iter, reply_parent);
                ^
src/parser_xml.c:615:17: note: iter is assigned
                LY_TREE_DFS_END(reply_top, iter, reply_parent);
                ^
src/parser_xml.c:615:17: note: iter is overwritten
                LY_TREE_DFS_END(reply_top, iter, reply_parent);
                ^
src/parser_xml.c:717:103: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        LOGVAL(ctx, LYE_INELEM, (result ? LY_VLOG_LYD : LY_VLOG_NONE), result, (options & LYD_OPT_RPC ? "action" : "notification"));
                                                                                                      ^
src/parser_yang.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/parser_yang.c:304:5: warning: Either the condition '!retval' is redundant or there is possible null pointer dereference: retval. [nullPointerRedundantCheck]
    retval->cond = transform_schema2json(module, value);
    ^
src/parser_yang.c:303:25: note: Assuming that condition '!retval' is not redundant
    LY_CHECK_ERR_RETURN(!retval, LOGMEM(module->ctx); free(value), NULL);
                        ^
src/parser_yang.c:302:20: note: Assignment 'retval=calloc(1,sizeof(*retval))', assigned value is 0
    retval = calloc(1, sizeof *retval);
                   ^
src/parser_yang.c:304:5: note: Null pointer dereference
    retval->cond = transform_schema2json(module, value);
    ^
src/parser_yang.c:305:10: warning: Either the condition '!retval' is redundant or there is possible null pointer dereference: retval. [nullPointerRedundantCheck]
    if (!retval->cond) {
         ^
src/parser_yang.c:303:25: note: Assuming that condition '!retval' is not redundant
    LY_CHECK_ERR_RETURN(!retval, LOGMEM(module->ctx); free(value), NULL);
                        ^
src/parser_yang.c:302:20: note: Assignment 'retval=calloc(1,sizeof(*retval))', assigned value is 0
    retval = calloc(1, sizeof *retval);
                   ^
src/parser_yang.c:305:10: note: Null pointer dereference
    if (!retval->cond) {
         ^
src/parser_yang.c:400:5: warning: Either the condition '!node' is redundant or there is possible null pointer dereference: node. [nullPointerRedundantCheck]
    node->name = lydict_insert_zc(module->ctx, value);
    ^
src/parser_yang.c:397:25: note: Assuming that condition '!node' is not redundant
    LY_CHECK_ERR_RETURN(!node, LOGMEM(module->ctx); free(value), NULL);
                        ^
src/parser_yang.c:396:18: note: Assignment 'node=calloc(1,sizeof_struct)', assigned value is 0
    node = calloc(1, sizeof_struct);
                 ^
src/parser_yang.c:400:5: note: Null pointer dereference
    node->name = lydict_insert_zc(module->ctx, value);
    ^
src/parser_yang.c:401:5: warning: Either the condition '!node' is redundant or there is possible null pointer dereference: node. [nullPointerRedundantCheck]
    node->module = module;
    ^
src/parser_yang.c:397:25: note: Assuming that condition '!node' is not redundant
    LY_CHECK_ERR_RETURN(!node, LOGMEM(module->ctx); free(value), NULL);
                        ^
src/parser_yang.c:396:18: note: Assignment 'node=calloc(1,sizeof_struct)', assigned value is 0
    node = calloc(1, sizeof_struct);
                 ^
src/parser_yang.c:401:5: note: Null pointer dereference
    node->module = module;
    ^
src/parser_yang.c:402:5: warning: Either the condition '!node' is redundant or there is possible null pointer dereference: node. [nullPointerRedundantCheck]
    node->nodetype = nodetype;
    ^
src/parser_yang.c:397:25: note: Assuming that condition '!node' is not redundant
    LY_CHECK_ERR_RETURN(!node, LOGMEM(module->ctx); free(value), NULL);
                        ^
src/parser_yang.c:396:18: note: Assignment 'node=calloc(1,sizeof_struct)', assigned value is 0
    node = calloc(1, sizeof_struct);
                 ^
src/parser_yang.c:402:5: note: Null pointer dereference
    node->nodetype = nodetype;
    ^
src/parser_yang.c:403:5: warning: Either the condition '!node' is redundant or there is possible null pointer dereference: node. [nullPointerRedundantCheck]
    node->parent = parent;
    ^
src/parser_yang.c:397:25: note: Assuming that condition '!node' is not redundant
    LY_CHECK_ERR_RETURN(!node, LOGMEM(module->ctx); free(value), NULL);
                        ^
src/parser_yang.c:396:18: note: Assignment 'node=calloc(1,sizeof_struct)', assigned value is 0
    node = calloc(1, sizeof_struct);
                 ^
src/parser_yang.c:403:5: note: Null pointer dereference
    node->parent = parent;
    ^
src/parser_yang.c:539:13: warning: Either the condition '!unique_info' is redundant or there is possible null pointer dereference: unique_info. [nullPointerRedundantCheck]
            unique_info->list = (struct lys_node *)list;
            ^
src/parser_yang.c:538:31: note: Assuming that condition '!unique_info' is not redundant
            LY_CHECK_ERR_GOTO(!unique_info, LOGMEM(module->ctx), error);
                              ^
src/parser_yang.c:537:33: note: Assignment 'unique_info=malloc(sizeof(*unique_info))', assigned value is 0
            unique_info = malloc(sizeof *unique_info);
                                ^
src/parser_yang.c:539:13: note: Null pointer dereference
            unique_info->list = (struct lys_node *)list;
            ^
src/parser_yang.c:540:13: warning: Either the condition '!unique_info' is redundant or there is possible null pointer dereference: unique_info. [nullPointerRedundantCheck]
            unique_info->expr = unique->expr[i];
            ^
src/parser_yang.c:538:31: note: Assuming that condition '!unique_info' is not redundant
            LY_CHECK_ERR_GOTO(!unique_info, LOGMEM(module->ctx), error);
                              ^
src/parser_yang.c:537:33: note: Assignment 'unique_info=malloc(sizeof(*unique_info))', assigned value is 0
            unique_info = malloc(sizeof *unique_info);
                                ^
src/parser_yang.c:540:13: note: Null pointer dereference
            unique_info->expr = unique->expr[i];
            ^
src/parser_yang.c:541:13: warning: Either the condition '!unique_info' is redundant or there is possible null pointer dereference: unique_info. [nullPointerRedundantCheck]
            unique_info->trg_type = &unique->trg_type;
            ^
src/parser_yang.c:538:31: note: Assuming that condition '!unique_info' is not redundant
            LY_CHECK_ERR_GOTO(!unique_info, LOGMEM(module->ctx), error);
                              ^
src/parser_yang.c:537:33: note: Assignment 'unique_info=malloc(sizeof(*unique_info))', assigned value is 0
            unique_info = malloc(sizeof *unique_info);
                                ^
src/parser_yang.c:541:13: note: Null pointer dereference
            unique_info->trg_type = &unique->trg_type;
            ^
src/parser_yang.c:1072:5: warning: Either the condition '!typ' is redundant or there is possible null pointer dereference: typ. [nullPointerRedundantCheck]
    typ->flags = LY_YANG_STRUCTURE_FLAG;
    ^
src/parser_yang.c:1070:25: note: Assuming that condition '!typ' is not redundant
    LY_CHECK_ERR_RETURN(!typ, LOGMEM(ctx), NULL);
                        ^
src/parser_yang.c:1069:17: note: Assignment 'typ=calloc(1,sizeof(*typ))', assigned value is 0
    typ = calloc(1, sizeof *typ);
                ^
src/parser_yang.c:1072:5: note: Null pointer dereference
    typ->flags = LY_YANG_STRUCTURE_FLAG;
    ^
src/parser_yang.c:1156:5: warning: Either the condition '!length' is redundant or there is possible null pointer dereference: length. [nullPointerRedundantCheck]
    length->expr = lydict_insert_zc(ctx, value);
    ^
src/parser_yang.c:1153:27: note: Assuming that condition '!length' is not redundant
        LY_CHECK_ERR_GOTO(!length, LOGMEM(ctx), error);
                          ^
src/parser_yang.c:1152:24: note: Assignment 'length=calloc(1,sizeof(*length))', assigned value is 0
        length = calloc(1, sizeof *length);
                       ^
src/parser_yang.c:1156:5: note: Null pointer dereference
    length->expr = lydict_insert_zc(ctx, value);
    ^
src/parser_yang.c:1179:5: warning: Either the condition '!buf' is redundant or there is possible null pointer dereference: buf. [nullPointerRedundantCheck]
    buf[0] = modifier;
    ^
src/parser_yang.c:1177:25: note: Assuming that condition '!buf' is not redundant
    LY_CHECK_ERR_RETURN(!buf, LOGMEM(ctx); free(value), EXIT_FAILURE);
                        ^
src/parser_yang.c:1176:17: note: Assignment 'buf=malloc((len+2)*sizeof(*buf))', assigned value is 0
    buf = malloc((len + 2) * sizeof *buf); /* modifier byte + value + terminating NULL byte */
                ^
src/parser_yang.c:1179:5: note: Null pointer dereference
    buf[0] = modifier;
    ^
src/parser_yang.c:1208:5: warning: Either the condition '!range' is redundant or there is possible null pointer dereference: range. [nullPointerRedundantCheck]
    range->expr = lydict_insert_zc(ctx, value);
    ^
src/parser_yang.c:1205:27: note: Assuming that condition '!range' is not redundant
        LY_CHECK_ERR_GOTO(!range, LOGMEM(ctx), error);
                          ^
src/parser_yang.c:1204:23: note: Assignment 'range=calloc(1,sizeof(*range))', assigned value is 0
        range = calloc(1, sizeof *range);
                      ^
src/parser_yang.c:1208:5: note: Null pointer dereference
    range->expr = lydict_insert_zc(ctx, value);
    ^
src/parser_yang.c:2635:5: warning: Either the condition '!module' is redundant or there is possible null pointer dereference: module. [nullPointerRedundantCheck]
    module->ctx = ctx;
    ^
src/parser_yang.c:2632:23: note: Assuming that condition '!module' is not redundant
    LY_CHECK_ERR_GOTO(!module, LOGMEM(ctx), error);
                      ^
src/parser_yang.c:2631:20: note: Assignment 'module=calloc(1,sizeof(*module))', assigned value is 0
    module = calloc(1, sizeof *module);
                   ^
src/parser_yang.c:2635:5: note: Null pointer dereference
    module->ctx = ctx;
    ^
src/parser_yang.c:2636:5: warning: Either the condition '!module' is redundant or there is possible null pointer dereference: module. [nullPointerRedundantCheck]
    module->type = 0;
    ^
src/parser_yang.c:2632:23: note: Assuming that condition '!module' is not redundant
    LY_CHECK_ERR_GOTO(!module, LOGMEM(ctx), error);
                      ^
src/parser_yang.c:2631:20: note: Assignment 'module=calloc(1,sizeof(*module))', assigned value is 0
    module = calloc(1, sizeof *module);
                   ^
src/parser_yang.c:2636:5: note: Null pointer dereference
    module->type = 0;
    ^
src/parser_yang.c:2637:5: warning: Either the condition '!module' is redundant or there is possible null pointer dereference: module. [nullPointerRedundantCheck]
    module->implemented = (implement ? 1 : 0);
    ^
src/parser_yang.c:2632:23: note: Assuming that condition '!module' is not redundant
    LY_CHECK_ERR_GOTO(!module, LOGMEM(ctx), error);
                      ^
src/parser_yang.c:2631:20: note: Assignment 'module=calloc(1,sizeof(*module))', assigned value is 0
    module = calloc(1, sizeof *module);
                   ^
src/parser_yang.c:2637:5: note: Null pointer dereference
    module->implemented = (implement ? 1 : 0);
    ^
src/parser_yang.c:2751:5: warning: Either the condition '!submodule' is redundant or there is possible null pointer dereference: submodule. [nullPointerRedundantCheck]
    submodule->ctx = module->ctx;
    ^
src/parser_yang.c:2749:23: note: Assuming that condition '!submodule' is not redundant
    LY_CHECK_ERR_GOTO(!submodule, LOGMEM(module->ctx), error);
                      ^
src/parser_yang.c:2748:23: note: Assignment 'submodule=calloc(1,sizeof(*submodule))', assigned value is 0
    submodule = calloc(1, sizeof *submodule);
                      ^
src/parser_yang.c:2751:5: note: Null pointer dereference
    submodule->ctx = module->ctx;
    ^
src/parser_yang.c:2752:5: warning: Either the condition '!submodule' is redundant or there is possible null pointer dereference: submodule. [nullPointerRedundantCheck]
    submodule->type = 1;
    ^
src/parser_yang.c:2749:23: note: Assuming that condition '!submodule' is not redundant
    LY_CHECK_ERR_GOTO(!submodule, LOGMEM(module->ctx), error);
                      ^
src/parser_yang.c:2748:23: note: Assignment 'submodule=calloc(1,sizeof(*submodule))', assigned value is 0
    submodule = calloc(1, sizeof *submodule);
                      ^
src/parser_yang.c:2752:5: note: Null pointer dereference
    submodule->type = 1;
    ^
src/parser_yang.c:2753:5: warning: Either the condition '!submodule' is redundant or there is possible null pointer dereference: submodule. [nullPointerRedundantCheck]
    submodule->implemented = module->implemented;
    ^
src/parser_yang.c:2749:23: note: Assuming that condition '!submodule' is not redundant
    LY_CHECK_ERR_GOTO(!submodule, LOGMEM(module->ctx), error);
                      ^
src/parser_yang.c:2748:23: note: Assignment 'submodule=calloc(1,sizeof(*submodule))', assigned value is 0
    submodule = calloc(1, sizeof *submodule);
                      ^
src/parser_yang.c:2753:5: note: Null pointer dereference
    submodule->implemented = module->implemented;
    ^
src/parser_yang.c:2754:5: warning: Either the condition '!submodule' is redundant or there is possible null pointer dereference: submodule. [nullPointerRedundantCheck]
    submodule->belongsto = module;
    ^
src/parser_yang.c:2749:23: note: Assuming that condition '!submodule' is not redundant
    LY_CHECK_ERR_GOTO(!submodule, LOGMEM(module->ctx), error);
                      ^
src/parser_yang.c:2748:23: note: Assignment 'submodule=calloc(1,sizeof(*submodule))', assigned value is 0
    submodule = calloc(1, sizeof *submodule);
                      ^
src/parser_yang.c:2754:5: note: Null pointer dereference
    submodule->belongsto = module;
    ^
src/parser_yang.c:3301:9: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
        info->data.yang = (*ext)[i]->parent;
        ^
src/parser_yang.c:3300:29: note: Assuming that condition '!info' is not redundant
        LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                            ^
src/parser_yang.c:3299:22: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
        info = malloc(sizeof *info);
                     ^
src/parser_yang.c:3301:9: note: Null pointer dereference
        info->data.yang = (*ext)[i]->parent;
        ^
src/parser_yang.c:3302:9: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
        info->datatype = LYS_IN_YANG;
        ^
src/parser_yang.c:3300:29: note: Assuming that condition '!info' is not redundant
        LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                            ^
src/parser_yang.c:3299:22: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
        info = malloc(sizeof *info);
                     ^
src/parser_yang.c:3302:9: note: Null pointer dereference
        info->datatype = LYS_IN_YANG;
        ^
src/parser_yang.c:3303:9: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
        info->parent = parent;
        ^
src/parser_yang.c:3300:29: note: Assuming that condition '!info' is not redundant
        LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                            ^
src/parser_yang.c:3299:22: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
        info = malloc(sizeof *info);
                     ^
src/parser_yang.c:3303:9: note: Null pointer dereference
        info->parent = parent;
        ^
src/parser_yang.c:3304:9: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
        info->mod = module;
        ^
src/parser_yang.c:3300:29: note: Assuming that condition '!info' is not redundant
        LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                            ^
src/parser_yang.c:3299:22: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
        info = malloc(sizeof *info);
                     ^
src/parser_yang.c:3304:9: note: Null pointer dereference
        info->mod = module;
        ^
src/parser_yang.c:3305:9: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
        info->parent_type = (*ext)[i]->parent_type;
        ^
src/parser_yang.c:3300:29: note: Assuming that condition '!info' is not redundant
        LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                            ^
src/parser_yang.c:3299:22: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
        info = malloc(sizeof *info);
                     ^
src/parser_yang.c:3305:9: note: Null pointer dereference
        info->parent_type = (*ext)[i]->parent_type;
        ^
src/parser_yang.c:3306:9: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
        info->substmt = (*ext)[i]->insubstmt;
        ^
src/parser_yang.c:3300:29: note: Assuming that condition '!info' is not redundant
        LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                            ^
src/parser_yang.c:3299:22: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
        info = malloc(sizeof *info);
                     ^
src/parser_yang.c:3306:9: note: Null pointer dereference
        info->substmt = (*ext)[i]->insubstmt;
        ^
src/parser_yang.c:3307:9: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
        info->substmt_index = (*ext)[i]->insubstmt_index;
        ^
src/parser_yang.c:3300:29: note: Assuming that condition '!info' is not redundant
        LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                            ^
src/parser_yang.c:3299:22: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
        info = malloc(sizeof *info);
                     ^
src/parser_yang.c:3307:9: note: Null pointer dereference
        info->substmt_index = (*ext)[i]->insubstmt_index;
        ^
src/parser_yang.c:3308:9: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
        info->ext_index = i;
        ^
src/parser_yang.c:3300:29: note: Assuming that condition '!info' is not redundant
        LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                            ^
src/parser_yang.c:3299:22: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
        info = malloc(sizeof *info);
                     ^
src/parser_yang.c:3308:9: note: Null pointer dereference
        info->ext_index = i;
        ^
src/parser_yang.c:3392:22: warning: Possible null pointer dereference: (struct lys_type_enum*)ptr [nullPointer]
        iffeature = ((struct lys_type_enum *)ptr)->iffeature;
                     ^
src/parser_yang.c:3699:43: note: Calling function 'yang_check_iffeatures', 2nd argument 'NULL' value is 0
        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {
                                          ^
src/parser_yang.c:3392:22: note: Null pointer dereference
        iffeature = ((struct lys_type_enum *)ptr)->iffeature;
                     ^
src/parser_yang.c:3392:46: warning: Possible null pointer dereference: ptr [nullPointer]
        iffeature = ((struct lys_type_enum *)ptr)->iffeature;
                                             ^
src/parser_yang.c:3699:43: note: Calling function 'yang_check_iffeatures', 2nd argument 'NULL' value is 0
        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {
                                          ^
src/parser_yang.c:3392:46: note: Null pointer dereference
        iffeature = ((struct lys_type_enum *)ptr)->iffeature;
                                             ^
src/parser_yang.c:3393:17: warning: Possible null pointer dereference: (struct lys_type_enum*)ptr [nullPointer]
        size = ((struct lys_type_enum *)ptr)->iffeature_size;
                ^
src/parser_yang.c:3699:43: note: Calling function 'yang_check_iffeatures', 2nd argument 'NULL' value is 0
        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {
                                          ^
src/parser_yang.c:3393:17: note: Null pointer dereference
        size = ((struct lys_type_enum *)ptr)->iffeature_size;
                ^
src/parser_yang.c:3393:41: warning: Possible null pointer dereference: ptr [nullPointer]
        size = ((struct lys_type_enum *)ptr)->iffeature_size;
                                        ^
src/parser_yang.c:3699:43: note: Calling function 'yang_check_iffeatures', 2nd argument 'NULL' value is 0
        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {
                                          ^
src/parser_yang.c:3393:41: note: Null pointer dereference
        size = ((struct lys_type_enum *)ptr)->iffeature_size;
                                        ^
src/parser_yang.c:3397:22: warning: Possible null pointer dereference: (struct lys_type_bit*)ptr [nullPointer]
        iffeature = ((struct lys_type_bit *)ptr)->iffeature;
                     ^
src/parser_yang.c:3699:43: note: Calling function 'yang_check_iffeatures', 2nd argument 'NULL' value is 0
        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {
                                          ^
src/parser_yang.c:3397:22: note: Null pointer dereference
        iffeature = ((struct lys_type_bit *)ptr)->iffeature;
                     ^
src/parser_yang.c:3397:45: warning: Possible null pointer dereference: ptr [nullPointer]
        iffeature = ((struct lys_type_bit *)ptr)->iffeature;
                                            ^
src/parser_yang.c:3699:43: note: Calling function 'yang_check_iffeatures', 2nd argument 'NULL' value is 0
        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {
                                          ^
src/parser_yang.c:3397:45: note: Null pointer dereference
        iffeature = ((struct lys_type_bit *)ptr)->iffeature;
                                            ^
src/parser_yang.c:3398:17: warning: Possible null pointer dereference: (struct lys_type_bit*)ptr [nullPointer]
        size = ((struct lys_type_bit *)ptr)->iffeature_size;
                ^
src/parser_yang.c:3699:43: note: Calling function 'yang_check_iffeatures', 2nd argument 'NULL' value is 0
        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {
                                          ^
src/parser_yang.c:3398:17: note: Null pointer dereference
        size = ((struct lys_type_bit *)ptr)->iffeature_size;
                ^
src/parser_yang.c:3398:40: warning: Possible null pointer dereference: ptr [nullPointer]
        size = ((struct lys_type_bit *)ptr)->iffeature_size;
                                       ^
src/parser_yang.c:3699:43: note: Calling function 'yang_check_iffeatures', 2nd argument 'NULL' value is 0
        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {
                                          ^
src/parser_yang.c:3398:40: note: Null pointer dereference
        size = ((struct lys_type_bit *)ptr)->iffeature_size;
                                       ^
src/parser_yang.c:3402:22: warning: Possible null pointer dereference: (struct lys_refine*)ptr [nullPointer]
        iffeature = ((struct lys_refine *)ptr)->iffeature;
                     ^
src/parser_yang.c:3699:43: note: Calling function 'yang_check_iffeatures', 2nd argument 'NULL' value is 0
        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {
                                          ^
src/parser_yang.c:3402:22: note: Null pointer dereference
        iffeature = ((struct lys_refine *)ptr)->iffeature;
                     ^
src/parser_yang.c:3402:43: warning: Possible null pointer dereference: ptr [nullPointer]
        iffeature = ((struct lys_refine *)ptr)->iffeature;
                                          ^
src/parser_yang.c:3699:43: note: Calling function 'yang_check_iffeatures', 2nd argument 'NULL' value is 0
        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {
                                          ^
src/parser_yang.c:3402:43: note: Null pointer dereference
        iffeature = ((struct lys_refine *)ptr)->iffeature;
                                          ^
src/parser_yang.c:3403:17: warning: Possible null pointer dereference: (struct lys_refine*)ptr [nullPointer]
        size = ((struct lys_refine *)ptr)->iffeature_size;
                ^
src/parser_yang.c:3699:43: note: Calling function 'yang_check_iffeatures', 2nd argument 'NULL' value is 0
        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {
                                          ^
src/parser_yang.c:3403:17: note: Null pointer dereference
        size = ((struct lys_refine *)ptr)->iffeature_size;
                ^
src/parser_yang.c:3403:38: warning: Possible null pointer dereference: ptr [nullPointer]
        size = ((struct lys_refine *)ptr)->iffeature_size;
                                     ^
src/parser_yang.c:3699:43: note: Calling function 'yang_check_iffeatures', 2nd argument 'NULL' value is 0
        if (yang_check_iffeatures(module, NULL, &module->ident[i], IDENTITY_KEYWORD, unres)) {
                                          ^
src/parser_yang.c:3403:38: note: Null pointer dereference
        size = ((struct lys_refine *)ptr)->iffeature_size;
                                     ^
src/parser_yang.c:4562:17: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                inout->nodetype = dev_target->nodetype;
                ^
src/parser_yang.c:4560:35: note: Assuming that condition '!inout' is not redundant
                LY_CHECK_ERR_GOTO(!inout, LOGMEM(module->ctx), error);
                                  ^
src/parser_yang.c:4559:31: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                inout = calloc(1, sizeof *inout);
                              ^
src/parser_yang.c:4562:17: note: Null pointer dereference
                inout->nodetype = dev_target->nodetype;
                ^
src/parser_yang.c:4563:17: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                inout->name = lydict_insert(module->ctx, (inout->nodetype == LYS_INPUT) ? "input" : "output", 0);
                ^
src/parser_yang.c:4560:35: note: Assuming that condition '!inout' is not redundant
                LY_CHECK_ERR_GOTO(!inout, LOGMEM(module->ctx), error);
                                  ^
src/parser_yang.c:4559:31: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                inout = calloc(1, sizeof *inout);
                              ^
src/parser_yang.c:4563:17: note: Null pointer dereference
                inout->name = lydict_insert(module->ctx, (inout->nodetype == LYS_INPUT) ? "input" : "output", 0);
                ^
src/parser_yang.c:4564:17: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                inout->module = dev_target->module;
                ^
src/parser_yang.c:4560:35: note: Assuming that condition '!inout' is not redundant
                LY_CHECK_ERR_GOTO(!inout, LOGMEM(module->ctx), error);
                                  ^
src/parser_yang.c:4559:31: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                inout = calloc(1, sizeof *inout);
                              ^
src/parser_yang.c:4564:17: note: Null pointer dereference
                inout->module = dev_target->module;
                ^
src/parser_yang.c:4565:17: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                inout->flags = LYS_IMPLICIT;
                ^
src/parser_yang.c:4560:35: note: Assuming that condition '!inout' is not redundant
                LY_CHECK_ERR_GOTO(!inout, LOGMEM(module->ctx), error);
                                  ^
src/parser_yang.c:4559:31: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                inout = calloc(1, sizeof *inout);
                              ^
src/parser_yang.c:4565:17: note: Null pointer dereference
                inout->flags = LYS_IMPLICIT;
                ^
src/parser_yang.c:4569:53: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                    && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUTPUT : LYS_INPUT)));
                                                    ^
src/parser_yang.c:4560:35: note: Assuming that condition '!inout' is not redundant
                LY_CHECK_ERR_GOTO(!inout, LOGMEM(module->ctx), error);
                                  ^
src/parser_yang.c:4559:31: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                inout = calloc(1, sizeof *inout);
                              ^
src/parser_yang.c:4569:53: note: Null pointer dereference
                    && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUTPUT : LYS_INPUT)));
                                                    ^
src/parser_yang.c:4571:17: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                inout->prev = parent->child;
                ^
src/parser_yang.c:4560:35: note: Assuming that condition '!inout' is not redundant
                LY_CHECK_ERR_GOTO(!inout, LOGMEM(module->ctx), error);
                                  ^
src/parser_yang.c:4559:31: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                inout = calloc(1, sizeof *inout);
                              ^
src/parser_yang.c:4571:17: note: Null pointer dereference
                inout->prev = parent->child;
                ^
src/parser_yang.c:4573:17: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                inout->parent = parent;
                ^
src/parser_yang.c:4560:35: note: Assuming that condition '!inout' is not redundant
                LY_CHECK_ERR_GOTO(!inout, LOGMEM(module->ctx), error);
                                  ^
src/parser_yang.c:4559:31: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                inout = calloc(1, sizeof *inout);
                              ^
src/parser_yang.c:4573:17: note: Null pointer dereference
                inout->parent = parent;
                ^
src/parser_yang.c:1417:24: warning: Either the condition '!deviate' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
        memset(deviate + dev->deviate_size, 0, LY_YANG_ARRAY_SIZE * sizeof *deviate);
                       ^
src/parser_yang.c:1416:29: note: Assuming that condition '!deviate' is not redundant
        LY_CHECK_ERR_RETURN(!deviate, LOGMEM(ctx), NULL);
                            ^
src/parser_yang.c:1415:26: note: Assignment 'deviate=realloc(dev->deviate,(8+dev->deviate_size)*sizeof(*deviate))', assigned value is 0
        deviate = realloc(dev->deviate, (LY_YANG_ARRAY_SIZE + dev->deviate_size) * sizeof *deviate);
                         ^
src/parser_yang.c:1417:24: note: Null pointer addition
        memset(deviate + dev->deviate_size, 0, LY_YANG_ARRAY_SIZE * sizeof *deviate);
                       ^
src/parser_yang.c:1505:23: warning: Either the condition '!unique' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
        memset(unique + list->unique_size, 0, deviate->unique_size * sizeof *unique);
                      ^
src/parser_yang.c:1503:27: note: Assuming that condition '!unique' is not redundant
        LY_CHECK_ERR_GOTO(!unique, LOGMEM(ctx), error);
                          ^
src/parser_yang.c:1502:28: note: Assignment 'unique=ly_realloc(list->unique,(deviate->unique_size+list->unique_size)*sizeof(*unique))', assigned value is 0
        unique = ly_realloc(list->unique, (deviate->unique_size + list->unique_size) * sizeof *unique);
                           ^
src/parser_yang.c:1505:23: note: Null pointer addition
        memset(unique + list->unique_size, 0, deviate->unique_size * sizeof *unique);
                      ^
src/parser_yang.c:1046:22: style: The scope of the variable 'stype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_type *stype;
                     ^
src/parser_yang.c:2462:11: style: The scope of the variable 'str' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *str;
          ^
src/parser_yang.c:2552:24: style: The scope of the variable 'trg' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_module *trg;
                       ^
src/parser_yang.c:2879:18: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned int i;
                 ^
src/parser_yang.c:3137:28: style: The scope of the variable 'child' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_node *tmp, *child, *sibling;
                           ^
src/parser_yang.c:3250:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
src/parser_yang.c:3376:11: style: The scope of the variable 's' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *s;
          ^
src/parser_yang.c:4870:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c = 0, decrement = 0;
        ^
src/parser_yang.c:4974:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i = 0;
        ^
src/parser_yang.c:5033:31: style: The scope of the variable 'siter' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_node **snode, *siter;
                              ^
src/parser_yang.c:5056:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c, i;
        ^
src/parser_yang.c:2476:53: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                   parent->flags & LYS_STATUS_DEPRC ? "deprecated" : "obsolete", str);
                                                    ^
src/parser_yang.c:2485:61: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                           parent->flags & LYS_STATUS_DEPRC ? "deprecated" : "obsolete", parent->name);
                                                            ^
src/parser_yang.c:4870:11: style: Variable 'c' is assigned a value that is never used. [unreadVariable]
    int c = 0, decrement = 0;
          ^
src/parser_yang_lex.h:307:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
       YYLTYPE *yyget_lloc ( yyscan_t yyscanner );
^
src/parser_yang_lex.h:309:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        void yyset_lloc ( YYLTYPE * yylloc_param , yyscan_t yyscanner );
^
src/parser_yang_lex.h:356:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
extern int yylex \
^
src/parser_yang_lex.h:303:0: information: Skipping configuration 'YYSTYPE;YYSTYPE_IS_DECLARED' since the value of 'YYSTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
YYSTYPE * yyget_lval ( yyscan_t yyscanner );
^
src/parser_yang_lex.h:305:0: information: Skipping configuration 'YYSTYPE;YYSTYPE_IS_DECLARED' since the value of 'YYSTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );
^
src/parser_yang_lex.h:356:0: information: Skipping configuration 'YYSTYPE;YYSTYPE_IS_DECLARED' since the value of 'YYSTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
extern int yylex \
^
src/parser_yang_bis.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/parser_yang_bis.c:2718:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    yymsg = "Deleting";
    ^
src/parser_yang_bis.c:2891:19: error: Dangerous assignment - the function parameter is assigned the address of a local auto-variable. Local auto-variables are reserved from the stack which is freed when the function ends. So the pointer to a local variable is invalid after the function ends. [autoVariables]
                  param->value = &s;
                  ^
src/parser_yang_bis.c:2892:19: error: Dangerous assignment - the function parameter is assigned the address of a local auto-variable. Local auto-variables are reserved from the stack which is freed when the function ends. So the pointer to a local variable is invalid after the function ends. [autoVariables]
                  param->data_node = (void **)&data_node;
                  ^
src/parser_yang_bis.c:2893:19: error: Dangerous assignment - the function parameter is assigned the address of a local auto-variable. Local auto-variables are reserved from the stack which is freed when the function ends. So the pointer to a local variable is invalid after the function ends. [autoVariables]
                  param->actual_node = &actual;
                  ^
src/parser_yang_bis.c:2931:0: information: Skipping configuration 'EXIT_SUCCESS;_ALLOCA_H;YYSTACK_USE_ALLOCA;yyoverflow' since the value of 'yyoverflow' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        yyoverflow (YY_("memory exhausted"),
^
src/parser_yang_bis.c:4628:82: style: Variable 'actual' is reassigned a value before the old one has been used. [redundantAssignment]
                                                                          actual = &(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre)[2 * (((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.pat_count - 1)];
                                                                                 ^
src/parser_yang_bis.c:4627:75: note: actual is assigned
                                                                          YANG_ADDELEM(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre, c, "patterns");
                                                                          ^
src/parser_yang_bis.c:4628:82: note: actual is overwritten
                                                                          actual = &(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre)[2 * (((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.pat_count - 1)];
                                                                                 ^
src/parser_yang_bis.c:2581:52: warning: Either the condition 'yytoken!=-2' is redundant or the array 'yytname[443]' is accessed at index -2, which is out of bounds. [negativeIndex]
  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
                                                   ^
src/parser_yang_bis.c:2615:15: note: Assuming that condition 'yytoken!=-2' is not redundant
  if (yytoken != YYEMPTY)
              ^
src/parser_yang_bis.c:2581:52: note: Negative array index
  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
                                                   ^
src/parser_yang_lex.h:307:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
       YYLTYPE *yyget_lloc ( yyscan_t yyscanner );
^
src/parser_yang_lex.h:309:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        void yyset_lloc ( YYLTYPE * yylloc_param , yyscan_t yyscanner );
^
src/parser_yang_lex.h:356:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
extern int yylex \
^
src/parser_yang_bis.c:101:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
void yyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...);
^
src/parser_yang_bis.c:492:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  YYLTYPE yyls_alloc;
^
src/parser_yang_bis.c:2711:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp, void *scanner, struct yang_parameter *param)
^
src/parser_yang_bis.c:2804:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
static YYLTYPE yyloc_default
^
src/parser_yang_bis.c:2809:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
YYLTYPE yylloc = yyloc_default;
^
src/parser_yang_bis.c:2837:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    YYLTYPE yylsa[YYINITDEPTH];
^
src/parser_yang_bis.c:2838:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    YYLTYPE *yyls;
^
src/parser_yang_bis.c:2839:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    YYLTYPE *yylsp;
^
src/parser_yang_bis.c:2842:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    YYLTYPE yyerror_range[3];
^
src/parser_yang_bis.c:2853:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  YYLTYPE yyloc;
^
src/parser_yang_bis.c:2954:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
^
src/parser_yang_bis.c:9127:0: information: Skipping configuration 'YYLTYPE' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
yyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)
^
src/parser_yang_bis.c:101:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
void yyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...);
^
src/parser_yang_bis.c:492:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  YYLTYPE yyls_alloc;
^
src/parser_yang_bis.c:2711:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp, void *scanner, struct yang_parameter *param)
^
src/parser_yang_bis.c:2804:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
static YYLTYPE yyloc_default
^
src/parser_yang_bis.c:2809:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
YYLTYPE yylloc = yyloc_default;
^
src/parser_yang_bis.c:2837:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    YYLTYPE yylsa[YYINITDEPTH];
^
src/parser_yang_bis.c:2838:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    YYLTYPE *yyls;
^
src/parser_yang_bis.c:2839:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    YYLTYPE *yylsp;
^
src/parser_yang_bis.c:2842:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    YYLTYPE yyerror_range[3];
^
src/parser_yang_bis.c:2853:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  YYLTYPE yyloc;
^
src/parser_yang_bis.c:2954:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
^
src/parser_yang_bis.c:9127:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
yyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)
^
src/parser_yang_lex.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/parser_yang_lex.c:3821:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    yyscanner = NULL;
    ^
src/parser_yang_lex.c:2116:22: style: Variable 'yyg->yylloc_r->last_column' is reassigned a value before the old one has been used. [redundantAssignment]
{yylloc->last_column = 0;}
                     ^
src/parser_yang_lex.c:2115:1: note: yyg->yylloc_r->last_column is assigned
YY_RULE_SETUP
^
src/parser_yang_lex.c:2116:22: note: yyg->yylloc_r->last_column is overwritten
{yylloc->last_column = 0;}
                     ^
src/parser_yang_lex.c:2129:36: style: Variable 'yyg->yylloc_r->last_column' is reassigned a value before the old one has been used. [redundantAssignment]
{BEGIN _state; yylloc->last_column = 0; return EOL; }
                                   ^
src/parser_yang_lex.c:2128:1: note: yyg->yylloc_r->last_column is assigned
YY_RULE_SETUP
^
src/parser_yang_lex.c:2129:36: note: yyg->yylloc_r->last_column is overwritten
{BEGIN _state; yylloc->last_column = 0; return EOL; }
                                   ^
src/parser_yang_lex.c:2482:22: style: Variable 'yyg->yylloc_r->last_column' is reassigned a value before the old one has been used. [redundantAssignment]
{yylloc->last_column = 0; size_str++; }
                     ^
src/parser_yang_lex.c:2481:1: note: yyg->yylloc_r->last_column is assigned
YY_RULE_SETUP
^
src/parser_yang_lex.c:2482:22: note: yyg->yylloc_r->last_column is overwritten
{yylloc->last_column = 0; size_str++; }
                     ^
src/parser_yang_lex.c:2590:23: style: Variable 'yyg->yylloc_r->last_column' is reassigned a value before the old one has been used. [redundantAssignment]
{ yylloc->last_column = 0; return EOL;}
                      ^
src/parser_yang_lex.c:2589:1: note: yyg->yylloc_r->last_column is assigned
YY_RULE_SETUP
^
src/parser_yang_lex.c:2590:23: note: yyg->yylloc_r->last_column is overwritten
{ yylloc->last_column = 0; return EOL;}
                      ^
src/parser_yang_lex.c:2638:9: style: Variable 'yyg->yy_c_buf_p' is reassigned a value before the old one has been used. [redundantAssignment]
        yyless(2);
        ^
src/parser_yang_lex.c:2638:9: note: yyg->yy_c_buf_p is assigned
        yyless(2);
        ^
src/parser_yang_lex.c:2638:9: note: yyg->yy_c_buf_p is overwritten
        yyless(2);
        ^
src/parser_yang_lex.c:2642:9: style: Variable 'yyg->yy_c_buf_p' is reassigned a value before the old one has been used. [redundantAssignment]
        yyless(2);
        ^
src/parser_yang_lex.c:2642:9: note: yyg->yy_c_buf_p is assigned
        yyless(2);
        ^
src/parser_yang_lex.c:2642:9: note: yyg->yy_c_buf_p is overwritten
        yyless(2);
        ^
src/parser_yang_lex.c:2651:25: style: Variable 'yyg->yy_c_buf_p' is reassigned a value before the old one has been used. [redundantAssignment]
                        yyless(i);
                        ^
src/parser_yang_lex.c:2651:25: note: yyg->yy_c_buf_p is assigned
                        yyless(i);
                        ^
src/parser_yang_lex.c:2651:25: note: yyg->yy_c_buf_p is overwritten
                        yyless(i);
                        ^
src/parser_yang_lex.c:2654:25: style: Variable 'yyg->yy_c_buf_p' is reassigned a value before the old one has been used. [redundantAssignment]
                        yyless(i);
                        ^
src/parser_yang_lex.c:2654:25: note: yyg->yy_c_buf_p is assigned
                        yyless(i);
                        ^
src/parser_yang_lex.c:2654:25: note: yyg->yy_c_buf_p is overwritten
                        yyless(i);
                        ^
src/parser_yang_lex.c:2659:25: style: Variable 'yyg->yy_c_buf_p' is reassigned a value before the old one has been used. [redundantAssignment]
                        yyless(1);
                        ^
src/parser_yang_lex.c:2659:25: note: yyg->yy_c_buf_p is assigned
                        yyless(1);
                        ^
src/parser_yang_lex.c:2659:25: note: yyg->yy_c_buf_p is overwritten
                        yyless(1);
                        ^
src/parser_yang_lex.c:2662:25: style: Variable 'yyg->yy_c_buf_p' is reassigned a value before the old one has been used. [redundantAssignment]
                        yyless(i);
                        ^
src/parser_yang_lex.c:2662:25: note: yyg->yy_c_buf_p is assigned
                        yyless(i);
                        ^
src/parser_yang_lex.c:2662:25: note: yyg->yy_c_buf_p is overwritten
                        yyless(i);
                        ^
src/parser_yang_lex.c:2707:23: style: Variable 'yyg->yylloc_r->last_column' is reassigned a value before the old one has been used. [redundantAssignment]
{ yylloc->last_column = 0; return EOL; }
                      ^
src/parser_yang_lex.c:2706:1: note: yyg->yylloc_r->last_column is assigned
YY_RULE_SETUP
^
src/parser_yang_lex.c:2707:23: note: yyg->yylloc_r->last_column is overwritten
{ yylloc->last_column = 0; return EOL; }
                      ^
src/parser_yang_lex.c:2961:3: style: Redundant initialization for 'c'. The initialized value is overwritten before it is read. [redundantInitialization]
  YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
  ^
src/parser_yang_lex.c:2961:3: note: c is initialized
  YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
  ^
src/parser_yang_lex.c:2961:3: note: c is overwritten
  YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
  ^
src/parser_yang_lex.c:369:15: style: struct member 'yy_trans_info::yy_verify' is never used. [unusedStructMember]
 flex_int32_t yy_verify;
              ^
src/parser_yang_lex.c:370:15: style: struct member 'yy_trans_info::yy_nxt' is never used. [unusedStructMember]
 flex_int32_t yy_nxt;
              ^
src/parser_yang_lex.c:1809:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    YYLTYPE * yylloc_r;
^
src/parser_yang_lex.c:1862:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
       YYLTYPE *yyget_lloc ( yyscan_t yyscanner );
^
src/parser_yang_lex.c:1864:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        void yyset_lloc ( YYLTYPE * yylloc_param , yyscan_t yyscanner );
^
src/parser_yang_lex.c:1979:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
extern int yylex \
^
src/parser_yang_lex.c:2003:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
YY_DECL
^
src/parser_yang_lex.c:3690:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
YYLTYPE *yyget_lloc  (yyscan_t yyscanner)
^
src/parser_yang_lex.c:3696:0: information: Skipping configuration 'YYLTYPE;YYLTYPE_IS_DECLARED' since the value of 'YYLTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
void yyset_lloc (YYLTYPE *  yylloc_param , yyscan_t yyscanner)
^
src/parser_yang_lex.c:1807:0: information: Skipping configuration 'YYSTYPE;YYSTYPE_IS_DECLARED' since the value of 'YYSTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    YYSTYPE * yylval_r;
^
src/parser_yang_lex.c:1858:0: information: Skipping configuration 'YYSTYPE;YYSTYPE_IS_DECLARED' since the value of 'YYSTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
YYSTYPE * yyget_lval ( yyscan_t yyscanner );
^
src/parser_yang_lex.c:1860:0: information: Skipping configuration 'YYSTYPE;YYSTYPE_IS_DECLARED' since the value of 'YYSTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );
^
src/parser_yang_lex.c:1979:0: information: Skipping configuration 'YYSTYPE;YYSTYPE_IS_DECLARED' since the value of 'YYSTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
extern int yylex \
^
src/parser_yang_lex.c:2003:0: information: Skipping configuration 'YYSTYPE;YYSTYPE_IS_DECLARED' since the value of 'YYSTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
YY_DECL
^
src/parser_yang_lex.c:3678:0: information: Skipping configuration 'YYSTYPE;YYSTYPE_IS_DECLARED' since the value of 'YYSTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
YYSTYPE * yyget_lval  (yyscan_t yyscanner)
^
src/parser_yang_lex.c:3684:0: information: Skipping configuration 'YYSTYPE;YYSTYPE_IS_DECLARED' since the value of 'YYSTYPE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
void yyset_lval (YYSTYPE *  yylval_param , yyscan_t yyscanner)
^
src/parser_yang_lex.c:2019:0: information: Skipping configuration 'YY_USER_INIT' since the value of 'YY_USER_INIT' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  YY_USER_INIT;
^
src/parser_yin.c:4013:20: style: Condition '!parent' is always true [knownConditionTrueFalse]
        } else if (!parent) {
                   ^
src/parser_yin.c:4011:13: note: Assuming that condition 'parent' is not redundant
        if (parent) {
            ^
src/parser_yin.c:4013:20: note: Condition '!parent' is always true
        } else if (!parent) {
                   ^
src/parser_yin.c:101:5: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
    info->data.yin = yin;
    ^
src/parser_yin.c:99:25: note: Assuming that condition '!info' is not redundant
    LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                        ^
src/parser_yin.c:98:18: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
    info = malloc(sizeof *info);
                 ^
src/parser_yin.c:101:5: note: Null pointer dereference
    info->data.yin = yin;
    ^
src/parser_yin.c:102:5: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
    info->datatype = LYS_IN_YIN;
    ^
src/parser_yin.c:99:25: note: Assuming that condition '!info' is not redundant
    LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                        ^
src/parser_yin.c:98:18: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
    info = malloc(sizeof *info);
                 ^
src/parser_yin.c:102:5: note: Null pointer dereference
    info->datatype = LYS_IN_YIN;
    ^
src/parser_yin.c:103:5: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
    info->parent = parent;
    ^
src/parser_yin.c:99:25: note: Assuming that condition '!info' is not redundant
    LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                        ^
src/parser_yin.c:98:18: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
    info = malloc(sizeof *info);
                 ^
src/parser_yin.c:103:5: note: Null pointer dereference
    info->parent = parent;
    ^
src/parser_yin.c:104:5: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
    info->mod = module;
    ^
src/parser_yin.c:99:25: note: Assuming that condition '!info' is not redundant
    LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                        ^
src/parser_yin.c:98:18: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
    info = malloc(sizeof *info);
                 ^
src/parser_yin.c:104:5: note: Null pointer dereference
    info->mod = module;
    ^
src/parser_yin.c:105:5: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
    info->parent_type = parent_type;
    ^
src/parser_yin.c:99:25: note: Assuming that condition '!info' is not redundant
    LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                        ^
src/parser_yin.c:98:18: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
    info = malloc(sizeof *info);
                 ^
src/parser_yin.c:105:5: note: Null pointer dereference
    info->parent_type = parent_type;
    ^
src/parser_yin.c:106:5: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
    info->substmt = substmt;
    ^
src/parser_yin.c:99:25: note: Assuming that condition '!info' is not redundant
    LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                        ^
src/parser_yin.c:98:18: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
    info = malloc(sizeof *info);
                 ^
src/parser_yin.c:106:5: note: Null pointer dereference
    info->substmt = substmt;
    ^
src/parser_yin.c:107:5: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
    info->substmt_index = substmt_index;
    ^
src/parser_yin.c:99:25: note: Assuming that condition '!info' is not redundant
    LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                        ^
src/parser_yin.c:98:18: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
    info = malloc(sizeof *info);
                 ^
src/parser_yin.c:107:5: note: Null pointer dereference
    info->substmt_index = substmt_index;
    ^
src/parser_yin.c:108:5: warning: Either the condition '!info' is redundant or there is possible null pointer dereference: info. [nullPointerRedundantCheck]
    info->ext_index = ext_index;
    ^
src/parser_yin.c:99:25: note: Assuming that condition '!info' is not redundant
    LY_CHECK_ERR_RETURN(!info, LOGMEM(module->ctx), EXIT_FAILURE);
                        ^
src/parser_yin.c:98:18: note: Assignment 'info=malloc(sizeof(*info))', assigned value is 0
    info = malloc(sizeof *info);
                 ^
src/parser_yin.c:108:5: note: Null pointer dereference
    info->ext_index = ext_index;
    ^
src/parser_yin.c:1493:17: warning: Either the condition '!buf' is redundant or there is possible null pointer dereference: buf. [nullPointerRedundantCheck]
                buf[0] = modifier;
                ^
src/parser_yin.c:1492:35: note: Assuming that condition '!buf' is not redundant
                LY_CHECK_ERR_GOTO(!buf, LOGMEM(ctx), error);
                                  ^
src/parser_yin.c:1491:29: note: Assignment 'buf=malloc((len+2)*sizeof(*buf))', assigned value is 0
                buf = malloc((len + 2) * sizeof *buf); /* modifier byte + value + terminating NULL byte */
                            ^
src/parser_yin.c:1493:17: note: Null pointer dereference
                buf[0] = modifier;
                ^
src/parser_yin.c:2058:13: warning: Either the condition '!unique_info' is redundant or there is possible null pointer dereference: unique_info. [nullPointerRedundantCheck]
            unique_info->list = parent;
            ^
src/parser_yin.c:2057:31: note: Assuming that condition '!unique_info' is not redundant
            LY_CHECK_ERR_GOTO(!unique_info, LOGMEM(ctx), error);
                              ^
src/parser_yin.c:2056:33: note: Assignment 'unique_info=malloc(sizeof(*unique_info))', assigned value is 0
            unique_info = malloc(sizeof *unique_info);
                                ^
src/parser_yin.c:2058:13: note: Null pointer dereference
            unique_info->list = parent;
            ^
src/parser_yin.c:2059:13: warning: Either the condition '!unique_info' is redundant or there is possible null pointer dereference: unique_info. [nullPointerRedundantCheck]
            unique_info->expr = unique->expr[i];
            ^
src/parser_yin.c:2057:31: note: Assuming that condition '!unique_info' is not redundant
            LY_CHECK_ERR_GOTO(!unique_info, LOGMEM(ctx), error);
                              ^
src/parser_yin.c:2056:33: note: Assignment 'unique_info=malloc(sizeof(*unique_info))', assigned value is 0
            unique_info = malloc(sizeof *unique_info);
                                ^
src/parser_yin.c:2059:13: note: Null pointer dereference
            unique_info->expr = unique->expr[i];
            ^
src/parser_yin.c:2060:13: warning: Either the condition '!unique_info' is redundant or there is possible null pointer dereference: unique_info. [nullPointerRedundantCheck]
            unique_info->trg_type = &unique->trg_type;
            ^
src/parser_yin.c:2057:31: note: Assuming that condition '!unique_info' is not redundant
            LY_CHECK_ERR_GOTO(!unique_info, LOGMEM(ctx), error);
                              ^
src/parser_yin.c:2056:33: note: Assignment 'unique_info=malloc(sizeof(*unique_info))', assigned value is 0
            unique_info = malloc(sizeof *unique_info);
                                ^
src/parser_yin.c:2060:13: note: Null pointer dereference
            unique_info->trg_type = &unique->trg_type;
            ^
src/parser_yin.c:2356:21: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                    inout->nodetype = dev_target->nodetype;
                    ^
src/parser_yin.c:2354:39: note: Assuming that condition '!inout' is not redundant
                    LY_CHECK_ERR_GOTO(!inout, LOGMEM(ctx), error);
                                      ^
src/parser_yin.c:2353:35: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                    inout = calloc(1, sizeof *inout);
                                  ^
src/parser_yin.c:2356:21: note: Null pointer dereference
                    inout->nodetype = dev_target->nodetype;
                    ^
src/parser_yin.c:2357:21: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                    inout->name = lydict_insert(ctx, (inout->nodetype == LYS_INPUT) ? "input" : "output", 0);
                    ^
src/parser_yin.c:2354:39: note: Assuming that condition '!inout' is not redundant
                    LY_CHECK_ERR_GOTO(!inout, LOGMEM(ctx), error);
                                      ^
src/parser_yin.c:2353:35: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                    inout = calloc(1, sizeof *inout);
                                  ^
src/parser_yin.c:2357:21: note: Null pointer dereference
                    inout->name = lydict_insert(ctx, (inout->nodetype == LYS_INPUT) ? "input" : "output", 0);
                    ^
src/parser_yin.c:2358:21: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                    inout->module = dev_target->module;
                    ^
src/parser_yin.c:2354:39: note: Assuming that condition '!inout' is not redundant
                    LY_CHECK_ERR_GOTO(!inout, LOGMEM(ctx), error);
                                      ^
src/parser_yin.c:2353:35: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                    inout = calloc(1, sizeof *inout);
                                  ^
src/parser_yin.c:2358:21: note: Null pointer dereference
                    inout->module = dev_target->module;
                    ^
src/parser_yin.c:2359:21: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                    inout->flags = LYS_IMPLICIT;
                    ^
src/parser_yin.c:2354:39: note: Assuming that condition '!inout' is not redundant
                    LY_CHECK_ERR_GOTO(!inout, LOGMEM(ctx), error);
                                      ^
src/parser_yin.c:2353:35: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                    inout = calloc(1, sizeof *inout);
                                  ^
src/parser_yin.c:2359:21: note: Null pointer dereference
                    inout->flags = LYS_IMPLICIT;
                    ^
src/parser_yin.c:2363:60: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                           && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUTPUT : LYS_INPUT)));
                                                           ^
src/parser_yin.c:2354:39: note: Assuming that condition '!inout' is not redundant
                    LY_CHECK_ERR_GOTO(!inout, LOGMEM(ctx), error);
                                      ^
src/parser_yin.c:2353:35: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                    inout = calloc(1, sizeof *inout);
                                  ^
src/parser_yin.c:2363:60: note: Null pointer dereference
                           && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUTPUT : LYS_INPUT)));
                                                           ^
src/parser_yin.c:2365:21: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                    inout->prev = parent->child;
                    ^
src/parser_yin.c:2354:39: note: Assuming that condition '!inout' is not redundant
                    LY_CHECK_ERR_GOTO(!inout, LOGMEM(ctx), error);
                                      ^
src/parser_yin.c:2353:35: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                    inout = calloc(1, sizeof *inout);
                                  ^
src/parser_yin.c:2365:21: note: Null pointer dereference
                    inout->prev = parent->child;
                    ^
src/parser_yin.c:2367:21: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
                    inout->parent = parent;
                    ^
src/parser_yin.c:2354:39: note: Assuming that condition '!inout' is not redundant
                    LY_CHECK_ERR_GOTO(!inout, LOGMEM(ctx), error);
                                      ^
src/parser_yin.c:2353:35: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
                    inout = calloc(1, sizeof *inout);
                                  ^
src/parser_yin.c:2367:21: note: Null pointer dereference
                    inout->parent = parent;
                    ^
src/parser_yin.c:4073:5: warning: Either the condition '!retval' is redundant or there is possible null pointer dereference: retval. [nullPointerRedundantCheck]
    retval->cond = transform_schema2json(module, value);
    ^
src/parser_yin.c:4070:25: note: Assuming that condition '!retval' is not redundant
    LY_CHECK_ERR_RETURN(!retval, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:4069:20: note: Assignment 'retval=calloc(1,sizeof(*retval))', assigned value is 0
    retval = calloc(1, sizeof *retval);
                   ^
src/parser_yin.c:4073:5: note: Null pointer dereference
    retval->cond = transform_schema2json(module, value);
    ^
src/parser_yin.c:4074:10: warning: Either the condition '!retval' is redundant or there is possible null pointer dereference: retval. [nullPointerRedundantCheck]
    if (!retval->cond) {
         ^
src/parser_yin.c:4070:25: note: Assuming that condition '!retval' is not redundant
    LY_CHECK_ERR_RETURN(!retval, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:4069:20: note: Assignment 'retval=calloc(1,sizeof(*retval))', assigned value is 0
    retval = calloc(1, sizeof *retval);
                   ^
src/parser_yin.c:4074:10: note: Null pointer dereference
    if (!retval->cond) {
         ^
src/parser_yin.c:4145:5: warning: Either the condition '!cs' is redundant or there is possible null pointer dereference: cs. [nullPointerRedundantCheck]
    cs->nodetype = LYS_CASE;
    ^
src/parser_yin.c:4144:25: note: Assuming that condition '!cs' is not redundant
    LY_CHECK_ERR_RETURN(!cs, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:4143:16: note: Assignment 'cs=calloc(1,sizeof(*cs))', assigned value is 0
    cs = calloc(1, sizeof *cs);
               ^
src/parser_yin.c:4145:5: note: Null pointer dereference
    cs->nodetype = LYS_CASE;
    ^
src/parser_yin.c:4146:5: warning: Either the condition '!cs' is redundant or there is possible null pointer dereference: cs. [nullPointerRedundantCheck]
    cs->prev = (struct lys_node *)cs;
    ^
src/parser_yin.c:4144:25: note: Assuming that condition '!cs' is not redundant
    LY_CHECK_ERR_RETURN(!cs, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:4143:16: note: Assignment 'cs=calloc(1,sizeof(*cs))', assigned value is 0
    cs = calloc(1, sizeof *cs);
               ^
src/parser_yin.c:4146:5: note: Null pointer dereference
    cs->prev = (struct lys_node *)cs;
    ^
src/parser_yin.c:4297:5: warning: Either the condition '!choice' is redundant or there is possible null pointer dereference: choice. [nullPointerRedundantCheck]
    choice->nodetype = LYS_CHOICE;
    ^
src/parser_yin.c:4295:25: note: Assuming that condition '!choice' is not redundant
    LY_CHECK_ERR_RETURN(!choice, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:4294:20: note: Assignment 'choice=calloc(1,sizeof(*choice))', assigned value is 0
    choice = calloc(1, sizeof *choice);
                   ^
src/parser_yin.c:4297:5: note: Null pointer dereference
    choice->nodetype = LYS_CHOICE;
    ^
src/parser_yin.c:4298:5: warning: Either the condition '!choice' is redundant or there is possible null pointer dereference: choice. [nullPointerRedundantCheck]
    choice->prev = (struct lys_node *)choice;
    ^
src/parser_yin.c:4295:25: note: Assuming that condition '!choice' is not redundant
    LY_CHECK_ERR_RETURN(!choice, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:4294:20: note: Assignment 'choice=calloc(1,sizeof(*choice))', assigned value is 0
    choice = calloc(1, sizeof *choice);
                   ^
src/parser_yin.c:4298:5: note: Null pointer dereference
    choice->prev = (struct lys_node *)choice;
    ^
src/parser_yin.c:4504:5: warning: Either the condition '!anyxml' is redundant or there is possible null pointer dereference: anyxml. [nullPointerRedundantCheck]
    anyxml->nodetype = type;
    ^
src/parser_yin.c:4502:25: note: Assuming that condition '!anyxml' is not redundant
    LY_CHECK_ERR_RETURN(!anyxml, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:4501:20: note: Assignment 'anyxml=calloc(1,sizeof(*anyxml))', assigned value is 0
    anyxml = calloc(1, sizeof *anyxml);
                   ^
src/parser_yin.c:4504:5: note: Null pointer dereference
    anyxml->nodetype = type;
    ^
src/parser_yin.c:4505:5: warning: Either the condition '!anyxml' is redundant or there is possible null pointer dereference: anyxml. [nullPointerRedundantCheck]
    anyxml->prev = (struct lys_node *)anyxml;
    ^
src/parser_yin.c:4502:25: note: Assuming that condition '!anyxml' is not redundant
    LY_CHECK_ERR_RETURN(!anyxml, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:4501:20: note: Assignment 'anyxml=calloc(1,sizeof(*anyxml))', assigned value is 0
    anyxml = calloc(1, sizeof *anyxml);
                   ^
src/parser_yin.c:4505:5: note: Null pointer dereference
    anyxml->prev = (struct lys_node *)anyxml;
    ^
src/parser_yin.c:4663:5: warning: Either the condition '!leaf' is redundant or there is possible null pointer dereference: leaf. [nullPointerRedundantCheck]
    leaf->nodetype = LYS_LEAF;
    ^
src/parser_yin.c:4661:25: note: Assuming that condition '!leaf' is not redundant
    LY_CHECK_ERR_RETURN(!leaf, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:4660:18: note: Assignment 'leaf=calloc(1,sizeof(*leaf))', assigned value is 0
    leaf = calloc(1, sizeof *leaf);
                 ^
src/parser_yin.c:4663:5: note: Null pointer dereference
    leaf->nodetype = LYS_LEAF;
    ^
src/parser_yin.c:4664:5: warning: Either the condition '!leaf' is redundant or there is possible null pointer dereference: leaf. [nullPointerRedundantCheck]
    leaf->prev = (struct lys_node *)leaf;
    ^
src/parser_yin.c:4661:25: note: Assuming that condition '!leaf' is not redundant
    LY_CHECK_ERR_RETURN(!leaf, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:4660:18: note: Assignment 'leaf=calloc(1,sizeof(*leaf))', assigned value is 0
    leaf = calloc(1, sizeof *leaf);
                 ^
src/parser_yin.c:4664:5: note: Null pointer dereference
    leaf->prev = (struct lys_node *)leaf;
    ^
src/parser_yin.c:4887:5: warning: Either the condition '!llist' is redundant or there is possible null pointer dereference: llist. [nullPointerRedundantCheck]
    llist->nodetype = LYS_LEAFLIST;
    ^
src/parser_yin.c:4885:25: note: Assuming that condition '!llist' is not redundant
    LY_CHECK_ERR_RETURN(!llist, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:4884:19: note: Assignment 'llist=calloc(1,sizeof(*llist))', assigned value is 0
    llist = calloc(1, sizeof *llist);
                  ^
src/parser_yin.c:4887:5: note: Null pointer dereference
    llist->nodetype = LYS_LEAFLIST;
    ^
src/parser_yin.c:4888:5: warning: Either the condition '!llist' is redundant or there is possible null pointer dereference: llist. [nullPointerRedundantCheck]
    llist->prev = (struct lys_node *)llist;
    ^
src/parser_yin.c:4885:25: note: Assuming that condition '!llist' is not redundant
    LY_CHECK_ERR_RETURN(!llist, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:4884:19: note: Assignment 'llist=calloc(1,sizeof(*llist))', assigned value is 0
    llist = calloc(1, sizeof *llist);
                  ^
src/parser_yin.c:4888:5: note: Null pointer dereference
    llist->prev = (struct lys_node *)llist;
    ^
src/parser_yin.c:5204:5: warning: Either the condition '!list' is redundant or there is possible null pointer dereference: list. [nullPointerRedundantCheck]
    list->nodetype = LYS_LIST;
    ^
src/parser_yin.c:5202:25: note: Assuming that condition '!list' is not redundant
    LY_CHECK_ERR_RETURN(!list, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:5201:18: note: Assignment 'list=calloc(1,sizeof(*list))', assigned value is 0
    list = calloc(1, sizeof *list);
                 ^
src/parser_yin.c:5204:5: note: Null pointer dereference
    list->nodetype = LYS_LIST;
    ^
src/parser_yin.c:5205:5: warning: Either the condition '!list' is redundant or there is possible null pointer dereference: list. [nullPointerRedundantCheck]
    list->prev = (struct lys_node *)list;
    ^
src/parser_yin.c:5202:25: note: Assuming that condition '!list' is not redundant
    LY_CHECK_ERR_RETURN(!list, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:5201:18: note: Assignment 'list=calloc(1,sizeof(*list))', assigned value is 0
    list = calloc(1, sizeof *list);
                 ^
src/parser_yin.c:5205:5: note: Null pointer dereference
    list->prev = (struct lys_node *)list;
    ^
src/parser_yin.c:5580:5: warning: Either the condition '!cont' is redundant or there is possible null pointer dereference: cont. [nullPointerRedundantCheck]
    cont->nodetype = LYS_CONTAINER;
    ^
src/parser_yin.c:5578:25: note: Assuming that condition '!cont' is not redundant
    LY_CHECK_ERR_RETURN(!cont, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:5577:18: note: Assignment 'cont=calloc(1,sizeof(*cont))', assigned value is 0
    cont = calloc(1, sizeof *cont);
                 ^
src/parser_yin.c:5580:5: note: Null pointer dereference
    cont->nodetype = LYS_CONTAINER;
    ^
src/parser_yin.c:5581:5: warning: Either the condition '!cont' is redundant or there is possible null pointer dereference: cont. [nullPointerRedundantCheck]
    cont->prev = (struct lys_node *)cont;
    ^
src/parser_yin.c:5578:25: note: Assuming that condition '!cont' is not redundant
    LY_CHECK_ERR_RETURN(!cont, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:5577:18: note: Assignment 'cont=calloc(1,sizeof(*cont))', assigned value is 0
    cont = calloc(1, sizeof *cont);
                 ^
src/parser_yin.c:5581:5: note: Null pointer dereference
    cont->prev = (struct lys_node *)cont;
    ^
src/parser_yin.c:5798:5: warning: Either the condition '!grp' is redundant or there is possible null pointer dereference: grp. [nullPointerRedundantCheck]
    grp->nodetype = LYS_GROUPING;
    ^
src/parser_yin.c:5796:25: note: Assuming that condition '!grp' is not redundant
    LY_CHECK_ERR_RETURN(!grp, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:5795:17: note: Assignment 'grp=calloc(1,sizeof(*grp))', assigned value is 0
    grp = calloc(1, sizeof *grp);
                ^
src/parser_yin.c:5798:5: note: Null pointer dereference
    grp->nodetype = LYS_GROUPING;
    ^
src/parser_yin.c:5799:5: warning: Either the condition '!grp' is redundant or there is possible null pointer dereference: grp. [nullPointerRedundantCheck]
    grp->prev = (struct lys_node *)grp;
    ^
src/parser_yin.c:5796:25: note: Assuming that condition '!grp' is not redundant
    LY_CHECK_ERR_RETURN(!grp, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:5795:17: note: Assignment 'grp=calloc(1,sizeof(*grp))', assigned value is 0
    grp = calloc(1, sizeof *grp);
                ^
src/parser_yin.c:5799:5: note: Null pointer dereference
    grp->prev = (struct lys_node *)grp;
    ^
src/parser_yin.c:5940:5: warning: Either the condition '!inout' is redundant or there is possible null pointer dereference: inout. [nullPointerRedundantCheck]
    inout->prev = (struct lys_node *)inout;
    ^
src/parser_yin.c:5939:25: note: Assuming that condition '!inout' is not redundant
    LY_CHECK_ERR_RETURN(!inout, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:5938:19: note: Assignment 'inout=calloc(1,sizeof(*inout))', assigned value is 0
    inout = calloc(1, sizeof *inout);
                  ^
src/parser_yin.c:5940:5: note: Null pointer dereference
    inout->prev = (struct lys_node *)inout;
    ^
src/parser_yin.c:6116:5: warning: Either the condition '!notif' is redundant or there is possible null pointer dereference: notif. [nullPointerRedundantCheck]
    notif->nodetype = LYS_NOTIF;
    ^
src/parser_yin.c:6114:25: note: Assuming that condition '!notif' is not redundant
    LY_CHECK_ERR_RETURN(!notif, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:6113:19: note: Assignment 'notif=calloc(1,sizeof(*notif))', assigned value is 0
    notif = calloc(1, sizeof *notif);
                  ^
src/parser_yin.c:6116:5: note: Null pointer dereference
    notif->nodetype = LYS_NOTIF;
    ^
src/parser_yin.c:6117:5: warning: Either the condition '!notif' is redundant or there is possible null pointer dereference: notif. [nullPointerRedundantCheck]
    notif->prev = (struct lys_node *)notif;
    ^
src/parser_yin.c:6114:25: note: Assuming that condition '!notif' is not redundant
    LY_CHECK_ERR_RETURN(!notif, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:6113:19: note: Assignment 'notif=calloc(1,sizeof(*notif))', assigned value is 0
    notif = calloc(1, sizeof *notif);
                  ^
src/parser_yin.c:6117:5: note: Null pointer dereference
    notif->prev = (struct lys_node *)notif;
    ^
src/parser_yin.c:6306:5: warning: Either the condition '!rpc' is redundant or there is possible null pointer dereference: rpc. [nullPointerRedundantCheck]
    rpc->nodetype = (!strcmp(yin->name, "rpc") ? LYS_RPC : LYS_ACTION);
    ^
src/parser_yin.c:6304:25: note: Assuming that condition '!rpc' is not redundant
    LY_CHECK_ERR_RETURN(!rpc, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:6303:17: note: Assignment 'rpc=calloc(1,sizeof(*rpc))', assigned value is 0
    rpc = calloc(1, sizeof *rpc);
                ^
src/parser_yin.c:6306:5: note: Null pointer dereference
    rpc->nodetype = (!strcmp(yin->name, "rpc") ? LYS_RPC : LYS_ACTION);
    ^
src/parser_yin.c:6307:5: warning: Either the condition '!rpc' is redundant or there is possible null pointer dereference: rpc. [nullPointerRedundantCheck]
    rpc->prev = (struct lys_node *)rpc;
    ^
src/parser_yin.c:6304:25: note: Assuming that condition '!rpc' is not redundant
    LY_CHECK_ERR_RETURN(!rpc, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:6303:17: note: Assignment 'rpc=calloc(1,sizeof(*rpc))', assigned value is 0
    rpc = calloc(1, sizeof *rpc);
                ^
src/parser_yin.c:6307:5: note: Null pointer dereference
    rpc->prev = (struct lys_node *)rpc;
    ^
src/parser_yin.c:6454:5: warning: Either the condition '!uses' is redundant or there is possible null pointer dereference: uses. [nullPointerRedundantCheck]
    uses->nodetype = LYS_USES;
    ^
src/parser_yin.c:6452:25: note: Assuming that condition '!uses' is not redundant
    LY_CHECK_ERR_RETURN(!uses, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:6451:18: note: Assignment 'uses=calloc(1,sizeof(*uses))', assigned value is 0
    uses = calloc(1, sizeof *uses);
                 ^
src/parser_yin.c:6454:5: note: Null pointer dereference
    uses->nodetype = LYS_USES;
    ^
src/parser_yin.c:6455:5: warning: Either the condition '!uses' is redundant or there is possible null pointer dereference: uses. [nullPointerRedundantCheck]
    uses->prev = (struct lys_node *)uses;
    ^
src/parser_yin.c:6452:25: note: Assuming that condition '!uses' is not redundant
    LY_CHECK_ERR_RETURN(!uses, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:6451:18: note: Assignment 'uses=calloc(1,sizeof(*uses))', assigned value is 0
    uses = calloc(1, sizeof *uses);
                 ^
src/parser_yin.c:6455:5: note: Null pointer dereference
    uses->prev = (struct lys_node *)uses;
    ^
src/parser_yin.c:6459:5: warning: Either the condition '!uses' is redundant or there is possible null pointer dereference: uses. [nullPointerRedundantCheck]
    uses->name = lydict_insert(ctx, value, 0);
    ^
src/parser_yin.c:6452:25: note: Assuming that condition '!uses' is not redundant
    LY_CHECK_ERR_RETURN(!uses, LOGMEM(ctx), NULL);
                        ^
src/parser_yin.c:6451:18: note: Assignment 'uses=calloc(1,sizeof(*uses))', assigned value is 0
    uses = calloc(1, sizeof *uses);
                 ^
src/parser_yin.c:6459:5: note: Null pointer dereference
    uses->name = lydict_insert(ctx, value, 0);
    ^
src/parser_yin.c:7277:5: warning: Either the condition '!submodule' is redundant or there is possible null pointer dereference: submodule. [nullPointerRedundantCheck]
    submodule->ctx = ctx;
    ^
src/parser_yin.c:7275:23: note: Assuming that condition '!submodule' is not redundant
    LY_CHECK_ERR_GOTO(!submodule, LOGMEM(ctx), error);
                      ^
src/parser_yin.c:7274:23: note: Assignment 'submodule=calloc(1,sizeof(*submodule))', assigned value is 0
    submodule = calloc(1, sizeof *submodule);
                      ^
src/parser_yin.c:7277:5: note: Null pointer dereference
    submodule->ctx = ctx;
    ^
src/parser_yin.c:7278:5: warning: Either the condition '!submodule' is redundant or there is possible null pointer dereference: submodule. [nullPointerRedundantCheck]
    submodule->name = lydict_insert(ctx, value, strlen(value));
    ^
src/parser_yin.c:7275:23: note: Assuming that condition '!submodule' is not redundant
    LY_CHECK_ERR_GOTO(!submodule, LOGMEM(ctx), error);
                      ^
src/parser_yin.c:7274:23: note: Assignment 'submodule=calloc(1,sizeof(*submodule))', assigned value is 0
    submodule = calloc(1, sizeof *submodule);
                      ^
src/parser_yin.c:7278:5: note: Null pointer dereference
    submodule->name = lydict_insert(ctx, value, strlen(value));
    ^
src/parser_yin.c:7279:5: warning: Either the condition '!submodule' is redundant or there is possible null pointer dereference: submodule. [nullPointerRedundantCheck]
    submodule->type = 1;
    ^
src/parser_yin.c:7275:23: note: Assuming that condition '!submodule' is not redundant
    LY_CHECK_ERR_GOTO(!submodule, LOGMEM(ctx), error);
                      ^
src/parser_yin.c:7274:23: note: Assignment 'submodule=calloc(1,sizeof(*submodule))', assigned value is 0
    submodule = calloc(1, sizeof *submodule);
                      ^
src/parser_yin.c:7279:5: note: Null pointer dereference
    submodule->type = 1;
    ^
src/parser_yin.c:7280:5: warning: Either the condition '!submodule' is redundant or there is possible null pointer dereference: submodule. [nullPointerRedundantCheck]
    submodule->implemented = module->implemented;
    ^
src/parser_yin.c:7275:23: note: Assuming that condition '!submodule' is not redundant
    LY_CHECK_ERR_GOTO(!submodule, LOGMEM(ctx), error);
                      ^
src/parser_yin.c:7274:23: note: Assignment 'submodule=calloc(1,sizeof(*submodule))', assigned value is 0
    submodule = calloc(1, sizeof *submodule);
                      ^
src/parser_yin.c:7280:5: note: Null pointer dereference
    submodule->implemented = module->implemented;
    ^
src/parser_yin.c:7281:5: warning: Either the condition '!submodule' is redundant or there is possible null pointer dereference: submodule. [nullPointerRedundantCheck]
    submodule->belongsto = module;
    ^
src/parser_yin.c:7275:23: note: Assuming that condition '!submodule' is not redundant
    LY_CHECK_ERR_GOTO(!submodule, LOGMEM(ctx), error);
                      ^
src/parser_yin.c:7274:23: note: Assignment 'submodule=calloc(1,sizeof(*submodule))', assigned value is 0
    submodule = calloc(1, sizeof *submodule);
                      ^
src/parser_yin.c:7281:5: note: Null pointer dereference
    submodule->belongsto = module;
    ^
src/parser_yin.c:7351:5: warning: Either the condition '!module' is redundant or there is possible null pointer dereference: module. [nullPointerRedundantCheck]
    module->ctx = ctx;
    ^
src/parser_yin.c:7349:23: note: Assuming that condition '!module' is not redundant
    LY_CHECK_ERR_GOTO(!module, LOGMEM(ctx), error);
                      ^
src/parser_yin.c:7348:20: note: Assignment 'module=calloc(1,sizeof(*module))', assigned value is 0
    module = calloc(1, sizeof *module);
                   ^
src/parser_yin.c:7351:5: note: Null pointer dereference
    module->ctx = ctx;
    ^
src/parser_yin.c:7352:5: warning: Either the condition '!module' is redundant or there is possible null pointer dereference: module. [nullPointerRedundantCheck]
    module->name = lydict_insert(ctx, value, strlen(value));
    ^
src/parser_yin.c:7349:23: note: Assuming that condition '!module' is not redundant
    LY_CHECK_ERR_GOTO(!module, LOGMEM(ctx), error);
                      ^
src/parser_yin.c:7348:20: note: Assignment 'module=calloc(1,sizeof(*module))', assigned value is 0
    module = calloc(1, sizeof *module);
                   ^
src/parser_yin.c:7352:5: note: Null pointer dereference
    module->name = lydict_insert(ctx, value, strlen(value));
    ^
src/parser_yin.c:7353:5: warning: Either the condition '!module' is redundant or there is possible null pointer dereference: module. [nullPointerRedundantCheck]
    module->type = 0;
    ^
src/parser_yin.c:7349:23: note: Assuming that condition '!module' is not redundant
    LY_CHECK_ERR_GOTO(!module, LOGMEM(ctx), error);
                      ^
src/parser_yin.c:7348:20: note: Assignment 'module=calloc(1,sizeof(*module))', assigned value is 0
    module = calloc(1, sizeof *module);
                   ^
src/parser_yin.c:7353:5: note: Null pointer dereference
    module->type = 0;
    ^
src/parser_yin.c:7354:5: warning: Either the condition '!module' is redundant or there is possible null pointer dereference: module. [nullPointerRedundantCheck]
    module->implemented = (implement ? 1 : 0);
    ^
src/parser_yin.c:7349:23: note: Assuming that condition '!module' is not redundant
    LY_CHECK_ERR_GOTO(!module, LOGMEM(ctx), error);
                      ^
src/parser_yin.c:7348:20: note: Assignment 'module=calloc(1,sizeof(*module))', assigned value is 0
    module = calloc(1, sizeof *module);
                   ^
src/parser_yin.c:7354:5: note: Null pointer dereference
    module->implemented = (implement ? 1 : 0);
    ^
src/parser_yin.c:7515:37: style: The scope of the variable 'value' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char **str, ***p = NULL, *value;
                                    ^
src/parser_yin.c:7729:31: style: The scope of the variable 'siter' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_node **snode, *siter;
                              ^
src/parser_yin.c:273:68: style: Redundant pointer operation on 'ext' - it's already a pointer. [redundantPointerOp]
        r = lyp_yin_fill_ext(elem, elem_type, type, i, mod, child, &(*ext), (*ext_size), unres);
                                                                   ^
src/parser_yin.c:4034:53: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                   parent->flags & LYS_STATUS_DEPRC ? "deprecated" : "obsolete", str);
                                                    ^
src/parser_yin.c:4043:57: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                       parent->flags & LYS_STATUS_DEPRC ? "deprecated" : "obsolete", parent->name);
                                                        ^
src/plugins.c:301:66: error: syntax error [syntaxError]
    LY_CHECK_ERR_RETURN(!loaded_plugins, free(name); LOGMEM(NULL), );
                                                                 ^
src/printer.c:940:13: style: Variable 'next' is reassigned a value before the old one has been used. [redundantAssignment]
            LY_TREE_DFS_END(node, next, elem)
            ^
src/printer.c:940:13: note: next is assigned
            LY_TREE_DFS_END(node, next, elem)
            ^
src/printer.c:940:13: note: next is overwritten
            LY_TREE_DFS_END(node, next, elem)
            ^
src/printer.c:952:13: style: Variable 'next' is reassigned a value before the old one has been used. [redundantAssignment]
            LY_TREE_DFS_END(node, next, elem)
            ^
src/printer.c:952:13: note: next is assigned
            LY_TREE_DFS_END(node, next, elem)
            ^
src/printer.c:952:13: note: next is overwritten
            LY_TREE_DFS_END(node, next, elem)
            ^
src/printer.c:990:9: warning: Redundant assignment of 'first' to itself. [selfAssignment]
        LY_TREE_FOR(first, first) {
        ^
src/printer.c:299:24: style: The scope of the variable 'mod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_module *mod;
                       ^
src/printer.c:965:22: style: The scope of the variable 'scase' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_node *scase, *sparent;
                     ^
src/printer_info.c:30:17: style: The scope of the variable 'ptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *ptr1, *ptr2;
                ^
src/printer_info.c:157:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
src/printer_info.c:188:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
src/printer_info.c:205:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
src/printer_info.c:434:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j;
        ^
src/printer_info.c:434:12: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j;
           ^
src/printer_info.c:453:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
src/printer_info.c:509:20: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int first = 1, i;
                   ^
src/printer_info.c:530:20: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int first = 1, i;
                   ^
src/printer_info.c:551:20: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int first = 1, i;
                   ^
src/printer_info.c:646:20: style: The scope of the variable 'from_include' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int first = 1, from_include;
                   ^
src/printer_info.c:647:22: style: The scope of the variable 'node' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_node *node;
                     ^
src/printer_json.c:624:17: style: Variable 'next' is reassigned a value before the old one has been used. [redundantAssignment]
                LY_TREE_DFS_END(root, next, node);
                ^
src/printer_json.c:624:17: note: next is assigned
                LY_TREE_DFS_END(root, next, node);
                ^
src/printer_json.c:624:17: note: next is overwritten
                LY_TREE_DFS_END(root, next, node);
                ^
src/printer_json.c:258:17: style: The scope of the variable 'schema' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *schema;
                ^
src/printer_json.c:608:35: style: The scope of the variable 'next' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const struct lyd_node *node, *next;
                                  ^
src/printer_json_schema.c:88:17: style: The scope of the variable 'str' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *str;
                ^
src/printer_json_schema.c:687:16: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int f = 1, j;
               ^
src/printer_json_schema.c:688:24: style: The scope of the variable 'mod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_module *mod;
                       ^
src/printer_json_schema.c:736:18: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned int j;
                 ^
src/printer_json_schema.c:528:47: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a+b?c:d'' should be written as either ''(a+b)?c:d'' or ''a+(b?c:d)''. [clarifyCalculation]
        ly_print(out, "%s\"%s%s%s\":{", i + j ? "," : "", imp[i].module->name,
                                              ^
src/printer_lyb.c:157:48: error: syntax error [syntaxError]
    LY_CHECK_ERR_RETURN(!augs, LOGMEM(mod->ctx), );
                                               ^
src/printer_tree.c:425:9: warning: Either the condition '!o' is redundant or there is possible null pointer dereference: o. [nullPointerRedundantCheck]
        o->type = LYOUT_MEMORY;
        ^
src/printer_tree.c:424:29: note: Assuming that condition '!o' is not redundant
        LY_CHECK_ERR_RETURN(!o, LOGMEM(NULL), 0);
                            ^
src/printer_tree.c:423:19: note: Assignment 'o=malloc(sizeof(*o))', assigned value is 0
        o = malloc(sizeof *o);
                  ^
src/printer_tree.c:425:9: note: Null pointer dereference
        o->type = LYOUT_MEMORY;
        ^
src/printer_tree.c:426:9: warning: Either the condition '!o' is redundant or there is possible null pointer dereference: o. [nullPointerRedundantCheck]
        o->method.mem.buf = NULL;
        ^
src/printer_tree.c:424:29: note: Assuming that condition '!o' is not redundant
        LY_CHECK_ERR_RETURN(!o, LOGMEM(NULL), 0);
                            ^
src/printer_tree.c:423:19: note: Assignment 'o=malloc(sizeof(*o))', assigned value is 0
        o = malloc(sizeof *o);
                  ^
src/printer_tree.c:426:9: note: Null pointer dereference
        o->method.mem.buf = NULL;
        ^
src/printer_tree.c:427:9: warning: Either the condition '!o' is redundant or there is possible null pointer dereference: o. [nullPointerRedundantCheck]
        o->method.mem.len = 0;
        ^
src/printer_tree.c:424:29: note: Assuming that condition '!o' is not redundant
        LY_CHECK_ERR_RETURN(!o, LOGMEM(NULL), 0);
                            ^
src/printer_tree.c:423:19: note: Assignment 'o=malloc(sizeof(*o))', assigned value is 0
        o = malloc(sizeof *o);
                  ^
src/printer_tree.c:427:9: note: Null pointer dereference
        o->method.mem.len = 0;
        ^
src/printer_tree.c:428:9: warning: Either the condition '!o' is redundant or there is possible null pointer dereference: o. [nullPointerRedundantCheck]
        o->method.mem.size = 0;
        ^
src/printer_tree.c:424:29: note: Assuming that condition '!o' is not redundant
        LY_CHECK_ERR_RETURN(!o, LOGMEM(NULL), 0);
                            ^
src/printer_tree.c:423:19: note: Assignment 'o=malloc(sizeof(*o))', assigned value is 0
        o = malloc(sizeof *o);
                  ^
src/printer_tree.c:428:9: note: Null pointer dereference
        o->method.mem.size = 0;
        ^
src/printer_tree.c:469:9: warning: Either the condition '!o' is redundant or there is possible null pointer dereference: o. [nullPointerRedundantCheck]
        o->type = LYOUT_MEMORY;
        ^
src/printer_tree.c:468:29: note: Assuming that condition '!o' is not redundant
        LY_CHECK_ERR_RETURN(!o, LOGMEM(NULL), 0);
                            ^
src/printer_tree.c:467:19: note: Assignment 'o=malloc(sizeof(*o))', assigned value is 0
        o = malloc(sizeof *o);
                  ^
src/printer_tree.c:469:9: note: Null pointer dereference
        o->type = LYOUT_MEMORY;
        ^
src/printer_tree.c:470:9: warning: Either the condition '!o' is redundant or there is possible null pointer dereference: o. [nullPointerRedundantCheck]
        o->method.mem.buf = NULL;
        ^
src/printer_tree.c:468:29: note: Assuming that condition '!o' is not redundant
        LY_CHECK_ERR_RETURN(!o, LOGMEM(NULL), 0);
                            ^
src/printer_tree.c:467:19: note: Assignment 'o=malloc(sizeof(*o))', assigned value is 0
        o = malloc(sizeof *o);
                  ^
src/printer_tree.c:470:9: note: Null pointer dereference
        o->method.mem.buf = NULL;
        ^
src/printer_tree.c:471:9: warning: Either the condition '!o' is redundant or there is possible null pointer dereference: o. [nullPointerRedundantCheck]
        o->method.mem.len = 0;
        ^
src/printer_tree.c:468:29: note: Assuming that condition '!o' is not redundant
        LY_CHECK_ERR_RETURN(!o, LOGMEM(NULL), 0);
                            ^
src/printer_tree.c:467:19: note: Assignment 'o=malloc(sizeof(*o))', assigned value is 0
        o = malloc(sizeof *o);
                  ^
src/printer_tree.c:471:9: note: Null pointer dereference
        o->method.mem.len = 0;
        ^
src/printer_tree.c:472:9: warning: Either the condition '!o' is redundant or there is possible null pointer dereference: o. [nullPointerRedundantCheck]
        o->method.mem.size = 0;
        ^
src/printer_tree.c:468:29: note: Assuming that condition '!o' is not redundant
        LY_CHECK_ERR_RETURN(!o, LOGMEM(NULL), 0);
                            ^
src/printer_tree.c:467:19: note: Assignment 'o=malloc(sizeof(*o))', assigned value is 0
        o = malloc(sizeof *o);
                  ^
src/printer_tree.c:472:9: note: Null pointer dereference
        o->method.mem.size = 0;
        ^
src/printer_tree.c:253:27: style: The scope of the variable 'list' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_node_list *list;
                          ^
src/printer_tree.c:254:14: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint16_t i;
             ^
src/printer_tree.c:784:25: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned int depth, i, j;
                        ^
src/printer_tree.c:784:28: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned int depth, i, j;
                           ^
src/printer_tree.c:438:102: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        printed += ly_print_iffeature(o, opts->module, &iff1[i], opts->options & LYS_OUTOPT_TREE_RFC ? 2 : 1);
                                                                                                     ^
src/printer_tree.c:444:102: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        printed += ly_print_iffeature(o, opts->module, &iff2[i], opts->options & LYS_OUTOPT_TREE_RFC ? 2 : 1);
                                                                                                     ^
src/printer_tree.c:545:71: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    line_len += ly_print(out, "%s--", (node->flags & LYS_STATUS_DEPRC ? "x" : (node->flags & LYS_STATUS_OBSLT ? "o" : "+")));
                                                                      ^
src/printer_xml.c:56:9: warning: Either the condition '!iter' is redundant or there is possible null pointer dereference: iter. [nullPointerRedundantCheck]
        iter->next = *mlist;
        ^
src/printer_xml.c:55:29: note: Assuming that condition '!iter' is not redundant
        LY_CHECK_ERR_RETURN(!iter, LOGMEM(mod->ctx), EXIT_FAILURE);
                            ^
src/printer_xml.c:54:22: note: Assignment 'iter=malloc(sizeof(*iter))', assigned value is 0
        iter = malloc(sizeof *iter);
                     ^
src/printer_xml.c:56:9: note: Null pointer dereference
        iter->next = *mlist;
        ^
src/printer_xml.c:57:9: warning: Either the condition '!iter' is redundant or there is possible null pointer dereference: iter. [nullPointerRedundantCheck]
        iter->module = (struct lys_module *)mod;
        ^
src/printer_xml.c:55:29: note: Assuming that condition '!iter' is not redundant
        LY_CHECK_ERR_RETURN(!iter, LOGMEM(mod->ctx), EXIT_FAILURE);
                            ^
src/printer_xml.c:54:22: note: Assignment 'iter=malloc(sizeof(*iter))', assigned value is 0
        iter = malloc(sizeof *iter);
                     ^
src/printer_xml.c:57:9: note: Null pointer dereference
        iter->module = (struct lys_module *)mod;
        ^
src/printer_xml.c:58:9: warning: Either the condition '!iter' is redundant or there is possible null pointer dereference: iter. [nullPointerRedundantCheck]
        iter->printed = 0;
        ^
src/printer_xml.c:55:29: note: Assuming that condition '!iter' is not redundant
        LY_CHECK_ERR_RETURN(!iter, LOGMEM(mod->ctx), EXIT_FAILURE);
                            ^
src/printer_xml.c:54:22: note: Assignment 'iter=malloc(sizeof(*iter))', assigned value is 0
        iter = malloc(sizeof *iter);
                     ^
src/printer_xml.c:58:9: note: Null pointer dereference
        iter->printed = 0;
        ^
src/printer_xml.c:142:13: style: Variable 'next' is reassigned a value before the old one has been used. [redundantAssignment]
            LY_TREE_DFS_END(node2, next, cur)}
            ^
src/printer_xml.c:142:13: note: next is assigned
            LY_TREE_DFS_END(node2, next, cur)}
            ^
src/printer_xml.c:142:13: note: next is overwritten
            LY_TREE_DFS_END(node2, next, cur)}
            ^
src/printer_xml.c:703:17: style: Variable 'next' is reassigned a value before the old one has been used. [redundantAssignment]
                LY_TREE_DFS_END(root, next, node);
                ^
src/printer_xml.c:703:17: note: next is assigned
                LY_TREE_DFS_END(root, next, node);
                ^
src/printer_xml.c:703:17: note: next is overwritten
                LY_TREE_DFS_END(root, next, node);
                ^
src/printer_xml.c:548:17: style: The scope of the variable 'ns' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *ns;
                ^
src/printer_xml.c:694:35: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    level = (options & LYP_FORMAT ? 1 : 0);
                                  ^
src/printer_yang.c:139:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    level--;
    ^
src/printer_yang.c:313:30: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int flag = 0, flag2 = 0, i;
                             ^
src/printer_yang.c:464:17: style: The scope of the variable 'str' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *str;
                ^
src/printer_yang.c:466:24: style: The scope of the variable 'mod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_module *mod;
                       ^
src/printer_yang.c:642:17: style: The scope of the variable 'str' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *str;
                ^
src/printer_yang.c:884:17: style: The scope of the variable 'dflt' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *dflt;
                ^
src/printer_yang.c:922:24: style: The scope of the variable 'mod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_module *mod;
                       ^
src/printer_yang.c:1116:17: style: The scope of the variable 'dflt' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *dflt;
                ^
src/printer_yang.c:1254:12: style: The scope of the variable 'p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, p, flag = 0;
           ^
src/printer_yang.c:1413:24: style: The scope of the variable 'mod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_module *mod;
                       ^
src/printer_yang.c:1637:9: style: The scope of the variable 'p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int p;
        ^
src/printer_yang.c:1843:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
src/printer_yang.c:139:10: style: Variable 'level' is assigned a value that is never used. [unreadVariable]
    level--;
         ^
src/printer_yin.c:265:32: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int close = 0, close2 = 0, i;
                               ^
src/printer_yin.c:435:17: style: The scope of the variable 'str' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *str;
                ^
src/printer_yin.c:437:24: style: The scope of the variable 'mod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_module *mod;
                       ^
src/printer_yin.c:616:17: style: The scope of the variable 'str' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *str;
                ^
src/printer_yin.c:863:17: style: The scope of the variable 'dflt' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *dflt;
                ^
src/printer_yin.c:901:24: style: The scope of the variable 'mod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_module *mod;
                       ^
src/printer_yin.c:1099:17: style: The scope of the variable 'dflt' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *dflt;
                ^
src/printer_yin.c:1243:12: style: The scope of the variable 'p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, p, content = 0, content2;
           ^
src/printer_yin.c:1402:24: style: The scope of the variable 'mod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_module *mod;
                       ^
src/printer_yin.c:1640:9: style: The scope of the variable 'p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int p;
        ^
src/printer_yin.c:1851:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
src/resolve.c:577:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    id += ret;
    ^
src/resolve.c:3282:9: style: The if condition is the same as the previous if condition [duplicateCondition]
    if (intv) {
        ^
src/resolve.c:3224:9: note: First condition
    if (intv) {
        ^
src/resolve.c:3282:9: note: Second condition
    if (intv) {
        ^
src/resolve.c:1679:13: warning: Either the condition '!iff_data' is redundant or there is possible null pointer dereference: iff_data. [nullPointerRedundantCheck]
            iff_data->node = node;
            ^
src/resolve.c:1678:31: note: Assuming that condition '!iff_data' is not redundant
            LY_CHECK_ERR_GOTO(!iff_data, LOGMEM(ctx), error);
                              ^
src/resolve.c:1677:30: note: Assignment 'iff_data=malloc(sizeof(*iff_data))', assigned value is 0
            iff_data = malloc(sizeof *iff_data);
                             ^
src/resolve.c:1679:13: note: Null pointer dereference
            iff_data->node = node;
            ^
src/resolve.c:1680:13: warning: Either the condition '!iff_data' is redundant or there is possible null pointer dereference: iff_data. [nullPointerRedundantCheck]
            iff_data->fname = lydict_insert(node->module->ctx, &c[i], j - i);
            ^
src/resolve.c:1678:31: note: Assuming that condition '!iff_data' is not redundant
            LY_CHECK_ERR_GOTO(!iff_data, LOGMEM(ctx), error);
                              ^
src/resolve.c:1677:30: note: Assignment 'iff_data=malloc(sizeof(*iff_data))', assigned value is 0
            iff_data = malloc(sizeof *iff_data);
                             ^
src/resolve.c:1680:13: note: Null pointer dereference
            iff_data->fname = lydict_insert(node->module->ctx, &c[i], j - i);
            ^
src/resolve.c:1681:13: warning: Either the condition '!iff_data' is redundant or there is possible null pointer dereference: iff_data. [nullPointerRedundantCheck]
            iff_data->infeature = infeature;
            ^
src/resolve.c:1678:31: note: Assuming that condition '!iff_data' is not redundant
            LY_CHECK_ERR_GOTO(!iff_data, LOGMEM(ctx), error);
                              ^
src/resolve.c:1677:30: note: Assignment 'iff_data=malloc(sizeof(*iff_data))', assigned value is 0
            iff_data = malloc(sizeof *iff_data);
                             ^
src/resolve.c:1681:13: note: Null pointer dereference
            iff_data->infeature = infeature;
            ^
src/resolve.c:3705:13: warning: Either the condition '!dup' is redundant or there is possible null pointer dereference: dup. [nullPointerRedundantCheck]
            dup[len] = '\0';
            ^
src/resolve.c:3704:33: note: Assuming that condition '!dup' is not redundant
            LY_CHECK_ERR_RETURN(!dup, LOGMEM(ctx), -1);
                                ^
src/resolve.c:3703:25: note: Assignment 'dup=strdup(name)', assigned value is 0
            dup = strdup(name);
                        ^
src/resolve.c:3705:13: note: Null pointer dereference
            dup[len] = '\0';
            ^
src/resolve.c:4855:13: warning: Either the condition '!c' is redundant or there is possible null pointer dereference: c. [nullPointerRedundantCheck]
            c->name = lydict_insert(ctx, sub->name, 0);
            ^
src/resolve.c:4854:33: note: Assuming that condition '!c' is not redundant
            LY_CHECK_ERR_RETURN(!c, LOGMEM(ctx), EXIT_FAILURE);
                                ^
src/resolve.c:4853:23: note: Assignment 'c=calloc(1,sizeof(*c))', assigned value is 0
            c = calloc(1, sizeof *c);
                      ^
src/resolve.c:4855:13: note: Null pointer dereference
            c->name = lydict_insert(ctx, sub->name, 0);
            ^
src/resolve.c:4856:13: warning: Either the condition '!c' is redundant or there is possible null pointer dereference: c. [nullPointerRedundantCheck]
            c->flags = LYS_IMPLICIT | (sub->flags & LYS_CONFIG_MASK);
            ^
src/resolve.c:4854:33: note: Assuming that condition '!c' is not redundant
            LY_CHECK_ERR_RETURN(!c, LOGMEM(ctx), EXIT_FAILURE);
                                ^
src/resolve.c:4853:23: note: Assignment 'c=calloc(1,sizeof(*c))', assigned value is 0
            c = calloc(1, sizeof *c);
                      ^
src/resolve.c:4856:13: note: Null pointer dereference
            c->flags = LYS_IMPLICIT | (sub->flags & LYS_CONFIG_MASK);
            ^
src/resolve.c:4857:13: warning: Either the condition '!c' is redundant or there is possible null pointer dereference: c. [nullPointerRedundantCheck]
            c->module = sub->module;
            ^
src/resolve.c:4854:33: note: Assuming that condition '!c' is not redundant
            LY_CHECK_ERR_RETURN(!c, LOGMEM(ctx), EXIT_FAILURE);
                                ^
src/resolve.c:4853:23: note: Assignment 'c=calloc(1,sizeof(*c))', assigned value is 0
            c = calloc(1, sizeof *c);
                      ^
src/resolve.c:4857:13: note: Null pointer dereference
            c->module = sub->module;
            ^
src/resolve.c:4858:13: warning: Either the condition '!c' is redundant or there is possible null pointer dereference: c. [nullPointerRedundantCheck]
            c->nodetype = LYS_CASE;
            ^
src/resolve.c:4854:33: note: Assuming that condition '!c' is not redundant
            LY_CHECK_ERR_RETURN(!c, LOGMEM(ctx), EXIT_FAILURE);
                                ^
src/resolve.c:4853:23: note: Assignment 'c=calloc(1,sizeof(*c))', assigned value is 0
            c = calloc(1, sizeof *c);
                      ^
src/resolve.c:4858:13: note: Null pointer dereference
            c->nodetype = LYS_CASE;
            ^
src/resolve.c:4859:13: warning: Either the condition '!c' is redundant or there is possible null pointer dereference: c. [nullPointerRedundantCheck]
            c->parent = sub->parent;
            ^
src/resolve.c:4854:33: note: Assuming that condition '!c' is not redundant
            LY_CHECK_ERR_RETURN(!c, LOGMEM(ctx), EXIT_FAILURE);
                                ^
src/resolve.c:4853:23: note: Assignment 'c=calloc(1,sizeof(*c))', assigned value is 0
            c = calloc(1, sizeof *c);
                      ^
src/resolve.c:4859:13: note: Null pointer dereference
            c->parent = sub->parent;
            ^
src/resolve.c:4860:13: warning: Either the condition '!c' is redundant or there is possible null pointer dereference: c. [nullPointerRedundantCheck]
            c->prev = sub->prev != sub ? sub->prev : (struct lys_node*)c;
            ^
src/resolve.c:4854:33: note: Assuming that condition '!c' is not redundant
            LY_CHECK_ERR_RETURN(!c, LOGMEM(ctx), EXIT_FAILURE);
                                ^
src/resolve.c:4853:23: note: Assignment 'c=calloc(1,sizeof(*c))', assigned value is 0
            c = calloc(1, sizeof *c);
                      ^
src/resolve.c:4860:13: note: Null pointer dereference
            c->prev = sub->prev != sub ? sub->prev : (struct lys_node*)c;
            ^
src/resolve.c:4861:17: warning: Either the condition '!c' is redundant or there is possible null pointer dereference: c. [nullPointerRedundantCheck]
            if (c->prev->next) {
                ^
src/resolve.c:4854:33: note: Assuming that condition '!c' is not redundant
            LY_CHECK_ERR_RETURN(!c, LOGMEM(ctx), EXIT_FAILURE);
                                ^
src/resolve.c:4853:23: note: Assignment 'c=calloc(1,sizeof(*c))', assigned value is 0
            c = calloc(1, sizeof *c);
                      ^
src/resolve.c:4861:17: note: Null pointer dereference
            if (c->prev->next) {
                ^
src/resolve.c:5780:17: warning: Possible null pointer dereference: ident [nullPointer]
        flags = ident->flags;
                ^
src/resolve.c:6952:38: note: Calling function 'resolve_base_ident', 2nd argument 'NULL' value is 0
        rc = resolve_base_ident(mod, NULL, expr, "type", stype, unres);
                                     ^
src/resolve.c:5780:17: note: Null pointer dereference
        flags = ident->flags;
                ^
src/resolve.c:5781:15: warning: Possible null pointer dereference: ident [nullPointer]
        mod = ident->module;
              ^
src/resolve.c:6952:38: note: Calling function 'resolve_base_ident', 2nd argument 'NULL' value is 0
        rc = resolve_base_ident(mod, NULL, expr, "type", stype, unres);
                                     ^
src/resolve.c:5781:15: note: Null pointer dereference
        mod = ident->module;
              ^
src/resolve.c:7155:23: warning: Either the condition '!u' is redundant or there is possible null pointer dereference: u. [nullPointerRedundantCheck]
                    (*u) = ext_data->ext_index;
                      ^
src/resolve.c:7154:41: note: Assuming that condition '!u' is not redundant
                    LY_CHECK_ERR_RETURN(!u, LOGMEM(ctx), -1);
                                        ^
src/resolve.c:7153:31: note: Assignment 'u=malloc(sizeof(*u))', assigned value is 0
                    u = malloc(sizeof *u);
                              ^
src/resolve.c:7155:23: note: Null pointer dereference
                    (*u) = ext_data->ext_index;
                      ^
src/resolve.c:7220:21: warning: Either the condition '!extlist' is redundant or there is possible null pointer dereference: extlist. [nullPointerRedundantCheck]
                    extlist[node->ext_size] = malloc(sizeof **extlist);
                    ^
src/resolve.c:7219:41: note: Assuming that condition '!extlist' is not redundant
                    LY_CHECK_ERR_RETURN(!extlist, LOGMEM(ctx), -1);
                                        ^
src/resolve.c:7218:38: note: Assignment 'extlist=realloc(node->ext,(node->ext_size+1)*sizeof(*node->ext))', assigned value is 0
                    extlist = realloc(node->ext, (node->ext_size + 1) * sizeof *node->ext);
                                     ^
src/resolve.c:7220:21: note: Null pointer dereference
                    extlist[node->ext_size] = malloc(sizeof **extlist);
                    ^
src/resolve.c:7221:42: warning: Either the condition '!extlist' is redundant or there is possible null pointer dereference: extlist. [nullPointerRedundantCheck]
                    LY_CHECK_ERR_RETURN(!extlist[node->ext_size], LOGMEM(ctx); node->ext = extlist, -1);
                                         ^
src/resolve.c:7219:41: note: Assuming that condition '!extlist' is not redundant
                    LY_CHECK_ERR_RETURN(!extlist, LOGMEM(ctx), -1);
                                        ^
src/resolve.c:7218:38: note: Assignment 'extlist=realloc(node->ext,(node->ext_size+1)*sizeof(*node->ext))', assigned value is 0
                    extlist = realloc(node->ext, (node->ext_size + 1) * sizeof *node->ext);
                                     ^
src/resolve.c:7221:42: note: Null pointer dereference
                    LY_CHECK_ERR_RETURN(!extlist[node->ext_size], LOGMEM(ctx); node->ext = extlist, -1);
                                         ^
src/resolve.c:7222:28: warning: Either the condition '!extlist' is redundant or there is possible null pointer dereference: extlist. [nullPointerRedundantCheck]
                    memcpy(extlist[node->ext_size], ext, sizeof *ext);
                           ^
src/resolve.c:7219:41: note: Assuming that condition '!extlist' is not redundant
                    LY_CHECK_ERR_RETURN(!extlist, LOGMEM(ctx), -1);
                                        ^
src/resolve.c:7218:38: note: Assignment 'extlist=realloc(node->ext,(node->ext_size+1)*sizeof(*node->ext))', assigned value is 0
                    extlist = realloc(node->ext, (node->ext_size + 1) * sizeof *node->ext);
                                     ^
src/resolve.c:7222:28: note: Null pointer dereference
                    memcpy(extlist[node->ext_size], ext, sizeof *ext);
                           ^
src/resolve.c:7223:21: warning: Either the condition '!extlist' is redundant or there is possible null pointer dereference: extlist. [nullPointerRedundantCheck]
                    extlist[node->ext_size]->flags |= LYEXT_OPT_INHERIT;
                    ^
src/resolve.c:7219:41: note: Assuming that condition '!extlist' is not redundant
                    LY_CHECK_ERR_RETURN(!extlist, LOGMEM(ctx), -1);
                                        ^
src/resolve.c:7218:38: note: Assignment 'extlist=realloc(node->ext,(node->ext_size+1)*sizeof(*node->ext))', assigned value is 0
                    extlist = realloc(node->ext, (node->ext_size + 1) * sizeof *node->ext);
                                     ^
src/resolve.c:7223:21: note: Null pointer dereference
                    extlist[node->ext_size]->flags |= LYEXT_OPT_INHERIT;
                    ^
src/resolve.c:7656:9: warning: Either the condition '!iff_data' is redundant or there is possible null pointer dereference: iff_data. [nullPointerRedundantCheck]
        iff_data->fname = lydict_insert(mod->ctx, ((struct unres_iffeat_data *)unres->str_snode[i])->fname, 0);
        ^
src/resolve.c:7655:29: note: Assuming that condition '!iff_data' is not redundant
        LY_CHECK_ERR_RETURN(!iff_data, LOGMEM(mod->ctx), -1);
                            ^
src/resolve.c:7654:26: note: Assignment 'iff_data=malloc(sizeof(*iff_data))', assigned value is 0
        iff_data = malloc(sizeof *iff_data);
                         ^
src/resolve.c:7656:9: note: Null pointer dereference
        iff_data->fname = lydict_insert(mod->ctx, ((struct unres_iffeat_data *)unres->str_snode[i])->fname, 0);
        ^
src/resolve.c:7657:9: warning: Either the condition '!iff_data' is redundant or there is possible null pointer dereference: iff_data. [nullPointerRedundantCheck]
        iff_data->node = ((struct unres_iffeat_data *)unres->str_snode[i])->node;
        ^
src/resolve.c:7655:29: note: Assuming that condition '!iff_data' is not redundant
        LY_CHECK_ERR_RETURN(!iff_data, LOGMEM(mod->ctx), -1);
                            ^
src/resolve.c:7654:26: note: Assignment 'iff_data=malloc(sizeof(*iff_data))', assigned value is 0
        iff_data = malloc(sizeof *iff_data);
                         ^
src/resolve.c:7657:9: note: Null pointer dereference
        iff_data->node = ((struct unres_iffeat_data *)unres->str_snode[i])->node;
        ^
src/resolve.c:7658:9: warning: Either the condition '!iff_data' is redundant or there is possible null pointer dereference: iff_data. [nullPointerRedundantCheck]
        iff_data->infeature = ((struct unres_iffeat_data *)unres->str_snode[i])->infeature;
        ^
src/resolve.c:7655:29: note: Assuming that condition '!iff_data' is not redundant
        LY_CHECK_ERR_RETURN(!iff_data, LOGMEM(mod->ctx), -1);
                            ^
src/resolve.c:7654:26: note: Assignment 'iff_data=malloc(sizeof(*iff_data))', assigned value is 0
        iff_data = malloc(sizeof *iff_data);
                         ^
src/resolve.c:7658:9: note: Null pointer dereference
        iff_data->infeature = ((struct unres_iffeat_data *)unres->str_snode[i])->infeature;
        ^
src/resolve.c:5159:36: warning: Either the condition '!tmp_ext' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            memset((char *)tmp_ext + offsetof(struct lys_ext_instance_complex, content), 0,
                                   ^
src/resolve.c:5158:31: note: Assuming that condition '!tmp_ext' is not redundant
            LY_CHECK_ERR_GOTO(!tmp_ext, LOGMEM(ctx), error);
                              ^
src/resolve.c:5157:30: note: Assignment 'tmp_ext=realloc(*ext,((struct lyext_plugin_complex*)e->plugin)->instance_size)', assigned value is 0
            tmp_ext = realloc(*ext, ((struct lyext_plugin_complex*)e->plugin)->instance_size);
                             ^
src/resolve.c:5159:36: note: Null pointer addition
            memset((char *)tmp_ext + offsetof(struct lys_ext_instance_complex, content), 0,
                                   ^
src/resolve.c:2039:25: style: Variable 'next' is reassigned a value before the old one has been used. [redundantAssignment]
                        LY_TREE_DFS_END(sibling, next, elem);
                        ^
src/resolve.c:2039:25: note: next is assigned
                        LY_TREE_DFS_END(sibling, next, elem);
                        ^
src/resolve.c:2039:25: note: next is overwritten
                        LY_TREE_DFS_END(sibling, next, elem);
                        ^
src/resolve.c:2058:25: style: Variable 'next' is reassigned a value before the old one has been used. [redundantAssignment]
                        LY_TREE_DFS_END(sibling, next, elem);
                        ^
src/resolve.c:2058:25: note: next is assigned
                        LY_TREE_DFS_END(sibling, next, elem);
                        ^
src/resolve.c:2058:25: note: next is overwritten
                        LY_TREE_DFS_END(sibling, next, elem);
                        ^
src/resolve.c:8372:17: style: Variable 'next' is reassigned a value before the old one has been used. [redundantAssignment]
                LY_TREE_DFS_END(unres->diff->second[i], next, child);
                ^
src/resolve.c:8372:17: note: next is assigned
                LY_TREE_DFS_END(unres->diff->second[i], next, child);
                ^
src/resolve.c:8372:17: note: next is overwritten
                LY_TREE_DFS_END(unres->diff->second[i], next, child);
                ^
src/resolve.c:4702:5: warning: Redundant assignment of 'node' to itself. [selfAssignment]
    LY_TREE_FOR(node, node) {
    ^
src/resolve.c:7465:108: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
    if (resolve_unres_schema_types(unres, UNRES_USES | UNRES_IFFEAT | UNRES_TYPE_DER | UNRES_TYPE_DER_TPDF | UNRES_TYPE_DER_TPDF
                                                                                                           ^
src/resolve.c:783:21: style: The scope of the variable 'ret' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int parsed = 0, ret;
                    ^
src/resolve.c:784:10: style: The scope of the variable 'quote' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char quote;
         ^
src/resolve.c:1014:10: style: The scope of the variable 'quote' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char quote;
         ^
src/resolve.c:1723:17: style: The scope of the variable 'token' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *str, *token, *p;
                ^
src/resolve.c:1822:42: style: The scope of the variable 'r' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int mod_len, nam_len, has_predicate, r, i;
                                         ^
src/resolve.c:2308:22: style: The scope of the variable 'key' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_node *key;
                     ^
src/resolve.c:2527:11: style: The scope of the variable 'val_str' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *val_str;
          ^
src/resolve.c:4755:28: style: The scope of the variable 'next' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_node *sub, *next;
                           ^
src/resolve.c:4759:27: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_node_case *c;
                          ^
src/resolve.c:5853:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
src/resolve.c:6172:17: style: The scope of the variable 'rc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, len, rc;
                ^
src/resolve.c:6250:22: style: The scope of the variable 'schema' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_node *schema;
                     ^
src/resolve.c:6386:22: style: The scope of the variable 'sparent' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_node *sparent;
                     ^
src/resolve.c:6388:14: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint16_t i, data_depth, schema_depth;
             ^
src/resolve.c:6388:17: style: The scope of the variable 'data_depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint16_t i, data_depth, schema_depth;
                ^
src/resolve.c:6388:29: style: The scope of the variable 'schema_depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint16_t i, data_depth, schema_depth;
                            ^
src/resolve.c:6571:31: style: The scope of the variable 'iter' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_node *schema, *iter;
                              ^
src/resolve.c:6877:13: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint8_t i;
            ^
src/resolve.c:7534:24: style: The scope of the variable 'yin' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lyxml_elem *yin;
                       ^
src/resolve.c:7991:14: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t i;
             ^
src/resolve.c:1367:39: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    return feat->flags & LYS_FENABLED ? 1 : 0;
                                      ^
src/resolve.c:5475:57: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a+b?c:d'' should be written as either ''(a+b)?c:d'' or ''a+(b?c:d)''. [clarifyCalculation]
                    usize = (usize1 / 4) + (usize1 % 4) ? 1 : 0;
                                                        ^
src/resolve.c:2033:21: error: Uninitialized variable: all_desc [uninitvar]
                if (all_desc) {
                    ^
src/resolve.c:1698:9: style: Variable 'expr_size' is assigned a value that is never used. [unreadVariable]
    if (++expr_size || ++f_size) {
        ^
src/resolve.c:5770:23: style: Variable 'target' is not assigned a value. [unassignedVariable]
    struct lys_ident *target, **ret;
                      ^
src/tree_data.c:2654:73: error: syntax error [syntaxError]
                    LY_CHECK_ERR_RETURN(!trg_any->value.mem, LOGMEM(ctx), );
                                                                        ^
src/tree_schema.c:4636:68: error: syntax error [syntaxError]
                    LY_CHECK_ERR_RETURN(!inout, LOGMEM(module->ctx), );
                                                                   ^
src/user_types/user_inet_types.c:70:38: style: The scope of the variable 'tmp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *ptr, *ipv6_addr, *result, *tmp;
                                     ^
src/user_types/user_inet_types.c:210:14: style: The scope of the variable 'mask' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t mask;
             ^
src/validation.c:55:22: style: The scope of the variable 'sparent' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lys_node *sparent, *op;
                     ^
src/validation.c:379:22: style: The scope of the variable 'diter' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lyd_node *diter, *first, *second;
                     ^
src/validation.c:380:17: style: The scope of the variable 'val1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *val1, *val2;
                ^
src/validation.c:380:24: style: The scope of the variable 'val2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *val1, *val2;
                       ^
src/validation.c:381:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
src/xml.c:210:9: warning: Either the condition '!dup' is redundant or there is possible null pointer dereference: dup. [nullPointerRedundantCheck]
        dup->content = lydict_insert(ctx, elem->content, 0);
        ^
src/xml.c:209:29: note: Assuming that condition '!dup' is not redundant
        LY_CHECK_ERR_RETURN(!dup, LOGMEM(ctx), NULL);
                            ^
src/xml.c:208:21: note: Assignment 'dup=calloc(1,sizeof(*dup))', assigned value is 0
        dup = calloc(1, sizeof *dup);
                    ^
src/xml.c:210:9: note: Null pointer dereference
        dup->content = lydict_insert(ctx, elem->content, 0);
        ^
src/xml.c:211:9: warning: Either the condition '!dup' is redundant or there is possible null pointer dereference: dup. [nullPointerRedundantCheck]
        dup->name = lydict_insert(ctx, elem->name, 0);
        ^
src/xml.c:209:29: note: Assuming that condition '!dup' is not redundant
        LY_CHECK_ERR_RETURN(!dup, LOGMEM(ctx), NULL);
                            ^
src/xml.c:208:21: note: Assignment 'dup=calloc(1,sizeof(*dup))', assigned value is 0
        dup = calloc(1, sizeof *dup);
                    ^
src/xml.c:211:9: note: Null pointer dereference
        dup->name = lydict_insert(ctx, elem->name, 0);
        ^
src/xml.c:212:9: warning: Either the condition '!dup' is redundant or there is possible null pointer dereference: dup. [nullPointerRedundantCheck]
        dup->flags = elem->flags;
        ^
src/xml.c:209:29: note: Assuming that condition '!dup' is not redundant
        LY_CHECK_ERR_RETURN(!dup, LOGMEM(ctx), NULL);
                            ^
src/xml.c:208:21: note: Assignment 'dup=calloc(1,sizeof(*dup))', assigned value is 0
        dup = calloc(1, sizeof *dup);
                    ^
src/xml.c:212:9: note: Null pointer dereference
        dup->flags = elem->flags;
        ^
src/xml.c:213:9: warning: Either the condition '!dup' is redundant or there is possible null pointer dereference: dup. [nullPointerRedundantCheck]
        dup->prev = dup;
        ^
src/xml.c:209:29: note: Assuming that condition '!dup' is not redundant
        LY_CHECK_ERR_RETURN(!dup, LOGMEM(ctx), NULL);
                            ^
src/xml.c:208:21: note: Assignment 'dup=calloc(1,sizeof(*dup))', assigned value is 0
        dup = calloc(1, sizeof *dup);
                    ^
src/xml.c:213:9: note: Null pointer dereference
        dup->prev = dup;
        ^
src/xml.c:770:9: warning: Either the condition '!attr' is redundant or there is possible null pointer dereference: attr. [nullPointerRedundantCheck]
        attr->type = LYXML_ATTR_NS;
        ^
src/xml.c:768:29: note: Assuming that condition '!attr' is not redundant
        LY_CHECK_ERR_RETURN(!attr, LOGMEM(ctx), NULL);
                            ^
src/xml.c:767:22: note: Assignment 'attr=calloc(1,sizeof(struct lyxml_ns))', assigned value is 0
        attr = calloc(1, sizeof (struct lyxml_ns));
                     ^
src/xml.c:770:9: note: Null pointer dereference
        attr->type = LYXML_ATTR_NS;
        ^
src/xml.c:771:10: warning: Either the condition '!attr' is redundant or there is possible null pointer dereference: (struct lyxml_ns*)attr. [nullPointerRedundantCheck]
        ((struct lyxml_ns *)attr)->parent = parent;
         ^
src/xml.c:768:29: note: Assuming that condition '!attr' is not redundant
        LY_CHECK_ERR_RETURN(!attr, LOGMEM(ctx), NULL);
                            ^
src/xml.c:767:22: note: Assignment 'attr=calloc(1,sizeof(struct lyxml_ns))', assigned value is 0
        attr = calloc(1, sizeof (struct lyxml_ns));
                     ^
src/xml.c:771:10: note: Null pointer dereference
        ((struct lyxml_ns *)attr)->parent = parent;
         ^
src/xml.c:771:29: warning: Either the condition '!attr' is redundant or there is possible null pointer dereference: attr. [nullPointerRedundantCheck]
        ((struct lyxml_ns *)attr)->parent = parent;
                            ^
src/xml.c:768:29: note: Assuming that condition '!attr' is not redundant
        LY_CHECK_ERR_RETURN(!attr, LOGMEM(ctx), NULL);
                            ^
src/xml.c:767:22: note: Assignment 'attr=calloc(1,sizeof(struct lyxml_ns))', assigned value is 0
        attr = calloc(1, sizeof (struct lyxml_ns));
                     ^
src/xml.c:771:29: note: Null pointer dereference
        ((struct lyxml_ns *)attr)->parent = parent;
                            ^
src/xml.c:783:9: warning: Either the condition '!attr' is redundant or there is possible null pointer dereference: attr. [nullPointerRedundantCheck]
        attr->type = LYXML_ATTR_STD;
        ^
src/xml.c:781:29: note: Assuming that condition '!attr' is not redundant
        LY_CHECK_ERR_RETURN(!attr, LOGMEM(ctx), NULL);
                            ^
src/xml.c:780:22: note: Assignment 'attr=calloc(1,sizeof(*attr))', assigned value is 0
        attr = calloc(1, sizeof *attr);
                     ^
src/xml.c:783:9: note: Null pointer dereference
        attr->type = LYXML_ATTR_STD;
        ^
src/xml.c:809:24: warning: Either the condition '!prefix' is redundant or there is possible null pointer dereference: prefix. [nullPointerRedundantCheck]
                memcpy(prefix, data, c - data);
                       ^
src/xml.c:808:35: note: Assuming that condition '!prefix' is not redundant
                LY_CHECK_ERR_GOTO(!prefix, LOGMEM(ctx), error);
                                  ^
src/xml.c:807:32: note: Assignment 'prefix=malloc((c-data+1)*sizeof(*prefix))', assigned value is 0
                prefix = malloc((c - data + 1) * sizeof *prefix);
                               ^
src/xml.c:809:24: note: Null pointer dereference
                memcpy(prefix, data, c - data);
                       ^
src/xml.c:810:17: warning: Either the condition '!prefix' is redundant or there is possible null pointer dereference: prefix. [nullPointerRedundantCheck]
                prefix[c - data] = '\0';
                ^
src/xml.c:808:35: note: Assuming that condition '!prefix' is not redundant
                LY_CHECK_ERR_GOTO(!prefix, LOGMEM(ctx), error);
                                  ^
src/xml.c:807:32: note: Assignment 'prefix=malloc((c-data+1)*sizeof(*prefix))', assigned value is 0
                prefix = malloc((c - data + 1) * sizeof *prefix);
                               ^
src/xml.c:810:17: note: Null pointer dereference
                prefix[c - data] = '\0';
                ^
src/xml.c:917:20: warning: Either the condition '!prefix' is redundant or there is possible null pointer dereference: prefix. [nullPointerRedundantCheck]
            memcpy(prefix, c, prefix_len);
                   ^
src/xml.c:916:31: note: Assuming that condition '!prefix' is not redundant
            LY_CHECK_ERR_GOTO(!prefix, LOGMEM(ctx), error);
                              ^
src/xml.c:915:28: note: Assignment 'prefix=malloc((prefix_len+1)*sizeof(*prefix))', assigned value is 0
            prefix = malloc((prefix_len + 1) * sizeof *prefix);
                           ^
src/xml.c:917:20: note: Null pointer dereference
            memcpy(prefix, c, prefix_len);
                   ^
src/xml.c:918:13: warning: Either the condition '!prefix' is redundant or there is possible null pointer dereference: prefix. [nullPointerRedundantCheck]
            prefix[prefix_len] = '\0';
            ^
src/xml.c:916:31: note: Assuming that condition '!prefix' is not redundant
            LY_CHECK_ERR_GOTO(!prefix, LOGMEM(ctx), error);
                              ^
src/xml.c:915:28: note: Assignment 'prefix=malloc((prefix_len+1)*sizeof(*prefix))', assigned value is 0
            prefix = malloc((prefix_len + 1) * sizeof *prefix);
                           ^
src/xml.c:918:13: note: Null pointer dereference
            prefix[prefix_len] = '\0';
            ^
src/xml.c:934:5: warning: Either the condition '!elem' is redundant or there is possible null pointer dereference: elem. [nullPointerRedundantCheck]
    elem->next = NULL;
    ^
src/xml.c:932:25: note: Assuming that condition '!elem' is not redundant
    LY_CHECK_ERR_RETURN(!elem, free(prefix); LOGMEM(ctx), NULL);
                        ^
src/xml.c:931:18: note: Assignment 'elem=calloc(1,sizeof(*elem))', assigned value is 0
    elem = calloc(1, sizeof *elem);
                 ^
src/xml.c:934:5: note: Null pointer dereference
    elem->next = NULL;
    ^
src/xml.c:935:5: warning: Either the condition '!elem' is redundant or there is possible null pointer dereference: elem. [nullPointerRedundantCheck]
    elem->prev = elem;
    ^
src/xml.c:932:25: note: Assuming that condition '!elem' is not redundant
    LY_CHECK_ERR_RETURN(!elem, free(prefix); LOGMEM(ctx), NULL);
                        ^
src/xml.c:931:18: note: Assignment 'elem=calloc(1,sizeof(*elem))', assigned value is 0
    elem = calloc(1, sizeof *elem);
                 ^
src/xml.c:935:5: note: Null pointer dereference
    elem->prev = elem;
    ^
src/xml.c:999:24: warning: Either the condition '!str' is redundant or there is possible null pointer dereference: str. [nullPointerRedundantCheck]
                memcpy(str, c, e - c);
                       ^
src/xml.c:998:35: note: Assuming that condition '!str' is not redundant
                LY_CHECK_ERR_GOTO(!str, LOGMEM(ctx), error);
                                  ^
src/xml.c:997:29: note: Assignment 'str=malloc((size+1)*sizeof(*str))', assigned value is 0
                str = malloc((size + 1) * sizeof *str);
                            ^
src/xml.c:999:24: note: Null pointer dereference
                memcpy(str, c, e - c);
                       ^
src/xml.c:1000:17: warning: Either the condition '!str' is redundant or there is possible null pointer dereference: str. [nullPointerRedundantCheck]
                str[e - c] = '\0';
                ^
src/xml.c:998:35: note: Assuming that condition '!str' is not redundant
                LY_CHECK_ERR_GOTO(!str, LOGMEM(ctx), error);
                                  ^
src/xml.c:997:29: note: Assignment 'str=malloc((size+1)*sizeof(*str))', assigned value is 0
                str = malloc((size + 1) * sizeof *str);
                            ^
src/xml.c:1000:17: note: Null pointer dereference
                str[e - c] = '\0';
                ^
src/xml.c:1066:21: warning: Either the condition '!child' is redundant or there is possible null pointer dereference: child. [nullPointerRedundantCheck]
                    child->content = elem->content;
                    ^
src/xml.c:1065:39: note: Assuming that condition '!child' is not redundant
                    LY_CHECK_ERR_GOTO(!child, LOGMEM(ctx), error);
                                      ^
src/xml.c:1064:35: note: Assignment 'child=calloc(1,sizeof(*child))', assigned value is 0
                    child = calloc(1, sizeof *child);
                                  ^
src/xml.c:1066:21: note: Null pointer dereference
                    child->content = elem->content;
                    ^
src/xml.c:1102:21: warning: Either the condition '!child' is redundant or there is possible null pointer dereference: child. [nullPointerRedundantCheck]
                    child->content = elem->content;
                    ^
src/xml.c:1101:39: note: Assuming that condition '!child' is not redundant
                    LY_CHECK_ERR_GOTO(!child, LOGMEM(ctx), error);
                                      ^
src/xml.c:1100:35: note: Assignment 'child=calloc(1,sizeof(*child))', assigned value is 0
                    child = calloc(1, sizeof *child);
                                  ^
src/xml.c:1102:21: note: Null pointer dereference
                    child->content = elem->content;
                    ^
src/xml.c:193:9: style: Variable 'tmp' is reassigned a value before the old one has been used. [redundantAssignment]
        LY_TREE_DFS_END(elem, tmp, iter);
        ^
src/xml.c:193:9: note: tmp is assigned
        LY_TREE_DFS_END(elem, tmp, iter);
        ^
src/xml.c:193:9: note: tmp is overwritten
        LY_TREE_DFS_END(elem, tmp, iter);
        ^
src/xml.c:207:5: warning: Redundant assignment of 'elem' to itself. [selfAssignment]
    LY_TREE_FOR(elem, elem) {
    ^
src/xml.c:80:28: style: The scope of the variable 'tmp_ns' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const struct lyxml_ns *tmp_ns;
                           ^
src/xml.c:330:32: style: The scope of the variable 'aprev' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lyxml_attr *aiter, *aprev;
                               ^
src/xml.c:741:14: style: Variable 'size' is assigned a value that is never used. [unreadVariable]
        size = 0;
             ^
src/xpath.c:306:51: error: syntax error [syntaxError]
        LY_CHECK_ERR_RETURN(!str_num, LOGMEM(NULL), );
                                                  ^
swig/cpp/examples/process_notif_tree.cpp:71:17: style: The scope of the variable 'data_xml' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *data_xml = "<busy xmlns=\"cpu-notif\">\n"
                ^
swig/cpp/src/Internal.cpp:46:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'context' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    context = NULL;
    ^
swig/cpp/src/Internal.cpp:53:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'context' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    context = NULL;
    ^
swig/cpp/src/Internal.cpp:60:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'context' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    context = NULL;
    ^
swig/cpp/src/Internal.cpp:67:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'context' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    context = NULL;
    ^
swig/cpp/src/Internal.cpp:74:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'context' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    context = NULL;
    ^
swig/cpp/src/Internal.cpp:88:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'context' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    context = NULL;
    ^
swig/cpp/src/Internal.cpp:95:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'context' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    context = NULL;
    ^
swig/cpp/src/Internal.hpp:252:5: style: Class 'Deleter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Deleter(ly_ctx *ctx, S_Deleter parent = nullptr);
    ^
swig/cpp/src/Internal.hpp:253:5: style: Class 'Deleter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Deleter(struct lyd_node *data, S_Deleter parent = nullptr);
    ^
swig/cpp/src/Internal.hpp:254:5: style: Class 'Deleter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Deleter(struct lys_node *schema, S_Deleter parent = nullptr);
    ^
swig/cpp/src/Internal.hpp:255:5: style: Class 'Deleter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Deleter(struct lys_module *module, S_Deleter parent = nullptr);
    ^
swig/cpp/src/Internal.hpp:256:5: style: Class 'Deleter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Deleter(struct lys_submodule *submodule, S_Deleter parent = nullptr);
    ^
swig/cpp/src/Internal.hpp:258:5: style: Class 'Deleter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Deleter(struct ly_set *set, S_Deleter parent = nullptr);
    ^
swig/cpp/src/Internal.hpp:259:5: style: Class 'Deleter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Deleter(struct lyd_difflist *diff, S_Deleter parent = nullptr);
    ^
swig/cpp/src/Libyang.hpp:162:5: style: Class 'Error' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Error(struct ly_err_item *eitem);
    ^
swig/cpp/src/Tree_Schema.hpp:608:5: style: Class 'Schema_Node_Container' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Schema_Node_Container(S_Schema_Node derived):
    ^
swig/cpp/src/Tree_Schema.hpp:641:5: style: Class 'Schema_Node_Choice' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Schema_Node_Choice(S_Schema_Node derived):
    ^
swig/cpp/src/Tree_Schema.hpp:670:5: style: Class 'Schema_Node_Leaf' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Schema_Node_Leaf(S_Schema_Node derived):
    ^
swig/cpp/src/Tree_Schema.hpp:708:5: style: Class 'Schema_Node_Leaflist' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Schema_Node_Leaflist(S_Schema_Node derived):
    ^
swig/cpp/src/Tree_Schema.hpp:754:5: style: Class 'Schema_Node_List' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Schema_Node_List(S_Schema_Node derived):
    ^
swig/cpp/src/Tree_Schema.hpp:803:5: style: Class 'Schema_Node_Anydata' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Schema_Node_Anydata(S_Schema_Node derived):
    ^
swig/cpp/src/Tree_Schema.hpp:834:5: style: Class 'Schema_Node_Uses' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Schema_Node_Uses(S_Schema_Node derived):
    ^
swig/cpp/src/Tree_Schema.hpp:869:5: style: Class 'Schema_Node_Grp' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Schema_Node_Grp(S_Schema_Node derived):
    ^
swig/cpp/src/Tree_Schema.hpp:898:5: style: Class 'Schema_Node_Case' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Schema_Node_Case(S_Schema_Node derived):
    ^
swig/cpp/src/Tree_Schema.hpp:925:5: style: Class 'Schema_Node_Inout' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Schema_Node_Inout(S_Schema_Node derived):
    ^
swig/cpp/src/Tree_Schema.hpp:958:5: style: Class 'Schema_Node_Notif' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Schema_Node_Notif(S_Schema_Node derived):
    ^
swig/cpp/src/Tree_Schema.hpp:991:5: style: Class 'Schema_Node_Rpc_Action' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Schema_Node_Rpc_Action(S_Schema_Node derived):
    ^
swig/cpp/src/Tree_Schema.hpp:1020:5: style: Class 'Schema_Node_Augment' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Schema_Node_Augment(S_Schema_Node derived):
    ^
swig/cpp/src/Tree_Schema.hpp:1424:5: style: Class 'When' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    When(struct lys_when *when, S_Deleter deleter = nullptr);
    ^
swig/cpp/src/Tree_Data.hpp:101:5: style: Class 'Data_Node' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Data_Node(struct lyd_node *node, S_Deleter deleter = nullptr);
    ^
swig/cpp/src/Tree_Data.hpp:231:5: style: Class 'Data_Node_Leaf_List' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Data_Node_Leaf_List(S_Data_Node derived);
    ^
swig/cpp/src/Tree_Data.hpp:233:5: style: Class 'Data_Node_Leaf_List' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Data_Node_Leaf_List(struct lyd_node *node, S_Deleter deleter = nullptr);
    ^
swig/cpp/src/Tree_Data.hpp:265:5: style: Class 'Data_Node_Anydata' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Data_Node_Anydata(S_Data_Node derived);
    ^
swig/cpp/src/Tree_Data.hpp:267:5: style: Class 'Data_Node_Anydata' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Data_Node_Anydata(struct lyd_node *node, S_Deleter deleter = nullptr);
    ^
swig/cpp/src/Tree_Data.hpp:289:5: style: Class 'Attr' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Attr(struct lyd_attr *attr, S_Deleter deleter = nullptr);
    ^
swig/cpp/src/Tree_Data.hpp:242:17: style: The function 'child' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    S_Data_Node child() {return nullptr;};
                ^
swig/cpp/src/Tree_Data.hpp:142:25: note: Virtual function in base class
    virtual S_Data_Node child() LY_NEW(node, child, Data_Node);
                        ^
swig/cpp/src/Tree_Data.hpp:242:17: note: Function in derived class
    S_Data_Node child() {return nullptr;};
                ^
swig/cpp/src/Tree_Data.hpp:274:17: style: The function 'child' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    S_Data_Node child() {return nullptr;};
                ^
swig/cpp/src/Tree_Data.hpp:142:25: note: Virtual function in base class
    virtual S_Data_Node child() LY_NEW(node, child, Data_Node);
                        ^
swig/cpp/src/Tree_Data.hpp:274:17: note: Function in derived class
    S_Data_Node child() {return nullptr;};
                ^
swig/cpp/src/Libyang.cpp:104:17: style: Condition 'mod==nullptr' is always false [knownConditionTrueFalse]
        if (mod == nullptr) {
                ^
swig/cpp/src/Libyang.cpp:103:17: note: Assuming that condition 'mod=ly_ctx_get_module_iter(ctx,&i)' is not redundant
    while ((mod = ly_ctx_get_module_iter(ctx, &i))) {
                ^
swig/cpp/src/Libyang.cpp:104:17: note: Condition 'mod==nullptr' is always false
        if (mod == nullptr) {
                ^
swig/cpp/src/Libyang.cpp:119:17: style: Condition 'mod==nullptr' is always false [knownConditionTrueFalse]
        if (mod == nullptr) {
                ^
swig/cpp/src/Libyang.cpp:118:17: note: Assuming that condition 'mod=ly_ctx_get_disabled_module_iter(ctx,&i)' is not redundant
    while ((mod = ly_ctx_get_disabled_module_iter(ctx, &i))) {
                ^
swig/cpp/src/Libyang.cpp:119:17: note: Condition 'mod==nullptr' is always false
        if (mod == nullptr) {
                ^
swig/cpp/src/Tree_Data.cpp:125:62: warning: Either the condition 'module?module->module->ctx:parent->node->schema->module->ctx' is redundant or there is possible null pointer dereference: module. [nullPointerRedundantCheck]
    new_node = lyd_new_anydata(parent ? parent->node : NULL, module->module, name,
                                                             ^
swig/cpp/src/Tree_Data.cpp:128:36: note: Assuming that condition 'module?module->module->ctx:parent->node->schema->module->ctx' is not redundant
        check_libyang_error(module ? module->module->ctx : parent->node->schema->module->ctx);
                                   ^
swig/cpp/src/Tree_Data.cpp:125:62: note: Null pointer dereference
    new_node = lyd_new_anydata(parent ? parent->node : NULL, module->module, name,
                                                             ^
swig/cpp/src/Tree_Data.cpp:594:13: style: Variable 'deleter' is assigned a value that is never used. [unreadVariable]
    deleter = std::make_shared<Deleter>(diff, deleter);
            ^
swig/cpp/tests/test_libyang.cpp:646:1: portability: %lu in format string (no. 2) requires 'unsigned long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
TEST_MAIN();
^
swig/cpp/tests/test_libyang.cpp:58:17: style: The scope of the variable 'yang_folder' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *yang_folder = "INVALID_PATH";
                ^
swig/cpp/tests/test_libyang.cpp:165:17: style: The scope of the variable 'name1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *name1 = "a";
                ^
swig/cpp/tests/test_libyang.cpp:166:17: style: The scope of the variable 'name2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *name2 = "b";
                ^
swig/cpp/tests/test_libyang.cpp:167:17: style: The scope of the variable 'revision' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *revision = "2016-03-01";
                ^
swig/cpp/tests/test_libyang.cpp:208:17: style: The scope of the variable 'name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *name = "b";
                ^
swig/cpp/tests/test_libyang.cpp:209:17: style: The scope of the variable 'revision' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *revision = "2016-03-01";
                ^
swig/cpp/tests/test_libyang.cpp:210:17: style: The scope of the variable 'revision_older' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *revision_older = "2015-01-01";
                ^
swig/cpp/tests/test_libyang.cpp:238:17: style: The scope of the variable 'module_name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *module_name = "a";
                ^
swig/cpp/tests/test_libyang.cpp:239:17: style: The scope of the variable 'ns' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *ns = "urn:a";
                ^
swig/cpp/tests/test_libyang.cpp:261:17: style: The scope of the variable 'module_name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *module_name = "a";
                ^
swig/cpp/tests/test_libyang.cpp:290:17: style: The scope of the variable 'module_name1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *module_name1 = "a";
                ^
swig/cpp/tests/test_libyang.cpp:291:17: style: The scope of the variable 'module_name2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *module_name2 = "b";
                ^
swig/cpp/tests/test_libyang.cpp:330:17: style: The scope of the variable 'module_name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *module_name = "a";
                ^
swig/cpp/tests/test_libyang.cpp:331:17: style: The scope of the variable 'sub_name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *sub_name = "asub";
                ^
swig/cpp/tests/test_libyang.cpp:352:17: style: The scope of the variable 'sub_name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *sub_name = "asub";
                ^
swig/cpp/tests/test_libyang.cpp:377:17: style: The scope of the variable 'schema_path1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *schema_path1 = "/b:x/b:bubba";
                ^
swig/cpp/tests/test_libyang.cpp:378:17: style: The scope of the variable 'schema_path2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *schema_path2 = "/a:x/a:bubba";
                ^
swig/cpp/tests/test_libyang.cpp:482:17: style: The scope of the variable 'module_name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *module_name = "a";
                ^
swig/cpp/tests/test_libyang.cpp:503:17: style: The scope of the variable 'module_name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *module_name = "x";
                ^
swig/cpp/tests/test_libyang.cpp:526:17: style: The scope of the variable 'module_name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *module_name = "b";
                ^
swig/cpp/tests/test_libyang.cpp:548:17: style: The scope of the variable 'module_name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *module_name = "b";
                ^
swig/cpp/tests/microtest.h:117:39: performance: Parameter 'description' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
    AssertFailedException(std::string description, std::string filepath, int line) :
                                      ^
swig/cpp/tests/microtest.h:117:64: performance: Parameter 'filepath' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
    AssertFailedException(std::string description, std::string filepath, int line) :
                                                               ^
swig/cpp/tests/test_libyang.cpp:62:9: warning: Conversion of string literal "exception not thrown" to bool always evaluates to true. [incorrectStringBooleanError]
        ASSERT_FALSE("exception not thrown");
        ^
swig/cpp/tests/test_tree_data.cpp:767:1: portability: %lu in format string (no. 2) requires 'unsigned long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
TEST_MAIN();
^
swig/cpp/tests/test_tree_data.cpp:136:17: style: The scope of the variable 'a_data_xml' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *a_data_xml = "\
                ^
swig/cpp/tests/test_tree_data.cpp:186:17: style: The scope of the variable 'module_name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *module_name = "a";
                ^
swig/cpp/tests/test_tree_data.cpp:187:17: style: The scope of the variable 'schema_name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *schema_name = "x";
                ^
swig/cpp/tests/test_tree_data.cpp:689:17: style: The scope of the variable 'sch' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *sch = "module x {"
                ^
swig/cpp/tests/test_tree_data.cpp:693:17: style: The scope of the variable 'data' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *data = "<x xmlns=\"urn:x\">hello</x>";
                ^
swig/cpp/tests/test_tree_schema.cpp:608:1: portability: %lu in format string (no. 2) requires 'unsigned long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
TEST_MAIN();
^
swig/cpp/tests/test_tree_schema.cpp:525:17: style: The scope of the variable 'module_name1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *module_name1 = "b";
                ^
swig/cpp/tests/test_tree_schema.cpp:547:17: style: The scope of the variable 'module_name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *module_name = "b";
                ^
tests/api/test_dict.c:196:9: error: Memory pointed to by 'value' is freed twice. [doubleFree]
        free(value);
        ^
tests/api/test_dict.c:189:9: note: Memory pointed to by 'value' is freed twice.
        free(value);
        ^
tests/api/test_dict.c:196:9: note: Memory pointed to by 'value' is freed twice.
        free(value);
        ^
tests/api/test_diff.c:217:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:214:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:217:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:222:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:214:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:222:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:228:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:214:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:228:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:231:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:214:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:231:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:265:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:262:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:265:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:270:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:262:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:270:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:276:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:262:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:276:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:279:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:262:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:279:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:313:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:310:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:313:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:353:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:350:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:353:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:358:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:350:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:358:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:361:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:350:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:361:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:401:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:398:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:401:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:439:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:433:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:439:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:442:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:433:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:442:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:481:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:475:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:481:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:484:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:475:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:484:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:489:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:475:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:489:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:492:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:475:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:492:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:498:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:475:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:498:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:531:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:527:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:531:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:536:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:527:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:536:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:542:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:527:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:542:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:548:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:527:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:548:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:554:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:527:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:554:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:557:5: error: Memory pointed to by 'str' is freed twice. [doubleFree]
    free(str);
    ^
tests/api/test_diff.c:527:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_diff.c:557:5: note: Memory pointed to by 'str' is freed twice.
    free(str);
    ^
tests/api/test_libyang.c:1466:9: style: Condition 'new_ctx' is always false [knownConditionTrueFalse]
    if (new_ctx) {
        ^
tests/api/test_libyang.c:1464:30: note: Assignment 'new_ctx=NULL', assigned value is 0
    struct ly_ctx *new_ctx = NULL;
                             ^
tests/api/test_libyang.c:1466:9: note: Condition 'new_ctx' is always false
    if (new_ctx) {
        ^
tests/api/test_libyang.c:311:30: style: Local variable 'module' shadows outer variable [shadowVariable]
    const struct lys_module *module;
                             ^
tests/api/test_libyang.c:39:26: note: Shadowed declaration
const struct lys_module *module = NULL;
                         ^
tests/api/test_libyang.c:311:30: note: Shadow variable
    const struct lys_module *module;
                             ^
tests/api/test_libyang.c:374:30: style: Local variable 'module' shadows outer variable [shadowVariable]
    const struct lys_module *module = NULL;
                             ^
tests/api/test_libyang.c:39:26: note: Shadowed declaration
const struct lys_module *module = NULL;
                         ^
tests/api/test_libyang.c:374:30: note: Shadow variable
    const struct lys_module *module = NULL;
                             ^
tests/api/test_libyang.c:412:30: style: Local variable 'module' shadows outer variable [shadowVariable]
    const struct lys_module *module;
                             ^
tests/api/test_libyang.c:39:26: note: Shadowed declaration
const struct lys_module *module = NULL;
                         ^
tests/api/test_libyang.c:412:30: note: Shadow variable
    const struct lys_module *module;
                             ^
tests/api/test_libyang.c:458:20: style: Local variable 'ctx' shadows outer variable [shadowVariable]
    struct ly_ctx *ctx;
                   ^
tests/api/test_libyang.c:37:16: note: Shadowed declaration
struct ly_ctx *ctx = NULL;
               ^
tests/api/test_libyang.c:458:20: note: Shadow variable
    struct ly_ctx *ctx;
                   ^
tests/api/test_libyang.c:511:20: style: Local variable 'ctx' shadows outer variable [shadowVariable]
    struct ly_ctx *ctx;
                   ^
tests/api/test_libyang.c:37:16: note: Shadowed declaration
struct ly_ctx *ctx = NULL;
               ^
tests/api/test_libyang.c:511:20: note: Shadow variable
    struct ly_ctx *ctx;
                   ^
tests/api/test_libyang.c:783:30: style: Local variable 'module' shadows outer variable [shadowVariable]
    const struct lys_module *module;
                             ^
tests/api/test_libyang.c:39:26: note: Shadowed declaration
const struct lys_module *module = NULL;
                         ^
tests/api/test_libyang.c:783:30: note: Shadow variable
    const struct lys_module *module;
                             ^
tests/api/test_libyang.c:1293:30: style: Local variable 'module' shadows outer variable [shadowVariable]
    const struct lys_module *module = NULL;
                             ^
tests/api/test_libyang.c:39:26: note: Shadowed declaration
const struct lys_module *module = NULL;
                         ^
tests/api/test_libyang.c:1293:30: note: Shadow variable
    const struct lys_module *module = NULL;
                             ^
tests/api/test_libyang.c:1337:20: style: Local variable 'ctx' shadows outer variable [shadowVariable]
    struct ly_ctx *ctx;
                   ^
tests/api/test_libyang.c:37:16: note: Shadowed declaration
struct ly_ctx *ctx = NULL;
               ^
tests/api/test_libyang.c:1337:20: note: Shadow variable
    struct ly_ctx *ctx;
                   ^
tests/api/test_libyang.c:623:11: style: Variable 'setid' is assigned a value that is never used. [unreadVariable]
    setid = ctx->models.module_set_id;
          ^
tests/api/test_tree_data.c:340:9: style: Condition 'root' is always true [knownConditionTrueFalse]
    if (root)
        ^
tests/api/test_tree_data.c:334:9: note: Assuming that condition '!root' is not redundant
    if (!root) {
        ^
tests/api/test_tree_data.c:340:9: note: Condition 'root' is always true
    if (root)
        ^
tests/api/test_tree_data.c:388:9: style: Condition 'root' is always true [knownConditionTrueFalse]
    if (root)
        ^
tests/api/test_tree_data.c:382:9: note: Assuming that condition '!root' is not redundant
    if (!root) {
        ^
tests/api/test_tree_data.c:388:9: note: Condition 'root' is always true
    if (root)
        ^
tests/api/test_tree_data.c:432:9: style: Condition 'root' is always true [knownConditionTrueFalse]
    if (root)
        ^
tests/api/test_tree_data.c:426:9: note: Assuming that condition '!root' is not redundant
    if (!root) {
        ^
tests/api/test_tree_data.c:432:9: note: Condition 'root' is always true
    if (root)
        ^
tests/api/test_tree_data.c:475:9: style: Condition 'node' is always true [knownConditionTrueFalse]
    if (node)
        ^
tests/api/test_tree_data.c:469:9: note: Assuming that condition '!node' is not redundant
    if (!node) {
        ^
tests/api/test_tree_data.c:475:9: note: Condition 'node' is always true
    if (node)
        ^
tests/api/test_tree_data.c:1540:5: error: Memory pointed to by 'buf' is freed twice. [doubleFree]
    free(buf);
    ^
tests/api/test_tree_data.c:1537:9: note: Memory pointed to by 'buf' is freed twice.
        free(buf);
        ^
tests/api/test_tree_data.c:1540:5: note: Memory pointed to by 'buf' is freed twice.
    free(buf);
    ^
tests/api/test_tree_data.c:1564:5: error: Memory pointed to by 'buf' is freed twice. [doubleFree]
    free(buf);
    ^
tests/api/test_tree_data.c:1561:9: note: Memory pointed to by 'buf' is freed twice.
        free(buf);
        ^
tests/api/test_tree_data.c:1564:5: note: Memory pointed to by 'buf' is freed twice.
    free(buf);
    ^
tests/api/test_tree_data.c:1588:5: error: Memory pointed to by 'buf' is freed twice. [doubleFree]
    free(buf);
    ^
tests/api/test_tree_data.c:1585:9: note: Memory pointed to by 'buf' is freed twice.
        free(buf);
        ^
tests/api/test_tree_data.c:1588:5: note: Memory pointed to by 'buf' is freed twice.
    free(buf);
    ^
tests/api/test_tree_data.c:1657:10: style: Redundant initialization for 'node'. The initialized value is overwritten before it is read. [redundantInitialization]
    node = new;
         ^
tests/api/test_tree_data.c:1653:27: note: node is initialized
    struct lyd_node *node = root;
                          ^
tests/api/test_tree_data.c:1657:10: note: node is overwritten
    node = new;
         ^
tests/api/test_tree_data.c:321:20: style: Local variable 'ctx' shadows outer variable [shadowVariable]
    struct ly_ctx *ctx = NULL;
                   ^
tests/api/test_tree_data.c:37:16: note: Shadowed declaration
struct ly_ctx *ctx = NULL;
               ^
tests/api/test_tree_data.c:321:20: note: Shadow variable
    struct ly_ctx *ctx = NULL;
                   ^
tests/api/test_tree_data.c:322:22: style: Local variable 'root' shadows outer variable [shadowVariable]
    struct lyd_node *root = NULL;
                     ^
tests/api/test_tree_data.c:38:18: note: Shadowed declaration
struct lyd_node *root = NULL;
                 ^
tests/api/test_tree_data.c:322:22: note: Shadow variable
    struct lyd_node *root = NULL;
                     ^
tests/api/test_tree_data.c:362:20: style: Local variable 'ctx' shadows outer variable [shadowVariable]
    struct ly_ctx *ctx = NULL;
                   ^
tests/api/test_tree_data.c:37:16: note: Shadowed declaration
struct ly_ctx *ctx = NULL;
               ^
tests/api/test_tree_data.c:362:20: note: Shadow variable
    struct ly_ctx *ctx = NULL;
                   ^
tests/api/test_tree_data.c:363:22: style: Local variable 'root' shadows outer variable [shadowVariable]
    struct lyd_node *root = NULL;
                     ^
tests/api/test_tree_data.c:38:18: note: Shadowed declaration
struct lyd_node *root = NULL;
                 ^
tests/api/test_tree_data.c:363:22: note: Shadow variable
    struct lyd_node *root = NULL;
                     ^
tests/api/test_tree_data.c:413:20: style: Local variable 'ctx' shadows outer variable [shadowVariable]
    struct ly_ctx *ctx = NULL;
                   ^
tests/api/test_tree_data.c:37:16: note: Shadowed declaration
struct ly_ctx *ctx = NULL;
               ^
tests/api/test_tree_data.c:413:20: note: Shadow variable
    struct ly_ctx *ctx = NULL;
                   ^
tests/api/test_tree_data.c:414:22: style: Local variable 'root' shadows outer variable [shadowVariable]
    struct lyd_node *root = NULL;
                     ^
tests/api/test_tree_data.c:38:18: note: Shadowed declaration
struct lyd_node *root = NULL;
                 ^
tests/api/test_tree_data.c:414:22: note: Shadow variable
    struct lyd_node *root = NULL;
                     ^
tests/api/test_tree_data.c:454:20: style: Local variable 'ctx' shadows outer variable [shadowVariable]
    struct ly_ctx *ctx = NULL;
                   ^
tests/api/test_tree_data.c:37:16: note: Shadowed declaration
struct ly_ctx *ctx = NULL;
               ^
tests/api/test_tree_data.c:454:20: note: Shadow variable
    struct ly_ctx *ctx = NULL;
                   ^
tests/api/test_tree_data.c:568:29: style: Local variable 'root' shadows outer variable [shadowVariable]
    struct lyd_node *node, *root;
                            ^
tests/api/test_tree_data.c:38:18: note: Shadowed declaration
struct lyd_node *root = NULL;
                 ^
tests/api/test_tree_data.c:568:29: note: Shadow variable
    struct lyd_node *node, *root;
                            ^
tests/api/test_tree_data.c:915:22: style: Local variable 'root' shadows outer variable [shadowVariable]
    struct lyd_node *root, *node, *node2;
                     ^
tests/api/test_tree_data.c:38:18: note: Shadowed declaration
struct lyd_node *root = NULL;
                 ^
tests/api/test_tree_data.c:915:22: note: Shadow variable
    struct lyd_node *root, *node, *node2;
                     ^
tests/api/test_tree_data.c:1611:20: style: Local variable 'ctx' shadows outer variable [shadowVariable]
    struct ly_ctx *ctx = (struct ly_ctx *)*state;
                   ^
tests/api/test_tree_data.c:37:16: note: Shadowed declaration
struct ly_ctx *ctx = NULL;
               ^
tests/api/test_tree_data.c:1611:20: note: Shadow variable
    struct ly_ctx *ctx = (struct ly_ctx *)*state;
                   ^
tests/api/test_tree_schema.c:722:17: style: Variable 'node_parent' is reassigned a value before the old one has been used. [redundantAssignment]
    node_parent = lys_parent(node_child);
                ^
tests/api/test_tree_schema.c:717:17: note: node_parent is assigned
    node_parent = module->data;
                ^
tests/api/test_tree_schema.c:722:17: note: node_parent is overwritten
    node_parent = lys_parent(node_child);
                ^
tests/api/test_xml.c:426:5: error: Memory pointed to by 'buf' is freed twice. [doubleFree]
    free(buf);
    ^
tests/api/test_xml.c:422:9: note: Memory pointed to by 'buf' is freed twice.
        free(buf);
        ^
tests/api/test_xml.c:426:5: note: Memory pointed to by 'buf' is freed twice.
    free(buf);
    ^
tests/conformance/test_sec6_1_3.c:132:30: style: The scope of the variable 'mod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const struct lys_module *mod;
                             ^
tests/data/test_json.c:572:10: style: Variable 'leaf' is assigned a value that is never used. [unreadVariable]
    leaf = (struct lyd_node_leaf_list *)leaf->next;
         ^
tests/data/test_parse_print.c:898:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(TESTS_DIR"/data/files/all.yin", O_RDONLY);
       ^
tests/data/test_parse_print.c:889:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:898:8: note: fd is overwritten
    fd = open(TESTS_DIR"/data/files/all.yin", O_RDONLY);
       ^
tests/data/test_parse_print.c:950:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(TESTS_DIR"/data/files/all.yang", O_RDONLY);
       ^
tests/data/test_parse_print.c:941:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:950:8: note: fd is overwritten
    fd = open(TESTS_DIR"/data/files/all.yang", O_RDONLY);
       ^
tests/data/test_parse_print.c:1002:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(rpc, O_RDONLY);
       ^
tests/data/test_parse_print.c:993:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1002:8: note: fd is overwritten
    fd = open(rpc, O_RDONLY);
       ^
tests/data/test_parse_print.c:1023:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(rpcreply, O_RDONLY);
       ^
tests/data/test_parse_print.c:1016:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1023:8: note: fd is overwritten
    fd = open(rpcreply, O_RDONLY);
       ^
tests/data/test_parse_print.c:1055:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(act, O_RDONLY);
       ^
tests/data/test_parse_print.c:1044:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1055:8: note: fd is overwritten
    fd = open(act, O_RDONLY);
       ^
tests/data/test_parse_print.c:1076:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(actreply, O_RDONLY);
       ^
tests/data/test_parse_print.c:1069:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1076:8: note: fd is overwritten
    fd = open(actreply, O_RDONLY);
       ^
tests/data/test_parse_print.c:1106:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(notif, O_RDONLY);
       ^
tests/data/test_parse_print.c:1095:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1106:8: note: fd is overwritten
    fd = open(notif, O_RDONLY);
       ^
tests/data/test_parse_print.c:1129:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(innotif, O_RDONLY);
       ^
tests/data/test_parse_print.c:1120:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1129:8: note: fd is overwritten
    fd = open(innotif, O_RDONLY);
       ^
tests/data/test_parse_print.c:1183:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(rpc, O_RDONLY);
       ^
tests/data/test_parse_print.c:1174:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1183:8: note: fd is overwritten
    fd = open(rpc, O_RDONLY);
       ^
tests/data/test_parse_print.c:1204:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(rpcreply, O_RDONLY);
       ^
tests/data/test_parse_print.c:1197:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1204:8: note: fd is overwritten
    fd = open(rpcreply, O_RDONLY);
       ^
tests/data/test_parse_print.c:1236:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(act, O_RDONLY);
       ^
tests/data/test_parse_print.c:1225:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1236:8: note: fd is overwritten
    fd = open(act, O_RDONLY);
       ^
tests/data/test_parse_print.c:1257:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(actreply, O_RDONLY);
       ^
tests/data/test_parse_print.c:1250:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1257:8: note: fd is overwritten
    fd = open(actreply, O_RDONLY);
       ^
tests/data/test_parse_print.c:1287:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(notif, O_RDONLY);
       ^
tests/data/test_parse_print.c:1276:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1287:8: note: fd is overwritten
    fd = open(notif, O_RDONLY);
       ^
tests/data/test_parse_print.c:1312:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(innotif, O_RDONLY);
       ^
tests/data/test_parse_print.c:1301:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1312:8: note: fd is overwritten
    fd = open(innotif, O_RDONLY);
       ^
tests/data/test_parse_print.c:1364:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(xml, O_RDONLY);
       ^
tests/data/test_parse_print.c:1355:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1364:8: note: fd is overwritten
    fd = open(xml, O_RDONLY);
       ^
tests/data/test_parse_print.c:1425:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(rpc, O_RDONLY);
       ^
tests/data/test_parse_print.c:1416:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1425:8: note: fd is overwritten
    fd = open(rpc, O_RDONLY);
       ^
tests/data/test_parse_print.c:1452:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(rpcreply, O_RDONLY);
       ^
tests/data/test_parse_print.c:1445:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1452:8: note: fd is overwritten
    fd = open(rpcreply, O_RDONLY);
       ^
tests/data/test_parse_print.c:1490:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(act, O_RDONLY);
       ^
tests/data/test_parse_print.c:1479:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1490:8: note: fd is overwritten
    fd = open(act, O_RDONLY);
       ^
tests/data/test_parse_print.c:1517:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(actreply, O_RDONLY);
       ^
tests/data/test_parse_print.c:1510:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1517:8: note: fd is overwritten
    fd = open(actreply, O_RDONLY);
       ^
tests/data/test_parse_print.c:1553:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(notif, O_RDONLY);
       ^
tests/data/test_parse_print.c:1542:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1553:8: note: fd is overwritten
    fd = open(notif, O_RDONLY);
       ^
tests/data/test_parse_print.c:1582:8: style: Variable 'fd' is reassigned a value before the old one has been used. [redundantAssignment]
    fd = open(innotif, O_RDONLY);
       ^
tests/data/test_parse_print.c:1573:8: note: fd is assigned
    fd = -1;
       ^
tests/data/test_parse_print.c:1582:8: note: fd is overwritten
    fd = open(innotif, O_RDONLY);
       ^
tests/internal/test_lyb.c:42:31: error: Uninitialized variable: *next [uninitvar]
    LY_TREE_DFS_BEGIN(*start, *next, *elem) {
                              ^
tests/internal/test_lyb.c:72:39: note: Calling function 'check_data_tree_next', 2nd argument '&next1' value is <Uninit>
    for (check_data_tree_next(&root1, &next1, &elem1), check_data_tree_next(&root2, &next2, &elem2);
                                      ^
tests/internal/test_lyb.c:42:31: note: Uninitialized variable: *next
    LY_TREE_DFS_BEGIN(*start, *next, *elem) {
                              ^
tests/internal/test_lyb.c:64:68: style: Unused variable: iter [unusedVariable]
    struct lyd_node *next1, *next2, *elem1 = NULL, *elem2 = NULL, *iter;
                                                                   ^
tests/internal/test_state_lists.c:41:25: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t orig_hash, i;
                        ^
tests/perf/validation_xml.c:50:6: style: Condition '!sdoc' is always false [knownConditionTrueFalse]
 if (!sdoc) {
     ^
tests/perf/validation_xml.c:43:6: note: Assuming that condition '!sdoc' is not redundant
 if (!sdoc) {
     ^
tests/perf/validation_xml.c:50:6: note: Condition '!sdoc' is always false
 if (!sdoc) {
     ^
tests/schema/test_augment.c:163:22: style: Variable 'module' is assigned a value that is never used. [unreadVariable]
        if (!(module = lys_parse_path(ctx, path, LYS_IN_YIN))) {
                     ^
tests/schema/test_augment.c:168:22: style: Variable 'module' is assigned a value that is never used. [unreadVariable]
        if (!(module = lys_parse_path(ctx, path, LYS_IN_YANG))) {
                     ^
tests/schema/test_augment.c:194:22: style: Variable 'module' is assigned a value that is never used. [unreadVariable]
        if (!(module = lys_parse_path(ctx, path, LYS_IN_YIN))) {
                     ^
tests/schema/test_augment.c:199:22: style: Variable 'module' is assigned a value that is never used. [unreadVariable]
        if (!(module = lys_parse_path(ctx, path, LYS_IN_YANG))) {
                     ^
tests/schema/test_augment.c:226:22: style: Variable 'module' is assigned a value that is never used. [unreadVariable]
        if (!(module = lys_parse_path(ctx, path, LYS_IN_YIN))) {
                     ^
tests/schema/test_augment.c:231:22: style: Variable 'module' is assigned a value that is never used. [unreadVariable]
        if (!(module = lys_parse_path(ctx, path, LYS_IN_YANG))) {
                     ^
tests/schema/test_augment.c:260:22: style: Variable 'module' is assigned a value that is never used. [unreadVariable]
        if (!(module = lys_parse_path(ctx, path, LYS_IN_YIN))) {
                     ^
tests/schema/test_augment.c:265:22: style: Variable 'module' is assigned a value that is never used. [unreadVariable]
        if (!(module = lys_parse_path(ctx, path, LYS_IN_YANG))) {
                     ^
tests/schema/test_augment.c:362:22: style: Variable 'module' is assigned a value that is never used. [unreadVariable]
        if (!(module = lys_parse_path(ctx, path, LYS_IN_YIN))) {
                     ^
tests/schema/test_augment.c:369:22: style: Variable 'module' is assigned a value that is never used. [unreadVariable]
        if (!(module = lys_parse_path(ctx, path, LYS_IN_YANG))) {
                     ^
tests/schema/test_extensions.c:3482:30: style: The scope of the variable 'mod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const struct lys_module *mod;
                             ^
tests/schema/test_extensions.c:3829:30: style: The scope of the variable 'mod' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const struct lys_module *mod;
                             ^
tests/schema/test_ietf.c:121:30: style: The scope of the variable 'module' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const struct lys_module *module;
                             ^
tests/schema/test_ietf.c:158:12: style: The scope of the variable 'ch1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, ch1, ch2;
           ^
tests/schema/test_ietf.c:158:17: style: The scope of the variable 'ch2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, ch1, ch2;
                ^
tests/schema/test_ietf.c:159:11: style: The scope of the variable 'f1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    FILE *f1, *f2;
          ^
tests/schema/test_ietf.c:159:16: style: The scope of the variable 'f2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    FILE *f1, *f2;
               ^
tests/schema/test_ietf.c:161:12: style: Local variable 'files' shadows outer variable [shadowVariable]
    char (*files)[2 * SCHEMA_COUNT][50] = *state;
           ^
tests/schema/test_ietf.c:40:6: note: Shadowed declaration
char files[SCHEMA_COUNT][32] = { "iana-crypt-hash", "iana-if-type",
     ^
tests/schema/test_ietf.c:161:12: note: Shadow variable
    char (*files)[2 * SCHEMA_COUNT][50] = *state;
           ^
tests/schema/test_refine.c:74:18: style: Variable 'module' is assigned a value that is never used. [unreadVariable]
    if (!(module = lys_parse_path(ctx, path, LYS_IN_YANG))) {
                 ^
tools/lint/commands.c:373:17: style: Variable 'ptr' is reassigned a value before the old one has been used. [redundantAssignment]
    while ((ptr = strtok(NULL, " "))) {
                ^
tools/lint/commands.c:372:9: note: ptr is assigned
    ptr = strtok(*argv, " ");
        ^
tools/lint/commands.c:373:17: note: ptr is overwritten
    while ((ptr = strtok(NULL, " "))) {
                ^
tools/lint/commands.c:683:17: style: Variable 'ptr' is reassigned a value before the old one has been used. [redundantAssignment]
    while ((ptr = strtok(NULL, " "))) {
                ^
tools/lint/commands.c:682:9: note: ptr is assigned
    ptr = strtok(*argv, " ");
        ^
tools/lint/commands.c:683:17: note: ptr is overwritten
    while ((ptr = strtok(NULL, " "))) {
                ^
tools/lint/commands.c:868:17: style: Variable 'ptr' is reassigned a value before the old one has been used. [redundantAssignment]
    while ((ptr = strtok(NULL, " "))) {
                ^
tools/lint/commands.c:867:9: note: ptr is assigned
    ptr = strtok(*argv, " ");
        ^
tools/lint/commands.c:868:17: note: ptr is overwritten
    while ((ptr = strtok(NULL, " "))) {
                ^
tools/lint/commands.c:1112:17: style: Variable 'ptr' is reassigned a value before the old one has been used. [redundantAssignment]
    while ((ptr = strtok(NULL, " "))) {
                ^
tools/lint/commands.c:1111:9: note: ptr is assigned
    ptr = strtok(*argv, " ");
        ^
tools/lint/commands.c:1112:17: note: ptr is overwritten
    while ((ptr = strtok(NULL, " "))) {
                ^
tools/lint/commands.c:1186:17: style: Variable 'ptr' is reassigned a value before the old one has been used. [redundantAssignment]
    while ((ptr = strtok(NULL, " "))) {
                ^
tools/lint/commands.c:1185:9: note: ptr is assigned
    ptr = strtok(*argv, " ");
        ^
tools/lint/commands.c:1186:17: note: ptr is overwritten
    while ((ptr = strtok(NULL, " "))) {
                ^
tools/lint/commands.c:1037:22: style: The scope of the variable 'ylib' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    struct lyd_node *ylib;
                     ^
tools/lint/commands.c:1304:25: style: The scope of the variable 'searchpaths' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char * const *searchpaths;
                        ^
tools/lint/commands.c:1305:9: style: The scope of the variable 'index' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int index;
        ^
tools/lint/main.c:71:32: style: Redundant condition: If 'EXPR == ' '', the comparison 'EXPR' is always true. [redundantCondition]
        for (i = 0; cmdline[i] && (cmdline[i] == ' '); i++);
                               ^
tools/lint/main_ni.c:169:11: style: The scope of the variable 'levstr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *levstr;
          ^
tools/yang2yin/main.c:337:19: style: The scope of the variable 'ret' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int used = 0, ret, slash = 0, comment = 0, string = 0, indent = 0, str_nl_indent = 0;
                  ^
src/common.c:813:17: warning: Null pointer dereference: exp [ctunullpointer]
    while (*i < exp->used) {
                ^
src/common.c:943:25: note: Assuming that condition '!exp' is not redundant

                        ^
src/common.c:942:26: note: Assignment 'exp=lyxp_parse_expr(cur_module->ctx,expr)', assigned value is 0

                         ^
src/common.c:946:37: note: Calling function transform_json2xpath_subexpr, 3rd argument is null
    if (transform_json2xpath_subexpr(cur_module, cur_module, exp, &i, LYXP_TOKEN_NONE, &out, &out_used, &out_size)) {
                                    ^
src/common.c:813:17: note: Dereferencing argument exp that is null
    while (*i < exp->used) {
                ^
src/printer.c:92:13: warning: Null pointer dereference: out [ctunullpointer]
    switch (out->type) {
            ^
src/printer_tree.c:424:29: note: Assuming that condition '!o' is not redundant

                            ^
src/printer_tree.c:423:19: note: Assignment 'o=malloc(sizeof(*o))', assigned value is 0

                  ^
src/printer_tree.c:433:23: note: Calling function ly_print, 1st argument is null
    printed = ly_print(o, "{");
                      ^
src/printer.c:92:13: note: Dereferencing argument out that is null
    switch (out->type) {
            ^
swig/cpp/src/Tree_Data.cpp:545:0: style: The function 'change_leaf' is never used. [unusedFunction]

^
swig/cpp/src/Libyang.cpp:409:0: style: The function 'contains' is never used. [unusedFunction]

^
swig/cpp/src/Libyang.cpp:441:0: style: The function 'create_new_Context' is never used. [unusedFunction]

^
swig/cpp/src/Tree_Data.cpp:626:0: style: The function 'create_new_Data_Node' is never used. [unusedFunction]

^
swig/cpp/src/Tree_Data.cpp:215:0: style: The function 'dup_withsiblings' is never used. [unusedFunction]

^
swig/cpp/src/Tree_Schema.cpp:83:0: style: The function 'feature_disable' is never used. [unusedFunction]

^
swig/cpp/src/Xml.cpp:57:0: style: The function 'get_attr' is never used. [unusedFunction]

^
src/common.c:164:0: style: The function 'get_current_dir_name' is never used. [unusedFunction]

^
swig/cpp/src/Xml.cpp:60:0: style: The function 'get_ns' is never used. [unusedFunction]

^
swig/cpp/src/Tree_Data.cpp:469:0: style: The function 'insert_attr' is never used. [unusedFunction]

^
swig/cpp/src/Tree_Data.cpp:555:0: style: The function 'leaf_type' is never used. [unusedFunction]

^
linenoise/linenoise.c:1162:0: style: The function 'linenoiseHistorySetMaxLen' is never used. [unusedFunction]

^
linenoise/linenoise.c:1022:0: style: The function 'linenoisePrintKeyCodes' is never used. [unusedFunction]

^
linenoise/linenoise.c:187:0: style: The function 'linenoiseSetMultiLine' is never used. [unusedFunction]

^
swig/cpp/src/Tree_Data.cpp:449:0: style: The function 'list_pos' is never used. [unusedFunction]

^
src/context.c:423:0: style: The function 'ly_ctx_get_options' is never used. [unusedFunction]

^
src/context.c:841:0: style: The function 'ly_ctx_set_priv_dup_clb' is never used. [unusedFunction]

^
src/common.c:90:0: style: The function 'ly_errapptag' is never used. [unusedFunction]

^
src/common.c:37:0: style: The function 'ly_errno_glob_address' is never used. [unusedFunction]

^
src/log.c:228:0: style: The function 'ly_log' is never used. [unusedFunction]

^
src/log.c:240:0: style: The function 'ly_log_dbg' is never used. [unusedFunction]

^
src/common.c:1344:0: style: The function 'ly_strequal_' is never used. [unusedFunction]

^
src/common.c:1477:0: style: The function 'ly_strlen_utf8' is never used. [unusedFunction]

^
src/log.c:851:0: style: The function 'ly_vlog' is never used. [unusedFunction]

^
src/printer.c:211:0: style: The function 'ly_write_skip' is never used. [unusedFunction]

^
src/printer.c:261:0: style: The function 'ly_write_skipped' is never used. [unusedFunction]

^
src/parser_json.c:1391:0: style: The function 'lyd_parse_json' is never used. [unusedFunction]

^
src/parser_lyb.c:1217:0: style: The function 'lyd_parse_lyb' is never used. [unusedFunction]

^
src/log.c:328:0: style: The function 'lyext_vlog' is never used. [unusedFunction]

^
src/printer.c:480:0: style: The function 'lys_print_clb' is never used. [unusedFunction]

^
src/printer.c:416:0: style: The function 'lys_print_path' is never used. [unusedFunction]

^
swig/cpp/src/Tree_Data.cpp:251:0: style: The function 'merge_to_ctx' is never used. [unusedFunction]

^
swig/cpp/src/Tree_Data.cpp:479:0: style: The function 'node_module' is never used. [unusedFunction]

^
swig/cpp/src/Libyang.cpp:264:0: style: The function 'parse_data_xml' is never used. [unusedFunction]

^
swig/cpp/src/Tree_Schema.cpp:326:0: style: The function 'ptdf' is never used. [unusedFunction]

^
src/resolve.c:2613:0: style: The function 'resolve_partial_json_data_nodeid' is never used. [unusedFunction]

^
src/resolve.c:8404:0: style: The function 'resolve_unres_data' is never used. [unusedFunction]

^
swig/cpp/src/Libyang.cpp:344:0: style: The function 'set_log_options' is never used. [unusedFunction]

^
swig/cpp/src/Libyang.cpp:349:0: style: The function 'set_log_verbosity' is never used. [unusedFunction]

^
tests/api/test_libyang.c:1589:0: style: The function 'test_ly_set_contains' is never used. [unusedFunction]

^
tests/api/test_libyang.c:1556:0: style: The function 'test_ly_set_merge' is never used. [unusedFunction]

^
tests/api/test_tree_data.c:1734:0: style: The function 'test_lyd_list_pos' is never used. [unusedFunction]

^
src/common.c:928:0: style: The function 'transform_json2xpath' is never used. [unusedFunction]

^
swig/cpp/src/Tree_Data.cpp:504:0: style: The function 'tree_for' is never used. [unusedFunction]

^
src/resolve.c:7623:0: style: The function 'unres_schema_dup' is never used. [unusedFunction]

^
swig/cpp/src/Tree_Data.cpp:552:0: style: The function 'wd_default' is never used. [unusedFunction]

^
swig/cpp/src/Tree_Schema.cpp:280:0: style: The function 'xpath_atomize' is never used. [unusedFunction]

^
src/parser_yang.c:2743:0: style: The function 'yang_read_submodule' is never used. [unusedFunction]

^
src/parser_yin.c:7446:0: style: The function 'yin_read_module' is never used. [unusedFunction]

^
src/parser_yin.c:7251:0: style: The function 'yin_read_submodule' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3842:0: style: The function 'yy_flex_strlen' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3460:0: style: The function 'yy_scan_string' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3559:0: style: The function 'yyget_column' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3664:0: style: The function 'yyget_debug' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3572:0: style: The function 'yyget_in' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3546:0: style: The function 'yyget_lineno' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3690:0: style: The function 'yyget_lloc' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3678:0: style: The function 'yyget_lval' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3581:0: style: The function 'yyget_out' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3735:0: style: The function 'yylex_init_extra' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3322:0: style: The function 'yypush_buffer_state' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3635:0: style: The function 'yyset_column' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3670:0: style: The function 'yyset_debug' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3652:0: style: The function 'yyset_in' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3620:0: style: The function 'yyset_lineno' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3696:0: style: The function 'yyset_lloc' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3684:0: style: The function 'yyset_lval' is never used. [unusedFunction]

^
src/parser_yang_lex.c:3658:0: style: The function 'yyset_out' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingInclude]


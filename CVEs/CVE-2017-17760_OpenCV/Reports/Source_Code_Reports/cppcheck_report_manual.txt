3rdparty/carotene/src/add_weighted.cpp:107:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'valpha' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        valpha = vdupq_n_f32(_alpha);
        ^
3rdparty/carotene/src/add_weighted.cpp:151:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'valpha' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        valpha = vdupq_n_f32(_alpha);
        ^
3rdparty/carotene/src/add_weighted.cpp:195:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'valpha' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        valpha = vdupq_n_f32(_alpha);
        ^
3rdparty/carotene/src/blur.cpp:85:38: warning: Either the condition '!srow0' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            internal::prefetch(srow0 + x);
                                     ^
3rdparty/carotene/src/blur.cpp:89:28: note: Assuming that condition '!srow0' is not redundant
            uint8x8_t x0 = !srow0 ? v_border : vld1_u8(srow0 + x);
                           ^
3rdparty/carotene/src/blur.cpp:85:38: note: Null pointer addition
            internal::prefetch(srow0 + x);
                                     ^
3rdparty/carotene/src/blur.cpp:87:38: warning: Either the condition '!srow2' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            internal::prefetch(srow2 + x);
                                     ^
3rdparty/carotene/src/blur.cpp:91:28: note: Assuming that condition '!srow2' is not redundant
            uint8x8_t x2 = !srow2 ? v_border : vld1_u8(srow2 + x);
                           ^
3rdparty/carotene/src/blur.cpp:87:38: note: Null pointer addition
            internal::prefetch(srow2 + x);
                                     ^
3rdparty/carotene/src/canny.cpp:54:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'vfmask' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        vfmask = vreinterpret_u8_u64(vmov_n_u64(borderxl ? 0x0000FFffFFffFFffULL : 0x0100FFffFFffFFffULL));
        ^
3rdparty/carotene/src/cmp.cpp:57:40: style: Parameter 'x' can be declared with const [constParameter]
                               size_t &x, size_t width)
                                       ^
3rdparty/carotene/src/colorconvert.cpp:1675:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'vc14216' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        vc14216 = vdupq_n_u16(-COEFF_R);
        ^
3rdparty/carotene/src/common.cpp:60:9: style: Condition '!isSupportedConfiguration()' is always true [knownConditionTrueFalse]
    if (!isSupportedConfiguration()) {
        ^
3rdparty/carotene/src/common.cpp:60:9: style: Condition '!isSupportedConfiguration()' is always false [knownConditionTrueFalse]
    if (!isSupportedConfiguration()) {
        ^
3rdparty/carotene/src/convolution.cpp:148:38: warning: Either the condition '!srow0' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            internal::prefetch(srow0 + x);
                                     ^
3rdparty/carotene/src/convolution.cpp:152:28: note: Assuming that condition '!srow0' is not redundant
            uint8x8_t x0 = !srow0 ? v_border : vld1_u8(srow0 + x);
                           ^
3rdparty/carotene/src/convolution.cpp:148:38: note: Null pointer addition
            internal::prefetch(srow0 + x);
                                     ^
3rdparty/carotene/src/convolution.cpp:150:38: warning: Either the condition '!srow2' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            internal::prefetch(srow2 + x);
                                     ^
3rdparty/carotene/src/convolution.cpp:154:28: note: Assuming that condition '!srow2' is not redundant
            uint8x8_t x2 = !srow2 ? v_border : vld1_u8(srow2 + x);
                           ^
3rdparty/carotene/src/convolution.cpp:150:38: note: Null pointer addition
            internal::prefetch(srow2 + x);
                                     ^
3rdparty/carotene/src/intrinsics.hpp:55:17: style: Local variable 'reciprocal' shadows outer function [shadowFunction]
    float32x4_t reciprocal = vrecpeq_f32(val);
                ^
3rdparty/carotene/src/div.cpp:561:6: note: Shadowed declaration
void reciprocal(const Size2D &size,
     ^
3rdparty/carotene/src/intrinsics.hpp:55:17: note: Shadow variable
    float32x4_t reciprocal = vrecpeq_f32(val);
                ^
3rdparty/carotene/src/intrinsics.hpp:63:17: style: Local variable 'reciprocal' shadows outer function [shadowFunction]
    float32x2_t reciprocal = vrecpe_f32(val);
                ^
3rdparty/carotene/src/div.cpp:561:6: note: Shadowed declaration
void reciprocal(const Size2D &size,
     ^
3rdparty/carotene/src/intrinsics.hpp:63:17: note: Shadow variable
    float32x2_t reciprocal = vrecpe_f32(val);
                ^
3rdparty/carotene/src/div.cpp:56:46: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
    const int32x4_t signMask = vdupq_n_s32(1 << 31), half = vreinterpretq_s32_f32(vdupq_n_f32(0.5f));
                                             ^
3rdparty/carotene/src/div.cpp:79:45: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
    const int32x2_t signMask = vdup_n_s32(1 << 31), half = vreinterpret_s32_f32(vdup_n_f32(0.5f));
                                            ^
3rdparty/carotene/src/fill_minmaxloc.cpp:85:58: style: Parameter 'minLocCount' can be declared with const [constParameter]
                    u8 minVal, size_t * minLocPtr, s32 & minLocCount, s32 minLocCapacity,
                                                         ^
3rdparty/carotene/src/fill_minmaxloc.cpp:86:58: style: Parameter 'maxLocCount' can be declared with const [constParameter]
                    u8 maxVal, size_t * maxLocPtr, s32 & maxLocCount, s32 maxLocCapacity)
                                                         ^
3rdparty/carotene/src/fill_minmaxloc.cpp:166:59: style: Parameter 'minLocCount' can be declared with const [constParameter]
                    u16 minVal, size_t * minLocPtr, s32 & minLocCount, s32 minLocCapacity,
                                                          ^
3rdparty/carotene/src/fill_minmaxloc.cpp:167:59: style: Parameter 'maxLocCount' can be declared with const [constParameter]
                    u16 maxVal, size_t * maxLocPtr, s32 & maxLocCount, s32 maxLocCapacity)
                                                          ^
3rdparty/carotene/src/fill_minmaxloc.cpp:246:59: style: Parameter 'minLocCount' can be declared with const [constParameter]
                    s16 minVal, size_t * minLocPtr, s32 & minLocCount, s32 minLocCapacity,
                                                          ^
3rdparty/carotene/src/fill_minmaxloc.cpp:247:59: style: Parameter 'maxLocCount' can be declared with const [constParameter]
                    s16 maxVal, size_t * maxLocPtr, s32 & maxLocCount, s32 maxLocCapacity)
                                                          ^
3rdparty/carotene/src/fill_minmaxloc.cpp:326:59: style: Parameter 'minLocCount' can be declared with const [constParameter]
                    s32 minVal, size_t * minLocPtr, s32 & minLocCount, s32 minLocCapacity,
                                                          ^
3rdparty/carotene/src/fill_minmaxloc.cpp:327:59: style: Parameter 'maxLocCount' can be declared with const [constParameter]
                    s32 maxVal, size_t * maxLocPtr, s32 & maxLocCount, s32 maxLocCapacity)
                                                          ^
3rdparty/carotene/src/fill_minmaxloc.cpp:385:59: style: Parameter 'minLocCount' can be declared with const [constParameter]
                    u32 minVal, size_t * minLocPtr, s32 & minLocCount, s32 minLocCapacity,
                                                          ^
3rdparty/carotene/src/fill_minmaxloc.cpp:386:59: style: Parameter 'maxLocCount' can be declared with const [constParameter]
                    u32 maxVal, size_t * maxLocPtr, s32 & maxLocCount, s32 maxLocCapacity)
                                                          ^
3rdparty/carotene/src/separable_filter.hpp:117:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'vw0' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        vw0 = vdupq_n_s16(w[0]);
        ^
3rdparty/carotene/src/separable_filter.hpp:345:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'vw0' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        vw0 = vdupq_n_s16(w[0]);
        ^
3rdparty/carotene/src/separable_filter.hpp:508:70: warning: Either the condition 'src2==0' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
                        vst1q_s16(dst + j, vqsubq_s16(vld1q_s16(src2 + j), v_border));
                                                                     ^
3rdparty/carotene/src/separable_filter.hpp:498:31: note: Assuming that condition 'src2==0' is not redundant
        if (src0 == 0 || src2 == 0)
                              ^
3rdparty/carotene/src/separable_filter.hpp:508:70: note: Null pointer addition
                        vst1q_s16(dst + j, vqsubq_s16(vld1q_s16(src2 + j), v_border));
                                                                     ^
3rdparty/carotene/src/separable_filter.hpp:509:74: warning: Either the condition 'src2==0' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
                        vst1q_s16(dst + j + 8, vqsubq_s16(vld1q_s16(src2 + j + 8), v_border));
                                                                         ^
3rdparty/carotene/src/separable_filter.hpp:498:31: note: Assuming that condition 'src2==0' is not redundant
        if (src0 == 0 || src2 == 0)
                              ^
3rdparty/carotene/src/separable_filter.hpp:509:74: note: Null pointer addition
                        vst1q_s16(dst + j + 8, vqsubq_s16(vld1q_s16(src2 + j + 8), v_border));
                                                                         ^
3rdparty/carotene/src/separable_filter.hpp:513:70: warning: Either the condition 'src2==0' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
                        vst1q_s16(dst + j, vqsubq_s16(vld1q_s16(src2 + j), v_border));
                                                                     ^
3rdparty/carotene/src/separable_filter.hpp:498:31: note: Assuming that condition 'src2==0' is not redundant
        if (src0 == 0 || src2 == 0)
                              ^
3rdparty/carotene/src/separable_filter.hpp:513:70: note: Null pointer addition
                        vst1q_s16(dst + j, vqsubq_s16(vld1q_s16(src2 + j), v_border));
                                                                     ^
3rdparty/carotene/src/separable_filter.hpp:519:70: warning: Either the condition 'src2==0' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
                        vst1q_s16(dst + j, vqsubq_s16(vld1q_s16(src2 + j), v_border));
                                                                     ^
3rdparty/carotene/src/separable_filter.hpp:498:31: note: Assuming that condition 'src2==0' is not redundant
        if (src0 == 0 || src2 == 0)
                              ^
3rdparty/carotene/src/separable_filter.hpp:519:70: note: Null pointer addition
                        vst1q_s16(dst + j, vqsubq_s16(vld1q_s16(src2 + j), v_border));
                                                                     ^
3rdparty/carotene/src/gaussian_blur.cpp:83:38: warning: Either the condition '!srow0' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            internal::prefetch(srow0 + x);
                                     ^
3rdparty/carotene/src/gaussian_blur.cpp:87:28: note: Assuming that condition '!srow0' is not redundant
            uint8x8_t x0 = !srow0 ? v_border : vld1_u8(srow0 + x);
                           ^
3rdparty/carotene/src/gaussian_blur.cpp:83:38: note: Null pointer addition
            internal::prefetch(srow0 + x);
                                     ^
3rdparty/carotene/src/gaussian_blur.cpp:85:38: warning: Either the condition '!srow2' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            internal::prefetch(srow2 + x);
                                     ^
3rdparty/carotene/src/gaussian_blur.cpp:89:28: note: Assuming that condition '!srow2' is not redundant
            uint8x8_t x2 = !srow2 ? v_border : vld1_u8(srow2 + x);
                           ^
3rdparty/carotene/src/gaussian_blur.cpp:85:38: note: Null pointer addition
            internal::prefetch(srow2 + x);
                                     ^
3rdparty/carotene/src/laplacian.cpp:85:38: warning: Either the condition '!srow0' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            internal::prefetch(srow0 + x);
                                     ^
3rdparty/carotene/src/laplacian.cpp:89:28: note: Assuming that condition '!srow0' is not redundant
            uint8x8_t x0 = !srow0 ? v_border : vld1_u8(srow0 + x);
                           ^
3rdparty/carotene/src/laplacian.cpp:85:38: note: Null pointer addition
            internal::prefetch(srow0 + x);
                                     ^
3rdparty/carotene/src/laplacian.cpp:87:38: warning: Either the condition '!srow2' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            internal::prefetch(srow2 + x);
                                     ^
3rdparty/carotene/src/laplacian.cpp:91:28: note: Assuming that condition '!srow2' is not redundant
            uint8x8_t x2 = !srow2 ? v_border : vld1_u8(srow2 + x);
                           ^
3rdparty/carotene/src/laplacian.cpp:87:38: note: Null pointer addition
            internal::prefetch(srow2 + x);
                                     ^
3rdparty/carotene/src/minmaxloc.cpp:212:21: style: Parameter 'minVal' can be declared with const [constParameter]
               f32 &minVal, size_t &minCol, size_t &minRow,
                    ^
3rdparty/carotene/src/minmaxloc.cpp:212:37: style: Parameter 'minCol' can be declared with const [constParameter]
               f32 &minVal, size_t &minCol, size_t &minRow,
                                    ^
3rdparty/carotene/src/minmaxloc.cpp:212:53: style: Parameter 'minRow' can be declared with const [constParameter]
               f32 &minVal, size_t &minCol, size_t &minRow,
                                                    ^
3rdparty/carotene/src/minmaxloc.cpp:213:21: style: Parameter 'maxVal' can be declared with const [constParameter]
               f32 &maxVal, size_t &maxCol, size_t &maxRow)
                    ^
3rdparty/carotene/src/minmaxloc.cpp:213:37: style: Parameter 'maxCol' can be declared with const [constParameter]
               f32 &maxVal, size_t &maxCol, size_t &maxRow)
                                    ^
3rdparty/carotene/src/minmaxloc.cpp:213:53: style: Parameter 'maxRow' can be declared with const [constParameter]
               f32 &maxVal, size_t &maxCol, size_t &maxRow)
                                                    ^
3rdparty/carotene/src/minmaxloc.cpp:345:21: style: Parameter 'minVal' can be declared with const [constParameter]
               f32 &minVal, size_t &minCol, size_t &minRow,
                    ^
3rdparty/carotene/src/minmaxloc.cpp:345:37: style: Parameter 'minCol' can be declared with const [constParameter]
               f32 &minVal, size_t &minCol, size_t &minRow,
                                    ^
3rdparty/carotene/src/minmaxloc.cpp:345:53: style: Parameter 'minRow' can be declared with const [constParameter]
               f32 &minVal, size_t &minCol, size_t &minRow,
                                                    ^
3rdparty/carotene/src/minmaxloc.cpp:346:21: style: Parameter 'maxVal' can be declared with const [constParameter]
               f32 &maxVal, size_t &maxCol, size_t &maxRow)
                    ^
3rdparty/carotene/src/minmaxloc.cpp:346:37: style: Parameter 'maxCol' can be declared with const [constParameter]
               f32 &maxVal, size_t &maxCol, size_t &maxRow)
                                    ^
3rdparty/carotene/src/minmaxloc.cpp:346:53: style: Parameter 'maxRow' can be declared with const [constParameter]
               f32 &maxVal, size_t &maxCol, size_t &maxRow)
                                                    ^
3rdparty/carotene/src/minmaxloc.cpp:491:21: style: Parameter 'minVal' can be declared with const [constParameter]
               s32 &minVal, size_t &minCol, size_t &minRow,
                    ^
3rdparty/carotene/src/minmaxloc.cpp:491:37: style: Parameter 'minCol' can be declared with const [constParameter]
               s32 &minVal, size_t &minCol, size_t &minRow,
                                    ^
3rdparty/carotene/src/minmaxloc.cpp:491:53: style: Parameter 'minRow' can be declared with const [constParameter]
               s32 &minVal, size_t &minCol, size_t &minRow,
                                                    ^
3rdparty/carotene/src/minmaxloc.cpp:492:21: style: Parameter 'maxVal' can be declared with const [constParameter]
               s32 &maxVal, size_t &maxCol, size_t &maxRow)
                    ^
3rdparty/carotene/src/minmaxloc.cpp:492:37: style: Parameter 'maxCol' can be declared with const [constParameter]
               s32 &maxVal, size_t &maxCol, size_t &maxRow)
                                    ^
3rdparty/carotene/src/minmaxloc.cpp:492:53: style: Parameter 'maxRow' can be declared with const [constParameter]
               s32 &maxVal, size_t &maxCol, size_t &maxRow)
                                                    ^
3rdparty/carotene/src/minmaxloc.cpp:623:21: style: Parameter 'minVal' can be declared with const [constParameter]
               s16 &minVal, size_t &minCol, size_t &minRow,
                    ^
3rdparty/carotene/src/minmaxloc.cpp:623:37: style: Parameter 'minCol' can be declared with const [constParameter]
               s16 &minVal, size_t &minCol, size_t &minRow,
                                    ^
3rdparty/carotene/src/minmaxloc.cpp:623:53: style: Parameter 'minRow' can be declared with const [constParameter]
               s16 &minVal, size_t &minCol, size_t &minRow,
                                                    ^
3rdparty/carotene/src/minmaxloc.cpp:624:21: style: Parameter 'maxVal' can be declared with const [constParameter]
               s16 &maxVal, size_t &maxCol, size_t &maxRow)
                    ^
3rdparty/carotene/src/minmaxloc.cpp:624:37: style: Parameter 'maxCol' can be declared with const [constParameter]
               s16 &maxVal, size_t &maxCol, size_t &maxRow)
                                    ^
3rdparty/carotene/src/minmaxloc.cpp:624:53: style: Parameter 'maxRow' can be declared with const [constParameter]
               s16 &maxVal, size_t &maxCol, size_t &maxRow)
                                                    ^
3rdparty/carotene/src/minmaxloc.cpp:778:21: style: Parameter 'minVal' can be declared with const [constParameter]
               u16 &minVal, size_t &minCol, size_t &minRow,
                    ^
3rdparty/carotene/src/minmaxloc.cpp:778:37: style: Parameter 'minCol' can be declared with const [constParameter]
               u16 &minVal, size_t &minCol, size_t &minRow,
                                    ^
3rdparty/carotene/src/minmaxloc.cpp:778:53: style: Parameter 'minRow' can be declared with const [constParameter]
               u16 &minVal, size_t &minCol, size_t &minRow,
                                                    ^
3rdparty/carotene/src/minmaxloc.cpp:779:21: style: Parameter 'maxVal' can be declared with const [constParameter]
               u16 &maxVal, size_t &maxCol, size_t &maxRow)
                    ^
3rdparty/carotene/src/minmaxloc.cpp:779:37: style: Parameter 'maxCol' can be declared with const [constParameter]
               u16 &maxVal, size_t &maxCol, size_t &maxRow)
                                    ^
3rdparty/carotene/src/minmaxloc.cpp:779:53: style: Parameter 'maxRow' can be declared with const [constParameter]
               u16 &maxVal, size_t &maxCol, size_t &maxRow)
                                                    ^
3rdparty/carotene/src/minmaxloc.cpp:1169:20: style: Parameter 'minVal' can be declared with const [constParameter]
               u8 &minVal, size_t &minCol, size_t &minRow,
                   ^
3rdparty/carotene/src/minmaxloc.cpp:1169:36: style: Parameter 'minCol' can be declared with const [constParameter]
               u8 &minVal, size_t &minCol, size_t &minRow,
                                   ^
3rdparty/carotene/src/minmaxloc.cpp:1169:52: style: Parameter 'minRow' can be declared with const [constParameter]
               u8 &minVal, size_t &minCol, size_t &minRow,
                                                   ^
3rdparty/carotene/src/minmaxloc.cpp:1170:20: style: Parameter 'maxVal' can be declared with const [constParameter]
               u8 &maxVal, size_t &maxCol, size_t &maxRow)
                   ^
3rdparty/carotene/src/minmaxloc.cpp:1170:36: style: Parameter 'maxCol' can be declared with const [constParameter]
               u8 &maxVal, size_t &maxCol, size_t &maxRow)
                                   ^
3rdparty/carotene/src/minmaxloc.cpp:1170:52: style: Parameter 'maxRow' can be declared with const [constParameter]
               u8 &maxVal, size_t &maxCol, size_t &maxRow)
                                                   ^
3rdparty/carotene/src/minmaxloc.cpp:1256:20: style: Parameter 'minVal' can be declared with const [constParameter]
               s8 &minVal, size_t &minCol, size_t &minRow,
                   ^
3rdparty/carotene/src/minmaxloc.cpp:1256:36: style: Parameter 'minCol' can be declared with const [constParameter]
               s8 &minVal, size_t &minCol, size_t &minRow,
                                   ^
3rdparty/carotene/src/minmaxloc.cpp:1256:52: style: Parameter 'minRow' can be declared with const [constParameter]
               s8 &minVal, size_t &minCol, size_t &minRow,
                                                   ^
3rdparty/carotene/src/minmaxloc.cpp:1257:20: style: Parameter 'maxVal' can be declared with const [constParameter]
               s8 &maxVal, size_t &maxCol, size_t &maxRow)
                   ^
3rdparty/carotene/src/minmaxloc.cpp:1257:36: style: Parameter 'maxCol' can be declared with const [constParameter]
               s8 &maxVal, size_t &maxCol, size_t &maxRow)
                                   ^
3rdparty/carotene/src/minmaxloc.cpp:1257:52: style: Parameter 'maxRow' can be declared with const [constParameter]
               s8 &maxVal, size_t &maxCol, size_t &maxRow)
                                                   ^
3rdparty/carotene/src/morph.cpp:147:38: warning: Either the condition '!srow0' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            internal::prefetch(srow0 + x);
                                     ^
3rdparty/carotene/src/morph.cpp:151:29: note: Assuming that condition '!srow0' is not redundant
            uint8x16_t x0 = !srow0 ? v_border : vld1q_u8(srow0 + x);
                            ^
3rdparty/carotene/src/morph.cpp:147:38: note: Null pointer addition
            internal::prefetch(srow0 + x);
                                     ^
3rdparty/carotene/src/morph.cpp:149:38: warning: Either the condition '!srow2' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            internal::prefetch(srow2 + x);
                                     ^
3rdparty/carotene/src/morph.cpp:153:29: note: Assuming that condition '!srow2' is not redundant
            uint8x16_t x2 = !srow2 ? v_border : vld1q_u8(srow2 + x);
                            ^
3rdparty/carotene/src/morph.cpp:149:38: note: Null pointer addition
            internal::prefetch(srow2 + x);
                                     ^
3rdparty/carotene/src/pyramid.cpp:1120:18: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [knownConditionTrueFalse]
        if (lane == lane0 && 2*i+1 < dstSize.height)
                 ^
3rdparty/carotene/src/pyramid.cpp:924:27: note: 'lane' is assigned value 'lane0' here.
        const u16* lane = lane0;
                          ^
3rdparty/carotene/src/pyramid.cpp:1120:18: note: The expression 'lane == lane0' is always true because 'lane' and 'lane0' represent the same value.
        if (lane == lane0 && 2*i+1 < dstSize.height)
                 ^
3rdparty/carotene/src/pyramid.cpp:1399:18: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [knownConditionTrueFalse]
        if (lane == lane0 && 2*i+1 < dstSize.height)
                 ^
3rdparty/carotene/src/pyramid.cpp:1202:27: note: 'lane' is assigned value 'lane0' here.
        const s32* lane = lane0;
                          ^
3rdparty/carotene/src/pyramid.cpp:1399:18: note: The expression 'lane == lane0' is always true because 'lane' and 'lane0' represent the same value.
        if (lane == lane0 && 2*i+1 < dstSize.height)
                 ^
3rdparty/carotene/src/resize.cpp:1439:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'vc_upd' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        vc_upd = vdupq_n_s32(4);
        ^
3rdparty/carotene/src/resize.cpp:1465:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'vc_upd' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        vc_upd = vdupq_n_s32(1);
        ^
3rdparty/carotene/src/resize.cpp:760:26: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
        if ((wr == 2.0f) && (wr == 2.0f))
                         ^
3rdparty/carotene/src/sum.cpp:112:17: style: Local variable 'sum' shadows outer function [shadowFunction]
            u32 sum[12];
                ^
3rdparty/carotene/src/sum.cpp:51:6: note: Shadowed declaration
void sum(const Size2D &_size,
     ^
3rdparty/carotene/src/sum.cpp:112:17: note: Shadow variable
            u32 sum[12];
                ^
3rdparty/cpufeatures/cpu-features.c:606:10: style: The scope of the variable 'architecture' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    long architecture = 0;
         ^
3rdparty/cpufeatures/cpu-features.c:606:23: style: Variable 'architecture' is assigned a value that is never used. [unreadVariable]
    long architecture = 0;
                      ^
3rdparty/ittnotify/src/ittnotify/ittnotify_static.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/ittnotify/src/ittnotify/ittnotify_static.h:130:1: error: syntax error [syntaxError]
ITT_STUBV(ITTAPI, void, detach, (void), (ITT_NO_PARAMS), detach, __itt_group_control | __itt_group_legacy, "no args")
^
3rdparty/ittnotify/src/ittnotify/ittnotify_static.c:843:0: information: Skipping configuration 'SDL_STRNCPY_S' since the value of 'SDL_STRNCPY_S' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                __itt_fstrcpyn(env_value, max_len, env, len + 1);
^
3rdparty/ittnotify/src/ittnotify/ittnotify_static.c:992:0: information: Skipping configuration 'SDL_STRNCPY_S' since the value of 'SDL_STRNCPY_S' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            __itt_fstrcpyn(gr, sizeof(gr) - 1, chunk,  min_len);
^
3rdparty/ittnotify/src/ittnotify/ittnotify_static.c:838:0: information: Skipping configuration 'SDL_STRNLEN_S' since the value of 'SDL_STRNLEN_S' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            size_t len = __itt_fstrnlen(env, MAX_ENV_VALUE_SIZE);
^
3rdparty/ittnotify/src/ittnotify/jitprofiling.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/ittnotify/src/ittnotify/jitprofiling.c:179:19: style: Variable 'dllName' is assigned a value that is never used. [unreadVariable]
    char *dllName = (char*)rcsid; /* !! Just to avoid unused code elimination */
                  ^
3rdparty/ittnotify/src/ittnotify/jitprofiling.c:209:22: style: Variable 'envret' is assigned a value that is never used. [unreadVariable]
        DWORD envret = 0;
                     ^
3rdparty/ittnotify/src/ittnotify/jitprofiling.c:228:26: style: Variable 'envret' is assigned a value that is never used. [unreadVariable]
            DWORD envret = 0;
                         ^
3rdparty/libjasper/jas_cm.c:647:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    pxformseq = 0;
    ^
3rdparty/libjasper/jas_cm.c:790:18: style: The scope of the variable 'b0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_cmreal_t b0;
                 ^
3rdparty/libjasper/jas_cm.c:791:18: style: The scope of the variable 'b1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_cmreal_t b1;
                 ^
3rdparty/libjasper/jas_cm.c:792:18: style: The scope of the variable 'b2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_cmreal_t b2;
                 ^
3rdparty/libjasper/jas_cm.c:940:18: style: The scope of the variable 'sx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_cmreal_t sx;
                 ^
3rdparty/libjasper/jas_cm.c:941:18: style: The scope of the variable 'sy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_cmreal_t sy;
                 ^
3rdparty/libjasper/jas_cm.c:1228:9: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int m;
        ^
3rdparty/libjasper/jas_cm.c:1245:9: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int m;
        ^
3rdparty/libjasper/jas_cm.c:162:17: style: Variable 'iccprof' is assigned a value that is never used. [unreadVariable]
        iccprof = 0;
                ^
3rdparty/libjasper/jas_cm.c:647:15: style: Variable 'pxformseq' is assigned a value that is never used. [unreadVariable]
    pxformseq = 0;
              ^
3rdparty/libjasper/jas_debug.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jas_getopt.c:110:11: style: The scope of the variable 's' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char *s;
          ^
3rdparty/libjasper/jas_icc.c:956:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    attrval = 0;
    ^
3rdparty/libjasper/jas_icc.c:982:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    attrval = 0;
    ^
3rdparty/libjasper/jas_icc.c:983:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    othattrval = 0;
    ^
3rdparty/libjasper/jas_icc.c:1074:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    attrval = 0;
    ^
3rdparty/libjasper/jas_icc.c:1075:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    othattrval = 0;
    ^
3rdparty/libjasper/jas_icc.c:1260:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    attrval = 0;
    ^
3rdparty/libjasper/jas_icc.c:1261:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    othattrval = 0;
    ^
3rdparty/libjasper/jas_icc.c:1429:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    attrval = 0;
    ^
3rdparty/libjasper/jas_icc.c:1430:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    othattrval = 0;
    ^
3rdparty/libjasper/jas_icc.c:617:15: style: Variable 'info' is reassigned a value before the old one has been used. [redundantAssignment]
    for (info = jas_iccattrvalinfos; info->type; ++info) {
              ^
3rdparty/libjasper/jas_icc.c:616:10: note: info is assigned
    info = jas_iccattrvalinfos;
         ^
3rdparty/libjasper/jas_icc.c:617:15: note: info is overwritten
    for (info = jas_iccattrvalinfos; info->type; ++info) {
              ^
3rdparty/libjasper/jas_icc.c:1076:13: style: Redundant initialization for 'txtdesc'. The initialized value is overwritten before it is read. [redundantInitialization]
    txtdesc = 0;
            ^
3rdparty/libjasper/jas_icc.c:1071:31: note: txtdesc is initialized
    jas_icctxtdesc_t *txtdesc = &attrval->data.txtdesc;
                              ^
3rdparty/libjasper/jas_icc.c:1076:13: note: txtdesc is overwritten
    txtdesc = 0;
            ^
3rdparty/libjasper/jas_icc.c:1262:10: style: Redundant initialization for 'lut8'. The initialized value is overwritten before it is read. [redundantInitialization]
    lut8 = 0;
         ^
3rdparty/libjasper/jas_icc.c:1258:25: note: lut8 is initialized
    jas_icclut8_t *lut8 = &attrval->data.lut8;
                        ^
3rdparty/libjasper/jas_icc.c:1262:10: note: lut8 is overwritten
    lut8 = 0;
         ^
3rdparty/libjasper/jas_icc.c:720:23: style: The scope of the variable 'attrval' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_iccattrval_t *attrval;
                      ^
3rdparty/libjasper/jas_icc.c:721:27: style: The scope of the variable 'info' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_iccattrvalinfo_t *info;
                          ^
3rdparty/libjasper/jas_icc.c:832:20: style: The scope of the variable 'attr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_iccattr_t *attr;
                   ^
3rdparty/libjasper/jas_icc.c:1041:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
3rdparty/libjasper/jas_icc.c:1577:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
3rdparty/libjasper/jas_icc.c:1638:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
3rdparty/libjasper/jas_icc.c:1661:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
3rdparty/libjasper/jas_icc.c:896:16: style: Variable 'newattrval' is assigned a value that is never used. [unreadVariable]
    newattrval = 0;
               ^
3rdparty/libjasper/jas_icc.c:956:13: style: Variable 'attrval' is assigned a value that is never used. [unreadVariable]
    attrval = 0;
            ^
3rdparty/libjasper/jas_icc.c:982:13: style: Variable 'attrval' is assigned a value that is never used. [unreadVariable]
    attrval = 0;
            ^
3rdparty/libjasper/jas_icc.c:983:16: style: Variable 'othattrval' is assigned a value that is never used. [unreadVariable]
    othattrval = 0;
               ^
3rdparty/libjasper/jas_icc.c:1074:13: style: Variable 'attrval' is assigned a value that is never used. [unreadVariable]
    attrval = 0;
            ^
3rdparty/libjasper/jas_icc.c:1075:16: style: Variable 'othattrval' is assigned a value that is never used. [unreadVariable]
    othattrval = 0;
               ^
3rdparty/libjasper/jas_icc.c:1076:13: style: Variable 'txtdesc' is assigned a value that is never used. [unreadVariable]
    txtdesc = 0;
            ^
3rdparty/libjasper/jas_icc.c:1260:13: style: Variable 'attrval' is assigned a value that is never used. [unreadVariable]
    attrval = 0;
            ^
3rdparty/libjasper/jas_icc.c:1261:16: style: Variable 'othattrval' is assigned a value that is never used. [unreadVariable]
    othattrval = 0;
               ^
3rdparty/libjasper/jas_icc.c:1262:10: style: Variable 'lut8' is assigned a value that is never used. [unreadVariable]
    lut8 = 0;
         ^
3rdparty/libjasper/jas_icc.c:1429:13: style: Variable 'attrval' is assigned a value that is never used. [unreadVariable]
    attrval = 0;
            ^
3rdparty/libjasper/jas_icc.c:1430:16: style: Variable 'othattrval' is assigned a value that is never used. [unreadVariable]
    othattrval = 0;
               ^
3rdparty/libjasper/jas_image.c:284:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
3rdparty/libjasper/jas_image.c:415:19: style: The scope of the variable 'd' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_seqent_t *d;
                  ^
3rdparty/libjasper/jas_image.c:464:19: style: The scope of the variable 'd' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_seqent_t *d;
                  ^
3rdparty/libjasper/jas_image.c:517:26: style: The scope of the variable 'fmtinfo' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_image_fmtinfo_t *fmtinfo;
                         ^
3rdparty/libjasper/jas_image.c:631:23: style: The scope of the variable 'cmpt' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_image_cmpt_t *cmpt;
                      ^
3rdparty/libjasper/jas_image.c:735:9: style: The scope of the variable 'cmptno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int cmptno;
        ^
3rdparty/libjasper/jas_image.c:736:18: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int_fast32_t x;
                 ^
3rdparty/libjasper/jas_image.c:737:18: style: The scope of the variable 'y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int_fast32_t y;
                 ^
3rdparty/libjasper/jas_image.c:816:9: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int n;
        ^
3rdparty/libjasper/jas_image.c:818:9: style: The scope of the variable 'width' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int width;
        ^
3rdparty/libjasper/jas_image.c:819:9: style: The scope of the variable 'height' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int height;
        ^
3rdparty/libjasper/jas_image.c:820:23: style: The scope of the variable 'cmpt' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_image_cmpt_t *cmpt;
                      ^
3rdparty/libjasper/jas_image.c:892:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
3rdparty/libjasper/jas_image.c:916:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
3rdparty/libjasper/jas_image.c:1167:23: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_image_coord_t t;
                      ^
3rdparty/libjasper/jas_image.c:1168:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
3rdparty/libjasper/jas_image.c:1206:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
3rdparty/libjasper/jas_image.c:1227:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
3rdparty/libjasper/jas_init.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jas_malloc.c:148:12: style: Unused variable: n [unusedVariable]
    size_t n;
           ^
3rdparty/libjasper/jas_seq.c:289:41: style: Variable 'data' is reassigned a value before the old one has been used. [redundantAssignment]
        for (j = matrix->numcols_, data = rowstart; j > 0; --j,
                                        ^
3rdparty/libjasper/jas_seq.c:288:14: note: data is assigned
        data = rowstart;
             ^
3rdparty/libjasper/jas_seq.c:289:41: note: data is overwritten
        for (j = matrix->numcols_, data = rowstart; j > 0; --j,
                                        ^
3rdparty/libjasper/jas_seq.c:282:19: style: The scope of the variable 'data' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_seqent_t *data;
                  ^
3rdparty/libjasper/jas_stream.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jas_stream.c:302:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    path = 0;
    ^
3rdparty/libjasper/jas_stream.c:607:12: style: Variable 'm' is reassigned a value before the old one has been used. [redundantAssignment]
    for (m = n; m > 0; --m) {
           ^
3rdparty/libjasper/jas_stream.c:606:7: note: m is assigned
    m = n;
      ^
3rdparty/libjasper/jas_stream.c:607:12: note: m is overwritten
    for (m = n; m > 0; --m) {
           ^
3rdparty/libjasper/jas_stream.c:619:12: style: Variable 'm' is reassigned a value before the old one has been used. [redundantAssignment]
    for (m = n; m > 0; --m) {
           ^
3rdparty/libjasper/jas_stream.c:618:7: note: m is assigned
    m = n;
      ^
3rdparty/libjasper/jas_stream.c:619:12: note: m is overwritten
    for (m = n; m > 0; --m) {
           ^
3rdparty/libjasper/jas_stream.c:519:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
3rdparty/libjasper/jas_stream.c:584:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
3rdparty/libjasper/jas_stream.c:808:9: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int n;
        ^
3rdparty/libjasper/jas_stream.c:883:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
3rdparty/libjasper/jas_stream.c:919:9: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int m;
        ^
3rdparty/libjasper/jas_stream.c:1017:10: style: The scope of the variable 'newbufsize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    long newbufsize;
         ^
3rdparty/libjasper/jas_stream.c:302:10: style: Variable 'path' is assigned a value that is never used. [unreadVariable]
    path = 0;
         ^
3rdparty/libjasper/jas_stream.c:315:19: style: Variable 'openflags' is assigned a value that is never used. [unreadVariable]
        openflags = O_RDWR;
                  ^
3rdparty/libjasper/jas_stream.c:317:19: style: Variable 'openflags' is assigned a value that is never used. [unreadVariable]
        openflags = O_RDONLY;
                  ^
3rdparty/libjasper/jas_stream.c:319:19: style: Variable 'openflags' is assigned a value that is never used. [unreadVariable]
        openflags = O_WRONLY;
                  ^
3rdparty/libjasper/jas_stream.c:321:19: style: Variable 'openflags' is assigned a value that is never used. [unreadVariable]
        openflags = 0;
                  ^
3rdparty/libjasper/jas_stream.c:324:19: style: Variable 'openflags' is assigned a value that is never used. [unreadVariable]
        openflags |= O_APPEND;
                  ^
3rdparty/libjasper/jas_stream.c:327:19: style: Variable 'openflags' is assigned a value that is never used. [unreadVariable]
        openflags |= O_BINARY;
                  ^
3rdparty/libjasper/jas_stream.c:330:19: style: Variable 'openflags' is assigned a value that is never used. [unreadVariable]
        openflags |= O_CREAT | O_TRUNC;
                  ^
3rdparty/libjasper/jas_stream.c:348:11: style: Unused variable: tmpname [unusedVariable]
    char *tmpname;
          ^
3rdparty/libjasper/jas_version.c:66:0: information: Skipping configuration 'JAS_VERSION' since the value of 'JAS_VERSION' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    return JAS_VERSION;
^
3rdparty/libjasper/jp2_cod.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jp2_cod.c:795:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    box = 0;
    ^
3rdparty/libjasper/jp2_cod.c:796:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    out = 0;
    ^
3rdparty/libjasper/jp2_cod.c:868:1: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
box = 0;
^
3rdparty/libjasper/jp2_cod.c:869:1: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
out = 0;
^
3rdparty/libjasper/jp2_cod.c:882:13: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
            fprintf(out, "LUT[%d][%d]=%d\n", i, j, (int)pclr->lutdata[i * pclr->numchans + j]);
            ^
3rdparty/libjasper/jp2_cod.c:312:5: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
    abort();
    ^
3rdparty/libjasper/jp2_cod.c:522:5: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
    abort();
    ^
3rdparty/libjasper/jp2_cod.c:606:21: style: The scope of the variable 'ent' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jp2_cdefchan_t *ent;
                    ^
3rdparty/libjasper/jp2_cod.c:687:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
3rdparty/libjasper/jp2_cod.c:805:20: style: The scope of the variable 'ent' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jp2_cmapent_t *ent;
                   ^
3rdparty/libjasper/jp2_cod.c:939:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
3rdparty/libjasper/jp2_cod.c:971:21: style: The scope of the variable 'cdefent' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jp2_cdefchan_t *cdefent;
                    ^
3rdparty/libjasper/jp2_cod.c:484:10: style: Unused variable: extlen [unusedVariable]
    bool extlen;
         ^
3rdparty/libjasper/jp2_cod.c:795:9: style: Variable 'box' is assigned a value that is never used. [unreadVariable]
    box = 0;
        ^
3rdparty/libjasper/jp2_cod.c:796:9: style: Variable 'out' is assigned a value that is never used. [unreadVariable]
    out = 0;
        ^
3rdparty/libjasper/jp2_cod.c:868:5: style: Variable 'box' is assigned a value that is never used. [unreadVariable]
box = 0;
    ^
3rdparty/libjasper/jp2_cod.c:869:5: style: Variable 'out' is assigned a value that is never used. [unreadVariable]
out = 0;
    ^
3rdparty/libjasper/jp2_dec.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jp2_dec.c:445:34: style: Argument '16>=(((12+16)<16)?12+16:16)' to function assert is always 1 [constArgument]
    assert(JAS_STREAM_MAXPUTBACK >= JP2_VALIDATELEN);
                                 ^
3rdparty/libjasper/jp2_enc.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jp2_enc.c:333:5: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
    abort();
    ^
3rdparty/libjasper/jp2_enc.c:377:5: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
    abort();
    ^
3rdparty/libjasper/jp2_enc.c:330:15: style: Variable 'tmpstream' is assigned a value that is never used. [unreadVariable]
    tmpstream = 0;
              ^
3rdparty/libjasper/jpc_bs.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_bs.c:194:9: style: The scope of the variable 'u' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int u;
        ^
3rdparty/libjasper/jpc_bs.c:416:11: style: Variable 'n' is assigned a value that is never used. [unreadVariable]
        n = 0;
          ^
3rdparty/libjasper/jpc_bs.c:417:11: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
        v = 0;
          ^
3rdparty/libjasper/jpc_cs.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_cs.c:428:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    cstate = 0;
    ^
3rdparty/libjasper/jpc_cs.c:447:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    cstate = 0;
    ^
3rdparty/libjasper/jpc_cs.c:725:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    compparms = 0;
    ^
3rdparty/libjasper/jpc_cs.c:1042:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    cstate = 0;
    ^
3rdparty/libjasper/jpc_cs.c:1055:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    cstate = 0;
    ^
3rdparty/libjasper/jpc_cs.c:1121:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    cstate = 0;
    ^
3rdparty/libjasper/jpc_cs.c:1190:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    cstate = 0;
    ^
3rdparty/libjasper/jpc_cs.c:1400:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    cstate = 0;
    ^
3rdparty/libjasper/jpc_cs.c:1424:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    cstate = 0;
    ^
3rdparty/libjasper/jpc_cs.c:1473:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    cstate = 0;
    ^
3rdparty/libjasper/jpc_cs.c:1494:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    cstate = 0;
    ^
3rdparty/libjasper/jpc_cs.c:1495:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    ms = 0;
    ^
3rdparty/libjasper/jpc_cs.c:1496:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    out = 0;
    ^
3rdparty/libjasper/jpc_cs.c:568:9: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
        fprintf(out, "prec[%d] = %d; sgnd[%d] = %d; hsamp[%d] = %d; "
        ^
3rdparty/libjasper/jpc_cs.c:568:9: warning: %d in format string (no. 3) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
        fprintf(out, "prec[%d] = %d; sgnd[%d] = %d; hsamp[%d] = %d; "
        ^
3rdparty/libjasper/jpc_cs.c:568:9: warning: %d in format string (no. 5) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
        fprintf(out, "prec[%d] = %d; sgnd[%d] = %d; hsamp[%d] = %d; "
        ^
3rdparty/libjasper/jpc_cs.c:568:9: warning: %d in format string (no. 7) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
        fprintf(out, "prec[%d] = %d; sgnd[%d] = %d; hsamp[%d] = %d; "
        ^
3rdparty/libjasper/jpc_cs.c:236:19: style: The scope of the variable 'tmpstream' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_stream_t *tmpstream;
                  ^
3rdparty/libjasper/jpc_cs.c:321:19: style: The scope of the variable 'tmpstream' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_stream_t *tmpstream;
                  ^
3rdparty/libjasper/jpc_cs.c:322:9: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int len;
        ^
3rdparty/libjasper/jpc_cs.c:629:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
3rdparty/libjasper/jpc_cs.c:732:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
3rdparty/libjasper/jpc_cs.c:773:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
3rdparty/libjasper/jpc_cs.c:428:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:447:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:486:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:530:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:725:15: style: Variable 'compparms' is assigned a value that is never used. [unreadVariable]
    compparms = 0;
              ^
3rdparty/libjasper/jpc_cs.c:735:8: style: Variable 'ms' is assigned a value that is never used. [unreadVariable]
    ms = 0;
       ^
3rdparty/libjasper/jpc_cs.c:736:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:777:8: style: Variable 'ms' is assigned a value that is never used. [unreadVariable]
    ms = 0;
       ^
3rdparty/libjasper/jpc_cs.c:778:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:1019:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:1042:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:1055:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:1121:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:1190:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:1358:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:1400:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:1424:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:1473:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:1494:12: style: Variable 'cstate' is assigned a value that is never used. [unreadVariable]
    cstate = 0;
           ^
3rdparty/libjasper/jpc_cs.c:1495:8: style: Variable 'ms' is assigned a value that is never used. [unreadVariable]
    ms = 0;
       ^
3rdparty/libjasper/jpc_cs.c:1496:9: style: Variable 'out' is assigned a value that is never used. [unreadVariable]
    out = 0;
        ^
3rdparty/libjasper/jpc_dec.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_dec.c:433:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    ms = 0;
    ^
3rdparty/libjasper/jpc_dec.c:1457:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    dec = 0;
    ^
3rdparty/libjasper/jpc_dec.c:1458:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    ms = 0;
    ^
3rdparty/libjasper/jpc_dec.c:1466:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    dec = 0;
    ^
3rdparty/libjasper/jpc_dec.c:1764:23: style: Condition 'n>=0' is always true [knownConditionTrueFalse]
    absstepsize |= (n >= 0) ? (JPC_QCX_GETMANT(stepsize) << n) :
                      ^
3rdparty/libjasper/jpc_dec.c:1763:26: note: Assignment 'n=13-11', assigned value is 2
    n = JPC_FIX_FRACBITS - 11;
                         ^
3rdparty/libjasper/jpc_dec.c:1764:23: note: Condition 'n>=0' is always true
    absstepsize |= (n >= 0) ? (JPC_QCX_GETMANT(stepsize) << n) :
                      ^
3rdparty/libjasper/jpc_dec.c:1920:16: style: Variable 'node->prev' is reassigned a value before the old one has been used. [redundantAssignment]
    node->prev = prev;
               ^
3rdparty/libjasper/jpc_dec.c:1918:16: note: node->prev is assigned
    node->prev = prev;
               ^
3rdparty/libjasper/jpc_dec.c:1920:16: note: node->prev is overwritten
    node->prev = prev;
               ^
3rdparty/libjasper/jpc_dec.c:356:15: style: The scope of the variable 'ms' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_ms_t *ms;
              ^
3rdparty/libjasper/jpc_dec.c:446:27: style: The scope of the variable 'compinfo' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jas_image_cmptparm_t *compinfo;
                          ^
3rdparty/libjasper/jpc_dec.c:448:9: style: The scope of the variable 'cmptno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int cmptno;
        ^
3rdparty/libjasper/jpc_dec.c:542:9: style: The scope of the variable 'pos' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int pos;
        ^
3rdparty/libjasper/jpc_dec.c:599:23: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        uint_fast32_t n;
                      ^
3rdparty/libjasper/jpc_dec.c:659:19: style: The scope of the variable 'brcbgyend' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint_fast32_t brcbgyend;
                  ^
3rdparty/libjasper/jpc_dec.c:678:17: style: The scope of the variable 'pchg' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_pchg_t *pchg;
                ^
3rdparty/libjasper/jpc_dec.c:912:9: style: The scope of the variable 'compno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int compno;
        ^
3rdparty/libjasper/jpc_dec.c:913:9: style: The scope of the variable 'bandno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int bandno;
        ^
3rdparty/libjasper/jpc_dec.c:914:9: style: The scope of the variable 'rlvlno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int rlvlno;
        ^
3rdparty/libjasper/jpc_dec.c:917:9: style: The scope of the variable 'prcno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int prcno;
        ^
3rdparty/libjasper/jpc_dec.c:919:20: style: The scope of the variable 'seg' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_dec_seg_t *seg;
                   ^
3rdparty/libjasper/jpc_dec.c:921:9: style: The scope of the variable 'cblkno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int cblkno;
        ^
3rdparty/libjasper/jpc_dec.c:1026:9: style: The scope of the variable 'adjust' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int adjust;
        ^
3rdparty/libjasper/jpc_dec.c:1027:9: style: The scope of the variable 'v' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int v;
        ^
3rdparty/libjasper/jpc_dec.c:1167:9: style: The scope of the variable 'htileno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int htileno;
        ^
3rdparty/libjasper/jpc_dec.c:1168:9: style: The scope of the variable 'vtileno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int vtileno;
        ^
3rdparty/libjasper/jpc_dec.c:1651:9: style: The scope of the variable 'rlvlno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int rlvlno;
        ^
3rdparty/libjasper/jpc_dec.c:1696:9: style: The scope of the variable 'bandno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int bandno;
        ^
3rdparty/libjasper/jpc_dec.c:1724:17: style: The scope of the variable 'pchg' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_pchg_t *pchg;
                ^
3rdparty/libjasper/jpc_dec.c:2066:9: style: The scope of the variable 'newmaxstreams' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int newmaxstreams;
        ^
3rdparty/libjasper/jpc_dec.c:2067:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
3rdparty/libjasper/jpc_dec.c:2107:9: style: The scope of the variable 'streamno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int streamno;
        ^
3rdparty/libjasper/jpc_dec.c:2276:23: style: The scope of the variable 'ent' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_ppxstabent_t *ent;
                      ^
3rdparty/libjasper/jpc_dec.c:416:9: style: Variable 'crg' is assigned a value that is never used. [unreadVariable]
    crg = &ms->parms.crg;
        ^
3rdparty/libjasper/jpc_dec.c:433:8: style: Variable 'ms' is assigned a value that is never used. [unreadVariable]
    ms = 0;
       ^
3rdparty/libjasper/jpc_dec.c:545:8: style: Variable 'ms' is assigned a value that is never used. [unreadVariable]
    ms = 0;
       ^
3rdparty/libjasper/jpc_dec.c:1142:8: style: Variable 'ms' is assigned a value that is never used. [unreadVariable]
    ms = 0;
       ^
3rdparty/libjasper/jpc_dec.c:1457:9: style: Variable 'dec' is assigned a value that is never used. [unreadVariable]
    dec = 0;
        ^
3rdparty/libjasper/jpc_dec.c:1458:8: style: Variable 'ms' is assigned a value that is never used. [unreadVariable]
    ms = 0;
       ^
3rdparty/libjasper/jpc_dec.c:1466:9: style: Variable 'dec' is assigned a value that is never used. [unreadVariable]
    dec = 0;
        ^
3rdparty/libjasper/jpc_dec.c:1654:8: style: Variable 'cp' is assigned a value that is never used. [unreadVariable]
    cp = 0;
       ^
3rdparty/libjasper/jpc_dec.c:1699:8: style: Variable 'cp' is assigned a value that is never used. [unreadVariable]
    cp = 0;
       ^
3rdparty/libjasper/jpc_enc.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_enc.c:1809:28: style: Condition 'pos<=cumlen' is always true [knownConditionTrueFalse]
            } else if (pos <= cumlen) {
                           ^
3rdparty/libjasper/jpc_enc.c:785:15: style: The scope of the variable 'f' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_flt_t f;
              ^
3rdparty/libjasper/jpc_enc.c:897:16: style: The scope of the variable 'qcc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_qcc_t *qcc;
               ^
3rdparty/libjasper/jpc_enc.c:901:15: style: The scope of the variable 'mctsynweight' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t mctsynweight;
              ^
3rdparty/libjasper/jpc_enc.c:903:17: style: The scope of the variable 'tsfb' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_tsfb_t *tsfb;
                ^
3rdparty/libjasper/jpc_enc.c:905:19: style: The scope of the variable 'numbands' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint_fast16_t numbands;
                  ^
3rdparty/libjasper/jpc_enc.c:1100:9: style: The scope of the variable 'tilex' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int tilex;
        ^
3rdparty/libjasper/jpc_enc.c:1101:9: style: The scope of the variable 'tiley' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int tiley;
        ^
3rdparty/libjasper/jpc_enc.c:1105:22: style: The scope of the variable 'endcomps' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_enc_tcmpt_t *endcomps;
                     ^
3rdparty/libjasper/jpc_enc.c:1516:21: style: The scope of the variable 'pass0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_enc_pass_t *pass0;
                    ^
3rdparty/libjasper/jpc_enc.c:1631:15: style: The scope of the variable 'lo' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_flt_t lo;
              ^
3rdparty/libjasper/jpc_enc.c:1632:15: style: The scope of the variable 'hi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_flt_t hi;
              ^
3rdparty/libjasper/jpc_enc.c:1637:15: style: The scope of the variable 'goodthresh' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_flt_t goodthresh;
              ^
3rdparty/libjasper/jpc_enc.c:1638:9: style: The scope of the variable 'success' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int success;
        ^
3rdparty/libjasper/jpc_enc.c:1641:9: style: The scope of the variable 'numiters' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int numiters;
        ^
3rdparty/libjasper/jpc_enc.c:2022:22: style: The scope of the variable 'tcmpt' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_enc_tcmpt_t *tcmpt;
                     ^
3rdparty/libjasper/jpc_enc.c:2023:19: style: The scope of the variable 'cmptno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint_fast16_t cmptno;
                  ^
3rdparty/libjasper/jpc_enc.c:2139:21: style: The scope of the variable 'rlvl' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_enc_rlvl_t *rlvl;
                    ^
3rdparty/libjasper/jpc_enc.c:2140:19: style: The scope of the variable 'rlvlno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint_fast16_t rlvlno;
                  ^
3rdparty/libjasper/jpc_enc.c:2241:21: style: The scope of the variable 'band' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_enc_band_t *band;
                    ^
3rdparty/libjasper/jpc_enc.c:2242:19: style: The scope of the variable 'bandno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint_fast16_t bandno;
                  ^
3rdparty/libjasper/jpc_enc.c:2322:20: style: The scope of the variable 'prc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_enc_prc_t *prc;
                   ^
3rdparty/libjasper/jpc_enc.c:2323:21: style: The scope of the variable 'rlvl' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_enc_rlvl_t *rlvl;
                    ^
3rdparty/libjasper/jpc_enc.c:2324:19: style: The scope of the variable 'prcno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint_fast32_t prcno;
                  ^
3rdparty/libjasper/jpc_enc.c:2466:21: style: The scope of the variable 'cblk' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_enc_cblk_t *cblk;
                    ^
3rdparty/libjasper/jpc_enc.c:2467:19: style: The scope of the variable 'cblkno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint_fast32_t cblkno;
                  ^
3rdparty/libjasper/jpc_enc.c:2550:19: style: The scope of the variable 'passno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint_fast16_t passno;
                  ^
3rdparty/libjasper/jpc_enc.c:2551:21: style: The scope of the variable 'pass' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_enc_pass_t *pass;
                    ^
3rdparty/libjasper/jpc_enc.c:788:13: style: Variable 'cp' is assigned a value that is never used. [unreadVariable]
    if ((cp = strchr(s, 'B'))) {
            ^
3rdparty/libjasper/jpc_enc.c:874:7: style: Variable 'e' is assigned a value that is never used. [unreadVariable]
    e = n - JPC_FIX_FRACBITS;
      ^
3rdparty/libjasper/jpc_enc.c:996:22: style: Variable 'mctsynweight' is assigned a value that is never used. [unreadVariable]
        mctsynweight = jpc_mct_getsynweight(tcp->mctid, cmptno);
                     ^
3rdparty/libjasper/jpc_mct.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_mct.c:93:16: style: The scope of the variable 'c0p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *c0p;
               ^
3rdparty/libjasper/jpc_mct.c:94:16: style: The scope of the variable 'c1p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *c1p;
               ^
3rdparty/libjasper/jpc_mct.c:95:16: style: The scope of the variable 'c2p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *c2p;
               ^
3rdparty/libjasper/jpc_mct.c:136:16: style: The scope of the variable 'c0p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *c0p;
               ^
3rdparty/libjasper/jpc_mct.c:137:16: style: The scope of the variable 'c1p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *c1p;
               ^
3rdparty/libjasper/jpc_mct.c:138:16: style: The scope of the variable 'c2p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *c2p;
               ^
3rdparty/libjasper/jpc_mct.c:183:16: style: The scope of the variable 'c0p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *c0p;
               ^
3rdparty/libjasper/jpc_mct.c:184:16: style: The scope of the variable 'c1p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *c1p;
               ^
3rdparty/libjasper/jpc_mct.c:185:16: style: The scope of the variable 'c2p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *c2p;
               ^
3rdparty/libjasper/jpc_mct.c:224:16: style: The scope of the variable 'c0p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *c0p;
               ^
3rdparty/libjasper/jpc_mct.c:225:16: style: The scope of the variable 'c1p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *c1p;
               ^
3rdparty/libjasper/jpc_mct.c:226:16: style: The scope of the variable 'c2p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *c2p;
               ^
3rdparty/libjasper/jpc_mqcod.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_mqdec.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_mqdec.c:264:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
3rdparty/libjasper/jpc_mqdec.c:265:19: style: The scope of the variable 'prevbuf' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char prevbuf;
                  ^
3rdparty/libjasper/jpc_mqenc.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_qmfb.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_qmfb.c:315:25: style: The scope of the variable 'srcptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *srcptr;
                        ^
3rdparty/libjasper/jpc_qmfb.c:316:25: style: The scope of the variable 'dstptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *dstptr;
                        ^
3rdparty/libjasper/jpc_qmfb.c:317:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:318:18: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int m;
                 ^
3rdparty/libjasper/jpc_qmfb.c:319:9: style: The scope of the variable 'hstartcol' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int hstartcol;
        ^
3rdparty/libjasper/jpc_qmfb.c:383:25: style: The scope of the variable 'srcptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *srcptr;
                        ^
3rdparty/libjasper/jpc_qmfb.c:384:25: style: The scope of the variable 'dstptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *dstptr;
                        ^
3rdparty/libjasper/jpc_qmfb.c:385:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:386:18: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int m;
                 ^
3rdparty/libjasper/jpc_qmfb.c:387:9: style: The scope of the variable 'hstartcol' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int hstartcol;
        ^
3rdparty/libjasper/jpc_qmfb.c:453:25: style: The scope of the variable 'srcptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *srcptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:454:25: style: The scope of the variable 'dstptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *dstptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:455:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:456:18: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int i;
                 ^
3rdparty/libjasper/jpc_qmfb.c:457:9: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int m;
        ^
3rdparty/libjasper/jpc_qmfb.c:458:9: style: The scope of the variable 'hstartcol' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int hstartcol;
        ^
3rdparty/libjasper/jpc_qmfb.c:542:25: style: The scope of the variable 'srcptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *srcptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:543:25: style: The scope of the variable 'dstptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *dstptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:544:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:545:18: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int i;
                 ^
3rdparty/libjasper/jpc_qmfb.c:546:9: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int m;
        ^
3rdparty/libjasper/jpc_qmfb.c:547:9: style: The scope of the variable 'hstartcol' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int hstartcol;
        ^
3rdparty/libjasper/jpc_qmfb.c:927:25: style: The scope of the variable 'hptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr;
                        ^
3rdparty/libjasper/jpc_qmfb.c:928:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:984:16: style: The scope of the variable 'hptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *hptr;
               ^
3rdparty/libjasper/jpc_qmfb.c:990:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:1048:25: style: The scope of the variable 'hptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:1049:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:1148:25: style: The scope of the variable 'hptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:1149:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:1245:25: style: The scope of the variable 'hptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr;
                        ^
3rdparty/libjasper/jpc_qmfb.c:1246:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:1302:16: style: The scope of the variable 'hptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t *hptr;
               ^
3rdparty/libjasper/jpc_qmfb.c:1308:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:1366:25: style: The scope of the variable 'hptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:1367:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:1466:25: style: The scope of the variable 'hptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:1467:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:1646:25: style: The scope of the variable 'lptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *lptr;
                        ^
3rdparty/libjasper/jpc_qmfb.c:1647:25: style: The scope of the variable 'hptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr;
                        ^
3rdparty/libjasper/jpc_qmfb.c:1648:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:1770:25: style: The scope of the variable 'lptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *lptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:1771:25: style: The scope of the variable 'hptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:1772:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:1773:18: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int i;
                 ^
3rdparty/libjasper/jpc_qmfb.c:1978:25: style: The scope of the variable 'lptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *lptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:1979:25: style: The scope of the variable 'hptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:1980:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:1981:18: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int i;
                 ^
3rdparty/libjasper/jpc_qmfb.c:2186:25: style: The scope of the variable 'lptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *lptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:2187:25: style: The scope of the variable 'hptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:2188:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:2360:25: style: The scope of the variable 'lptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *lptr;
                        ^
3rdparty/libjasper/jpc_qmfb.c:2361:25: style: The scope of the variable 'hptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr;
                        ^
3rdparty/libjasper/jpc_qmfb.c:2362:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:2484:25: style: The scope of the variable 'lptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *lptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:2485:25: style: The scope of the variable 'hptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:2486:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:2487:18: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int i;
                 ^
3rdparty/libjasper/jpc_qmfb.c:2692:25: style: The scope of the variable 'lptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *lptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:2693:25: style: The scope of the variable 'hptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:2694:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:2695:18: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int i;
                 ^
3rdparty/libjasper/jpc_qmfb.c:2900:25: style: The scope of the variable 'lptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *lptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:2901:25: style: The scope of the variable 'hptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register jpc_fix_t *hptr2;
                        ^
3rdparty/libjasper/jpc_qmfb.c:2902:18: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register int n;
                 ^
3rdparty/libjasper/jpc_qmfb.c:2203:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2204:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2213:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2214:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2223:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2224:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2235:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2236:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2245:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2246:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2255:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2256:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2267:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2268:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2277:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2278:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2287:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2288:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2299:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2300:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2309:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2310:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2319:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2320:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2330:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2338:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2916:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2924:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2937:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2938:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2947:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2948:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2957:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2958:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2969:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2970:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2979:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2980:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2989:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:2990:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:3001:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:3002:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:3011:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:3012:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:3021:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:3022:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:3033:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:3034:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:3043:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:3044:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:3053:13: style: Variable 'lptr2' is assigned a value that is never used. [unreadVariable]
            ++lptr2;
            ^
3rdparty/libjasper/jpc_qmfb.c:3054:13: style: Variable 'hptr2' is assigned a value that is never used. [unreadVariable]
            ++hptr2;
            ^
3rdparty/libjasper/jpc_t1cod.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_t1cod.c:139:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    numlvls = 0;
    ^
3rdparty/libjasper/jpc_t1cod.c:168:9: style: The scope of the variable 'passtype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int passtype;
        ^
3rdparty/libjasper/jpc_t1cod.c:219:9: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int n;
        ^
3rdparty/libjasper/jpc_t1cod.c:239:11: style: The scope of the variable 'u' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float u;
          ^
3rdparty/libjasper/jpc_t1cod.c:240:11: style: The scope of the variable 'v' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float v;
          ^
3rdparty/libjasper/jpc_t1cod.c:241:11: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float t;
          ^
3rdparty/libjasper/jpc_t1dec.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_t1dec.c:369:9: style: The scope of the variable 'vscanlen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int vscanlen;
        ^
3rdparty/libjasper/jpc_t1dec.c:476:9: style: The scope of the variable 'vscanlen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int vscanlen;
        ^
3rdparty/libjasper/jpc_t1dec.c:574:9: style: The scope of the variable 'vscanlen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int vscanlen;
        ^
3rdparty/libjasper/jpc_t1dec.c:673:9: style: The scope of the variable 'vscanlen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int vscanlen;
        ^
3rdparty/libjasper/jpc_t1dec.c:242:35: style: The unsigned expression 'ccp->roishift' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
                if (ccp->roishift <= 0) {
                                  ^
3rdparty/libjasper/jpc_t1enc.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_t1enc.c:113:21: style: The scope of the variable 'endlvls' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_enc_rlvl_t *endlvls;
                    ^
3rdparty/libjasper/jpc_t1enc.c:200:9: style: The scope of the variable 'ret' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int ret;
        ^
3rdparty/libjasper/jpc_t1enc.c:201:9: style: The scope of the variable 'passtype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int passtype;
        ^
3rdparty/libjasper/jpc_t1enc.c:206:9: style: The scope of the variable 'vcausal' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int vcausal;
        ^
3rdparty/libjasper/jpc_t1enc.c:207:9: style: The scope of the variable 'segsym' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int segsym;
        ^
3rdparty/libjasper/jpc_t1enc.c:435:9: style: The scope of the variable 'vscanlen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int vscanlen;
        ^
3rdparty/libjasper/jpc_t1enc.c:535:9: style: The scope of the variable 'vscanlen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int vscanlen;
        ^
3rdparty/libjasper/jpc_t1enc.c:636:9: style: The scope of the variable 'vscanlen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int vscanlen;
        ^
3rdparty/libjasper/jpc_t1enc.c:730:9: style: The scope of the variable 'vscanlen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int vscanlen;
        ^
3rdparty/libjasper/jpc_t1enc.c:600:16: style: Variable 'fp' is assigned a value that is never used. [unreadVariable]
            fp += frowstep;
               ^
3rdparty/libjasper/jpc_t1enc.c:601:16: style: Variable 'dp' is assigned a value that is never used. [unreadVariable]
            dp += drowstep;
               ^
3rdparty/libjasper/jpc_t2cod.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_t2cod.c:86:17: style: The scope of the variable 'pchg' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_pchg_t *pchg;
                ^
3rdparty/libjasper/jpc_t2cod.c:506:9: style: The scope of the variable 'rlvlno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int rlvlno;
        ^
3rdparty/libjasper/jpc_t2cod.c:507:19: style: The scope of the variable 'pirlvl' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_pirlvl_t *pirlvl;
                  ^
3rdparty/libjasper/jpc_t2cod.c:519:19: style: The scope of the variable 'picomp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_picomp_t *picomp;
                  ^
3rdparty/libjasper/jpc_t2cod.c:520:9: style: The scope of the variable 'compno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int compno;
        ^
3rdparty/libjasper/jpc_t2cod.c:569:9: style: The scope of the variable 'newmaxpchgs' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int newmaxpchgs;
        ^
3rdparty/libjasper/jpc_t2cod.c:616:17: style: The scope of the variable 'newpchg' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_pchg_t *newpchg;
                ^
3rdparty/libjasper/jpc_t2cod.c:633:9: style: The scope of the variable 'pchgno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int pchgno;
        ^
3rdparty/libjasper/jpc_t2dec.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_t2dec.c:110:9: style: The scope of the variable 'v' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int v;
        ^
3rdparty/libjasper/jpc_t2dec.c:164:9: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int n;
        ^
3rdparty/libjasper/jpc_t2dec.c:165:9: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int m;
        ^
3rdparty/libjasper/jpc_t2dec.c:166:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
3rdparty/libjasper/jpc_t2dec.c:167:24: style: The scope of the variable 'leaf' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_tagtreenode_t *leaf;
                       ^
3rdparty/libjasper/jpc_t2dec.c:168:9: style: The scope of the variable 'included' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int included;
        ^
3rdparty/libjasper/jpc_t2dec.c:169:9: style: The scope of the variable 'ret' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int ret;
        ^
3rdparty/libjasper/jpc_t2dec.c:170:9: style: The scope of the variable 'numnewpasses' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int numnewpasses;
        ^
3rdparty/libjasper/jpc_t2dec.c:172:9: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int len;
        ^
3rdparty/libjasper/jpc_t2dec.c:174:9: style: The scope of the variable 'savenumnewpasses' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int savenumnewpasses;
        ^
3rdparty/libjasper/jpc_t2dec.c:175:9: style: The scope of the variable 'mycounter' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int mycounter;
        ^
3rdparty/libjasper/jpc_t2dec.c:182:9: style: The scope of the variable 'usedcblkcnt' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int usedcblkcnt;
        ^
3rdparty/libjasper/jpc_t2dec.c:186:9: style: The scope of the variable 'passno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int passno;
        ^
3rdparty/libjasper/jpc_t2dec.c:187:9: style: The scope of the variable 'maxpasses' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int maxpasses;
        ^
3rdparty/libjasper/jpc_t2dec.c:421:9: style: The scope of the variable 'ret' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int ret;
        ^
3rdparty/libjasper/jpc_t2enc.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_t2enc.c:540:45: style: Variable 'pass->lyrno' is reassigned a value before the old one has been used. [redundantAssignment]
                                pass->lyrno = 0;
                                            ^
3rdparty/libjasper/jpc_t2enc.c:539:45: note: pass->lyrno is assigned
                                pass->lyrno = -1;
                                            ^
3rdparty/libjasper/jpc_t2enc.c:540:45: note: pass->lyrno is overwritten
                                pass->lyrno = 0;
                                            ^
3rdparty/libjasper/jpc_t2enc.c:395:21: style: The scope of the variable 'endlvls' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_enc_rlvl_t *endlvls;
                    ^
3rdparty/libjasper/jpc_t2enc.c:443:21: style: The scope of the variable 'endlvls' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_enc_rlvl_t *endlvls;
                    ^
3rdparty/libjasper/jpc_t2enc.c:491:21: style: The scope of the variable 'endlvls' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_enc_rlvl_t *endlvls;
                    ^
3rdparty/libjasper/jpc_tagtree.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_tagtree.c:247:10: style: Variable 'tree' is assigned a value that is never used. [unreadVariable]
    tree = 0;
         ^
3rdparty/libjasper/jpc_tagtree.c:276:10: style: Variable 'tree' is assigned a value that is never used. [unreadVariable]
    tree = 0;
         ^
3rdparty/libjasper/jpc_tagtree.c:337:10: style: Variable 'tree' is assigned a value that is never used. [unreadVariable]
    tree = 0;
         ^
3rdparty/libjasper/jpc_tsfb.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_util.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjasper/jpc_util.c:105:20: style: Condition 'cp!='\0'' is always true [knownConditionTrueFalse]
            if (cp != '\0') {
                   ^
3rdparty/libjasper/jpc_util.c:104:20: note: Assuming that condition 'cp=strtok(0,delim)' is not redundant
        while ((cp = strtok(0, delim))) {
                   ^
3rdparty/libjasper/jpc_util.c:105:20: note: Condition 'cp!='\0'' is always true
            if (cp != '\0') {
                   ^
3rdparty/libjasper/jpc_util.c:123:24: style: Condition 'cp!='\0'' is always true [knownConditionTrueFalse]
                if (cp != '\0') {
                       ^
3rdparty/libjasper/jpc_util.c:122:24: note: Assuming that condition 'cp=strtok(0,delim)' is not redundant
            while ((cp = strtok(0, delim))) {
                       ^
3rdparty/libjasper/jpc_util.c:123:24: note: Condition 'cp!='\0'' is always true
                if (cp != '\0') {
                       ^
3rdparty/libjasper/jpc_util.c:173:15: style: The scope of the variable 's' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    jpc_fix_t s;
              ^
3rdparty/libjasper/jpc_util.c:105:20: warning: Char literal compared with pointer 'cp'. Did you intend to dereference it? [charLiteralWithCharPtrCompare]
            if (cp != '\0') {
                   ^
3rdparty/libjasper/jpc_util.c:123:24: warning: Char literal compared with pointer 'cp'. Did you intend to dereference it? [charLiteralWithCharPtrCompare]
                if (cp != '\0') {
                       ^
3rdparty/libjasper/jpc_util.c:102:13: style: Variable 'cp' is assigned a value that is never used. [unreadVariable]
    if ((cp = strtok(buf, delim))) {
            ^
3rdparty/libjpeg/jaricom.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jcapimin.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jcapimin.c:130:16: style: The scope of the variable 'qtbl' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JQUANT_TBL * qtbl;
               ^
3rdparty/libjpeg/jcapimin.c:131:15: style: The scope of the variable 'htbl' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JHUFF_TBL * htbl;
              ^
3rdparty/libjpeg/jcapistd.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jcarith.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jcarith.c:880:28: warning: Either the condition 'tbl>=16' is redundant or the array 'entropy->dc_stats[16]' is accessed at index 16, which is out of bounds. [arrayIndexOutOfBoundsCond]
      if (entropy->dc_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jcarith.c:878:26: note: Assuming that condition 'tbl>=16' is not redundant
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
                         ^
3rdparty/libjpeg/jcarith.c:877:20: note: Assignment 'tbl=compptr->dc_tbl_no', assigned value is 16
      tbl = compptr->dc_tbl_no;
                   ^
3rdparty/libjpeg/jcarith.c:880:28: note: Array index out of bounds
      if (entropy->dc_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jcarith.c:880:28: warning: Either the condition 'tbl<0' is redundant or the array 'entropy->dc_stats[16]' is accessed at index -1, which is out of bounds. [negativeIndex]
      if (entropy->dc_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jcarith.c:878:15: note: Assuming that condition 'tbl<0' is not redundant
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
              ^
3rdparty/libjpeg/jcarith.c:880:28: note: Negative array index
      if (entropy->dc_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jcarith.c:893:28: warning: Either the condition 'tbl>=16' is redundant or the array 'entropy->ac_stats[16]' is accessed at index 16, which is out of bounds. [arrayIndexOutOfBoundsCond]
      if (entropy->ac_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jcarith.c:891:26: note: Assuming that condition 'tbl>=16' is not redundant
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
                         ^
3rdparty/libjpeg/jcarith.c:890:20: note: Assignment 'tbl=compptr->ac_tbl_no', assigned value is 16
      tbl = compptr->ac_tbl_no;
                   ^
3rdparty/libjpeg/jcarith.c:893:28: note: Array index out of bounds
      if (entropy->ac_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jcarith.c:893:28: warning: Either the condition 'tbl<0' is redundant or the array 'entropy->ac_stats[16]' is accessed at index -1, which is out of bounds. [negativeIndex]
      if (entropy->ac_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jcarith.c:891:15: note: Assuming that condition 'tbl<0' is not redundant
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
              ^
3rdparty/libjpeg/jcarith.c:893:28: note: Negative array index
      if (entropy->ac_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jcarith.c:323:25: style: The scope of the variable 'compptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  jpeg_component_info * compptr;
                        ^
3rdparty/libjpeg/jcarith.c:365:18: style: The scope of the variable 'st' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  unsigned char *st;
                 ^
3rdparty/libjpeg/jcarith.c:366:13: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int blkn, ci, tbl;
            ^
3rdparty/libjpeg/jcarith.c:366:17: style: The scope of the variable 'tbl' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int blkn, ci, tbl;
                ^
3rdparty/libjpeg/jcarith.c:367:14: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int v, v2, m;
             ^
3rdparty/libjpeg/jcarith.c:458:14: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int v, v2, m;
             ^
3rdparty/libjpeg/jcarith.c:696:13: style: The scope of the variable 'block' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JBLOCKROW block;
            ^
3rdparty/libjpeg/jcarith.c:697:18: style: The scope of the variable 'st' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  unsigned char *st;
                 ^
3rdparty/libjpeg/jcarith.c:698:7: style: The scope of the variable 'tbl' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int tbl, k, ke;
      ^
3rdparty/libjpeg/jcarith.c:698:15: style: The scope of the variable 'ke' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int tbl, k, ke;
              ^
3rdparty/libjpeg/jcarith.c:700:13: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int blkn, ci;
            ^
3rdparty/libjpeg/jcarith.c:629:13: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
      if (v >>= cinfo->Al) break;
            ^
3rdparty/libjpeg/jcarith.c:632:13: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
      if (v >>= cinfo->Al) break;
            ^
3rdparty/libjpeg/jcarith.c:639:13: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
      if (v >>= cinfo->Ah) break;
            ^
3rdparty/libjpeg/jcarith.c:642:13: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
      if (v >>= cinfo->Ah) break;
            ^
3rdparty/libjpeg/jccoefct.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jccoefct.c:381:31: portability: Assigning a pointer to an integer (int/long/etc) is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit address to 32-bit integer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t). [AssignmentAddressToInteger]
     coef->MCU_buffer[blkn++] = buffer_ptr++;
                              ^
3rdparty/libjpeg/jccoefct.c:450:27: portability: Assigning a pointer to an integer (int/long/etc) is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit address to 32-bit integer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t). [AssignmentAddressToInteger]
      coef->MCU_buffer[i] = buffer + i;
                          ^
3rdparty/libjpeg/jccoefct.c:253:14: style: The scope of the variable 'blocks_across' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JDIMENSION blocks_across, MCUs_across, MCUindex;
             ^
3rdparty/libjpeg/jccoefct.c:254:15: style: The scope of the variable 'h_samp_factor' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int bi, ci, h_samp_factor, block_row, block_rows, ndummy;
              ^
3rdparty/libjpeg/jccoefct.c:254:53: style: The scope of the variable 'ndummy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int bi, ci, h_samp_factor, block_row, block_rows, ndummy;
                                                    ^
3rdparty/libjpeg/jccoefct.c:259:19: style: The scope of the variable 'forward_DCT' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  forward_DCT_ptr forward_DCT;
                  ^
3rdparty/libjpeg/jccolor.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jccolor.c:150:21: style: The scope of the variable 'inptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr;
                    ^
3rdparty/libjpeg/jccolor.c:151:21: style: The scope of the variable 'outptr0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr0, outptr1, outptr2;
                    ^
3rdparty/libjpeg/jccolor.c:151:30: style: The scope of the variable 'outptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr0, outptr1, outptr2;
                             ^
3rdparty/libjpeg/jccolor.c:151:39: style: The scope of the variable 'outptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr0, outptr1, outptr2;
                                      ^
3rdparty/libjpeg/jccolor.c:206:21: style: The scope of the variable 'inptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr;
                    ^
3rdparty/libjpeg/jccolor.c:207:21: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr;
                    ^
3rdparty/libjpeg/jccolor.c:245:21: style: The scope of the variable 'outptr0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr0, outptr1, outptr2, outptr3;
                    ^
3rdparty/libjpeg/jccolor.c:245:30: style: The scope of the variable 'outptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr0, outptr1, outptr2, outptr3;
                             ^
3rdparty/libjpeg/jccolor.c:245:39: style: The scope of the variable 'outptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr0, outptr1, outptr2, outptr3;
                                      ^
3rdparty/libjpeg/jccolor.c:245:48: style: The scope of the variable 'outptr3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr0, outptr1, outptr2, outptr3;
                                               ^
3rdparty/libjpeg/jccolor.c:300:21: style: The scope of the variable 'inptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr;
                    ^
3rdparty/libjpeg/jccolor.c:301:21: style: The scope of the variable 'outptr0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr0, outptr1, outptr2;
                    ^
3rdparty/libjpeg/jccolor.c:301:30: style: The scope of the variable 'outptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr0, outptr1, outptr2;
                             ^
3rdparty/libjpeg/jccolor.c:301:39: style: The scope of the variable 'outptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr0, outptr1, outptr2;
                                      ^
3rdparty/libjpeg/jccolor.c:340:21: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr;
                    ^
3rdparty/libjpeg/jccolor.c:367:21: style: The scope of the variable 'outptr0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr0, outptr1, outptr2;
                    ^
3rdparty/libjpeg/jccolor.c:367:30: style: The scope of the variable 'outptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr0, outptr1, outptr2;
                             ^
3rdparty/libjpeg/jccolor.c:367:39: style: The scope of the variable 'outptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr0, outptr1, outptr2;
                                      ^
3rdparty/libjpeg/jcdctmgr.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jcdctmgr.c:363:33: warning: Either the condition 'qtblno>=4' is redundant or the array 'cinfo->quant_tbl_ptrs[4]' is accessed at index 4, which is out of bounds. [arrayIndexOutOfBoundsCond]
    qtbl = cinfo->quant_tbl_ptrs[qtblno];
                                ^
3rdparty/libjpeg/jcdctmgr.c:360:30: note: Assuming that condition 'qtblno>=4' is not redundant
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
                             ^
3rdparty/libjpeg/jcdctmgr.c:358:21: note: Assignment 'qtblno=compptr->quant_tbl_no', assigned value is 4
    qtblno = compptr->quant_tbl_no;
                    ^
3rdparty/libjpeg/jcdctmgr.c:363:33: note: Array index out of bounds
    qtbl = cinfo->quant_tbl_ptrs[qtblno];
                                ^
3rdparty/libjpeg/jcdctmgr.c:363:33: warning: Either the condition 'qtblno<0' is redundant or the array 'cinfo->quant_tbl_ptrs[4]' is accessed at index -1, which is out of bounds. [negativeIndex]
    qtbl = cinfo->quant_tbl_ptrs[qtblno];
                                ^
3rdparty/libjpeg/jcdctmgr.c:360:16: note: Assuming that condition 'qtblno<0' is not redundant
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
               ^
3rdparty/libjpeg/jcdctmgr.c:363:33: note: Negative array index
    qtbl = cinfo->quant_tbl_ptrs[qtblno];
                                ^
3rdparty/libjpeg/jcdctmgr.c:94:24: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    { register DCTELEM temp, qval;
                       ^
3rdparty/libjpeg/jcdctmgr.c:94:30: style: The scope of the variable 'qval' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    { register DCTELEM temp, qval;
                             ^
3rdparty/libjpeg/jcdctmgr.c:157:27: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    { register FAST_FLOAT temp;
                          ^
3rdparty/libjpeg/jcdctmgr.c:192:11: style: The scope of the variable 'qtblno' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci, qtblno, i;
          ^
3rdparty/libjpeg/jcdctmgr.c:195:16: style: The scope of the variable 'qtbl' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JQUANT_TBL * qtbl;
               ^
3rdparty/libjpeg/jcdctmgr.c:46:11: style: union member 'divisor_table::int_array' is never used. [unusedStructMember]
  DCTELEM int_array[DCTSIZE2];
          ^
3rdparty/libjpeg/jcdctmgr.c:48:14: style: union member 'divisor_table::float_array' is never used. [unusedStructMember]
  FAST_FLOAT float_array[DCTSIZE2];
             ^
3rdparty/libjpeg/jchuff.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jchuff.c:179:35: warning: Either the condition 'tblno>=4' is redundant or the array 'cinfo->dc_huff_tbl_ptrs[4]' is accessed at index 4, which is out of bounds. [arrayIndexOutOfBoundsCond]
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                  ^
3rdparty/libjpeg/jchuff.c:176:26: note: Assuming that condition 'tblno>=4' is not redundant
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
                         ^
3rdparty/libjpeg/jchuff.c:179:35: note: Array index out of bounds
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                  ^
3rdparty/libjpeg/jchuff.c:179:35: warning: Either the condition 'tblno<0' is redundant or the array 'cinfo->dc_huff_tbl_ptrs[4]' is accessed at index -1, which is out of bounds. [negativeIndex]
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                  ^
3rdparty/libjpeg/jchuff.c:176:13: note: Assuming that condition 'tblno<0' is not redundant
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
            ^
3rdparty/libjpeg/jchuff.c:179:35: note: Negative array index
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                  ^
3rdparty/libjpeg/jchuff.c:179:68: warning: Either the condition 'tblno>=4' is redundant or the array 'cinfo->ac_huff_tbl_ptrs[4]' is accessed at index 4, which is out of bounds. [arrayIndexOutOfBoundsCond]
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                                                   ^
3rdparty/libjpeg/jchuff.c:176:26: note: Assuming that condition 'tblno>=4' is not redundant
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
                         ^
3rdparty/libjpeg/jchuff.c:179:68: note: Array index out of bounds
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                                                   ^
3rdparty/libjpeg/jchuff.c:179:68: warning: Either the condition 'tblno<0' is redundant or the array 'cinfo->ac_huff_tbl_ptrs[4]' is accessed at index -1, which is out of bounds. [negativeIndex]
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                                                   ^
3rdparty/libjpeg/jchuff.c:176:13: note: Assuming that condition 'tblno<0' is not redundant
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
            ^
3rdparty/libjpeg/jchuff.c:179:68: note: Negative array index
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                                                   ^
3rdparty/libjpeg/jchuff.c:243:17: warning: Either the condition 'i<0' is redundant or the array 'dtbl->ehufco[256]' is accessed at index -1, which is out of bounds. [negativeIndex]
    dtbl->ehufco[i] = huffcode[p];
                ^
3rdparty/libjpeg/jchuff.c:241:11: note: Assuming that condition 'i<0' is not redundant
    if (i < 0 || i > maxsymbol || dtbl->ehufsi[i])
          ^
3rdparty/libjpeg/jchuff.c:243:17: note: Negative array index
    dtbl->ehufco[i] = huffcode[p];
                ^
3rdparty/libjpeg/jchuff.c:244:17: warning: Either the condition 'i<0' is redundant or the array 'dtbl->ehufsi[256]' is accessed at index -1, which is out of bounds. [negativeIndex]
    dtbl->ehufsi[i] = huffsize[p];
                ^
3rdparty/libjpeg/jchuff.c:241:11: note: Assuming that condition 'i<0' is not redundant
    if (i < 0 || i > maxsymbol || dtbl->ehufsi[i])
          ^
3rdparty/libjpeg/jchuff.c:244:17: note: Negative array index
    dtbl->ehufsi[i] = huffsize[p];
                ^
3rdparty/libjpeg/jchuff.c:1334:11: warning: Either the condition 'codesize[i]>32' is redundant or the array 'bits[33]' is accessed at index 33, which is out of bounds. [arrayIndexOutOfBoundsCond]
      bits[codesize[i]]++;
          ^
3rdparty/libjpeg/jchuff.c:1331:23: note: Assuming that condition 'codesize[i]>32' is not redundant
      if (codesize[i] > MAX_CLEN)
                      ^
3rdparty/libjpeg/jchuff.c:1334:11: note: Array index out of bounds
      bits[codesize[i]]++;
          ^
3rdparty/libjpeg/jchuff.c:1507:28: warning: Either the condition 'tbl>=4' is redundant or the array 'entropy->dc_count_ptrs[4]' is accessed at index 4, which is out of bounds. [arrayIndexOutOfBoundsCond]
 if (entropy->dc_count_ptrs[tbl] == NULL)
                           ^
3rdparty/libjpeg/jchuff.c:1503:21: note: Assuming that condition 'tbl>=4' is not redundant
 if (tbl < 0 || tbl >= NUM_HUFF_TBLS)
                    ^
3rdparty/libjpeg/jchuff.c:1507:28: note: Array index out of bounds
 if (entropy->dc_count_ptrs[tbl] == NULL)
                           ^
3rdparty/libjpeg/jchuff.c:1507:28: warning: Either the condition 'tbl<0' is redundant or the array 'entropy->dc_count_ptrs[4]' is accessed at index -1, which is out of bounds. [negativeIndex]
 if (entropy->dc_count_ptrs[tbl] == NULL)
                           ^
3rdparty/libjpeg/jchuff.c:1503:10: note: Assuming that condition 'tbl<0' is not redundant
 if (tbl < 0 || tbl >= NUM_HUFF_TBLS)
         ^
3rdparty/libjpeg/jchuff.c:1507:28: note: Negative array index
 if (entropy->dc_count_ptrs[tbl] == NULL)
                           ^
3rdparty/libjpeg/jchuff.c:1527:28: warning: Either the condition 'tbl>=4' is redundant or the array 'entropy->ac_count_ptrs[4]' is accessed at index 4, which is out of bounds. [arrayIndexOutOfBoundsCond]
 if (entropy->ac_count_ptrs[tbl] == NULL)
                           ^
3rdparty/libjpeg/jchuff.c:1525:21: note: Assuming that condition 'tbl>=4' is not redundant
 if (tbl < 0 || tbl >= NUM_HUFF_TBLS)
                    ^
3rdparty/libjpeg/jchuff.c:1527:28: note: Array index out of bounds
 if (entropy->ac_count_ptrs[tbl] == NULL)
                           ^
3rdparty/libjpeg/jchuff.c:1527:28: warning: Either the condition 'tbl<0' is redundant or the array 'entropy->ac_count_ptrs[4]' is accessed at index -1, which is out of bounds. [negativeIndex]
 if (entropy->ac_count_ptrs[tbl] == NULL)
                           ^
3rdparty/libjpeg/jchuff.c:1525:10: note: Assuming that condition 'tbl<0' is not redundant
 if (tbl < 0 || tbl >= NUM_HUFF_TBLS)
         ^
3rdparty/libjpeg/jchuff.c:1527:28: note: Negative array index
 if (entropy->ac_count_ptrs[tbl] == NULL)
                           ^
3rdparty/libjpeg/jchuff.c:466:16: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register int temp, nbits;
               ^
3rdparty/libjpeg/jchuff.c:466:22: style: The scope of the variable 'nbits' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register int temp, nbits;
                     ^
3rdparty/libjpeg/jchuff.c:518:7: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci;
      ^
3rdparty/libjpeg/jchuff.c:549:16: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register int temp, temp2;
               ^
3rdparty/libjpeg/jchuff.c:549:22: style: The scope of the variable 'temp2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register int temp, temp2;
                     ^
3rdparty/libjpeg/jchuff.c:550:16: style: The scope of the variable 'nbits' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register int nbits;
               ^
3rdparty/libjpeg/jchuff.c:551:13: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int blkn, ci, tbl;
            ^
3rdparty/libjpeg/jchuff.c:551:17: style: The scope of the variable 'tbl' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int blkn, ci, tbl;
                ^
3rdparty/libjpeg/jchuff.c:634:16: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register int temp, temp2;
               ^
3rdparty/libjpeg/jchuff.c:1017:13: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int blkn, ci;
            ^
3rdparty/libjpeg/jchuff.c:1018:25: style: The scope of the variable 'compptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  jpeg_component_info * compptr;
                        ^
3rdparty/libjpeg/jchuff.c:1198:25: style: The scope of the variable 'compptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  jpeg_component_info * compptr;
                        ^
3rdparty/libjpeg/jchuff.c:1259:7: style: The scope of the variable 'c1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int c1, c2;
      ^
3rdparty/libjpeg/jchuff.c:1259:11: style: The scope of the variable 'c2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int c1, c2;
          ^
3rdparty/libjpeg/jchuff.c:1261:8: style: The scope of the variable 'v' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  long v;
       ^
3rdparty/libjpeg/jcinit.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jcinit.c:41:27: style: The unsigned expression 'cinfo->image_height' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
  if (cinfo->image_height <= 0 || cinfo->image_width <= 0 ||
                          ^
3rdparty/libjpeg/jcinit.c:41:54: style: The unsigned expression 'cinfo->image_width' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
  if (cinfo->image_height <= 0 || cinfo->image_width <= 0 ||
                                                     ^
3rdparty/libjpeg/jcmainct.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jcmainct.c:251:7: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci;
      ^
3rdparty/libjpeg/jcmainct.c:252:24: style: The scope of the variable 'compptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  jpeg_component_info *compptr;
                       ^
3rdparty/libjpeg/jcmarker.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jcmarker.c:203:9: warning: Either the condition 'htbl==NULL' is redundant or there is possible null pointer dereference: htbl. [nullPointerRedundantCheck]
  if (! htbl->sent_table) {
        ^
3rdparty/libjpeg/jcmarker.c:200:12: note: Assuming that condition 'htbl==NULL' is not redundant
  if (htbl == NULL)
           ^
3rdparty/libjpeg/jcmarker.c:203:9: note: Null pointer dereference
  if (! htbl->sent_table) {
        ^
3rdparty/libjpeg/jcmarker.c:191:7: style: The scope of the variable 'length' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int length, i;
      ^
3rdparty/libjpeg/jcmarker.c:191:15: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int length, i;
              ^
3rdparty/libjpeg/jcmarker.c:234:24: style: The scope of the variable 'compptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  jpeg_component_info *compptr;
                       ^
3rdparty/libjpeg/jcmarker.c:351:10: style: The scope of the variable 'td' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i, td, ta;
         ^
3rdparty/libjpeg/jcmarker.c:351:14: style: The scope of the variable 'ta' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i, td, ta;
             ^
3rdparty/libjpeg/jcmarker.c:352:24: style: The scope of the variable 'compptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  jpeg_component_info *compptr;
                       ^
3rdparty/libjpeg/jcmarker.c:616:7: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i;
      ^
3rdparty/libjpeg/jcmarker.c:617:24: style: The scope of the variable 'compptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  jpeg_component_info *compptr;
                       ^
3rdparty/libjpeg/jcmaster.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jcmaster.c:223:11: style: The scope of the variable 'ssize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci, ssize;
          ^
3rdparty/libjpeg/jcmaster.c:358:15: style: The scope of the variable 'ncomps' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int scanno, ncomps, ci, coefi, thisi;
              ^
3rdparty/libjpeg/jcmaster.c:359:7: style: The scope of the variable 'Ss' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int Ss, Se, Ah, Al;
      ^
3rdparty/libjpeg/jcmaster.c:359:11: style: The scope of the variable 'Se' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int Ss, Se, Ah, Al;
          ^
3rdparty/libjpeg/jcmaster.c:359:15: style: The scope of the variable 'Ah' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int Ss, Se, Ah, Al;
              ^
3rdparty/libjpeg/jcmaster.c:359:19: style: The scope of the variable 'Al' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int Ss, Se, Ah, Al;
                  ^
3rdparty/libjpeg/jcmaster.c:570:7: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci, mcublks, tmp;
      ^
3rdparty/libjpeg/jcmaster.c:570:11: style: The scope of the variable 'mcublks' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci, mcublks, tmp;
          ^
3rdparty/libjpeg/jcmaster.c:251:26: style: The unsigned expression 'cinfo->jpeg_height' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
  if (cinfo->jpeg_height <= 0 || cinfo->jpeg_width <= 0 ||
                         ^
3rdparty/libjpeg/jcmaster.c:251:52: style: The unsigned expression 'cinfo->jpeg_width' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
  if (cinfo->jpeg_height <= 0 || cinfo->jpeg_width <= 0 ||
                                                   ^
3rdparty/libjpeg/jcomapi.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jcparam.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jcparam.c:44:36: warning: Either the condition 'which_tbl<0' is redundant or the array 'cinfo->quant_tbl_ptrs[4]' is accessed at index -1, which is out of bounds. [negativeIndex]
  qtblptr = & cinfo->quant_tbl_ptrs[which_tbl];
                                   ^
3rdparty/libjpeg/jcparam.c:41:17: note: Assuming that condition 'which_tbl<0' is not redundant
  if (which_tbl < 0 || which_tbl >= NUM_QUANT_TBLS)
                ^
3rdparty/libjpeg/jcparam.c:44:36: note: Negative array index
  qtblptr = & cinfo->quant_tbl_ptrs[which_tbl];
                                   ^
3rdparty/libjpeg/jcparam.c:35:8: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  long temp;
       ^
3rdparty/libjpeg/jcparam.c:573:7: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci;
      ^
3rdparty/libjpeg/jcparam.c:660:13: style: Variable 'scanptr' is assigned a value that is never used. [unreadVariable]
    scanptr = fill_a_scan(scanptr, 0, 1, 63, 1, 0);
            ^
3rdparty/libjpeg/jcparam.c:671:13: style: Variable 'scanptr' is assigned a value that is never used. [unreadVariable]
    scanptr = fill_scans(scanptr, ncomps, 1, 63, 1, 0);
            ^
3rdparty/libjpeg/jcprepct.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jcprepct.c:135:7: style: The scope of the variable 'numrows' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int numrows, ci;
      ^
3rdparty/libjpeg/jcprepct.c:136:14: style: The scope of the variable 'inrows' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JDIMENSION inrows;
             ^
3rdparty/libjpeg/jcprepct.c:321:7: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci;
      ^
3rdparty/libjpeg/jcprepct.c:322:25: style: The scope of the variable 'compptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  jpeg_component_info * compptr;
                        ^
3rdparty/libjpeg/jcsample.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jcsample.c:100:20: style: The scope of the variable 'pixval' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPLE pixval;
                   ^
3rdparty/libjpeg/jcsample.c:101:16: style: The scope of the variable 'count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register int count;
               ^
3rdparty/libjpeg/jcsample.c:102:7: style: The scope of the variable 'row' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int row;
      ^
3rdparty/libjpeg/jcsample.c:130:14: style: The scope of the variable 'in_ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPARRAY in_ptr, out_ptr;
             ^
3rdparty/libjpeg/jcsample.c:130:22: style: The scope of the variable 'out_ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPARRAY in_ptr, out_ptr;
                     ^
3rdparty/libjpeg/jcsample.c:157:19: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW inptr, outptr;
                  ^
3rdparty/libjpeg/jcsample.c:230:21: style: The scope of the variable 'inptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr, outptr;
                    ^
3rdparty/libjpeg/jcsample.c:230:28: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr, outptr;
                           ^
3rdparty/libjpeg/jcsample.c:231:16: style: The scope of the variable 'bias' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register int bias;
               ^
3rdparty/libjpeg/jcsample.c:267:21: style: The scope of the variable 'inptr0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, outptr;
                    ^
3rdparty/libjpeg/jcsample.c:267:29: style: The scope of the variable 'inptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, outptr;
                            ^
3rdparty/libjpeg/jcsample.c:267:37: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, outptr;
                                    ^
3rdparty/libjpeg/jcsample.c:268:16: style: The scope of the variable 'bias' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register int bias;
               ^
3rdparty/libjpeg/jcsample.c:311:21: style: The scope of the variable 'inptr0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;
                    ^
3rdparty/libjpeg/jcsample.c:311:29: style: The scope of the variable 'inptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;
                            ^
3rdparty/libjpeg/jcsample.c:311:37: style: The scope of the variable 'above_ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;
                                    ^
3rdparty/libjpeg/jcsample.c:311:48: style: The scope of the variable 'below_ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;
                                               ^
3rdparty/libjpeg/jcsample.c:311:59: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;
                                                          ^
3rdparty/libjpeg/jcsample.c:312:9: style: The scope of the variable 'membersum' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 membersum, neighsum, memberscale, neighscale;
        ^
3rdparty/libjpeg/jcsample.c:312:20: style: The scope of the variable 'neighsum' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 membersum, neighsum, memberscale, neighscale;
                   ^
3rdparty/libjpeg/jcsample.c:412:21: style: The scope of the variable 'inptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr, above_ptr, below_ptr, outptr;
                    ^
3rdparty/libjpeg/jcsample.c:412:28: style: The scope of the variable 'above_ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr, above_ptr, below_ptr, outptr;
                           ^
3rdparty/libjpeg/jcsample.c:412:39: style: The scope of the variable 'below_ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr, above_ptr, below_ptr, outptr;
                                      ^
3rdparty/libjpeg/jcsample.c:412:50: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr, above_ptr, below_ptr, outptr;
                                                 ^
3rdparty/libjpeg/jcsample.c:413:9: style: The scope of the variable 'membersum' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 membersum, neighsum, memberscale, neighscale;
        ^
3rdparty/libjpeg/jcsample.c:413:20: style: The scope of the variable 'neighsum' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 membersum, neighsum, memberscale, neighscale;
                   ^
3rdparty/libjpeg/jcsample.c:414:7: style: The scope of the variable 'colsum' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int colsum, lastcolsum, nextcolsum;
      ^
3rdparty/libjpeg/jcsample.c:414:15: style: The scope of the variable 'lastcolsum' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int colsum, lastcolsum, nextcolsum;
              ^
3rdparty/libjpeg/jcsample.c:414:27: style: The scope of the variable 'nextcolsum' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int colsum, lastcolsum, nextcolsum;
                          ^
3rdparty/libjpeg/jcsample.c:484:7: style: The scope of the variable 'h_in_group' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int h_in_group, v_in_group, h_out_group, v_out_group;
      ^
3rdparty/libjpeg/jcsample.c:484:19: style: The scope of the variable 'v_in_group' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int h_in_group, v_in_group, h_out_group, v_out_group;
                  ^
3rdparty/libjpeg/jcsample.c:484:31: style: The scope of the variable 'h_out_group' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int h_in_group, v_in_group, h_out_group, v_out_group;
                              ^
3rdparty/libjpeg/jcsample.c:484:44: style: The scope of the variable 'v_out_group' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int h_in_group, v_in_group, h_out_group, v_out_group;
                                           ^
3rdparty/libjpeg/jctrans.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jctrans.c:315:27: portability: Assigning a pointer to an integer (int/long/etc) is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit address to 32-bit integer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t). [AssignmentAddressToInteger]
       MCU_buffer[blkn++] = buffer_ptr++;
                          ^
3rdparty/libjpeg/jctrans.c:383:27: portability: Assigning a pointer to an integer (int/long/etc) is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit address to 32-bit integer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t). [AssignmentAddressToInteger]
    coef->dummy_buffer[i] = buffer + i;
                          ^
3rdparty/libjpeg/jctrans.c:128:41: warning: Either the condition 'tblno>=4' is redundant or the array 'srcinfo->quant_tbl_ptrs[4]' is accessed at index 4, which is out of bounds. [arrayIndexOutOfBoundsCond]
    slot_quant = srcinfo->quant_tbl_ptrs[tblno];
                                        ^
3rdparty/libjpeg/jctrans.c:125:28: note: Assuming that condition 'tblno>=4' is not redundant
    if (tblno < 0 || tblno >= NUM_QUANT_TBLS ||
                           ^
3rdparty/libjpeg/jctrans.c:124:20: note: Assignment 'tblno=outcomp->quant_tbl_no', assigned value is 4
    tblno = outcomp->quant_tbl_no;
                   ^
3rdparty/libjpeg/jctrans.c:128:41: note: Array index out of bounds
    slot_quant = srcinfo->quant_tbl_ptrs[tblno];
                                        ^
3rdparty/libjpeg/jctrans.c:128:41: warning: Either the condition 'tblno<0' is redundant or the array 'srcinfo->quant_tbl_ptrs[4]' is accessed at index -1, which is out of bounds. [negativeIndex]
    slot_quant = srcinfo->quant_tbl_ptrs[tblno];
                                        ^
3rdparty/libjpeg/jctrans.c:125:15: note: Assuming that condition 'tblno<0' is not redundant
    if (tblno < 0 || tblno >= NUM_QUANT_TBLS ||
              ^
3rdparty/libjpeg/jctrans.c:128:41: note: Negative array index
    slot_quant = srcinfo->quant_tbl_ptrs[tblno];
                                        ^
3rdparty/libjpeg/jctrans.c:69:15: style: The scope of the variable 'c_quant' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JQUANT_TBL *c_quant, *slot_quant;
              ^
3rdparty/libjpeg/jctrans.c:69:25: style: The scope of the variable 'slot_quant' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JQUANT_TBL *c_quant, *slot_quant;
                        ^
3rdparty/libjpeg/jdapimin.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdapistd.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdarith.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdarith.c:476:16: portability: Assigning an integer (int/long/etc) to a pointer is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit integer to 32-bit pointer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t). [AssignmentIntegerToAddress]
      thiscoef = *block + natural_order[++k];
               ^
3rdparty/libjpeg/jdarith.c:718:28: warning: Either the condition 'tbl>=16' is redundant or the array 'entropy->dc_stats[16]' is accessed at index 16, which is out of bounds. [arrayIndexOutOfBoundsCond]
      if (entropy->dc_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jdarith.c:716:26: note: Assuming that condition 'tbl>=16' is not redundant
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
                         ^
3rdparty/libjpeg/jdarith.c:715:20: note: Assignment 'tbl=compptr->dc_tbl_no', assigned value is 16
      tbl = compptr->dc_tbl_no;
                   ^
3rdparty/libjpeg/jdarith.c:718:28: note: Array index out of bounds
      if (entropy->dc_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jdarith.c:718:28: warning: Either the condition 'tbl<0' is redundant or the array 'entropy->dc_stats[16]' is accessed at index -1, which is out of bounds. [negativeIndex]
      if (entropy->dc_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jdarith.c:716:15: note: Assuming that condition 'tbl<0' is not redundant
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
              ^
3rdparty/libjpeg/jdarith.c:718:28: note: Negative array index
      if (entropy->dc_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jdarith.c:731:28: warning: Either the condition 'tbl>=16' is redundant or the array 'entropy->ac_stats[16]' is accessed at index 16, which is out of bounds. [arrayIndexOutOfBoundsCond]
      if (entropy->ac_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jdarith.c:729:26: note: Assuming that condition 'tbl>=16' is not redundant
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
                         ^
3rdparty/libjpeg/jdarith.c:728:20: note: Assignment 'tbl=compptr->ac_tbl_no', assigned value is 16
      tbl = compptr->ac_tbl_no;
                   ^
3rdparty/libjpeg/jdarith.c:731:28: note: Array index out of bounds
      if (entropy->ac_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jdarith.c:731:28: warning: Either the condition 'tbl<0' is redundant or the array 'entropy->ac_stats[16]' is accessed at index -1, which is out of bounds. [negativeIndex]
      if (entropy->ac_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jdarith.c:729:15: note: Assuming that condition 'tbl<0' is not redundant
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
              ^
3rdparty/libjpeg/jdarith.c:731:28: note: Negative array index
      if (entropy->ac_stats[tbl] == NULL)
                           ^
3rdparty/libjpeg/jdarith.c:194:25: style: The scope of the variable 'compptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  jpeg_component_info * compptr;
                        ^
3rdparty/libjpeg/jdarith.c:245:13: style: The scope of the variable 'block' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JBLOCKROW block;
            ^
3rdparty/libjpeg/jdarith.c:246:18: style: The scope of the variable 'st' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  unsigned char *st;
                 ^
3rdparty/libjpeg/jdarith.c:247:13: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int blkn, ci, tbl, sign;
            ^
3rdparty/libjpeg/jdarith.c:247:17: style: The scope of the variable 'tbl' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int blkn, ci, tbl, sign;
                ^
3rdparty/libjpeg/jdarith.c:325:18: style: The scope of the variable 'st' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  unsigned char *st;
                 ^
3rdparty/libjpeg/jdarith.c:326:12: style: The scope of the variable 'sign' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int tbl, sign, k;
           ^
3rdparty/libjpeg/jdarith.c:327:7: style: The scope of the variable 'v' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int v, m;
      ^
3rdparty/libjpeg/jdarith.c:327:10: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int v, m;
         ^
3rdparty/libjpeg/jdarith.c:441:18: style: The scope of the variable 'st' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  unsigned char *st;
                 ^
3rdparty/libjpeg/jdarith.c:515:13: style: The scope of the variable 'block' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JBLOCKROW block;
            ^
3rdparty/libjpeg/jdarith.c:516:18: style: The scope of the variable 'st' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  unsigned char *st;
                 ^
3rdparty/libjpeg/jdarith.c:517:13: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int blkn, ci, tbl, sign, k;
            ^
3rdparty/libjpeg/jdarith.c:517:17: style: The scope of the variable 'tbl' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int blkn, ci, tbl, sign, k;
                ^
3rdparty/libjpeg/jdarith.c:462:13: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
  m1 = (-1) << cinfo->Al; /* -1 in the bit position being coded */
            ^
3rdparty/libjpeg/jdatadst.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdatadst.c:260:8: warning: Either the condition 'outbuffer==NULL' is redundant or there is possible null pointer dereference: outbuffer. [nullPointerRedundantCheck]
  if (*outbuffer == NULL || *outsize == 0) {
       ^
3rdparty/libjpeg/jdatadst.c:240:17: note: Assuming that condition 'outbuffer==NULL' is not redundant
  if (outbuffer == NULL || outsize == NULL) /* sanity check */
                ^
3rdparty/libjpeg/jdatadst.c:260:8: note: Null pointer dereference
  if (*outbuffer == NULL || *outsize == 0) {
       ^
3rdparty/libjpeg/jdatadst.c:143:43: warning: Either the condition 'nextbuffer==NULL' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
  dest->pub.next_output_byte = nextbuffer + dest->bufsize;
                                          ^
3rdparty/libjpeg/jdatadst.c:133:18: note: Assuming that condition 'nextbuffer==NULL' is not redundant
  if (nextbuffer == NULL)
                 ^
3rdparty/libjpeg/jdatadst.c:131:16: note: Assignment 'nextbuffer=(unsigned char*)malloc(nextsize)', assigned value is 0
  nextbuffer = (JOCTET *) malloc(nextsize);
               ^
3rdparty/libjpeg/jdatadst.c:143:43: note: Null pointer addition
  dest->pub.next_output_byte = nextbuffer + dest->bufsize;
                                          ^
3rdparty/libjpeg/jdatasrc.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdatasrc.c:104:14: style: The unsigned expression 'nbytes' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
  if (nbytes <= 0) {
             ^
3rdparty/libjpeg/jdcoefct.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdcoefct.c:282:31: portability: Assigning a pointer to an integer (int/long/etc) is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit address to 32-bit integer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t). [AssignmentAddressToInteger]
     coef->MCU_buffer[blkn++] = buffer_ptr++;
                              ^
3rdparty/libjpeg/jdcoefct.c:442:15: portability: Assigning an integer (int/long/etc) to a pointer is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit integer to 32-bit pointer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t). [AssignmentIntegerToAddress]
    coef_bits = cinfo->coef_bits[ci];
              ^
3rdparty/libjpeg/jdcoefct.c:732:27: portability: Assigning a pointer to an integer (int/long/etc) is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit address to 32-bit integer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t). [AssignmentAddressToInteger]
      coef->MCU_buffer[i] = buffer + i;
                          ^
3rdparty/libjpeg/jdcoefct.c:413:16: style: The scope of the variable 'qtable' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JQUANT_TBL * qtable;
               ^
3rdparty/libjpeg/jdcoefct.c:698:13: style: The scope of the variable 'access_rows' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int ci, access_rows;
            ^
3rdparty/libjpeg/jdcolor.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdcolor.c:210:21: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr;
                    ^
3rdparty/libjpeg/jdcolor.c:211:21: style: The scope of the variable 'inptr0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2;
                    ^
3rdparty/libjpeg/jdcolor.c:211:29: style: The scope of the variable 'inptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2;
                            ^
3rdparty/libjpeg/jdcolor.c:211:37: style: The scope of the variable 'inptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2;
                                    ^
3rdparty/libjpeg/jdcolor.c:285:21: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr;
                    ^
3rdparty/libjpeg/jdcolor.c:286:21: style: The scope of the variable 'inptr0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2;
                    ^
3rdparty/libjpeg/jdcolor.c:286:29: style: The scope of the variable 'inptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2;
                            ^
3rdparty/libjpeg/jdcolor.c:286:37: style: The scope of the variable 'inptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2;
                                    ^
3rdparty/libjpeg/jdcolor.c:323:21: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr;
                    ^
3rdparty/libjpeg/jdcolor.c:324:21: style: The scope of the variable 'inptr0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2;
                    ^
3rdparty/libjpeg/jdcolor.c:324:29: style: The scope of the variable 'inptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2;
                            ^
3rdparty/libjpeg/jdcolor.c:324:37: style: The scope of the variable 'inptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2;
                                    ^
3rdparty/libjpeg/jdcolor.c:363:21: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr;
                    ^
3rdparty/libjpeg/jdcolor.c:364:21: style: The scope of the variable 'inptr0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2;
                    ^
3rdparty/libjpeg/jdcolor.c:364:29: style: The scope of the variable 'inptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2;
                            ^
3rdparty/libjpeg/jdcolor.c:364:37: style: The scope of the variable 'inptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2;
                                    ^
3rdparty/libjpeg/jdcolor.c:402:21: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr;
                    ^
3rdparty/libjpeg/jdcolor.c:514:21: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW outptr;
                    ^
3rdparty/libjpeg/jdcolor.c:515:21: style: The scope of the variable 'inptr0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2, inptr3;
                    ^
3rdparty/libjpeg/jdcolor.c:515:29: style: The scope of the variable 'inptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2, inptr3;
                            ^
3rdparty/libjpeg/jdcolor.c:515:37: style: The scope of the variable 'inptr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr0, inptr1, inptr2, inptr3;
                                    ^
3rdparty/libjpeg/jdcolor.c:139:7: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
      RIGHT_SHIFT(FIX(1.402) * x + ONE_HALF, SCALEBITS);
      ^
3rdparty/libjpeg/jdcolor.c:142:7: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
      RIGHT_SHIFT(FIX(1.772) * x + ONE_HALF, SCALEBITS);
      ^
3rdparty/libjpeg/jdcolor.c:179:7: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
      RIGHT_SHIFT(FIX(2.804) * x + ONE_HALF, SCALEBITS);
      ^
3rdparty/libjpeg/jdcolor.c:182:7: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
      RIGHT_SHIFT(FIX(3.544) * x + ONE_HALF, SCALEBITS);
      ^
3rdparty/libjpeg/jddctmgr.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jddctmgr.c:61:19: style: union member 'multiplier_table::islow_array' is never used. [unusedStructMember]
  ISLOW_MULT_TYPE islow_array[DCTSIZE2];
                  ^
3rdparty/libjpeg/jddctmgr.c:63:19: style: union member 'multiplier_table::ifast_array' is never used. [unusedStructMember]
  IFAST_MULT_TYPE ifast_array[DCTSIZE2];
                  ^
3rdparty/libjpeg/jddctmgr.c:66:19: style: union member 'multiplier_table::float_array' is never used. [unusedStructMember]
  FLOAT_MULT_TYPE float_array[DCTSIZE2];
                  ^
3rdparty/libjpeg/jdhuff.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdhuff.c:993:13: portability: Assigning an integer (int/long/etc) to a pointer is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit integer to 32-bit pointer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t). [AssignmentIntegerToAddress]
   thiscoef = *block + natural_order[k];
            ^
3rdparty/libjpeg/jdhuff.c:1028:11: portability: Assigning an integer (int/long/etc) to a pointer is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit integer to 32-bit pointer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t). [AssignmentIntegerToAddress]
 thiscoef = *block + natural_order[k];
          ^
3rdparty/libjpeg/jdhuff.c:342:35: warning: Either the condition 'tblno>=4' is redundant or the array 'cinfo->dc_huff_tbl_ptrs[4]' is accessed at index 4, which is out of bounds. [arrayIndexOutOfBoundsCond]
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                  ^
3rdparty/libjpeg/jdhuff.c:339:26: note: Assuming that condition 'tblno>=4' is not redundant
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
                         ^
3rdparty/libjpeg/jdhuff.c:342:35: note: Array index out of bounds
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                  ^
3rdparty/libjpeg/jdhuff.c:342:35: warning: Either the condition 'tblno<0' is redundant or the array 'cinfo->dc_huff_tbl_ptrs[4]' is accessed at index -1, which is out of bounds. [negativeIndex]
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                  ^
3rdparty/libjpeg/jdhuff.c:339:13: note: Assuming that condition 'tblno<0' is not redundant
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
            ^
3rdparty/libjpeg/jdhuff.c:342:35: note: Negative array index
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                  ^
3rdparty/libjpeg/jdhuff.c:342:68: warning: Either the condition 'tblno>=4' is redundant or the array 'cinfo->ac_huff_tbl_ptrs[4]' is accessed at index 4, which is out of bounds. [arrayIndexOutOfBoundsCond]
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                                                   ^
3rdparty/libjpeg/jdhuff.c:339:26: note: Assuming that condition 'tblno>=4' is not redundant
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
                         ^
3rdparty/libjpeg/jdhuff.c:342:68: note: Array index out of bounds
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                                                   ^
3rdparty/libjpeg/jdhuff.c:342:68: warning: Either the condition 'tblno<0' is redundant or the array 'cinfo->ac_huff_tbl_ptrs[4]' is accessed at index -1, which is out of bounds. [negativeIndex]
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                                                   ^
3rdparty/libjpeg/jdhuff.c:339:13: note: Assuming that condition 'tblno<0' is not redundant
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
            ^
3rdparty/libjpeg/jdhuff.c:342:68: note: Negative array index
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
                                                                   ^
3rdparty/libjpeg/jdhuff.c:602:3: style: Redundant pointer operation on 'state' - it's already a pointer. [redundantPointerOp]
  CHECK_BIT_BUFFER(*state, l, return -1);
  ^
3rdparty/libjpeg/jdhuff.c:610:5: style: Redundant pointer operation on 'state' - it's already a pointer. [redundantPointerOp]
    CHECK_BIT_BUFFER(*state, 1, return -1);
    ^
3rdparty/libjpeg/jdhuff.c:941:15: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
    m1 = (-1) << cinfo->Al; /* -1 in the bit position being coded */
              ^
3rdparty/libjpeg/jdinput.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdinput.c:507:5: warning: Either the condition 'qtblno>=4' is redundant or the array 'cinfo->quant_tbl_ptrs[4]' is accessed at index 4, which is out of bounds. [arrayIndexOutOfBoundsCond]
    MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
    ^
3rdparty/libjpeg/jdinput.c:500:30: note: Assuming that condition 'qtblno>=4' is not redundant
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
                             ^
3rdparty/libjpeg/jdinput.c:499:21: note: Assignment 'qtblno=compptr->quant_tbl_no', assigned value is 4
    qtblno = compptr->quant_tbl_no;
                    ^
3rdparty/libjpeg/jdinput.c:507:5: note: Array index out of bounds
    MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
    ^
3rdparty/libjpeg/jdinput.c:507:5: warning: Either the condition 'qtblno<0' is redundant or the array 'cinfo->quant_tbl_ptrs[4]' is accessed at index -1, which is out of bounds. [negativeIndex]
    MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
    ^
3rdparty/libjpeg/jdinput.c:500:16: note: Assuming that condition 'qtblno<0' is not redundant
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
               ^
3rdparty/libjpeg/jdinput.c:507:5: note: Negative array index
    MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
    ^
3rdparty/libjpeg/jdinput.c:392:7: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci, mcublks, tmp;
      ^
3rdparty/libjpeg/jdinput.c:392:11: style: The scope of the variable 'mcublks' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci, mcublks, tmp;
          ^
3rdparty/libjpeg/jdinput.c:563:7: style: The scope of the variable 'val' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int val;
      ^
3rdparty/libjpeg/jdmainct.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdmainct.c:164:11: style: The scope of the variable 'rgroup' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci, rgroup;
          ^
3rdparty/libjpeg/jdmainct.c:205:14: style: The scope of the variable 'rgroup' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci, i, rgroup;
             ^
3rdparty/libjpeg/jdmainct.c:245:14: style: The scope of the variable 'rgroup' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci, i, rgroup;
             ^
3rdparty/libjpeg/jdmainct.c:274:14: style: The scope of the variable 'rgroup' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci, i, rgroup, iMCUheight, rows_left;
             ^
3rdparty/libjpeg/jdmainct.c:274:22: style: The scope of the variable 'iMCUheight' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci, i, rgroup, iMCUheight, rows_left;
                     ^
3rdparty/libjpeg/jdmainct.c:274:34: style: The scope of the variable 'rows_left' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci, i, rgroup, iMCUheight, rows_left;
                                 ^
3rdparty/libjpeg/jdmainct.c:480:11: style: The scope of the variable 'rgroup' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci, rgroup, ngroups;
          ^
3rdparty/libjpeg/jdmarker.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdmarker.c:435:24: warning: Either the condition 'index>=(2*16)' is redundant or the array 'cinfo->arith_ac_K[16]' is accessed at index 16, which is out of bounds. [arrayIndexOutOfBoundsCond]
      cinfo->arith_ac_K[index-NUM_ARITH_TBLS] = (UINT8) val;
                       ^
3rdparty/libjpeg/jdmarker.c:431:28: note: Assuming that condition 'index>=(2*16)' is not redundant
    if (index < 0 || index >= (2*NUM_ARITH_TBLS))
                           ^
3rdparty/libjpeg/jdmarker.c:435:24: note: Array index out of bounds
      cinfo->arith_ac_K[index-NUM_ARITH_TBLS] = (UINT8) val;
                       ^
3rdparty/libjpeg/jdmarker.c:437:24: warning: Either the condition 'index<0' is redundant or the array 'cinfo->arith_dc_L[16]' is accessed at index -1, which is out of bounds. [negativeIndex]
      cinfo->arith_dc_L[index] = (UINT8) (val & 0x0F);
                       ^
3rdparty/libjpeg/jdmarker.c:431:15: note: Assuming that condition 'index<0' is not redundant
    if (index < 0 || index >= (2*NUM_ARITH_TBLS))
              ^
3rdparty/libjpeg/jdmarker.c:437:24: note: Negative array index
      cinfo->arith_dc_L[index] = (UINT8) (val & 0x0F);
                       ^
3rdparty/libjpeg/jdmarker.c:438:24: warning: Either the condition 'index<0' is redundant or the array 'cinfo->arith_dc_U[16]' is accessed at index -1, which is out of bounds. [negativeIndex]
      cinfo->arith_dc_U[index] = (UINT8) (val >> 4);
                       ^
3rdparty/libjpeg/jdmarker.c:431:15: note: Assuming that condition 'index<0' is not redundant
    if (index < 0 || index >= (2*NUM_ARITH_TBLS))
              ^
3rdparty/libjpeg/jdmarker.c:438:24: note: Negative array index
      cinfo->arith_dc_U[index] = (UINT8) (val >> 4);
                       ^
3rdparty/libjpeg/jdmarker.c:439:28: warning: Either the condition 'index<0' is redundant or the array 'cinfo->arith_dc_L[16]' is accessed at index -1, which is out of bounds. [negativeIndex]
      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])
                           ^
3rdparty/libjpeg/jdmarker.c:431:15: note: Assuming that condition 'index<0' is not redundant
    if (index < 0 || index >= (2*NUM_ARITH_TBLS))
              ^
3rdparty/libjpeg/jdmarker.c:439:28: note: Negative array index
      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])
                           ^
3rdparty/libjpeg/jdmarker.c:439:55: warning: Either the condition 'index<0' is redundant or the array 'cinfo->arith_dc_U[16]' is accessed at index -1, which is out of bounds. [negativeIndex]
      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])
                                                      ^
3rdparty/libjpeg/jdmarker.c:431:15: note: Assuming that condition 'index<0' is not redundant
    if (index < 0 || index >= (2*NUM_ARITH_TBLS))
              ^
3rdparty/libjpeg/jdmarker.c:439:55: note: Negative array index
      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])
                                                      ^
3rdparty/libjpeg/jdmarker.c:556:30: warning: Either the condition 'n>=4' is redundant or the array 'cinfo->quant_tbl_ptrs[4]' is accessed at index 4, which is out of bounds. [arrayIndexOutOfBoundsCond]
    if (cinfo->quant_tbl_ptrs[n] == NULL)
                             ^
3rdparty/libjpeg/jdmarker.c:553:11: note: Assuming that condition 'n>=4' is not redundant
    if (n >= NUM_QUANT_TBLS)
          ^
3rdparty/libjpeg/jdmarker.c:556:30: note: Array index out of bounds
    if (cinfo->quant_tbl_ptrs[n] == NULL)
                             ^
3rdparty/libjpeg/jdmarker.c:465:17: style: The scope of the variable 'count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i, index, count;
                ^
3rdparty/libjpeg/jdmarker.c:536:10: style: The scope of the variable 'prec' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int n, prec;
         ^
3rdparty/libjpeg/jdmarker.c:804:16: style: The scope of the variable 'version' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  unsigned int version, flags0, flags1, transform;
               ^
3rdparty/libjpeg/jdmarker.c:804:25: style: The scope of the variable 'flags0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  unsigned int version, flags0, flags1, transform;
                        ^
3rdparty/libjpeg/jdmarker.c:804:33: style: The scope of the variable 'flags1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  unsigned int version, flags0, flags1, transform;
                                ^
3rdparty/libjpeg/jdmarker.c:804:41: style: The scope of the variable 'transform' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  unsigned int version, flags0, flags1, transform;
                                        ^
3rdparty/libjpeg/jdmarker.c:272:27: style: The unsigned expression 'cinfo->image_height' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
  if (cinfo->image_height <= 0 || cinfo->image_width <= 0 ||
                          ^
3rdparty/libjpeg/jdmarker.c:272:54: style: The unsigned expression 'cinfo->image_width' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
  if (cinfo->image_height <= 0 || cinfo->image_width <= 0 ||
                                                     ^
3rdparty/libjpeg/jdmarker.c:1346:14: style: Variable 'action' is assigned a value that is never used. [unreadVariable]
  int action = 1;
             ^
3rdparty/libjpeg/jdmarker.c:253:3: error: There is an unknown macro here somewhere. Configuration is required. If MAKESTMT is a macro then please configure it. [unknownMacro]
  INPUT_2BYTES(cinfo, length, return FALSE);
  ^
3rdparty/libjpeg/jdmaster.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdmaster.c:284:28: style: The unsigned expression 'cinfo->output_height' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
  if (cinfo->output_height <= 0 || cinfo->output_width <= 0 ||
                           ^
3rdparty/libjpeg/jdmaster.c:284:56: style: The unsigned expression 'cinfo->output_width' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
  if (cinfo->output_height <= 0 || cinfo->output_width <= 0 ||
                                                       ^
3rdparty/libjpeg/jdmerge.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdmerge.c:194:12: style: The scope of the variable 'work_ptrs' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW work_ptrs[2];
           ^
3rdparty/libjpeg/jdmerge.c:110:7: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
      RIGHT_SHIFT(FIX(1.402) * x + ONE_HALF, SCALEBITS);
      ^
3rdparty/libjpeg/jdmerge.c:113:7: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
      RIGHT_SHIFT(FIX(1.772) * x + ONE_HALF, SCALEBITS);
      ^
3rdparty/libjpeg/jdmerge.c:150:7: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
      RIGHT_SHIFT(FIX(2.804) * x + ONE_HALF, SCALEBITS);
      ^
3rdparty/libjpeg/jdmerge.c:153:7: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
      RIGHT_SHIFT(FIX(3.544) * x + ONE_HALF, SCALEBITS);
      ^
3rdparty/libjpeg/jdpostct.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdpostct.c:165:28: style: The scope of the variable 'num_rows' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JDIMENSION old_next_row, num_rows;
                           ^
3rdparty/libjpeg/jdsample.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jdsample.c:97:7: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int ci;
      ^
3rdparty/libjpeg/jdsample.c:98:25: style: The scope of the variable 'compptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  jpeg_component_info * compptr;
                        ^
3rdparty/libjpeg/jdsample.c:195:21: style: The scope of the variable 'inptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr, outptr;
                    ^
3rdparty/libjpeg/jdsample.c:198:12: style: The scope of the variable 'outend' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outend;
           ^
3rdparty/libjpeg/jdsample.c:238:21: style: The scope of the variable 'inptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr, outptr;
                    ^
3rdparty/libjpeg/jdsample.c:240:12: style: The scope of the variable 'outend' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outend;
           ^
3rdparty/libjpeg/jdsample.c:266:21: style: The scope of the variable 'inptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr, outptr;
                    ^
3rdparty/libjpeg/jdsample.c:268:12: style: The scope of the variable 'outend' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outend;
           ^
3rdparty/libjpeg/jdsample.c:299:7: style: The scope of the variable 'h_in_group' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int h_in_group, v_in_group, h_out_group, v_out_group;
      ^
3rdparty/libjpeg/jdsample.c:299:19: style: The scope of the variable 'v_in_group' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int h_in_group, v_in_group, h_out_group, v_out_group;
                  ^
3rdparty/libjpeg/jdsample.c:299:31: style: The scope of the variable 'h_out_group' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int h_in_group, v_in_group, h_out_group, v_out_group;
                              ^
3rdparty/libjpeg/jdsample.c:299:44: style: The scope of the variable 'v_out_group' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int h_in_group, v_in_group, h_out_group, v_out_group;
                                           ^
3rdparty/libjpeg/jdtrans.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jerror.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jfdctflt.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jfdctflt.c:68:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctfst.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jfdctfst.c:123:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jfdctint.c:164:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:341:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:476:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:590:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:701:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:795:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:951:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:1101:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:1266:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:1449:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:1616:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:1815:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:2017:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:2196:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:2401:33: style: The scope of the variable 'tmp4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
                                ^
3rdparty/libjpeg/jfdctint.c:2401:39: style: The scope of the variable 'tmp5' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
                                      ^
3rdparty/libjpeg/jfdctint.c:2401:45: style: The scope of the variable 'tmp6' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
                                            ^
3rdparty/libjpeg/jfdctint.c:2401:51: style: The scope of the variable 'tmp7' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
                                                  ^
3rdparty/libjpeg/jfdctint.c:2402:37: style: The scope of the variable 'tmp14' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16, tmp17;
                                    ^
3rdparty/libjpeg/jfdctint.c:2402:44: style: The scope of the variable 'tmp15' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16, tmp17;
                                           ^
3rdparty/libjpeg/jfdctint.c:2402:51: style: The scope of the variable 'tmp16' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16, tmp17;
                                                  ^
3rdparty/libjpeg/jfdctint.c:2402:58: style: The scope of the variable 'tmp17' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16, tmp17;
                                                         ^
3rdparty/libjpeg/jfdctint.c:2403:9: style: The scope of the variable 'z1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1;
        ^
3rdparty/libjpeg/jfdctint.c:2405:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:2584:33: style: The scope of the variable 'tmp4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
                                ^
3rdparty/libjpeg/jfdctint.c:2584:39: style: The scope of the variable 'tmp5' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
                                      ^
3rdparty/libjpeg/jfdctint.c:2584:45: style: The scope of the variable 'tmp6' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
                                            ^
3rdparty/libjpeg/jfdctint.c:2585:30: style: The scope of the variable 'tmp13' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                             ^
3rdparty/libjpeg/jfdctint.c:2585:37: style: The scope of the variable 'tmp14' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                                    ^
3rdparty/libjpeg/jfdctint.c:2585:44: style: The scope of the variable 'tmp15' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                                           ^
3rdparty/libjpeg/jfdctint.c:2585:51: style: The scope of the variable 'tmp16' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                                                  ^
3rdparty/libjpeg/jfdctint.c:2586:9: style: The scope of the variable 'z1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
        ^
3rdparty/libjpeg/jfdctint.c:2586:13: style: The scope of the variable 'z2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
            ^
3rdparty/libjpeg/jfdctint.c:2586:17: style: The scope of the variable 'z3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
                ^
3rdparty/libjpeg/jfdctint.c:2588:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:2749:27: style: The scope of the variable 'tmp3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
                          ^
3rdparty/libjpeg/jfdctint.c:2749:33: style: The scope of the variable 'tmp4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
                                ^
3rdparty/libjpeg/jfdctint.c:2749:39: style: The scope of the variable 'tmp5' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
                                      ^
3rdparty/libjpeg/jfdctint.c:2750:30: style: The scope of the variable 'tmp13' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;
                             ^
3rdparty/libjpeg/jfdctint.c:2750:37: style: The scope of the variable 'tmp14' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;
                                    ^
3rdparty/libjpeg/jfdctint.c:2750:44: style: The scope of the variable 'tmp15' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;
                                           ^
3rdparty/libjpeg/jfdctint.c:2752:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:2889:27: style: The scope of the variable 'tmp3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4;
                          ^
3rdparty/libjpeg/jfdctint.c:2889:33: style: The scope of the variable 'tmp4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4;
                                ^
3rdparty/libjpeg/jfdctint.c:2890:23: style: The scope of the variable 'tmp12' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14;
                      ^
3rdparty/libjpeg/jfdctint.c:2890:30: style: The scope of the variable 'tmp13' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14;
                             ^
3rdparty/libjpeg/jfdctint.c:2890:37: style: The scope of the variable 'tmp14' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14;
                                    ^
3rdparty/libjpeg/jfdctint.c:2892:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:3022:21: style: The scope of the variable 'tmp2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3;
                    ^
3rdparty/libjpeg/jfdctint.c:3022:27: style: The scope of the variable 'tmp3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3;
                          ^
3rdparty/libjpeg/jfdctint.c:3023:23: style: The scope of the variable 'tmp12' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13;
                      ^
3rdparty/libjpeg/jfdctint.c:3023:30: style: The scope of the variable 'tmp13' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13;
                             ^
3rdparty/libjpeg/jfdctint.c:3024:9: style: The scope of the variable 'z1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1;
        ^
3rdparty/libjpeg/jfdctint.c:3026:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:3164:9: style: The scope of the variable 'tmp10' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12;
        ^
3rdparty/libjpeg/jfdctint.c:3164:16: style: The scope of the variable 'tmp11' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12;
               ^
3rdparty/libjpeg/jfdctint.c:3164:23: style: The scope of the variable 'tmp12' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12;
                      ^
3rdparty/libjpeg/jfdctint.c:3166:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:3265:9: style: The scope of the variable 'tmp10' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11;
        ^
3rdparty/libjpeg/jfdctint.c:3265:16: style: The scope of the variable 'tmp11' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11;
               ^
3rdparty/libjpeg/jfdctint.c:3267:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:3383:33: style: The scope of the variable 'tmp4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
                                ^
3rdparty/libjpeg/jfdctint.c:3383:39: style: The scope of the variable 'tmp5' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
                                      ^
3rdparty/libjpeg/jfdctint.c:3383:45: style: The scope of the variable 'tmp6' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
                                            ^
3rdparty/libjpeg/jfdctint.c:3383:51: style: The scope of the variable 'tmp7' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
                                                  ^
3rdparty/libjpeg/jfdctint.c:3384:37: style: The scope of the variable 'tmp14' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16, tmp17;
                                    ^
3rdparty/libjpeg/jfdctint.c:3384:44: style: The scope of the variable 'tmp15' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16, tmp17;
                                           ^
3rdparty/libjpeg/jfdctint.c:3384:51: style: The scope of the variable 'tmp16' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16, tmp17;
                                                  ^
3rdparty/libjpeg/jfdctint.c:3384:58: style: The scope of the variable 'tmp17' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16, tmp17;
                                                         ^
3rdparty/libjpeg/jfdctint.c:3385:9: style: The scope of the variable 'z1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1;
        ^
3rdparty/libjpeg/jfdctint.c:3389:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:3577:33: style: The scope of the variable 'tmp4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
                                ^
3rdparty/libjpeg/jfdctint.c:3577:39: style: The scope of the variable 'tmp5' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
                                      ^
3rdparty/libjpeg/jfdctint.c:3577:45: style: The scope of the variable 'tmp6' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
                                            ^
3rdparty/libjpeg/jfdctint.c:3578:30: style: The scope of the variable 'tmp13' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                             ^
3rdparty/libjpeg/jfdctint.c:3578:37: style: The scope of the variable 'tmp14' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                                    ^
3rdparty/libjpeg/jfdctint.c:3578:44: style: The scope of the variable 'tmp15' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                                           ^
3rdparty/libjpeg/jfdctint.c:3578:51: style: The scope of the variable 'tmp16' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                                                  ^
3rdparty/libjpeg/jfdctint.c:3579:9: style: The scope of the variable 'z1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
        ^
3rdparty/libjpeg/jfdctint.c:3579:13: style: The scope of the variable 'z2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
            ^
3rdparty/libjpeg/jfdctint.c:3579:17: style: The scope of the variable 'z3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
                ^
3rdparty/libjpeg/jfdctint.c:3583:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:3759:27: style: The scope of the variable 'tmp3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
                          ^
3rdparty/libjpeg/jfdctint.c:3759:33: style: The scope of the variable 'tmp4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
                                ^
3rdparty/libjpeg/jfdctint.c:3759:39: style: The scope of the variable 'tmp5' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
                                      ^
3rdparty/libjpeg/jfdctint.c:3760:30: style: The scope of the variable 'tmp13' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;
                             ^
3rdparty/libjpeg/jfdctint.c:3760:37: style: The scope of the variable 'tmp14' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;
                                    ^
3rdparty/libjpeg/jfdctint.c:3760:44: style: The scope of the variable 'tmp15' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;
                                           ^
3rdparty/libjpeg/jfdctint.c:3764:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:3909:27: style: The scope of the variable 'tmp3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4;
                          ^
3rdparty/libjpeg/jfdctint.c:3909:33: style: The scope of the variable 'tmp4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4;
                                ^
3rdparty/libjpeg/jfdctint.c:3910:23: style: The scope of the variable 'tmp12' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14;
                      ^
3rdparty/libjpeg/jfdctint.c:3910:30: style: The scope of the variable 'tmp13' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14;
                             ^
3rdparty/libjpeg/jfdctint.c:3910:37: style: The scope of the variable 'tmp14' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14;
                                    ^
3rdparty/libjpeg/jfdctint.c:3914:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:4056:21: style: The scope of the variable 'tmp2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3;
                    ^
3rdparty/libjpeg/jfdctint.c:4056:27: style: The scope of the variable 'tmp3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3;
                          ^
3rdparty/libjpeg/jfdctint.c:4057:23: style: The scope of the variable 'tmp12' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13;
                      ^
3rdparty/libjpeg/jfdctint.c:4057:30: style: The scope of the variable 'tmp13' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13;
                             ^
3rdparty/libjpeg/jfdctint.c:4058:9: style: The scope of the variable 'z1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1;
        ^
3rdparty/libjpeg/jfdctint.c:4060:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:4198:9: style: The scope of the variable 'tmp10' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12;
        ^
3rdparty/libjpeg/jfdctint.c:4198:16: style: The scope of the variable 'tmp11' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12;
               ^
3rdparty/libjpeg/jfdctint.c:4198:23: style: The scope of the variable 'tmp12' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12;
                      ^
3rdparty/libjpeg/jfdctint.c:4200:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:4304:9: style: The scope of the variable 'tmp10' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11;
        ^
3rdparty/libjpeg/jfdctint.c:4304:16: style: The scope of the variable 'tmp11' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11;
               ^
3rdparty/libjpeg/jfdctint.c:4306:12: style: The scope of the variable 'elemptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW elemptr;
           ^
3rdparty/libjpeg/jfdctint.c:948:11: style: Variable 'workspace' is not assigned a value. [unassignedVariable]
  DCTELEM workspace[8];
          ^
3rdparty/libjpeg/jfdctint.c:1098:11: style: Variable 'workspace' is not assigned a value. [unassignedVariable]
  DCTELEM workspace[8*2];
          ^
3rdparty/libjpeg/jfdctint.c:1263:11: style: Variable 'workspace' is not assigned a value. [unassignedVariable]
  DCTELEM workspace[8*3];
          ^
3rdparty/libjpeg/jfdctint.c:1446:11: style: Variable 'workspace' is not assigned a value. [unassignedVariable]
  DCTELEM workspace[8*4];
          ^
3rdparty/libjpeg/jfdctint.c:1613:11: style: Variable 'workspace' is not assigned a value. [unassignedVariable]
  DCTELEM workspace[8*5];
          ^
3rdparty/libjpeg/jfdctint.c:1812:11: style: Variable 'workspace' is not assigned a value. [unassignedVariable]
  DCTELEM workspace[8*6];
          ^
3rdparty/libjpeg/jfdctint.c:2014:11: style: Variable 'workspace' is not assigned a value. [unassignedVariable]
  DCTELEM workspace[8*7];
          ^
3rdparty/libjpeg/jfdctint.c:2193:11: style: Variable 'workspace' is not assigned a value. [unassignedVariable]
  DCTELEM workspace[DCTSIZE2];
          ^
3rdparty/libjpeg/jfdctint.c:3386:11: style: Variable 'workspace' is not assigned a value. [unassignedVariable]
  DCTELEM workspace[DCTSIZE2];
          ^
3rdparty/libjpeg/jfdctint.c:3580:11: style: Variable 'workspace' is not assigned a value. [unassignedVariable]
  DCTELEM workspace[8*6];
          ^
3rdparty/libjpeg/jfdctint.c:3761:11: style: Variable 'workspace' is not assigned a value. [unassignedVariable]
  DCTELEM workspace[8*4];
          ^
3rdparty/libjpeg/jfdctint.c:3911:11: style: Variable 'workspace' is not assigned a value. [unassignedVariable]
  DCTELEM workspace[8*2];
          ^
3rdparty/libjpeg/jidctflt.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jidctflt.c:81:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctfst.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jidctfst.c:154:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jidctint.c:183:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:447:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:598:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:721:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:838:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:944:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:1122:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:1292:25: style: The scope of the variable 'z5' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3, z4, z5;
                        ^
3rdparty/libjpeg/jidctint.c:1296:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:1493:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:1689:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:1907:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:2137:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:2365:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:2609:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:2867:9: style: The scope of the variable 'tmp20' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
        ^
3rdparty/libjpeg/jidctint.c:2867:16: style: The scope of the variable 'tmp21' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
               ^
3rdparty/libjpeg/jidctint.c:2867:23: style: The scope of the variable 'tmp22' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
                      ^
3rdparty/libjpeg/jidctint.c:2867:30: style: The scope of the variable 'tmp23' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
                             ^
3rdparty/libjpeg/jidctint.c:2867:37: style: The scope of the variable 'tmp24' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
                                    ^
3rdparty/libjpeg/jidctint.c:2867:44: style: The scope of the variable 'tmp25' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
                                           ^
3rdparty/libjpeg/jidctint.c:2867:51: style: The scope of the variable 'tmp26' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
                                                  ^
3rdparty/libjpeg/jidctint.c:2867:58: style: The scope of the variable 'tmp27' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
                                                         ^
3rdparty/libjpeg/jidctint.c:2868:21: style: The scope of the variable 'z4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3, z4;
                    ^
3rdparty/libjpeg/jidctint.c:2872:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:3143:30: style: The scope of the variable 'tmp13' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                             ^
3rdparty/libjpeg/jidctint.c:3143:37: style: The scope of the variable 'tmp14' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                                    ^
3rdparty/libjpeg/jidctint.c:3143:44: style: The scope of the variable 'tmp15' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                                           ^
3rdparty/libjpeg/jidctint.c:3143:51: style: The scope of the variable 'tmp16' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                                                  ^
3rdparty/libjpeg/jidctint.c:3144:37: style: The scope of the variable 'tmp24' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;
                                    ^
3rdparty/libjpeg/jidctint.c:3144:44: style: The scope of the variable 'tmp25' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;
                                           ^
3rdparty/libjpeg/jidctint.c:3144:51: style: The scope of the variable 'tmp26' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;
                                                  ^
3rdparty/libjpeg/jidctint.c:3145:21: style: The scope of the variable 'z4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3, z4;
                    ^
3rdparty/libjpeg/jidctint.c:3149:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:3342:30: style: The scope of the variable 'tmp13' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;
                             ^
3rdparty/libjpeg/jidctint.c:3342:37: style: The scope of the variable 'tmp14' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;
                                    ^
3rdparty/libjpeg/jidctint.c:3342:44: style: The scope of the variable 'tmp15' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;
                                           ^
3rdparty/libjpeg/jidctint.c:3343:30: style: The scope of the variable 'tmp23' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;
                             ^
3rdparty/libjpeg/jidctint.c:3343:37: style: The scope of the variable 'tmp24' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;
                                    ^
3rdparty/libjpeg/jidctint.c:3343:44: style: The scope of the variable 'tmp25' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;
                                           ^
3rdparty/libjpeg/jidctint.c:3344:21: style: The scope of the variable 'z4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3, z4;
                    ^
3rdparty/libjpeg/jidctint.c:3348:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:3523:9: style: The scope of the variable 'tmp20' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24;
        ^
3rdparty/libjpeg/jidctint.c:3523:16: style: The scope of the variable 'tmp21' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24;
               ^
3rdparty/libjpeg/jidctint.c:3523:23: style: The scope of the variable 'tmp22' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24;
                      ^
3rdparty/libjpeg/jidctint.c:3523:30: style: The scope of the variable 'tmp23' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24;
                             ^
3rdparty/libjpeg/jidctint.c:3523:37: style: The scope of the variable 'tmp24' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24;
                                    ^
3rdparty/libjpeg/jidctint.c:3524:21: style: The scope of the variable 'z4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3, z4;
                    ^
3rdparty/libjpeg/jidctint.c:3528:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:3687:15: style: The scope of the variable 'tmp1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3;
              ^
3rdparty/libjpeg/jidctint.c:3687:27: style: The scope of the variable 'tmp3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp3;
                          ^
3rdparty/libjpeg/jidctint.c:3688:16: style: The scope of the variable 'tmp11' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13;
               ^
3rdparty/libjpeg/jidctint.c:3688:30: style: The scope of the variable 'tmp13' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13;
                             ^
3rdparty/libjpeg/jidctint.c:3693:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:3847:15: style: The scope of the variable 'tmp1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp10, tmp11, tmp12;
              ^
3rdparty/libjpeg/jidctint.c:3847:34: style: The scope of the variable 'tmp11' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp10, tmp11, tmp12;
                                 ^
3rdparty/libjpeg/jidctint.c:3848:9: style: The scope of the variable 'z1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
        ^
3rdparty/libjpeg/jidctint.c:3848:13: style: The scope of the variable 'z2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
            ^
3rdparty/libjpeg/jidctint.c:3848:17: style: The scope of the variable 'z3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
                ^
3rdparty/libjpeg/jidctint.c:3852:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:3961:15: style: The scope of the variable 'tmp2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp2, tmp10, tmp12;
              ^
3rdparty/libjpeg/jidctint.c:3961:28: style: The scope of the variable 'tmp12' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp2, tmp10, tmp12;
                           ^
3rdparty/libjpeg/jidctint.c:3962:9: style: The scope of the variable 'z1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
        ^
3rdparty/libjpeg/jidctint.c:3962:13: style: The scope of the variable 'z2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
            ^
3rdparty/libjpeg/jidctint.c:3962:17: style: The scope of the variable 'z3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
                ^
3rdparty/libjpeg/jidctint.c:3966:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:4095:9: style: The scope of the variable 'tmp20' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
        ^
3rdparty/libjpeg/jidctint.c:4095:16: style: The scope of the variable 'tmp21' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
               ^
3rdparty/libjpeg/jidctint.c:4095:23: style: The scope of the variable 'tmp22' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
                      ^
3rdparty/libjpeg/jidctint.c:4095:30: style: The scope of the variable 'tmp23' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
                             ^
3rdparty/libjpeg/jidctint.c:4095:37: style: The scope of the variable 'tmp24' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
                                    ^
3rdparty/libjpeg/jidctint.c:4095:44: style: The scope of the variable 'tmp25' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
                                           ^
3rdparty/libjpeg/jidctint.c:4095:51: style: The scope of the variable 'tmp26' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
                                                  ^
3rdparty/libjpeg/jidctint.c:4095:58: style: The scope of the variable 'tmp27' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;
                                                         ^
3rdparty/libjpeg/jidctint.c:4096:21: style: The scope of the variable 'z4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3, z4;
                    ^
3rdparty/libjpeg/jidctint.c:4100:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:4318:30: style: The scope of the variable 'tmp13' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                             ^
3rdparty/libjpeg/jidctint.c:4318:37: style: The scope of the variable 'tmp14' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                                    ^
3rdparty/libjpeg/jidctint.c:4318:44: style: The scope of the variable 'tmp15' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                                           ^
3rdparty/libjpeg/jidctint.c:4318:51: style: The scope of the variable 'tmp16' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;
                                                  ^
3rdparty/libjpeg/jidctint.c:4319:37: style: The scope of the variable 'tmp24' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;
                                    ^
3rdparty/libjpeg/jidctint.c:4319:44: style: The scope of the variable 'tmp25' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;
                                           ^
3rdparty/libjpeg/jidctint.c:4319:51: style: The scope of the variable 'tmp26' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;
                                                  ^
3rdparty/libjpeg/jidctint.c:4320:21: style: The scope of the variable 'z4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3, z4;
                    ^
3rdparty/libjpeg/jidctint.c:4324:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:4505:30: style: The scope of the variable 'tmp13' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;
                             ^
3rdparty/libjpeg/jidctint.c:4505:37: style: The scope of the variable 'tmp14' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;
                                    ^
3rdparty/libjpeg/jidctint.c:4505:44: style: The scope of the variable 'tmp15' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;
                                           ^
3rdparty/libjpeg/jidctint.c:4506:30: style: The scope of the variable 'tmp23' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;
                             ^
3rdparty/libjpeg/jidctint.c:4506:37: style: The scope of the variable 'tmp24' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;
                                    ^
3rdparty/libjpeg/jidctint.c:4506:44: style: The scope of the variable 'tmp25' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;
                                           ^
3rdparty/libjpeg/jidctint.c:4507:21: style: The scope of the variable 'z4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3, z4;
                    ^
3rdparty/libjpeg/jidctint.c:4511:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:4674:9: style: The scope of the variable 'tmp20' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24;
        ^
3rdparty/libjpeg/jidctint.c:4674:16: style: The scope of the variable 'tmp21' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24;
               ^
3rdparty/libjpeg/jidctint.c:4674:23: style: The scope of the variable 'tmp22' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24;
                      ^
3rdparty/libjpeg/jidctint.c:4674:30: style: The scope of the variable 'tmp23' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24;
                             ^
3rdparty/libjpeg/jidctint.c:4674:37: style: The scope of the variable 'tmp24' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp20, tmp21, tmp22, tmp23, tmp24;
                                    ^
3rdparty/libjpeg/jidctint.c:4675:21: style: The scope of the variable 'z4' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3, z4, z5;
                    ^
3rdparty/libjpeg/jidctint.c:4675:25: style: The scope of the variable 'z5' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3, z4, z5;
                        ^
3rdparty/libjpeg/jidctint.c:4679:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:4835:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:5016:15: style: The scope of the variable 'tmp1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp10, tmp11, tmp12;
              ^
3rdparty/libjpeg/jidctint.c:5016:34: style: The scope of the variable 'tmp11' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp1, tmp2, tmp10, tmp11, tmp12;
                                 ^
3rdparty/libjpeg/jidctint.c:5017:9: style: The scope of the variable 'z1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
        ^
3rdparty/libjpeg/jidctint.c:5017:13: style: The scope of the variable 'z2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
            ^
3rdparty/libjpeg/jidctint.c:5017:17: style: The scope of the variable 'z3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
                ^
3rdparty/libjpeg/jidctint.c:5021:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jidctint.c:5124:15: style: The scope of the variable 'tmp2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp2, tmp10, tmp12;
              ^
3rdparty/libjpeg/jidctint.c:5124:28: style: The scope of the variable 'tmp12' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 tmp0, tmp2, tmp10, tmp12;
                           ^
3rdparty/libjpeg/jidctint.c:5125:9: style: The scope of the variable 'z1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
        ^
3rdparty/libjpeg/jidctint.c:5125:13: style: The scope of the variable 'z2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
            ^
3rdparty/libjpeg/jidctint.c:5125:17: style: The scope of the variable 'z3' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 z1, z2, z3;
                ^
3rdparty/libjpeg/jidctint.c:5129:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;
           ^
3rdparty/libjpeg/jmemansi.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jmemmgr.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jmemmgr.c:279:28: warning: Either the condition 'pool_id>=2' is redundant or the array 'mem->small_list[2]' is accessed at index 2, which is out of bounds. [arrayIndexOutOfBoundsCond]
  hdr_ptr = mem->small_list[pool_id];
                           ^
3rdparty/libjpeg/jmemmgr.c:276:30: note: Assuming that condition 'pool_id>=2' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
                             ^
3rdparty/libjpeg/jmemmgr.c:279:28: note: Array index out of bounds
  hdr_ptr = mem->small_list[pool_id];
                           ^
3rdparty/libjpeg/jmemmgr.c:279:28: warning: Either the condition 'pool_id<0' is redundant or the array 'mem->small_list[2]' is accessed at index -1, which is out of bounds. [negativeIndex]
  hdr_ptr = mem->small_list[pool_id];
                           ^
3rdparty/libjpeg/jmemmgr.c:276:15: note: Assuming that condition 'pool_id<0' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
              ^
3rdparty/libjpeg/jmemmgr.c:279:28: note: Negative array index
  hdr_ptr = mem->small_list[pool_id];
                           ^
3rdparty/libjpeg/jmemmgr.c:370:38: warning: Either the condition 'pool_id>=2' is redundant or the array 'mem->large_list[2]' is accessed at index 2, which is out of bounds. [arrayIndexOutOfBoundsCond]
  hdr_ptr->hdr.next = mem->large_list[pool_id];
                                     ^
3rdparty/libjpeg/jmemmgr.c:360:30: note: Assuming that condition 'pool_id>=2' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
                             ^
3rdparty/libjpeg/jmemmgr.c:370:38: note: Array index out of bounds
  hdr_ptr->hdr.next = mem->large_list[pool_id];
                                     ^
3rdparty/libjpeg/jmemmgr.c:370:38: warning: Either the condition 'pool_id<0' is redundant or the array 'mem->large_list[2]' is accessed at index -1, which is out of bounds. [negativeIndex]
  hdr_ptr->hdr.next = mem->large_list[pool_id];
                                     ^
3rdparty/libjpeg/jmemmgr.c:360:15: note: Assuming that condition 'pool_id<0' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
              ^
3rdparty/libjpeg/jmemmgr.c:370:38: note: Negative array index
  hdr_ptr->hdr.next = mem->large_list[pool_id];
                                     ^
3rdparty/libjpeg/jmemmgr.c:376:18: warning: Either the condition 'pool_id>=2' is redundant or the array 'mem->large_list[2]' is accessed at index 2, which is out of bounds. [arrayIndexOutOfBoundsCond]
  mem->large_list[pool_id] = hdr_ptr;
                 ^
3rdparty/libjpeg/jmemmgr.c:360:30: note: Assuming that condition 'pool_id>=2' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
                             ^
3rdparty/libjpeg/jmemmgr.c:376:18: note: Array index out of bounds
  mem->large_list[pool_id] = hdr_ptr;
                 ^
3rdparty/libjpeg/jmemmgr.c:376:18: warning: Either the condition 'pool_id<0' is redundant or the array 'mem->large_list[2]' is accessed at index -1, which is out of bounds. [negativeIndex]
  mem->large_list[pool_id] = hdr_ptr;
                 ^
3rdparty/libjpeg/jmemmgr.c:360:15: note: Assuming that condition 'pool_id<0' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
              ^
3rdparty/libjpeg/jmemmgr.c:376:18: note: Negative array index
  mem->large_list[pool_id] = hdr_ptr;
                 ^
3rdparty/libjpeg/jmemmgr.c:968:29: warning: Either the condition 'pool_id>=2' is redundant or the array 'mem->large_list[2]' is accessed at index 2, which is out of bounds. [arrayIndexOutOfBoundsCond]
  lhdr_ptr = mem->large_list[pool_id];
                            ^
3rdparty/libjpeg/jmemmgr.c:938:30: note: Assuming that condition 'pool_id>=2' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
                             ^
3rdparty/libjpeg/jmemmgr.c:968:29: note: Array index out of bounds
  lhdr_ptr = mem->large_list[pool_id];
                            ^
3rdparty/libjpeg/jmemmgr.c:968:29: warning: Either the condition 'pool_id<0' is redundant or the array 'mem->large_list[2]' is accessed at index -1, which is out of bounds. [negativeIndex]
  lhdr_ptr = mem->large_list[pool_id];
                            ^
3rdparty/libjpeg/jmemmgr.c:938:15: note: Assuming that condition 'pool_id<0' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
              ^
3rdparty/libjpeg/jmemmgr.c:968:29: note: Negative array index
  lhdr_ptr = mem->large_list[pool_id];
                            ^
3rdparty/libjpeg/jmemmgr.c:969:18: warning: Either the condition 'pool_id>=2' is redundant or the array 'mem->large_list[2]' is accessed at index 2, which is out of bounds. [arrayIndexOutOfBoundsCond]
  mem->large_list[pool_id] = NULL;
                 ^
3rdparty/libjpeg/jmemmgr.c:938:30: note: Assuming that condition 'pool_id>=2' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
                             ^
3rdparty/libjpeg/jmemmgr.c:969:18: note: Array index out of bounds
  mem->large_list[pool_id] = NULL;
                 ^
3rdparty/libjpeg/jmemmgr.c:969:18: warning: Either the condition 'pool_id<0' is redundant or the array 'mem->large_list[2]' is accessed at index -1, which is out of bounds. [negativeIndex]
  mem->large_list[pool_id] = NULL;
                 ^
3rdparty/libjpeg/jmemmgr.c:938:15: note: Assuming that condition 'pool_id<0' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
              ^
3rdparty/libjpeg/jmemmgr.c:969:18: note: Negative array index
  mem->large_list[pool_id] = NULL;
                 ^
3rdparty/libjpeg/jmemmgr.c:982:29: warning: Either the condition 'pool_id>=2' is redundant or the array 'mem->small_list[2]' is accessed at index 2, which is out of bounds. [arrayIndexOutOfBoundsCond]
  shdr_ptr = mem->small_list[pool_id];
                            ^
3rdparty/libjpeg/jmemmgr.c:938:30: note: Assuming that condition 'pool_id>=2' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
                             ^
3rdparty/libjpeg/jmemmgr.c:982:29: note: Array index out of bounds
  shdr_ptr = mem->small_list[pool_id];
                            ^
3rdparty/libjpeg/jmemmgr.c:982:29: warning: Either the condition 'pool_id<0' is redundant or the array 'mem->small_list[2]' is accessed at index -1, which is out of bounds. [negativeIndex]
  shdr_ptr = mem->small_list[pool_id];
                            ^
3rdparty/libjpeg/jmemmgr.c:938:15: note: Assuming that condition 'pool_id<0' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
              ^
3rdparty/libjpeg/jmemmgr.c:982:29: note: Negative array index
  shdr_ptr = mem->small_list[pool_id];
                            ^
3rdparty/libjpeg/jmemmgr.c:983:18: warning: Either the condition 'pool_id>=2' is redundant or the array 'mem->small_list[2]' is accessed at index 2, which is out of bounds. [arrayIndexOutOfBoundsCond]
  mem->small_list[pool_id] = NULL;
                 ^
3rdparty/libjpeg/jmemmgr.c:938:30: note: Assuming that condition 'pool_id>=2' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
                             ^
3rdparty/libjpeg/jmemmgr.c:983:18: note: Array index out of bounds
  mem->small_list[pool_id] = NULL;
                 ^
3rdparty/libjpeg/jmemmgr.c:983:18: warning: Either the condition 'pool_id<0' is redundant or the array 'mem->small_list[2]' is accessed at index -1, which is out of bounds. [negativeIndex]
  mem->small_list[pool_id] = NULL;
                 ^
3rdparty/libjpeg/jmemmgr.c:938:15: note: Assuming that condition 'pool_id<0' is not redundant
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
              ^
3rdparty/libjpeg/jmemmgr.c:983:18: note: Negative array index
  mem->small_list[pool_id] = NULL;
                 ^
3rdparty/libjpeg/jmemmgr.c:309:5: warning: Either the condition 'hdr_ptr!=NULL' is redundant or there is possible null pointer dereference: hdr_ptr. [nullPointerRedundantCheck]
    hdr_ptr->hdr.next = NULL;
    ^
3rdparty/libjpeg/jmemmgr.c:301:19: note: Assuming that condition 'hdr_ptr!=NULL' is not redundant
      if (hdr_ptr != NULL)
                  ^
3rdparty/libjpeg/jmemmgr.c:300:17: note: Assignment 'hdr_ptr=(union small_pool_struct*)jpeg_get_small(cinfo,min_request+slop)', assigned value is 0
      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
                ^
3rdparty/libjpeg/jmemmgr.c:309:5: note: Null pointer dereference
    hdr_ptr->hdr.next = NULL;
    ^
3rdparty/libjpeg/jmemmgr.c:310:5: warning: Either the condition 'hdr_ptr!=NULL' is redundant or there is possible null pointer dereference: hdr_ptr. [nullPointerRedundantCheck]
    hdr_ptr->hdr.bytes_used = 0;
    ^
3rdparty/libjpeg/jmemmgr.c:301:19: note: Assuming that condition 'hdr_ptr!=NULL' is not redundant
      if (hdr_ptr != NULL)
                  ^
3rdparty/libjpeg/jmemmgr.c:300:17: note: Assignment 'hdr_ptr=(union small_pool_struct*)jpeg_get_small(cinfo,min_request+slop)', assigned value is 0
      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
                ^
3rdparty/libjpeg/jmemmgr.c:310:5: note: Null pointer dereference
    hdr_ptr->hdr.bytes_used = 0;
    ^
3rdparty/libjpeg/jmemmgr.c:311:5: warning: Either the condition 'hdr_ptr!=NULL' is redundant or there is possible null pointer dereference: hdr_ptr. [nullPointerRedundantCheck]
    hdr_ptr->hdr.bytes_left = sizeofobject + slop;
    ^
3rdparty/libjpeg/jmemmgr.c:301:19: note: Assuming that condition 'hdr_ptr!=NULL' is not redundant
      if (hdr_ptr != NULL)
                  ^
3rdparty/libjpeg/jmemmgr.c:300:17: note: Assignment 'hdr_ptr=(union small_pool_struct*)jpeg_get_small(cinfo,min_request+slop)', assigned value is 0
      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
                ^
3rdparty/libjpeg/jmemmgr.c:311:5: note: Null pointer dereference
    hdr_ptr->hdr.bytes_left = sizeofobject + slop;
    ^
3rdparty/libjpeg/jmemmgr.c:1068:3: warning: Either the condition 'mem==NULL' is redundant or there is possible null pointer dereference: mem. [nullPointerRedundantCheck]
  mem->pub.alloc_small = alloc_small;
  ^
3rdparty/libjpeg/jmemmgr.c:1062:11: note: Assuming that condition 'mem==NULL' is not redundant
  if (mem == NULL) {
          ^
3rdparty/libjpeg/jmemmgr.c:1060:9: note: Assignment 'mem=(struct my_memory_mgr*)jpeg_get_small(cinfo,(unsigned long)sizeof(struct my_memory_mgr))', assigned value is 0
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
        ^
3rdparty/libjpeg/jmemmgr.c:1068:3: note: Null pointer dereference
  mem->pub.alloc_small = alloc_small;
  ^
3rdparty/libjpeg/jmemmgr.c:1069:3: warning: Either the condition 'mem==NULL' is redundant or there is possible null pointer dereference: mem. [nullPointerRedundantCheck]
  mem->pub.alloc_large = alloc_large;
  ^
3rdparty/libjpeg/jmemmgr.c:1062:11: note: Assuming that condition 'mem==NULL' is not redundant
  if (mem == NULL) {
          ^
3rdparty/libjpeg/jmemmgr.c:1060:9: note: Assignment 'mem=(struct my_memory_mgr*)jpeg_get_small(cinfo,(unsigned long)sizeof(struct my_memory_mgr))', assigned value is 0
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
        ^
3rdparty/libjpeg/jmemmgr.c:1069:3: note: Null pointer dereference
  mem->pub.alloc_large = alloc_large;
  ^
3rdparty/libjpeg/jmemmgr.c:1070:3: warning: Either the condition 'mem==NULL' is redundant or there is possible null pointer dereference: mem. [nullPointerRedundantCheck]
  mem->pub.alloc_sarray = alloc_sarray;
  ^
3rdparty/libjpeg/jmemmgr.c:1062:11: note: Assuming that condition 'mem==NULL' is not redundant
  if (mem == NULL) {
          ^
3rdparty/libjpeg/jmemmgr.c:1060:9: note: Assignment 'mem=(struct my_memory_mgr*)jpeg_get_small(cinfo,(unsigned long)sizeof(struct my_memory_mgr))', assigned value is 0
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
        ^
3rdparty/libjpeg/jmemmgr.c:1070:3: note: Null pointer dereference
  mem->pub.alloc_sarray = alloc_sarray;
  ^
3rdparty/libjpeg/jmemmgr.c:1071:3: warning: Either the condition 'mem==NULL' is redundant or there is possible null pointer dereference: mem. [nullPointerRedundantCheck]
  mem->pub.alloc_barray = alloc_barray;
  ^
3rdparty/libjpeg/jmemmgr.c:1062:11: note: Assuming that condition 'mem==NULL' is not redundant
  if (mem == NULL) {
          ^
3rdparty/libjpeg/jmemmgr.c:1060:9: note: Assignment 'mem=(struct my_memory_mgr*)jpeg_get_small(cinfo,(unsigned long)sizeof(struct my_memory_mgr))', assigned value is 0
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
        ^
3rdparty/libjpeg/jmemmgr.c:1071:3: note: Null pointer dereference
  mem->pub.alloc_barray = alloc_barray;
  ^
3rdparty/libjpeg/jmemmgr.c:1072:3: warning: Either the condition 'mem==NULL' is redundant or there is possible null pointer dereference: mem. [nullPointerRedundantCheck]
  mem->pub.request_virt_sarray = request_virt_sarray;
  ^
3rdparty/libjpeg/jmemmgr.c:1062:11: note: Assuming that condition 'mem==NULL' is not redundant
  if (mem == NULL) {
          ^
3rdparty/libjpeg/jmemmgr.c:1060:9: note: Assignment 'mem=(struct my_memory_mgr*)jpeg_get_small(cinfo,(unsigned long)sizeof(struct my_memory_mgr))', assigned value is 0
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
        ^
3rdparty/libjpeg/jmemmgr.c:1072:3: note: Null pointer dereference
  mem->pub.request_virt_sarray = request_virt_sarray;
  ^
3rdparty/libjpeg/jmemmgr.c:1073:3: warning: Either the condition 'mem==NULL' is redundant or there is possible null pointer dereference: mem. [nullPointerRedundantCheck]
  mem->pub.request_virt_barray = request_virt_barray;
  ^
3rdparty/libjpeg/jmemmgr.c:1062:11: note: Assuming that condition 'mem==NULL' is not redundant
  if (mem == NULL) {
          ^
3rdparty/libjpeg/jmemmgr.c:1060:9: note: Assignment 'mem=(struct my_memory_mgr*)jpeg_get_small(cinfo,(unsigned long)sizeof(struct my_memory_mgr))', assigned value is 0
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
        ^
3rdparty/libjpeg/jmemmgr.c:1073:3: note: Null pointer dereference
  mem->pub.request_virt_barray = request_virt_barray;
  ^
3rdparty/libjpeg/jmemmgr.c:1074:3: warning: Either the condition 'mem==NULL' is redundant or there is possible null pointer dereference: mem. [nullPointerRedundantCheck]
  mem->pub.realize_virt_arrays = realize_virt_arrays;
  ^
3rdparty/libjpeg/jmemmgr.c:1062:11: note: Assuming that condition 'mem==NULL' is not redundant
  if (mem == NULL) {
          ^
3rdparty/libjpeg/jmemmgr.c:1060:9: note: Assignment 'mem=(struct my_memory_mgr*)jpeg_get_small(cinfo,(unsigned long)sizeof(struct my_memory_mgr))', assigned value is 0
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
        ^
3rdparty/libjpeg/jmemmgr.c:1074:3: note: Null pointer dereference
  mem->pub.realize_virt_arrays = realize_virt_arrays;
  ^
3rdparty/libjpeg/jmemmgr.c:1075:3: warning: Either the condition 'mem==NULL' is redundant or there is possible null pointer dereference: mem. [nullPointerRedundantCheck]
  mem->pub.access_virt_sarray = access_virt_sarray;
  ^
3rdparty/libjpeg/jmemmgr.c:1062:11: note: Assuming that condition 'mem==NULL' is not redundant
  if (mem == NULL) {
          ^
3rdparty/libjpeg/jmemmgr.c:1060:9: note: Assignment 'mem=(struct my_memory_mgr*)jpeg_get_small(cinfo,(unsigned long)sizeof(struct my_memory_mgr))', assigned value is 0
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
        ^
3rdparty/libjpeg/jmemmgr.c:1075:3: note: Null pointer dereference
  mem->pub.access_virt_sarray = access_virt_sarray;
  ^
3rdparty/libjpeg/jmemmgr.c:1076:3: warning: Either the condition 'mem==NULL' is redundant or there is possible null pointer dereference: mem. [nullPointerRedundantCheck]
  mem->pub.access_virt_barray = access_virt_barray;
  ^
3rdparty/libjpeg/jmemmgr.c:1062:11: note: Assuming that condition 'mem==NULL' is not redundant
  if (mem == NULL) {
          ^
3rdparty/libjpeg/jmemmgr.c:1060:9: note: Assignment 'mem=(struct my_memory_mgr*)jpeg_get_small(cinfo,(unsigned long)sizeof(struct my_memory_mgr))', assigned value is 0
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
        ^
3rdparty/libjpeg/jmemmgr.c:1076:3: note: Null pointer dereference
  mem->pub.access_virt_barray = access_virt_barray;
  ^
3rdparty/libjpeg/jmemmgr.c:1077:3: warning: Either the condition 'mem==NULL' is redundant or there is possible null pointer dereference: mem. [nullPointerRedundantCheck]
  mem->pub.free_pool = free_pool;
  ^
3rdparty/libjpeg/jmemmgr.c:1062:11: note: Assuming that condition 'mem==NULL' is not redundant
  if (mem == NULL) {
          ^
3rdparty/libjpeg/jmemmgr.c:1060:9: note: Assignment 'mem=(struct my_memory_mgr*)jpeg_get_small(cinfo,(unsigned long)sizeof(struct my_memory_mgr))', assigned value is 0
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
        ^
3rdparty/libjpeg/jmemmgr.c:1077:3: note: Null pointer dereference
  mem->pub.free_pool = free_pool;
  ^
3rdparty/libjpeg/jmemmgr.c:1078:3: warning: Either the condition 'mem==NULL' is redundant or there is possible null pointer dereference: mem. [nullPointerRedundantCheck]
  mem->pub.self_destruct = self_destruct;
  ^
3rdparty/libjpeg/jmemmgr.c:1062:11: note: Assuming that condition 'mem==NULL' is not redundant
  if (mem == NULL) {
          ^
3rdparty/libjpeg/jmemmgr.c:1060:9: note: Assignment 'mem=(struct my_memory_mgr*)jpeg_get_small(cinfo,(unsigned long)sizeof(struct my_memory_mgr))', assigned value is 0
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
        ^
3rdparty/libjpeg/jmemmgr.c:1078:3: note: Null pointer dereference
  mem->pub.self_destruct = self_destruct;
  ^
3rdparty/libjpeg/jmemmgr.c:1081:3: warning: Either the condition 'mem==NULL' is redundant or there is possible null pointer dereference: mem. [nullPointerRedundantCheck]
  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
  ^
3rdparty/libjpeg/jmemmgr.c:1062:11: note: Assuming that condition 'mem==NULL' is not redundant
  if (mem == NULL) {
          ^
3rdparty/libjpeg/jmemmgr.c:1060:9: note: Assignment 'mem=(struct my_memory_mgr*)jpeg_get_small(cinfo,(unsigned long)sizeof(struct my_memory_mgr))', assigned value is 0
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
        ^
3rdparty/libjpeg/jmemmgr.c:1081:3: note: Null pointer dereference
  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
  ^
3rdparty/libjpeg/jmemmgr.c:1084:3: warning: Either the condition 'mem==NULL' is redundant or there is possible null pointer dereference: mem. [nullPointerRedundantCheck]
  mem->pub.max_memory_to_use = max_to_use;
  ^
3rdparty/libjpeg/jmemmgr.c:1062:11: note: Assuming that condition 'mem==NULL' is not redundant
  if (mem == NULL) {
          ^
3rdparty/libjpeg/jmemmgr.c:1060:9: note: Assignment 'mem=(struct my_memory_mgr*)jpeg_get_small(cinfo,(unsigned long)sizeof(struct my_memory_mgr))', assigned value is 0
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
        ^
3rdparty/libjpeg/jmemmgr.c:1084:3: note: Null pointer dereference
  mem->pub.max_memory_to_use = max_to_use;
  ^
3rdparty/libjpeg/jmemmgr.c:264:21: style: The scope of the variable 'min_request' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  size_t odd_bytes, min_request, slop;
                    ^
3rdparty/libjpeg/jmemmgr.c:264:34: style: The scope of the variable 'slop' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  size_t odd_bytes, min_request, slop;
                                 ^
3rdparty/libjpeg/jmemmgr.c:694:34: style: The scope of the variable 'byte_count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;
                                 ^
3rdparty/libjpeg/jmemmgr.c:694:46: style: The scope of the variable 'rows' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;
                                             ^
3rdparty/libjpeg/jmemmgr.c:694:52: style: The scope of the variable 'thisrow' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;
                                                   ^
3rdparty/libjpeg/jmemmgr.c:727:34: style: The scope of the variable 'byte_count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;
                                 ^
3rdparty/libjpeg/jmemmgr.c:727:46: style: The scope of the variable 'rows' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;
                                             ^
3rdparty/libjpeg/jmemmgr.c:727:52: style: The scope of the variable 'thisrow' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;
                                                   ^
3rdparty/libjpeg/jmemmgr.c:765:14: style: The scope of the variable 'undef_row' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JDIMENSION undef_row;
             ^
3rdparty/libjpeg/jmemmgr.c:850:14: style: The scope of the variable 'undef_row' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JDIMENSION undef_row;
             ^
3rdparty/libjpeg/jmemnobs.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jquant1.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jquant1.c:444:10: portability: Assigning an integer (int/long/etc) to a pointer is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit integer to 32-bit pointer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t). [AssignmentIntegerToAddress]
 odither = cquantize->odither[j];
         ^
3rdparty/libjpeg/jquant1.c:450:27: portability: Assigning a pointer to an integer (int/long/etc) is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit address to 32-bit integer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t). [AssignmentAddressToInteger]
    cquantize->odither[i] = odither;
                          ^
3rdparty/libjpeg/jquant1.c:279:14: style: The scope of the variable 'nci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i,j,k, nci, blksize, blkdist, ptr, val;
             ^
3rdparty/libjpeg/jquant1.c:279:19: style: The scope of the variable 'blksize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i,j,k, nci, blksize, blkdist, ptr, val;
                  ^
3rdparty/libjpeg/jquant1.c:338:11: style: The scope of the variable 'k' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i,j,k, nci, blksize, val, pad;
          ^
3rdparty/libjpeg/jquant1.c:338:14: style: The scope of the variable 'nci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i,j,k, nci, blksize, val, pad;
             ^
3rdparty/libjpeg/jquant1.c:338:28: style: The scope of the variable 'val' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i,j,k, nci, blksize, val, pad;
                           ^
3rdparty/libjpeg/jquant1.c:437:13: style: The scope of the variable 'nci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i, j, nci;
            ^
3rdparty/libjpeg/jquant1.c:467:21: style: The scope of the variable 'ptrin' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW ptrin, ptrout;
                    ^
3rdparty/libjpeg/jquant1.c:467:28: style: The scope of the variable 'ptrout' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW ptrin, ptrout;
                           ^
3rdparty/libjpeg/jquant1.c:494:21: style: The scope of the variable 'ptrin' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW ptrin, ptrout;
                    ^
3rdparty/libjpeg/jquant1.c:494:28: style: The scope of the variable 'ptrout' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW ptrin, ptrout;
                           ^
3rdparty/libjpeg/jquant1.c:525:7: style: The scope of the variable 'row_index' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int row_index, col_index; /* current indexes into dither matrix */
      ^
3rdparty/libjpeg/jquant1.c:572:21: style: The scope of the variable 'input_ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW input_ptr;
                    ^
3rdparty/libjpeg/jquant1.c:573:21: style: The scope of the variable 'output_ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW output_ptr;
                    ^
3rdparty/libjpeg/jquant1.c:577:9: style: The scope of the variable 'dither0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int * dither0;  /* points to active row of dither matrix */
        ^
3rdparty/libjpeg/jquant1.c:578:9: style: The scope of the variable 'dither1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int * dither1;
        ^
3rdparty/libjpeg/jquant1.c:579:9: style: The scope of the variable 'dither2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int * dither2;
        ^
3rdparty/libjpeg/jquant1.c:580:7: style: The scope of the variable 'row_index' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int row_index, col_index; /* current indexes into dither matrix */
      ^
3rdparty/libjpeg/jquant1.c:580:18: style: The scope of the variable 'col_index' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int row_index, col_index; /* current indexes into dither matrix */
                 ^
3rdparty/libjpeg/jquant2.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jquant2.c:229:21: style: The scope of the variable 'ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW ptr;
                    ^
3rdparty/libjpeg/jquant2.c:429:7: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int n,lb;
      ^
3rdparty/libjpeg/jquant2.c:430:7: style: The scope of the variable 'c0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int c0,c1,c2,cmax;
      ^
3rdparty/libjpeg/jquant2.c:430:10: style: The scope of the variable 'c1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int c0,c1,c2,cmax;
         ^
3rdparty/libjpeg/jquant2.c:430:13: style: The scope of the variable 'c2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int c0,c1,c2,cmax;
            ^
3rdparty/libjpeg/jquant2.c:430:16: style: The scope of the variable 'cmax' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int c0,c1,c2,cmax;
               ^
3rdparty/libjpeg/jquant2.c:431:22: style: The scope of the variable 'b2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register boxptr b1,b2;
                     ^
3rdparty/libjpeg/jquant2.c:661:10: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i, x, ncolors;
         ^
3rdparty/libjpeg/jquant2.c:786:10: style: The scope of the variable 'icolor' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i, icolor;
         ^
3rdparty/libjpeg/jquant2.c:788:13: style: The scope of the variable 'cptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPLE * cptr;  /* pointer into bestcolor[] array */
            ^
3rdparty/libjpeg/jquant2.c:789:9: style: The scope of the variable 'dist0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 dist0, dist1;  /* initial distance values */
        ^
3rdparty/libjpeg/jquant2.c:791:9: style: The scope of the variable 'xx0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 xx0, xx1;  /* distance increments */
        ^
3rdparty/libjpeg/jquant2.c:793:9: style: The scope of the variable 'inc0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 inc0, inc1, inc2; /* initial values for increments */
        ^
3rdparty/libjpeg/jquant2.c:793:15: style: The scope of the variable 'inc1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 inc0, inc1, inc2; /* initial values for increments */
              ^
3rdparty/libjpeg/jquant2.c:793:21: style: The scope of the variable 'inc2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  INT32 inc0, inc1, inc2; /* initial values for increments */
                    ^
3rdparty/libjpeg/jquant2.c:922:21: style: The scope of the variable 'inptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr, outptr;
                    ^
3rdparty/libjpeg/jquant2.c:922:28: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr, outptr;
                           ^
3rdparty/libjpeg/jquant2.c:956:23: style: The scope of the variable 'cur0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register LOCFSERROR cur0, cur1, cur2; /* current error or pixel value */
                      ^
3rdparty/libjpeg/jquant2.c:956:29: style: The scope of the variable 'cur1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register LOCFSERROR cur0, cur1, cur2; /* current error or pixel value */
                            ^
3rdparty/libjpeg/jquant2.c:956:35: style: The scope of the variable 'cur2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register LOCFSERROR cur0, cur1, cur2; /* current error or pixel value */
                                  ^
3rdparty/libjpeg/jquant2.c:957:14: style: The scope of the variable 'belowerr0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */
             ^
3rdparty/libjpeg/jquant2.c:957:25: style: The scope of the variable 'belowerr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */
                        ^
3rdparty/libjpeg/jquant2.c:957:36: style: The scope of the variable 'belowerr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */
                                   ^
3rdparty/libjpeg/jquant2.c:958:14: style: The scope of the variable 'bpreverr0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */
             ^
3rdparty/libjpeg/jquant2.c:958:25: style: The scope of the variable 'bpreverr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */
                        ^
3rdparty/libjpeg/jquant2.c:958:36: style: The scope of the variable 'bpreverr2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */
                                   ^
3rdparty/libjpeg/jquant2.c:960:12: style: The scope of the variable 'inptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW inptr;  /* => current input pixel */
           ^
3rdparty/libjpeg/jquant2.c:961:12: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  JSAMPROW outptr;  /* => current output pixel */
           ^
3rdparty/libjpeg/jutils.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libjpeg/jutils.c:186:21: style: The scope of the variable 'inptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr, outptr;
                    ^
3rdparty/libjpeg/jutils.c:186:28: style: The scope of the variable 'outptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  register JSAMPROW inptr, outptr;
                           ^
3rdparty/libpng/arm/arm_init.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/arm/arm_init.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_ARM_NEON_CHECK_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_CHECK_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_CHECK_SUPPORTED;PNG_READ_SUPPORTED;PNG_ALIGNED_MEMORY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_CHECK_SUPPORTED;PNG_READ_SUPPORTED;__linux__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/arm/filter_neon_intrinsics.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/arm/filter_neon_intrinsics.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_IMPLEMENTATION=1;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/intel/filter_sse2_intrinsics.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/intel/filter_sse2_intrinsics.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/intel/intel_init.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/intel/intel_init.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/png.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/png.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_16BIT_SUPPORTED;PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_16BIT_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED;PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_RGB_TO_GRAY_SUPPORTED;PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_16BIT_SUPPORTED;PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED;PNG_READ_pHYs_SUPPORTED;PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED;PNG_READ_pHYs_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_READ_RGB_TO_GRAY_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_iCCP_SUPPORTED;PNG_SET_USER_LIMITS_SUPPORTED;PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_iCCP_SUPPORTED;PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SET_OPTION_SUPPORTED;PNG_iCCP_SUPPORTED;PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WARNINGS_SUPPORTED;PNG_iCCP_SUPPORTED;PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_iCCP_SUPPORTED;PNG_sRGB_PROFILE_CHECKS=0;PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_iCCP_SUPPORTED;PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED;PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_RGB_TO_GRAY_SUPPORTED;PNG_cHRM_SUPPORTED;PNG_gAMA_SUPPORTED;PNG_sCAL_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_READ_UNKNOWN_CHUNKS_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED;PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_RGB_TO_GRAY_SUPPORTED;PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_USER_CHUNK_CACHE_MAX;PNG_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_USER_CHUNK_MALLOC_MAX;PNG_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_pCAL_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STRING_COPYRIGHT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngerror.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngerror.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONSOLE_IO_SUPPORTED;PNG_ERROR_NUMBERS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONSOLE_IO_SUPPORTED;PNG_ERROR_NUMBERS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONSOLE_IO_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONSOLE_IO_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED;PNG_ERROR_TEXT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WARNINGS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_TIME_RFC1123_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngget.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngget.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED;PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED;PNG_FIXED_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED;PNG_FIXED_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngmem.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngmem.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MAX_MALLOC_64K;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_TEXT_SUPPORTED;PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngpread.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngpread.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_iTXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_tEXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_zTXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngread.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngread.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_READ_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_READ_ERRORS_SUPPORTED;PNG_READ_SUPPORTED;PNG_RELEASE_BUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_iCCP_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_BGR_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_EXPAND_16_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_GRAY_TO_RGB_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_INVERT_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_PACKSWAP_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_PACK_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_SCALE_16_TO_8_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_SHIFT_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_STRIP_16_TO_8_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_STRIP_ALPHA_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_SWAP_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED;PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_UNKNOWN_CHUNKS_SUPPORTED;PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_bKGD_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_cHRM_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_eXIf_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_gAMA_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_hIST_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_iCCP_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_iTXt_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_oFFs_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_pCAL_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_pHYs_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_sBIT_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_sCAL_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_sPLT_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_sRGB_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_tEXt_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_tIME_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_tRNS_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_zTXt_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_SIMPLIFIED_READ_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;__COVERITY__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngrio.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngrio.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngrtran.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngrtran.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED;PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED;PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED;PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED;PNG_READ_RGB_TO_GRAY_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_16BIT_SUPPORTED;PNG_READ_FILLER_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_16BIT_SUPPORTED;PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_16BIT_SUPPORTED;PNG_READ_SCALE_16_TO_8_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_16BIT_SUPPORTED;PNG_READ_SHIFT_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_16BIT_SUPPORTED;PNG_READ_STRIP_16_TO_8_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_16BIT_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_16BIT_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_SWAP_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_16BIT_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED;PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED;PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED;PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED;PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_16_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_READ_GRAY_TO_RGB_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_SCALE_16_TO_8_SUPPORTED;PNG_READ_STRIP_16_TO_8_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED;PNG_READ_RGB_TO_GRAY_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED;PNG_READ_RGB_TO_GRAY_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED;PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED;PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngrutil.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngrutil.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALIGNED_MEMORY_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FILTER_OPTIMIZATIONS;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IGNORE_ADLER32;PNG_SET_OPTION_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MAXIMUM_INFLATE_WINDOW;PNG_SET_OPTION_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MAX_MALLOC_64K;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MAX_MALLOC_64K;PNG_READ_SUPPORTED;PNG_READ_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MAX_MALLOC_64K;PNG_READ_SUPPORTED;PNG_READ_tEXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POINTER_INDEXING_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POINTER_INDEXING_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPRESSED_TEXT_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPRESSED_TEXT_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_iTXt_SUPPORTED;PNG_READ_zTXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPRESSED_TEXT_SUPPORTED;PNG_READ_SUPPORTED;PNG_READ_iTXt_SUPPORTED;PNG_READ_zTXt_SUPPORTED;PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED;PNG_READ_GRAY_TO_RGB_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_READ_GRAY_TO_RGB_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_READ_PACKSWAP_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_READ_SUPPORTED;PNG_USE_COMPILE_TIME_MASKS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_UNKNOWN_CHUNKS_SUPPORTED;PNG_READ_USER_CHUNKS_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_UNKNOWN_CHUNKS_SUPPORTED;PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_UNKNOWN_CHUNKS_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_UNKNOWN_CHUNKS_SUPPORTED;PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_UNKNOWN_CHUNKS_SUPPORTED;PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_UNKNOWN_CHUNKS_SUPPORTED;PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_cHRM_SUPPORTED;PNG_READ_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_iCCP_SUPPORTED;PNG_READ_iTXt_SUPPORTED;PNG_READ_pCAL_SUPPORTED;PNG_READ_sCAL_SUPPORTED;PNG_READ_sPLT_SUPPORTED;PNG_READ_tEXt_SUPPORTED;PNG_READ_zTXt_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_iCCP_SUPPORTED;PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_iTXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_iTXt_SUPPORTED;PNG_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_sPLT_SUPPORTED;PNG_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_tEXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_tEXt_SUPPORTED;PNG_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_zTXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_zTXt_SUPPORTED;PNG_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_RELEASE_BUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_USE_ABS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;window_bits : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngset.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngset.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_READ_UNKNOWN_CHUNKS_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_TEXT_SUPPORTED;PNG_iCCP_SUPPORTED;PNG_pCAL_SUPPORTED;PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_TEXT_SUPPORTED;PNG_iCCP_SUPPORTED;PNG_pCAL_SUPPORTED;PNG_sPLT_SUPPORTED;PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_TEXT_SUPPORTED;PNG_iTXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WARNINGS_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngtrans.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngtrans.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_16BIT_SUPPORTED;PNG_BUILTIN_BSWAP16_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_16BIT_SUPPORTED;PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_16BIT_SUPPORTED;PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_16BIT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_16BIT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED;PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED;PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED;PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED;PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngwio.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngwio.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED;PNG_WRITE_FLUSH_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngwrite.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngwrite.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_WRITE_ERRORS_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_iCCP_SUPPORTED;PNG_WRITE_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_BGR_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_PACK_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED;PNG_WRITE_16BIT_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_RELEASE_BUILD;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_WRITE_BGR_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_COMPRESSED_TEXT_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FILTER_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED;PNG_WRITE_FLUSH_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INTERLACING_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INVERT_ALPHA_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_TEXT_SUPPORTED;PNG_WRITE_iTXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_TEXT_SUPPORTED;PNG_WRITE_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_TEXT_SUPPORTED;PNG_WRITE_tEXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_TEXT_SUPPORTED;PNG_WRITE_zTXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngwtran.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngwtran.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_16BIT_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_16BIT_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_16BIT_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_BGR_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FILLER_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INVERT_ALPHA_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INVERT_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_PACKSWAP_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_PACK_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SHIFT_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_TRANSFORMS_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/pngwutil.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/pngwutil.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED;PNG_WARNINGS_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POINTER_INDEXING_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POINTER_INDEXING_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_RELEASE_BUILD;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_ABS;PNG_WRITE_FILTER_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_16BIT_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_16BIT_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_16BIT_SUPPORTED;PNG_WRITE_SUPPORTED;PNG_WRITE_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_COMPRESSED_TEXT_SUPPORTED;PNG_WRITE_OPTIMIZE_CMF_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_COMPRESSED_TEXT_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FILTER_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INTERLACING_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_OPTIMIZE_CMF_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_iTXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_tEXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_zTXt_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/powerpc/filter_vsx_intrinsics.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/powerpc/filter_vsx_intrinsics.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_IMPLEMENTATION=1;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_IMPLEMENTATION=1;PNG_READ_SUPPORTED;PNG_USE_ABS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_IMPLEMENTATION=1;PNG_READ_SUPPORTED;__BIG_ENDIAN__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_IMPLEMENTATION=1;PNG_READ_SUPPORTED;__LITTLE_ENDIAN__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libpng/powerpc/powerpc_init.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libpng/powerpc/powerpc_init.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
DLL_EXPORT : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
HAVE_CONFIG_H;PNG_NO_CONFIG_H : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;PNG_MAX_MALLOC_64K : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
MAXSEG_64K;_MSC_VER;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNGPREFIX_H;PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOCATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ALLOW_BENIGN_ERRORS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=1;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_API_RULE=2;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ARM_NEON_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BENIGN_ERRORS_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED;PNG_GET_PALETTE_MAX_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_COLORSPACE_SUPPORTED;PNG_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_CONVERT_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;PNG_DEBUG_FILE;_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEBUG;__STDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEFAULT_READ_MACROS;PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_DEPRECATED;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EASY_ACCESS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_NUMBERS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_ERROR_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_EXPORT_LAST_ORDINAL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_MACRO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FIXED_POINT_SUPPORTED;PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_ARITHMETIC_SUPPORTED;PNG_FLOATING_POINT_SUPPORTED;PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FLOATING_POINT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_AFIRST_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_FORMAT_BGR_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_GAMMA_SUPPORTED;PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_HANDLE_AS_UNKNOWN_SUPPORTED;PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INCH_CONVERSIONS_SUPPORTED;PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INFO_IMAGE_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_INTEL_SSE;_M_AMD64;_M_IX86_FP;_M_X64;__AVX__;__SSE2__;__SSE4_1__;__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_IO_STATE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_LIBPNG_SPECIALBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MIPS_MSA_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_MNG_FEATURES_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NORETURN;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_NO_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_POWERPC_VSX_CHECK_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_API_SUPPORTED;PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_CHECK_SUPPORTED;PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_POWERPC_VSX_CHECK_SUPPORTED;PNG_READ_SUPPORTED;__linux__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PREFIX : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PRIVATE;__clang__;__has_attribute;__has_extension : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_PROGRESSIVE_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_ALPHA_MODE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_READ_EXPAND_SUPPORTED;PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BACKGROUND_SUPPORTED;PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_BGR_SUPPORTED;PNG_WRITE_BGR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_COMPOSITE_NODIV_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_16_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_EXPAND_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_FILLER_SUPPORTED;PNG_WRITE_FILLER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GAMMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_GRAY_TO_RGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INTERLACING_SUPPORTED;PNG_WRITE_INTERLACING_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_ALPHA_SUPPORTED;PNG_WRITE_INVERT_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_INVERT_SUPPORTED;PNG_WRITE_INVERT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACKSWAP_SUPPORTED;PNG_WRITE_PACKSWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_PACK_SUPPORTED;PNG_WRITE_PACK_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_QUANTIZE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_RGB_TO_GRAY_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SCALE_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SHIFT_SUPPORTED;PNG_WRITE_SHIFT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_16_TO_8_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_STRIP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_ALPHA_SUPPORTED;PNG_WRITE_SWAP_ALPHA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_SWAP_SUPPORTED;PNG_WRITE_SWAP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_USER_TRANSFORM_SUPPORTED;PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_READ_eXIf_SUPPORTED;PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SAVE_INT_32_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SEQUENTIAL_READ_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SETJMP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_OPTION_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SET_USER_LIMITS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_SIMPLIFIED_READ_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED;PNG_SIMPLIFIED_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STDIO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED;PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TEXT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_TIME_RFC1123_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_UNKNOWN_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CHUNKS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_CONFIG : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_MEM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_PRIVATEBUILD;WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_INFO_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USER_TRANSFORM_PTR_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_DLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_READ_MACROS : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_USE_RESULT;__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WARNINGS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED;PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_FLUSH_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_INT_FUNCTIONS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_SUPPORTED;PNG_WRITE_WEIGHTED_FILTER_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_WRITE_USER_TRANSFORM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_bKGD_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_cHRM_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_eXIf_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_gAMA_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_hIST_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_iCCP_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_oFFs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_pHYs_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sBIT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sCAL_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sPLT_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_sRGB_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tIME_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
PNG_tRNS_SUPPORTED : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
TARGET_OS_MAC;THINK_C;__MWERKS__;__SC__;applec;macintosh;__MATH_H;__MATH_H__;__cmath__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
UINT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
USHRT_MAX=65535 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__BORLANDC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__CYGWIN__;__WIN32__;_MSC_VER;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WIN32;_WIN32;_WINDOWS;_Windows;__WIN32__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
WINRT;_WINDOWS_ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_AMIGA;_M68881;__SASC : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_MSC_VER : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_M_AMD64;_M_IX86_FP;_M_X64;__SSE2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64 : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WIN64;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_WINDLL : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
_Windows;__FLAT__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ALTIVEC__;__PPC64__;__VSX__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__ARM_NEON;__ARM_NEON__;__clang__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__AVX__;__SSE4_1__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__DLL__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC_MINOR__;__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__GNUC__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__IBMCPP__;__IBMC__;__OS2__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__MSDOS__;__TURBOC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__SSSE3__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__WATCOMC__ : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__has_attribute : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__clang__;__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
__mips_msa : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
const : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes"
offsetof : [3rdparty/libpng/pngconf.h:483] #error "libpng requires 8-bit bytes" [noValidConfiguration]

^
3rdparty/libtiff/tif_aux.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_aux.c:138:6: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 int i;
     ^
3rdparty/libtiff/tif_close.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_codec.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_color.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_compress.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_dir.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_dir.c:1188:11: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
         *(float *)val;
          ^
3rdparty/libtiff/tif_dir.c:1193:11: portability: Casting between signed char * and double * which have an incompatible binary data representation. [invalidPointerCast]
         *(double *)val;
          ^
3rdparty/libtiff/tif_dirinfo.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_dirread.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_dirread.c:4422:16: style: The scope of the variable 'dp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 TIFFDirEntry *dp;
               ^
3rdparty/libtiff/tif_dirwrite.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_dumpmode.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_error.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_extension.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_fax3.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_fax3.c:719:29: style: The scope of the variable 'tparm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 unsigned int code, length, tparm;
                            ^
3rdparty/libtiff/tif_fax3.c:680:3: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  DEBUG_PRINT("MakeUp", te->runlen);
  ^
3rdparty/libtiff/tif_fax3.c:691:3: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  DEBUG_PRINT("MakeUp", te->runlen);
  ^
3rdparty/libtiff/tif_fax3.c:699:2: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
 DEBUG_PRINT("  Term", tab[span].runlen);
 ^
3rdparty/libtiff/tif_fax3.c:248:3: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
  EXPAND1D(EOF1Da);
  ^
3rdparty/libtiff/tif_fax3.c:301:4: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
   EXPAND1D(EOF2Da);
   ^
3rdparty/libtiff/tif_fax3.c:303:4: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
   EXPAND2D(EOF2Da);
   ^
3rdparty/libtiff/tif_fax3.c:680:3: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
  DEBUG_PRINT("MakeUp", te->runlen);
  ^
3rdparty/libtiff/tif_fax3.c:691:3: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
  DEBUG_PRINT("MakeUp", te->runlen);
  ^
3rdparty/libtiff/tif_fax3.c:699:2: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
 DEBUG_PRINT("  Term", tab[span].runlen);
 ^
3rdparty/libtiff/tif_fax3.c:1455:3: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
  EXPAND2D(EOFG4);
  ^
3rdparty/libtiff/tif_fax3.c:1579:3: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
  EXPAND1D(EOFRLE);
  ^
3rdparty/libtiff/tif_flush.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_getimage.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_getimage.c:2138:8: style: Variable 'cp2' is assigned a value that is never used. [unreadVariable]
   cp2 += 2;
       ^
3rdparty/libtiff/tif_jbig.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_jpeg.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_jpeg.c:1100:6: style: The scope of the variable 'ci' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 int ci;
     ^
3rdparty/libtiff/tif_jpeg.c:2121:6: style: The scope of the variable 'clumpoffset' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 int clumpoffset, ci, xpos, ypos;
     ^
3rdparty/libtiff/tif_jpeg.c:1468:27: style: Variable 'cc' is assigned a value that is never used. [unreadVariable]
                       cc -= sp->bytesperline;
                          ^
3rdparty/libtiff/tif_jpeg.c:1365:28: style: Variable 'cc' is assigned a value that is never used. [unreadVariable]
                        cc -= sp->bytesperline;
                           ^
3rdparty/libtiff/tif_jpeg_12.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_luv.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_lzma.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_lzw.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_next.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_ojpeg.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_ojpeg.c:818:9: style: The scope of the variable 'ocb' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 uint8* ocb;
        ^
3rdparty/libtiff/tif_ojpeg.c:819:9: style: The scope of the variable 'ocr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 uint8* ocr;
        ^
3rdparty/libtiff/tif_ojpeg.c:820:9: style: The scope of the variable 'p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 uint8* p;
        ^
3rdparty/libtiff/tif_ojpeg.c:1160:10: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 uint8** m;
         ^
3rdparty/libtiff/tif_open.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_packbits.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_pixarlog.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_predict.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_predict.c:530:17: style: The scope of the variable 'r1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
   unsigned int r1, g1, b1;
                ^
3rdparty/libtiff/tif_predict.c:530:21: style: The scope of the variable 'g1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
   unsigned int r1, g1, b1;
                    ^
3rdparty/libtiff/tif_predict.c:530:25: style: The scope of the variable 'b1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
   unsigned int r1, g1, b1;
                        ^
3rdparty/libtiff/tif_predict.c:541:17: style: The scope of the variable 'r1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
   unsigned int r1, g1, b1, a1;
                ^
3rdparty/libtiff/tif_predict.c:541:21: style: The scope of the variable 'g1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
   unsigned int r1, g1, b1, a1;
                    ^
3rdparty/libtiff/tif_predict.c:541:25: style: The scope of the variable 'b1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
   unsigned int r1, g1, b1, a1;
                        ^
3rdparty/libtiff/tif_predict.c:541:29: style: The scope of the variable 'a1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
   unsigned int r1, g1, b1, a1;
                            ^
3rdparty/libtiff/tif_print.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_read.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_read.c:355:13: style: Condition '!whole_strip' is always false [knownConditionTrueFalse]
        if( !whole_strip )
            ^
3rdparty/libtiff/tif_read.c:352:23: note: Assignment 'whole_strip=1', assigned value is 1
        whole_strip = 1;
                      ^
3rdparty/libtiff/tif_read.c:355:13: note: Condition '!whole_strip' is always false
        if( !whole_strip )
            ^
3rdparty/libtiff/tif_read.c:377:21: style: Condition 'whole_strip' is always true [knownConditionTrueFalse]
                if( whole_strip )
                    ^
3rdparty/libtiff/tif_read.c:352:23: note: Assignment 'whole_strip=1', assigned value is 1
        whole_strip = 1;
                      ^
3rdparty/libtiff/tif_read.c:377:21: note: Condition 'whole_strip' is always true
                if( whole_strip )
                    ^
3rdparty/libtiff/tif_read.c:392:18: style: Condition '!whole_strip' is always false [knownConditionTrueFalse]
        else if( !whole_strip )
                 ^
3rdparty/libtiff/tif_read.c:352:23: note: Assignment 'whole_strip=1', assigned value is 1
        whole_strip = 1;
                      ^
3rdparty/libtiff/tif_read.c:392:18: note: Condition '!whole_strip' is always false
        else if( !whole_strip )
                 ^
3rdparty/libtiff/tif_stream.cxx:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_strip.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_strip.c:290:29: warning: Opposite inner 'if' condition leads to a dead code block (outer condition is 'td->td_samplesperpixel==3' and inner condition is 'td->td_samplesperpixel!=3'). [oppositeInnerCondition]
   if(td->td_samplesperpixel!=3)
                            ^
3rdparty/libtiff/tif_strip.c:282:30: note: outer condition: td->td_samplesperpixel==3
      (td->td_samplesperpixel==3)&&
                             ^
3rdparty/libtiff/tif_strip.c:290:29: note: opposite inner condition: td->td_samplesperpixel!=3
   if(td->td_samplesperpixel!=3)
                            ^
3rdparty/libtiff/tif_swab.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_swab.c:76:25: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 register unsigned char t;
                        ^
3rdparty/libtiff/tif_swab.c:92:16: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 unsigned char t;
               ^
3rdparty/libtiff/tif_swab.c:108:25: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 register unsigned char t;
                        ^
3rdparty/libtiff/tif_swab.c:125:25: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 register unsigned char t;
                        ^
3rdparty/libtiff/tif_swab.c:156:25: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 register unsigned char t;
                        ^
3rdparty/libtiff/tif_swab.c:187:25: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 register unsigned char t;
                        ^
3rdparty/libtiff/tiffio.h:489:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabArrayOfDouble' since the value of 'TIFFSwabArrayOfDouble' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
extern void TIFFSwabArrayOfDouble(double* dp, tmsize_t n);
^
3rdparty/libtiff/tif_swab.c:184:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabArrayOfDouble' since the value of 'TIFFSwabArrayOfDouble' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
TIFFSwabArrayOfDouble(double* dp, tmsize_t n)
^
3rdparty/libtiff/tiffio.h:488:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabArrayOfFloat' since the value of 'TIFFSwabArrayOfFloat' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
extern void TIFFSwabArrayOfFloat(float* fp, tmsize_t n);
^
3rdparty/libtiff/tif_swab.c:153:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabArrayOfFloat' since the value of 'TIFFSwabArrayOfFloat' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
TIFFSwabArrayOfFloat(register float* fp, tmsize_t n)
^
3rdparty/libtiff/tiffio.h:486:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabArrayOfLong' since the value of 'TIFFSwabArrayOfLong' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
extern void TIFFSwabArrayOfLong(uint32* lp, tmsize_t n);
^
3rdparty/libtiff/tif_swab.c:105:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabArrayOfLong' since the value of 'TIFFSwabArrayOfLong' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
TIFFSwabArrayOfLong(register uint32* lp, tmsize_t n)
^
3rdparty/libtiff/tiffio.h:487:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabArrayOfLong8' since the value of 'TIFFSwabArrayOfLong8' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
extern void TIFFSwabArrayOfLong8(uint64* lp, tmsize_t n);
^
3rdparty/libtiff/tif_swab.c:122:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabArrayOfLong8' since the value of 'TIFFSwabArrayOfLong8' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
TIFFSwabArrayOfLong8(register uint64* lp, tmsize_t n)
^
3rdparty/libtiff/tiffio.h:484:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabArrayOfShort' since the value of 'TIFFSwabArrayOfShort' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
extern void TIFFSwabArrayOfShort(uint16* wp, tmsize_t n);
^
3rdparty/libtiff/tif_swab.c:73:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabArrayOfShort' since the value of 'TIFFSwabArrayOfShort' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
TIFFSwabArrayOfShort(register uint16* wp, tmsize_t n)
^
3rdparty/libtiff/tiffio.h:485:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabArrayOfTriples' since the value of 'TIFFSwabArrayOfTriples' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
extern void TIFFSwabArrayOfTriples(uint8* tp, tmsize_t n);
^
3rdparty/libtiff/tif_swab.c:89:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabArrayOfTriples' since the value of 'TIFFSwabArrayOfTriples' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
TIFFSwabArrayOfTriples(register uint8* tp, tmsize_t n)
^
3rdparty/libtiff/tiffio.h:483:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabDouble' since the value of 'TIFFSwabDouble' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
extern void TIFFSwabDouble(double*);
^
3rdparty/libtiff/tif_swab.c:170:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabDouble' since the value of 'TIFFSwabDouble' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
TIFFSwabDouble(double *dp)
^
3rdparty/libtiff/tiffio.h:482:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabFloat' since the value of 'TIFFSwabFloat' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
extern void TIFFSwabFloat(float*);
^
3rdparty/libtiff/tif_swab.c:141:0: information: Skipping configuration 'DISABLE_CHECK_TIFFSWABMACROS;TIFFSwabFloat' since the value of 'TIFFSwabFloat' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
TIFFSwabFloat(float* fp)
^
3rdparty/libtiff/tif_thunder.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_tile.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_unix.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_version.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_warning.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_win32.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_write.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libtiff/tif_zip.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libwebp/src/dec/alpha_dec.c:180:21: warning: Either the condition 'io!=NULL' is redundant or there is possible null pointer dereference: io. [nullPointerRedundantCheck]
  const int width = io->width;
                    ^
3rdparty/libwebp/src/dec/alpha_dec.c:183:28: note: Assuming that condition 'io!=NULL' is not redundant
  assert(dec != NULL && io != NULL);
                           ^
3rdparty/libwebp/src/dec/alpha_dec.c:180:21: note: Null pointer dereference
  const int width = io->width;
                    ^
3rdparty/libwebp/src/dec/alpha_dec.c:181:22: warning: Either the condition 'io!=NULL' is redundant or there is possible null pointer dereference: io. [nullPointerRedundantCheck]
  const int height = io->crop_bottom;
                     ^
3rdparty/libwebp/src/dec/alpha_dec.c:183:28: note: Assuming that condition 'io!=NULL' is not redundant
  assert(dec != NULL && io != NULL);
                           ^
3rdparty/libwebp/src/dec/alpha_dec.c:181:22: note: Null pointer dereference
  const int height = io->crop_bottom;
                     ^
3rdparty/libwebp/src/dec/alpha_dec.c:52:42: warning: Either the condition 'data!=NULL' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
  const uint8_t* const alpha_data = data + ALPHA_HEADER_LEN;
                                         ^
3rdparty/libwebp/src/dec/alpha_dec.c:57:15: note: Assuming that condition 'data!=NULL' is not redundant
  assert(data != NULL && output != NULL && src_io != NULL);
              ^
3rdparty/libwebp/src/dec/alpha_dec.c:52:42: note: Null pointer addition
  const uint8_t* const alpha_data = data + ALPHA_HEADER_LEN;
                                         ^
3rdparty/libwebp/src/dec/io_dec.c:137:7: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int j;
      ^
3rdparty/libwebp/src/dec/vp8_dec.c:690:9: warning: Identical inner 'if' condition is always true (outer condition is 'ok' and inner condition is 'ok'). [identicalInnerCondition]
    if (ok) ok = VP8InitFrame(dec, io);
        ^
3rdparty/libwebp/src/dec/vp8_dec.c:688:7: note: outer condition: ok
  if (ok) {   // good to go.
      ^
3rdparty/libwebp/src/dec/vp8_dec.c:690:9: note: identical inner condition: ok
    if (ok) ok = VP8InitFrame(dec, io);
        ^
3rdparty/libwebp/src/dec/vp8l_dec.c:1218:7: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i;
      ^
3rdparty/libwebp/src/dec/webp_dec.c:227:30: warning: Either the condition 'data!=NULL' is redundant or there is possible null pointer dereference: data. [nullPointerRedundantCheck]
  const int is_vp8 = !memcmp(data, "VP8 ", TAG_SIZE);
                             ^
3rdparty/libwebp/src/dec/webp_dec.c:232:15: note: Assuming that condition 'data!=NULL' is not redundant
  assert(data != NULL);
              ^
3rdparty/libwebp/src/dec/webp_dec.c:227:30: note: Null pointer dereference
  const int is_vp8 = !memcmp(data, "VP8 ", TAG_SIZE);
                             ^
3rdparty/libwebp/src/dec/webp_dec.c:228:31: warning: Either the condition 'data!=NULL' is redundant or there is possible null pointer dereference: data. [nullPointerRedundantCheck]
  const int is_vp8l = !memcmp(data, "VP8L", TAG_SIZE);
                              ^
3rdparty/libwebp/src/dec/webp_dec.c:232:15: note: Assuming that condition 'data!=NULL' is not redundant
  assert(data != NULL);
              ^
3rdparty/libwebp/src/dec/webp_dec.c:228:31: note: Null pointer dereference
  const int is_vp8l = !memcmp(data, "VP8L", TAG_SIZE);
                              ^
3rdparty/libwebp/src/dsp/argb.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libwebp/src/dsp/argb_mips_dsp_r2.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libwebp/src/dsp/argb_sse2.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libwebp/src/dsp/cpu.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/libwebp/src/dsp/cpu.c:159:24: style: The expression '(X & 0x0) == 0x6' is always false. Check carefully constants and operators used, these errors might be hard to spot sometimes. In case of complex expression it might help to split it to separate expressions. [comparisonError]
      return (xgetbv() & 0x6) == 0x6;
                       ^
3rdparty/libwebp/src/dsp/dec_mips32.c:25:22: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
  const int sign = x >> 31;
                     ^
3rdparty/libwebp/src/dsp/enc.c:240:7: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int j;
      ^
3rdparty/libwebp/src/dsp/enc.c:262:7: style: The scope of the variable 'y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int y;
      ^
3rdparty/libwebp/src/dsp/enc_mips_dsp_r2.c:1313:15: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [knownConditionTrueFalse]
  return (ret != 0);
              ^
3rdparty/libwebp/src/dsp/enc_mips_dsp_r2.c:1281:13: note: 'ret' is assigned value '0' here.
  int ret = 0;
            ^
3rdparty/libwebp/src/dsp/enc_mips_dsp_r2.c:1313:15: note: The expression 'ret != 0' is always false.
  return (ret != 0);
              ^
3rdparty/libwebp/src/dsp/lossless.c:182:1: error: There is an unknown macro here somewhere. Configuration is required. If GENERATE_PREDICTOR_ADD is a macro then please configure it. [unknownMacro]
GENERATE_PREDICTOR_ADD(Predictor2_C, PredictorAdd2_C)
^
3rdparty/libwebp/src/dsp/lossless_enc.c:819:1: error: There is an unknown macro here somewhere. Configuration is required. If GENERATE_PREDICTOR_SUB is a macro then please configure it. [unknownMacro]
GENERATE_PREDICTOR_SUB(Predictor2, PredictorSub2_C)
^
3rdparty/libwebp/src/dsp/lossless_enc_mips32.c:65:23: style: The scope of the variable 'y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t log_cnt, y;
                      ^
3rdparty/libwebp/src/dsp/lossless_enc_mips_dsp_r2.c:84:25: style: The scope of the variable 'new_red' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  uint32_t argb, argb1, new_red, new_red1;
                        ^
3rdparty/libwebp/src/dsp/lossless_enc_msa.c:99:7: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i;
      ^
3rdparty/libwebp/src/dsp/lossless_msa.c:114:7: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i;
      ^
3rdparty/libwebp/src/dsp/lossless_msa.c:249:7: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i;
      ^
3rdparty/libwebp/src/dsp/lossless_sse2.c:251:1: error: There is an unknown macro here somewhere. Configuration is required. If GENERATE_PREDICTOR_ADD is a macro then please configure it. [unknownMacro]
GENERATE_PREDICTOR_ADD(Predictor5_SSE2, PredictorAdd5_SSE2)
^
3rdparty/libwebp/src/enc/alpha_enc.c:296:34: warning: Either the condition 'enc!=NULL' is redundant or there is possible null pointer dereference: enc. [nullPointerRedundantCheck]
  const WebPPicture* const pic = enc->pic_;
                                 ^
3rdparty/libwebp/src/enc/alpha_enc.c:308:14: note: Assuming that condition 'enc!=NULL' is not redundant
  assert(enc != NULL && pic != NULL && pic->a != NULL);
             ^
3rdparty/libwebp/src/enc/alpha_enc.c:296:34: note: Null pointer dereference
  const WebPPicture* const pic = enc->pic_;
                                 ^
3rdparty/libwebp/src/enc/alpha_enc.c:297:21: warning: Either the condition 'pic!=NULL' is redundant or there is possible null pointer dereference: pic. [nullPointerRedundantCheck]
  const int width = pic->width;
                    ^
3rdparty/libwebp/src/enc/alpha_enc.c:308:29: note: Assuming that condition 'pic!=NULL' is not redundant
  assert(enc != NULL && pic != NULL && pic->a != NULL);
                            ^
3rdparty/libwebp/src/enc/alpha_enc.c:297:21: note: Null pointer dereference
  const int width = pic->width;
                    ^
3rdparty/libwebp/src/enc/alpha_enc.c:298:22: warning: Either the condition 'pic!=NULL' is redundant or there is possible null pointer dereference: pic. [nullPointerRedundantCheck]
  const int height = pic->height;
                     ^
3rdparty/libwebp/src/enc/alpha_enc.c:308:29: note: Assuming that condition 'pic!=NULL' is not redundant
  assert(enc != NULL && pic != NULL && pic->a != NULL);
                            ^
3rdparty/libwebp/src/enc/alpha_enc.c:298:22: note: Null pointer dereference
  const int height = pic->height;
                     ^
3rdparty/libwebp/src/enc/analysis_enc.c:498:9: style: Condition 'do_mt' is always false [knownConditionTrueFalse]
    if (do_mt) {
        ^
3rdparty/libwebp/src/enc/backward_references_cost_enc.c:725:11: style: The scope of the variable 'k' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
      int k;
          ^
3rdparty/libwebp/src/enc/frame_enc.c:564:30: style: int result is assigned to long variable. If the variable is long to avoid loss of information, then there is loss of information. To avoid loss of information you must cast a calculation operand to long, for example 'l = a * b;' => 'l = (long)a * b;'. [truncLongCastAssignment]
  const uint64_t pixel_count = nb_mbs * 384;
                             ^
3rdparty/libwebp/src/enc/histogram_enc.c:996:8: warning: Either the condition 'orig_histo==NULL' is redundant or there is possible null pointer dereference: orig_histo. [nullPointerRedundantCheck]
      (orig_histo->size > entropy_combine_num_bins * 2) && (quality < 100);
       ^
3rdparty/libwebp/src/enc/histogram_enc.c:998:18: note: Assuming that condition 'orig_histo==NULL' is not redundant
  if (orig_histo == NULL) goto Error;
                 ^
3rdparty/libwebp/src/enc/histogram_enc.c:996:8: note: Null pointer dereference
      (orig_histo->size > entropy_combine_num_bins * 2) && (quality < 100);
       ^
3rdparty/libwebp/src/enc/picture_csp_enc.c:840:7: style: The scope of the variable 'y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int y;
      ^
3rdparty/libwebp/src/enc/predictor_enc.c:430:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x;
        ^
3rdparty/libwebp/src/enc/predictor_enc.c:479:7: style: The scope of the variable 'tile_y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int tile_y;
      ^
3rdparty/libwebp/src/enc/predictor_enc.c:480:7: style: The scope of the variable 'histo' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int histo[4][256];
      ^
3rdparty/libwebp/src/enc/vp8l_enc.c:1665:9: style: Condition '!use_delta_palette' is always true [knownConditionTrueFalse]
    if (!use_delta_palette) {
        ^
3rdparty/libwebp/src/enc/vp8l_enc.c:1581:27: note: Assignment 'use_delta_palette=0', assigned value is 0
  int use_delta_palette = 0;
                          ^
3rdparty/libwebp/src/enc/vp8l_enc.c:1665:9: note: Condition '!use_delta_palette' is always true
    if (!use_delta_palette) {
        ^
3rdparty/libwebp/src/enc/vp8l_enc.c:373:21: warning: Either the condition 'pic!=NULL' is redundant or there is possible null pointer dereference: pic. [nullPointerRedundantCheck]
  const int width = pic->width;
                    ^
3rdparty/libwebp/src/enc/vp8l_enc.c:381:14: note: Assuming that condition 'pic!=NULL' is not redundant
  assert(pic != NULL && pic->argb != NULL);
             ^
3rdparty/libwebp/src/enc/vp8l_enc.c:373:21: note: Null pointer dereference
  const int width = pic->width;
                    ^
3rdparty/libwebp/src/enc/vp8l_enc.c:374:22: warning: Either the condition 'pic!=NULL' is redundant or there is possible null pointer dereference: pic. [nullPointerRedundantCheck]
  const int height = pic->height;
                     ^
3rdparty/libwebp/src/enc/vp8l_enc.c:381:14: note: Assuming that condition 'pic!=NULL' is not redundant
  assert(pic != NULL && pic->argb != NULL);
             ^
3rdparty/libwebp/src/enc/vp8l_enc.c:374:22: note: Null pointer dereference
  const int height = pic->height;
                     ^
3rdparty/libwebp/src/enc/vp8l_enc.c:726:48: warning: Either the condition 'huffman_codes!=NULL' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
  const HuffmanTreeCode* codes = huffman_codes + 5 * histogram_ix;
                                               ^
3rdparty/libwebp/src/enc/vp8l_enc.c:1046:23: note: Assuming that condition 'huffman_codes!=NULL' is not redundant
    if (huffman_codes != NULL) {
                      ^
3rdparty/libwebp/src/enc/vp8l_enc.c:1033:50: note: Calling function 'StoreImageToBitMask', 6th argument 'huffman_codes' value is 0
                              histogram_symbols, huffman_codes);
                                                 ^
3rdparty/libwebp/src/enc/vp8l_enc.c:726:48: note: Null pointer addition
  const HuffmanTreeCode* codes = huffman_codes + 5 * histogram_ix;
                                               ^
3rdparty/libwebp/src/enc/vp8l_enc.c:208:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, x, y;
        ^
3rdparty/libwebp/src/enc/vp8l_enc.c:1207:29: style: int result is assigned to long variable. If the variable is long to avoid loss of information, then there is loss of information. To avoid loss of information you must cast a calculation operand to long, for example 'l = a * b;' => 'l = (long)a * b;'. [truncLongCastAssignment]
  const uint64_t image_size = width * height;
                            ^
3rdparty/libwebp/src/enc/webp_enc.c:173:3: portability: %ld in format string (no. 2) requires 'long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
  printf("Memory used:\n"
  ^
3rdparty/libwebp/src/enc/webp_enc.c:173:3: portability: %ld in format string (no. 3) requires 'long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
  printf("Memory used:\n"
  ^
3rdparty/libwebp/src/enc/webp_enc.c:173:3: portability: %ld in format string (no. 4) requires 'long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
  printf("Memory used:\n"
  ^
3rdparty/libwebp/src/enc/webp_enc.c:173:3: portability: %ld in format string (no. 5) requires 'long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
  printf("Memory used:\n"
  ^
3rdparty/libwebp/src/enc/webp_enc.c:173:3: portability: %ld in format string (no. 6) requires 'long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
  printf("Memory used:\n"
  ^
3rdparty/libwebp/src/enc/webp_enc.c:173:3: warning: %ld in format string (no. 7) requires 'long' but the argument type is 'unsigned long'. [invalidPrintfArgType_sint]
  printf("Memory used:\n"
  ^
3rdparty/libwebp/src/enc/webp_enc.c:183:3: portability: %ld in format string (no. 1) requires 'long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
  printf("Transient object sizes:\n"
  ^
3rdparty/libwebp/src/enc/webp_enc.c:183:3: portability: %ld in format string (no. 2) requires 'long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
  printf("Transient object sizes:\n"
  ^
3rdparty/libwebp/src/enc/webp_enc.c:183:3: portability: %ld in format string (no. 3) requires 'long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
  printf("Transient object sizes:\n"
  ^
3rdparty/libwebp/src/enc/webp_enc.c:183:3: portability: %ld in format string (no. 4) requires 'long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
  printf("Transient object sizes:\n"
  ^
3rdparty/libwebp/src/enc/webp_enc.c:183:3: portability: %ld in format string (no. 5) requires 'long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
  printf("Transient object sizes:\n"
  ^
3rdparty/libwebp/src/enc/webp_enc.c:192:3: portability: %ld in format string (no. 1) requires 'long' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
  printf("Picture size (yuv): %ld\n",
  ^
3rdparty/libwebp/src/mux/anim_encode.c:599:49: warning: Either the condition 'curr_canvas==NULL' is redundant or there is possible null pointer dereference: curr_canvas. [nullPointerRedundantCheck]
  const int right = clip(*x_offset + *width, 0, curr_canvas->width);
                                                ^
3rdparty/libwebp/src/mux/anim_encode.c:603:42: note: Assuming that condition 'curr_canvas==NULL' is not redundant
  if (prev_canvas == NULL || curr_canvas == NULL ||
                                         ^
3rdparty/libwebp/src/mux/anim_encode.c:599:49: note: Null pointer dereference
  const int right = clip(*x_offset + *width, 0, curr_canvas->width);
                                                ^
3rdparty/libwebp/src/mux/anim_encode.c:600:39: warning: Either the condition 'curr_canvas==NULL' is redundant or there is possible null pointer dereference: curr_canvas. [nullPointerRedundantCheck]
  const int left = clip(*x_offset, 0, curr_canvas->width - 1);
                                      ^
3rdparty/libwebp/src/mux/anim_encode.c:603:42: note: Assuming that condition 'curr_canvas==NULL' is not redundant
  if (prev_canvas == NULL || curr_canvas == NULL ||
                                         ^
3rdparty/libwebp/src/mux/anim_encode.c:600:39: note: Null pointer dereference
  const int left = clip(*x_offset, 0, curr_canvas->width - 1);
                                      ^
3rdparty/libwebp/src/mux/anim_encode.c:601:51: warning: Either the condition 'curr_canvas==NULL' is redundant or there is possible null pointer dereference: curr_canvas. [nullPointerRedundantCheck]
  const int bottom = clip(*y_offset + *height, 0, curr_canvas->height);
                                                  ^
3rdparty/libwebp/src/mux/anim_encode.c:603:42: note: Assuming that condition 'curr_canvas==NULL' is not redundant
  if (prev_canvas == NULL || curr_canvas == NULL ||
                                         ^
3rdparty/libwebp/src/mux/anim_encode.c:601:51: note: Null pointer dereference
  const int bottom = clip(*y_offset + *height, 0, curr_canvas->height);
                                                  ^
3rdparty/libwebp/src/mux/anim_encode.c:602:38: warning: Either the condition 'curr_canvas==NULL' is redundant or there is possible null pointer dereference: curr_canvas. [nullPointerRedundantCheck]
  const int top = clip(*y_offset, 0, curr_canvas->height - 1);
                                     ^
3rdparty/libwebp/src/mux/anim_encode.c:603:42: note: Assuming that condition 'curr_canvas==NULL' is not redundant
  if (prev_canvas == NULL || curr_canvas == NULL ||
                                         ^
3rdparty/libwebp/src/mux/anim_encode.c:602:38: note: Null pointer dereference
  const int top = clip(*y_offset, 0, curr_canvas->height - 1);
                                     ^
3rdparty/libwebp/src/mux/anim_encode.c:719:24: warning: Either the condition 'rect!=NULL' is redundant or there is possible null pointer dereference: rect. [nullPointerRedundantCheck]
  const int y_start = (rect->y_offset_ + block_size) & ~(block_size - 1);
                       ^
3rdparty/libwebp/src/mux/anim_encode.c:723:45: note: Assuming that condition 'rect!=NULL' is not redundant
  assert(src != NULL && dst != NULL && rect != NULL);
                                            ^
3rdparty/libwebp/src/mux/anim_encode.c:719:24: note: Null pointer dereference
  const int y_start = (rect->y_offset_ + block_size) & ~(block_size - 1);
                       ^
3rdparty/libwebp/src/mux/anim_encode.c:720:22: warning: Either the condition 'rect!=NULL' is redundant or there is possible null pointer dereference: rect. [nullPointerRedundantCheck]
  const int y_end = (rect->y_offset_ + rect->height_) & ~(block_size - 1);
                     ^
3rdparty/libwebp/src/mux/anim_encode.c:723:45: note: Assuming that condition 'rect!=NULL' is not redundant
  assert(src != NULL && dst != NULL && rect != NULL);
                                            ^
3rdparty/libwebp/src/mux/anim_encode.c:720:22: note: Null pointer dereference
  const int y_end = (rect->y_offset_ + rect->height_) & ~(block_size - 1);
                     ^
3rdparty/libwebp/src/mux/anim_encode.c:721:24: warning: Either the condition 'rect!=NULL' is redundant or there is possible null pointer dereference: rect. [nullPointerRedundantCheck]
  const int x_start = (rect->x_offset_ + block_size) & ~(block_size - 1);
                       ^
3rdparty/libwebp/src/mux/anim_encode.c:723:45: note: Assuming that condition 'rect!=NULL' is not redundant
  assert(src != NULL && dst != NULL && rect != NULL);
                                            ^
3rdparty/libwebp/src/mux/anim_encode.c:721:24: note: Null pointer dereference
  const int x_start = (rect->x_offset_ + block_size) & ~(block_size - 1);
                       ^
3rdparty/libwebp/src/mux/anim_encode.c:722:22: warning: Either the condition 'rect!=NULL' is redundant or there is possible null pointer dereference: rect. [nullPointerRedundantCheck]
  const int x_end = (rect->x_offset_ + rect->width_) & ~(block_size - 1);
                     ^
3rdparty/libwebp/src/mux/anim_encode.c:723:45: note: Assuming that condition 'rect!=NULL' is not redundant
  assert(src != NULL && dst != NULL && rect != NULL);
                                            ^
3rdparty/libwebp/src/mux/anim_encode.c:722:22: note: Null pointer dereference
  const int x_end = (rect->x_offset_ + rect->width_) & ~(block_size - 1);
                     ^
3rdparty/libwebp/src/mux/muxedit.c:395:10: warning: Either the condition 'frame_chunk!=NULL' is redundant or there is possible null pointer dereference: frame_chunk. [nullPointerRedundantCheck]
  assert(frame_chunk->tag_ == kChunks[IDX_ANMF].tag);
         ^
3rdparty/libwebp/src/mux/muxedit.c:396:22: note: Assuming that condition 'frame_chunk!=NULL' is not redundant
  assert(frame_chunk != NULL);
                     ^
3rdparty/libwebp/src/mux/muxedit.c:395:10: note: Null pointer dereference
  assert(frame_chunk->tag_ == kChunks[IDX_ANMF].tag);
         ^
3rdparty/libwebp/src/mux/muxedit.c:409:40: warning: Either the condition 'wpi!=NULL' is redundant or there is possible null pointer dereference: wpi. [nullPointerRedundantCheck]
  const WebPChunk* const frame_chunk = wpi->header_;
                                       ^
3rdparty/libwebp/src/mux/muxedit.c:411:14: note: Assuming that condition 'wpi!=NULL' is not redundant
  assert(wpi != NULL);
             ^
3rdparty/libwebp/src/mux/muxedit.c:409:40: note: Null pointer dereference
  const WebPChunk* const frame_chunk = wpi->header_;
                                       ^
3rdparty/libwebp/src/mux/muxread.c:78:28: warning: Either the condition 'img!=NULL' is redundant or there is possible null pointer dereference: img. [nullPointerRedundantCheck]
  const int is_lossless = (img->tag_ == kChunks[IDX_VP8L].tag);
                           ^
3rdparty/libwebp/src/mux/muxread.c:84:14: note: Assuming that condition 'img!=NULL' is not redundant
  assert(img != NULL);
             ^
3rdparty/libwebp/src/mux/muxread.c:78:28: note: Null pointer dereference
  const int is_lossless = (img->tag_ == kChunks[IDX_VP8L].tag);
                           ^
3rdparty/libwebp/src/utils/huffman_encode_utils.c:329:49: warning: Either the condition 'tokens!=NULL' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
  HuffmanTreeToken* const ending_token = tokens + max_tokens;
                                                ^
3rdparty/libwebp/src/utils/huffman_encode_utils.c:333:17: note: Assuming that condition 'tokens!=NULL' is not redundant
  assert(tokens != NULL);
                ^
3rdparty/libwebp/src/utils/huffman_encode_utils.c:329:49: note: Null pointer addition
  HuffmanTreeToken* const ending_token = tokens + max_tokens;
                                                ^
3rdparty/libwebp/src/utils/utils.c:256:26: warning: Either the condition 'pic!=NULL' is redundant or there is possible null pointer dereference: pic. [nullPointerRedundantCheck]
  const uint32_t* argb = pic->argb;
                         ^
3rdparty/libwebp/src/utils/utils.c:260:14: note: Assuming that condition 'pic!=NULL' is not redundant
  assert(pic != NULL);
             ^
3rdparty/libwebp/src/utils/utils.c:256:26: note: Null pointer dereference
  const uint32_t* argb = pic->argb;
                         ^
3rdparty/libwebp/src/utils/utils.c:257:21: warning: Either the condition 'pic!=NULL' is redundant or there is possible null pointer dereference: pic. [nullPointerRedundantCheck]
  const int width = pic->width;
                    ^
3rdparty/libwebp/src/utils/utils.c:260:14: note: Assuming that condition 'pic!=NULL' is not redundant
  assert(pic != NULL);
             ^
3rdparty/libwebp/src/utils/utils.c:257:21: note: Null pointer dereference
  const int width = pic->width;
                    ^
3rdparty/libwebp/src/utils/utils.c:258:22: warning: Either the condition 'pic!=NULL' is redundant or there is possible null pointer dereference: pic. [nullPointerRedundantCheck]
  const int height = pic->height;
                     ^
3rdparty/libwebp/src/utils/utils.c:260:14: note: Assuming that condition 'pic!=NULL' is not redundant
  assert(pic != NULL);
             ^
3rdparty/libwebp/src/utils/utils.c:258:22: note: Null pointer dereference
  const int height = pic->height;
                     ^
3rdparty/libwebp/src/utils/utils.c:251:7: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i;
      ^
3rdparty/openexr/Half/half.h:111:5: style: Class 'half' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    half (float f);
    ^
3rdparty/openexr/Half/toFloat.cpp:77:18: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
        return s << 31;
                 ^
3rdparty/openexr/Half/toFloat.cpp:103:19: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
        return (s << 31) | 0x7f800000;
                  ^
3rdparty/openexr/Half/toFloat.cpp:111:19: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
        return (s << 31) | 0x7f800000 | (m << 13);
                  ^
3rdparty/openexr/Half/toFloat.cpp:126:15: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
    return (s << 31) | (e << 23) | m;
              ^
3rdparty/openexr/Iex/IexBaseExc.h:72:5: style: Class 'BaseExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    BaseExc (const std::string &s) throw(); // std::string (s)
    ^
3rdparty/openexr/Iex/IexBaseExc.h:73:5: style: Class 'BaseExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    BaseExc (std::stringstream &s) throw(); // std::string (s.str())
    ^
3rdparty/openexr/Iex/IexBaseExc.h:142:1: style: Class 'ArgExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (ArgExc,   BaseExc)   // Invalid arguments to a function call
^
3rdparty/openexr/Iex/IexBaseExc.h:144:1: style: Class 'LogicExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (LogicExc, BaseExc)   // General error in a program's logic,
^
3rdparty/openexr/Iex/IexBaseExc.h:149:1: style: Class 'InputExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (InputExc, BaseExc)   // Invalid input data, e.g. from a file
^
3rdparty/openexr/Iex/IexBaseExc.h:151:1: style: Class 'IoExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (IoExc, BaseExc)   // Input or output operation failed
^
3rdparty/openexr/Iex/IexBaseExc.h:153:1: style: Class 'MathExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (MathExc,  BaseExc)   // Arithmetic exception; more specific
^
3rdparty/openexr/Iex/IexBaseExc.h:157:1: style: Class 'ErrnoExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (ErrnoExc, BaseExc)   // Base class for exceptions corresponding
^
3rdparty/openexr/Iex/IexBaseExc.h:162:1: style: Class 'NoImplExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (NoImplExc, BaseExc)  // Missing method exception e.g. from a
^
3rdparty/openexr/Iex/IexBaseExc.h:168:1: style: Class 'NullExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (NullExc, BaseExc)   // A pointer is inappropriately null.
^
3rdparty/openexr/Iex/IexBaseExc.h:170:1: style: Class 'TypeExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (TypeExc, BaseExc)   // An object is an inappropriate type,
^
3rdparty/openexr/Iex/IexBaseExc.h:142:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (ArgExc,   BaseExc)   // Invalid arguments to a function call
^
3rdparty/openexr/Iex/IexBaseExc.h:144:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (LogicExc, BaseExc)   // General error in a program's logic,
^
3rdparty/openexr/Iex/IexBaseExc.h:149:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (InputExc, BaseExc)   // Invalid input data, e.g. from a file
^
3rdparty/openexr/Iex/IexBaseExc.h:151:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (IoExc, BaseExc)   // Input or output operation failed
^
3rdparty/openexr/Iex/IexBaseExc.h:153:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (MathExc,  BaseExc)   // Arithmetic exception; more specific
^
3rdparty/openexr/Iex/IexBaseExc.h:157:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (ErrnoExc, BaseExc)   // Base class for exceptions corresponding
^
3rdparty/openexr/Iex/IexBaseExc.h:162:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (NoImplExc, BaseExc)  // Missing method exception e.g. from a
^
3rdparty/openexr/Iex/IexBaseExc.h:168:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (NullExc, BaseExc)   // A pointer is inappropriately null.
^
3rdparty/openexr/Iex/IexBaseExc.h:170:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (TypeExc, BaseExc)   // An object is an inappropriate type,
^
3rdparty/openexr/Iex/IexThrowErrnoExc.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/openexr/Iex/IexErrnoExc.h:51:1: style: Class 'EpermExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EpermExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:52:1: style: Class 'EnoentExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnoentExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:53:1: style: Class 'EsrchExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EsrchExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:54:1: style: Class 'EintrExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EintrExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:55:1: style: Class 'EioExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EioExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:56:1: style: Class 'EnxioExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnxioExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:57:1: style: Class 'E2bigExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (E2bigExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:58:1: style: Class 'EnoexecExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnoexecExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:59:1: style: Class 'EbadfExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EbadfExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:60:1: style: Class 'EchildExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EchildExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:61:1: style: Class 'EagainExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EagainExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:62:1: style: Class 'EnomemExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnomemExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:63:1: style: Class 'EaccesExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EaccesExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:64:1: style: Class 'EfaultExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EfaultExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:65:1: style: Class 'EnotblkExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnotblkExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:66:1: style: Class 'EbusyExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EbusyExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:67:1: style: Class 'EexistExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EexistExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:68:1: style: Class 'ExdevExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (ExdevExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:69:1: style: Class 'EnodevExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnodevExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:70:1: style: Class 'EnotdirExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnotdirExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:71:1: style: Class 'EisdirExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EisdirExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:72:1: style: Class 'EinvalExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EinvalExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:73:1: style: Class 'EnfileExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnfileExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:74:1: style: Class 'EmfileExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EmfileExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:75:1: style: Class 'EnottyExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnottyExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:76:1: style: Class 'EtxtbsyExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EtxtbsyExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:77:1: style: Class 'EfbigExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EfbigExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:78:1: style: Class 'EnospcExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnospcExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:79:1: style: Class 'EspipeExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EspipeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:80:1: style: Class 'ErofsExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (ErofsExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:81:1: style: Class 'EmlinkExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EmlinkExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:82:1: style: Class 'EpipeExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EpipeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:83:1: style: Class 'EdomExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EdomExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:84:1: style: Class 'ErangeExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (ErangeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:85:1: style: Class 'EnomsgExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnomsgExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:86:1: style: Class 'EidrmExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EidrmExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:87:1: style: Class 'EchrngExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EchrngExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:88:1: style: Class 'El2nsyncExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (El2nsyncExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:89:1: style: Class 'El3hltExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (El3hltExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:90:1: style: Class 'El3rstExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (El3rstExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:91:1: style: Class 'ElnrngExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (ElnrngExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:92:1: style: Class 'EunatchExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EunatchExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:93:1: style: Class 'EnocsiExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnocsiExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:94:1: style: Class 'El2hltExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (El2hltExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:95:1: style: Class 'EdeadlkExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EdeadlkExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:96:1: style: Class 'EnolckExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnolckExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:97:1: style: Class 'EbadeExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EbadeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:98:1: style: Class 'EbadrExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EbadrExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:99:1: style: Class 'ExfullExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (ExfullExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:100:1: style: Class 'EnoanoExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnoanoExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:101:1: style: Class 'EbadrqcExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EbadrqcExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:102:1: style: Class 'EbadsltExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EbadsltExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:103:1: style: Class 'EdeadlockExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EdeadlockExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:104:1: style: Class 'EbfontExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EbfontExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:105:1: style: Class 'EnostrExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnostrExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:106:1: style: Class 'EnodataExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnodataExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:107:1: style: Class 'EtimeExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EtimeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:108:1: style: Class 'EnosrExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnosrExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:109:1: style: Class 'EnonetExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnonetExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:110:1: style: Class 'EnopkgExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnopkgExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:111:1: style: Class 'EremoteExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EremoteExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:112:1: style: Class 'EnolinkExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnolinkExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:113:1: style: Class 'EadvExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EadvExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:114:1: style: Class 'EsrmntExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EsrmntExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:115:1: style: Class 'EcommExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EcommExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:116:1: style: Class 'EprotoExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EprotoExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:117:1: style: Class 'EmultihopExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EmultihopExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:118:1: style: Class 'EbadmsgExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EbadmsgExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:119:1: style: Class 'EnametoolongExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnametoolongExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:120:1: style: Class 'EoverflowExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EoverflowExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:121:1: style: Class 'EnotuniqExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnotuniqExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:122:1: style: Class 'EbadfdExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EbadfdExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:123:1: style: Class 'EremchgExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EremchgExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:124:1: style: Class 'ElibaccExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (ElibaccExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:125:1: style: Class 'ElibbadExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (ElibbadExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:126:1: style: Class 'ElibscnExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (ElibscnExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:127:1: style: Class 'ElibmaxExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (ElibmaxExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:128:1: style: Class 'ElibexecExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (ElibexecExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:129:1: style: Class 'EilseqExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EilseqExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:130:1: style: Class 'EnosysExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnosysExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:131:1: style: Class 'EloopExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EloopExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:132:1: style: Class 'ErestartExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (ErestartExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:133:1: style: Class 'EstrpipeExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EstrpipeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:134:1: style: Class 'EnotemptyExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnotemptyExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:135:1: style: Class 'EusersExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EusersExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:136:1: style: Class 'EnotsockExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnotsockExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:137:1: style: Class 'EdestaddrreqExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EdestaddrreqExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:138:1: style: Class 'EmsgsizeExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EmsgsizeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:139:1: style: Class 'EprototypeExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EprototypeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:140:1: style: Class 'EnoprotooptExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnoprotooptExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:141:1: style: Class 'EprotonosupportExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EprotonosupportExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:142:1: style: Class 'EsocktnosupportExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EsocktnosupportExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:143:1: style: Class 'EopnotsuppExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EopnotsuppExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:144:1: style: Class 'EpfnosupportExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EpfnosupportExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:145:1: style: Class 'EafnosupportExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EafnosupportExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:146:1: style: Class 'EaddrinuseExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EaddrinuseExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:147:1: style: Class 'EaddrnotavailExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EaddrnotavailExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:148:1: style: Class 'EnetdownExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnetdownExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:149:1: style: Class 'EnetunreachExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnetunreachExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:150:1: style: Class 'EnetresetExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnetresetExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:151:1: style: Class 'EconnabortedExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EconnabortedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:152:1: style: Class 'EconnresetExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EconnresetExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:153:1: style: Class 'EnobufsExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnobufsExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:154:1: style: Class 'EisconnExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EisconnExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:155:1: style: Class 'EnotconnExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnotconnExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:156:1: style: Class 'EshutdownExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EshutdownExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:157:1: style: Class 'EtoomanyrefsExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EtoomanyrefsExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:158:1: style: Class 'EtimedoutExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EtimedoutExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:159:1: style: Class 'EconnrefusedExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EconnrefusedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:160:1: style: Class 'EhostdownExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EhostdownExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:161:1: style: Class 'EhostunreachExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EhostunreachExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:162:1: style: Class 'EalreadyExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EalreadyExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:163:1: style: Class 'EinprogressExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EinprogressExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:164:1: style: Class 'EstaleExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EstaleExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:165:1: style: Class 'EioresidExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EioresidExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:166:1: style: Class 'EucleanExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EucleanExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:167:1: style: Class 'EnotnamExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnotnamExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:168:1: style: Class 'EnavailExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnavailExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:169:1: style: Class 'EisnamExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EisnamExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:170:1: style: Class 'EremoteioExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EremoteioExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:171:1: style: Class 'EinitExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EinitExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:172:1: style: Class 'EremdevExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EremdevExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:173:1: style: Class 'EcanceledExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EcanceledExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:174:1: style: Class 'EnolimfileExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnolimfileExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:175:1: style: Class 'EproclimExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EproclimExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:176:1: style: Class 'EdisjointExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EdisjointExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:177:1: style: Class 'EnologinExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnologinExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:178:1: style: Class 'EloginlimExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EloginlimExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:179:1: style: Class 'EgrouploopExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EgrouploopExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:180:1: style: Class 'EnoattachExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnoattachExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:181:1: style: Class 'EnotsupExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnotsupExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:182:1: style: Class 'EnoattrExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnoattrExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:183:1: style: Class 'EdircorruptedExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EdircorruptedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:184:1: style: Class 'EdquotExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EdquotExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:185:1: style: Class 'EnfsremoteExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnfsremoteExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:186:1: style: Class 'EcontrollerExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EcontrollerExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:187:1: style: Class 'EnotcontrollerExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnotcontrollerExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:188:1: style: Class 'EenqueuedExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EenqueuedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:189:1: style: Class 'EnotenqueuedExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnotenqueuedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:190:1: style: Class 'EjoinedExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EjoinedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:191:1: style: Class 'EnotjoinedExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnotjoinedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:192:1: style: Class 'EnoprocExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnoprocExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:193:1: style: Class 'EmustrunExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EmustrunExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:194:1: style: Class 'EnotstoppedExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnotstoppedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:195:1: style: Class 'EclockcpuExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EclockcpuExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:196:1: style: Class 'EinvalstateExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EinvalstateExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:197:1: style: Class 'EnoexistExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnoexistExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:198:1: style: Class 'EendofminorExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EendofminorExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:199:1: style: Class 'EbufsizeExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EbufsizeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:200:1: style: Class 'EemptyExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EemptyExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:201:1: style: Class 'EnointrgroupExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EnointrgroupExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:202:1: style: Class 'EinvalmodeExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EinvalmodeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:203:1: style: Class 'EcantextentExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EcantextentExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:204:1: style: Class 'EinvaltimeExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EinvaltimeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:205:1: style: Class 'EdestroyedExc' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
DEFINE_EXC (EdestroyedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:51:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EpermExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:52:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnoentExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:53:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EsrchExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:54:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EintrExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:55:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EioExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:56:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnxioExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:57:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (E2bigExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:58:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnoexecExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:59:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EbadfExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:60:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EchildExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:61:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EagainExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:62:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnomemExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:63:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EaccesExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:64:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EfaultExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:65:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnotblkExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:66:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EbusyExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:67:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EexistExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:68:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (ExdevExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:69:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnodevExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:70:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnotdirExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:71:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EisdirExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:72:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EinvalExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:73:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnfileExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:74:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EmfileExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:75:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnottyExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:76:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EtxtbsyExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:77:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EfbigExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:78:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnospcExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:79:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EspipeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:80:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (ErofsExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:81:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EmlinkExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:82:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EpipeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:83:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EdomExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:84:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (ErangeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:85:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnomsgExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:86:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EidrmExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:87:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EchrngExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:88:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (El2nsyncExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:89:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (El3hltExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:90:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (El3rstExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:91:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (ElnrngExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:92:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EunatchExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:93:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnocsiExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:94:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (El2hltExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:95:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EdeadlkExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:96:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnolckExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:97:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EbadeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:98:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EbadrExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:99:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (ExfullExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:100:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnoanoExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:101:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EbadrqcExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:102:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EbadsltExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:103:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EdeadlockExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:104:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EbfontExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:105:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnostrExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:106:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnodataExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:107:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EtimeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:108:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnosrExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:109:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnonetExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:110:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnopkgExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:111:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EremoteExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:112:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnolinkExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:113:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EadvExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:114:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EsrmntExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:115:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EcommExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:116:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EprotoExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:117:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EmultihopExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:118:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EbadmsgExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:119:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnametoolongExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:120:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EoverflowExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:121:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnotuniqExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:122:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EbadfdExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:123:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EremchgExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:124:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (ElibaccExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:125:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (ElibbadExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:126:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (ElibscnExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:127:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (ElibmaxExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:128:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (ElibexecExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:129:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EilseqExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:130:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnosysExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:131:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EloopExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:132:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (ErestartExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:133:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EstrpipeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:134:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnotemptyExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:135:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EusersExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:136:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnotsockExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:137:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EdestaddrreqExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:138:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EmsgsizeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:139:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EprototypeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:140:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnoprotooptExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:141:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EprotonosupportExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:142:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EsocktnosupportExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:143:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EopnotsuppExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:144:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EpfnosupportExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:145:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EafnosupportExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:146:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EaddrinuseExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:147:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EaddrnotavailExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:148:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnetdownExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:149:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnetunreachExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:150:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnetresetExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:151:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EconnabortedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:152:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EconnresetExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:153:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnobufsExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:154:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EisconnExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:155:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnotconnExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:156:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EshutdownExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:157:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EtoomanyrefsExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:158:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EtimedoutExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:159:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EconnrefusedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:160:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EhostdownExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:161:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EhostunreachExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:162:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EalreadyExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:163:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EinprogressExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:164:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EstaleExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:165:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EioresidExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:166:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EucleanExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:167:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnotnamExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:168:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnavailExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:169:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EisnamExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:170:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EremoteioExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:171:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EinitExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:172:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EremdevExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:173:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EcanceledExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:174:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnolimfileExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:175:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EproclimExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:176:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EdisjointExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:177:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnologinExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:178:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EloginlimExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:179:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EgrouploopExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:180:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnoattachExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:181:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnotsupExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:182:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnoattrExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:183:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EdircorruptedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:184:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EdquotExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:185:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnfsremoteExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:186:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EcontrollerExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:187:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnotcontrollerExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:188:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EenqueuedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:189:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnotenqueuedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:190:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EjoinedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:191:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnotjoinedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:192:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnoprocExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:193:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EmustrunExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:194:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnotstoppedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:195:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EclockcpuExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:196:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EinvalstateExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:197:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnoexistExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:198:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EendofminorExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:199:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EbufsizeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:200:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EemptyExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:201:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EnointrgroupExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:202:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EinvalmodeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:203:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EcantextentExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:204:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EinvaltimeExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexErrnoExc.h:205:1: style: Parameter 'text' can be declared with const [constParameter]
DEFINE_EXC (EdestroyedExc, ErrnoExc)
^
3rdparty/openexr/Iex/IexThrowErrnoExc.cpp:94:0: information: Skipping configuration 'E2BIG' since the value of 'E2BIG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      case E2BIG:
^
3rdparty/openexr/Iex/IexThrowErrnoExc.cpp:124:0: information: Skipping configuration 'EACCES' since the value of 'EACCES' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      case EACCES:
^
3rdparty/openexr/Iex/IexThrowErrnoExc.cpp:544:0: information: Skipping configuration 'EADDRINUSE' since the value of 'EADDRINUSE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      case EADDRINUSE:
^
3rdparty/openexr/Iex/IexThrowErrnoExc.cpp:549:0: information: Skipping configuration 'EADDRNOTAVAIL' since the value of 'EADDRNOTAVAIL' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      case EADDRNOTAVAIL:
^
3rdparty/openexr/Iex/IexThrowErrnoExc.cpp:379:0: information: Skipping configuration 'EADV' since the value of 'EADV' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      case EADV:
^
3rdparty/openexr/Iex/IexThrowErrnoExc.cpp:539:0: information: Skipping configuration 'EAFNOSUPPORT' since the value of 'EAFNOSUPPORT' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      case EAFNOSUPPORT:
^
3rdparty/openexr/Iex/IexThrowErrnoExc.cpp:114:0: information: Skipping configuration 'EAGAIN' since the value of 'EAGAIN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      case EAGAIN:
^
3rdparty/openexr/Iex/IexThrowErrnoExc.cpp:624:0: information: Skipping configuration 'EALREADY' since the value of 'EALREADY' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      case EALREADY:
^
3rdparty/openexr/Iex/IexThrowErrnoExc.cpp:294:0: information: Skipping configuration 'EBADE' since the value of 'EBADE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      case EBADE:
^
3rdparty/openexr/Iex/IexThrowErrnoExc.cpp:104:0: information: Skipping configuration 'EBADF' since the value of 'EBADF' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      case EBADF:
^
3rdparty/openexr/Iex/IexThrowErrnoExc.cpp:424:0: information: Skipping configuration 'EBADFD' since the value of 'EBADFD' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      case EBADFD:
^
3rdparty/openexr/IlmImf/ImfB44Compressor.cpp:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/openexr/IlmImf/ImfXdr.h:452] #error write<T> (T &out, signed long v) not implemented
DEBUG : [3rdparty/openexr/IlmImf/ImfXdr.h:452] #error write<T> (T &out, signed long v) not implemented [noValidConfiguration]

^
3rdparty/openexr/IlmImf/ImfName.h:61:5: style: Class 'Name' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Name (const char text[]);
    ^
3rdparty/openexr/IlmImf/ImfChannelList.h:275:5: style: Class 'Iterator' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Iterator (const ChannelList::ChannelMap::iterator &i);
    ^
3rdparty/openexr/IlmImf/ImfChannelList.h:296:5: style: Class 'ConstIterator' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ConstIterator (const ChannelList::ChannelMap::const_iterator &i);
    ^
3rdparty/openexr/IlmImf/ImfChannelList.h:297:5: style: Class 'ConstIterator' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ConstIterator (const ChannelList::Iterator &other);
    ^
3rdparty/openexr/IlmImf/ImfRleCompressor.h:58:17: style: The function 'numScanLines' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int numScanLines () const;
                ^
3rdparty/openexr/IlmImf/ImfCompressor.h:79:18: note: Virtual function in base class
    virtual int  numScanLines () const = 0;
                 ^
3rdparty/openexr/IlmImf/ImfRleCompressor.h:58:17: note: Function in derived class
    virtual int numScanLines () const;
                ^
3rdparty/openexr/IlmImf/ImfRleCompressor.h:60:17: style: The function 'compress' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int compress (const char *inPtr,
                ^
3rdparty/openexr/IlmImf/ImfCompressor.h:158:18: note: Virtual function in base class
    virtual int  compress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfRleCompressor.h:60:17: note: Function in derived class
    virtual int compress (const char *inPtr,
                ^
3rdparty/openexr/IlmImf/ImfRleCompressor.h:65:17: style: The function 'uncompress' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int uncompress (const char *inPtr,
                ^
3rdparty/openexr/IlmImf/ImfCompressor.h:184:18: note: Virtual function in base class
    virtual int  uncompress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfRleCompressor.h:65:17: note: Function in derived class
    virtual int uncompress (const char *inPtr,
                ^
3rdparty/openexr/IlmImf/ImfZipCompressor.h:61:17: style: The function 'numScanLines' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int numScanLines () const;
                ^
3rdparty/openexr/IlmImf/ImfCompressor.h:79:18: note: Virtual function in base class
    virtual int  numScanLines () const = 0;
                 ^
3rdparty/openexr/IlmImf/ImfZipCompressor.h:61:17: note: Function in derived class
    virtual int numScanLines () const;
                ^
3rdparty/openexr/IlmImf/ImfZipCompressor.h:63:17: style: The function 'compress' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int compress (const char *inPtr,
                ^
3rdparty/openexr/IlmImf/ImfCompressor.h:158:18: note: Virtual function in base class
    virtual int  compress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfZipCompressor.h:63:17: note: Function in derived class
    virtual int compress (const char *inPtr,
                ^
3rdparty/openexr/IlmImf/ImfZipCompressor.h:68:17: style: The function 'uncompress' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int uncompress (const char *inPtr,
                ^
3rdparty/openexr/IlmImf/ImfCompressor.h:184:18: note: Virtual function in base class
    virtual int  uncompress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfZipCompressor.h:68:17: note: Function in derived class
    virtual int uncompress (const char *inPtr,
                ^
3rdparty/openexr/IlmImf/ImfPizCompressor.h:62:18: style: The function 'numScanLines' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  numScanLines () const;
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:79:18: note: Virtual function in base class
    virtual int  numScanLines () const = 0;
                 ^
3rdparty/openexr/IlmImf/ImfPizCompressor.h:62:18: note: Function in derived class
    virtual int  numScanLines () const;
                 ^
3rdparty/openexr/IlmImf/ImfPizCompressor.h:64:20: style: The function 'format' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual Format format () const;
                   ^
3rdparty/openexr/IlmImf/ImfCompressor.h:95:20: note: Virtual function in base class
    virtual Format format () const;
                   ^
3rdparty/openexr/IlmImf/ImfPizCompressor.h:64:20: note: Function in derived class
    virtual Format format () const;
                   ^
3rdparty/openexr/IlmImf/ImfPizCompressor.h:66:18: style: The function 'compress' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  compress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:158:18: note: Virtual function in base class
    virtual int  compress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPizCompressor.h:66:18: note: Function in derived class
    virtual int  compress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPizCompressor.h:71:18: style: The function 'compressTile' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  compressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:163:18: note: Virtual function in base class
    virtual int  compressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPizCompressor.h:71:18: note: Function in derived class
    virtual int  compressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPizCompressor.h:76:18: style: The function 'uncompress' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  uncompress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:184:18: note: Virtual function in base class
    virtual int  uncompress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPizCompressor.h:76:18: note: Function in derived class
    virtual int  uncompress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPizCompressor.h:81:18: style: The function 'uncompressTile' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  uncompressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:189:18: note: Virtual function in base class
    virtual int  uncompressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPizCompressor.h:81:18: note: Function in derived class
    virtual int  uncompressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.h:60:18: style: The function 'numScanLines' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  numScanLines () const;
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:79:18: note: Virtual function in base class
    virtual int  numScanLines () const = 0;
                 ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.h:60:18: note: Function in derived class
    virtual int  numScanLines () const;
                 ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.h:62:20: style: The function 'format' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual Format format () const;
                   ^
3rdparty/openexr/IlmImf/ImfCompressor.h:95:20: note: Virtual function in base class
    virtual Format format () const;
                   ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.h:62:20: note: Function in derived class
    virtual Format format () const;
                   ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.h:64:18: style: The function 'compress' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  compress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:158:18: note: Virtual function in base class
    virtual int  compress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.h:64:18: note: Function in derived class
    virtual int  compress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.h:69:18: style: The function 'compressTile' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  compressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:163:18: note: Virtual function in base class
    virtual int  compressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.h:69:18: note: Function in derived class
    virtual int  compressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.h:74:18: style: The function 'uncompress' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  uncompress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:184:18: note: Virtual function in base class
    virtual int  uncompress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.h:74:18: note: Function in derived class
    virtual int  uncompress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.h:79:18: style: The function 'uncompressTile' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  uncompressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:189:18: note: Virtual function in base class
    virtual int  uncompressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.h:79:18: note: Function in derived class
    virtual int  uncompressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfB44Compressor.h:63:18: style: The function 'numScanLines' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  numScanLines () const;
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:79:18: note: Virtual function in base class
    virtual int  numScanLines () const = 0;
                 ^
3rdparty/openexr/IlmImf/ImfB44Compressor.h:63:18: note: Function in derived class
    virtual int  numScanLines () const;
                 ^
3rdparty/openexr/IlmImf/ImfB44Compressor.h:65:20: style: The function 'format' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual Format format () const;
                   ^
3rdparty/openexr/IlmImf/ImfCompressor.h:95:20: note: Virtual function in base class
    virtual Format format () const;
                   ^
3rdparty/openexr/IlmImf/ImfB44Compressor.h:65:20: note: Function in derived class
    virtual Format format () const;
                   ^
3rdparty/openexr/IlmImf/ImfB44Compressor.h:67:18: style: The function 'compress' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  compress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:158:18: note: Virtual function in base class
    virtual int  compress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfB44Compressor.h:67:18: note: Function in derived class
    virtual int  compress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfB44Compressor.h:72:18: style: The function 'compressTile' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  compressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:163:18: note: Virtual function in base class
    virtual int  compressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfB44Compressor.h:72:18: note: Function in derived class
    virtual int  compressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfB44Compressor.h:77:18: style: The function 'uncompress' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  uncompress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:184:18: note: Virtual function in base class
    virtual int  uncompress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfB44Compressor.h:77:18: note: Function in derived class
    virtual int  uncompress (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfB44Compressor.h:82:18: style: The function 'uncompressTile' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int  uncompressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfCompressor.h:189:18: note: Virtual function in base class
    virtual int  uncompressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfB44Compressor.h:82:18: note: Function in derived class
    virtual int  uncompressTile (const char *inPtr,
                 ^
3rdparty/openexr/IlmImf/ImfFrameBuffer.h:225:5: style: Class 'Iterator' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Iterator (const FrameBuffer::SliceMap::iterator &i);
    ^
3rdparty/openexr/IlmImf/ImfFrameBuffer.h:246:5: style: Class 'ConstIterator' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ConstIterator (const FrameBuffer::SliceMap::const_iterator &i);
    ^
3rdparty/openexr/IlmImf/ImfFrameBuffer.h:247:5: style: Class 'ConstIterator' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ConstIterator (const FrameBuffer::Iterator &other);
    ^
3rdparty/openexr/IlmImf/ImfAutoArray.h:64:20: warning: Class 'AutoArray < int , HUF_ENCSIZE >' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
     AutoArray (): _data (new T [size]) { memset(_data, 0, size*sizeof(T)); }
                   ^
3rdparty/openexr/IlmImf/ImfAutoArray.h:64:20: warning: Class 'AutoArray < int , HUF_ENCSIZE >' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
     AutoArray (): _data (new T [size]) { memset(_data, 0, size*sizeof(T)); }
                   ^
3rdparty/openexr/IlmImf/ImfAutoArray.h:64:20: warning: Class 'AutoArray < Int64 * , HUF_ENCSIZE >' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
     AutoArray (): _data (new T [size]) { memset(_data, 0, size*sizeof(T)); }
                   ^
3rdparty/openexr/IlmImf/ImfAutoArray.h:64:20: warning: Class 'AutoArray < Int64 * , HUF_ENCSIZE >' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
     AutoArray (): _data (new T [size]) { memset(_data, 0, size*sizeof(T)); }
                   ^
3rdparty/openexr/IlmImf/ImfAutoArray.h:64:20: warning: Class 'AutoArray < Int64 , HUF_ENCSIZE >' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
     AutoArray (): _data (new T [size]) { memset(_data, 0, size*sizeof(T)); }
                   ^
3rdparty/openexr/IlmImf/ImfAutoArray.h:64:20: warning: Class 'AutoArray < Int64 , HUF_ENCSIZE >' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
     AutoArray (): _data (new T [size]) { memset(_data, 0, size*sizeof(T)); }
                   ^
3rdparty/openexr/IlmImf/ImfAutoArray.h:64:20: warning: Class 'AutoArray < HufDec , HUF_DECSIZE >' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
     AutoArray (): _data (new T [size]) { memset(_data, 0, size*sizeof(T)); }
                   ^
3rdparty/openexr/IlmImf/ImfAutoArray.h:64:20: warning: Class 'AutoArray < HufDec , HUF_DECSIZE >' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
     AutoArray (): _data (new T [size]) { memset(_data, 0, size*sizeof(T)); }
                   ^
3rdparty/openexr/IlmImf/ImfInputFile.cpp:100:18: warning: Member variable 'Data::version' is not initialized in the constructor. [uninitMemberVar]
InputFile::Data::Data (bool del, int numThreads):
                 ^
3rdparty/openexr/IlmImf/ImfInputFile.cpp:100:18: warning: Member variable 'Data::lineOrder' is not initialized in the constructor. [uninitMemberVar]
InputFile::Data::Data (bool del, int numThreads):
                 ^
3rdparty/openexr/IlmImf/ImfInputFile.cpp:100:18: warning: Member variable 'Data::minY' is not initialized in the constructor. [uninitMemberVar]
InputFile::Data::Data (bool del, int numThreads):
                 ^
3rdparty/openexr/IlmImf/ImfInputFile.cpp:100:18: warning: Member variable 'Data::maxY' is not initialized in the constructor. [uninitMemberVar]
InputFile::Data::Data (bool del, int numThreads):
                 ^
3rdparty/openexr/IlmImf/ImfInputFile.cpp:100:18: warning: Member variable 'Data::offset' is not initialized in the constructor. [uninitMemberVar]
InputFile::Data::Data (bool del, int numThreads):
                 ^
3rdparty/openexr/IlmImf/ImfInputFile.h:199:22: style: Unused private function: 'InputFile::tFile' [unusedPrivateFunction]
    TiledInputFile * tFile ();
                     ^
3rdparty/openexr/IlmImf/ImfHeader.h:371:5: style: Class 'Iterator' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Iterator (const Header::AttributeMap::iterator &i);
    ^
3rdparty/openexr/IlmImf/ImfHeader.h:392:5: style: Class 'ConstIterator' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ConstIterator (const Header::AttributeMap::const_iterator &i);
    ^
3rdparty/openexr/IlmImf/ImfHeader.h:393:5: style: Class 'ConstIterator' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ConstIterator (const Header::Iterator &other);
    ^
3rdparty/openexr/IlmImf/ImfInputFile.h:71:5: style: Class 'InputFile' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    InputFile (const char fileName[], int numThreads = globalThreadCount());
    ^
3rdparty/openexr/IlmImf/ImfInputFile.h:83:5: style: Class 'InputFile' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    InputFile (IStream &is, int numThreads = globalThreadCount());
    ^
3rdparty/openexr/IlmImf/ImfTiledInputFile.h:68:5: style: Class 'TiledInputFile' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    TiledInputFile (const char fileName[],
    ^
3rdparty/openexr/IlmImf/ImfTiledInputFile.h:80:5: style: Class 'TiledInputFile' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    TiledInputFile (IStream &is, int numThreads = globalThreadCount ());
    ^
3rdparty/openexr/IlmImf/ImfStdIO.h:66:5: style: Class 'StdIFStream' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    StdIFStream (const char fileName[]);
    ^
3rdparty/openexr/IlmImf/ImfStdIO.h:106:5: style: Class 'StdOFStream' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    StdOFStream (const char fileName[]);
    ^
3rdparty/openexr/IlmImf/ImfStdIO.h:80:18: style: The function 'read' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool read (char c[/*n*/], int n);
                 ^
3rdparty/openexr/IlmImf/ImfIO.h:87:18: note: Virtual function in base class
    virtual bool read (char c[/*n*/], int n) = 0;
                 ^
3rdparty/openexr/IlmImf/ImfStdIO.h:80:18: note: Function in derived class
    virtual bool read (char c[/*n*/], int n);
                 ^
3rdparty/openexr/IlmImf/ImfStdIO.h:81:19: style: The function 'tellg' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual Int64 tellg ();
                  ^
3rdparty/openexr/IlmImf/ImfIO.h:110:19: note: Virtual function in base class
    virtual Int64 tellg () = 0;
                  ^
3rdparty/openexr/IlmImf/ImfStdIO.h:81:19: note: Function in derived class
    virtual Int64 tellg ();
                  ^
3rdparty/openexr/IlmImf/ImfStdIO.h:82:18: style: The function 'seekg' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void seekg (Int64 pos);
                 ^
3rdparty/openexr/IlmImf/ImfIO.h:118:18: note: Virtual function in base class
    virtual void seekg (Int64 pos) = 0;
                 ^
3rdparty/openexr/IlmImf/ImfStdIO.h:82:18: note: Function in derived class
    virtual void seekg (Int64 pos);
                 ^
3rdparty/openexr/IlmImf/ImfStdIO.h:83:18: style: The function 'clear' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void clear ();
                 ^
3rdparty/openexr/IlmImf/ImfIO.h:125:18: note: Virtual function in base class
    virtual void clear ();
                 ^
3rdparty/openexr/IlmImf/ImfStdIO.h:83:18: note: Function in derived class
    virtual void clear ();
                 ^
3rdparty/openexr/IlmImf/ImfStdIO.h:120:18: style: The function 'write' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void write (const char c[/*n*/], int n);
                 ^
3rdparty/openexr/IlmImf/ImfIO.h:170:18: note: Virtual function in base class
    virtual void write (const char c[/*n*/], int n) = 0;
                 ^
3rdparty/openexr/IlmImf/ImfStdIO.h:120:18: note: Function in derived class
    virtual void write (const char c[/*n*/], int n);
                 ^
3rdparty/openexr/IlmImf/ImfStdIO.h:121:19: style: The function 'tellp' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual Int64 tellp ();
                  ^
3rdparty/openexr/IlmImf/ImfIO.h:180:19: note: Virtual function in base class
    virtual Int64 tellp () = 0;
                  ^
3rdparty/openexr/IlmImf/ImfStdIO.h:121:19: note: Function in derived class
    virtual Int64 tellp ();
                  ^
3rdparty/openexr/IlmImf/ImfStdIO.h:122:18: style: The function 'seekp' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void seekp (Int64 pos);
                 ^
3rdparty/openexr/IlmImf/ImfIO.h:188:18: note: Virtual function in base class
    virtual void seekp (Int64 pos) = 0;
                 ^
3rdparty/openexr/IlmImf/ImfStdIO.h:122:18: note: Function in derived class
    virtual void seekp (Int64 pos);
                 ^
3rdparty/openexr/IlmImf/ImfStdIO.h:142:18: style: The function 'write' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void write (const char c[/*n*/], int n);
                 ^
3rdparty/openexr/IlmImf/ImfIO.h:170:18: note: Virtual function in base class
    virtual void write (const char c[/*n*/], int n) = 0;
                 ^
3rdparty/openexr/IlmImf/ImfStdIO.h:142:18: note: Function in derived class
    virtual void write (const char c[/*n*/], int n);
                 ^
3rdparty/openexr/IlmImf/ImfStdIO.h:143:19: style: The function 'tellp' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual Int64 tellp ();
                  ^
3rdparty/openexr/IlmImf/ImfIO.h:180:19: note: Virtual function in base class
    virtual Int64 tellp () = 0;
                  ^
3rdparty/openexr/IlmImf/ImfStdIO.h:143:19: note: Function in derived class
    virtual Int64 tellp ();
                  ^
3rdparty/openexr/IlmImf/ImfStdIO.h:144:18: style: The function 'seekp' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void seekp (Int64 pos);
                 ^
3rdparty/openexr/IlmImf/ImfIO.h:188:18: note: Virtual function in base class
    virtual void seekp (Int64 pos) = 0;
                 ^
3rdparty/openexr/IlmImf/ImfStdIO.h:144:18: note: Function in derived class
    virtual void seekp (Int64 pos);
                 ^
3rdparty/openexr/IlmImf/ImfInputFile.cpp:155:21: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
        delete [] (((float *)s.base) + offset);
                    ^
3rdparty/openexr/IlmImf/ImfInputFile.cpp:259:29: style: The scope of the variable 'toPtr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            char *fromPtr, *toPtr;
                            ^
3rdparty/openexr/IlmImf/ImfInputFile.cpp:263:13: style: Local variable 'yStart' shadows outer variable [shadowVariable]
        int yStart = minYThisRow;
            ^
3rdparty/openexr/IlmImf/ImfInputFile.cpp:203:9: note: Shadowed declaration
    int yStart, yEnd, yStep;
        ^
3rdparty/openexr/IlmImf/ImfInputFile.cpp:263:13: note: Shadow variable
        int yStart = minYThisRow;
            ^
3rdparty/openexr/IlmImf/ImfRgbaFile.h:239:5: style: Class 'RgbaInputFile' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    RgbaInputFile (const char name[], int numThreads = globalThreadCount());
    ^
3rdparty/openexr/IlmImf/ImfRgbaFile.h:249:5: style: Class 'RgbaInputFile' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    RgbaInputFile (IStream &is, int numThreads = globalThreadCount());
    ^
3rdparty/openexr/IlmImf/ImfLut.h:68:5: style: Class 'HalfLut' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    HalfLut (Function f);
    ^
3rdparty/openexr/IlmImf/ImfLut.h:106:5: style: Class 'RgbaLut' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    RgbaLut (Function f, RgbaChannels chn = WRITE_RGB);
    ^
3rdparty/openexr/IlmImf/ImfLut.h:153:5: style: Struct 'roundNBit' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    roundNBit (int n): n(n) {}
    ^
3rdparty/openexr/IlmImf/ImfOutputFile.cpp:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/openexr/IlmImf/ImfXdr.h:452] #error write<T> (T &out, signed long v) not implemented
DEBUG : [3rdparty/openexr/IlmImf/ImfXdr.h:452] #error write<T> (T &out, signed long v) not implemented [noValidConfiguration]

^
3rdparty/openexr/IlmImf/ImfPizCompressor.cpp:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/openexr/IlmImf/ImfXdr.h:452] #error write<T> (T &out, signed long v) not implemented
DEBUG : [3rdparty/openexr/IlmImf/ImfXdr.h:452] #error write<T> (T &out, signed long v) not implemented [noValidConfiguration]

^
3rdparty/openexr/IlmImf/ImfPreviewImage.cpp:88:15: warning: 'operator=' should check for assignment to self to ensure that each block of dynamically allocated memory is owned and managed by only one instance of the class. [operatorEqToSelf]
PreviewImage::operator = (const PreviewImage &other)
              ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.cpp:198:5: warning: Class 'Pxr24Compressor' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    _tmpBuffer = new unsigned char [maxInBytes];
    ^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.cpp:198:5: warning: Class 'Pxr24Compressor' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    _tmpBuffer = new unsigned char [maxInBytes];
    ^
3rdparty/openexr/IlmImf/ImfRational.cpp:100:16: style: Condition 'x<0' is always true [knownConditionTrueFalse]
    else if (x < 0)
               ^
3rdparty/openexr/IlmImf/ImfRleCompressor.cpp:168:5: warning: Class 'RleCompressor' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    _tmpBuffer = new char [maxScanLineSize];
    ^
3rdparty/openexr/IlmImf/ImfRleCompressor.cpp:168:5: warning: Class 'RleCompressor' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    _tmpBuffer = new char [maxScanLineSize];
    ^
3rdparty/openexr/IlmImf/ImfStdIO.cpp:80:22: style: Parameter 'os' can be declared with const [constParameter]
checkError (ostream &os)
                     ^
3rdparty/openexr/IlmImf/ImfTiledOutputFile.cpp:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [3rdparty/openexr/IlmImf/ImfXdr.h:452] #error write<T> (T &out, signed long v) not implemented
DEBUG : [3rdparty/openexr/IlmImf/ImfXdr.h:452] #error write<T> (T &out, signed long v) not implemented [noValidConfiguration]

^
3rdparty/openexr/IlmImf/ImfTimeCode.h:157:5: style: Class 'TimeCode' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    TimeCode (unsigned int timeAndFlags,
    ^
3rdparty/openexr/IlmImf/ImfTimeCode.cpp:350:62: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
    t &= ~((1 << 6) | (1 << 15) | (1 << 23) | (1 << 30) | (1 << 31));
                                                             ^
3rdparty/openexr/IlmImf/ImfTimeCode.cpp:376:62: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
         ~((1 << 6) | (1 << 15) | (1 << 23) | (1 << 30) | (1 << 31));
                                                             ^
3rdparty/openexr/IlmImf/ImfTimeCode.cpp:387:20: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
    if (value & (1 << 31))
                   ^
3rdparty/openexr/IlmImf/ImfZipCompressor.cpp:71:5: warning: Class 'ZipCompressor' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    _tmpBuffer =
    ^
3rdparty/openexr/IlmImf/ImfZipCompressor.cpp:71:5: warning: Class 'ZipCompressor' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    _tmpBuffer =
    ^
3rdparty/openexr/IlmThread/IlmThread.cpp:67:5: warning: The class Thread is not safe because its destructor throws an exception. If Thread is used and an exception is thrown that is caught in an outer scope the program will terminate. [exceptThrowInDestructor]
    throw Iex::NoImplExc ("Threads not supported on this platform.");
    ^
3rdparty/openexr/IlmThread/IlmThreadMutex.h:115:5: style: Class 'Lock' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Lock (const Mutex& m, bool autoLock = true):
    ^
3rdparty/openexr/IlmThread/IlmThreadPool.cpp:328:5: warning: Class 'ThreadPool' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    _data (new Data())
    ^
3rdparty/openexr/IlmThread/IlmThreadPool.cpp:328:5: warning: Class 'ThreadPool' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    _data (new Data())
    ^
3rdparty/openexr/IlmThread/IlmThreadPool.cpp:311:5: warning: Class 'TaskGroup' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    _data (new Data())
    ^
3rdparty/openexr/IlmThread/IlmThreadPool.cpp:311:5: warning: Class 'TaskGroup' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    _data (new Data())
    ^
3rdparty/openexr/IlmThread/IlmThreadPool.cpp:57:5: style: Class 'WorkerThread' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    WorkerThread (ThreadPool::Data* data);
    ^
3rdparty/openexr/IlmThread/IlmThreadSemaphoreWin32.cpp:65:22: style: Variable 'bufferLength' is assigned a value that is never used. [unreadVariable]
    if (bufferLength = FormatMessageA (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                     ^
3rdparty/openexr/Imath/ImathColor.h:447:16: warning: The address of local variable 'r' might be accessed at non-zero index. [objectIndex]
    return (&r)[i];
               ^
3rdparty/openexr/Imath/ImathColor.h:447:13: note: Address of variable taken here.
    return (&r)[i];
            ^
3rdparty/openexr/Imath/ImathColor.h:447:16: note: The address of local variable 'r' might be accessed at non-zero index.
    return (&r)[i];
               ^
3rdparty/openexr/Imath/ImathColor.h:454:16: warning: The address of local variable 'r' might be accessed at non-zero index. [objectIndex]
    return (&r)[i];
               ^
3rdparty/openexr/Imath/ImathColor.h:454:13: note: Address of variable taken here.
    return (&r)[i];
            ^
3rdparty/openexr/Imath/ImathColor.h:454:16: note: The address of local variable 'r' might be accessed at non-zero index.
    return (&r)[i];
               ^
3rdparty/openexr/Imath/ImathVec.h:1276:16: warning: The address of local variable 'x' might be accessed at non-zero index. [objectIndex]
    return (&x)[i];
               ^
3rdparty/openexr/Imath/ImathVec.h:1276:13: note: Address of variable taken here.
    return (&x)[i];
            ^
3rdparty/openexr/Imath/ImathVec.h:1276:16: note: The address of local variable 'x' might be accessed at non-zero index.
    return (&x)[i];
               ^
3rdparty/openexr/Imath/ImathVec.h:1283:16: warning: The address of local variable 'x' might be accessed at non-zero index. [objectIndex]
    return (&x)[i];
               ^
3rdparty/openexr/Imath/ImathVec.h:1283:13: note: Address of variable taken here.
    return (&x)[i];
            ^
3rdparty/openexr/Imath/ImathVec.h:1283:16: note: The address of local variable 'x' might be accessed at non-zero index.
    return (&x)[i];
               ^
3rdparty/openexr/Imath/ImathColor.h:73:5: style: The Color3::operator= does not conform to standard C/C++ behaviour. To conform to standard C/C++ behaviour, return a reference to self (such as: 'Color3 &Color3::operator=(..) { .. return *this; }'. For safety reasons it might be better to not fix this message. If you think that safety is always more important than conformance then please ignore/suppress this message. For more details about this topic, see the book "Effective C++" by Scott Meyers. [operatorEq]
    const Color3 & operator = (const Color3 &c);
    ^
3rdparty/openexr/Imath/ImathColor.h:71:24: style: Class 'Color3' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    template <class S> Color3 (const Vec3<S> &v);
                       ^
3rdparty/openexr/Imath/ImathColor.h:148:24: style: Class 'Color4 < double >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    template <class S> Color4 (const Color4<S> &v);
                       ^
3rdparty/openexr/Imath/ImathVec.h:294:24: style: Class 'Vec3 < short >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    template <class S> Vec3 (const Vec3<S> &v);
                       ^
3rdparty/openexr/Imath/ImathVec.h:294:24: style: Class 'Vec3 < int >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    template <class S> Vec3 (const Vec3<S> &v);
                       ^
3rdparty/openexr/Imath/ImathVec.h:294:24: style: Class 'Vec3 < double >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    template <class S> Vec3 (const Vec3<S> &v);
                       ^
3rdparty/openexr/Imath/ImathVec.h:1770:16: warning: The address of local variable 'x' might be accessed at non-zero index. [objectIndex]
    return (&x)[i];
               ^
3rdparty/openexr/Imath/ImathVec.h:1770:13: note: Address of variable taken here.
    return (&x)[i];
            ^
3rdparty/openexr/Imath/ImathVec.h:1770:16: note: The address of local variable 'x' might be accessed at non-zero index.
    return (&x)[i];
               ^
3rdparty/openexr/Imath/ImathVec.h:1777:16: warning: The address of local variable 'x' might be accessed at non-zero index. [objectIndex]
    return (&x)[i];
               ^
3rdparty/openexr/Imath/ImathVec.h:1777:13: note: Address of variable taken here.
    return (&x)[i];
            ^
3rdparty/openexr/Imath/ImathVec.h:1777:16: note: The address of local variable 'x' might be accessed at non-zero index.
    return (&x)[i];
               ^
3rdparty/openexr/Imath/ImathMatrix.h:446:5: warning: Member variable 'Matrix44 < float >::x' is not initialized in the constructor. [uninitMemberVar]
    Matrix44 (Uninitialized) {}
    ^
3rdparty/openexr/Imath/ImathMatrix.h:446:5: warning: Member variable 'Matrix44 < double >::x' is not initialized in the constructor. [uninitMemberVar]
    Matrix44 (Uninitialized) {}
    ^
3rdparty/openexr/Imath/ImathMatrix.h:86:5: warning: Member variable 'Matrix33 < float >::x' is not initialized in the constructor. [uninitMemberVar]
    Matrix33 (Uninitialized) {}
    ^
3rdparty/openexr/Imath/ImathMatrix.h:86:5: warning: Member variable 'Matrix33 < double >::x' is not initialized in the constructor. [uninitMemberVar]
    Matrix33 (Uninitialized) {}
    ^
3rdparty/openexr/Imath/ImathVec.h:1297:13: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'z' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    x = y = z = a;
            ^
3rdparty/openexr/Imath/ImathVec.h:1304:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'x' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    x = a;
    ^
3rdparty/openexr/Imath/ImathVec.h:1305:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'y' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    y = b;
    ^
3rdparty/openexr/Imath/ImathVec.h:1306:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'z' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    z = c;
    ^
3rdparty/openexr/Imath/ImathVec.h:1313:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'x' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    x = v.x;
    ^
3rdparty/openexr/Imath/ImathVec.h:1314:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'y' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    y = v.y;
    ^
3rdparty/openexr/Imath/ImathVec.h:1315:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'z' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    z = v.z;
    ^
3rdparty/openexr/Imath/ImathVec.h:1323:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'x' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    x = T (v.x);
    ^
3rdparty/openexr/Imath/ImathVec.h:1343:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'x' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    x = T (v.x / v.w);
    ^
3rdparty/openexr/Imath/ImathEuler.h:220:5: style: Class 'Euler' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Euler(Order p);
    ^
3rdparty/openexr/Imath/ImathEuler.h:221:5: style: Class 'Euler' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Euler(const Vec3<T> &v, Order o = Default, InputLayout l = IJKLayout);
    ^
3rdparty/openexr/Imath/ImathEuler.h:224:5: style: Class 'Euler' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Euler(const Matrix33<T> &, Order o = Default);
    ^
3rdparty/openexr/Imath/ImathEuler.h:225:5: style: Class 'Euler' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Euler(const Matrix44<T> &, Order o = Default);
    ^
3rdparty/openexr/Imath/ImathMatrix.h:446:5: style: Class 'Matrix44 < float >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Matrix44 (Uninitialized) {}
    ^
3rdparty/openexr/Imath/ImathMatrix.h:454:5: style: Class 'Matrix44 < float >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Matrix44 (T a);
    ^
3rdparty/openexr/Imath/ImathMatrix.h:460:5: style: Class 'Matrix44 < float >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Matrix44 (const T a[4][4]) ;
    ^
3rdparty/openexr/Imath/ImathMatrix.h:446:5: style: Class 'Matrix44 < double >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Matrix44 (Uninitialized) {}
    ^
3rdparty/openexr/Imath/ImathMatrix.h:454:5: style: Class 'Matrix44 < double >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Matrix44 (T a);
    ^
3rdparty/openexr/Imath/ImathMatrix.h:460:5: style: Class 'Matrix44 < double >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Matrix44 (const T a[4][4]) ;
    ^
3rdparty/openexr/Imath/ImathMatrix.h:86:5: style: Class 'Matrix33 < float >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Matrix33 (Uninitialized) {}
    ^
3rdparty/openexr/Imath/ImathMatrix.h:93:5: style: Class 'Matrix33 < float >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Matrix33 (T a);
    ^
3rdparty/openexr/Imath/ImathMatrix.h:98:5: style: Class 'Matrix33 < float >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Matrix33 (const T a[3][3]);
    ^
3rdparty/openexr/Imath/ImathMatrix.h:86:5: style: Class 'Matrix33 < double >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Matrix33 (Uninitialized) {}
    ^
3rdparty/openexr/Imath/ImathMatrix.h:93:5: style: Class 'Matrix33 < double >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Matrix33 (T a);
    ^
3rdparty/openexr/Imath/ImathMatrix.h:98:5: style: Class 'Matrix33 < double >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Matrix33 (const T a[3][3]);
    ^
3rdparty/openexr/Imath/ImathVec.h:507:24: style: Class 'Vec4 < short >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    template <class S> Vec4 (const Vec4<S> &v);
                       ^
3rdparty/openexr/Imath/ImathVec.h:507:24: style: Class 'Vec4 < int >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    template <class S> Vec4 (const Vec4<S> &v);
                       ^
3rdparty/openexr/Imath/ImathVec.h:507:24: style: Class 'Vec4 < float >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    template <class S> Vec4 (const Vec4<S> &v);
                       ^
3rdparty/openexr/Imath/ImathVec.h:507:24: style: Class 'Vec4 < double >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    template <class S> Vec4 (const Vec4<S> &v);
                       ^
3rdparty/openexr/Imath/ImathQuat.h:384:38: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
    return Math<T>::sqrt (r * r + (v ^ v));
                                     ^
3rdparty/openexr/Imath/ImathQuat.h:428:20: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
    T qdot = *this ^ *this;
                   ^
3rdparty/openexr/Imath/ImathQuat.h:437:22: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
    T qdot = (*this) ^ (*this);
                     ^
3rdparty/openexr/Imath/ImathMatrixAlgo.h:692:10: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int    i, j, k;
         ^
3rdparty/openexr/Imath/ImathMatrixAlgo.h:692:13: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int    i, j, k;
            ^
3rdparty/openexr/Imath/ImathMatrixAlgo.h:692:16: style: The scope of the variable 'k' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int    i, j, k;
               ^
3rdparty/openexr/Imath/ImathQuat.h:580:23: warning: Function 'squad' argument order different: declaration 'q1, q2, qa, qb, t' definition 'q1, qa, qb, q2, t' [funcArgOrderDifferent]
squad (const Quat<T> &q1, const Quat<T> &qa,
                      ^
3rdparty/openexr/Imath/ImathQuat.h:168:33: note: Function 'squad' argument order different: declaration 'q1, q2, qa, qb, t' definition 'q1, qa, qb, q2, t'
Quat<T>   squad (const Quat<T> &q1, const Quat<T> &q2,
                                ^
3rdparty/openexr/Imath/ImathQuat.h:580:23: note: Function 'squad' argument order different: declaration 'q1, q2, qa, qb, t' definition 'q1, qa, qb, q2, t'
squad (const Quat<T> &q1, const Quat<T> &qa,
                      ^
3rdparty/openexr/Imath/ImathEuler.h:787:21: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    set( p & 0x2000 ? Z : (p & 0x1000 ? Y : X), // initial axis
                    ^
3rdparty/openexr/Imath/ImathVec.h:855:16: warning: The address of local variable 'x' might be accessed at non-zero index. [objectIndex]
    return (&x)[i];
               ^
3rdparty/openexr/Imath/ImathVec.h:855:13: note: Address of variable taken here.
    return (&x)[i];
            ^
3rdparty/openexr/Imath/ImathVec.h:855:16: note: The address of local variable 'x' might be accessed at non-zero index.
    return (&x)[i];
               ^
3rdparty/openexr/Imath/ImathVec.h:862:16: warning: The address of local variable 'x' might be accessed at non-zero index. [objectIndex]
    return (&x)[i];
               ^
3rdparty/openexr/Imath/ImathVec.h:862:13: note: Address of variable taken here.
    return (&x)[i];
            ^
3rdparty/openexr/Imath/ImathVec.h:862:16: note: The address of local variable 'x' might be accessed at non-zero index.
    return (&x)[i];
               ^
3rdparty/openexr/Imath/ImathVec.h:1819:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'x' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    x = T (v.x);
    ^
3rdparty/openexr/Imath/ImathVec.h:96:24: style: Class 'Vec2 < short >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    template <class S> Vec2 (const Vec2<S> &v);
                       ^
3rdparty/openexr/Imath/ImathVec.h:96:24: style: Class 'Vec2 < int >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    template <class S> Vec2 (const Vec2<S> &v);
                       ^
3rdparty/openvx/hal/openvx_hal.cpp:120:5: style: Class 'vxImage' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    vxImage(const ivx::Image &_img) : ivx::Image(_img) {}
    ^
3rdparty/openvx/hal/openvx_hal.cpp:568:23: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    *filter_context = (cvhalFilter2D*)(cnv);
                      ^
3rdparty/openvx/hal/openvx_hal.cpp:576:16: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        delete (FilterCtx*)filter_context;
               ^
3rdparty/openvx/hal/openvx_hal.cpp:593:26: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        FilterCtx* cnv = (FilterCtx*)filter_context;
                         ^
3rdparty/openvx/hal/openvx_hal.cpp:673:23: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    *filter_context = (cvhalFilter2D*)(cnv);
                      ^
3rdparty/openvx/hal/openvx_hal.cpp:503:59: performance: Parameter 'data' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
    FilterCtx(ivx::Context &ctx, const std::vector<short> data, int w, int h, int _dst_type, ivx::border_t & _border) :
                                                          ^
3rdparty/openvx/hal/openvx_hal.cpp:503:110: style: Parameter '_border' can be declared with const [constParameter]
    FilterCtx(ivx::Context &ctx, const std::vector<short> data, int w, int h, int _dst_type, ivx::border_t & _border) :
                                                                                                             ^
3rdparty/protobuf/src/google/protobuf/descriptor.cc:3349:20: warning: Member variable 'DescriptorBuilder::file_' is not initialized in the constructor. [uninitMemberVar]
DescriptorBuilder::DescriptorBuilder(
                   ^
3rdparty/protobuf/src/google/protobuf/descriptor.cc:3349:20: warning: Member variable 'DescriptorBuilder::file_tables_' is not initialized in the constructor. [uninitMemberVar]
DescriptorBuilder::DescriptorBuilder(
                   ^
3rdparty/protobuf/src/google/protobuf/descriptor.cc:5710:39: warning: Member variable 'OptionInterpreter::options_to_interpret_' is not initialized in the constructor. [uninitMemberVar]
DescriptorBuilder::OptionInterpreter::OptionInterpreter(
                                      ^
3rdparty/protobuf/src/google/protobuf/descriptor.cc:5710:39: warning: Member variable 'OptionInterpreter::uninterpreted_option_' is not initialized in the constructor. [uninitMemberVar]
DescriptorBuilder::OptionInterpreter::OptionInterpreter(
                                      ^
3rdparty/protobuf/src/google/protobuf/descriptor.cc:244:3: style: Class 'PrefixRemover' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
  PrefixRemover(StringPiece prefix) {
  ^
3rdparty/protobuf/src/google/protobuf/descriptor.cc:4153:7: style: The if condition is the same as the previous if condition [duplicateCondition]
  if (!had_errors_) {
      ^
3rdparty/protobuf/src/google/protobuf/descriptor.cc:4142:7: note: First condition
  if (!had_errors_) {
      ^
3rdparty/protobuf/src/google/protobuf/descriptor.cc:4153:7: note: Second condition
  if (!had_errors_) {
      ^
3rdparty/protobuf/src/google/protobuf/dynamic_message.cc:243:5: warning: Member variable 'TypeInfo::size' is not initialized in the constructor. [uninitMemberVar]
    TypeInfo() : prototype(NULL), default_oneof_instance(NULL) {}
    ^
3rdparty/protobuf/src/google/protobuf/dynamic_message.cc:243:5: warning: Member variable 'TypeInfo::has_bits_offset' is not initialized in the constructor. [uninitMemberVar]
    TypeInfo() : prototype(NULL), default_oneof_instance(NULL) {}
    ^
3rdparty/protobuf/src/google/protobuf/dynamic_message.cc:243:5: warning: Member variable 'TypeInfo::oneof_case_offset' is not initialized in the constructor. [uninitMemberVar]
    TypeInfo() : prototype(NULL), default_oneof_instance(NULL) {}
    ^
3rdparty/protobuf/src/google/protobuf/dynamic_message.cc:243:5: warning: Member variable 'TypeInfo::unknown_fields_offset' is not initialized in the constructor. [uninitMemberVar]
    TypeInfo() : prototype(NULL), default_oneof_instance(NULL) {}
    ^
3rdparty/protobuf/src/google/protobuf/dynamic_message.cc:243:5: warning: Member variable 'TypeInfo::extensions_offset' is not initialized in the constructor. [uninitMemberVar]
    TypeInfo() : prototype(NULL), default_oneof_instance(NULL) {}
    ^
3rdparty/protobuf/src/google/protobuf/dynamic_message.cc:243:5: warning: Member variable 'TypeInfo::factory' is not initialized in the constructor. [uninitMemberVar]
    TypeInfo() : prototype(NULL), default_oneof_instance(NULL) {}
    ^
3rdparty/protobuf/src/google/protobuf/dynamic_message.cc:243:5: warning: Member variable 'TypeInfo::pool' is not initialized in the constructor. [uninitMemberVar]
    TypeInfo() : prototype(NULL), default_oneof_instance(NULL) {}
    ^
3rdparty/protobuf/src/google/protobuf/dynamic_message.cc:243:5: warning: Member variable 'TypeInfo::type' is not initialized in the constructor. [uninitMemberVar]
    TypeInfo() : prototype(NULL), default_oneof_instance(NULL) {}
    ^
3rdparty/protobuf/src/google/protobuf/dynamic_message.cc:251:3: style: Class 'DynamicMessage' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
  DynamicMessage(const TypeInfo* type_info);
  ^
3rdparty/protobuf/src/google/protobuf/struct.pb.cc:800:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed. [duplicateBreak]
        break;
        ^
3rdparty/protobuf/src/google/protobuf/struct.pb.cc:815:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed. [duplicateBreak]
        break;
        ^
3rdparty/protobuf/src/google/protobuf/struct.pb.cc:831:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed. [duplicateBreak]
        break;
        ^
3rdparty/protobuf/src/google/protobuf/struct.pb.cc:846:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed. [duplicateBreak]
        break;
        ^
3rdparty/protobuf/src/google/protobuf/stubs/stringprintf.cc:75:9: style: Condition 'IS_COMPILER_MSVC' is always false [knownConditionTrueFalse]
    if (IS_COMPILER_MSVC) {
        ^
3rdparty/protobuf/src/google/protobuf/stubs/stringprintf.cc:163:52: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [knownConditionTrueFalse]
  GOOGLE_COMPILE_ASSERT(kStringPrintfVectorMaxArgs == 32, arg_count_mismatch);
                                                   ^
3rdparty/protobuf/src/google/protobuf/stubs/stringprintf.cc:133:40: note: 'kStringPrintfVectorMaxArgs' is assigned value '32' here.
const int kStringPrintfVectorMaxArgs = 32;
                                       ^
3rdparty/protobuf/src/google/protobuf/stubs/stringprintf.cc:163:52: note: The expression 'kStringPrintfVectorMaxArgs == 32' is always true.
  GOOGLE_COMPILE_ASSERT(kStringPrintfVectorMaxArgs == 32, arg_count_mismatch);
                                                   ^
3rdparty/protobuf/src/google/protobuf/stubs/stringprintf.cc:75:9: style: Condition 'IS_COMPILER_MSVC' is always true [knownConditionTrueFalse]
    if (IS_COMPILER_MSVC) {
        ^
3rdparty/protobuf/src/google/protobuf/stubs/stringprintf.cc:64:3: error: va_list 'backup_ap' used before va_start() was called. [va_list_usedBeforeStarted]
  va_copy(backup_ap, ap);
  ^
3rdparty/protobuf/src/google/protobuf/stubs/stringprintf.cc:65:55: error: va_list 'backup_ap' used before va_start() was called. [va_list_usedBeforeStarted]
  int result = vsnprintf(space, kSpaceLength, format, backup_ap);
                                                      ^
3rdparty/protobuf/src/google/protobuf/stubs/stringprintf.cc:66:3: error: va_list 'backup_ap' used before va_start() was called. [va_list_usedBeforeStarted]
  va_end(backup_ap);
  ^
3rdparty/protobuf/src/google/protobuf/stubs/structurally_valid.cc:479:7: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int n;
      ^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:1291:9: style: Local variable 'snprintf_result' shadows outer variable [shadowVariable]
    int snprintf_result =
        ^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:1276:7: note: Shadowed declaration
  int snprintf_result =
      ^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:1291:9: note: Shadow variable
    int snprintf_result =
        ^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:1403:9: style: Local variable 'snprintf_result' shadows outer variable [shadowVariable]
    int snprintf_result =
        ^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:1394:7: note: Shadowed declaration
  int snprintf_result =
      ^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:1403:9: note: Shadow variable
    int snprintf_result =
        ^
3rdparty/protobuf/src/google/protobuf/util/internal/default_value_objectwriter.cc:592:11: style: Variable 'child' is assigned a value that is never used. [unreadVariable]
    child = node.get();
          ^
3rdparty/protobuf/src/google/protobuf/util/internal/protostream_objectsource.cc:215:11: style: Condition 'check_maps' is always true [knownConditionTrueFalse]
      if (check_maps && IsMap(*field)) {
          ^
3rdparty/protobuf/src/google/protobuf/util/internal/protostream_objectsource.cc:213:25: note: Assignment 'check_maps=true', assigned value is 1
      bool check_maps = true;
                        ^
3rdparty/protobuf/src/google/protobuf/util/internal/protostream_objectsource.cc:215:11: note: Condition 'check_maps' is always true
      if (check_maps && IsMap(*field)) {
          ^
3rdparty/protobuf/src/google/protobuf/util/message_differencer.cc:157:10: error: Uninitialized variable: differencer [uninitvar]
  return differencer.Compare(message1, message2);
         ^
3rdparty/zlib/adler32.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/adler32.c:69:14: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned n;
             ^
3rdparty/zlib/compress.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/zconf.h:245:0: information: Skipping configuration 'NO_SIZE_T' since the value of 'NO_SIZE_T' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
     typedef unsigned NO_SIZE_T z_size_t;
^
3rdparty/zlib/crc32.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/crc32.c:90:13: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    z_crc_t c;
            ^
3rdparty/zlib/crc32.c:91:9: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int n, k;
        ^
3rdparty/zlib/crc32.c:91:12: style: The scope of the variable 'k' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int n, k;
           ^
3rdparty/zlib/crc32.c:92:13: style: The scope of the variable 'poly' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    z_crc_t poly;                       /* polynomial exclusive-or pattern */
            ^
3rdparty/zlib/crc32.c:95:32: style: The scope of the variable 'p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
                               ^
3rdparty/zlib/crc32.c:112:27: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                c = c & 1 ? poly ^ (c >> 1) : c >> 1;
                          ^
3rdparty/zlib/crc32.c:172:45: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ",
                                            ^
3rdparty/zlib/deflate.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/deflate.c:382:10: style: The scope of the variable 'str' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uInt str, n;
         ^
3rdparty/zlib/deflate.c:382:15: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uInt str, n;
              ^
3rdparty/zlib/deflate.c:548:9: style: The scope of the variable 'put' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int put;
        ^
3rdparty/zlib/deflate.c:1242:21: style: The scope of the variable 'match' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    register Bytef *match;                      /* matched string */
                    ^
3rdparty/zlib/deflate.c:1485:14: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned n;
             ^
3rdparty/zlib/deflate.c:1486:14: style: The scope of the variable 'more' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned more;    /* Amount of free space at the end of the window. */
             ^
3rdparty/zlib/deflate.c:1828:10: style: The scope of the variable 'hash_head' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    IPos hash_head;       /* head of the hash chain */
         ^
3rdparty/zlib/deflate.c:1930:10: style: The scope of the variable 'hash_head' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    IPos hash_head;          /* head of hash chain */
         ^
3rdparty/zlib/deflate.c:2038:9: style: Variable 'bflush' is assigned a value that is never used. [unreadVariable]
        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
        ^
3rdparty/zlib/deflate.c:204:17: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned n, m;
                ^
3rdparty/zlib/deflate.c:214:7: style: Variable 'n' is assigned a value that is never used. [unreadVariable]
    n = wsize;
      ^
3rdparty/zlib/gzclose.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/gzlib.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/gzlib.c:371:14: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned n;
             ^
3rdparty/zlib/gzlib.c:372:15: style: The scope of the variable 'ret' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    z_off64_t ret;
              ^
3rdparty/zlib/gzlib.c:426:0: information: Skipping configuration 'INT_MAX' since the value of 'INT_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
^
3rdparty/zlib/gzread.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/gzread.c:28:14: style: The scope of the variable 'get' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned get, max = ((unsigned)-1 >> 2) + 1;
             ^
3rdparty/zlib/gzread.c:548:20: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned left, n;
                   ^
3rdparty/zlib/gzread.c:550:20: style: The scope of the variable 'eol' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *eol;
                   ^
3rdparty/zlib/gzread.c:438:43: warning: Either the condition 'size' is redundant or there is division by zero at line 438. [zerodivcond]
    return len ? gz_read(state, buf, len) / size : 0;
                                          ^
3rdparty/zlib/gzread.c:432:9: note: Assuming that condition 'size' is not redundant
    if (size && len / size != nitems) {
        ^
3rdparty/zlib/gzread.c:438:43: note: Division by zero
    return len ? gz_read(state, buf, len) / size : 0;
                                          ^
3rdparty/zlib/gzread.c:269:0: information: Skipping configuration 'INT_MAX' since the value of 'INT_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
^
3rdparty/zlib/gzwrite.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/gzwrite.c:20:9: style: The scope of the variable 'ret' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int ret;
        ^
3rdparty/zlib/gzwrite.c:150:14: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned n;
             ^
3rdparty/zlib/gzwrite.c:308:14: style: The scope of the variable 'have' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned have;
             ^
3rdparty/zlib/gzwrite.c:472:19: style: The scope of the variable 'left' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned len, left;
                  ^
3rdparty/zlib/gzwrite.c:300:44: warning: Either the condition 'size' is redundant or there is division by zero at line 300. [zerodivcond]
    return len ? gz_write(state, buf, len) / size : 0;
                                           ^
3rdparty/zlib/gzwrite.c:294:9: note: Assuming that condition 'size' is not redundant
    if (size && len / size != nitems) {
        ^
3rdparty/zlib/gzwrite.c:300:44: note: Division by zero
    return len ? gz_write(state, buf, len) / size : 0;
                                           ^
3rdparty/zlib/gzwrite.c:382:14: style: The scope of the variable 'left' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned left;
             ^
3rdparty/zlib/gzwrite.c:160:0: information: Skipping configuration 'INT_MAX' since the value of 'INT_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
^
3rdparty/zlib/infback.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/inffast.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/inflate.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/inflate.c:402:14: style: The scope of the variable 'dist' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned dist;
             ^
3rdparty/zlib/inflate.c:1320:19: style: The scope of the variable 'dictid' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned long dictid;
                  ^
3rdparty/zlib/inflate.c:1405:19: style: The scope of the variable 'buf' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char buf[4];       /* to restore bit buffer to byte string */
                  ^
3rdparty/zlib/inflate.c:1468:14: style: The scope of the variable 'wsize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned wsize;
             ^
3rdparty/zlib/inflate.c:702:40: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
            state->mode = hold & 0x200 ? DICTID : TYPE;
                                       ^
3rdparty/zlib/inftrees.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/inftrees.c:50:14: style: The scope of the variable 'fill' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned fill;              /* index for replicating entries */
             ^
3rdparty/zlib/trees.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/trees.c:710:9: style: The scope of the variable 'curlen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int curlen;                /* length of current code */
        ^
3rdparty/zlib/trees.c:755:9: style: The scope of the variable 'curlen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int curlen;                /* length of current code */
        ^
3rdparty/zlib/trees.c:1069:14: style: The scope of the variable 'dist' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned dist;      /* distance of matched string */
             ^
3rdparty/zlib/trees.c:1070:9: style: The scope of the variable 'lc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int lc;             /* match length or unmatched char (if dist == 0) */
        ^
3rdparty/zlib/trees.c:1071:14: style: The scope of the variable 'lx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned lx = 0;    /* running index in l_buf */
             ^
3rdparty/zlib/trees.c:1072:14: style: The scope of the variable 'code' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned code;      /* the code to send */
             ^
3rdparty/zlib/trees.c:1073:9: style: The scope of the variable 'extra' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int extra;          /* number of extra bits to send */
        ^
3rdparty/zlib/trees.c:974:28: style: Unsigned expression 'static_lenb' can't be negative so it is unnecessary to test it. [unsignedPositive]
    } else if (static_lenb >= 0) { /* force static trees */
                           ^
3rdparty/zlib/trees.c:362:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
        fprintf(header, "%1u%s", base_length[i],
        ^
3rdparty/zlib/trees.c:368:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
        fprintf(header, "%5u%s", base_dist[i],
        ^
3rdparty/zlib/uncompr.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
3rdparty/zlib/zutil.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
apps/annotation/opencv_annotation.cpp:307:97: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
    for(map<String, vector<Rect> >::iterator it = annotations.begin(); it != annotations.end(); it++){
                                                                                                ^
apps/createsamples/utility.cpp:1307:12: warning: fscanf() without field width limits can crash with huge input data. Add a field width specifier to fix this problem.

Sample program that can crash:

#include <stdio.h>
int main()
{
    char c[5];
    scanf("%s", c);
    return 0;
}

Typing in 5 or more characters may make the program crash. The correct usage here is 'scanf("%4s", c);', as the maximum field width does not include the terminating null byte.
Source: http://linux.die.net/man/3/scanf
Source: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c [invalidscanf]
        if(fscanf(info, "%s %d", filename, &count) == 2)
           ^
apps/createsamples/utility.cpp:71:9: style: The scope of the variable 'pos' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int pos;
        ^
apps/createsamples/utility.cpp:226:12: style: The scope of the variable 'y_max' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double y_max = 0;
           ^
apps/createsamples/utility.cpp:229:12: style: The scope of the variable 'd' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double d = 0;
           ^
apps/createsamples/utility.cpp:717:12: style: The scope of the variable 'datasize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t datasize = 0;
           ^
apps/createsamples/utility.cpp:718:12: style: The scope of the variable 'count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int    count = 0;
           ^
apps/createsamples/utility.cpp:721:12: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int    len   = 0;
           ^
apps/createsamples/utility.cpp:817:9: style: The scope of the variable 'round' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int round = 0;
        ^
apps/createsamples/utility.cpp:818:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i = 0;
        ^
apps/createsamples/utility.cpp:1140:15: style: The scope of the variable 'filename' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        char* filename;
              ^
apps/createsamples/utility.cpp:1141:15: style: The scope of the variable 'info' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        FILE* info;
              ^
apps/createsamples/utility.cpp:1398:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
apps/createsamples/utility.cpp:226:18: style: Variable 'y_max' is assigned a value that is never used. [unreadVariable]
    double y_max = 0;
                 ^
apps/createsamples/utility.cpp:229:14: style: Variable 'd' is assigned a value that is never used. [unreadVariable]
    double d = 0;
             ^
apps/createsamples/utility.cpp:717:21: style: Variable 'datasize' is assigned a value that is never used. [unreadVariable]
    size_t datasize = 0;
                    ^
apps/createsamples/utility.cpp:718:18: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
    int    count = 0;
                 ^
apps/createsamples/utility.cpp:721:18: style: Variable 'len' is assigned a value that is never used. [unreadVariable]
    int    len   = 0;
                 ^
apps/createsamples/utility.cpp:817:15: style: Variable 'round' is assigned a value that is never used. [unreadVariable]
    int round = 0;
              ^
apps/createsamples/utility.cpp:1369:11: style: Variable 'c' is assigned a value that is never used. [unreadVariable]
    int c = 0;
          ^
apps/interactive-calibration/calibCommon.hpp:56:9: warning: Member variable 'calibrationData::totalAvgErr' is not initialized in the constructor. [uninitMemberVar]
        calibrationData()
        ^
apps/interactive-calibration/calibCommon.hpp:95:9: warning: Member variable 'captureParameters::captureMethod' is not initialized in the constructor. [uninitMemberVar]
        captureParameters()
        ^
apps/interactive-calibration/calibCommon.hpp:95:9: warning: Member variable 'captureParameters::source' is not initialized in the constructor. [uninitMemberVar]
        captureParameters()
        ^
apps/interactive-calibration/calibCommon.hpp:95:9: warning: Member variable 'captureParameters::board' is not initialized in the constructor. [uninitMemberVar]
        captureParameters()
        ^
apps/interactive-calibration/calibCommon.hpp:95:9: warning: Member variable 'captureParameters::charucoDictName' is not initialized in the constructor. [uninitMemberVar]
        captureParameters()
        ^
apps/interactive-calibration/calibCommon.hpp:95:9: warning: Member variable 'captureParameters::charucoSquareLenght' is not initialized in the constructor. [uninitMemberVar]
        captureParameters()
        ^
apps/interactive-calibration/calibCommon.hpp:95:9: warning: Member variable 'captureParameters::charucoMarkerSize' is not initialized in the constructor. [uninitMemberVar]
        captureParameters()
        ^
apps/interactive-calibration/calibCommon.hpp:95:9: warning: Member variable 'captureParameters::squareSize' is not initialized in the constructor. [uninitMemberVar]
        captureParameters()
        ^
apps/interactive-calibration/calibCommon.hpp:95:9: warning: Member variable 'captureParameters::templDst' is not initialized in the constructor. [uninitMemberVar]
        captureParameters()
        ^
apps/interactive-calibration/calibCommon.hpp:95:9: warning: Member variable 'captureParameters::flipVertical' is not initialized in the constructor. [uninitMemberVar]
        captureParameters()
        ^
apps/interactive-calibration/calibCommon.hpp:95:9: warning: Member variable 'captureParameters::camID' is not initialized in the constructor. [uninitMemberVar]
        captureParameters()
        ^
apps/interactive-calibration/calibController.cpp:43:25: warning: Member variable 'calibController::mMinFramesNum' is not initialized in the constructor. [uninitMemberVar]
calib::calibController::calibController()
                        ^
apps/interactive-calibration/calibController.cpp:43:25: warning: Member variable 'calibController::mNeedTuning' is not initialized in the constructor. [uninitMemberVar]
calib::calibController::calibController()
                        ^
apps/interactive-calibration/calibController.cpp:43:25: warning: Member variable 'calibController::mConfIntervalsState' is not initialized in the constructor. [uninitMemberVar]
calib::calibController::calibController()
                        ^
apps/interactive-calibration/calibController.cpp:43:25: warning: Member variable 'calibController::mCoverageQualityState' is not initialized in the constructor. [uninitMemberVar]
calib::calibController::calibController()
                        ^
apps/interactive-calibration/calibCommon.hpp:58:13: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'imageSize' a value by passing the value to the constructor in the initialization list. [useInitializationList]
            imageSize = cv::Size(IMAGE_MAX_WIDTH, IMAGE_MAX_HEIGHT);
            ^
apps/interactive-calibration/calibCommon.hpp:102:13: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'cameraResolution' a value by passing the value to the constructor in the initialization list. [useInitializationList]
            cameraResolution = cv::Size(IMAGE_MAX_WIDTH, IMAGE_MAX_HEIGHT);
            ^
apps/interactive-calibration/calibController.cpp:19:43: style: Argument 'gridSize*gridSize' to function pointsInCell is always 100 [constArgument]
    std::vector<int> pointsInCell(gridSize*gridSize);
                                          ^
apps/interactive-calibration/calibController.cpp:16:20: note: Assignment 'gridSize=10', assigned value is 10
    int gridSize = 10;
                   ^
apps/interactive-calibration/calibController.cpp:19:43: note: Argument 'gridSize*gridSize' to function pointsInCell is always 100
    std::vector<int> pointsInCell(gridSize*gridSize);
                                          ^
apps/interactive-calibration/calibController.cpp:158:47: style: Argument 'gridSize*gridSize' to function pointsInCell is always 100 [constArgument]
        std::vector<int> pointsInCell(gridSize*gridSize);
                                              ^
apps/interactive-calibration/calibController.cpp:155:24: note: Assignment 'gridSize=10', assigned value is 10
        int gridSize = 10;
                       ^
apps/interactive-calibration/calibController.cpp:158:47: note: Argument 'gridSize*gridSize' to function pointsInCell is always 100
        std::vector<int> pointsInCell(gridSize*gridSize);
                                              ^
apps/interactive-calibration/calibPipeline.hpp:38:5: style: Class 'CalibPipeline' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CalibPipeline(captureParameters params);
    ^
apps/interactive-calibration/frameProcessor.hpp:64:21: style: The function 'processFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual cv::Mat processFrame(const cv::Mat& frame);
                    ^
apps/interactive-calibration/frameProcessor.hpp:25:21: note: Virtual function in base class
    virtual cv::Mat processFrame(const cv::Mat& frame) = 0;
                    ^
apps/interactive-calibration/frameProcessor.hpp:64:21: note: Function in derived class
    virtual cv::Mat processFrame(const cv::Mat& frame);
                    ^
apps/interactive-calibration/frameProcessor.hpp:65:18: style: The function 'isProcessed' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool isProcessed() const;
                 ^
apps/interactive-calibration/frameProcessor.hpp:26:18: note: Virtual function in base class
    virtual bool isProcessed() const = 0;
                 ^
apps/interactive-calibration/frameProcessor.hpp:65:18: note: Function in derived class
    virtual bool isProcessed() const;
                 ^
apps/interactive-calibration/frameProcessor.hpp:66:18: style: The function 'resetState' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void resetState();
                 ^
apps/interactive-calibration/frameProcessor.hpp:27:18: note: Virtual function in base class
    virtual void resetState() = 0;
                 ^
apps/interactive-calibration/frameProcessor.hpp:66:18: note: Function in derived class
    virtual void resetState();
                 ^
apps/interactive-calibration/frameProcessor.hpp:87:21: style: The function 'processFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual cv::Mat processFrame(const cv::Mat& frame);
                    ^
apps/interactive-calibration/frameProcessor.hpp:25:21: note: Virtual function in base class
    virtual cv::Mat processFrame(const cv::Mat& frame) = 0;
                    ^
apps/interactive-calibration/frameProcessor.hpp:87:21: note: Function in derived class
    virtual cv::Mat processFrame(const cv::Mat& frame);
                    ^
apps/interactive-calibration/frameProcessor.hpp:88:18: style: The function 'isProcessed' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool isProcessed() const;
                 ^
apps/interactive-calibration/frameProcessor.hpp:26:18: note: Virtual function in base class
    virtual bool isProcessed() const = 0;
                 ^
apps/interactive-calibration/frameProcessor.hpp:88:18: note: Function in derived class
    virtual bool isProcessed() const;
                 ^
apps/interactive-calibration/frameProcessor.hpp:89:18: style: The function 'resetState' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void resetState();
                 ^
apps/interactive-calibration/frameProcessor.hpp:27:18: note: Virtual function in base class
    virtual void resetState() = 0;
                 ^
apps/interactive-calibration/frameProcessor.hpp:89:18: note: Function in derived class
    virtual void resetState();
                 ^
apps/interactive-calibration/calibPipeline.cpp:24:48: performance: Parameter 'params' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
CalibPipeline::CalibPipeline(captureParameters params) :
                                               ^
apps/interactive-calibration/parametersController.hpp:25:5: style: Class 'parametersController' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    parametersController(cv::Ptr<captureParameters> params);
    ^
apps/interactive-calibration/main.cpp:220:5: style: The exception is caught by value. It could be caught as a (const) reference which is usually recommended in C++. [catchExceptionByValue]
    catch (std::runtime_error exp) {
    ^
apps/interactive-calibration/parametersController.cpp:106:8: performance: Either inefficient or wrong usage of string::find(). string::starts_with() will be faster if string::find's result is compared with 0, because it will not scan the whole string. If your intention is to check that there are no findings in the string, you should compare with std::string::npos. [stlIfStrFind]
    if(templateType.find("circles", 0) == 0) {
       ^
apps/interactive-calibration/parametersController.cpp:110:13: performance: Either inefficient or wrong usage of string::find(). string::starts_with() will be faster if string::find's result is compared with 0, because it will not scan the whole string. If your intention is to check that there are no findings in the string, you should compare with std::string::npos. [stlIfStrFind]
    else if(templateType.find("chessboard", 0) == 0) {
            ^
apps/interactive-calibration/parametersController.cpp:114:13: performance: Either inefficient or wrong usage of string::find(). string::starts_with() will be faster if string::find's result is compared with 0, because it will not scan the whole string. If your intention is to check that there are no findings in the string, you should compare with std::string::npos. [stlIfStrFind]
    else if(templateType.find("dualcircles", 0) == 0) {
            ^
apps/interactive-calibration/parametersController.cpp:118:13: performance: Either inefficient or wrong usage of string::find(). string::starts_with() will be faster if string::find's result is compared with 0, because it will not scan the whole string. If your intention is to check that there are no findings in the string, you should compare with std::string::npos. [stlIfStrFind]
    else if(templateType.find("charuco", 0) == 0) {
            ^
apps/traincascade/old_ml.hpp:513:5: error: There is an unknown macro here somewhere. Configuration is required. If CV_WRAP_AS is a macro then please configure it. [unknownMacro]
    CV_WRAP_AS(predict_all) virtual void predict( cv::InputArray samples, cv::OutputArray results ) const;
    ^
apps/traincascade/imagestorage.cpp:122:34: warning: Member variable 'PosReader::count' is not initialized in the constructor. [uninitMemberVar]
CvCascadeImageReader::PosReader::PosReader()
                                 ^
apps/traincascade/imagestorage.cpp:122:34: warning: Member variable 'PosReader::vecSize' is not initialized in the constructor. [uninitMemberVar]
CvCascadeImageReader::PosReader::PosReader()
                                 ^
apps/traincascade/imagestorage.cpp:122:34: warning: Member variable 'PosReader::last' is not initialized in the constructor. [uninitMemberVar]
CvCascadeImageReader::PosReader::PosReader()
                                 ^
apps/traincascade/imagestorage.cpp:122:34: warning: Member variable 'PosReader::base' is not initialized in the constructor. [uninitMemberVar]
CvCascadeImageReader::PosReader::PosReader()
                                 ^
apps/traincascade/imagestorage.cpp:19:34: warning: Member variable 'NegReader::last' is not initialized in the constructor. [uninitMemberVar]
CvCascadeImageReader::NegReader::NegReader()
                                 ^
apps/traincascade/imagestorage.cpp:19:34: warning: Member variable 'NegReader::round' is not initialized in the constructor. [uninitMemberVar]
CvCascadeImageReader::NegReader::NegReader()
                                 ^
apps/traincascade/imagestorage.cpp:14:49: performance: Parameter '_posFilename' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
bool CvCascadeImageReader::create( const string _posFilename, const string _negFilename, Size _winSize )
                                                ^
apps/traincascade/imagestorage.cpp:14:76: performance: Parameter '_negFilename' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
bool CvCascadeImageReader::create( const string _posFilename, const string _negFilename, Size _winSize )
                                                                           ^
apps/traincascade/imagestorage.cpp:29:60: performance: Parameter '_filename' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
bool CvCascadeImageReader::NegReader::create( const string _filename, Size _winSize )
                                                           ^
apps/traincascade/imagestorage.cpp:128:60: performance: Parameter '_filename' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
bool CvCascadeImageReader::PosReader::create( const string _filename )
                                                           ^
cmake/checks/cpu_avx.cpp:7:14: style: Variable 'a' is assigned a value that is never used. [unreadVariable]
    __m256 a = _mm256_set1_ps(0.0f);
             ^
cmake/checks/cpu_avx2.cpp:8:15: style: Variable 'a' is assigned a value that is never used. [unreadVariable]
    __m256i a = _mm256_loadu_si256((const __m256i *)data);
              ^
cmake/checks/cpu_avx512.cpp:5:17: style: Variable 'zmm' is assigned a value that is never used. [unreadVariable]
    __m512i zmm = _mm512_setzero_si512();
                ^
cmake/checks/cpu_popcnt.cpp:20:11: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    int j = CV_POPCNT_U32(1);
          ^
cmake/checks/cpu_popcnt.cpp:18:11: style: Variable 'i' is assigned a value that is never used. [unreadVariable]
    int i = CV_POPCNT_U64(1);
          ^
cmake/checks/cpu_sse3.cpp:5:7: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
    v = _mm_moveldup_ps(u); // SSE3
      ^
cmake/checks/cpu_sse41.cpp:4:15: style: Variable 'c' is assigned a value that is never used. [unreadVariable]
    __m128i c = _mm_packus_epi32(a, b);
              ^
cmake/checks/cpu_sse42.cpp:5:22: style: Variable 'res' is assigned a value that is never used. [unreadVariable]
    unsigned int res = _mm_crc32_u8(1, 2);
                     ^
cmake/checks/cpu_ssse3.cpp:5:15: style: Variable 'b' is assigned a value that is never used. [unreadVariable]
    __m128i b = _mm_abs_epi32(a);
              ^
cmake/checks/cxx11.cpp:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [cmake/checks/cxx11.cpp:4] #error "C++11 is not supported"
_MSC_VER : [cmake/checks/cxx11.cpp:4] #error "C++11 is not supported" [noValidConfiguration]

^
modules/calib3d/perf/perf_affine2d.cpp:55:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(Method, RANSAC, LMEDS)
^
modules/calib3d/perf/perf_pnp.cpp:13:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(pnpAlgo, SOLVEPNP_ITERATIVE, SOLVEPNP_EPNP, SOLVEPNP_P3P, SOLVEPNP_DLS, SOLVEPNP_UPNP)
^
modules/calib3d/perf/perf_stereosgbm.cpp:51:1: error: syntax error [syntaxError]
PERF_TEST_P( TestStereoCorresp, SGBM, Combine(Values(Size(1280,720),Size(640,480)), Values(256,128), SGBMModes::all()) )
^
modules/calib3d/perf/perf_stereosgbm.cpp:53:1: error: syntax error [syntaxError]
PERF_TEST_P( TestStereoCorresp, DISABLED_TooLongInDebug_SGBM, Combine(Values(Size(1280,720),Size(640,480)), Values(256,128), SGBMModes::all()) )
^
modules/calib3d/src/ap3p.h:40:5: style: Class 'ap3p' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ap3p(cv::Mat cameraMatrix);
    ^
modules/calib3d/src/calibinit.cpp:383:22: style: Defensive programming: The variable 'iIdxBGMax' is used as an array index before it is checked that is within limits. This can mean that the array might be accessed out of bounds. Reorder conditions such as '(a[i] && i < 10)' to '(i < 10 && a[i])'. That way the array will not be accessed if the index is out of limits. [arrayIndexThenCheck]
        if ( piMaxPos[iIdxBGMax] >= 250 && iIdxBGMax < iCntMaxima )
                     ^
modules/calib3d/src/calibinit.cpp:932:13: portability: Using memset() on struct which contains a floating point number. This is not portable because memset() sets each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined. Note: In case of an IEEE754-1985 compatible implementation setting all bits to zero results in the value 0.0. [memsetClassFloat]
            memset( q, 0, sizeof(*q) );
            ^
modules/calib3d/src/calibinit.cpp:1834:9: portability: Using memset() on struct which contains a floating point number. This is not portable because memset() sets each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined. Note: In case of an IEEE754-1985 compatible implementation setting all bits to zero results in the value 0.0. [memsetClassFloat]
        memset( q, 0, sizeof(*q) );
        ^
modules/calib3d/src/circlesgrid.hpp:59:3: style: Class 'CirclesGridClusterFinder' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
  CirclesGridClusterFinder(const cv::CirclesGridFinderParameters2 &parameters)
  ^
modules/calib3d/src/circlesgrid.hpp:92:3: style: Class 'Graph' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
  Graph(size_t n);
  ^
modules/calib3d/src/calibinit.cpp:1841:45: warning: Either the condition 'onePoint!=NULL' is redundant or there is possible null pointer dereference: onePoint. [nullPointerRedundantCheck]
            CvPoint2D32f pt = cvPointTo32f(*onePoint);
                                            ^
modules/calib3d/src/calibinit.cpp:1840:32: note: Assuming that condition 'onePoint!=NULL' is not redundant
            CV_Assert(onePoint != NULL);
                               ^
modules/calib3d/src/calibinit.cpp:1839:34: note: Assignment 'onePoint=(CvPoint*)cvGetSeqElem(src_contour,i)', assigned value is 0
            CvPoint * onePoint = (CvPoint*)cvGetSeqElem(src_contour, i);
                                 ^
modules/calib3d/src/calibinit.cpp:1841:45: note: Null pointer dereference
            CvPoint2D32f pt = cvPointTo32f(*onePoint);
                                            ^
modules/calib3d/src/calibinit.cpp:1805:43: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                    CvContourEx* parent = (CvContourEx*)(src_contour->v_prev);
                                          ^
modules/calib3d/src/calibinit.cpp:1822:18: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    *out_quads = (CvCBQuad*)cvAlloc(*max_quad_buf_size * sizeof((*out_quads)[0]));
                 ^
modules/calib3d/src/calibinit.cpp:1823:20: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    *out_corners = (CvCBCorner*)cvAlloc(*max_quad_buf_size * 4 * sizeof((*out_corners)[0]));
                   ^
modules/calib3d/src/calibinit.cpp:328:9: style: The scope of the variable 'iSumAroundMax' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int iSumAroundMax = 0;
        ^
modules/calib3d/src/calibinit.cpp:327:10: style: Variable 'iIdx' is assigned a value that is never used. [unreadVariable]
    iIdx = 0;
         ^
modules/calib3d/src/calibinit.cpp:328:23: style: Variable 'iSumAroundMax' is assigned a value that is never used. [unreadVariable]
    int iSumAroundMax = 0;
                      ^
modules/calib3d/src/calibinit.cpp:436:11: style: Variable 'k' is assigned a value that is never used. [unreadVariable]
    int k = 0;
          ^
modules/calib3d/src/calibinit.cpp:91:30: error: va_list 'args' was opened but not closed by va_end(). [va_end_missing]
    return vprintf(fmt, args);
                             ^
modules/calib3d/src/calibration.cpp:3801:8: style: Redundant initialization for 'R3'. The initialized value is overwritten before it is read. [redundantInitialization]
    R3 = wR*r_r.t()*r_r13.t();
       ^
modules/calib3d/src/calibration.cpp:3770:12: note: R3 is initialized
    Mat R3 = _Rmat3.getMat(), P3 = _Pmat3.getMat();
           ^
modules/calib3d/src/calibration.cpp:3801:8: note: R3 is overwritten
    R3 = wR*r_r.t()*r_r13.t();
       ^
modules/calib3d/src/calibration.cpp:254:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, k;
        ^
modules/calib3d/src/calibration.cpp:254:12: style: The scope of the variable 'k' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, k;
           ^
modules/calib3d/src/calibration.cpp:397:20: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            double t;
                   ^
modules/calib3d/src/calibration.cpp:977:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, count;
        ^
modules/calib3d/src/calibration.cpp:1039:33: style: The scope of the variable 'h1_norm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            double tt[3], h[9], h1_norm, h2_norm;
                                ^
modules/calib3d/src/calibration.cpp:1039:42: style: The scope of the variable 'h2_norm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            double tt[3], h[9], h1_norm, h2_norm;
                                         ^
modules/calib3d/src/calibration.cpp:2554:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j, npoints;
        ^
modules/calib3d/src/calibration.cpp:2554:12: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j, npoints;
           ^
modules/calib3d/src/calibration.cpp:1030:12: style: Variable 'Mc' is assigned a value that is never used. [unreadVariable]
        Mc = cvAvg(matM);
           ^
modules/calib3d/src/calibration.cpp:2941:24: style: Variable 'matR[0][0]' is assigned a value that is never used. [unreadVariable]
            matR[0][0] *= -1;
                       ^
modules/calib3d/src/calibration.cpp:2942:24: style: Variable 'matR[0][1]' is assigned a value that is never used. [unreadVariable]
            matR[0][1] *= -1;
                       ^
modules/calib3d/src/calibration.cpp:2943:24: style: Variable 'matR[1][1]' is assigned a value that is never used. [unreadVariable]
            matR[1][1] *= -1;
                       ^
modules/calib3d/src/calibration.cpp:2956:24: style: Variable 'matR[0][0]' is assigned a value that is never used. [unreadVariable]
            matR[0][0] *= -1;
                       ^
modules/calib3d/src/calibration.cpp:2957:24: style: Variable 'matR[0][2]' is assigned a value that is never used. [unreadVariable]
            matR[0][2] *= -1;
                       ^
modules/calib3d/src/calibration.cpp:2958:24: style: Variable 'matR[1][2]' is assigned a value that is never used. [unreadVariable]
            matR[1][2] *= -1;
                       ^
modules/calib3d/src/calibration.cpp:2959:24: style: Variable 'matR[2][2]' is assigned a value that is never used. [unreadVariable]
            matR[2][2] *= -1;
                       ^
modules/calib3d/src/calibration.cpp:2977:20: style: Variable 'matR[0][1]' is assigned a value that is never used. [unreadVariable]
        matR[0][1] *= -1;
                   ^
modules/calib3d/src/calibration.cpp:2978:20: style: Variable 'matR[0][2]' is assigned a value that is never used. [unreadVariable]
        matR[0][2] *= -1;
                   ^
modules/calib3d/src/calibration.cpp:2979:20: style: Variable 'matR[1][1]' is assigned a value that is never used. [unreadVariable]
        matR[1][1] *= -1;
                   ^
modules/calib3d/src/calibration.cpp:2980:20: style: Variable 'matR[1][2]' is assigned a value that is never used. [unreadVariable]
        matR[1][2] *= -1;
                   ^
modules/calib3d/src/calibration.cpp:2981:20: style: Variable 'matR[2][2]' is assigned a value that is never used. [unreadVariable]
        matR[2][2] *= -1;
                   ^
modules/calib3d/src/calibration.cpp:3179:13: style: Variable 'dst' is assigned a value that is never used. [unreadVariable]
        dst = Scalar(0);
            ^
modules/calib3d/src/dls.h:103:10: style: Unused private function: 'EigenvalueDecomposition::alloc_1d' [unusedPrivateFunction]
    _Tp *alloc_1d(int m) {
         ^
modules/calib3d/src/dls.h:118:11: style: Unused private function: 'EigenvalueDecomposition::alloc_2d' [unusedPrivateFunction]
    _Tp **alloc_2d(int m, int _n) {
          ^
modules/calib3d/src/dls.h:729:5: style: Class 'EigenvalueDecomposition' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    EigenvalueDecomposition(InputArray src) {
    ^
modules/calib3d/src/dls.cpp:226:7: style: Redundant initialization for 'H'. The initialized value is overwritten before it is read. [redundantInitialization]
    H = eye.mul(N) - z * z.t();
      ^
modules/calib3d/src/dls.cpp:215:15: note: H is initialized
    cv::Mat H = cv::Mat::zeros(3, 3, CV_64F);
              ^
modules/calib3d/src/dls.cpp:226:7: note: H is overwritten
    H = eye.mul(N) - z * z.t();
      ^
modules/calib3d/src/epnp.cpp:199:38: warning: Function 'copy_R_and_t' argument order different: declaration 'R_dst, t_dst, R_src, t_src' definition 'R_src, t_src, R_dst, t_dst' [funcArgOrderDifferent]
void epnp::copy_R_and_t(const double R_src[3][3], const double t_src[3],
                                     ^
modules/calib3d/src/epnp.h:72:34: note: Function 'copy_R_and_t' argument order different: declaration 'R_dst, t_dst, R_src, t_src' definition 'R_src, t_src, R_dst, t_dst'
  void copy_R_and_t(const double R_dst[3][3], const double t_dst[3],
                                 ^
modules/calib3d/src/epnp.cpp:199:38: note: Function 'copy_R_and_t' argument order different: declaration 'R_dst, t_dst, R_src, t_src' definition 'R_src, t_src, R_dst, t_dst'
void epnp::copy_R_and_t(const double R_src[3][3], const double t_src[3],
                                     ^
modules/calib3d/src/fisheye.cpp:469:22: portability: Casting from float * to signed short * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
        short*  m1 = (short*)m1f;
                     ^
modules/calib3d/src/fisheye.cpp:721:66: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    finalParam.isEstimate[2] = flags & CALIB_FIX_PRINCIPAL_POINT ? 0 : 1;
                                                                 ^
modules/calib3d/src/fisheye.cpp:722:66: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    finalParam.isEstimate[3] = flags & CALIB_FIX_PRINCIPAL_POINT ? 0 : 1;
                                                                 ^
modules/calib3d/src/fisheye.cpp:723:55: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    finalParam.isEstimate[4] = flags & CALIB_FIX_SKEW ? 0 : 1;
                                                      ^
modules/calib3d/src/fisheye.cpp:724:53: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    finalParam.isEstimate[5] = flags & CALIB_FIX_K1 ? 0 : 1;
                                                    ^
modules/calib3d/src/fisheye.cpp:725:53: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    finalParam.isEstimate[6] = flags & CALIB_FIX_K2 ? 0 : 1;
                                                    ^
modules/calib3d/src/fisheye.cpp:726:53: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    finalParam.isEstimate[7] = flags & CALIB_FIX_K3 ? 0 : 1;
                                                    ^
modules/calib3d/src/fisheye.cpp:727:53: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    finalParam.isEstimate[8] = flags & CALIB_FIX_K4 ? 0 : 1;
                                                    ^
modules/calib3d/src/fisheye.cpp:729:71: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    const int recompute_extrinsic = flags & CALIB_RECOMPUTE_EXTRINSIC ? 1: 0;
                                                                      ^
modules/calib3d/src/fisheye.cpp:730:53: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    const int check_cond = flags & CALIB_CHECK_COND ? 1 : 0;
                                                    ^
modules/calib3d/src/fisheye.cpp:745:52: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                        Vec4d(flags & CALIB_FIX_K1 ? 0 : _D[0],
                                                   ^
modules/calib3d/src/fisheye.cpp:746:52: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                              flags & CALIB_FIX_K2 ? 0 : _D[1],
                                                   ^
modules/calib3d/src/fisheye.cpp:747:52: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                              flags & CALIB_FIX_K3 ? 0 : _D[2],
                                                   ^
modules/calib3d/src/fisheye.cpp:748:52: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                              flags & CALIB_FIX_K4 ? 0 : _D[3]),
                                                   ^
modules/calib3d/src/fisheye.cpp:899:63: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicLeft.isEstimate[0] = flags & CALIB_FIX_INTRINSIC ? 0 : 1;
                                                              ^
modules/calib3d/src/fisheye.cpp:900:63: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicLeft.isEstimate[1] = flags & CALIB_FIX_INTRINSIC ? 0 : 1;
                                                              ^
modules/calib3d/src/fisheye.cpp:901:63: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicLeft.isEstimate[2] = flags & CALIB_FIX_INTRINSIC ? 0 : 1;
                                                              ^
modules/calib3d/src/fisheye.cpp:902:63: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicLeft.isEstimate[3] = flags & CALIB_FIX_INTRINSIC ? 0 : 1;
                                                              ^
modules/calib3d/src/fisheye.cpp:903:82: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicLeft.isEstimate[4] = flags & (CALIB_FIX_SKEW | CALIB_FIX_INTRINSIC) ? 0 : 1;
                                                                                 ^
modules/calib3d/src/fisheye.cpp:904:80: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicLeft.isEstimate[5] = flags & (CALIB_FIX_K1 | CALIB_FIX_INTRINSIC) ? 0 : 1;
                                                                               ^
modules/calib3d/src/fisheye.cpp:905:80: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicLeft.isEstimate[6] = flags & (CALIB_FIX_K2 | CALIB_FIX_INTRINSIC) ? 0 : 1;
                                                                               ^
modules/calib3d/src/fisheye.cpp:906:80: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicLeft.isEstimate[7] = flags & (CALIB_FIX_K3 | CALIB_FIX_INTRINSIC) ? 0 : 1;
                                                                               ^
modules/calib3d/src/fisheye.cpp:907:80: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicLeft.isEstimate[8] = flags & (CALIB_FIX_K4 | CALIB_FIX_INTRINSIC) ? 0 : 1;
                                                                               ^
modules/calib3d/src/fisheye.cpp:909:64: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicRight.isEstimate[0] = flags & CALIB_FIX_INTRINSIC ? 0 : 1;
                                                               ^
modules/calib3d/src/fisheye.cpp:910:64: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicRight.isEstimate[1] = flags & CALIB_FIX_INTRINSIC ? 0 : 1;
                                                               ^
modules/calib3d/src/fisheye.cpp:911:64: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicRight.isEstimate[2] = flags & CALIB_FIX_INTRINSIC ? 0 : 1;
                                                               ^
modules/calib3d/src/fisheye.cpp:912:64: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicRight.isEstimate[3] = flags & CALIB_FIX_INTRINSIC ? 0 : 1;
                                                               ^
modules/calib3d/src/fisheye.cpp:913:83: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicRight.isEstimate[4] = flags & (CALIB_FIX_SKEW | CALIB_FIX_INTRINSIC) ? 0 : 1;
                                                                                  ^
modules/calib3d/src/fisheye.cpp:914:81: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicRight.isEstimate[5] = flags & (CALIB_FIX_K1 | CALIB_FIX_INTRINSIC) ? 0 : 1;
                                                                                ^
modules/calib3d/src/fisheye.cpp:915:81: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicRight.isEstimate[6] = flags & (CALIB_FIX_K2 | CALIB_FIX_INTRINSIC) ? 0 : 1;
                                                                                ^
modules/calib3d/src/fisheye.cpp:916:81: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicRight.isEstimate[7] = flags & (CALIB_FIX_K3 | CALIB_FIX_INTRINSIC) ? 0 : 1;
                                                                                ^
modules/calib3d/src/fisheye.cpp:917:81: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    intrinsicRight.isEstimate[8] = flags & (CALIB_FIX_K4 | CALIB_FIX_INTRINSIC) ? 0 : 1;
                                                                                ^
modules/calib3d/src/fisheye.cpp:623:17: style: Variable 'aaa' is assigned a value that is never used. [unreadVariable]
    cv::Mat aaa = _tvec.getMat().reshape(3, 1);
                ^
modules/calib3d/src/fisheye.cpp:919:37: style: Variable 'intrinsicLeft_errors.isEstimate' is assigned a value that is never used. [unreadVariable]
    intrinsicLeft_errors.isEstimate = intrinsicLeft.isEstimate;
                                    ^
modules/calib3d/src/fisheye.cpp:920:38: style: Variable 'intrinsicRight_errors.isEstimate' is assigned a value that is never used. [unreadVariable]
    intrinsicRight_errors.isEstimate = intrinsicRight.isEstimate;
                                     ^
modules/calib3d/src/five-point.cpp:40:9: style: The function 'runKernel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/precomp.hpp:89:21: note: Virtual function in base class
        virtual int runKernel(InputArray m1, InputArray m2, OutputArray model) const = 0;
                    ^
modules/calib3d/src/five-point.cpp:40:9: note: Function in derived class
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/five-point.cpp:373:10: style: The function 'computeError' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void computeError( InputArray _m1, InputArray _m2, InputArray _model, OutputArray _err ) const
         ^
modules/calib3d/src/precomp.hpp:90:22: note: Virtual function in base class
        virtual void computeError(InputArray m1, InputArray m2, InputArray model, OutputArray err) const = 0;
                     ^
modules/calib3d/src/five-point.cpp:373:10: note: Function in derived class
    void computeError( InputArray _m1, InputArray _m2, InputArray _model, OutputArray _err ) const
         ^
modules/calib3d/src/five-point.cpp:457:82: warning: Found suspicious operator ',' [constStatement]
    Mat cameraMatrix = (Mat_<double>(3,3) << focal, 0, pp.x, 0, focal, pp.y, 0, 0, 1);
                                                                                 ^
modules/calib3d/src/five-point.cpp:639:82: warning: Found suspicious operator ',' [constStatement]
    Mat cameraMatrix = (Mat_<double>(3,3) << focal, 0, pp.x, 0, focal, pp.y, 0, 0, 1);
                                                                                 ^
modules/calib3d/src/five-point.cpp:656:59: warning: Found suspicious operator ',' [constStatement]
    Mat W = (Mat_<double>(3, 3) << 0, 1, 0, -1, 0, 0, 0, 0, 1);
                                                          ^
modules/calib3d/src/fundam.cpp:185:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'src' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        src = _src.getMat();
        ^
modules/calib3d/src/fundam.cpp:53:10: style: The function 'checkSubset' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool checkSubset( InputArray _ms1, InputArray _ms2, int count ) const
         ^
modules/calib3d/src/precomp.hpp:91:22: note: Virtual function in base class
        virtual bool checkSubset(InputArray, InputArray, int) const { return true; }
                     ^
modules/calib3d/src/fundam.cpp:53:10: note: Function in derived class
    bool checkSubset( InputArray _ms1, InputArray _ms2, int count ) const
         ^
modules/calib3d/src/fundam.cpp:90:9: style: The function 'runKernel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/precomp.hpp:89:21: note: Virtual function in base class
        virtual int runKernel(InputArray m1, InputArray m2, OutputArray model) const = 0;
                    ^
modules/calib3d/src/fundam.cpp:90:9: note: Function in derived class
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/fundam.cpp:157:10: style: The function 'computeError' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void computeError( InputArray _m1, InputArray _m2, InputArray _model, OutputArray _err ) const
         ^
modules/calib3d/src/precomp.hpp:90:22: note: Virtual function in base class
        virtual void computeError(InputArray m1, InputArray m2, InputArray model, OutputArray err) const = 0;
                     ^
modules/calib3d/src/fundam.cpp:157:10: note: Function in derived class
    void computeError( InputArray _m1, InputArray _m2, InputArray _model, OutputArray _err ) const
         ^
modules/calib3d/src/fundam.cpp:189:10: style: The function 'compute' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool compute(InputArray _param, OutputArray _err, OutputArray _Jac) const
         ^
modules/calib3d/src/precomp.hpp:73:22: note: Virtual function in base class
        virtual bool compute(InputArray param, OutputArray err, OutputArray J) const = 0;
                     ^
modules/calib3d/src/fundam.cpp:189:10: note: Function in derived class
    bool compute(InputArray _param, OutputArray _err, OutputArray _Jac) const
         ^
modules/calib3d/src/fundam.cpp:635:10: style: The function 'checkSubset' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool checkSubset( InputArray _ms1, InputArray _ms2, int count ) const
         ^
modules/calib3d/src/precomp.hpp:91:22: note: Virtual function in base class
        virtual bool checkSubset(InputArray, InputArray, int) const { return true; }
                     ^
modules/calib3d/src/fundam.cpp:635:10: note: Function in derived class
    bool checkSubset( InputArray _ms1, InputArray _ms2, int count ) const
         ^
modules/calib3d/src/fundam.cpp:641:9: style: The function 'runKernel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/precomp.hpp:89:21: note: Virtual function in base class
        virtual int runKernel(InputArray m1, InputArray m2, OutputArray model) const = 0;
                    ^
modules/calib3d/src/fundam.cpp:641:9: note: Function in derived class
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/fundam.cpp:657:10: style: The function 'computeError' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void computeError( InputArray _m1, InputArray _m2, InputArray _model, OutputArray _err ) const
         ^
modules/calib3d/src/precomp.hpp:90:22: note: Virtual function in base class
        virtual void computeError(InputArray m1, InputArray m2, InputArray model, OutputArray err) const = 0;
                     ^
modules/calib3d/src/fundam.cpp:657:10: note: Function in derived class
    void computeError( InputArray _m1, InputArray _m2, InputArray _model, OutputArray _err ) const
         ^
modules/calib3d/src/homography_decomp.cpp:99:18: style: The function 'decompose' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void decompose(std::vector<CameraMotion>& camMotions);
                 ^
modules/calib3d/src/homography_decomp.cpp:81:18: note: Virtual function in base class
    virtual void decompose(std::vector<CameraMotion>& camMotions) = 0;
                 ^
modules/calib3d/src/homography_decomp.cpp:99:18: note: Function in derived class
    virtual void decompose(std::vector<CameraMotion>& camMotions);
                 ^
modules/calib3d/src/homography_decomp.cpp:110:18: style: The function 'decompose' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void decompose(std::vector<CameraMotion>& camMotions);
                 ^
modules/calib3d/src/homography_decomp.cpp:81:18: note: Virtual function in base class
    virtual void decompose(std::vector<CameraMotion>& camMotions) = 0;
                 ^
modules/calib3d/src/homography_decomp.cpp:110:18: note: Function in derived class
    virtual void decompose(std::vector<CameraMotion>& camMotions);
                 ^
modules/calib3d/src/levmarq.cpp:92:9: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int run(InputOutputArray _param0) const
        ^
modules/calib3d/src/precomp.hpp:77:17: note: Virtual function in base class
    virtual int run(InputOutputArray _param0) const = 0;
                ^
modules/calib3d/src/levmarq.cpp:92:9: note: Function in derived class
    int run(InputOutputArray _param0) const
        ^
modules/calib3d/src/levmarq.cpp:201:10: style: The function 'setCallback' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void setCallback(const Ptr<LMSolver::Callback>& _cb) { cb = _cb; }
         ^
modules/calib3d/src/precomp.hpp:76:18: note: Virtual function in base class
    virtual void setCallback(const Ptr<LMSolver::Callback>& cb) = 0;
                 ^
modules/calib3d/src/levmarq.cpp:201:10: note: Function in derived class
    void setCallback(const Ptr<LMSolver::Callback>& _cb) { cb = _cb; }
         ^
modules/calib3d/src/p3p.h:11:3: style: Class 'p3p' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
  p3p(cv::Mat cameraMatrix);
  ^
modules/calib3d/src/posit.cpp:82:15: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    pObject = (CvPOSITObject *) cvAlloc( sizeof( CvPOSITObject ) +
              ^
modules/calib3d/src/posit.cpp:90:25: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
    pObject->inv_matr = (float *) ((char *) pObject + sizeof( CvPOSITObject ));
                        ^
modules/calib3d/src/posit.cpp:91:25: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
    pObject->obj_vecs = (float *) ((char *) (pObject->inv_matr) + inv_matr_size);
                        ^
modules/calib3d/src/posit.cpp:92:25: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
    pObject->img_vecs = (float *) ((char *) (pObject->obj_vecs) + obj_vec_size);
                        ^
modules/calib3d/src/ptsetreg.cpp:658:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'src' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        src = _src.getMat();
        ^
modules/calib3d/src/ptsetreg.cpp:716:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'src' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        src = _src.getMat();
        ^
modules/calib3d/src/ptsetreg.cpp:164:10: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool run(InputArray _m1, InputArray _m2, OutputArray _model, OutputArray _mask) const
         ^
modules/calib3d/src/precomp.hpp:95:18: note: Virtual function in base class
    virtual bool run(InputArray m1, InputArray m2, OutputArray model, OutputArray mask) const = 0;
                 ^
modules/calib3d/src/ptsetreg.cpp:164:10: note: Function in derived class
    bool run(InputArray _m1, InputArray _m2, OutputArray _model, OutputArray _mask) const
         ^
modules/calib3d/src/ptsetreg.cpp:260:10: style: The function 'setCallback' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void setCallback(const Ptr<PointSetRegistrator::Callback>& _cb) { cb = _cb; }
         ^
modules/calib3d/src/precomp.hpp:94:18: note: Virtual function in base class
    virtual void setCallback(const Ptr<PointSetRegistrator::Callback>& cb) = 0;
                 ^
modules/calib3d/src/ptsetreg.cpp:260:10: note: Function in derived class
    void setCallback(const Ptr<PointSetRegistrator::Callback>& _cb) { cb = _cb; }
         ^
modules/calib3d/src/ptsetreg.cpp:277:10: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool run(InputArray _m1, InputArray _m2, OutputArray _model, OutputArray _mask) const
         ^
modules/calib3d/src/precomp.hpp:95:18: note: Virtual function in base class
    virtual bool run(InputArray m1, InputArray m2, OutputArray model, OutputArray mask) const = 0;
                 ^
modules/calib3d/src/ptsetreg.cpp:277:10: note: Function in derived class
    bool run(InputArray _m1, InputArray _m2, OutputArray _model, OutputArray _mask) const
         ^
modules/calib3d/src/ptsetreg.cpp:402:9: style: The function 'runKernel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/precomp.hpp:89:21: note: Virtual function in base class
        virtual int runKernel(InputArray m1, InputArray m2, OutputArray model) const = 0;
                    ^
modules/calib3d/src/ptsetreg.cpp:402:9: note: Function in derived class
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/ptsetreg.cpp:440:10: style: The function 'computeError' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void computeError( InputArray _m1, InputArray _m2, InputArray _model, OutputArray _err ) const
         ^
modules/calib3d/src/precomp.hpp:90:22: note: Virtual function in base class
        virtual void computeError(InputArray m1, InputArray m2, InputArray model, OutputArray err) const = 0;
                     ^
modules/calib3d/src/ptsetreg.cpp:440:10: note: Function in derived class
    void computeError( InputArray _m1, InputArray _m2, InputArray _model, OutputArray _err ) const
         ^
modules/calib3d/src/ptsetreg.cpp:467:10: style: The function 'checkSubset' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool checkSubset( InputArray _ms1, InputArray _ms2, int count ) const
         ^
modules/calib3d/src/precomp.hpp:91:22: note: Virtual function in base class
        virtual bool checkSubset(InputArray, InputArray, int) const { return true; }
                     ^
modules/calib3d/src/ptsetreg.cpp:467:10: note: Function in derived class
    bool checkSubset( InputArray _ms1, InputArray _ms2, int count ) const
         ^
modules/calib3d/src/ptsetreg.cpp:505:9: style: The function 'runKernel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/precomp.hpp:89:21: note: Virtual function in base class
        virtual int runKernel(InputArray m1, InputArray m2, OutputArray model) const = 0;
                    ^
modules/calib3d/src/ptsetreg.cpp:505:9: note: Function in derived class
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/ptsetreg.cpp:565:10: style: The function 'computeError' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void computeError( InputArray _m1, InputArray _m2, InputArray _model, OutputArray _err ) const
         ^
modules/calib3d/src/precomp.hpp:90:22: note: Virtual function in base class
        virtual void computeError(InputArray m1, InputArray m2, InputArray model, OutputArray err) const = 0;
                     ^
modules/calib3d/src/ptsetreg.cpp:565:10: note: Function in derived class
    void computeError( InputArray _m1, InputArray _m2, InputArray _model, OutputArray _err ) const
         ^
modules/calib3d/src/ptsetreg.cpp:594:10: style: The function 'checkSubset' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool checkSubset( InputArray _ms1, InputArray, int count ) const
         ^
modules/calib3d/src/precomp.hpp:91:22: note: Virtual function in base class
        virtual bool checkSubset(InputArray, InputArray, int) const { return true; }
                     ^
modules/calib3d/src/ptsetreg.cpp:594:10: note: Function in derived class
    bool checkSubset( InputArray _ms1, InputArray, int count ) const
         ^
modules/calib3d/src/ptsetreg.cpp:606:9: style: The function 'runKernel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/precomp.hpp:89:21: note: Virtual function in base class
        virtual int runKernel(InputArray m1, InputArray m2, OutputArray model) const = 0;
                    ^
modules/calib3d/src/ptsetreg.cpp:606:9: note: Function in derived class
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/ptsetreg.cpp:662:10: style: The function 'compute' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool compute(InputArray _param, OutputArray _err, OutputArray _Jac) const
         ^
modules/calib3d/src/precomp.hpp:73:22: note: Virtual function in base class
        virtual bool compute(InputArray param, OutputArray err, OutputArray J) const = 0;
                     ^
modules/calib3d/src/ptsetreg.cpp:662:10: note: Function in derived class
    bool compute(InputArray _param, OutputArray _err, OutputArray _Jac) const
         ^
modules/calib3d/src/ptsetreg.cpp:720:10: style: The function 'compute' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool compute(InputArray _param, OutputArray _err, OutputArray _Jac) const
         ^
modules/calib3d/src/precomp.hpp:73:22: note: Virtual function in base class
        virtual bool compute(InputArray param, OutputArray err, OutputArray J) const = 0;
                     ^
modules/calib3d/src/ptsetreg.cpp:720:10: note: Function in derived class
    bool compute(InputArray _param, OutputArray _err, OutputArray _Jac) const
         ^
modules/calib3d/src/rho.cpp:614:16: warning: Member variable 'RHO_HEST_REFC::arg' is not initialized in the constructor. [uninitMemberVarPrivate]
RHO_HEST_REFC::RHO_HEST_REFC(const RHO_HEST_REFC&) : initialized(0){
               ^
modules/calib3d/src/rho.cpp:614:16: warning: Member variable 'RHO_HEST_REFC::ctrl' is not initialized in the constructor. [uninitMemberVarPrivate]
RHO_HEST_REFC::RHO_HEST_REFC(const RHO_HEST_REFC&) : initialized(0){
               ^
modules/calib3d/src/rho.cpp:614:16: warning: Member variable 'RHO_HEST_REFC::curr' is not initialized in the constructor. [uninitMemberVarPrivate]
RHO_HEST_REFC::RHO_HEST_REFC(const RHO_HEST_REFC&) : initialized(0){
               ^
modules/calib3d/src/rho.cpp:614:16: warning: Member variable 'RHO_HEST_REFC::best' is not initialized in the constructor. [uninitMemberVarPrivate]
RHO_HEST_REFC::RHO_HEST_REFC(const RHO_HEST_REFC&) : initialized(0){
               ^
modules/calib3d/src/rho.cpp:614:16: warning: Member variable 'RHO_HEST_REFC::nr' is not initialized in the constructor. [uninitMemberVarPrivate]
RHO_HEST_REFC::RHO_HEST_REFC(const RHO_HEST_REFC&) : initialized(0){
               ^
modules/calib3d/src/rho.cpp:614:16: warning: Member variable 'RHO_HEST_REFC::eval' is not initialized in the constructor. [uninitMemberVarPrivate]
RHO_HEST_REFC::RHO_HEST_REFC(const RHO_HEST_REFC&) : initialized(0){
               ^
modules/calib3d/src/rho.cpp:614:16: warning: Member variable 'RHO_HEST_REFC::lm' is not initialized in the constructor. [uninitMemberVarPrivate]
RHO_HEST_REFC::RHO_HEST_REFC(const RHO_HEST_REFC&) : initialized(0){
               ^
modules/calib3d/src/rho.cpp:341:19: warning: Virtual function 'finalize' is called from destructor '~RHO_HEST_REFC()' at line 624. Dynamic binding is not used. [virtualCallInConstructor]
    inline void   finalize(void);
                  ^
modules/calib3d/src/rho.cpp:624:9: note: Calling finalize
        finalize();
        ^
modules/calib3d/src/rho.cpp:341:19: note: finalize is a virtual function
    inline void   finalize(void);
                  ^
modules/calib3d/src/rho.cpp:340:19: style: The function 'initialize' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    inline int    initialize(void);
                  ^
modules/calib3d/src/rho.cpp:107:27: note: Virtual function in base class
    virtual inline int    initialize(void){return 1;}
                          ^
modules/calib3d/src/rho.cpp:340:19: note: Function in derived class
    inline int    initialize(void);
                  ^
modules/calib3d/src/rho.cpp:341:19: style: The function 'finalize' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    inline void   finalize(void);
                  ^
modules/calib3d/src/rho.cpp:114:27: note: Virtual function in base class
    virtual inline void   finalize(void){}
                          ^
modules/calib3d/src/rho.cpp:341:19: note: Function in derived class
    inline void   finalize(void);
                  ^
modules/calib3d/src/rho.cpp:342:19: style: The function 'ensureCapacity' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    inline int    ensureCapacity(unsigned N, double beta);
                  ^
modules/calib3d/src/rho.cpp:130:27: note: Virtual function in base class
    virtual inline int    ensureCapacity(unsigned N, double beta){
                          ^
modules/calib3d/src/rho.cpp:342:19: note: Function in derived class
    inline int    ensureCapacity(unsigned N, double beta);
                  ^
modules/calib3d/src/rho.cpp:343:19: style: The function 'rhoHest' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    unsigned      rhoHest(const float*   src,     /* Source points */
                  ^
modules/calib3d/src/rho.cpp:214:27: note: Virtual function in base class
    virtual unsigned      rhoHest(const float*   src,     /* Source points */
                          ^
modules/calib3d/src/rho.cpp:343:19: note: Function in derived class
    unsigned      rhoHest(const float*   src,     /* Source points */
                  ^
modules/calib3d/src/rho.cpp:871:19: portability: Casting between unsigned char * and float * which have an incompatible binary data representation. [invalidPointerCast]
    curr.pkdPts = (float*)     (ptr + curr_pkdPts_of);
                  ^
modules/calib3d/src/rho.cpp:872:19: portability: Casting between unsigned char * and float * which have an incompatible binary data representation. [invalidPointerCast]
    curr.H      = (float*)     (ptr + curr_H_of);
                  ^
modules/calib3d/src/rho.cpp:873:19: portability: Casting between unsigned char * and float * which have an incompatible binary data representation. [invalidPointerCast]
    best.H      = (float*)     (ptr + best_H_of);
                  ^
modules/calib3d/src/rho.cpp:876:19: portability: Casting between unsigned char * and float * which have an incompatible binary data representation. [invalidPointerCast]
    lm.Jte      = (float*)     (ptr + lm_Jte_of);
                  ^
modules/calib3d/src/rho.cpp:889:12: style: Finding variables 'best_inl_sz' and 'curr_inl_sz' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
    size_t best_inl_sz = arg.N;
           ^
modules/calib3d/src/rho.cpp:890:12: note: Same expression used in consecutive assignments of 'best_inl_sz' and 'curr_inl_sz'.
    size_t curr_inl_sz = arg.N;
           ^
modules/calib3d/src/rho.cpp:889:12: note: Same expression used in consecutive assignments of 'best_inl_sz' and 'curr_inl_sz'.
    size_t best_inl_sz = arg.N;
           ^
modules/calib3d/src/rho.cpp:1449:14: style: The scope of the variable 'isInlier' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned isInlier;
             ^
modules/calib3d/src/rho.cpp:2138:17: style: The scope of the variable 'gain' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float       gain;     /* Gain-parameter. */
                ^
modules/calib3d/src/solvepnp.cpp:184:9: style: The function 'runKernel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/precomp.hpp:89:21: note: Virtual function in base class
        virtual int runKernel(InputArray m1, InputArray m2, OutputArray model) const = 0;
                    ^
modules/calib3d/src/solvepnp.cpp:184:9: note: Function in derived class
    int runKernel( InputArray _m1, InputArray _m2, OutputArray _model ) const
        ^
modules/calib3d/src/solvepnp.cpp:200:10: style: The function 'computeError' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void computeError( InputArray _m1, InputArray _m2, InputArray _model, OutputArray _err ) const
         ^
modules/calib3d/src/precomp.hpp:90:22: note: Virtual function in base class
        virtual void computeError(InputArray m1, InputArray m2, InputArray model, OutputArray err) const = 0;
                     ^
modules/calib3d/src/solvepnp.cpp:200:10: note: Function in derived class
    void computeError( InputArray _m1, InputArray _m2, InputArray _model, OutputArray _err ) const
         ^
modules/calib3d/src/solvepnp.cpp:186:21: style: Variable 'opoints' is assigned a value that is never used. [unreadVariable]
        Mat opoints = _m1.getMat(), ipoints = _m2.getMat();
                    ^
modules/calib3d/src/solvepnp.cpp:186:45: style: Variable 'ipoints' is assigned a value that is never used. [unreadVariable]
        Mat opoints = _m1.getMat(), ipoints = _m2.getMat();
                                            ^
modules/calib3d/src/stereobm.cpp:958:5: warning: Member variable 'FindStereoCorrespInvoker::useSIMD' is not initialized in the constructor. [uninitMemberVar]
    FindStereoCorrespInvoker( const Mat& _left, const Mat& _right,
    ^
modules/calib3d/src/stereobm.cpp:70:16: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'roi2' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        roi1 = roi2 = Rect(0,0,0,0);
               ^
modules/calib3d/src/stereobm.cpp:1054:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'params' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        params = StereoBMParams();
        ^
modules/calib3d/src/stereobm.cpp:1059:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'params' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        params = StereoBMParams(_numDisparities, _SADWindowSize);
        ^
modules/calib3d/src/stereobm.cpp:995:18: style: Variable 'part' is reassigned a value before the old one has been used. [redundantAssignment]
            part = Scalar::all(FILTERED);
                 ^
modules/calib3d/src/stereobm.cpp:994:18: note: part is assigned
            part = disp->rowRange(_row0, row0);
                 ^
modules/calib3d/src/stereobm.cpp:995:18: note: part is overwritten
            part = Scalar::all(FILTERED);
                 ^
modules/calib3d/src/stereobm.cpp:1000:18: style: Variable 'part' is reassigned a value before the old one has been used. [redundantAssignment]
            part = Scalar::all(FILTERED);
                 ^
modules/calib3d/src/stereobm.cpp:999:18: note: part is assigned
            part = disp->rowRange(row1, _row1);
                 ^
modules/calib3d/src/stereobm.cpp:1000:18: note: part is overwritten
            part = Scalar::all(FILTERED);
                 ^
modules/calib3d/src/stereobm.cpp:1028:18: style: Variable 'part' is reassigned a value before the old one has been used. [redundantAssignment]
            part = Scalar::all(FILTERED);
                 ^
modules/calib3d/src/stereobm.cpp:1027:18: note: part is assigned
            part = disp_i.colRange(0, roi.x);
                 ^
modules/calib3d/src/stereobm.cpp:1028:18: note: part is overwritten
            part = Scalar::all(FILTERED);
                 ^
modules/calib3d/src/stereobm.cpp:1033:18: style: Variable 'part' is reassigned a value before the old one has been used. [redundantAssignment]
            part = Scalar::all(FILTERED);
                 ^
modules/calib3d/src/stereobm.cpp:1032:18: note: part is assigned
            part = disp_i.colRange(roi.x + roi.width, cols);
                 ^
modules/calib3d/src/stereobm.cpp:1033:18: note: part is overwritten
            part = Scalar::all(FILTERED);
                 ^
modules/calib3d/src/stereobm.cpp:574:25: style: The scope of the variable 'lptr_sub' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const uchar *lptr, *lptr_sub, *rptr;
                        ^
modules/calib3d/src/stereobm.cpp:995:18: style: Variable 'part' is assigned a value that is never used. [unreadVariable]
            part = Scalar::all(FILTERED);
                 ^
modules/calib3d/src/stereobm.cpp:1000:18: style: Variable 'part' is assigned a value that is never used. [unreadVariable]
            part = Scalar::all(FILTERED);
                 ^
modules/calib3d/src/stereobm.cpp:1028:18: style: Variable 'part' is assigned a value that is never used. [unreadVariable]
            part = Scalar::all(FILTERED);
                 ^
modules/calib3d/src/stereobm.cpp:1033:18: style: Variable 'part' is assigned a value that is never used. [unreadVariable]
            part = Scalar::all(FILTERED);
                 ^
modules/calib3d/src/stereobm.cpp:1150:19: style: Variable 'disp0' is assigned a value that is never used. [unreadVariable]
            disp0 = Scalar::all( FILTERED * ( disp0.type() < CV_32F ? 1 : 1./(1 << disp_shift) ) );
                  ^
modules/calib3d/src/stereobm.cpp:312:25: style: The scope of the variable 'lptr_sub' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const uchar *lptr, *lptr_sub, *rptr;
                        ^
modules/calib3d/src/stereobm.cpp:289:83: style: Parameter 'state' can be declared with const [constParameter]
                                            Mat& disp, Mat& cost, StereoBMParams& state,
                                                                                  ^
modules/calib3d/src/stereosgbm.cpp:2136:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'params' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        params = StereoSGBMParams();
        ^
modules/calib3d/src/stereosgbm.cpp:2144:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'params' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        params = StereoSGBMParams( _minDisparity, _numDisparities, _SADWindowSize,
        ^
modules/calib3d/src/stereosgbm.cpp:1969:14: style: Redundant initialization for 'cur_disp'. The initialized value is overwritten before it is read. [redundantInitialization]
    cur_disp = Scalar(INVALID_DISP_SCALED);
             ^
modules/calib3d/src/stereosgbm.cpp:1968:20: note: cur_disp is initialized
    Mat cur_disp   = dst_disp[range.start];
                   ^
modules/calib3d/src/stereosgbm.cpp:1969:14: note: cur_disp is overwritten
    cur_disp = Scalar(INVALID_DISP_SCALED);
             ^
modules/calib3d/src/stereosgbm.cpp:1597:9: style: Finding variables 'horPassCostVolumeSize' and 'vertPassCostVolumeSize' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
    int horPassCostVolumeSize  = costVolumeLineSize_ext*sizeof(CostType); // buffer for the 2-pass horizontal cost aggregation
        ^
modules/calib3d/src/stereosgbm.cpp:1598:9: note: Same expression used in consecutive assignments of 'horPassCostVolumeSize' and 'vertPassCostVolumeSize'.
    int vertPassCostVolumeSize = costVolumeLineSize_ext*sizeof(CostType); // buffer for the vertical cost aggregation
        ^
modules/calib3d/src/stereosgbm.cpp:1597:9: note: Same expression used in consecutive assignments of 'horPassCostVolumeSize' and 'vertPassCostVolumeSize'.
    int horPassCostVolumeSize  = costVolumeLineSize_ext*sizeof(CostType); // buffer for the 2-pass horizontal cost aggregation
        ^
modules/calib3d/src/stereosgbm.cpp:1603:9: style: Finding variables 'disp2CostBufSize' and 'disp2BufSize' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
    int disp2CostBufSize = width*sizeof(CostType);
        ^
modules/calib3d/src/stereosgbm.cpp:1604:9: note: Same expression used in consecutive assignments of 'disp2CostBufSize' and 'disp2BufSize'.
    int disp2BufSize     = width*sizeof(short);
        ^
modules/calib3d/src/stereosgbm.cpp:1603:9: note: Same expression used in consecutive assignments of 'disp2CostBufSize' and 'disp2BufSize'.
    int disp2CostBufSize = width*sizeof(CostType);
        ^
modules/calib3d/src/stereosgbm.cpp:1166:18: style: The scope of the variable 'minLr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        CostType minLr;
                 ^
modules/calib3d/src/stereosgbm.cpp:1818:18: style: The scope of the variable 'tmp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        CostType tmp;
                 ^
modules/calib3d/src/stereosgbm.cpp:1916:18: style: The scope of the variable 'tmp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        CostType tmp;
                 ^
modules/calib3d/src/stereosgbm.cpp:2118:12: style: The scope of the variable 'dst_row' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    short* dst_row;
           ^
modules/calib3d/src/stereosgbm.cpp:2119:12: style: The scope of the variable 'src_row' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    short* src_row;
           ^
modules/calib3d/src/triangulate.cpp:316:27: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
        tmp31->data.db[2] /= tmp31->data.db[2];
                          ^
modules/calib3d/src/triangulate.cpp:327:27: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
        tmp31->data.db[2] /= tmp31->data.db[2];
                          ^
modules/calib3d/src/triangulate.cpp:198:12: style: The scope of the variable 'x1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x1, y1, x2, y2;
           ^
modules/calib3d/src/triangulate.cpp:198:16: style: The scope of the variable 'y1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x1, y1, x2, y2;
               ^
modules/calib3d/src/triangulate.cpp:198:20: style: The scope of the variable 'x2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x1, y1, x2, y2;
                   ^
modules/calib3d/src/triangulate.cpp:198:24: style: The scope of the variable 'y2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x1, y1, x2, y2;
                       ^
modules/calib3d/src/triangulate.cpp:199:12: style: The scope of the variable 'scale' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double scale;
           ^
modules/calib3d/src/triangulate.cpp:200:12: style: The scope of the variable 'f1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double f1, f2, a, b, c, d;
           ^
modules/calib3d/src/triangulate.cpp:200:16: style: The scope of the variable 'f2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double f1, f2, a, b, c, d;
               ^
modules/calib3d/src/triangulate.cpp:200:20: style: The scope of the variable 'a' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double f1, f2, a, b, c, d;
                   ^
modules/calib3d/src/triangulate.cpp:200:23: style: The scope of the variable 'b' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double f1, f2, a, b, c, d;
                      ^
modules/calib3d/src/triangulate.cpp:200:26: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double f1, f2, a, b, c, d;
                         ^
modules/calib3d/src/triangulate.cpp:200:29: style: The scope of the variable 'd' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double f1, f2, a, b, c, d;
                            ^
modules/calib3d/src/triangulate.cpp:203:12: style: The scope of the variable 't_min' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double t_min, s_val, t, s;
           ^
modules/calib3d/src/triangulate.cpp:203:19: style: The scope of the variable 's_val' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double t_min, s_val, t, s;
                  ^
modules/calib3d/src/upnp.cpp:113:7: style: Redundant initialization for 'MtM'. The initialized value is overwritten before it is read. [redundantInitialization]
  MtM = M->t() * (*M);
      ^
modules/calib3d/src/upnp.cpp:108:11: note: MtM is initialized
  Mat MtM = Mat(12, 12, CV_64F, mtm);
          ^
modules/calib3d/src/upnp.cpp:113:7: note: MtM is overwritten
  MtM = M->t() * (*M);
      ^
modules/calib3d/src/upnp.cpp:287:12: style: Redundant initialization for 'ALPHAS'. The initialized value is overwritten before it is read. [redundantInitialization]
    ALPHAS = Mat( CC_.inv() * PC_ ).t();
           ^
modules/calib3d/src/upnp.cpp:276:16: note: ALPHAS is initialized
    Mat ALPHAS = Mat(number_of_correspondences, 4, CV_64F, &alphas[0]);
               ^
modules/calib3d/src/upnp.cpp:287:12: note: ALPHAS is overwritten
    ALPHAS = Mat( CC_.inv() * PC_ ).t();
           ^
modules/calib3d/src/upnp.cpp:147:38: warning: Function 'copy_R_and_t' argument order different: declaration 'R_dst, t_dst, R_src, t_src' definition 'R_src, t_src, R_dst, t_dst' [funcArgOrderDifferent]
void upnp::copy_R_and_t(const double R_src[3][3], const double t_src[3],
                                     ^
modules/calib3d/src/upnp.h:122:38: note: Function 'copy_R_and_t' argument order different: declaration 'R_dst, t_dst, R_src, t_src' definition 'R_src, t_src, R_dst, t_dst'
      void copy_R_and_t(const double R_dst[3][3], const double t_dst[3],
                                     ^
modules/calib3d/src/upnp.cpp:147:38: note: Function 'copy_R_and_t' argument order different: declaration 'R_dst, t_dst, R_src, t_src' definition 'R_src, t_src, R_dst, t_dst'
void upnp::copy_R_and_t(const double R_src[3][3], const double t_src[3],
                                     ^
modules/calib3d/src/upnp.cpp:287:12: style: Variable 'ALPHAS' is assigned a value that is never used. [unreadVariable]
    ALPHAS = Mat( CC_.inv() * PC_ ).t();
           ^
modules/calib3d/test/opencl/test_stereobm.cpp:80:1: error: syntax error [syntaxError]
OCL_TEST_P(StereoBMFixture, StereoBM)
^
modules/calib3d/test/test_affine2d_estimator.cpp:51:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(Method, RANSAC, LMEDS)
^
modules/calib3d/test/test_affine3d_estimator.cpp:80:5: style: Struct 'WrapAff' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    WrapAff(const Mat& aff) : F(aff.ptr<double>()) {}
    ^
modules/calib3d/test/test_affine3d_estimator.cpp:123:5: style: Struct 'Noise' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Noise(float level) : l(level) {}
    ^
modules/calib3d/test/test_affine3d_estimator.cpp:126:14: style: Variable 'rng' can be declared with const [constVariable]
        RNG& rng = theRNG();
             ^
modules/calib3d/test/test_affine_partial2d_estimator.cpp:51:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(Method, RANSAC, LMEDS)
^
modules/calib3d/test/test_cameracalibration.cpp:726:18: style: The function 'calibrate' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void calibrate( int imageCount, int* pointCounts,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:259:18: note: Virtual function in base class
    virtual void calibrate( int imageCount, int* pointCounts,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:726:18: note: Function in derived class
    virtual void calibrate( int imageCount, int* pointCounts,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:730:18: style: The function 'project' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void project( int pointCount, CvPoint3D64f* objectPoints,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:263:18: note: Virtual function in base class
    virtual void project( int pointCount, CvPoint3D64f* objectPoints,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:730:18: note: Function in derived class
    virtual void project( int pointCount, CvPoint3D64f* objectPoints,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:785:18: style: The function 'calibrate' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void calibrate( int imageCount, int* pointCounts,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:259:18: note: Virtual function in base class
    virtual void calibrate( int imageCount, int* pointCounts,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:785:18: note: Function in derived class
    virtual void calibrate( int imageCount, int* pointCounts,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:789:18: style: The function 'project' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void project( int pointCount, CvPoint3D64f* objectPoints,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:263:18: note: Virtual function in base class
    virtual void project( int pointCount, CvPoint3D64f* objectPoints,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:789:18: note: Function in derived class
    virtual void project( int pointCount, CvPoint3D64f* objectPoints,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1005:18: style: The function 'calibMatrixValues' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void calibMatrixValues( const Mat& cameraMatrix, Size imageSize,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:902:18: note: Virtual function in base class
    virtual void calibMatrixValues( const Mat& cameraMatrix, Size imageSize,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1005:18: note: Function in derived class
    virtual void calibMatrixValues( const Mat& cameraMatrix, Size imageSize,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1031:18: style: The function 'calibMatrixValues' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void calibMatrixValues( const Mat& cameraMatrix, Size imageSize,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:902:18: note: Virtual function in base class
    virtual void calibMatrixValues( const Mat& cameraMatrix, Size imageSize,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1031:18: note: Function in derived class
    virtual void calibMatrixValues( const Mat& cameraMatrix, Size imageSize,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1288:18: style: The function 'project' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void project( const Mat& objectPoints,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1079:18: note: Virtual function in base class
    virtual void project( const Mat& objectPoints,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1288:18: note: Function in derived class
    virtual void project( const Mat& objectPoints,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1325:18: style: The function 'project' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void project( const Mat& objectPoints,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1079:18: note: Virtual function in base class
    virtual void project( const Mat& objectPoints,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1325:18: note: Function in derived class
    virtual void project( const Mat& objectPoints,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1866:20: style: The function 'calibrateStereoCamera' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double calibrateStereoCamera( const vector<vector<Point3f> >& objectPoints,
                   ^
modules/calib3d/test/test_cameracalibration.cpp:1464:20: note: Virtual function in base class
    virtual double calibrateStereoCamera( const vector<vector<Point3f> >& objectPoints,
                   ^
modules/calib3d/test/test_cameracalibration.cpp:1866:20: note: Function in derived class
    virtual double calibrateStereoCamera( const vector<vector<Point3f> >& objectPoints,
                   ^
modules/calib3d/test/test_cameracalibration.cpp:1873:18: style: The function 'rectify' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void rectify( const Mat& cameraMatrix1, const Mat& distCoeffs1,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1471:18: note: Virtual function in base class
    virtual void rectify( const Mat& cameraMatrix1, const Mat& distCoeffs1,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1873:18: note: Function in derived class
    virtual void rectify( const Mat& cameraMatrix1, const Mat& distCoeffs1,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1879:18: style: The function 'rectifyUncalibrated' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool rectifyUncalibrated( const Mat& points1,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1477:18: note: Virtual function in base class
    virtual bool rectifyUncalibrated( const Mat& points1,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1879:18: note: Function in derived class
    virtual bool rectifyUncalibrated( const Mat& points1,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1882:18: style: The function 'triangulate' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void triangulate( const Mat& P1, const Mat& P2,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1480:18: note: Virtual function in base class
    virtual void triangulate( const Mat& P1, const Mat& P2,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1882:18: note: Function in derived class
    virtual void triangulate( const Mat& P1, const Mat& P2,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1885:18: style: The function 'correct' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void correct( const Mat& F,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1483:18: note: Virtual function in base class
    virtual void correct( const Mat& F,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1885:18: note: Function in derived class
    virtual void correct( const Mat& F,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1999:20: style: The function 'calibrateStereoCamera' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double calibrateStereoCamera( const vector<vector<Point3f> >& objectPoints,
                   ^
modules/calib3d/test/test_cameracalibration.cpp:1464:20: note: Virtual function in base class
    virtual double calibrateStereoCamera( const vector<vector<Point3f> >& objectPoints,
                   ^
modules/calib3d/test/test_cameracalibration.cpp:1999:20: note: Function in derived class
    virtual double calibrateStereoCamera( const vector<vector<Point3f> >& objectPoints,
                   ^
modules/calib3d/test/test_cameracalibration.cpp:2006:18: style: The function 'rectify' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void rectify( const Mat& cameraMatrix1, const Mat& distCoeffs1,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1471:18: note: Virtual function in base class
    virtual void rectify( const Mat& cameraMatrix1, const Mat& distCoeffs1,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:2006:18: note: Function in derived class
    virtual void rectify( const Mat& cameraMatrix1, const Mat& distCoeffs1,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:2012:18: style: The function 'rectifyUncalibrated' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool rectifyUncalibrated( const Mat& points1,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1477:18: note: Virtual function in base class
    virtual bool rectifyUncalibrated( const Mat& points1,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:2012:18: note: Function in derived class
    virtual bool rectifyUncalibrated( const Mat& points1,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:2015:18: style: The function 'triangulate' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void triangulate( const Mat& P1, const Mat& P2,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1480:18: note: Virtual function in base class
    virtual void triangulate( const Mat& P1, const Mat& P2,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:2015:18: note: Function in derived class
    virtual void triangulate( const Mat& P1, const Mat& P2,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:2018:18: style: The function 'correct' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void correct( const Mat& F,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:1483:18: note: Virtual function in base class
    virtual void correct( const Mat& F,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:2018:18: note: Function in derived class
    virtual void correct( const Mat& F,
                 ^
modules/calib3d/test/test_cameracalibration.cpp:359:23: warning: fscanf() without field width limits can crash with huge input data. Add a field width specifier to fix this problem.

Sample program that can crash:

#include <stdio.h>
int main()
{
    char c[5];
    scanf("%s", c);
    return 0;
}

Typing in 5 or more characters may make the program crash. The correct usage here is 'scanf("%4s", c);', as the maximum field width does not include the terminating null byte.
Source: http://linux.die.net/man/3/scanf
Source: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c [invalidscanf]
        values_read = fscanf(datafile,"%s",i_dat_file);
                      ^
modules/calib3d/test/test_cameracalibration.cpp:927:12: style: Finding variables 'apertureWidth' and 'apertureHeight' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
    double apertureWidth = (double)rng * apertureMaxVal,
           ^
modules/calib3d/test/test_cameracalibration.cpp:928:12: note: Same expression used in consecutive assignments of 'apertureWidth' and 'apertureHeight'.
           apertureHeight = (double)rng * apertureMaxVal;
           ^
modules/calib3d/test/test_cameracalibration.cpp:927:12: note: Same expression used in consecutive assignments of 'apertureWidth' and 'apertureHeight'.
    double apertureWidth = (double)rng * apertureMaxVal,
           ^
modules/calib3d/test/test_cameracalibration.cpp:941:30: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [knownConditionTrueFalse]
    if( apertureWidth != 0.0 && apertureHeight != 0.0 )
                             ^
modules/calib3d/test/test_cameracalibration.cpp:927:40: note: 'apertureWidth' is assigned value '(double)rng*apertureMaxVal' here.
    double apertureWidth = (double)rng * apertureMaxVal,
                                       ^
modules/calib3d/test/test_cameracalibration.cpp:928:41: note: 'apertureHeight' is assigned value '(double)rng*apertureMaxVal' here.
           apertureHeight = (double)rng * apertureMaxVal;
                                        ^
modules/calib3d/test/test_cameracalibration.cpp:941:30: note: Same expression on both sides of '&&' because 'apertureWidth!=0.0' and 'apertureHeight!=0.0' represent the same value.
    if( apertureWidth != 0.0 && apertureHeight != 0.0 )
                             ^
modules/calib3d/test/test_cameracalibration.cpp:1558:11: style: The scope of the variable 'f' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    FILE* f = 0;
          ^
modules/calib3d/test/test_cameracalibration.cpp:1114:32: warning: Found suspicious operator ',' [constStatement]
                    0.f,    0.f,    1.f;
                               ^
modules/calib3d/test/test_cameracalibration.cpp:1115:35: warning: Found suspicious operator ',' [constStatement]
    distCoeffs << 0.1, 0.01, 0.001, 0.001;
                                  ^
modules/calib3d/test/test_cameracalibration.cpp:1558:13: style: Variable 'f' is assigned a value that is never used. [unreadVariable]
    FILE* f = 0;
            ^
modules/calib3d/test/test_cameracalibration_artificial.cpp:385:20: style: Finding variables 'fx' and 'fy' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
            double fx = 300 + (20 * (double)rng - 10);
                   ^
modules/calib3d/test/test_cameracalibration_artificial.cpp:386:20: note: Same expression used in consecutive assignments of 'fx' and 'fy'.
            double fy = 300 + (20 * (double)rng - 10);
                   ^
modules/calib3d/test/test_cameracalibration_artificial.cpp:385:20: note: Same expression used in consecutive assignments of 'fx' and 'fy'.
            double fx = 300 + (20 * (double)rng - 10);
                   ^
modules/calib3d/test/test_cameracalibration_artificial.cpp:395:20: style: Finding variables 'k2' and 'k3' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
            double k2 = (double)rng/5;
                   ^
modules/calib3d/test/test_cameracalibration_artificial.cpp:396:20: note: Same expression used in consecutive assignments of 'k2' and 'k3'.
            double k3 = (double)rng/5;
                   ^
modules/calib3d/test/test_cameracalibration_artificial.cpp:395:20: note: Same expression used in consecutive assignments of 'k2' and 'k3'.
            double k2 = (double)rng/5;
                   ^
modules/calib3d/test/test_cameracalibration_artificial.cpp:398:20: style: Finding variables 'p1' and 'p2' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
            double p1 = 0.001 + (double)rng/10;
                   ^
modules/calib3d/test/test_cameracalibration_artificial.cpp:399:20: note: Same expression used in consecutive assignments of 'p1' and 'p2'.
            double p2 = 0.001 + (double)rng/10;
                   ^
modules/calib3d/test/test_cameracalibration_artificial.cpp:398:20: note: Same expression used in consecutive assignments of 'p1' and 'p2'.
            double p1 = 0.001 + (double)rng/10;
                   ^
modules/calib3d/test/test_cameracalibration_artificial.cpp:392:52: warning: Found suspicious operator ',' [constStatement]
            camMat << fx, 0., cx, 0, fy, cy, 0., 0., 1.;
                                                   ^
modules/calib3d/test/test_cameracalibration_artificial.cpp:402:41: warning: Found suspicious operator ',' [constStatement]
            distCoeffs << k1, k2, p1, p2, k3;
                                        ^
modules/calib3d/test/test_cameracalibration_artificial.cpp:373:14: style: Variable 'rng' can be declared with const [constVariable]
        RNG& rng = theRNG();
             ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:292:11: style: Variable 'CM[1]' is reassigned a value before the old one has been used. [redundantAssignment]
    CM[1] = 0;
          ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:289:11: note: CM[1] is assigned
    CM[1] = 0.1; //Non-zero skew
          ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:292:11: note: CM[1] is overwritten
    CM[1] = 0;
          ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:296:11: style: Variable 'CM[3]' is reassigned a value before the old one has been used. [redundantAssignment]
    CM[3] = 0; CM[6] = 0.1; /* mad matrix shape */
          ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:293:11: note: CM[3] is assigned
    CM[3] = 0.1; /* mad matrix shape */
          ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:296:11: note: CM[3] is overwritten
    CM[3] = 0; CM[6] = 0.1; /* mad matrix shape */
          ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:304:11: style: Variable 'CM[8]' is reassigned a value before the old one has been used. [redundantAssignment]
    CM[8] = 1.0;
          ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:302:44: note: CM[8] is assigned
    CM[3] = 0; CM[6] = 0; CM[7] = 0; CM[8] = 1.1; /* mad matrix shape */
                                           ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:304:11: note: CM[8] is overwritten
    CM[8] = 1.0;
          ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:93:84: warning: Found suspicious operator ',' [constStatement]
    camMat << 300.f, 0.f, imgSize.width/2.f, 0, 300.f, imgSize.height/2.f, 0.f, 0.f, 1.f;
                                                                                   ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:94:40: warning: Found suspicious operator ',' [constStatement]
    distCoeffs0 << 1.2f, 0.2f, 0.f, 0.f, 0.f;
                                       ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:460:88: warning: Found suspicious operator ',' [constStatement]
        camMat << 300.f, 0.f, imsSize.width/2.f, 0, 300.f, imsSize.height/2.f, 0.f, 0.f, 1.f;
                                                                                       ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:461:43: warning: Found suspicious operator ',' [constStatement]
        distCoeffs << 1.2f, 0.2f, 0.f, 0.f, 0.f;
                                          ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:311:14: style: Variable 'rng' can be declared with const [constVariable]
    cv::RNG& rng = theRNG();
             ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.src [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.dst [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.jacobian [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.objectPoints [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.r_vec [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.t_vec [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.A [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.imagePoints [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.dpdr [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.dpdt [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.dpdf [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.dpdc [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.dpdk [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:154:18: error: Uninitialized struct member: caller.aspectRatio [uninitStructMember]
    bad_caller = caller;
                 ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.objPts [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.imgPts [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.npoints [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.cameraMatrix [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.distCoeffs [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.rvecs [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.tvecs [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.flags [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.objectPoints [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.r_vec [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.t_vec [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.A [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.imagePoints [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.dpdr [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.dpdt [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.dpdf [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.dpdc [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.dpdk [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:371:22: error: Uninitialized struct member: caller.aspectRatio [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:539:22: error: Uninitialized struct member: caller.objPts [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:539:22: error: Uninitialized struct member: caller.imgPts [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:539:22: error: Uninitialized struct member: caller.npoints [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:539:22: error: Uninitialized struct member: caller.cameraMatrix [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:539:22: error: Uninitialized struct member: caller.rvecs [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:539:22: error: Uninitialized struct member: caller.tvecs [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:539:22: error: Uninitialized struct member: caller.flags [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:539:22: error: Uninitialized struct member: caller.src [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:539:22: error: Uninitialized struct member: caller.dst [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_badarg.cpp:539:22: error: Uninitialized struct member: caller.jacobian [uninitStructMember]
        bad_caller = caller;
                     ^
modules/calib3d/test/test_cameracalibration_tilt.cpp:65:5: warning: Member variable 'cameraCalibrationTiltTest::m_imageDistance' is not initialized in the constructor. [uninitMemberVar]
    cameraCalibrationTiltTest()
    ^
modules/calib3d/test/test_cameracalibration_tilt.cpp:65:5: warning: Member variable 'cameraCalibrationTiltTest::m_imageTiltDegree' is not initialized in the constructor. [uninitMemberVar]
    cameraCalibrationTiltTest()
    ^
modules/calib3d/test/test_cameracalibration_tilt.cpp:323:23: warning: Redundant assignment of '*(param[col])' to itself. [selfAssignment]
        *(param[col]) = save;
                      ^
modules/calib3d/test/test_cameracalibration_tilt.cpp:128:47: style: Parameter 'coeff' can be declared with const [constParameter]
        cv::Vec<double, NUM_DIST_COEFF_TILT>& coeff,
                                              ^
modules/calib3d/test/test_chessboardgenerator.cpp:75:5: style: Struct 'Mult' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Mult(int mult) : m((float)mult) {}
    ^
modules/calib3d/test/test_chesscorners.cpp:85:5: style: Class 'CV_ChessboardDetectorTest' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ChessboardDetectorTest( Pattern pattern, int algorithmFlags = 0 );
    ^
modules/calib3d/test/test_chesscorners.cpp:343:17: style: Variable 'tmp' is reassigned a value before the old one has been used. [redundantAssignment]
            tmp = norm( cur - mat(i - 1, j + 1 ) );
                ^
modules/calib3d/test/test_chesscorners.cpp:341:21: note: tmp is assigned
                tmp = minNeibDist;
                    ^
modules/calib3d/test/test_chesscorners.cpp:343:17: note: tmp is overwritten
            tmp = norm( cur - mat(i - 1, j + 1 ) );
                ^
modules/calib3d/test/test_chesscorners.cpp:347:17: style: Variable 'tmp' is reassigned a value before the old one has been used. [redundantAssignment]
            tmp = norm( cur - mat(i + 1, j - 1) );
                ^
modules/calib3d/test/test_chesscorners.cpp:345:21: note: tmp is assigned
                tmp = minNeibDist;
                    ^
modules/calib3d/test/test_chesscorners.cpp:347:17: note: tmp is overwritten
            tmp = norm( cur - mat(i + 1, j - 1) );
                ^
modules/calib3d/test/test_chesscorners.cpp:351:17: style: Variable 'tmp' is reassigned a value before the old one has been used. [redundantAssignment]
            tmp = norm( cur - mat(i - 1, j - 1) );
                ^
modules/calib3d/test/test_chesscorners.cpp:349:21: note: tmp is assigned
                tmp = minNeibDist;
                    ^
modules/calib3d/test/test_chesscorners.cpp:351:17: note: tmp is overwritten
            tmp = norm( cur - mat(i - 1, j - 1) );
                ^
modules/calib3d/test/test_chesscorners.cpp:375:71: warning: Found suspicious operator ',' [constStatement]
    camMat << 300.f, 0.f, bg.cols/2.f, 0, 300.f, bg.rows/2.f, 0.f, 0.f, 1.f;
                                                                      ^
modules/calib3d/test/test_chesscorners.cpp:378:39: warning: Found suspicious operator ',' [constStatement]
    distCoeffs << 1.2f, 0.2f, 0.f, 0.f, 0.f;
                                      ^
modules/calib3d/test/test_chesscorners.cpp:444:48: warning: Found suspicious operator ',' [constStatement]
        aff << 1.0, 0.0, -(double)c.x, 0.0, 1.0, 0.0;
                                               ^
modules/calib3d/test/test_chesscorners.cpp:333:16: style: Variable 'tmp' is assigned a value that is never used. [unreadVariable]
    double tmp = 0;
               ^
modules/calib3d/test/test_chesscorners.cpp:353:21: style: Variable 'tmp' is assigned a value that is never used. [unreadVariable]
                tmp = minNeibDist;
                    ^
modules/calib3d/test/test_chesscorners.cpp:307:15: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [knownConditionTrueFalse]
    if (count != 0)
              ^
modules/calib3d/test/test_chesscorners.cpp:215:17: note: 'count' is assigned value '0' here.
    int count = 0;
                ^
modules/calib3d/test/test_chesscorners.cpp:307:15: note: The expression 'count != 0' is always false.
    if (count != 0)
              ^
modules/calib3d/test/test_chesscorners.cpp:299:21: style: Local variable 'fs' shadows outer variable [shadowVariable]
        FileStorage fs(_filename, FileStorage::WRITE);
                    ^
modules/calib3d/test/test_chesscorners.cpp:200:17: note: Shadowed declaration
    FileStorage fs( folder + filename, FileStorage::READ );
                ^
modules/calib3d/test/test_chesscorners.cpp:299:21: note: Shadow variable
        FileStorage fs(_filename, FileStorage::WRITE);
                    ^
modules/calib3d/test/test_chesscorners_badarg.cpp:106:71: warning: Found suspicious operator ',' [constStatement]
    camMat << 300.f, 0.f, bg.cols/2.f, 0, 300.f, bg.rows/2.f, 0.f, 0.f, 1.f;
                                                                      ^
modules/calib3d/test/test_chesscorners_badarg.cpp:108:39: warning: Found suspicious operator ',' [constStatement]
    distCoeffs << 1.2f, 0.2f, 0.f, 0.f, 0.f;
                                      ^
modules/calib3d/test/test_cornerssubpix.cpp:239:82: warning: Found suspicious operator ',' [constStatement]
    intrinsic_matrix_ = (Mat_<double>(3, 3) << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0);
                                                                                 ^
modules/calib3d/test/test_cornerssubpix.cpp:240:63: warning: Found suspicious operator ',' [constStatement]
    distortion_coeffs_ = (Mat_<double>(1, 5) << k1, k2, p1, p2, k3);
                                                              ^
modules/calib3d/test/test_fundam.cpp:1051:16: style: Boolean value assigned to floating point variable. [assignBoolToFloat]
    f_prop2[0] = f_result != 0;
               ^
modules/calib3d/test/test_fundam.cpp:619:26: style: Finding the same value in both branches of ternary operator is suspicious as the same code is executed regardless of the condition. [duplicateValueTernary]
    return j == 4 ? 1e-2 : 1e-2;
                         ^
modules/calib3d/test/test_fundam.cpp:52:11: style: The scope of the variable 'Jf' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float Jf[27];
          ^
modules/calib3d/test/test_fundam.cpp:1462:9: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int t;
        ^
modules/calib3d/test/test_fundam.cpp:351:45: style: Parameter 'dst' can be declared with const [constParameter]
void cvtest::Rodrigues(const Mat& src, Mat& dst, Mat* jac)
                                            ^
modules/calib3d/test/test_fundam.cpp:482:17: style: Variable 'rng' is assigned a value that is never used. [unreadVariable]
            rng = 0;
                ^
modules/calib3d/test/test_posit.cpp:82:11: style: The scope of the variable 'angleX' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float angleX, angleY, angleZ;
          ^
modules/calib3d/test/test_posit.cpp:82:19: style: The scope of the variable 'angleY' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float angleX, angleY, angleZ;
                  ^
modules/calib3d/test/test_posit.cpp:82:27: style: The scope of the variable 'angleZ' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float angleX, angleY, angleZ;
                          ^
modules/calib3d/test/test_reproject_image_to_3d.cpp:99:16: style: The scope of the variable 'tmp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double tmp, sum = 0;
               ^
modules/calib3d/test/test_solvepnp_ransac.cpp:212:18: style: The function 'runTest' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool runTest(RNG& rng, int mode, int method, const vector<Point3f>& points, const double* epsilon, double& maxError)
                 ^
modules/calib3d/test/test_solvepnp_ransac.cpp:116:18: note: Virtual function in base class
    virtual bool runTest(RNG& rng, int mode, int method, const vector<Point3f>& points, const double* epsilon, double& maxError)
                 ^
modules/calib3d/test/test_solvepnp_ransac.cpp:212:18: note: Function in derived class
    virtual bool runTest(RNG& rng, int mode, int method, const vector<Point3f>& points, const double* epsilon, double& maxError)
                 ^
modules/calib3d/test/test_solvepnp_ransac.cpp:282:16: style: The function 'runTest' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool runTest(RNG& rng, int mode, int method, const vector<Point3f>& points, const double* epsilon, double& maxError)
               ^
modules/calib3d/test/test_solvepnp_ransac.cpp:116:18: note: Virtual function in base class
    virtual bool runTest(RNG& rng, int mode, int method, const vector<Point3f>& points, const double* epsilon, double& maxError)
                 ^
modules/calib3d/test/test_solvepnp_ransac.cpp:282:16: note: Function in derived class
  virtual bool runTest(RNG& rng, int mode, int method, const vector<Point3f>& points, const double* epsilon, double& maxError)
               ^
modules/calib3d/test/test_solvepnp_ransac.cpp:320:16: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual void run(int)
               ^
modules/calib3d/test/test_solvepnp_ransac.cpp:155:18: note: Virtual function in base class
    virtual void run(int)
                 ^
modules/calib3d/test/test_solvepnp_ransac.cpp:320:16: note: Function in derived class
  virtual void run(int)
               ^
modules/calib3d/test/test_solvepnp_ransac.cpp:512:36: warning: Found suspicious operator ',' [constStatement]
    rvec =(Mat_<float>(3,1) << 0, 0, 0);
                                   ^
modules/calib3d/test/test_solvepnp_ransac.cpp:513:41: warning: Found suspicious operator ',' [constStatement]
    tvec = (Mat_<float>(3,1) << 100, 100, 0);
                                        ^
modules/calib3d/test/test_solvepnp_ransac.cpp:519:37: warning: Found suspicious operator ',' [constStatement]
    rvec =(Mat_<double>(3,1) << 0, 0, 0);
                                    ^
modules/calib3d/test/test_solvepnp_ransac.cpp:520:42: warning: Found suspicious operator ',' [constStatement]
    tvec = (Mat_<double>(3,1) << 100, 100, 0);
                                         ^
modules/calib3d/test/test_solvepnp_ransac.cpp:543:64: warning: Found suspicious operator ',' [constStatement]
        Mat rvec_ground_truth = (Mat_<double>(3,1) << 0.3, -0.2, 0.75);
                                                               ^
modules/calib3d/test/test_solvepnp_ransac.cpp:544:65: warning: Found suspicious operator ',' [constStatement]
        Mat tvec_ground_truth = (Mat_<double>(3,1) << 0.15, -0.2, 1.5);
                                                                ^
modules/calib3d/test/test_solvepnp_ransac.cpp:549:55: warning: Found suspicious operator ',' [constStatement]
        Mat rvec_est = (Mat_<double>(3,1) << 0.2, -0.1, 0.6);
                                                      ^
modules/calib3d/test/test_solvepnp_ransac.cpp:550:57: warning: Found suspicious operator ',' [constStatement]
        Mat tvec_est = (Mat_<double>(3,1) << 0.05, -0.05, 1.0);
                                                        ^
modules/calib3d/test/test_solvepnp_ransac.cpp:574:66: warning: Found suspicious operator ',' [constStatement]
        Mat rvec_ground_truth = (Mat_<float>(3,1) << -0.75f, 0.4f, 0.34f);
                                                                 ^
modules/calib3d/test/test_solvepnp_ransac.cpp:575:67: warning: Found suspicious operator ',' [constStatement]
        Mat tvec_ground_truth = (Mat_<float>(3,1) << -0.15f, 0.35f, 1.58f);
                                                                  ^
modules/calib3d/test/test_solvepnp_ransac.cpp:580:56: warning: Found suspicious operator ',' [constStatement]
        Mat rvec_est = (Mat_<float>(3,1) << -0.5f, 0.2f, 0.2f);
                                                       ^
modules/calib3d/test/test_solvepnp_ransac.cpp:581:55: warning: Found suspicious operator ',' [constStatement]
        Mat tvec_est = (Mat_<float>(3,1) << 0.0f, 0.2f, 1.0f);
                                                      ^
modules/calib3d/test/test_solvepnp_ransac.cpp:159:33: style: Unused variable: points_dls [unusedVariable]
        vector<Point3f> points, points_dls;
                                ^
modules/calib3d/test/test_stereomatching.cpp:344:5: style: Class 'QualityEvalParams' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    QualityEvalParams( int _ignoreBorder )
    ^
modules/calib3d/test/test_stereomatching.cpp:760:17: style: The function 'readRunParams' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int readRunParams( FileStorage& fs )
                ^
modules/calib3d/test/test_stereomatching.cpp:379:17: note: Virtual function in base class
    virtual int readRunParams( FileStorage& fs );
                ^
modules/calib3d/test/test_stereomatching.cpp:760:17: note: Function in derived class
    virtual int readRunParams( FileStorage& fs )
                ^
modules/calib3d/test/test_stereomatching.cpp:779:17: style: The function 'runStereoMatchingAlgorithm' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int runStereoMatchingAlgorithm( const Mat& _leftImg, const Mat& _rightImg,
                ^
modules/calib3d/test/test_stereomatching.cpp:375:17: note: Virtual function in base class
    virtual int runStereoMatchingAlgorithm( const Mat& leftImg, const Mat& rightImg,
                ^
modules/calib3d/test/test_stereomatching.cpp:779:17: note: Function in derived class
    virtual int runStereoMatchingAlgorithm( const Mat& _leftImg, const Mat& _rightImg,
                ^
modules/calib3d/test/test_stereomatching.cpp:831:17: style: The function 'readRunParams' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int readRunParams( FileStorage& fs )
                ^
modules/calib3d/test/test_stereomatching.cpp:379:17: note: Virtual function in base class
    virtual int readRunParams( FileStorage& fs );
                ^
modules/calib3d/test/test_stereomatching.cpp:831:17: note: Function in derived class
    virtual int readRunParams( FileStorage& fs )
                ^
modules/calib3d/test/test_stereomatching.cpp:850:17: style: The function 'runStereoMatchingAlgorithm' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int runStereoMatchingAlgorithm( const Mat& leftImg, const Mat& rightImg,
                ^
modules/calib3d/test/test_stereomatching.cpp:375:17: note: Virtual function in base class
    virtual int runStereoMatchingAlgorithm( const Mat& leftImg, const Mat& rightImg,
                ^
modules/calib3d/test/test_stereomatching.cpp:850:17: note: Function in derived class
    virtual int runStereoMatchingAlgorithm( const Mat& leftImg, const Mat& rightImg,
                ^
modules/calib3d/test/test_stereomatching.cpp:774:38: error: Uninitialized struct member: params.mode [uninitStructMember]
            caseRunParams.push_back( params );
                                     ^
modules/calib3d/test/test_stereomatching.cpp:845:38: error: Uninitialized struct member: params.mindisp [uninitStructMember]
            caseRunParams.push_back( params );
                                     ^
modules/calib3d/test/test_undistort.cpp:87:101: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    matrix_type = types[INPUT][0] = types[OUTPUT][0]= types[REF_OUTPUT][0] = cvtest::randInt(rng)%2 ? CV_64F : CV_32F;
                                                                                                    ^
modules/calib3d/test/test_undistort.cpp:223:108: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
        types[INPUT][0] = types[OUTPUT][0] = types[REF_OUTPUT][0] = types[TEMP][0]= cvtest::randInt(rng)%2 ? CV_64FC2 : CV_32FC2;
                                                                                                           ^
modules/calib3d/test/test_undistort.cpp:225:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    types[INPUT][1] = cvtest::randInt(rng)%2 ? CV_64F : CV_32F;
                                             ^
modules/calib3d/test/test_undistort.cpp:226:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    types[INPUT][2] = cvtest::randInt(rng)%2 ? CV_64F : CV_32F;
                                             ^
modules/calib3d/test/test_undistort.cpp:227:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    types[INPUT][3] = cvtest::randInt(rng)%2 ? CV_64F : CV_32F;
                                             ^
modules/calib3d/test/test_undistort.cpp:228:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    types[INPUT][4] = cvtest::randInt(rng)%2 ? CV_64F : CV_32F;
                                             ^
modules/calib3d/test/test_undistort.cpp:230:104: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    sizes[INPUT][0] = sizes[OUTPUT][0] = sizes[REF_OUTPUT][0] = sizes[TEMP][0]= cvtest::randInt(rng)%2 ? cvSize(1,N_POINTS) : cvSize(N_POINTS,1);
                                                                                                       ^
modules/calib3d/test/test_undistort.cpp:232:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    sizes[INPUT][4] = cvtest::randInt(rng)%2 ? cvSize(3,3) : cvSize(4,3);
                                             ^
modules/calib3d/test/test_undistort.cpp:629:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    types[INPUT][1] = cvtest::randInt(rng)%2 ? CV_64F : CV_32F;
                                             ^
modules/calib3d/test/test_undistort.cpp:630:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    types[INPUT][2] = cvtest::randInt(rng)%2 ? CV_64F : CV_32F;
                                             ^
modules/calib3d/test/test_undistort.cpp:631:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    types[INPUT][3] = cvtest::randInt(rng)%2 ? CV_64F : CV_32F;
                                             ^
modules/calib3d/test/test_undistort.cpp:632:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    types[INPUT][4] = cvtest::randInt(rng)%2 ? CV_64F : CV_32F;
                                             ^
modules/calib3d/test/test_undistort.cpp:308:21: style: Variable 'dist[4]' is assigned a value that is never used. [unreadVariable]
            dist[4] = cvtest::randReal(rng)*0.004 - 0.002;
                    ^
modules/calib3d/test/test_undistort.cpp:314:21: style: Variable 'dist[4]' is assigned a value that is never used. [unreadVariable]
            dist[4] = 0;
                    ^
modules/calib3d/test/test_undistort.cpp:324:21: style: Variable 'proj[4]' is assigned a value that is never used. [unreadVariable]
            proj[4] = 1;
                    ^
modules/calib3d/test/test_undistort.cpp:331:21: style: Variable 'proj[5]' is assigned a value that is never used. [unreadVariable]
            proj[5] = cam[5] + (cvtest::randReal(rng) - (double)0.5)*0.3*img_size.height; //15%
                    ^
modules/calib3d/test/test_undistort.cpp:344:18: style: Variable 'proj[11]' is assigned a value that is never used. [unreadVariable]
        proj[11] = (img_size.height + img_size.width - 1)*0.5 + cvtest::randReal(rng)*10 - 5;
                 ^
modules/calib3d/test/test_undistort.cpp:732:21: style: Variable 'dist[4]' is assigned a value that is never used. [unreadVariable]
            dist[4] = cvtest::randReal(rng)*0.004 - 0.002;
                    ^
modules/calib3d/test/test_undistort.cpp:738:21: style: Variable 'dist[4]' is assigned a value that is never used. [unreadVariable]
            dist[4] = 0;
                    ^
modules/calib3d/test/test_undistort.cpp:753:16: style: Variable 'new_cam[5]' is assigned a value that is never used. [unreadVariable]
    new_cam[5] = cam[5] + (cvtest::randReal(rng) - (double)0.5)*0.3*img_size.height; //15%
               ^
modules/calib3d/test/test_undistort_badarg.cpp:170:5: error: Non-local variable '_dst_points' will use pointer to local variable '_dst_points_orig'. [danglingLifetime]
    _dst_points = &_dst_points_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:170:19: note: Address of variable taken here.
    _dst_points = &_dst_points_orig;
                  ^
modules/calib3d/test/test_undistort_badarg.cpp:120:11: note: Variable created here.
    CvMat _dst_points_orig = cvMat(1,4,CV_64FC2,d_points);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:170:5: note: Non-local variable '_dst_points' will use pointer to local variable '_dst_points_orig'.
    _dst_points = &_dst_points_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:176:5: error: Non-local variable '_src_points' will use pointer to local variable '_src_points_orig'. [danglingLifetime]
    _src_points = &_src_points_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:176:19: note: Address of variable taken here.
    _src_points = &_src_points_orig;
                  ^
modules/calib3d/test/test_undistort_badarg.cpp:119:11: note: Variable created here.
    CvMat _src_points_orig = cvMat(1,4,CV_64FC2,s_points);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:176:5: note: Non-local variable '_src_points' will use pointer to local variable '_src_points_orig'.
    _src_points = &_src_points_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:194:5: error: Non-local variable '_camera_mat' will use pointer to local variable '_camera_mat_orig'. [danglingLifetime]
    _camera_mat = &_camera_mat_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:194:19: note: Address of variable taken here.
    _camera_mat = &_camera_mat_orig;
                  ^
modules/calib3d/test/test_undistort_badarg.cpp:115:11: note: Variable created here.
    CvMat _camera_mat_orig = cvMat(3,3,CV_64F,cam);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:194:5: note: Non-local variable '_camera_mat' will use pointer to local variable '_camera_mat_orig'.
    _camera_mat = &_camera_mat_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:211:5: error: Non-local variable '_distortion_coeffs' will use pointer to local variable '_distortion_coeffs_orig'. [danglingLifetime]
    _distortion_coeffs = &_distortion_coeffs_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:211:26: note: Address of variable taken here.
    _distortion_coeffs = &_distortion_coeffs_orig;
                         ^
modules/calib3d/test/test_undistort_badarg.cpp:116:11: note: Variable created here.
    CvMat _distortion_coeffs_orig = cvMat(1,4,CV_64F,dist);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:211:5: note: Non-local variable '_distortion_coeffs' will use pointer to local variable '_distortion_coeffs_orig'.
    _distortion_coeffs = &_distortion_coeffs_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:228:5: error: Non-local variable 'matR' will use pointer to local variable '_R_orig'. [danglingLifetime]
    matR = &_R_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:228:12: note: Address of variable taken here.
    matR = &_R_orig;
           ^
modules/calib3d/test/test_undistort_badarg.cpp:118:11: note: Variable created here.
    CvMat _R_orig = cvMat(3,3,CV_64F,r);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:228:5: note: Non-local variable 'matR' will use pointer to local variable '_R_orig'.
    matR = &_R_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:246:5: error: Non-local variable 'matP' will use pointer to local variable '_P_orig'. [danglingLifetime]
    matP = &_P_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:246:12: note: Address of variable taken here.
    matP = &_P_orig;
           ^
modules/calib3d/test/test_undistort_badarg.cpp:117:11: note: Variable created here.
    CvMat _P_orig = cvMat(3,3,CV_64F,p);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:246:5: note: Non-local variable 'matP' will use pointer to local variable '_P_orig'.
    matP = &_P_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:356:5: error: Non-local variable '_camera_mat' will use pointer to local variable '_camera_mat_orig'. [danglingLifetime]
    _camera_mat = &_camera_mat_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:356:19: note: Address of variable taken here.
    _camera_mat = &_camera_mat_orig;
                  ^
modules/calib3d/test/test_undistort_badarg.cpp:348:11: note: Variable created here.
    CvMat _camera_mat_orig = cvMat(3,3,CV_64F,cam);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:356:5: note: Non-local variable '_camera_mat' will use pointer to local variable '_camera_mat_orig'.
    _camera_mat = &_camera_mat_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:357:5: error: Non-local variable '_distortion_coeffs' will use pointer to local variable '_distortion_coeffs_orig'. [danglingLifetime]
    _distortion_coeffs = &_distortion_coeffs_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:357:26: note: Address of variable taken here.
    _distortion_coeffs = &_distortion_coeffs_orig;
                         ^
modules/calib3d/test/test_undistort_badarg.cpp:349:11: note: Variable created here.
    CvMat _distortion_coeffs_orig = cvMat(1,4,CV_64F,dist);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:357:5: note: Non-local variable '_distortion_coeffs' will use pointer to local variable '_distortion_coeffs_orig'.
    _distortion_coeffs = &_distortion_coeffs_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:358:5: error: Non-local variable '_new_camera_mat' will use pointer to local variable '_new_camera_mat_orig'. [danglingLifetime]
    _new_camera_mat = &_new_camera_mat_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:358:23: note: Address of variable taken here.
    _new_camera_mat = &_new_camera_mat_orig;
                      ^
modules/calib3d/test/test_undistort_badarg.cpp:350:11: note: Variable created here.
    CvMat _new_camera_mat_orig = cvMat(3,3,CV_64F,arr_new_camera_mat);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:358:5: note: Non-local variable '_new_camera_mat' will use pointer to local variable '_new_camera_mat_orig'.
    _new_camera_mat = &_new_camera_mat_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:359:5: error: Non-local variable 'matR' will use pointer to local variable '_R_orig'. [danglingLifetime]
    matR = &_R_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:359:12: note: Address of variable taken here.
    matR = &_R_orig;
           ^
modules/calib3d/test/test_undistort_badarg.cpp:351:11: note: Variable created here.
    CvMat _R_orig = cvMat(3,3,CV_64F,r);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:359:5: note: Non-local variable 'matR' will use pointer to local variable '_R_orig'.
    matR = &_R_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:360:5: error: Non-local variable '_mapx' will use pointer to local variable '_mapx_orig'. [danglingLifetime]
    _mapx = &_mapx_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:360:13: note: Address of variable taken here.
    _mapx = &_mapx_orig;
            ^
modules/calib3d/test/test_undistort_badarg.cpp:352:11: note: Variable created here.
    CvMat _mapx_orig = cvMat(img_size.height,img_size.width,CV_32FC1,arr_mapx);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:360:5: note: Non-local variable '_mapx' will use pointer to local variable '_mapx_orig'.
    _mapx = &_mapx_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:361:5: error: Non-local variable '_mapy' will use pointer to local variable '_mapy_orig'. [danglingLifetime]
    _mapy = &_mapy_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:361:13: note: Address of variable taken here.
    _mapy = &_mapy_orig;
            ^
modules/calib3d/test/test_undistort_badarg.cpp:353:11: note: Variable created here.
    CvMat _mapy_orig = cvMat(img_size.height,img_size.width,CV_32FC1,arr_mapy);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:361:5: note: Non-local variable '_mapy' will use pointer to local variable '_mapy_orig'.
    _mapy = &_mapy_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:475:5: error: Non-local variable '_camera_mat' will use pointer to local variable '_camera_mat_orig'. [danglingLifetime]
    _camera_mat = &_camera_mat_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:475:19: note: Address of variable taken here.
    _camera_mat = &_camera_mat_orig;
                  ^
modules/calib3d/test/test_undistort_badarg.cpp:469:11: note: Variable created here.
    CvMat _camera_mat_orig = cvMat(3,3,CV_64F,cam);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:475:5: note: Non-local variable '_camera_mat' will use pointer to local variable '_camera_mat_orig'.
    _camera_mat = &_camera_mat_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:476:5: error: Non-local variable '_distortion_coeffs' will use pointer to local variable '_distortion_coeffs_orig'. [danglingLifetime]
    _distortion_coeffs = &_distortion_coeffs_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:476:26: note: Address of variable taken here.
    _distortion_coeffs = &_distortion_coeffs_orig;
                         ^
modules/calib3d/test/test_undistort_badarg.cpp:470:11: note: Variable created here.
    CvMat _distortion_coeffs_orig = cvMat(1,4,CV_64F,dist);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:476:5: note: Non-local variable '_distortion_coeffs' will use pointer to local variable '_distortion_coeffs_orig'.
    _distortion_coeffs = &_distortion_coeffs_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:477:5: error: Non-local variable '_new_camera_mat' will use pointer to local variable '_new_camera_mat_orig'. [danglingLifetime]
    _new_camera_mat = &_new_camera_mat_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:477:23: note: Address of variable taken here.
    _new_camera_mat = &_new_camera_mat_orig;
                      ^
modules/calib3d/test/test_undistort_badarg.cpp:471:11: note: Variable created here.
    CvMat _new_camera_mat_orig = cvMat(3,3,CV_64F,arr_new_camera_mat);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:477:5: note: Non-local variable '_new_camera_mat' will use pointer to local variable '_new_camera_mat_orig'.
    _new_camera_mat = &_new_camera_mat_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:504:5: error: Non-local variable '_src' will use pointer to local variable '_src_orig'. [danglingLifetime]
    _src = &_src_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:504:12: note: Address of variable taken here.
    _src = &_src_orig;
           ^
modules/calib3d/test/test_undistort_badarg.cpp:472:11: note: Variable created here.
    CvMat _src_orig = cvMat(img_size.height,img_size.width,CV_32FC1,arr_src);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:504:5: note: Non-local variable '_src' will use pointer to local variable '_src_orig'.
    _src = &_src_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:505:5: error: Non-local variable '_dst' will use pointer to local variable '_dst_orig'. [danglingLifetime]
    _dst = &_dst_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:505:12: note: Address of variable taken here.
    _dst = &_dst_orig;
           ^
modules/calib3d/test/test_undistort_badarg.cpp:473:11: note: Variable created here.
    CvMat _dst_orig = cvMat(img_size.height,img_size.width,CV_32FC1,arr_dst);
          ^
modules/calib3d/test/test_undistort_badarg.cpp:505:5: note: Non-local variable '_dst' will use pointer to local variable '_dst_orig'.
    _dst = &_dst_orig;
    ^
modules/calib3d/test/test_undistort_badarg.cpp:317:39: warning: Member variable 'CV_InitUndistortRectifyMapBadArgTest::mat_type' is not initialized in the constructor. [uninitMemberVar]
CV_InitUndistortRectifyMapBadArgTest::CV_InitUndistortRectifyMapBadArgTest ()
                                      ^
modules/calib3d/test/test_undistort_badarg.cpp:369:14: style: Variable 'useCPlus' is reassigned a value before the old one has been used. [redundantAssignment]
    useCPlus = true;
             ^
modules/calib3d/test/test_undistort_badarg.cpp:365:14: note: useCPlus is assigned
    useCPlus = true;
             ^
modules/calib3d/test/test_undistort_badarg.cpp:369:14: note: useCPlus is overwritten
    useCPlus = true;
             ^
modules/calib3d/test/test_undistort_badarg.cpp:487:14: style: Variable 'useCPlus' is reassigned a value before the old one has been used. [redundantAssignment]
    useCPlus = false;
             ^
modules/calib3d/test/test_undistort_badarg.cpp:482:14: note: useCPlus is assigned
    useCPlus = true;
             ^
modules/calib3d/test/test_undistort_badarg.cpp:487:14: note: useCPlus is overwritten
    useCPlus = false;
             ^
modules/calib3d/test/test_undistort_points.cpp:100:61: warning: Found suspicious operator ',' [constStatement]
                                                        0, 0, 1);
                                                            ^
modules/calib3d/test/test_undistort_points.cpp:102:88: warning: Found suspicious operator ',' [constStatement]
                      -2.57614020e-01, 8.77086999e-02, -2.56970803e-04, -5.93390389e-04, -1.52194091e-02);
                                                                                       ^
modules/core/perf/opencl/perf_arithm.cpp:353:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(FlipType, FLIP_BOTH, FLIP_ROWS, FLIP_COLS)
^
modules/core/perf/opencl/perf_bufferpool.cpp:50:1: error: syntax error [syntaxError]
OCL_PERF_TEST_P(BufferPoolFixture, BufferPool_UMatCreation100, Bool())
^
modules/core/perf/opencl/perf_channels.cpp:88:1: error: syntax error [syntaxError]
OCL_PERF_TEST_P(SplitFixture, Split,
^
modules/core/perf/opencl/perf_dxt.cpp:68:1: error: syntax error [syntaxError]
OCL_PERF_TEST_P(DftFixture, Dft, ::testing::Combine(Values(C2C, R2R, C2R, R2C),
^
modules/core/perf/opencl/perf_gemm.cpp:57:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(FlagType, 0, GEMM_1_T, GEMM_2_T, GEMM_3_T, GEMM_1_T|GEMM_2_T, GEMM_2_T|GEMM_3_T)
^
modules/core/perf/opencl/perf_matop.cpp:42:1: error: syntax error [syntaxError]
OCL_PERF_TEST_P(SetToFixture, SetToWithMask,
^
modules/core/perf/opencl/perf_usage_flags.cpp:24:5: error: syntax error [syntaxError]
    OCL_TEST_CYCLE()
    ^
modules/core/perf/perf_compare.cpp:9:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(CmpType, CMP_EQ, CMP_GT, CMP_GE, CMP_LT, CMP_LE, CMP_NE)
^
modules/core/perf/perf_dft.cpp:13:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(FlagsType, 0, DFT_INVERSE, DFT_SCALE, DFT_COMPLEX_OUTPUT, DFT_ROWS, DFT_INVERSE|DFT_COMPLEX_OUTPUT)
^
modules/core/perf/perf_norm.cpp:12:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_FLAGS is a macro then please configure it. [unknownMacro]
CV_FLAGS(NormType, NORM_HAMMING2, NORM_HAMMING, NORM_INF, NORM_L1, NORM_L2, NORM_TYPE_MASK, NORM_RELATIVE, NORM_MINMAX)
^
modules/core/perf/perf_reduce.cpp:10:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(ROp, CV_REDUCE_SUM, CV_REDUCE_AVG, CV_REDUCE_MAX, CV_REDUCE_MIN)
^
modules/core/perf/perf_umat.cpp:19:5: style: Struct 'OpenCLState' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    OpenCLState(bool useOpenCL)
    ^
modules/core/src/algorithm.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/arithm_simd.hpp:476:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_mask' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_mask = vdupq_n_u8(255);
        ^
modules/core/src/arithm_simd.hpp:512:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_mask' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_mask = vdup_n_u8(255);
        ^
modules/core/src/arithm_simd.hpp:560:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_mask' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_mask = vdup_n_u8(255);
        ^
modules/core/src/arithm_simd.hpp:613:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_mask' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_mask = vdup_n_u8(255);
        ^
modules/core/src/alloc.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/alloc.cpp:75:12: warning: Size of pointer 'udata' used instead of size of its data. This is likely to lead to a buffer overflow. You probably intend to write 'sizeof(*udata)'. [pointerSize]
    uchar* udata = (uchar*)malloc(size + sizeof(void*) + CV_MALLOC_ALIGN);
           ^
modules/core/src/arithm.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/arithm.cpp:247:12: style: The scope of the variable 'scbuf' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uchar *scbuf = 0, *maskbuf = 0;
           ^
modules/core/src/arithm.cpp:1593:20: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    int k = cn % 4 ? cn % 4 : 4;
                   ^
modules/core/src/arithm.cpp:247:18: style: Variable 'scbuf' is assigned a value that is never used. [unreadVariable]
    uchar *scbuf = 0, *maskbuf = 0;
                 ^
modules/core/src/array.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/array.cpp:764:41: warning: Either the condition 'if(prev)' is redundant or there is possible null pointer dereference: node. [nullPointerRedundantCheck]
         node != 0; prev = node, node = node->next )
                                        ^
modules/core/src/array.cpp:779:11: note: Assuming that condition 'if(prev)' is not redundant
        if( prev )
          ^
modules/core/src/array.cpp:764:28: note: Assignment from 'node'
         node != 0; prev = node, node = node->next )
                           ^
modules/core/src/array.cpp:764:41: note: Null pointer dereference
         node != 0; prev = node, node = node->next )
                                        ^
modules/core/src/command_line_parser.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/conjugate_gradient.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/conjugate_gradient.cpp:181:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '_Function' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        _Function=Ptr<Function>();
        ^
modules/core/src/convert.avx2.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/convert.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/convert.cpp:4586:17: style: Condition 'ok' is always true [knownConditionTrueFalse]
            if (ok)
                ^
modules/core/src/convert.cpp:4579:29: note: Assuming that condition 'ok' is not redundant
        if (body != NULL && ok)
                            ^
modules/core/src/convert.cpp:4586:17: note: Condition 'ok' is always true
            if (ok)
                ^
modules/core/src/convert.cpp:4573:32: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [knownConditionTrueFalse]
        if (body == NULL || ok == false)
                               ^
modules/core/src/convert.cpp:4570:19: note: 'ok' is assigned value 'false' here.
        bool ok = false;
                  ^
modules/core/src/convert.cpp:4573:32: note: The expression 'ok == false' is always true because 'ok' and 'false' represent the same value.
        if (body == NULL || ok == false)
                               ^
modules/core/src/convert.fp16.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/convert.sse4_1.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/copy.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/copy.cpp:1327:7: style: Redundant initialization for 'm'. The initialized value is overwritten before it is read. [redundantInitialization]
    m = cv::Scalar(0);
      ^
modules/core/src/copy.cpp:1326:15: note: m is initialized
    cv::Mat m = cv::cvarrToMat(arr);
              ^
modules/core/src/copy.cpp:1327:7: note: m is overwritten
    m = cv::Scalar(0);
      ^
modules/core/src/copy.cpp:1310:11: style: Variable 'm' is assigned a value that is never used. [unreadVariable]
        m = value;
          ^
modules/core/src/copy.cpp:1327:7: style: Variable 'm' is assigned a value that is never used. [unreadVariable]
    m = cv::Scalar(0);
      ^
modules/core/src/cuda_gpu_mat.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/cuda_host_mem.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/cuda_info.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/cuda_stream.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/cuda_stream.cpp:724:5: style: Class 'Impl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Impl(unsigned int)
    ^
modules/core/src/datastructs.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/datastructs.cpp:2859:51: warning: Either the condition 'if(prev_edge)' is redundant or there is possible null pointer dereference: edge. [nullPointerRedundantCheck]
         prev_ofs = ofs, prev_edge = edge, edge = edge->next[ofs] )
                                                  ^
modules/core/src/datastructs.cpp:2871:7: note: Assuming that condition 'if(prev_edge)' is not redundant
    if( prev_edge )
      ^
modules/core/src/datastructs.cpp:2859:38: note: Assignment from 'edge'
         prev_ofs = ofs, prev_edge = edge, edge = edge->next[ofs] )
                                     ^
modules/core/src/datastructs.cpp:2859:51: note: Null pointer dereference
         prev_ofs = ofs, prev_edge = edge, edge = edge->next[ofs] )
                                                  ^
modules/core/src/datastructs.cpp:2877:51: warning: Either the condition 'if(prev_edge)' is redundant or there is possible null pointer dereference: edge. [nullPointerRedundantCheck]
         prev_ofs = ofs, prev_edge = edge, edge = edge->next[ofs] )
                                                  ^
modules/core/src/datastructs.cpp:2888:7: note: Assuming that condition 'if(prev_edge)' is not redundant
    if( prev_edge )
      ^
modules/core/src/datastructs.cpp:2877:38: note: Assignment from 'edge'
         prev_ofs = ofs, prev_edge = edge, edge = edge->next[ofs] )
                                     ^
modules/core/src/datastructs.cpp:2877:51: note: Null pointer dereference
         prev_ofs = ofs, prev_edge = edge, edge = edge->next[ofs] )
                                                  ^
modules/core/src/datastructs.cpp:2091:30: style: Variable 'swap_cnt' is reassigned a value before the old one has been used. [redundantAssignment]
                    swap_cnt = 1;
                             ^
modules/core/src/datastructs.cpp:2048:38: note: swap_cnt is assigned
                            swap_cnt = 1;
                                     ^
modules/core/src/datastructs.cpp:2091:30: note: swap_cnt is overwritten
                    swap_cnt = 1;
                             ^
modules/core/src/datastructs.cpp:2091:30: style: Variable 'swap_cnt' is reassigned a value before the old one has been used. [redundantAssignment]
                    swap_cnt = 1;
                             ^
modules/core/src/datastructs.cpp:2060:38: note: swap_cnt is assigned
                            swap_cnt = 1;
                                     ^
modules/core/src/datastructs.cpp:2091:30: note: swap_cnt is overwritten
                    swap_cnt = 1;
                             ^
modules/core/src/datastructs.cpp:445:9: style: The scope of the variable 'count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int count, total = seq->total;
        ^
modules/core/src/datastructs.cpp:1042:20: style: The scope of the variable 'count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int elem_size, count, total;
                   ^
modules/core/src/datastructs.cpp:1605:20: style: The scope of the variable 'count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int elem_size, count, length;
                   ^
modules/core/src/datastructs.cpp:378:52: style: The unsigned expression 'elem_size' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
    if( header_size < sizeof( CvSeq ) || elem_size <= 0 )
                                                   ^
modules/core/src/datastructs.cpp:1375:22: style: Variable 'front' is assigned a value that is never used. [unreadVariable]
    int total, front = 0;
                     ^
modules/core/src/directx.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/downhill_simplex.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/downhill_simplex.cpp:148:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '_Function' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        _Function=Ptr<Function>();
        ^
modules/core/src/downhill_simplex.cpp:149:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '_step' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        _step=Mat_<double>();
        ^
modules/core/src/dxt.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/dxt.cpp:3510:17: portability: Casting between signed char * and const float * which have an incompatible binary data representation. [invalidPointerCast]
        dataA = (const T*)(((char*)dataA) + stepA);
                ^
modules/core/src/dxt.cpp:3511:17: portability: Casting between signed char * and const float * which have an incompatible binary data representation. [invalidPointerCast]
        dataB = (const T*)(((char*)dataB) + stepB);
                ^
modules/core/src/dxt.cpp:3512:23: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
        dataC =       (T*)(((char*)dataC) + stepC);
                      ^
modules/core/src/dxt.cpp:3510:17: portability: Casting between signed char * and const double * which have an incompatible binary data representation. [invalidPointerCast]
        dataA = (const T*)(((char*)dataA) + stepA);
                ^
modules/core/src/dxt.cpp:3511:17: portability: Casting between signed char * and const double * which have an incompatible binary data representation. [invalidPointerCast]
        dataB = (const T*)(((char*)dataB) + stepB);
                ^
modules/core/src/dxt.cpp:3512:23: portability: Casting between signed char * and double * which have an incompatible binary data representation. [invalidPointerCast]
        dataC =       (T*)(((char*)dataC) + stepC);
                      ^
modules/core/src/dxt.cpp:3444:5: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
    MUL_SPECTRUMS_COL(AC, B, AC);
    ^
modules/core/src/dxt.cpp:3444:5: portability: Casting between signed char * and double * which have an incompatible binary data representation. [invalidPointerCast]
    MUL_SPECTRUMS_COL(AC, B, AC);
    ^
modules/core/src/dxt.cpp:3438:5: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
    MUL_SPECTRUMS_COL(A, B, C);
    ^
modules/core/src/dxt.cpp:3438:5: portability: Casting between signed char * and double * which have an incompatible binary data representation. [invalidPointerCast]
    MUL_SPECTRUMS_COL(A, B, C);
    ^
modules/core/src/dxt.cpp:178:9: style: The scope of the variable 'digits' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int digits[34], radix[34];
        ^
modules/core/src/dxt.cpp:181:12: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j, k;
           ^
modules/core/src/dxt.cpp:181:15: style: The scope of the variable 'k' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j, k;
              ^
modules/core/src/gl_core_3_1.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/glob.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/hal_internal.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/kmeans.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/kmeans.cpp:51:85: style: Parameter 'rng' can be declared with const [constParameter]
static void generateRandomCenter(const std::vector<Vec2f>& box, float* center, RNG& rng)
                                                                                    ^
modules/core/src/kmeans.cpp:103:43: style: Parameter 'rng' can be declared with const [constParameter]
                              int K, RNG& rng, int trials)
                                          ^
modules/core/src/lapack.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/lapack.cpp:123:9: style: The scope of the variable 'iters' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int iters, maxIters = n*n*30;
        ^
modules/core/src/lapack.cpp:127:12: style: Variable 'mv' is assigned a value that is never used. [unreadVariable]
    _Tp mv = (_Tp)0;
           ^
modules/core/src/lapack.cpp:932:33: style: Variable '((float*)(dstdata+1*dststep))[0]' is assigned a value that is never used. [unreadVariable]
                        Df(1,0) = (float)t1;
                                ^
modules/core/src/lapack.cpp:975:33: style: Variable '((double*)(dstdata+1*dststep))[0]' is assigned a value that is never used. [unreadVariable]
                        Dd(1,0) = t1;
                                ^
modules/core/src/lapack.cpp:1006:75: style: Variable '((float*)(dstdata+2*dststep))[2]' is assigned a value that is never used. [unreadVariable]
                    Df(2,0) = (float)t[6]; Df(2,1) = (float)t[7]; Df(2,2) = (float)t[8];
                                                                          ^
modules/core/src/lapack.cpp:1032:61: style: Variable '((double*)(dstdata+2*dststep))[2]' is assigned a value that is never used. [unreadVariable]
                    Dd(2,0) = t[6]; Dd(2,1) = t[7]; Dd(2,2) = t[8];
                                                            ^
modules/core/src/lapack.cpp:1046:29: style: Variable '((float*)(dstdata+0*dststep))[0]' is assigned a value that is never used. [unreadVariable]
                    Df(0,0) = (float)(1./d);
                            ^
modules/core/src/lapack.cpp:1055:29: style: Variable '((double*)(dstdata+0*dststep))[0]' is assigned a value that is never used. [unreadVariable]
                    Dd(0,0) = 1./d;
                            ^
modules/core/src/lapack.cpp:1060:17: style: Variable 'dst' is assigned a value that is never used. [unreadVariable]
            dst = Scalar(0);
                ^
modules/core/src/lapack.cpp:1134:29: style: Variable '((float*)(dstdata+0*dststep))[0]' is assigned a value that is never used. [unreadVariable]
                    Df(0,0) = (float)t;
                            ^
modules/core/src/lapack.cpp:1148:29: style: Variable '((double*)(dstdata+0*dststep))[0]' is assigned a value that is never used. [unreadVariable]
                    Dd(0,0) = t;
                            ^
modules/core/src/lapack.cpp:1181:29: style: Variable '((float*)(dstdata+2*dststep))[0]' is assigned a value that is never used. [unreadVariable]
                    Df(2,0) = t[2];
                            ^
modules/core/src/lapack.cpp:1209:29: style: Variable '((double*)(dstdata+2*dststep))[0]' is assigned a value that is never used. [unreadVariable]
                    Dd(2,0) = t[2];
                            ^
modules/core/src/lapack.cpp:1223:29: style: Variable '((float*)(dstdata+0*dststep))[0]' is assigned a value that is never used. [unreadVariable]
                    Df(0,0) = (float)(bf(0)/d);
                            ^
modules/core/src/lapack.cpp:1231:29: style: Variable '((double*)(dstdata+0*dststep))[0]' is assigned a value that is never used. [unreadVariable]
                    Dd(0,0) = (bd(0)/d);
                            ^
modules/core/src/lda.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/lda.cpp:266:10: style: Unused private function: 'EigenvalueDecomposition::alloc_1d' [unusedPrivateFunction]
    _Tp *alloc_1d(int m) {
         ^
modules/core/src/lda.cpp:281:11: style: Unused private function: 'EigenvalueDecomposition::alloc_2d' [unusedPrivateFunction]
    _Tp **alloc_2d(int m, int _n) {
          ^
modules/core/src/lda.cpp:896:5: style: Class 'EigenvalueDecomposition' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    EigenvalueDecomposition(InputArray src, bool fallbackSymmetric = true) {
    ^
modules/core/src/lda.cpp:985:26: warning: Either the condition 'pSrc!=NULL' is redundant or there is possible null pointer dereference: pSrc. [nullPointerRedundantCheck]
            memcpy(pDst, pSrc, n * sizeof(double));
                         ^
modules/core/src/lda.cpp:984:28: note: Assuming that condition 'pSrc!=NULL' is not redundant
            CV_Assert(pSrc != NULL);
                           ^
modules/core/src/lda.cpp:983:55: note: Assignment 'pSrc=eigenvectors64f.ptr<double>(sort_indexes[(int)i])', assigned value is 0
            double* pSrc = eigenvectors64f.ptr<double>(sort_indexes[(int)i]);
                                                      ^
modules/core/src/lda.cpp:985:26: note: Null pointer dereference
            memcpy(pDst, pSrc, n * sizeof(double));
                         ^
modules/core/src/lda.cpp:670:36: style: The scope of the variable 'vr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                    double ra, sa, vr, vi;
                                   ^
modules/core/src/lda.cpp:670:40: style: The scope of the variable 'vi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                    double ra, sa, vr, vi;
                                       ^
modules/core/src/lpsolver.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/lpsolver.cpp:354:47: style: Parameter 'A' can be declared with const [constParameter]
static inline void swap_columns(Mat_<double>& A,int col1,int col2){
                                              ^
modules/core/src/lpsolver.cpp:54:91: performance: Parameter 'N' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
static void print_simplex_state(const Mat& c,const Mat& b,double v,const std::vector<int> N,const std::vector<int> B){
                                                                                          ^
modules/core/src/lpsolver.cpp:54:116: performance: Parameter 'B' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
static void print_simplex_state(const Mat& c,const Mat& b,double v,const std::vector<int> N,const std::vector<int> B){
                                                                                                                   ^
modules/core/src/mathfuncs.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/mathfuncs_core.dispatch.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/mathfuncs_core.simd.hpp:1224:20: portability: Casting from const float * to const signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
    const int* x = (const int*)_x;
                   ^
modules/core/src/mathfuncs_core.simd.hpp:1531:21: style: Variable 'buf[0].i.hi' is assigned a value that is never used. [unreadVariable]
        buf[0].i.hi = (h0 & LOGTAB_MASK2) | (1023 << 20);
                    ^
modules/core/src/mathfuncs_core.simd.hpp:1532:21: style: Variable 'buf[0].i.lo' is assigned a value that is never used. [unreadVariable]
        buf[0].i.lo = X[i].i.lo;
                    ^
modules/core/src/mathfuncs_core.simd.hpp:111:5: style: Struct 'v_atan < double >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    v_atan(double scale) : impl(static_cast<float>(scale)) {}
    ^
modules/core/src/matmul.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/matmul.cpp:331:65: warning: Either the condition '!c_data' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
        for( i = 0; i < drows; i++, _a_data += a_step0, _c_data += c_step0, d_data += d_step )
                                                                ^
modules/core/src/matmul.cpp:368:17: note: Assuming that condition '!c_data' is not redundant
            if( !c_data )
                ^
modules/core/src/matmul.cpp:335:22: note: Assignment from '_c_data'
            c_data = _c_data;
                     ^
modules/core/src/matmul.cpp:331:65: note: Null pointer addition
        for( i = 0; i < drows; i++, _a_data += a_step0, _c_data += c_step0, d_data += d_step )
                                                                ^
modules/core/src/matmul.cpp:2539:18: style: Variable 'mean' is reassigned a value before the old one has been used. [redundantAssignment]
            mean = _mean.getMat().reshape(1, 1);
                 ^
modules/core/src/matmul.cpp:2536:22: note: mean is assigned
                mean = tmp;
                     ^
modules/core/src/matmul.cpp:2539:18: note: mean is overwritten
            mean = _mean.getMat().reshape(1, 1);
                 ^
modules/core/src/matmul.cpp:63:9: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int j;
        ^
modules/core/src/matmul.cpp:392:30: style: The scope of the variable 't_step' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t a_step0, a_step1, t_step;
                             ^
modules/core/src/matmul.cpp:145:48: style: The scope of the variable 't_step' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t a_step0, a_step1, c_step0, c_step1, t_step;
                                               ^
modules/core/src/matmul.cpp:2283:11: style: Variable 'm' is assigned a value that is never used. [unreadVariable]
        m = tmp;
          ^
modules/core/src/matmul.cpp:175:18: style: Variable 'b_buf' is assigned a value that is never used. [unreadVariable]
        T* b_buf = 0;
                 ^
modules/core/src/matmul.cpp:3068:54: style: The scope of the variable 'blockSize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int len0 = len & -8, blockSize0 = (1 << 15), blockSize;
                                                     ^
modules/core/src/matmul.cpp:3156:54: style: The scope of the variable 'blockSize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int len0 = len & -8, blockSize0 = (1 << 14), blockSize;
                                                     ^
modules/core/src/matmul.cpp:3032:54: style: The scope of the variable 'blockSize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int len0 = len & -8, blockSize0 = (1 << 15), blockSize;
                                                     ^
modules/core/src/matmul.cpp:3120:54: style: The scope of the variable 'blockSize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int len0 = len & -8, blockSize0 = (1 << 14), blockSize;
                                                     ^
modules/core/src/matmul.cpp:3239:54: style: The scope of the variable 'blockSize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int len0 = len & -4, blockSize0 = (1 << 13), blockSize;
                                                     ^
modules/core/src/matop.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/matrix.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/matrix.cpp:4359:5: style: Class 'LessThanIdx < schar >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    LessThanIdx( const _Tp* _arr ) : arr(_arr) {}
    ^
modules/core/src/matrix.cpp:4359:5: style: Class 'LessThanIdx < ushort >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    LessThanIdx( const _Tp* _arr ) : arr(_arr) {}
    ^
modules/core/src/matrix.cpp:4359:5: style: Class 'LessThanIdx < short >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    LessThanIdx( const _Tp* _arr ) : arr(_arr) {}
    ^
modules/core/src/matrix.cpp:4359:5: style: Class 'LessThanIdx < int >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    LessThanIdx( const _Tp* _arr ) : arr(_arr) {}
    ^
modules/core/src/matrix.cpp:4359:5: style: Class 'LessThanIdx < float >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    LessThanIdx( const _Tp* _arr ) : arr(_arr) {}
    ^
modules/core/src/matrix.cpp:4359:5: style: Class 'LessThanIdx < double >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    LessThanIdx( const _Tp* _arr ) : arr(_arr) {}
    ^
modules/core/src/matrix.cpp:3627:9: warning: Either the condition 'func!=0' is redundant or there is possible null pointer dereference: func. [nullPointerRedundantCheck]
        func( src.ptr(), src.step, dst.ptr(), dst.step, src.size() );
        ^
modules/core/src/matrix.cpp:3626:25: note: Assuming that condition 'func!=0' is not redundant
        CV_Assert( func != 0 );
                        ^
modules/core/src/matrix.cpp:3625:42: note: Assignment 'func=transposeTab[esz]', assigned value is 0
        TransposeFunc func = transposeTab[esz];
                                         ^
modules/core/src/matrix.cpp:3627:9: note: Null pointer dereference
        func( src.ptr(), src.step, dst.ptr(), dst.step, src.size() );
        ^
modules/core/src/matrix.cpp:4517:5: warning: Either the condition 'func!=0' is redundant or there is possible null pointer dereference: func. [nullPointerRedundantCheck]
    func( src, dst, flags );
    ^
modules/core/src/matrix.cpp:4515:21: note: Assuming that condition 'func!=0' is not redundant
    CV_Assert( func != 0 );
                    ^
modules/core/src/matrix.cpp:4514:24: note: Assignment 'func=tab[src.depth()]', assigned value is 0
    SortFunc func = tab[src.depth()];
                       ^
modules/core/src/matrix.cpp:4517:5: note: Null pointer dereference
    func( src, dst, flags );
    ^
modules/core/src/matrix.cpp:4541:5: warning: Either the condition 'func!=0' is redundant or there is possible null pointer dereference: func. [nullPointerRedundantCheck]
    func( src, dst, flags );
    ^
modules/core/src/matrix.cpp:4540:21: note: Assuming that condition 'func!=0' is not redundant
    CV_Assert( func != 0 );
                    ^
modules/core/src/matrix.cpp:4539:24: note: Assignment 'func=tab[src.depth()]', assigned value is 0
    SortFunc func = tab[src.depth()];
                       ^
modules/core/src/matrix.cpp:4541:5: note: Null pointer dereference
    func( src, dst, flags );
    ^
modules/core/src/matrix.cpp:901:14: style: Redundant initialization for 'part'. The initialized value is overwritten before it is read. [redundantInitialization]
        part = s;
             ^
modules/core/src/matrix.cpp:900:18: note: part is initialized
        Mat part = rowRange(saveRows, size.p[0]);
                 ^
modules/core/src/matrix.cpp:901:14: note: part is overwritten
        part = s;
             ^
modules/core/src/matrix.cpp:5024:19: style: The scope of the variable 'ofs0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        ptrdiff_t ofs0, y;
                  ^
modules/core/src/matrix.cpp:3360:14: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i=0, j, m = sz.width, n = sz.height;
             ^
modules/core/src/matrix.cpp:901:14: style: Variable 'part' is assigned a value that is never used. [unreadVariable]
        part = s;
             ^
modules/core/src/matrix_decomp.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/merge.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/merge.cpp:270:20: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    int k = cn % 4 ? cn % 4 : 4;
                   ^
modules/core/src/merge.cpp:261:1: portability: Casting between const signed int * and const float * which have an incompatible binary data representation. [invalidPointerCast]
MERGE2_KERNEL_TEMPLATE(   int,  __m128,   float, _mm_interleave_ps, ps, CV_CPU_SSE2);
^
modules/core/src/merge.cpp:261:1: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
MERGE2_KERNEL_TEMPLATE(   int,  __m128,   float, _mm_interleave_ps, ps, CV_CPU_SSE2);
^
modules/core/src/merge.cpp:262:1: portability: Casting between const signed int * and const float * which have an incompatible binary data representation. [invalidPointerCast]
MERGE3_KERNEL_TEMPLATE(   int,  __m128,   float, _mm_interleave_ps, ps, CV_CPU_SSE2);
^
modules/core/src/merge.cpp:262:1: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
MERGE3_KERNEL_TEMPLATE(   int,  __m128,   float, _mm_interleave_ps, ps, CV_CPU_SSE2);
^
modules/core/src/merge.cpp:263:1: portability: Casting between const signed int * and const float * which have an incompatible binary data representation. [invalidPointerCast]
MERGE4_KERNEL_TEMPLATE(   int,  __m128,   float, _mm_interleave_ps, ps, CV_CPU_SSE2);
^
modules/core/src/merge.cpp:263:1: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
MERGE4_KERNEL_TEMPLATE(   int,  __m128,   float, _mm_interleave_ps, ps, CV_CPU_SSE2);
^
modules/core/src/ocl.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/ocl_deprecated.hpp:918:0: error: Array 'dst_origin[3]' accessed at index 3, which is out of bounds. [arrayIndexOutOfBounds]
OCL_FUNC(cl_int, clEnqueueCopyBufferToImage,
^
modules/core/src/ocl_deprecated.hpp:918:0: error: Array 'region[3]' accessed at index 3, which is out of bounds. [arrayIndexOutOfBounds]
OCL_FUNC(cl_int, clEnqueueCopyBufferToImage,
^
modules/core/src/ocl.cpp:5058:24: warning: Either the condition 'i>=0' is redundant or the array 'sz[0]' is accessed at index -1, which is out of bounds. [negativeIndex]
            total *= sz[i];
                       ^
modules/core/src/ocl.cpp:5056:19: note: Assuming that condition 'i>=0' is not redundant
            if( i >= 0 && (total != srcstep[i] || total != dststep[i]) )
                  ^
modules/core/src/ocl.cpp:5058:24: note: Negative array index
            total *= sz[i];
                       ^
modules/core/src/ocl.cpp:138:5: warning: Member variable 'DummyImpl::refcount' is not initialized in the constructor. [uninitMemberVar]
    DummyImpl() { CV_OPENCL_NO_SUPPORT(); }
    ^
modules/core/src/ocl.cpp:4222:18: warning: Virtual function 'freeAllReservedBuffers' is called from destructor '~OpenCLBufferPoolBaseImpl < OpenCLBufferPoolImpl , CLBufferEntry , _cl_mem * >()' at line 4160. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void freeAllReservedBuffers()
                 ^
modules/core/src/ocl.cpp:4160:9: note: Calling freeAllReservedBuffers
        freeAllReservedBuffers();
        ^
modules/core/src/ocl.cpp:4222:18: note: freeAllReservedBuffers is a virtual function
    virtual void freeAllReservedBuffers()
                 ^
modules/core/src/ocl.cpp:232:5: style: Struct 'UMat2D' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    UMat2D(const UMat& m)
    ^
modules/core/src/ocl.cpp:247:5: style: Struct 'UMat3D' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    UMat3D(const UMat& m)
    ^
modules/core/src/ocl.cpp:1187:5: style: Struct 'Impl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Impl(void* d)
    ^
modules/core/src/ocl.cpp:1975:5: style: Struct 'Impl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Impl(int dtype0)
    ^
modules/core/src/ocl.cpp:2545:5: style: Struct 'Impl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Impl(cl_command_queue q)
    ^
modules/core/src/ocl.cpp:3220:5: style: Struct 'Impl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Impl(const String& src)
    ^
modules/core/src/ocl.cpp:5831:5: style: Struct 'Impl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Impl(void* id)
    ^
modules/core/src/ocl.cpp:6526:5: style: Struct 'Impl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Impl(const Queue& q)
    ^
modules/core/src/ocl.cpp:4164:15: style: The function 'allocate' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual T allocate(size_t size)
              ^
modules/core/src/ocl.cpp:4054:15: note: Virtual function in base class
    virtual T allocate(size_t size) = 0;
              ^
modules/core/src/ocl.cpp:4164:15: note: Function in derived class
    virtual T allocate(size_t size)
              ^
modules/core/src/ocl.cpp:4179:18: style: The function 'release' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void release(T buffer)
                 ^
modules/core/src/ocl.cpp:4055:18: note: Virtual function in base class
    virtual void release(T buffer) = 0;
                 ^
modules/core/src/ocl.cpp:4179:18: note: Function in derived class
    virtual void release(T buffer)
                 ^
modules/core/src/ocl.cpp:6154:59: warning: Either the condition 'func!=0' is redundant or there is possible null pointer dereference: func. [nullPointerRedundantCheck]
    return cv::format(" -D %s=%s", name ? name : "COEFF", func(kernel).c_str());
                                                          ^
modules/core/src/ocl.cpp:6152:20: note: Assuming that condition 'func!=0' is not redundant
    CV_Assert(func != 0);
                   ^
modules/core/src/ocl.cpp:6151:30: note: Assignment 'func=funcs[ddepth]', assigned value is 0
    const func_t func = funcs[ddepth];
                             ^
modules/core/src/ocl.cpp:6154:59: note: Null pointer dereference
    return cv::format(" -D %s=%s", name ? name : "COEFF", func(kernel).c_str());
                                                          ^
modules/core/src/ocl.cpp:6376:16: style: The scope of the variable 'region' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        size_t region[] = { static_cast<size_t>(src.cols), static_cast<size_t>(src.rows), 1 };
               ^
modules/core/src/ocl.cpp:1924:40: style: Parameter 'context' can be declared with const [constParameter]
    static Context::Impl* get(Context& context) { return context.p; }
                                       ^
modules/core/src/ocl.cpp:2512:43: style: Parameter 'ctx' can be declared with const [constParameter]
void initializeContextFromHandle(Context& ctx, void* platform, void* _context, void* _device)
                                          ^
modules/core/src/ocl.cpp:2529:15: style: Variable 'p' can be declared with const [constVariable]
    Platform& p = Platform::getDefault();
              ^
modules/core/src/ocl.cpp:4524:18: style: Variable 'ctx' can be declared with const [constVariable]
        Context& ctx = Context::getDefault();
                 ^
modules/core/src/ocl.cpp:4713:39: warning: Conversion of string literal "UMat deallocation error: some derived Mat is still alive" to bool always evaluates to true. [incorrectStringBooleanError]
        CV_Assert(u->refcount == 0 && "UMat deallocation error: some derived Mat is still alive");
                                      ^
modules/core/src/ocl.cpp:2506:40: error: Uninitialized variable: q [uninitvar]
    getCoreTlsData().get()->oclQueue = q;
                                       ^
modules/core/src/ocl.cpp:2983:23: style: Variable 'u2d' is assigned a value that is never used. [unreadVariable]
            UMat2D u2d(*arg.m);
                      ^
modules/core/src/ocl.cpp:3002:23: style: Variable 'u3d' is assigned a value that is never used. [unreadVariable]
            UMat3D u3d(*arg.m);
                      ^
modules/core/src/ocl.cpp:4985:23: style: Variable 'retval' is assigned a value that is never used. [unreadVariable]
        cl_int retval = 0;
                      ^
modules/core/src/opencl/arithm.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/opencl/copymakeborder.cl:111:31: style: The scope of the variable 'src_y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int src_x = x - left, src_y;
                              ^
modules/core/src/opencl/copymakeborder.cl:121:13: style: The scope of the variable 'delta' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            EXTRAPOLATE(src_x, src_cols)
            ^
modules/core/src/opencl/copymakeborder.cl:130:17: style: The scope of the variable 'delta' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                EXTRAPOLATE(src_y, src_rows)
                ^
modules/core/src/opencl/fft.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/opencl/fft.cl:841:24: style: Condition 'x==0' is always true [knownConditionTrueFalse]
            int ind = x==0 ? 0: 2*x-1;
                       ^
modules/core/src/opencl/fft.cl:827:14: note: Assuming that condition 'x!=0' is not redundant
        if (x!=0)
             ^
modules/core/src/opencl/fft.cl:841:24: note: Condition 'x==0' is always true
            int ind = x==0 ? 0: 2*x-1;
                       ^
modules/core/src/opencl/fft.cl:841:17: style: Local variable 'ind' shadows outer variable [shadowVariable]
            int ind = x==0 ? 0: 2*x-1;
                ^
modules/core/src/opencl/fft.cl:820:19: note: Shadowed declaration
        const int ind = y;
                  ^
modules/core/src/opencl/fft.cl:841:17: note: Shadow variable
            int ind = x==0 ? 0: 2*x-1;
                ^
modules/core/src/opencl/fft.cl:332:20: style: Variable 'tw_ind' is assigned a value that is never used. [unreadVariable]
        int tw_ind = block_size / 8;
                   ^
modules/core/src/opencl/fft.cl:487:17: style: Variable 'k' is assigned a value that is never used. [unreadVariable]
    const int k = x % block_size;
                ^
modules/core/src/opencl/fft.cl:543:23: style: Variable 'ind' is assigned a value that is never used. [unreadVariable]
        const int ind = x;
                      ^
modules/core/src/opencl/fft.cl:547:18: style: Variable 'scale' is assigned a value that is never used. [unreadVariable]
        FT scale = (FT) 1/(dst_cols*dst_rows);
                 ^
modules/core/src/opencl/fft.cl:623:23: style: Variable 'ind' is assigned a value that is never used. [unreadVariable]
        const int ind = y;
                      ^
modules/core/src/opencl/fft.cl:625:18: style: Variable 'scale' is assigned a value that is never used. [unreadVariable]
        FT scale = 1.f/(dst_rows*dst_cols);
                 ^
modules/core/src/opencl/fft.cl:682:20: style: Variable 'scale' is assigned a value that is never used. [unreadVariable]
    const FT scale = (FT) 1/(dst_cols*dst_rows);
                   ^
modules/core/src/opencl/fft.cl:689:23: style: Variable 'ind' is assigned a value that is never used. [unreadVariable]
        const int ind = x;
                      ^
modules/core/src/opencl/fft.cl:820:23: style: Variable 'ind' is assigned a value that is never used. [unreadVariable]
        const int ind = y;
                      ^
modules/core/src/opencl/fft.cl:792:23: style: Variable 'ind' is assigned a value that is never used. [unreadVariable]
        const int ind = y;
                      ^
modules/core/src/opencl/fft.cl:545:18: style: Variable 'scale' is assigned a value that is never used. [unreadVariable]
        FT scale = (FT) 1/dst_cols;
                 ^
modules/core/src/opencl/fft.cl:680:20: style: Variable 'scale' is assigned a value that is never used. [unreadVariable]
    const FT scale = (FT) 1/dst_cols;
                   ^
modules/core/src/opencl/gemm.cl:54:14: style: Variable 'lidx' is assigned a value that is never used. [unreadVariable]
    int lidx = get_local_id(0);
             ^
modules/core/src/opencl/gemm.cl:55:14: style: Variable 'lidy' is assigned a value that is never used. [unreadVariable]
    int lidy = get_local_id(1);
             ^
modules/core/src/opencl/intel_gemm.cl:716:9: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
        MM_DOT_PRODUCT(arow1,7);
        ^
modules/core/src/opencl/intel_gemm.cl:565:11: style: The scope of the variable 'output' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float output = 0.0f;
          ^
modules/core/src/opencl/intel_gemm.cl:55:24: style: Variable 'global_x' is assigned a value that is never used. [unreadVariable]
    const int global_x = get_global_id(0);
                       ^
modules/core/src/opencl/intel_gemm.cl:56:24: style: Variable 'global_y' is assigned a value that is never used. [unreadVariable]
    const int global_y = get_global_id(1);
                       ^
modules/core/src/opencl/intel_gemm.cl:241:17: style: Variable 'arow0.x' is assigned a value that is never used. [unreadVariable]
        arow0.x = ((w + local_x * 2) < K) ? (float)alpha * (src0_read + row0 * ldA)[0] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:242:17: style: Variable 'arow0.y' is assigned a value that is never used. [unreadVariable]
        arow0.y = ((w + local_x * 2 + 1) < K) ? (float)alpha * (src0_read + row0 * ldA)[1] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:243:17: style: Variable 'arow1.x' is assigned a value that is never used. [unreadVariable]
        arow1.x = ((w + local_x * 2) < K) ? (float)alpha * (src0_read + row1 * ldA)[0] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:244:17: style: Variable 'arow1.y' is assigned a value that is never used. [unreadVariable]
        arow1.y = ((w + local_x * 2 + 1) < K) ? (float)alpha * (src0_read + row1 * ldA)[1] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:245:17: style: Variable 'arow2.x' is assigned a value that is never used. [unreadVariable]
        arow2.x = ((w + local_x * 2) < K) ? (float)alpha * (src0_read + row2 * ldA)[0] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:246:17: style: Variable 'arow2.y' is assigned a value that is never used. [unreadVariable]
        arow2.y = ((w + local_x * 2 + 1) < K) ? (float)alpha * (src0_read + row2 * ldA)[1] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:247:17: style: Variable 'arow3.x' is assigned a value that is never used. [unreadVariable]
        arow3.x = ((w + local_x * 2) < K) ? (float)alpha * (src0_read + row3 * ldA)[0] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:248:17: style: Variable 'arow3.y' is assigned a value that is never used. [unreadVariable]
        arow3.y = ((w + local_x * 2 + 1) < K) ? (float)alpha * (src0_read + row3 * ldA)[1] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:249:17: style: Variable 'arow4.x' is assigned a value that is never used. [unreadVariable]
        arow4.x = ((w + local_x * 2) < K) ? (float)alpha * (src0_read + row4 * ldA)[0] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:250:17: style: Variable 'arow4.y' is assigned a value that is never used. [unreadVariable]
        arow4.y = ((w + local_x * 2 + 1) < K) ? (float)alpha * (src0_read + row4 * ldA)[1] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:251:17: style: Variable 'arow5.x' is assigned a value that is never used. [unreadVariable]
        arow5.x = ((w + local_x * 2) < K) ? (float)alpha * (src0_read + row5 * ldA)[0] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:252:17: style: Variable 'arow5.y' is assigned a value that is never used. [unreadVariable]
        arow5.y = ((w + local_x * 2 + 1) < K) ? (float)alpha * (src0_read + row5 * ldA)[1] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:253:17: style: Variable 'arow6.x' is assigned a value that is never used. [unreadVariable]
        arow6.x = ((w + local_x * 2) < K) ? (float)alpha * (src0_read + row6 * ldA)[0] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:254:17: style: Variable 'arow6.y' is assigned a value that is never used. [unreadVariable]
        arow6.y = ((w + local_x * 2 + 1) < K) ? (float)alpha * (src0_read + row6 * ldA)[1] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:255:17: style: Variable 'arow7.x' is assigned a value that is never used. [unreadVariable]
        arow7.x = ((w + local_x * 2) < K) ? (float)alpha * (src0_read + row7 * ldA)[0] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:256:17: style: Variable 'arow7.y' is assigned a value that is never used. [unreadVariable]
        arow7.y = ((w + local_x * 2 + 1) < K) ? (float)alpha * (src0_read + row7 * ldA)[1] : 0.0f;
                ^
modules/core/src/opencl/intel_gemm.cl:284:9: style: Variable 'w' is assigned a value that is never used. [unreadVariable]
        MM_DOT_PRODUCT(7,1);
        ^
modules/core/src/opencl/intel_gemm.cl:716:9: style: Variable 'start_index' is assigned a value that is never used. [unreadVariable]
        MM_DOT_PRODUCT(arow1,7);
        ^
modules/core/src/opencl/minmaxloc.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/opencl/minmaxloc.cl:164:9: style: The scope of the variable 'src_index' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int src_index;
        ^
modules/core/src/opencl/minmaxloc.cl:127:13: style: Variable 'gid' is assigned a value that is never used. [unreadVariable]
    int gid = get_group_id(0);
            ^
modules/core/src/opencl/minmaxloc.cl:197:18: style: Variable 'temp' is assigned a value that is never used. [unreadVariable]
            temp = convertToDT(loadpix(srcptr + src_index));
                 ^
modules/core/src/opencl/minmaxloc.cl:292:18: style: Variable 'lid3' is assigned a value that is never used. [unreadVariable]
        int lid3 = lid - WGS2_ALIGNED;
                 ^
modules/core/src/opencl/minmaxloc.cl:370:17: style: Variable 'pos' is assigned a value that is never used. [unreadVariable]
        int pos = 0;
                ^
modules/core/src/opencl/minmaxloc.cl:166:9: style: The scope of the variable 'mask_index' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int mask_index;
        ^
modules/core/src/opencl/reduce.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/opencl/reduce.cl:186:0: error: failed to expand 'REDUCE_GLOBAL', Wrong number of parameters for macro 'FUNC'. [preprocessorErrorDirective]
#define PROCESS_ELEMS \
^
modules/core/src/opencl/reduce2.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/opencl/runtime/opencl_clamdblas.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/opencl/runtime/opencl_clamdfft.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/opencl/runtime/opencl_core.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/opengl.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/opengl.cpp:1704:54: style: Parameter 'texture' can be declared with const [constParameter]
void convertToGLTexture2D(InputArray src, Texture2D& texture)
                                                     ^
modules/core/src/opengl.cpp:1871:26: style: Parameter 'u' can be declared with const [constParameter]
void unmapGLBuffer(UMat& u)
                         ^
modules/core/src/out.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/out.cpp:84:9: warning: Member variable 'FormattedImpl::buf' is not initialized in the constructor. [uninitMemberVar]
        FormattedImpl(String pl, String el, Mat m, char br[5], bool sLine, bool aOrder, int precision)
        ^
modules/core/src/ovx.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/ovx.cpp:100:24: warning: Conversion of string literal "OpenVX support isn't enabled at compile time" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(!flag && "OpenVX support isn't enabled at compile time");
                       ^
modules/core/src/parallel.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/parallel_pthreads.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/pca.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/persistence.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/persistence.cpp:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
BUILD_SHARED_LIBS : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
BUILD_SHARED_LIBS;WINCE;_WIN32 : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
BUILD_SHARED_LIBS;__GNUC__ : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
CV_AVX2 : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
CV_AVX2;CV_SSE2 : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
CV_COLLECT_IMPL_DATA : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
CV_ENABLE_UNROLLED : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
CV_NEON : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
CV_SIMD128 : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
CV_SIMD128;CV_SIMD128_64F : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
CV_SSE2 : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
CV_SSE2;CV_SSE4_1 : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
CV__LEGACY_PERSISTENCE : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
CV__LEGACY_PERSISTENCE;OPENCV_TRAITS_ENABLE_DEPRECATED : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
HAVE_IPP : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
HAVE_LAPACK : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
HAVE_OPENCL : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
HAVE_OPENVX : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
HAVE_TEGRA_OPTIMIZATION : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
_MSC_VER : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit."
__GNUC__ : [modules/core/src/persistence.cpp:7494] #error "`char` should be 8 bit." [noValidConfiguration]

^
modules/core/src/rand.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/rand.cpp:860:5: warning: Either the condition 'func!=0' is redundant or there is possible null pointer dereference: func. [nullPointerRedundantCheck]
    func( dst, rng, iterFactor );
    ^
modules/core/src/rand.cpp:859:21: note: Assuming that condition 'func!=0' is not redundant
    CV_Assert( func != 0 );
                    ^
modules/core/src/rand.cpp:858:31: note: Assignment 'func=tab[dst.elemSize()]', assigned value is 0
    RandShuffleFunc func = tab[dst.elemSize()];
                              ^
modules/core/src/rand.cpp:860:5: note: Null pointer dereference
    func( dst, rng, iterFactor );
    ^
modules/core/src/rand.cpp:601:22: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                ds = (DivStruct*)(ip + cn);
                     ^
modules/core/src/rand.cpp:710:32: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                DivStruct* p = (DivStruct*)param;
                               ^
modules/core/src/rand.cpp:741:16: portability: Casting between double * and float * which have an incompatible binary data representation. [invalidPointerCast]
        nbuf = (float*)(double*)buf;
               ^
modules/core/src/rand.cpp:158:18: style: The scope of the variable 't1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned t0, t1, v0, v1;
                 ^
modules/core/src/rand.cpp:158:26: style: The scope of the variable 'v1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned t0, t1, v0, v1;
                         ^
modules/core/src/rand.cpp:442:12: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j, k;
           ^
modules/core/src/rand.cpp:517:12: style: The scope of the variable 'k' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int j, k;
           ^
modules/core/src/rand.cpp:943:21: style: The scope of the variable 'mag01' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    static unsigned mag01[2] = { 0x0U, /*MATRIX_A*/ 0x9908b0dfU};
                    ^
modules/core/src/rand.cpp:793:31: style: Parameter 'rng' can be declared with const [constParameter]
randShuffle_( Mat& _arr, RNG& rng, double )
                              ^
modules/core/src/rand.cpp:301:13: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
    int64 v = 0;
            ^
modules/core/src/softfloat.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/softfloat.cpp:3015:51: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
    sig &= ~(uint_fast32_t) (! (roundBits ^ 0x40) & roundNearEven);
                                                  ^
modules/core/src/softfloat.cpp:3085:52: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
    sig &= ~(uint_fast64_t) (! (roundBits ^ 0x200) & roundNearEven);
                                                   ^
modules/core/src/softfloat.cpp:3120:54: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
    sig32 &= ~(uint_fast32_t) (! (roundBits ^ 0x800) & roundNearEven);
                                                     ^
modules/core/src/softfloat.cpp:3160:17: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
                & roundNearEven);
                ^
modules/core/src/softfloat.cpp:2153:10: style: The scope of the variable 'sign' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool sign;
         ^
modules/core/src/softfloat.cpp:2154:19: style: The scope of the variable 'absA' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint_fast32_t absA;
                  ^
modules/core/src/softfloat.cpp:2155:17: style: The scope of the variable 'shiftDist' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int_fast8_t shiftDist;
                ^
modules/core/src/softfloat.cpp:2176:19: style: The scope of the variable 'sig' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint_fast32_t sig;
                  ^
modules/core/src/softfloat.cpp:3179:18: style: The scope of the variable 'u8NegDist' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint_fast8_t u8NegDist;
                 ^
modules/core/src/softfloat.cpp:3408:17: style: The scope of the variable 'shiftDist' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int_fast8_t shiftDist;
                ^
modules/core/src/softfloat.cpp:3423:19: style: The scope of the variable 'sig' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint_fast32_t sig;
                  ^
modules/core/src/softfloat.cpp:1085:18: style: Local variable 'exp' shadows outer function [shadowFunction]
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:291:12: note: Shadowed declaration
softfloat  exp( const softfloat&  a) { return f32_exp(a); }
           ^
modules/core/src/softfloat.cpp:1085:18: note: Shadow variable
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:1237:18: style: Local variable 'exp' shadows outer function [shadowFunction]
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:291:12: note: Shadowed declaration
softfloat  exp( const softfloat&  a) { return f32_exp(a); }
           ^
modules/core/src/softfloat.cpp:1237:18: note: Shadow variable
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:1282:18: style: Local variable 'exp' shadows outer function [shadowFunction]
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:291:12: note: Shadowed declaration
softfloat  exp( const softfloat&  a) { return f32_exp(a); }
           ^
modules/core/src/softfloat.cpp:1282:18: note: Shadow variable
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:1319:18: style: Local variable 'exp' shadows outer function [shadowFunction]
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:291:12: note: Shadowed declaration
softfloat  exp( const softfloat&  a) { return f32_exp(a); }
           ^
modules/core/src/softfloat.cpp:1319:18: note: Shadow variable
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:1792:18: style: Local variable 'exp' shadows outer function [shadowFunction]
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:291:12: note: Shadowed declaration
softfloat  exp( const softfloat&  a) { return f32_exp(a); }
           ^
modules/core/src/softfloat.cpp:1792:18: note: Shadow variable
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:1961:18: style: Local variable 'exp' shadows outer function [shadowFunction]
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:291:12: note: Shadowed declaration
softfloat  exp( const softfloat&  a) { return f32_exp(a); }
           ^
modules/core/src/softfloat.cpp:1961:18: note: Shadow variable
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:2001:18: style: Local variable 'exp' shadows outer function [shadowFunction]
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:291:12: note: Shadowed declaration
softfloat  exp( const softfloat&  a) { return f32_exp(a); }
           ^
modules/core/src/softfloat.cpp:2001:18: note: Shadow variable
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:2037:18: style: Local variable 'exp' shadows outer function [shadowFunction]
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:291:12: note: Shadowed declaration
softfloat  exp( const softfloat&  a) { return f32_exp(a); }
           ^
modules/core/src/softfloat.cpp:2037:18: note: Shadow variable
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:2089:18: style: Local variable 'exp' shadows outer function [shadowFunction]
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:291:12: note: Shadowed declaration
softfloat  exp( const softfloat&  a) { return f32_exp(a); }
           ^
modules/core/src/softfloat.cpp:2089:18: note: Shadow variable
    int_fast16_t exp;
                 ^
modules/core/src/softfloat.cpp:417:32: style: struct member 'uint64_extra::extra' is never used. [unusedStructMember]
struct uint64_extra { uint64_t extra, v; };
                               ^
modules/core/src/softfloat.cpp:418:33: style: struct member 'uint128_extra::extra' is never used. [unusedStructMember]
struct uint128_extra { uint64_t extra; struct uint128 v; };
                                ^
modules/core/src/split.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/split.cpp:269:20: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    int k = cn % 4 ? cn % 4 : 4;
                   ^
modules/core/src/split.cpp:254:1: portability: Casting between const signed int * and const float * which have an incompatible binary data representation. [invalidPointerCast]
SPLIT2_KERNEL_TEMPLATE(   int,  __m128,   float, _mm_deinterleave_ps, ps);
^
modules/core/src/split.cpp:254:1: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
SPLIT2_KERNEL_TEMPLATE(   int,  __m128,   float, _mm_deinterleave_ps, ps);
^
modules/core/src/split.cpp:258:1: portability: Casting between const signed int * and const float * which have an incompatible binary data representation. [invalidPointerCast]
SPLIT3_KERNEL_TEMPLATE(   int,  __m128,   float, _mm_deinterleave_ps, ps);
^
modules/core/src/split.cpp:258:1: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
SPLIT3_KERNEL_TEMPLATE(   int,  __m128,   float, _mm_deinterleave_ps, ps);
^
modules/core/src/split.cpp:262:1: portability: Casting between const signed int * and const float * which have an incompatible binary data representation. [invalidPointerCast]
SPLIT4_KERNEL_TEMPLATE(   int,  __m128,   float, _mm_deinterleave_ps, ps);
^
modules/core/src/split.cpp:262:1: portability: Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]
SPLIT4_KERNEL_TEMPLATE(   int,  __m128,   float, _mm_deinterleave_ps, ps);
^
modules/core/src/stat.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/stat.cpp:1889:17: portability: Casting from double * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
    int *sbuf = (int*)s, *sqbuf = (int*)sq;
                ^
modules/core/src/stat.cpp:1900:16: portability: Casting from double * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
        sbuf = (int*)(sq + cn);
               ^
modules/core/src/stat.cpp:2737:18: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
        minval = (int*)&fminval, maxval = (int*)&fmaxval;
                 ^
modules/core/src/stat.cpp:2739:18: portability: Casting from double * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
        minval = (int*)&dminval, maxval = (int*)&dmaxval;
                 ^
modules/core/src/stat.dispatch.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/stat.simd.hpp:63:0: information: Skipping configuration 'CV_POPCNT;CV_POPCNT_U64' since the value of 'CV_POPCNT_U64' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            result += (int)CV_POPCNT_U64(*(uint64*)(a + i));
^
modules/core/src/stat.simd.hpp:134:0: information: Skipping configuration 'CV_POPCNT;CV_POPCNT_U64' since the value of 'CV_POPCNT_U64' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            result += (int)CV_POPCNT_U64(*(uint64*)(a + i) ^ *(uint64*)(b + i));
^
modules/core/src/stl.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/system.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/system.cpp:791:30: error: Syntax Error: AST broken, binary operator '=' doesn't have two operands. [internalAstError]
    static String build_info =
                             ^
modules/core/src/tables.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/trace.cpp:1059:9: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
        value = "<null>";
        ^
modules/core/src/trace.cpp:108:5: warning: Member variable 'TraceMessage::buffer' is not initialized in the constructor. [uninitMemberVar]
    TraceMessage() :
    ^
modules/core/src/trace.cpp:735:5: style: Class 'AsyncTraceStorage' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    AsyncTraceStorage(const std::string& filename) :
    ^
modules/core/src/trace.cpp:764:5: style: Class 'SyncTraceStorage' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    SyncTraceStorage(const std::string& filename) :
    ^
modules/core/src/trace.cpp:1059:15: style: Variable 'value' is assigned a value that is never used. [unreadVariable]
        value = "<null>";
              ^
modules/core/src/trace.cpp:199:17: style: Local variable 'isInitialized' shadows outer variable [shadowVariable]
    static bool isInitialized = false;
                ^
modules/core/src/trace.cpp:819:13: note: Shadowed declaration
static bool isInitialized = false;
            ^
modules/core/src/trace.cpp:199:17: note: Shadow variable
    static bool isInitialized = false;
                ^
modules/core/src/trace.cpp:804:17: warning: Return value of function strrchr() is not used. [ignoredReturnValue]
                strrchr(filepath.c_str(), '\\');
                ^
modules/core/src/trace.cpp:806:17: style: The if condition is the same as the previous if condition [duplicateCondition]
            if (!pos)
                ^
modules/core/src/trace.cpp:803:17: note: First condition
            if (!pos)
                ^
modules/core/src/trace.cpp:806:17: note: Second condition
            if (!pos)
                ^
modules/core/src/types.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/types.cpp:54:9: style: Variable 'u.f' is reassigned a value before the old one has been used. [redundantAssignment]
    u.f = pt.y; _Val = (scale * _Val) ^ u.u;
        ^
modules/core/src/types.cpp:53:9: note: u.f is assigned
    u.f = pt.x; _Val = (scale * _Val) ^ u.u;
        ^
modules/core/src/types.cpp:54:9: note: u.f is overwritten
    u.f = pt.y; _Val = (scale * _Val) ^ u.u;
        ^
modules/core/src/types.cpp:55:9: style: Variable 'u.f' is reassigned a value before the old one has been used. [redundantAssignment]
    u.f = size; _Val = (scale * _Val) ^ u.u;
        ^
modules/core/src/types.cpp:54:9: note: u.f is assigned
    u.f = pt.y; _Val = (scale * _Val) ^ u.u;
        ^
modules/core/src/types.cpp:55:9: note: u.f is overwritten
    u.f = size; _Val = (scale * _Val) ^ u.u;
        ^
modules/core/src/types.cpp:56:9: style: Variable 'u.f' is reassigned a value before the old one has been used. [redundantAssignment]
    u.f = angle; _Val = (scale * _Val) ^ u.u;
        ^
modules/core/src/types.cpp:55:9: note: u.f is assigned
    u.f = size; _Val = (scale * _Val) ^ u.u;
        ^
modules/core/src/types.cpp:56:9: note: u.f is overwritten
    u.f = angle; _Val = (scale * _Val) ^ u.u;
        ^
modules/core/src/types.cpp:57:9: style: Variable 'u.f' is reassigned a value before the old one has been used. [redundantAssignment]
    u.f = response; _Val = (scale * _Val) ^ u.u;
        ^
modules/core/src/types.cpp:56:9: note: u.f is assigned
    u.f = angle; _Val = (scale * _Val) ^ u.u;
        ^
modules/core/src/types.cpp:57:9: note: u.f is overwritten
    u.f = response; _Val = (scale * _Val) ^ u.u;
        ^
modules/core/src/umatrix.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/umatrix.cpp:831:57: style: The scope of the variable 'dstofs' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t i, sz[CV_MAX_DIM] = {0}, srcofs[CV_MAX_DIM], dstofs[CV_MAX_DIM], esz = elemSize();
                                                        ^
modules/core/src/umatrix.cpp:778:35: warning: Conversion of string literal "Error mapping of UMat to host memory." to bool always evaluates to true. [incorrectStringBooleanError]
        CV_Assert(u->data != 0 && "Error mapping of UMat to host memory.");
                                  ^
modules/core/src/umatrix.cpp:967:14: style: Variable 'src' is assigned a value that is never used. [unreadVariable]
    UMat src = *this;  // Fake reference to itself.
             ^
modules/core/src/utils/filesystem.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/src/utils/filesystem.cpp:199:16: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [knownConditionTrueFalse]
    if (result == -1)
               ^
modules/core/src/utils/filesystem.cpp:196:19: note: 'result' is assigned value '-1' here.
    int result = -1;
                  ^
modules/core/src/utils/filesystem.cpp:199:16: note: The expression 'result == -1' is always true.
    if (result == -1)
               ^
modules/core/src/utils/filesystem.cpp:245:5: style: Struct 'Impl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Impl(const char* fname)
    ^
modules/core/src/utils/filesystem.cpp:312:5: style: Struct 'Impl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Impl(const char* fname)
    ^
modules/core/src/va_intel.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/core/test/ocl/test_arithm.cpp:101:1: error: syntax error [syntaxError]
OCL_TEST_P(Lut, Mat)
^
modules/core/test/ocl/test_channels.cpp:133:1: error: syntax error [syntaxError]
OCL_TEST_P(Merge, Accuracy)
^
modules/core/test/ocl/test_dft.cpp:107:1: error: syntax error [syntaxError]
OCL_TEST_P(Dft, Mat)
^
modules/core/test/ocl/test_gemm.cpp:130:1: error: syntax error [syntaxError]
OCL_TEST_P(Gemm, Accuracy)
^
modules/core/test/ocl/test_image2d.cpp:27:1: error: syntax error [syntaxError]
TEST(Image2D, createImage2DWithEmptyUMat)
^
modules/core/test/ocl/test_matrix_expr.cpp:36:1: error: syntax error [syntaxError]
OCL_TEST_P(UMatExpr, Eye)
^
modules/core/test/ocl/test_matrix_operation.cpp:88:1: error: syntax error [syntaxError]
OCL_TEST_P(ConvertTo, WithScale_Accuracy)
^
modules/core/test/ocl/test_opencl.cpp:30:1: error: syntax error [syntaxError]
TEST(OpenCL, support_binary_programs)
^
modules/core/test/test_arithm.cpp:22:53: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'gamma' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    BaseElemWiseOp() { flags = 0; alpha = beta = 0; gamma = Scalar::all(0); ninputs = 0; context = 1; }
                                                    ^
modules/core/test/test_arithm.cpp:281:5: style: Struct 'LogicOp' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    LogicOp(char _opcode) : BaseElemWiseOp(2, FIX_ALPHA+FIX_BETA+FIX_GAMMA+SUPPORT_MASK, 1, 1, Scalar::all(0)), opcode(_opcode) {}
    ^
modules/core/test/test_arithm.cpp:311:5: style: Struct 'LogicSOp' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    LogicSOp(char _opcode)
    ^
modules/core/test/test_arithm.cpp:102:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:102:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:119:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:119:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:132:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:132:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:145:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:145:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:158:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:158:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:171:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:171:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:175:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:175:12: note: Function in derived class
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:185:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:185:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:189:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:189:12: note: Function in derived class
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:198:10: style: The function 'getValueRange' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void getValueRange(int depth, double& minval, double& maxval)
         ^
modules/core/test/test_arithm.cpp:26:18: note: Virtual function in base class
    virtual void getValueRange(int depth, double& minval, double& maxval)
                 ^
modules/core/test/test_arithm.cpp:198:10: note: Function in derived class
    void getValueRange(int depth, double& minval, double& maxval)
         ^
modules/core/test/test_arithm.cpp:205:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:205:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:209:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:209:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:213:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:213:12: note: Function in derived class
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:222:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:222:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:226:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:226:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:230:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:230:12: note: Function in derived class
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:239:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:239:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:243:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:243:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:247:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:247:12: note: Function in derived class
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:256:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:256:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:260:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:260:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:269:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:269:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:273:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:273:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:282:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:282:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:291:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:291:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:302:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:302:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:313:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:313:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:324:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:324:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:335:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:335:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:345:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:345:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:349:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:349:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:353:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:353:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:362:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:362:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:366:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:366:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:370:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:370:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:379:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:379:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:383:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:383:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:387:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:387:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:396:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:396:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:400:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:400:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:404:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:404:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:413:10: style: The function 'generateScalars' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void generateScalars(int depth, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:44:18: note: Virtual function in base class
    virtual void generateScalars(int depth, RNG& rng)
                 ^
modules/core/test/test_arithm.cpp:413:10: note: Function in derived class
    void generateScalars(int depth, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:418:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:418:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:422:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:422:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:426:9: style: The function 'getRandomType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:37:17: note: Virtual function in base class
    virtual int getRandomType(RNG& rng)
                ^
modules/core/test/test_arithm.cpp:426:9: note: Function in derived class
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:431:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:431:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:441:10: style: The function 'generateScalars' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void generateScalars(int depth, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:44:18: note: Virtual function in base class
    virtual void generateScalars(int depth, RNG& rng)
                 ^
modules/core/test/test_arithm.cpp:441:10: note: Function in derived class
    void generateScalars(int depth, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:448:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:448:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:452:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:452:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:456:9: style: The function 'getRandomType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:37:17: note: Virtual function in base class
    virtual int getRandomType(RNG& rng)
                ^
modules/core/test/test_arithm.cpp:456:9: note: Function in derived class
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:460:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:460:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:471:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:471:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:475:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:475:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:479:9: style: The function 'getRandomType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:37:17: note: Virtual function in base class
    virtual int getRandomType(RNG& rng)
                ^
modules/core/test/test_arithm.cpp:479:9: note: Function in derived class
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:483:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:483:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:493:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>&, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:493:10: note: Function in derived class
    void op(const vector<Mat>&, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:497:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>&, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:497:10: note: Function in derived class
    void refop(const vector<Mat>&, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:501:9: style: The function 'getRandomType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:37:17: note: Virtual function in base class
    virtual int getRandomType(RNG& rng)
                ^
modules/core/test/test_arithm.cpp:501:9: note: Function in derived class
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:505:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:505:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:654:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:654:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:658:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:658:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:662:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:662:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:666:10: style: The function 'generateScalars' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void generateScalars(int depth, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:44:18: note: Virtual function in base class
    virtual void generateScalars(int depth, RNG& rng)
                 ^
modules/core/test/test_arithm.cpp:666:10: note: Function in derived class
    void generateScalars(int depth, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:684:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:684:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:692:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:692:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:700:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:700:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:710:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:710:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:714:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:714:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:718:9: style: The function 'getRandomType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:37:17: note: Virtual function in base class
    virtual int getRandomType(RNG& rng)
                ^
modules/core/test/test_arithm.cpp:718:9: note: Function in derived class
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:724:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:724:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:728:10: style: The function 'generateScalars' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void generateScalars(int depth, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:44:18: note: Virtual function in base class
    virtual void generateScalars(int depth, RNG& rng)
                 ^
modules/core/test/test_arithm.cpp:728:10: note: Function in derived class
    void generateScalars(int depth, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:744:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:744:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:750:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:750:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:754:9: style: The function 'getRandomType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int getRandomType(RNG&)
        ^
modules/core/test/test_arithm.cpp:37:17: note: Virtual function in base class
    virtual int getRandomType(RNG& rng)
                ^
modules/core/test/test_arithm.cpp:754:9: note: Function in derived class
    int getRandomType(RNG&)
        ^
modules/core/test/test_arithm.cpp:761:10: style: The function 'getValueRange' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void getValueRange(int, double& minval, double& maxval)
         ^
modules/core/test/test_arithm.cpp:26:18: note: Virtual function in base class
    virtual void getValueRange(int depth, double& minval, double& maxval)
                 ^
modules/core/test/test_arithm.cpp:761:10: note: Function in derived class
    void getValueRange(int, double& minval, double& maxval)
         ^
modules/core/test/test_arithm.cpp:787:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:787:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:791:10: style: The function 'generateScalars' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void generateScalars(int, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:44:18: note: Virtual function in base class
    virtual void generateScalars(int depth, RNG& rng)
                 ^
modules/core/test/test_arithm.cpp:791:10: note: Function in derived class
    void generateScalars(int, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:801:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:801:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:805:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:805:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:809:9: style: The function 'getRandomType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:37:17: note: Virtual function in base class
    virtual int getRandomType(RNG& rng)
                ^
modules/core/test/test_arithm.cpp:809:9: note: Function in derived class
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:814:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:814:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:818:10: style: The function 'generateScalars' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void generateScalars(int depth, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:44:18: note: Virtual function in base class
    virtual void generateScalars(int depth, RNG& rng)
                 ^
modules/core/test/test_arithm.cpp:818:10: note: Function in derived class
    void generateScalars(int depth, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:874:10: style: The function 'getRandomSize' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void getRandomSize(RNG& rng, vector<int>& size)
         ^
modules/core/test/test_arithm.cpp:32:18: note: Virtual function in base class
    virtual void getRandomSize(RNG& rng, vector<int>& size)
                 ^
modules/core/test/test_arithm.cpp:874:10: note: Function in derived class
    void getRandomSize(RNG& rng, vector<int>& size)
         ^
modules/core/test/test_arithm.cpp:878:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:878:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:882:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:882:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:886:10: style: The function 'generateScalars' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void generateScalars(int, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:44:18: note: Virtual function in base class
    virtual void generateScalars(int depth, RNG& rng)
                 ^
modules/core/test/test_arithm.cpp:886:10: note: Function in derived class
    void generateScalars(int, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:890:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:890:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:900:10: style: The function 'getRandomSize' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void getRandomSize(RNG& rng, vector<int>& size)
         ^
modules/core/test/test_arithm.cpp:32:18: note: Virtual function in base class
    virtual void getRandomSize(RNG& rng, vector<int>& size)
                 ^
modules/core/test/test_arithm.cpp:900:10: note: Function in derived class
    void getRandomSize(RNG& rng, vector<int>& size)
         ^
modules/core/test/test_arithm.cpp:904:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:904:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:908:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:908:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:912:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:912:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:921:10: style: The function 'getRandomSize' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void getRandomSize(RNG& rng, vector<int>& size)
         ^
modules/core/test/test_arithm.cpp:32:18: note: Virtual function in base class
    virtual void getRandomSize(RNG& rng, vector<int>& size)
                 ^
modules/core/test/test_arithm.cpp:921:10: note: Function in derived class
    void getRandomSize(RNG& rng, vector<int>& size)
         ^
modules/core/test/test_arithm.cpp:925:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>&, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:925:10: note: Function in derived class
    void op(const vector<Mat>&, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:929:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>&, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:929:10: note: Function in derived class
    void refop(const vector<Mat>&, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:933:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:933:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:942:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>&, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:942:10: note: Function in derived class
    void op(const vector<Mat>&, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:946:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>&, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:946:10: note: Function in derived class
    void refop(const vector<Mat>&, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:950:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:950:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:1018:9: style: The function 'getRandomType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:37:17: note: Virtual function in base class
    virtual int getRandomType(RNG& rng)
                ^
modules/core/test/test_arithm.cpp:1018:9: note: Function in derived class
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:1022:10: style: The function 'getValueRange' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void getValueRange(int depth, double& minval, double& maxval)
         ^
modules/core/test/test_arithm.cpp:26:18: note: Virtual function in base class
    virtual void getValueRange(int depth, double& minval, double& maxval)
                 ^
modules/core/test/test_arithm.cpp:1022:10: note: Function in derived class
    void getValueRange(int depth, double& minval, double& maxval)
         ^
modules/core/test/test_arithm.cpp:1027:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1027:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:1031:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1031:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:1035:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:1035:12: note: Function in derived class
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:1045:9: style: The function 'getRandomType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:37:17: note: Virtual function in base class
    virtual int getRandomType(RNG& rng)
                ^
modules/core/test/test_arithm.cpp:1045:9: note: Function in derived class
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:1049:10: style: The function 'getValueRange' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void getValueRange(int depth, double& minval, double& maxval)
         ^
modules/core/test/test_arithm.cpp:26:18: note: Virtual function in base class
    virtual void getValueRange(int depth, double& minval, double& maxval)
                 ^
modules/core/test/test_arithm.cpp:1049:10: note: Function in derived class
    void getValueRange(int depth, double& minval, double& maxval)
         ^
modules/core/test/test_arithm.cpp:1054:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1054:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:1060:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1060:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:1066:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:1066:12: note: Function in derived class
    double getMaxErr(int depth)
           ^
modules/core/test/test_arithm.cpp:1131:9: style: The function 'getRandomType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:37:17: note: Virtual function in base class
    virtual int getRandomType(RNG& rng)
                ^
modules/core/test/test_arithm.cpp:1131:9: note: Function in derived class
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:1135:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1135:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:1147:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1147:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:1156:10: style: The function 'generateScalars' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void generateScalars(int, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:44:18: note: Virtual function in base class
    virtual void generateScalars(int depth, RNG& rng)
                 ^
modules/core/test/test_arithm.cpp:1156:10: note: Function in derived class
    void generateScalars(int, RNG& rng)
         ^
modules/core/test/test_arithm.cpp:1160:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:1160:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:1174:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1174:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:1179:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1179:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:1184:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:1184:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:1197:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1197:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:1202:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1202:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat&)
         ^
modules/core/test/test_arithm.cpp:1207:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:1207:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:1218:9: style: The function 'getRandomType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:37:17: note: Virtual function in base class
    virtual int getRandomType(RNG& rng)
                ^
modules/core/test/test_arithm.cpp:1218:9: note: Function in derived class
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:1222:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1222:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:1231:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1231:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:1240:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:1240:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:1257:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1257:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:1262:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1262:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:1280:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:1280:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:1298:9: style: The function 'getRandomType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:37:17: note: Virtual function in base class
    virtual int getRandomType(RNG& rng)
                ^
modules/core/test/test_arithm.cpp:1298:9: note: Function in derived class
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:1315:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1315:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:1321:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1321:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:1327:10: style: The function 'generateScalars' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void generateScalars(int, RNG& /*rng*/)
         ^
modules/core/test/test_arithm.cpp:44:18: note: Virtual function in base class
    virtual void generateScalars(int depth, RNG& rng)
                 ^
modules/core/test/test_arithm.cpp:1327:10: note: Function in derived class
    void generateScalars(int, RNG& /*rng*/)
         ^
modules/core/test/test_arithm.cpp:1330:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:1330:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:1344:9: style: The function 'getRandomType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:37:17: note: Virtual function in base class
    virtual int getRandomType(RNG& rng)
                ^
modules/core/test/test_arithm.cpp:1344:9: note: Function in derived class
    int getRandomType(RNG& rng)
        ^
modules/core/test/test_arithm.cpp:1362:10: style: The function 'op' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:24:18: note: Virtual function in base class
    virtual void op(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1362:10: note: Function in derived class
    void op(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:1370:10: style: The function 'refop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:25:18: note: Virtual function in base class
    virtual void refop(const vector<Mat>&, Mat&, const Mat&) {}
                 ^
modules/core/test/test_arithm.cpp:1370:10: note: Function in derived class
    void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)
         ^
modules/core/test/test_arithm.cpp:1378:12: style: The function 'getMaxErr' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:43:20: note: Virtual function in base class
    virtual double getMaxErr(int depth) { return depth < CV_32F ? 1 : depth == CV_32F ? 1e-5 : 1e-12; }
                   ^
modules/core/test/test_arithm.cpp:1378:12: note: Function in derived class
    double getMaxErr(int)
           ^
modules/core/test/test_arithm.cpp:40:69: style: Finding the same value in both branches of ternary operator is suspicious as the same code is executed regardless of the condition. [duplicateValueTernary]
                                  ninputs > 1 ? ARITHM_MAX_CHANNELS : 4);
                                                                    ^
modules/core/test/test_arithm.cpp:812:47: style: Finding the same value in both branches of ternary operator is suspicious as the same code is executed regardless of the condition. [duplicateValueTernary]
            ninputs > 1 ? ARITHM_MAX_CHANNELS : 4);
                                              ^
modules/core/test/test_arithm.cpp:1586:58: warning: Found suspicious operator ',' [constStatement]
    cv::Mat m1 = (cv::Mat_<double>(3, 2) << 1, 2, 3, 4, 5, 6);
                                                         ^
modules/core/test/test_arithm.cpp:1589:60: warning: Found suspicious operator ',' [constStatement]
    cv::Mat m2 = (cv::Mat_<double>(3, 2) << 1, 12, 3, 14, 5, 16);
                                                           ^
modules/core/test/test_arithm.cpp:1596:64: warning: Found suspicious operator ',' [constStatement]
    cv::Mat m1 = (cv::Mat_<double>(4, 2) << 1, 2, 3, 4, 5, 6, 7, 8);
                                                               ^
modules/core/test/test_arithm.cpp:1599:67: warning: Found suspicious operator ',' [constStatement]
    cv::Mat m2 = (cv::Mat_<double>(4, 2) << 1, 12, 3, 14, 5, 16, 7, 18);
                                                                  ^
modules/core/test/test_arithm.cpp:1938:38: warning: Found suspicious operator ',' [constStatement]
    Mat_<double> A(4,1); A << 1, 3, 2, 4;
                                     ^
modules/core/test/test_concatenation.cpp:82:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'mat0x5' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    mat0x5 = Mat::ones(0,5, CV_8U);
    ^
modules/core/test/test_conjugate_gradient.cpp:90:56: warning: Found suspicious operator ',' [constStatement]
        cv::Mat x=(cv::Mat_<double>(4,1)<<50.0,10.0,1.0,-10.0),
                                                       ^
modules/core/test/test_conjugate_gradient.cpp:91:57: warning: Found suspicious operator ',' [constStatement]
            etalon_x=(cv::Mat_<double>(1,4)<<0.0,0.0,0.0,0.0);
                                                        ^
modules/core/test/test_conjugate_gradient.cpp:99:46: warning: Found suspicious operator ',' [constStatement]
        cv::Mat x=(cv::Mat_<double>(2,1)<<0.0,0.0),
                                             ^
modules/core/test/test_conjugate_gradient.cpp:100:49: warning: Found suspicious operator ',' [constStatement]
            etalon_x=(cv::Mat_<double>(2,1)<<1.0,1.0);
                                                ^
modules/core/test/test_conjugate_gradient.cpp:45:18: style: Parameter 'etalon_x' can be declared with const [constParameter]
        cv::Mat& etalon_x,double etalon_res){
                 ^
modules/core/test/test_countnonzero.cpp:134:12: style: The scope of the variable 'mean' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double mean = 0.0, sigma = 1.0;
           ^
modules/core/test/test_countnonzero.cpp:134:24: style: The scope of the variable 'sigma' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double mean = 0.0, sigma = 1.0;
                       ^
modules/core/test/test_downhill_simplex.cpp:88:46: warning: Found suspicious operator ',' [constStatement]
        cv::Mat x=(cv::Mat_<double>(1,2)<<1.0,1.0),
                                             ^
modules/core/test/test_downhill_simplex.cpp:89:46: warning: Found suspicious operator ',' [constStatement]
            step=(cv::Mat_<double>(2,1)<<-0.5,-0.5),
                                             ^
modules/core/test/test_downhill_simplex.cpp:90:50: warning: Found suspicious operator ',' [constStatement]
            etalon_x=(cv::Mat_<double>(1,2)<<-0.0,0.0);
                                                 ^
modules/core/test/test_downhill_simplex.cpp:98:46: warning: Found suspicious operator ',' [constStatement]
        cv::Mat x=(cv::Mat_<double>(2,1)<<0.0,0.0),
                                             ^
modules/core/test/test_downhill_simplex.cpp:99:45: warning: Found suspicious operator ',' [constStatement]
            step=(cv::Mat_<double>(2,1)<<0.5,+0.5),
                                            ^
modules/core/test/test_downhill_simplex.cpp:100:49: warning: Found suspicious operator ',' [constStatement]
            etalon_x=(cv::Mat_<double>(2,1)<<1.0,1.0);
                                                ^
modules/core/test/test_downhill_simplex.cpp:47:18: style: Parameter 'etalon_x' can be declared with const [constParameter]
        cv::Mat& etalon_x,double etalon_res){
                 ^
modules/core/test/test_ds.cpp:349:25: warning: Member variable 'Core_DynStructBaseTest::cpu_freq' is not initialized in the constructor. [uninitMemberVar]
Core_DynStructBaseTest::Core_DynStructBaseTest()
                        ^
modules/core/test/test_ds.cpp:1382:16: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double t;
               ^
modules/core/test/test_ds.cpp:1811:16: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double t;
               ^
modules/core/test/test_ds.cpp:1928:16: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double t;
               ^
modules/core/test/test_ds.cpp:1142:64: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
                        elem2 = cvSeqSearch( seq, elem0, k % 2 ? icvCmpSeqElems : 0, 0, &idx, seq );
                                                               ^
modules/core/test/test_dxt.cpp:922:5: style: Class 'Core_DXTReverseTest' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Core_DXTReverseTest(Mode m) : mode(m) {}
    ^
modules/core/test/test_dxt.cpp:610:20: style: Condition 'cn==2' is always false [knownConditionTrueFalse]
            if( cn == 2 )
                   ^
modules/core/test/test_dxt.cpp:602:48: note: Assuming that condition 'cn==1' is not redundant
    else if( /*(cn == 2 && (bits&32)) ||*/ (cn == 1 && allow_complex) )
                                               ^
modules/core/test/test_dxt.cpp:610:20: note: Condition 'cn==2' is always false
            if( cn == 2 )
                   ^
modules/core/test/test_dxt.cpp:623:20: style: Condition 'cn==2' is always false [knownConditionTrueFalse]
            if( cn == 2 )
                   ^
modules/core/test/test_dxt.cpp:602:48: note: Assuming that condition 'cn==1' is not redundant
    else if( /*(cn == 2 && (bits&32)) ||*/ (cn == 1 && allow_complex) )
                                               ^
modules/core/test/test_dxt.cpp:623:20: note: Condition 'cn==2' is always false
            if( cn == 2 )
                   ^
modules/core/test/test_eigen.cpp:103:18: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void run(int) = 0;
                 ^
modules/core/test/test_eigen.cpp:80:18: note: Virtual function in base class
    virtual void run (int) = 0;             // main testing method
                 ^
modules/core/test/test_eigen.cpp:103:18: note: Function in derived class
    virtual void run(int) = 0;
                 ^
modules/core/test/test_eigen.cpp:112:10: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void run(int);
         ^
modules/core/test/test_eigen.cpp:103:18: note: Virtual function in base class
    virtual void run(int) = 0;
                 ^
modules/core/test/test_eigen.cpp:112:10: note: Function in derived class
    void run(int);
         ^
modules/core/test/test_eigen.cpp:120:10: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void run(int);
         ^
modules/core/test/test_eigen.cpp:103:18: note: Virtual function in base class
    virtual void run(int) = 0;
                 ^
modules/core/test/test_eigen.cpp:120:10: note: Function in derived class
    void run(int);
         ^
modules/core/test/test_eigen.cpp:128:10: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void run(int);
         ^
modules/core/test/test_eigen.cpp:80:18: note: Virtual function in base class
    virtual void run (int) = 0;             // main testing method
                 ^
modules/core/test/test_eigen.cpp:128:10: note: Function in derived class
    void run(int);
         ^
modules/core/test/test_eigen.cpp:136:10: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void run(int);
         ^
modules/core/test/test_eigen.cpp:80:18: note: Virtual function in base class
    virtual void run (int) = 0;             // main testing method
                 ^
modules/core/test/test_eigen.cpp:136:10: note: Function in derived class
    void run(int);
         ^
modules/core/test/test_hal_core.cpp:133:1: error: syntax error [syntaxError]
TEST_P(HAL, mat_decomp)
^
modules/core/test/test_intrin.cpp:18:1: error: syntax error [syntaxError]
TEST(hal_intrin, uint8x16) {
^
modules/core/test/test_io.cpp:112:55: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            double test_real = (cvtest::randInt(rng)%2?1:-1)*exp(cvtest::randReal(rng)*18-9);
                                                      ^
modules/core/test/test_io.cpp:714:35: error: Uninitialized struct member: tmp.required_alignment_field_for_linux32 [uninitStructMember]
                rawdata.push_back(tmp);
                                  ^
modules/core/test/test_ippasync.cpp:49:1: error: syntax error [syntaxError]
TEST_P(IPPAsync, accuracy)
^
modules/core/test/test_lpsolver.cpp:49:34: warning: Found suspicious operator ',' [constStatement]
    A=(cv::Mat_<double>(3,1)<<3,1,2);
                                 ^
modules/core/test/test_lpsolver.cpp:50:54: warning: Found suspicious operator ',' [constStatement]
    B=(cv::Mat_<double>(3,4)<<1,1,3,30,2,2,5,24,4,1,2,36);
                                                     ^
modules/core/test/test_lpsolver.cpp:54:41: warning: Found suspicious operator ',' [constStatement]
    etalon_z=(cv::Mat_<double>(3,1)<<8,4,0);
                                        ^
modules/core/test/test_lpsolver.cpp:60:33: warning: Found suspicious operator ',' [constStatement]
    A=(cv::Mat_<double>(1,2)<<18,12.5);
                                ^
modules/core/test/test_lpsolver.cpp:61:48: warning: Found suspicious operator ',' [constStatement]
    B=(cv::Mat_<double>(3,3)<<1,1,20,1,0,20,0,1,16);
                                               ^
modules/core/test/test_lpsolver.cpp:65:40: warning: Found suspicious operator ',' [constStatement]
    etalon_z=(cv::Mat_<double>(2,1)<<20,0);
                                       ^
modules/core/test/test_lpsolver.cpp:71:32: warning: Found suspicious operator ',' [constStatement]
    A=(cv::Mat_<double>(1,2)<<5,-3);
                               ^
modules/core/test/test_lpsolver.cpp:72:41: warning: Found suspicious operator ',' [constStatement]
    B=(cv::Mat_<double>(2,3)<<1,-1,1,2,1,2);
                                        ^
modules/core/test/test_lpsolver.cpp:76:39: warning: Found suspicious operator ',' [constStatement]
    etalon_z=(cv::Mat_<double>(2,1)<<1,0);
                                      ^
modules/core/test/test_lpsolver.cpp:86:36: warning: Found suspicious operator ',' [constStatement]
    A=(cv::Mat_<double>(1,3)<<-1,-1,-1);
                                   ^
modules/core/test/test_lpsolver.cpp:87:59: warning: Found suspicious operator ',' [constStatement]
    B=(cv::Mat_<double>(2,4)<<-2,-7.5,-3,-10000,-20,-5,-10,-30000);
                                                          ^
modules/core/test/test_lpsolver.cpp:91:47: warning: Found suspicious operator ',' [constStatement]
    etalon_z=(cv::Mat_<double>(3,1)<<1250,1000,0);
                                              ^
modules/core/test/test_lpsolver.cpp:102:32: warning: Found suspicious operator ',' [constStatement]
    B=(cv::Mat_<double>(2,2)<<1,-1);
                               ^
modules/core/test/test_lpsolver.cpp:114:32: warning: Found suspicious operator ',' [constStatement]
    A=(cv::Mat_<double>(2,1)<<1,1);
                               ^
modules/core/test/test_lpsolver.cpp:115:34: warning: Found suspicious operator ',' [constStatement]
    B=(cv::Mat_<double>(1,3)<<1,1,1);
                                 ^
modules/core/test/test_lpsolver.cpp:131:40: warning: Found suspicious operator ',' [constStatement]
    A=(cv::Mat_<double>(4,1)<<10,-57,-9,-24);
                                       ^
modules/core/test/test_lpsolver.cpp:132:74: warning: Found suspicious operator ',' [constStatement]
    B=(cv::Mat_<double>(3,5)<<0.5,-5.5,-2.5,9,0,0.5,-1.5,-0.5,1,0,1,0,0,0,1);
                                                                         ^
modules/core/test/test_mat.cpp:1051:17: style: The function 'run_case' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int run_case(int depth, size_t matCount, const Size& size, RNG& rng)
                ^
modules/core/test/test_mat.cpp:1004:17: note: Virtual function in base class
    virtual int run_case(int depth, size_t channels, const Size& size, RNG& rng) = 0;
                ^
modules/core/test/test_mat.cpp:1051:17: note: Function in derived class
    virtual int run_case(int depth, size_t matCount, const Size& size, RNG& rng)
                ^
modules/core/test/test_mat.cpp:1109:17: style: The function 'run_case' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int run_case(int depth, size_t channels, const Size& size, RNG& rng)
                ^
modules/core/test/test_mat.cpp:1004:17: note: Virtual function in base class
    virtual int run_case(int depth, size_t channels, const Size& size, RNG& rng) = 0;
                ^
modules/core/test/test_mat.cpp:1109:17: note: Function in derived class
    virtual int run_case(int depth, size_t channels, const Size& size, RNG& rng)
                ^
modules/core/test/test_mat.cpp:1019:16: style: Redundant initialization for 'curRes'. The initialized value is overwritten before it is read. [redundantInitialization]
        curRes = run_case(CV_8U, mvSize, mSize, rng);
               ^
modules/core/test/test_mat.cpp:1018:42: note: curRes is initialized
        int res = cvtest::TS::OK, curRes = res;
                                         ^
modules/core/test/test_mat.cpp:1019:16: note: curRes is overwritten
        curRes = run_case(CV_8U, mvSize, mSize, rng);
               ^
modules/core/test/test_mat.cpp:1198:99: warning: Found suspicious operator ',' [constStatement]
    cv::Mat A = (cv::Mat_<float>(2,3) << 3.4884074, 1.4159607, 0.78737736,  2.3456569, -0.88010466, 0.3009364);
                                                                                                  ^
modules/core/test/test_mat.cpp:1276:44: warning: Found suspicious operator ',' [constStatement]
    Mat a = (Mat_<float>(1,2) << 3.4884074f, 1.4159607f);
                                           ^
modules/core/test/test_mat.cpp:1277:45: warning: Found suspicious operator ',' [constStatement]
    Mat b = (Mat_<float>(1,2) << 0.78737736f, 2.3456569f);
                                            ^
modules/core/test/test_mat.cpp:1289:71: warning: Found suspicious operator ',' [constStatement]
    Mat c = (Mat_<float>(2,2) << -0.88010466f, 0.3009364f, 2.22399974f, -5.45933905f);
                                                                      ^
modules/core/test/test_mat.cpp:1328:22: warning: Found suspicious operator ',' [constStatement]
    src << 1, 2, 3, 4, 5;
                     ^
modules/core/test/test_mat.cpp:1343:54: warning: Found suspicious operator ',' [constStatement]
    Mat_<double> a = (Mat_<double>(2,2) << 10, 11, 12, 13);
                                                     ^
modules/core/test/test_mat.cpp:1429:27: warning: Found suspicious operator ',' [constStatement]
    src_base << 1, 2, 3, 4, 5;
                          ^
modules/core/test/test_mat.cpp:1447:42: warning: Found suspicious operator ',' [constStatement]
    src_base << 1, 2, 3, 4, 5, 6, 7, 8, 9, 10;
                                         ^
modules/core/test/test_mat.cpp:1479:42: warning: Found suspicious operator ',' [constStatement]
    src_base << 1, 2, 3, 4, 5, 6, 7, 8, 9, 10;
                                         ^
modules/core/test/test_mat.cpp:512:59: style: Parameter 'rng' can be declared with const [constParameter]
static double getValue(SparseMat& M, const int* idx, RNG& rng)
                                                          ^
modules/core/test/test_mat.cpp:536:59: style: Parameter 'rng' can be declared with const [constParameter]
static void eraseValue(SparseMat& M, const int* idx, RNG& rng)
                                                          ^
modules/core/test/test_mat.cpp:560:71: style: Parameter 'rng' can be declared with const [constParameter]
static void setValue(SparseMat& M, const int* idx, double value, RNG& rng)
                                                                      ^
modules/core/test/test_mat.cpp:42:19: style: Variable 'sum_' can be declared with const [constVariable]
    Mat_<double>& sum_ = (Mat_<double>&)sum;
                  ^
modules/core/test/test_mat.cpp:43:19: style: Variable 'min_' can be declared with const [constVariable]
    Mat_<double>& min_ = (Mat_<double>&)min;
                  ^
modules/core/test/test_mat.cpp:44:19: style: Variable 'max_' can be declared with const [constVariable]
    Mat_<double>& max_ = (Mat_<double>&)max;
                  ^
modules/core/test/test_mat.cpp:515:15: style: Variable 'hv' is assigned a value that is never used. [unreadVariable]
    size_t hv = 0, *phv = 0;
              ^
modules/core/test/test_mat.cpp:539:15: style: Variable 'hv' is assigned a value that is never used. [unreadVariable]
    size_t hv = 0, *phv = 0;
              ^
modules/core/test/test_mat.cpp:563:15: style: Variable 'hv' is assigned a value that is never used. [unreadVariable]
    size_t hv = 0, *phv = 0;
              ^
modules/core/test/test_mat.cpp:1445:24: style: Unused variable: dst1 [unusedVariable]
    std::vector<uchar> dst1;
                       ^
modules/core/test/test_mat.cpp:1352:54: warning: Found suspicious operator ',' [constStatement]
    Mat_<double> a = (Mat_<double>(2,2) << 10, 11, 12, 13);
                                                     ^
modules/core/test/test_mat.cpp:1722:35: warning: Found suspicious operator ',' [constStatement]
    Mat_<float> B(3, 1); B << 1, 2, 3;
                                  ^
modules/core/test/test_mat.cpp:1731:35: warning: Found suspicious operator ',' [constStatement]
    Mat_<float> B(3, 1); B << 1, 2, 3;
                                  ^
modules/core/test/test_mat.cpp:1739:56: warning: Found suspicious operator ',' [constStatement]
    Mat mat = (Mat_<float>(2, 2) << 11.0f, 22.0f, 33.0f, 44.0f);
                                                       ^
modules/core/test/test_mat.cpp:1751:66: warning: Found suspicious operator ',' [constStatement]
                                              55.0f, 66.0f, 77.0f, 88.0f);
                                                                 ^
modules/core/test/test_mat.cpp:1711:15: style: Consider using std::fill algorithm instead of a raw loop. [useStlAlgorithm]
        pixel = 1;
              ^
modules/core/test/test_mat.cpp:1609:27: warning: Found suspicious operator ',' [constStatement]
    src_base << 1, 2, 3, 4, 5;
                          ^
modules/core/test/test_mat.cpp:1627:42: warning: Found suspicious operator ',' [constStatement]
    src_base << 1, 2, 3, 4, 5, 6, 7, 8, 9, 10;
                                         ^
modules/core/test/test_mat.cpp:1649:42: warning: Found suspicious operator ',' [constStatement]
    src_base << 1, 2, 3, 4, 5, 6, 7, 8, 9, 10;
                                         ^
modules/core/test/test_math.cpp:2904:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(KMeansInputVariant, MAT_N_DIM_C1, MAT_N_1_CDIM, MAT_1_N_CDIM, MAT_N_DIM_C1_NONCONT, MAT_N_1_CDIM_NONCONT, VECTOR)
^
modules/core/test/test_misc.cpp:42:57: warning: Found suspicious operator ',' [constStatement]
    Mat expected = (Mat_<double>(2,3) << 1, 2, 3, .1, .2, .3);
                                                        ^
modules/core/test/test_misc.cpp:57:56: warning: Found suspicious operator ',' [constStatement]
    Mat expected = (Mat_<float>(2,3) << 1, 2, 3, .1, .2, .3);
                                                       ^
modules/core/test/test_misc.cpp:72:57: warning: Found suspicious operator ',' [constStatement]
    Mat expected = (Mat_<double>(2,3) << 1, 2, 3, .1, .2, .3);
                                                        ^
modules/core/test/test_misc.cpp:87:57: warning: Found suspicious operator ',' [constStatement]
    Mat expected = (Mat_<double>(2,3) << 1, 2, 3, .1, .2, .3);
                                                        ^
modules/core/test/test_misc.cpp:103:56: warning: Found suspicious operator ',' [constStatement]
    Mat expected = (Mat_<float>(2,3) << 1, 2, 3, .1, .2, .3);
                                                       ^
modules/core/test/test_misc.cpp:119:57: warning: Found suspicious operator ',' [constStatement]
    Mat expected = (Mat_<double>(2,3) << 1, 2, 3, .1, .2, .3);
                                                        ^
modules/core/test/test_misc.cpp:151:42: warning: Found suspicious operator ',' [constStatement]
    Mat src = (Mat_<int>(1, 4) << 1, 2, 3, 4);
                                         ^
modules/core/test/test_operations.cpp:1146:1: error: syntax error [syntaxError]
TEST(Core_Array, expressions) { CV_OperationsTest test; test.safe_run(); }
^
modules/core/test/test_ptr.cpp:55:5: style: Struct 'Reporter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Reporter(bool* deleted) : deleted_(deleted)
    ^
modules/core/test/test_ptr.cpp:70:5: style: Struct 'ReportingDeleter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ReportingDeleter(bool* deleted) : deleted_(deleted)
    ^
modules/core/test/test_ptr.cpp:286:5: style: Struct 'SubReporter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    SubReporter(bool* deleted) : Reporter(deleted)
    ^
modules/core/test/test_ptr.cpp:158:12: style: Variable 'p1' is assigned a value that is never used. [unreadVariable]
        p1 = p1;
           ^
modules/core/test/test_ptr.cpp:362:21: style: Variable 'p' is assigned a value that is never used. [unreadVariable]
        Ptr<void> p = makePtr<Reporter>(&deleted);
                    ^
modules/core/test/test_rand.cpp:407:1: error: syntax error [syntaxError]
TEST(Core_Rand, parallel_for_stable_results)
^
modules/core/test/test_umat.cpp:85:1: error: syntax error [syntaxError]
TEST_P(UMatBasicTests, createUMat)
^
modules/core/test/test_utils.cpp:18:1: error: syntax error [syntaxError]
TEST(CommandLineParser, testFailure)
^
modules/cudaarithm/perf/perf_arithm.cpp:114:1: error: syntax error [syntaxError]
PERF_TEST_P(Sz_Flags, MulSpectrums,
^
modules/cudaarithm/perf/perf_arithm.cpp:62:1: error: syntax error [syntaxError]
PERF_TEST_P(Sz_Type_Flags, GEMM,
^
modules/cudaarithm/test/test_arithm.cpp:59:1: error: syntax error [syntaxError]
PARAM_TEST_CASE(GEMM, cv::cuda::DeviceInfo, cv::Size, MatType, GemmFlags, UseRoi)
^
modules/cudaarithm/test/test_core.cpp:74:1: error: syntax error [syntaxError]
CUDA_TEST_P(Merge, Accuracy)
^
modules/cudaarithm/test/test_element_operations.cpp:57:9: style: The scope of the variable 'channels' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int channels;
        ^
modules/cudaarithm/test/test_element_operations.cpp:58:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:60:9: style: The scope of the variable 'stype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int stype;
        ^
modules/cudaarithm/test/test_element_operations.cpp:61:9: style: The scope of the variable 'dtype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int dtype;
        ^
modules/cudaarithm/test/test_element_operations.cpp:120:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:122:9: style: The scope of the variable 'stype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int stype;
        ^
modules/cudaarithm/test/test_element_operations.cpp:123:9: style: The scope of the variable 'dtype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int dtype;
        ^
modules/cudaarithm/test/test_element_operations.cpp:184:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:272:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:360:9: style: The scope of the variable 'channels' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int channels;
        ^
modules/cudaarithm/test/test_element_operations.cpp:361:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:363:9: style: The scope of the variable 'stype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int stype;
        ^
modules/cudaarithm/test/test_element_operations.cpp:364:9: style: The scope of the variable 'dtype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int dtype;
        ^
modules/cudaarithm/test/test_element_operations.cpp:423:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:425:9: style: The scope of the variable 'stype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int stype;
        ^
modules/cudaarithm/test/test_element_operations.cpp:426:9: style: The scope of the variable 'dtype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int dtype;
        ^
modules/cudaarithm/test/test_element_operations.cpp:487:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:575:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:663:9: style: The scope of the variable 'channels' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int channels;
        ^
modules/cudaarithm/test/test_element_operations.cpp:664:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:666:9: style: The scope of the variable 'stype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int stype;
        ^
modules/cudaarithm/test/test_element_operations.cpp:667:9: style: The scope of the variable 'dtype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int dtype;
        ^
modules/cudaarithm/test/test_element_operations.cpp:757:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:856:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:943:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:1030:9: style: The scope of the variable 'channels' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int channels;
        ^
modules/cudaarithm/test/test_element_operations.cpp:1031:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:1033:9: style: The scope of the variable 'stype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int stype;
        ^
modules/cudaarithm/test/test_element_operations.cpp:1034:9: style: The scope of the variable 'dtype' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int dtype;
        ^
modules/cudaarithm/test/test_element_operations.cpp:1124:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:1223:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:1309:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:1364:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_element_operations.cpp:1365:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:1478:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_element_operations.cpp:1479:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:1517:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_element_operations.cpp:1518:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:1587:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_element_operations.cpp:1588:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:1657:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_element_operations.cpp:1658:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:1737:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_element_operations.cpp:1738:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:1780:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_element_operations.cpp:1781:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:1944:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudaarithm/test/test_element_operations.cpp:1945:9: style: The scope of the variable 'cmp_code' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int cmp_code;
        ^
modules/cudaarithm/test/test_element_operations.cpp:1946:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:2012:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudaarithm/test/test_element_operations.cpp:2082:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_element_operations.cpp:2083:9: style: The scope of the variable 'channels' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int channels;
        ^
modules/cudaarithm/test/test_element_operations.cpp:2180:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_element_operations.cpp:2181:9: style: The scope of the variable 'channels' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int channels;
        ^
modules/cudaarithm/test/test_element_operations.cpp:2182:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:2260:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_element_operations.cpp:2261:9: style: The scope of the variable 'channels' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int channels;
        ^
modules/cudaarithm/test/test_element_operations.cpp:2262:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:2305:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_element_operations.cpp:2306:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:2388:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_element_operations.cpp:2389:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:2471:9: style: The scope of the variable 'depth1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth1;
        ^
modules/cudaarithm/test/test_element_operations.cpp:2472:9: style: The scope of the variable 'depth2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth2;
        ^
modules/cudaarithm/test/test_element_operations.cpp:2473:9: style: The scope of the variable 'dst_depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int dst_depth;
        ^
modules/cudaarithm/test/test_element_operations.cpp:2474:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:2587:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:2676:10: style: The scope of the variable 'angleInDegrees' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool angleInDegrees;
         ^
modules/cudaarithm/test/test_element_operations.cpp:2677:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:2717:10: style: The scope of the variable 'angleInDegrees' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool angleInDegrees;
         ^
modules/cudaarithm/test/test_element_operations.cpp:2718:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:2761:10: style: The scope of the variable 'angleInDegrees' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool angleInDegrees;
         ^
modules/cudaarithm/test/test_element_operations.cpp:2762:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_element_operations.cpp:1569:48: style: Parameter 'dst' can be declared with const [constParameter]
    void sqrtGold(const cv::Mat& src, cv::Mat& dst)
                                               ^
modules/cudaarithm/test/test_element_operations.cpp:1639:47: style: Parameter 'dst' can be declared with const [constParameter]
    void logGold(const cv::Mat& src, cv::Mat& dst)
                                              ^
modules/cudaarithm/test/test_element_operations.cpp:1719:47: style: Parameter 'dst' can be declared with const [constParameter]
    void expGold(const cv::Mat& src, cv::Mat& dst)
                                              ^
modules/cudaarithm/test/test_element_operations.cpp:1922:72: style: Parameter 'dst' can be declared with const [constParameter]
    void compareScalarGold(const cv::Mat& src, cv::Scalar sc, cv::Mat& dst, int cmpop)
                                                                       ^
modules/cudaarithm/test/test_element_operations.cpp:2163:71: style: Parameter 'dst' can be declared with const [constParameter]
    void rhiftGold(const cv::Mat& src, cv::Scalar_<int> val, cv::Mat& dst)
                                                                      ^
modules/cudaarithm/test/test_element_operations.cpp:2243:71: style: Parameter 'dst' can be declared with const [constParameter]
    void lhiftGold(const cv::Mat& src, cv::Scalar_<int> val, cv::Mat& dst)
                                                                      ^
modules/cudaarithm/test/test_gpumat.cpp:59:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudaarithm/test/test_gpumat.cpp:60:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_gpumat.cpp:175:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudaarithm/test/test_gpumat.cpp:176:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_gpumat.cpp:245:9: style: The scope of the variable 'depth1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth1;
        ^
modules/cudaarithm/test/test_gpumat.cpp:246:9: style: The scope of the variable 'depth2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth2;
        ^
modules/cudaarithm/test/test_gpumat.cpp:247:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_opengl.cpp:69:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudaarithm/test/test_opengl.cpp:293:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudaarithm/test/test_opengl.cpp:294:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_opengl.cpp:295:9: style: The scope of the variable 'cn' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int cn;
        ^
modules/cudaarithm/test/test_reductions.cpp:56:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_reductions.cpp:57:9: style: The scope of the variable 'normCode' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int normCode;
        ^
modules/cudaarithm/test/test_reductions.cpp:58:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_reductions.cpp:123:9: style: The scope of the variable 'normCode' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int normCode;
        ^
modules/cudaarithm/test/test_reductions.cpp:124:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_reductions.cpp:263:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudaarithm/test/test_reductions.cpp:264:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_reductions.cpp:375:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_reductions.cpp:376:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_reductions.cpp:541:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_reductions.cpp:542:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_reductions.cpp:753:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaarithm/test/test_reductions.cpp:754:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_reductions.cpp:908:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudaarithm/test/test_reductions.cpp:909:9: style: The scope of the variable 'norm_type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int norm_type;
        ^
modules/cudaarithm/test/test_reductions.cpp:910:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_reductions.cpp:912:12: style: The scope of the variable 'alpha' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double alpha;
           ^
modules/cudaarithm/test/test_reductions.cpp:913:12: style: The scope of the variable 'beta' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double beta;
           ^
modules/cudaarithm/test/test_reductions.cpp:974:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_reductions.cpp:1052:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaarithm/test/test_reductions.cpp:1089:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudabgsegm/test/test_bgsegm.cpp:64:10: style: The scope of the variable 'useGray' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useGray;
         ^
modules/cudabgsegm/test/test_bgsegm.cpp:65:10: style: The scope of the variable 'detectShadow' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool detectShadow;
         ^
modules/cudabgsegm/test/test_bgsegm.cpp:66:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudacodec/src/video_source.hpp:56:1: style: The class 'VideoSource' does not have a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class VideoSource
^
modules/cudacodec/src/video_source.hpp:79:5: style: Class 'RawVideoSourceWrapper' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    RawVideoSourceWrapper(const Ptr<RawVideoSource>& source);
    ^
modules/cudacodec/src/ffmpeg_video_source.hpp:56:5: style: Class 'FFmpegVideoSource' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    FFmpegVideoSource(const String& fname);
    ^
modules/cudacodec/src/video_source.hpp:81:16: style: The function 'format' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    FormatInfo format() const;
               ^
modules/cudacodec/src/video_source.hpp:61:24: note: Virtual function in base class
    virtual FormatInfo format() const = 0;
                       ^
modules/cudacodec/src/video_source.hpp:81:16: note: Function in derived class
    FormatInfo format() const;
               ^
modules/cudacodec/src/video_source.hpp:82:10: style: The function 'start' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void start();
         ^
modules/cudacodec/src/video_source.hpp:62:18: note: Virtual function in base class
    virtual void start() = 0;
                 ^
modules/cudacodec/src/video_source.hpp:82:10: note: Function in derived class
    void start();
         ^
modules/cudacodec/src/video_source.hpp:83:10: style: The function 'stop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void stop();
         ^
modules/cudacodec/src/video_source.hpp:63:18: note: Virtual function in base class
    virtual void stop() = 0;
                 ^
modules/cudacodec/src/video_source.hpp:83:10: note: Function in derived class
    void stop();
         ^
modules/cudacodec/src/video_source.hpp:84:10: style: The function 'isStarted' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool isStarted() const;
         ^
modules/cudacodec/src/video_source.hpp:64:18: note: Virtual function in base class
    virtual bool isStarted() const = 0;
                 ^
modules/cudacodec/src/video_source.hpp:84:10: note: Function in derived class
    bool isStarted() const;
         ^
modules/cudacodec/src/video_source.hpp:85:10: style: The function 'hasError' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool hasError() const;
         ^
modules/cudacodec/src/video_source.hpp:65:18: note: Virtual function in base class
    virtual bool hasError() const = 0;
                 ^
modules/cudacodec/src/video_source.hpp:85:10: note: Function in derived class
    bool hasError() const;
         ^
modules/cudacodec/src/cuvid_video_source.hpp:65:16: style: The function 'format' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    FormatInfo format() const;
               ^
modules/cudacodec/src/video_source.hpp:61:24: note: Virtual function in base class
    virtual FormatInfo format() const = 0;
                       ^
modules/cudacodec/src/cuvid_video_source.hpp:65:16: note: Function in derived class
    FormatInfo format() const;
               ^
modules/cudacodec/src/cuvid_video_source.hpp:66:10: style: The function 'start' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void start();
         ^
modules/cudacodec/src/video_source.hpp:62:18: note: Virtual function in base class
    virtual void start() = 0;
                 ^
modules/cudacodec/src/cuvid_video_source.hpp:66:10: note: Function in derived class
    void start();
         ^
modules/cudacodec/src/cuvid_video_source.hpp:67:10: style: The function 'stop' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void stop();
         ^
modules/cudacodec/src/video_source.hpp:63:18: note: Virtual function in base class
    virtual void stop() = 0;
                 ^
modules/cudacodec/src/cuvid_video_source.hpp:67:10: note: Function in derived class
    void stop();
         ^
modules/cudacodec/src/cuvid_video_source.hpp:68:10: style: The function 'isStarted' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool isStarted() const;
         ^
modules/cudacodec/src/video_source.hpp:64:18: note: Virtual function in base class
    virtual bool isStarted() const = 0;
                 ^
modules/cudacodec/src/cuvid_video_source.hpp:68:10: note: Function in derived class
    bool isStarted() const;
         ^
modules/cudacodec/src/cuvid_video_source.hpp:69:10: style: The function 'hasError' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool hasError() const;
         ^
modules/cudacodec/src/video_source.hpp:65:18: note: Virtual function in base class
    virtual bool hasError() const = 0;
                 ^
modules/cudacodec/src/cuvid_video_source.hpp:69:10: note: Function in derived class
    bool hasError() const;
         ^
modules/cudacodec/src/ffmpeg_video_source.cpp:62:13: style: Condition '!initialized' is always true [knownConditionTrueFalse]
        if (!initialized)
            ^
modules/cudacodec/src/video_reader.cpp:118:9: style: Class 'VideoCtxAutoLock' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        VideoCtxAutoLock(CUvideoctxlock lock) : m_lock(lock) { cuSafeCall( cuvidCtxLock(m_lock, 0) ); }
        ^
modules/cudacodec/src/video_source.cpp:57:47: warning: Member variable 'RawVideoSourceWrapper::stop_' is not initialized in the constructor. [uninitMemberVar]
cv::cudacodec::detail::RawVideoSourceWrapper::RawVideoSourceWrapper(const Ptr<RawVideoSource>& source) :
                                              ^
modules/cudacodec/src/video_source.cpp:57:47: warning: Member variable 'RawVideoSourceWrapper::hasError_' is not initialized in the constructor. [uninitMemberVar]
cv::cudacodec::detail::RawVideoSourceWrapper::RawVideoSourceWrapper(const Ptr<RawVideoSource>& source) :
                                              ^
modules/cudacodec/src/video_writer.cpp:486:73: style: Parameter 'dst' can be declared with const [constParameter]
    void copyUYVYorYUY2Frame(Size frameSize, const GpuMat& src, GpuMat& dst)
                                                                        ^
modules/cudacodec/src/video_writer.cpp:578:67: style: Parameter 'dst' can be declared with const [constParameter]
    void copyNV12Frame(Size frameSize, const GpuMat& src, GpuMat& dst)
                                                                  ^
modules/cudafeatures2d/test/test_features2d.cpp:76:1: error: syntax error [syntaxError]
CUDA_TEST_P(FAST, Accuracy)
^
modules/cudafilters/test/test_filters.cpp:51:5: error: There is an unknown macro here somewhere. Configuration is required. If IMPLEMENT_PARAM_CLASS is a macro then please configure it. [unknownMacro]
    IMPLEMENT_PARAM_CLASS(KSize, cv::Size)
    ^
modules/cudaimgproc/perf/perf_histogram.cpp:100:9: style: The scope of the variable 'histSize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int histSize[] = {30, 30, 30, 30};
        ^
modules/cudaimgproc/perf/perf_histogram.cpp:101:9: style: The scope of the variable 'lowerLevel' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int lowerLevel[] = {0, 0, 0, 0};
        ^
modules/cudaimgproc/perf/perf_histogram.cpp:102:9: style: The scope of the variable 'upperLevel' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int upperLevel[] = {180, 180, 180, 180};
        ^
modules/cudaimgproc/test/test_bilateral_filter.cpp:56:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudaimgproc/test/test_bilateral_filter.cpp:57:9: style: The scope of the variable 'kernel_size' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int kernel_size;
        ^
modules/cudaimgproc/test/test_bilateral_filter.cpp:58:11: style: The scope of the variable 'sigma_color' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float sigma_color;
          ^
modules/cudaimgproc/test/test_bilateral_filter.cpp:59:11: style: The scope of the variable 'sigma_spatial' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float sigma_spatial;
          ^
modules/cudaimgproc/test/test_blend.cpp:83:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudaimgproc/test/test_blend.cpp:84:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaimgproc/test/test_canny.cpp:78:1: error: syntax error [syntaxError]
CUDA_TEST_P(Canny, Accuracy)
^
modules/cudaimgproc/test/test_color.cpp:56:9: style: The scope of the variable 'depth' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int depth;
        ^
modules/cudaimgproc/test/test_color.cpp:57:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaimgproc/test/test_color.cpp:2478:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudaimgproc/test/test_corners.cpp:61:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudaimgproc/test/test_corners.cpp:62:9: style: The scope of the variable 'borderType' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int borderType;
        ^
modules/cudaimgproc/test/test_corners.cpp:63:9: style: The scope of the variable 'blockSize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int blockSize;
        ^
modules/cudaimgproc/test/test_corners.cpp:64:9: style: The scope of the variable 'apertureSize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int apertureSize;
        ^
modules/cudaimgproc/test/test_corners.cpp:109:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudaimgproc/test/test_corners.cpp:110:9: style: The scope of the variable 'borderType' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int borderType;
        ^
modules/cudaimgproc/test/test_corners.cpp:111:9: style: The scope of the variable 'blockSize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int blockSize;
        ^
modules/cudaimgproc/test/test_corners.cpp:112:9: style: The scope of the variable 'apertureSize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int apertureSize;
        ^
modules/cudaimgproc/test/test_gftt.cpp:60:12: style: The scope of the variable 'minDistance' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double minDistance;
           ^
modules/cudaimgproc/test/test_histogram.cpp:68:1: error: syntax error [syntaxError]
CUDA_TEST_P(HistEven, Accuracy)
^
modules/cudaimgproc/test/test_hough.cpp:85:1: error: syntax error [syntaxError]
CUDA_TEST_P(HoughLines, Accuracy)
^
modules/cudaimgproc/test/test_match_template.cpp:65:9: style: The scope of the variable 'cn' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int cn;
        ^
modules/cudaimgproc/test/test_match_template.cpp:66:9: style: The scope of the variable 'method' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int method;
        ^
modules/cudaimgproc/test/test_match_template.cpp:122:9: style: The scope of the variable 'cn' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int cn;
        ^
modules/cudaimgproc/test/test_match_template.cpp:123:9: style: The scope of the variable 'method' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int method;
        ^
modules/cudaimgproc/test/test_match_template.cpp:179:9: style: The scope of the variable 'method' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int method;
        ^
modules/cudaimgproc/test/test_mean_shift.cpp:136:9: style: The scope of the variable 'minsize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int minsize;
        ^
modules/cudalegacy/perf/perf_labeling.cpp:83:73: warning: Struct 'GreedyLabeling' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    : image(img), _labels(image.size(), CV_32SC1, cv::Scalar::all(-1)) {stack = new dot[image.cols * image.rows];}
                                                                        ^
modules/cudalegacy/perf/perf_labeling.cpp:83:73: warning: Struct 'GreedyLabeling' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    : image(img), _labels(image.size(), CV_32SC1, cv::Scalar::all(-1)) {stack = new dot[image.cols * image.rows];}
                                                                        ^
modules/cudalegacy/perf/perf_labeling.cpp:82:5: style: Struct 'GreedyLabeling' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    GreedyLabeling(cv::Mat img)
    ^
modules/cudalegacy/src/NCV.cpp:363:66: error: syntax error [syntaxError]
            ncvAssertCUDAReturn(cudaMalloc(&allocBegin, capacity), );
                                                                 ^
modules/cudalegacy/test/NCVTest.hpp:87:103: error: syntax error [syntaxError]
        ncvAssertPrintReturn(cudaSuccess == cudaGetDevice(&devId), "Error returned from cudaGetDevice", );
                                                                                                      ^
modules/cudaobjdetect/test/test_objdetect.cpp:157:1: error: syntax error [syntaxError]
CUDA_TEST_P(HOG, DISABLED_Detect)
^
modules/cudaoptflow/perf/perf_optflow.cpp:218:28: style: Variable 'u' is assigned a value that is never used. [unreadVariable]
        cv::cuda::GpuMat u = flows[0];
                           ^
modules/cudaoptflow/perf/perf_optflow.cpp:219:28: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
        cv::cuda::GpuMat v = flows[1];
                           ^
modules/cudaoptflow/test/test_optflow.cpp:68:1: error: syntax error [syntaxError]
CUDA_TEST_P(BroxOpticalFlow, Regression)
^
modules/cudastereo/test/test_stereo.cpp:66:1: error: syntax error [syntaxError]
CUDA_TEST_P(StereoBM, Regression)
^
modules/cudawarping/test/test_pyramids.cpp:56:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudawarping/test/test_pyramids.cpp:57:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudawarping/test/test_pyramids.cpp:96:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudawarping/test/test_pyramids.cpp:97:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudawarping/test/test_remap.cpp:119:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudawarping/test/test_remap.cpp:120:9: style: The scope of the variable 'interpolation' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int interpolation;
        ^
modules/cudawarping/test/test_remap.cpp:121:9: style: The scope of the variable 'borderType' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int borderType;
        ^
modules/cudawarping/test/test_remap.cpp:122:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudawarping/test/test_remap.cpp:72:91: style: Parameter 'dst' can be declared with const [constParameter]
    void remapGold(const cv::Mat& src, const cv::Mat& xmap, const cv::Mat& ymap, cv::Mat& dst, int interpolation, int borderType, cv::Scalar borderVal)
                                                                                          ^
modules/cudawarping/test/test_resize.cpp:124:12: style: The scope of the variable 'coeff' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double coeff;
           ^
modules/cudawarping/test/test_resize.cpp:125:9: style: The scope of the variable 'interpolation' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int interpolation;
        ^
modules/cudawarping/test/test_resize.cpp:126:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudawarping/test/test_resize.cpp:127:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudawarping/test/test_resize.cpp:169:12: style: The scope of the variable 'coeff' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double coeff;
           ^
modules/cudawarping/test/test_resize.cpp:170:9: style: The scope of the variable 'interpolation' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int interpolation;
        ^
modules/cudawarping/test/test_resize.cpp:171:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudawarping/test/test_resize.cpp:172:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudawarping/test/test_resize.cpp:76:50: style: Parameter 'dst' can be declared with const [constParameter]
    void resizeGold(const cv::Mat& src, cv::Mat& dst, double fx, double fy, int interpolation)
                                                 ^
modules/cudawarping/test/test_warp_affine.cpp:69:10: style: The scope of the variable 'inverse' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool inverse;
         ^
modules/cudawarping/test/test_warp_affine.cpp:187:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudawarping/test/test_warp_affine.cpp:188:10: style: The scope of the variable 'inverse' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool inverse;
         ^
modules/cudawarping/test/test_warp_affine.cpp:189:9: style: The scope of the variable 'interpolation' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int interpolation;
        ^
modules/cudawarping/test/test_warp_affine.cpp:190:9: style: The scope of the variable 'borderType' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int borderType;
        ^
modules/cudawarping/test/test_warp_affine.cpp:191:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudawarping/test/test_warp_affine.cpp:240:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudawarping/test/test_warp_affine.cpp:241:10: style: The scope of the variable 'inverse' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool inverse;
         ^
modules/cudawarping/test/test_warp_affine.cpp:242:9: style: The scope of the variable 'interpolation' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int interpolation;
        ^
modules/cudawarping/test/test_warp_affine.cpp:133:102: style: Parameter 'dst' can be declared with const [constParameter]
    void warpAffineGold(const cv::Mat& src, const cv::Mat& M, bool inverse, cv::Size dsize, cv::Mat& dst, int interpolation, int borderType, cv::Scalar borderVal)
                                                                                                     ^
modules/cudawarping/test/test_warp_perspective.cpp:70:10: style: The scope of the variable 'inverse' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool inverse;
         ^
modules/cudawarping/test/test_warp_perspective.cpp:190:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudawarping/test/test_warp_perspective.cpp:191:10: style: The scope of the variable 'inverse' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool inverse;
         ^
modules/cudawarping/test/test_warp_perspective.cpp:192:9: style: The scope of the variable 'interpolation' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int interpolation;
        ^
modules/cudawarping/test/test_warp_perspective.cpp:193:9: style: The scope of the variable 'borderType' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int borderType;
        ^
modules/cudawarping/test/test_warp_perspective.cpp:194:10: style: The scope of the variable 'useRoi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useRoi;
         ^
modules/cudawarping/test/test_warp_perspective.cpp:243:9: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int type;
        ^
modules/cudawarping/test/test_warp_perspective.cpp:244:10: style: The scope of the variable 'inverse' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool inverse;
         ^
modules/cudawarping/test/test_warp_perspective.cpp:245:9: style: The scope of the variable 'interpolation' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int interpolation;
        ^
modules/cudawarping/test/test_warp_perspective.cpp:136:107: style: Parameter 'dst' can be declared with const [constParameter]
    void warpPerspectiveGold(const cv::Mat& src, const cv::Mat& M, bool inverse, cv::Size dsize, cv::Mat& dst, int interpolation, int borderType, cv::Scalar borderVal)
                                                                                                          ^
modules/dnn/misc/caffe/opencv-caffe.pb.cc:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [modules/dnn/misc/caffe/opencv-caffe.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS : [modules/dnn/misc/caffe/opencv-caffe.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS=0 : [modules/dnn/misc/caffe/opencv-caffe.pb.h:12] #error This file was generated by a newer version of protoc which is
_MSC_VER : [modules/dnn/misc/caffe/opencv-caffe.pb.h:12] #error This file was generated by a newer version of protoc which is
__clang__ : [modules/dnn/misc/caffe/opencv-caffe.pb.h:12] #error This file was generated by a newer version of protoc which is [noValidConfiguration]

^
modules/dnn/misc/tensorflow/attr_value.pb.cc:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [modules/dnn/misc/tensorflow/attr_value.pb.h:12] #error This file was generated by a newer version of protoc which is
GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER : [modules/dnn/misc/tensorflow/attr_value.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS : [modules/dnn/misc/tensorflow/attr_value.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS=0 : [modules/dnn/misc/tensorflow/attr_value.pb.h:12] #error This file was generated by a newer version of protoc which is
_MSC_VER : [modules/dnn/misc/tensorflow/attr_value.pb.h:12] #error This file was generated by a newer version of protoc which is [noValidConfiguration]

^
modules/dnn/misc/tensorflow/function.pb.cc:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [modules/dnn/misc/tensorflow/function.pb.h:12] #error This file was generated by a newer version of protoc which is
GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER : [modules/dnn/misc/tensorflow/function.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS : [modules/dnn/misc/tensorflow/function.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS=0 : [modules/dnn/misc/tensorflow/function.pb.h:12] #error This file was generated by a newer version of protoc which is
_MSC_VER : [modules/dnn/misc/tensorflow/function.pb.h:12] #error This file was generated by a newer version of protoc which is [noValidConfiguration]

^
modules/dnn/misc/tensorflow/graph.pb.cc:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [modules/dnn/misc/tensorflow/graph.pb.h:12] #error This file was generated by a newer version of protoc which is
GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER : [modules/dnn/misc/tensorflow/graph.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS : [modules/dnn/misc/tensorflow/graph.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS=0 : [modules/dnn/misc/tensorflow/graph.pb.h:12] #error This file was generated by a newer version of protoc which is
_MSC_VER : [modules/dnn/misc/tensorflow/graph.pb.h:12] #error This file was generated by a newer version of protoc which is [noValidConfiguration]

^
modules/dnn/misc/tensorflow/op_def.pb.cc:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [modules/dnn/misc/tensorflow/op_def.pb.h:12] #error This file was generated by a newer version of protoc which is
GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER : [modules/dnn/misc/tensorflow/op_def.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS : [modules/dnn/misc/tensorflow/op_def.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS=0 : [modules/dnn/misc/tensorflow/op_def.pb.h:12] #error This file was generated by a newer version of protoc which is
_MSC_VER : [modules/dnn/misc/tensorflow/op_def.pb.h:12] #error This file was generated by a newer version of protoc which is
__clang__ : [modules/dnn/misc/tensorflow/op_def.pb.h:12] #error This file was generated by a newer version of protoc which is [noValidConfiguration]

^
modules/dnn/misc/tensorflow/tensor.pb.cc:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [modules/dnn/misc/tensorflow/tensor.pb.h:12] #error This file was generated by a newer version of protoc which is
GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER : [modules/dnn/misc/tensorflow/tensor.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS : [modules/dnn/misc/tensorflow/tensor.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS=0 : [modules/dnn/misc/tensorflow/tensor.pb.h:12] #error This file was generated by a newer version of protoc which is
_MSC_VER : [modules/dnn/misc/tensorflow/tensor.pb.h:12] #error This file was generated by a newer version of protoc which is
__clang__ : [modules/dnn/misc/tensorflow/tensor.pb.h:12] #error This file was generated by a newer version of protoc which is [noValidConfiguration]

^
modules/dnn/misc/tensorflow/tensor_shape.pb.cc:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [modules/dnn/misc/tensorflow/tensor_shape.pb.h:12] #error This file was generated by a newer version of protoc which is
GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER : [modules/dnn/misc/tensorflow/tensor_shape.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS : [modules/dnn/misc/tensorflow/tensor_shape.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS=0 : [modules/dnn/misc/tensorflow/tensor_shape.pb.h:12] #error This file was generated by a newer version of protoc which is
_MSC_VER : [modules/dnn/misc/tensorflow/tensor_shape.pb.h:12] #error This file was generated by a newer version of protoc which is [noValidConfiguration]

^
modules/dnn/misc/tensorflow/types.pb.cc:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [modules/dnn/misc/tensorflow/types.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS=0 : [modules/dnn/misc/tensorflow/types.pb.h:12] #error This file was generated by a newer version of protoc which is [noValidConfiguration]

^
modules/dnn/misc/tensorflow/versions.pb.cc:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [modules/dnn/misc/tensorflow/versions.pb.h:12] #error This file was generated by a newer version of protoc which is
GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER : [modules/dnn/misc/tensorflow/versions.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS : [modules/dnn/misc/tensorflow/versions.pb.h:12] #error This file was generated by a newer version of protoc which is
PROTOBUF_INLINE_NOT_IN_HEADERS=0 : [modules/dnn/misc/tensorflow/versions.pb.h:12] #error This file was generated by a newer version of protoc which is
_MSC_VER : [modules/dnn/misc/tensorflow/versions.pb.h:12] #error This file was generated by a newer version of protoc which is
__clang__ : [modules/dnn/misc/tensorflow/versions.pb.h:12] #error This file was generated by a newer version of protoc which is [noValidConfiguration]

^
modules/dnn/perf/opencl/perf_convolution.cpp:40:1: error: syntax error [syntaxError]
OCL_PERF_TEST_P( ConvolutionPerfTest, perf, Combine(
^
modules/dnn/perf/perf_caffe.cpp:71:1: error: syntax error [syntaxError]
PERF_TEST(AlexNet_caffe, CaffePerfTest)
^
modules/dnn/perf/perf_convolution.cpp:23:1: error: syntax error [syntaxError]
PERF_TEST_P( ConvolutionPerfTest, perf, Combine(
^
modules/dnn/perf/perf_net.cpp:169:36: error: syntax error [syntaxError]
INSTANTIATE_TEST_CASE_P(/*nothing*/, DNNTestNetwork,
                                   ^
modules/dnn/src/darknet/darknet_importer.cpp:159:93: performance: Parameter 'nn' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
    void addInput(const std::string &name, int layerId, int inNum, Net &dstNet, std::string nn)
                                                                                            ^
modules/dnn/src/darknet/darknet_io.cpp:100:17: style: Class 'setLayersParams' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
                setLayersParams(NetParameter *_net, std::string _first_layer = "data") :
                ^
modules/dnn/src/darknet/darknet_io.cpp:159:49: style: Local variable 'lp' shadows outer variable [shadowVariable]
                        darknet::LayerParameter lp;
                                                ^
modules/dnn/src/darknet/darknet_io.cpp:134:45: note: Shadowed declaration
                    darknet::LayerParameter lp;
                                            ^
modules/dnn/src/darknet/darknet_io.cpp:159:49: note: Shadow variable
                        darknet::LayerParameter lp;
                                                ^
modules/dnn/src/darknet/darknet_io.cpp:160:37: style: Local variable 'layer_name' shadows outer variable [shadowVariable]
                        std::string layer_name = cv::format("bn_%d", layer_id);
                                    ^
modules/dnn/src/darknet/darknet_io.cpp:135:33: note: Shadowed declaration
                    std::string layer_name = cv::format("conv_%d", layer_id);
                                ^
modules/dnn/src/darknet/darknet_io.cpp:160:37: note: Shadow variable
                        std::string layer_name = cv::format("bn_%d", layer_id);
                                    ^
modules/dnn/src/darknet/darknet_io.cpp:176:49: style: Local variable 'lp' shadows outer variable [shadowVariable]
                        darknet::LayerParameter lp;
                                                ^
modules/dnn/src/darknet/darknet_io.cpp:134:45: note: Shadowed declaration
                    darknet::LayerParameter lp;
                                            ^
modules/dnn/src/darknet/darknet_io.cpp:176:49: note: Shadow variable
                        darknet::LayerParameter lp;
                                                ^
modules/dnn/src/darknet/darknet_io.cpp:177:37: style: Local variable 'layer_name' shadows outer variable [shadowVariable]
                        std::string layer_name = cv::format("relu_%d", layer_id);
                                    ^
modules/dnn/src/darknet/darknet_io.cpp:135:33: note: Shadowed declaration
                    std::string layer_name = cv::format("conv_%d", layer_id);
                                ^
modules/dnn/src/darknet/darknet_io.cpp:177:37: note: Shadow variable
                        std::string layer_name = cv::format("relu_%d", layer_id);
                                    ^
modules/dnn/src/darknet/darknet_io.cpp:81:0: performance: Parameter 'param_name' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
            template<typename T>
^
modules/dnn/src/darknet/darknet_io.cpp:100:65: performance: Parameter '_first_layer' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
                setLayersParams(NetParameter *_net, std::string _first_layer = "data") :
                                                                ^
modules/dnn/src/darknet/darknet_io.cpp:104:64: performance: Parameter 'blobs' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
                void setLayerBlobs(int i, std::vector<cv::Mat> blobs)
                                                               ^
modules/dnn/src/darknet/darknet_io.cpp:404:44: style: Variable 'vec' is assigned a value that is never used. [unreadVariable]
                    std::vector<float> vec = getNumbers<float>(anchors);
                                           ^
modules/dnn/src/dnn.cpp:296:1: style: The struct 'BlobManager' does not have a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
struct BlobManager
^
modules/dnn/src/dnn.cpp:645:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'netInputLayer' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        netInputLayer = Ptr<DataLayer>(new DataLayer());
        ^
modules/dnn/src/halide_scheduler.hpp:21:5: style: Class 'HalideScheduler' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    HalideScheduler(const std::string& configFile);
    ^
modules/dnn/src/dnn.cpp:2503:22: style: Condition 'instance==NULL' is always true [knownConditionTrueFalse]
        if (instance == NULL)
                     ^
modules/dnn/src/dnn.cpp:2500:18: note: Assuming that condition 'instance==NULL' is not redundant
    if (instance == NULL)
                 ^
modules/dnn/src/dnn.cpp:2503:22: note: Condition 'instance==NULL' is always true
        if (instance == NULL)
                     ^
modules/dnn/src/dnn.cpp:1205:25: style: The scope of the variable 'currLayer' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            Ptr<Layer>& currLayer = ld.layerInstance;
                        ^
modules/dnn/src/dnn.cpp:1586:32: style: The scope of the variable 'inputLayerIds' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        std::vector<LayerPin>& inputLayerIds = layers[id].inputBlobsId;
                               ^
modules/dnn/src/dnn.cpp:112:20: style: Local variable 'crop' shadows outer argument [shadowArgument]
              Rect crop(Point(0.5 * (images[i].cols - size.width),
                   ^
modules/dnn/src/dnn.cpp:96:59: note: Shadowed declaration
                   const Scalar& mean_, bool swapRB, bool crop)
                                                          ^
modules/dnn/src/dnn.cpp:112:20: note: Shadow variable
              Rect crop(Point(0.5 * (images[i].cols - size.width),
                   ^
modules/dnn/src/dnn.cpp:166:16: style: Local variable 'image' shadows outer variable [shadowVariable]
           Mat image = images[i];
               ^
modules/dnn/src/dnn.cpp:136:15: note: Shadowed declaration
    Mat blob, image;
              ^
modules/dnn/src/dnn.cpp:166:16: note: Shadow variable
           Mat image = images[i];
               ^
modules/dnn/src/dnn.cpp:1565:24: style: Local variable 'ld' shadows outer argument [shadowArgument]
            LayerData &ld = it->second;
                       ^
modules/dnn/src/dnn.cpp:1546:36: note: Shadowed declaration
    void forwardToLayer(LayerData &ld, bool clearFlags = true)
                                   ^
modules/dnn/src/dnn.cpp:1565:24: note: Shadow variable
            LayerData &ld = it->second;
                       ^
modules/dnn/src/dnn.cpp:1873:18: style: Local variable 'i' shadows outer variable [shadowVariable]
        for (int i = 0; i < lp.size(); i++)
                 ^
modules/dnn/src/dnn.cpp:1870:14: note: Shadowed declaration
    for (int i = 0; i < outBlobNames.size(); i++)
             ^
modules/dnn/src/dnn.cpp:1873:18: note: Shadow variable
        for (int i = 0; i < lp.size(); i++)
                 ^
modules/dnn/src/dnn.cpp:2147:39: performance: Searching before insertion is not necessary. [stlFindInsert]
            layers[it->second.type] = 0;
                                      ^
modules/dnn/src/dnn.cpp:692:44: style: Variable 'baseBuffer' is assigned a value that is never used. [unreadVariable]
            Ptr<BackendWrapper> baseBuffer = backendWrappers[data];
                                           ^
modules/dnn/src/dnn.cpp:534:60: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
        for(it = idxSizes.rbegin(); it != idxSizes.rend(); it++)
                                                           ^
modules/dnn/src/dnn.cpp:763:55: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
        for (it = layers.begin(); it != layers.end(); it++)
                                                      ^
modules/dnn/src/dnn.cpp:972:55: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
        for (it = layers.begin(); it != layers.end(); it++)
                                                      ^
modules/dnn/src/dnn.cpp:1003:36: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
        for (; it != layers.end(); it++)
                                   ^
modules/dnn/src/dnn.cpp:1088:92: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
        for (set<int>::iterator i = ld.inputLayersId.begin(); i != ld.inputLayersId.end(); i++)
                                                                                           ^
modules/dnn/src/dnn.cpp:1182:55: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
        for (it = layers.begin(); it != layers.end(); it++)
                                                      ^
modules/dnn/src/dnn.cpp:1454:55: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
        for (it = layers.begin(); it != layers.end(); it++)
                                                      ^
modules/dnn/src/dnn.cpp:1485:55: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
        for (it = layers.begin(); it != layers.end(); it++)
                                                      ^
modules/dnn/src/dnn.cpp:1553:59: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
            for (it = layers.begin(); it != layers.end(); it++)
                                                          ^
modules/dnn/src/dnn.cpp:1619:34: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
             it != layers.end(); it++)
                                 ^
modules/dnn/src/dnn.cpp:2013:63: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
    for (it = impl->layers.begin(); it != impl->layers.end(); it++)
                                                              ^
modules/dnn/src/dnn.cpp:2032:63: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
    for (it = impl->layers.begin(); it != impl->layers.end(); it++)
                                                              ^
modules/dnn/src/dnn.cpp:2057:34: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
        it != inOutShapes.end(); it++)
                                 ^
modules/dnn/src/dnn.cpp:2144:36: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
         it != impl->layers.end(); it++)
                                   ^
modules/dnn/src/dnn.cpp:2152:30: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
         it != layers.end(); it++)
                             ^
modules/dnn/src/dnn.cpp:2162:36: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
         it != impl->layers.end(); it++)
                                   ^
modules/dnn/src/op_halide.hpp:41:9: style: Class 'HalideBackendNode' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        HalideBackendNode(const Halide::Func& func);
        ^
modules/dnn/src/op_halide.hpp:43:9: style: Class 'HalideBackendNode' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        HalideBackendNode(const std::vector<Halide::Func>& funcs);
        ^
modules/dnn/src/dnn.cpp:752:34: style: Consider using std::fill or std::generate algorithm instead of a raw loop. [useStlAlgorithm]
        for (auto& t: threads) t = std::thread(fn);
                                 ^
modules/dnn/src/layers/batch_norm_layer.cpp:26:5: style: Class 'BatchNormLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    BatchNormLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/blank_layer.cpp:51:5: style: Class 'BlankLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    BlankLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/concat_layer.cpp:56:5: style: Class 'ConcatLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ConcatLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/concat_layer.cpp:191:13: style: The scope of the variable 'bottom_concat_axis' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int bottom_concat_axis;
            ^
modules/dnn/src/layers/convolution_layer.cpp:349:9: warning: Member variable 'ParallelConv::outShape' is not initialized in the constructor. [uninitMemberVar]
        ParallelConv()
        ^
modules/dnn/src/layers/convolution_layer.cpp:180:14: style: The function 'computeColRowShape' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    MatShape computeColRowShape(const MatShape &inpShape, const MatShape &outShape) const
             ^
modules/dnn/src/layers/convolution_layer.cpp:96:22: note: Virtual function in base class
    virtual MatShape computeColRowShape(const MatShape &inpShape, const MatShape &outShape) const = 0;
                     ^
modules/dnn/src/layers/convolution_layer.cpp:180:14: note: Function in derived class
    MatShape computeColRowShape(const MatShape &inpShape, const MatShape &outShape) const
             ^
modules/dnn/src/layers/convolution_layer.cpp:1038:14: style: The function 'computeColRowShape' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    MatShape computeColRowShape(const MatShape &inpShape, const MatShape &outShape) const
             ^
modules/dnn/src/layers/convolution_layer.cpp:96:22: note: Virtual function in base class
    virtual MatShape computeColRowShape(const MatShape &inpShape, const MatShape &outShape) const = 0;
                     ^
modules/dnn/src/layers/convolution_layer.cpp:1038:14: note: Function in derived class
    MatShape computeColRowShape(const MatShape &inpShape, const MatShape &outShape) const
             ^
modules/dnn/src/layers/convolution_layer.cpp:910:13: style: The scope of the variable 'k' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int k, outCn = blobs[0].size[0];
            ^
modules/dnn/src/layers/convolution_layer.cpp:577:34: style: Local variable 'i' shadows outer variable [shadowVariable]
                        for( int i = 0; i < outCn; i += 2 )
                                 ^
modules/dnn/src/layers/convolution_layer.cpp:416:17: note: Shadowed declaration
            int i, j, k;
                ^
modules/dnn/src/layers/convolution_layer.cpp:577:34: note: Shadow variable
                        for( int i = 0; i < outCn; i += 2 )
                                 ^
modules/dnn/src/layers/convolution_layer.cpp:584:35: style: Local variable 'r0' shadows outer argument [shadowArgument]
                            float r0 = 1.f, r1 = 1.f;
                                  ^
modules/dnn/src/layers/convolution_layer.cpp:404:47: note: Shadowed declaration
        virtual void operator ()(const Range &r0) const
                                              ^
modules/dnn/src/layers/convolution_layer.cpp:584:35: note: Shadow variable
                            float r0 = 1.f, r1 = 1.f;
                                  ^
modules/dnn/src/layers/convolution_layer.cpp:599:33: style: Local variable 'j' shadows outer variable [shadowVariable]
                            int j = 0;
                                ^
modules/dnn/src/layers/convolution_layer.cpp:416:20: note: Shadowed declaration
            int i, j, k;
                   ^
modules/dnn/src/layers/convolution_layer.cpp:599:33: note: Shadow variable
                            int j = 0;
                                ^
modules/dnn/src/layers/convolution_layer.cpp:669:43: style: Local variable 'r0' shadows outer argument [shadowArgument]
                                    float r0 = rptr[k];
                                          ^
modules/dnn/src/layers/convolution_layer.cpp:404:47: note: Shadowed declaration
        virtual void operator ()(const Range &r0) const
                                              ^
modules/dnn/src/layers/convolution_layer.cpp:669:43: note: Shadow variable
                                    float r0 = rptr[k];
                                          ^
modules/dnn/src/layers/convolution_layer.cpp:1248:23: style: Local variable 'nstripes' shadows outer variable [shadowVariable]
            const int nstripes = getNumThreads();
                      ^
modules/dnn/src/layers/convolution_layer.cpp:1230:13: note: Shadowed declaration
        int nstripes;
            ^
modules/dnn/src/layers/convolution_layer.cpp:1248:23: note: Shadow variable
            const int nstripes = getNumThreads();
                      ^
modules/dnn/src/layers/convolution_layer.cpp:437:26: style: Variable 'nstripes' is assigned a value that is never used. [unreadVariable]
                nstripes *= samplesPerStripe;
                         ^
modules/dnn/src/layers/convolution_layer.cpp:626:49: style: Local variable 'r0' shadows outer argument [shadowArgument]
                                    v_float32x4 r0 = v_load_aligned(rptr), r1 = v_load_aligned(rptr + vsz_a),
                                                ^
modules/dnn/src/layers/convolution_layer.cpp:404:47: note: Shadowed declaration
        virtual void operator ()(const Range &r0) const
                                              ^
modules/dnn/src/layers/convolution_layer.cpp:626:49: note: Shadow variable
                                    v_float32x4 r0 = v_load_aligned(rptr), r1 = v_load_aligned(rptr + vsz_a),
                                                ^
modules/dnn/src/layers/convolution_layer.cpp:626:76: style: Local variable 'r1' shadows outer variable [shadowVariable]
                                    v_float32x4 r0 = v_load_aligned(rptr), r1 = v_load_aligned(rptr + vsz_a),
                                                                           ^
modules/dnn/src/layers/convolution_layer.cpp:584:45: note: Shadowed declaration
                            float r0 = 1.f, r1 = 1.f;
                                            ^
modules/dnn/src/layers/convolution_layer.cpp:626:76: note: Shadow variable
                                    v_float32x4 r0 = v_load_aligned(rptr), r1 = v_load_aligned(rptr + vsz_a),
                                                                           ^
modules/dnn/src/layers/convolution_layer.cpp:1105:17: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int m, n, k;
                ^
modules/dnn/src/layers/convolution_layer.cpp:1105:20: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int m, n, k;
                   ^
modules/dnn/src/layers/convolution_layer.cpp:1105:23: style: The scope of the variable 'k' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int m, n, k;
                      ^
modules/dnn/src/layers/convolution_layer.cpp:175:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'activType' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        activType = OCL4DNN_CONV_FUSED_ACTIV_NONE;
        ^
modules/dnn/src/layers/convolution_layer.cpp:720:13: style: The scope of the variable 'k' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int k, outCn = umat_blobs[0].size[0];
            ^
modules/dnn/src/layers/crop_layer.cpp:54:5: style: Class 'CropLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CropLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/crop_layer.cpp:144:38: style: Parameter 'inputs' can be declared with const [constParameter]
    void forward(std::vector<Mat *> &inputs, std::vector<Mat> &outputs, std::vector<Mat> &internals)
                                     ^
modules/dnn/src/layers/crop_layer.cpp:149:14: style: Variable 'input' can be declared with const [constVariable]
        Mat &input = *inputs[0];
             ^
modules/dnn/src/layers/detection_output_layer.cpp:169:5: style: Class 'DetectionOutputLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    DetectionOutputLayerImpl(const LayerParams &params)
    ^
modules/dnn/src/layers/elementwise_layers.cpp:462:44: style: Expression 'exp(x) - 1' can be replaced by 'expm1(x)' to avoid loss of precision. [unpreciseMathCall]
                dstptr[i] = x >= 0.f ? x : exp(x) - 1;
                                           ^
modules/dnn/src/layers/elementwise_layers.cpp:532:29: style: Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]
                dstptr[i] = log(1.f + exp(-abs(x)));
                            ^
modules/dnn/src/layers/elementwise_layers.cpp:110:68: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'func' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    ElementWiseLayer(const Func &f=Func()) : run_parallel(false) { func = f; }
                                                                   ^
modules/dnn/src/layers/elementwise_layers.cpp:479:56: style: Expression 'exp(x) - 1' can be replaced by 'expm1(x)' to avoid loss of precision. [unpreciseMathCall]
        top(x, y, c, n) = select(input >= 0.0f, input, exp(input) - 1);
                                                       ^
modules/dnn/src/layers/elementwise_layers.cpp:549:27: style: Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]
        top(x, y, c, n) = log(1.0f + exp(-abs(input)));
                          ^
modules/dnn/src/layers/elementwise_layers.cpp:369:64: style: Parameter 'top' can be declared with const [constParameter]
    void attachHalide(const Halide::Expr& input, Halide::Func& top)
                                                               ^
modules/dnn/src/layers/elementwise_layers.cpp:404:64: style: Parameter 'top' can be declared with const [constParameter]
    void attachHalide(const Halide::Expr& input, Halide::Func& top)
                                                               ^
modules/dnn/src/layers/elementwise_layers.cpp:439:64: style: Parameter 'top' can be declared with const [constParameter]
    void attachHalide(const Halide::Expr& input, Halide::Func& top)
                                                               ^
modules/dnn/src/layers/elementwise_layers.cpp:476:64: style: Parameter 'top' can be declared with const [constParameter]
    void attachHalide(const Halide::Expr& input, Halide::Func& top)
                                                               ^
modules/dnn/src/layers/elementwise_layers.cpp:511:64: style: Parameter 'top' can be declared with const [constParameter]
    void attachHalide(const Halide::Expr& input, Halide::Func& top)
                                                               ^
modules/dnn/src/layers/elementwise_layers.cpp:546:64: style: Parameter 'top' can be declared with const [constParameter]
    void attachHalide(const Halide::Expr& input, Halide::Func& top)
                                                               ^
modules/dnn/src/layers/elementwise_layers.cpp:603:64: style: Parameter 'top' can be declared with const [constParameter]
    void attachHalide(const Halide::Expr& input, Halide::Func& top)
                                                               ^
modules/dnn/src/layers/elementwise_layers.cpp:678:64: style: Parameter 'top' can be declared with const [constParameter]
    void attachHalide(const Halide::Expr& input, Halide::Func& top)
                                                               ^
modules/dnn/src/layers/eltwise_layer.cpp:63:5: style: Class 'EltwiseLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    EltwiseLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/flatten_layer.cpp:57:5: style: Class 'FlattenLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    FlattenLayerImpl(const LayerParams &params)
    ^
modules/dnn/src/layers/fully_connected_layer.cpp:68:5: style: Class 'FullyConnectedLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    FullyConnectedLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/fully_connected_layer.cpp:382:35: style: Local variable 'bias' shadows outer variable [shadowVariable]
            Halide::Buffer<float> bias = wrapToHalideBuffer(blobs[1], {outC});
                                  ^
modules/dnn/src/layers/fully_connected_layer.cpp:407:10: note: Shadowed declaration
    bool bias;
         ^
modules/dnn/src/layers/fully_connected_layer.cpp:382:35: note: Shadow variable
            Halide::Buffer<float> bias = wrapToHalideBuffer(blobs[1], {outC});
                                  ^
modules/dnn/src/layers/lrn_layer.cpp:64:5: style: Class 'LRNLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    LRNLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/lrn_layer.cpp:274:36: style: Parameter 'srcBlob' can be declared with const [constParameter]
    void spatialNormalization(Mat &srcBlob, Mat &dstBlob)
                                   ^
modules/dnn/src/layers/lrn_layer.cpp:274:50: style: Parameter 'dstBlob' can be declared with const [constParameter]
    void spatialNormalization(Mat &srcBlob, Mat &dstBlob)
                                                 ^
modules/dnn/src/layers/max_unpooling_layer.cpp:27:5: style: Class 'MaxUnpoolLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    MaxUnpoolLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/mvn_layer.cpp:55:5: style: Class 'MVNLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    MVNLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/normalize_bbox_layer.cpp:51:5: style: Class 'NormalizeBBoxLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    NormalizeBBoxLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/padding_layer.cpp:25:5: style: Class 'PaddingLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    PaddingLayerImpl(const LayerParams &params)
    ^
modules/dnn/src/layers/permute_layer.cpp:86:5: style: Class 'PermuteLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    PermuteLayerImpl(const LayerParams &params)
    ^
modules/dnn/src/layers/pooling_layer.cpp:68:5: style: Class 'PoolingLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    PoolingLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/pooling_layer.cpp:618:26: style: Parameter 'src' can be declared with const [constParameter]
    void maxPooling(Mat &src, Mat &dst, Mat &mask)
                         ^
modules/dnn/src/layers/pooling_layer.cpp:625:26: style: Parameter 'src' can be declared with const [constParameter]
    void avePooling(Mat &src, Mat &dst)
                         ^
modules/dnn/src/layers/prior_box_layer.cpp:180:5: style: Class 'PriorBoxLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    PriorBoxLayerImpl(const LayerParams &params)
    ^
modules/dnn/src/layers/prior_box_layer.cpp:352:25: style: Local variable 'kernel' shadows outer variable [shadowVariable]
            ocl::Kernel kernel("set_variance", ocl::dnn::prior_box_oclsrc);
                        ^
modules/dnn/src/layers/prior_box_layer.cpp:317:21: note: Shadowed declaration
        ocl::Kernel kernel("prior_box", ocl::dnn::prior_box_oclsrc);
                    ^
modules/dnn/src/layers/prior_box_layer.cpp:352:25: note: Shadow variable
            ocl::Kernel kernel("set_variance", ocl::dnn::prior_box_oclsrc);
                        ^
modules/dnn/src/layers/prior_box_layer.cpp:354:20: style: Local variable 'nthreads' shadows outer variable [shadowVariable]
            size_t nthreads = _layerHeight * _layerWidth * _numPriors;
                   ^
modules/dnn/src/layers/prior_box_layer.cpp:315:16: note: Shadowed declaration
        size_t nthreads = _layerHeight * _layerWidth;
               ^
modules/dnn/src/layers/prior_box_layer.cpp:354:20: note: Shadow variable
            size_t nthreads = _layerHeight * _layerWidth * _numPriors;
                   ^
modules/dnn/src/layers/proposal_layer.cpp:15:5: style: Class 'ProposalLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ProposalLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/recurrent_layers.cpp:98:5: style: Class 'LSTMLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    LSTMLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/recurrent_layers.cpp:379:5: style: Class 'RNNLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    RNNLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/recurrent_layers.cpp:226:14: style: Variable 'Wh' can be declared with const [constVariable]
        Mat &Wh = blobs[0], &Wx = blobs[1];
             ^
modules/dnn/src/layers/recurrent_layers.cpp:263:88: style: Parameter 'internals' can be declared with const [constParameter]
    void forward(std::vector<Mat*> &input, std::vector<Mat> &output, std::vector<Mat> &internals)
                                                                                       ^
modules/dnn/src/layers/recurrent_layers.cpp:484:88: style: Parameter 'internals' can be declared with const [constParameter]
    void forward(std::vector<Mat*> &input, std::vector<Mat> &output, std::vector<Mat> &internals)
                                                                                       ^
modules/dnn/src/layers/region_layer.cpp:61:5: style: Class 'RegionLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    RegionLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/region_layer.cpp:318:9: style: Struct 'nms_comparator' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        nms_comparator(int _k) : k(_k) {}
        ^
modules/dnn/src/layers/region_layer.cpp:306:23: performance: Parameter 'a' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
    float box_iou(box a, box b)
                      ^
modules/dnn/src/layers/region_layer.cpp:306:30: performance: Parameter 'b' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
    float box_iou(box a, box b)
                             ^
modules/dnn/src/layers/reorg_layer.cpp:59:5: style: Class 'ReorgLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ReorgLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/reorg_layer.cpp:159:30: style: Local variable 'i' shadows outer variable [shadowVariable]
                    for (int i = 0; i < width; ++i) {
                             ^
modules/dnn/src/layers/reorg_layer.cpp:146:21: note: Shadowed declaration
        for (size_t i = 0; i < inputs.size(); i++)
                    ^
modules/dnn/src/layers/reorg_layer.cpp:159:30: note: Shadow variable
                    for (int i = 0; i < width; ++i) {
                             ^
modules/dnn/src/layers/reshape_layer.cpp:149:5: style: Class 'ReshapeLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ReshapeLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/resize_nearest_neighbor_layer.cpp:16:5: style: Class 'ResizeNearestNeighborLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ResizeNearestNeighborLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/scale_layer.cpp:25:5: style: Class 'ScaleLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ScaleLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/shift_layer.cpp:23:5: style: Class 'ShiftLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ShiftLayerImpl(const LayerParams &params)
    ^
modules/dnn/src/layers/slice_layer.cpp:55:5: style: Class 'SliceLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    SliceLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/slice_layer.cpp:182:37: style: Parameter 'inputs' can be declared with const [constParameter]
    void forward(std::vector<Mat*> &inputs, std::vector<Mat> &outputs, std::vector<Mat> &internals)
                                    ^
modules/dnn/src/layers/softmax_layer.cpp:63:5: style: Class 'SoftMaxLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    SoftMaxLayerImpl(const LayerParams& params)
    ^
modules/dnn/src/layers/softmax_layer.cpp:197:37: style: Parameter 'inputs' can be declared with const [constParameter]
    void forward(std::vector<Mat*> &inputs, std::vector<Mat> &outputs, std::vector<Mat> &internals)
                                    ^
modules/dnn/src/layers/split_layer.cpp:54:5: style: Class 'SplitLayerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    SplitLayerImpl(const LayerParams &params)
    ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:212:13: style: Condition 'is_image_b' is always false [knownConditionTrueFalse]
        if (is_image_b || (K % use_buffer_indicator != 0))
            ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:160:9: note: Assuming that condition 'is_image_b' is not redundant
    if (is_image_b)
        ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:212:13: note: Condition 'is_image_b' is always false
        if (is_image_b || (K % use_buffer_indicator != 0))
            ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:403:19: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [knownConditionTrueFalse]
    if (gemm_type == GEMM_TYPE_FAST_IMAGE_32_1 ||
                  ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:401:29: note: 'gemm_type' is assigned value 'GEMM_TYPE_FAST_IMAGE_32_1' here.
    gemm_type_t gemm_type = GEMM_TYPE_FAST_IMAGE_32_1;
                            ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:403:19: note: The expression 'gemm_type == GEMM_TYPE_FAST_IMAGE_32_1' is always true because 'gemm_type' and 'GEMM_TYPE_FAST_IMAGE_32_1' represent the same value.
    if (gemm_type == GEMM_TYPE_FAST_IMAGE_32_1 ||
                  ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:475:20: style: Local variable 'localsize' shadows outer variable [shadowVariable]
            size_t localsize[] = { 128 };
                   ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:454:16: note: Shadowed declaration
        size_t localsize[] = { 128 };
               ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:475:20: note: Shadow variable
            size_t localsize[] = { 128 };
                   ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:476:20: style: Local variable 'globalsize' shadows outer variable [shadowVariable]
            size_t globalsize[] = { row_size % 4 * localsize[0] };
                   ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:455:16: note: Shadowed declaration
        size_t globalsize[] = { row_size / 4 * localsize[0] };
               ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:476:20: note: Shadow variable
            size_t globalsize[] = { row_size % 4 * localsize[0] };
                   ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:479:18: style: Local variable 'argId' shadows outer variable [shadowVariable]
            uint argId = 0;
                 ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:457:14: note: Shadowed declaration
        uint argId = 0;
             ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:479:18: note: Shadow variable
            uint argId = 0;
                 ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:184:22: style: Variable 'blockC_width' is assigned a value that is never used. [unreadVariable]
    int blockC_width = blocksize;
                     ^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:185:23: style: Variable 'blockC_height' is assigned a value that is never used. [unreadVariable]
    int blockC_height = blocksize;
                      ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1571:13: style: The scope of the variable 'failures' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t failures = 0;
            ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1712:17: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int32_t x, y, z, type, lx, ly, lz;
                ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1712:20: style: The scope of the variable 'y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int32_t x, y, z, type, lx, ly, lz;
                   ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1712:23: style: The scope of the variable 'z' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int32_t x, y, z, type, lx, ly, lz;
                      ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1712:26: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int32_t x, y, z, type, lx, ly, lz;
                         ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1712:32: style: The scope of the variable 'lx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int32_t x, y, z, type, lx, ly, lz;
                               ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1712:36: style: The scope of the variable 'ly' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int32_t x, y, z, type, lx, ly, lz;
                                   ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1712:40: style: The scope of the variable 'lz' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int32_t x, y, z, type, lx, ly, lz;
                                       ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1713:14: style: The scope of the variable 'swizzle' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        bool swizzle, nullLocal;
             ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1713:23: style: The scope of the variable 'nullLocal' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        bool swizzle, nullLocal;
                      ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1795:13: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t x, y, z, type, lx, ly, lz;
            ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1795:16: style: The scope of the variable 'y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t x, y, z, type, lx, ly, lz;
               ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1795:19: style: The scope of the variable 'z' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t x, y, z, type, lx, ly, lz;
                  ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1795:22: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t x, y, z, type, lx, ly, lz;
                     ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1795:28: style: The scope of the variable 'lx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t x, y, z, type, lx, ly, lz;
                           ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1795:32: style: The scope of the variable 'ly' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t x, y, z, type, lx, ly, lz;
                               ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1795:36: style: The scope of the variable 'lz' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int32_t x, y, z, type, lx, ly, lz;
                                   ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1796:10: style: The scope of the variable 'swizzle' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool swizzle, nullLocal;
         ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1796:19: style: The scope of the variable 'nullLocal' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool swizzle, nullLocal;
                  ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:1325:24: warning: Conversion of string literal "Internal error" to bool always evaluates to true. [incorrectStringBooleanError]
        CV_Assert(0 && "Internal error");
                       ^
modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp:599:22: style: Variable 'queue' is assigned a value that is never used. [unreadVariable]
    ocl::Queue queue = ocl::Queue::getDefault();
                     ^
modules/dnn/src/op_halide.cpp:99:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'buffer' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    buffer = wrapToHalideBuffer(m);
    ^
modules/dnn/src/op_halide.cpp:208:55: style: Parameter 'outputs' can be declared with const [constParameter]
void forwardHalide(std::vector<Ptr<BackendWrapper> > &outputs,
                                                      ^
modules/dnn/src/op_halide.cpp:67:13: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
        vec.push_back(halideBuffer(ptr));
            ^
modules/dnn/src/opencl/activations.cl:72:46: style: Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]
    out[index] = in[index] > 0 ? in[index] + log(1.0f + exp(-in[index])) : log(1.0f + exp(in[index]));
                                             ^
modules/dnn/src/opencl/conv_layer_spatial.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/dnn/src/opencl/conv_layer_spatial.cl:459:9: style: The scope of the variable 'interleaved_y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int interleaved_y;
        ^
modules/dnn/src/opencl/conv_layer_spatial.cl:460:9: style: The scope of the variable 'kernel_y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int kernel_y;
        ^
modules/dnn/src/opencl/conv_layer_spatial.cl:461:9: style: The scope of the variable 'kernel_idx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int kernel_idx;
        ^
modules/dnn/src/opencl/conv_layer_spatial.cl:455:23: style: Variable 'group_y' is assigned a value that is never used. [unreadVariable]
    const int group_y = get_group_id(1);
                      ^
modules/dnn/src/opencl/conv_layer_spatial.cl:586:102: style: Variable 'kernel_idx' is assigned a value that is never used. [unreadVariable]
                    DOT_PRODUCT_8( blockC30, pblockA00[kernel_y], pBlockB00[kernel_idx] ); kernel_idx++;
                                                                                                     ^
modules/dnn/src/opencl/conv_layer_spatial.cl:1343:23: style: Variable 'group_y' is assigned a value that is never used. [unreadVariable]
    const int group_y = get_group_id(1);
                      ^
modules/dnn/src/opencl/conv_layer_spatial.cl:1473:99: style: Variable 'kernel_idx' is assigned a value that is never used. [unreadVariable]
                DOT_PRODUCT_16( blockC10, pblockA00[kernel_y], pBlockB00[kernel_idx] ); kernel_idx++;
                                                                                                  ^
modules/dnn/src/opencl/conv_layer_spatial.cl:826:9: style: The scope of the variable 'interleaved_y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int interleaved_y;
        ^
modules/dnn/src/opencl/conv_layer_spatial.cl:827:9: style: The scope of the variable 'kernel_y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int kernel_y;
        ^
modules/dnn/src/opencl/conv_layer_spatial.cl:828:9: style: The scope of the variable 'kernel_idx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int kernel_idx;
        ^
modules/dnn/src/opencl/conv_layer_spatial.cl:822:23: style: Variable 'group_y' is assigned a value that is never used. [unreadVariable]
    const int group_y = get_group_id(1);
                      ^
modules/dnn/src/opencl/conv_layer_spatial.cl:983:102: style: Variable 'kernel_idx' is assigned a value that is never used. [unreadVariable]
                    DOT_PRODUCT_8( blockC31, pblockA01[kernel_y], pBlockB00[kernel_idx] ); kernel_idx++;
                                                                                                     ^
modules/dnn/src/opencl/conv_layer_spatial.cl:253:0: error: failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter [preprocessorErrorDirective]
#if INPUT_PAD_W != 0 || INPUT_PAD_H != 0
^
modules/dnn/src/opencl/conv_layer_spatial.cl:394:31: style: struct member 'float1::s0' is never used. [unusedStructMember]
typedef struct float1 { float s0; } float1;
                              ^
modules/dnn/src/opencl/conv_layer_spatial.cl:395:31: style: struct member 'float5::s0' is never used. [unusedStructMember]
typedef struct float5 { float s0; float s1; float s2; float s3; float s4; } float5;
                              ^
modules/dnn/src/opencl/conv_layer_spatial.cl:395:41: style: struct member 'float5::s1' is never used. [unusedStructMember]
typedef struct float5 { float s0; float s1; float s2; float s3; float s4; } float5;
                                        ^
modules/dnn/src/opencl/conv_layer_spatial.cl:395:51: style: struct member 'float5::s2' is never used. [unusedStructMember]
typedef struct float5 { float s0; float s1; float s2; float s3; float s4; } float5;
                                                  ^
modules/dnn/src/opencl/conv_layer_spatial.cl:395:61: style: struct member 'float5::s3' is never used. [unusedStructMember]
typedef struct float5 { float s0; float s1; float s2; float s3; float s4; } float5;
                                                            ^
modules/dnn/src/opencl/conv_layer_spatial.cl:395:71: style: struct member 'float5::s4' is never used. [unusedStructMember]
typedef struct float5 { float s0; float s1; float s2; float s3; float s4; } float5;
                                                                      ^
modules/dnn/src/opencl/conv_layer_spatial.cl:396:31: style: struct member 'float6::s0' is never used. [unusedStructMember]
typedef struct float6 { float s0; float s1; float s2; float s3; float s4; float s5; } float6;
                              ^
modules/dnn/src/opencl/conv_layer_spatial.cl:396:41: style: struct member 'float6::s1' is never used. [unusedStructMember]
typedef struct float6 { float s0; float s1; float s2; float s3; float s4; float s5; } float6;
                                        ^
modules/dnn/src/opencl/conv_layer_spatial.cl:396:51: style: struct member 'float6::s2' is never used. [unusedStructMember]
typedef struct float6 { float s0; float s1; float s2; float s3; float s4; float s5; } float6;
                                                  ^
modules/dnn/src/opencl/conv_layer_spatial.cl:396:61: style: struct member 'float6::s3' is never used. [unusedStructMember]
typedef struct float6 { float s0; float s1; float s2; float s3; float s4; float s5; } float6;
                                                            ^
modules/dnn/src/opencl/conv_layer_spatial.cl:396:71: style: struct member 'float6::s4' is never used. [unusedStructMember]
typedef struct float6 { float s0; float s1; float s2; float s3; float s4; float s5; } float6;
                                                                      ^
modules/dnn/src/opencl/conv_layer_spatial.cl:396:81: style: struct member 'float6::s5' is never used. [unusedStructMember]
typedef struct float6 { float s0; float s1; float s2; float s3; float s4; float s5; } float6;
                                                                                ^
modules/dnn/src/opencl/conv_layer_spatial.cl:397:31: style: struct member 'float7::s0' is never used. [unusedStructMember]
typedef struct float7 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; } float7;
                              ^
modules/dnn/src/opencl/conv_layer_spatial.cl:397:41: style: struct member 'float7::s1' is never used. [unusedStructMember]
typedef struct float7 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; } float7;
                                        ^
modules/dnn/src/opencl/conv_layer_spatial.cl:397:51: style: struct member 'float7::s2' is never used. [unusedStructMember]
typedef struct float7 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; } float7;
                                                  ^
modules/dnn/src/opencl/conv_layer_spatial.cl:397:61: style: struct member 'float7::s3' is never used. [unusedStructMember]
typedef struct float7 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; } float7;
                                                            ^
modules/dnn/src/opencl/conv_layer_spatial.cl:397:71: style: struct member 'float7::s4' is never used. [unusedStructMember]
typedef struct float7 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; } float7;
                                                                      ^
modules/dnn/src/opencl/conv_layer_spatial.cl:397:81: style: struct member 'float7::s5' is never used. [unusedStructMember]
typedef struct float7 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; } float7;
                                                                                ^
modules/dnn/src/opencl/conv_layer_spatial.cl:397:91: style: struct member 'float7::s6' is never used. [unusedStructMember]
typedef struct float7 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; } float7;
                                                                                          ^
modules/dnn/src/opencl/conv_layer_spatial.cl:398:31: style: struct member 'float9::s0' is never used. [unusedStructMember]
typedef struct float9 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; float s7; float s8; } float9;
                              ^
modules/dnn/src/opencl/conv_layer_spatial.cl:398:41: style: struct member 'float9::s1' is never used. [unusedStructMember]
typedef struct float9 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; float s7; float s8; } float9;
                                        ^
modules/dnn/src/opencl/conv_layer_spatial.cl:398:51: style: struct member 'float9::s2' is never used. [unusedStructMember]
typedef struct float9 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; float s7; float s8; } float9;
                                                  ^
modules/dnn/src/opencl/conv_layer_spatial.cl:398:61: style: struct member 'float9::s3' is never used. [unusedStructMember]
typedef struct float9 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; float s7; float s8; } float9;
                                                            ^
modules/dnn/src/opencl/conv_layer_spatial.cl:398:71: style: struct member 'float9::s4' is never used. [unusedStructMember]
typedef struct float9 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; float s7; float s8; } float9;
                                                                      ^
modules/dnn/src/opencl/conv_layer_spatial.cl:398:81: style: struct member 'float9::s5' is never used. [unusedStructMember]
typedef struct float9 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; float s7; float s8; } float9;
                                                                                ^
modules/dnn/src/opencl/conv_layer_spatial.cl:398:91: style: struct member 'float9::s6' is never used. [unusedStructMember]
typedef struct float9 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; float s7; float s8; } float9;
                                                                                          ^
modules/dnn/src/opencl/conv_layer_spatial.cl:398:101: style: struct member 'float9::s7' is never used. [unusedStructMember]
typedef struct float9 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; float s7; float s8; } float9;
                                                                                                    ^
modules/dnn/src/opencl/conv_layer_spatial.cl:398:111: style: struct member 'float9::s8' is never used. [unusedStructMember]
typedef struct float9 { float s0; float s1; float s2; float s3; float s4; float s5; float s6; float s7; float s8; } float9;
                                                                                                              ^
modules/dnn/src/opencl/conv_layer_spatial.cl:399:32: style: struct member 'float10::s0' is never used. [unusedStructMember]
typedef struct float10 { float s0; float s1; float s2; float s3; float s4; float s5;
                               ^
modules/dnn/src/opencl/conv_layer_spatial.cl:399:42: style: struct member 'float10::s1' is never used. [unusedStructMember]
typedef struct float10 { float s0; float s1; float s2; float s3; float s4; float s5;
                                         ^
modules/dnn/src/opencl/conv_layer_spatial.cl:399:52: style: struct member 'float10::s2' is never used. [unusedStructMember]
typedef struct float10 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                   ^
modules/dnn/src/opencl/conv_layer_spatial.cl:399:62: style: struct member 'float10::s3' is never used. [unusedStructMember]
typedef struct float10 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                             ^
modules/dnn/src/opencl/conv_layer_spatial.cl:399:72: style: struct member 'float10::s4' is never used. [unusedStructMember]
typedef struct float10 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                                       ^
modules/dnn/src/opencl/conv_layer_spatial.cl:399:82: style: struct member 'float10::s5' is never used. [unusedStructMember]
typedef struct float10 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                                                 ^
modules/dnn/src/opencl/conv_layer_spatial.cl:400:32: style: struct member 'float10::s6' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9;} float10;
                               ^
modules/dnn/src/opencl/conv_layer_spatial.cl:400:42: style: struct member 'float10::s7' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9;} float10;
                                         ^
modules/dnn/src/opencl/conv_layer_spatial.cl:400:52: style: struct member 'float10::s8' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9;} float10;
                                                   ^
modules/dnn/src/opencl/conv_layer_spatial.cl:400:62: style: struct member 'float10::s9' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9;} float10;
                                                             ^
modules/dnn/src/opencl/conv_layer_spatial.cl:401:32: style: struct member 'float11::s0' is never used. [unusedStructMember]
typedef struct float11 { float s0; float s1; float s2; float s3; float s4; float s5;
                               ^
modules/dnn/src/opencl/conv_layer_spatial.cl:401:42: style: struct member 'float11::s1' is never used. [unusedStructMember]
typedef struct float11 { float s0; float s1; float s2; float s3; float s4; float s5;
                                         ^
modules/dnn/src/opencl/conv_layer_spatial.cl:401:52: style: struct member 'float11::s2' is never used. [unusedStructMember]
typedef struct float11 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                   ^
modules/dnn/src/opencl/conv_layer_spatial.cl:401:62: style: struct member 'float11::s3' is never used. [unusedStructMember]
typedef struct float11 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                             ^
modules/dnn/src/opencl/conv_layer_spatial.cl:401:72: style: struct member 'float11::s4' is never used. [unusedStructMember]
typedef struct float11 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                                       ^
modules/dnn/src/opencl/conv_layer_spatial.cl:401:82: style: struct member 'float11::s5' is never used. [unusedStructMember]
typedef struct float11 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                                                 ^
modules/dnn/src/opencl/conv_layer_spatial.cl:402:32: style: struct member 'float11::s6' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa;} float11;
                               ^
modules/dnn/src/opencl/conv_layer_spatial.cl:402:42: style: struct member 'float11::s7' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa;} float11;
                                         ^
modules/dnn/src/opencl/conv_layer_spatial.cl:402:52: style: struct member 'float11::s8' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa;} float11;
                                                   ^
modules/dnn/src/opencl/conv_layer_spatial.cl:402:62: style: struct member 'float11::s9' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa;} float11;
                                                             ^
modules/dnn/src/opencl/conv_layer_spatial.cl:402:72: style: struct member 'float11::sa' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa;} float11;
                                                                       ^
modules/dnn/src/opencl/conv_layer_spatial.cl:403:32: style: struct member 'float12::s0' is never used. [unusedStructMember]
typedef struct float12 { float s0; float s1; float s2; float s3; float s4; float s5;
                               ^
modules/dnn/src/opencl/conv_layer_spatial.cl:403:42: style: struct member 'float12::s1' is never used. [unusedStructMember]
typedef struct float12 { float s0; float s1; float s2; float s3; float s4; float s5;
                                         ^
modules/dnn/src/opencl/conv_layer_spatial.cl:403:52: style: struct member 'float12::s2' is never used. [unusedStructMember]
typedef struct float12 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                   ^
modules/dnn/src/opencl/conv_layer_spatial.cl:403:62: style: struct member 'float12::s3' is never used. [unusedStructMember]
typedef struct float12 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                             ^
modules/dnn/src/opencl/conv_layer_spatial.cl:403:72: style: struct member 'float12::s4' is never used. [unusedStructMember]
typedef struct float12 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                                       ^
modules/dnn/src/opencl/conv_layer_spatial.cl:403:82: style: struct member 'float12::s5' is never used. [unusedStructMember]
typedef struct float12 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                                                 ^
modules/dnn/src/opencl/conv_layer_spatial.cl:404:32: style: struct member 'float12::s6' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; } float12;
                               ^
modules/dnn/src/opencl/conv_layer_spatial.cl:404:42: style: struct member 'float12::s7' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; } float12;
                                         ^
modules/dnn/src/opencl/conv_layer_spatial.cl:404:52: style: struct member 'float12::s8' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; } float12;
                                                   ^
modules/dnn/src/opencl/conv_layer_spatial.cl:404:62: style: struct member 'float12::s9' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; } float12;
                                                             ^
modules/dnn/src/opencl/conv_layer_spatial.cl:404:72: style: struct member 'float12::sa' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; } float12;
                                                                       ^
modules/dnn/src/opencl/conv_layer_spatial.cl:404:82: style: struct member 'float12::sb' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; } float12;
                                                                                 ^
modules/dnn/src/opencl/conv_layer_spatial.cl:405:32: style: struct member 'float13::s0' is never used. [unusedStructMember]
typedef struct float13 { float s0; float s1; float s2; float s3; float s4; float s5;
                               ^
modules/dnn/src/opencl/conv_layer_spatial.cl:405:42: style: struct member 'float13::s1' is never used. [unusedStructMember]
typedef struct float13 { float s0; float s1; float s2; float s3; float s4; float s5;
                                         ^
modules/dnn/src/opencl/conv_layer_spatial.cl:405:52: style: struct member 'float13::s2' is never used. [unusedStructMember]
typedef struct float13 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                   ^
modules/dnn/src/opencl/conv_layer_spatial.cl:405:62: style: struct member 'float13::s3' is never used. [unusedStructMember]
typedef struct float13 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                             ^
modules/dnn/src/opencl/conv_layer_spatial.cl:405:72: style: struct member 'float13::s4' is never used. [unusedStructMember]
typedef struct float13 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                                       ^
modules/dnn/src/opencl/conv_layer_spatial.cl:405:82: style: struct member 'float13::s5' is never used. [unusedStructMember]
typedef struct float13 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                                                 ^
modules/dnn/src/opencl/conv_layer_spatial.cl:406:32: style: struct member 'float13::s6' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc;} float13;
                               ^
modules/dnn/src/opencl/conv_layer_spatial.cl:406:42: style: struct member 'float13::s7' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc;} float13;
                                         ^
modules/dnn/src/opencl/conv_layer_spatial.cl:406:52: style: struct member 'float13::s8' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc;} float13;
                                                   ^
modules/dnn/src/opencl/conv_layer_spatial.cl:406:62: style: struct member 'float13::s9' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc;} float13;
                                                             ^
modules/dnn/src/opencl/conv_layer_spatial.cl:406:72: style: struct member 'float13::sa' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc;} float13;
                                                                       ^
modules/dnn/src/opencl/conv_layer_spatial.cl:406:82: style: struct member 'float13::sb' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc;} float13;
                                                                                 ^
modules/dnn/src/opencl/conv_layer_spatial.cl:406:92: style: struct member 'float13::sc' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc;} float13;
                                                                                           ^
modules/dnn/src/opencl/conv_layer_spatial.cl:407:32: style: struct member 'float14::s0' is never used. [unusedStructMember]
typedef struct float14 { float s0; float s1; float s2; float s3; float s4; float s5;
                               ^
modules/dnn/src/opencl/conv_layer_spatial.cl:407:42: style: struct member 'float14::s1' is never used. [unusedStructMember]
typedef struct float14 { float s0; float s1; float s2; float s3; float s4; float s5;
                                         ^
modules/dnn/src/opencl/conv_layer_spatial.cl:407:52: style: struct member 'float14::s2' is never used. [unusedStructMember]
typedef struct float14 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                   ^
modules/dnn/src/opencl/conv_layer_spatial.cl:407:62: style: struct member 'float14::s3' is never used. [unusedStructMember]
typedef struct float14 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                             ^
modules/dnn/src/opencl/conv_layer_spatial.cl:407:72: style: struct member 'float14::s4' is never used. [unusedStructMember]
typedef struct float14 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                                       ^
modules/dnn/src/opencl/conv_layer_spatial.cl:407:82: style: struct member 'float14::s5' is never used. [unusedStructMember]
typedef struct float14 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                                                 ^
modules/dnn/src/opencl/conv_layer_spatial.cl:408:32: style: struct member 'float14::s6' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; } float14;
                               ^
modules/dnn/src/opencl/conv_layer_spatial.cl:408:42: style: struct member 'float14::s7' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; } float14;
                                         ^
modules/dnn/src/opencl/conv_layer_spatial.cl:408:52: style: struct member 'float14::s8' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; } float14;
                                                   ^
modules/dnn/src/opencl/conv_layer_spatial.cl:408:62: style: struct member 'float14::s9' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; } float14;
                                                             ^
modules/dnn/src/opencl/conv_layer_spatial.cl:408:72: style: struct member 'float14::sa' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; } float14;
                                                                       ^
modules/dnn/src/opencl/conv_layer_spatial.cl:408:82: style: struct member 'float14::sb' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; } float14;
                                                                                 ^
modules/dnn/src/opencl/conv_layer_spatial.cl:408:92: style: struct member 'float14::sc' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; } float14;
                                                                                           ^
modules/dnn/src/opencl/conv_layer_spatial.cl:408:102: style: struct member 'float14::sd' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; } float14;
                                                                                                     ^
modules/dnn/src/opencl/conv_layer_spatial.cl:409:32: style: struct member 'float15::s0' is never used. [unusedStructMember]
typedef struct float15 { float s0; float s1; float s2; float s3; float s4; float s5;
                               ^
modules/dnn/src/opencl/conv_layer_spatial.cl:409:42: style: struct member 'float15::s1' is never used. [unusedStructMember]
typedef struct float15 { float s0; float s1; float s2; float s3; float s4; float s5;
                                         ^
modules/dnn/src/opencl/conv_layer_spatial.cl:409:52: style: struct member 'float15::s2' is never used. [unusedStructMember]
typedef struct float15 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                   ^
modules/dnn/src/opencl/conv_layer_spatial.cl:409:62: style: struct member 'float15::s3' is never used. [unusedStructMember]
typedef struct float15 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                             ^
modules/dnn/src/opencl/conv_layer_spatial.cl:409:72: style: struct member 'float15::s4' is never used. [unusedStructMember]
typedef struct float15 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                                       ^
modules/dnn/src/opencl/conv_layer_spatial.cl:409:82: style: struct member 'float15::s5' is never used. [unusedStructMember]
typedef struct float15 { float s0; float s1; float s2; float s3; float s4; float s5;
                                                                                 ^
modules/dnn/src/opencl/conv_layer_spatial.cl:410:32: style: struct member 'float15::s6' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; float se; } float15;
                               ^
modules/dnn/src/opencl/conv_layer_spatial.cl:410:42: style: struct member 'float15::s7' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; float se; } float15;
                                         ^
modules/dnn/src/opencl/conv_layer_spatial.cl:410:52: style: struct member 'float15::s8' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; float se; } float15;
                                                   ^
modules/dnn/src/opencl/conv_layer_spatial.cl:410:62: style: struct member 'float15::s9' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; float se; } float15;
                                                             ^
modules/dnn/src/opencl/conv_layer_spatial.cl:410:72: style: struct member 'float15::sa' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; float se; } float15;
                                                                       ^
modules/dnn/src/opencl/conv_layer_spatial.cl:410:82: style: struct member 'float15::sb' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; float se; } float15;
                                                                                 ^
modules/dnn/src/opencl/conv_layer_spatial.cl:410:92: style: struct member 'float15::sc' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; float se; } float15;
                                                                                           ^
modules/dnn/src/opencl/conv_layer_spatial.cl:410:102: style: struct member 'float15::sd' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; float se; } float15;
                                                                                                     ^
modules/dnn/src/opencl/conv_layer_spatial.cl:410:112: style: struct member 'float15::se' is never used. [unusedStructMember]
                         float s6; float s7; float s8; float s9; float sa; float sb; float sc; float sd; float se; } float15;
                                                                                                               ^
modules/dnn/src/opencl/conv_layer_spatial.cl:411:31: style: struct member 'float0::s0' is never used. [unusedStructMember]
typedef struct float0 { float s0; } float0; //never used but makes compiler happy.
                              ^
modules/dnn/src/opencl/conv_spatial_helper.cl:60:22: style: Variable 'outputSublayer' is assigned a value that is never used. [unreadVariable]
  int outputSublayer = channels / swizzleFactor;
                     ^
modules/dnn/src/opencl/conv_spatial_helper.cl:61:27: style: Variable 'outputSublayerIndex' is assigned a value that is never used. [unreadVariable]
  int outputSublayerIndex = channels % swizzleFactor;
                          ^
modules/dnn/src/opencl/gemm_image.cl:413:1: style: Variable 'sampler' is assigned a value that is never used. [unreadVariable]
GEMM_NT(1, 0, BUFFER, 1) // ALPHA == 1, BETA == 0
^
modules/dnn/src/opencl/gemm_image.cl:414:1: style: Variable 'sampler' is assigned a value that is never used. [unreadVariable]
GEMM_NT(1, 1, BUFFER, 1) // ALPHA == 1, BETA != 0
^
modules/dnn/src/opencl/gemm_image.cl:415:1: style: Variable 'sampler' is assigned a value that is never used. [unreadVariable]
GEMM_NT(0, 0, BUFFER, 1) // ALPHA != 1, BETA == 0
^
modules/dnn/src/opencl/gemm_image.cl:416:1: style: Variable 'sampler' is assigned a value that is never used. [unreadVariable]
GEMM_NT(0, 1, BUFFER, 1) // ALPHA != 1, BETA != 0
^
modules/dnn/src/opencl/gemm_image.cl:552:1: style: Variable 'sampler' is assigned a value that is never used. [unreadVariable]
GEMM_TT(1, 0, BUFFER, 1) // ALPHA == 1, BETA == 0
^
modules/dnn/src/opencl/gemm_image.cl:553:1: style: Variable 'sampler' is assigned a value that is never used. [unreadVariable]
GEMM_TT(1, 1, BUFFER, 1) // ALPHA == 1, BETA != 0
^
modules/dnn/src/opencl/gemm_image.cl:554:1: style: Variable 'sampler' is assigned a value that is never used. [unreadVariable]
GEMM_TT(0, 0, BUFFER, 1) // ALPHA != 1, BETA == 0
^
modules/dnn/src/opencl/gemm_image.cl:555:1: style: Variable 'sampler' is assigned a value that is never used. [unreadVariable]
GEMM_TT(0, 1, BUFFER, 1) // ALPHA != 1, BETA != 0
^
modules/dnn/src/opencl/matvec_mul.cl:97:24: style: Local variable 'i' shadows outer variable [shadowVariable]
      for(unsigned int i = 0; i < trail_item; ++i) {
                       ^
modules/dnn/src/opencl/matvec_mul.cl:69:16: note: Shadowed declaration
  unsigned int i = lid;
               ^
modules/dnn/src/opencl/matvec_mul.cl:97:24: note: Shadow variable
      for(unsigned int i = 0; i < trail_item; ++i) {
                       ^
modules/dnn/src/opencl/matvec_mul.cl:168:24: style: Local variable 'i' shadows outer variable [shadowVariable]
      for(unsigned int i = 0; i < trail_item; ++i) {
                       ^
modules/dnn/src/opencl/matvec_mul.cl:150:16: note: Shadowed declaration
  unsigned int i = lid;
               ^
modules/dnn/src/opencl/matvec_mul.cl:168:24: note: Shadow variable
      for(unsigned int i = 0; i < trail_item; ++i) {
                       ^
modules/dnn/src/tensorflow/tf_importer.cpp:49:5: style: Struct 'Pin' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Pin(const std::string &_name, int _blobIndex = 0) :
    ^
modules/dnn/src/tensorflow/tf_importer.cpp:451:5: style: Class 'TFImporter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    TFImporter(const char *model, const char *config = NULL);
    ^
modules/dnn/src/tensorflow/tf_importer.cpp:65:13: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i, n = _shape.dim_size();
            ^
modules/dnn/src/torch/THDiskFile.cpp:383:9: error: Common realloc mistake: 'p' nulled but not freed upon failure [memleakOnRealloc]
        p = (char*)THRealloc(p, total);
        ^
modules/dnn/src/torch/THDiskFile.cpp:417:9: error: Common realloc mistake: 'p' nulled but not freed upon failure [memleakOnRealloc]
        p = (char*)THRealloc(p, total);
        ^
modules/dnn/src/torch/THDiskFile.cpp:410:10: style: The scope of the variable 'size' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    long size;
         ^
modules/dnn/src/torch/torch_importer.cpp:111:9: style: Struct 'Module' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Module(const String &_thName, const String &_apiType = String())
        ^
modules/dnn/src/torch/torch_importer.cpp:283:14: style: The scope of the variable 'fpos' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        long fpos;
             ^
modules/dnn/src/torch/torch_importer.cpp:1010:21: style: The scope of the variable 'newId' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int newId, mergeId;
                    ^
modules/dnn/src/torch/torch_importer.cpp:1034:21: style: The scope of the variable 'newId' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int newId, mergeId;
                    ^
modules/dnn/src/torch/torch_importer.cpp:1058:21: style: The scope of the variable 'newId' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int newId, splitId, mergeId, reshapeId;
                    ^
modules/dnn/src/torch/torch_importer.cpp:308:21: style: Local variable 'index' shadows outer variable [shadowVariable]
                int index = readInt();
                    ^
modules/dnn/src/torch/torch_importer.cpp:278:13: note: Shadowed declaration
        int index = readInt();
            ^
modules/dnn/src/torch/torch_importer.cpp:308:21: note: Shadow variable
                int index = readInt();
                    ^
modules/dnn/src/torch/torch_importer.cpp:361:71: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
            for (it = tensorParams.begin(); it != tensorParams.end(); it++)
                                                                      ^
modules/dnn/test/test_caffe_importer.cpp:60:1: error: syntax error [syntaxError]
TEST(Test_Caffe, memory_read)
^
modules/dnn/test/test_darknet_importer.cpp:62:1: error: syntax error [syntaxError]
TEST(Test_Darknet, read_tiny_yolo_voc)
^
modules/dnn/test/test_googlenet.cpp:59:1: error: syntax error [syntaxError]
TEST(Reproducibility_GoogLeNet, Accuracy)
^
modules/dnn/test/test_halide_layers.cpp:40:1: error: syntax error [syntaxError]
TEST(Padding_Halide, Accuracy)
^
modules/dnn/test/test_halide_nets.cpp:83:1: error: syntax error [syntaxError]
TEST(Reproducibility_MobileNetSSD_Halide, Accuracy)
^
modules/dnn/test/test_layers.cpp:127:1: error: syntax error [syntaxError]
TEST(Layer_Test_Softmax, Accuracy)
^
modules/dnn/test/test_tf_importer.cpp:29:1: error: syntax error [syntaxError]
TEST(Test_TensorFlow, read_inception)
^
modules/dnn/test/test_torch_importer.cpp:65:1: error: syntax error [syntaxError]
TEST(Torch_Importer, simple_read)
^
modules/features2d/perf/opencl/perf_brute_force_matcher.cpp:79:1: error: syntax error [syntaxError]
OCL_PERF_TEST_P(BruteForceMatcherFixture, KnnMatch, ::testing::Combine(OCL_PERF_ENUM(OCL_SIZE_1, OCL_SIZE_2, OCL_SIZE_3), OCL_PERF_ENUM((MatType)CV_32FC1) ) )
^
modules/features2d/perf/perf_feature2d.hpp:31:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM_EXPAND(Feature2DType, DETECTORS_ONLY, DETECTORS_EXTRACTORS)
^
modules/features2d/perf/perf_batchDistance.cpp:9:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(NormType, NORM_L1, NORM_L2, NORM_L2SQR, NORM_HAMMING, NORM_HAMMING2)
^
modules/features2d/src/agast.cpp:8073:41: style: Unused variable: currCorner_nms [unusedVariable]
        std::vector<KeyPoint>::iterator currCorner_nms;
                                        ^
modules/features2d/src/agast.cpp:5358:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x, y;
        ^
modules/features2d/src/agast_score.cpp:9388:9: style: The scope of the variable 'offset' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int offset;
        ^
modules/features2d/src/agast_score.cpp:9414:9: style: The scope of the variable 'result' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int result;
        ^
modules/features2d/src/kaze/AKAZEFeatures.h:102:3: style: Class 'AKAZEFeatures' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
  AKAZEFeatures(const AKAZEOptions& options);
  ^
modules/features2d/src/bagofwords.cpp:212:19: style: Variable 'imgDescriptor' is assigned a value that is never used. [unreadVariable]
    imgDescriptor /= keypointDescriptors.size().height;
                  ^
modules/features2d/src/brisk.cpp:2089:3: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'img_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
  img_ = img_in;
  ^
modules/features2d/src/brisk.cpp:2090:3: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'scores_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
  scores_ = cv::Mat_<uchar>::zeros(img_in.rows, img_in.cols);
  ^
modules/features2d/src/brisk.cpp:164:3: style: Class 'BriskLayer' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
  BriskLayer(const cv::Mat& img, float scale = 1.0f, float offset = 0.0f);
  ^
modules/features2d/src/brisk.cpp:1316:23: style: Variable 'max_below_float' is reassigned a value before the old one has been used. [redundantAssignment]
      max_below_float = (float)max_below;
                      ^
modules/features2d/src/brisk.cpp:1314:23: note: max_below_float is assigned
      max_below_float = subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, delta_x_below,
                      ^
modules/features2d/src/brisk.cpp:1316:23: note: max_below_float is overwritten
      max_below_float = (float)max_below;
                      ^
modules/features2d/src/brisk.cpp:379:19: style: The scope of the variable 'theta' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double alpha, theta;
                  ^
modules/features2d/src/brisk.cpp:1053:7: style: The scope of the variable 'sixth_x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int sixth_x;
      ^
modules/features2d/src/brisk.cpp:1054:7: style: The scope of the variable 'quarter_x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int quarter_x;
      ^
modules/features2d/src/brisk.cpp:1056:7: style: The scope of the variable 'sixth_y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int sixth_y;
      ^
modules/features2d/src/brisk.cpp:1057:7: style: The scope of the variable 'quarter_y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int quarter_y;
      ^
modules/features2d/src/brisk.cpp:1290:9: style: The scope of the variable 'max_below' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int max_below = 0;
        ^
modules/features2d/src/brisk.cpp:323:47: performance: Parameter 'indexChange' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
                       const std::vector<int> indexChange)
                                              ^
modules/features2d/src/brisk.cpp:335:47: performance: Parameter 'indexChange' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
                       const std::vector<int> indexChange)
                                              ^
modules/features2d/src/brisk.cpp:160:22: style: struct member 'CommonParams::HALFSAMPLE' is never used. [unusedStructMember]
    static const int HALFSAMPLE = 0;
                     ^
modules/features2d/src/brisk.cpp:161:22: style: struct member 'CommonParams::TWOTHIRDSAMPLE' is never used. [unusedStructMember]
    static const int TWOTHIRDSAMPLE = 1;
                     ^
modules/features2d/src/brisk.cpp:1238:10: style: Variable 'data' is assigned a value that is never used. [unreadVariable]
    data = scores.ptr() + y_layer * scorescols + x_layer;
         ^
modules/features2d/src/brisk.cpp:1290:19: style: Variable 'max_below' is assigned a value that is never used. [unreadVariable]
    int max_below = 0;
                  ^
modules/features2d/src/draw.cpp:145:16: style: Variable 'outImg' is reassigned a value before the old one has been used. [redundantAssignment]
        outImg = Scalar::all(0);
               ^
modules/features2d/src/draw.cpp:144:16: note: outImg is assigned
        outImg = _outImg.getMat();
               ^
modules/features2d/src/draw.cpp:145:16: note: outImg is overwritten
        outImg = Scalar::all(0);
               ^
modules/features2d/src/evaluation.cpp:141:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'center' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    center = _center;
    ^
modules/features2d/src/evaluation.cpp:142:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'ellipse' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    ellipse = _ellipse;
    ^
modules/features2d/src/evaluation.cpp:314:9: style: Struct 'UsedFinder' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        UsedFinder(const SIdx& _used) : used(_used) {}
        ^
modules/features2d/src/evaluation.cpp:484:5: style: Struct 'DMatchForEvaluation' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    DMatchForEvaluation( const DMatch &dm ) : DMatch( dm ), isCorrect(0) {}
    ^
modules/features2d/src/evaluation.cpp:541:11: style: Local variable 'recall' shadows outer function [shadowFunction]
    float recall = -1.f;
          ^
modules/features2d/src/evaluation.cpp:487:21: note: Shadowed declaration
static inline float recall( int correctMatchCount, int correspondenceCount )
                    ^
modules/features2d/src/evaluation.cpp:541:11: note: Shadow variable
    float recall = -1.f;
          ^
modules/features2d/src/evaluation.cpp:494:48: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a+b?c:d'' should be written as either ''(a+b)?c:d'' or ''a+(b?c:d)''. [clarifyCalculation]
    return correctMatchCount + falseMatchCount ? (float)correctMatchCount / (float)(correctMatchCount + falseMatchCount) : -1;
                                               ^
modules/features2d/src/evaluation.cpp:285:38: style: Parameter 'ac' can be declared with const [constParameter]
    void join( IntersectAreaCounter& ac )
                                     ^
modules/features2d/src/fast.avx2.cpp:64:18: style: The function 'process' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void process(int &j, const uchar* &ptr, uchar* curr, int* cornerpos, int &ncorners)
                 ^
modules/features2d/src/fast.hpp:56:18: note: Virtual function in base class
    virtual void process(int &j, const uchar* &ptr, uchar* curr, int* cornerpos, int &ncorners) = 0;
                 ^
modules/features2d/src/fast.avx2.cpp:64:18: note: Function in derived class
    virtual void process(int &j, const uchar* &ptr, uchar* curr, int* cornerpos, int &ncorners)
                 ^
modules/features2d/src/kaze/KAZEFeatures.h:45:5: style: Class 'KAZEFeatures' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    KAZEFeatures(KAZEOptions& options);
    ^
modules/features2d/src/kaze/AKAZEFeatures.h:35:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'size' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    size = other.size;
    ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1927:20: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
    int* ivalues = (int*) values;
                   ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2251:9: style: Redundant initialization for 'comps'. The initialized value is overwritten before it is read. [redundantInitialization]
  comps = 1000;
        ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2250:19: note: comps is initialized
  Mat_<int> comps = Mat_<int>(nchannels * npicks, 2);
                  ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2251:9: note: comps is overwritten
  comps = 1000;
        ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:49:9: style: The scope of the variable 'rfactor' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  float rfactor = 0.0f;
        ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:50:7: style: The scope of the variable 'level_height' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int level_height = 0, level_width = 0;
      ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:50:25: style: The scope of the variable 'level_width' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int level_height = 0, level_width = 0;
                        ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1493:46: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                                             ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1498:21: style: The scope of the variable 'cy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  float cx = -0.5f, cy = 0.5f;
                    ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1627:30: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                             ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1631:21: style: The scope of the variable 'cy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  float cx = -0.5f, cy = 0.5f;
                    ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2106:9: style: The scope of the variable 'di' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  float di = 0.0f, dx = 0.0f, dy = 0.0f;
        ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2106:20: style: The scope of the variable 'dx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  float di = 0.0f, dx = 0.0f, dy = 0.0f;
                   ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2106:31: style: The scope of the variable 'dy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  float di = 0.0f, dx = 0.0f, dy = 0.0f;
                              ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2224:29: warning: Conversion of string literal "Descriptor size can't be bigger than full descriptor (486 = 162*3 - 3 channels)" to bool always evaluates to true. [incorrectStringBooleanError]
  CV_Assert(nbits <= ssz && "Descriptor size can't be bigger than full descriptor (486 = 162*3 - 3 channels)");
                            ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:49:17: style: Variable 'rfactor' is assigned a value that is never used. [unreadVariable]
  float rfactor = 0.0f;
                ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:50:20: style: Variable 'level_height' is assigned a value that is never used. [unreadVariable]
  int level_height = 0, level_width = 0;
                   ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:50:37: style: Variable 'level_width' is assigned a value that is never used. [unreadVariable]
  int level_height = 0, level_width = 0;
                                    ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:144:16: style: Variable 'step_r' is assigned a value that is never used. [unreadVariable]
  float step_r = 0.f;
               ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:336:9: style: Variable 'modgs' is assigned a value that is never used. [unreadVariable]
  modgs *= (nbins - 1) / hmax;
        ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1489:12: style: Variable 'dx' is assigned a value that is never used. [unreadVariable]
  float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
           ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1489:22: style: Variable 'dy' is assigned a value that is never used. [unreadVariable]
  float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                     ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1489:33: style: Variable 'mdx' is assigned a value that is never used. [unreadVariable]
  float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1489:44: style: Variable 'mdy' is assigned a value that is never used. [unreadVariable]
  float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                           ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1489:60: style: Variable 'gauss_s1' is assigned a value that is never used. [unreadVariable]
  float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                                           ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1490:63: style: Variable 'ys' is assigned a value that is never used. [unreadVariable]
  float rx = 0.0, ry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                                              ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1490:73: style: Variable 'xs' is assigned a value that is never used. [unreadVariable]
  float rx = 0.0, ry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                                                        ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1491:18: style: Variable 'sample_x' is assigned a value that is never used. [unreadVariable]
  float sample_x = 0.0, sample_y = 0.0;
                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1491:34: style: Variable 'sample_y' is assigned a value that is never used. [unreadVariable]
  float sample_x = 0.0, sample_y = 0.0;
                                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1492:10: style: Variable 'x1' is assigned a value that is never used. [unreadVariable]
  int x1 = 0, y1 = 0, sample_step = 0, pattern_size = 0;
         ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1492:18: style: Variable 'y1' is assigned a value that is never used. [unreadVariable]
  int x1 = 0, y1 = 0, sample_step = 0, pattern_size = 0;
                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1493:10: style: Variable 'x2' is assigned a value that is never used. [unreadVariable]
  int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
         ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1493:18: style: Variable 'y2' is assigned a value that is never used. [unreadVariable]
  int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1493:26: style: Variable 'kx' is assigned a value that is never used. [unreadVariable]
  int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                         ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1493:34: style: Variable 'ky' is assigned a value that is never used. [unreadVariable]
  int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1493:48: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
  int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                                               ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1498:24: style: Variable 'cy' is assigned a value that is never used. [unreadVariable]
  float cx = -0.5f, cy = 0.5f;
                       ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1622:12: style: Variable 'dx' is assigned a value that is never used. [unreadVariable]
  float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
           ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1622:22: style: Variable 'dy' is assigned a value that is never used. [unreadVariable]
  float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                     ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1622:33: style: Variable 'mdx' is assigned a value that is never used. [unreadVariable]
  float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1622:44: style: Variable 'mdy' is assigned a value that is never used. [unreadVariable]
  float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                           ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1622:60: style: Variable 'gauss_s1' is assigned a value that is never used. [unreadVariable]
  float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                                           ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1623:85: style: Variable 'ys' is assigned a value that is never used. [unreadVariable]
  float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                                                                    ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1623:95: style: Variable 'xs' is assigned a value that is never used. [unreadVariable]
  float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                                                                              ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1624:18: style: Variable 'sample_x' is assigned a value that is never used. [unreadVariable]
  float sample_x = 0.0, sample_y = 0.0, co = 0.0, si = 0.0, angle = 0.0;
                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1624:34: style: Variable 'sample_y' is assigned a value that is never used. [unreadVariable]
  float sample_x = 0.0, sample_y = 0.0, co = 0.0, si = 0.0, angle = 0.0;
                                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1626:10: style: Variable 'x1' is assigned a value that is never used. [unreadVariable]
  int x1 = 0, y1 = 0, x2 = 0, y2 = 0, sample_step = 0, pattern_size = 0;
         ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1626:18: style: Variable 'y1' is assigned a value that is never used. [unreadVariable]
  int x1 = 0, y1 = 0, x2 = 0, y2 = 0, sample_step = 0, pattern_size = 0;
                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1626:26: style: Variable 'x2' is assigned a value that is never used. [unreadVariable]
  int x1 = 0, y1 = 0, x2 = 0, y2 = 0, sample_step = 0, pattern_size = 0;
                         ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1626:34: style: Variable 'y2' is assigned a value that is never used. [unreadVariable]
  int x1 = 0, y1 = 0, x2 = 0, y2 = 0, sample_step = 0, pattern_size = 0;
                                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1627:10: style: Variable 'kx' is assigned a value that is never used. [unreadVariable]
  int kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
         ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1627:18: style: Variable 'ky' is assigned a value that is never used. [unreadVariable]
  int kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1627:32: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
  int kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                               ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:1631:24: style: Variable 'cy' is assigned a value that is never used. [unreadVariable]
  float cx = -0.5f, cy = 0.5f;
                       ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2000:18: style: Variable 'sample_x' is assigned a value that is never used. [unreadVariable]
  float sample_x = 0.f, sample_y = 0.f;
                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2000:34: style: Variable 'sample_y' is assigned a value that is never used. [unreadVariable]
  float sample_x = 0.f, sample_y = 0.f;
                                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2106:12: style: Variable 'di' is assigned a value that is never used. [unreadVariable]
  float di = 0.0f, dx = 0.0f, dy = 0.0f;
           ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2106:23: style: Variable 'dx' is assigned a value that is never used. [unreadVariable]
  float di = 0.0f, dx = 0.0f, dy = 0.0f;
                      ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2106:34: style: Variable 'dy' is assigned a value that is never used. [unreadVariable]
  float di = 0.0f, dx = 0.0f, dy = 0.0f;
                                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2108:18: style: Variable 'sample_x' is assigned a value that is never used. [unreadVariable]
  float sample_x = 0.0f, sample_y = 0.0f;
                 ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2108:35: style: Variable 'sample_y' is assigned a value that is never used. [unreadVariable]
  float sample_x = 0.0f, sample_y = 0.0f;
                                  ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2109:10: style: Variable 'x1' is assigned a value that is never used. [unreadVariable]
  int x1 = 0, y1 = 0;
         ^
modules/features2d/src/kaze/AKAZEFeatures.cpp:2109:18: style: Variable 'y1' is assigned a value that is never used. [unreadVariable]
  int x1 = 0, y1 = 0;
                 ^
modules/features2d/src/kaze/KAZEFeatures.cpp:378:28: style: Condition 'is_out==false' is always true [knownConditionTrueFalse]
                if (is_out == false) {
                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:376:26: note: Assignment 'is_out=false', assigned value is 0
                is_out = false;
                         ^
modules/features2d/src/kaze/KAZEFeatures.cpp:378:28: note: Condition 'is_out==false' is always true
                if (is_out == false) {
                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:376:24: style: Variable 'is_out' is reassigned a value before the old one has been used. [redundantAssignment]
                is_out = false;
                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:373:28: note: is_out is assigned
                    is_out = true;
                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:376:24: note: is_out is overwritten
                is_out = false;
                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:400:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0, y = 0;
        ^
modules/features2d/src/kaze/KAZEFeatures.cpp:400:16: style: The scope of the variable 'y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0, y = 0;
               ^
modules/features2d/src/kaze/KAZEFeatures.cpp:401:11: style: The scope of the variable 'Dx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float Dx = 0.0, Dy = 0.0, Ds = 0.0, dsc = 0.0;
          ^
modules/features2d/src/kaze/KAZEFeatures.cpp:401:21: style: The scope of the variable 'Dy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float Dx = 0.0, Dy = 0.0, Ds = 0.0, dsc = 0.0;
                    ^
modules/features2d/src/kaze/KAZEFeatures.cpp:401:31: style: The scope of the variable 'Ds' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float Dx = 0.0, Dy = 0.0, Ds = 0.0, dsc = 0.0;
                              ^
modules/features2d/src/kaze/KAZEFeatures.cpp:402:11: style: The scope of the variable 'Dxx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float Dxx = 0.0, Dyy = 0.0, Dss = 0.0, Dxy = 0.0, Dxs = 0.0, Dys = 0.0;
          ^
modules/features2d/src/kaze/KAZEFeatures.cpp:402:22: style: The scope of the variable 'Dyy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float Dxx = 0.0, Dyy = 0.0, Dss = 0.0, Dxy = 0.0, Dxs = 0.0, Dys = 0.0;
                     ^
modules/features2d/src/kaze/KAZEFeatures.cpp:402:33: style: The scope of the variable 'Dss' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float Dxx = 0.0, Dyy = 0.0, Dss = 0.0, Dxy = 0.0, Dxs = 0.0, Dys = 0.0;
                                ^
modules/features2d/src/kaze/KAZEFeatures.cpp:402:44: style: The scope of the variable 'Dxy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float Dxx = 0.0, Dyy = 0.0, Dss = 0.0, Dxy = 0.0, Dxs = 0.0, Dys = 0.0;
                                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:402:55: style: The scope of the variable 'Dxs' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float Dxx = 0.0, Dyy = 0.0, Dss = 0.0, Dxy = 0.0, Dxs = 0.0, Dys = 0.0;
                                                      ^
modules/features2d/src/kaze/KAZEFeatures.cpp:402:66: style: The scope of the variable 'Dys' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float Dxx = 0.0, Dyy = 0.0, Dss = 0.0, Dxy = 0.0, Dxs = 0.0, Dys = 0.0;
                                                                 ^
modules/features2d/src/kaze/KAZEFeatures.cpp:584:11: style: The scope of the variable 'sumX' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float sumX = 0.0, sumY = 0.0, max = 0.0, ang1 = 0.0, ang2 = 0.0;
          ^
modules/features2d/src/kaze/KAZEFeatures.cpp:584:23: style: The scope of the variable 'sumY' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float sumX = 0.0, sumY = 0.0, max = 0.0, ang1 = 0.0, ang2 = 0.0;
                      ^
modules/features2d/src/kaze/KAZEFeatures.cpp:584:58: style: The scope of the variable 'ang2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float sumX = 0.0, sumY = 0.0, max = 0.0, ang1 = 0.0, ang2 = 0.0;
                                                         ^
modules/features2d/src/kaze/KAZEFeatures.cpp:662:48: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                                               ^
modules/features2d/src/kaze/KAZEFeatures.cpp:669:23: style: The scope of the variable 'cy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float cx = -0.5f, cy = 0.5f;
                      ^
modules/features2d/src/kaze/KAZEFeatures.cpp:791:32: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                               ^
modules/features2d/src/kaze/KAZEFeatures.cpp:797:23: style: The scope of the variable 'cy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float cx = -0.5f, cy = 0.5f;
                      ^
modules/features2d/src/kaze/KAZEFeatures.cpp:919:48: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                                               ^
modules/features2d/src/kaze/KAZEFeatures.cpp:926:23: style: The scope of the variable 'cy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float cx = -0.5f, cy = 0.5f;
                      ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1074:32: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                               ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1080:23: style: The scope of the variable 'cy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float cx = -0.5f, cy = 0.5f;
                      ^
modules/features2d/src/kaze/KAZEFeatures.cpp:39:41: style: Parameter 'options' can be declared with const [constParameter]
KAZEFeatures::KAZEFeatures(KAZEOptions& options)
                                        ^
modules/features2d/src/kaze/KAZEFeatures.cpp:510:44: style: Variable 'evolution' can be declared with const [constVariable]
                std::vector<TEvolution>   &evolution = *evolution_;
                                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:158:15: style: Variable 'lxx' is assigned a value that is never used. [unreadVariable]
    float lxx = 0.0, lxy = 0.0, lyy = 0.0;
              ^
modules/features2d/src/kaze/KAZEFeatures.cpp:158:26: style: Variable 'lxy' is assigned a value that is never used. [unreadVariable]
    float lxx = 0.0, lxy = 0.0, lyy = 0.0;
                         ^
modules/features2d/src/kaze/KAZEFeatures.cpp:158:37: style: Variable 'lyy' is assigned a value that is never used. [unreadVariable]
    float lxx = 0.0, lxy = 0.0, lyy = 0.0;
                                    ^
modules/features2d/src/kaze/KAZEFeatures.cpp:313:15: style: Variable 'level' is assigned a value that is never used. [unreadVariable]
    int level = 0;
              ^
modules/features2d/src/kaze/KAZEFeatures.cpp:314:16: style: Variable 'dist' is assigned a value that is never used. [unreadVariable]
    float dist = 0.0, smax = 3.0;
               ^
modules/features2d/src/kaze/KAZEFeatures.cpp:316:16: style: Variable 'left_x' is assigned a value that is never used. [unreadVariable]
    int left_x = 0, right_x = 0, up_y = 0, down_y = 0;
               ^
modules/features2d/src/kaze/KAZEFeatures.cpp:316:29: style: Variable 'right_x' is assigned a value that is never used. [unreadVariable]
    int left_x = 0, right_x = 0, up_y = 0, down_y = 0;
                            ^
modules/features2d/src/kaze/KAZEFeatures.cpp:316:39: style: Variable 'up_y' is assigned a value that is never used. [unreadVariable]
    int left_x = 0, right_x = 0, up_y = 0, down_y = 0;
                                      ^
modules/features2d/src/kaze/KAZEFeatures.cpp:316:51: style: Variable 'down_y' is assigned a value that is never used. [unreadVariable]
    int left_x = 0, right_x = 0, up_y = 0, down_y = 0;
                                                  ^
modules/features2d/src/kaze/KAZEFeatures.cpp:317:22: style: Variable 'is_extremum' is assigned a value that is never used. [unreadVariable]
    bool is_extremum = false, is_repeated = false, is_out = false;
                     ^
modules/features2d/src/kaze/KAZEFeatures.cpp:317:43: style: Variable 'is_repeated' is assigned a value that is never used. [unreadVariable]
    bool is_extremum = false, is_repeated = false, is_out = false;
                                          ^
modules/features2d/src/kaze/KAZEFeatures.cpp:317:59: style: Variable 'is_out' is assigned a value that is never used. [unreadVariable]
    bool is_extremum = false, is_repeated = false, is_out = false;
                                                          ^
modules/features2d/src/kaze/KAZEFeatures.cpp:343:20: style: Variable 'is_out' is assigned a value that is never used. [unreadVariable]
            is_out = false;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:400:11: style: Variable 'x' is assigned a value that is never used. [unreadVariable]
    int x = 0, y = 0;
          ^
modules/features2d/src/kaze/KAZEFeatures.cpp:400:18: style: Variable 'y' is assigned a value that is never used. [unreadVariable]
    int x = 0, y = 0;
                 ^
modules/features2d/src/kaze/KAZEFeatures.cpp:401:14: style: Variable 'Dx' is assigned a value that is never used. [unreadVariable]
    float Dx = 0.0, Dy = 0.0, Ds = 0.0, dsc = 0.0;
             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:401:24: style: Variable 'Dy' is assigned a value that is never used. [unreadVariable]
    float Dx = 0.0, Dy = 0.0, Ds = 0.0, dsc = 0.0;
                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:401:34: style: Variable 'Ds' is assigned a value that is never used. [unreadVariable]
    float Dx = 0.0, Dy = 0.0, Ds = 0.0, dsc = 0.0;
                                 ^
modules/features2d/src/kaze/KAZEFeatures.cpp:401:45: style: Variable 'dsc' is assigned a value that is never used. [unreadVariable]
    float Dx = 0.0, Dy = 0.0, Ds = 0.0, dsc = 0.0;
                                            ^
modules/features2d/src/kaze/KAZEFeatures.cpp:402:15: style: Variable 'Dxx' is assigned a value that is never used. [unreadVariable]
    float Dxx = 0.0, Dyy = 0.0, Dss = 0.0, Dxy = 0.0, Dxs = 0.0, Dys = 0.0;
              ^
modules/features2d/src/kaze/KAZEFeatures.cpp:402:26: style: Variable 'Dyy' is assigned a value that is never used. [unreadVariable]
    float Dxx = 0.0, Dyy = 0.0, Dss = 0.0, Dxy = 0.0, Dxs = 0.0, Dys = 0.0;
                         ^
modules/features2d/src/kaze/KAZEFeatures.cpp:402:37: style: Variable 'Dss' is assigned a value that is never used. [unreadVariable]
    float Dxx = 0.0, Dyy = 0.0, Dss = 0.0, Dxy = 0.0, Dxs = 0.0, Dys = 0.0;
                                    ^
modules/features2d/src/kaze/KAZEFeatures.cpp:402:48: style: Variable 'Dxy' is assigned a value that is never used. [unreadVariable]
    float Dxx = 0.0, Dyy = 0.0, Dss = 0.0, Dxy = 0.0, Dxs = 0.0, Dys = 0.0;
                                               ^
modules/features2d/src/kaze/KAZEFeatures.cpp:402:59: style: Variable 'Dxs' is assigned a value that is never used. [unreadVariable]
    float Dxx = 0.0, Dyy = 0.0, Dss = 0.0, Dxy = 0.0, Dxs = 0.0, Dys = 0.0;
                                                          ^
modules/features2d/src/kaze/KAZEFeatures.cpp:402:70: style: Variable 'Dys' is assigned a value that is never used. [unreadVariable]
    float Dxx = 0.0, Dyy = 0.0, Dss = 0.0, Dxy = 0.0, Dxs = 0.0, Dys = 0.0;
                                                                     ^
modules/features2d/src/kaze/KAZEFeatures.cpp:579:12: style: Variable 'ix' is assigned a value that is never used. [unreadVariable]
    int ix = 0, iy = 0, idx = 0, s = 0, level = 0;
           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:579:20: style: Variable 'iy' is assigned a value that is never used. [unreadVariable]
    int ix = 0, iy = 0, idx = 0, s = 0, level = 0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:580:39: style: Variable 'gweight' is assigned a value that is never used. [unreadVariable]
    float xf = 0.0, yf = 0.0, gweight = 0.0;
                                      ^
modules/features2d/src/kaze/KAZEFeatures.cpp:584:16: style: Variable 'sumX' is assigned a value that is never used. [unreadVariable]
    float sumX = 0.0, sumY = 0.0, max = 0.0, ang1 = 0.0, ang2 = 0.0;
               ^
modules/features2d/src/kaze/KAZEFeatures.cpp:584:28: style: Variable 'sumY' is assigned a value that is never used. [unreadVariable]
    float sumX = 0.0, sumY = 0.0, max = 0.0, ang1 = 0.0, ang2 = 0.0;
                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:584:63: style: Variable 'ang2' is assigned a value that is never used. [unreadVariable]
    float sumX = 0.0, sumY = 0.0, max = 0.0, ang1 = 0.0, ang2 = 0.0;
                                                              ^
modules/features2d/src/kaze/KAZEFeatures.cpp:658:14: style: Variable 'dx' is assigned a value that is never used. [unreadVariable]
    float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:658:24: style: Variable 'dy' is assigned a value that is never used. [unreadVariable]
    float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:658:35: style: Variable 'mdx' is assigned a value that is never used. [unreadVariable]
    float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                  ^
modules/features2d/src/kaze/KAZEFeatures.cpp:658:46: style: Variable 'mdy' is assigned a value that is never used. [unreadVariable]
    float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:658:62: style: Variable 'gauss_s1' is assigned a value that is never used. [unreadVariable]
    float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                                             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:658:78: style: Variable 'gauss_s2' is assigned a value that is never used. [unreadVariable]
    float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                                                             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:659:14: style: Variable 'rx' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:659:24: style: Variable 'ry' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:659:65: style: Variable 'ys' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                                                ^
modules/features2d/src/kaze/KAZEFeatures.cpp:659:75: style: Variable 'xs' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                                                          ^
modules/features2d/src/kaze/KAZEFeatures.cpp:660:20: style: Variable 'sample_x' is assigned a value that is never used. [unreadVariable]
    float sample_x = 0.0, sample_y = 0.0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:660:36: style: Variable 'sample_y' is assigned a value that is never used. [unreadVariable]
    float sample_x = 0.0, sample_y = 0.0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:661:12: style: Variable 'x1' is assigned a value that is never used. [unreadVariable]
    int x1 = 0, y1 = 0, sample_step = 0, pattern_size = 0;
           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:661:20: style: Variable 'y1' is assigned a value that is never used. [unreadVariable]
    int x1 = 0, y1 = 0, sample_step = 0, pattern_size = 0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:662:12: style: Variable 'x2' is assigned a value that is never used. [unreadVariable]
    int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:662:20: style: Variable 'y2' is assigned a value that is never used. [unreadVariable]
    int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:662:28: style: Variable 'kx' is assigned a value that is never used. [unreadVariable]
    int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:662:36: style: Variable 'ky' is assigned a value that is never used. [unreadVariable]
    int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:662:50: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                                                 ^
modules/features2d/src/kaze/KAZEFeatures.cpp:663:14: style: Variable 'fx' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:663:24: style: Variable 'fy' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:663:36: style: Variable 'res1' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:663:48: style: Variable 'res2' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                               ^
modules/features2d/src/kaze/KAZEFeatures.cpp:663:60: style: Variable 'res3' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:663:72: style: Variable 'res4' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                                                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:669:26: style: Variable 'cy' is assigned a value that is never used. [unreadVariable]
    float cx = -0.5f, cy = 0.5f;
                         ^
modules/features2d/src/kaze/KAZEFeatures.cpp:786:14: style: Variable 'dx' is assigned a value that is never used. [unreadVariable]
    float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:786:24: style: Variable 'dy' is assigned a value that is never used. [unreadVariable]
    float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:786:35: style: Variable 'mdx' is assigned a value that is never used. [unreadVariable]
    float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                  ^
modules/features2d/src/kaze/KAZEFeatures.cpp:786:46: style: Variable 'mdy' is assigned a value that is never used. [unreadVariable]
    float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:786:62: style: Variable 'gauss_s1' is assigned a value that is never used. [unreadVariable]
    float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                                             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:786:78: style: Variable 'gauss_s2' is assigned a value that is never used. [unreadVariable]
    float dx = 0.0, dy = 0.0, mdx = 0.0, mdy = 0.0, gauss_s1 = 0.0, gauss_s2 = 0.0;
                                                                             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:787:14: style: Variable 'rx' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:787:24: style: Variable 'ry' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:787:35: style: Variable 'rrx' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                  ^
modules/features2d/src/kaze/KAZEFeatures.cpp:787:46: style: Variable 'rry' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:787:87: style: Variable 'ys' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                                                                      ^
modules/features2d/src/kaze/KAZEFeatures.cpp:787:97: style: Variable 'xs' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                                                                                ^
modules/features2d/src/kaze/KAZEFeatures.cpp:788:20: style: Variable 'sample_x' is assigned a value that is never used. [unreadVariable]
    float sample_x = 0.0, sample_y = 0.0, co = 0.0, si = 0.0, angle = 0.0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:788:36: style: Variable 'sample_y' is assigned a value that is never used. [unreadVariable]
    float sample_x = 0.0, sample_y = 0.0, co = 0.0, si = 0.0, angle = 0.0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:789:14: style: Variable 'fx' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:789:24: style: Variable 'fy' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:789:36: style: Variable 'res1' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:789:48: style: Variable 'res2' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                               ^
modules/features2d/src/kaze/KAZEFeatures.cpp:789:60: style: Variable 'res3' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:789:72: style: Variable 'res4' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                                                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:790:12: style: Variable 'x1' is assigned a value that is never used. [unreadVariable]
    int x1 = 0, y1 = 0, x2 = 0, y2 = 0, sample_step = 0, pattern_size = 0;
           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:790:20: style: Variable 'y1' is assigned a value that is never used. [unreadVariable]
    int x1 = 0, y1 = 0, x2 = 0, y2 = 0, sample_step = 0, pattern_size = 0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:790:28: style: Variable 'x2' is assigned a value that is never used. [unreadVariable]
    int x1 = 0, y1 = 0, x2 = 0, y2 = 0, sample_step = 0, pattern_size = 0;
                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:790:36: style: Variable 'y2' is assigned a value that is never used. [unreadVariable]
    int x1 = 0, y1 = 0, x2 = 0, y2 = 0, sample_step = 0, pattern_size = 0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:791:12: style: Variable 'kx' is assigned a value that is never used. [unreadVariable]
    int kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:791:20: style: Variable 'ky' is assigned a value that is never used. [unreadVariable]
    int kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:791:34: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    int kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                                 ^
modules/features2d/src/kaze/KAZEFeatures.cpp:797:26: style: Variable 'cy' is assigned a value that is never used. [unreadVariable]
    float cx = -0.5f, cy = 0.5f;
                         ^
modules/features2d/src/kaze/KAZEFeatures.cpp:915:20: style: Variable 'gauss_s1' is assigned a value that is never used. [unreadVariable]
    float gauss_s1 = 0.0, gauss_s2 = 0.0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:915:36: style: Variable 'gauss_s2' is assigned a value that is never used. [unreadVariable]
    float gauss_s1 = 0.0, gauss_s2 = 0.0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:916:14: style: Variable 'rx' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:916:24: style: Variable 'ry' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:916:65: style: Variable 'ys' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                                                ^
modules/features2d/src/kaze/KAZEFeatures.cpp:916:75: style: Variable 'xs' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                                                          ^
modules/features2d/src/kaze/KAZEFeatures.cpp:917:20: style: Variable 'sample_x' is assigned a value that is never used. [unreadVariable]
    float sample_x = 0.0, sample_y = 0.0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:917:36: style: Variable 'sample_y' is assigned a value that is never used. [unreadVariable]
    float sample_x = 0.0, sample_y = 0.0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:918:12: style: Variable 'x1' is assigned a value that is never used. [unreadVariable]
    int x1 = 0, y1 = 0, sample_step = 0, pattern_size = 0;
           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:918:20: style: Variable 'y1' is assigned a value that is never used. [unreadVariable]
    int x1 = 0, y1 = 0, sample_step = 0, pattern_size = 0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:919:12: style: Variable 'x2' is assigned a value that is never used. [unreadVariable]
    int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:919:20: style: Variable 'y2' is assigned a value that is never used. [unreadVariable]
    int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:919:28: style: Variable 'kx' is assigned a value that is never used. [unreadVariable]
    int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:919:36: style: Variable 'ky' is assigned a value that is never used. [unreadVariable]
    int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:919:50: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    int x2 = 0, y2 = 0, kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                                                 ^
modules/features2d/src/kaze/KAZEFeatures.cpp:920:14: style: Variable 'fx' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:920:24: style: Variable 'fy' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:920:36: style: Variable 'res1' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:920:48: style: Variable 'res2' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                               ^
modules/features2d/src/kaze/KAZEFeatures.cpp:920:60: style: Variable 'res3' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:920:72: style: Variable 'res4' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                                                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:921:15: style: Variable 'dxp' is assigned a value that is never used. [unreadVariable]
    float dxp = 0.0, dyp = 0.0, mdxp = 0.0, mdyp = 0.0;
              ^
modules/features2d/src/kaze/KAZEFeatures.cpp:921:26: style: Variable 'dyp' is assigned a value that is never used. [unreadVariable]
    float dxp = 0.0, dyp = 0.0, mdxp = 0.0, mdyp = 0.0;
                         ^
modules/features2d/src/kaze/KAZEFeatures.cpp:921:38: style: Variable 'mdxp' is assigned a value that is never used. [unreadVariable]
    float dxp = 0.0, dyp = 0.0, mdxp = 0.0, mdyp = 0.0;
                                     ^
modules/features2d/src/kaze/KAZEFeatures.cpp:921:50: style: Variable 'mdyp' is assigned a value that is never used. [unreadVariable]
    float dxp = 0.0, dyp = 0.0, mdxp = 0.0, mdyp = 0.0;
                                                 ^
modules/features2d/src/kaze/KAZEFeatures.cpp:922:15: style: Variable 'dxn' is assigned a value that is never used. [unreadVariable]
    float dxn = 0.0, dyn = 0.0, mdxn = 0.0, mdyn = 0.0;
              ^
modules/features2d/src/kaze/KAZEFeatures.cpp:922:26: style: Variable 'dyn' is assigned a value that is never used. [unreadVariable]
    float dxn = 0.0, dyn = 0.0, mdxn = 0.0, mdyn = 0.0;
                         ^
modules/features2d/src/kaze/KAZEFeatures.cpp:922:38: style: Variable 'mdxn' is assigned a value that is never used. [unreadVariable]
    float dxn = 0.0, dyn = 0.0, mdxn = 0.0, mdyn = 0.0;
                                     ^
modules/features2d/src/kaze/KAZEFeatures.cpp:922:50: style: Variable 'mdyn' is assigned a value that is never used. [unreadVariable]
    float dxn = 0.0, dyn = 0.0, mdxn = 0.0, mdyn = 0.0;
                                                 ^
modules/features2d/src/kaze/KAZEFeatures.cpp:926:26: style: Variable 'cy' is assigned a value that is never used. [unreadVariable]
    float cx = -0.5f, cy = 0.5f;
                         ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1067:20: style: Variable 'gauss_s1' is assigned a value that is never used. [unreadVariable]
    float gauss_s1 = 0.0, gauss_s2 = 0.0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1067:36: style: Variable 'gauss_s2' is assigned a value that is never used. [unreadVariable]
    float gauss_s1 = 0.0, gauss_s2 = 0.0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1068:14: style: Variable 'rx' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1068:24: style: Variable 'ry' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1068:35: style: Variable 'rrx' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                  ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1068:46: style: Variable 'rry' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1068:87: style: Variable 'ys' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                                                                      ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1068:97: style: Variable 'xs' is assigned a value that is never used. [unreadVariable]
    float rx = 0.0, ry = 0.0, rrx = 0.0, rry = 0.0, len = 0.0, xf = 0.0, yf = 0.0, ys = 0.0, xs = 0.0;
                                                                                                ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1069:20: style: Variable 'sample_x' is assigned a value that is never used. [unreadVariable]
    float sample_x = 0.0, sample_y = 0.0, co = 0.0, si = 0.0, angle = 0.0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1069:36: style: Variable 'sample_y' is assigned a value that is never used. [unreadVariable]
    float sample_x = 0.0, sample_y = 0.0, co = 0.0, si = 0.0, angle = 0.0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1070:14: style: Variable 'fx' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
             ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1070:24: style: Variable 'fy' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1070:36: style: Variable 'res1' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1070:48: style: Variable 'res2' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                               ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1070:60: style: Variable 'res3' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1070:72: style: Variable 'res4' is assigned a value that is never used. [unreadVariable]
    float fx = 0.0, fy = 0.0, res1 = 0.0, res2 = 0.0, res3 = 0.0, res4 = 0.0;
                                                                       ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1071:15: style: Variable 'dxp' is assigned a value that is never used. [unreadVariable]
    float dxp = 0.0, dyp = 0.0, mdxp = 0.0, mdyp = 0.0;
              ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1071:26: style: Variable 'dyp' is assigned a value that is never used. [unreadVariable]
    float dxp = 0.0, dyp = 0.0, mdxp = 0.0, mdyp = 0.0;
                         ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1071:38: style: Variable 'mdxp' is assigned a value that is never used. [unreadVariable]
    float dxp = 0.0, dyp = 0.0, mdxp = 0.0, mdyp = 0.0;
                                     ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1071:50: style: Variable 'mdyp' is assigned a value that is never used. [unreadVariable]
    float dxp = 0.0, dyp = 0.0, mdxp = 0.0, mdyp = 0.0;
                                                 ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1072:15: style: Variable 'dxn' is assigned a value that is never used. [unreadVariable]
    float dxn = 0.0, dyn = 0.0, mdxn = 0.0, mdyn = 0.0;
              ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1072:26: style: Variable 'dyn' is assigned a value that is never used. [unreadVariable]
    float dxn = 0.0, dyn = 0.0, mdxn = 0.0, mdyn = 0.0;
                         ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1072:38: style: Variable 'mdxn' is assigned a value that is never used. [unreadVariable]
    float dxn = 0.0, dyn = 0.0, mdxn = 0.0, mdyn = 0.0;
                                     ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1072:50: style: Variable 'mdyn' is assigned a value that is never used. [unreadVariable]
    float dxn = 0.0, dyn = 0.0, mdxn = 0.0, mdyn = 0.0;
                                                 ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1073:12: style: Variable 'x1' is assigned a value that is never used. [unreadVariable]
    int x1 = 0, y1 = 0, x2 = 0, y2 = 0, sample_step = 0, pattern_size = 0;
           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1073:20: style: Variable 'y1' is assigned a value that is never used. [unreadVariable]
    int x1 = 0, y1 = 0, x2 = 0, y2 = 0, sample_step = 0, pattern_size = 0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1073:28: style: Variable 'x2' is assigned a value that is never used. [unreadVariable]
    int x1 = 0, y1 = 0, x2 = 0, y2 = 0, sample_step = 0, pattern_size = 0;
                           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1073:36: style: Variable 'y2' is assigned a value that is never used. [unreadVariable]
    int x1 = 0, y1 = 0, x2 = 0, y2 = 0, sample_step = 0, pattern_size = 0;
                                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1074:12: style: Variable 'kx' is assigned a value that is never used. [unreadVariable]
    int kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
           ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1074:20: style: Variable 'ky' is assigned a value that is never used. [unreadVariable]
    int kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                   ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1074:34: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    int kx = 0, ky = 0, i = 0, j = 0, dcount = 0;
                                 ^
modules/features2d/src/kaze/KAZEFeatures.cpp:1080:26: style: Variable 'cy' is assigned a value that is never used. [unreadVariable]
    float cx = -0.5f, cy = 0.5f;
                         ^
modules/features2d/src/kaze/fed.cpp:128:7: style: The scope of the variable 'kappa' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int kappa = 0, prime = 0;
      ^
modules/features2d/src/kaze/fed.cpp:128:18: style: The scope of the variable 'prime' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int kappa = 0, prime = 0;
                 ^
modules/features2d/src/kaze/fed.cpp:128:13: style: Variable 'kappa' is assigned a value that is never used. [unreadVariable]
  int kappa = 0, prime = 0;
            ^
modules/features2d/src/kaze/fed.cpp:128:24: style: Variable 'prime' is assigned a value that is never used. [unreadVariable]
  int kappa = 0, prime = 0;
                       ^
modules/features2d/src/kaze/fed.cpp:165:17: style: Variable 'is_prime' is assigned a value that is never used. [unreadVariable]
  bool is_prime = false;
                ^
modules/features2d/src/kaze/nldiffusion_functions.cpp:232:14: style: Variable 'nbin' is assigned a value that is never used. [unreadVariable]
    int nbin = 0, nelements = 0, nthreshold = 0, k = 0;
             ^
modules/features2d/src/kaze/nldiffusion_functions.cpp:233:29: style: Variable 'modg' is assigned a value that is never used. [unreadVariable]
    float kperc = 0.0, modg = 0.0;
                            ^
modules/features2d/src/keypoint.cpp:49:5: style: Struct 'KeypointResponseGreaterThanThreshold' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    KeypointResponseGreaterThanThreshold(float _value) :
    ^
modules/features2d/src/keypoint.cpp:94:5: style: Struct 'RoiPredicate' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    RoiPredicate( const Rect& _r ) : r(_r)
    ^
modules/features2d/src/keypoint.cpp:146:5: style: Class 'MaskPredicate' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    MaskPredicate( const Mat& _mask ) : mask(_mask) {}
    ^
modules/features2d/src/keypoint.cpp:169:5: style: Struct 'KeyPoint_LessThan' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    KeyPoint_LessThan(const std::vector<KeyPoint>& _kp) : kp(&_kp) {}
    ^
modules/features2d/src/matchers.cpp:405:42: style: Same iterators expression are used for algorithm. [sameIteratorExpression]
    std::copy( collection.startIdxs.begin(), collection.startIdxs.begin(), startIdxs.begin() );
                                         ^
modules/features2d/src/mser.cpp:111:28: warning: Suspicious pointer subtraction. Did you intend to write '->'? [thisSubtraction]
            return imgptr0[this - ptr0] ^ mask;
                           ^
modules/features2d/src/mser.cpp:107:9: style: Struct 'Pixel' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Pixel(int _val) : val(_val) {}
        ^
modules/features2d/src/mser.cpp:918:21: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    MSCRNode* map = (MSCRNode*)cvAlloc( src.cols*src.rows*sizeof(map[0]) );
                    ^
modules/features2d/src/mser.cpp:920:22: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    MSCREdge* edge = (MSCREdge*)cvAlloc( Ne*sizeof(edge[0]) );
                     ^
modules/features2d/src/mser.cpp:921:22: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    TempMSCR* mscr = (TempMSCR*)cvAlloc( src.cols*src.rows*sizeof(mscr[0]) );
                     ^
modules/features2d/src/opencl/brute_force_match.cl:265:16: warning: Redundant assignment of 'result' to itself. [selfAssignment]
        result = DIST_RES(result);
               ^
modules/features2d/src/opencl/brute_force_match.cl:469:16: warning: Redundant assignment of 'result' to itself. [selfAssignment]
        result = DIST_RES(result);
               ^
modules/features2d/src/opencl/fast.cl:66:13: style: Unused variable: k [unusedVariable]
        int k, tofs, v0, v1;
            ^
modules/features2d/src/orb.cpp:858:24: style: Unused variable: ukeypoints_buf [unusedVariable]
    std::vector<Vec3i> ukeypoints_buf;
                       ^
modules/features2d/src/orb.cpp:918:13: warning: Identical inner 'if' condition is always true (outer condition is 'useOCL' and inner condition is 'useOCL'). [identicalInnerCondition]
        if( useOCL )
            ^
modules/features2d/src/orb.cpp:915:9: note: outer condition: useOCL
    if( useOCL )
        ^
modules/features2d/src/orb.cpp:918:13: note: identical inner condition: useOCL
        if( useOCL )
            ^
modules/features2d/test/ocl/test_brute_force_matcher.cpp:117:1: error: syntax error [syntaxError]
OCL_TEST_P(BruteForceMatcher, Match_Single)
^
modules/features2d/test/ocl/test_brute_force_matcher.cpp:115:1: error: syntax error [syntaxError]
OCL_TEST_P(BruteForceMatcher, DISABLED_Match_Single)
^
modules/features2d/test/ocl/test_feature2d.cpp:47:1: error: syntax error [syntaxError]
OCL_TEST_P(Feature2DFixture, KeypointsSame)
^
modules/features2d/test/test_descriptors_regression.cpp:107:46: performance: Parameter '_name' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
    CV_DescriptorExtractorTest( const string _name, DistanceType _maxDist, const Ptr<DescriptorExtractor>& _dextractor,
                                             ^
modules/features2d/test/test_keypoints.cpp:58:5: style: Class 'CV_FeatureDetectorKeypointsTest' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_FeatureDetectorKeypointsTest(const Ptr<FeatureDetector>& _detector) :
    ^
modules/features2d/test/test_matchers_algorithmic.cpp:278:25: style: The scope of the variable 'match' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                DMatch& match = matches[i];
                        ^
modules/features2d/test/test_matchers_algorithmic.cpp:383:33: style: The scope of the variable 'match' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                        DMatch& match = matches[i][k];
                                ^
modules/features2d/test/test_matchers_algorithmic.cpp:487:29: style: The scope of the variable 'match' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                    DMatch& match = matches[i][k];
                            ^
modules/features2d/test/test_nearestneighbors.cpp:107:10: style: Redundant initialization for 'code'. The initialized value is overwritten before it is read. [redundantInitialization]
    code = findNeighbors( points, results );
         ^
modules/features2d/test/test_nearestneighbors.cpp:90:14: note: code is initialized
    int code = cvtest::TS::OK;
             ^
modules/features2d/test/test_nearestneighbors.cpp:107:10: note: code is overwritten
    code = findNeighbors( points, results );
         ^
modules/features2d/test/test_nearestneighbors.cpp:173:18: style: The function 'releaseModel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void releaseModel();
                 ^
modules/features2d/test/test_nearestneighbors.cpp:75:18: note: Virtual function in base class
    virtual void releaseModel() = 0;
                 ^
modules/features2d/test/test_nearestneighbors.cpp:173:18: note: Function in derived class
    virtual void releaseModel();
                 ^
modules/features2d/test/test_nearestneighbors.cpp:261:18: style: The function 'createModel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void createModel( const Mat& data ) { createIndex( data, LinearIndexParams() ); }
                 ^
modules/features2d/test/test_nearestneighbors.cpp:70:18: note: Virtual function in base class
    virtual void createModel( const Mat& data ) = 0;
                 ^
modules/features2d/test/test_nearestneighbors.cpp:261:18: note: Function in derived class
    virtual void createModel( const Mat& data ) { createIndex( data, LinearIndexParams() ); }
                 ^
modules/features2d/test/test_nearestneighbors.cpp:262:17: style: The function 'findNeighbors' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int findNeighbors( Mat& points, Mat& neighbors ) { return knnSearch( points, neighbors ); }
                ^
modules/features2d/test/test_nearestneighbors.cpp:71:17: note: Virtual function in base class
    virtual int findNeighbors( Mat& points, Mat& neighbors ) = 0;
                ^
modules/features2d/test/test_nearestneighbors.cpp:262:17: note: Function in derived class
    virtual int findNeighbors( Mat& points, Mat& neighbors ) { return knnSearch( points, neighbors ); }
                ^
modules/features2d/test/test_nearestneighbors.cpp:271:18: style: The function 'createModel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void createModel( const Mat& data ) { createIndex( data, KMeansIndexParams() ); }
                 ^
modules/features2d/test/test_nearestneighbors.cpp:70:18: note: Virtual function in base class
    virtual void createModel( const Mat& data ) = 0;
                 ^
modules/features2d/test/test_nearestneighbors.cpp:271:18: note: Function in derived class
    virtual void createModel( const Mat& data ) { createIndex( data, KMeansIndexParams() ); }
                 ^
modules/features2d/test/test_nearestneighbors.cpp:272:17: style: The function 'findNeighbors' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int findNeighbors( Mat& points, Mat& neighbors ) { return radiusSearch( points, neighbors ); }
                ^
modules/features2d/test/test_nearestneighbors.cpp:71:17: note: Virtual function in base class
    virtual int findNeighbors( Mat& points, Mat& neighbors ) = 0;
                ^
modules/features2d/test/test_nearestneighbors.cpp:272:17: note: Function in derived class
    virtual int findNeighbors( Mat& points, Mat& neighbors ) { return radiusSearch( points, neighbors ); }
                ^
modules/features2d/test/test_nearestneighbors.cpp:281:18: style: The function 'createModel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void createModel( const Mat& data ) { createIndex( data, KDTreeIndexParams() ); }
                 ^
modules/features2d/test/test_nearestneighbors.cpp:70:18: note: Virtual function in base class
    virtual void createModel( const Mat& data ) = 0;
                 ^
modules/features2d/test/test_nearestneighbors.cpp:281:18: note: Function in derived class
    virtual void createModel( const Mat& data ) { createIndex( data, KDTreeIndexParams() ); }
                 ^
modules/features2d/test/test_nearestneighbors.cpp:282:17: style: The function 'findNeighbors' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int findNeighbors( Mat& points, Mat& neighbors ) { return radiusSearch( points, neighbors ); }
                ^
modules/features2d/test/test_nearestneighbors.cpp:71:17: note: Virtual function in base class
    virtual int findNeighbors( Mat& points, Mat& neighbors ) = 0;
                ^
modules/features2d/test/test_nearestneighbors.cpp:282:17: note: Function in derived class
    virtual int findNeighbors( Mat& points, Mat& neighbors ) { return radiusSearch( points, neighbors ); }
                ^
modules/features2d/test/test_nearestneighbors.cpp:291:18: style: The function 'createModel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void createModel( const Mat& data ) { createIndex( data, CompositeIndexParams() ); }
                 ^
modules/features2d/test/test_nearestneighbors.cpp:70:18: note: Virtual function in base class
    virtual void createModel( const Mat& data ) = 0;
                 ^
modules/features2d/test/test_nearestneighbors.cpp:291:18: note: Function in derived class
    virtual void createModel( const Mat& data ) { createIndex( data, CompositeIndexParams() ); }
                 ^
modules/features2d/test/test_nearestneighbors.cpp:292:17: style: The function 'findNeighbors' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int findNeighbors( Mat& points, Mat& neighbors ) { return knnSearch( points, neighbors ); }
                ^
modules/features2d/test/test_nearestneighbors.cpp:71:17: note: Virtual function in base class
    virtual int findNeighbors( Mat& points, Mat& neighbors ) = 0;
                ^
modules/features2d/test/test_nearestneighbors.cpp:292:17: note: Function in derived class
    virtual int findNeighbors( Mat& points, Mat& neighbors ) { return knnSearch( points, neighbors ); }
                ^
modules/features2d/test/test_nearestneighbors.cpp:301:18: style: The function 'createModel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void createModel( const Mat& data ) { createIndex( data, AutotunedIndexParams() ); }
                 ^
modules/features2d/test/test_nearestneighbors.cpp:70:18: note: Virtual function in base class
    virtual void createModel( const Mat& data ) = 0;
                 ^
modules/features2d/test/test_nearestneighbors.cpp:301:18: note: Function in derived class
    virtual void createModel( const Mat& data ) { createIndex( data, AutotunedIndexParams() ); }
                 ^
modules/features2d/test/test_nearestneighbors.cpp:302:17: style: The function 'findNeighbors' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int findNeighbors( Mat& points, Mat& neighbors ) { return knnSearch( points, neighbors ); }
                ^
modules/features2d/test/test_nearestneighbors.cpp:71:17: note: Virtual function in base class
    virtual int findNeighbors( Mat& points, Mat& neighbors ) = 0;
                ^
modules/features2d/test/test_nearestneighbors.cpp:302:17: note: Function in derived class
    virtual int findNeighbors( Mat& points, Mat& neighbors ) { return knnSearch( points, neighbors ); }
                ^
modules/features2d/test/test_nearestneighbors.cpp:310:18: style: The function 'createModel' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void createModel( const Mat& data );
                 ^
modules/features2d/test/test_nearestneighbors.cpp:70:18: note: Virtual function in base class
    virtual void createModel( const Mat& data ) = 0;
                 ^
modules/features2d/test/test_nearestneighbors.cpp:310:18: note: Function in derived class
    virtual void createModel( const Mat& data );
                 ^
modules/features2d/test/test_nearestneighbors.cpp:311:17: style: The function 'findNeighbors' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int findNeighbors( Mat& points, Mat& neighbors ) { return knnSearch( points, neighbors ); }
                ^
modules/features2d/test/test_nearestneighbors.cpp:71:17: note: Virtual function in base class
    virtual int findNeighbors( Mat& points, Mat& neighbors ) = 0;
                ^
modules/features2d/test/test_nearestneighbors.cpp:311:17: note: Function in derived class
    virtual int findNeighbors( Mat& points, Mat& neighbors ) { return knnSearch( points, neighbors ); }
                ^
modules/highgui/src/roiSelector.cpp:13:1: style: The class 'ROISelector' does not have a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class ROISelector
^
modules/highgui/src/roiSelector.cpp:189:12: error: Uninitialized variable: selector [uninitvar]
    return selector.select("ROI selector", img.getMat(), showCrosshair, fromCenter);
           ^
modules/highgui/src/roiSelector.cpp:195:12: error: Uninitialized variable: selector [uninitvar]
    return selector.select(windowName, img.getMat(), showCrosshair, fromCenter);
           ^
modules/highgui/src/window_QT.cpp:1288:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'callback' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    callback = NULL;
    ^
modules/highgui/src/window_QT.cpp:1289:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'callback2' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    callback2 = on_change;
    ^
modules/highgui/src/window_QT.cpp:1298:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'callback' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    callback = on_change;
    ^
modules/highgui/src/window_QT.cpp:1299:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'callback2' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    callback2 = NULL;
    ^
modules/highgui/src/window_QT.cpp:1474:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'button_name' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    button_name = arg2;
    ^
modules/highgui/src/window_QT.cpp:1475:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'callback' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    callback = arg3;
    ^
modules/highgui/src/window_QT.cpp:1496:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'button_name' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    button_name = arg2;
    ^
modules/highgui/src/window_QT.cpp:1497:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'callback' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    callback = arg3;
    ^
modules/highgui/src/window_QT.cpp:1519:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'button_name' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    button_name = arg2;
    ^
modules/highgui/src/window_QT.cpp:1520:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'callback' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    callback = arg3;
    ^
modules/highgui/src/window_QT.cpp:2323:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'mouseCallback' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    mouseCallback = 0;
    ^
modules/highgui/src/window_QT.cpp:2403:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'centralWidget' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    centralWidget = arg;
    ^
modules/highgui/src/window_QT.h:290:5: style: Class 'CvWindow' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CvWindow(QString arg2, int flag = CV_WINDOW_NORMAL);
    ^
modules/highgui/src/window_QT.h:416:10: style: The function 'setMouseCallBack' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void setMouseCallBack(CvMouseCallback callback, void* param);
         ^
modules/highgui/src/window_QT.h:391:18: note: Virtual function in base class
    virtual void setMouseCallBack(CvMouseCallback callback, void* param) = 0;
                 ^
modules/highgui/src/window_QT.h:416:10: note: Function in derived class
    void setMouseCallBack(CvMouseCallback callback, void* param);
         ^
modules/highgui/src/window_QT.h:485:14: style: The function 'getWidget' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    QWidget* getWidget();
             ^
modules/highgui/src/window_QT.h:389:22: note: Virtual function in base class
    virtual QWidget* getWidget() = 0;
                     ^
modules/highgui/src/window_QT.h:485:14: note: Function in derived class
    QWidget* getWidget();
             ^
modules/highgui/src/window_QT.h:487:10: style: The function 'writeSettings' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void writeSettings(QSettings& settings);
         ^
modules/highgui/src/window_QT.h:393:18: note: Virtual function in base class
    virtual void writeSettings(QSettings& settings) = 0;
                 ^
modules/highgui/src/window_QT.h:487:10: note: Function in derived class
    void writeSettings(QSettings& settings);
         ^
modules/highgui/src/window_QT.h:488:10: style: The function 'readSettings' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void readSettings(QSettings& settings);
         ^
modules/highgui/src/window_QT.h:394:18: note: Virtual function in base class
    virtual void readSettings(QSettings& settings) = 0;
                 ^
modules/highgui/src/window_QT.h:488:10: note: Function in derived class
    void readSettings(QSettings& settings);
         ^
modules/highgui/src/window_QT.h:490:12: style: The function 'getRatio' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getRatio();
           ^
modules/highgui/src/window_QT.h:396:20: note: Virtual function in base class
    virtual double getRatio() = 0;
                   ^
modules/highgui/src/window_QT.h:490:12: note: Function in derived class
    double getRatio();
           ^
modules/highgui/src/window_QT.h:491:10: style: The function 'setRatio' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void setRatio(int flags);
         ^
modules/highgui/src/window_QT.h:397:18: note: Virtual function in base class
    virtual void setRatio(int flags) = 0;
                 ^
modules/highgui/src/window_QT.h:491:10: note: Function in derived class
    void setRatio(int flags);
         ^
modules/highgui/src/window_QT.h:493:10: style: The function 'updateImage' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void updateImage(const CvArr* arr);
         ^
modules/highgui/src/window_QT.h:399:18: note: Virtual function in base class
    virtual void updateImage(const CvArr* arr) = 0;
                 ^
modules/highgui/src/window_QT.h:493:10: note: Function in derived class
    void updateImage(const CvArr* arr);
         ^
modules/highgui/src/window_QT.h:495:10: style: The function 'startDisplayInfo' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void startDisplayInfo(QString text, int delayms);
         ^
modules/highgui/src/window_QT.h:401:18: note: Virtual function in base class
    virtual void startDisplayInfo(QString text, int delayms) = 0;
                 ^
modules/highgui/src/window_QT.h:495:10: note: Function in derived class
    void startDisplayInfo(QString text, int delayms);
         ^
modules/highgui/src/window_QT.h:497:10: style: The function 'setOpenGlDrawCallback' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void setOpenGlDrawCallback(CvOpenGlDrawCallback callback, void* userdata);
         ^
modules/highgui/src/window_QT.h:403:18: note: Virtual function in base class
    virtual void setOpenGlDrawCallback(CvOpenGlDrawCallback callback, void* userdata) = 0;
                 ^
modules/highgui/src/window_QT.h:497:10: note: Function in derived class
    void setOpenGlDrawCallback(CvOpenGlDrawCallback callback, void* userdata);
         ^
modules/highgui/src/window_QT.h:498:10: style: The function 'makeCurrentOpenGlContext' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void makeCurrentOpenGlContext();
         ^
modules/highgui/src/window_QT.h:404:18: note: Virtual function in base class
    virtual void makeCurrentOpenGlContext() = 0;
                 ^
modules/highgui/src/window_QT.h:498:10: note: Function in derived class
    void makeCurrentOpenGlContext();
         ^
modules/highgui/src/window_QT.h:499:10: style: The function 'updateGl' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void updateGl();
         ^
modules/highgui/src/window_QT.h:405:18: note: Virtual function in base class
    virtual void updateGl() = 0;
                 ^
modules/highgui/src/window_QT.h:499:10: note: Function in derived class
    void updateGl();
         ^
modules/highgui/src/window_QT.h:501:10: style: The function 'setSize' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void setSize(QSize size_);
         ^
modules/highgui/src/window_QT.h:407:18: note: Virtual function in base class
    virtual void setSize(QSize size_) = 0;
                 ^
modules/highgui/src/window_QT.h:501:10: note: Function in derived class
    void setSize(QSize size_);
         ^
modules/highgui/src/window_QT.h:567:10: style: The function 'icvmouseProcessing' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void icvmouseProcessing(QPointF pt, int cv_event, int flags);
         ^
modules/highgui/src/window_QT.h:421:18: note: Virtual function in base class
    virtual void icvmouseProcessing(QPointF pt, int cv_event, int flags);
                 ^
modules/highgui/src/window_QT.h:567:10: note: Function in derived class
    void icvmouseProcessing(QPointF pt, int cv_event, int flags);
         ^
modules/highgui/src/window_QT.cpp:395:32: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            CvWinModel* temp = (CvWinModel*) widget;
                               ^
modules/highgui/src/window_QT.cpp:399:31: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                CvWindow* w = (CvWindow*) temp;
                              ^
modules/highgui/src/window_QT.cpp:422:20: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        CvBar* t = (CvBar*) layout->layout()->itemAt(i);
                   ^
modules/highgui/src/window_QT.cpp:448:20: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            return (CvTrackbar*) icvFindBarByName(w->myBarLayout, nameQt, type_CvTrackbar);
                   ^
modules/highgui/src/window_QT.cpp:455:24: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                return (CvTrackbar*) result;
                       ^
modules/highgui/src/window_QT.cpp:457:20: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            return (CvTrackbar*) icvFindBarByName(global_control_panel->myLayout, nameQt, type_CvTrackbar);
                   ^
modules/highgui/src/window_QT.cpp:465:16: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        return (CvTrackbar*) icvFindBarByName(layout, nameQt, type_CvTrackbar);
               ^
modules/highgui/src/window_QT.cpp:559:13: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    return ((CvWindow*)window_handle)->objectName().toLatin1().data();
            ^
modules/highgui/src/window_QT.cpp:1127:32: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            CvWinModel* temp = (CvWinModel*) widget;
                               ^
modules/highgui/src/window_QT.cpp:1130:31: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                CvWindow* w = (CvWindow*) widget;
                              ^
modules/highgui/src/window_QT.cpp:1155:26: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        CvBar* lastbar = (CvBar*) global_control_panel->myLayout->itemAt(global_control_panel->myLayout->count() - 1);
                         ^
modules/highgui/src/window_QT.cpp:1162:17: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            b = (CvButtonbar*) lastbar;
                ^
modules/highgui/src/window_QT.cpp:2158:24: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            CvBar* t = (CvBar*) global_control_panel->myLayout->layout()->itemAt(i);
                       ^
modules/highgui/src/window_QT.cpp:2164:22: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                    ((CvTrackbar*)t)->slider->setValue(settings.value("valuebar").toInt());
                     ^
modules/highgui/src/window_QT.cpp:2171:34: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                if ( subsize == ((CvButtonbar*)t)->layout()->count() )
                                 ^
modules/highgui/src/window_QT.cpp:2172:38: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                    icvLoadButtonbar((CvButtonbar*)t,&settings);
                                     ^
modules/highgui/src/window_QT.cpp:2191:20: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        CvBar* t = (CvBar*) global_control_panel->myLayout->layout()->itemAt(i);
                   ^
modules/highgui/src/window_QT.cpp:2196:43: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            settings.setValue("valuebar",((CvTrackbar*)t)->slider->value());
                                          ^
modules/highgui/src/window_QT.cpp:2201:30: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            icvSaveButtonbar((CvButtonbar*)t,&settings);
                             ^
modules/highgui/src/window_QT.cpp:2221:36: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            CvPushButton* button = (CvPushButton*) temp;
                                   ^
modules/highgui/src/window_QT.cpp:2227:34: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            CvCheckBox* button = (CvCheckBox*) temp;
                                 ^
modules/highgui/src/window_QT.cpp:2233:37: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            CvRadioButton* button = (CvRadioButton*) temp;
                                    ^
modules/highgui/src/window_QT.cpp:2252:36: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            CvPushButton* button = (CvPushButton*) temp;
                                   ^
modules/highgui/src/window_QT.cpp:2259:34: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            CvCheckBox* button = (CvCheckBox*) temp;
                                 ^
modules/highgui/src/window_QT.cpp:2266:37: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            CvRadioButton* button = (CvRadioButton*) temp;
                                    ^
modules/highgui/src/window_QT.cpp:2288:29: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            CvTrackbar* t = (CvTrackbar*) myBarLayout->layout()->itemAt(i);
                            ^
modules/highgui/src/window_QT.cpp:2308:25: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        CvTrackbar* t = (CvTrackbar*) myBarLayout->layout()->itemAt(i);
                        ^
modules/highgui/src/window_QT.cpp:1613:28: warning: Function 'CvWindow' argument order different: declaration 'arg2, flag' definition 'name, arg2' [funcArgOrderDifferent]
CvWindow::CvWindow(QString name, int arg2)
                           ^
modules/highgui/src/window_QT.h:290:22: note: Function 'CvWindow' argument order different: declaration 'arg2, flag' definition 'name, arg2'
    CvWindow(QString arg2, int flag = CV_WINDOW_NORMAL);
                     ^
modules/highgui/src/window_QT.cpp:1613:28: note: Function 'CvWindow' argument order different: declaration 'arg2, flag' definition 'name, arg2'
CvWindow::CvWindow(QString name, int arg2)
                           ^
modules/highgui/src/window_QT.cpp:374:25: style: Variable 'future' is assigned a value that is never used. [unreadVariable]
    QFuture<int> future = QtConcurrent::run(pt2Func, argc, argv);
                        ^
modules/highgui/src/window_QT.cpp:3137:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'glDrawCallback' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    glDrawCallback = 0;
    ^
modules/highgui/src/window_QT.h:436:14: style: The function 'getWidget' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    QWidget* getWidget();
             ^
modules/highgui/src/window_QT.h:389:22: note: Virtual function in base class
    virtual QWidget* getWidget() = 0;
                     ^
modules/highgui/src/window_QT.h:436:14: note: Function in derived class
    QWidget* getWidget();
             ^
modules/highgui/src/window_QT.h:438:10: style: The function 'writeSettings' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void writeSettings(QSettings& settings);
         ^
modules/highgui/src/window_QT.h:393:18: note: Virtual function in base class
    virtual void writeSettings(QSettings& settings) = 0;
                 ^
modules/highgui/src/window_QT.h:438:10: note: Function in derived class
    void writeSettings(QSettings& settings);
         ^
modules/highgui/src/window_QT.h:439:10: style: The function 'readSettings' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void readSettings(QSettings& settings);
         ^
modules/highgui/src/window_QT.h:394:18: note: Virtual function in base class
    virtual void readSettings(QSettings& settings) = 0;
                 ^
modules/highgui/src/window_QT.h:439:10: note: Function in derived class
    void readSettings(QSettings& settings);
         ^
modules/highgui/src/window_QT.h:441:12: style: The function 'getRatio' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    double getRatio();
           ^
modules/highgui/src/window_QT.h:396:20: note: Virtual function in base class
    virtual double getRatio() = 0;
                   ^
modules/highgui/src/window_QT.h:441:12: note: Function in derived class
    double getRatio();
           ^
modules/highgui/src/window_QT.h:442:10: style: The function 'setRatio' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void setRatio(int flags);
         ^
modules/highgui/src/window_QT.h:397:18: note: Virtual function in base class
    virtual void setRatio(int flags) = 0;
                 ^
modules/highgui/src/window_QT.h:442:10: note: Function in derived class
    void setRatio(int flags);
         ^
modules/highgui/src/window_QT.h:444:10: style: The function 'updateImage' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void updateImage(const CvArr* arr);
         ^
modules/highgui/src/window_QT.h:399:18: note: Virtual function in base class
    virtual void updateImage(const CvArr* arr) = 0;
                 ^
modules/highgui/src/window_QT.h:444:10: note: Function in derived class
    void updateImage(const CvArr* arr);
         ^
modules/highgui/src/window_QT.h:446:10: style: The function 'startDisplayInfo' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void startDisplayInfo(QString text, int delayms);
         ^
modules/highgui/src/window_QT.h:401:18: note: Virtual function in base class
    virtual void startDisplayInfo(QString text, int delayms) = 0;
                 ^
modules/highgui/src/window_QT.h:446:10: note: Function in derived class
    void startDisplayInfo(QString text, int delayms);
         ^
modules/highgui/src/window_QT.h:448:10: style: The function 'setOpenGlDrawCallback' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void setOpenGlDrawCallback(CvOpenGlDrawCallback callback, void* userdata);
         ^
modules/highgui/src/window_QT.h:403:18: note: Virtual function in base class
    virtual void setOpenGlDrawCallback(CvOpenGlDrawCallback callback, void* userdata) = 0;
                 ^
modules/highgui/src/window_QT.h:448:10: note: Function in derived class
    void setOpenGlDrawCallback(CvOpenGlDrawCallback callback, void* userdata);
         ^
modules/highgui/src/window_QT.h:449:10: style: The function 'makeCurrentOpenGlContext' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void makeCurrentOpenGlContext();
         ^
modules/highgui/src/window_QT.h:404:18: note: Virtual function in base class
    virtual void makeCurrentOpenGlContext() = 0;
                 ^
modules/highgui/src/window_QT.h:449:10: note: Function in derived class
    void makeCurrentOpenGlContext();
         ^
modules/highgui/src/window_QT.h:450:10: style: The function 'updateGl' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void updateGl();
         ^
modules/highgui/src/window_QT.h:405:18: note: Virtual function in base class
    virtual void updateGl() = 0;
                 ^
modules/highgui/src/window_QT.h:450:10: note: Function in derived class
    void updateGl();
         ^
modules/highgui/src/window_QT.h:452:10: style: The function 'setSize' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void setSize(QSize size_);
         ^
modules/highgui/src/window_QT.h:407:18: note: Virtual function in base class
    virtual void setSize(QSize size_) = 0;
                 ^
modules/highgui/src/window_QT.h:452:10: note: Function in derived class
    void setSize(QSize size_);
         ^
modules/highgui/src/window_QT.cpp:1645:44: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    mode_display = arg2 & CV_WINDOW_OPENGL ? CV_MODE_OPENGL : CV_MODE_NORMAL;
                                           ^
modules/highgui/src/window_carbon.cpp:207:28: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    CvTrackbar* trackbar = window->toolbar.first;
                           ^
modules/highgui/src/window_carbon.cpp:535:9: note: Assuming that condition '!window' is not redundant
    if( !window )
        ^
modules/highgui/src/window_carbon.cpp:534:33: note: Assignment 'window=icvFindWindowByName(window_name)', assigned value is 0
    window = icvFindWindowByName(window_name);
                                ^
modules/highgui/src/window_carbon.cpp:538:38: note: Calling function 'icvFindTrackbarByName', 1st argument 'window' value is 0
    trackbar = icvFindTrackbarByName(window,trackbar_name);
                                     ^
modules/highgui/src/window_carbon.cpp:207:28: note: Null pointer dereference
    CvTrackbar* trackbar = window->toolbar.first;
                           ^
modules/highgui/src/window_carbon.cpp:311:9: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    if( window->prev )
        ^
modules/highgui/src/window_carbon.cpp:352:9: note: Assuming that condition '!window' is not redundant
    if( !window )
        ^
modules/highgui/src/window_carbon.cpp:351:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName( name );
                                ^
modules/highgui/src/window_carbon.cpp:355:22: note: Calling function 'icvDeleteWindow', 1st argument 'window' value is 0
    icvDeleteWindow( window );
                     ^
modules/highgui/src/window_carbon.cpp:311:9: note: Null pointer dereference
    if( window->prev )
        ^
modules/highgui/src/window_carbon.cpp:441:16: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    SizeWindow(window->window, width, height, true);
               ^
modules/highgui/src/window_carbon.cpp:438:8: note: Assuming that condition '!window' is not redundant
    if(!window)
       ^
modules/highgui/src/window_carbon.cpp:437:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName(name);
                                ^
modules/highgui/src/window_carbon.cpp:441:16: note: Null pointer dereference
    SizeWindow(window->window, width, height, true);
               ^
modules/highgui/src/window_carbon.cpp:462:16: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    MoveWindow(window->window, x, y, true);
               ^
modules/highgui/src/window_carbon.cpp:459:8: note: Assuming that condition '!window' is not redundant
    if(!window)
       ^
modules/highgui/src/window_carbon.cpp:458:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName(name);
                                ^
modules/highgui/src/window_carbon.cpp:462:16: note: Null pointer dereference
    MoveWindow(window->window, x, y, true);
               ^
modules/highgui/src/window_carbon.cpp:949:12: style: Variable 'result' is reassigned a value before the old one has been used. [redundantAssignment]
    result = 1;
           ^
modules/highgui/src/window_carbon.cpp:905:16: note: result is assigned
        result = 1;
               ^
modules/highgui/src/window_carbon.cpp:949:12: note: result is overwritten
    result = 1;
           ^
modules/highgui/src/window_carbon.cpp:987:17: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
            err = GetEventParameter(theEvent, kEventParamKeyModifiers, typeUInt32, NULL, sizeof(modifiers), NULL, &modifiers);
                ^
modules/highgui/src/window_carbon.cpp:986:17: note: err is assigned
            err = GetEventParameter(theEvent, kEventParamMouseButton, typeMouseButton, NULL, sizeof(eventMouseButton), NULL, &eventMouseButton);
                ^
modules/highgui/src/window_carbon.cpp:987:17: note: err is overwritten
            err = GetEventParameter(theEvent, kEventParamKeyModifiers, typeUInt32, NULL, sizeof(modifiers), NULL, &modifiers);
                ^
modules/highgui/src/window_carbon.cpp:988:17: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
            err = GetEventParameter(theEvent,kEventParamClickCount,typeUInt32,NULL,sizeof(UInt32),NULL,&count);
                ^
modules/highgui/src/window_carbon.cpp:987:17: note: err is assigned
            err = GetEventParameter(theEvent, kEventParamKeyModifiers, typeUInt32, NULL, sizeof(modifiers), NULL, &modifiers);
                ^
modules/highgui/src/window_carbon.cpp:988:17: note: err is overwritten
            err = GetEventParameter(theEvent,kEventParamClickCount,typeUInt32,NULL,sizeof(UInt32),NULL,&count);
                ^
modules/highgui/src/window_carbon.cpp:960:9: style: The scope of the variable 'event' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int event = 0;
        ^
modules/highgui/src/window_carbon.cpp:137:15: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
    OSErr err = noErr;
              ^
modules/highgui/src/window_carbon.cpp:786:18: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
    OSStatus err = noErr;
                 ^
modules/highgui/src/window_carbon.cpp:946:9: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
    err = InstallWindowEventHandler(outWindow, NewEventHandlerUPP(windowEventHandler), GetEventTypeCount(genericWindowEventHandler), genericWindowEventHandler, outWindow, NULL);
        ^
modules/highgui/src/window_carbon.cpp:1082:16: style: Variable 'eventKind' is assigned a value that is never used. [unreadVariable]
    eventKind  = GetEventKind     (theEvent);
               ^
modules/highgui/src/window_carbon.cpp:1083:16: style: Variable 'eventClass' is assigned a value that is never used. [unreadVariable]
    eventClass = GetEventClass    (theEvent);
               ^
modules/highgui/src/window_gtk.cpp:514:5: style: Struct 'CvUIBase' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CvUIBase(int signature_) : signature(signature_) { }
    ^
modules/highgui/src/window_gtk.cpp:521:5: style: Struct 'CvTrackbar' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CvTrackbar(const char* trackbar_name) :
    ^
modules/highgui/src/window_gtk.cpp:550:5: style: Struct 'CvWindow' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CvWindow(const char* window_name) :
    ^
modules/highgui/src/window_gtk.cpp:676:5: style: Class 'GMutexLock' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    GMutexLock(GMutex* mutex) : mutex_(mutex) { if (mutex_) g_mutex_lock(mutex_); }
    ^
modules/highgui/src/window_gtk.cpp:1620:41: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            icvShowSaveAsDialog(widget, (CvWindow*)user_data);
                                        ^
modules/highgui/src/window_gtk.cpp:1667:28: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    CvTrackbar* trackbar = (CvTrackbar*)user_data;
                           ^
modules/highgui/src/window_gtk.cpp:1684:24: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    CvWindow* window = (CvWindow*)user_data;
                       ^
modules/highgui/src/window_gtk.cpp:1697:24: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    CvWindow* window = (CvWindow*)user_data;
                       ^
modules/highgui/src/window_gtk.cpp:710:23: warning: Conversion of string literal "NULL name string" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(name && "NULL name string");
                      ^
modules/highgui/src/window_gtk.cpp:724:23: warning: Conversion of string literal "NULL name string" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(name && "NULL name string");
                      ^
modules/highgui/src/window_gtk.cpp:770:23: warning: Conversion of string literal "NULL name string" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(name && "NULL name string");
                      ^
modules/highgui/src/window_gtk.cpp:784:23: warning: Conversion of string literal "NULL name string" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(name && "NULL name string");
                      ^
modules/highgui/src/window_gtk.cpp:978:23: warning: Conversion of string literal "NULL name string" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(name && "NULL name string");
                      ^
modules/highgui/src/window_gtk.cpp:1176:24: warning: Conversion of string literal "Can't destroy non-registered window" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(found && "Can't destroy non-registered window");
                       ^
modules/highgui/src/window_gtk.cpp:1183:23: warning: Conversion of string literal "NULL name string" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(name && "NULL name string");
                      ^
modules/highgui/src/window_gtk.cpp:1198:24: warning: Conversion of string literal "Can't destroy non-registered window" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(found && "Can't destroy non-registered window");
                       ^
modules/highgui/src/window_gtk.cpp:1228:23: warning: Conversion of string literal "NULL name string" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(name && "NULL name string");
                      ^
modules/highgui/src/window_gtk.cpp:1257:23: warning: Conversion of string literal "NULL name string" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(name && "NULL name string");
                      ^
modules/highgui/src/window_gtk.cpp:1280:23: warning: Conversion of string literal "NULL name string" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(name && "NULL name string");
                      ^
modules/highgui/src/window_gtk.cpp:1309:30: warning: Conversion of string literal "NULL window name" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(window_name && "NULL window name");
                             ^
modules/highgui/src/window_gtk.cpp:1310:32: warning: Conversion of string literal "NULL trackbar name" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(trackbar_name && "NULL trackbar name");
                               ^
modules/highgui/src/window_gtk.cpp:1394:30: warning: Conversion of string literal "NULL window name" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(window_name && "NULL window name");
                             ^
modules/highgui/src/window_gtk.cpp:1409:30: warning: Conversion of string literal "NULL window name" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(window_name && "NULL window name");
                             ^
modules/highgui/src/window_gtk.cpp:1410:32: warning: Conversion of string literal "NULL trackbar name" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(trackbar_name && "NULL trackbar name");
                               ^
modules/highgui/src/window_gtk.cpp:1428:30: warning: Conversion of string literal "NULL window name" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(window_name && "NULL window name");
                             ^
modules/highgui/src/window_gtk.cpp:1429:32: warning: Conversion of string literal "NULL trackbar name" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(trackbar_name && "NULL trackbar name");
                               ^
modules/highgui/src/window_gtk.cpp:1457:30: warning: Conversion of string literal "NULL window name" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(window_name && "NULL window name");
                             ^
modules/highgui/src/window_gtk.cpp:1458:32: warning: Conversion of string literal "NULL trackbar name" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(trackbar_name && "NULL trackbar name");
                               ^
modules/highgui/src/window_gtk.cpp:1478:30: warning: Conversion of string literal "NULL window name" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(window_name && "NULL window name");
                             ^
modules/highgui/src/window_gtk.cpp:1479:32: warning: Conversion of string literal "NULL trackbar name" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(trackbar_name && "NULL trackbar name");
                               ^
modules/highgui/src/window_gtk.cpp:1499:30: warning: Conversion of string literal "NULL window name" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(window_name && "NULL window name");
                             ^
modules/highgui/src/window_gtk.cpp:1513:32: warning: Conversion of string literal "NULL window handle" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(window_handle && "NULL window handle");
                               ^
modules/highgui/src/window_gtk.cpp:812:19: style: Boolean value assigned to floating point variable. [assignBoolToFloat]
    double result = window->useGl;
                  ^
modules/highgui/src/window_gtk.cpp:922:24: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    CvWindow* window = (CvWindow*)data;
                       ^
modules/highgui/src/window_gtk.cpp:804:23: warning: Conversion of string literal "NULL name string" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(name && "NULL name string");
                      ^
modules/highgui/src/window_gtk.cpp:1075:23: warning: Conversion of string literal "NULL name string" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(name && "NULL name string");
                      ^
modules/highgui/src/window_gtk.cpp:1095:23: warning: Conversion of string literal "NULL name string" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(name && "NULL name string");
                      ^
modules/highgui/src/window_gtk.cpp:1109:23: warning: Conversion of string literal "NULL name string" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(name && "NULL name string");
                      ^
modules/highgui/src/window_w32.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/highgui/src/window_w32.cpp:443:14: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    result = window->status;
             ^
modules/highgui/src/window_w32.cpp:440:9: note: Assuming that condition '!window' is not redundant
    if (!window)
        ^
modules/highgui/src/window_w32.cpp:439:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName( name );
                                ^
modules/highgui/src/window_w32.cpp:443:14: note: Null pointer dereference
    result = window->status;
             ^
modules/highgui/src/window_w32.cpp:571:34: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    result = static_cast<double>(window->width) / window->height;
                                 ^
modules/highgui/src/window_w32.cpp:568:9: note: Assuming that condition '!window' is not redundant
    if (!window)
        ^
modules/highgui/src/window_w32.cpp:567:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName( name );
                                ^
modules/highgui/src/window_w32.cpp:571:34: note: Null pointer dereference
    result = static_cast<double>(window->width) / window->height;
                                 ^
modules/highgui/src/window_w32.cpp:994:16: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    mainhWnd = window->frame;
               ^
modules/highgui/src/window_w32.cpp:991:9: note: Assuming that condition '!window' is not redundant
    if( !window )
        ^
modules/highgui/src/window_w32.cpp:990:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName( name );
                                ^
modules/highgui/src/window_w32.cpp:994:16: note: Null pointer dereference
    mainhWnd = window->frame;
               ^
modules/highgui/src/window_w32.cpp:996:17: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    SendMessage(window->hwnd, WM_CLOSE, 0, 0);
                ^
modules/highgui/src/window_w32.cpp:991:9: note: Assuming that condition '!window' is not redundant
    if( !window )
        ^
modules/highgui/src/window_w32.cpp:990:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName( name );
                                ^
modules/highgui/src/window_w32.cpp:996:17: note: Null pointer dereference
    SendMessage(window->hwnd, WM_CLOSE, 0, 0);
                ^
modules/highgui/src/window_w32.cpp:1147:9: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    if (window->image)
        ^
modules/highgui/src/window_w32.cpp:1131:9: note: Assuming that condition '!window' is not redundant
    if( !window || !arr )
        ^
modules/highgui/src/window_w32.cpp:1147:9: note: Null pointer dereference
    if (window->image)
        ^
modules/highgui/src/window_w32.cpp:1322:20: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    GetWindowRect( window->frame, &rect );
                   ^
modules/highgui/src/window_w32.cpp:1319:8: note: Assuming that condition '!window' is not redundant
    if(!window)
       ^
modules/highgui/src/window_w32.cpp:1318:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName(name);
                                ^
modules/highgui/src/window_w32.cpp:1322:20: note: Null pointer dereference
    GetWindowRect( window->frame, &rect );
                   ^
modules/highgui/src/window_w32.cpp:1323:17: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    MoveWindow( window->frame, x, y, rect.right - rect.left, rect.bottom - rect.top, TRUE);
                ^
modules/highgui/src/window_w32.cpp:1319:8: note: Assuming that condition '!window' is not redundant
    if(!window)
       ^
modules/highgui/src/window_w32.cpp:1318:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName(name);
                                ^
modules/highgui/src/window_w32.cpp:1323:17: note: Null pointer dereference
    MoveWindow( window->frame, x, y, rect.right - rect.left, rect.bottom - rect.top, TRUE);
                ^
modules/highgui/src/window_w32.cpp:2022:28: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    CvTrackbar* trackbar = window->toolbar.first;
                           ^
modules/highgui/src/window_w32.cpp:2054:9: note: Assuming that condition '!window' is not redundant
    if( !window )
        ^
modules/highgui/src/window_w32.cpp:2053:33: note: Assignment 'window=icvFindWindowByName(window_name)', assigned value is 0
    window = icvFindWindowByName(window_name);
                                ^
modules/highgui/src/window_w32.cpp:2057:38: note: Calling function 'icvFindTrackbarByName', 1st argument 'window' value is 0
    trackbar = icvFindTrackbarByName(window,trackbar_name);
                                     ^
modules/highgui/src/window_w32.cpp:2022:28: note: Null pointer dereference
    CvTrackbar* trackbar = window->toolbar.first;
                           ^
modules/highgui/src/window_w32.cpp:2260:5: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    window->on_mouse = on_mouse;
    ^
modules/highgui/src/window_w32.cpp:2257:9: note: Assuming that condition '!window' is not redundant
    if( !window )
        ^
modules/highgui/src/window_w32.cpp:2256:33: note: Assignment 'window=icvFindWindowByName(window_name)', assigned value is 0
    window = icvFindWindowByName(window_name);
                                ^
modules/highgui/src/window_w32.cpp:2260:5: note: Null pointer dereference
    window->on_mouse = on_mouse;
    ^
modules/highgui/src/window_w32.cpp:2261:5: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    window->on_mouse_param = param;
    ^
modules/highgui/src/window_w32.cpp:2257:9: note: Assuming that condition '!window' is not redundant
    if( !window )
        ^
modules/highgui/src/window_w32.cpp:2256:33: note: Assignment 'window=icvFindWindowByName(window_name)', assigned value is 0
    window = icvFindWindowByName(window_name);
                                ^
modules/highgui/src/window_w32.cpp:2261:5: note: Null pointer dereference
    window->on_mouse_param = param;
    ^
modules/highgui/src/window_w32.cpp:845:12: style: Variable 'result' is reassigned a value before the old one has been used. [redundantAssignment]
    result = 1;
           ^
modules/highgui/src/window_w32.cpp:755:16: note: result is assigned
        result = 1;
               ^
modules/highgui/src/window_w32.cpp:845:12: note: result is overwritten
    result = 1;
           ^
modules/highgui/src/window_w32.cpp:1477:17: style: Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]
            ret = CombineRgn(rgn, rgn, rgn2, RGN_DIFF);
                ^
modules/highgui/src/window_w32.cpp:1476:17: note: ret is assigned
            ret = CombineRgn(rgn, rgn, rgn1, RGN_DIFF);
                ^
modules/highgui/src/window_w32.cpp:1477:17: note: ret is overwritten
            ret = CombineRgn(rgn, rgn, rgn2, RGN_DIFF);
                ^
modules/highgui/src/window_w32.cpp:370:10: style: The scope of the variable 'rootKey' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char rootKey[1024];
         ^
modules/highgui/src/window_w32.cpp:1764:17: style: The scope of the variable 'suffix' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char* suffix = "";
                ^
modules/highgui/src/window_w32.cpp:1765:10: style: The scope of the variable 'pos_text' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char pos_text[32];
         ^
modules/highgui/src/window_w32.cpp:1766:9: style: The scope of the variable 'name_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int name_len;
        ^
modules/highgui/src/window_w32.cpp:2042:10: style: The scope of the variable 'slider_name' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char slider_name[32];
         ^
modules/highgui/src/window_w32.cpp:2335:21: style: The scope of the variable 'trackbar' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        CvTrackbar* trackbar = 0;
                    ^
modules/highgui/src/window_w32.cpp:2367:21: style: The scope of the variable 'trackbar' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        CvTrackbar* trackbar = 0;
                    ^
modules/highgui/src/window_w32.cpp:1426:49: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
          int flags = (wParam & MK_LBUTTON      ? CV_EVENT_FLAG_LBUTTON  : 0)|
                                                ^
modules/highgui/src/window_w32.cpp:1427:49: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                      (wParam & MK_RBUTTON      ? CV_EVENT_FLAG_RBUTTON  : 0)|
                                                ^
modules/highgui/src/window_w32.cpp:1428:49: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                      (wParam & MK_MBUTTON      ? CV_EVENT_FLAG_MBUTTON  : 0)|
                                                ^
modules/highgui/src/window_w32.cpp:1429:49: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                      (wParam & MK_CONTROL      ? CV_EVENT_FLAG_CTRLKEY  : 0)|
                                                ^
modules/highgui/src/window_w32.cpp:1430:49: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                      (wParam & MK_SHIFT        ? CV_EVENT_FLAG_SHIFTKEY : 0)|
                                                ^
modules/highgui/src/window_w32.cpp:1604:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
            int flags = (wParam & MK_LBUTTON ? CV_EVENT_FLAG_LBUTTON : 0)|
                                             ^
modules/highgui/src/window_w32.cpp:1605:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                        (wParam & MK_RBUTTON ? CV_EVENT_FLAG_RBUTTON : 0)|
                                             ^
modules/highgui/src/window_w32.cpp:1606:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                        (wParam & MK_MBUTTON ? CV_EVENT_FLAG_MBUTTON : 0)|
                                             ^
modules/highgui/src/window_w32.cpp:1607:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                        (wParam & MK_CONTROL ? CV_EVENT_FLAG_CTRLKEY : 0)|
                                             ^
modules/highgui/src/window_w32.cpp:1608:44: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                        (wParam & MK_SHIFT ? CV_EVENT_FLAG_SHIFTKEY : 0)|
                                           ^
modules/highgui/src/window_w32.cpp:1975:38: style: Variable 'is_processed' is assigned a value that is never used. [unreadVariable]
                        is_processed = 1;
                                     ^
modules/highgui/src/window_w32.cpp:1990:38: style: Variable 'is_processed' is assigned a value that is never used. [unreadVariable]
                        is_processed = 1;
                                     ^
modules/highgui/src/window_w32.cpp:2335:30: style: Variable 'trackbar' is assigned a value that is never used. [unreadVariable]
        CvTrackbar* trackbar = 0;
                             ^
modules/highgui/src/window_w32.cpp:2367:30: style: Variable 'trackbar' is assigned a value that is never used. [unreadVariable]
        CvTrackbar* trackbar = 0;
                             ^
modules/highgui/src/window_w32.cpp:596:12: style: Boolean value assigned to floating point variable. [assignBoolToFloat]
    result = window->useGl;
           ^
modules/highgui/src/window_w32.cpp:596:14: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    result = window->useGl;
             ^
modules/highgui/src/window_w32.cpp:593:9: note: Assuming that condition '!window' is not redundant
    if (!window)
        ^
modules/highgui/src/window_w32.cpp:592:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName( name );
                                ^
modules/highgui/src/window_w32.cpp:596:14: note: Null pointer dereference
    result = window->useGl;
             ^
modules/highgui/src/window_w32.cpp:892:20: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    InvalidateRect(window->hwnd, 0, 0);
                   ^
modules/highgui/src/window_w32.cpp:889:9: note: Assuming that condition '!window' is not redundant
    if (!window)
        ^
modules/highgui/src/window_w32.cpp:888:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName( name );
                                ^
modules/highgui/src/window_w32.cpp:892:20: note: Null pointer dereference
    InvalidateRect(window->hwnd, 0, 0);
                   ^
modules/highgui/src/window_w32.cpp:912:10: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    if (!window->useGl)
         ^
modules/highgui/src/window_w32.cpp:909:9: note: Assuming that condition '!window' is not redundant
    if( !window )
        ^
modules/highgui/src/window_w32.cpp:908:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName( name );
                                ^
modules/highgui/src/window_w32.cpp:912:10: note: Null pointer dereference
    if (!window->useGl)
         ^
modules/highgui/src/window_w32.cpp:915:5: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    window->glDrawCallback = callback;
    ^
modules/highgui/src/window_w32.cpp:909:9: note: Assuming that condition '!window' is not redundant
    if( !window )
        ^
modules/highgui/src/window_w32.cpp:908:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName( name );
                                ^
modules/highgui/src/window_w32.cpp:915:5: note: Null pointer dereference
    window->glDrawCallback = callback;
    ^
modules/highgui/src/window_w32.cpp:916:5: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    window->glDrawData = userdata;
    ^
modules/highgui/src/window_w32.cpp:909:9: note: Assuming that condition '!window' is not redundant
    if( !window )
        ^
modules/highgui/src/window_w32.cpp:908:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0
    window = icvFindWindowByName( name );
                                ^
modules/highgui/src/window_w32.cpp:916:5: note: Null pointer dereference
    window->glDrawData = userdata;
    ^
modules/highgui/src/window_w32.cpp:1140:9: warning: Either the condition '!window' is redundant or there is possible null pointer dereference: window. [nullPointerRedundantCheck]
    if (window->useGl)
        ^
modules/highgui/src/window_w32.cpp:1131:9: note: Assuming that condition '!window' is not redundant
    if( !window || !arr )
        ^
modules/highgui/src/window_w32.cpp:1140:9: note: Null pointer dereference
    if (window->useGl)
        ^
modules/highgui/src/window_w32.cpp:1892:0: information: Skipping configuration 'OPENFILENAME_SIZE_VERSION_400;_WIN32' since the value of 'OPENFILENAME_SIZE_VERSION_400' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
^
modules/highgui/src/window_winrt_bridge.hpp:117:5: warning: Member variable 'HighguiBridge::currentWindow' is not initialized in the constructor. [uninitMemberVarPrivate]
    HighguiBridge() {
    ^
modules/highgui/src/window_winrt_bridge.hpp:170:5: style: Class 'CvWindow' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CvWindow(cv::String name, int flag = CV_WINDOW_NORMAL);
    ^
modules/highgui/src/window_winrt.cpp:120:13: style: Variable 'pos' is assigned a value that is never used. [unreadVariable]
    int pos = 0;
            ^
modules/highgui/src/window_winrt.cpp:213:15: style: Variable 'time0' is assigned a value that is never used. [unreadVariable]
    int time0 = GetTickCount64();
              ^
modules/highgui/src/window_winrt.cpp:217:19: style: Unused variable: window [unusedVariable]
        CvWindow* window;
                  ^
modules/highgui/src/window_winrt_bridge.cpp:222:23: error: syntax error [syntaxError]
    this->page = (Page^)Windows::UI::Xaml::Markup::XamlReader::Load(const_cast<Platform::String^>(markupContent));
                      ^
modules/imgcodecs/src/bitstrm.cpp:168:13: warning: Non-pure function: 'isOpened' is called inside assert statement. Assert statements are removed from release builds so the code inside assert statement is not executed. If the code is needed also in release builds, this is a bug. [assertWithSideEffect]
    assert( isOpened() && pos >= 0 );
            ^
modules/imgcodecs/src/bitstrm.cpp:185:13: warning: Non-pure function: 'isOpened' is called inside assert statement. Assert statements are removed from release builds so the code inside assert statement is not executed. If the code is needed also in release builds, this is a bug. [assertWithSideEffect]
    assert( isOpened() );
            ^
modules/imgcodecs/src/bitstrm.cpp:376:13: warning: Non-pure function: 'isOpened' is called inside assert statement. Assert statements are removed from release builds so the code inside assert statement is not executed. If the code is needed also in release builds, this is a bug. [assertWithSideEffect]
    assert( isOpened() );
            ^
modules/imgcodecs/src/bitstrm.cpp:447:13: warning: Non-pure function: 'isOpened' is called inside assert statement. Assert statements are removed from release builds so the code inside assert statement is not executed. If the code is needed also in release builds, this is a bug. [assertWithSideEffect]
    assert( isOpened() );
            ^
modules/imgcodecs/src/bitstrm.hpp:78:19: warning: Virtual function 'close' is called from destructor '~RBaseStream()' at line 88. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void  close();
                  ^
modules/imgcodecs/src/bitstrm.cpp:88:5: note: Calling close
    close();    // Close files
    ^
modules/imgcodecs/src/bitstrm.hpp:78:19: note: close is a virtual function
    virtual void  close();
                  ^
modules/imgcodecs/src/bitstrm.hpp:96:19: warning: Virtual function 'release' is called from destructor '~RBaseStream()' at line 89. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void  release();
                  ^
modules/imgcodecs/src/bitstrm.cpp:89:5: note: Calling release
    release();  // free  buffers
    ^
modules/imgcodecs/src/bitstrm.hpp:96:19: note: release is a virtual function
    virtual void  release();
                  ^
modules/imgcodecs/src/bitstrm.hpp:135:19: warning: Virtual function 'close' is called from destructor '~WBaseStream()' at line 351. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void  close();
                  ^
modules/imgcodecs/src/bitstrm.cpp:351:5: note: Calling close
    close();
    ^
modules/imgcodecs/src/bitstrm.hpp:135:19: note: close is a virtual function
    virtual void  close();
                  ^
modules/imgcodecs/src/bitstrm.hpp:151:19: warning: Virtual function 'release' is called from destructor '~WBaseStream()' at line 352. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void  release();
                  ^
modules/imgcodecs/src/bitstrm.cpp:352:5: note: Calling release
    release();
    ^
modules/imgcodecs/src/bitstrm.hpp:151:19: note: release is a virtual function
    virtual void  release();
                  ^
modules/imgcodecs/src/exif.cpp:179:23: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
                count = m_stream.gcount();
                      ^
modules/imgcodecs/src/exif.cpp:483:18: style: Unused variable: result [unusedVariable]
    u_rational_t result;
                 ^
modules/imgcodecs/src/grfmt_bmp.cpp:53:13: warning: Member variable 'BmpDecoder::m_palette' is not initialized in the constructor. [uninitMemberVar]
BmpDecoder::BmpDecoder()
            ^
modules/imgcodecs/src/grfmt_bmp.hpp:68:11: style: The function 'readData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_base.hpp:72:18: note: Virtual function in base class
    virtual bool readData( Mat& img ) = 0;
                 ^
modules/imgcodecs/src/grfmt_bmp.hpp:68:11: note: Function in derived class
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_bmp.hpp:69:11: style: The function 'readHeader' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_base.hpp:71:18: note: Virtual function in base class
    virtual bool readHeader() = 0;
                 ^
modules/imgcodecs/src/grfmt_bmp.hpp:69:11: note: Function in derived class
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_bmp.hpp:92:11: style: The function 'write' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_base.hpp:103:18: note: Virtual function in base class
    virtual bool write( const Mat& img, const std::vector<int>& params ) = 0;
                 ^
modules/imgcodecs/src/grfmt_bmp.hpp:92:11: note: Function in derived class
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_bmp.hpp:94:18: style: The function 'newEncoder' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_base.hpp:106:26: note: Virtual function in base class
    virtual ImageEncoder newEncoder() const;
                         ^
modules/imgcodecs/src/grfmt_bmp.hpp:94:18: note: Function in derived class
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_exr.cpp:88:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'm_type' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    m_type = ((Imf::PixelType)0);
    ^
modules/imgcodecs/src/grfmt_exr.hpp:88:21: warning: The class 'ExrDecoder' defines member variable with name 'm_type' also defined in its parent class 'BaseImageDecoder'. [duplInheritedMember]
    Imf::PixelType  m_type;
                    ^
modules/imgcodecs/src/grfmt_base.hpp:84:10: note: Parent variable 'BaseImageDecoder::m_type'
    int  m_type;
         ^
modules/imgcodecs/src/grfmt_exr.hpp:88:21: note: Derived variable 'ExrDecoder::m_type'
    Imf::PixelType  m_type;
                    ^
modules/imgcodecs/src/grfmt_exr.hpp:73:11: style: The function 'type' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int   type() const;
          ^
modules/imgcodecs/src/grfmt_base.hpp:66:17: note: Virtual function in base class
    virtual int type() const { return m_type; }
                ^
modules/imgcodecs/src/grfmt_exr.hpp:73:11: note: Function in derived class
    int   type() const;
          ^
modules/imgcodecs/src/grfmt_exr.hpp:74:11: style: The function 'readData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_base.hpp:72:18: note: Virtual function in base class
    virtual bool readData( Mat& img ) = 0;
                 ^
modules/imgcodecs/src/grfmt_exr.hpp:74:11: note: Function in derived class
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_exr.hpp:75:11: style: The function 'readHeader' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_base.hpp:71:18: note: Virtual function in base class
    virtual bool readHeader() = 0;
                 ^
modules/imgcodecs/src/grfmt_exr.hpp:75:11: note: Function in derived class
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_exr.hpp:112:11: style: The function 'isFormatSupported' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  isFormatSupported( int depth ) const;
          ^
modules/imgcodecs/src/grfmt_base.hpp:99:18: note: Virtual function in base class
    virtual bool isFormatSupported( int depth ) const;
                 ^
modules/imgcodecs/src/grfmt_exr.hpp:112:11: note: Function in derived class
    bool  isFormatSupported( int depth ) const;
          ^
modules/imgcodecs/src/grfmt_exr.hpp:113:11: style: The function 'write' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_base.hpp:103:18: note: Virtual function in base class
    virtual bool write( const Mat& img, const std::vector<int>& params ) = 0;
                 ^
modules/imgcodecs/src/grfmt_exr.hpp:113:11: note: Function in derived class
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_exr.hpp:114:18: style: The function 'newEncoder' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_base.hpp:106:26: note: Virtual function in base class
    virtual ImageEncoder newEncoder() const;
                         ^
modules/imgcodecs/src/grfmt_exr.hpp:114:18: note: Function in derived class
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_exr.cpp:341:32: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
                    UpSampleX( (float *)buffer + i, channels, xsample[i] );
                               ^
modules/imgcodecs/src/grfmt_exr.cpp:345:28: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
                RGBToGray( (float *)buffer, (float *)out );
                           ^
modules/imgcodecs/src/grfmt_exr.cpp:350:34: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
                    ChromaToBGR( (float *)buffer, 1, step );
                                 ^
modules/imgcodecs/src/grfmt_exr.cpp:354:33: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
                    float *fi = (float *)buffer;
                                ^
modules/imgcodecs/src/grfmt_exr.cpp:429:18: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                ((unsigned *)data)[(xre + n) * xstep] = ((unsigned *)data)[x * xstep];
                 ^
modules/imgcodecs/src/grfmt_exr.cpp:475:22: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                b = ((unsigned *)data)[y * step + x * 3];
                     ^
modules/imgcodecs/src/grfmt_exr.cpp:476:22: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                Y = ((unsigned *)data)[y * step + x * 3 + 1];
                     ^
modules/imgcodecs/src/grfmt_exr.cpp:477:22: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                r = ((unsigned *)data)[y * step + x * 3 + 2];
                     ^
modules/imgcodecs/src/grfmt_exr.cpp:492:18: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                ((unsigned *)data)[y * step + x * 3 + 0] = (unsigned)MAX(t, 0);
                 ^
modules/imgcodecs/src/grfmt_exr.cpp:494:18: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                ((unsigned *)data)[y * step + x * 3 + 1] = (unsigned)MAX(t, 0);
                 ^
modules/imgcodecs/src/grfmt_exr.cpp:496:18: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                ((unsigned *)data)[y * step + x * 3 + 2] = (unsigned)MAX(t, 0);
                 ^
modules/imgcodecs/src/grfmt_exr.cpp:526:28: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
            unsigned *ui = (unsigned *)in;
                           ^
modules/imgcodecs/src/grfmt_exr.cpp:529:23: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
            int *si = (int *)in;
                      ^
modules/imgcodecs/src/grfmt_exr.cpp:531:18: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                ((int *)out)[i] = int(si[n] * m_chroma.blue[0] + si[n + 1] * m_chroma.green[0] + si[n + 2] * m_chroma.red[0]);
                 ^
modules/imgcodecs/src/grfmt_exr.cpp:535:28: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
            unsigned *ui = (unsigned *)in;
                           ^
modules/imgcodecs/src/grfmt_gdal.cpp:138:14: warning: Member variable 'GdalDecoder::hasColorTable' is not initialized in the constructor. [uninitMemberVar]
GdalDecoder::GdalDecoder(){
             ^
modules/imgcodecs/src/grfmt_gdal.hpp:123:14: style: The function 'readData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        bool readData( Mat& img );
             ^
modules/imgcodecs/src/grfmt_base.hpp:72:18: note: Virtual function in base class
    virtual bool readData( Mat& img ) = 0;
                 ^
modules/imgcodecs/src/grfmt_gdal.hpp:123:14: note: Function in derived class
        bool readData( Mat& img );
             ^
modules/imgcodecs/src/grfmt_gdal.hpp:128:14: style: The function 'readHeader' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        bool readHeader();
             ^
modules/imgcodecs/src/grfmt_base.hpp:71:18: note: Virtual function in base class
    virtual bool readHeader() = 0;
                 ^
modules/imgcodecs/src/grfmt_gdal.hpp:128:14: note: Function in derived class
        bool readHeader();
             ^
modules/imgcodecs/src/grfmt_gdal.hpp:147:22: style: The function 'checkSignature' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual bool checkSignature( const String& signature ) const;
                     ^
modules/imgcodecs/src/grfmt_base.hpp:78:18: note: Virtual function in base class
    virtual bool checkSignature( const String& signature ) const;
                 ^
modules/imgcodecs/src/grfmt_gdal.hpp:147:22: note: Function in derived class
        virtual bool checkSignature( const String& signature ) const;
                     ^
modules/imgcodecs/src/grfmt_gdal.cpp:380:9: style: The scope of the variable 'nRows' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int nRows, nCols;
        ^
modules/imgcodecs/src/grfmt_gdal.cpp:380:16: style: The scope of the variable 'nCols' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int nRows, nCols;
               ^
modules/imgcodecs/src/grfmt_gdcm.hpp:60:11: style: The function 'readData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_base.hpp:72:18: note: Virtual function in base class
    virtual bool readData( Mat& img ) = 0;
                 ^
modules/imgcodecs/src/grfmt_gdcm.hpp:60:11: note: Function in derived class
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_gdcm.hpp:61:11: style: The function 'readHeader' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_base.hpp:71:18: note: Virtual function in base class
    virtual bool readHeader() = 0;
                 ^
modules/imgcodecs/src/grfmt_gdcm.hpp:61:11: note: Function in derived class
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_gdcm.hpp:63:18: style: The function 'checkSignature' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool checkSignature( const String& signature ) const;
                 ^
modules/imgcodecs/src/grfmt_base.hpp:78:18: note: Virtual function in base class
    virtual bool checkSignature( const String& signature ) const;
                 ^
modules/imgcodecs/src/grfmt_gdcm.hpp:63:18: note: Function in derived class
    virtual bool checkSignature( const String& signature ) const;
                 ^
modules/imgcodecs/src/grfmt_hdr.cpp:53:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'm_signature_alt' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    m_signature_alt = "#?RADIANCE";
    ^
modules/imgcodecs/src/grfmt_hdr.hpp:63:10: style: The function 'readHeader' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool readHeader();
         ^
modules/imgcodecs/src/grfmt_base.hpp:71:18: note: Virtual function in base class
    virtual bool readHeader() = 0;
                 ^
modules/imgcodecs/src/grfmt_hdr.hpp:63:10: note: Function in derived class
    bool readHeader();
         ^
modules/imgcodecs/src/grfmt_hdr.hpp:64:10: style: The function 'readData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool readData( Mat& img );
         ^
modules/imgcodecs/src/grfmt_base.hpp:72:18: note: Virtual function in base class
    virtual bool readData( Mat& img ) = 0;
                 ^
modules/imgcodecs/src/grfmt_hdr.hpp:64:10: note: Function in derived class
    bool readData( Mat& img );
         ^
modules/imgcodecs/src/grfmt_hdr.hpp:65:10: style: The function 'checkSignature' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool checkSignature( const String& signature ) const;
         ^
modules/imgcodecs/src/grfmt_base.hpp:78:18: note: Virtual function in base class
    virtual bool checkSignature( const String& signature ) const;
                 ^
modules/imgcodecs/src/grfmt_hdr.hpp:65:10: note: Function in derived class
    bool checkSignature( const String& signature ) const;
         ^
modules/imgcodecs/src/grfmt_hdr.hpp:67:12: style: The function 'signatureLength' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    size_t signatureLength() const;
           ^
modules/imgcodecs/src/grfmt_base.hpp:77:20: note: Virtual function in base class
    virtual size_t signatureLength() const;
                   ^
modules/imgcodecs/src/grfmt_hdr.hpp:67:12: note: Function in derived class
    size_t signatureLength() const;
           ^
modules/imgcodecs/src/grfmt_hdr.hpp:79:10: style: The function 'write' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool write( const Mat& img, const std::vector<int>& params );
         ^
modules/imgcodecs/src/grfmt_base.hpp:103:18: note: Virtual function in base class
    virtual bool write( const Mat& img, const std::vector<int>& params ) = 0;
                 ^
modules/imgcodecs/src/grfmt_hdr.hpp:79:10: note: Function in derived class
    bool write( const Mat& img, const std::vector<int>& params );
         ^
modules/imgcodecs/src/grfmt_hdr.hpp:80:18: style: The function 'newEncoder' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_base.hpp:106:26: note: Virtual function in base class
    virtual ImageEncoder newEncoder() const;
                         ^
modules/imgcodecs/src/grfmt_hdr.hpp:80:18: note: Function in derived class
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_hdr.hpp:81:10: style: The function 'isFormatSupported' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool isFormatSupported( int depth ) const;
         ^
modules/imgcodecs/src/grfmt_base.hpp:99:18: note: Virtual function in base class
    virtual bool isFormatSupported( int depth ) const;
                 ^
modules/imgcodecs/src/grfmt_hdr.hpp:81:10: note: Function in derived class
    bool isFormatSupported( int depth ) const;
         ^
modules/imgcodecs/src/grfmt_jpeg.cpp:109:1: error: There is an unknown macro here somewhere. Configuration is required. If METHODDEF is a macro then please configure it. [unknownMacro]
METHODDEF(void)
^
modules/imgcodecs/src/grfmt_jpeg2000.hpp:60:11: style: The function 'readData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_base.hpp:72:18: note: Virtual function in base class
    virtual bool readData( Mat& img ) = 0;
                 ^
modules/imgcodecs/src/grfmt_jpeg2000.hpp:60:11: note: Function in derived class
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_jpeg2000.hpp:61:11: style: The function 'readHeader' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_base.hpp:71:18: note: Virtual function in base class
    virtual bool readHeader() = 0;
                 ^
modules/imgcodecs/src/grfmt_jpeg2000.hpp:61:11: note: Function in derived class
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_jpeg2000.hpp:82:11: style: The function 'isFormatSupported' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  isFormatSupported( int depth ) const;
          ^
modules/imgcodecs/src/grfmt_base.hpp:99:18: note: Virtual function in base class
    virtual bool isFormatSupported( int depth ) const;
                 ^
modules/imgcodecs/src/grfmt_jpeg2000.hpp:82:11: note: Function in derived class
    bool  isFormatSupported( int depth ) const;
          ^
modules/imgcodecs/src/grfmt_jpeg2000.hpp:83:11: style: The function 'write' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_base.hpp:103:18: note: Virtual function in base class
    virtual bool write( const Mat& img, const std::vector<int>& params ) = 0;
                 ^
modules/imgcodecs/src/grfmt_jpeg2000.hpp:83:11: note: Function in derived class
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_jpeg2000.hpp:84:18: style: The function 'newEncoder' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_base.hpp:106:26: note: Virtual function in base class
    virtual ImageEncoder newEncoder() const;
                         ^
modules/imgcodecs/src/grfmt_jpeg2000.hpp:84:18: note: Function in derived class
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_jpeg2000.cpp:300:19: style: The scope of the variable 'y1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x, y, x1, y1, j;
                  ^
modules/imgcodecs/src/grfmt_jpeg2000.cpp:364:19: style: The scope of the variable 'y1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x, y, x1, y1, j;
                  ^
modules/imgcodecs/src/grfmt_pam.hpp:69:11: style: The function 'readData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_base.hpp:72:18: note: Virtual function in base class
    virtual bool readData( Mat& img ) = 0;
                 ^
modules/imgcodecs/src/grfmt_pam.hpp:69:11: note: Function in derived class
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_pam.hpp:70:11: style: The function 'readHeader' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_base.hpp:71:18: note: Virtual function in base class
    virtual bool readHeader() = 0;
                 ^
modules/imgcodecs/src/grfmt_pam.hpp:70:11: note: Function in derived class
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_pam.hpp:72:12: style: The function 'signatureLength' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    size_t signatureLength() const;
           ^
modules/imgcodecs/src/grfmt_base.hpp:77:20: note: Virtual function in base class
    virtual size_t signatureLength() const;
                   ^
modules/imgcodecs/src/grfmt_pam.hpp:72:12: note: Function in derived class
    size_t signatureLength() const;
           ^
modules/imgcodecs/src/grfmt_pam.hpp:73:10: style: The function 'checkSignature' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool checkSignature( const String& signature ) const;
         ^
modules/imgcodecs/src/grfmt_base.hpp:78:18: note: Virtual function in base class
    virtual bool checkSignature( const String& signature ) const;
                 ^
modules/imgcodecs/src/grfmt_pam.hpp:73:10: note: Function in derived class
    bool checkSignature( const String& signature ) const;
         ^
modules/imgcodecs/src/grfmt_pam.hpp:91:11: style: The function 'isFormatSupported' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  isFormatSupported( int depth ) const;
          ^
modules/imgcodecs/src/grfmt_base.hpp:99:18: note: Virtual function in base class
    virtual bool isFormatSupported( int depth ) const;
                 ^
modules/imgcodecs/src/grfmt_pam.hpp:91:11: note: Function in derived class
    bool  isFormatSupported( int depth ) const;
          ^
modules/imgcodecs/src/grfmt_pam.hpp:92:11: style: The function 'write' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_base.hpp:103:18: note: Virtual function in base class
    virtual bool write( const Mat& img, const std::vector<int>& params ) = 0;
                 ^
modules/imgcodecs/src/grfmt_pam.hpp:92:11: note: Function in derived class
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_pam.hpp:94:18: style: The function 'newEncoder' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_base.hpp:106:26: note: Virtual function in base class
    virtual ImageEncoder newEncoder() const;
                         ^
modules/imgcodecs/src/grfmt_pam.hpp:94:18: note: Function in derived class
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_pam.cpp:283:33: warning: Logical disjunction always evaluates to true: code != '\n' || code != '\r'. Are these conditions necessary? Did you intend to use && instead? Are the numbers correct? Are you comparing the correct variables? [incorrectLogicOperator]
        } else if (code != '\n' || code != '\r')
                                ^
modules/imgcodecs/src/grfmt_pam.cpp:521:44: style: Condition '!isBigEndian()' is always true [knownConditionTrueFalse]
            if (m_sampledepth == CV_16U && !isBigEndian())
                                           ^
modules/imgcodecs/src/grfmt_pam.cpp:568:52: style: Condition '!isBigEndian()' is always true [knownConditionTrueFalse]
                    if( m_sampledepth == CV_16U && !isBigEndian() )
                                                   ^
modules/imgcodecs/src/grfmt_pam.cpp:702:13: style: Condition '!isBigEndian()' is always true [knownConditionTrueFalse]
        if (!isBigEndian()) {
            ^
modules/imgcodecs/src/grfmt_pam.cpp:368:9: style: The scope of the variable 'byte' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int byte;
        ^
modules/imgcodecs/src/grfmt_pam.cpp:496:25: style: Variable 'gray_palette' is assigned a value that is never used. [unreadVariable]
    uchar* gray_palette = _gray_palette;
                        ^
modules/imgcodecs/src/grfmt_pam.cpp:694:9: style: Variable 'tmp' is assigned a value that is never used. [unreadVariable]
    tmp += sprintf( buffer + tmp, "ENDHDR\n" );
        ^
modules/imgcodecs/src/grfmt_png.hpp:61:11: style: The function 'readData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_base.hpp:72:18: note: Virtual function in base class
    virtual bool readData( Mat& img ) = 0;
                 ^
modules/imgcodecs/src/grfmt_png.hpp:61:11: note: Function in derived class
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_png.hpp:62:11: style: The function 'readHeader' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_base.hpp:71:18: note: Virtual function in base class
    virtual bool readHeader() = 0;
                 ^
modules/imgcodecs/src/grfmt_png.hpp:62:11: note: Function in derived class
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_png.hpp:87:11: style: The function 'isFormatSupported' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  isFormatSupported( int depth ) const;
          ^
modules/imgcodecs/src/grfmt_base.hpp:99:18: note: Virtual function in base class
    virtual bool isFormatSupported( int depth ) const;
                 ^
modules/imgcodecs/src/grfmt_png.hpp:87:11: note: Function in derived class
    bool  isFormatSupported( int depth ) const;
          ^
modules/imgcodecs/src/grfmt_png.hpp:88:11: style: The function 'write' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_base.hpp:103:18: note: Virtual function in base class
    virtual bool write( const Mat& img, const std::vector<int>& params ) = 0;
                 ^
modules/imgcodecs/src/grfmt_png.hpp:88:11: note: Function in derived class
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_png.hpp:90:18: style: The function 'newEncoder' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_base.hpp:106:26: note: Virtual function in base class
    virtual ImageEncoder newEncoder() const;
                         ^
modules/imgcodecs/src/grfmt_png.hpp:90:18: note: Function in derived class
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_png.cpp:243:22: style: Condition '!isBigEndian()' is always true [knownConditionTrueFalse]
            else if( !isBigEndian() )
                     ^
modules/imgcodecs/src/grfmt_png.cpp:422:25: style: Condition '!isBigEndian()' is always true [knownConditionTrueFalse]
                    if( !isBigEndian() )
                        ^
modules/imgcodecs/src/grfmt_png.cpp:130:27: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    PngDecoder* decoder = (PngDecoder*)(png_get_io_ptr(png_ptr));
                          ^
modules/imgcodecs/src/grfmt_png.cpp:327:27: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    PngEncoder* encoder = (PngEncoder*)(png_get_io_ptr(png_ptr));
                          ^
modules/imgcodecs/src/grfmt_png.cpp:344:9: style: The scope of the variable 'y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int y, width = img.cols, height = img.rows;
        ^
modules/imgcodecs/src/grfmt_pxm.cpp:101:13: warning: Member variable 'PxMDecoder::m_palette' is not initialized in the constructor. [uninitMemberVar]
PxMDecoder::PxMDecoder()
            ^
modules/imgcodecs/src/grfmt_pxm.hpp:59:11: style: The function 'readData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_base.hpp:72:18: note: Virtual function in base class
    virtual bool readData( Mat& img ) = 0;
                 ^
modules/imgcodecs/src/grfmt_pxm.hpp:59:11: note: Function in derived class
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_pxm.hpp:60:11: style: The function 'readHeader' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_base.hpp:71:18: note: Virtual function in base class
    virtual bool readHeader() = 0;
                 ^
modules/imgcodecs/src/grfmt_pxm.hpp:60:11: note: Function in derived class
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_pxm.hpp:63:12: style: The function 'signatureLength' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    size_t signatureLength() const;
           ^
modules/imgcodecs/src/grfmt_base.hpp:77:20: note: Virtual function in base class
    virtual size_t signatureLength() const;
                   ^
modules/imgcodecs/src/grfmt_pxm.hpp:63:12: note: Function in derived class
    size_t signatureLength() const;
           ^
modules/imgcodecs/src/grfmt_pxm.hpp:64:10: style: The function 'checkSignature' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool checkSignature( const String& signature ) const;
         ^
modules/imgcodecs/src/grfmt_base.hpp:78:18: note: Virtual function in base class
    virtual bool checkSignature( const String& signature ) const;
                 ^
modules/imgcodecs/src/grfmt_pxm.hpp:64:10: note: Function in derived class
    bool checkSignature( const String& signature ) const;
         ^
modules/imgcodecs/src/grfmt_pxm.hpp:84:11: style: The function 'isFormatSupported' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  isFormatSupported( int depth ) const;
          ^
modules/imgcodecs/src/grfmt_base.hpp:99:18: note: Virtual function in base class
    virtual bool isFormatSupported( int depth ) const;
                 ^
modules/imgcodecs/src/grfmt_pxm.hpp:84:11: note: Function in derived class
    bool  isFormatSupported( int depth ) const;
          ^
modules/imgcodecs/src/grfmt_pxm.hpp:85:11: style: The function 'write' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_base.hpp:103:18: note: Virtual function in base class
    virtual bool write( const Mat& img, const std::vector<int>& params ) = 0;
                 ^
modules/imgcodecs/src/grfmt_pxm.hpp:85:11: note: Function in derived class
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_pxm.hpp:87:18: style: The function 'newEncoder' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_base.hpp:106:26: note: Virtual function in base class
    virtual ImageEncoder newEncoder() const;
                         ^
modules/imgcodecs/src/grfmt_pxm.hpp:87:18: note: Function in derived class
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_pxm.cpp:301:44: style: Condition '!isBigEndian()' is always true [knownConditionTrueFalse]
                    if( bit_depth == 16 && !isBigEndian() )
                                           ^
modules/imgcodecs/src/grfmt_pxm.cpp:467:32: style: Condition '!isBigEndian()' is always true [knownConditionTrueFalse]
            if( depth == 16 && !isBigEndian() )
                               ^
modules/imgcodecs/src/grfmt_pxm.cpp:90:37: warning: Conversion of string literal "PXM: ReadNumber(): result is too large" to bool always evaluates to true. [incorrectStringBooleanError]
        CV_Assert(val <= INT_MAX && "PXM: ReadNumber(): result is too large");
                                    ^
modules/imgcodecs/src/grfmt_sunras.cpp:53:19: warning: Member variable 'SunRasterDecoder::m_palette' is not initialized in the constructor. [uninitMemberVar]
SunRasterDecoder::SunRasterDecoder()
                  ^
modules/imgcodecs/src/grfmt_sunras.hpp:74:11: style: The function 'readData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_base.hpp:72:18: note: Virtual function in base class
    virtual bool readData( Mat& img ) = 0;
                 ^
modules/imgcodecs/src/grfmt_sunras.hpp:74:11: note: Function in derived class
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_sunras.hpp:75:11: style: The function 'readHeader' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_base.hpp:71:18: note: Virtual function in base class
    virtual bool readHeader() = 0;
                 ^
modules/imgcodecs/src/grfmt_sunras.hpp:75:11: note: Function in derived class
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_sunras.hpp:98:10: style: The function 'write' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool write( const Mat& img, const std::vector<int>& params );
         ^
modules/imgcodecs/src/grfmt_base.hpp:103:18: note: Virtual function in base class
    virtual bool write( const Mat& img, const std::vector<int>& params ) = 0;
                 ^
modules/imgcodecs/src/grfmt_sunras.hpp:98:10: note: Function in derived class
    bool write( const Mat& img, const std::vector<int>& params );
         ^
modules/imgcodecs/src/grfmt_sunras.hpp:100:18: style: The function 'newEncoder' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_base.hpp:106:26: note: Virtual function in base class
    virtual ImageEncoder newEncoder() const;
                         ^
modules/imgcodecs/src/grfmt_sunras.hpp:100:18: note: Function in derived class
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_sunras.cpp:405:9: style: The scope of the variable 'y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int y, width = img.cols, height = img.rows, channels = img.channels();
        ^
modules/imgcodecs/src/grfmt_tiff.cpp:598:5: style: Class 'TiffEncoderBufHelper' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    TiffEncoderBufHelper(std::vector<uchar> *buf)
    ^
modules/imgcodecs/src/grfmt_tiff.hpp:99:11: style: The function 'readHeader' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_base.hpp:71:18: note: Virtual function in base class
    virtual bool readHeader() = 0;
                 ^
modules/imgcodecs/src/grfmt_tiff.hpp:99:11: note: Function in derived class
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_tiff.hpp:100:11: style: The function 'readData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_base.hpp:72:18: note: Virtual function in base class
    virtual bool readData( Mat& img ) = 0;
                 ^
modules/imgcodecs/src/grfmt_tiff.hpp:100:11: note: Function in derived class
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_tiff.hpp:102:11: style: The function 'nextPage' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  nextPage();
          ^
modules/imgcodecs/src/grfmt_base.hpp:75:18: note: Virtual function in base class
    virtual bool nextPage() { return false; }
                 ^
modules/imgcodecs/src/grfmt_tiff.hpp:102:11: note: Function in derived class
    bool  nextPage();
          ^
modules/imgcodecs/src/grfmt_tiff.hpp:104:12: style: The function 'signatureLength' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    size_t signatureLength() const;
           ^
modules/imgcodecs/src/grfmt_base.hpp:77:20: note: Virtual function in base class
    virtual size_t signatureLength() const;
                   ^
modules/imgcodecs/src/grfmt_tiff.hpp:104:12: note: Function in derived class
    size_t signatureLength() const;
           ^
modules/imgcodecs/src/grfmt_tiff.hpp:105:10: style: The function 'checkSignature' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool checkSignature( const String& signature ) const;
         ^
modules/imgcodecs/src/grfmt_base.hpp:78:18: note: Virtual function in base class
    virtual bool checkSignature( const String& signature ) const;
                 ^
modules/imgcodecs/src/grfmt_tiff.hpp:105:10: note: Function in derived class
    bool checkSignature( const String& signature ) const;
         ^
modules/imgcodecs/src/grfmt_tiff.hpp:127:10: style: The function 'isFormatSupported' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool isFormatSupported( int depth ) const;
         ^
modules/imgcodecs/src/grfmt_base.hpp:99:18: note: Virtual function in base class
    virtual bool isFormatSupported( int depth ) const;
                 ^
modules/imgcodecs/src/grfmt_tiff.hpp:127:10: note: Function in derived class
    bool isFormatSupported( int depth ) const;
         ^
modules/imgcodecs/src/grfmt_tiff.hpp:129:11: style: The function 'write' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_base.hpp:103:18: note: Virtual function in base class
    virtual bool write( const Mat& img, const std::vector<int>& params ) = 0;
                 ^
modules/imgcodecs/src/grfmt_tiff.hpp:129:11: note: Function in derived class
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_tiff.hpp:130:18: style: The function 'newEncoder' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_base.hpp:106:26: note: Virtual function in base class
    virtual ImageEncoder newEncoder() const;
                         ^
modules/imgcodecs/src/grfmt_tiff.hpp:130:18: note: Function in derived class
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_tiff.cpp:273:20: style: Variable 'result' is reassigned a value before the old one has been used. [redundantAssignment]
            result = true;
                   ^
modules/imgcodecs/src/grfmt_tiff.cpp:271:28: note: result is assigned
                    result = false;
                           ^
modules/imgcodecs/src/grfmt_tiff.cpp:273:20: note: result is overwritten
            result = true;
                   ^
modules/imgcodecs/src/grfmt_tiff.cpp:308:13: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int x, y, i;
            ^
modules/imgcodecs/src/grfmt_tiff.cpp:308:16: style: The scope of the variable 'y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int x, y, i;
               ^
modules/imgcodecs/src/grfmt_tiff.cpp:308:19: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int x, y, i;
                  ^
modules/imgcodecs/src/grfmt_tiff.cpp:136:24: style: Local variable 'size' shadows outer function [shadowFunction]
        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();
                       ^
modules/imgcodecs/src/grfmt_tiff.cpp:185:19: note: Shadowed declaration
    static toff_t size( thandle_t handle )
                  ^
modules/imgcodecs/src/grfmt_tiff.cpp:136:24: note: Shadow variable
        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();
                       ^
modules/imgcodecs/src/grfmt_tiff.cpp:157:22: style: Local variable 'size' shadows outer function [shadowFunction]
        const toff_t size = buf.cols*buf.rows*buf.elemSize();
                     ^
modules/imgcodecs/src/grfmt_tiff.cpp:185:19: note: Shadowed declaration
    static toff_t size( thandle_t handle )
                  ^
modules/imgcodecs/src/grfmt_tiff.cpp:157:22: note: Shadow variable
        const toff_t size = buf.cols*buf.rows*buf.elemSize();
                     ^
modules/imgcodecs/src/grfmt_tiff.cpp:633:22: style: Local variable 'size' shadows outer function [shadowFunction]
        const toff_t size = helper->m_buf->size();
                     ^
modules/imgcodecs/src/grfmt_tiff.cpp:651:19: note: Shadowed declaration
    static toff_t size( thandle_t handle )
                  ^
modules/imgcodecs/src/grfmt_tiff.cpp:633:22: note: Shadow variable
        const toff_t size = helper->m_buf->size();
                     ^
modules/imgcodecs/src/grfmt_webp.hpp:62:10: style: The function 'readData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool readData( Mat& img );
         ^
modules/imgcodecs/src/grfmt_base.hpp:72:18: note: Virtual function in base class
    virtual bool readData( Mat& img ) = 0;
                 ^
modules/imgcodecs/src/grfmt_webp.hpp:62:10: note: Function in derived class
    bool readData( Mat& img );
         ^
modules/imgcodecs/src/grfmt_webp.hpp:63:10: style: The function 'readHeader' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool readHeader();
         ^
modules/imgcodecs/src/grfmt_base.hpp:71:18: note: Virtual function in base class
    virtual bool readHeader() = 0;
                 ^
modules/imgcodecs/src/grfmt_webp.hpp:63:10: note: Function in derived class
    bool readHeader();
         ^
modules/imgcodecs/src/grfmt_webp.hpp:66:12: style: The function 'signatureLength' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    size_t signatureLength() const;
           ^
modules/imgcodecs/src/grfmt_base.hpp:77:20: note: Virtual function in base class
    virtual size_t signatureLength() const;
                   ^
modules/imgcodecs/src/grfmt_webp.hpp:66:12: note: Function in derived class
    size_t signatureLength() const;
           ^
modules/imgcodecs/src/grfmt_webp.hpp:67:10: style: The function 'checkSignature' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool checkSignature( const String& signature) const;
         ^
modules/imgcodecs/src/grfmt_base.hpp:78:18: note: Virtual function in base class
    virtual bool checkSignature( const String& signature ) const;
                 ^
modules/imgcodecs/src/grfmt_webp.hpp:67:10: note: Function in derived class
    bool checkSignature( const String& signature) const;
         ^
modules/imgcodecs/src/grfmt_webp.hpp:82:10: style: The function 'write' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool write(const Mat& img, const std::vector<int>& params);
         ^
modules/imgcodecs/src/grfmt_base.hpp:103:18: note: Virtual function in base class
    virtual bool write( const Mat& img, const std::vector<int>& params ) = 0;
                 ^
modules/imgcodecs/src/grfmt_webp.hpp:82:10: note: Function in derived class
    bool write(const Mat& img, const std::vector<int>& params);
         ^
modules/imgcodecs/src/grfmt_webp.hpp:84:18: style: The function 'newEncoder' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_base.hpp:106:26: note: Virtual function in base class
    virtual ImageEncoder newEncoder() const;
                         ^
modules/imgcodecs/src/grfmt_webp.hpp:84:18: note: Function in derived class
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_webp.cpp:122:61: warning: Either the condition 'if(wfile)' is redundant or there is possible null pointer dereference: wfile. [nullPointerRedundantCheck]
        size_t data_size = fread(data.ptr(), 1, wfile_size, wfile);
                                                            ^
modules/imgcodecs/src/grfmt_webp.cpp:124:11: note: Assuming that condition 'if(wfile)' is not redundant
        if(wfile)
          ^
modules/imgcodecs/src/grfmt_webp.cpp:122:61: note: Null pointer dereference
        size_t data_size = fread(data.ptr(), 1, wfile_size, wfile);
                                                            ^
modules/imgcodecs/src/loadsave.cpp:913:16: warning: Either the condition 'f!=0' is redundant or there is possible null pointer dereference: f. [nullPointerRedundantCheck]
        fseek( f, 0, SEEK_END );
               ^
modules/imgcodecs/src/loadsave.cpp:912:21: note: Assuming that condition 'f!=0' is not redundant
        CV_Assert(f != 0);
                    ^
modules/imgcodecs/src/loadsave.cpp:911:24: note: Assignment 'f=fopen(filename.c_str(),"rb")', assigned value is 0
        FILE* f = fopen( filename.c_str(), "rb" );
                       ^
modules/imgcodecs/src/loadsave.cpp:913:16: note: Null pointer dereference
        fseek( f, 0, SEEK_END );
               ^
modules/imgcodecs/src/loadsave.cpp:914:26: warning: Either the condition 'f!=0' is redundant or there is possible null pointer dereference: f. [nullPointerRedundantCheck]
        long pos = ftell(f);
                         ^
modules/imgcodecs/src/loadsave.cpp:912:21: note: Assuming that condition 'f!=0' is not redundant
        CV_Assert(f != 0);
                    ^
modules/imgcodecs/src/loadsave.cpp:911:24: note: Assignment 'f=fopen(filename.c_str(),"rb")', assigned value is 0
        FILE* f = fopen( filename.c_str(), "rb" );
                       ^
modules/imgcodecs/src/loadsave.cpp:914:26: note: Null pointer dereference
        long pos = ftell(f);
                         ^
modules/imgcodecs/src/loadsave.cpp:916:16: warning: Either the condition 'f!=0' is redundant or there is possible null pointer dereference: f. [nullPointerRedundantCheck]
        fseek( f, 0, SEEK_SET );
               ^
modules/imgcodecs/src/loadsave.cpp:912:21: note: Assuming that condition 'f!=0' is not redundant
        CV_Assert(f != 0);
                    ^
modules/imgcodecs/src/loadsave.cpp:911:24: note: Assignment 'f=fopen(filename.c_str(),"rb")', assigned value is 0
        FILE* f = fopen( filename.c_str(), "rb" );
                       ^
modules/imgcodecs/src/loadsave.cpp:916:16: note: Null pointer dereference
        fseek( f, 0, SEEK_SET );
               ^
modules/imgcodecs/src/loadsave.cpp:917:51: warning: Either the condition 'f!=0' is redundant or there is possible null pointer dereference: f. [nullPointerRedundantCheck]
        buf.resize(fread( &buf[0], 1, buf.size(), f ));
                                                  ^
modules/imgcodecs/src/loadsave.cpp:912:21: note: Assuming that condition 'f!=0' is not redundant
        CV_Assert(f != 0);
                    ^
modules/imgcodecs/src/loadsave.cpp:911:24: note: Assignment 'f=fopen(filename.c_str(),"rb")', assigned value is 0
        FILE* f = fopen( filename.c_str(), "rb" );
                       ^
modules/imgcodecs/src/loadsave.cpp:917:51: note: Null pointer dereference
        buf.resize(fread( &buf[0], 1, buf.size(), f ));
                                                  ^
modules/imgcodecs/src/loadsave.cpp:918:16: warning: Either the condition 'f!=0' is redundant or there is possible null pointer dereference: f. [nullPointerRedundantCheck]
        fclose(f);
               ^
modules/imgcodecs/src/loadsave.cpp:912:21: note: Assuming that condition 'f!=0' is not redundant
        CV_Assert(f != 0);
                    ^
modules/imgcodecs/src/loadsave.cpp:911:24: note: Assignment 'f=fopen(filename.c_str(),"rb")', assigned value is 0
        FILE* f = fopen( filename.c_str(), "rb" );
                       ^
modules/imgcodecs/src/loadsave.cpp:918:16: note: Null pointer dereference
        fclose(f);
               ^
modules/imgcodecs/src/loadsave.cpp:1005:50: warning: Either the condition '_params' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
        i > 0 ? std::vector<int>(_params, _params+i) : std::vector<int>() );
                                                 ^
modules/imgcodecs/src/loadsave.cpp:990:9: note: Assuming that condition '_params' is not redundant
    if( _params )
        ^
modules/imgcodecs/src/loadsave.cpp:1005:50: note: Null pointer addition
        i > 0 ? std::vector<int>(_params, _params+i) : std::vector<int>() );
                                                 ^
modules/imgcodecs/src/grfmt_jpeg.hpp:63:11: style: The function 'readData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_base.hpp:72:18: note: Virtual function in base class
    virtual bool readData( Mat& img ) = 0;
                 ^
modules/imgcodecs/src/grfmt_jpeg.hpp:63:11: note: Function in derived class
    bool  readData( Mat& img );
          ^
modules/imgcodecs/src/grfmt_jpeg.hpp:64:11: style: The function 'readHeader' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_base.hpp:71:18: note: Virtual function in base class
    virtual bool readHeader() = 0;
                 ^
modules/imgcodecs/src/grfmt_jpeg.hpp:64:11: note: Function in derived class
    bool  readHeader();
          ^
modules/imgcodecs/src/grfmt_jpeg.hpp:86:11: style: The function 'write' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_base.hpp:103:18: note: Virtual function in base class
    virtual bool write( const Mat& img, const std::vector<int>& params ) = 0;
                 ^
modules/imgcodecs/src/grfmt_jpeg.hpp:86:11: note: Function in derived class
    bool  write( const Mat& img, const std::vector<int>& params );
          ^
modules/imgcodecs/src/grfmt_jpeg.hpp:87:18: style: The function 'newEncoder' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/grfmt_base.hpp:106:26: note: Virtual function in base class
    virtual ImageEncoder newEncoder() const;
                         ^
modules/imgcodecs/src/grfmt_jpeg.hpp:87:18: note: Function in derived class
    ImageEncoder newEncoder() const;
                 ^
modules/imgcodecs/src/rgbe.cpp:134:9: style: The scope of the variable 'f' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  float f;
        ^
modules/imgcodecs/src/rgbe.cpp:275:12: style: The scope of the variable 'beg_run' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int cur, beg_run, run_count, old_run_count, nonrun_count;
           ^
modules/imgcodecs/src/rgbe.cpp:275:21: style: The scope of the variable 'run_count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int cur, beg_run, run_count, old_run_count, nonrun_count;
                    ^
modules/imgcodecs/src/rgbe.cpp:275:32: style: The scope of the variable 'old_run_count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int cur, beg_run, run_count, old_run_count, nonrun_count;
                               ^
modules/imgcodecs/src/rgbe.cpp:373:45: style: The scope of the variable 'ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  unsigned char rgbe[4], *scanline_buffer, *ptr, *ptr_end;
                                            ^
modules/imgcodecs/src/utils.cpp:477:11: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        *((PaletteEntry*)(data-3)) = palette[*indices++];
          ^
modules/imgcodecs/src/utils.cpp:503:11: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        *((PaletteEntry*)(data-6)) = palette[idx >> 4];
          ^
modules/imgcodecs/src/utils.cpp:504:11: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        *((PaletteEntry*)(data-3)) = palette[idx & 15];
          ^
modules/imgcodecs/src/utils.cpp:552:11: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        *((PaletteEntry*)(data - 24)) = (idx & 128) ? p1 : p0;
          ^
modules/imgcodecs/src/utils.cpp:553:11: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        *((PaletteEntry*)(data - 21)) = (idx & 64) ? p1 : p0;
          ^
modules/imgcodecs/src/utils.cpp:554:11: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        *((PaletteEntry*)(data - 18)) = (idx & 32) ? p1 : p0;
          ^
modules/imgcodecs/src/utils.cpp:555:11: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        *((PaletteEntry*)(data - 15)) = (idx & 16) ? p1 : p0;
          ^
modules/imgcodecs/src/utils.cpp:556:11: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        *((PaletteEntry*)(data - 12)) = (idx & 8) ? p1 : p0;
          ^
modules/imgcodecs/src/utils.cpp:557:11: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        *((PaletteEntry*)(data - 9)) = (idx & 4) ? p1 : p0;
          ^
modules/imgcodecs/src/utils.cpp:558:11: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        *((PaletteEntry*)(data - 6)) = (idx & 2) ? p1 : p0;
          ^
modules/imgcodecs/src/utils.cpp:559:11: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        *((PaletteEntry*)(data - 3)) = (idx & 1) ? p1 : p0;
          ^
modules/imgcodecs/test/test_tiff.cpp:78:62: warning: Either the condition 'fp!=NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
        ASSERT_EQ((size_t)1, fwrite(tiff_sample_data, 86, 1, fp));
                                                             ^
modules/imgcodecs/test/test_tiff.cpp:77:24: note: Assuming that condition 'fp!=NULL' is not redundant
        ASSERT_TRUE(fp != NULL);
                       ^
modules/imgcodecs/test/test_tiff.cpp:76:25: note: Assignment 'fp=fopen(filename.c_str(),"wb")', assigned value is 0
        FILE* fp = fopen(filename.c_str(), "wb");
                        ^
modules/imgcodecs/test/test_tiff.cpp:78:62: note: Null pointer dereference
        ASSERT_EQ((size_t)1, fwrite(tiff_sample_data, 86, 1, fp));
                                                             ^
modules/imgcodecs/test/test_tiff.cpp:79:16: warning: Either the condition 'fp!=NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
        fclose(fp);
               ^
modules/imgcodecs/test/test_tiff.cpp:77:24: note: Assuming that condition 'fp!=NULL' is not redundant
        ASSERT_TRUE(fp != NULL);
                       ^
modules/imgcodecs/test/test_tiff.cpp:76:25: note: Assignment 'fp=fopen(filename.c_str(),"wb")', assigned value is 0
        FILE* fp = fopen(filename.c_str(), "wb");
                        ^
modules/imgcodecs/test/test_tiff.cpp:79:16: note: Null pointer dereference
        fclose(fp);
               ^
modules/imgcodecs/test/test_webp.cpp:36:12: style: Condition 'wfile' is always true [knownConditionTrueFalse]
        if(wfile)
           ^
modules/imgcodecs/test/test_webp.cpp:26:15: note: Assuming that condition 'wfile!=NULL' is not redundant
    if (wfile != NULL)
              ^
modules/imgcodecs/test/test_webp.cpp:36:12: note: Condition 'wfile' is always true
        if(wfile)
           ^
modules/imgproc/perf/opencl/perf_3vs4.cpp:23:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(Modes, Pure, Split, Convert)
^
modules/imgproc/perf/opencl/perf_accumulate.cpp:79:1: error: syntax error [syntaxError]
OCL_PERF_TEST_P(AccumulateSquareFixture, AccumulateSquare,
^
modules/imgproc/perf/opencl/perf_color.cpp:59:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(ConversionTypes, COLOR_RGB2GRAY, COLOR_RGB2BGR, COLOR_RGB2YUV, COLOR_YUV2RGB, COLOR_RGB2YCrCb,
^
modules/imgproc/perf/opencl/perf_filters.cpp:173:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(MorphOp, MORPH_OPEN, MORPH_CLOSE, MORPH_GRADIENT, MORPH_TOPHAT, MORPH_BLACKHAT)
^
modules/imgproc/perf/opencl/perf_houghlines.cpp:30:1: error: syntax error [syntaxError]
OCL_PERF_TEST_P(HoughLinesFixture, HoughLines, Combine(OCL_TEST_SIZES,
^
modules/imgproc/perf/opencl/perf_imgproc.cpp:126:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(Border, BORDER_CONSTANT, BORDER_REPLICATE, BORDER_REFLECT, BORDER_WRAP, BORDER_REFLECT_101)
^
modules/imgproc/perf/opencl/perf_imgwarp.cpp:57:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(InterType, INTER_NEAREST, INTER_LINEAR, INTER_CUBIC)
^
modules/imgproc/perf/opencl/perf_matchTemplate.cpp:10:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(MethodType, TM_SQDIFF, TM_SQDIFF_NORMED, TM_CCORR, TM_CCORR_NORMED, TM_CCOEFF, TM_CCOEFF_NORMED)
^
modules/imgproc/perf/opencl/perf_pyramid.cpp:83:1: error: syntax error [syntaxError]
OCL_PERF_TEST_P(PyrUpFixture, PyrUp,
^
modules/imgproc/perf/perf_bilateral.cpp:10:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(Mat_Type, CV_8UC1, CV_8UC3, CV_32FC1, CV_32FC3)
^
modules/imgproc/perf/perf_blur.cpp:37:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(BorderType3x3, BORDER_REPLICATE, BORDER_CONSTANT)
^
modules/imgproc/perf/perf_corners.cpp:9:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(BorderType, BORDER_REPLICATE, BORDER_CONSTANT, BORDER_REFLECT, BORDER_REFLECT_101)
^
modules/imgproc/perf/perf_cvt_color.cpp:355:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(EdgeAwareBayerMode, COLOR_BayerBG2BGR_EA, COLOR_BayerGB2BGR_EA, COLOR_BayerRG2BGR_EA, COLOR_BayerGR2BGR_EA)
^
modules/imgproc/perf/perf_distanceTransform.cpp:33:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(DistanceType, DIST_L1, DIST_L2 , DIST_C)
^
modules/imgproc/perf/perf_filter2d.cpp:11:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(BorderMode, BORDER_CONSTANT, BORDER_REPLICATE, BORDER_REFLECT_101)
^
modules/imgproc/perf/perf_matchTemplate.cpp:9:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(MethodType, TM_SQDIFF, TM_SQDIFF_NORMED, TM_CCORR, TM_CCORR_NORMED, TM_CCOEFF, TM_CCOEFF_NORMED)
^
modules/imgproc/perf/perf_moments.cpp:40:9: style: Variable 'mat' is assigned a value that is never used. [unreadVariable]
    mat += 1;
        ^
modules/imgproc/perf/perf_remap.cpp:10:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(InterType, INTER_NEAREST, INTER_LINEAR, INTER_CUBIC, INTER_LANCZOS4)
^
modules/imgproc/perf/perf_sepfilters.cpp:11:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(BorderType3x3, BORDER_REPLICATE, BORDER_CONSTANT)
^
modules/imgproc/perf/perf_threshold.cpp:9:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(ThreshType, THRESH_BINARY, THRESH_BINARY_INV, THRESH_TRUNC, THRESH_TOZERO, THRESH_TOZERO_INV)
^
modules/imgproc/perf/perf_warp.cpp:12:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(BorderMode, BORDER_CONSTANT, BORDER_REPLICATE)
^
modules/imgproc/src/accum.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/accum.cpp:191:23: style: Variable 'ippiAdd_I' is assigned a value that is never used. [unreadVariable]
            ippiAdd_I = sdepth == CV_8U && ddepth == CV_32F ? (IppiAdd)ippiAdd_8u32f_C1IR :
                      ^
modules/imgproc/src/accum.simd.hpp:2812:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0;
        ^
modules/imgproc/src/accum.simd.hpp:2835:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0;
        ^
modules/imgproc/src/accum.simd.hpp:2863:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0;
        ^
modules/imgproc/src/accum.simd.hpp:2887:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0;
        ^
modules/imgproc/src/accum.simd.hpp:2911:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0;
        ^
modules/imgproc/src/accum.simd.hpp:2941:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0;
        ^
modules/imgproc/src/accum.simd.hpp:2966:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0;
        ^
modules/imgproc/src/accum.simd.hpp:2991:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0;
        ^
modules/imgproc/src/accum.simd.hpp:3024:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0;
        ^
modules/imgproc/src/accum.simd.hpp:3050:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0;
        ^
modules/imgproc/src/accum.simd.hpp:3074:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0;
        ^
modules/imgproc/src/accum.simd.hpp:3106:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x = 0;
        ^
modules/imgproc/src/approx.cpp:504:28: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int             i = 0, j, pos = 0, wpos, count = count0, new_count=0;
                           ^
modules/imgproc/src/approx.cpp:541:20: style: The scope of the variable 'dist' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            double dist, max_dist = 0;
                   ^
modules/imgproc/src/approx.cpp:588:28: style: The scope of the variable 'dist' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            double dx, dy, dist, max_dist = 0;
                           ^
modules/imgproc/src/blend.cpp:70:52: style: Parameter 'val0' can be declared with const [constParameter]
static inline v_uint8x16 pack_f32tou8(v_float32x4& val0, v_float32x4& val1, v_float32x4& val2, v_float32x4& val3)
                                                   ^
modules/imgproc/src/blend.cpp:70:71: style: Parameter 'val1' can be declared with const [constParameter]
static inline v_uint8x16 pack_f32tou8(v_float32x4& val0, v_float32x4& val1, v_float32x4& val2, v_float32x4& val3)
                                                                      ^
modules/imgproc/src/blend.cpp:70:90: style: Parameter 'val2' can be declared with const [constParameter]
static inline v_uint8x16 pack_f32tou8(v_float32x4& val0, v_float32x4& val1, v_float32x4& val2, v_float32x4& val3)
                                                                                         ^
modules/imgproc/src/blend.cpp:70:109: style: Parameter 'val3' can be declared with const [constParameter]
static inline v_uint8x16 pack_f32tou8(v_float32x4& val0, v_float32x4& val1, v_float32x4& val2, v_float32x4& val3)
                                                                                                            ^
modules/imgproc/src/canny.cpp:349:20: warning: Member variable 'parallelCanny::low' is not assigned a value in 'parallelCanny::operator='. [operatorEqVarError]
    parallelCanny& operator=(const parallelCanny&) { return *this; }
                   ^
modules/imgproc/src/canny.cpp:349:20: warning: Member variable 'parallelCanny::high' is not assigned a value in 'parallelCanny::operator='. [operatorEqVarError]
    parallelCanny& operator=(const parallelCanny&) { return *this; }
                   ^
modules/imgproc/src/canny.cpp:349:20: warning: Member variable 'parallelCanny::aperture_size' is not assigned a value in 'parallelCanny::operator='. [operatorEqVarError]
    parallelCanny& operator=(const parallelCanny&) { return *this; }
                   ^
modules/imgproc/src/canny.cpp:349:20: warning: Member variable 'parallelCanny::mapstep' is not assigned a value in 'parallelCanny::operator='. [operatorEqVarError]
    parallelCanny& operator=(const parallelCanny&) { return *this; }
                   ^
modules/imgproc/src/canny.cpp:349:20: warning: Member variable 'parallelCanny::cn' is not assigned a value in 'parallelCanny::operator='. [operatorEqVarError]
    parallelCanny& operator=(const parallelCanny&) { return *this; }
                   ^
modules/imgproc/src/canny.cpp:939:77: warning: Conversion of string literal "Inplace parameters are not supported" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert((_dst.getObj() != _src.getObj() || _src.type() == CV_8UC1) && "Inplace parameters are not supported");
                                                                            ^
modules/imgproc/src/canny.cpp:100:9: style: The exception is caught by value. It could be caught as a (const) reference which is usually recommended in C++. [catchExceptionByValue]
        catch (::ipp::IwException ex)
        ^
modules/imgproc/src/color.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/color.cpp:1086:5: style: Struct 'Gray2RGB5x5' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Gray2RGB5x5(int _greenBits) : greenBits(_greenBits)
    ^
modules/imgproc/src/color.cpp:1207:5: style: Struct 'RGB5x52Gray' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    RGB5x52Gray(int _greenBits) : greenBits(_greenBits)
    ^
modules/imgproc/src/color.cpp:1059:5: style: Struct 'Gray2RGB < uchar >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Gray2RGB(int _dstcn) : dstcn(_dstcn) {}
    ^
modules/imgproc/src/color.cpp:1059:5: style: Struct 'Gray2RGB < ushort >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Gray2RGB(int _dstcn) : dstcn(_dstcn) {}
    ^
modules/imgproc/src/color.cpp:1059:5: style: Struct 'Gray2RGB < float >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Gray2RGB(int _dstcn) : dstcn(_dstcn) {}
    ^
modules/imgproc/src/color.cpp:4868:16: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i, j, dcn = dstcn;
               ^
modules/imgproc/src/color.cpp:5236:16: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i, j, scn = srccn;
               ^
modules/imgproc/src/color.cpp:5658:16: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i, j, dcn = dstcn;
               ^
modules/imgproc/src/color.cpp:7336:16: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i, j, dcn = dstcn;
               ^
modules/imgproc/src/color.cpp:8258:16: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i, j, scn = srccn;
               ^
modules/imgproc/src/color.cpp:8648:16: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i, j, dcn = dstcn;
               ^
modules/imgproc/src/color.cpp:946:41: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                    dst[3] = t & 0x8000 ? 255 : 0;
                                        ^
modules/imgproc/src/color.cpp:719:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_alpha' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_alpha = vdupq_n_u8(ColorChannel<uchar>::max());
        ^
modules/imgproc/src/color.cpp:857:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_n3' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_n3 = vdupq_n_u16(~3);
        ^
modules/imgproc/src/color.cpp:967:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_n3' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_n3 = vdup_n_u8(~3);
        ^
modules/imgproc/src/color.cpp:1089:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_n7' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_n7 = vdup_n_u8(~7);
        ^
modules/imgproc/src/color.cpp:1210:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_b2y' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_b2y = vdup_n_u16(B2Y);
        ^
modules/imgproc/src/color.cpp:4818:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_scale_inv' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_scale_inv = vdupq_n_f32(1.f/255.f);
        ^
modules/imgproc/src/color.cpp:5200:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_scale_inv' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_scale_inv = vdupq_n_f32(1.f/255.f);
        ^
modules/imgproc/src/color.cpp:5608:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_scale_inv' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_scale_inv = vdupq_n_f32(1.f/255.f);
        ^
modules/imgproc/src/color.cpp:7275:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_scale_inv' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_scale_inv = vdupq_n_f32(100.f/255.f);
        ^
modules/imgproc/src/color.cpp:8210:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_scale_inv' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_scale_inv = vdupq_n_f32(softfloat::one()/f255);
        ^
modules/imgproc/src/color.cpp:4822:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_scale' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_scale = _mm_set1_ps(255.0f);
        ^
modules/imgproc/src/color.cpp:5204:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_scale_inv' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_scale_inv = _mm_set1_ps(1.f/255.f);
        ^
modules/imgproc/src/color.cpp:5612:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_scale' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_scale = _mm_set1_ps(255.f);
        ^
modules/imgproc/src/color.cpp:7280:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_scale' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_scale = _mm_set1_ps(255.f);
        ^
modules/imgproc/src/color.cpp:8218:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'v_zero' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        v_zero = _mm_setzero_si128();
        ^
modules/imgproc/src/colormap.cpp:186:14: warning: Virtual function 'init' is called from constructor 'Autumn()' at line 179. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:179:13: note: Calling init
            init(256);
            ^
modules/imgproc/src/colormap.cpp:186:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:186:14: warning: Virtual function 'init' is called from constructor 'Autumn(int n)' at line 183. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:183:13: note: Calling init
            init(n);
            ^
modules/imgproc/src/colormap.cpp:186:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:210:14: warning: Virtual function 'init' is called from constructor 'Bone()' at line 203. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:203:13: note: Calling init
            init(256);
            ^
modules/imgproc/src/colormap.cpp:210:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:210:14: warning: Virtual function 'init' is called from constructor 'Bone(int n)' at line 207. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:207:13: note: Calling init
            init(n);
            ^
modules/imgproc/src/colormap.cpp:210:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:237:14: warning: Virtual function 'init' is called from constructor 'Jet()' at line 231. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:231:13: note: Calling init
            init(256);
            ^
modules/imgproc/src/colormap.cpp:237:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:237:14: warning: Virtual function 'init' is called from constructor 'Jet(int n)' at line 234. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:234:13: note: Calling init
            init(n);
            ^
modules/imgproc/src/colormap.cpp:237:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:264:14: warning: Virtual function 'init' is called from constructor 'Winter()' at line 257. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:257:13: note: Calling init
            init(256);
            ^
modules/imgproc/src/colormap.cpp:264:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:264:14: warning: Virtual function 'init' is called from constructor 'Winter(int n)' at line 261. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:261:13: note: Calling init
            init(n);
            ^
modules/imgproc/src/colormap.cpp:264:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:288:14: warning: Virtual function 'init' is called from constructor 'Rainbow()' at line 281. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:281:13: note: Calling init
            init(256);
            ^
modules/imgproc/src/colormap.cpp:288:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:288:14: warning: Virtual function 'init' is called from constructor 'Rainbow(int n)' at line 285. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:285:13: note: Calling init
            init(n);
            ^
modules/imgproc/src/colormap.cpp:288:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:312:14: warning: Virtual function 'init' is called from constructor 'Ocean()' at line 305. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:305:13: note: Calling init
            init(256);
            ^
modules/imgproc/src/colormap.cpp:312:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:312:14: warning: Virtual function 'init' is called from constructor 'Ocean(int n)' at line 309. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:309:13: note: Calling init
            init(n);
            ^
modules/imgproc/src/colormap.cpp:312:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:336:14: warning: Virtual function 'init' is called from constructor 'Summer()' at line 329. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:329:13: note: Calling init
            init(256);
            ^
modules/imgproc/src/colormap.cpp:336:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:336:14: warning: Virtual function 'init' is called from constructor 'Summer(int n)' at line 333. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:333:13: note: Calling init
            init(n);
            ^
modules/imgproc/src/colormap.cpp:336:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:360:14: warning: Virtual function 'init' is called from constructor 'Spring()' at line 353. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:353:13: note: Calling init
            init(256);
            ^
modules/imgproc/src/colormap.cpp:360:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:360:14: warning: Virtual function 'init' is called from constructor 'Spring(int n)' at line 357. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:357:13: note: Calling init
            init(n);
            ^
modules/imgproc/src/colormap.cpp:360:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:384:14: warning: Virtual function 'init' is called from constructor 'Cool()' at line 377. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:377:13: note: Calling init
            init(256);
            ^
modules/imgproc/src/colormap.cpp:384:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:384:14: warning: Virtual function 'init' is called from constructor 'Cool(int n)' at line 381. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:381:13: note: Calling init
            init(n);
            ^
modules/imgproc/src/colormap.cpp:384:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:408:14: warning: Virtual function 'init' is called from constructor 'HSV()' at line 401. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:401:13: note: Calling init
            init(256);
            ^
modules/imgproc/src/colormap.cpp:408:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:408:14: warning: Virtual function 'init' is called from constructor 'HSV(int n)' at line 405. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:405:13: note: Calling init
            init(n);
            ^
modules/imgproc/src/colormap.cpp:408:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:432:14: warning: Virtual function 'init' is called from constructor 'Pink()' at line 425. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:425:13: note: Calling init
            init(256);
            ^
modules/imgproc/src/colormap.cpp:432:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:432:14: warning: Virtual function 'init' is called from constructor 'Pink(int n)' at line 429. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:429:13: note: Calling init
            init(n);
            ^
modules/imgproc/src/colormap.cpp:432:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:456:14: warning: Virtual function 'init' is called from constructor 'Hot()' at line 449. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:449:13: note: Calling init
            init(256);
            ^
modules/imgproc/src/colormap.cpp:456:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:456:14: warning: Virtual function 'init' is called from constructor 'Hot(int n)' at line 453. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:453:13: note: Calling init
            init(n);
            ^
modules/imgproc/src/colormap.cpp:456:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:480:14: warning: Virtual function 'init' is called from constructor 'Parula()' at line 473. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:473:13: note: Calling init
            init(256);
            ^
modules/imgproc/src/colormap.cpp:480:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:480:14: warning: Virtual function 'init' is called from constructor 'Parula(int n)' at line 477. Dynamic binding is not used. [virtualCallInConstructor]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:477:13: note: Calling init
            init(n);
            ^
modules/imgproc/src/colormap.cpp:480:14: note: init is a virtual function
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:182:9: style: Class 'Autumn' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Autumn(int n) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:206:9: style: Class 'Bone' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Bone(int n) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:233:9: style: Class 'Jet' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Jet(int n) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:260:9: style: Class 'Winter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Winter(int n) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:284:9: style: Class 'Rainbow' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Rainbow(int n) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:308:9: style: Class 'Ocean' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Ocean(int n) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:332:9: style: Class 'Summer' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Summer(int n) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:356:9: style: Class 'Spring' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Spring(int n) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:380:9: style: Class 'Cool' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Cool(int n) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:404:9: style: Class 'HSV' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        HSV(int n) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:428:9: style: Class 'Pink' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Pink(int n) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:452:9: style: Class 'Hot' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Hot(int n) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:476:9: style: Class 'Parula' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Parula(int n) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:497:9: style: Class 'UserColorMap' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        UserColorMap(Mat c) : ColorMap() {
        ^
modules/imgproc/src/colormap.cpp:186:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:186:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:210:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:210:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:237:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:237:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:264:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:264:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:288:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:288:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:312:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:312:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:336:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:336:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:360:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:360:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:384:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:384:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:408:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:408:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:432:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:432:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:456:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:456:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:480:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:480:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:504:14: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        void init(int n) {
             ^
modules/imgproc/src/colormap.cpp:153:22: note: Virtual function in base class
        virtual void init(int n) = 0;
                     ^
modules/imgproc/src/colormap.cpp:504:14: note: Function in derived class
        void init(int n) {
             ^
modules/imgproc/src/connectedcomponents.cpp:284:38: warning: Member variable 'FirstScan8Connectivity::P_' is not assigned a value in 'FirstScan8Connectivity::operator='. [operatorEqVarError]
            FirstScan8Connectivity&  operator=(const FirstScan8Connectivity& ) { return *this; }
                                     ^
modules/imgproc/src/connectedcomponents.cpp:284:38: warning: Member variable 'FirstScan8Connectivity::chunksSizeAndLabels_' is not assigned a value in 'FirstScan8Connectivity::operator='. [operatorEqVarError]
            FirstScan8Connectivity&  operator=(const FirstScan8Connectivity& ) { return *this; }
                                     ^
modules/imgproc/src/connectedcomponents.cpp:386:38: warning: Member variable 'FirstScan4Connectivity::P_' is not assigned a value in 'FirstScan4Connectivity::operator='. [operatorEqVarError]
            FirstScan4Connectivity&  operator=(const FirstScan4Connectivity& ) { return *this; }
                                     ^
modules/imgproc/src/connectedcomponents.cpp:386:38: warning: Member variable 'FirstScan4Connectivity::chunksSizeAndLabels_' is not assigned a value in 'FirstScan4Connectivity::operator='. [operatorEqVarError]
            FirstScan4Connectivity&  operator=(const FirstScan4Connectivity& ) { return *this; }
                                     ^
modules/imgproc/src/connectedcomponents.cpp:463:26: warning: Member variable 'SecondScan::P_' is not assigned a value in 'SecondScan::operator='. [operatorEqVarError]
            SecondScan&  operator=(const SecondScan& ) { return *this; }
                         ^
modules/imgproc/src/connectedcomponents.cpp:463:26: warning: Member variable 'SecondScan::sopArray_' is not assigned a value in 'SecondScan::operator='. [operatorEqVarError]
            SecondScan&  operator=(const SecondScan& ) { return *this; }
                         ^
modules/imgproc/src/connectedcomponents.cpp:840:25: warning: Member variable 'FirstScan::P_' is not assigned a value in 'FirstScan::operator='. [operatorEqVarError]
            FirstScan&  operator=(const FirstScan&) { return *this; }
                        ^
modules/imgproc/src/connectedcomponents.cpp:840:25: warning: Member variable 'FirstScan::chunksSizeAndLabels_' is not assigned a value in 'FirstScan::operator='. [operatorEqVarError]
            FirstScan&  operator=(const FirstScan&) { return *this; }
                        ^
modules/imgproc/src/connectedcomponents.cpp:1908:26: warning: Member variable 'SecondScan::P_' is not assigned a value in 'SecondScan::operator='. [operatorEqVarError]
            SecondScan&  operator=(const SecondScan& ) { return *this; }
                         ^
modules/imgproc/src/connectedcomponents.cpp:1908:26: warning: Member variable 'SecondScan::sopArray_' is not assigned a value in 'SecondScan::operator='. [operatorEqVarError]
            SecondScan&  operator=(const SecondScan& ) { return *this; }
                         ^
modules/imgproc/src/contours.cpp:573:22: warning: Either the condition 'i4!=NULL' is redundant or there is possible null pointer dereference: i4. [nullPointerRedundantCheck]
                if( *i4 != 0 )
                     ^
modules/imgproc/src/contours.cpp:572:30: note: Assuming that condition 'i4!=NULL' is not redundant
                CV_Assert(i4 != NULL);
                             ^
modules/imgproc/src/contours.cpp:571:25: note: Assignment 'i4=i3+deltas[++s]', assigned value is 0
                i4 = i3 + deltas[++s];
                        ^
modules/imgproc/src/contours.cpp:573:22: note: Null pointer dereference
                if( *i4 != 0 )
                     ^
modules/imgproc/src/contours.cpp:669:22: warning: Either the condition 'i4!=NULL' is redundant or there is possible null pointer dereference: i4. [nullPointerRedundantCheck]
                if( *i4 != 0 )
                     ^
modules/imgproc/src/contours.cpp:668:30: note: Assuming that condition 'i4!=NULL' is not redundant
                CV_Assert(i4 != NULL);
                             ^
modules/imgproc/src/contours.cpp:667:25: note: Assignment 'i4=i3+deltas[++s]', assigned value is 0
                i4 = i3 + deltas[++s];
                        ^
modules/imgproc/src/contours.cpp:669:22: note: Null pointer dereference
                if( *i4 != 0 )
                     ^
modules/imgproc/src/contours.cpp:750:22: warning: Either the condition 'i4!=NULL' is redundant or there is possible null pointer dereference: i4. [nullPointerRedundantCheck]
                if( *i4 != 0 )
                     ^
modules/imgproc/src/contours.cpp:749:30: note: Assuming that condition 'i4!=NULL' is not redundant
                CV_Assert(i4 != NULL);
                             ^
modules/imgproc/src/contours.cpp:748:25: note: Assignment 'i4=i3+deltas[++s]', assigned value is 0
                i4 = i3 + deltas[++s];
                        ^
modules/imgproc/src/contours.cpp:750:22: note: Null pointer dereference
                if( *i4 != 0 )
                     ^
modules/imgproc/src/contours.cpp:858:23: warning: Either the condition 'i4!=NULL' is redundant or there is possible null pointer dereference: i4. [nullPointerRedundantCheck]
                if( (*i4 & value_mask) == ccomp_val )
                      ^
modules/imgproc/src/contours.cpp:857:30: note: Assuming that condition 'i4!=NULL' is not redundant
                CV_Assert(i4 != NULL);
                             ^
modules/imgproc/src/contours.cpp:856:25: note: Assignment 'i4=i3+deltas[++s]', assigned value is 0
                i4 = i3 + deltas[++s];
                        ^
modules/imgproc/src/contours.cpp:858:23: note: Null pointer dereference
                if( (*i4 & value_mask) == ccomp_val )
                      ^
modules/imgproc/src/contours.cpp:943:22: warning: Either the condition 'i4!=NULL' is redundant or there is possible null pointer dereference: i4. [nullPointerRedundantCheck]
            while( (*i4 & value_mask) != ccomp_val && ( s < MAX_SIZE - 1 ) );
                     ^
modules/imgproc/src/contours.cpp:941:30: note: Assuming that condition 'i4!=NULL' is not redundant
                CV_Assert(i4 != NULL);
                             ^
modules/imgproc/src/contours.cpp:940:25: note: Assignment 'i4=i3+deltas[++s]', assigned value is 0
                i4 = i3 + deltas[++s];
                        ^
modules/imgproc/src/contours.cpp:943:22: note: Null pointer dereference
            while( (*i4 & value_mask) != ccomp_val && ( s < MAX_SIZE - 1 ) );
                     ^
modules/imgproc/src/contours.cpp:272:24: style: Variable 'scanner->seq_type2' is reassigned a value before the old one has been used. [redundantAssignment]
    scanner->seq_type2 = scanner->approx_method2 == CV_CHAIN_CODE ?
                       ^
modules/imgproc/src/contours.cpp:260:28: note: scanner->seq_type2 is assigned
        scanner->seq_type2 = scanner->seq_type1;
                           ^
modules/imgproc/src/contours.cpp:272:24: note: scanner->seq_type2 is overwritten
    scanner->seq_type2 = scanner->approx_method2 == CV_CHAIN_CODE ?
                       ^
modules/imgproc/src/contours.cpp:81:9: style: The scope of the variable 'code' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int code;
        ^
modules/imgproc/src/contours.cpp:525:21: style: The scope of the variable 'prev_s' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int             prev_s = -1, s, s_end;
                    ^
modules/imgproc/src/contours.cpp:697:17: style: The scope of the variable 'prev_s' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int         prev_s = -1, s, s_end;
                ^
modules/imgproc/src/contours.cpp:886:17: style: The scope of the variable 'prev_s' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int         prev_s = -1, s, s_end;
                ^
modules/imgproc/src/contours.cpp:1481:10: style: The scope of the variable 'connect_flag' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int  connect_flag;
         ^
modules/imgproc/src/contours.cpp:1482:10: style: The scope of the variable 'lower_total' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int  lower_total;
         ^
modules/imgproc/src/contours.cpp:1484:10: style: The scope of the variable 'all_total' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int  all_total;
         ^
modules/imgproc/src/contours.cpp:1759:31: style: The scope of the variable 'p_temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            CvLinkedRunPoint* p_temp;
                              ^
modules/imgproc/src/contours.cpp:1813:12: style: The scope of the variable 'contour' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    CvSeq *contour = 0;
           ^
modules/imgproc/src/contours.cpp:525:28: style: Variable 'prev_s' is assigned a value that is never used. [unreadVariable]
    int             prev_s = -1, s, s_end;
                           ^
modules/imgproc/src/contours.cpp:697:24: style: Variable 'prev_s' is assigned a value that is never used. [unreadVariable]
    int         prev_s = -1, s, s_end;
                       ^
modules/imgproc/src/contours.cpp:851:19: style: Variable 's_end' is assigned a value that is never used. [unreadVariable]
            s_end = s;
                  ^
modules/imgproc/src/contours.cpp:886:24: style: Variable 'prev_s' is assigned a value that is never used. [unreadVariable]
    int         prev_s = -1, s, s_end;
                       ^
modules/imgproc/src/contours.cpp:1812:30: style: Variable 'scanner' is assigned a value that is never used. [unreadVariable]
    CvContourScanner scanner = 0;
                             ^
modules/imgproc/src/convhull.cpp:273:12: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j = 0, npoints = points.checkVector(2, CV_32S);
           ^
modules/imgproc/src/convhull.cpp:273:14: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    int i, j = 0, npoints = points.checkVector(2, CV_32S);
             ^
modules/imgproc/src/corner.cpp:54:12: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j;
           ^
modules/imgproc/src/corner.cpp:110:12: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j;
           ^
modules/imgproc/src/corner.cpp:285:12: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j;
           ^
modules/imgproc/src/corner.cpp:719:12: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j;
           ^
modules/imgproc/src/deriv.cpp:767:5: style: The exception is caught by value. It could be caught as a (const) reference which is usually recommended in C++. [catchExceptionByValue]
    catch (::ipp::IwException ex)
    ^
modules/imgproc/src/distransform.cpp:508:27: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
        int* v = alignPtr((int*)(z + n + 1), sizeof(int));
                          ^
modules/imgproc/src/distransform.cpp:568:33: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
    int* sat_tab = cv::alignPtr((int*)(sqr_tab + m*2), sizeof(int));
                                ^
modules/imgproc/src/distransform.cpp:756:24: style: The scope of the variable 'pBuffer' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                Ipp8u *pBuffer;
                       ^
modules/imgproc/src/drawing.cpp:1209:25: style: The scope of the variable 'ty' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                    int ty = 0;
                        ^
modules/imgproc/src/drawing.cpp:1335:30: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a-b?c:d'' should be written as either ''(a-b)?c:d'' or ''a-(b?c:d)''. [clarifyCalculation]
        return e1.y0 - e2.y0 ? e1.y0 < e2.y0 :
                             ^
modules/imgproc/src/drawing.cpp:1336:25: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a-b?c:d'' should be written as either ''(a-b)?c:d'' or ''a-(b?c:d)''. [clarifyCalculation]
            e1.x - e2.x ? e1.x < e2.x : e1.dx < e2.dx;
                        ^
modules/imgproc/src/drawing.cpp:94:56: style: Parameter 'pt2' can be declared with const [constParameter]
bool clipLine( Size2l img_size, Point2l& pt1, Point2l& pt2 )
                                                       ^
modules/imgproc/src/drawing.cpp:1878:22: style: Parameter 'img' can be declared with const [constParameter]
void rectangle( Mat& img, Rect rec,
                     ^
modules/imgproc/src/drawing.cpp:343:12: style: Variable 'dx' is assigned a value that is never used. [unreadVariable]
        dx = ax;
           ^
modules/imgproc/src/drawing.cpp:367:12: style: Variable 'dy' is assigned a value that is never used. [unreadVariable]
        dy = ay;
           ^
modules/imgproc/src/drawing.cpp:682:12: style: Variable 'dx' is assigned a value that is never used. [unreadVariable]
        dx = ax;
           ^
modules/imgproc/src/drawing.cpp:697:12: style: Variable 'dy' is assigned a value that is never used. [unreadVariable]
        dy = ay;
           ^
modules/imgproc/src/emd.cpp:161:5: portability: Using memset() on struct which contains a floating point number. This is not portable because memset() sets each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined. Note: In case of an IEEE754-1985 compatible implementation setting all bits to zero results in the value 0.0. [memsetClassFloat]
    memset( &state, 0, sizeof(state));
    ^
modules/imgproc/src/emd.cpp:338:5: portability: Using memset() on struct which contains a floating point number. This is not portable because memset() sets each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined. Note: In case of an IEEE754-1985 compatible implementation setting all bits to zero results in the value 0.0. [memsetClassFloat]
    memset( state, 0, sizeof( *state ));
    ^
modules/imgproc/src/emd.cpp:371:16: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
    state->s = (float *) buffer;
               ^
modules/imgproc/src/emd.cpp:374:16: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
    state->d = (float *) buffer;
               ^
modules/imgproc/src/emd.cpp:438:21: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
        float* xs = (float *) buffer;
                    ^
modules/imgproc/src/emd.cpp:473:27: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
        state->delta[i] = (float *) buffer;
                          ^
modules/imgproc/src/emd.cpp:492:26: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
        state->cost[i] = (float *) buffer;
                         ^
modules/imgproc/src/emd.cpp:1166:14: style: Variable 'flow' is reassigned a value before the old one has been used. [redundantAssignment]
        flow = Scalar::all(0);
             ^
modules/imgproc/src/emd.cpp:1165:14: note: flow is assigned
        flow = _flow.getMat();
             ^
modules/imgproc/src/emd.cpp:1166:14: note: flow is overwritten
        flow = Scalar::all(0);
             ^
modules/imgproc/src/emd.cpp:165:16: style: The scope of the variable 'min_delta' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float eps, min_delta;
               ^
modules/imgproc/src/emd.cpp:574:10: style: The scope of the variable 'found' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool found;
         ^
modules/imgproc/src/emd.cpp:896:15: style: The scope of the variable 'min_i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j, min_i = -1, min_j = -1;
              ^
modules/imgproc/src/emd.cpp:897:11: style: The scope of the variable 'min_delta' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float min_delta, diff;
          ^
modules/imgproc/src/emd.cpp:900:53: style: The scope of the variable 'remember' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    CvNode1D *prev_u_min_i = 0, *prev_v_min_j = 0, *remember;
                                                    ^
modules/imgproc/src/emd.cpp:896:21: style: Variable 'min_i' is assigned a value that is never used. [unreadVariable]
    int i, j, min_i = -1, min_j = -1;
                    ^
modules/imgproc/src/filter.avx2.cpp:147:18: style: The scope of the variable 'S' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const float *S, *S2;
                 ^
modules/imgproc/src/filter.avx2.cpp:155:11: style: Variable 'S' is assigned a value that is never used. [unreadVariable]
        S = src[0] + i;
          ^
modules/imgproc/src/filter.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/filter.cpp:70:28: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'ksize' a value by passing the value to the constructor in the initialization list. [useInitializationList]
BaseFilter::BaseFilter() { ksize = Size(-1,-1); anchor = Point(-1,-1); }
                           ^
modules/imgproc/src/filter.cpp:447:5: style: Struct 'RowNoVec' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    RowNoVec(const Mat&) {}
    ^
modules/imgproc/src/filter.cpp:3589:5: style: Struct 'FixedPtCastEx < int , uchar >' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    FixedPtCastEx(int bits) : SHIFT(bits), DELTA(bits ? 1 << (bits-1) : 0) {}
    ^
modules/imgproc/src/filter.cpp:3892:10: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void operator()(const uchar** src, uchar* dst, int dststep, int count, int width, int cn)
         ^
modules/imgproc/src/filterengine.hpp:128:18: note: Virtual function in base class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int dstcount, int width, int cn) = 0;
                 ^
modules/imgproc/src/filter.cpp:3892:10: note: Function in derived class
    void operator()(const uchar** src, uchar* dst, int dststep, int count, int width, int cn)
         ^
modules/imgproc/src/filter.cpp:3423:10: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
         ^
modules/imgproc/src/filterengine.hpp:100:18: note: Virtual function in base class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int dstcount, int width) = 0;
                 ^
modules/imgproc/src/filter.cpp:3423:10: note: Function in derived class
    void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
         ^
modules/imgproc/src/filter.cpp:3317:10: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
         ^
modules/imgproc/src/filterengine.hpp:100:18: note: Virtual function in base class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int dstcount, int width) = 0;
                 ^
modules/imgproc/src/filter.cpp:3317:10: note: Function in derived class
    void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
         ^
modules/imgproc/src/filter.cpp:3254:10: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
         ^
modules/imgproc/src/filterengine.hpp:100:18: note: Virtual function in base class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int dstcount, int width) = 0;
                 ^
modules/imgproc/src/filter.cpp:3254:10: note: Function in derived class
    void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
         ^
modules/imgproc/src/filter.cpp:3115:10: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void operator()(const uchar* src, uchar* dst, int width, int cn)
         ^
modules/imgproc/src/filterengine.hpp:72:18: note: Virtual function in base class
    virtual void operator()(const uchar* src, uchar* dst, int width, int cn) = 0;
                 ^
modules/imgproc/src/filter.cpp:3115:10: note: Function in derived class
    void operator()(const uchar* src, uchar* dst, int width, int cn)
         ^
modules/imgproc/src/filter.cpp:3057:10: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void operator()(const uchar* src, uchar* dst, int width, int cn)
         ^
modules/imgproc/src/filterengine.hpp:72:18: note: Virtual function in base class
    virtual void operator()(const uchar* src, uchar* dst, int width, int cn) = 0;
                 ^
modules/imgproc/src/filter.cpp:3057:10: note: Function in derived class
    void operator()(const uchar* src, uchar* dst, int width, int cn)
         ^
modules/imgproc/src/filter.cpp:4441:12: style: Redundant initialization for 'kdepth'. The initialized value is overwritten before it is read. [redundantInitialization]
    kdepth = sdepth == CV_64F || ddepth == CV_64F ? CV_64F : CV_32F;
           ^
modules/imgproc/src/filter.cpp:4427:41: note: kdepth is initialized
    int cn = CV_MAT_CN(srcType), kdepth = _kernel.depth();
                                        ^
modules/imgproc/src/filter.cpp:4441:12: note: kdepth is overwritten
    kdepth = sdepth == CV_64F || ddepth == CV_64F ? CV_64F : CV_32F;
           ^
modules/imgproc/src/filter.cpp:3898:13: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i, k, nz = (int)coords.size();
            ^
modules/imgproc/src/filter.cpp:3427:13: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i;
            ^
modules/imgproc/src/filter.cpp:3259:13: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i, k;
            ^
modules/imgproc/src/filter.cpp:3061:19: style: The scope of the variable 'S' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        const ST* S;
                  ^
modules/imgproc/src/filter.cpp:3337:59: style: The scope of the variable 'S2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                    const ST* S = (const ST*)src[0] + i, *S2;
                                                          ^
modules/imgproc/src/filter.cpp:3375:31: style: The scope of the variable 'S' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                    const ST *S, *S2;
                              ^
modules/imgproc/src/filter.cpp:3375:35: style: The scope of the variable 'S2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                    const ST *S, *S2;
                                  ^
modules/imgproc/src/filter.cpp:2187:5: warning: Member variable 'SymmRowSmallVec_8u32s::symmetryType' is not initialized in the constructor. [uninitMemberVar]
    SymmRowSmallVec_8u32s() { smallValues = false; }
    ^
modules/imgproc/src/filter.cpp:2423:5: warning: Member variable 'SymmColumnVec_32s8u::delta' is not initialized in the constructor. [uninitMemberVar]
    SymmColumnVec_32s8u() { symmetryType=0; }
    ^
modules/imgproc/src/filter.cpp:2575:5: warning: Member variable 'SymmColumnSmallVec_32s16s::delta' is not initialized in the constructor. [uninitMemberVar]
    SymmColumnSmallVec_32s16s() { symmetryType=0; }
    ^
modules/imgproc/src/filter.cpp:2754:5: warning: Member variable 'SymmColumnVec_32f16s::delta' is not initialized in the constructor. [uninitMemberVar]
    SymmColumnVec_32f16s() { symmetryType=0; }
    ^
modules/imgproc/src/filter.cpp:2754:5: warning: Member variable 'SymmColumnVec_32f16s::neon_supported' is not initialized in the constructor. [uninitMemberVar]
    SymmColumnVec_32f16s() { symmetryType=0; }
    ^
modules/imgproc/src/filter.cpp:2190:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'kernel' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        kernel = _kernel;
        ^
modules/imgproc/src/filter.cpp:2758:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'kernel' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        kernel = _kernel;
        ^
modules/imgproc/src/filter.cpp:2908:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'kernel' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        kernel = _kernel;
        ^
modules/imgproc/src/filter.cpp:489:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'kernel' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        kernel = _kernel;
        ^
modules/imgproc/src/filter.cpp:576:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'kernel' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        kernel = _kernel;
        ^
modules/imgproc/src/filter.cpp:1162:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'kernel' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        kernel = _kernel;
        ^
modules/imgproc/src/filter.cpp:1210:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'kernel' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        kernel = _kernel;
        ^
modules/imgproc/src/filter.cpp:1369:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'kernel' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        kernel = _kernel;
        ^
modules/imgproc/src/filter.cpp:1472:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'kernel' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        kernel = _kernel;
        ^
modules/imgproc/src/filter.cpp:1671:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'kernel' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        kernel = _kernel;
        ^
modules/imgproc/src/filter.cpp:1819:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'kernel' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        kernel = _kernel;
        ^
modules/imgproc/src/filter.cpp:487:5: style: Struct 'RowVec_8u32s' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    RowVec_8u32s( const Mat& _kernel )
    ^
modules/imgproc/src/filter.cpp:1160:5: style: Struct 'RowVec_16s32f' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    RowVec_16s32f( const Mat& _kernel )
    ^
modules/imgproc/src/filter.cpp:1367:5: style: Struct 'RowVec_32f' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    RowVec_32f( const Mat& _kernel )
    ^
modules/imgproc/src/filter.cpp:508:20: style: The scope of the variable 'k' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i = 0, k, _ksize = kernel.rows + kernel.cols - 1;
                   ^
modules/imgproc/src/filter.cpp:4631:5: style: The exception is caught by value. It could be caught as a (const) reference which is usually recommended in C++. [catchExceptionByValue]
    catch(::ipp::IwException ex)
    ^
modules/imgproc/src/filter.cpp:4111:98: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [knownConditionTrueFalse]
            bool extra_extrapolation = h < requiredTop || h < requiredBottom || w < requiredLeft || w < requiredRight;
                                                                                                 ^
modules/imgproc/src/filter.cpp:4108:33: note: 'requiredRight' is assigned value '(int)BLOCK_SIZE' here.
            int requiredRight = (int)BLOCK_SIZE; // not this: ksize.width - 1 - anchor.x;
                                ^
modules/imgproc/src/filter.cpp:4106:32: note: 'requiredLeft' is assigned value '(int)BLOCK_SIZE' here.
            int requiredLeft = (int)BLOCK_SIZE; // not this: anchor.x;
                               ^
modules/imgproc/src/filter.cpp:4111:98: note: Same expression on both sides of '||' because 'w<requiredRight' and 'w<requiredLeft' represent the same value.
            bool extra_extrapolation = h < requiredTop || h < requiredBottom || w < requiredLeft || w < requiredRight;
                                                                                                 ^
modules/imgproc/src/filter.cpp:4049:43: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            pxPerWorkItemX = sz.width % 8 ? sz.width % 4 ? sz.width % 2 ? 1 : 2 : 4 : 8;
                                          ^
modules/imgproc/src/filter.cpp:4050:44: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            pxPerWorkItemY = sz.height % 2 ? 1 : 2;
                                           ^
modules/imgproc/src/filter.cpp:4054:43: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            pxPerWorkItemX = sz.width % 2 ? 1 : 2;
                                          ^
modules/imgproc/src/filter.cpp:4055:44: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            pxPerWorkItemY = sz.height % 2 ? 1 : 2;
                                           ^
modules/imgproc/src/floodfill.cpp:117:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'rect' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    rect = Rect(0, 0, 0, 0);
    ^
modules/imgproc/src/floodfill.cpp:138:21: style: Finding variables 'YMin' and 'YMax' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
    int XMin, XMax, YMin = seed.y, YMax = seed.y;
                    ^
modules/imgproc/src/floodfill.cpp:138:36: note: Same expression used in consecutive assignments of 'YMin' and 'YMax'.
    int XMin, XMax, YMin = seed.y, YMax = seed.y;
                                   ^
modules/imgproc/src/floodfill.cpp:138:21: note: Same expression used in consecutive assignments of 'YMin' and 'YMax'.
    int XMin, XMax, YMin = seed.y, YMax = seed.y;
                    ^
modules/imgproc/src/floodfill.cpp:495:22: style: Variable 'connectivity' is assigned a value that is never used. [unreadVariable]
        connectivity = 4;
                     ^
modules/imgproc/src/generalized_hough.cpp:213:9: style: Class 'Vec3iGreaterThanIdx' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        Vec3iGreaterThanIdx( const Vec3i* _arr ) : arr(_arr) {}
        ^
modules/imgproc/src/geometry.cpp:434:20: style: Variable 'p0' is assigned a value that is never used. [unreadVariable]
                p0 = p;
                   ^
modules/imgproc/src/grabcut.cpp:87:6: warning: Member variable 'GMM::sums' is not initialized in the constructor. [uninitMemberVar]
GMM::GMM( Mat& _model )
     ^
modules/imgproc/src/grabcut.cpp:87:6: warning: Member variable 'GMM::prods' is not initialized in the constructor. [uninitMemberVar]
GMM::GMM( Mat& _model )
     ^
modules/imgproc/src/grabcut.cpp:87:6: warning: Member variable 'GMM::sampleCounts' is not initialized in the constructor. [uninitMemberVar]
GMM::GMM( Mat& _model )
     ^
modules/imgproc/src/grabcut.cpp:62:5: style: Class 'GMM' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    GMM( Mat& _model );
    ^
modules/imgproc/src/histogram.cpp:1028:51: warning: Either the condition '!mask' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
        for( ; imsize.height--; p0 += step0, mask += mstep )
                                                  ^
modules/imgproc/src/histogram.cpp:1030:17: note: Assuming that condition '!mask' is not redundant
            if( !mask )
                ^
modules/imgproc/src/histogram.cpp:1028:51: note: Null pointer addition
        for( ; imsize.height--; p0 += step0, mask += mstep )
                                                  ^
modules/imgproc/src/histogram.cpp:1084:64: warning: Either the condition '!mask' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
        for( ; imsize.height--; p0 += step0, p1 += step1, mask += mstep )
                                                               ^
modules/imgproc/src/histogram.cpp:1086:17: note: Assuming that condition '!mask' is not redundant
            if( !mask )
                ^
modules/imgproc/src/histogram.cpp:1084:64: note: Null pointer addition
        for( ; imsize.height--; p0 += step0, p1 += step1, mask += mstep )
                                                               ^
modules/imgproc/src/histogram.cpp:1119:77: warning: Either the condition '!mask' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
        for( ; imsize.height--; p0 += step0, p1 += step1, p2 += step2, mask += mstep )
                                                                            ^
modules/imgproc/src/histogram.cpp:1121:17: note: Assuming that condition '!mask' is not redundant
            if( !mask )
                ^
modules/imgproc/src/histogram.cpp:1119:77: note: Null pointer addition
        for( ; imsize.height--; p0 += step0, p1 += step1, p2 += step2, mask += mstep )
                                                                            ^
modules/imgproc/src/histogram.cpp:789:55: warning: Either the condition '!mask' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            for( ; imsize.height--; p0 += step0, mask += mstep )
                                                      ^
modules/imgproc/src/histogram.cpp:791:21: note: Assuming that condition '!mask' is not redundant
                if( !mask )
                    ^
modules/imgproc/src/histogram.cpp:789:55: note: Null pointer addition
            for( ; imsize.height--; p0 += step0, mask += mstep )
                                                      ^
modules/imgproc/src/histogram.cpp:824:68: warning: Either the condition '!mask' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            for( ; imsize.height--; p0 += step0, p1 += step1, mask += mstep )
                                                                   ^
modules/imgproc/src/histogram.cpp:826:21: note: Assuming that condition '!mask' is not redundant
                if( !mask )
                    ^
modules/imgproc/src/histogram.cpp:824:68: note: Null pointer addition
            for( ; imsize.height--; p0 += step0, p1 += step1, mask += mstep )
                                                                   ^
modules/imgproc/src/histogram.cpp:869:81: warning: Either the condition '!mask' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
            for( ; imsize.height--; p0 += step0, p1 += step1, p2 += step2, mask += mstep )
                                                                                ^
modules/imgproc/src/histogram.cpp:871:21: note: Assuming that condition '!mask' is not redundant
                if( !mask )
                    ^
modules/imgproc/src/histogram.cpp:869:81: note: Null pointer addition
            for( ; imsize.height--; p0 += step0, p1 += step1, p2 += step2, mask += mstep )
                                                                                ^
modules/imgproc/src/histogram.cpp:2512:9: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int j, len = (int)it.size;
        ^
modules/imgproc/src/histogram.cpp:3360:12: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j;
           ^
modules/imgproc/src/histogram.cpp:4078:9: style: The scope of the variable 'sizes' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int sizes[CV_MAX_DIM];
        ^
modules/imgproc/src/histogram.cpp:4079:9: style: The scope of the variable 'dims' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int dims;
        ^
modules/imgproc/src/histogram.cpp:4080:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
modules/imgproc/src/histogram.cpp:4086:53: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    have_ranges = (hist->type & CV_HIST_RANGES_FLAG ? 1 : 0);
                                                    ^
modules/imgproc/src/histogram.cpp:2512:16: style: Variable 'len' is assigned a value that is never used. [unreadVariable]
    int j, len = (int)it.size;
               ^
modules/imgproc/src/histogram.cpp:1224:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'm_histSize' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        m_histSize       = histSize;
        ^
modules/imgproc/src/histogram.cpp:1225:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'm_type' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        m_type           = ippiGetDataType(src.type());
        ^
modules/imgproc/src/histogram.cpp:736:41: style: Parameter '_ptrs' can be declared with const [constParameter]
callCalcHist2D_8u( std::vector<uchar*>& _ptrs, const std::vector<int>& _deltas,
                                        ^
modules/imgproc/src/histogram.cpp:737:76: style: Parameter '_tab' can be declared with const [constParameter]
                   Size imsize, Mat& hist, int dims,  std::vector<size_t>& _tab )
                                                                           ^
modules/imgproc/src/histogram.cpp:747:41: style: Parameter '_ptrs' can be declared with const [constParameter]
callCalcHist3D_8u( std::vector<uchar*>& _ptrs, const std::vector<int>& _deltas,
                                        ^
modules/imgproc/src/histogram.cpp:748:76: style: Parameter '_tab' can be declared with const [constParameter]
                   Size imsize, Mat& hist, int dims,  std::vector<size_t>& _tab )
                                                                           ^
modules/imgproc/src/histogram.cpp:166:22: style: Variable 'isContinuous' is assigned a value that is never used. [unreadVariable]
        isContinuous = isContinuous && mask.isContinuous();
                     ^
modules/imgproc/src/hough.cpp:64:41: style: Defensive programming: The variable 'l1' is used as an array index before it is checked that is within limits. This can mean that the array might be accessed out of bounds. Reorder conditions such as '(a[i] && i < 10)' to '(i < 10 && a[i])'. That way the array will not be accessed if the index is out of limits. [arrayIndexThenCheck]
        return aux[l1] > aux[l2] || (aux[l1] == aux[l2] && l1 < l2);
                                        ^
modules/imgproc/src/hough.cpp:61:5: style: Struct 'hough_cmp_gt' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    hough_cmp_gt(const int* _aux) : aux(_aux) {}
    ^
modules/imgproc/src/hough.cpp:985:37: style: The scope of the variable 'x1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int sx, sy, x0, y0, x1, y1;
                                    ^
modules/imgproc/src/hough.cpp:985:41: style: The scope of the variable 'y1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int sx, sy, x0, y0, x1, y1;
                                        ^
modules/imgproc/src/hough.cpp:1173:17: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int j = 0, nzCount = 0, maxCount = 0;
                ^
modules/imgproc/src/hough.cpp:1173:24: style: The scope of the variable 'nzCount' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int j = 0, nzCount = 0, maxCount = 0;
                       ^
modules/imgproc/src/hough.cpp:701:12: style: The scope of the variable 'localThreads' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t localThreads[2];
           ^
modules/imgproc/src/imgwarp.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/imgwarp.cpp:3373:33: style: Expression 'exp(x) - 1' can be replaced by 'expm1(x)' to avoid loss of precision. [unpreciseMathCall]
            exp_tab[rho] = std::exp(rho/M) - 1.0;
                                ^
modules/imgproc/src/imgwarp.cpp:3491:33: style: Expression 'exp(x) - 1' can be replaced by 'expm1(x)' to avoid loss of precision. [unpreciseMathCall]
            exp_tab[rho] = std::exp(rho / M) - 1.0;
                                ^
modules/imgproc/src/imgwarp.cpp:1931:29: portability: Casting from const float * to const signed short * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
        const short* src1 = (const short*)src1f;
                            ^
modules/imgproc/src/imgwarp.cpp:1936:23: portability: Casting from float * to signed short * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
        short* dst1 = (short*)dst1f;
                      ^
modules/imgproc/src/imgwarp.cpp:1926:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x, y;
        ^
modules/imgproc/src/imgwarp.sse4_1.cpp:215:5: style: Class 'WarpPerspectiveLine_SSE4_Impl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    WarpPerspectiveLine_SSE4_Impl(const double *M)
    ^
modules/imgproc/src/imgwarp.sse4_1.cpp:219:18: style: The function 'processNN' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void processNN(const double *M, short* xy, double X0, double Y0, double W0, int bw)
                 ^
modules/imgproc/src/imgwarp.hpp:75:18: note: Virtual function in base class
    virtual void processNN(const double *M, short* xy, double X0, double Y0, double W0, int bw) = 0;
                 ^
modules/imgproc/src/imgwarp.sse4_1.cpp:219:18: note: Function in derived class
    virtual void processNN(const double *M, short* xy, double X0, double Y0, double W0, int bw)
                 ^
modules/imgproc/src/imgwarp.sse4_1.cpp:349:18: style: The function 'process' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void process(const double *M, short* xy, short* alpha, double X0, double Y0, double W0, int bw)
                 ^
modules/imgproc/src/imgwarp.hpp:76:18: note: Virtual function in base class
    virtual void process(const double *M, short* xy, short* alpha, double X0, double Y0, double W0, int bw) = 0;
                 ^
modules/imgproc/src/imgwarp.sse4_1.cpp:349:18: note: Function in derived class
    virtual void process(const double *M, short* xy, short* alpha, double X0, double Y0, double W0, int bw)
                 ^
modules/imgproc/src/lsd.cpp:1059:12: style: Finding variables 'left_x' and 'right_x' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
    double left_x = min_y->p.x, right_x = min_y->p.x;
           ^
modules/imgproc/src/lsd.cpp:1059:33: note: Same expression used in consecutive assignments of 'left_x' and 'right_x'.
    double left_x = min_y->p.x, right_x = min_y->p.x;
                                ^
modules/imgproc/src/lsd.cpp:1059:12: note: Same expression used in consecutive assignments of 'left_x' and 'right_x'.
    double left_x = min_y->p.x, right_x = min_y->p.x;
           ^
modules/imgproc/src/min_enclosing_triangle.cpp:1166:41: style: Parameter 'gammaAngle' can be declared with const [constParameter]
static bool isGammaAngleEqualTo(double &gammaAngle, double angle) {
                                        ^
modules/imgproc/src/min_enclosing_triangle.cpp:1176:37: style: Parameter 'gammaAngle' can be declared with const [constParameter]
static bool isGammaAngleBtw(double &gammaAngle, double angle1, double angle2) {
                                    ^
modules/imgproc/src/moments.cpp:107:20: style: The scope of the variable 'xi2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double xi, yi, xi2, yi2, xi_1, yi_1, xi_12, yi_12, dxy, xii_1, yii_1;
                   ^
modules/imgproc/src/moments.cpp:107:25: style: The scope of the variable 'yi2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double xi, yi, xi2, yi2, xi_1, yi_1, xi_12, yi_12, dxy, xii_1, yii_1;
                        ^
modules/imgproc/src/moments.cpp:107:56: style: The scope of the variable 'dxy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double xi, yi, xi2, yi2, xi_1, yi_1, xi_12, yi_12, dxy, xii_1, yii_1;
                                                       ^
modules/imgproc/src/moments.cpp:107:61: style: The scope of the variable 'xii_1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double xi, yi, xi2, yi2, xi_1, yi_1, xi_12, yi_12, dxy, xii_1, yii_1;
                                                            ^
modules/imgproc/src/moments.cpp:107:68: style: The scope of the variable 'yii_1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double xi, yi, xi2, yi2, xi_1, yi_1, xi_12, yi_12, dxy, xii_1, yii_1;
                                                                   ^
modules/imgproc/src/morph.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/morph.cpp:795:10: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void operator()(const uchar** src, uchar* dst, int dststep, int count, int width, int cn)
         ^
modules/imgproc/src/filterengine.hpp:128:18: note: Virtual function in base class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int dstcount, int width, int cn) = 0;
                 ^
modules/imgproc/src/morph.cpp:795:10: note: Function in derived class
    void operator()(const uchar** src, uchar* dst, int dststep, int count, int width, int cn)
         ^
modules/imgproc/src/morph.cpp:694:10: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void operator()(const uchar** _src, uchar* dst, int dststep, int count, int width)
         ^
modules/imgproc/src/filterengine.hpp:100:18: note: Virtual function in base class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int dstcount, int width) = 0;
                 ^
modules/imgproc/src/morph.cpp:694:10: note: Function in derived class
    void operator()(const uchar** _src, uchar* dst, int dststep, int count, int width)
         ^
modules/imgproc/src/morph.cpp:640:10: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void operator()(const uchar* src, uchar* dst, int width, int cn)
         ^
modules/imgproc/src/filterengine.hpp:72:18: note: Virtual function in base class
    virtual void operator()(const uchar* src, uchar* dst, int width, int cn) = 0;
                 ^
modules/imgproc/src/morph.cpp:640:10: note: Function in derived class
    void operator()(const uchar* src, uchar* dst, int width, int cn)
         ^
modules/imgproc/src/morph.cpp:799:13: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int i, k, nz = (int)coords.size();
            ^
modules/imgproc/src/morph.cpp:1300:5: style: The exception is caught by value. It could be caught as a (const) reference which is usually recommended in C++. [catchExceptionByValue]
    catch(::ipp::IwException ex)
    ^
modules/imgproc/src/morph.cpp:1535:41: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
        pxPerWorkItemX = size.width % 8 ? size.width % 4 ? size.width % 2 ? 1 : 2 : 4 : 8;
                                        ^
modules/imgproc/src/morph.cpp:1536:42: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
        pxPerWorkItemY = size.height % 2 ? 1 : 2;
                                         ^
modules/imgproc/src/morph.cpp:1540:41: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
        pxPerWorkItemX = size.width % 2 ? 1 : 2;
                                        ^
modules/imgproc/src/morph.cpp:1541:42: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
        pxPerWorkItemY = size.height % 2 ? 1 : 2;
                                         ^
modules/imgproc/src/opencl/boxFilter.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/opencl/boxFilter.cl:151:0: error: failed to expand 'EXTRAPOLATE', it is invalid to use a preprocessor directive as macro parameter [preprocessorErrorDirective]
#ifdef BORDER_ISOLATED
^
modules/imgproc/src/opencl/boxFilter3x3.cl:44:15: style: Variable 'src_index' is assigned a value that is never used. [unreadVariable]
    src_index = block_x * 16 * ssx + (y - 1) * src_step;
              ^
modules/imgproc/src/opencl/boxFilter3x3.cl:45:19: style: Variable 'line_end' is assigned a value that is never used. [unreadVariable]
    bool line_end = ((block_x + 1) * 16 == cols);
                  ^
modules/imgproc/src/opencl/corner.cl:183:18: style: Local variable 'k' shadows outer argument [shadowArgument]
        for (int k=0; k<6; k++)
                 ^
modules/imgproc/src/opencl/corner.cl:96:108: note: Shadowed declaration
                     __global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols, float k)
                                                                                                           ^
modules/imgproc/src/opencl/corner.cl:183:18: note: Shadow variable
        for (int k=0; k<6; k++)
                 ^
modules/imgproc/src/opencl/covardata.cl:99:5: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
    INIT_AND_READ_LOCAL_SOURCE(width, height, 0, 1)
    ^
modules/imgproc/src/opencl/covardata.cl:138:5: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
    INIT_AND_READ_LOCAL_SOURCE(width, height, 0, 2)
    ^
modules/imgproc/src/opencl/covardata.cl:209:5: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
    INIT_AND_READ_LOCAL_SOURCE(width, height, 0, 3)
    ^
modules/imgproc/src/opencl/covardata.cl:99:5: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
    INIT_AND_READ_LOCAL_SOURCE(width, height, 0, 1)
    ^
modules/imgproc/src/opencl/covardata.cl:138:5: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
    INIT_AND_READ_LOCAL_SOURCE(width, height, 0, 2)
    ^
modules/imgproc/src/opencl/covardata.cl:209:5: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
    INIT_AND_READ_LOCAL_SOURCE(width, height, 0, 3)
    ^
modules/imgproc/src/opencl/cvtcolor.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/opencl/cvtcolor.cl:1111:37: style: Finding the same value in both branches of ternary operator is suspicious as the same code is executed regardless of the condition. [duplicateValueTernary]
                h += h < 0 ? hrange : 0;
                                    ^
modules/imgproc/src/opencl/cvtcolor.cl:1373:57: style: Argument 'h*0' to function convert_uchar_sat_rte is always 0 [constArgument]
                dst[dst_index] = convert_uchar_sat_rte(h*hscale);
                                                        ^
modules/imgproc/src/opencl/cvtcolor.cl:436:89: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
                __global const uchar* vsrc = usrc + mad24(rows >> 2, src_step, rows % 4 ? vsteps[y%2] : 0);
                                                                                        ^
modules/imgproc/src/opencl/cvtcolor.cl:517:87: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
                __global uchar* vdst = udst + mad24(y_rows >> 2, dst_step, y_rows % 4 ? vsteps[y%2] : 0);
                                                                                      ^
modules/imgproc/src/opencl/cvtcolor.cl:2146:23: style: Unused variable: d [unusedVariable]
                float d, X, Y, Z;
                      ^
modules/imgproc/src/opencl/cvtcolor.cl:947:49: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                dst[dst_index + 3] = t & 0x8000 ? 255 : 0;
                                                ^
modules/imgproc/src/opencl/filter2D.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/opencl/filter2D.cl:185:9: style: The scope of the variable 'srcBeginY' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int srcBeginY = 0;
        ^
modules/imgproc/src/opencl/filter2DSmall.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/opencl/filter2DSmall.cl:295:5: style: The scope of the variable 'y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    LOOP(PX_LOAD_Y_ITERATIONS, py,
    ^
modules/imgproc/src/opencl/filter2DSmall.cl:323:5: style: The scope of the variable 'y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    LOOP(PX_PER_WI_Y, py,
    ^
modules/imgproc/src/opencl/filter2DSmall.cl:323:5: style: The scope of the variable 'kernelIndex' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    LOOP(PX_PER_WI_Y, py,
    ^
modules/imgproc/src/opencl/filter2DSmall.cl:295:5: style: Variable 'srcPos.x' is assigned a value that is never used. [unreadVariable]
    LOOP(PX_LOAD_Y_ITERATIONS, py,
    ^
modules/imgproc/src/opencl/filterSepRow.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/opencl/filterSepRow.cl:209:9: style: The scope of the variable 's_y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int s_y;
        ^
modules/imgproc/src/opencl/filterSepRow.cl:337:32: style: The scope of the variable 's_x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int index[READ_TIMES_ROW], s_x, s_y;
                               ^
modules/imgproc/src/opencl/filterSepRow.cl:337:37: style: The scope of the variable 's_y' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int index[READ_TIMES_ROW], s_x, s_y;
                                    ^
modules/imgproc/src/opencl/filterSepRow.cl:305:20: style: Variable 'start_addr' is assigned a value that is never used. [unreadVariable]
    int start_addr = mad24(start_y, src_step, start_x * SRCSIZE);
                   ^
modules/imgproc/src/opencl/filterSepRow.cl:195:21: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i].x = ELEM(start_x+i*LSIZE0*4,   0, src_whole_cols, 0,         temp[i].x);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:196:21: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i].y = ELEM(start_x+i*LSIZE0*4+1, 0, src_whole_cols, 0,         temp[i].y);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:197:21: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i].z = ELEM(start_x+i*LSIZE0*4+2, 0, src_whole_cols, 0,         temp[i].z);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:198:21: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i].w = ELEM(start_x+i*LSIZE0*4+3, 0, src_whole_cols, 0,         temp[i].w);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:199:21: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i]   = ELEM(start_y,              0, src_whole_rows, (uchar4)0, temp[i]);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:332:19: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i] = ELEM(mad24(i, LSIZE0, start_x), 0, src_whole_cols, (srcT)(0), temp[i]);
                  ^
modules/imgproc/src/opencl/filterSepRow.cl:333:19: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i] = ELEM(start_y,                   0, src_whole_rows, (srcT)(0), temp[i]);
                  ^
modules/imgproc/src/opencl/filterSepRow.cl:195:21: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i].x = ELEM(start_x+i*LSIZE0*4,   0, src_whole_cols, 0,         temp[i].x);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:196:21: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i].y = ELEM(start_x+i*LSIZE0*4+1, 0, src_whole_cols, 0,         temp[i].y);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:197:21: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i].z = ELEM(start_x+i*LSIZE0*4+2, 0, src_whole_cols, 0,         temp[i].z);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:198:21: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i].w = ELEM(start_x+i*LSIZE0*4+3, 0, src_whole_cols, 0,         temp[i].w);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:199:21: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i]   = ELEM(start_y,              0, src_whole_rows, (uchar4)0, temp[i]);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:332:19: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i] = ELEM(mad24(i, LSIZE0, start_x), 0, src_whole_cols, (srcT)(0), temp[i]);
                  ^
modules/imgproc/src/opencl/filterSepRow.cl:333:19: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i] = ELEM(start_y,                   0, src_whole_rows, (srcT)(0), temp[i]);
                  ^
modules/imgproc/src/opencl/filterSepRow.cl:186:21: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i].x = ELEM(start_x+i*LSIZE0*4,   src_offset_x, src_offset_x + src_cols, 0,         temp[i].x);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:187:21: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i].y = ELEM(start_x+i*LSIZE0*4+1, src_offset_x, src_offset_x + src_cols, 0,         temp[i].y);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:188:21: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i].z = ELEM(start_x+i*LSIZE0*4+2, src_offset_x, src_offset_x + src_cols, 0,         temp[i].z);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:189:21: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i].w = ELEM(start_x+i*LSIZE0*4+3, src_offset_x, src_offset_x + src_cols, 0,         temp[i].w);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:190:21: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i]   = ELEM(start_y,              src_offset_y, src_offset_y + src_rows, (uchar4)0, temp[i]);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:326:19: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i] = ELEM(mad24(i, LSIZE0, start_x), src_offset_x, src_offset_x + src_cols, (srcT)(0), temp[i]);
                  ^
modules/imgproc/src/opencl/filterSepRow.cl:327:19: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
        temp[i] = ELEM(start_y,                   src_offset_y, src_offset_y + src_rows, (srcT)(0), temp[i]);
                  ^
modules/imgproc/src/opencl/filterSepRow.cl:186:21: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i].x = ELEM(start_x+i*LSIZE0*4,   src_offset_x, src_offset_x + src_cols, 0,         temp[i].x);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:187:21: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i].y = ELEM(start_x+i*LSIZE0*4+1, src_offset_x, src_offset_x + src_cols, 0,         temp[i].y);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:188:21: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i].z = ELEM(start_x+i*LSIZE0*4+2, src_offset_x, src_offset_x + src_cols, 0,         temp[i].z);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:189:21: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i].w = ELEM(start_x+i*LSIZE0*4+3, src_offset_x, src_offset_x + src_cols, 0,         temp[i].w);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:190:21: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i]   = ELEM(start_y,              src_offset_y, src_offset_y + src_rows, (uchar4)0, temp[i]);
                    ^
modules/imgproc/src/opencl/filterSepRow.cl:326:19: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i] = ELEM(mad24(i, LSIZE0, start_x), src_offset_x, src_offset_x + src_cols, (srcT)(0), temp[i]);
                  ^
modules/imgproc/src/opencl/filterSepRow.cl:327:19: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
        temp[i] = ELEM(start_y,                   src_offset_y, src_offset_y + src_rows, (srcT)(0), temp[i]);
                  ^
modules/imgproc/src/opencl/filterSep_singlePass.cl:141:35: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
            lsmem[clocY][clocX] = ELEM(xb, yb, (width), (height), 0 );
                                  ^
modules/imgproc/src/opencl/filterSep_singlePass.cl:216:45: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
            lsmem[liy + 2*RADIUSY][clocX] = ELEM(xb, yb, (width), (height), 0 );
                                            ^
modules/imgproc/src/opencl/filterSep_singlePass.cl:199:18: style: Local variable 'i' shadows outer variable [shadowVariable]
        for (int i = liy * BLK_X + lix; i < (RADIUSY*2) * (BLK_X+(RADIUSX*2)); i += BLK_X * BLK_Y)
                 ^
modules/imgproc/src/opencl/filterSep_singlePass.cl:157:13: note: Shadowed declaration
        int i, clocX = lix;
            ^
modules/imgproc/src/opencl/filterSep_singlePass.cl:199:18: note: Shadow variable
        for (int i = liy * BLK_X + lix; i < (RADIUSY*2) * (BLK_X+(RADIUSX*2)); i += BLK_X * BLK_Y)
                 ^
modules/imgproc/src/opencl/filterSep_singlePass.cl:201:17: style: Local variable 'clocX' shadows outer variable [shadowVariable]
            int clocX = i % (BLK_X+(RADIUSX*2));
                ^
modules/imgproc/src/opencl/filterSep_singlePass.cl:157:16: note: Shadowed declaration
        int i, clocX = lix;
               ^
modules/imgproc/src/opencl/filterSep_singlePass.cl:201:17: note: Shadow variable
            int clocX = i % (BLK_X+(RADIUSX*2));
                ^
modules/imgproc/src/opencl/filterSep_singlePass.cl:202:17: style: Local variable 'clocY' shadows outer variable [shadowVariable]
            int clocY = i / (BLK_X+(RADIUSX*2));
                ^
modules/imgproc/src/opencl/filterSep_singlePass.cl:129:9: note: Shadowed declaration
    int clocY = liy;
        ^
modules/imgproc/src/opencl/filterSep_singlePass.cl:202:17: note: Shadow variable
            int clocY = i / (BLK_X+(RADIUSX*2));
                ^
modules/imgproc/src/opencl/filterSep_singlePass.cl:141:35: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
            lsmem[clocY][clocX] = ELEM(xb, yb, (width), (height), 0 );
                                  ^
modules/imgproc/src/opencl/filterSep_singlePass.cl:216:45: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
            lsmem[liy + 2*RADIUSY][clocX] = ELEM(xb, yb, (width), (height), 0 );
                                            ^
modules/imgproc/src/opencl/filterSmall.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/opencl/filterSmall.cl:366:0: error: failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter [preprocessorErrorDirective]
#ifdef SQR
^
modules/imgproc/src/opencl/filterSmall.cl:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
BORDER_CONSTANT : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
BORDER_CONSTANT;EXTRA_EXTRAPOLATION : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
BORDER_CONSTANT;OP_DILATE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
BORDER_CONSTANT;OP_ERODE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
BORDER_ISOLATED : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
BORDER_REFLECT : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
BORDER_REFLECT101;BORDER_REFLECT_101;BORDER_REFLECT;BORDER_REFLECT_101;EXTRA_EXTRAPOLATION : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
BORDER_REFLECT;BORDER_REFLECT;BORDER_REFLECT_101;EXTRA_EXTRAPOLATION : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
BORDER_REFLECT;BORDER_REFLECT_101;EXTRA_EXTRAPOLATION : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
BORDER_REFLECT;BORDER_REFLECT_101;EXTRA_EXTRAPOLATION;OP_DILATE;OP_DILATE;OP_ERODE;OP_DILATE;OP_ERODE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
BORDER_REFLECT_101 : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
BORDER_REPLICATE : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
BORDER_REPLICATE;EXTRA_EXTRAPOLATION : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
BORDER_WRAP : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
BORDER_WRAP;EXTRA_EXTRAPOLATION : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
DEPTH_0;INTEL_DEVICE;OP_DILATE;OP_ERODE;OP_ERODE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
DEPTH_0;OP_DILATE;OP_ERODE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
DEPTH_1;OP_DILATE;OP_ERODE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
DEPTH_2;OP_DILATE;OP_ERODE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
DEPTH_3;OP_DILATE;OP_ERODE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
DEPTH_4;OP_DILATE;OP_ERODE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
DEPTH_5;OP_DILATE;OP_ERODE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
DEPTH_6;OP_DILATE;OP_ERODE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
DOUBLE_SUPPORT : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
DOUBLE_SUPPORT;cl_amd_fp64 : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
DOUBLE_SUPPORT;cl_khr_fp64 : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
EXTRA_EXTRAPOLATION : [modules/imgproc/src/opencl/filterSmall.cl:101] #error No extrapolation method
NORMALIZE : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
OP_BLACKHAT;OP_BLACKHAT;OP_GRADIENT;OP_TOPHAT : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
OP_BLACKHAT;OP_GRADIENT;OP_TOPHAT : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
OP_BLACKHAT;OP_GRADIENT;OP_TOPHAT;OP_GRADIENT : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
OP_BLACKHAT;OP_GRADIENT;OP_TOPHAT;OP_TOPHAT : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified"
OP_BOX_FILTER : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
OP_DILATE;OP_DILATE;OP_ERODE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
OP_DILATE;OP_ERODE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
OP_DILATE;OP_ERODE;OP_ERODE : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
OP_FILTER2D : [modules/imgproc/src/opencl/filterSmall.cl:366] failed to expand 'LOOP', it is invalid to use a preprocessor directive as macro parameter
SQR : [modules/imgproc/src/opencl/filterSmall.cl:287] #error "No processing is specified" [noValidConfiguration]

^
modules/imgproc/src/opencl/gaussianBlur3x3.cl:45:15: style: Variable 'src_index' is assigned a value that is never used. [unreadVariable]
    src_index = block_x * 16 * ssx + (y - 1) * src_step;
              ^
modules/imgproc/src/opencl/gaussianBlur3x3.cl:46:19: style: Variable 'line_end' is assigned a value that is never used. [unreadVariable]
    bool line_end = ((block_x + 1) * 16 == cols);
                  ^
modules/imgproc/src/opencl/gaussianBlur5x5.cl:32:30: style: Variable 'line[2]' is assigned a value that is never used. [unreadVariable]
    if (offset == 0) line[2] = (uchar8)(0, 0, line[2].s0123, line[2].s45);
                             ^
modules/imgproc/src/opencl/gaussianBlur5x5.cl:101:16: style: Variable 'row_s' is assigned a value that is never used. [unreadVariable]
    bool row_s = (x == 0);
               ^
modules/imgproc/src/opencl/gaussianBlur5x5.cl:102:16: style: Variable 'row_e' is assigned a value that is never used. [unreadVariable]
    bool row_e = ((x + 4) == cols);
               ^
modules/imgproc/src/opencl/gaussianBlur5x5.cl:104:11: style: Unused variable: s [unusedVariable]
    uchar s, e;
          ^
modules/imgproc/src/opencl/gaussianBlur5x5.cl:104:14: style: Unused variable: e [unusedVariable]
    uchar s, e;
             ^
modules/imgproc/src/opencl/histogram.cl:65:9: style: The scope of the variable 'src_index' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int src_index;
        ^
modules/imgproc/src/opencl/histogram.cl:192:13: style: The scope of the variable 'sum' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int sum = 0, i = 0;
            ^
modules/imgproc/src/opencl/laplacian3.cl:45:15: style: Variable 'src_index' is assigned a value that is never used. [unreadVariable]
    src_index = block_x * 16 * ssx + (y - 1) * src_step;
              ^
modules/imgproc/src/opencl/laplacian3.cl:46:19: style: Variable 'line_end' is assigned a value that is never used. [unreadVariable]
    bool line_end = ((block_x + 1) * 16 == cols);
                  ^
modules/imgproc/src/opencl/laplacian5.cl:130:35: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
            lsmem[clocY][clocX] = ELEM(xb, yb, (width), (height), 0 );
                                  ^
modules/imgproc/src/opencl/laplacian5.cl:196:44: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
            lsmem[liy + 2*RADIUS][clocX] = ELEM(xb, yb, (width), (height), 0 );
                                           ^
modules/imgproc/src/opencl/laplacian5.cl:179:18: style: Local variable 'i' shadows outer variable [shadowVariable]
        for (int i = liy * BLK_X + lix; i < (RADIUS*2) * (BLK_X+(RADIUS*2)); i += BLK_X * BLK_Y)
                 ^
modules/imgproc/src/opencl/laplacian5.cl:146:13: note: Shadowed declaration
        int i, clocX = lix;
            ^
modules/imgproc/src/opencl/laplacian5.cl:179:18: note: Shadow variable
        for (int i = liy * BLK_X + lix; i < (RADIUS*2) * (BLK_X+(RADIUS*2)); i += BLK_X * BLK_Y)
                 ^
modules/imgproc/src/opencl/laplacian5.cl:181:17: style: Local variable 'clocX' shadows outer variable [shadowVariable]
            int clocX = i % (BLK_X+(RADIUS*2));
                ^
modules/imgproc/src/opencl/laplacian5.cl:146:16: note: Shadowed declaration
        int i, clocX = lix;
               ^
modules/imgproc/src/opencl/laplacian5.cl:181:17: note: Shadow variable
            int clocX = i % (BLK_X+(RADIUS*2));
                ^
modules/imgproc/src/opencl/laplacian5.cl:182:17: style: Local variable 'clocY' shadows outer variable [shadowVariable]
            int clocY = i / (BLK_X+(RADIUS*2));
                ^
modules/imgproc/src/opencl/laplacian5.cl:118:9: note: Shadowed declaration
    int clocY = liy;
        ^
modules/imgproc/src/opencl/laplacian5.cl:182:17: note: Shadow variable
            int clocY = i / (BLK_X+(RADIUS*2));
                ^
modules/imgproc/src/opencl/laplacian5.cl:130:35: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
            lsmem[clocY][clocX] = ELEM(xb, yb, (width), (height), 0 );
                                  ^
modules/imgproc/src/opencl/laplacian5.cl:196:44: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
            lsmem[liy + 2*RADIUS][clocX] = ELEM(xb, yb, (width), (height), 0 );
                                           ^
modules/imgproc/src/opencl/logPolar.cl:14:18: style: Expression 'exp(x) - 1' can be replaced by 'expm1(x)' to avoid loss of precision. [unpreciseMathCall]
        r[gid] = exp(gid/m)-1.0f;
                 ^
modules/imgproc/src/opencl/logPolar.cl:61:21: style: Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]
        float mag = log(sqrt(dx*dx + dy*dy)+1.0f);
                    ^
modules/imgproc/src/opencl/match_template.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/opencl/match_template.cl:454:11: style: Unused variable: sum_ [unusedVariable]
    float sum_[2];
          ^
modules/imgproc/src/opencl/match_template.cl:455:11: style: Unused variable: sqsum_ [unusedVariable]
    float sqsum_[2];
          ^
modules/imgproc/src/opencl/match_template.cl:491:18: style: Variable 'step' is assigned a value that is never used. [unreadVariable]
        int step = src_sums_step/(int)sizeof(T);
                 ^
modules/imgproc/src/opencl/medianFilter.cl:154:5: style: Variable 'c0' is assigned a value that is never used. [unreadVariable]
    ITER3(3);
    ^
modules/imgproc/src/opencl/medianFilter.cl:154:5: style: Variable 'c1' is assigned a value that is never used. [unreadVariable]
    ITER3(3);
    ^
modules/imgproc/src/opencl/medianFilter.cl:154:5: style: Variable 'c2' is assigned a value that is never used. [unreadVariable]
    ITER3(3);
    ^
modules/imgproc/src/opencl/medianFilter.cl:154:5: style: Variable 'c3' is assigned a value that is never used. [unreadVariable]
    ITER3(3);
    ^
modules/imgproc/src/opencl/medianFilter.cl:154:5: style: Variable 'c4' is assigned a value that is never used. [unreadVariable]
    ITER3(3);
    ^
modules/imgproc/src/opencl/medianFilter.cl:154:5: style: Variable 'c5' is assigned a value that is never used. [unreadVariable]
    ITER3(3);
    ^
modules/imgproc/src/opencl/moments.cl:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [modules/imgproc/src/opencl/moments.cl:4] #error "TILE SIZE should be 32"
OP_MOMENTS_BINARY : [modules/imgproc/src/opencl/moments.cl:4] #error "TILE SIZE should be 32" [noValidConfiguration]

^
modules/imgproc/src/opencl/morph.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/opencl/morph.cl:144:13: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
    temp0 = ELEM(cur_x, 0, src_whole_cols, (T)(VAL), temp0);
            ^
modules/imgproc/src/opencl/morph.cl:145:13: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
    temp0 = ELEM(cur_y, 0, src_whole_rows, (T)(VAL), temp0);
            ^
modules/imgproc/src/opencl/morph.cl:147:13: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
    temp1 = ELEM(cur_x2, 0, src_whole_cols, (T)(VAL), temp1);
            ^
modules/imgproc/src/opencl/morph.cl:148:13: style: Suspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses. [clarifyCondition]
    temp1 = ELEM(cur_y2, 0, src_whole_rows, (T)(VAL), temp1);
            ^
modules/imgproc/src/opencl/morph.cl:144:13: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
    temp0 = ELEM(cur_x, 0, src_whole_cols, (T)(VAL), temp0);
            ^
modules/imgproc/src/opencl/morph.cl:145:13: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
    temp0 = ELEM(cur_y, 0, src_whole_rows, (T)(VAL), temp0);
            ^
modules/imgproc/src/opencl/morph.cl:147:13: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
    temp1 = ELEM(cur_x2, 0, src_whole_cols, (T)(VAL), temp1);
            ^
modules/imgproc/src/opencl/morph.cl:148:13: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a|b?c:d'' should be written as either ''(a|b)?c:d'' or ''a|(b?c:d)''. [clarifyCalculation]
    temp1 = ELEM(cur_y2, 0, src_whole_rows, (T)(VAL), temp1);
            ^
modules/imgproc/src/opencl/morph.cl:156:27: style: Unused variable: temp [unusedVariable]
        T res = (T)(VAL), temp;
                          ^
modules/imgproc/src/opencl/morph3x3.cl:88:13: style: Variable 'arr[11]' is assigned a value that is never used. [unreadVariable]
    arr[11] = (uchar16)(k.s12345678, k.s9abc, k.sdef, l);
            ^
modules/imgproc/src/opencl/pyr_down.cl:159:20: style: Unused variable: sum40 [unusedVariable]
            float4 sum40, sum41, temp4;
                   ^
modules/imgproc/src/opencl/pyr_down.cl:159:27: style: Unused variable: sum41 [unusedVariable]
            float4 sum40, sum41, temp4;
                          ^
modules/imgproc/src/opencl/pyr_down.cl:159:34: style: Unused variable: temp4 [unusedVariable]
            float4 sum40, sum41, temp4;
                                 ^
modules/imgproc/src/opencl/pyr_down.cl:192:20: style: Unused variable: sum40 [unusedVariable]
            float4 sum40, sum41, temp4;
                   ^
modules/imgproc/src/opencl/pyr_down.cl:192:27: style: Unused variable: sum41 [unusedVariable]
            float4 sum40, sum41, temp4;
                          ^
modules/imgproc/src/opencl/pyr_down.cl:192:34: style: Unused variable: temp4 [unusedVariable]
            float4 sum40, sum41, temp4;
                                 ^
modules/imgproc/src/opencl/pyramid_up.cl:19:12: style: Unused variable: line_out [unusedVariable]
    uchar4 line_out;
           ^
modules/imgproc/src/opencl/remap.cl:362:23: style: Redundant initialization for 'a'. The initialized value is overwritten before it is read. [redundantInitialization]
                    a = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataA.y, src_step, map_dataA.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:359:22: note: a is initialized
                WT a = scalar, b = scalar, c = scalar, d = scalar;
                     ^
modules/imgproc/src/opencl/remap.cl:362:23: note: a is overwritten
                    a = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataA.y, src_step, map_dataA.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:367:23: style: Redundant initialization for 'b'. The initialized value is overwritten before it is read. [redundantInitialization]
                    b = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataB.y, src_step, map_dataB.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:359:34: note: b is initialized
                WT a = scalar, b = scalar, c = scalar, d = scalar;
                                 ^
modules/imgproc/src/opencl/remap.cl:367:23: note: b is overwritten
                    b = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataB.y, src_step, map_dataB.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:372:23: style: Redundant initialization for 'c'. The initialized value is overwritten before it is read. [redundantInitialization]
                    c = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataC.y, src_step, map_dataC.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:359:46: note: c is initialized
                WT a = scalar, b = scalar, c = scalar, d = scalar;
                                             ^
modules/imgproc/src/opencl/remap.cl:372:23: note: c is overwritten
                    c = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataC.y, src_step, map_dataC.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:377:23: style: Redundant initialization for 'd'. The initialized value is overwritten before it is read. [redundantInitialization]
                    d = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataD.y, src_step, map_dataD.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:359:58: note: d is initialized
                WT a = scalar, b = scalar, c = scalar, d = scalar;
                                                         ^
modules/imgproc/src/opencl/remap.cl:377:23: note: d is overwritten
                    d = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataD.y, src_step, map_dataD.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:533:23: style: Redundant initialization for 'a'. The initialized value is overwritten before it is read. [redundantInitialization]
                    a = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataA.y, src_step, map_dataA.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:530:22: note: a is initialized
                WT a = scalar, b = scalar, c = scalar, d = scalar;
                     ^
modules/imgproc/src/opencl/remap.cl:533:23: note: a is overwritten
                    a = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataA.y, src_step, map_dataA.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:538:23: style: Redundant initialization for 'b'. The initialized value is overwritten before it is read. [redundantInitialization]
                    b = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataB.y, src_step, map_dataB.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:530:34: note: b is initialized
                WT a = scalar, b = scalar, c = scalar, d = scalar;
                                 ^
modules/imgproc/src/opencl/remap.cl:538:23: note: b is overwritten
                    b = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataB.y, src_step, map_dataB.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:543:23: style: Redundant initialization for 'c'. The initialized value is overwritten before it is read. [redundantInitialization]
                    c = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataC.y, src_step, map_dataC.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:530:46: note: c is initialized
                WT a = scalar, b = scalar, c = scalar, d = scalar;
                                             ^
modules/imgproc/src/opencl/remap.cl:543:23: note: c is overwritten
                    c = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataC.y, src_step, map_dataC.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:548:23: style: Redundant initialization for 'd'. The initialized value is overwritten before it is read. [redundantInitialization]
                    d = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataD.y, src_step, map_dataD.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/remap.cl:530:58: note: d is initialized
                WT a = scalar, b = scalar, c = scalar, d = scalar;
                                                         ^
modules/imgproc/src/opencl/remap.cl:548:23: note: d is overwritten
                    d = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataD.y, src_step, map_dataD.x * TSIZE + src_offset))));
                      ^
modules/imgproc/src/opencl/resize.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/opencl/sepFilter3x3.cl:46:15: style: Variable 'src_index' is assigned a value that is never used. [unreadVariable]
    src_index = block_x * 16 * ssx + (y - 1) * src_step;
              ^
modules/imgproc/src/opencl/sepFilter3x3.cl:47:19: style: Variable 'line_end' is assigned a value that is never used. [unreadVariable]
    bool line_end = ((block_x + 1) * 16 == cols);
                  ^
modules/imgproc/src/opencl/warp_affine.cl:333:79: style: The scope of the variable 'src_index' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int src_index0 = mad24(sy, src_step, mad24(sx, pixsize, src_offset)), src_index;
                                                                              ^
modules/imgproc/src/opencl/warp_affine.cl:192:83: style: The scope of the variable 'src_index' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int src_index0 = mad24(sy, src_step, mad24(sx, pixsize, src_offset)), src_index;
                                                                                  ^
modules/imgproc/src/phasecorr.cpp:77:39: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            for( k = 0; k < (cols % 2 ? 1 : 2); k++ )
                                      ^
modules/imgproc/src/phasecorr.cpp:121:39: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            for( k = 0; k < (cols % 2 ? 1 : 2); k++ )
                                      ^
modules/imgproc/src/phasecorr.cpp:196:39: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            for( k = 0; k < (cols % 2 ? 1 : 2); k++ )
                                      ^
modules/imgproc/src/phasecorr.cpp:281:39: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            for( k = 0; k < (cols % 2 ? 1 : 2); k++ )
                                      ^
modules/imgproc/src/pyramids.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/pyramids.cpp:1385:5: warning: Possible null pointer dereference: func [nullPointer]
    func( src, dst, borderType );
    ^
modules/imgproc/src/pyramids.cpp:1371:20: note: Assignment 'func=0', assigned value is 0
    PyrFunc func = 0;
                   ^
modules/imgproc/src/pyramids.cpp:1385:5: note: Null pointer dereference
    func( src, dst, borderType );
    ^
modules/imgproc/src/pyramids.cpp:1493:5: warning: Possible null pointer dereference: func [nullPointer]
    func( src, dst, borderType );
    ^
modules/imgproc/src/pyramids.cpp:1479:20: note: Assignment 'func=0', assigned value is 0
    PyrFunc func = 0;
                   ^
modules/imgproc/src/pyramids.cpp:1493:5: note: Null pointer dereference
    func( src, dst, borderType );
    ^
modules/imgproc/src/resize.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/fixedpoint.inl.hpp:33:5: style: Class 'fixedpoint64' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    fixedpoint64(int64_t _val) : val(_val) {}
    ^
modules/imgproc/src/fixedpoint.inl.hpp:38:22: style: Class 'fixedpoint64' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE fixedpoint64(const int8_t& _val) { val = ((int64_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:39:22: style: Class 'fixedpoint64' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE fixedpoint64(const int16_t& _val) { val = ((int64_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:40:22: style: Class 'fixedpoint64' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE fixedpoint64(const int32_t& _val) { val = ((int64_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:41:22: style: Class 'fixedpoint64' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE fixedpoint64(const cv::softdouble& _val) { val = cvRound64(_val * cv::softdouble((int64_t)(1LL << fixedShift))); }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:95:5: style: Class 'ufixedpoint64' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ufixedpoint64(uint64_t _val) : val(_val) {}
    ^
modules/imgproc/src/fixedpoint.inl.hpp:100:22: style: Class 'ufixedpoint64' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE ufixedpoint64(const uint8_t& _val) { val = ((uint64_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:101:22: style: Class 'ufixedpoint64' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE ufixedpoint64(const uint16_t& _val) { val = ((uint64_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:102:22: style: Class 'ufixedpoint64' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE ufixedpoint64(const uint32_t& _val) { val = ((uint64_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:103:22: style: Class 'ufixedpoint64' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE ufixedpoint64(const cv::softdouble& _val) { val = _val.getSign() ? 0 : (uint64_t)cvRound64(_val * cv::softdouble((int64_t)(1LL << fixedShift))); }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:148:5: style: Class 'fixedpoint32' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    fixedpoint32(int32_t _val) : val(_val) {}
    ^
modules/imgproc/src/fixedpoint.inl.hpp:153:22: style: Class 'fixedpoint32' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE fixedpoint32(const int8_t& _val) { val = ((int32_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:154:22: style: Class 'fixedpoint32' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE fixedpoint32(const uint8_t& _val) { val = ((int32_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:155:22: style: Class 'fixedpoint32' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE fixedpoint32(const int16_t& _val) { val = ((int32_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:156:22: style: Class 'fixedpoint32' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE fixedpoint32(const cv::softdouble& _val) { val = (int32_t)cvRound(_val * cv::softdouble((1 << fixedShift))); }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:189:5: style: Class 'ufixedpoint32' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ufixedpoint32(uint32_t _val) : val(_val) {}
    ^
modules/imgproc/src/fixedpoint.inl.hpp:194:22: style: Class 'ufixedpoint32' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE ufixedpoint32(const uint8_t& _val) { val = ((uint32_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:195:22: style: Class 'ufixedpoint32' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE ufixedpoint32(const uint16_t& _val) { val = ((uint32_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:196:22: style: Class 'ufixedpoint32' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE ufixedpoint32(const cv::softdouble& _val) { val = _val.getSign() ? 0 : (uint32_t)cvRound(_val * cv::softdouble((1 << fixedShift))); }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:228:5: style: Class 'fixedpoint16' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    fixedpoint16(int16_t _val) : val(_val) {}
    ^
modules/imgproc/src/fixedpoint.inl.hpp:233:22: style: Class 'fixedpoint16' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE fixedpoint16(const int8_t& _val) { val = ((int16_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:234:22: style: Class 'fixedpoint16' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE fixedpoint16(const uint8_t& _val) { val = ((int16_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:235:22: style: Class 'fixedpoint16' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE fixedpoint16(const cv::softdouble& _val) { val = (int16_t)cvRound(_val * cv::softdouble((1 << fixedShift))); }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:259:5: style: Class 'ufixedpoint16' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ufixedpoint16(uint16_t _val) : val(_val) {}
    ^
modules/imgproc/src/fixedpoint.inl.hpp:264:22: style: Class 'ufixedpoint16' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE ufixedpoint16(const uint8_t& _val) { val = ((uint16_t)_val) << fixedShift; }
                     ^
modules/imgproc/src/fixedpoint.inl.hpp:265:22: style: Class 'ufixedpoint16' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ALWAYS_INLINE ufixedpoint16(const cv::softdouble& _val) { val = _val.getSign() ? 0 : (uint16_t)cvRound(_val * cv::softdouble((int32_t)(1 << fixedShift))); }
                     ^
modules/imgproc/src/resize.cpp:3771:17: warning: Either the condition 'func!=0' is redundant or there is possible null pointer dereference: func. [nullPointerRedundantCheck]
                func( src, dst, ofs, xofs, iscale_x, iscale_y );
                ^
modules/imgproc/src/resize.cpp:3757:33: note: Assuming that condition 'func!=0' is not redundant
                CV_Assert( func != 0 );
                                ^
modules/imgproc/src/resize.cpp:3756:55: note: Assignment 'func=areafast_tab[depth]', assigned value is 0
                ResizeAreaFastFunc func = areafast_tab[depth];
                                                      ^
modules/imgproc/src/resize.cpp:3771:17: note: Null pointer dereference
                func( src, dst, ofs, xofs, iscale_x, iscale_y );
                ^
modules/imgproc/src/resize.cpp:3796:13: warning: Either the condition 'func!=0' is redundant or there is possible null pointer dereference: func. [nullPointerRedundantCheck]
            func( src, dst, xtab, xtab_size, ytab, ytab_size, tabofs );
            ^
modules/imgproc/src/resize.cpp:3776:29: note: Assuming that condition 'func!=0' is not redundant
            CV_Assert( func != 0 && cn <= 4 );
                            ^
modules/imgproc/src/resize.cpp:3775:43: note: Assignment 'func=area_tab[depth]', assigned value is 0
            ResizeAreaFunc func = area_tab[depth];
                                          ^
modules/imgproc/src/resize.cpp:3796:13: note: Null pointer dereference
            func( src, dst, xtab, xtab_size, ytab, ytab_size, tabofs );
            ^
modules/imgproc/src/resize.cpp:3823:21: portability: Casting from float * to signed short * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
    short* ialpha = (short*)alpha;
                    ^
modules/imgproc/src/fixedpoint.inl.hpp:52:48: portability: Shifting signed 64-bit value by 63 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
        uint64_t uval = (uint64_t)((val ^ (val >> 63)) - (val >> 63));
                                               ^
modules/imgproc/src/fixedpoint.inl.hpp:53:58: portability: Shifting signed 64-bit value by 63 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
        uint64_t umul = (uint64_t)((val2.val ^ (val2.val >> 63)) - (val2.val >> 63));
                                                         ^
modules/imgproc/src/fixedpoint.inl.hpp:54:32: portability: Shifting signed 64-bit value by 63 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
        int64_t ressign = (val >> 63) ^ (val2.val >> 63);
                               ^
modules/imgproc/src/resize.cpp:3222:19: style: The scope of the variable 'fxx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            float fxx, fyy;
                  ^
modules/imgproc/src/resize.cpp:3222:24: style: The scope of the variable 'fyy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            float fxx, fyy;
                       ^
modules/imgproc/src/resize.cpp:3223:17: style: The scope of the variable 'sx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int sx, sy;
                ^
modules/imgproc/src/resize.cpp:3223:21: style: The scope of the variable 'sy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int sx, sy;
                    ^
modules/imgproc/src/rotcalipers.cpp:288:30: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
                float *buf = (float *) buffer;
                             ^
modules/imgproc/src/rotcalipers.cpp:292:18: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                ((int *) buf)[0] = seq[3];
                 ^
modules/imgproc/src/rotcalipers.cpp:298:18: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                ((int *) buf)[5] = seq[0];
                 ^
modules/imgproc/src/rotcalipers.cpp:310:22: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
        float *buf = (float *) buffer;
                     ^
modules/imgproc/src/rotcalipers.cpp:318:33: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
        float C1 = A1 * points[((int *) buf)[0]].x + points[((int *) buf)[0]].y * B1;
                                ^
modules/imgproc/src/rotcalipers.cpp:319:33: portability: Casting from float * to signed int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
        float C2 = A2 * points[((int *) buf)[5]].x + points[((int *) buf)[5]].y * B2;
                                ^
modules/imgproc/src/rotcalipers.cpp:48:9: style: struct member 'MinAreaState::bottom' is never used. [unusedStructMember]
    int bottom;
        ^
modules/imgproc/src/rotcalipers.cpp:49:9: style: struct member 'MinAreaState::left' is never used. [unusedStructMember]
    int left;
        ^
modules/imgproc/src/rotcalipers.cpp:52:11: style: struct member 'MinAreaState::base_a' is never used. [unusedStructMember]
    float base_a;
          ^
modules/imgproc/src/rotcalipers.cpp:53:11: style: struct member 'MinAreaState::base_b' is never used. [unusedStructMember]
    float base_b;
          ^
modules/imgproc/src/samplers.cpp:138:15: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j, c;
              ^
modules/imgproc/src/segmentation.cpp:448:48: warning: Either the condition 'if(mask&&!mask[j])' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
                                          mask += mstep )
                                               ^
modules/imgproc/src/segmentation.cpp:455:19: note: Assuming that condition 'if(mask&&!mask[j])' is not redundant
                if( mask && !mask[j] )
                  ^
modules/imgproc/src/segmentation.cpp:448:48: note: Null pointer addition
                                          mask += mstep )
                                               ^
modules/imgproc/src/segmentation.cpp:452:37: style: The scope of the variable 'x1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int x0 = j, y0 = i, x1, y1, iter;
                                    ^
modules/imgproc/src/segmentation.cpp:452:41: style: The scope of the variable 'y1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                int x0 = j, y0 = i, x1, y1, iter;
                                        ^
modules/imgproc/src/segmentation.cpp:464:25: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                    int x, y, count = 0;
                        ^
modules/imgproc/src/shapedescr.cpp:433:12: style: The scope of the variable 'x0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x0, y0, a, b, theta;
           ^
modules/imgproc/src/shapedescr.cpp:433:16: style: The scope of the variable 'y0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x0, y0, a, b, theta;
               ^
modules/imgproc/src/shapedescr.cpp:433:20: style: The scope of the variable 'a' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x0, y0, a, b, theta;
                   ^
modules/imgproc/src/shapedescr.cpp:433:23: style: The scope of the variable 'b' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x0, y0, a, b, theta;
                      ^
modules/imgproc/src/shapedescr.cpp:433:26: style: The scope of the variable 'theta' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x0, y0, a, b, theta;
                         ^
modules/imgproc/src/shapedescr.cpp:499:20: style: The scope of the variable 'normi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            double normi, normEVali, normMinpos, normEValMinpos;
                   ^
modules/imgproc/src/shapedescr.cpp:499:27: style: The scope of the variable 'normEVali' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            double normi, normEVali, normMinpos, normEValMinpos;
                          ^
modules/imgproc/src/shapedescr.cpp:608:12: style: The scope of the variable 'x0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x0, y0, a, b, theta, Ts;
           ^
modules/imgproc/src/shapedescr.cpp:608:16: style: The scope of the variable 'y0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x0, y0, a, b, theta, Ts;
               ^
modules/imgproc/src/shapedescr.cpp:608:20: style: The scope of the variable 'a' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x0, y0, a, b, theta, Ts;
                   ^
modules/imgproc/src/shapedescr.cpp:608:23: style: The scope of the variable 'b' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x0, y0, a, b, theta, Ts;
                      ^
modules/imgproc/src/shapedescr.cpp:608:26: style: The scope of the variable 'theta' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double x0, y0, a, b, theta, Ts;
                         ^
modules/imgproc/src/shapedescr.cpp:743:52: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int  xmin = 0, ymin = 0, xmax = -1, ymax = -1, i;
                                                   ^
modules/imgproc/src/shapedescr.cpp:862:64: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int xmin = size.width, ymin = -1, xmax = -1, ymax = -1, i, j, k;
                                                               ^
modules/imgproc/src/shapedescr.cpp:868:26: style: The scope of the variable 'k_min' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int have_nz = 0, k_min, offset = (int)(ptr - _ptr);
                         ^
modules/imgproc/src/shapedescr.cpp:1210:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j = 0, count;
        ^
modules/imgproc/src/shapedescr.cpp:1210:12: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j = 0, count;
           ^
modules/imgproc/src/shapedescr.cpp:1210:19: style: The scope of the variable 'count' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j = 0, count;
                  ^
modules/imgproc/src/shapedescr.cpp:1040:40: style: Argument 'p_max*sizeof(double)' to function cvAlloc is always 16 [constArgument]
    p_are1 = (double *) cvAlloc( p_max * sizeof( double ));
                                       ^
modules/imgproc/src/shapedescr.cpp:1016:17: note: Assignment 'p_max=2', assigned value is 2
    int p_max = 2, p_ind;
                ^
modules/imgproc/src/shapedescr.cpp:1040:40: note: Argument 'p_max*sizeof(double)' to function cvAlloc is always 16
    p_are1 = (double *) cvAlloc( p_max * sizeof( double ));
                                       ^
modules/imgproc/src/smooth.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/imgproc/src/smooth.cpp:296:18: style: The function 'reset' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/filterengine.hpp:102:18: note: Virtual function in base class
    virtual void reset();
                 ^
modules/imgproc/src/smooth.cpp:296:18: note: Function in derived class
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/smooth.cpp:298:18: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/filterengine.hpp:100:18: note: Virtual function in base class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int dstcount, int width) = 0;
                 ^
modules/imgproc/src/smooth.cpp:298:18: note: Function in derived class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/smooth.cpp:443:18: style: The function 'reset' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/filterengine.hpp:102:18: note: Virtual function in base class
    virtual void reset();
                 ^
modules/imgproc/src/smooth.cpp:443:18: note: Function in derived class
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/smooth.cpp:445:18: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/filterengine.hpp:100:18: note: Virtual function in base class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int dstcount, int width) = 0;
                 ^
modules/imgproc/src/smooth.cpp:445:18: note: Function in derived class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/smooth.cpp:572:18: style: The function 'reset' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/filterengine.hpp:102:18: note: Virtual function in base class
    virtual void reset();
                 ^
modules/imgproc/src/smooth.cpp:572:18: note: Function in derived class
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/smooth.cpp:574:18: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/filterengine.hpp:100:18: note: Virtual function in base class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int dstcount, int width) = 0;
                 ^
modules/imgproc/src/smooth.cpp:574:18: note: Function in derived class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/smooth.cpp:700:18: style: The function 'reset' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/filterengine.hpp:102:18: note: Virtual function in base class
    virtual void reset();
                 ^
modules/imgproc/src/smooth.cpp:700:18: note: Function in derived class
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/smooth.cpp:702:18: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/filterengine.hpp:100:18: note: Virtual function in base class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int dstcount, int width) = 0;
                 ^
modules/imgproc/src/smooth.cpp:702:18: note: Function in derived class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/smooth.cpp:825:18: style: The function 'reset' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/filterengine.hpp:102:18: note: Virtual function in base class
    virtual void reset();
                 ^
modules/imgproc/src/smooth.cpp:825:18: note: Function in derived class
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/smooth.cpp:827:18: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/filterengine.hpp:100:18: note: Virtual function in base class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int dstcount, int width) = 0;
                 ^
modules/imgproc/src/smooth.cpp:827:18: note: Function in derived class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/smooth.cpp:944:18: style: The function 'reset' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/filterengine.hpp:102:18: note: Virtual function in base class
    virtual void reset();
                 ^
modules/imgproc/src/smooth.cpp:944:18: note: Function in derived class
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/smooth.cpp:946:18: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/filterengine.hpp:100:18: note: Virtual function in base class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int dstcount, int width) = 0;
                 ^
modules/imgproc/src/smooth.cpp:946:18: note: Function in derived class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/smooth.cpp:1605:18: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void operator()(const uchar* src, uchar* dst, int width, int cn)
                 ^
modules/imgproc/src/filterengine.hpp:72:18: note: Virtual function in base class
    virtual void operator()(const uchar* src, uchar* dst, int width, int cn) = 0;
                 ^
modules/imgproc/src/smooth.cpp:1605:18: note: Function in derived class
    virtual void operator()(const uchar* src, uchar* dst, int width, int cn)
                 ^
modules/imgproc/src/smooth.cpp:198:18: style: The function 'reset' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/filterengine.hpp:102:18: note: Virtual function in base class
    virtual void reset();
                 ^
modules/imgproc/src/smooth.cpp:198:18: note: Function in derived class
    virtual void reset() { sumCount = 0; }
                 ^
modules/imgproc/src/smooth.cpp:200:18: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/filterengine.hpp:100:18: note: Virtual function in base class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int dstcount, int width) = 0;
                 ^
modules/imgproc/src/smooth.cpp:200:18: note: Function in derived class
    virtual void operator()(const uchar** src, uchar* dst, int dststep, int count, int width)
                 ^
modules/imgproc/src/smooth.cpp:87:18: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void operator()(const uchar* src, uchar* dst, int width, int cn)
                 ^
modules/imgproc/src/filterengine.hpp:72:18: note: Virtual function in base class
    virtual void operator()(const uchar* src, uchar* dst, int width, int cn) = 0;
                 ^
modules/imgproc/src/smooth.cpp:87:18: note: Function in derived class
    virtual void operator()(const uchar* src, uchar* dst, int width, int cn)
                 ^
modules/imgproc/src/smooth.cpp:3471:12: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j, maxk, radius;
           ^
modules/imgproc/src/smooth.cpp:1609:15: style: Variable 'i' is assigned a value that is never used. [unreadVariable]
        int i = 0, k, ksz_cn = ksize*cn;
              ^
modules/imgproc/src/smooth.cpp:91:15: style: Variable 'i' is assigned a value that is never used. [unreadVariable]
        int i = 0, k, ksz_cn = ksize*cn;
              ^
modules/imgproc/src/smooth.cpp:3189:0: information: Skipping configuration 'CV_SIMD128' since the value of 'CV_SIMD128' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            (CV_SIMD128 && hasSIMD128() ? 1 : 3))
^
modules/imgproc/src/smooth.cpp:3823:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'valSquareSigma' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        valSquareSigma  = _valSquareSigma;
        ^
modules/imgproc/src/smooth.cpp:3824:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'posSquareSigma' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        posSquareSigma  = _posSquareSigma;
        ^
modules/imgproc/src/smooth.cpp:3825:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'borderType' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        borderType      = _borderType;
        ^
modules/imgproc/src/smooth.cpp:2054:16: warning: Identical condition '!ok', second condition is always false [identicalConditionAfterEarlyExit]
            if(!ok)
               ^
modules/imgproc/src/smooth.cpp:2049:16: note: If condition '!ok' is true, the function will return/exit
            if(!ok)
               ^
modules/imgproc/src/smooth.cpp:2054:16: note: Testing identical condition '!ok'
            if(!ok)
               ^
modules/imgproc/src/smooth.cpp:3890:16: warning: Identical condition '!ok', second condition is always false [identicalConditionAfterEarlyExit]
            if(!ok)
               ^
modules/imgproc/src/smooth.cpp:3885:16: note: If condition '!ok' is true, the function will return/exit
            if(!ok)
               ^
modules/imgproc/src/smooth.cpp:3890:16: note: Testing identical condition '!ok'
            if(!ok)
               ^
modules/imgproc/src/smooth.cpp:1993:9: style: The exception is caught by value. It could be caught as a (const) reference which is usually recommended in C++. [catchExceptionByValue]
        catch(::ipp::IwException e)
        ^
modules/imgproc/src/smooth.cpp:2060:5: style: The exception is caught by value. It could be caught as a (const) reference which is usually recommended in C++. [catchExceptionByValue]
    catch (::ipp::IwException ex)
    ^
modules/imgproc/src/smooth.cpp:1182:45: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            pxPerWorkItemX = size.width % 8 ? size.width % 4 ? size.width % 2 ? 1 : 2 : 4 : 8;
                                            ^
modules/imgproc/src/smooth.cpp:1183:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            pxPerWorkItemY = size.height % 2 ? 1 : 2;
                                             ^
modules/imgproc/src/smooth.cpp:1187:45: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            pxPerWorkItemX = size.width % 2 ? 1 : 2;
                                            ^
modules/imgproc/src/smooth.cpp:1188:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            pxPerWorkItemY = size.height % 2 ? 1 : 2;
                                             ^
modules/imgproc/src/spatialgradient.cpp:295:13: style: Variable 'v00' is reassigned a value before the old one has been used. [redundantAssignment]
        v00 = p_src[j_p]; v01 = p_src[j];
            ^
modules/imgproc/src/spatialgradient.cpp:289:13: note: v00 is assigned
        v00 = v01; v10 = v11; v20 = v21;
            ^
modules/imgproc/src/spatialgradient.cpp:295:13: note: v00 is overwritten
        v00 = p_src[j_p]; v01 = p_src[j];
            ^
modules/imgproc/src/spatialgradient.cpp:296:13: style: Variable 'v10' is reassigned a value before the old one has been used. [redundantAssignment]
        v10 = c_src[j_p]; v11 = c_src[j];
            ^
modules/imgproc/src/spatialgradient.cpp:289:24: note: v10 is assigned
        v00 = v01; v10 = v11; v20 = v21;
                       ^
modules/imgproc/src/spatialgradient.cpp:296:13: note: v10 is overwritten
        v10 = c_src[j_p]; v11 = c_src[j];
            ^
modules/imgproc/src/spatialgradient.cpp:297:13: style: Variable 'v20' is reassigned a value before the old one has been used. [redundantAssignment]
        v20 = n_src[j_p]; v21 = n_src[j];
            ^
modules/imgproc/src/spatialgradient.cpp:289:35: note: v20 is assigned
        v00 = v01; v10 = v11; v20 = v21;
                                  ^
modules/imgproc/src/spatialgradient.cpp:297:13: note: v20 is overwritten
        v20 = n_src[j_p]; v21 = n_src[j];
            ^
modules/imgproc/src/spatialgradient.cpp:295:31: style: Variable 'v01' is reassigned a value before the old one has been used. [redundantAssignment]
        v00 = p_src[j_p]; v01 = p_src[j];
                              ^
modules/imgproc/src/spatialgradient.cpp:290:13: note: v01 is assigned
        v01 = v02; v11 = v12; v21 = v22;
            ^
modules/imgproc/src/spatialgradient.cpp:295:31: note: v01 is overwritten
        v00 = p_src[j_p]; v01 = p_src[j];
                              ^
modules/imgproc/src/spatialgradient.cpp:296:31: style: Variable 'v11' is reassigned a value before the old one has been used. [redundantAssignment]
        v10 = c_src[j_p]; v11 = c_src[j];
                              ^
modules/imgproc/src/spatialgradient.cpp:290:24: note: v11 is assigned
        v01 = v02; v11 = v12; v21 = v22;
                       ^
modules/imgproc/src/spatialgradient.cpp:296:31: note: v11 is overwritten
        v10 = c_src[j_p]; v11 = c_src[j];
                              ^
modules/imgproc/src/spatialgradient.cpp:297:31: style: Variable 'v21' is reassigned a value before the old one has been used. [redundantAssignment]
        v20 = n_src[j_p]; v21 = n_src[j];
                              ^
modules/imgproc/src/spatialgradient.cpp:290:35: note: v21 is assigned
        v01 = v02; v11 = v12; v21 = v22;
                                  ^
modules/imgproc/src/spatialgradient.cpp:297:31: note: v21 is overwritten
        v20 = n_src[j_p]; v21 = n_src[j];
                              ^
modules/imgproc/src/spatialgradient.cpp:104:9: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        j = 0;
        ^
modules/imgproc/src/spatialgradient.cpp:128:12: style: The scope of the variable 'c_dx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    short *c_dx,  *c_dy;
           ^
modules/imgproc/src/spatialgradient.cpp:128:20: style: The scope of the variable 'c_dy' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    short *c_dx,  *c_dy;
                   ^
modules/imgproc/src/spatialgradient.cpp:264:9: style: The scope of the variable 'j_p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int j_p, j_n;
        ^
modules/imgproc/src/spatialgradient.cpp:264:14: style: The scope of the variable 'j_n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int j_p, j_n;
             ^
modules/imgproc/src/spatialgradient.cpp:104:11: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
        j = 0;
          ^
modules/imgproc/src/subdivision2d.cpp:416:40: style: The scope of the variable 'deleted_edge' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int curr_point = 0, curr_edge = 0, deleted_edge = 0;
                                       ^
modules/imgproc/src/subdivision2d.cpp:416:53: style: Variable 'deleted_edge' is assigned a value that is never used. [unreadVariable]
    int curr_point = 0, curr_edge = 0, deleted_edge = 0;
                                                    ^
modules/imgproc/src/sumpixels.cpp:86:13: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int j = 0;
            ^
modules/imgproc/src/sumpixels.cpp:85:52: style: Variable 'prev' is assigned a value that is never used. [unreadVariable]
        __m128i v_zero = _mm_setzero_si128(), prev = v_zero;
                                                   ^
modules/imgproc/src/sumpixels.cpp:86:15: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
        int j = 0;
              ^
modules/imgproc/src/templmatch.cpp:777:15: style: Variable 'depth' is assigned a value that is never used. [unreadVariable]
        depth = CV_32F;
              ^
modules/imgproc/src/templmatch.cpp:784:16: style: Variable 'tdepth' is assigned a value that is never used. [unreadVariable]
        tdepth = CV_32F;
               ^
modules/imgproc/src/templmatch.cpp:791:16: style: Variable 'mdepth' is assigned a value that is never used. [unreadVariable]
        mdepth = CV_32F;
               ^
modules/imgproc/src/templmatch.cpp:464:19: style: Redundant initialization for 'templ_sum'. The initialized value is overwritten before it is read. [redundantInitialization]
        templ_sum = (Vec4f)mean(templ);
                  ^
modules/imgproc/src/templmatch.cpp:463:25: note: templ_sum is initialized
        Vec4f templ_sum = Vec4f::all(0);
                        ^
modules/imgproc/src/templmatch.cpp:464:19: note: templ_sum is overwritten
        templ_sum = (Vec4f)mean(templ);
                  ^
modules/imgproc/src/templmatch.cpp:516:19: style: Redundant initialization for 'templ_sum'. The initialized value is overwritten before it is read. [redundantInitialization]
        templ_sum = sum(templ);
                  ^
modules/imgproc/src/templmatch.cpp:515:25: note: templ_sum is initialized
        Vec4f templ_sum = Vec4f::all(0), templ_sqsum = Vec4f::all(0);
                        ^
modules/imgproc/src/templmatch.cpp:516:19: note: templ_sum is overwritten
        templ_sum = sum(templ);
                  ^
modules/imgproc/src/templmatch.cpp:519:21: style: Redundant initialization for 'templ_sqsum'. The initialized value is overwritten before it is read. [redundantInitialization]
        templ_sqsum = sum(temp);
                    ^
modules/imgproc/src/templmatch.cpp:515:54: note: templ_sqsum is initialized
        Vec4f templ_sum = Vec4f::all(0), templ_sqsum = Vec4f::all(0);
                                                     ^
modules/imgproc/src/templmatch.cpp:519:21: note: templ_sqsum is overwritten
        templ_sqsum = sum(temp);
                    ^
modules/imgproc/src/templmatch.cpp:183:11: style: Variable 'block_size' can be declared with const [constVariable]
    Size& block_size = buf.block_size;
          ^
modules/imgproc/src/templmatch.cpp:184:11: style: Variable 'dft_size' can be declared with const [constVariable]
    Size& dft_size = buf.dft_size;
          ^
modules/imgproc/src/templmatch.cpp:249:21: style: Variable 'result' is assigned a value that is never used. [unreadVariable]
        UMat result = _result.getUMat();
                    ^
modules/imgproc/src/templmatch.cpp:506:20: style: Variable 'result' is assigned a value that is never used. [unreadVariable]
            result = Scalar::all(1);
                   ^
modules/imgproc/src/thresh.cpp:1201:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'src' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        src = _src;
        ^
modules/imgproc/src/thresh.cpp:1202:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'dst' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        dst = _dst;
        ^
modules/imgproc/src/thresh.cpp:1041:12: style: The scope of the variable 'j' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j, h[N] = {0};
           ^
modules/imgproc/src/thresh.cpp:1124:9: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int temp;
        ^
modules/imgproc/src/thresh.cpp:1172:28: style: The scope of the variable 'tempdist' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double a, b, dist = 0, tempdist;
                           ^
modules/imgproc/src/thresh.cpp:1533:13: style: Variable 'dst' is assigned a value that is never used. [unreadVariable]
        dst = Scalar(0);
            ^
modules/imgproc/src/undistort.cpp:148:21: portability: Casting from float * to signed short * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
        short* m1 = (short*)m1f;
                    ^
modules/imgproc/src/undistort.cpp:377:22: style: The scope of the variable 'x0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double x, y, x0 = 0, y0 = 0, u, v;
                     ^
modules/imgproc/src/undistort.cpp:377:30: style: The scope of the variable 'y0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double x, y, x0 = 0, y0 = 0, u, v;
                             ^
modules/imgproc/src/undistort.cpp:252:78: style: Variable 'dst0' is assigned a value that is never used. [unreadVariable]
    cv::Mat src = cv::cvarrToMat(srcarr), dst = cv::cvarrToMat(dstarr), dst0 = dst;
                                                                             ^
modules/imgproc/test/ocl/test_accumulate.cpp:106:1: error: syntax error [syntaxError]
OCL_TEST_P(Accumulate, Mat)
^
modules/imgproc/test/ocl/test_blend.cpp:111:1: error: syntax error [syntaxError]
OCL_TEST_P(BlendLinear, Accuracy)
^
modules/imgproc/test/ocl/test_boxfilter.cpp:103:1: error: syntax error [syntaxError]
OCL_TEST_P(BoxFilter, Mat)
^
modules/imgproc/test/ocl/test_canny.cpp:97:1: error: syntax error [syntaxError]
OCL_TEST_P(Canny, Accuracy)
^
modules/imgproc/test/ocl/test_color.cpp:132:1: error: syntax error [syntaxError]
OCL_TEST_P(CvtColor, BGR2BGRA) { performTest(3, 4, CVTCODE(BGR2BGRA)); }
^
modules/imgproc/test/ocl/test_filter2d.cpp:111:1: error: syntax error [syntaxError]
OCL_TEST_P(Filter2D, Mat)
^
modules/imgproc/test/ocl/test_filters.cpp:132:1: error: syntax error [syntaxError]
OCL_TEST_P(Bilateral, Mat)
^
modules/imgproc/test/ocl/test_gftt.cpp:95:1: error: syntax error [syntaxError]
OCL_TEST_P(GoodFeaturesToTrack, Accuracy)
^
modules/imgproc/test/ocl/test_histogram.cpp:199:1: error: syntax error [syntaxError]
OCL_TEST_P(CalcBackProject, Mat)
^
modules/imgproc/test/ocl/test_houghlines.cpp:27:1: error: syntax error [syntaxError]
PARAM_TEST_CASE(HoughLines, double, double, int)
^
modules/imgproc/test/ocl/test_imgproc.cpp:108:1: error: syntax error [syntaxError]
PARAM_TEST_CASE(CopyMakeBorder, MatDepth, // depth
^
modules/imgproc/test/ocl/test_match_template.cpp:114:1: error: syntax error [syntaxError]
OCL_TEST_P(MatchTemplate, Mat)
^
modules/imgproc/test/ocl/test_medianfilter.cpp:90:1: error: syntax error [syntaxError]
OCL_TEST_P(MedianFilter, Mat)
^
modules/imgproc/test/ocl/test_pyramids.cpp:93:1: error: syntax error [syntaxError]
OCL_TEST_P(PyrDown, Mat)
^
modules/imgproc/test/ocl/test_sepfilter2d.cpp:109:1: error: syntax error [syntaxError]
OCL_TEST_P(SepFilter2D, Mat)
^
modules/imgproc/test/ocl/test_warp.cpp:70:1: error: syntax error [syntaxError]
PARAM_TEST_CASE(WarpTestBase, MatType, Interpolation, bool, bool)
^
modules/imgproc/test/test_approxpoly.cpp:175:12: style: The scope of the variable 'A' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double A,B,C;
           ^
modules/imgproc/test/test_approxpoly.cpp:175:14: style: The scope of the variable 'B' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double A,B,C;
             ^
modules/imgproc/test/test_approxpoly.cpp:175:16: style: The scope of the variable 'C' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double A,B,C;
               ^
modules/imgproc/test/test_approxpoly.cpp:176:12: style: The scope of the variable 'Sq' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double Sq;
           ^
modules/imgproc/test/test_bilateral_filter.cpp:287:5: error: syntax error [syntaxError]
    TEST(Imgproc_BilateralFilter, accuracy)
    ^
modules/imgproc/test/test_boundingrect.cpp:78:97: performance: Parameter 'src' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
template <typename T> cv::Rect CV_BoundingRectTest::get_bounding_rect(const vector <Point_<T> > src)
                                                                                                ^
modules/imgproc/test/test_canny.cpp:354:9: style: The scope of the variable 'kSize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int kSize;
        ^
modules/imgproc/test/test_canny.cpp:355:10: style: The scope of the variable 'useL2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool useL2;
         ^
modules/imgproc/test/test_canny.cpp:98:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    aperture_size = cvtest::randInt(rng) % 2 ? 5 : 3;
                                             ^
modules/imgproc/test/test_canny.cpp:347:1: performance: Parameter 'arg' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
IMPLEMENT_PARAM_CLASS(ImagePath, string)
^
modules/imgproc/test/test_color.cpp:429:10: style: The function 'convert_row_bgr2abc_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:66:18: note: Virtual function in base class
    virtual void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:429:10: note: Function in derived class
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:430:10: style: The function 'convert_row_abc2bgr_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:69:18: note: Virtual function in base class
    virtual void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:430:10: note: Function in derived class
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:503:10: style: The function 'convert_row_bgr2abc_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:66:18: note: Virtual function in base class
    virtual void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:503:10: note: Function in derived class
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:504:10: style: The function 'convert_row_abc2bgr_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:69:18: note: Virtual function in base class
    virtual void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:504:10: note: Function in derived class
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:595:10: style: The function 'convert_row_bgr2abc_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:66:18: note: Virtual function in base class
    virtual void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:595:10: note: Function in derived class
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:596:10: style: The function 'convert_row_abc2bgr_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:69:18: note: Virtual function in base class
    virtual void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:596:10: note: Function in derived class
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:734:10: style: The function 'convert_row_bgr2abc_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:66:18: note: Virtual function in base class
    virtual void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:734:10: note: Function in derived class
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:735:10: style: The function 'convert_row_abc2bgr_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:69:18: note: Virtual function in base class
    virtual void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:735:10: note: Function in derived class
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:918:10: style: The function 'convert_row_bgr2abc_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:66:18: note: Virtual function in base class
    virtual void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:918:10: note: Function in derived class
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:919:10: style: The function 'convert_row_abc2bgr_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:69:18: note: Virtual function in base class
    virtual void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:919:10: note: Function in derived class
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:1045:10: style: The function 'convert_row_bgr2abc_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:66:18: note: Virtual function in base class
    virtual void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:1045:10: note: Function in derived class
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:1046:10: style: The function 'convert_row_abc2bgr_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:69:18: note: Virtual function in base class
    virtual void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:1046:10: note: Function in derived class
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:1224:10: style: The function 'convert_row_bgr2abc_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:66:18: note: Virtual function in base class
    virtual void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:1224:10: note: Function in derived class
    void convert_row_bgr2abc_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:1225:10: style: The function 'convert_row_abc2bgr_32f_c3' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:69:18: note: Virtual function in base class
    virtual void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
                 ^
modules/imgproc/test/test_color.cpp:1225:10: note: Function in derived class
    void convert_row_abc2bgr_32f_c3( const float* src_row, float* dst_row, int n );
         ^
modules/imgproc/test/test_color.cpp:1430:10: style: The function 'convert_forward' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_forward( const Mat& src, Mat& dst );
         ^
modules/imgproc/test/test_color.cpp:61:18: note: Virtual function in base class
    virtual void convert_forward( const Mat& src, Mat& dst );
                 ^
modules/imgproc/test/test_color.cpp:1430:10: note: Function in derived class
    void convert_forward( const Mat& src, Mat& dst );
         ^
modules/imgproc/test/test_color.cpp:1431:10: style: The function 'convert_backward' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void convert_backward( const Mat& src, const Mat& dst, Mat& dst2 );
         ^
modules/imgproc/test/test_color.cpp:63:18: note: Virtual function in base class
    virtual void convert_backward( const Mat& src, const Mat& dst, Mat& dst2 );
                 ^
modules/imgproc/test/test_color.cpp:1431:10: note: Function in derived class
    void convert_backward( const Mat& src, const Mat& dst, Mat& dst2 );
         ^
modules/imgproc/test/test_color.cpp:1581:41: warning: Function 'convert_backward' argument order different: declaration 'src, dst, dst2' definition ', src, dst' [funcArgOrderDifferent]
void CV_ColorRGBTest::convert_backward( const Mat& /*src*/, const Mat& src, Mat& dst )
                                        ^
modules/imgproc/test/test_color.cpp:1431:39: note: Function 'convert_backward' argument order different: declaration 'src, dst, dst2' definition ', src, dst'
    void convert_backward( const Mat& src, const Mat& dst, Mat& dst2 );
                                      ^
modules/imgproc/test/test_color.cpp:1581:41: note: Function 'convert_backward' argument order different: declaration 'src, dst, dst2' definition ', src, dst'
void CV_ColorRGBTest::convert_backward( const Mat& /*src*/, const Mat& src, Mat& dst )
                                        ^
modules/imgproc/test/test_color.cpp:1270:24: style: Local variable 'uLow' shadows outer variable [shadowVariable]
    static const float uLow = -134.f, uHigh = 220.f, uRange = uHigh - uLow;
                       ^
modules/imgproc/test/test_color.cpp:2156:24: note: Shadowed declaration
static const softfloat uLow(-134), uHigh(220), uRange(uHigh-uLow);
                       ^
modules/imgproc/test/test_color.cpp:1270:24: note: Shadow variable
    static const float uLow = -134.f, uHigh = 220.f, uRange = uHigh - uLow;
                       ^
modules/imgproc/test/test_color.cpp:1270:39: style: Local variable 'uHigh' shadows outer variable [shadowVariable]
    static const float uLow = -134.f, uHigh = 220.f, uRange = uHigh - uLow;
                                      ^
modules/imgproc/test/test_color.cpp:2156:36: note: Shadowed declaration
static const softfloat uLow(-134), uHigh(220), uRange(uHigh-uLow);
                                   ^
modules/imgproc/test/test_color.cpp:1270:39: note: Shadow variable
    static const float uLow = -134.f, uHigh = 220.f, uRange = uHigh - uLow;
                                      ^
modules/imgproc/test/test_color.cpp:1270:54: style: Local variable 'uRange' shadows outer variable [shadowVariable]
    static const float uLow = -134.f, uHigh = 220.f, uRange = uHigh - uLow;
                                                     ^
modules/imgproc/test/test_color.cpp:2156:48: note: Shadowed declaration
static const softfloat uLow(-134), uHigh(220), uRange(uHigh-uLow);
                                               ^
modules/imgproc/test/test_color.cpp:1270:54: note: Shadow variable
    static const float uLow = -134.f, uHigh = 220.f, uRange = uHigh - uLow;
                                                     ^
modules/imgproc/test/test_color.cpp:1271:24: style: Local variable 'vLow' shadows outer variable [shadowVariable]
    static const float vLow = -140.f, vHigh = 122.f, vRange = vHigh - vLow;
                       ^
modules/imgproc/test/test_color.cpp:2157:24: note: Shadowed declaration
static const softfloat vLow(-140), vHigh(122), vRange(vHigh-vLow);
                       ^
modules/imgproc/test/test_color.cpp:1271:24: note: Shadow variable
    static const float vLow = -140.f, vHigh = 122.f, vRange = vHigh - vLow;
                       ^
modules/imgproc/test/test_color.cpp:1271:39: style: Local variable 'vHigh' shadows outer variable [shadowVariable]
    static const float vLow = -140.f, vHigh = 122.f, vRange = vHigh - vLow;
                                      ^
modules/imgproc/test/test_color.cpp:2157:36: note: Shadowed declaration
static const softfloat vLow(-140), vHigh(122), vRange(vHigh-vLow);
                                   ^
modules/imgproc/test/test_color.cpp:1271:39: note: Shadow variable
    static const float vLow = -140.f, vHigh = 122.f, vRange = vHigh - vLow;
                                      ^
modules/imgproc/test/test_color.cpp:1271:54: style: Local variable 'vRange' shadows outer variable [shadowVariable]
    static const float vLow = -140.f, vHigh = 122.f, vRange = vHigh - vLow;
                                                     ^
modules/imgproc/test/test_color.cpp:2157:48: note: Shadowed declaration
static const softfloat vLow(-140), vHigh(122), vRange(vHigh-vLow);
                                               ^
modules/imgproc/test/test_color.cpp:1271:54: note: Shadow variable
    static const float vLow = -140.f, vHigh = 122.f, vRange = vHigh - vLow;
                                                     ^
modules/imgproc/test/test_color.cpp:1347:24: style: Local variable 'uLow' shadows outer variable [shadowVariable]
    static const float uLow = -134.f, uHigh = 220.f, uRange = uHigh - uLow;
                       ^
modules/imgproc/test/test_color.cpp:2156:24: note: Shadowed declaration
static const softfloat uLow(-134), uHigh(220), uRange(uHigh-uLow);
                       ^
modules/imgproc/test/test_color.cpp:1347:24: note: Shadow variable
    static const float uLow = -134.f, uHigh = 220.f, uRange = uHigh - uLow;
                       ^
modules/imgproc/test/test_color.cpp:1347:39: style: Local variable 'uHigh' shadows outer variable [shadowVariable]
    static const float uLow = -134.f, uHigh = 220.f, uRange = uHigh - uLow;
                                      ^
modules/imgproc/test/test_color.cpp:2156:36: note: Shadowed declaration
static const softfloat uLow(-134), uHigh(220), uRange(uHigh-uLow);
                                   ^
modules/imgproc/test/test_color.cpp:1347:39: note: Shadow variable
    static const float uLow = -134.f, uHigh = 220.f, uRange = uHigh - uLow;
                                      ^
modules/imgproc/test/test_color.cpp:1347:54: style: Local variable 'uRange' shadows outer variable [shadowVariable]
    static const float uLow = -134.f, uHigh = 220.f, uRange = uHigh - uLow;
                                                     ^
modules/imgproc/test/test_color.cpp:2156:48: note: Shadowed declaration
static const softfloat uLow(-134), uHigh(220), uRange(uHigh-uLow);
                                               ^
modules/imgproc/test/test_color.cpp:1347:54: note: Shadow variable
    static const float uLow = -134.f, uHigh = 220.f, uRange = uHigh - uLow;
                                                     ^
modules/imgproc/test/test_color.cpp:1348:24: style: Local variable 'vLow' shadows outer variable [shadowVariable]
    static const float vLow = -140.f, vHigh = 122.f, vRange = vHigh - vLow;
                       ^
modules/imgproc/test/test_color.cpp:2157:24: note: Shadowed declaration
static const softfloat vLow(-140), vHigh(122), vRange(vHigh-vLow);
                       ^
modules/imgproc/test/test_color.cpp:1348:24: note: Shadow variable
    static const float vLow = -140.f, vHigh = 122.f, vRange = vHigh - vLow;
                       ^
modules/imgproc/test/test_color.cpp:1348:39: style: Local variable 'vHigh' shadows outer variable [shadowVariable]
    static const float vLow = -140.f, vHigh = 122.f, vRange = vHigh - vLow;
                                      ^
modules/imgproc/test/test_color.cpp:2157:36: note: Shadowed declaration
static const softfloat vLow(-140), vHigh(122), vRange(vHigh-vLow);
                                   ^
modules/imgproc/test/test_color.cpp:1348:39: note: Shadow variable
    static const float vLow = -140.f, vHigh = 122.f, vRange = vHigh - vLow;
                                      ^
modules/imgproc/test/test_color.cpp:1348:54: style: Local variable 'vRange' shadows outer variable [shadowVariable]
    static const float vLow = -140.f, vHigh = 122.f, vRange = vHigh - vLow;
                                                     ^
modules/imgproc/test/test_color.cpp:2157:48: note: Shadowed declaration
static const softfloat vLow(-140), vHigh(122), vRange(vHigh-vLow);
                                               ^
modules/imgproc/test/test_color.cpp:1348:54: note: Shadow variable
    static const float vLow = -140.f, vHigh = 122.f, vRange = vHigh - vLow;
                                                     ^
modules/imgproc/test/test_color.cpp:142:41: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    blue_idx = cvtest::randInt(rng) & 1 ? 2 : 0;
                                        ^
modules/imgproc/test/test_color.cpp:2813:20: style: Variable 'S' is assigned a value that is never used. [unreadVariable]
    const uchar* S = src.ptr<uchar>(1) + 1;
                   ^
modules/imgproc/test/test_color.cpp:2814:14: style: Variable 'D' is assigned a value that is never used. [unreadVariable]
    uchar* D = dst.ptr<uchar>(1) + dcn;
             ^
modules/imgproc/test/test_connectedcomponents.cpp:63:29: style: Parameter 'imgLabels' can be declared with const [constParameter]
void normalizeLabels(Mat1i& imgLabels, int iNumLabels) {
                            ^
modules/imgproc/test/test_contours.cpp:87:21: warning: Member variable 'CV_FindContourTest::blob_count' is not initialized in the constructor. [uninitMemberVar]
CV_FindContourTest::CV_FindContourTest()
                    ^
modules/imgproc/test/test_contours.cpp:87:21: warning: Member variable 'CV_FindContourTest::retr_mode' is not initialized in the constructor. [uninitMemberVar]
CV_FindContourTest::CV_FindContourTest()
                    ^
modules/imgproc/test/test_contours.cpp:87:21: warning: Member variable 'CV_FindContourTest::approx_method' is not initialized in the constructor. [uninitMemberVar]
CV_FindContourTest::CV_FindContourTest()
                    ^
modules/imgproc/test/test_contours.cpp:87:21: warning: Member variable 'CV_FindContourTest::count' is not initialized in the constructor. [uninitMemberVar]
CV_FindContourTest::CV_FindContourTest()
                    ^
modules/imgproc/test/test_contours.cpp:87:21: warning: Member variable 'CV_FindContourTest::count2' is not initialized in the constructor. [uninitMemberVar]
CV_FindContourTest::CV_FindContourTest()
                    ^
modules/imgproc/test/test_contours.cpp:87:21: warning: Member variable 'CV_FindContourTest::contours' is not initialized in the constructor. [uninitMemberVar]
CV_FindContourTest::CV_FindContourTest()
                    ^
modules/imgproc/test/test_contours.cpp:87:21: warning: Member variable 'CV_FindContourTest::contours2' is not initialized in the constructor. [uninitMemberVar]
CV_FindContourTest::CV_FindContourTest()
                    ^
modules/imgproc/test/test_contours.cpp:87:21: warning: Member variable 'CV_FindContourTest::chain' is not initialized in the constructor. [uninitMemberVar]
CV_FindContourTest::CV_FindContourTest()
                    ^
modules/imgproc/test/test_contours.cpp:91:26: style: Condition 'useVeryWideImages' is always false [knownConditionTrueFalse]
    test_case_count    = useVeryWideImages ? 10 : 300;
                         ^
modules/imgproc/test/test_contours.cpp:96:26: style: Condition 'useVeryWideImages' is always false [knownConditionTrueFalse]
    min_log_img_width  = useVeryWideImages ? 17 : 3;
                         ^
modules/imgproc/test/test_contours.cpp:97:26: style: Condition 'useVeryWideImages' is always false [knownConditionTrueFalse]
    max_log_img_width  = useVeryWideImages ? 17 : 10;
                         ^
modules/imgproc/test/test_contours.cpp:152:65: style: Condition 'useVeryWideImages' is always false [knownConditionTrueFalse]
    min_log_img_width  = cvtest::clipInt( min_log_img_width, 1, useVeryWideImages ? 17 : 10 );
                                                                ^
modules/imgproc/test/test_contours.cpp:153:65: style: Condition 'useVeryWideImages' is always false [knownConditionTrueFalse]
    min_log_img_width  = cvtest::clipInt( max_log_img_width, 1, useVeryWideImages ? 17 : 10 );
                                                                ^
modules/imgproc/test/test_contours.cpp:130:9: style: The scope of the variable 't' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int t;
        ^
modules/imgproc/test/test_contours.cpp:431:9: style: The scope of the variable 'rx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int rx, ry, s, t=d;
        ^
modules/imgproc/test/test_contours.cpp:431:13: style: The scope of the variable 'ry' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int rx, ry, s, t=d;
            ^
modules/imgproc/test/test_convhull.cpp:217:24: warning: Member variable 'CV_BaseShapeDescrTest::result' is not initialized in the constructor. [uninitMemberVar]
CV_BaseShapeDescrTest::CV_BaseShapeDescrTest()
                       ^
modules/imgproc/test/test_convhull.cpp:947:19: warning: Member variable 'CV_MinCircleTest::radius' is not initialized in the constructor. [uninitMemberVar]
CV_MinCircleTest::CV_MinCircleTest()
                  ^
modules/imgproc/test/test_convhull.cpp:1036:20: warning: Member variable 'CV_MinCircleTest2::delta' is not initialized in the constructor. [uninitMemberVar]
CV_MinCircleTest2::CV_MinCircleTest2()
                   ^
modules/imgproc/test/test_convhull.cpp:1096:19: warning: Member variable 'CV_PerimeterTest::is_closed' is not initialized in the constructor. [uninitMemberVar]
CV_PerimeterTest::CV_PerimeterTest()
                  ^
modules/imgproc/test/test_convhull.cpp:1096:19: warning: Member variable 'CV_PerimeterTest::result' is not initialized in the constructor. [uninitMemberVar]
CV_PerimeterTest::CV_PerimeterTest()
                  ^
modules/imgproc/test/test_convhull.cpp:1491:17: warning: Member variable 'CV_FitLineTest::dist_type' is not initialized in the constructor. [uninitMemberVar]
CV_FitLineTest::CV_FitLineTest()
                ^
modules/imgproc/test/test_convhull.cpp:1491:17: warning: Member variable 'CV_FitLineTest::reps' is not initialized in the constructor. [uninitMemberVar]
CV_FitLineTest::CV_FitLineTest()
                ^
modules/imgproc/test/test_convhull.cpp:1491:17: warning: Member variable 'CV_FitLineTest::aeps' is not initialized in the constructor. [uninitMemberVar]
CV_FitLineTest::CV_FitLineTest()
                ^
modules/imgproc/test/test_convhull.cpp:1759:24: warning: Member variable 'CV_ContourMomentsTest::area0' is not initialized in the constructor. [uninitMemberVar]
CV_ContourMomentsTest::CV_ContourMomentsTest()
                       ^
modules/imgproc/test/test_convhull.cpp:1759:24: warning: Member variable 'CV_ContourMomentsTest::area' is not initialized in the constructor. [uninitMemberVar]
CV_ContourMomentsTest::CV_ContourMomentsTest()
                       ^
modules/imgproc/test/test_convhull.cpp:1759:24: warning: Member variable 'CV_ContourMomentsTest::max_r_scale' is not initialized in the constructor. [uninitMemberVar]
CV_ContourMomentsTest::CV_ContourMomentsTest()
                       ^
modules/imgproc/test/test_convhull.cpp:1759:24: warning: Member variable 'CV_ContourMomentsTest::angle' is not initialized in the constructor. [uninitMemberVar]
CV_ContourMomentsTest::CV_ContourMomentsTest()
                       ^
modules/imgproc/test/test_convhull.cpp:226:11: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'high' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    low = high = cvScalarAll(0);
          ^
modules/imgproc/test/test_convhull.cpp:1038:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'rng' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    rng = ts->get_rng();
    ^
modules/imgproc/test/test_convhull.cpp:1092:12: warning: The class 'CV_PerimeterTest' defines member variable with name 'result' also defined in its parent class 'CV_BaseShapeDescrTest'. [duplInheritedMember]
    double result;
           ^
modules/imgproc/test/test_convhull.cpp:209:11: note: Parent variable 'CV_BaseShapeDescrTest::result'
    void* result;
          ^
modules/imgproc/test/test_convhull.cpp:1092:12: note: Derived variable 'CV_PerimeterTest::result'
    double result;
           ^
modules/imgproc/test/test_convhull.cpp:1196:10: style: The function 'generate_point_set' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void generate_point_set( void* points );
         ^
modules/imgproc/test/test_convhull.cpp:197:18: note: Virtual function in base class
    virtual void generate_point_set( void* points );
                 ^
modules/imgproc/test/test_convhull.cpp:1196:10: note: Function in derived class
    void generate_point_set( void* points );
         ^
modules/imgproc/test/test_convhull.cpp:1421:10: style: The function 'generate_point_set' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void generate_point_set( void* points );
         ^
modules/imgproc/test/test_convhull.cpp:197:18: note: Virtual function in base class
    virtual void generate_point_set( void* points );
                 ^
modules/imgproc/test/test_convhull.cpp:1421:10: note: Function in derived class
    void generate_point_set( void* points );
         ^
modules/imgproc/test/test_convhull.cpp:1481:10: style: The function 'generate_point_set' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void generate_point_set( void* points );
         ^
modules/imgproc/test/test_convhull.cpp:197:18: note: Virtual function in base class
    virtual void generate_point_set( void* points );
                 ^
modules/imgproc/test/test_convhull.cpp:1481:10: note: Function in derived class
    void generate_point_set( void* points );
         ^
modules/imgproc/test/test_convhull.cpp:1746:10: style: The function 'generate_point_set' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void generate_point_set( void* points );
         ^
modules/imgproc/test/test_convhull.cpp:197:18: note: Virtual function in base class
    virtual void generate_point_set( void* points );
                 ^
modules/imgproc/test/test_convhull.cpp:1746:10: note: Function in derived class
    void generate_point_set( void* points );
         ^
modules/imgproc/test/test_convhull.cpp:838:10: style: The scope of the variable 'errorEnclosed' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool errorEnclosed = false, errorMiddlePoints = false, errorFlush = true;
         ^
modules/imgproc/test/test_convhull.cpp:838:33: style: The scope of the variable 'errorMiddlePoints' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool errorEnclosed = false, errorMiddlePoints = false, errorFlush = true;
                                ^
modules/imgproc/test/test_convhull.cpp:838:60: style: The scope of the variable 'errorFlush' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool errorEnclosed = false, errorMiddlePoints = false, errorFlush = true;
                                                           ^
modules/imgproc/test/test_convhull.cpp:839:12: style: The scope of the variable 'eps' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double eps = 1e-4;
           ^
modules/imgproc/test/test_convhull.cpp:348:37: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
        (enable_flt_points ? 2 : 1) ? CV_32F : CV_32S, dims);
                                    ^
modules/imgproc/test/test_convhull.cpp:473:44: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    orientation = cvtest::randInt(rng) % 2 ? CV_CLOCKWISE : CV_COUNTER_CLOCKWISE;
                                           ^
modules/imgproc/test/test_cvtyuv.cpp:615:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(YUVCVTS, CV_YUV2RGB_NV12, CV_YUV2BGR_NV12, CV_YUV2RGB_NV21, CV_YUV2BGR_NV21,
^
modules/imgproc/test/test_distancetransform.cpp:68:18: warning: Member variable 'CV_DisTransTest::mask_size' is not initialized in the constructor. [uninitMemberVar]
CV_DisTransTest::CV_DisTransTest()
                 ^
modules/imgproc/test/test_distancetransform.cpp:68:18: warning: Member variable 'CV_DisTransTest::dist_type' is not initialized in the constructor. [uninitMemberVar]
CV_DisTransTest::CV_DisTransTest()
                 ^
modules/imgproc/test/test_distancetransform.cpp:68:18: warning: Member variable 'CV_DisTransTest::fill_labels' is not initialized in the constructor. [uninitMemberVar]
CV_DisTransTest::CV_DisTransTest()
                 ^
modules/imgproc/test/test_distancetransform.cpp:68:18: warning: Member variable 'CV_DisTransTest::mask' is not initialized in the constructor. [uninitMemberVar]
CV_DisTransTest::CV_DisTransTest()
                 ^
modules/imgproc/test/test_drawing.cpp:554:1: error: syntax error [syntaxError]
TEST(Drawing,    cpp_regression) { CV_DrawingTest_CPP test; test.safe_run(); }
^
modules/imgproc/test/test_filter.cpp:66:20: warning: Member variable 'CV_FilterBaseTest::border' is not initialized in the constructor. [uninitMemberVar]
CV_FilterBaseTest::CV_FilterBaseTest( bool _fp_kernel ) : fp_kernel(_fp_kernel)
                   ^
modules/imgproc/test/test_filter.cpp:450:19: warning: Member variable 'CV_DerivBaseTest::_aperture_size' is not initialized in the constructor. [uninitMemberVar]
CV_DerivBaseTest::CV_DerivBaseTest() : CV_FilterBaseTest( true )
                  ^
modules/imgproc/test/test_filter.cpp:493:15: warning: Member variable 'CV_SobelTest::dx' is not initialized in the constructor. [uninitMemberVar]
CV_SobelTest::CV_SobelTest() {}
              ^
modules/imgproc/test/test_filter.cpp:493:15: warning: Member variable 'CV_SobelTest::dy' is not initialized in the constructor. [uninitMemberVar]
CV_SobelTest::CV_SobelTest() {}
              ^
modules/imgproc/test/test_filter.cpp:493:15: warning: Member variable 'CV_SobelTest::origin' is not initialized in the constructor. [uninitMemberVar]
CV_SobelTest::CV_SobelTest() {}
              ^
modules/imgproc/test/test_filter.cpp:570:25: warning: Member variable 'CV_SpatialGradientTest::ksize' is not initialized in the constructor. [uninitMemberVar]
CV_SpatialGradientTest::CV_SpatialGradientTest() {
                        ^
modules/imgproc/test/test_filter.cpp:738:14: warning: Member variable 'CV_BlurTest::normalize' is not initialized in the constructor. [uninitMemberVar]
CV_BlurTest::CV_BlurTest()
             ^
modules/imgproc/test/test_filter.cpp:802:22: warning: Member variable 'CV_GaussianBlurTest::param1' is not initialized in the constructor. [uninitMemberVar]
CV_GaussianBlurTest::CV_GaussianBlurTest() : CV_SmoothBaseTest()
                     ^
modules/imgproc/test/test_filter.cpp:802:22: warning: Member variable 'CV_GaussianBlurTest::param2' is not initialized in the constructor. [uninitMemberVar]
CV_GaussianBlurTest::CV_GaussianBlurTest() : CV_SmoothBaseTest()
                     ^
modules/imgproc/test/test_filter.cpp:1280:24: warning: Member variable 'CV_FeatureSelBaseTest::aperture_size' is not initialized in the constructor. [uninitMemberVar]
CV_FeatureSelBaseTest::CV_FeatureSelBaseTest( int _width_factor )
                       ^
modules/imgproc/test/test_filter.cpp:1280:24: warning: Member variable 'CV_FeatureSelBaseTest::block_size' is not initialized in the constructor. [uninitMemberVar]
CV_FeatureSelBaseTest::CV_FeatureSelBaseTest( int _width_factor )
                       ^
modules/imgproc/test/test_filter.cpp:50:5: style: Class 'CV_FilterBaseTest' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_FilterBaseTest( bool _fp_kernel );
    ^
modules/imgproc/test/test_filter.cpp:1089:5: style: Class 'CV_PyramidBaseTest' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_PyramidBaseTest( bool downsample );
    ^
modules/imgproc/test/test_filter.cpp:1266:5: style: Class 'CV_FeatureSelBaseTest' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_FeatureSelBaseTest( int width_factor );
    ^
modules/imgproc/test/test_filter.cpp:970:31: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j, k, l, m2 = m*m, n;
                              ^
modules/imgproc/test/test_filter.cpp:1979:72: warning: Found suspicious operator ',' [constStatement]
            (Mat_<uchar>(3, 3) << 170, 113, 170, 113, 28, 113, 170, 113, 170);
                                                                       ^
modules/imgproc/test/test_filter.cpp:2045:59: warning: Found suspicious operator ',' [constStatement]
    Mat src = (Mat_<uchar>(3, 3) << 1, 2, 3, 4, 5, 6, 7, 8, 9), dst, expected_dst;
                                                          ^
modules/imgproc/test/test_filter.cpp:2068:61: warning: Found suspicious operator ',' [constStatement]
        (Mat_<short>(3, 3) << -15, 0, 15, -20, 0, 20, -15, 0, 15);
                                                            ^
modules/imgproc/test/test_filter.cpp:2095:18: warning: Found suspicious operator ',' [constStatement]
           0, 255, 0;
                 ^
modules/imgproc/test/test_filter.cpp:2113:18: warning: Found suspicious operator ',' [constStatement]
           0, 255, 0;
                 ^
modules/imgproc/test/test_floodfill.cpp:75:19: warning: Member variable 'CV_FloodFillTest::connectivity' is not initialized in the constructor. [uninitMemberVar]
CV_FloodFillTest::CV_FloodFillTest()
                  ^
modules/imgproc/test/test_floodfill.cpp:75:19: warning: Member variable 'CV_FloodFillTest::use_mask' is not initialized in the constructor. [uninitMemberVar]
CV_FloodFillTest::CV_FloodFillTest()
                  ^
modules/imgproc/test/test_floodfill.cpp:75:19: warning: Member variable 'CV_FloodFillTest::mask_only' is not initialized in the constructor. [uninitMemberVar]
CV_FloodFillTest::CV_FloodFillTest()
                  ^
modules/imgproc/test/test_floodfill.cpp:75:19: warning: Member variable 'CV_FloodFillTest::range_type' is not initialized in the constructor. [uninitMemberVar]
CV_FloodFillTest::CV_FloodFillTest()
                  ^
modules/imgproc/test/test_floodfill.cpp:75:19: warning: Member variable 'CV_FloodFillTest::new_mask_val' is not initialized in the constructor. [uninitMemberVar]
CV_FloodFillTest::CV_FloodFillTest()
                  ^
modules/imgproc/test/test_floodfill.cpp:97:12: style: The scope of the variable 'buff' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double buff[8];
           ^
modules/imgproc/test/test_floodfill.cpp:102:35: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    cn = cvtest::randInt(rng) & 1 ? 3 : 1;
                                  ^
modules/imgproc/test/test_goodfeaturetotrack.cpp:366:43: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    useHarrisDetector = test_case_idx & 2 ?  true : false;
                                          ^
modules/imgproc/test/test_histograms.cpp:90:18: warning: Member variable 'CV_BaseHistTest::cdims' is not initialized in the constructor. [uninitMemberVar]
CV_BaseHistTest::CV_BaseHistTest()
                 ^
modules/imgproc/test/test_histograms.cpp:90:18: warning: Member variable 'CV_BaseHistTest::dims' is not initialized in the constructor. [uninitMemberVar]
CV_BaseHistTest::CV_BaseHistTest()
                 ^
modules/imgproc/test/test_histograms.cpp:90:18: warning: Member variable 'CV_BaseHistTest::total_size' is not initialized in the constructor. [uninitMemberVar]
CV_BaseHistTest::CV_BaseHistTest()
                 ^
modules/imgproc/test/test_histograms.cpp:90:18: warning: Member variable 'CV_BaseHistTest::hist_type' is not initialized in the constructor. [uninitMemberVar]
CV_BaseHistTest::CV_BaseHistTest()
                 ^
modules/imgproc/test/test_histograms.cpp:90:18: warning: Member variable 'CV_BaseHistTest::uniform' is not initialized in the constructor. [uninitMemberVar]
CV_BaseHistTest::CV_BaseHistTest()
                 ^
modules/imgproc/test/test_histograms.cpp:90:18: warning: Member variable 'CV_BaseHistTest::gen_hist_sparse_nz_ratio' is not initialized in the constructor. [uninitMemberVar]
CV_BaseHistTest::CV_BaseHistTest()
                 ^
modules/imgproc/test/test_histograms.cpp:90:18: warning: Member variable 'CV_BaseHistTest::img_type' is not initialized in the constructor. [uninitMemberVar]
CV_BaseHistTest::CV_BaseHistTest()
                 ^
modules/imgproc/test/test_histograms.cpp:90:18: warning: Member variable 'CV_BaseHistTest::low' is not initialized in the constructor. [uninitMemberVar]
CV_BaseHistTest::CV_BaseHistTest()
                 ^
modules/imgproc/test/test_histograms.cpp:90:18: warning: Member variable 'CV_BaseHistTest::high' is not initialized in the constructor. [uninitMemberVar]
CV_BaseHistTest::CV_BaseHistTest()
                 ^
modules/imgproc/test/test_histograms.cpp:90:18: warning: Member variable 'CV_BaseHistTest::range_delta' is not initialized in the constructor. [uninitMemberVar]
CV_BaseHistTest::CV_BaseHistTest()
                 ^
modules/imgproc/test/test_histograms.cpp:593:20: warning: Member variable 'CV_MinMaxHistTest::min_idx' is not initialized in the constructor. [uninitMemberVar]
CV_MinMaxHistTest::CV_MinMaxHistTest()
                   ^
modules/imgproc/test/test_histograms.cpp:593:20: warning: Member variable 'CV_MinMaxHistTest::max_idx' is not initialized in the constructor. [uninitMemberVar]
CV_MinMaxHistTest::CV_MinMaxHistTest()
                   ^
modules/imgproc/test/test_histograms.cpp:593:20: warning: Member variable 'CV_MinMaxHistTest::min_val' is not initialized in the constructor. [uninitMemberVar]
CV_MinMaxHistTest::CV_MinMaxHistTest()
                   ^
modules/imgproc/test/test_histograms.cpp:593:20: warning: Member variable 'CV_MinMaxHistTest::max_val' is not initialized in the constructor. [uninitMemberVar]
CV_MinMaxHistTest::CV_MinMaxHistTest()
                   ^
modules/imgproc/test/test_histograms.cpp:593:20: warning: Member variable 'CV_MinMaxHistTest::min_idx0' is not initialized in the constructor. [uninitMemberVar]
CV_MinMaxHistTest::CV_MinMaxHistTest()
                   ^
modules/imgproc/test/test_histograms.cpp:593:20: warning: Member variable 'CV_MinMaxHistTest::max_idx0' is not initialized in the constructor. [uninitMemberVar]
CV_MinMaxHistTest::CV_MinMaxHistTest()
                   ^
modules/imgproc/test/test_histograms.cpp:593:20: warning: Member variable 'CV_MinMaxHistTest::min_val0' is not initialized in the constructor. [uninitMemberVar]
CV_MinMaxHistTest::CV_MinMaxHistTest()
                   ^
modules/imgproc/test/test_histograms.cpp:593:20: warning: Member variable 'CV_MinMaxHistTest::max_val0' is not initialized in the constructor. [uninitMemberVar]
CV_MinMaxHistTest::CV_MinMaxHistTest()
                   ^
modules/imgproc/test/test_histograms.cpp:809:20: warning: Member variable 'CV_ThreshHistTest::orig_nz_count' is not initialized in the constructor. [uninitMemberVar]
CV_ThreshHistTest::CV_ThreshHistTest()
                   ^
modules/imgproc/test/test_histograms.cpp:963:21: warning: Member variable 'CV_CompareHistTest::result' is not initialized in the constructor. [uninitMemberVar]
CV_CompareHistTest::CV_CompareHistTest()
                    ^
modules/imgproc/test/test_histograms.cpp:1571:30: warning: Member variable 'CV_CalcBackProjectPatchTest::factor' is not initialized in the constructor. [uninitMemberVar]
CV_CalcBackProjectPatchTest::CV_CalcBackProjectPatchTest()
                             ^
modules/imgproc/test/test_histograms.cpp:1571:30: warning: Member variable 'CV_CalcBackProjectPatchTest::method' is not initialized in the constructor. [uninitMemberVar]
CV_CalcBackProjectPatchTest::CV_CalcBackProjectPatchTest()
                             ^
modules/imgproc/test/test_histograms.cpp:325:10: style: The function 'init_hist' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void init_hist( int test_case_idx, int i );
         ^
modules/imgproc/test/test_histograms.cpp:61:18: note: Virtual function in base class
    virtual void init_hist( int test_case_idx, int i );
                 ^
modules/imgproc/test/test_histograms.cpp:325:10: note: Function in derived class
    void init_hist( int test_case_idx, int i );
         ^
modules/imgproc/test/test_histograms.cpp:583:10: style: The function 'init_hist' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void init_hist(int, int);
         ^
modules/imgproc/test/test_histograms.cpp:61:18: note: Virtual function in base class
    virtual void init_hist( int test_case_idx, int i );
                 ^
modules/imgproc/test/test_histograms.cpp:583:10: note: Function in derived class
    void init_hist(int, int);
         ^
modules/imgproc/test/test_histograms.cpp:1754:10: style: The function 'init_hist' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void init_hist( int test_case_idx, int i );
         ^
modules/imgproc/test/test_histograms.cpp:61:18: note: Virtual function in base class
    virtual void init_hist( int test_case_idx, int i );
                 ^
modules/imgproc/test/test_histograms.cpp:1754:10: note: Function in derived class
    void init_hist( int test_case_idx, int i );
         ^
modules/imgproc/test/test_histograms.cpp:1755:10: style: The function 'get_hist_params' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void get_hist_params( int test_case_idx );
         ^
modules/imgproc/test/test_histograms.cpp:63:18: note: Virtual function in base class
    virtual void get_hist_params( int test_case_idx );
                 ^
modules/imgproc/test/test_histograms.cpp:1755:10: note: Function in derived class
    void get_hist_params( int test_case_idx );
         ^
modules/imgproc/test/test_histograms.cpp:1431:22: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
                    ((float*)data)[idx] = (float)val;
                     ^
modules/imgproc/test/test_histograms.cpp:1659:22: portability: Casting between signed char * and float * which have an incompatible binary data representation. [invalidPointerCast]
                    ((float*)data)[idx] = (float)val;
                     ^
modules/imgproc/test/test_histograms.cpp:1539:10: style: Redundant initialization for 'code'. The initialized value is overwritten before it is read. [redundantInitialization]
    code = cvtest::cmpEps2( ts, a, b, threshold, true, "Back project image" );
         ^
modules/imgproc/test/test_histograms.cpp:1534:14: note: code is initialized
    int code = cvtest::TS::OK;
             ^
modules/imgproc/test/test_histograms.cpp:1539:10: note: code is overwritten
    code = cvtest::cmpEps2( ts, a, b, threshold, true, "Back project image" );
         ^
modules/imgproc/test/test_histograms.cpp:1733:10: style: Redundant initialization for 'code'. The initialized value is overwritten before it is read. [redundantInitialization]
    code = cvtest::cmpEps2( ts, a, b, err_level, true, "BackProjectPatch result" );
         ^
modules/imgproc/test/test_histograms.cpp:1726:14: note: code is initialized
    int code = cvtest::TS::OK;
             ^
modules/imgproc/test/test_histograms.cpp:1733:10: note: code is overwritten
    code = cvtest::cmpEps2( ts, a, b, err_level, true, "BackProjectPatch result" );
         ^
modules/imgproc/test/test_histograms.cpp:890:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
modules/imgproc/test/test_histograms.cpp:149:42: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    hist_type = cvtest::randInt(rng) % 2 ? CV_HIST_SPARSE : CV_HIST_ARRAY;
                                         ^
modules/imgproc/test/test_histograms.cpp:159:41: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    img_type = cvtest::randInt(rng) % 2 ? CV_32F : CV_8U;
                                        ^
modules/imgproc/test/test_imgwarp.cpp:845:19: warning: Member variable 'CV_UndistortTest::useCPlus' is not initialized in the constructor. [uninitMemberVar]
CV_UndistortTest::CV_UndistortTest() : CV_ImgWarpBaseTest( false )
                  ^
modules/imgproc/test/test_imgwarp.cpp:845:19: warning: Member variable 'CV_UndistortTest::zero_new_cam' is not initialized in the constructor. [uninitMemberVar]
CV_UndistortTest::CV_UndistortTest() : CV_ImgWarpBaseTest( false )
                  ^
modules/imgproc/test/test_imgwarp.cpp:845:19: warning: Member variable 'CV_UndistortTest::zero_distortion' is not initialized in the constructor. [uninitMemberVar]
CV_UndistortTest::CV_UndistortTest() : CV_ImgWarpBaseTest( false )
                  ^
modules/imgproc/test/test_imgwarp.cpp:1009:22: warning: Member variable 'CV_UndistortMapTest::dualChannel' is not initialized in the constructor. [uninitMemberVar]
CV_UndistortMapTest::CV_UndistortMapTest()
                     ^
modules/imgproc/test/test_imgwarp.cpp:50:5: style: Class 'CV_ImgWarpBaseTest' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_ImgWarpBaseTest( bool warp_matrix );
    ^
modules/imgproc/test/test_imgwarp.cpp:110:52: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        types[INPUT][1] = cvtest::randInt(rng) & 1 ? CV_32FC1 : CV_64FC1;
                                                   ^
modules/imgproc/test/test_imgwarp.cpp:863:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    types[INPUT][1] = cvtest::randInt(rng)%2 ? CV_64F : CV_32F;
                                             ^
modules/imgproc/test/test_imgwarp.cpp:864:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    types[INPUT][2] = cvtest::randInt(rng)%2 ? CV_64F : CV_32F;
                                             ^
modules/imgproc/test/test_imgwarp.cpp:866:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    sizes[INPUT][2] = cvtest::randInt(rng)%2 ? cvSize(4,1) : cvSize(1,4);
                                             ^
modules/imgproc/test/test_imgwarp.cpp:1026:40: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    int depth = cvtest::randInt(rng)%2 ? CV_64F : CV_32F;
                                       ^
modules/imgproc/test/test_imgwarp.cpp:1034:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    sizes[INPUT][1] = cvtest::randInt(rng)%2 ? cvSize(4,1) : cvSize(1,4);
                                             ^
modules/imgproc/test/test_imgwarp.cpp:1192:39: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    int cn = cvtest::randInt(rng) % 2 ? 3 : 1;
                                      ^
modules/imgproc/test/test_imgwarp.cpp:1300:39: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    int cn = cvtest::randInt(rng) % 2 ? 3 : 1;
                                      ^
modules/imgproc/test/test_imgwarp.cpp:683:10: style: Variable 'src' can be declared with const [constVariable]
    Mat& src = test_mat[INPUT][0];
         ^
modules/imgproc/test/test_imgwarp.cpp:979:10: style: Variable 'src' can be declared with const [constVariable]
    Mat& src = test_mat[INPUT][0];
         ^
modules/imgproc/test/test_imgwarp_strict.cpp:342:18: style: The function 'generate_test_data' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void generate_test_data();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:83:18: note: Virtual function in base class
    virtual void generate_test_data();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:342:18: note: Function in derived class
    virtual void generate_test_data();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:344:18: style: The function 'run_func' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void run_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:85:18: note: Virtual function in base class
    virtual void run_func() = 0;
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:344:18: note: Function in derived class
    virtual void run_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:345:18: style: The function 'run_reference_func' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void run_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:86:18: note: Virtual function in base class
    virtual void run_reference_func() = 0;
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:345:18: note: Function in derived class
    virtual void run_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:701:18: style: The function 'generate_test_data' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void generate_test_data();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:83:18: note: Virtual function in base class
    virtual void generate_test_data();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:701:18: note: Function in derived class
    virtual void generate_test_data();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:702:18: style: The function 'prepare_test_data_for_reference_func' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void prepare_test_data_for_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:88:18: note: Virtual function in base class
    virtual void prepare_test_data_for_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:702:18: note: Function in derived class
    virtual void prepare_test_data_for_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:704:18: style: The function 'run_func' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void run_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:85:18: note: Virtual function in base class
    virtual void run_func() = 0;
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:704:18: note: Function in derived class
    virtual void run_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:705:18: style: The function 'run_reference_func' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void run_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:86:18: note: Virtual function in base class
    virtual void run_reference_func() = 0;
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:705:18: note: Function in derived class
    virtual void run_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:719:18: style: The function 'validate_results' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void validate_results() const;
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:87:18: note: Virtual function in base class
    virtual void validate_results() const;
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:719:18: note: Function in derived class
    virtual void validate_results() const;
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1040:18: style: The function 'generate_test_data' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void generate_test_data();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:701:18: note: Virtual function in base class
    virtual void generate_test_data();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1040:18: note: Function in derived class
    virtual void generate_test_data();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1041:18: style: The function 'prepare_test_data_for_reference_func' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void prepare_test_data_for_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:702:18: note: Virtual function in base class
    virtual void prepare_test_data_for_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1041:18: note: Function in derived class
    virtual void prepare_test_data_for_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1043:18: style: The function 'run_func' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void run_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:704:18: note: Virtual function in base class
    virtual void run_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1043:18: note: Function in derived class
    virtual void run_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1044:18: style: The function 'run_reference_func' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void run_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:705:18: note: Virtual function in base class
    virtual void run_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1044:18: note: Function in derived class
    virtual void run_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1168:18: style: The function 'generate_test_data' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void generate_test_data();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1040:18: note: Virtual function in base class
    virtual void generate_test_data();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1168:18: note: Function in derived class
    virtual void generate_test_data();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1170:18: style: The function 'run_func' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void run_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1043:18: note: Virtual function in base class
    virtual void run_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1170:18: note: Function in derived class
    virtual void run_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1171:18: style: The function 'run_reference_func' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void run_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1044:18: note: Virtual function in base class
    virtual void run_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:1171:18: note: Function in derived class
    virtual void run_reference_func();
                 ^
modules/imgproc/test/test_imgwarp_strict.cpp:172:94: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
                        std::min<int>(cell_size, ssize.height - y)), Scalar::all((x + y) % 2 ? 255: 0), CV_FILLED);
                                                                                             ^
modules/imgproc/test/test_imgwarp_strict.cpp:445:94: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
                        std::min<int>(cell_size, ssize.height - y)), Scalar::all((x + y) % 2 ? 255: 0), CV_FILLED);
                                                                                             ^
modules/imgproc/test/test_lsd.cpp:15:5: warning: Member variable 'LSDBase::passedtests' is not initialized in the constructor. [uninitMemberVar]
    LSDBase() { }
    ^
modules/imgproc/test/test_moments.cpp:210:21: style: Boolean value assigned to floating point variable. [assignBoolToFloat]
                val = val != 0;
                    ^
modules/imgproc/test/test_moments.cpp:256:21: style: Boolean value assigned to floating point variable. [assignBoolToFloat]
                val = val != 0;
                    ^
modules/imgproc/test/test_moments.cpp:58:5: style: Class 'CV_MomentsTest' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_MomentsTest(bool try_umat);
    ^
modules/imgproc/test/test_pc.cpp:87:1: error: syntax error [syntaxError]
TEST(Imgproc_PhaseCorrelatorTest, accuracy) { CV_PhaseCorrelatorTest test; test.safe_run(); }
^
modules/imgproc/test/test_templmatch.cpp:108:73: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    int depth = cvtest::randInt(rng) % 2, cn = cvtest::randInt(rng) & 1 ? 3 : 1;
                                                                        ^
modules/imgproc/test/test_thresh.cpp:64:16: warning: Member variable 'CV_ThreshTest::thresh_type' is not initialized in the constructor. [uninitMemberVar]
CV_ThreshTest::CV_ThreshTest()
               ^
modules/imgproc/test/test_thresh.cpp:64:16: warning: Member variable 'CV_ThreshTest::thresh_val' is not initialized in the constructor. [uninitMemberVar]
CV_ThreshTest::CV_ThreshTest()
               ^
modules/imgproc/test/test_thresh.cpp:64:16: warning: Member variable 'CV_ThreshTest::max_val' is not initialized in the constructor. [uninitMemberVar]
CV_ThreshTest::CV_ThreshTest()
               ^
modules/java/generator/src/cpp/utils.cpp:27:24: style: The scope of the variable 'dst' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    Mat&               dst = *((Mat*)m_addr);
                       ^
modules/java/generator/src/cpp/utils.cpp:90:24: style: The scope of the variable 'src' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    Mat&               src = *((Mat*)m_addr);
                       ^
modules/js/src/core_bindings.cpp:313:56: performance: Parameter 'msg' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
    void setExceptionMsg(cv::Exception& e, std::string msg) {
                                                       ^
modules/ml/src/precomp.hpp:176:9: error: There is an unknown macro here somewhere. Configuration is required. If CV_IMPL_PROPERTY is a macro then please configure it. [unknownMacro]
        CV_IMPL_PROPERTY(bool, UseSurrogates, useSurrogates)
        ^
modules/ml/test/test_precomp.hpp:77:5: style: Class 'CV_AMLTest' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_AMLTest( const char* _modelName );
    ^
modules/ml/test/test_precomp.hpp:87:5: style: Class 'CV_SLMLTest' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_SLMLTest( const char* _modelName );
    ^
modules/ml/test/test_precomp.hpp:80:17: style: The function 'run_test_case' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int run_test_case( int testCaseIdx );
                ^
modules/ml/test/test_precomp.hpp:54:17: note: Virtual function in base class
    virtual int run_test_case( int testCaseIdx ) = 0;
                ^
modules/ml/test/test_precomp.hpp:80:17: note: Function in derived class
    virtual int run_test_case( int testCaseIdx );
                ^
modules/ml/test/test_precomp.hpp:81:17: style: The function 'validate_test_results' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int validate_test_results( int testCaseIdx );
                ^
modules/ml/test/test_precomp.hpp:55:17: note: Virtual function in base class
    virtual int validate_test_results( int testCaseIdx ) = 0;
                ^
modules/ml/test/test_precomp.hpp:81:17: note: Function in derived class
    virtual int validate_test_results( int testCaseIdx );
                ^
modules/ml/test/test_precomp.hpp:90:17: style: The function 'run_test_case' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int run_test_case( int testCaseIdx );
                ^
modules/ml/test/test_precomp.hpp:54:17: note: Virtual function in base class
    virtual int run_test_case( int testCaseIdx ) = 0;
                ^
modules/ml/test/test_precomp.hpp:90:17: note: Function in derived class
    virtual int run_test_case( int testCaseIdx );
                ^
modules/ml/test/test_precomp.hpp:91:17: style: The function 'validate_test_results' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int validate_test_results( int testCaseIdx );
                ^
modules/ml/test/test_precomp.hpp:55:17: note: Virtual function in base class
    virtual int validate_test_results( int testCaseIdx ) = 0;
                ^
modules/ml/test/test_precomp.hpp:91:17: note: Function in derived class
    virtual int validate_test_results( int testCaseIdx );
                ^
modules/ml/test/test_emknearestkmeans.cpp:96:9: style: The scope of the variable 'bi' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int bi, ei = 0;
        ^
modules/ml/test/test_mltests.cpp:56:10: style: Redundant initialization for 'code'. The initialized value is overwritten before it is read. [redundantInitialization]
    code = prepare_test_case( testCaseIdx );
         ^
modules/ml/test/test_mltests.cpp:55:14: note: code is initialized
    int code = cvtest::TS::OK;
             ^
modules/ml/test/test_mltests.cpp:56:10: note: code is overwritten
    code = prepare_test_case( testCaseIdx );
         ^
modules/ml/test/test_mltests.cpp:97:11: style: The scope of the variable 'mean' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float mean, sigma;
          ^
modules/ml/test/test_mltests.cpp:184:9: style: The scope of the variable 'val' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int val;
        ^
modules/ml/test/test_mltests.cpp:142:48: warning: Found suspicious operator ',' [constStatement]
         4,3,2,1,  4,3,2,1,   4,3,2,1,    4,3,2,1;
                                               ^
modules/ml/test/test_mltests.cpp:146:33: warning: Found suspicious operator ',' [constStatement]
    Y << 0,0,0,0, 1,1,1,1, 2,2,2,2;
                                ^
modules/ml/test/test_mltests.cpp:193:60: warning: Found suspicious operator ',' [constStatement]
    Mat labels = (Mat_<int>(n,1) << 0,0,0,0, 1,1,1,1, 2,2,2,2);
                                                           ^
modules/ml/test/test_save_load.cpp:164:5: style: Class 'CV_LegacyTest' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CV_LegacyTest(const std::string &_modelName, const std::string &_suffixes = std::string())
    ^
modules/ml/test/test_save_load.cpp:133:14: style: The if condition is the same as the previous if condition [duplicateCondition]
    if( code >= 0 )
             ^
modules/ml/test/test_save_load.cpp:127:14: note: First condition
    if( code >= 0 )
             ^
modules/ml/test/test_save_load.cpp:133:14: note: Second condition
    if( code >= 0 )
             ^
modules/ml/test/test_save_load.cpp:58:10: style: Redundant initialization for 'code'. The initialized value is overwritten before it is read. [redundantInitialization]
    code = prepare_test_case( testCaseIdx );
         ^
modules/ml/test/test_save_load.cpp:57:14: note: code is initialized
    int code = cvtest::TS::OK;
             ^
modules/ml/test/test_save_load.cpp:58:10: note: code is overwritten
    code = prepare_test_case( testCaseIdx );
         ^
modules/objdetect/perf/opencl/perf_hogdetect.cpp:73:1: error: syntax error [syntaxError]
OCL_PERF_TEST(HOGFixture, HOG)
^
modules/objdetect/src/cascadedetect.hpp:457:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'rect' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    rect = Rect();
    ^
modules/objdetect/src/cascadedetect.cpp:178:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'densityKernel' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        densityKernel = densKer;
        ^
modules/objdetect/src/cascadedetect.cpp:179:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'weightsV' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        weightsV = wV;
        ^
modules/objdetect/src/cascadedetect.cpp:180:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'positionsV' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        positionsV = posV;
        ^
modules/objdetect/src/cascadedetect.cpp:772:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'features' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    features = makePtr<std::vector<Feature> >();
    ^
modules/objdetect/src/cascadedetect.cpp:773:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'optfeatures' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    optfeatures = makePtr<std::vector<OptFeature> >();
    ^
modules/objdetect/src/cascadedetect.cpp:996:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'mask' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        mask = _mask;
        ^
modules/objdetect/src/cascadedetect.hpp:347:18: style: The function 'read' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool read( const FileNode& node, Size origWinSize);
                 ^
modules/objdetect/src/cascadedetect.hpp:37:18: note: Virtual function in base class
    virtual bool read(const FileNode& node, Size origWinSize);
                 ^
modules/objdetect/src/cascadedetect.hpp:347:18: note: Function in derived class
    virtual bool read( const FileNode& node, Size origWinSize);
                 ^
modules/objdetect/src/cascadedetect.hpp:348:35: style: The function 'clone' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual Ptr<FeatureEvaluator> clone() const;
                                  ^
modules/objdetect/src/cascadedetect.hpp:38:35: note: Virtual function in base class
    virtual Ptr<FeatureEvaluator> clone() const;
                                  ^
modules/objdetect/src/cascadedetect.hpp:348:35: note: Function in derived class
    virtual Ptr<FeatureEvaluator> clone() const;
                                  ^
modules/objdetect/src/cascadedetect.hpp:349:17: style: The function 'getFeatureType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getFeatureType() const { return FeatureEvaluator::HAAR; }
                ^
modules/objdetect/src/cascadedetect.hpp:39:17: note: Virtual function in base class
    virtual int getFeatureType() const;
                ^
modules/objdetect/src/cascadedetect.hpp:349:17: note: Function in derived class
    virtual int getFeatureType() const { return FeatureEvaluator::HAAR; }
                ^
modules/objdetect/src/cascadedetect.hpp:351:18: style: The function 'setWindow' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setWindow(Point p, int scaleIdx);
                 ^
modules/objdetect/src/cascadedetect.hpp:43:18: note: Virtual function in base class
    virtual bool setWindow(Point p, int scaleIdx);
                 ^
modules/objdetect/src/cascadedetect.hpp:351:18: note: Function in derived class
    virtual bool setWindow(Point p, int scaleIdx);
                 ^
modules/objdetect/src/cascadedetect.hpp:357:19: style: The function 'calcOrd' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual float calcOrd(int featureIdx) const
                  ^
modules/objdetect/src/cascadedetect.hpp:55:19: note: Virtual function in base class
    virtual float calcOrd(int featureIdx) const;
                  ^
modules/objdetect/src/cascadedetect.hpp:357:19: note: Function in derived class
    virtual float calcOrd(int featureIdx) const
                  ^
modules/objdetect/src/cascadedetect.hpp:361:18: style: The function 'computeChannels' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void computeChannels( int i, InputArray img );
                 ^
modules/objdetect/src/cascadedetect.hpp:65:18: note: Virtual function in base class
    virtual void computeChannels( int, InputArray ) {}
                 ^
modules/objdetect/src/cascadedetect.hpp:361:18: note: Function in derived class
    virtual void computeChannels( int i, InputArray img );
                 ^
modules/objdetect/src/cascadedetect.hpp:362:18: style: The function 'computeOptFeatures' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void computeOptFeatures();
                 ^
modules/objdetect/src/cascadedetect.hpp:66:18: note: Virtual function in base class
    virtual void computeOptFeatures() {}
                 ^
modules/objdetect/src/cascadedetect.hpp:362:18: note: Function in derived class
    virtual void computeOptFeatures();
                 ^
modules/objdetect/src/cascadedetect.hpp:432:18: style: The function 'read' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool read( const FileNode& node, Size origWinSize );
                 ^
modules/objdetect/src/cascadedetect.hpp:37:18: note: Virtual function in base class
    virtual bool read(const FileNode& node, Size origWinSize);
                 ^
modules/objdetect/src/cascadedetect.hpp:432:18: note: Function in derived class
    virtual bool read( const FileNode& node, Size origWinSize );
                 ^
modules/objdetect/src/cascadedetect.hpp:433:35: style: The function 'clone' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual Ptr<FeatureEvaluator> clone() const;
                                  ^
modules/objdetect/src/cascadedetect.hpp:38:35: note: Virtual function in base class
    virtual Ptr<FeatureEvaluator> clone() const;
                                  ^
modules/objdetect/src/cascadedetect.hpp:433:35: note: Function in derived class
    virtual Ptr<FeatureEvaluator> clone() const;
                                  ^
modules/objdetect/src/cascadedetect.hpp:434:17: style: The function 'getFeatureType' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getFeatureType() const { return FeatureEvaluator::LBP; }
                ^
modules/objdetect/src/cascadedetect.hpp:39:17: note: Virtual function in base class
    virtual int getFeatureType() const;
                ^
modules/objdetect/src/cascadedetect.hpp:434:17: note: Function in derived class
    virtual int getFeatureType() const { return FeatureEvaluator::LBP; }
                ^
modules/objdetect/src/cascadedetect.hpp:436:18: style: The function 'setWindow' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setWindow(Point p, int scaleIdx);
                 ^
modules/objdetect/src/cascadedetect.hpp:43:18: note: Virtual function in base class
    virtual bool setWindow(Point p, int scaleIdx);
                 ^
modules/objdetect/src/cascadedetect.hpp:436:18: note: Function in derived class
    virtual bool setWindow(Point p, int scaleIdx);
                 ^
modules/objdetect/src/cascadedetect.hpp:440:17: style: The function 'calcCat' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int calcCat(int featureIdx) const
                ^
modules/objdetect/src/cascadedetect.hpp:56:17: note: Virtual function in base class
    virtual int calcCat(int featureIdx) const;
                ^
modules/objdetect/src/cascadedetect.hpp:440:17: note: Function in derived class
    virtual int calcCat(int featureIdx) const
                ^
modules/objdetect/src/cascadedetect.hpp:443:18: style: The function 'computeChannels' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void computeChannels( int i, InputArray img );
                 ^
modules/objdetect/src/cascadedetect.hpp:65:18: note: Virtual function in base class
    virtual void computeChannels( int, InputArray ) {}
                 ^
modules/objdetect/src/cascadedetect.hpp:443:18: note: Function in derived class
    virtual void computeChannels( int i, InputArray img );
                 ^
modules/objdetect/src/cascadedetect.hpp:444:18: style: The function 'computeOptFeatures' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void computeOptFeatures();
                 ^
modules/objdetect/src/cascadedetect.hpp:66:18: note: Virtual function in base class
    virtual void computeOptFeatures() {}
                 ^
modules/objdetect/src/cascadedetect.hpp:444:18: note: Function in derived class
    virtual void computeOptFeatures();
                 ^
modules/objdetect/src/cascadedetect.hpp:491:12: style: Variable 'featureEvaluator' can be declared with const [constVariable]
    FEval& featureEvaluator = (FEval&)*_featureEvaluator;
           ^
modules/objdetect/src/cascadedetect.hpp:533:12: style: Variable 'featureEvaluator' can be declared with const [constVariable]
    FEval& featureEvaluator = (FEval&)*_featureEvaluator;
           ^
modules/objdetect/src/cascadedetect.hpp:576:12: style: Variable 'featureEvaluator' can be declared with const [constVariable]
    FEval& featureEvaluator = (FEval&)*_featureEvaluator;
           ^
modules/objdetect/src/cascadedetect.hpp:616:12: style: Variable 'featureEvaluator' can be declared with const [constVariable]
    FEval& featureEvaluator = (FEval&)*_featureEvaluator;
           ^
modules/objdetect/src/cascadedetect.cpp:320:60: style: Parameter 'scales' can be declared with const [constParameter]
                                      std::vector<double>& scales, Size winDetSize)
                                                           ^
modules/objdetect/src/detection_based_tracker.cpp:876:13: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
            it++;
            ^
modules/objdetect/src/haar.cpp:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. The tested configurations have these preprocessor errors:
'' : [modules/objdetect/src/haar.cpp:50] #error CV_HAAR_FEATURE_MAX definition changed. Adjust CV_HAAR_FEATURE_MAX_LOCAL value please.
CV_HAAR_USE_AVX : [modules/objdetect/src/haar.cpp:50] #error CV_HAAR_FEATURE_MAX definition changed. Adjust CV_HAAR_FEATURE_MAX_LOCAL value please.
CV_HAAR_USE_AVX;_MSC_VER : [modules/objdetect/src/haar.cpp:50] #error CV_HAAR_FEATURE_MAX definition changed. Adjust CV_HAAR_FEATURE_MAX_LOCAL value please.
CV_SSE2 : [modules/objdetect/src/haar.cpp:50] #error CV_HAAR_FEATURE_MAX definition changed. Adjust CV_HAAR_FEATURE_MAX_LOCAL value please.
HAVE_IPP : [modules/objdetect/src/haar.cpp:50] #error CV_HAAR_FEATURE_MAX definition changed. Adjust CV_HAAR_FEATURE_MAX_LOCAL value please.
HAVE_IPP;IPP_DISABLE_HAAR=0 : [modules/objdetect/src/haar.cpp:50] #error CV_HAAR_FEATURE_MAX definition changed. Adjust CV_HAAR_FEATURE_MAX_LOCAL value please.
HAVE_TEGRA_OPTIMIZATION : [modules/objdetect/src/haar.cpp:50] #error CV_HAAR_FEATURE_MAX definition changed. Adjust CV_HAAR_FEATURE_MAX_LOCAL value please. [noValidConfiguration]

^
modules/objdetect/src/hog.cpp:1789:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'img' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        img = _img;
        ^
modules/objdetect/src/hog.cpp:1791:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'winStride' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        winStride = _winStride;
        ^
modules/objdetect/src/hog.cpp:1792:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'padding' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        padding = _padding;
        ^
modules/objdetect/src/hog.cpp:3500:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'img' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        img = _img;
        ^
modules/objdetect/src/hog.cpp:3502:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'padding' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        padding = _padding;
        ^
modules/objdetect/src/hog.cpp:578:18: warning: Virtual function 'init' is called from constructor 'HOGCache(const HOGDescriptor*descriptor,const Mat&img,const Size&paddingTL,const Size&paddingBR,bool useCache,const Size&cacheStride)' at line 617. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void init(const HOGDescriptor* descriptor,
                 ^
modules/objdetect/src/hog.cpp:617:5: note: Calling init
    init(_descriptor, _img, _paddingTL, _paddingBR, _useCache, _cacheStride);
    ^
modules/objdetect/src/hog.cpp:578:18: note: init is a virtual function
    virtual void init(const HOGDescriptor* descriptor,
                 ^
modules/objdetect/src/hog.cpp:3705:9: error: Resource handle 'modelfl' freed twice. [doubleFree]
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3697:9: note: Resource handle 'modelfl' freed twice.
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3705:9: note: Resource handle 'modelfl' freed twice.
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3713:9: error: Resource handle 'modelfl' freed twice. [doubleFree]
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3697:9: note: Resource handle 'modelfl' freed twice.
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3713:9: note: Resource handle 'modelfl' freed twice.
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3721:9: error: Resource handle 'modelfl' freed twice. [doubleFree]
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3697:9: note: Resource handle 'modelfl' freed twice.
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3721:9: note: Resource handle 'modelfl' freed twice.
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3767:13: error: Resource handle 'modelfl' freed twice. [doubleFree]
            fclose(modelfl);
            ^
modules/objdetect/src/hog.cpp:3697:9: note: Resource handle 'modelfl' freed twice.
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3767:13: note: Resource handle 'modelfl' freed twice.
            fclose(modelfl);
            ^
modules/objdetect/src/hog.cpp:3778:9: error: Resource handle 'modelfl' freed twice. [doubleFree]
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3697:9: note: Resource handle 'modelfl' freed twice.
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3778:9: note: Resource handle 'modelfl' freed twice.
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3781:5: error: Resource handle 'modelfl' freed twice. [doubleFree]
    fclose(modelfl);
    ^
modules/objdetect/src/hog.cpp:3697:9: note: Resource handle 'modelfl' freed twice.
        fclose(modelfl);
        ^
modules/objdetect/src/hog.cpp:3781:5: note: Resource handle 'modelfl' freed twice.
    fclose(modelfl);
    ^
modules/objdetect/src/hog.cpp:881:22: style: Redundant initialization for 'cacheRow'. The initialized value is overwritten before it is read. [redundantInitialization]
            cacheRow = (uchar)0;
                     ^
modules/objdetect/src/hog.cpp:880:34: note: cacheRow is initialized
            Mat_<uchar> cacheRow = blockCacheFlags.row(cacheIdx.y);
                                 ^
modules/objdetect/src/hog.cpp:881:22: note: cacheRow is overwritten
            cacheRow = (uchar)0;
                     ^
modules/objdetect/src/hog.cpp:3730:14: style: Variable 'nread' is reassigned a value before the old one has been used. [redundantAssignment]
        nread=fread(&(poly_degree),sizeof(int),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3726:10: note: nread is assigned
    nread=fread(&(kernel_type),sizeof(int),1,modelfl);
         ^
modules/objdetect/src/hog.cpp:3730:14: note: nread is overwritten
        nread=fread(&(poly_degree),sizeof(int),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3733:14: style: Variable 'nread' is reassigned a value before the old one has been used. [redundantAssignment]
        nread=fread(&(rbf_gamma),sizeof(double), 1, modelfl);
             ^
modules/objdetect/src/hog.cpp:3730:14: note: nread is assigned
        nread=fread(&(poly_degree),sizeof(int),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3733:14: note: nread is overwritten
        nread=fread(&(rbf_gamma),sizeof(double), 1, modelfl);
             ^
modules/objdetect/src/hog.cpp:3735:14: style: Variable 'nread' is reassigned a value before the old one has been used. [redundantAssignment]
        nread=fread(&(coef_lin),sizeof(double),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3733:14: note: nread is assigned
        nread=fread(&(rbf_gamma),sizeof(double), 1, modelfl);
             ^
modules/objdetect/src/hog.cpp:3735:14: note: nread is overwritten
        nread=fread(&(coef_lin),sizeof(double),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3737:14: style: Variable 'nread' is reassigned a value before the old one has been used. [redundantAssignment]
        nread=fread(&(coef_const),sizeof(double),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3735:14: note: nread is assigned
        nread=fread(&(coef_lin),sizeof(double),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3737:14: note: nread is overwritten
        nread=fread(&(coef_const),sizeof(double),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3739:14: style: Variable 'nread' is reassigned a value before the old one has been used. [redundantAssignment]
        nread=fread(&l,sizeof(int),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3737:14: note: nread is assigned
        nread=fread(&(coef_const),sizeof(double),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3739:14: note: nread is overwritten
        nread=fread(&l,sizeof(int),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3742:14: style: Variable 'nread' is reassigned a value before the old one has been used. [redundantAssignment]
        nread=fread(custom,sizeof(char),l,modelfl);
             ^
modules/objdetect/src/hog.cpp:3739:14: note: nread is assigned
        nread=fread(&l,sizeof(int),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3742:14: note: nread is overwritten
        nread=fread(custom,sizeof(char),l,modelfl);
             ^
modules/objdetect/src/hog.cpp:3746:10: style: Variable 'nread' is reassigned a value before the old one has been used. [redundantAssignment]
    nread=fread(&(totwords),sizeof(int),1,modelfl);
         ^
modules/objdetect/src/hog.cpp:3742:14: note: nread is assigned
        nread=fread(custom,sizeof(char),l,modelfl);
             ^
modules/objdetect/src/hog.cpp:3746:10: note: nread is overwritten
    nread=fread(&(totwords),sizeof(int),1,modelfl);
         ^
modules/objdetect/src/hog.cpp:3749:14: style: Variable 'nread' is reassigned a value before the old one has been used. [redundantAssignment]
        nread=fread(&(totdoc),sizeof(int),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3746:10: note: nread is assigned
    nread=fread(&(totwords),sizeof(int),1,modelfl);
         ^
modules/objdetect/src/hog.cpp:3749:14: note: nread is overwritten
        nread=fread(&(totdoc),sizeof(int),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3751:14: style: Variable 'nread' is reassigned a value before the old one has been used. [redundantAssignment]
        nread=fread(&(sv_num), sizeof(int),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3749:14: note: nread is assigned
        nread=fread(&(totdoc),sizeof(int),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3751:14: note: nread is overwritten
        nread=fread(&(sv_num), sizeof(int),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3755:10: style: Variable 'nread' is reassigned a value before the old one has been used. [redundantAssignment]
    nread=fread(&linearbias, sizeof(double), 1, modelfl);
         ^
modules/objdetect/src/hog.cpp:3751:14: note: nread is assigned
        nread=fread(&(sv_num), sizeof(int),1,modelfl);
             ^
modules/objdetect/src/hog.cpp:3755:10: note: nread is overwritten
    nread=fread(&linearbias, sizeof(double), 1, modelfl);
         ^
modules/objdetect/src/hog.cpp:881:22: style: Variable 'cacheRow' is assigned a value that is never used. [unreadVariable]
            cacheRow = (uchar)0;
                     ^
modules/objdetect/src/hog.cpp:3755:10: style: Variable 'nread' is assigned a value that is never used. [unreadVariable]
    nread=fread(&linearbias, sizeof(double), 1, modelfl);
         ^
modules/objdetect/src/opencl/cascadedetect.cl:46:9: style: struct member 'Stage::first' is never used. [unusedStructMember]
    int first __attribute__((aligned (4)));
        ^
modules/objdetect/src/opencl/cascadedetect.cl:47:9: style: struct member 'Stage::ntrees' is never used. [unusedStructMember]
    int ntrees __attribute__((aligned (4)));
        ^
modules/objdetect/src/opencl/cascadedetect.cl:48:11: style: struct member 'Stage::threshold' is never used. [unusedStructMember]
    float threshold __attribute__((aligned (4)));
          ^
modules/objdetect/src/opencl/cascadedetect.cl:54:11: style: struct member 'ScaleData::scale' is never used. [unusedStructMember]
    float scale __attribute__((aligned (4)));
          ^
modules/objdetect/src/opencl/cascadedetect.cl:55:9: style: struct member 'ScaleData::szi_width' is never used. [unusedStructMember]
    int szi_width __attribute__((aligned (4)));
        ^
modules/objdetect/src/opencl/cascadedetect.cl:56:9: style: struct member 'ScaleData::szi_height' is never used. [unusedStructMember]
    int szi_height __attribute__((aligned (4)));
        ^
modules/objdetect/src/opencl/cascadedetect.cl:57:9: style: struct member 'ScaleData::layer_ofs' is never used. [unusedStructMember]
    int layer_ofs __attribute__((aligned (4)));
        ^
modules/objdetect/src/opencl/cascadedetect.cl:58:9: style: struct member 'ScaleData::ystep' is never used. [unusedStructMember]
    int ystep __attribute__((aligned (4)));
        ^
modules/objdetect/test/opencl/test_hogdetector.cpp:78:1: error: syntax error [syntaxError]
OCL_TEST_P(HOG, GetDescriptors)
^
modules/objdetect/test/test_cascadeandhog.cpp:96:18: warning: Member variable 'CV_DetectorTest::eps' is not initialized in the constructor. [uninitMemberVar]
CV_DetectorTest::CV_DetectorTest()
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:98:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'configFilename' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    configFilename = "dummy";
    ^
modules/objdetect/test/test_cascadeandhog.cpp:606:18: warning: Virtual function 'init' is called from constructor 'HOGCacheTester(const HOGDescriptorTester*descriptor,const Mat&img,Size paddingTL,Size paddingBR,bool useCache,Size cacheStride)' at line 644. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void init(const HOGDescriptorTester* descriptor,
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:644:5: note: Calling init
    init(_descriptor, _img, _paddingTL, _paddingBR, _useCache, _cacheStride);
    ^
modules/objdetect/test/test_cascadeandhog.cpp:606:18: note: init is a virtual function
    virtual void init(const HOGDescriptorTester* descriptor,
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:560:5: style: Class 'HOGDescriptorTester' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    HOGDescriptorTester(HOGDescriptor& instance) :
    ^
modules/objdetect/test/test_cascadeandhog.cpp:392:18: style: The function 'readDetector' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void readDetector( const FileNode& fn );
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:73:18: note: Virtual function in base class
    virtual void readDetector( const FileNode& fn ) = 0;
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:392:18: note: Function in derived class
    virtual void readDetector( const FileNode& fn );
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:393:18: style: The function 'writeDetector' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void writeDetector( FileStorage& fs, int di );
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:74:18: note: Virtual function in base class
    virtual void writeDetector( FileStorage& fs, int di ) = 0;
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:393:18: note: Function in derived class
    virtual void writeDetector( FileStorage& fs, int di );
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:394:17: style: The function 'detectMultiScale' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int detectMultiScale( int di, const Mat& img, vector<Rect>& objects );
                ^
modules/objdetect/test/test_cascadeandhog.cpp:76:17: note: Virtual function in base class
    virtual int detectMultiScale( int di, const Mat& img, vector<Rect>& objects ) = 0;
                ^
modules/objdetect/test/test_cascadeandhog.cpp:394:17: note: Function in derived class
    virtual int detectMultiScale( int di, const Mat& img, vector<Rect>& objects );
                ^
modules/objdetect/test/test_cascadeandhog.cpp:486:18: style: The function 'readDetector' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void readDetector( const FileNode& fn );
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:73:18: note: Virtual function in base class
    virtual void readDetector( const FileNode& fn ) = 0;
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:486:18: note: Function in derived class
    virtual void readDetector( const FileNode& fn );
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:487:18: style: The function 'writeDetector' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void writeDetector( FileStorage& fs, int di );
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:74:18: note: Virtual function in base class
    virtual void writeDetector( FileStorage& fs, int di ) = 0;
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:487:18: note: Function in derived class
    virtual void writeDetector( FileStorage& fs, int di );
                 ^
modules/objdetect/test/test_cascadeandhog.cpp:488:17: style: The function 'detectMultiScale' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int detectMultiScale( int di, const Mat& img, vector<Rect>& objects );
                ^
modules/objdetect/test/test_cascadeandhog.cpp:76:17: note: Virtual function in base class
    virtual int detectMultiScale( int di, const Mat& img, vector<Rect>& objects ) = 0;
                ^
modules/objdetect/test/test_cascadeandhog.cpp:488:17: note: Function in derived class
    virtual int detectMultiScale( int di, const Mat& img, vector<Rect>& objects );
                ^
modules/objdetect/test/test_cascadeandhog.cpp:843:22: style: Redundant initialization for 'cacheRow'. The initialized value is overwritten before it is read. [redundantInitialization]
            cacheRow = (uchar)0;
                     ^
modules/objdetect/test/test_cascadeandhog.cpp:842:34: note: cacheRow is initialized
            Mat_<uchar> cacheRow = blockCacheFlags.row(cacheIdx.y);
                                 ^
modules/objdetect/test/test_cascadeandhog.cpp:843:22: note: cacheRow is overwritten
            cacheRow = (uchar)0;
                     ^
modules/objdetect/test/test_cascadeandhog.cpp:247:56: style: The unsigned expression 'imageFilenames.size()' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
    if ( test_case_count <= 0 || imageFilenames.size() <= 0 )
                                                       ^
modules/objdetect/test/test_cascadeandhog.cpp:420:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    int sc = flags[di] & CASCADE_SCALE_IMAGE ? 0 : 1;
                                             ^
modules/objdetect/test/test_cascadeandhog.cpp:843:22: style: Variable 'cacheRow' is assigned a value that is never used. [unreadVariable]
            cacheRow = (uchar)0;
                     ^
modules/photo/perf/opencl/perf_denoising.cpp:32:1: error: syntax error [syntaxError]
OCL_PERF_TEST(Photo, DenoisingColored)
^
modules/photo/perf/perf_inpaint.cpp:9:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(InpaintingMethod, INPAINT_NS, INPAINT_TELEA)
^
modules/photo/src/calibrate.cpp:231:18: style: Redundant initialization for 'response'. The initialized value is overwritten before it is read. [redundantInitialization]
        response = linearResponse(3) / (LDR_SIZE / 2.0f);
                 ^
modules/photo/src/calibrate.cpp:230:22: note: response is initialized
        Mat response = dst.getMat();
                     ^
modules/photo/src/calibrate.cpp:231:18: note: response is overwritten
        response = linearResponse(3) / (LDR_SIZE / 2.0f);
                 ^
modules/photo/src/contrast_preserve.hpp:51:1: style: The class 'Decolor' does not have a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class Decolor
^
modules/photo/src/contrast_preserve.hpp:361:7: style: Redundant initialization for 'A'. The initialized value is overwritten before it is read. [redundantInitialization]
    A = P*P_trans;
      ^
modules/photo/src/contrast_preserve.hpp:347:11: note: A is initialized
    Mat A = Mat(size, size, CV_32FC1);
          ^
modules/photo/src/contrast_preserve.hpp:361:7: note: A is overwritten
    A = P*P_trans;
      ^
modules/photo/src/contrast_preserve.hpp:90:12: style: The scope of the variable 'val' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double val = 0.0;
           ^
modules/photo/src/contrast_preserve.hpp:126:12: style: The scope of the variable 'dp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double dp;
           ^
modules/photo/src/contrast_preserve.hpp:199:12: style: The scope of the variable 'res' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double res =0.0;
           ^
modules/photo/src/contrast_preserve.hpp:232:12: style: The scope of the variable 'sizefactor' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double sizefactor;
           ^
modules/photo/src/contrast_preserve.hpp:308:12: style: The scope of the variable 'sizefactor' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double sizefactor;
           ^
modules/photo/src/contrast_preserve.cpp:112:16: style: The scope of the variable 'val' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double val = 0.0;
               ^
modules/photo/src/contrast_preserve.cpp:122:16: style: The scope of the variable 'pos' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double pos = 0.0;
               ^
modules/photo/src/contrast_preserve.cpp:123:16: style: The scope of the variable 'neg' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double neg = 0.0;
               ^
modules/photo/src/contrast_preserve.cpp:151:16: style: The scope of the variable 'val1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double val1 = 0.0;
               ^
modules/photo/src/contrast_preserve.hpp:84:46: style: Parameter 'Cg' can be declared with const [constParameter]
double Decolor::energyCalcu(vector <double> &Cg, vector < vector <double> > &polyGrad, vector <double> &wei)
                                             ^
modules/photo/src/contrast_preserve.hpp:84:105: style: Parameter 'wei' can be declared with const [constParameter]
double Decolor::energyCalcu(vector <double> &Cg, vector < vector <double> > &polyGrad, vector <double> &wei)
                                                                                                        ^
modules/photo/src/contrast_preserve.hpp:123:80: style: Parameter 'initRGB' can be declared with const [constParameter]
vector<double> Decolor::product(vector < vector<int> > &comb, vector <double> &initRGB)
                                                                               ^
modules/photo/src/contrast_preserve.hpp:393:47: style: Parameter 'wei' can be declared with const [constParameter]
void Decolor::grayImContruct(vector <double> &wei, Mat img, Mat &Gray)
                                              ^
modules/photo/src/contrast_preserve.hpp:90:16: style: Variable 'val' is assigned a value that is never used. [unreadVariable]
    double val = 0.0;
               ^
modules/photo/src/contrast_preserve.hpp:199:16: style: Variable 'res' is assigned a value that is never used. [unreadVariable]
    double res =0.0;
               ^
modules/photo/src/contrast_preserve.hpp:239:15: style: Variable 'curIm' is assigned a value that is never used. [unreadVariable]
    Mat curIm = Mat(img.size(),CV_32FC1);
              ^
modules/photo/src/contrast_preserve.hpp:295:9: style: Variable 'sum' is assigned a value that is never used. [unreadVariable]
    sum = (double)100*sum/alf.size();
        ^
modules/photo/src/contrast_preserve.cpp:190:15: style: Variable 'color' is assigned a value that is never used. [unreadVariable]
    Mat color = Mat(img.size(),CV_8UC3);
              ^
modules/photo/src/denoise_tvl1.cpp:51:13: style: Class 'AddFloatToCharScaled' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
            AddFloatToCharScaled(double scale):_scale(scale){}
            ^
modules/photo/src/denoise_tvl1.cpp:93:24: style: The scope of the variable 'dx' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                double dx, dy, m;
                       ^
modules/photo/src/denoise_tvl1.cpp:67:17: style: Variable 's' is assigned a value that is never used. [unreadVariable]
        double s=0;
                ^
modules/photo/src/denoising.cuda.cpp:101:5: warning: Either the condition 'func!=0' is redundant or there is possible null pointer dereference: func. [nullPointerRedundantCheck]
    func(src, dst, search_window/2, block_window/2, h, borderMode, StreamAccessor::getStream(stream));
    ^
modules/photo/src/denoising.cuda.cpp:93:20: note: Assuming that condition 'func!=0' is not redundant
    CV_Assert(func != 0);
                   ^
modules/photo/src/denoising.cuda.cpp:92:30: note: Assignment 'func=funcs[src.channels()-1]', assigned value is 0
    const func_t func = funcs[src.channels() - 1];
                             ^
modules/photo/src/denoising.cuda.cpp:101:5: note: Null pointer dereference
    func(src, dst, search_window/2, block_window/2, h, borderMode, StreamAccessor::getStream(stream));
    ^
modules/photo/src/inpaint.cpp:519:47: style: The scope of the variable 'color' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
   int i = 0, j = 0, ii = 0, jj = 0, k, l, q, color = 0;
                                              ^
modules/photo/src/merge.cpp:93:16: style: Redundant initialization for 'result'. The initialized value is overwritten before it is read. [redundantInitialization]
        result = Mat::zeros(size, CV_32FCC);
               ^
modules/photo/src/merge.cpp:76:20: note: result is initialized
        Mat result = dst.getMat();
                   ^
modules/photo/src/merge.cpp:93:16: note: result is overwritten
        result = Mat::zeros(size, CV_32FCC);
               ^
modules/photo/src/merge.cpp:337:16: style: Redundant initialization for 'result'. The initialized value is overwritten before it is read. [redundantInitialization]
        result = Mat::zeros(images[0].size(), CV_32FCC);
               ^
modules/photo/src/merge.cpp:327:20: note: result is initialized
        Mat result = dst.getMat();
                   ^
modules/photo/src/merge.cpp:337:16: note: result is overwritten
        result = Mat::zeros(images[0].size(), CV_32FCC);
               ^
modules/photo/src/merge.cpp:347:16: style: Variable 'result' is assigned a value that is never used. [unreadVariable]
        result = result.mul(1 / wsum);
               ^
modules/photo/src/npr.hpp:223:15: style: Redundant initialization for 'lower_pos'. The initialized value is overwritten before it is read. [redundantInitialization]
    lower_pos = hz - radius;
              ^
modules/photo/src/npr.hpp:220:19: note: lower_pos is initialized
    Mat lower_pos = Mat(h,w,CV_32FC1);
                  ^
modules/photo/src/npr.hpp:223:15: note: lower_pos is overwritten
    lower_pos = hz - radius;
              ^
modules/photo/src/npr.hpp:224:15: style: Redundant initialization for 'upper_pos'. The initialized value is overwritten before it is read. [redundantInitialization]
    upper_pos = hz + radius;
              ^
modules/photo/src/npr.hpp:221:19: note: upper_pos is initialized
    Mat upper_pos = Mat(h,w,CV_32FC1);
                  ^
modules/photo/src/npr.hpp:224:15: note: upper_pos is overwritten
    upper_pos = hz + radius;
              ^
modules/photo/src/npr.cpp:111:12: style: Redundant initialization for 'detail'. The initialized value is overwritten before it is read. [redundantInitialization]
    detail = L - res;
           ^
modules/photo/src/npr.cpp:109:16: note: detail is initialized
    Mat detail = Mat(h,w,CV_32FC1);
               ^
modules/photo/src/npr.cpp:111:12: note: detail is overwritten
    detail = L - res;
           ^
modules/photo/src/npr.hpp:512:15: style: The scope of the variable 'radius' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        float radius;
              ^
modules/photo/src/npr.hpp:559:11: style: The scope of the variable 'radius' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float radius;
          ^
modules/photo/src/npr.hpp:216:44: style: Parameter 'output' can be declared with const [constParameter]
void Domain_Filter::compute_boxfilter(Mat &output, Mat &hz, Mat &psketch, float radius)
                                           ^
modules/photo/src/npr.hpp:336:11: style: Variable 'a' is assigned a value that is never used. [unreadVariable]
    Mat a = Mat::zeros(h,w,CV_32FC1);
          ^
modules/photo/src/npr.hpp:337:11: style: Variable 'b' is assigned a value that is never used. [unreadVariable]
    Mat b = Mat::zeros(h,w,CV_32FC1);
          ^
modules/photo/src/npr.hpp:437:15: style: Variable 'final' is assigned a value that is never used. [unreadVariable]
    Mat final = Mat(h,w,CV_32FC3);
              ^
modules/photo/src/npr.hpp:483:19: style: Variable 'sigma_h' is assigned a value that is never used. [unreadVariable]
    float sigma_h = sigma_s;
                  ^
modules/photo/src/npr.hpp:550:19: style: Variable 'sigma_h' is assigned a value that is never used. [unreadVariable]
    float sigma_h = sigma_s;
                  ^
modules/photo/src/opencl/nlmeans.cl:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/photo/src/seamless_cloning_impl.cpp:213:16: style: Redundant initialization for 'resLinePtr'. The initialized value is overwritten before it is read. [redundantInitialization]
    resLinePtr = result.ptr<unsigned char>(h-1);
               ^
modules/photo/src/seamless_cloning_impl.cpp:178:33: note: resLinePtr is initialized
    unsigned char *  resLinePtr = result.ptr<unsigned char>(0);
                                ^
modules/photo/src/seamless_cloning_impl.cpp:213:16: note: resLinePtr is overwritten
    resLinePtr = result.ptr<unsigned char>(h-1);
               ^
modules/photo/src/seamless_cloning_impl.cpp:214:16: style: Redundant initialization for 'imgLinePtr'. The initialized value is overwritten before it is read. [redundantInitialization]
    imgLinePtr = img.ptr<unsigned char>(h-1);
               ^
modules/photo/src/seamless_cloning_impl.cpp:179:38: note: imgLinePtr is initialized
    const unsigned char * imgLinePtr = img.ptr<unsigned char>(0);
                                     ^
modules/photo/src/seamless_cloning_impl.cpp:214:16: note: imgLinePtr is overwritten
    imgLinePtr = img.ptr<unsigned char>(h-1);
               ^
modules/photo/src/seamless_cloning_impl.cpp:226:9: style: Redundant initialization for 'lap'. The initialized value is overwritten before it is read. [redundantInitialization]
    lap = laplacianX + laplacianY;
        ^
modules/photo/src/seamless_cloning_impl.cpp:224:13: note: lap is initialized
    Mat lap = Mat(img.size(),CV_32FC1);
            ^
modules/photo/src/seamless_cloning_impl.cpp:226:9: note: lap is overwritten
    lap = laplacianX + laplacianY;
        ^
modules/photo/src/seamless_cloning_impl.cpp:309:16: style: Redundant initialization for 'laplacianX'. The initialized value is overwritten before it is read. [redundantInitialization]
    laplacianX = destinationGradientX + patchGradientX;
               ^
modules/photo/src/seamless_cloning_impl.cpp:306:20: note: laplacianX is initialized
    Mat laplacianX = Mat(destination.size(),CV_32FC3);
                   ^
modules/photo/src/seamless_cloning_impl.cpp:309:16: note: laplacianX is overwritten
    laplacianX = destinationGradientX + patchGradientX;
               ^
modules/photo/src/seamless_cloning_impl.cpp:310:16: style: Redundant initialization for 'laplacianY'. The initialized value is overwritten before it is read. [redundantInitialization]
    laplacianY = destinationGradientY + patchGradientY;
               ^
modules/photo/src/seamless_cloning_impl.cpp:307:20: note: laplacianY is initialized
    Mat laplacianY = Mat(destination.size(),CV_32FC3);
                   ^
modules/photo/src/seamless_cloning_impl.cpp:310:16: note: laplacianY is overwritten
    laplacianY = destinationGradientY + patchGradientY;
               ^
modules/photo/src/seamless_cloning_impl.cpp:219:50: style: Parameter 'laplacianX' can be declared with const [constParameter]
void Cloning::poissonSolver(const Mat &img, Mat &laplacianX , Mat &laplacianY, Mat &result)
                                                 ^
modules/photo/src/seamless_cloning_impl.cpp:219:68: style: Parameter 'laplacianY' can be declared with const [constParameter]
void Cloning::poissonSolver(const Mat &img, Mat &laplacianX , Mat &laplacianY, Mat &result)
                                                                   ^
modules/photo/src/seamless_cloning_impl.cpp:340:97: style: Parameter 'cloned' can be declared with const [constParameter]
void Cloning::normalClone(const Mat &destination, const Mat &patch, const Mat &binaryMask, Mat &cloned, int flag)
                                                                                                ^
modules/photo/src/seamless_cloning_impl.cpp:421:47: style: Parameter 'mask' can be declared with const [constParameter]
void Cloning::illuminationChange(Mat &I, Mat &mask, Mat &wmask, Mat &cloned, float alpha, float beta)
                                              ^
modules/photo/src/seamless_cloning_impl.cpp:421:58: style: Parameter 'wmask' can be declared with const [constParameter]
void Cloning::illuminationChange(Mat &I, Mat &mask, Mat &wmask, Mat &cloned, float alpha, float beta)
                                                         ^
modules/photo/src/seamless_cloning_impl.cpp:421:70: style: Parameter 'cloned' can be declared with const [constParameter]
void Cloning::illuminationChange(Mat &I, Mat &mask, Mat &wmask, Mat &cloned, float alpha, float beta)
                                                                     ^
modules/photo/src/seamless_cloning_impl.cpp:453:35: style: Parameter 'I' can be declared with const [constParameter]
void Cloning::textureFlatten(Mat &I, Mat &mask, Mat &wmask, float low_threshold,
                                  ^
modules/photo/src/seamless_cloning_impl.cpp:453:54: style: Parameter 'wmask' can be declared with const [constParameter]
void Cloning::textureFlatten(Mat &I, Mat &mask, Mat &wmask, float low_threshold,
                                                     ^
modules/photo/src/seamless_cloning_impl.cpp:454:53: style: Parameter 'cloned' can be declared with const [constParameter]
        float high_threshold, int kernel_size, Mat &cloned)
                                                    ^
modules/photo/src/tonemap.cpp:59:5: style: Class 'TonemapImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    TonemapImpl(float _gamma) : name("Tonemap"), gamma(_gamma)
    ^
modules/photo/src/tonemap.cpp:526:71: style: Parameter 'y_contrast' can be declared with const [constParameter]
    void calculateSum(std::vector<Mat>& x_contrast, std::vector<Mat>& y_contrast, Mat& sum)
                                                                      ^
modules/photo/test/ocl/test_denoising.cpp:79:1: error: syntax error [syntaxError]
OCL_TEST_P(FastNlMeansDenoising, Mat)
^
modules/photo/test/test_denoise_tvl1.cpp:53:10: style: Redundant initialization for 'half'. The initialized value is overwritten before it is read. [redundantInitialization]
    half = cv::Scalar::all(1);
         ^
modules/photo/test/test_denoise_tvl1.cpp:52:18: note: half is initialized
    cv::Mat half = mask.colRange(0, img.cols/2);
                 ^
modules/photo/test/test_denoise_tvl1.cpp:53:10: note: half is overwritten
    half = cv::Scalar::all(1);
         ^
modules/photo/test/test_denoise_tvl1.cpp:53:10: style: Variable 'half' is assigned a value that is never used. [unreadVariable]
    half = cv::Scalar::all(1);
         ^
modules/shape/src/aff_trans.cpp:55:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'name_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        name_ = "ShapeTransformer.AFF";
        ^
modules/shape/src/aff_trans.cpp:62:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'name_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        name_ = "ShapeTransformer.AFF";
        ^
modules/shape/src/aff_trans.cpp:59:5: style: Class 'AffineTransformerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    AffineTransformerImpl(bool _fullAffine)
    ^
modules/shape/src/emdL1.cpp:548:9: style: The scope of the variable 'iC' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int iC, iMinC = 0;
        ^
modules/shape/src/emdL1.cpp:549:16: style: The scope of the variable 'pE' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    cvPEmdEdge pE;
               ^
modules/shape/src/emdL1.cpp:282:18: style: Variable 'bUpward' is assigned a value that is never used. [unreadVariable]
    bool bUpward = false;
                 ^
modules/shape/src/haus_dis.cpp:55:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'name_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        name_ = "ShapeDistanceExtractor.HAU";
        ^
modules/shape/src/hist_cost.cpp:57:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'name_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        name_ = "HistogramCostExtractor.NOR";
        ^
modules/shape/src/hist_cost.cpp:185:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'name_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        name_ = "HistogramCostExtractor.EMD";
        ^
modules/shape/src/hist_cost.cpp:322:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'name_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        name_ = "HistogramCostExtractor.CHI";
        ^
modules/shape/src/hist_cost.cpp:441:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'name_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        name_ = "HistogramCostExtractor.CHI";
        ^
modules/shape/src/sc_dis.cpp:67:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'comparer' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        comparer=_comparer;
        ^
modules/shape/src/sc_dis.cpp:69:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'transformer' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        transformer=_transformer;
        ^
modules/shape/src/sc_dis.cpp:74:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'name_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        name_ = "ShapeDistanceExtractor.SCD";
        ^
modules/shape/src/sc_dis.cpp:228:11: style: The scope of the variable 'beta' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float beta;
          ^
modules/shape/src/sc_dis.cpp:236:13: style: The scope of the variable 'jj' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int ii, jj, pt;
            ^
modules/shape/src/sc_dis.cpp:236:17: style: The scope of the variable 'pt' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int ii, jj, pt;
                ^
modules/shape/src/sc_dis.cpp:518:10: style: The scope of the variable 'unassignedfound' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool unassignedfound;
         ^
modules/shape/src/sc_dis.cpp:519:15: style: The scope of the variable 'imin' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int  i=0, imin=0, numfree=0, prvnumfree=0, f=0, i0=0, k=0, freerow=0;
              ^
modules/shape/src/sc_dis.cpp:519:34: style: The scope of the variable 'prvnumfree' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int  i=0, imin=0, numfree=0, prvnumfree=0, f=0, i0=0, k=0, freerow=0;
                                 ^
modules/shape/src/sc_dis.cpp:519:64: style: The scope of the variable 'freerow' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int  i=0, imin=0, numfree=0, prvnumfree=0, f=0, i0=0, k=0, freerow=0;
                                                               ^
modules/shape/src/sc_dis.cpp:520:48: style: The scope of the variable 'low' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int  j=0, j1=0, j2=0, endofpath=0, last=0, low=0, up=0;
                                               ^
modules/shape/src/sc_dis.cpp:520:55: style: The scope of the variable 'up' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int  j=0, j1=0, j2=0, endofpath=0, last=0, low=0, up=0;
                                                      ^
modules/shape/src/sc_dis.cpp:333:31: style: Parameter 'contour' can be declared with const [constParameter]
void SCD::extractSCD(cv::Mat &contour, cv::Mat &descriptors, const std::vector<int> &queryInliers, const float _meanDistance)
                              ^
modules/shape/src/sc_dis.cpp:411:50: style: Parameter 'contour' can be declared with const [constParameter]
void SCD::buildNormalizedDistanceMatrix(cv::Mat &contour, cv::Mat &disMatrix, const std::vector<int> &queryInliers, const float _meanDistance)
                                                 ^
modules/shape/src/sc_dis.cpp:446:37: style: Parameter 'contour' can be declared with const [constParameter]
void SCD::buildAngleMatrix(cv::Mat &contour, cv::Mat &angleMatrix) const
                                    ^
modules/shape/src/sc_dis.cpp:489:44: style: Parameter 'descriptors1' can be declared with const [constParameter]
void SCDMatcher::matchDescriptors(cv::Mat &descriptors1, cv::Mat &descriptors2, std::vector<cv::DMatch> &matches,
                                           ^
modules/shape/src/sc_dis.cpp:489:67: style: Parameter 'descriptors2' can be declared with const [constParameter]
void SCDMatcher::matchDescriptors(cv::Mat &descriptors1, cv::Mat &descriptors2, std::vector<cv::DMatch> &matches,
                                                                  ^
modules/shape/src/sc_dis.cpp:519:19: style: Variable 'imin' is assigned a value that is never used. [unreadVariable]
    int  i=0, imin=0, numfree=0, prvnumfree=0, f=0, i0=0, k=0, freerow=0;
                  ^
modules/shape/src/sc_dis.cpp:519:44: style: Variable 'prvnumfree' is assigned a value that is never used. [unreadVariable]
    int  i=0, imin=0, numfree=0, prvnumfree=0, f=0, i0=0, k=0, freerow=0;
                                           ^
modules/shape/src/sc_dis.cpp:519:55: style: Variable 'i0' is assigned a value that is never used. [unreadVariable]
    int  i=0, imin=0, numfree=0, prvnumfree=0, f=0, i0=0, k=0, freerow=0;
                                                      ^
modules/shape/src/sc_dis.cpp:519:60: style: Variable 'k' is assigned a value that is never used. [unreadVariable]
    int  i=0, imin=0, numfree=0, prvnumfree=0, f=0, i0=0, k=0, freerow=0;
                                                           ^
modules/shape/src/sc_dis.cpp:519:71: style: Variable 'freerow' is assigned a value that is never used. [unreadVariable]
    int  i=0, imin=0, numfree=0, prvnumfree=0, f=0, i0=0, k=0, freerow=0;
                                                                      ^
modules/shape/src/sc_dis.cpp:520:17: style: Variable 'j1' is assigned a value that is never used. [unreadVariable]
    int  j=0, j1=0, j2=0, endofpath=0, last=0, low=0, up=0;
                ^
modules/shape/src/sc_dis.cpp:520:51: style: Variable 'low' is assigned a value that is never used. [unreadVariable]
    int  j=0, j1=0, j2=0, endofpath=0, last=0, low=0, up=0;
                                                  ^
modules/shape/src/sc_dis.cpp:520:57: style: Variable 'up' is assigned a value that is never used. [unreadVariable]
    int  j=0, j1=0, j2=0, endofpath=0, last=0, low=0, up=0;
                                                        ^
modules/shape/src/sc_dis.cpp:521:19: style: Variable 'h' is assigned a value that is never used. [unreadVariable]
    float min=0, h=0, umin=0, usubmin=0, v2=0;
                  ^
modules/shape/src/sc_dis.cpp:521:27: style: Variable 'umin' is assigned a value that is never used. [unreadVariable]
    float min=0, h=0, umin=0, usubmin=0, v2=0;
                          ^
modules/shape/src/sc_dis.cpp:521:38: style: Variable 'usubmin' is assigned a value that is never used. [unreadVariable]
    float min=0, h=0, umin=0, usubmin=0, v2=0;
                                     ^
modules/shape/src/sc_dis.cpp:521:44: style: Variable 'v2' is assigned a value that is never used. [unreadVariable]
    float min=0, h=0, umin=0, usubmin=0, v2=0;
                                           ^
modules/shape/src/tps_trans.cpp:55:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'name_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        name_ = "ShapeTransformer.TPS";
        ^
modules/shape/src/tps_trans.cpp:63:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'name_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        name_ = "ShapeTransformer.TPS";
        ^
modules/shape/src/tps_trans.cpp:60:5: style: Class 'ThinPlateSplineShapeTransformerImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ThinPlateSplineShapeTransformerImpl(double _regularizationParameter)
    ^
modules/shape/test/test_shape.cpp:216:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'mysc' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        mysc = createShapeContextDistanceExtractor(angularBins, radialBins, minRad, maxRad);
        ^
modules/shape/test/test_shape.cpp:253:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'mysc' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        mysc = createShapeContextDistanceExtractor(angularBins, radialBins, minRad, maxRad);
        ^
modules/shape/test/test_shape.cpp:286:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'haus' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        haus = createHausdorffDistanceExtractor();
        ^
modules/stitching/perf/opencl/perf_stitch.cpp:32:1: error: syntax error [syntaxError]
OCL_PERF_TEST_P(stitch, a123, TEST_DETECTORS)
^
modules/stitching/perf/opencl/perf_warpers.cpp:104:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(WarperType, SphericalWarperType, CylindricalWarperType, PlaneWarperType, AffineWarperType)
^
modules/imgproc/src/gcgraph.hpp:85:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'flow' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    flow = 0;
    ^
modules/stitching/src/blenders.cpp:756:77: style: Parameter 'pyr' can be declared with const [constParameter]
void createLaplacePyrGpu(InputArray img, int num_levels, std::vector<UMat> &pyr)
                                                                            ^
modules/stitching/src/blenders.cpp:797:55: style: Parameter 'pyr' can be declared with const [constParameter]
void restoreImageFromLaplacePyrGpu(std::vector<UMat> &pyr)
                                                      ^
modules/stitching/src/matchers.cpp:158:5: style: Class 'CpuMatcher' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CpuMatcher(float match_conf) : FeaturesMatcher(true), match_conf_(match_conf) {}
    ^
modules/stitching/src/matchers.cpp:169:5: style: Class 'GpuMatcher' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    GpuMatcher(float match_conf) : match_conf_(match_conf) {}
    ^
modules/stitching/src/motion_estimators.cpp:54:5: style: Struct 'IncDistance' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    IncDistance(std::vector<int> &vdists) : dists(&vdists[0]) {}
    ^
modules/stitching/src/motion_estimators.cpp:285:13: style: Condition '_err' is always true [knownConditionTrueFalse]
        if (_err)
            ^
modules/stitching/src/motion_estimators.cpp:275:25: note: Assuming that condition '!_err' is not redundant
        if (!proceed || !_err)
                        ^
modules/stitching/src/motion_estimators.cpp:285:13: note: Condition '_err' is always true
        if (_err)
            ^
modules/stitching/src/stitcher.cpp:258:32: style: Variable 'compose_work_aspect' is assigned a value that is never used. [unreadVariable]
    double compose_work_aspect = 1;
                               ^
modules/stitching/src/util.cpp:63:9: style: The scope of the variable 'next' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int next;
        ^
modules/stitching/test/ocl/test_warpers.cpp:85:1: error: syntax error [syntaxError]
OCL_TEST_F(SphericalWarperTest, Mat)
^
modules/superres/src/btv_l1.cpp:475:9: error: There is an unknown macro here somewhere. Configuration is required. If CV_IMPL_PROPERTY is a macro then please configure it. [unknownMacro]
        CV_IMPL_PROPERTY(int, Scale, scale_)
        ^
modules/superres/src/btv_l1_cuda.cpp:221:9: error: There is an unknown macro here somewhere. Configuration is required. If CV_IMPL_PROPERTY is a macro then please configure it. [unknownMacro]
        CV_IMPL_PROPERTY(int, Scale, scale_)
        ^
modules/superres/src/frame_source.cpp:211:9: style: Class 'VideoFrameSource_CUDA' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        VideoFrameSource_CUDA(const String& fileName);
        ^
modules/superres/src/frame_source.cpp:136:9: style: Class 'VideoFrameSource' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        VideoFrameSource(const String& fileName);
        ^
modules/superres/src/frame_source.cpp:159:9: style: Class 'CameraFrameSource' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        CameraFrameSource(int deviceId);
        ^
modules/superres/src/input_array_utility.cpp:162:5: warning: Either the condition 'func!=0' is redundant or there is possible null pointer dereference: func. [nullPointerRedundantCheck]
    func(src, dst);
    ^
modules/superres/src/input_array_utility.cpp:160:21: note: Assuming that condition 'func!=0' is not redundant
    CV_Assert( func != 0 );
                    ^
modules/superres/src/input_array_utility.cpp:159:40: note: Assignment 'func=funcs[src_kind][dst_kind]', assigned value is 0
    const func_t func = funcs[src_kind][dst_kind];
                                       ^
modules/superres/src/input_array_utility.cpp:162:5: note: Null pointer dereference
    func(src, dst);
    ^
modules/superres/src/input_array_utility.cpp:237:64: style: Parameter 'buf0' can be declared with const [constParameter]
Mat cv::superres::convertToType(const Mat& src, int type, Mat& buf0, Mat& buf1)
                                                               ^
modules/superres/src/input_array_utility.cpp:237:75: style: Parameter 'buf1' can be declared with const [constParameter]
Mat cv::superres::convertToType(const Mat& src, int type, Mat& buf0, Mat& buf1)
                                                                          ^
modules/superres/src/input_array_utility.cpp:264:67: style: Parameter 'buf0' can be declared with const [constParameter]
UMat cv::superres::convertToType(const UMat& src, int type, UMat& buf0, UMat& buf1)
                                                                  ^
modules/superres/src/input_array_utility.cpp:264:79: style: Parameter 'buf1' can be declared with const [constParameter]
UMat cv::superres::convertToType(const UMat& src, int type, UMat& buf0, UMat& buf1)
                                                                              ^
modules/superres/src/optical_flow.cpp:189:9: error: There is an unknown macro here somewhere. Configuration is required. If CV_IMPL_PROPERTY is a macro then please configure it. [unknownMacro]
        CV_IMPL_PROPERTY(double, PyrScale, pyrScale_)
        ^
modules/ts/src/ts.cpp:286:23: style: The scope of the variable 'code' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int progress = 0, code;
                      ^
modules/ts/src/ts.cpp:817:0: information: Skipping configuration 'OPENCV_INSTALL_PREFIX;OPENCV_TEST_DATA_INSTALL_PATH' since the value of 'OPENCV_INSTALL_PREFIX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        datapath = path_join(OPENCV_INSTALL_PREFIX, OPENCV_TEST_DATA_INSTALL_PATH);
^
modules/ts/src/ts.cpp:804:0: information: Skipping configuration 'OPENCV_INSTALL_PREFIX;OPENCV_TEST_DATA_INSTALL_PATH' since the value of 'OPENCV_TEST_DATA_INSTALL_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    datapath = path_join("./", OPENCV_TEST_DATA_INSTALL_PATH);
^
modules/ts/src/ts.cpp:817:0: information: Skipping configuration 'OPENCV_INSTALL_PREFIX;OPENCV_TEST_DATA_INSTALL_PATH' since the value of 'OPENCV_TEST_DATA_INSTALL_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        datapath = path_join(OPENCV_INSTALL_PREFIX, OPENCV_TEST_DATA_INSTALL_PATH);
^
modules/ts/src/ts.cpp:804:0: information: Skipping configuration 'OPENCV_TEST_DATA_INSTALL_PATH' since the value of 'OPENCV_TEST_DATA_INSTALL_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    datapath = path_join("./", OPENCV_TEST_DATA_INSTALL_PATH);
^
modules/ts/src/ts_arrtest.cpp:142:19: style: Variable 'is_image' is assigned a value that is never used. [unreadVariable]
    bool is_image = false;
                  ^
modules/ts/src/ts_func.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/ts/src/ts_func.cpp:897:15: style: The scope of the variable 'k' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i, j, k, esz = (int)src.elemSize();
              ^
modules/ts/src/ts_func.cpp:2251:9: style: The scope of the variable 'c_rows' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c_rows = 0, c_cols = 0, c_step = 0, c_delta = 0;
        ^
modules/ts/src/ts_func.cpp:2251:21: style: The scope of the variable 'c_cols' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c_rows = 0, c_cols = 0, c_step = 0, c_delta = 0;
                    ^
modules/ts/src/ts_func.cpp:2042:24: style: Local variable 'threshold' shadows outer function [shadowFunction]
                double threshold;
                       ^
modules/ts/src/ts_func.cpp:3122:6: note: Shadowed declaration
void threshold( const Mat& _src, Mat& _dst,
     ^
modules/ts/src/ts_func.cpp:2042:24: note: Shadow variable
                double threshold;
                       ^
modules/ts/src/ts_func.cpp:2073:24: style: Local variable 'threshold' shadows outer function [shadowFunction]
                double threshold;
                       ^
modules/ts/src/ts_func.cpp:3122:6: note: Shadowed declaration
void threshold( const Mat& _src, Mat& _dst,
     ^
modules/ts/src/ts_func.cpp:2073:24: note: Shadow variable
                double threshold;
                       ^
modules/ts/src/ts_func.cpp:802:37: style: Parameter 'dst' can be declared with const [constParameter]
void filter2D(const Mat& _src, Mat& dst, int ddepth, const Mat& kernel,
                                    ^
modules/ts/src/ts_func.cpp:2251:16: style: Variable 'c_rows' is assigned a value that is never used. [unreadVariable]
    int c_rows = 0, c_cols = 0, c_step = 0, c_delta = 0;
               ^
modules/ts/src/ts_func.cpp:2251:28: style: Variable 'c_cols' is assigned a value that is never used. [unreadVariable]
    int c_rows = 0, c_cols = 0, c_step = 0, c_delta = 0;
                           ^
modules/ts/src/ts_gtest.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/ts/src/ts_gtest.cpp:9516:1: error: There is an unknown macro here somewhere. Configuration is required. If GTEST_DISABLE_MSC_WARNINGS_PUSH_ is a macro then please configure it. [unknownMacro]
GTEST_DISABLE_MSC_WARNINGS_PUSH_(4996)
^
modules/ts/src/ts_gtest.cpp:1855:0: information: Skipping configuration 'GTEST_CUSTOM_GET_ARGVS_' since the value of 'GTEST_CUSTOM_GET_ARGVS_' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  return GTEST_CUSTOM_GET_ARGVS_();
^
modules/ts/src/ts_gtest.cpp:6858:0: information: Skipping configuration 'GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_' since the value of 'GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);
^
modules/ts/src/ts_gtest.cpp:6868:0: information: Skipping configuration 'GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_' since the value of 'GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);
^
modules/ts/src/ts_gtest.cpp:5916:0: information: Skipping configuration 'GTEST_CUSTOM_TEST_EVENT_LISTENER_' since the value of 'GTEST_CUSTOM_TEST_EVENT_LISTENER_' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    listeners()->Append(new GTEST_CUSTOM_TEST_EVENT_LISTENER_());
^
modules/ts/src/ts_gtest.cpp:6054:0: information: Skipping configuration 'GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_;GTEST_HAS_DEATH_TEST' since the value of 'GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_();
^
modules/ts/src/ts_gtest.cpp:7759:0: information: Skipping configuration 'GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_;GTEST_HAS_DEATH_TEST' since the value of 'GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_();
^
modules/ts/src/ts_gtest.cpp:9781:0: information: Skipping configuration 'GTEST_GET_BOOL_FROM_ENV_' since the value of 'GTEST_GET_BOOL_FROM_ENV_' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  return GTEST_GET_BOOL_FROM_ENV_(flag, default_value);
^
modules/ts/src/ts_gtest.cpp:9794:0: information: Skipping configuration 'GTEST_GET_INT32_FROM_ENV_' since the value of 'GTEST_GET_INT32_FROM_ENV_' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  return GTEST_GET_INT32_FROM_ENV_(flag, default_value);
^
modules/ts/src/ts_gtest.cpp:9819:0: information: Skipping configuration 'GTEST_GET_STRING_FROM_ENV_' since the value of 'GTEST_GET_STRING_FROM_ENV_' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  return GTEST_GET_STRING_FROM_ENV_(flag, default_value);
^
modules/ts/src/ts_perf.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/ts/src/ts_perf.cpp:2148:5: style: Struct 'KeypointComparator' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    KeypointComparator(std::vector<cv::KeyPoint>& pts) : pts_(pts), cmp() {}
    ^
modules/ts/src/ts_perf.cpp:204:17: style: The scope of the variable 'path_separator' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char *path_separator = "/";
                ^
modules/ts/src/ts_perf.cpp:1663:13: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
            ? (double)times[offset + n / 2]
            ^
modules/video/perf/opencl/perf_bgfg_mog2.cpp:42:1: error: syntax error [syntaxError]
OCL_PERF_TEST_P(MOG2_Apply, Mog2, Combine(Values("gpu/video/768x576.avi", "gpu/video/1920x1080.avi"), Values(1,3)))
^
modules/video/perf/opencl/perf_optflow_farneback.cpp:58:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(farneFlagType, 0, OPTFLOW_FARNEBACK_GAUSSIAN)
^
modules/video/perf/perf_ecc.cpp:9:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(MotionType, MOTION_TRANSLATION, MOTION_EUCLIDEAN, MOTION_AFFINE, MOTION_HOMOGRAPHY)
^
modules/video/perf/perf_optflowpyrlk.cpp:233:1: error: There is an unknown macro here somewhere. Configuration is required. If CV_ENUM is a macro then please configure it. [unknownMacro]
CV_ENUM(PyrBorderMode, BORDER_DEFAULT, BORDER_TRANSPARENT)
^
modules/video/src/bgfg_KNN.cpp:72:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'frameSize' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    frameSize = Size(0,0);
    ^
modules/video/src/bgfg_KNN.cpp:100:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'frameSize' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    frameSize = Size(0,0);
    ^
modules/video/src/bgfg_KNN.cpp:400:9: style: The scope of the variable 'Ps' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int Ps = 0; // the total probability that this pixel is background shadow
        ^
modules/video/src/bgfg_gaussmix2.cpp:127:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'frameSize' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        frameSize = Size(0,0);
        ^
modules/video/src/bgfg_gaussmix2.cpp:153:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'frameSize' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        frameSize = Size(0,0);
        ^
modules/video/src/bgfg_gaussmix2.cpp:406:9: style: struct member 'GaussBGStatModel2Params::nWidth' is never used. [unusedStructMember]
    int nWidth;
        ^
modules/video/src/bgfg_gaussmix2.cpp:407:9: style: struct member 'GaussBGStatModel2Params::nHeight' is never used. [unusedStructMember]
    int nHeight;
        ^
modules/video/src/bgfg_gaussmix2.cpp:408:9: style: struct member 'GaussBGStatModel2Params::nND' is never used. [unusedStructMember]
    int nND;//number of data dimensions (image channels)
        ^
modules/video/src/bgfg_gaussmix2.cpp:410:10: style: struct member 'GaussBGStatModel2Params::bPostFiltering' is never used. [unusedStructMember]
    bool bPostFiltering;//defult 1 - do postfiltering - will make shadow detection results also give value 255
         ^
modules/video/src/bgfg_gaussmix2.cpp:411:13: style: struct member 'GaussBGStatModel2Params::minArea' is never used. [unusedStructMember]
    double  minArea; // for postfiltering
            ^
modules/video/src/bgfg_gaussmix2.cpp:413:10: style: struct member 'GaussBGStatModel2Params::bInit' is never used. [unusedStructMember]
    bool bInit;//default 1, faster updates at start
         ^
modules/video/src/bgfg_gaussmix2.cpp:418:11: style: struct member 'GaussBGStatModel2Params::fAlphaT' is never used. [unusedStructMember]
    float fAlphaT;
          ^
modules/video/src/bgfg_gaussmix2.cpp:422:11: style: struct member 'GaussBGStatModel2Params::fTb' is never used. [unusedStructMember]
    float fTb;
          ^
modules/video/src/bgfg_gaussmix2.cpp:431:11: style: struct member 'GaussBGStatModel2Params::fTg' is never used. [unusedStructMember]
    float fTg;
          ^
modules/video/src/bgfg_gaussmix2.cpp:437:11: style: struct member 'GaussBGStatModel2Params::fTB' is never used. [unusedStructMember]
    float fTB;//1-cf from the paper
          ^
modules/video/src/bgfg_gaussmix2.cpp:442:11: style: struct member 'GaussBGStatModel2Params::fVarInit' is never used. [unusedStructMember]
    float fVarInit;
          ^
modules/video/src/bgfg_gaussmix2.cpp:443:11: style: struct member 'GaussBGStatModel2Params::fVarMax' is never used. [unusedStructMember]
    float fVarMax;
          ^
modules/video/src/bgfg_gaussmix2.cpp:444:11: style: struct member 'GaussBGStatModel2Params::fVarMin' is never used. [unusedStructMember]
    float fVarMin;
          ^
modules/video/src/bgfg_gaussmix2.cpp:449:11: style: struct member 'GaussBGStatModel2Params::fCT' is never used. [unusedStructMember]
    float fCT;//CT - complexity reduction prior
          ^
modules/video/src/bgfg_gaussmix2.cpp:455:9: style: struct member 'GaussBGStatModel2Params::nM' is never used. [unusedStructMember]
    int nM;//max number of modes - const - 4 is usually enough
        ^
modules/video/src/bgfg_gaussmix2.cpp:458:10: style: struct member 'GaussBGStatModel2Params::bShadowDetection' is never used. [unusedStructMember]
    bool bShadowDetection;//default 1 - do shadow detection
         ^
modules/video/src/bgfg_gaussmix2.cpp:459:19: style: struct member 'GaussBGStatModel2Params::nShadowDetection' is never used. [unusedStructMember]
    unsigned char nShadowDetection;//do shadow detection - insert this value as the detection result
                  ^
modules/video/src/bgfg_gaussmix2.cpp:460:11: style: struct member 'GaussBGStatModel2Params::fTau' is never used. [unusedStructMember]
    float fTau;
          ^
modules/video/src/ecc.cpp:336:13: style: Variable 'map' is reassigned a value before the old one has been used. [redundantAssignment]
        map = Mat::eye(rowCount, 3, CV_32F);
            ^
modules/video/src/ecc.cpp:335:13: note: map is assigned
        map = warpMatrix.getMat();
            ^
modules/video/src/ecc.cpp:336:13: note: map is overwritten
        map = Mat::eye(rowCount, 3, CV_32F);
            ^
modules/video/src/lkpyramid.cpp:165:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'winSize' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    winSize = _winSize;
    ^
modules/video/src/lkpyramid.cpp:166:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'criteria' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    criteria = _criteria;
    ^
modules/video/src/lkpyramid.cpp:68:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x, y, delta = (int)alignSize((cols + 2)*cn, 16);
        ^
modules/video/src/lkpyramid.cpp:1449:18: style: Variable 'sa[5][5]' is assigned a value that is never used. [unreadVariable]
        sa[5][5] = sa[2][2] = count;
                 ^
modules/video/src/lkpyramid.cpp:857:25: style: The unsigned expression 'patch.x' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
            if (patch.x <= 0 || patch.x >= 6 || patch.y <= 0 || patch.y >= 6)
                        ^
modules/video/src/lkpyramid.cpp:857:57: style: The unsigned expression 'patch.y' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
            if (patch.x <= 0 || patch.x >= 6 || patch.y <= 0 || patch.y >= 6)
                                                        ^
modules/video/src/lkpyramid.cpp:961:21: style: Variable 'block.z' is assigned a value that is never used. [unreadVariable]
            block.z = patch.z = 1;
                    ^
modules/video/src/opencl/bgfg_mog2.cl:166:22: style: Local variable 'mode' shadows outer variable [shadowVariable]
            for (int mode = 0; mode < nmodes; ++mode)
                     ^
modules/video/src/opencl/bgfg_mog2.cl:93:15: note: Shadowed declaration
        uchar mode = 0;
              ^
modules/video/src/opencl/bgfg_mog2.cl:166:22: note: Shadow variable
            for (int mode = 0; mode < nmodes; ++mode)
                     ^
modules/video/src/opencl/bgfg_mog2.cl:172:19: style: Local variable 'mode' shadows outer variable [shadowVariable]
            uchar mode = nmodes == (NMIXTURES) ? (NMIXTURES) - 1 : nmodes++;
                  ^
modules/video/src/opencl/bgfg_mog2.cl:93:15: note: Shadowed declaration
        uchar mode = 0;
              ^
modules/video/src/opencl/bgfg_mog2.cl:172:19: note: Shadow variable
            uchar mode = nmodes == (NMIXTURES) ? (NMIXTURES) - 1 : nmodes++;
                  ^
modules/video/src/opencl/bgfg_mog2.cl:155:26: style: Variable 'c_weight' is assigned a value that is never used. [unreadVariable]
                c_weight = 0.0f;
                         ^
modules/video/src/opencl/bgfg_mog2.cl:208:24: style: Local variable 'mode' shadows outer variable [shadowVariable]
            for (uchar mode = 0; mode < nmodes; ++mode)
                       ^
modules/video/src/opencl/bgfg_mog2.cl:93:15: note: Shadowed declaration
        uchar mode = 0;
              ^
modules/video/src/opencl/bgfg_mog2.cl:208:24: note: Shadow variable
            for (uchar mode = 0; mode < nmodes; ++mode)
                       ^
modules/video/src/optflowgf.cpp:136:26: style: The scope of the variable 'g1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        float g0 = g[0], g1, g2;
                         ^
modules/video/src/optflowgf.cpp:136:30: style: The scope of the variable 'g2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        float g0 = g[0], g1, g2;
                             ^
modules/video/src/optflowgf.cpp:137:50: style: The scope of the variable 'srow1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        const float *srow0 = src.ptr<float>(y), *srow1 = 0;
                                                 ^
modules/video/src/optflowgf.cpp:320:17: style: The scope of the variable 'y1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int y0 = 0, y1;
                ^
modules/video/src/optflowgf.cpp:411:9: style: The scope of the variable 'x' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int x, y, i, width = _flow.cols, height = _flow.rows;
        ^
modules/video/src/optflowgf.cpp:413:17: style: The scope of the variable 'y1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int y0 = 0, y1;
                ^
modules/video/src/optflowgf.cpp:449:16: style: The scope of the variable 'g11' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double g11, g12, g22, h1, h2;
               ^
modules/video/src/optflowgf.cpp:449:21: style: The scope of the variable 'g12' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double g11, g12, g22, h1, h2;
                    ^
modules/video/src/optflowgf.cpp:449:26: style: The scope of the variable 'g22' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double g11, g12, g22, h1, h2;
                         ^
modules/video/src/optflowgf.cpp:449:31: style: The scope of the variable 'h1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double g11, g12, g22, h1, h2;
                              ^
modules/video/src/optflowgf.cpp:449:35: style: The scope of the variable 'h2' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double g11, g12, g22, h1, h2;
                                  ^
modules/video/src/optflowgf.cpp:201:9: style: Variable 'row' is assigned a value that is never used. [unreadVariable]
    row -= n*3;
        ^
modules/video/src/optflowgf.cpp:465:48: style: The scope of the variable 'sptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                const float *sptr0 = srow[m], *sptr1;
                                               ^
modules/video/src/optflowgf.cpp:496:48: style: The scope of the variable 'sptr1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
                const float *sptr0 = srow[m], *sptr1;
                                               ^
modules/video/src/optflowgf.cpp:593:5: warning: Member variable 'FarnebackOpticalFlowImpl::m_igd' is not initialized in the constructor. [uninitMemberVar]
    FarnebackOpticalFlowImpl(int numLevels=5, double pyrScale=0.5, bool fastPyramids=false, int winSize=13,
    ^
modules/video/src/optflowgf.cpp:593:5: warning: Member variable 'FarnebackOpticalFlowImpl::m_ig' is not initialized in the constructor. [uninitMemberVar]
    FarnebackOpticalFlowImpl(int numLevels=5, double pyrScale=0.5, bool fastPyramids=false, int winSize=13,
    ^
modules/video/src/tvl1flow.cpp:108:5: error: There is an unknown macro here somewhere. Configuration is required. If CV_IMPL_PROPERTY is a macro then please configure it. [unknownMacro]
    CV_IMPL_PROPERTY(double, Tau, tau)
    ^
modules/video/test/ocl/test_bgfg_mog2.cpp:19:1: error: syntax error [syntaxError]
PARAM_TEST_CASE(Mog2_Update, UseGray, DetectShadow,UseFloat)
^
modules/video/test/ocl/test_optflow_farneback.cpp:62:1: error: syntax error [syntaxError]
PARAM_TEST_CASE(FarnebackOpticalFlow, PyrScale, PolyN, FarnebackOptFlowFlags, UseInitFlow)
^
modules/video/test/ocl/test_optflow_tvl1flow.cpp:61:1: error: syntax error [syntaxError]
PARAM_TEST_CASE(OpticalFlowTVL1, UseInitFlow, MedianFiltering, ScaleStep)
^
modules/video/test/ocl/test_optflowpyrlk.cpp:76:1: error: syntax error [syntaxError]
OCL_TEST_P(PyrLKOpticalFlow, Mat)
^
modules/video/test/test_accum.cpp:60:19: warning: Member variable 'CV_AccumBaseTest::alpha' is not initialized in the constructor. [uninitMemberVar]
CV_AccumBaseTest::CV_AccumBaseTest()
                  ^
modules/video/test/test_accum.cpp:75:73: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    int depth = cvtest::randInt(rng) % 4, cn = cvtest::randInt(rng) & 1 ? 3 : 1;
                                                                        ^
modules/video/test/test_camshift.cpp:71:19: warning: Member variable 'CV_TrackBaseTest::img_type' is not initialized in the constructor. [uninitMemberVar]
CV_TrackBaseTest::CV_TrackBaseTest()
                  ^
modules/video/test/test_camshift.cpp:220:18: warning: Member variable 'CV_CamShiftTest::area0' is not initialized in the constructor. [uninitMemberVar]
CV_CamShiftTest::CV_CamShiftTest()
                 ^
modules/video/test/test_camshift.cpp:387:19: warning: Member variable 'CV_MeanShiftTest::area0' is not initialized in the constructor. [uninitMemberVar]
CV_MeanShiftTest::CV_MeanShiftTest()
                  ^
modules/video/test/test_camshift.cpp:387:19: warning: Member variable 'CV_MeanShiftTest::area' is not initialized in the constructor. [uninitMemberVar]
CV_MeanShiftTest::CV_MeanShiftTest()
                  ^
modules/video/test/test_camshift.cpp:228:12: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double m;
           ^
modules/video/test/test_camshift.cpp:395:12: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double m;
           ^
modules/video/test/test_camshift.cpp:174:41: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a%b?c:d'' should be written as either ''(a%b)?c:d'' or ''a%(b?c:d)''. [clarifyCalculation]
    img_type = cvtest::randInt(rng) % 2 ? CV_32F : CV_8U;
                                        ^
modules/video/test/test_ecc.cpp:143:64: warning: Found suspicious operator ',' [constStatement]
        Mat mapTranslation = (Mat_<float>(2,3) << 1, 0, 0, 0, 1, 0);
                                                               ^
modules/video/test/test_ecc.cpp:218:62: warning: Found suspicious operator ',' [constStatement]
        Mat mapEuclidean = (Mat_<float>(2,3) << 1, 0, 0, 0, 1, 0);
                                                             ^
modules/video/test/test_ecc.cpp:293:59: warning: Found suspicious operator ',' [constStatement]
        Mat mapAffine = (Mat_<float>(2,3) << 1, 0, 0, 0, 1, 0);
                                                          ^
modules/video/test/test_ecc.cpp:361:77: warning: Found suspicious operator ',' [constStatement]
            (rng.uniform(0.0001f, 0.0003f)), (rng.uniform(0.0001f, 0.0003f)), 1.f);
                                                                            ^
modules/video/test/test_ecc.cpp:443:64: warning: Found suspicious operator ',' [constStatement]
        Mat mapTranslation = (Mat_<float>(2,3) << 1, 0, 0, 0, 1, 0);
                                                               ^
modules/video/test/test_estimaterigid.cpp:75:5: style: Struct 'WrapAff2D' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    WrapAff2D(const Mat& aff) : F(aff.ptr<double>()) {}
    ^
modules/video/test/test_estimaterigid.cpp:116:20: style: The scope of the variable 'dB' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            double dB=0, nB=0;
                   ^
modules/video/test/test_estimaterigid.cpp:116:26: style: The scope of the variable 'nB' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            double dB=0, nB=0;
                         ^
modules/video/test/test_estimaterigid.cpp:116:22: style: Variable 'dB' is assigned a value that is never used. [unreadVariable]
            double dB=0, nB=0;
                     ^
modules/video/test/test_estimaterigid.cpp:116:28: style: Variable 'nB' is assigned a value that is never used. [unreadVariable]
            double dB=0, nB=0;
                           ^
modules/video/test/test_kalman.cpp:113:10: style: Redundant initialization for 'code'. The initialized value is overwritten before it is read. [redundantInitialization]
    code = cvtest::cmpEps2( ts, _Sample, _state_post, EPSILON, false, "The final estimated state" );
         ^
modules/video/test/test_kalman.cpp:62:14: note: code is initialized
    int code = cvtest::TS::OK;
             ^
modules/video/test/test_kalman.cpp:113:10: note: code is overwritten
    code = cvtest::cmpEps2( ts, _Sample, _state_post, EPSILON, false, "The final estimated state" );
         ^
modules/videoio/src/cap.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/videoio/src/cap.cpp:170:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    index -= pref;
    ^
modules/videoio/src/cap.cpp:481:15: style: Variable 'index' is assigned a value that is never used. [unreadVariable]
        index %= 100;
              ^
modules/videoio/src/cap_dshow.hpp:26:5: style: Class 'VideoCapture_DShow' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    VideoCapture_DShow(int index);
    ^
modules/videoio/src/cap_dshow.hpp:29:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/precomp.hpp:174:24: note: Virtual function in base class
        virtual double getProperty(int) const { return 0; }
                       ^
modules/videoio/src/cap_dshow.hpp:29:20: note: Function in derived class
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/cap_dshow.hpp:30:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int propIdx, double propVal);
                 ^
modules/videoio/src/precomp.hpp:175:22: note: Virtual function in base class
        virtual bool setProperty(int, double) { return false; }
                     ^
modules/videoio/src/cap_dshow.hpp:30:18: note: Function in derived class
    virtual bool setProperty(int propIdx, double propVal);
                 ^
modules/videoio/src/cap_dshow.hpp:32:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:176:22: note: Virtual function in base class
        virtual bool grabFrame() = 0;
                     ^
modules/videoio/src/cap_dshow.hpp:32:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_dshow.hpp:33:18: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool retrieveFrame(int outputType, OutputArray frame);
                 ^
modules/videoio/src/precomp.hpp:177:22: note: Virtual function in base class
        virtual bool retrieveFrame(int, OutputArray) = 0;
                     ^
modules/videoio/src/cap_dshow.hpp:33:18: note: Function in derived class
    virtual bool retrieveFrame(int outputType, OutputArray frame);
                 ^
modules/videoio/src/cap_dshow.hpp:34:17: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getCaptureDomain();
                ^
modules/videoio/src/precomp.hpp:179:21: note: Virtual function in base class
        virtual int getCaptureDomain() { return CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                    ^
modules/videoio/src/cap_dshow.hpp:34:17: note: Function in derived class
    virtual int getCaptureDomain();
                ^
modules/videoio/src/cap_dshow.hpp:35:18: style: The function 'isOpened' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool isOpened() const;
                 ^
modules/videoio/src/precomp.hpp:178:22: note: Virtual function in base class
        virtual bool isOpened() const = 0;
                     ^
modules/videoio/src/cap_dshow.hpp:35:18: note: Function in derived class
    virtual bool isOpened() const;
                 ^
modules/videoio/src/cap_intelperc.hpp:64:18: style: The function 'initStream' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool initStream(PXCSession *session);
                 ^
modules/videoio/src/cap_intelperc.hpp:36:18: note: Virtual function in base class
    virtual bool initStream(PXCSession *session)            = 0;
                 ^
modules/videoio/src/cap_intelperc.hpp:64:18: note: Function in derived class
    virtual bool initStream(PXCSession *session);
                 ^
modules/videoio/src/cap_intelperc.hpp:65:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/cap_intelperc.hpp:37:20: note: Virtual function in base class
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/cap_intelperc.hpp:65:20: note: Function in derived class
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/cap_intelperc.hpp:66:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int propIdx, double propVal);
                 ^
modules/videoio/src/cap_intelperc.hpp:38:18: note: Virtual function in base class
    virtual bool setProperty(int propIdx, double propVal);
                 ^
modules/videoio/src/cap_intelperc.hpp:66:18: note: Function in derived class
    virtual bool setProperty(int propIdx, double propVal);
                 ^
modules/videoio/src/cap_intelperc.hpp:78:18: style: The function 'initStream' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool initStream(PXCSession *session);
                 ^
modules/videoio/src/cap_intelperc.hpp:36:18: note: Virtual function in base class
    virtual bool initStream(PXCSession *session)            = 0;
                 ^
modules/videoio/src/cap_intelperc.hpp:78:18: note: Function in derived class
    virtual bool initStream(PXCSession *session);
                 ^
modules/videoio/src/cap_intelperc.hpp:79:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/cap_intelperc.hpp:37:20: note: Virtual function in base class
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/cap_intelperc.hpp:79:20: note: Function in derived class
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/cap_intelperc.hpp:80:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int propIdx, double propVal);
                 ^
modules/videoio/src/cap_intelperc.hpp:38:18: note: Virtual function in base class
    virtual bool setProperty(int propIdx, double propVal);
                 ^
modules/videoio/src/cap_intelperc.hpp:80:18: note: Function in derived class
    virtual bool setProperty(int propIdx, double propVal);
                 ^
modules/videoio/src/cap_intelperc.hpp:86:18: style: The function 'validProfile' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool validProfile(const PXCCapture::VideoStream::ProfileInfo& pinfo);
                 ^
modules/videoio/src/cap_intelperc.hpp:53:18: note: Virtual function in base class
    virtual bool validProfile(const PXCCapture::VideoStream::ProfileInfo& /*pinfo*/);
                 ^
modules/videoio/src/cap_intelperc.hpp:86:18: note: Function in derived class
    virtual bool validProfile(const PXCCapture::VideoStream::ProfileInfo& pinfo);
                 ^
modules/videoio/src/cap_intelperc.hpp:97:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/precomp.hpp:174:24: note: Virtual function in base class
        virtual double getProperty(int) const { return 0; }
                       ^
modules/videoio/src/cap_intelperc.hpp:97:20: note: Function in derived class
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/cap_intelperc.hpp:98:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int propIdx, double propVal);
                 ^
modules/videoio/src/precomp.hpp:175:22: note: Virtual function in base class
        virtual bool setProperty(int, double) { return false; }
                     ^
modules/videoio/src/cap_intelperc.hpp:98:18: note: Function in derived class
    virtual bool setProperty(int propIdx, double propVal);
                 ^
modules/videoio/src/cap_intelperc.hpp:100:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:176:22: note: Virtual function in base class
        virtual bool grabFrame() = 0;
                     ^
modules/videoio/src/cap_intelperc.hpp:100:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_intelperc.hpp:101:18: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool retrieveFrame(int outputType, OutputArray frame);
                 ^
modules/videoio/src/precomp.hpp:177:22: note: Virtual function in base class
        virtual bool retrieveFrame(int, OutputArray) = 0;
                     ^
modules/videoio/src/cap_intelperc.hpp:101:18: note: Function in derived class
    virtual bool retrieveFrame(int outputType, OutputArray frame);
                 ^
modules/videoio/src/cap_intelperc.hpp:102:17: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getCaptureDomain();
                ^
modules/videoio/src/precomp.hpp:179:21: note: Virtual function in base class
        virtual int getCaptureDomain() { return CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                    ^
modules/videoio/src/cap_intelperc.hpp:102:17: note: Function in derived class
    virtual int getCaptureDomain();
                ^
modules/videoio/src/cap_intelperc.hpp:103:18: style: The function 'isOpened' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool isOpened() const;
                 ^
modules/videoio/src/precomp.hpp:178:22: note: Virtual function in base class
        virtual bool isOpened() const = 0;
                     ^
modules/videoio/src/cap_intelperc.hpp:103:18: note: Function in derived class
    virtual bool isOpened() const;
                 ^
modules/videoio/src/cap_aravis.cpp:176:22: warning: Member variable 'CvCaptureCAM_Aravis::fpsAvailable' is not initialized in the constructor. [uninitMemberVar]
CvCaptureCAM_Aravis::CvCaptureCAM_Aravis()
                     ^
modules/videoio/src/cap_aravis.cpp:176:22: warning: Member variable 'CvCaptureCAM_Aravis::gainAvailable' is not initialized in the constructor. [uninitMemberVar]
CvCaptureCAM_Aravis::CvCaptureCAM_Aravis()
                     ^
modules/videoio/src/cap_aravis.cpp:176:22: warning: Member variable 'CvCaptureCAM_Aravis::exposureAvailable' is not initialized in the constructor. [uninitMemberVar]
CvCaptureCAM_Aravis::CvCaptureCAM_Aravis()
                     ^
modules/videoio/src/cap_aravis.cpp:176:22: warning: Member variable 'CvCaptureCAM_Aravis::autoGain' is not initialized in the constructor. [uninitMemberVar]
CvCaptureCAM_Aravis::CvCaptureCAM_Aravis()
                     ^
modules/videoio/src/cap_aravis.cpp:176:22: warning: Member variable 'CvCaptureCAM_Aravis::pixelFormats' is not initialized in the constructor. [uninitMemberVar]
CvCaptureCAM_Aravis::CvCaptureCAM_Aravis()
                     ^
modules/videoio/src/cap_aravis.cpp:176:22: warning: Member variable 'CvCaptureCAM_Aravis::fps' is not initialized in the constructor. [uninitMemberVar]
CvCaptureCAM_Aravis::CvCaptureCAM_Aravis()
                     ^
modules/videoio/src/cap_aravis.cpp:176:22: warning: Member variable 'CvCaptureCAM_Aravis::exposure' is not initialized in the constructor. [uninitMemberVar]
CvCaptureCAM_Aravis::CvCaptureCAM_Aravis()
                     ^
modules/videoio/src/cap_aravis.cpp:176:22: warning: Member variable 'CvCaptureCAM_Aravis::gain' is not initialized in the constructor. [uninitMemberVar]
CvCaptureCAM_Aravis::CvCaptureCAM_Aravis()
                     ^
modules/videoio/src/cap_aravis.cpp:176:22: warning: Member variable 'CvCaptureCAM_Aravis::midGrey' is not initialized in the constructor. [uninitMemberVar]
CvCaptureCAM_Aravis::CvCaptureCAM_Aravis()
                     ^
modules/videoio/src/cap_aravis.cpp:105:18: warning: Virtual function 'close' is called from destructor '~CvCaptureCAM_Aravis()' at line 101. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_aravis.cpp:101:9: note: Calling close
        close();
        ^
modules/videoio/src/cap_aravis.cpp:105:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_aravis.cpp:106:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_aravis.cpp:106:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_aravis.cpp:107:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_aravis.cpp:107:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_aravis.cpp:108:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_aravis.cpp:108:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_aravis.cpp:109:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_aravis.cpp:109:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/cap_aravis.cpp:110:17: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getCaptureDomain()
                ^
modules/videoio/src/precomp.hpp:93:17: note: Virtual function in base class
    virtual int getCaptureDomain() { return cv::CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                ^
modules/videoio/src/cap_aravis.cpp:110:17: note: Function in derived class
    virtual int getCaptureDomain()
                ^
modules/videoio/src/cap_aravis.cpp:388:16: style: The scope of the variable 'ev' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double ev, ng = 0;
               ^
modules/videoio/src/cap_cmu.cpp:58:5: warning: Member variable 'CvCaptureCAM_CMU::fps' is not initialized in the constructor. [uninitMemberVar]
    CvCaptureCAM_CMU()
    ^
modules/videoio/src/cap_cmu.cpp:58:5: warning: Member variable 'CvCaptureCAM_CMU::mode' is not initialized in the constructor. [uninitMemberVar]
    CvCaptureCAM_CMU()
    ^
modules/videoio/src/cap_cmu.cpp:58:5: warning: Member variable 'CvCaptureCAM_CMU::format' is not initialized in the constructor. [uninitMemberVar]
    CvCaptureCAM_CMU()
    ^
modules/videoio/src/cap_cmu.cpp:70:18: warning: Virtual function 'close' is called from destructor '~CvCaptureCAM_CMU()' at line 66. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_cmu.cpp:66:9: note: Calling close
        close();
        ^
modules/videoio/src/cap_cmu.cpp:70:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_cmu.cpp:71:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_cmu.cpp:71:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_cmu.cpp:72:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_cmu.cpp:72:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_cmu.cpp:73:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_cmu.cpp:73:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_cmu.cpp:74:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_cmu.cpp:74:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/cap_cmu.cpp:329:26: style: Local variable 'size' shadows outer variable [shadowVariable]
                for (int size=CV_CAP_IEEE1394_SIZE_1600X1200; size>=0 && !found_format; size--)
                         ^
modules/videoio/src/cap_cmu.cpp:300:16: note: Shadowed declaration
        CvSize size;
               ^
modules/videoio/src/cap_cmu.cpp:329:26: note: Shadow variable
                for (int size=CV_CAP_IEEE1394_SIZE_1600X1200; size>=0 && !found_format; size--)
                         ^
modules/videoio/src/cap_dc1394_v2.cpp:275:29: warning: Member variable 'CvCaptureCAM_DC1394_v2_CPP::videoMode' is not initialized in the constructor. [uninitMemberVar]
CvCaptureCAM_DC1394_v2_CPP::CvCaptureCAM_DC1394_v2_CPP()
                            ^
modules/videoio/src/cap_dc1394_v2.cpp:275:29: warning: Member variable 'CvCaptureCAM_DC1394_v2_CPP::init_rectify' is not initialized in the constructor. [uninitMemberVar]
CvCaptureCAM_DC1394_v2_CPP::CvCaptureCAM_DC1394_v2_CPP()
                            ^
modules/videoio/src/cap_dc1394_v2.cpp:286:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'bayer' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    bayer = DC1394_BAYER_METHOD_BILINEAR;
    ^
modules/videoio/src/cap_dc1394_v2.cpp:287:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'bayerFilter' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    bayerFilter = DC1394_COLOR_FILTER_GRBG;
    ^
modules/videoio/src/cap_dc1394_v2.cpp:208:18: warning: Virtual function 'close' is called from destructor '~CvCaptureCAM_DC1394_v2_CPP()' at line 204. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_dc1394_v2.cpp:204:9: note: Calling close
        close();
        ^
modules/videoio/src/cap_dc1394_v2.cpp:208:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_dc1394_v2.cpp:210:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_dc1394_v2.cpp:210:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_dc1394_v2.cpp:211:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_dc1394_v2.cpp:211:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_dc1394_v2.cpp:212:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_dc1394_v2.cpp:212:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_dc1394_v2.cpp:213:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_dc1394_v2.cpp:213:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/cap_dc1394_v2.cpp:214:17: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getCaptureDomain() { return CV_CAP_DC1394; } // Return the type of the capture object: CV_CAP_VFW, etc...
                ^
modules/videoio/src/precomp.hpp:93:17: note: Virtual function in base class
    virtual int getCaptureDomain() { return cv::CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                ^
modules/videoio/src/cap_dc1394_v2.cpp:214:17: note: Function in derived class
    virtual int getCaptureDomain() { return CV_CAP_DC1394; } // Return the type of the capture object: CV_CAP_VFW, etc...
                ^
modules/videoio/src/cap_dc1394_v2.cpp:451:10: style: Variable 'code' is reassigned a value before the old one has been used. [redundantAssignment]
    code = dc1394_capture_setup(dcCam, nDMABufs, DC1394_CAPTURE_FLAGS_DEFAULT);
         ^
modules/videoio/src/cap_dc1394_v2.cpp:414:18: note: code is assigned
            code = dc1394_video_set_mode(dcCam, bestMode);
                 ^
modules/videoio/src/cap_dc1394_v2.cpp:451:10: note: code is overwritten
    code = dc1394_capture_setup(dcCam, nDMABufs, DC1394_CAPTURE_FLAGS_DEFAULT);
         ^
modules/videoio/src/cap_dc1394_v2.cpp:451:10: style: Variable 'code' is reassigned a value before the old one has been used. [redundantAssignment]
    code = dc1394_capture_setup(dcCam, nDMABufs, DC1394_CAPTURE_FLAGS_DEFAULT);
         ^
modules/videoio/src/cap_dc1394_v2.cpp:439:18: note: code is assigned
            code = dc1394_video_set_framerate(dcCam, bestFps);
                 ^
modules/videoio/src/cap_dc1394_v2.cpp:451:10: note: code is overwritten
    code = dc1394_capture_setup(dcCam, nDMABufs, DC1394_CAPTURE_FLAGS_DEFAULT);
         ^
modules/videoio/src/cap_dc1394_v2.cpp:890:49: style: Finding the same expression in both branches of ternary operator is suspicious as the same code is executed regardless of the condition. [duplicateExpressionTernary]
        CvMat* rectification = k == 0 ? &l_rect : &r_rect;
                                                ^
modules/videoio/src/cap_dc1394_v2.cpp:871:65: note: 'r_rect' is assigned value 'l_rect' here.
    CvMat l_rect = cvMat(3, 3, CV_32F, identity_data), r_rect = l_rect;
                                                                ^
modules/videoio/src/cap_dc1394_v2.cpp:890:49: note: Same expression in both branches of ternary operator.
        CvMat* rectification = k == 0 ? &l_rect : &r_rect;
                                                ^
modules/videoio/src/cap_dc1394_v2.cpp:381:17: style: The scope of the variable 'pref' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            int pref = -1;
                ^
modules/videoio/src/cap_dc1394_v2.cpp:402:26: style: Variable 'pref' is assigned a value that is never used. [unreadVariable]
                    pref = 1;
                         ^
modules/videoio/src/cap_dshow.cpp:660:5: error: There is an unknown macro here somewhere. Configuration is required. If STDMETHODIMP_ is a macro then please configure it. [unknownMacro]
    STDMETHODIMP_(ULONG) AddRef() { return 1; }
    ^
modules/videoio/src/cap_ffmpeg.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/videoio/src/cap_ffmpeg.cpp:240:18: warning: Virtual function 'close' is called from destructor '~CvCapture_FFMPEG_proxy()' at line 204. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close()
                 ^
modules/videoio/src/cap_ffmpeg.cpp:204:41: note: Calling close
    virtual ~CvCapture_FFMPEG_proxy() { close(); }
                                        ^
modules/videoio/src/cap_ffmpeg.cpp:240:18: note: close is a virtual function
    virtual void close()
                 ^
modules/videoio/src/cap_ffmpeg.cpp:289:18: warning: Virtual function 'close' is called from destructor '~CvVideoWriter_FFMPEG_proxy()' at line 268. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close()
                 ^
modules/videoio/src/cap_ffmpeg.cpp:268:45: note: Calling close
    virtual ~CvVideoWriter_FFMPEG_proxy() { close(); }
                                            ^
modules/videoio/src/cap_ffmpeg.cpp:289:18: note: close is a virtual function
    virtual void close()
                 ^
modules/videoio/src/cap_ffmpeg.cpp:206:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int propId) const
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_ffmpeg.cpp:206:20: note: Function in derived class
    virtual double getProperty(int propId) const
                   ^
modules/videoio/src/cap_ffmpeg.cpp:210:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int propId, double value)
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_ffmpeg.cpp:210:18: note: Function in derived class
    virtual bool setProperty(int propId, double value)
                 ^
modules/videoio/src/cap_ffmpeg.cpp:214:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame()
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_ffmpeg.cpp:214:18: note: Function in derived class
    virtual bool grabFrame()
                 ^
modules/videoio/src/cap_ffmpeg.cpp:218:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int)
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_ffmpeg.cpp:218:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int)
                      ^
modules/videoio/src/cap_ffmpeg.cpp:270:18: style: The function 'writeFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool writeFrame( const IplImage* image )
                 ^
modules/videoio/src/precomp.hpp:101:18: note: Virtual function in base class
    virtual bool writeFrame(const IplImage*) { return false; }
                 ^
modules/videoio/src/cap_ffmpeg.cpp:270:18: note: Function in derived class
    virtual bool writeFrame( const IplImage* image )
                 ^
modules/videoio/src/cap_ffmpeg_impl.hpp:726:5: style: Class 'AutoLock' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    AutoLock(ImplMutex& m) : mutex(&m) { mutex->lock(); }
    ^
modules/videoio/src/cap_ffmpeg_impl.hpp:2161:33: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    CvCapture_FFMPEG* capture = (CvCapture_FFMPEG*)malloc(sizeof(*capture));
                                ^
modules/videoio/src/cap_ffmpeg_impl.hpp:2207:36: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    CvVideoWriter_FFMPEG* writer = (CvVideoWriter_FFMPEG*)malloc(sizeof(*writer));
                                   ^
modules/videoio/src/cap_ffmpeg_impl.hpp:2520:40: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    OutputMediaStream_FFMPEG* stream = (OutputMediaStream_FFMPEG*) malloc(sizeof(OutputMediaStream_FFMPEG));
                                       ^
modules/videoio/src/cap_ffmpeg_impl.hpp:2789:39: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    InputMediaStream_FFMPEG* stream = (InputMediaStream_FFMPEG*) malloc(sizeof(InputMediaStream_FFMPEG));
                                      ^
modules/videoio/src/cap_ffmpeg_impl.hpp:1407:15: style: The scope of the variable 'picture_buf' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint8_t * picture_buf = 0;
              ^
modules/videoio/src/cap_ffmpeg_impl.hpp:1407:27: style: Variable 'picture_buf' is assigned a value that is never used. [unreadVariable]
    uint8_t * picture_buf = 0;
                          ^
modules/videoio/src/cap_ffmpeg_impl.hpp:1479:11: style: Variable 'codec' is assigned a value that is never used. [unreadVariable]
    codec = avcodec_find_encoder(c->codec_id);
          ^
modules/videoio/src/cap_giganetix.cpp:296:18: warning: Virtual function 'close' is called from destructor '~CvCaptureCAM_Giganetix()' at line 355. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_giganetix.cpp:355:3: note: Calling close
  close();
  ^
modules/videoio/src/cap_giganetix.cpp:296:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_giganetix.cpp:297:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_giganetix.cpp:297:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_giganetix.cpp:298:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_giganetix.cpp:298:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_giganetix.cpp:299:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_giganetix.cpp:299:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_giganetix.cpp:300:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_giganetix.cpp:300:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/cap_giganetix.cpp:301:17: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getCaptureDomain()
                ^
modules/videoio/src/precomp.hpp:93:17: note: Virtual function in base class
    virtual int getCaptureDomain() { return cv::CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                ^
modules/videoio/src/cap_giganetix.cpp:301:17: note: Function in derived class
    virtual int getCaptureDomain()
                ^
modules/videoio/src/cap_giganetix.cpp:761:13: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    return ((CvCapture*)capture);
            ^
modules/videoio/src/cap_giganetix.cpp:722:15: style: Variable 'b_ret' is reassigned a value before the old one has been used. [redundantAssignment]
        b_ret = m_device->SetIntegerNodeValue ("OffsetY", (INT64)value);
              ^
modules/videoio/src/cap_giganetix.cpp:721:19: note: b_ret is assigned
            b_ret = m_device->SetIntegerNodeValue ("OffsetY", (val + h) > hmax ? (hmax - h) : val);
                  ^
modules/videoio/src/cap_giganetix.cpp:722:15: note: b_ret is overwritten
        b_ret = m_device->SetIntegerNodeValue ("OffsetY", (INT64)value);
              ^
modules/videoio/src/cap_gphoto2.cpp:142:18: warning: Virtual function 'isOpened' is called from constructor 'DigitalCameraCapture(int index)' at line 363. Dynamic binding is not used. [virtualCallInConstructor]
    virtual bool isOpened() const;
                 ^
modules/videoio/src/cap_gphoto2.cpp:363:9: note: Calling open
        open(index);
        ^
modules/videoio/src/cap_gphoto2.cpp:410:9: note: Calling isOpened
    if (isOpened()) {
        ^
modules/videoio/src/cap_gphoto2.cpp:142:18: note: isOpened is a virtual function
    virtual bool isOpened() const;
                 ^
modules/videoio/src/cap_gphoto2.cpp:142:18: warning: Virtual function 'isOpened' is called from constructor 'DigitalCameraCapture(const String&deviceName)' at line 375. Dynamic binding is not used. [virtualCallInConstructor]
    virtual bool isOpened() const;
                 ^
modules/videoio/src/cap_gphoto2.cpp:375:9: note: Calling open
        open(index);
        ^
modules/videoio/src/cap_gphoto2.cpp:410:9: note: Calling isOpened
    if (isOpened()) {
        ^
modules/videoio/src/cap_gphoto2.cpp:142:18: note: isOpened is a virtual function
    virtual bool isOpened() const;
                 ^
modules/videoio/src/cap_gphoto2.cpp:138:5: style: Class 'DigitalCameraCapture' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    DigitalCameraCapture(int index);
    ^
modules/videoio/src/cap_gphoto2.cpp:139:5: style: Class 'DigitalCameraCapture' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    DigitalCameraCapture(const String &deviceName);
    ^
modules/videoio/src/cap_gphoto2.cpp:260:14: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            (const DigitalCameraCapture *) thatGPhotoCap;
             ^
modules/videoio/src/cap_gphoto2.cpp:271:14: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            (const DigitalCameraCapture *) thatGPhotoCap;
             ^
modules/videoio/src/cap_gphoto2.cpp:282:14: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            (const DigitalCameraCapture *) thatGPhotoCap;
             ^
modules/videoio/src/cap_gphoto2.cpp:407:9: style: The scope of the variable 'm' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int m, p;
        ^
modules/videoio/src/cap_gphoto2.cpp:407:12: style: The scope of the variable 'p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int m, p;
           ^
modules/videoio/src/cap_gphoto2.cpp:73:32: style: Parameter 'e' can be declared with const [constParameter]
            GPhoto2Exception & e)
                               ^
modules/videoio/src/cap_gstreamer.cpp:1264:5: warning: Member variable 'CvVideoWriter_GStreamer::input_pix_fmt' is not initialized in the constructor. [uninitMemberVar]
    CvVideoWriter_GStreamer() { init(); }
    ^
modules/videoio/src/cap_gstreamer.cpp:140:18: warning: Virtual function 'close' is called from destructor '~CvCapture_GStreamer()' at line 137. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_gstreamer.cpp:137:38: note: Calling close
    virtual ~CvCapture_GStreamer() { close(); }
                                     ^
modules/videoio/src/cap_gstreamer.cpp:140:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_gstreamer.cpp:1269:18: warning: Virtual function 'close' is called from destructor '~CvVideoWriter_GStreamer()' at line 1265. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_gstreamer.cpp:1265:42: note: Calling close
    virtual ~CvVideoWriter_GStreamer() { close(); }
                                         ^
modules/videoio/src/cap_gstreamer.cpp:1269:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_gstreamer.cpp:142:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_gstreamer.cpp:142:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_gstreamer.cpp:143:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_gstreamer.cpp:143:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_gstreamer.cpp:144:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_gstreamer.cpp:144:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_gstreamer.cpp:145:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_gstreamer.cpp:145:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/cap_gstreamer.cpp:1270:18: style: The function 'writeFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool writeFrame( const IplImage* image );
                 ^
modules/videoio/src/precomp.hpp:101:18: note: Virtual function in base class
    virtual bool writeFrame(const IplImage*) { return false; }
                 ^
modules/videoio/src/cap_gstreamer.cpp:1270:18: note: Function in derived class
    virtual bool writeFrame( const IplImage* image );
                 ^
modules/videoio/src/cap_gstreamer.cpp:364:19: style: Condition 'depth>0' is always true [knownConditionTrueFalse]
        if (depth > 0) {
                  ^
modules/videoio/src/cap_gstreamer.cpp:310:21: note: Assignment 'depth=3', assigned value is 3
        int depth = 3;
                    ^
modules/videoio/src/cap_gstreamer.cpp:364:19: note: Condition 'depth>0' is always true
        if (depth > 0) {
                  ^
modules/videoio/src/cap_gstreamer.cpp:365:16: style: Condition 'height_extend' is always false [knownConditionTrueFalse]
            if(height_extend){
               ^
modules/videoio/src/cap_gstreamer.cpp:311:30: note: Assignment 'height_extend=false', assigned value is 0
        bool height_extend = false;
                             ^
modules/videoio/src/cap_gstreamer.cpp:365:16: note: Condition 'height_extend' is always false
            if(height_extend){
               ^
modules/videoio/src/cap_gstreamer.cpp:689:17: warning: Either the condition 'uri' is redundant or there is possible null pointer dereference: uri. [nullPointerRedundantCheck]
                CV_WARN(uri);
                ^
modules/videoio/src/cap_gstreamer.cpp:681:16: note: Assuming that condition 'uri' is not redundant
            if(uri)
               ^
modules/videoio/src/cap_gstreamer.cpp:689:17: note: Null pointer dereference
                CV_WARN(uri);
                ^
modules/videoio/src/cap_gstreamer.cpp:689:17: error: Null pointer dereference [nullPointer]
                CV_WARN(uri);
                ^
modules/videoio/src/cap_gstreamer.cpp:311:14: style: The scope of the variable 'height_extend' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        bool height_extend = false;
             ^
modules/videoio/src/cap_images.cpp:83:18: warning: Virtual function 'close' is called from destructor '~CvCapture_Images()' at line 79. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_images.cpp:79:9: note: Calling close
        close();
        ^
modules/videoio/src/cap_images.cpp:83:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_images.cpp:335:18: warning: Virtual function 'close' is called from destructor '~CvVideoWriter_Images()' at line 332. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_images.cpp:332:39: note: Calling close
    virtual ~CvVideoWriter_Images() { close(); }
                                      ^
modules/videoio/src/cap_images.cpp:335:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_images.cpp:84:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_images.cpp:84:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_images.cpp:85:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_images.cpp:85:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_images.cpp:86:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_images.cpp:86:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_images.cpp:87:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_images.cpp:87:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/cap_images.cpp:337:18: style: The function 'writeFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool writeFrame( const IplImage* );
                 ^
modules/videoio/src/precomp.hpp:101:18: note: Virtual function in base class
    virtual bool writeFrame(const IplImage*) { return false; }
                 ^
modules/videoio/src/cap_images.cpp:337:18: note: Function in derived class
    virtual bool writeFrame( const IplImage* );
                 ^
modules/videoio/src/cap_images.cpp:240:17: warning: Either the condition 'name!=NULL' is redundant or there is possible null pointer dereference: name. [nullPointerRedundantCheck]
        strncpy(name, filename, at - filename);
                ^
modules/videoio/src/cap_images.cpp:239:24: note: Assuming that condition 'name!=NULL' is not redundant
        CV_Assert(name != NULL);
                       ^
modules/videoio/src/cap_images.cpp:238:16: note: Assignment 'name=(char*)malloc(size)', assigned value is 0
        name = (char *)malloc(size);
               ^
modules/videoio/src/cap_images.cpp:240:17: note: Null pointer dereference
        strncpy(name, filename, at - filename);
                ^
modules/videoio/src/cap_images.cpp:241:9: warning: Either the condition 'name!=NULL' is redundant or there is possible null pointer dereference: name. [nullPointerRedundantCheck]
        name[at - filename] = 0;
        ^
modules/videoio/src/cap_images.cpp:239:24: note: Assuming that condition 'name!=NULL' is not redundant
        CV_Assert(name != NULL);
                       ^
modules/videoio/src/cap_images.cpp:238:16: note: Assignment 'name=(char*)malloc(size)', assigned value is 0
        name = (char *)malloc(size);
               ^
modules/videoio/src/cap_images.cpp:241:9: note: Null pointer dereference
        name[at - filename] = 0;
        ^
modules/videoio/src/cap_images.cpp:243:16: warning: Either the condition 'name!=NULL' is redundant or there is possible null pointer dereference: name. [nullPointerRedundantCheck]
        strcat(name, "%0");
               ^
modules/videoio/src/cap_images.cpp:239:24: note: Assuming that condition 'name!=NULL' is not redundant
        CV_Assert(name != NULL);
                       ^
modules/videoio/src/cap_images.cpp:238:16: note: Assignment 'name=(char*)malloc(size)', assigned value is 0
        name = (char *)malloc(size);
               ^
modules/videoio/src/cap_images.cpp:243:16: note: Null pointer dereference
        strcat(name, "%0");
               ^
modules/videoio/src/cap_images.cpp:252:16: warning: Either the condition 'name!=NULL' is redundant or there is possible null pointer dereference: name. [nullPointerRedundantCheck]
        strcat(name, places);
               ^
modules/videoio/src/cap_images.cpp:239:24: note: Assuming that condition 'name!=NULL' is not redundant
        CV_Assert(name != NULL);
                       ^
modules/videoio/src/cap_images.cpp:238:16: note: Assignment 'name=(char*)malloc(size)', assigned value is 0
        name = (char *)malloc(size);
               ^
modules/videoio/src/cap_images.cpp:252:16: note: Null pointer dereference
        strcat(name, places);
               ^
modules/videoio/src/cap_images.cpp:253:16: warning: Either the condition 'name!=NULL' is redundant or there is possible null pointer dereference: name. [nullPointerRedundantCheck]
        strcat(name, extension);
               ^
modules/videoio/src/cap_images.cpp:239:24: note: Assuming that condition 'name!=NULL' is not redundant
        CV_Assert(name != NULL);
                       ^
modules/videoio/src/cap_images.cpp:238:16: note: Assignment 'name=(char*)malloc(size)', assigned value is 0
        name = (char *)malloc(size);
               ^
modules/videoio/src/cap_images.cpp:253:16: note: Null pointer dereference
        strcat(name, extension);
               ^
modules/videoio/src/cap_intelperc.cpp:10:22: warning: Member variable 'IntelPerCStreamBase::m_timeStamp' is not initialized in the constructor. [uninitMemberVar]
IntelPerCStreamBase::IntelPerCStreamBase()
                     ^
modules/videoio/src/cap_mfx_common.hpp:39:5: style: Struct 'HexWrap' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    HexWrap(T val_) : val(val_) {}
    ^
modules/videoio/src/cap_mfx_common.hpp:58:5: style: Struct 'FourCC' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    FourCC(uint val) : val32(val) {}
    ^
modules/videoio/src/cap_mfx_common.hpp:212:5: style: Class 'ReadBitstream' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ReadBitstream(const char * filename, size_t maxSize = 10 * 1024 * 1024);
    ^
modules/videoio/src/cap_mfx_common.cpp:26:9: style: Variable 'res' is reassigned a value before the old one has been used. [redundantAssignment]
    res = session.QueryIMPL(&impl);
        ^
modules/videoio/src/cap_mfx_common.cpp:23:9: note: res is assigned
    res = session.Init(impl, &ver);
        ^
modules/videoio/src/cap_mfx_common.cpp:26:9: note: res is overwritten
    res = session.QueryIMPL(&impl);
        ^
modules/videoio/src/cap_mfx_common.cpp:29:9: style: Variable 'res' is reassigned a value before the old one has been used. [redundantAssignment]
    res = session.QueryVersion(&ver);
        ^
modules/videoio/src/cap_mfx_common.cpp:26:9: note: res is assigned
    res = session.QueryIMPL(&impl);
        ^
modules/videoio/src/cap_mfx_common.cpp:29:9: note: res is overwritten
    res = session.QueryVersion(&ver);
        ^
modules/videoio/src/cap_mfx_common.hpp:322:18: style: The function 'initDeviceSession' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool initDeviceSession(MFXVideoSession &) { return true; }
                 ^
modules/videoio/src/cap_mfx_common.hpp:284:18: note: Virtual function in base class
    virtual bool initDeviceSession(MFXVideoSession &session) = 0;
                 ^
modules/videoio/src/cap_mfx_common.hpp:322:18: note: Function in derived class
    virtual bool initDeviceSession(MFXVideoSession &) { return true; }
                 ^
modules/videoio/src/cap_mfx_common.hpp:301:18: style: The function 'initDeviceSession' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool initDeviceSession(MFXVideoSession &session);
                 ^
modules/videoio/src/cap_mfx_common.hpp:284:18: note: Virtual function in base class
    virtual bool initDeviceSession(MFXVideoSession &session) = 0;
                 ^
modules/videoio/src/cap_mfx_common.hpp:301:18: note: Function in derived class
    virtual bool initDeviceSession(MFXVideoSession &session);
                 ^
modules/videoio/src/cap_mfx_reader.hpp:21:5: style: Class 'VideoCapture_IntelMFX' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    VideoCapture_IntelMFX(const cv::String &filename);
    ^
modules/videoio/src/cap_mfx_reader.hpp:23:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:174:24: note: Virtual function in base class
        virtual double getProperty(int) const { return 0; }
                       ^
modules/videoio/src/cap_mfx_reader.hpp:23:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_mfx_reader.hpp:24:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:175:22: note: Virtual function in base class
        virtual bool setProperty(int, double) { return false; }
                     ^
modules/videoio/src/cap_mfx_reader.hpp:24:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_mfx_reader.hpp:25:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:176:22: note: Virtual function in base class
        virtual bool grabFrame() = 0;
                     ^
modules/videoio/src/cap_mfx_reader.hpp:25:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_mfx_reader.hpp:27:18: style: The function 'isOpened' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool isOpened() const;
                 ^
modules/videoio/src/precomp.hpp:178:22: note: Virtual function in base class
        virtual bool isOpened() const = 0;
                     ^
modules/videoio/src/cap_mfx_reader.hpp:27:18: note: Function in derived class
    virtual bool isOpened() const;
                 ^
modules/videoio/src/cap_mfx_reader.hpp:28:17: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getCaptureDomain();
                ^
modules/videoio/src/precomp.hpp:179:21: note: Virtual function in base class
        virtual int getCaptureDomain() { return CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                    ^
modules/videoio/src/cap_mfx_reader.hpp:28:17: note: Function in derived class
    virtual int getCaptureDomain();
                ^
modules/videoio/src/cap_mfx_reader.cpp:242:19: style: Variable 'info' can be declared with const [constVariable]
    mfxFrameInfo &info = s->Info;
                  ^
modules/videoio/src/cap_mfx_writer.cpp:32:23: warning: Member variable 'VideoWriter_IntelMFX::outSurface' is not initialized in the constructor. [uninitMemberVar]
VideoWriter_IntelMFX::VideoWriter_IntelMFX(const String &filename, int _fourcc, double fps, Size frameSize_, bool)
                      ^
modules/videoio/src/cap_mfx_writer.hpp:23:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:186:24: note: Virtual function in base class
        virtual double getProperty(int) const { return 0; }
                       ^
modules/videoio/src/cap_mfx_writer.hpp:23:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_mfx_writer.hpp:24:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:187:22: note: Virtual function in base class
        virtual bool setProperty(int, double) { return false; }
                     ^
modules/videoio/src/cap_mfx_writer.hpp:24:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_mfx_writer.hpp:25:18: style: The function 'isOpened' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool isOpened() const;
                 ^
modules/videoio/src/precomp.hpp:189:22: note: Virtual function in base class
        virtual bool isOpened() const = 0;
                     ^
modules/videoio/src/cap_mfx_writer.hpp:25:18: note: Function in derived class
    virtual bool isOpened() const;
                 ^
modules/videoio/src/cap_mjpeg_decoder.cpp:162:5: style: Class 'MjpegInputStream' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    MjpegInputStream(const String& filename);
    ^
modules/videoio/src/cap_mjpeg_decoder.cpp:699:5: style: Class 'MotionJpegCapture' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    MotionJpegCapture(const String&);
    ^
modules/videoio/src/cap_mjpeg_decoder.cpp:693:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:174:24: note: Virtual function in base class
        virtual double getProperty(int) const { return 0; }
                       ^
modules/videoio/src/cap_mjpeg_decoder.cpp:693:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_mjpeg_decoder.cpp:694:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:175:22: note: Virtual function in base class
        virtual bool setProperty(int, double) { return false; }
                     ^
modules/videoio/src/cap_mjpeg_decoder.cpp:694:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_mjpeg_decoder.cpp:695:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:176:22: note: Virtual function in base class
        virtual bool grabFrame() = 0;
                     ^
modules/videoio/src/cap_mjpeg_decoder.cpp:695:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_mjpeg_decoder.cpp:696:18: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool retrieveFrame(int, OutputArray);
                 ^
modules/videoio/src/precomp.hpp:177:22: note: Virtual function in base class
        virtual bool retrieveFrame(int, OutputArray) = 0;
                     ^
modules/videoio/src/cap_mjpeg_decoder.cpp:696:18: note: Function in derived class
    virtual bool retrieveFrame(int, OutputArray);
                 ^
modules/videoio/src/cap_mjpeg_decoder.cpp:697:18: style: The function 'isOpened' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool isOpened() const;
                 ^
modules/videoio/src/precomp.hpp:178:22: note: Virtual function in base class
        virtual bool isOpened() const = 0;
                     ^
modules/videoio/src/cap_mjpeg_decoder.cpp:697:18: note: Function in derived class
    virtual bool isOpened() const;
                 ^
modules/videoio/src/cap_mjpeg_decoder.cpp:698:17: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getCaptureDomain() { return CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                ^
modules/videoio/src/precomp.hpp:179:21: note: Virtual function in base class
        virtual int getCaptureDomain() { return CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                    ^
modules/videoio/src/cap_mjpeg_decoder.cpp:698:17: note: Function in derived class
    virtual int getCaptureDomain() { return CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                ^
modules/videoio/src/cap_mjpeg_decoder.cpp:409:51: style: Parameter 'in_str' can be declared with const [constParameter]
void AviMjpegStream::printError(MjpegInputStream& in_str, RiffList& list, uint32_t expected_fourcc)
                                                  ^
modules/videoio/src/cap_mjpeg_decoder.cpp:409:69: style: Parameter 'list' can be declared with const [constParameter]
void AviMjpegStream::printError(MjpegInputStream& in_str, RiffList& list, uint32_t expected_fourcc)
                                                                    ^
modules/videoio/src/cap_mjpeg_decoder.cpp:425:51: style: Parameter 'in_str' can be declared with const [constParameter]
void AviMjpegStream::printError(MjpegInputStream& in_str, RiffChunk& chunk, uint32_t expected_fourcc)
                                                  ^
modules/videoio/src/cap_mjpeg_decoder.cpp:425:70: style: Parameter 'chunk' can be declared with const [constParameter]
void AviMjpegStream::printError(MjpegInputStream& in_str, RiffChunk& chunk, uint32_t expected_fourcc)
                                                                     ^
modules/videoio/src/cap_mjpeg_decoder.cpp:461:12: error: Uninitialized struct member: idx1.ckid [uninitStructMember]
        if(idx1.ckid == m_stream_id)
           ^
modules/videoio/src/cap_mjpeg_decoder.cpp:463:52: error: Uninitialized struct member: idx1.dwChunkOffset [uninitStructMember]
            uint64_t absolute_pos = m_movi_start + idx1.dwChunkOffset;
                                                   ^
modules/videoio/src/cap_mjpeg_decoder.cpp:495:12: error: Uninitialized struct member: strm_hdr.fccType [uninitStructMember]
        if(strm_hdr.fccType == VIDS_CC && strm_hdr.fccHandler == MJPG_CC)
           ^
modules/videoio/src/cap_mjpeg_decoder.cpp:503:49: error: Uninitialized struct member: strm_hdr.dwScale [uninitStructMember]
                m_fps = double(strm_hdr.dwRate)/strm_hdr.dwScale;
                                                ^
modules/videoio/src/cap_mjpeg_decoder.cpp:554:35: error: Uninitialized struct member: avi_hdr.dwFlags [uninitStructMember]
            m_is_indx_present = ((avi_hdr.dwFlags & 0x10) != 0);
                                  ^
modules/videoio/src/cap_mjpeg_decoder.cpp:555:39: error: Uninitialized struct member: avi_hdr.dwStreams [uninitStructMember]
            DWORD number_of_streams = avi_hdr.dwStreams;
                                      ^
modules/videoio/src/cap_mjpeg_decoder.cpp:557:23: error: Uninitialized struct member: avi_hdr.dwWidth [uninitStructMember]
            m_width = avi_hdr.dwWidth;
                      ^
modules/videoio/src/cap_mjpeg_decoder.cpp:558:24: error: Uninitialized struct member: avi_hdr.dwHeight [uninitStructMember]
            m_height = avi_hdr.dwHeight;
                       ^
modules/videoio/src/cap_mjpeg_decoder.cpp:571:40: error: Uninitialized struct member: strl_list.m_size [uninitStructMember]
                    next_strl_list += (strl_list.m_size - 4);
                                       ^
modules/videoio/src/cap_mjpeg_decoder.cpp:599:23: error: Uninitialized struct member: hdrl_list.m_size [uninitStructMember]
        next_list += (hdrl_list.m_size - 4);
                      ^
modules/videoio/src/cap_mjpeg_decoder.cpp:613:31: error: Uninitialized struct member: some_list.m_size [uninitStructMember]
                next_list += (some_list.m_size - 4);
                              ^
modules/videoio/src/cap_mjpeg_decoder.cpp:645:61: error: Uninitialized struct member: index_chunk.m_size [uninitStructMember]
                        is_index_found = parseIndex(in_str, index_chunk.m_size, in_frame_list);
                                                            ^
modules/videoio/src/cap_mjpeg_decoder.cpp:791:20: error: Uninitialized struct member: chunk.m_size [uninitStructMember]
    result.reserve(chunk.m_size);
                   ^
modules/videoio/src/cap_mjpeg_decoder.cpp:889:27: error: Uninitialized struct member: riff_list.m_size [uninitStructMember]
            next_riff += (riff_list.m_size - 4);
                          ^
modules/videoio/src/cap_mjpeg_decoder.cpp:112:19: style: struct member 'Anonymous0::left' is never used. [unusedStructMember]
        short int left;
                  ^
modules/videoio/src/cap_mjpeg_decoder.cpp:113:19: style: struct member 'Anonymous0::top' is never used. [unusedStructMember]
        short int top;
                  ^
modules/videoio/src/cap_mjpeg_decoder.cpp:114:19: style: struct member 'Anonymous0::right' is never used. [unusedStructMember]
        short int right;
                  ^
modules/videoio/src/cap_mjpeg_decoder.cpp:115:19: style: struct member 'Anonymous0::bottom' is never used. [unusedStructMember]
        short int bottom;
                  ^
modules/videoio/src/cap_mjpeg_decoder.cpp:489:33: style: Variable 'next_strl_list' is assigned a value that is never used. [unreadVariable]
        uint64_t next_strl_list = in_str.tellg();
                                ^
modules/videoio/src/cap_mjpeg_decoder.cpp:490:24: style: Variable 'next_strl_list' is assigned a value that is never used. [unreadVariable]
        next_strl_list += strh.m_size;
                       ^
modules/videoio/src/cap_mjpeg_encoder.cpp:1724:19: warning: Member variable 'MjpegEncoder::in_data' is not assigned a value in 'MjpegEncoder::operator='. [operatorEqVarError]
    MjpegEncoder& operator=( const MjpegEncoder & ) { return *this; }
                  ^
modules/videoio/src/cap_mjpeg_encoder.cpp:1724:19: warning: Member variable 'MjpegEncoder::cat_table' is not assigned a value in 'MjpegEncoder::operator='. [operatorEqVarError]
    MjpegEncoder& operator=( const MjpegEncoder & ) { return *this; }
                  ^
modules/videoio/src/cap_mjpeg_encoder.cpp:1724:19: warning: Member variable 'MjpegEncoder::stripes_count' is not assigned a value in 'MjpegEncoder::operator='. [operatorEqVarError]
    MjpegEncoder& operator=( const MjpegEncoder & ) { return *this; }
                  ^
modules/videoio/src/cap_mjpeg_encoder.cpp:191:36: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
        m_current[1] = (uchar)(val >> 8);
                                   ^
modules/videoio/src/cap_mjpeg_encoder.cpp:192:36: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
        m_current[2] = (uchar)(val >> 16);
                                   ^
modules/videoio/src/cap_mjpeg_encoder.cpp:193:36: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
        m_current[3] = (uchar)(val >> 24);
                                   ^
modules/videoio/src/cap_mjpeg_encoder.cpp:1558:23: style: Variable 'code' is assigned a value that is never used. [unreadVariable]
        unsigned code = 0;
                      ^
modules/videoio/src/cap_msmf.cpp:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
modules/videoio/src/cap_msmf.cpp:302:5: error: There is an unknown macro here somewhere. Configuration is required. If STDMETHODIMP_ is a macro then please configure it. [unknownMacro]
    STDMETHODIMP_(ULONG) AddRef();
    ^
modules/videoio/src/cap_msmf.hpp:366:0: error: failed to expand 'WRL_METHOD', Invalid ## usage when expanding 'WRL_METHOD'. [preprocessorErrorDirective]
#define WRL_METHOD(obj, method, ret, hr, ...) hr = obj->##method(__VA_ARGS__, &ret);
^
modules/videoio/src/cap_msmf.hpp:273:0: error: failed to expand 'WRL_PROP_GET', Invalid ## usage when expanding 'WRL_PROP_GET'. [preprocessorErrorDirective]
#define WRL_PROP_GET(obj, prop, arg, hr) arg = obj->##prop;\
^
modules/videoio/src/cap_openni.cpp:261:9: style: Class 'ApproximateSynchronizer' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        ApproximateSynchronizer( ApproximateSyncGrabber& _approxSyncGrabber ) :
        ^
modules/videoio/src/cap_openni.cpp:442:5: style: Class 'CvCapture_OpenNI' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CvCapture_OpenNI(const char * filename);
    ^
modules/videoio/src/cap_openni.cpp:265:22: style: The function 'isSpinContinue' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual bool isSpinContinue() const
                     ^
modules/videoio/src/cap_openni.cpp:188:22: note: Virtual function in base class
        virtual bool isSpinContinue() const = 0;
                     ^
modules/videoio/src/cap_openni.cpp:265:22: note: Function in derived class
        virtual bool isSpinContinue() const
                     ^
modules/videoio/src/cap_openni.cpp:272:29: style: The function 'pushDepthMetaData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual inline void pushDepthMetaData( xn::DepthMetaData& depthMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:189:22: note: Virtual function in base class
        virtual void pushDepthMetaData( xn::DepthMetaData& depthMetaData ) = 0;
                     ^
modules/videoio/src/cap_openni.cpp:272:29: note: Function in derived class
        virtual inline void pushDepthMetaData( xn::DepthMetaData& depthMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:278:29: style: The function 'pushImageMetaData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual inline void pushImageMetaData( xn::ImageMetaData& imageMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:190:22: note: Virtual function in base class
        virtual void pushImageMetaData( xn::ImageMetaData& imageMetaData ) = 0;
                     ^
modules/videoio/src/cap_openni.cpp:278:29: note: Function in derived class
        virtual inline void pushImageMetaData( xn::ImageMetaData& imageMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:284:29: style: The function 'popDepthMetaData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual inline bool popDepthMetaData( xn::DepthMetaData& depthMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:191:22: note: Virtual function in base class
        virtual bool popDepthMetaData( xn::DepthMetaData& depthMetaData ) = 0;
                     ^
modules/videoio/src/cap_openni.cpp:284:29: note: Function in derived class
        virtual inline bool popDepthMetaData( xn::DepthMetaData& depthMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:293:29: style: The function 'popImageMetaData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual inline bool popImageMetaData( xn::ImageMetaData& imageMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:192:22: note: Virtual function in base class
        virtual bool popImageMetaData( xn::ImageMetaData& imageMetaData ) = 0;
                     ^
modules/videoio/src/cap_openni.cpp:293:29: note: Function in derived class
        virtual inline bool popImageMetaData( xn::ImageMetaData& imageMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:445:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_openni.cpp:445:20: note: Function in derived class
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/cap_openni.cpp:446:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int probIdx, double propVal);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_openni.cpp:446:18: note: Function in derived class
    virtual bool setProperty(int probIdx, double propVal);
                 ^
modules/videoio/src/cap_openni.cpp:447:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_openni.cpp:447:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_openni.cpp:448:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int outputType);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_openni.cpp:448:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int outputType);
                      ^
modules/videoio/src/cap_openni.cpp:267:17: style: Local variable 'maxBufferSize' shadows outer variable [shadowVariable]
            int maxBufferSize = approxSyncGrabber.getMaxBufferSize();
                ^
modules/videoio/src/cap_openni.cpp:175:9: note: Shadowed declaration
    int maxBufferSize;
        ^
modules/videoio/src/cap_openni.cpp:267:17: note: Shadow variable
            int maxBufferSize = approxSyncGrabber.getMaxBufferSize();
                ^
modules/videoio/src/cap_openni.cpp:313:9: style: Class 'TBBApproximateSynchronizer' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        TBBApproximateSynchronizer( ApproximateSyncGrabber& _approxSyncGrabber ) :
        ^
modules/videoio/src/cap_openni.cpp:392:9: style: Class 'TBBApproximateSynchronizerTask' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        TBBApproximateSynchronizerTask( ApproximateSyncGrabber& approxSyncGrabber ) :
        ^
modules/videoio/src/cap_openni.cpp:329:29: style: The function 'isSpinContinue' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual inline bool isSpinContinue() const { return true; }
                            ^
modules/videoio/src/cap_openni.cpp:188:22: note: Virtual function in base class
        virtual bool isSpinContinue() const = 0;
                     ^
modules/videoio/src/cap_openni.cpp:329:29: note: Function in derived class
        virtual inline bool isSpinContinue() const { return true; }
                            ^
modules/videoio/src/cap_openni.cpp:331:29: style: The function 'pushDepthMetaData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual inline void pushDepthMetaData( xn::DepthMetaData& depthMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:189:22: note: Virtual function in base class
        virtual void pushDepthMetaData( xn::DepthMetaData& depthMetaData ) = 0;
                     ^
modules/videoio/src/cap_openni.cpp:331:29: note: Function in derived class
        virtual inline void pushDepthMetaData( xn::DepthMetaData& depthMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:349:29: style: The function 'pushImageMetaData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual inline void pushImageMetaData( xn::ImageMetaData& imageMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:190:22: note: Virtual function in base class
        virtual void pushImageMetaData( xn::ImageMetaData& imageMetaData ) = 0;
                     ^
modules/videoio/src/cap_openni.cpp:349:29: note: Function in derived class
        virtual inline void pushImageMetaData( xn::ImageMetaData& imageMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:367:29: style: The function 'popDepthMetaData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual inline bool popDepthMetaData( xn::DepthMetaData& depthMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:191:22: note: Virtual function in base class
        virtual bool popDepthMetaData( xn::DepthMetaData& depthMetaData ) = 0;
                     ^
modules/videoio/src/cap_openni.cpp:367:29: note: Function in derived class
        virtual inline bool popDepthMetaData( xn::DepthMetaData& depthMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:375:29: style: The function 'popImageMetaData' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual inline bool popImageMetaData( xn::ImageMetaData& imageMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:192:22: note: Virtual function in base class
        virtual bool popImageMetaData( xn::ImageMetaData& imageMetaData ) = 0;
                     ^
modules/videoio/src/cap_openni.cpp:375:29: note: Function in derived class
        virtual inline bool popImageMetaData( xn::ImageMetaData& imageMetaData )
                            ^
modules/videoio/src/cap_openni.cpp:321:17: style: Local variable 'maxBufferSize' shadows outer variable [shadowVariable]
            int maxBufferSize = approxSyncGrabber.getMaxBufferSize();
                ^
modules/videoio/src/cap_openni.cpp:175:9: note: Shadowed declaration
    int maxBufferSize;
        ^
modules/videoio/src/cap_openni.cpp:321:17: note: Shadow variable
            int maxBufferSize = approxSyncGrabber.getMaxBufferSize();
                ^
modules/videoio/src/cap_openni.cpp:392:65: style: Parameter 'approxSyncGrabber' can be declared with const [constParameter]
        TBBApproximateSynchronizerTask( ApproximateSyncGrabber& approxSyncGrabber ) :
                                                                ^
modules/videoio/src/cap_openni2.cpp:90:5: style: Class 'CvCapture_OpenNI2' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CvCapture_OpenNI2(const char * filename);
    ^
modules/videoio/src/cap_openni2.cpp:93:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_openni2.cpp:93:20: note: Function in derived class
    virtual double getProperty(int propIdx) const;
                   ^
modules/videoio/src/cap_openni2.cpp:94:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int probIdx, double propVal);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_openni2.cpp:94:18: note: Function in derived class
    virtual bool setProperty(int probIdx, double propVal);
                 ^
modules/videoio/src/cap_openni2.cpp:95:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_openni2.cpp:95:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_openni2.cpp:96:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int outputType);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_openni2.cpp:96:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int outputType);
                      ^
modules/videoio/src/cap_openni2.cpp:502:19: warning: Variable 'propValue' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]
        propValue = isMirroring ? 1.0 : 0.0;
                  ^
modules/videoio/src/cap_openni2.cpp:496:19: note: $symbol is assigned
        propValue = const_cast<CvCapture_OpenNI2 *>(this)->device.getDepthColorSyncEnabled();
                  ^
modules/videoio/src/cap_openni2.cpp:502:19: note: $symbol is overwritten
        propValue = isMirroring ? 1.0 : 0.0;
                  ^
modules/videoio/src/cap_openni2.cpp:271:24: style: The scope of the variable 'stream_names' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    static const char* stream_names[CV_MAX_NUM_STREAMS] = {
                       ^
modules/videoio/src/cap_pvapi.cpp:83:18: warning: Virtual function 'close' is called from destructor '~CvCaptureCAM_PvAPI()' at line 79. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_pvapi.cpp:79:9: note: Calling close
        close();
        ^
modules/videoio/src/cap_pvapi.cpp:83:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_pvapi.cpp:84:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_pvapi.cpp:84:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_pvapi.cpp:85:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_pvapi.cpp:85:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_pvapi.cpp:86:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_pvapi.cpp:86:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_pvapi.cpp:87:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_pvapi.cpp:87:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/cap_pvapi.cpp:88:17: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getCaptureDomain()
                ^
modules/videoio/src/precomp.hpp:93:17: note: Virtual function in base class
    virtual int getCaptureDomain() { return cv::CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                ^
modules/videoio/src/cap_pvapi.cpp:88:17: note: Function in derived class
    virtual int getCaptureDomain()
                ^
modules/videoio/src/cap_pvapi.cpp:250:14: style: The scope of the variable 'mIp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        char mIp[11];
             ^
modules/videoio/src/cap_qt.cpp:1442:18: warning: Virtual function 'close' is called from destructor '~CvCapture_QT_Movie_CPP()' at line 1439. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_qt.cpp:1439:41: note: Calling close
    virtual ~CvCapture_QT_Movie_CPP() { close(); }
                                        ^
modules/videoio/src/cap_qt.cpp:1442:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_qt.cpp:1511:18: warning: Virtual function 'close' is called from destructor '~CvCapture_QT_Cam_CPP()' at line 1508. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_qt.cpp:1508:39: note: Calling close
    virtual ~CvCapture_QT_Cam_CPP() { close(); }
                                      ^
modules/videoio/src/cap_qt.cpp:1511:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_qt.cpp:1580:18: warning: Virtual function 'close' is called from destructor '~CvVideoWriter_QT_CPP()' at line 1576. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_qt.cpp:1576:39: note: Calling close
    virtual ~CvVideoWriter_QT_CPP() { close(); }
                                      ^
modules/videoio/src/cap_qt.cpp:1580:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_qt.cpp:1444:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_qt.cpp:1444:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_qt.cpp:1445:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_qt.cpp:1445:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_qt.cpp:1446:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_qt.cpp:1446:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_qt.cpp:1447:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_qt.cpp:1447:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/cap_qt.cpp:1448:17: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getCaptureDomain() { return CV_CAP_QT; } // Return the type of the capture object: CV_CAP_VFW, etc...
                ^
modules/videoio/src/precomp.hpp:93:17: note: Virtual function in base class
    virtual int getCaptureDomain() { return cv::CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                ^
modules/videoio/src/cap_qt.cpp:1448:17: note: Function in derived class
    virtual int getCaptureDomain() { return CV_CAP_QT; } // Return the type of the capture object: CV_CAP_VFW, etc...
                ^
modules/videoio/src/cap_qt.cpp:1513:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_qt.cpp:1513:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_qt.cpp:1514:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_qt.cpp:1514:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_qt.cpp:1515:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_qt.cpp:1515:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_qt.cpp:1516:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_qt.cpp:1516:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/cap_qt.cpp:1517:17: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getCaptureDomain() { return CV_CAP_QT; } // Return the type of the capture object: CV_CAP_VFW, etc...
                ^
modules/videoio/src/precomp.hpp:93:17: note: Virtual function in base class
    virtual int getCaptureDomain() { return cv::CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                ^
modules/videoio/src/cap_qt.cpp:1517:17: note: Function in derived class
    virtual int getCaptureDomain() { return CV_CAP_QT; } // Return the type of the capture object: CV_CAP_VFW, etc...
                ^
modules/videoio/src/cap_qt.cpp:1581:18: style: The function 'writeFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool writeFrame( const IplImage* );
                 ^
modules/videoio/src/precomp.hpp:101:18: note: Virtual function in base class
    virtual bool writeFrame(const IplImage*) { return false; }
                 ^
modules/videoio/src/cap_qt.cpp:1581:18: note: Function in derived class
    virtual bool writeFrame( const IplImage* );
                 ^
modules/videoio/src/cap_qt.cpp:963:12: style: Variable 'result' is reassigned a value before the old one has been used. [redundantAssignment]
    result = SGSetGWorld (capture->grabber, capture->gworld, 0);
           ^
modules/videoio/src/cap_qt.cpp:962:12: note: result is assigned
    result = QTNewGWorld (& (capture->gworld), k32ARGBPixelFormat, & (capture->bounds), 0, 0, 0);
           ^
modules/videoio/src/cap_qt.cpp:963:12: note: result is overwritten
    result = SGSetGWorld (capture->grabber, capture->gworld, 0);
           ^
modules/videoio/src/cap_qt.cpp:1160:12: style: Redundant initialization for 'retval'. The initialized value is overwritten before it is read. [redundantInitialization]
    retval = CVPixelBufferLockBaseAddress( pixel_buffer_ref, 0 );
           ^
modules/videoio/src/cap_qt.cpp:1144:21: note: retval is initialized
    CVReturn retval =
                    ^
modules/videoio/src/cap_qt.cpp:1160:12: note: retval is overwritten
    retval = CVPixelBufferLockBaseAddress( pixel_buffer_ref, 0 );
           ^
modules/videoio/src/cap_qt.cpp:1168:12: style: Variable 'retval' is reassigned a value before the old one has been used. [redundantAssignment]
    retval = CVPixelBufferUnlockBaseAddress( pixel_buffer_ref, 0 );
           ^
modules/videoio/src/cap_qt.cpp:1160:12: note: retval is assigned
    retval = CVPixelBufferLockBaseAddress( pixel_buffer_ref, 0 );
           ^
modules/videoio/src/cap_qt.cpp:1168:12: note: retval is overwritten
    retval = CVPixelBufferUnlockBaseAddress( pixel_buffer_ref, 0 );
           ^
modules/videoio/src/cap_qt.cpp:100:16: style: Local variable 'did_enter_movies' shadows outer variable [shadowVariable]
    static int did_enter_movies = 0;
               ^
modules/videoio/src/cap_qt.cpp:67:12: note: Shadowed declaration
static int did_enter_movies = 0;
           ^
modules/videoio/src/cap_qt.cpp:100:16: note: Shadow variable
    static int did_enter_movies = 0;
               ^
modules/videoio/src/cap_qt.cpp:347:41: style: Variable 'myErr' is assigned a value that is never used. [unreadVariable]
                OSErr        myErr      = noErr;
                                        ^
modules/videoio/src/cap_qt.cpp:403:42: style: Variable 'myErr' is assigned a value that is never used. [unreadVariable]
                OSErr        myErr       = noErr;
                                         ^
modules/videoio/src/cap_qt.cpp:1082:34: style: Variable 'myErr' is assigned a value that is never used. [unreadVariable]
    OSErr         myErr          = noErr;
                                 ^
modules/videoio/src/cap_qt.cpp:1168:12: style: Variable 'retval' is assigned a value that is never used. [unreadVariable]
    retval = CVPixelBufferUnlockBaseAddress( pixel_buffer_ref, 0 );
           ^
modules/videoio/src/cap_qt.cpp:1177:21: style: Variable 'status' is assigned a value that is never used. [unreadVariable]
    OSStatus status =
                    ^
modules/videoio/src/cap_qt.cpp:699:37: style: Local variable 'nameBuffer' shadows outer variable [shadowVariable]
                            Str255  nameBuffer;
                                    ^
modules/videoio/src/cap_qt.cpp:662:39: note: Shadowed declaration
                char                  nameBuffer [255];
                                      ^
modules/videoio/src/cap_qt.cpp:699:37: note: Shadow variable
                            Str255  nameBuffer;
                                    ^
modules/videoio/src/cap_unicap.cpp:59:3: warning: Member variable 'CvCapture_Unicap::desired_device' is not initialized in the constructor. [uninitMemberVar]
  CvCapture_Unicap() { init(); }
  ^
modules/videoio/src/cap_unicap.cpp:63:16: warning: Virtual function 'close' is called from destructor '~CvCapture_Unicap()' at line 60. Dynamic binding is not used. [virtualCallInConstructor]
  virtual void close();
               ^
modules/videoio/src/cap_unicap.cpp:60:33: note: Calling close
  virtual ~CvCapture_Unicap() { close(); }
                                ^
modules/videoio/src/cap_unicap.cpp:63:16: note: close is a virtual function
  virtual void close();
               ^
modules/videoio/src/cap_unicap.cpp:65:18: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual double getProperty(int) const;
                 ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_unicap.cpp:65:18: note: Function in derived class
  virtual double getProperty(int) const;
                 ^
modules/videoio/src/cap_unicap.cpp:66:16: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool setProperty(int, double);
               ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_unicap.cpp:66:16: note: Function in derived class
  virtual bool setProperty(int, double);
               ^
modules/videoio/src/cap_unicap.cpp:67:16: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual bool grabFrame();
               ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_unicap.cpp:67:16: note: Function in derived class
  virtual bool grabFrame();
               ^
modules/videoio/src/cap_unicap.cpp:68:21: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual IplImage* retrieveFrame(int);
                    ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_unicap.cpp:68:21: note: Function in derived class
  virtual IplImage* retrieveFrame(int);
                    ^
modules/videoio/src/cap_unicap.cpp:69:15: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
  virtual int getCaptureDomain() { return CV_CAP_UNICAP; } // Return the type of the capture object: CV_CAP_VFW, etc...
              ^
modules/videoio/src/precomp.hpp:93:17: note: Virtual function in base class
    virtual int getCaptureDomain() { return cv::CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                ^
modules/videoio/src/cap_unicap.cpp:69:15: note: Function in derived class
  virtual int getCaptureDomain() { return CV_CAP_UNICAP; } // Return the type of the capture object: CV_CAP_VFW, etc...
              ^
modules/videoio/src/cap_unicap.cpp:151:7: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  int i;
      ^
modules/videoio/src/cap_vfw.cpp:100:18: warning: Virtual function 'close' is called from destructor '~CvCaptureAVI_VFW()' at line 95. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_vfw.cpp:95:9: note: Calling close
        close();
        ^
modules/videoio/src/cap_vfw.cpp:100:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_vfw.cpp:327:18: warning: Virtual function 'close' is called from destructor '~CvCaptureCAM_VFW()' at line 322. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_vfw.cpp:322:9: note: Calling close
        close();
        ^
modules/videoio/src/cap_vfw.cpp:327:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_vfw.cpp:697:18: warning: Virtual function 'close' is called from destructor '~CvVideoWriter_VFW()' at line 691. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_vfw.cpp:691:9: note: Calling close
        close();
        ^
modules/videoio/src/cap_vfw.cpp:697:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_vfw.cpp:102:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_vfw.cpp:102:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_vfw.cpp:103:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_vfw.cpp:103:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_vfw.cpp:104:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_vfw.cpp:104:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_vfw.cpp:105:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_vfw.cpp:105:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/cap_vfw.cpp:106:17: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getCaptureDomain() { return CV_CAP_VFW; } // Return the type of the capture object: CV_CAP_VFW, etc...
                ^
modules/videoio/src/precomp.hpp:93:17: note: Virtual function in base class
    virtual int getCaptureDomain() { return cv::CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                ^
modules/videoio/src/cap_vfw.cpp:106:17: note: Function in derived class
    virtual int getCaptureDomain() { return CV_CAP_VFW; } // Return the type of the capture object: CV_CAP_VFW, etc...
                ^
modules/videoio/src/cap_vfw.cpp:328:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_vfw.cpp:328:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_vfw.cpp:329:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_vfw.cpp:329:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_vfw.cpp:330:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_vfw.cpp:330:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_vfw.cpp:331:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_vfw.cpp:331:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/cap_vfw.cpp:332:17: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getCaptureDomain() { return CV_CAP_VFW; } // Return the type of the capture object: CV_CAP_VFW, etc...
                ^
modules/videoio/src/precomp.hpp:93:17: note: Virtual function in base class
    virtual int getCaptureDomain() { return cv::CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                ^
modules/videoio/src/cap_vfw.cpp:332:17: note: Function in derived class
    virtual int getCaptureDomain() { return CV_CAP_VFW; } // Return the type of the capture object: CV_CAP_VFW, etc...
                ^
modules/videoio/src/cap_vfw.cpp:698:18: style: The function 'writeFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool writeFrame( const IplImage* );
                 ^
modules/videoio/src/precomp.hpp:101:18: note: Virtual function in base class
    virtual bool writeFrame(const IplImage*) { return false; }
                 ^
modules/videoio/src/cap_vfw.cpp:698:18: note: Function in derived class
    virtual bool writeFrame( const IplImage* );
                 ^
modules/videoio/src/cap_vfw.cpp:379:15: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    capture = (CvCaptureCAM_VFW*)capGetUserData(hWnd);
              ^
modules/videoio/src/cap_vfw.cpp:813:21: warning: Redundant assignment of 'fps' to itself. [selfAssignment]
                fps = fps;
                    ^
modules/videoio/src/cap_winrt/MFIncludes.hpp:166:5: information: The code 'class MediaSample sealed {' is not handled. You can use -I or --include to add handling of this code. [class_X_Y]
ref class MediaSample sealed
    ^
modules/videoio/src/cap_winrt/MediaStreamSink.hpp:29:1: information: The code 'class MediaStreamSink WrlSealed :' is not handled. You can use -I or --include to add handling of this code. [class_X_Y]
class MediaStreamSink WrlSealed :
^
modules/videoio/src/cap_winrt/MediaSink.hpp:33:1: information: The code 'class MediaSink WrlSealed :' is not handled. You can use -I or --include to add handling of this code. [class_X_Y]
class MediaSink WrlSealed
^
modules/videoio/src/cap_winrt/CaptureFrameGrabber.hpp:38:5: information: The code 'class CaptureFrameGrabber sealed {' is not handled. You can use -I or --include to add handling of this code. [class_X_Y]
ref class CaptureFrameGrabber sealed
    ^
modules/videoio/src/cap_winrt/MediaSink.hpp:82:19: style: Variable 'lock' is assigned a value that is never used. [unreadVariable]
        auto lock = _lock.LockExclusive();
                  ^
modules/videoio/src/cap_winrt/MediaSink.hpp:91:19: style: Variable 'lock' is assigned a value that is never used. [unreadVariable]
        auto lock = _lock.LockExclusive();
                  ^
modules/videoio/src/cap_winrt/MediaSink.hpp:100:19: style: Variable 'lock' is assigned a value that is never used. [unreadVariable]
        auto lock = _lock.LockExclusive();
                  ^
modules/videoio/src/cap_winrt/MediaSink.hpp:109:19: style: Variable 'lock' is assigned a value that is never used. [unreadVariable]
        auto lock = _lock.LockExclusive();
                  ^
modules/videoio/src/cap_winrt/CaptureFrameGrabber.cpp:142:15: style: Variable 'lock' is assigned a value that is never used. [unreadVariable]
    auto lock = _lock.LockExclusive();
              ^
modules/videoio/src/cap_winrt/CaptureFrameGrabber.cpp:162:19: style: Variable 'lock' is assigned a value that is never used. [unreadVariable]
        auto lock = _lock.LockExclusive();
                  ^
modules/videoio/src/cap_winrt/MediaStreamSink.cpp:100:15: style: Variable 'lock' is assigned a value that is never used. [unreadVariable]
    auto lock = _lock.LockExclusive();
              ^
modules/videoio/src/cap_winrt/MediaStreamSink.cpp:331:15: style: Variable 'lock' is assigned a value that is never used. [unreadVariable]
    auto lock = _lock.LockExclusive();
              ^
modules/videoio/src/cap_winrt/MediaStreamSink.cpp:342:15: style: Variable 'lock' is assigned a value that is never used. [unreadVariable]
    auto lock = _lock.LockExclusive();
              ^
modules/videoio/src/cap_winrt_capture.hpp:48:9: warning: Member variable 'VideoCapture_WinRT::bytesPerPixel' is not initialized in the constructor. [uninitMemberVar]
        VideoCapture_WinRT() : started(false) {}
        ^
modules/videoio/src/cap_winrt_capture.hpp:48:9: warning: Member variable 'VideoCapture_WinRT::frameCurrent' is not initialized in the constructor. [uninitMemberVar]
        VideoCapture_WinRT() : started(false) {}
        ^
modules/videoio/src/cap_winrt_bridge.hpp:88:5: warning: Member variable 'VideoioBridge::frontInputPtr' is not initialized in the constructor. [uninitMemberVarPrivate]
    VideoioBridge() {
    ^
modules/videoio/src/cap_winrt_bridge.hpp:88:5: warning: Member variable 'VideoioBridge::backInputPtr' is not initialized in the constructor. [uninitMemberVarPrivate]
    VideoioBridge() {
    ^
modules/videoio/src/cap_winrt_bridge.hpp:92:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'deviceReady' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        deviceReady = false;
        ^
modules/videoio/src/cap_winrt_bridge.hpp:93:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'bIsFrameNew' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        bIsFrameNew = false;
        ^
modules/videoio/src/cap_winrt_bridge.hpp:95:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'frameCounter' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        frameCounter = 0;
        ^
modules/videoio/src/cap_winrt_capture.hpp:49:9: style: Class 'VideoCapture_WinRT' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        VideoCapture_WinRT(int device);
        ^
modules/videoio/src/cap_winrt_capture.hpp:54:22: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual bool setProperty(int, double);
                     ^
modules/videoio/src/precomp.hpp:175:22: note: Virtual function in base class
        virtual bool setProperty(int, double) { return false; }
                     ^
modules/videoio/src/cap_winrt_capture.hpp:54:22: note: Function in derived class
        virtual bool setProperty(int, double);
                     ^
modules/videoio/src/cap_winrt_capture.hpp:55:22: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual bool grabFrame();
                     ^
modules/videoio/src/precomp.hpp:176:22: note: Virtual function in base class
        virtual bool grabFrame() = 0;
                     ^
modules/videoio/src/cap_winrt_capture.hpp:55:22: note: Function in derived class
        virtual bool grabFrame();
                     ^
modules/videoio/src/cap_winrt_capture.hpp:59:21: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual int getCaptureDomain() { return CAP_WINRT; }
                    ^
modules/videoio/src/precomp.hpp:179:21: note: Virtual function in base class
        virtual int getCaptureDomain() { return CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                    ^
modules/videoio/src/cap_winrt_capture.hpp:59:21: note: Function in derived class
        virtual int getCaptureDomain() { return CAP_WINRT; }
                    ^
modules/videoio/src/cap_winrt_capture.hpp:61:22: style: The function 'isOpened' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual bool isOpened() const;
                     ^
modules/videoio/src/precomp.hpp:178:22: note: Virtual function in base class
        virtual bool isOpened() const = 0;
                     ^
modules/videoio/src/cap_winrt_capture.hpp:61:22: note: Function in derived class
        virtual bool isOpened() const;
                     ^
modules/videoio/src/cap_winrt_capture.cpp:123:25: warning: Member variable 'VideoCapture_WinRT::bytesPerPixel' is not initialized in the constructor. [uninitMemberVar]
    VideoCapture_WinRT::VideoCapture_WinRT(int device) : started(false)
                        ^
modules/videoio/src/cap_winrt_capture.cpp:123:25: warning: Member variable 'VideoCapture_WinRT::frameCurrent' is not initialized in the constructor. [uninitMemberVar]
    VideoCapture_WinRT::VideoCapture_WinRT(int device) : started(false)
                        ^
modules/videoio/src/cap_winrt_video.cpp:63:8: warning: Member variable 'Video::bChooseDevice' is not initialized in the constructor. [uninitMemberVarPrivate]
Video::Video() {}
       ^
modules/videoio/src/cap_winrt_video.cpp:63:8: warning: Member variable 'Video::bVerbose' is not initialized in the constructor. [uninitMemberVarPrivate]
Video::Video() {}
       ^
modules/videoio/src/cap_winrt_video.cpp:63:8: warning: Member variable 'Video::bFlipImageX' is not initialized in the constructor. [uninitMemberVarPrivate]
Video::Video() {}
       ^
modules/videoio/src/cap_winrt_video.cpp:63:8: warning: Member variable 'Video::m_deviceID' is not initialized in the constructor. [uninitMemberVarPrivate]
Video::Video() {}
       ^
modules/videoio/src/cap_winrt_video.cpp:63:8: warning: Member variable 'Video::attemptFramerate' is not initialized in the constructor. [uninitMemberVarPrivate]
Video::Video() {}
       ^
modules/videoio/src/cap_winrt_video.cpp:63:8: warning: Member variable 'Video::width' is not initialized in the constructor. [uninitMemberVarPrivate]
Video::Video() {}
       ^
modules/videoio/src/cap_winrt_video.cpp:63:8: warning: Member variable 'Video::height' is not initialized in the constructor. [uninitMemberVarPrivate]
Video::Video() {}
       ^
modules/videoio/src/cap_winrt_video.cpp:63:8: warning: Member variable 'Video::bytesPerPixel' is not initialized in the constructor. [uninitMemberVarPrivate]
Video::Video() {}
       ^
modules/videoio/src/cap_winrt_video.hpp:53:10: style: Unused private function: 'Video::listDevices' [unusedPrivateFunction]
    bool listDevices();
         ^
modules/videoio/src/cap_ximea.cpp:22:18: warning: Virtual function 'close' is called from destructor '~CvCaptureCAM_XIMEA()' at line 18. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_ximea.cpp:18:37: note: Calling close
    virtual ~CvCaptureCAM_XIMEA() { close(); }
                                    ^
modules/videoio/src/cap_ximea.cpp:22:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_ximea.cpp:23:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_ximea.cpp:23:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_ximea.cpp:24:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_ximea.cpp:24:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_ximea.cpp:25:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_ximea.cpp:25:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_ximea.cpp:26:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_ximea.cpp:26:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/cap_ximea.cpp:27:17: style: The function 'getCaptureDomain' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int getCaptureDomain() { return CV_CAP_XIAPI; } // Return the type of the capture object: CV_CAP_VFW, etc...
                ^
modules/videoio/src/precomp.hpp:93:17: note: Virtual function in base class
    virtual int getCaptureDomain() { return cv::CAP_ANY; } // Return the type of the capture object: CAP_VFW, etc...
                ^
modules/videoio/src/cap_ximea.cpp:27:17: note: Function in derived class
    virtual int getCaptureDomain() { return CV_CAP_XIAPI; } // Return the type of the capture object: CV_CAP_VFW, etc...
                ^
modules/videoio/src/cap_ximea.cpp:95:15: style: Variable 'mvret' is assigned a value that is never used. [unreadVariable]
    if((mvret = xiOpenDevice( wIndex, &hmv)) != XI_OK)
              ^
modules/videoio/src/cap_xine.cpp:765:5: portability: Using memset() on struct which contains a floating point number. This is not portable because memset() sets each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined. Note: In case of an IEEE754-1985 compatible implementation setting all bits to zero results in the value 0.0. [memsetClassFloat]
    memset( capture, 0, sizeof ( CvCaptureAVI_XINE ) );
    ^
modules/videoio/src/cap_xine.cpp:787:18: warning: Virtual function 'close' is called from destructor '~CvCaptureAVI_XINE_CPP()' at line 784. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void close();
                 ^
modules/videoio/src/cap_xine.cpp:784:40: note: Calling close
    virtual ~CvCaptureAVI_XINE_CPP() { close(); }
                                       ^
modules/videoio/src/cap_xine.cpp:787:18: note: close is a virtual function
    virtual void close();
                 ^
modules/videoio/src/cap_xine.cpp:789:20: style: The function 'getProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/precomp.hpp:89:20: note: Virtual function in base class
    virtual double getProperty(int) const { return 0; }
                   ^
modules/videoio/src/cap_xine.cpp:789:20: note: Function in derived class
    virtual double getProperty(int) const;
                   ^
modules/videoio/src/cap_xine.cpp:790:18: style: The function 'setProperty' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/precomp.hpp:90:18: note: Virtual function in base class
    virtual bool setProperty(int, double) { return 0; }
                 ^
modules/videoio/src/cap_xine.cpp:790:18: note: Function in derived class
    virtual bool setProperty(int, double);
                 ^
modules/videoio/src/cap_xine.cpp:791:18: style: The function 'grabFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual bool grabFrame();
                 ^
modules/videoio/src/precomp.hpp:91:18: note: Virtual function in base class
    virtual bool grabFrame() { return true; }
                 ^
modules/videoio/src/cap_xine.cpp:791:18: note: Function in derived class
    virtual bool grabFrame();
                 ^
modules/videoio/src/cap_xine.cpp:792:23: style: The function 'retrieveFrame' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/precomp.hpp:92:23: note: Virtual function in base class
    virtual IplImage* retrieveFrame(int) { return 0; }
                      ^
modules/videoio/src/cap_xine.cpp:792:23: note: Function in derived class
    virtual IplImage* retrieveFrame(int);
                      ^
modules/videoio/src/cap_xine.cpp:102:9: style: The scope of the variable 'offset' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int offset;
        ^
modules/videoio/test/test_ffmpeg.cpp:268:5: style: Class 'WriteVideo_Invoker' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    WriteVideo_Invoker(const std::vector<VideoWriter*>& _writers) :
    ^
modules/videoio/test/test_video_io.cpp:59:5: warning: Member variable 'Videoio_Test_Base::apiPref' is not initialized in the constructor. [uninitMemberVar]
    Videoio_Test_Base() {}
    ^
modules/videoio/test/test_video_io.cpp:247:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'frame_size' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        frame_size = get<0>(GetParam());
        ^
modules/videoio/test/test_video_io.cpp:286:18: style: The function 'checkFrameContent' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void checkFrameContent(Mat & img, int idx)
                 ^
modules/videoio/test/test_video_io.cpp:61:18: note: Virtual function in base class
    virtual void checkFrameContent(Mat &, int) {}
                 ^
modules/videoio/test/test_video_io.cpp:286:18: note: Function in derived class
    virtual void checkFrameContent(Mat & img, int idx)
                 ^
modules/videoio/test/test_video_io.cpp:293:18: style: The function 'checkFrameCount' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void checkFrameCount(int &actual)
                 ^
modules/videoio/test/test_video_io.cpp:62:18: note: Virtual function in base class
    virtual void checkFrameCount(int &) {}
                 ^
modules/videoio/test/test_video_io.cpp:293:18: note: Function in derived class
    virtual void checkFrameCount(int &actual)
                 ^
modules/videostab/src/fast_marching.cpp:97:9: style: The scope of the variable 'l' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int l, r, smallest;
        ^
modules/videostab/src/fast_marching.cpp:97:12: style: The scope of the variable 'r' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int l, r, smallest;
           ^
modules/videostab/src/fast_marching.cpp:97:15: style: The scope of the variable 'smallest' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int l, r, smallest;
              ^
modules/videostab/src/frame_source.cpp:65:18: warning: Virtual function 'reset' is called from constructor 'VideoFileSourceImpl(const String&path,bool volatileFrame)' at line 63. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void reset()
                 ^
modules/videostab/src/frame_source.cpp:63:56: note: Calling reset
        : path_(path), volatileFrame_(volatileFrame) { reset(); }
                                                       ^
modules/videostab/src/frame_source.cpp:65:18: note: reset is a virtual function
    virtual void reset()
                 ^
modules/videostab/src/frame_source.cpp:114:40: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
int VideoFileSource::width() { return ((VideoFileSourceImpl*)impl.get())->width(); }
                                       ^
modules/videostab/src/frame_source.cpp:115:41: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
int VideoFileSource::height() { return ((VideoFileSourceImpl*)impl.get())->height(); }
                                        ^
modules/videostab/src/frame_source.cpp:116:40: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
int VideoFileSource::count() { return ((VideoFileSourceImpl*)impl.get())->count(); }
                                       ^
modules/videostab/src/frame_source.cpp:117:41: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
double VideoFileSource::fps() { return ((VideoFileSourceImpl*)impl.get())->fps(); }
                                        ^
modules/videostab/src/global_motion.cpp:152:12: style: The scope of the variable 'a0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float *a0, *a1;
           ^
modules/videostab/src/global_motion.cpp:152:17: style: The scope of the variable 'a1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float *a0, *a1;
                ^
modules/videostab/src/global_motion.cpp:287:12: style: The scope of the variable 'a0' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float *a0, *a1;
           ^
modules/videostab/src/global_motion.cpp:287:17: style: The scope of the variable 'a1' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float *a0, *a1;
                ^
modules/videostab/src/motion_stabilizing.cpp:687:11: style: The scope of the variable 'z' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float z;
          ^
modules/viz/src/vizimpl.hpp:57:5: style: Struct 'VizImpl' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    VizImpl(const String &name);
    ^
modules/viz/src/clouds.cpp:235:15: warning: Conversion of string literal "Correctness check." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Correctness check." && actor);
              ^
modules/viz/src/clouds.cpp:252:15: warning: Conversion of string literal "Incompatible widget type." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Incompatible widget type." && actor);
              ^
modules/viz/src/clouds.cpp:255:15: warning: Conversion of string literal "Need to add at least one cloud." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Need to add at least one cloud." && mapper);
              ^
modules/viz/src/clouds.cpp:486:15: warning: Conversion of string literal "Widget is not 3D actor." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget is not 3D actor." && widget_actor);
              ^
modules/viz/src/clouds.cpp:489:15: warning: Conversion of string literal "Widget doesn't have a polydata mapper" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget doesn't have a polydata mapper" && widget_mapper);
              ^
modules/viz/src/clouds.cpp:495:15: warning: Conversion of string literal "Correctness check" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Correctness check" && append_filter);
              ^
modules/viz/src/clouds.cpp:505:15: warning: Conversion of string literal "Correctness check" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Correctness check" && append_filter);
              ^
modules/viz/src/shapes.cpp:517:15: warning: Conversion of string literal "This widget does not support text." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("This widget does not support text." && actor);
              ^
modules/viz/src/shapes.cpp:522:15: warning: Conversion of string literal "This widget does not support text." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("This widget does not support text." && textSource);
              ^
modules/viz/src/shapes.cpp:532:15: warning: Conversion of string literal "This widget does not support text." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("This widget does not support text." && actor);
              ^
modules/viz/src/shapes.cpp:536:15: warning: Conversion of string literal "This widget does not support text." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("This widget does not support text." && textSource);
              ^
modules/viz/src/shapes.cpp:579:15: warning: Conversion of string literal "This widget does not support text." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("This widget does not support text." && actor);
              ^
modules/viz/src/shapes.cpp:586:15: warning: Conversion of string literal "This widget does not support text." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("This widget does not support text." && actor);
              ^
modules/viz/src/shapes.cpp:631:15: warning: Conversion of string literal "This widget does not support overlay image." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("This widget does not support overlay image." && actor);
              ^
modules/viz/src/shapes.cpp:634:15: warning: Conversion of string literal "This widget does not support overlay image." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("This widget does not support overlay image." && mapper);
              ^
modules/viz/src/shapes.cpp:720:15: warning: Conversion of string literal "This widget does not support 3D image." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("This widget does not support 3D image." && actor);
              ^
modules/viz/src/types.cpp:91:15: warning: Conversion of string literal "File does not exist or file format is not supported." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("File does not exist or file format is not supported." && polydata);
              ^
modules/viz/src/vizcore.cpp:172:34: warning: Conversion of string literal "Extention is required" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(file.size() > 4 && "Extention is required");
                                 ^
modules/viz/src/vizcore.cpp:205:34: warning: Conversion of string literal "Extention is required" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert(file.size() > 4 && "Extention is required");
                                 ^
modules/viz/src/vizimpl.cpp:259:15: warning: Conversion of string literal "Widget does not exist." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget does not exist." && exists);
              ^
modules/viz/src/vizimpl.cpp:260:15: warning: Conversion of string literal "Widget could not be removed." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget could not be removed." && removeActorFromRenderer(wam_itr->second));
              ^
modules/viz/src/vizimpl.cpp:269:15: warning: Conversion of string literal "Widget does not exist." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget does not exist." && exists);
              ^
modules/viz/src/vizimpl.cpp:281:15: warning: Conversion of string literal "Widget does not exist." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget does not exist." && exists);
              ^
modules/viz/src/vizimpl.cpp:284:15: warning: Conversion of string literal "Widget is not 3D." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget is not 3D." && actor);
              ^
modules/viz/src/vizimpl.cpp:296:15: warning: Conversion of string literal "Widget does not exist." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget does not exist." && exists);
              ^
modules/viz/src/vizimpl.cpp:299:15: warning: Conversion of string literal "Widget is not 3D." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget is not 3D." && actor);
              ^
modules/viz/src/vizimpl.cpp:319:15: warning: Conversion of string literal "Widget does not exist." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget does not exist." && exists);
              ^
modules/viz/src/vizimpl.cpp:322:15: warning: Conversion of string literal "Widget is not 3D." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget is not 3D." && actor);
              ^
modules/viz/src/vizimpl.cpp:553:19: warning: Conversion of string literal "Widget is not 3D." to bool always evaluates to true. [incorrectStringBooleanError]
        CV_Assert("Widget is not 3D." && actor);
                  ^
modules/viz/src/vizimpl.cpp:358:17: style: Variable 'resultImage' is assigned a value that is never used. [unreadVariable]
    resultImage = 0;
                ^
modules/viz/src/vtk/vtkCloudMatSink.cpp:98:55: warning: Conversion of string literal "Only 3- or 4-channel color data support is implemented" to bool always evaluates to true. [incorrectStringBooleanError]
        CV_Assert((channels == 3 || channels == 4) && "Only 3- or 4-channel color data support is implemented");
                                                      ^
modules/viz/src/vtk/vtkVizInteractorStyle.cpp:55:33: warning: Member variable 'vtkVizInteractorStyle::DeltaYaw' is not initialized in the constructor. [uninitMemberVar]
cv::viz::vtkVizInteractorStyle::vtkVizInteractorStyle()
                                ^
modules/viz/src/vtk/vtkVizInteractorStyle.cpp:55:33: warning: Member variable 'vtkVizInteractorStyle::DeltaPitch' is not initialized in the constructor. [uninitMemberVar]
cv::viz::vtkVizInteractorStyle::vtkVizInteractorStyle()
                                ^
modules/viz/src/vtk/vtkVizInteractorStyle.cpp:67:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'win_size_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    win_size_ = Vec2i(-1, -1);
    ^
modules/viz/src/vtk/vtkXYZWriter.cpp:52:24: warning: Member variable 'vtkXYZWriter::FileName' is not initialized in the constructor. [uninitMemberVar]
cv::viz::vtkXYZWriter::vtkXYZWriter()
                       ^
modules/viz/src/widget.cpp:109:15: warning: Conversion of string literal "Widget type is not supported." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget type is not supported." && actor);
              ^
modules/viz/src/widget.cpp:129:23: warning: Conversion of string literal "Widget does not have text content." to bool always evaluates to true. [incorrectStringBooleanError]
            CV_Assert("Widget does not have text content." && text_actor);
                      ^
modules/viz/src/widget.cpp:153:35: warning: Conversion of string literal "Can't set shading property for such type of widget" to bool always evaluates to true. [incorrectStringBooleanError]
                        CV_Assert("Can't set shading property for such type of widget" && mapper);
                                  ^
modules/viz/src/widget.cpp:166:35: warning: Conversion of string literal "Can't set shading property for such type of widget" to bool always evaluates to true. [incorrectStringBooleanError]
                        CV_Assert("Can't set shading property for such type of widget" && mapper);
                                  ^
modules/viz/src/widget.cpp:186:15: warning: Conversion of string literal "Widget type is not supported." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget type is not supported." && actor);
              ^
modules/viz/src/widget.cpp:199:23: warning: Conversion of string literal "Widget does not have text content." to bool always evaluates to true. [incorrectStringBooleanError]
            CV_Assert("Widget does not have text content." && text_actor);
                      ^
modules/viz/src/widget.cpp:248:15: warning: Conversion of string literal "Widget is not 3D." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget is not 3D." && actor);
              ^
modules/viz/src/widget.cpp:258:15: warning: Conversion of string literal "Widget is not 3D." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget is not 3D." && actor);
              ^
modules/viz/src/widget.cpp:277:15: warning: Conversion of string literal "Widget is not 3D." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget is not 3D." && actor);
              ^
modules/viz/src/widget.cpp:284:15: warning: Conversion of string literal "Widget is not 3D actor." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget is not 3D actor." && actor);
              ^
modules/viz/src/widget.cpp:287:15: warning: Conversion of string literal "Widget doesn't have a polydata mapper" to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget doesn't have a polydata mapper" && mapper);
              ^
modules/viz/src/widget.cpp:297:15: warning: Conversion of string literal "Widget type is not supported." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget type is not supported." && actor);
              ^
modules/viz/src/widget.cpp:309:15: warning: Conversion of string literal "Widget cannot be cast." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget cannot be cast." && actor);
              ^
modules/viz/src/widget.cpp:322:15: warning: Conversion of string literal "Widget type is not supported." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget type is not supported." && actor);
              ^
modules/viz/src/widget.cpp:331:15: warning: Conversion of string literal "Widget cannot be cast." to bool always evaluates to true. [incorrectStringBooleanError]
    CV_Assert("Widget cannot be cast." && actor);
              ^
modules/viz/test/test_tutorial2.cpp:28:37: style: The scope of the variable 'translation' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double translation_phase = 0.0, translation = 0.0;
                                    ^
modules/viz/test/test_tutorial2.cpp:28:49: style: Variable 'translation' is assigned a value that is never used. [unreadVariable]
    double translation_phase = 0.0, translation = 0.0;
                                                ^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:24:5: style: Class 'CascadeDetectorAdapter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    CascadeDetectorAdapter(cv::Ptr<cv::CascadeClassifier> detector):
    ^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:120:14: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            ((DetectorAgregator*)thiz)->tracker->stop();
             ^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:121:20: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            delete (DetectorAgregator*)thiz;
                   ^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:148:10: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        ((DetectorAgregator*)thiz)->tracker->run();
         ^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:174:10: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        ((DetectorAgregator*)thiz)->tracker->stop();
         ^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:202:14: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            ((DetectorAgregator*)thiz)->mainDetector->setMinObjectSize(Size(faceSize, faceSize));
             ^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:232:10: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        ((DetectorAgregator*)thiz)->tracker->process(*((Mat*)imageGray));
         ^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:233:10: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        ((DetectorAgregator*)thiz)->tracker->getObjects(RectFaces);
         ^
samples/android/tutorial-4-opencl/jni/CLprocessor.cpp:214:5: style: Label 'cv' is not used. [unusedLabel]
    cv:multiply(uTmp, 10, uOut);
    ^
samples/cpp/3calibration.cpp:332:12: style: Variable 'canvas' is assigned a value that is never used. [unreadVariable]
    canvas = Scalar::all(0);
           ^
samples/cpp/autofocus.cpp:66:56: style: Parameter 'state' can be declared with const [constParameter]
static ostream & operator<<(ostream & os, FocusState & state)
                                                       ^
samples/cpp/calibration.cpp:231:15: style: Redundant initialization for 'r'. The initialized value is overwritten before it is read. [redundantInitialization]
            r = rvecs[i].t();
              ^
samples/cpp/calibration.cpp:225:19: note: r is initialized
            Mat r = bigmat(Range(i, i+1), Range(0,3));
                  ^
samples/cpp/calibration.cpp:231:15: note: r is overwritten
            r = rvecs[i].t();
              ^
samples/cpp/calibration.cpp:232:15: style: Redundant initialization for 't'. The initialized value is overwritten before it is read. [redundantInitialization]
            t = tvecs[i].t();
              ^
samples/cpp/calibration.cpp:226:19: note: t is initialized
            Mat t = bigmat(Range(i, i+1), Range(3,6));
                  ^
samples/cpp/calibration.cpp:232:15: note: t is overwritten
            t = tvecs[i].t();
              ^
samples/cpp/calibration.cpp:94:26: style: The scope of the variable 'err' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double totalErr = 0, err;
                         ^
samples/cpp/calibration.cpp:203:47: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
            flags & CALIB_USE_INTRINSIC_GUESS ? "+use_intrinsic_guess" : "",
                                              ^
samples/cpp/calibration.cpp:204:44: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
            flags & CALIB_FIX_ASPECT_RATIO ? "+fix_aspectRatio" : "",
                                           ^
samples/cpp/calibration.cpp:205:47: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
            flags & CALIB_FIX_PRINCIPAL_POINT ? "+fix_principal_point" : "",
                                              ^
samples/cpp/calibration.cpp:206:45: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
            flags & CALIB_ZERO_TANGENT_DIST ? "+zero_tangent_dist" : "" );
                                            ^
samples/cpp/dbt_face_detection.cpp:20:9: style: Class 'CascadeDetectorAdapter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
        CascadeDetectorAdapter(cv::Ptr<cv::CascadeClassifier> detector):
        ^
samples/cpp/detect_blob.cpp:19:51: style: Parameter 'pAct' can be declared with const [constParameter]
static String Legende(SimpleBlobDetector::Params &pAct)
                                                  ^
samples/cpp/detect_blob.cpp:157:20: style: Unused variable: desMethCmp [unusedVariable]
    vector<double> desMethCmp;
                   ^
samples/cpp/detect_blob.cpp:164:26: style: Unused variable: keyImg1 [unusedVariable]
        vector<KeyPoint> keyImg1;
                         ^
samples/cpp/detect_blob.cpp:175:27: style: Unused variable: zone [unusedVariable]
            vector<Rect>  zone;
                          ^
samples/cpp/detect_blob.cpp:176:38: style: Unused variable: region [unusedVariable]
            vector<vector <Point> >  region;
                                     ^
samples/cpp/detect_mser.cpp:73:35: style: Parameter 'pAct' can be declared with const [constParameter]
static String Legende(MSERParams &pAct)
                                  ^
samples/cpp/detect_mser.cpp:341:15: style: Variable 'val[fond]' is assigned a value that is never used. [unreadVariable]
    val[fond] = 1;
              ^
samples/cpp/detect_mser.cpp:465:20: style: Unused variable: desMethCmp [unusedVariable]
    vector<double> desMethCmp;
                   ^
samples/cpp/detect_mser.cpp:473:26: style: Unused variable: keyImg1 [unusedVariable]
        vector<KeyPoint> keyImg1;
                         ^
samples/cpp/detect_mser.cpp:506:31: style: Unused variable: keyImg [unusedVariable]
            vector<KeyPoint>  keyImg;
                              ^
samples/cpp/drawing.cpp:14:32: style: Parameter 'rng' can be declared with const [constParameter]
static Scalar randomColor(RNG& rng)
                               ^
samples/cpp/facial_features.cpp:158:16: style: The scope of the variable 'mouth_center_height' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        double mouth_center_height = 0.0;
               ^
samples/cpp/facial_features.cpp:107:69: performance: Parameter 'faces' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
static void detectFacialFeaures(Mat& img, const vector<Rect_<int> > faces, string eye_cascade,
                                                                    ^
samples/cpp/falsecolor.cpp:22:24: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    ParamColorMap *p = (ParamColorMap*)r;
                       ^
samples/cpp/grabcut.cpp:49:1: style: The class 'GCApplication' does not have a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class GCApplication
^
samples/cpp/image_alignment.cpp:87:9: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int i;
        ^
samples/cpp/image_alignment.cpp:267:81: warning: Found suspicious operator ',' [constStatement]
                (rng.uniform(0.0001f, 0.0003f)), (rng.uniform(0.0001f, 0.0003f)), 1.f);
                                                                                ^
samples/cpp/kalman.cpp:43:60: warning: Found suspicious operator ',' [constStatement]
        KF.transitionMatrix = (Mat_<float>(2, 2) << 1, 1, 0, 1);
                                                           ^
samples/cpp/npr_demo.cpp:45:13: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int num,type;
            ^
samples/cpp/select3dobj.cpp:80:24: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    MouseEvent* data = (MouseEvent*)userdata;
                       ^
samples/cpp/select3dobj.cpp:216:15: style: The scope of the variable 'Z' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        float Z = 0.f;
              ^
samples/cpp/select3dobj.cpp:464:17: style: The scope of the variable 'outbarename' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    const char* outbarename = 0;
                ^
samples/cpp/select3dobj.cpp:488:10: style: The scope of the variable 'boardFound' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    bool boardFound = false;
         ^
samples/cpp/select3dobj.cpp:208:19: style: Unused variable: temphull [unusedVariable]
    vector<Point> temphull;
                  ^
samples/cpp/select3dobj.cpp:477:24: style: Variable 'outbarename' is assigned a value that is never used. [unreadVariable]
            outbarename++;
                       ^
samples/cpp/select3dobj.cpp:480:25: style: Variable 'outbarename' is assigned a value that is never used. [unreadVariable]
            outbarename = outprefix.c_str();
                        ^
samples/cpp/select3dobj.cpp:488:21: style: Variable 'boardFound' is assigned a value that is never used. [unreadVariable]
    bool boardFound = false;
                    ^
samples/cpp/smiledetect.cpp:169:13: style: The scope of the variable 'radius' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        int radius;
            ^
samples/cpp/stitching_detailed.cpp:762:32: style: Variable 'compose_work_aspect' is assigned a value that is never used. [unreadVariable]
    double compose_work_aspect = 1;
                               ^
samples/cpp/train_svmsgd.cpp:20:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'img' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        img = Mat::zeros(HEIGHT, WIDTH, CV_8UC3);
        ^
samples/cpp/train_svmsgd.cpp:187:19: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    Data &data = *(Data*)pData;
                  ^
samples/cpp/train_svmsgd.cpp:87:11: style: Variable 'x' is assigned a value that is never used. [unreadVariable]
    int x = 0;
          ^
samples/cpp/train_svmsgd.cpp:88:11: style: Variable 'y' is assigned a value that is never used. [unreadVariable]
    int y = 0;
          ^
samples/cpp/travelsalesman.cpp:14:5: warning: Member variable 'TravelSalesman::d0' is not initialized in the constructor. [uninitMemberVar]
    TravelSalesman(std::vector<Point> &p, std::vector<int> &n) :
    ^
samples/cpp/travelsalesman.cpp:14:5: warning: Member variable 'TravelSalesman::d1' is not initialized in the constructor. [uninitMemberVar]
    TravelSalesman(std::vector<Point> &p, std::vector<int> &n) :
    ^
samples/cpp/travelsalesman.cpp:14:5: warning: Member variable 'TravelSalesman::d2' is not initialized in the constructor. [uninitMemberVar]
    TravelSalesman(std::vector<Point> &p, std::vector<int> &n) :
    ^
samples/cpp/travelsalesman.cpp:14:5: warning: Member variable 'TravelSalesman::d3' is not initialized in the constructor. [uninitMemberVar]
    TravelSalesman(std::vector<Point> &p, std::vector<int> &n) :
    ^
samples/cpp/travelsalesman.cpp:17:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'rng' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        rng = theRNG();
        ^
samples/cpp/tree_engine.cpp:105:24: style: Variable 'ref_labels' is assigned a value that is never used. [unreadVariable]
    cv::Mat ref_labels = data->getClassLabels();
                       ^
samples/cpp/tree_engine.cpp:106:23: style: Variable 'test_data' is assigned a value that is never used. [unreadVariable]
    cv::Mat test_data = data->getTestSampleIdx();
                      ^
samples/cpp/tutorial_code/ImgProc/HitMiss/HitMiss.cpp:16:34: warning: Found suspicious operator ',' [constStatement]
        0, 255, 255, 255, 0, 0, 0, 0);
                                 ^
samples/cpp/tutorial_code/ImgProc/HitMiss/HitMiss.cpp:21:13: warning: Found suspicious operator ',' [constStatement]
        0, 1, 0);
            ^
samples/cpp/tutorial_code/ImgTrans/filter2D_demo.cpp:25:9: style: The scope of the variable 'kernel_size' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int kernel_size;
        ^
samples/cpp/tutorial_code/ImgTrans/imageSegmentation.cpp:49:18: warning: Found suspicious operator ',' [constStatement]
            1,  1, 1); // an approximation of second derivative, a quite strong kernel
                 ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::calibrationPattern' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::squareSize' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::nrFrames' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::aspectRatio' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::delay' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::writePoints' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::writeExtrinsics' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::calibZeroTangentDist' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::calibFixPrincipalPoint' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::flipVertical' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::showUndistorsed' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::useFisheye' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::fixK1' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::fixK2' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::fixK3' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::fixK4' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::fixK5' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::cameraID' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::atImageList' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::inputType' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:28:5: warning: Member variable 'Settings::flag' is not initialized in the constructor. [uninitMemberVar]
    Settings() : goodInput(false) {}
    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:471:26: style: The scope of the variable 'err' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double totalErr = 0, err;
                         ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:603:54: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & fisheye::CALIB_FIX_SKEW ? " +fix_skew" : "")
                                                     ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:604:52: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & fisheye::CALIB_FIX_K1 ? " +fix_k1" : "")
                                                   ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:605:52: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & fisheye::CALIB_FIX_K2 ? " +fix_k2" : "")
                                                   ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:606:52: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & fisheye::CALIB_FIX_K3 ? " +fix_k3" : "")
                                                   ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:607:52: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & fisheye::CALIB_FIX_K4 ? " +fix_k4" : "")
                                                   ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:608:65: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & fisheye::CALIB_RECOMPUTE_EXTRINSIC ? " +recompute_extrinsic" : "");
                                                                ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:613:56: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & CALIB_USE_INTRINSIC_GUESS ? " +use_intrinsic_guess" : "")
                                                       ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:614:53: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & CALIB_FIX_ASPECT_RATIO ? " +fix_aspectRatio" : "")
                                                    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:615:56: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & CALIB_FIX_PRINCIPAL_POINT ? " +fix_principal_point" : "")
                                                       ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:616:54: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & CALIB_ZERO_TANGENT_DIST ? " +zero_tangent_dist" : "")
                                                     ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:617:43: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & CALIB_FIX_K1 ? " +fix_k1" : "")
                                          ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:618:43: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & CALIB_FIX_K2 ? " +fix_k2" : "")
                                          ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:619:43: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & CALIB_FIX_K3 ? " +fix_k3" : "")
                                          ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:620:43: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & CALIB_FIX_K4 ? " +fix_k4" : "")
                                          ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:621:43: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                << (s.flag & CALIB_FIX_K5 ? " +fix_k5" : "");
                                          ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:685:53: performance: Parameter 'imagePoints' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
                           vector<vector<Point2f> > imagePoints)
                                                    ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:571:50: style: Parameter 'imageSize' can be declared with const [constParameter]
static void saveCameraParams( Settings& s, Size& imageSize, Mat& cameraMatrix, Mat& distCoeffs,
                                                 ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:571:66: style: Parameter 'cameraMatrix' can be declared with const [constParameter]
static void saveCameraParams( Settings& s, Size& imageSize, Mat& cameraMatrix, Mat& distCoeffs,
                                                                 ^
samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp:571:85: style: Parameter 'distCoeffs' can be declared with const [constParameter]
static void saveCameraParams( Settings& s, Size& imageSize, Mat& cameraMatrix, Mat& distCoeffs,
                                                                                    ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/CsvReader.h:22:3: style: Class 'CsvReader' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
  CsvReader(const string &path, const char &separator = ' ');
  ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/CsvReader.cpp:37:13: style: Condition 'end_header' is always true [knownConditionTrueFalse]
    else if(end_header)
            ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/CsvReader.cpp:23:8: note: Assuming that condition '!end_header' is not redundant
    if(!end_header)
       ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/CsvReader.cpp:37:13: note: Condition 'end_header' is always true
    else if(end_header)
            ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/Mesh.h:71:31: performance: Parameter 'path_file' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
  void load(const std::string path_file);
                              ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/CsvWriter.h:14:3: style: Class 'CsvWriter' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
  CsvWriter(const string &path, const string &separator = " ");
  ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/Mesh.cpp:65:35: performance: Parameter 'path' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
void Mesh::load(const std::string path)
                                  ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/Model.cpp:45:36: performance: Parameter 'path' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
void Model::save(const std::string path)
                                   ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/Model.cpp:61:36: performance: Parameter 'path' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
void Model::load(const std::string path)
                                   ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/PnPProblem.cpp:74:3: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '_A_matrix' a value by passing the value to the constructor in the initialization list. [useInitializationList]
  _A_matrix = cv::Mat::zeros(3, 3, CV_64FC1);   // intrinsic camera parameters
  ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/PnPProblem.cpp:187:15: style: Redundant initialization for 'point2d_vec'. The initialized value is overwritten before it is read. [redundantInitialization]
  point2d_vec = _A_matrix * _P_matrix * point3d_vec;
              ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/PnPProblem.cpp:186:23: note: point2d_vec is initialized
  cv::Mat point2d_vec = cv::Mat(4, 1, CV_64FC1);
                      ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/PnPProblem.cpp:187:15: note: point2d_vec is overwritten
  point2d_vec = _A_matrix * _P_matrix * point3d_vec;
              ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/PnPProblem.cpp:52:60: style: Parameter 'points_list' can be declared with const [constParameter]
cv::Point3f get_nearest_3D_point(std::vector<cv::Point3f> &points_list, cv::Point3f origin)
                                                           ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/PnPProblem.cpp:262:63: style: Parameter 'Triangle' can be declared with const [constParameter]
bool PnPProblem::intersect_MollerTrumbore(Ray &Ray, Triangle &Triangle, double *out)
                                                              ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/RobustMatcher.h:22:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'detector_' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    detector_ = cv::ORB::create();
    ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/Utils.cpp:275:24: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a>>b?c:d'' should be written as either ''(a>>b)?c:d'' or ''a>>(b?c:d)''. [clarifyCalculation]
   return ss >> result ? result : 0;
                       ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/Utils.cpp:76:100: style: Parameter 'list_points_3d' can be declared with const [constParameter]
void drawPoints(cv::Mat image, std::vector<cv::Point2f> &list_points_2d, std::vector<cv::Point3f> &list_points_3d, cv::Scalar color)
                                                                                                   ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/Utils.cpp:275:17: error: Uninitialized variable: result [uninitvar]
   return ss >> result ? result : 0;
                ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/Utils.cpp:274:8: style: Variable 'result' is not assigned a value. [unassignedVariable]
   int result;
       ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/main_detection.cpp:173:10: style: The scope of the variable 'fps' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  double fps, sec;
         ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/main_detection.cpp:173:15: style: The scope of the variable 'sec' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
  double fps, sec;
              ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/Model.h:35:31: performance: Parameter 'path' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
  void save(const std::string path);
                              ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/Model.h:36:31: performance: Parameter 'path' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
  void load(const std::string path);
                              ^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/main_detection.cpp:435:18: style: Variable 'prediction' is assigned a value that is never used. [unreadVariable]
  Mat prediction = KF.predict();
                 ^
samples/cpp/tutorial_code/core/Matrix/Drawing_2.cpp:98:33: style: Parameter 'rng' can be declared with const [constParameter]
static Scalar randomColor( RNG& rng )
                                ^
samples/cpp/tutorial_code/core/how_to_scan_images/how_to_scan_images.cpp:151:12: style: The scope of the variable 'p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uchar* p;
           ^
samples/cpp/tutorial_code/core/how_to_use_OpenCV_parallel_for_/how_to_use_OpenCV_parallel_for_.cpp:61:25: warning: Member variable 'ParallelMandelbrot::m_x1' is not assigned a value in 'ParallelMandelbrot::operator='. [operatorEqVarError]
    ParallelMandelbrot& operator=(const ParallelMandelbrot &) {
                        ^
samples/cpp/tutorial_code/core/how_to_use_OpenCV_parallel_for_/how_to_use_OpenCV_parallel_for_.cpp:61:25: warning: Member variable 'ParallelMandelbrot::m_y1' is not assigned a value in 'ParallelMandelbrot::operator='. [operatorEqVarError]
    ParallelMandelbrot& operator=(const ParallelMandelbrot &) {
                        ^
samples/cpp/tutorial_code/core/how_to_use_OpenCV_parallel_for_/how_to_use_OpenCV_parallel_for_.cpp:61:25: warning: Member variable 'ParallelMandelbrot::m_scaleX' is not assigned a value in 'ParallelMandelbrot::operator='. [operatorEqVarError]
    ParallelMandelbrot& operator=(const ParallelMandelbrot &) {
                        ^
samples/cpp/tutorial_code/core/how_to_use_OpenCV_parallel_for_/how_to_use_OpenCV_parallel_for_.cpp:61:25: warning: Member variable 'ParallelMandelbrot::m_scaleY' is not assigned a value in 'ParallelMandelbrot::operator='. [operatorEqVarError]
    ParallelMandelbrot& operator=(const ParallelMandelbrot &) {
                        ^
samples/cpp/tutorial_code/core/ippasync/ippasync_sample.cpp:54:17: style: The scope of the variable 'src' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    hppiMatrix* src,* dst;
                ^
samples/cpp/tutorial_code/core/ippasync/ippasync_sample.cpp:54:23: style: The scope of the variable 'dst' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    hppiMatrix* src,* dst;
                      ^
samples/cpp/tutorial_code/core/mat_mask_operations/mat_mask_operations.cpp:56:42: warning: Found suspicious operator ',' [constStatement]
                                    0, -1,  0);
                                         ^
samples/cpp/tutorial_code/core/mat_the_basic_image_container/mat_the_basic_image_container.cpp:58:61: warning: Found suspicious operator ',' [constStatement]
    Mat C = (Mat_<double>(3,3) << 0, -1, 0, -1, 5, -1, 0, -1, 0);
                                                            ^
samples/cpp/tutorial_code/features2D/AKAZE_tracking/utils.h:41:29: performance: Parameter 'name' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
void printStatistics(string name, Stats stats)
                            ^
samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp:96:44: warning: Found suspicious operator ',' [constStatement]
    Mat normal = (Mat_<double>(3,1) << 0, 0, 1);
                                           ^
samples/cpp/tutorial_code/features2D/Homography/decompose_homography.cpp:111:26: style: Variable 'homography_euclidean' is assigned a value that is never used. [unreadVariable]
    homography_euclidean /= homography_euclidean.at<double>(2,2);
                         ^
samples/cpp/tutorial_code/features2D/Homography/homography_from_camera_displacement.cpp:115:44: warning: Found suspicious operator ',' [constStatement]
    Mat normal = (Mat_<double>(3,1) << 0, 0, 1);
                                           ^
samples/cpp/tutorial_code/features2D/Homography/panorama_stitching_rotating_camera.cpp:18:45: warning: Found suspicious operator ',' [constStatement]
                                     0, 0, 0, 1);
                                            ^
samples/cpp/tutorial_code/features2D/Homography/panorama_stitching_rotating_camera.cpp:25:45: warning: Found suspicious operator ',' [constStatement]
                                     0, 0, 0, 1);
                                            ^
samples/cpp/tutorial_code/features2D/Homography/panorama_stitching_rotating_camera.cpp:31:50: warning: Found suspicious operator ',' [constStatement]
                                             0, 0, 1);
                                                 ^
samples/cpp/tutorial_code/features2D/Homography/perspective_correction.cpp:82:69: warning: Found suspicious operator ',' [constStatement]
        Mat pt1 = (Mat_<double>(3,1) << corners1[i].x, corners1[i].y, 1);
                                                                    ^
samples/cpp/tutorial_code/features2D/Homography/perspective_correction.cpp:14:26: style: Parameter 'rng' can be declared with const [constParameter]
Scalar randomColor( RNG& rng )
                         ^
samples/cpp/tutorial_code/ml/introduction_to_svm/introduction_to_svm.cpp:44:51: warning: Found suspicious operator ',' [constStatement]
            Mat sampleMat = (Mat_<float>(1,2) << j,i);
                                                  ^
samples/cpp/tutorial_code/ml/non_linear_svms/non_linear_svms.cpp:98:51: warning: Found suspicious operator ',' [constStatement]
            Mat sampleMat = (Mat_<float>(1,2) << i, j);
                                                  ^
samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp:27:13: style: The scope of the variable 'type' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int num,type;
            ^
samples/cpp/tutorial_code/snippets/core_merge.cpp:20:40: warning: Found suspicious operator ',' [constStatement]
    Mat m1 = (Mat_<uchar>(2,2) << 1,4,7,10);
                                       ^
samples/cpp/tutorial_code/snippets/core_merge.cpp:21:40: warning: Found suspicious operator ',' [constStatement]
    Mat m2 = (Mat_<uchar>(2,2) << 2,5,8,11);
                                       ^
samples/cpp/tutorial_code/snippets/core_merge.cpp:22:40: warning: Found suspicious operator ',' [constStatement]
    Mat m3 = (Mat_<uchar>(2,2) << 3,6,9,12);
                                       ^
samples/cpp/tutorial_code/snippets/core_reduce.cpp:23:47: warning: Found suspicious operator ',' [constStatement]
        Mat m = (Mat_<uchar>(3,2) << 1,2,3,4,5,6);
                                              ^
samples/cpp/tutorial_code/videoio/video-input-psnr-ssim/video-input-psnr-ssim.cpp:90:12: style: The scope of the variable 'psnrV' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    double psnrV;
           ^
samples/cpp/tutorial_code/viz/histo3D.cpp:67:19: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
   Histo3DData *x=(Histo3DData *)t;
                  ^
samples/cpp/tutorial_code/viz/histo3D.cpp:101:22: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    Histo3DData *h = (Histo3DData *)r;
                     ^
samples/cpp/tutorial_code/viz/widget_pose.cpp:54:36: style: The scope of the variable 'translation' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    float translation_phase = 0.0, translation = 0.0;
                                   ^
samples/cpp/tutorial_code/viz/widget_pose.cpp:54:48: style: Variable 'translation' is assigned a value that is never used. [unreadVariable]
    float translation_phase = 0.0, translation = 0.0;
                                               ^
samples/cpp/videostab.cpp:195:43: style: The function 'build' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual Ptr<ImageMotionEstimatorBase> build()
                                          ^
samples/cpp/videostab.cpp:182:43: note: Virtual function in base class
    virtual Ptr<ImageMotionEstimatorBase> build() = 0;
                                          ^
samples/cpp/videostab.cpp:195:43: note: Function in derived class
    virtual Ptr<ImageMotionEstimatorBase> build()
                                          ^
samples/cpp/videostab.cpp:248:43: style: The function 'build' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual Ptr<ImageMotionEstimatorBase> build()
                                          ^
samples/cpp/videostab.cpp:182:43: note: Virtual function in base class
    virtual Ptr<ImageMotionEstimatorBase> build() = 0;
                                          ^
samples/cpp/videostab.cpp:248:43: note: Function in derived class
    virtual Ptr<ImageMotionEstimatorBase> build()
                                          ^
samples/cpp/videostab.cpp:184:48: style: Parameter 'command' can be declared with const [constParameter]
    IMotionEstimatorBuilder(CommandLineParser &command) : cmd(command) {}
                                               ^
samples/cpp/videostab.cpp:228:35: warning: Conversion of string literal "CUDA modules are not available" to bool always evaluates to true. [incorrectStringBooleanError]
        CV_Assert(gpu == false && "CUDA modules are not available");
                                  ^
samples/cpp/videostab.cpp:271:35: warning: Conversion of string literal "CUDA modules are not available" to bool always evaluates to true. [incorrectStringBooleanError]
        CV_Assert(gpu == false && "CUDA modules are not available");
                                  ^
samples/directx/d3d10_interop.cpp:30:5: warning: Member variable 'D3D10WinApp::m_pD3D10Dev' is not initialized in the constructor. [uninitMemberVar]
    D3D10WinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap) :
    ^
samples/directx/d3d10_interop.cpp:30:5: warning: Member variable 'D3D10WinApp::m_pD3D10SwapChain' is not initialized in the constructor. [uninitMemberVar]
    D3D10WinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap) :
    ^
samples/directx/d3d10_interop.cpp:30:5: warning: Member variable 'D3D10WinApp::m_pBackBuffer' is not initialized in the constructor. [uninitMemberVar]
    D3D10WinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap) :
    ^
samples/directx/d3d10_interop.cpp:30:5: warning: Member variable 'D3D10WinApp::m_pSurface' is not initialized in the constructor. [uninitMemberVar]
    D3D10WinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap) :
    ^
samples/directx/d3d10_interop.cpp:30:5: warning: Member variable 'D3D10WinApp::m_pRenderTarget' is not initialized in the constructor. [uninitMemberVar]
    D3D10WinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap) :
    ^
samples/directx/winapp.hpp:19:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'm_window_name' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        m_window_name = window_name;
        ^
samples/directx/winapp.hpp:20:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'm_hInstance' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        m_hInstance   = ::GetModuleHandle(NULL);
        ^
samples/directx/d3dsample.hpp:88:17: style: The function 'create' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int create() { return WinApp::create(); }
                ^
samples/directx/winapp.hpp:27:17: note: Virtual function in base class
    virtual int create()
                ^
samples/directx/d3dsample.hpp:88:17: note: Function in derived class
    virtual int create() { return WinApp::create(); }
                ^
samples/directx/d3dsample.hpp:90:17: style: The function 'cleanup' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int cleanup()
                ^
samples/directx/winapp.hpp:92:17: note: Virtual function in base class
    virtual int cleanup()
                ^
samples/directx/d3dsample.hpp:90:17: note: Function in derived class
    virtual int cleanup()
                ^
samples/directx/d3dsample.hpp:97:30: style: The function 'WndProc' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
                             ^
samples/directx/winapp.hpp:123:30: note: Virtual function in base class
    virtual LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) = 0;
                             ^
samples/directx/d3dsample.hpp:97:30: note: Function in derived class
    virtual LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
                             ^
samples/directx/d3dsample.hpp:140:17: style: The function 'idle' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual int idle() { return render(); }
                ^
samples/directx/winapp.hpp:125:17: note: Virtual function in base class
    virtual int idle() = 0;
                ^
samples/directx/d3dsample.hpp:140:17: note: Function in derived class
    virtual int idle() { return render(); }
                ^
samples/directx/d3d10_interop.cpp:36:9: style: The function 'create' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int create(void)
        ^
samples/directx/d3dsample.hpp:88:17: note: Virtual function in base class
    virtual int create() { return WinApp::create(); }
                ^
samples/directx/d3d10_interop.cpp:36:9: note: Function in derived class
    int create(void)
        ^
samples/directx/d3d10_interop.cpp:162:9: style: The function 'render' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int render()
        ^
samples/directx/d3dsample.hpp:89:17: note: Virtual function in base class
    virtual int render() = 0;
                ^
samples/directx/d3d10_interop.cpp:162:9: note: Function in derived class
    int render()
        ^
samples/directx/d3d10_interop.cpp:275:9: style: The function 'cleanup' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int cleanup(void)
        ^
samples/directx/d3dsample.hpp:90:17: note: Virtual function in base class
    virtual int cleanup()
                ^
samples/directx/d3d10_interop.cpp:275:9: note: Function in derived class
    int cleanup(void)
        ^
samples/directx/winapp.hpp:15:48: style: Parameter 'window_name' can be declared with const [constParameter]
    WinApp(int width, int height, std::string& window_name)
                                               ^
samples/directx/d3dsample.hpp:74:82: style: Parameter 'cap' can be declared with const [constParameter]
    D3DSample(int width, int height, std::string& window_name, cv::VideoCapture& cap) :
                                                                                 ^
samples/directx/d3dsample.hpp:176:49: style: Parameter 'title' can be declared with const [constParameter]
int d3d_app(int argc, char** argv, std::string& title)
                                                ^
samples/directx/d3d11_interop.cpp:30:5: warning: Member variable 'D3D11WinApp::m_pD3D11Dev' is not initialized in the constructor. [uninitMemberVar]
    D3D11WinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap)
    ^
samples/directx/d3d11_interop.cpp:30:5: warning: Member variable 'D3D11WinApp::m_pD3D11SwapChain' is not initialized in the constructor. [uninitMemberVar]
    D3D11WinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap)
    ^
samples/directx/d3d11_interop.cpp:30:5: warning: Member variable 'D3D11WinApp::m_pD3D11Ctx' is not initialized in the constructor. [uninitMemberVar]
    D3D11WinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap)
    ^
samples/directx/d3d11_interop.cpp:30:5: warning: Member variable 'D3D11WinApp::m_pBackBuffer' is not initialized in the constructor. [uninitMemberVar]
    D3D11WinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap)
    ^
samples/directx/d3d11_interop.cpp:30:5: warning: Member variable 'D3D11WinApp::m_pSurfaceRGBA' is not initialized in the constructor. [uninitMemberVar]
    D3D11WinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap)
    ^
samples/directx/d3d11_interop.cpp:30:5: warning: Member variable 'D3D11WinApp::m_pSurfaceNV12' is not initialized in the constructor. [uninitMemberVar]
    D3D11WinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap)
    ^
samples/directx/d3d11_interop.cpp:30:5: warning: Member variable 'D3D11WinApp::m_pSurfaceNV12_cpu_copy' is not initialized in the constructor. [uninitMemberVar]
    D3D11WinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap)
    ^
samples/directx/d3d11_interop.cpp:30:5: warning: Member variable 'D3D11WinApp::m_pRenderTarget' is not initialized in the constructor. [uninitMemberVar]
    D3D11WinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap)
    ^
samples/directx/d3d11_interop.cpp:38:9: style: The function 'create' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int create(void)
        ^
samples/directx/d3dsample.hpp:88:17: note: Virtual function in base class
    virtual int create() { return WinApp::create(); }
                ^
samples/directx/d3d11_interop.cpp:38:9: note: Function in derived class
    int create(void)
        ^
samples/directx/d3d11_interop.cpp:238:9: style: The function 'render' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int render()
        ^
samples/directx/d3dsample.hpp:89:17: note: Virtual function in base class
    virtual int render() = 0;
                ^
samples/directx/d3d11_interop.cpp:238:9: note: Function in derived class
    int render()
        ^
samples/directx/d3d11_interop.cpp:401:9: style: The function 'cleanup' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int cleanup(void)
        ^
samples/directx/d3dsample.hpp:90:17: note: Virtual function in base class
    virtual int cleanup()
                ^
samples/directx/d3d11_interop.cpp:401:9: note: Function in derived class
    int cleanup(void)
        ^
samples/directx/d3d11_interop.cpp:427:28: style: The scope of the variable 'dst' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            unsigned char* dst;
                           ^
samples/directx/d3d11_interop.cpp:446:28: style: The scope of the variable 'pDstUV' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            unsigned char* pDstUV;
                           ^
samples/directx/d3d9_interop.cpp:35:9: style: The function 'create' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int create(void)
        ^
samples/directx/d3dsample.hpp:88:17: note: Virtual function in base class
    virtual int create() { return WinApp::create(); }
                ^
samples/directx/d3d9_interop.cpp:35:9: note: Function in derived class
    int create(void)
        ^
samples/directx/d3d9_interop.cpp:139:9: style: The function 'render' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int render()
        ^
samples/directx/d3dsample.hpp:89:17: note: Virtual function in base class
    virtual int render() = 0;
                ^
samples/directx/d3d9_interop.cpp:139:9: note: Function in derived class
    int render()
        ^
samples/directx/d3d9_interop.cpp:291:9: style: The function 'cleanup' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int cleanup(void)
        ^
samples/directx/d3dsample.hpp:90:17: note: Virtual function in base class
    virtual int cleanup()
                ^
samples/directx/d3d9_interop.cpp:291:9: note: Function in derived class
    int cleanup(void)
        ^
samples/directx/d3d9ex_interop.cpp:35:9: style: The function 'create' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int create(void)
        ^
samples/directx/d3dsample.hpp:88:17: note: Virtual function in base class
    virtual int create() { return WinApp::create(); }
                ^
samples/directx/d3d9ex_interop.cpp:35:9: note: Function in derived class
    int create(void)
        ^
samples/directx/d3d9ex_interop.cpp:139:9: style: The function 'render' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int render()
        ^
samples/directx/d3dsample.hpp:89:17: note: Virtual function in base class
    virtual int render() = 0;
                ^
samples/directx/d3d9ex_interop.cpp:139:9: note: Function in derived class
    int render()
        ^
samples/directx/d3d9ex_interop.cpp:292:9: style: The function 'cleanup' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int cleanup(void)
        ^
samples/directx/d3dsample.hpp:90:17: note: Virtual function in base class
    virtual int cleanup()
                ^
samples/directx/d3d9ex_interop.cpp:292:9: note: Function in derived class
    int cleanup(void)
        ^
samples/dnn/faster_rcnn.cpp:55:58: warning: Found suspicious operator ',' [constStatement]
    Mat imInfo = (Mat_<float>(1, 3) << img.rows, img.cols, 1.6f);
                                                         ^
samples/gpu/hog.cpp:234:6: warning: Member variable 'App::running' is not initialized in the constructor. [uninitMemberVar]
App::App(const Args& s)
     ^
samples/gpu/hog.cpp:234:6: warning: Member variable 'App::hog_work_fps' is not initialized in the constructor. [uninitMemberVar]
App::App(const Args& s)
     ^
samples/gpu/hog.cpp:234:6: warning: Member variable 'App::work_fps' is not initialized in the constructor. [uninitMemberVar]
App::App(const Args& s)
     ^
samples/gpu/hog.cpp:63:5: style: Class 'App' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    App(const Args& s);
    ^
samples/gpu/morphology.cpp:172:17: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    App* thiz = (App*) data;
                ^
samples/gpu/morphology.cpp:178:17: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    App* thiz = (App*) data;
                ^
samples/gpu/opengl.cpp:75:29: warning: Found suspicious operator ',' [constStatement]
    indices << 0, 1, 2, 2, 3, 0;
                            ^
samples/gpu/performance/tests.cpp:32:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(matchTemplate)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:32:1: note: Function in derived class
TEST(matchTemplate)
^
samples/gpu/performance/tests.cpp:62:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(minMaxLoc)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:62:1: note: Function in derived class
TEST(minMaxLoc)
^
samples/gpu/performance/tests.cpp:89:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(remap)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:89:1: note: Function in derived class
TEST(remap)
^
samples/gpu/performance/tests.cpp:135:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(dft)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:135:1: note: Function in derived class
TEST(dft)
^
samples/gpu/performance/tests.cpp:163:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(cornerHarris)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:163:1: note: Function in derived class
TEST(cornerHarris)
^
samples/gpu/performance/tests.cpp:193:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(integral)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:193:1: note: Function in derived class
TEST(integral)
^
samples/gpu/performance/tests.cpp:221:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(norm)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:221:1: note: Function in derived class
TEST(norm)
^
samples/gpu/performance/tests.cpp:249:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(meanShift)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:249:1: note: Function in derived class
TEST(meanShift)
^
samples/gpu/performance/tests.cpp:312:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(FAST)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:312:1: note: Function in derived class
TEST(FAST)
^
samples/gpu/performance/tests.cpp:337:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(ORB)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:337:1: note: Function in derived class
TEST(ORB)
^
samples/gpu/performance/tests.cpp:366:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(BruteForceMatcher)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:366:1: note: Function in derived class
TEST(BruteForceMatcher)
^
samples/gpu/performance/tests.cpp:437:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(magnitude)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:437:1: note: Function in derived class
TEST(magnitude)
^
samples/gpu/performance/tests.cpp:467:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(add)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:467:1: note: Function in derived class
TEST(add)
^
samples/gpu/performance/tests.cpp:497:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(log)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:497:1: note: Function in derived class
TEST(log)
^
samples/gpu/performance/tests.cpp:525:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(mulSpectrums)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:525:1: note: Function in derived class
TEST(mulSpectrums)
^
samples/gpu/performance/tests.cpp:555:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(resize)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:555:1: note: Function in derived class
TEST(resize)
^
samples/gpu/performance/tests.cpp:604:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(cvtColor)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:604:1: note: Function in derived class
TEST(cvtColor)
^
samples/gpu/performance/tests.cpp:733:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(erode)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:733:1: note: Function in derived class
TEST(erode)
^
samples/gpu/performance/tests.cpp:763:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(threshold)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:763:1: note: Function in derived class
TEST(threshold)
^
samples/gpu/performance/tests.cpp:811:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(pow)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:811:1: note: Function in derived class
TEST(pow)
^
samples/gpu/performance/tests.cpp:839:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(projectPoints)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:839:1: note: Function in derived class
TEST(projectPoints)
^
samples/gpu/performance/tests.cpp:885:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(solvePnPRansac)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:885:1: note: Function in derived class
TEST(solvePnPRansac)
^
samples/gpu/performance/tests.cpp:918:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(GaussianBlur)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:918:1: note: Function in derived class
TEST(GaussianBlur)
^
samples/gpu/performance/tests.cpp:948:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(filter2D)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:948:1: note: Function in derived class
TEST(filter2D)
^
samples/gpu/performance/tests.cpp:982:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(pyrDown)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:982:1: note: Function in derived class
TEST(pyrDown)
^
samples/gpu/performance/tests.cpp:1008:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(pyrUp)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:1008:1: note: Function in derived class
TEST(pyrUp)
^
samples/gpu/performance/tests.cpp:1036:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(equalizeHist)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:1036:1: note: Function in derived class
TEST(equalizeHist)
^
samples/gpu/performance/tests.cpp:1064:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(Canny)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:1064:1: note: Function in derived class
TEST(Canny)
^
samples/gpu/performance/tests.cpp:1089:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(reduce)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:1089:1: note: Function in derived class
TEST(reduce)
^
samples/gpu/performance/tests.cpp:1134:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(gemm)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:1134:1: note: Function in derived class
TEST(gemm)
^
samples/gpu/performance/tests.cpp:1165:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(GoodFeaturesToTrack)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:1165:1: note: Function in derived class
TEST(GoodFeaturesToTrack)
^
samples/gpu/performance/tests.cpp:1245:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(MOG2)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:1245:1: note: Function in derived class
TEST(MOG2)
^
samples/gpu/performance/tests.cpp:1192:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(MOG)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:1192:1: note: Function in derived class
TEST(MOG)
^
samples/gpu/performance/tests.cpp:282:1: style: The function 'run' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
TEST(SURF)
^
samples/gpu/performance/performance.h:21:18: note: Virtual function in base class
    virtual void run() = 0;
                 ^
samples/gpu/performance/tests.cpp:282:1: note: Function in derived class
TEST(SURF)
^
samples/gpu/stereo_match.cpp:141:6: warning: Member variable 'App::work_fps' is not initialized in the constructor. [uninitMemberVar]
App::App(const Params& params)
     ^
samples/gpu/stereo_match.cpp:41:5: style: Struct 'App' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    App(const Params& p);
    ^
samples/opencl/opencl-opencv-interop.cpp:99:5: warning: Member variable 'DeviceInfo::m_max_work_group_size' is not initialized in the constructor. [uninitMemberVar]
    DeviceInfo()
    ^
samples/opencl/opencl-opencv-interop.cpp:99:5: warning: Member variable 'DeviceInfo::m_image2d_max_width' is not initialized in the constructor. [uninitMemberVar]
    DeviceInfo()
    ^
samples/opencl/opencl-opencv-interop.cpp:99:5: warning: Member variable 'DeviceInfo::m_image2d_max_height' is not initialized in the constructor. [uninitMemberVar]
    DeviceInfo()
    ^
samples/opencl/opencl-opencv-interop.cpp:99:5: warning: Member variable 'DeviceInfo::m_image3d_max_width' is not initialized in the constructor. [uninitMemberVar]
    DeviceInfo()
    ^
samples/opencl/opencl-opencv-interop.cpp:99:5: warning: Member variable 'DeviceInfo::m_image3d_max_height' is not initialized in the constructor. [uninitMemberVar]
    DeviceInfo()
    ^
samples/opencl/opencl-opencv-interop.cpp:99:5: warning: Member variable 'DeviceInfo::m_image3d_max_depth' is not initialized in the constructor. [uninitMemberVar]
    DeviceInfo()
    ^
samples/opencl/opencl-opencv-interop.cpp:99:5: warning: Member variable 'DeviceInfo::m_max_parameter_size' is not initialized in the constructor. [uninitMemberVar]
    DeviceInfo()
    ^
samples/opencl/opencl-opencv-interop.cpp:99:5: warning: Member variable 'DeviceInfo::m_profiling_timer_resolution' is not initialized in the constructor. [uninitMemberVar]
    DeviceInfo()
    ^
samples/opencl/opencl-opencv-interop.cpp:478:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'm_file_name' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    m_file_name  = cmd.get<string>("video");
    ^
samples/opencl/opencl-opencv-interop.cpp:484:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'm_t0' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    m_t0         = 0;
    ^
samples/opencl/opencl-opencv-interop.cpp:485:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'm_t1' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    m_t1         = 0;
    ^
samples/opencl/opencl-opencv-interop.cpp:412:5: style: Class 'App' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    App(CommandLineParser& cmd);
    ^
samples/opencl/opencl-opencv-interop.cpp:677:5: style: The exception is caught by value. It could be caught as a (const) reference which is usually recommended in C++. [catchExceptionByValue]
    catch (std::exception e)
    ^
samples/opencl/opencl-opencv-interop.cpp:99:5: warning: Member variable 'DeviceInfo::m_image_max_buffer_size' is not initialized in the constructor. [uninitMemberVar]
    DeviceInfo()
    ^
samples/opencl/opencl-opencv-interop.cpp:99:5: warning: Member variable 'DeviceInfo::m_image_max_array_size' is not initialized in the constructor. [uninitMemberVar]
    DeviceInfo()
    ^
samples/opencl/opencl-opencv-interop.cpp:99:5: warning: Member variable 'DeviceInfo::m_printf_buffer_size' is not initialized in the constructor. [uninitMemberVar]
    DeviceInfo()
    ^
samples/opencl/opencl-opencv-interop.cpp:99:5: warning: Member variable 'DeviceInfo::m_max_global_variable_size' is not initialized in the constructor. [uninitMemberVar]
    DeviceInfo()
    ^
samples/opencl/opencl-opencv-interop.cpp:99:5: warning: Member variable 'DeviceInfo::m_global_variable_preferred_total_size' is not initialized in the constructor. [uninitMemberVar]
    DeviceInfo()
    ^
samples/opengl/winapp.hpp:80:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'm_window_name' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        m_window_name = window_name;
        ^
samples/opengl/opengl_interop.cpp:67:18: style: The function 'cleanup' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual void cleanup()
                 ^
samples/opengl/winapp.hpp:167:18: note: Virtual function in base class
    virtual void cleanup()
                 ^
samples/opengl/opengl_interop.cpp:67:18: note: Function in derived class
    virtual void cleanup()
                 ^
samples/opengl/opengl_interop.cpp:170:9: style: The function 'init' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int init()
        ^
samples/opengl/winapp.hpp:250:17: note: Virtual function in base class
    virtual int init() = 0;
                ^
samples/opengl/opengl_interop.cpp:170:9: note: Function in derived class
    int init()
        ^
samples/opengl/opengl_interop.cpp:261:10: style: The function 'idle' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    void idle()
         ^
samples/opengl/winapp.hpp:253:18: note: Virtual function in base class
    virtual void idle() = 0;
                 ^
samples/opengl/opengl_interop.cpp:261:10: note: Function in derived class
    void idle()
         ^
samples/opengl/opengl_interop.cpp:266:9: style: The function 'render' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int render()
        ^
samples/opengl/winapp.hpp:251:17: note: Virtual function in base class
    virtual int render() = 0;
                ^
samples/opengl/opengl_interop.cpp:266:9: note: Function in derived class
    int render()
        ^
samples/opengl/winapp.hpp:76:48: style: Parameter 'window_name' can be declared with const [constParameter]
    WinApp(int width, int height, std::string& window_name)
                                               ^
samples/opengl/opengl_interop.cpp:53:81: style: Parameter 'cap' can be declared with const [constParameter]
    GLWinApp(int width, int height, std::string& window_name, cv::VideoCapture& cap) :
                                                                                ^
samples/opengl/winapp.hpp:82:9: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'm_hInstance' a value by passing the value to the constructor in the initialization list. [useInitializationList]
        m_hInstance   = ::GetModuleHandle(NULL);
        ^
samples/opengl/opengl_interop.cpp:78:30: style: The function 'WndProc' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
                             ^
samples/opengl/winapp.hpp:178:30: note: Virtual function in base class
    virtual LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) = 0;
                             ^
samples/opengl/opengl_interop.cpp:78:30: note: Function in derived class
    virtual LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
                             ^
samples/opengl/winapp.hpp:228:20: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            pWnd = (WinApp*)(pCreateStruct->lpCreateParams);
                   ^
samples/opengl/winapp.hpp:76:5: warning: Member variable 'WinApp::m_display' is not initialized in the constructor. [uninitMemberVar]
    WinApp(int width, int height, std::string& window_name)
    ^
samples/opengl/winapp.hpp:76:5: warning: Member variable 'WinApp::m_visual_info' is not initialized in the constructor. [uninitMemberVar]
    WinApp(int width, int height, std::string& window_name)
    ^
samples/opengl/winapp.hpp:76:5: warning: Member variable 'WinApp::m_event_mask' is not initialized in the constructor. [uninitMemberVar]
    WinApp(int width, int height, std::string& window_name)
    ^
samples/opengl/winapp.hpp:76:5: warning: Member variable 'WinApp::m_end_loop' is not initialized in the constructor. [uninitMemberVar]
    WinApp(int width, int height, std::string& window_name)
    ^
samples/opengl/opengl_interop.cpp:124:9: style: The function 'handle_event' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    int handle_event(XEvent& e)
        ^
samples/opengl/winapp.hpp:247:17: note: Virtual function in base class
    virtual int handle_event(XEvent& e) = 0;
                ^
samples/opengl/opengl_interop.cpp:124:9: note: Function in derived class
    int handle_event(XEvent& e)
        ^
samples/openvx/wrappers_video.cpp:128:32: style: Unused variable: ptrs [unusedVariable]
            std::vector<void*> ptrs;
                               ^
samples/tapi/hog.cpp:95:6: warning: Member variable 'App::running' is not initialized in the constructor. [uninitMemberVar]
App::App(CommandLineParser& cmd)
     ^
samples/tapi/hog.cpp:95:6: warning: Member variable 'App::hog_work_fps' is not initialized in the constructor. [uninitMemberVar]
App::App(CommandLineParser& cmd)
     ^
samples/tapi/hog.cpp:95:6: warning: Member variable 'App::work_fps' is not initialized in the constructor. [uninitMemberVar]
App::App(CommandLineParser& cmd)
     ^
samples/tapi/hog.cpp:22:5: style: Class 'App' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    App(CommandLineParser& cmd);
    ^
samples/tapi/pyrlk_optical_flow.cpp:138:17: style: Condition 'defaultPicturesFail' is always true [knownConditionTrueFalse]
            if (defaultPicturesFail)
                ^
samples/tapi/pyrlk_optical_flow.cpp:98:32: note: Assignment 'defaultPicturesFail=true', assigned value is 1
    bool defaultPicturesFail = true;
                               ^
samples/tapi/pyrlk_optical_flow.cpp:138:17: note: Condition 'defaultPicturesFail' is always true
            if (defaultPicturesFail)
                ^
samples/va_intel/va_intel_interop.cpp:62:5: warning: Member variable 'CmdlineParser::m_files' is not initialized in the constructor. [uninitMemberVar]
    CmdlineParser(int argc, char** argv):
    ^
samples/va_intel/va_intel_interop.cpp:62:5: warning: Member variable 'CmdlineParser::m_interop' is not initialized in the constructor. [uninitMemberVar]
    CmdlineParser(int argc, char** argv):
    ^
samples/va_intel/display.cpp.inc:36:5: style: Class 'Directory' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    Directory(const char* path)
    ^
samples/va_intel/display.cpp.inc:120:5: style: Class 'NodeInfo' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    NodeInfo(int adapterIndex)
    ^
samples/winrt/FaceDetection/FaceDetection/App.xaml.h:15:9: information: The code 'class App sealed {' is not handled. You can use -I or --include to add handling of this code. [class_X_Y]
    ref class App sealed
        ^
samples/winrt/FaceDetection/FaceDetection/MainPage.xaml.h:18:16: information: The code 'class MainPage sealed {' is not handled. You can use -I or --include to add handling of this code. [class_X_Y]
    public ref class MainPage sealed
               ^
samples/winrt/ImageManipulations/MainPage.xaml.h:58:69: error: syntax error [syntaxError]
            Windows::Foundation::Collections::IMap<Platform::String^, Platform::Object^>^ pageState) override;
                                                                    ^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.h:64:1: style: The class 'OcvImageManipulations' does not have a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class OcvImageManipulations
^
samples/winrt/ImageManipulations/common/LayoutAwarePage.h:53:88: error: syntax error [syntaxError]
            property Windows::Foundation::Collections::IObservableMap<Platform::String^, Platform::Object^>^ DefaultViewModel
                                                                                       ^
samples/winrt/ImageManipulations/common/suspensionmanager.cpp:38:16: error: syntax error [syntaxError]
    Map<String^, Object^>^ _sessionState = ref new Map<String^, Object^>();
               ^
samples/winrt/OcvImageProcessing/OcvImageProcessing/App.xaml.h:15:9: information: The code 'class App sealed {' is not handled. You can use -I or --include to add handling of this code. [class_X_Y]
    ref class App sealed
        ^
samples/winrt/OcvImageProcessing/OcvImageProcessing/MainPage.xaml.h:18:16: information: The code 'class MainPage sealed {' is not handled. You can use -I or --include to add handling of this code. [class_X_Y]
    public ref class MainPage sealed
               ^
samples/winrt/OcvImageProcessing/OcvImageProcessing/MainPage.xaml.cpp:82:29: error: Syntax Error: AST broken, binary operator '>' doesn't have two operands. [internalAstError]
        Platform::Array<byte>^ srcPixels = pixelProvider->DetachPixelData();
                            ^
samples/winrt_universal/PhoneTutorial/App.xaml.h:15:9: information: The code 'class App sealed {' is not handled. You can use -I or --include to add handling of this code. [class_X_Y]
    ref class App sealed
        ^
samples/winrt_universal/PhoneTutorial/MainPage.xaml.h:15:16: information: The code 'class MainPage sealed {' is not handled. You can use -I or --include to add handling of this code. [class_X_Y]
    public ref class MainPage sealed
               ^
samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.Shared/App.xaml.h:39:9: information: The code 'class App sealed {' is not handled. You can use -I or --include to add handling of this code. [class_X_Y]
    ref class App sealed
        ^
samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.Windows/MainPage.xaml.h:15:16: information: The code 'class MainPage sealed {' is not handled. You can use -I or --include to add handling of this code. [class_X_Y]
    public ref class MainPage sealed
               ^
samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.WindowsPhone/MainPage.xaml.h:15:16: information: The code 'class MainPage sealed {' is not handled. You can use -I or --include to add handling of this code. [class_X_Y]
    public ref class MainPage sealed
               ^
samples/wp8/OcvImageManipulation/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1Comp/DirectXHelper.h:34:75: error: syntax error [syntaxError]
        }).then([] (Streams::IBuffer^ fileBuffer) -> Platform::Array<byte>^
                                                                          ^
samples/wp8/OcvRotatingCube/PhoneXamlDirect3DApp1/PhoneXamlDirect3DApp1Comp/DirectXHelper.h:34:75: error: syntax error [syntaxError]
        }).then([] (Streams::IBuffer^ fileBuffer) -> Platform::Array<byte>^
                                                                          ^
samples/wp8/OpenCVXaml/OpenCVComponent/OpenCVComponent.cpp:30:50: error: syntax error [syntaxError]
    return create_async([=]() -> IVectorView<int>^
                                                 ^
3rdparty/libtiff/tif_unix.c:348:12: warning: Null pointer dereference: s [ctunullpointer]
 memcpy(d, s, (size_t) c);
           ^
3rdparty/libtiff/tif_dirread.c:4914:15: note: Assuming that condition 'data!=0' is not redundant

              ^
3rdparty/libtiff/tif_dirread.c:4912:18: note: Calling function _TIFFmemcpy, 2nd argument is null
      _TIFFmemcpy(o,data,(uint32)dp->tdir_count);
                 ^
3rdparty/libtiff/tif_unix.c:348:12: note: Dereferencing argument s that is null
 memcpy(d, s, (size_t) c);
           ^
3rdparty/libtiff/tif_win32.c:392:12: warning: Null pointer dereference: s [ctunullpointer]
 memcpy(d, s, (size_t) c);
           ^
3rdparty/libtiff/tif_dirread.c:4914:15: note: Assuming that condition 'data!=0' is not redundant

              ^
3rdparty/libtiff/tif_dirread.c:4912:18: note: Calling function _TIFFmemcpy, 2nd argument is null
      _TIFFmemcpy(o,data,(uint32)dp->tdir_count);
                 ^
3rdparty/libtiff/tif_win32.c:392:12: note: Dereferencing argument s that is null
 memcpy(d, s, (size_t) c);
           ^
modules/core/src/ocl_deprecated.hpp:685:0: error: Null pointer dereference: platforms [ctunullpointer]
OCL_FUNC(cl_int, clGetPlatformIDs,
^
modules/core/src/ocl.cpp:1727:9: note: Calling function clGetPlatformIDs, 2nd argument is null
        CV_OCL_DBG_CHECK(clGetPlatformIDs(0, NULL, &numPlatforms));
        ^
modules/core/src/ocl_deprecated.hpp:685:0: note: Dereferencing argument platforms that is null
OCL_FUNC(cl_int, clGetPlatformIDs,
^
modules/core/src/ocl_deprecated.hpp:704:0: error: Null pointer dereference: devices [ctunullpointer]
OCL_FUNC(cl_int, clGetDeviceIDs,
^
modules/core/src/ocl.cpp:1792:43: note: Calling function clGetDeviceIDs, 4th argument is null
            cl_int status = clGetDeviceIDs(platforms[i], deviceType, 0, NULL, &count);
                                          ^
modules/core/src/ocl_deprecated.hpp:704:0: note: Dereferencing argument devices that is null
OCL_FUNC(cl_int, clGetDeviceIDs,
^
modules/core/src/ocl_deprecated.hpp:905:0: error: Null pointer dereference: event_wait_list [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueCopyImageToBuffer,
^
modules/core/src/ocl.cpp:5804:5: note: Calling function clEnqueueCopyImageToBuffer, 8th argument is null
    CV_OCL_CHECK(clEnqueueCopyImageToBuffer(q, clImage, clBuffer, src_origin, region, offset, 0, NULL, NULL));
    ^
modules/core/src/ocl_deprecated.hpp:905:0: note: Dereferencing argument event_wait_list that is null
OCL_FUNC(cl_int, clEnqueueCopyImageToBuffer,
^
modules/core/src/ocl_deprecated.hpp:905:0: error: Null pointer dereference: event [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueCopyImageToBuffer,
^
modules/core/src/ocl.cpp:5804:5: note: Calling function clEnqueueCopyImageToBuffer, 9th argument is null
    CV_OCL_CHECK(clEnqueueCopyImageToBuffer(q, clImage, clBuffer, src_origin, region, offset, 0, NULL, NULL));
    ^
modules/core/src/ocl_deprecated.hpp:905:0: note: Dereferencing argument event that is null
OCL_FUNC(cl_int, clEnqueueCopyImageToBuffer,
^
modules/core/src/ocl_deprecated.hpp:918:0: error: Null pointer dereference: event_wait_list [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueCopyBufferToImage,
^
modules/core/src/ocl.cpp:6397:13: note: Calling function clEnqueueCopyBufferToImage, 8th argument is null
            CV_OCL_CHECK(clEnqueueCopyBufferToImage(queue, devData, handle, 0, origin, region, 0, NULL, 0));
            ^
modules/core/src/ocl_deprecated.hpp:918:0: note: Dereferencing argument event_wait_list that is null
OCL_FUNC(cl_int, clEnqueueCopyBufferToImage,
^
modules/core/src/ocl_deprecated.hpp:918:0: error: Null pointer dereference: event [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueCopyBufferToImage,
^
modules/core/src/ocl.cpp:6397:13: note: Calling function clEnqueueCopyBufferToImage, 9th argument is null
            CV_OCL_CHECK(clEnqueueCopyBufferToImage(queue, devData, handle, 0, origin, region, 0, NULL, 0));
            ^
modules/core/src/ocl_deprecated.hpp:918:0: note: Dereferencing argument event that is null
OCL_FUNC(cl_int, clEnqueueCopyBufferToImage,
^
modules/core/src/ocl_deprecated.hpp:1044:0: error: Null pointer dereference: event_wait_list [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueReadBuffer,
^
modules/core/src/ocl.cpp:4778:25: note: Calling function clEnqueueReadBuffer, 8th argument is null
                        CV_OCL_CHECK(clEnqueueReadBuffer(q, (cl_mem)u->handle, CL_TRUE, 0,
                        ^
modules/core/src/ocl_deprecated.hpp:1044:0: note: Dereferencing argument event_wait_list that is null
OCL_FUNC(cl_int, clEnqueueReadBuffer,
^
modules/core/src/ocl_deprecated.hpp:1044:0: error: Null pointer dereference: event [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueReadBuffer,
^
modules/core/src/ocl.cpp:4778:25: note: Calling function clEnqueueReadBuffer, 9th argument is null
                        CV_OCL_CHECK(clEnqueueReadBuffer(q, (cl_mem)u->handle, CL_TRUE, 0,
                        ^
modules/core/src/ocl_deprecated.hpp:1044:0: note: Dereferencing argument event that is null
OCL_FUNC(cl_int, clEnqueueReadBuffer,
^
modules/core/src/ocl_deprecated.hpp:1057:0: error: Null pointer dereference: event_wait_list [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueReadBufferRect,
^
modules/core/src/ocl.cpp:5233:17: note: Calling function clEnqueueReadBufferRect, 13th argument is null
                CV_OCL_CHECK(clEnqueueReadBufferRect(q, (cl_mem)u->handle, CL_TRUE,
                ^
modules/core/src/ocl_deprecated.hpp:1057:0: note: Dereferencing argument event_wait_list that is null
OCL_FUNC(cl_int, clEnqueueReadBufferRect,
^
modules/core/src/ocl_deprecated.hpp:1057:0: error: Null pointer dereference: event [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueReadBufferRect,
^
modules/core/src/ocl.cpp:5233:17: note: Calling function clEnqueueReadBufferRect, 14th argument is null
                CV_OCL_CHECK(clEnqueueReadBufferRect(q, (cl_mem)u->handle, CL_TRUE,
                ^
modules/core/src/ocl_deprecated.hpp:1057:0: note: Dereferencing argument event that is null
OCL_FUNC(cl_int, clEnqueueReadBufferRect,
^
modules/core/src/ocl_deprecated.hpp:1076:0: error: Null pointer dereference: event_wait_list [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueWriteBuffer,
^
modules/core/src/ocl.cpp:5036:13: note: Calling function clEnqueueWriteBuffer, 8th argument is null
            CV_OCL_CHECK(retval = clEnqueueWriteBuffer(q, (cl_mem)u->handle, CL_TRUE,
            ^
modules/core/src/ocl_deprecated.hpp:1076:0: note: Dereferencing argument event_wait_list that is null
OCL_FUNC(cl_int, clEnqueueWriteBuffer,
^
modules/core/src/ocl_deprecated.hpp:1076:0: error: Null pointer dereference: event [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueWriteBuffer,
^
modules/core/src/ocl.cpp:5036:13: note: Calling function clEnqueueWriteBuffer, 9th argument is null
            CV_OCL_CHECK(retval = clEnqueueWriteBuffer(q, (cl_mem)u->handle, CL_TRUE,
            ^
modules/core/src/ocl_deprecated.hpp:1076:0: note: Dereferencing argument event that is null
OCL_FUNC(cl_int, clEnqueueWriteBuffer,
^
modules/core/src/ocl_deprecated.hpp:1089:0: error: Null pointer dereference: event_wait_list [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueWriteBufferRect,
^
modules/core/src/ocl.cpp:5375:17: note: Calling function clEnqueueWriteBufferRect, 13th argument is null
                CV_OCL_CHECK(clEnqueueWriteBufferRect(q, (cl_mem)u->handle, CL_TRUE,
                ^
modules/core/src/ocl_deprecated.hpp:1089:0: note: Dereferencing argument event_wait_list that is null
OCL_FUNC(cl_int, clEnqueueWriteBufferRect,
^
modules/core/src/ocl_deprecated.hpp:1089:0: error: Null pointer dereference: event [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueWriteBufferRect,
^
modules/core/src/ocl.cpp:5375:17: note: Calling function clEnqueueWriteBufferRect, 14th argument is null
                CV_OCL_CHECK(clEnqueueWriteBufferRect(q, (cl_mem)u->handle, CL_TRUE,
                ^
modules/core/src/ocl_deprecated.hpp:1089:0: note: Dereferencing argument event that is null
OCL_FUNC(cl_int, clEnqueueWriteBufferRect,
^
modules/core/src/ocl_deprecated.hpp:1121:0: error: Null pointer dereference: event_wait_list [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueCopyBuffer,
^
modules/core/src/ocl.cpp:5520:17: note: Calling function clEnqueueCopyBuffer, 8th argument is null
                CV_OCL_CHECK(retval = clEnqueueCopyBuffer(q, (cl_mem)src->handle, (cl_mem)dst->handle,
                ^
modules/core/src/ocl_deprecated.hpp:1121:0: note: Dereferencing argument event_wait_list that is null
OCL_FUNC(cl_int, clEnqueueCopyBuffer,
^
modules/core/src/ocl_deprecated.hpp:1121:0: error: Null pointer dereference: event [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueCopyBuffer,
^
modules/core/src/ocl.cpp:5520:17: note: Calling function clEnqueueCopyBuffer, 9th argument is null
                CV_OCL_CHECK(retval = clEnqueueCopyBuffer(q, (cl_mem)src->handle, (cl_mem)dst->handle,
                ^
modules/core/src/ocl_deprecated.hpp:1121:0: note: Dereferencing argument event that is null
OCL_FUNC(cl_int, clEnqueueCopyBuffer,
^
modules/core/src/ocl_deprecated.hpp:1134:0: error: Null pointer dereference: event_wait_list [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueCopyBufferRect,
^
modules/core/src/ocl.cpp:5560:17: note: Calling function clEnqueueCopyBufferRect, 12th argument is null
                CV_OCL_CHECK(retval = clEnqueueCopyBufferRect(q, (cl_mem)src->handle, (cl_mem)dst->handle,
                ^
modules/core/src/ocl_deprecated.hpp:1134:0: note: Dereferencing argument event_wait_list that is null
OCL_FUNC(cl_int, clEnqueueCopyBufferRect,
^
modules/core/src/ocl_deprecated.hpp:1134:0: error: Null pointer dereference: event [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueCopyBufferRect,
^
modules/core/src/ocl.cpp:5560:17: note: Calling function clEnqueueCopyBufferRect, 13th argument is null
                CV_OCL_CHECK(retval = clEnqueueCopyBufferRect(q, (cl_mem)src->handle, (cl_mem)dst->handle,
                ^
modules/core/src/ocl_deprecated.hpp:1134:0: note: Dereferencing argument event that is null
OCL_FUNC(cl_int, clEnqueueCopyBufferRect,
^
modules/core/src/ocl_deprecated.hpp:1152:0: error: Null pointer dereference: event_wait_list [ctunullpointer]
OCL_FUNC_P(void*, clEnqueueMapBuffer,
^
modules/core/src/ocl.cpp:4788:60: note: Calling function clEnqueueMapBuffer, 8th argument is null
                            void* data = clEnqueueMapBuffer(q, (cl_mem)u->handle, CL_TRUE,
                                                           ^
modules/core/src/ocl_deprecated.hpp:1152:0: note: Dereferencing argument event_wait_list that is null
OCL_FUNC_P(void*, clEnqueueMapBuffer,
^
modules/core/src/ocl_deprecated.hpp:1152:0: error: Null pointer dereference: event [ctunullpointer]
OCL_FUNC_P(void*, clEnqueueMapBuffer,
^
modules/core/src/ocl.cpp:4788:60: note: Calling function clEnqueueMapBuffer, 9th argument is null
                            void* data = clEnqueueMapBuffer(q, (cl_mem)u->handle, CL_TRUE,
                                                           ^
modules/core/src/ocl_deprecated.hpp:1152:0: note: Dereferencing argument event that is null
OCL_FUNC_P(void*, clEnqueueMapBuffer,
^
modules/core/src/ocl_deprecated.hpp:1166:0: error: Null pointer dereference: event_wait_list [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueUnmapMemObject,
^
modules/core/src/ocl.cpp:4797:29: note: Calling function clEnqueueUnmapMemObject, 5th argument is null
                            CV_OCL_CHECK(clEnqueueUnmapMemObject(q, (cl_mem)u->handle, data, 0, 0, 0));
                            ^
modules/core/src/ocl_deprecated.hpp:1166:0: note: Dereferencing argument event_wait_list that is null
OCL_FUNC(cl_int, clEnqueueUnmapMemObject,
^
modules/core/src/ocl_deprecated.hpp:1166:0: error: Null pointer dereference: event [ctunullpointer]
OCL_FUNC(cl_int, clEnqueueUnmapMemObject,
^
modules/core/src/ocl.cpp:4797:29: note: Calling function clEnqueueUnmapMemObject, 6th argument is null
                            CV_OCL_CHECK(clEnqueueUnmapMemObject(q, (cl_mem)u->handle, data, 0, 0, 0));
                            ^
modules/core/src/ocl_deprecated.hpp:1166:0: note: Dereferencing argument event that is null
OCL_FUNC(cl_int, clEnqueueUnmapMemObject,
^
modules/highgui/src/window_carbon.cpp:207:28: warning: Null pointer dereference: window [ctunullpointer]
    CvTrackbar* trackbar = window->toolbar.first;
                           ^
modules/highgui/src/window_carbon.cpp:535:9: note: Assuming that condition '!window' is not redundant

        ^
modules/highgui/src/window_carbon.cpp:534:33: note: Assignment 'window=icvFindWindowByName(window_name)', assigned value is 0

                                ^
modules/highgui/src/window_carbon.cpp:538:37: note: Calling function icvFindTrackbarByName, 1st argument is null
    trackbar = icvFindTrackbarByName(window,trackbar_name);
                                    ^
modules/highgui/src/window_carbon.cpp:207:28: note: Dereferencing argument window that is null
    CvTrackbar* trackbar = window->toolbar.first;
                           ^
modules/highgui/src/window_carbon.cpp:311:9: warning: Null pointer dereference: window [ctunullpointer]
    if( window->prev )
        ^
modules/highgui/src/window_carbon.cpp:352:9: note: Assuming that condition '!window' is not redundant

        ^
modules/highgui/src/window_carbon.cpp:351:33: note: Assignment 'window=icvFindWindowByName(name)', assigned value is 0

                                ^
modules/highgui/src/window_carbon.cpp:355:20: note: Calling function icvDeleteWindow, 1st argument is null
    icvDeleteWindow( window );
                   ^
modules/highgui/src/window_carbon.cpp:311:9: note: Dereferencing argument window that is null
    if( window->prev )
        ^
modules/highgui/src/window_w32.cpp:2022:28: warning: Null pointer dereference: window [ctunullpointer]
    CvTrackbar* trackbar = window->toolbar.first;
                           ^
modules/highgui/src/window_w32.cpp:2054:9: note: Assuming that condition '!window' is not redundant

        ^
modules/highgui/src/window_w32.cpp:2053:33: note: Assignment 'window=icvFindWindowByName(window_name)', assigned value is 0

                                ^
modules/highgui/src/window_w32.cpp:2057:37: note: Calling function icvFindTrackbarByName, 1st argument is null
    trackbar = icvFindTrackbarByName(window,trackbar_name);
                                    ^
modules/highgui/src/window_w32.cpp:2022:28: note: Dereferencing argument window that is null
    CvTrackbar* trackbar = window->toolbar.first;
                           ^
modules/core/src/ocl_deprecated.hpp:789:0: error: Using argument errcode_ret that points at uninitialized variable err [ctuuninitvar]
OCL_FUNC_P(cl_mem, clCreateImage2D,
^
modules/core/src/ocl.cpp:6370:37: note: Calling function clCreateImage2D, 8th argument is uninitialized
            handle = clCreateImage2D(context, CL_MEM_READ_WRITE, &format, src.cols, src.rows, 0, NULL, &err);
                                    ^
modules/core/src/ocl_deprecated.hpp:789:0: note: Using argument errcode_ret
OCL_FUNC_P(cl_mem, clCreateImage2D,
^
modules/features2d/src/opencl/akaze.cl:111:0: style: The function 'AKAZE_compute_determinant' is never used. [unusedFunction]

^
modules/features2d/src/opencl/akaze.cl:30:0: style: The function 'AKAZE_nld_step_scalar' is never used. [unusedFunction]

^
modules/features2d/src/opencl/akaze.cl:15:0: style: The function 'AKAZE_pm_g2' is never used. [unusedFunction]

^
modules/dnn/src/opencl/activations.cl:76:0: style: The function 'AbsValForward' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:389:0: style: The function 'AddInputStreams' is never used. [unusedFunction]

^
modules/dnn/src/opencl/pooling.cl:71:0: style: The function 'AvePoolForward' is never used. [unusedFunction]

^
modules/core/src/opencl/cvtclr_dx.cl:165:0: style: The function 'BGR2YUV_NV12_8u' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/cvtcolor.cl:997:0: style: The function 'BGR5x52Gray' is never used. [unusedFunction]

^
modules/dnn/src/opencl/activations.cl:69:0: style: The function 'BNLLForward' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/atomicops_internals_x86_msvc.cc:70:0: style: The function 'Barrier_AtomicIncrement' is never used. [unusedFunction]

^
modules/features2d/src/opencl/brute_force_match.cl:178:0: style: The function 'BruteForceMatch_Match' is never used. [unusedFunction]

^
modules/features2d/src/opencl/brute_force_match.cl:308:0: style: The function 'BruteForceMatch_RadiusMatch' is never used. [unusedFunction]

^
modules/features2d/src/opencl/brute_force_match.cl:381:0: style: The function 'BruteForceMatch_knnMatch' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:630:0: style: The function 'CHexEscape' is never used. [unusedFunction]

^
3rdparty/carotene/src/canny.cpp:661:0: style: The function 'Canny3x3L1' is never used. [unusedFunction]

^
3rdparty/carotene/src/canny.cpp:688:0: style: The function 'Canny3x3L2' is never used. [unusedFunction]

^
modules/core/src/lapack.cpp:73:0: style: The function 'Cholesky' is never used. [unusedFunction]

^
modules/dnn/src/opencl/conv_layer_spatial.cl:452:0: style: The function 'Conv_Interleaved' is never used. [unusedFunction]

^
modules/dnn/src/opencl/conv_layer_spatial.cl:106:0: style: The function 'ConvolveBasic' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/listconverters.cpp:46:0: style: The function 'Copy_vector_String_to_List' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/field_mask_utility.cc:47:0: style: The function 'CreatePublicError' is never used. [unusedFunction]

^
modules/core/src/convert.sse4_1.cpp:216:0: style: The function 'Cvt_SIMD_f64u16_SSE41' is never used. [unusedFunction]

^
modules/dnn/src/opencl/conv_layer_spatial.cl:1505:0: style: The function 'DWCONV' is never used. [unusedFunction]

^
modules/dnn/src/opencl/detection_output.cl:108:0: style: The function 'DecodeBBoxesCENTER_SIZE' is never used. [unusedFunction]

^
modules/dnn/src/opencl/detection_output.cl:45:0: style: The function 'DecodeBBoxesCORNER' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:378:0: style: The function 'DeleteInputStream' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/dllmain.cpp:48:0: style: The function 'DllCanUnloadNow' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/dllmain.cpp:42:0: style: The function 'DllGetActivationFactory' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/dllmain.cpp:54:0: style: The function 'DllGetClassObject' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/dllmain.cpp:23:0: style: The function 'DllMain' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/common.cc:304:0: style: The function 'DoNothing' is never used. [unusedFunction]

^
apps/interactive-calibration/rotationConverters.cpp:120:0: style: The function 'EulerToRodrigues' is never used. [unusedFunction]

^
samples/opencl/opencl-opencv-interop.cpp:60:0: style: The function 'Extensions' is never used. [unusedFunction]

^
modules/features2d/src/opencl/fast.cl:53:0: style: The function 'FAST_findKeypoints' is never used. [unusedFunction]

^
modules/features2d/src/opencl/fast.cl:128:0: style: The function 'FAST_nonmaxSupression' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:940:0: style: The function 'FastHex32ToBuffer' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:936:0: style: The function 'FastHex64ToBuffer' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:906:0: style: The function 'FastHexToBuffer' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:1065:0: style: The function 'FastInt32ToBufferLeft' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:1116:0: style: The function 'FastInt64ToBufferLeft' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/descriptor.pb.cc:4346:0: style: The function 'FieldDescriptorProto_Label_descriptor' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/descriptor.pb.cc:4293:0: style: The function 'FieldDescriptorProto_Type_descriptor' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/descriptor.pb.cc:10264:0: style: The function 'FieldOptions_CType_descriptor' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/descriptor.pb.cc:10287:0: style: The function 'FieldOptions_JSType_descriptor' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/type.pb.cc:1146:0: style: The function 'Field_Cardinality_IsValid' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/type.pb.cc:1142:0: style: The function 'Field_Cardinality_descriptor' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/type.pb.cc:1091:0: style: The function 'Field_Kind_IsValid' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/type.pb.cc:1087:0: style: The function 'Field_Kind_descriptor' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/descriptor.pb.cc:8226:0: style: The function 'FileOptions_OptimizeMode_descriptor' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkCloudMatSink.cpp:160:0: style: The function 'FillInputPortInformation' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/utility.cc:183:0: style: The function 'FindFieldInTypeByNumberOrNull' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/utility.cc:170:0: style: The function 'FindJsonFieldInTypeOrNull' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:327:0: style: The function 'GetAttributes' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/utility.cc:81:0: style: The function 'GetDoubleOptionOrDefault' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:404:0: style: The function 'GetInputAvailableType' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:621:0: style: The function 'GetInputCurrentType' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:696:0: style: The function 'GetInputStatus' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:349:0: style: The function 'GetInputStreamAttributes' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:231:0: style: The function 'GetInputStreamInfo' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/utility.cc:71:0: style: The function 'GetInt64OptionOrDefault' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/dynamic_message.cc:584:0: style: The function 'GetMetadata' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:452:0: style: The function 'GetOutputAvailableType' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:658:0: style: The function 'GetOutputCurrentType' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:743:0: style: The function 'GetOutputStatus' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:364:0: style: The function 'GetOutputStreamAttributes' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:278:0: style: The function 'GetOutputStreamInfo' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:186:0: style: The function 'GetStreamCount' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:210:0: style: The function 'GetStreamIDs' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:157:0: style: The function 'GetStreamLimits' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/utility.cc:91:0: style: The function 'GetStringOptionOrDefault' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:1619:0: style: The function 'GlobalReplaceSubstring' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/once.cc:65:0: style: The function 'GoogleOnceInitImpl' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/cvtcolor.cl:1029:0: style: The function 'Gray2BGR5x5' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/cvtcolor.cl:194:0: style: The function 'Gray2RGB' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/generated_message_util.cc:44:0: style: The function 'Infinity' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/generated_message_util.cc:58:0: style: The function 'InitEmptyString' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/json_escaping.cc:90:0: style: The function 'IsHighSurrogate' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/json_escaping.cc:102:0: style: The function 'IsLowSurrogate' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/utility.cc:365:0: style: The function 'IsMessageSetWireFormat' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/json_escaping.cc:122:0: style: The function 'IsSupplementalCodePoint' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/utility.cc:352:0: style: The function 'IsValidBoolString' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/utility.cc:347:0: style: The function 'IsWellKnownType' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/jni_part.cpp:20:0: style: The function 'JNI_OnLoad' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/jni_part.cpp:33:0: style: The function 'JNI_OnUnload' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/utils.cpp:71:0: style: The function 'Java_org_opencv_android_Utils_nBitmapToMat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/utils.cpp:153:0: style: The function 'Java_org_opencv_android_Utils_nMatToBitmap' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1088:0: style: The function 'Java_org_opencv_core_Mat_locateROI_10' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:2099:0: style: The function 'Java_org_opencv_core_Mat_nDump' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:2061:0: style: The function 'Java_org_opencv_core_Mat_nGet' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:2016:0: style: The function 'Java_org_opencv_core_Mat_nGetB' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:2052:0: style: The function 'Java_org_opencv_core_Mat_nGetD' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:2043:0: style: The function 'Java_org_opencv_core_Mat_nGetF' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:2034:0: style: The function 'Java_org_opencv_core_Mat_nGetI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:2025:0: style: The function 'Java_org_opencv_core_Mat_nGetS' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1924:0: style: The function 'Java_org_opencv_core_Mat_nPutB' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1786:0: style: The function 'Java_org_opencv_core_Mat_nPutD' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1951:0: style: The function 'Java_org_opencv_core_Mat_nPutF' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1942:0: style: The function 'Java_org_opencv_core_Mat_nPutI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1933:0: style: The function 'Java_org_opencv_core_Mat_nPutS' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:45:0: style: The function 'Java_org_opencv_core_Mat_n_1Mat__' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:111:0: style: The function 'Java_org_opencv_core_Mat_n_1Mat__DDI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:164:0: style: The function 'Java_org_opencv_core_Mat_n_1Mat__DDIDDDD' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:86:0: style: The function 'Java_org_opencv_core_Mat_n_1Mat__III' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:138:0: style: The function 'Java_org_opencv_core_Mat_n_1Mat__IIIDDDD' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:61:0: style: The function 'Java_org_opencv_core_Mat_n_1Mat__IIILjava_nio_ByteBuffer_2' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:214:0: style: The function 'Java_org_opencv_core_Mat_n_1Mat__JII' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:191:0: style: The function 'Java_org_opencv_core_Mat_n_1Mat__JIIII' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:239:0: style: The function 'Java_org_opencv_core_Mat_n_1adjustROI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:285:0: style: The function 'Java_org_opencv_core_Mat_n_1assignTo__JJ' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:266:0: style: The function 'Java_org_opencv_core_Mat_n_1assignTo__JJI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:309:0: style: The function 'Java_org_opencv_core_Mat_n_1channels' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:379:0: style: The function 'Java_org_opencv_core_Mat_n_1checkVector__JI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:357:0: style: The function 'Java_org_opencv_core_Mat_n_1checkVector__JII' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:335:0: style: The function 'Java_org_opencv_core_Mat_n_1checkVector__JIIZ' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:406:0: style: The function 'Java_org_opencv_core_Mat_n_1clone' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:433:0: style: The function 'Java_org_opencv_core_Mat_n_1col' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:460:0: style: The function 'Java_org_opencv_core_Mat_n_1colRange' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:513:0: style: The function 'Java_org_opencv_core_Mat_n_1cols' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:579:0: style: The function 'Java_org_opencv_core_Mat_n_1convertTo__JJI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:559:0: style: The function 'Java_org_opencv_core_Mat_n_1convertTo__JJID' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:539:0: style: The function 'Java_org_opencv_core_Mat_n_1convertTo__JJIDD' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:604:0: style: The function 'Java_org_opencv_core_Mat_n_1copyTo__JJ' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:629:0: style: The function 'Java_org_opencv_core_Mat_n_1copyTo__JJJ' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:679:0: style: The function 'Java_org_opencv_core_Mat_n_1create__JDDI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:655:0: style: The function 'Java_org_opencv_core_Mat_n_1create__JIII' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:704:0: style: The function 'Java_org_opencv_core_Mat_n_1cross' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:732:0: style: The function 'Java_org_opencv_core_Mat_n_1dataAddr' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1774:0: style: The function 'Java_org_opencv_core_Mat_n_1delete' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:749:0: style: The function 'Java_org_opencv_core_Mat_n_1depth' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:803:0: style: The function 'Java_org_opencv_core_Mat_n_1diag__J' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:775:0: style: The function 'Java_org_opencv_core_Mat_n_1diag__JI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:487:0: style: The function 'Java_org_opencv_core_Mat_n_1dims' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:829:0: style: The function 'Java_org_opencv_core_Mat_n_1dot' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:856:0: style: The function 'Java_org_opencv_core_Mat_n_1elemSize' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:882:0: style: The function 'Java_org_opencv_core_Mat_n_1elemSize1' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:908:0: style: The function 'Java_org_opencv_core_Mat_n_1empty' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:960:0: style: The function 'Java_org_opencv_core_Mat_n_1eye__DDI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:934:0: style: The function 'Java_org_opencv_core_Mat_n_1eye__III' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1009:0: style: The function 'Java_org_opencv_core_Mat_n_1inv__J' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:987:0: style: The function 'Java_org_opencv_core_Mat_n_1inv__JI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1036:0: style: The function 'Java_org_opencv_core_Mat_n_1isContinuous' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1062:0: style: The function 'Java_org_opencv_core_Mat_n_1isSubmatrix' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1139:0: style: The function 'Java_org_opencv_core_Mat_n_1mul__JJ' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1115:0: style: The function 'Java_org_opencv_core_Mat_n_1mul__JJD' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1193:0: style: The function 'Java_org_opencv_core_Mat_n_1ones__DDI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1167:0: style: The function 'Java_org_opencv_core_Mat_n_1ones__III' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1220:0: style: The function 'Java_org_opencv_core_Mat_n_1push_1back' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1244:0: style: The function 'Java_org_opencv_core_Mat_n_1release' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1291:0: style: The function 'Java_org_opencv_core_Mat_n_1reshape__JI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1268:0: style: The function 'Java_org_opencv_core_Mat_n_1reshape__JII' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1318:0: style: The function 'Java_org_opencv_core_Mat_n_1row' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1345:0: style: The function 'Java_org_opencv_core_Mat_n_1rowRange' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1372:0: style: The function 'Java_org_opencv_core_Mat_n_1rows' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1398:0: style: The function 'Java_org_opencv_core_Mat_n_1setTo__JDDDD' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1426:0: style: The function 'Java_org_opencv_core_Mat_n_1setTo__JDDDDJ' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1480:0: style: The function 'Java_org_opencv_core_Mat_n_1setTo__JJ' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1455:0: style: The function 'Java_org_opencv_core_Mat_n_1setTo__JJJ' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1508:0: style: The function 'Java_org_opencv_core_Mat_n_1size' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1560:0: style: The function 'Java_org_opencv_core_Mat_n_1step1__J' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1538:0: style: The function 'Java_org_opencv_core_Mat_n_1step1__JI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1613:0: style: The function 'Java_org_opencv_core_Mat_n_1submat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1584:0: style: The function 'Java_org_opencv_core_Mat_n_1submat_1rr' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1641:0: style: The function 'Java_org_opencv_core_Mat_n_1t' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1668:0: style: The function 'Java_org_opencv_core_Mat_n_1total' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1694:0: style: The function 'Java_org_opencv_core_Mat_n_1type' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1746:0: style: The function 'Java_org_opencv_core_Mat_n_1zeros__DDI' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/Mat.cpp:1720:0: style: The function 'Java_org_opencv_core_Mat_n_1zeros__III' is never used. [unusedFunction]

^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:68:0: style: The function 'Java_org_opencv_samples_facedetect_DetectionBasedTracker_nativeCreateObject' is never used. [unusedFunction]

^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:111:0: style: The function 'Java_org_opencv_samples_facedetect_DetectionBasedTracker_nativeDestroyObject' is never used. [unusedFunction]

^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:224:0: style: The function 'Java_org_opencv_samples_facedetect_DetectionBasedTracker_nativeDetect' is never used. [unusedFunction]

^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:193:0: style: The function 'Java_org_opencv_samples_facedetect_DetectionBasedTracker_nativeSetFaceSize' is never used. [unusedFunction]

^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:141:0: style: The function 'Java_org_opencv_samples_facedetect_DetectionBasedTracker_nativeStart' is never used. [unusedFunction]

^
samples/android/face-detection/jni/DetectionBasedTracker_jni.cpp:167:0: style: The function 'Java_org_opencv_samples_facedetect_DetectionBasedTracker_nativeStop' is never used. [unusedFunction]

^
samples/android/tutorial-2-mixedprocessing/jni/jni_part.cpp:13:0: style: The function 'Java_org_opencv_samples_tutorial2_Tutorial2Activity_FindFeatures' is never used. [unusedFunction]

^
samples/android/tutorial-4-opencl/jni/jni.c:12:0: style: The function 'Java_org_opencv_samples_tutorial4_NativePart_closeCL' is never used. [unusedFunction]

^
samples/android/tutorial-4-opencl/jni/jni.c:7:0: style: The function 'Java_org_opencv_samples_tutorial4_NativePart_initCL' is never used. [unusedFunction]

^
samples/android/tutorial-4-opencl/jni/jni.c:17:0: style: The function 'Java_org_opencv_samples_tutorial4_NativePart_processFrame' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:306:0: style: The function 'JoinStrings' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/json_util.cc:219:0: style: The function 'JsonStringToMessage' is never used. [unusedFunction]

^
modules/dnn/src/opencl/lrn.cl:27:0: style: The function 'LRNComputeOutput' is never used. [unusedFunction]

^
modules/dnn/src/opencl/lrn.cl:34:0: style: The function 'LRNFillScale' is never used. [unusedFunction]

^
modules/core/src/lapack.cpp:59:0: style: The function 'LU' is never used. [unusedFunction]

^
3rdparty/carotene/src/laplacian.cpp:197:0: style: The function 'Laplacian1OpenCV' is never used. [unusedFunction]

^
3rdparty/carotene/src/laplacian.cpp:327:0: style: The function 'Laplacian3OpenCV' is never used. [unusedFunction]

^
3rdparty/carotene/src/laplacian.cpp:54:0: style: The function 'Laplacian3x3' is never used. [unusedFunction]

^
3rdparty/carotene/src/laplacian.cpp:461:0: style: The function 'Laplacian5OpenCV' is never used. [unusedFunction]

^
modules/dnn/misc/java/src/cpp/dnn_converters.cpp:22:0: style: The function 'List_to_vector_MatShape' is never used. [unusedFunction]

^
modules/dnn/misc/java/src/cpp/dnn_converters.cpp:62:0: style: The function 'List_to_vector_Ptr_Layer' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/listconverters.cpp:26:0: style: The function 'List_to_vector_String' is never used. [unusedFunction]

^
modules/dnn/misc/java/src/cpp/dnn_converters.cpp:17:0: style: The function 'MatShape_to_Mat' is never used. [unusedFunction]

^
modules/dnn/misc/java/src/cpp/dnn_converters.cpp:10:0: style: The function 'Mat_to_MatShape' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:123:0: style: The function 'Mat_to_vector_Point2d' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:148:0: style: The function 'Mat_to_vector_Point3d' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:132:0: style: The function 'Mat_to_vector_Point3i' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:80:0: style: The function 'Mat_to_vector_Rect' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:94:0: style: The function 'Mat_to_vector_Rect2d' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:23:0: style: The function 'Mat_to_vector_double' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:38:0: style: The function 'Mat_to_vector_float' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:8:0: style: The function 'Mat_to_vector_int' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:53:0: style: The function 'Mat_to_vector_uchar' is never used. [unusedFunction]

^
modules/features2d/misc/java/src/cpp/features2d_converters.cpp:88:0: style: The function 'Mat_to_vector_vector_DMatch' is never used. [unusedFunction]

^
modules/features2d/misc/java/src/cpp/features2d_converters.cpp:62:0: style: The function 'Mat_to_vector_vector_KeyPoint' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:217:0: style: The function 'Mat_to_vector_vector_Point' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:230:0: style: The function 'Mat_to_vector_vector_Point2f' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:243:0: style: The function 'Mat_to_vector_vector_Point3f' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:256:0: style: The function 'Mat_to_vector_vector_char' is never used. [unusedFunction]

^
modules/dnn/src/opencl/pooling.cl:27:0: style: The function 'MaxPoolForward' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/json_util.cc:203:0: style: The function 'MessageToJsonString' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/generated_message_util.cc:47:0: style: The function 'NaN' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/generated_message_reflection.cc:70:0: style: The function 'NameOfEnum' is never used. [unusedFunction]

^
modules/dnn/src/caffe/caffe_io.cpp:165:0: style: The function 'NetNeedsUpgrade' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/atomicops_internals_x86_msvc.cc:52:0: style: The function 'NoBarrier_CompareAndSwap' is never used. [unusedFunction]

^
3rdparty/carotene/src/canny.cpp:225:0: style: The function 'NormCanny < true >' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/struct.pb.cc:210:0: style: The function 'NullValue_IsValid' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/struct.pb.cc:206:0: style: The function 'NullValue_descriptor' is never used. [unusedFunction]

^
modules/features2d/src/opencl/orb.cl:20:0: style: The function 'ORB_HarrisResponses' is never used. [unusedFunction]

^
modules/features2d/src/opencl/orb.cl:86:0: style: The function 'ORB_ICAngle' is never used. [unusedFunction]

^
modules/features2d/src/opencl/orb.cl:134:0: style: The function 'ORB_computeDescriptor' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkVizInteractorStyle.cpp:568:0: style: The function 'OnLeftButtonDown' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkVizInteractorStyle.cpp:613:0: style: The function 'OnLeftButtonUp' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkVizInteractorStyle.cpp:634:0: style: The function 'OnMiddleButtonDown' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkVizInteractorStyle.cpp:651:0: style: The function 'OnMiddleButtonUp' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkVizInteractorStyle.cpp:523:0: style: The function 'OnMouseMove' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkVizInteractorStyle.cpp:760:0: style: The function 'OnMouseWheelBackward' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkVizInteractorStyle.cpp:722:0: style: The function 'OnMouseWheelForward' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkVizInteractorStyle.cpp:667:0: style: The function 'OnRightButtonDown' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkVizInteractorStyle.cpp:699:0: style: The function 'OnRightButtonUp' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkVizInteractorStyle.cpp:799:0: style: The function 'OnTimer' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/generated_message_reflection.cc:61:0: style: The function 'ParseNamedEnum' is never used. [unusedFunction]

^
modules/dnn/src/opencl/activations.cl:82:0: style: The function 'PowForward' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/quant_enc.c:53:0: style: The function 'PrintBlockInfo' is never used. [unusedFunction]

^
modules/imgproc/test/test_canny.cpp:347:0: style: The function 'PrintTo' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:787:0: style: The function 'ProcessEvent' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:868:0: style: The function 'ProcessInput' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:803:0: style: The function 'ProcessMessage' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:933:0: style: The function 'ProcessOutput' is never used. [unusedFunction]

^
samples/opencl/opencl-opencv-interop.cpp:56:0: style: The function 'Profile' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/cvtcolor.cl:491:0: style: The function 'RGB2YUV_YV12_IYUV' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/cvtcolor.cl:1587:0: style: The function 'RGBA2mRGBA' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfRgbaYca.cpp:65:0: style: The function 'RGBAtoYCA' is never used. [unusedFunction]

^
modules/dnn/src/opencl/activations.cl:43:0: style: The function 'ReLUForward' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/map_field.cc:58:0: style: The function 'RegisterMapEntryDefaultInstance' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:101:0: style: The function 'ReplaceCharacters' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkImageMatSource.cpp:70:0: style: The function 'RequestData' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkImageMatSource.cpp:58:0: style: The function 'RequestInformation' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/stringprintf.cc:116:0: style: The function 'SStringPrintf' is never used. [unusedFunction]

^
3rdparty/carotene/src/scharr.cpp:54:0: style: The function 'Scharr3x3' is never used. [unusedFunction]

^
3rdparty/carotene/src/scharr.cpp:81:0: style: The function 'ScharrDeriv' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:497:0: style: The function 'SetInputType' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/common.cc:272:0: style: The function 'SetLogHandler' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:772:0: style: The function 'SetOutputBounds' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:559:0: style: The function 'SetOutputType' is never used. [unusedFunction]

^
samples/winrt/ImageManipulations/MediaExtensions/OcvTransform/OcvTransform.cpp:107:0: style: The function 'SetProperties' is never used. [unusedFunction]

^
modules/dnn/src/opencl/activations.cl:63:0: style: The function 'SigmoidForward' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/utility.cc:52:0: style: The function 'SkipWhiteSpace' is never used. [unusedFunction]

^
3rdparty/carotene/src/sobel.cpp:55:0: style: The function 'Sobel3x3' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:266:0: style: The function 'SplitStringAllowEmpty' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:227:0: style: The function 'SplitStringUsing' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/stringprintf.cc:140:0: style: The function 'StringPrintfVector' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:86:0: style: The function 'StripString' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/generated_message_reflection.cc:76:0: style: The function 'SupportsArenas' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/type.pb.cc:281:0: style: The function 'Syntax_IsValid' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/type.pb.cc:277:0: style: The function 'Syntax_descriptor' is never used. [unusedFunction]

^
modules/dnn/src/torch/THDiskFile.cpp:229:0: style: The function 'THDiskFile_bigEndianEncoding' is never used. [unusedFunction]

^
modules/dnn/src/torch/THDiskFile.cpp:210:0: style: The function 'THDiskFile_isBigEndianCPU' is never used. [unusedFunction]

^
modules/dnn/src/torch/THDiskFile.cpp:222:0: style: The function 'THDiskFile_littleEndianEncoding' is never used. [unusedFunction]

^
modules/dnn/src/torch/THDiskFile.cpp:238:0: style: The function 'THDiskFile_longSize' is never used. [unusedFunction]

^
modules/dnn/src/torch/THDiskFile.cpp:215:0: style: The function 'THDiskFile_nativeEndianEncoding' is never used. [unusedFunction]

^
modules/dnn/src/torch/THDiskFile.cpp:246:0: style: The function 'THDiskFile_noBuffer' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:79:0: style: The function 'THFile_autoSpacing' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:99:0: style: The function 'THFile_clearError' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:41:0: style: The function 'THFile_close' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:67:0: style: The function 'THFile_hasError' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:66:0: style: The function 'THFile_isAutoSpacing' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:65:0: style: The function 'THFile_isBinary' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:62:0: style: The function 'THFile_isQuiet' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:63:0: style: The function 'THFile_isReadable' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:64:0: style: The function 'THFile_isWritable' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:84:0: style: The function 'THFile_noAutoSpacing' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:94:0: style: The function 'THFile_pedantic' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:89:0: style: The function 'THFile_quiet' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:112:0: style: The function 'THFile_readByteScalar' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:113:0: style: The function 'THFile_readCharScalar' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:117:0: style: The function 'THFile_readFloatScalar' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:114:0: style: The function 'THFile_readShortScalar' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:21:0: style: The function 'THFile_readStringRaw' is never used. [unusedFunction]

^
modules/dnn/src/torch/THFile.cpp:31:0: style: The function 'THFile_seekEnd' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_extension.c:60:0: style: The function 'TIFFAccessTagMethods' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dirwrite.c:194:0: style: The function 'TIFFCheckpointDirectory' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:537:0: style: The function 'TIFFClientdata' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dir.c:1344:0: style: The function 'TIFFCreateEXIFDirectory' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dir.c:1647:0: style: The function 'TIFFCurrentDirOffset' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:596:0: style: The function 'TIFFCurrentDirectory' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:587:0: style: The function 'TIFFCurrentRow' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:605:0: style: The function 'TIFFCurrentStrip' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:614:0: style: The function 'TIFFCurrentTile' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_strip.c:234:0: style: The function 'TIFFDefaultStripSize' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_tile.c:295:0: style: The function 'TIFFDefaultTileSize' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_error.c:51:0: style: The function 'TIFFError' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dirinfo.c:596:0: style: The function 'TIFFFieldDataType' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dirinfo.c:590:0: style: The function 'TIFFFieldName' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dirinfo.c:602:0: style: The function 'TIFFFieldPassCount' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dirinfo.c:608:0: style: The function 'TIFFFieldReadCount' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dirinfo.c:584:0: style: The function 'TIFFFieldTag' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dirinfo.c:572:0: style: The function 'TIFFFieldWithName' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dirinfo.c:614:0: style: The function 'TIFFFieldWriteCount' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:517:0: style: The function 'TIFFFileno' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_extension.c:66:0: style: The function 'TIFFGetClientInfo' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:686:0: style: The function 'TIFFGetCloseProc' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_compress.c:253:0: style: The function 'TIFFGetConfiguredCODECs' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:704:0: style: The function 'TIFFGetMapFileProc' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:557:0: style: The function 'TIFFGetMode' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:659:0: style: The function 'TIFFGetReadProc' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:677:0: style: The function 'TIFFGetSeekProc' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:695:0: style: The function 'TIFFGetSizeProc' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:713:0: style: The function 'TIFFGetUnmapFileProc' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_version.c:30:0: style: The function 'TIFFGetVersion' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:668:0: style: The function 'TIFFGetWriteProc' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_jpeg.c:2483:0: style: The function 'TIFFInitJPEG' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_ojpeg.c:420:0: style: The function 'TIFFInitOJPEG' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:650:0: style: The function 'TIFFIsBigEndian' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:623:0: style: The function 'TIFFIsByteSwapped' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:641:0: style: The function 'TIFFIsMSB2LSB' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:632:0: style: The function 'TIFFIsUpSampled' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_jpeg.c:1060:0: style: The function 'TIFFJPEGIsFullStripRequired' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dir.c:1657:0: style: The function 'TIFFLastDirectory' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dirinfo.c:890:0: style: The function 'TIFFMergeFieldInfo' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dir.c:1567:0: style: The function 'TIFFNumberOfDirectories' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_win32.c:297:0: style: The function 'TIFFOpenW' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_predict.c:859:0: style: The function 'TIFFPredictorCleanup' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_predict.c:818:0: style: The function 'TIFFPredictorInit' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_print.c:236:0: style: The function 'TIFFPrintDirectory' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_strip.c:367:0: style: The function 'TIFFRasterScanlineSize' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_strip.c:174:0: style: The function 'TIFFRawStripSize' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dirread.c:4410:0: style: The function 'TIFFReadEXIFDirectory' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_getimage.c:547:0: style: The function 'TIFFReadRGBAImage' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_read.c:709:0: style: The function 'TIFFReadRawStrip' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_read.c:1170:0: style: The function 'TIFFReadRawTile' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_read.c:440:0: style: The function 'TIFFReadScanline' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_compress.c:202:0: style: The function 'TIFFRegisterCODEC' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_extension.c:80:0: style: The function 'TIFFSetClientInfo' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:546:0: style: The function 'TIFFSetClientdata' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dir.c:1598:0: style: The function 'TIFFSetDirectory' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_error.c:43:0: style: The function 'TIFFSetErrorHandlerExt' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:506:0: style: The function 'TIFFSetFileName' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:526:0: style: The function 'TIFFSetFileno' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_open.c:566:0: style: The function 'TIFFSetMode' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dir.c:1632:0: style: The function 'TIFFSetSubDirectory' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dir.c:1295:0: style: The function 'TIFFSetTagExtender' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_warning.c:43:0: style: The function 'TIFFSetWarningHandlerExt' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_stream.cxx:397:0: style: The function 'TIFFStreamOpen' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_swab.c:170:0: style: The function 'TIFFSwabDouble' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_swab.c:141:0: style: The function 'TIFFSwabFloat' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_compress.c:225:0: style: The function 'TIFFUnRegisterCODEC' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dir.c:1666:0: style: The function 'TIFFUnlinkDirectory' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dir.c:807:0: style: The function 'TIFFUnsetField' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_tile.c:249:0: style: The function 'TIFFVTileSize' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_warning.c:51:0: style: The function 'TIFFWarning' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dirwrite.c:206:0: style: The function 'TIFFWriteCustomDirectory' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_write.c:306:0: style: The function 'TIFFWriteRawStrip' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_write.c:507:0: style: The function 'TIFFWriteRawTile' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_write.c:354:0: style: The function 'TIFFWriteTile' is never used. [unusedFunction]

^
modules/dnn/src/opencl/activations.cl:57:0: style: The function 'TanHForward' is never used. [unusedFunction]

^
modules/ts/src/ts_perf.cpp:87:0: style: The function 'TearDown' is never used. [unusedFunction]

^
modules/ts/src/ts_perf.cpp:1199:0: style: The function 'TestBody' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/internal/json_escaping.cc:138:0: style: The function 'ToCodePoint' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/util/time_util.cc:405:0: style: The function 'ToTimestamp' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dsp/argb.c:48:0: style: The function 'VP8EncDspARGBInit' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dsp/argb_mips_dsp_r2.c:108:0: style: The function 'VP8EncDspARGBInitMIPSdspR2' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dsp/argb_sse2.c:68:0: style: The function 'VP8EncDspARGBInitSSE2' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/vp8_dec.c:47:0: style: The function 'VP8InitIoInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/utils/bit_reader_utils.c:192:0: style: The function 'VP8LDoFillBitWindow' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/near_lossless_enc.c:149:0: style: The function 'VP8LNearLosslessStub' is never used. [unusedFunction]

^
3rdparty/libwebp/src/utils/bit_writer_utils.c:276:0: style: The function 'VP8LPutBitsFlushBits' is never used. [unusedFunction]

^
3rdparty/libwebp/src/utils/bit_writer_utils.c:293:0: style: The function 'VP8LPutBitsInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/backward_references_enc.c:127:0: style: The function 'VP8LRefsCursorNextBlock' is never used. [unusedFunction]

^
3rdparty/libwebp/src/utils/bit_reader_utils.c:87:0: style: The function 'VP8LoadFinalBytes' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/vp8_dec.c:69:0: style: The function 'VP8Status' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/vp8_dec.c:74:0: style: The function 'VP8StatusMessage' is never used. [unusedFunction]

^
samples/opencl/opencl-opencv-interop.cpp:59:0: style: The function 'Vendor' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/common.cc:62:0: style: The function 'VerifyVersion' is never used. [unusedFunction]

^
3rdparty/libwebp/src/demux/anim_decode.c:441:0: style: The function 'WebPAnimDecoderGetDemuxer' is never used. [unusedFunction]

^
3rdparty/libwebp/src/demux/anim_decode.c:131:0: style: The function 'WebPAnimDecoderGetInfo' is never used. [unusedFunction]

^
3rdparty/libwebp/src/demux/anim_decode.c:309:0: style: The function 'WebPAnimDecoderGetNext' is never used. [unusedFunction]

^
3rdparty/libwebp/src/demux/anim_decode.c:85:0: style: The function 'WebPAnimDecoderNewInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/demux/anim_decode.c:53:0: style: The function 'WebPAnimDecoderOptionsInitInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/anim_encode.c:1337:0: style: The function 'WebPAnimEncoderAdd' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/anim_encode.c:1518:0: style: The function 'WebPAnimEncoderAssemble' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/anim_encode.c:1576:0: style: The function 'WebPAnimEncoderGetError' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/anim_encode.c:236:0: style: The function 'WebPAnimEncoderNewInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/anim_encode.c:183:0: style: The function 'WebPAnimEncoderOptionsInitInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/anim_encode.c:594:0: style: The function 'WebPAnimEncoderRefineRect' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_tools_enc.c:198:0: style: The function 'WebPBlendAlpha' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/config_enc.c:24:0: style: The function 'WebPConfigInitInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/config_enc.c:144:0: style: The function 'WebPConfigLosslessPreset' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/webp_dec.c:643:0: style: The function 'WebPDecodeARGB' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/webp_dec.c:560:0: style: The function 'WebPDecodeARGBInto' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/webp_dec.c:648:0: style: The function 'WebPDecodeBGR' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/webp_dec.c:653:0: style: The function 'WebPDecodeBGRA' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/webp_dec.c:633:0: style: The function 'WebPDecodeRGB' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/webp_dec.c:638:0: style: The function 'WebPDecodeRGBA' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/webp_dec.c:555:0: style: The function 'WebPDecodeRGBAInto' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/webp_dec.c:550:0: style: The function 'WebPDecodeRGBInto' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/webp_dec.c:658:0: style: The function 'WebPDecodeYUV' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/webp_dec.c:575:0: style: The function 'WebPDecodeYUVInto' is never used. [unusedFunction]

^
3rdparty/libwebp/src/demux/demux.c:936:0: style: The function 'WebPDemuxGetChunk' is never used. [unusedFunction]

^
3rdparty/libwebp/src/demux/demux.c:697:0: style: The function 'WebPDemuxInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/demux/demux.c:946:0: style: The function 'WebPDemuxNextChunk' is never used. [unusedFunction]

^
3rdparty/libwebp/src/demux/demux.c:872:0: style: The function 'WebPDemuxNextFrame' is never used. [unusedFunction]

^
3rdparty/libwebp/src/demux/demux.c:955:0: style: The function 'WebPDemuxPrevChunk' is never used. [unusedFunction]

^
3rdparty/libwebp/src/demux/demux.c:877:0: style: The function 'WebPDemuxPrevFrame' is never used. [unusedFunction]

^
3rdparty/libwebp/src/demux/demux.c:964:0: style: The function 'WebPDemuxReleaseChunkIterator' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_enc.c:287:0: style: The function 'WebPEncodeLosslessRGB' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_enc.c:288:0: style: The function 'WebPEncodeLosslessRGBA' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_enc.c:272:0: style: The function 'WebPEncodeRGB' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_enc.c:273:0: style: The function 'WebPEncodeRGBA' is never used. [unusedFunction]

^
3rdparty/libwebp/src/utils/utils.c:220:0: style: The function 'WebPFree' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/vp8_dec.c:25:0: style: The function 'WebPGetDecoderVersion' is never used. [unusedFunction]

^
3rdparty/libwebp/src/demux/demux.c:102:0: style: The function 'WebPGetDemuxVersion' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/webp_enc.c:32:0: style: The function 'WebPGetEncoderVersion' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/webp_dec.c:733:0: style: The function 'WebPGetFeaturesInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/muxinternal.c:38:0: style: The function 'WebPGetMuxVersion' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/buffer_dec.c:260:0: style: The function 'WebPGrabDecBuffer' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/idec_dec.c:765:0: style: The function 'WebPIAppend' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/idec_dec.c:838:0: style: The function 'WebPIDecGetRGB' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/idec_dec.c:854:0: style: The function 'WebPIDecGetYUVA' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/idec_dec.c:627:0: style: The function 'WebPIDecode' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/idec_dec.c:822:0: style: The function 'WebPIDecodedArea' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/idec_dec.c:655:0: style: The function 'WebPIDelete' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/idec_dec.c:676:0: style: The function 'WebPINewRGB' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/idec_dec.c:743:0: style: The function 'WebPINewYUV' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/idec_dec.c:877:0: style: The function 'WebPISetIOHooks' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/idec_dec.c:786:0: style: The function 'WebPIUpdate' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/buffer_dec.c:230:0: style: The function 'WebPInitDecBufferInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/dec/webp_dec.c:719:0: style: The function 'WebPInitDecoderConfigInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/muxread.c:168:0: style: The function 'WebPMuxCreateInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/muxedit.c:377:0: style: The function 'WebPMuxDeleteChunk' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/muxedit.c:382:0: style: The function 'WebPMuxDeleteFrame' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/muxread.c:484:0: style: The function 'WebPMuxGetAnimationParams' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/muxread.c:406:0: style: The function 'WebPMuxGetChunk' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/muxedit.c:178:0: style: The function 'WebPMuxSetChunk' is never used. [unusedFunction]

^
3rdparty/libwebp/src/mux/muxedit.c:29:0: style: The function 'WebPNewInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_csp_enc.c:1009:0: style: The function 'WebPPictureARGBToYUVA' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_rescale_enc.c:126:0: style: The function 'WebPPictureCrop' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_psnr_enc.c:172:0: style: The function 'WebPPictureDistortion' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_csp_enc.c:1154:0: style: The function 'WebPPictureImportBGRX' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_csp_enc.c:1177:0: style: The function 'WebPPictureImportRGBX' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_enc.c:34:0: style: The function 'WebPPictureInitInternal' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_rescale_enc.c:85:0: style: The function 'WebPPictureIsView' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_rescale_enc.c:198:0: style: The function 'WebPPictureRescale' is never used. [unusedFunction]

^
3rdparty/libwebp/src/enc/picture_csp_enc.c:1017:0: style: The function 'WebPPictureSmartARGBToYUVA' is never used. [unusedFunction]

^
3rdparty/libwebp/src/utils/thread_utils.c:344:0: style: The function 'WebPSetWorkerInterface' is never used. [unusedFunction]

^
modules/viz/src/vtk/vtkCloudMatSink.cpp:63:0: style: The function 'WriteData' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfChromaticities.cpp:129:0: style: The function 'XYZtoRGB' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfRgbaYca.cpp:357:0: style: The function 'YCAtoRGBA' is never used. [unusedFunction]

^
modules/core/src/opencl/cvtclr_dx.cl:84:0: style: The function 'YUV2BGR_NV12_8u' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/cvtcolor.cl:595:0: style: The function 'YUV2RGB_422' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/cvtcolor.cl:335:0: style: The function 'YUV2RGB_NVx' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/cvtcolor.cl:406:0: style: The function 'YUV2RGB_YV12_IYUV' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dirinfo.c:620:0: style: The function '_TIFFFindOrRegisterField' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dirinfo.c:416:0: style: The function '_TIFFPrintFieldInfo' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_aux.c:347:0: style: The function '_TIFFUInt64ToDouble' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_aux.c:331:0: style: The function '_TIFFUInt64ToFloat' is never used. [unusedFunction]

^
3rdparty/libtiff/snprintf.c:13:0: style: The function '_TIFF_vsnprintf_f' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_print.c:708:0: style: The function '_TIFFprintAsciiTag' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dir.c:67:0: style: The function '_TIFFsetLongArray' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_dir.c:61:0: style: The function '_TIFFsetString' is never used. [unusedFunction]

^
3rdparty/zlib/trees.c:1014:0: style: The function '_tr_tally' is never used. [unusedFunction]

^
3rdparty/carotene/src/absdiff.cpp:109:0: style: The function 'absDiff' is never used. [unusedFunction]

^
3rdparty/openexr/IlmThread/IlmThreadPool.cpp:450:0: style: The function 'addGlobalTask' is never used. [unusedFunction]

^
3rdparty/zlib/adler32.c:172:0: style: The function 'adler32_combine' is never used. [unusedFunction]

^
3rdparty/zlib/adler32.c:180:0: style: The function 'adler32_combine64' is never used. [unusedFunction]

^
modules/features2d/src/agast_score.cpp:9839:0: style: The function 'agast_cornerScore < AgastFeatureDetector :: AGAST_5_8 >' is never used. [unusedFunction]

^
modules/features2d/src/agast_score.cpp:9846:0: style: The function 'agast_cornerScore < AgastFeatureDetector :: AGAST_7_12d >' is never used. [unusedFunction]

^
modules/features2d/src/agast_score.cpp:9853:0: style: The function 'agast_cornerScore < AgastFeatureDetector :: AGAST_7_12s >' is never used. [unusedFunction]

^
modules/features2d/src/agast_score.cpp:9860:0: style: The function 'agast_cornerScore < AgastFeatureDetector :: OAST_9_16 >' is never used. [unusedFunction]

^
modules/ts/src/cuda_test.cpp:390:0: style: The function 'all_types' is never used. [unusedFunction]

^
3rdparty/cpufeatures/cpu-features.c:1103:0: style: The function 'android_getCpuCount' is never used. [unusedFunction]

^
3rdparty/cpufeatures/cpu-features.c:1132:0: style: The function 'android_getCpuIdArm' is never used. [unusedFunction]

^
3rdparty/cpufeatures/cpu-features.c:1139:0: style: The function 'android_setCpuArm' is never used. [unusedFunction]

^
modules/core/src/opencl/flip.cl:129:0: style: The function 'arithm_flip_cols' is never used. [unusedFunction]

^
modules/core/src/opencl/flip.cl:52:0: style: The function 'arithm_flip_rows' is never used. [unusedFunction]

^
modules/core/src/opencl/flip.cl:83:0: style: The function 'arithm_flip_rows_cols' is never used. [unusedFunction]

^
modules/superres/src/input_array_utility.cpp:48:0: style: The function 'arrGetMat' is never used. [unusedFunction]

^
modules/superres/src/input_array_utility.cpp:65:0: style: The function 'arrGetUMat' is never used. [unusedFunction]

^
modules/ts/src/cuda_test.cpp:474:0: style: The function 'assertKeyPointsEquals' is never used. [unusedFunction]

^
modules/ts/src/cuda_test.cpp:318:0: style: The function 'assertMatNear' is never used. [unusedFunction]

^
modules/dnn/src/opencl/ocl4dnn_pooling.cl:99:0: style: The function 'ave_pool_forward_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/math.cl:47:0: style: The function 'axpy_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/batchnorm.cl:2:0: style: The function 'batchnorm' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:293:0: style: The function 'bgr2gray' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:1950:0: style: The function 'bgr2hsv' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2358:0: style: The function 'bgr2ycrcb' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:395:0: style: The function 'bgrx2gray' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2002:0: style: The function 'bgrx2hsv' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2402:0: style: The function 'bgrx2ycrcb' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/bilateral.cl:59:0: style: The function 'bilateral' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/bilateral.cl:99:0: style: The function 'bilateral_float4' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfTimeCode.cpp:318:0: style: The function 'binaryGroup' is never used. [unusedFunction]

^
3rdparty/carotene/src/bitwise.cpp:159:0: style: The function 'bitwiseAnd' is never used. [unusedFunction]

^
3rdparty/carotene/src/bitwise.cpp:115:0: style: The function 'bitwiseNot' is never used. [unusedFunction]

^
3rdparty/carotene/src/bitwise.cpp:181:0: style: The function 'bitwiseOr' is never used. [unusedFunction]

^
3rdparty/carotene/src/bitwise.cpp:203:0: style: The function 'bitwiseXor' is never used. [unusedFunction]

^
modules/dnn/test/npy_blob.cpp:63:0: style: The function 'blobFromNPY' is never used. [unusedFunction]

^
3rdparty/carotene/src/blur.cpp:54:0: style: The function 'blur3x3' is never used. [unusedFunction]

^
3rdparty/carotene/src/blur.cpp:501:0: style: The function 'blur5x5' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/boxFilter3x3.cl:5:0: style: The function 'boxFilter3x3_8UC1_cols16_rows2' is never used. [unusedFunction]

^
modules/video/src/opencl/optical_flow_farneback.cl:350:0: style: The function 'boxFilter5' is never used. [unusedFunction]

^
modules/imgcodecs/src/bitstrm.cpp:51:0: style: The function 'bsIsBigEndian' is never used. [unusedFunction]

^
modules/superres/src/opencl/superres_btvl1.cl:54:0: style: The function 'buildMotionMaps' is never used. [unusedFunction]

^
modules/photo/src/opencl/nlmeans.cl:23:0: style: The function 'calcAlmostDist2Weight' is never used. [unusedFunction]

^
modules/superres/src/opencl/superres_btvl1.cl:130:0: style: The function 'calcBtvRegularization' is never used. [unusedFunction]

^
modules/objdetect/src/cascadedetect.cpp:433:0: style: The function 'calcCat' is never used. [unusedFunction]

^
modules/objdetect/src/cascadedetect.cpp:432:0: style: The function 'calcOrd' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfTiledMisc.cpp:111:0: style: The function 'calculateBytesPerPixel' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/histogram.cl:50:0: style: The function 'calculate_histogram' is never used. [unusedFunction]

^
modules/stitching/src/autocalib.cpp:142:0: style: The function 'calibrateRotatingCamera' is never used. [unusedFunction]

^
modules/video/src/opencl/optical_flow_tvl1.cl:46:0: style: The function 'centeredGradientKernel' is never used. [unusedFunction]

^
samples/cpp/travelsalesman.cpp:28:0: style: The function 'changeState' is never used. [unusedFunction]

^
modules/viz/test/test_common.cpp:20:0: style: The function 'change_extension' is never used. [unusedFunction]

^
modules/ts/src/ts.cpp:688:0: style: The function 'checkIppStatus' is never used. [unusedFunction]

^
modules/ts/src/cuda_test.cpp:363:0: style: The function 'checkSimilarity' is never used. [unusedFunction]

^
modules/objdetect/src/opencl/objdetect_hog.cl:291:0: style: The function 'classify_hists_180_kernel' is never used. [unusedFunction]

^
modules/objdetect/src/opencl/objdetect_hog.cl:364:0: style: The function 'classify_hists_252_kernel' is never used. [unusedFunction]

^
modules/objdetect/src/opencl/objdetect_hog.cl:433:0: style: The function 'classify_hists_kernel' is never used. [unusedFunction]

^
apps/interactive-calibration/frameProcessor.cpp:487:0: style: The function 'clearBoardsView' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:3566:0: style: The function 'clearSeq' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:1565:0: style: The function 'closeEvent' is never used. [unusedFunction]

^
3rdparty/carotene/src/cmp.cpp:308:0: style: The function 'cmpEQ' is never used. [unusedFunction]

^
3rdparty/carotene/src/cmp.cpp:332:0: style: The function 'cmpGE' is never used. [unusedFunction]

^
3rdparty/carotene/src/cmp.cpp:324:0: style: The function 'cmpGT' is never used. [unusedFunction]

^
3rdparty/carotene/src/cmp.cpp:316:0: style: The function 'cmpNE' is never used. [unusedFunction]

^
modules/ts/src/ts_func.cpp:1835:0: style: The function 'cmpUlps' is never used. [unusedFunction]

^
modules/dnn/src/opencl/col2im.cl:27:0: style: The function 'col2im' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/filterSepCol.cl:66:0: style: The function 'col_filter' is never used. [unusedFunction]

^
3rdparty/carotene/src/channels_combine.cpp:222:0: style: The function 'combine2' is never used. [unusedFunction]

^
3rdparty/carotene/src/channels_combine.cpp:223:0: style: The function 'combine3' is never used. [unusedFunction]

^
3rdparty/carotene/src/channels_combine.cpp:224:0: style: The function 'combine4' is never used. [unusedFunction]

^
3rdparty/carotene/src/channels_combine.cpp:312:0: style: The function 'combineUYVY' is never used. [unusedFunction]

^
3rdparty/carotene/src/channels_combine.cpp:235:0: style: The function 'combineYUYV' is never used. [unusedFunction]

^
modules/imgproc/src/lsd.cpp:1172:0: style: The function 'compareSegments' is never used. [unusedFunction]

^
3rdparty/zlib/compress.c:81:0: style: The function 'compressBound' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.cpp:245:0: style: The function 'compressTile' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/linearPolar.cl:3:0: style: The function 'computeAngleRadius' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfRgbaYca.cpp:57:0: style: The function 'computeYw' is never used. [unusedFunction]

^
modules/objdetect/src/opencl/objdetect_hog.cl:664:0: style: The function 'compute_gradients_8UC1_kernel' is never used. [unusedFunction]

^
modules/objdetect/src/opencl/objdetect_hog.cl:565:0: style: The function 'compute_gradients_8UC4_kernel' is never used. [unusedFunction]

^
modules/objdetect/src/opencl/objdetect_hog.cl:65:0: style: The function 'compute_hists_lut_kernel' is never used. [unusedFunction]

^
modules/dnn/src/opencl/concat.cl:42:0: style: The function 'concat' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:2668:0: style: The function 'contextMenuEvent' is never used. [unusedFunction]

^
3rdparty/carotene/src/convert_scale.cpp:186:0: style: The function 'convertScale' is never used. [unusedFunction]

^
modules/superres/src/input_array_utility.cpp:237:0: style: The function 'convertToType' is never used. [unusedFunction]

^
modules/python/src2/cv2.cpp:1655:0: style: The function 'convert_to_char' is never used. [unusedFunction]

^
3rdparty/carotene/src/convolution.cpp:76:0: style: The function 'convolution' is never used. [unusedFunction]

^
modules/core/src/opencl/copyset.cl:53:0: style: The function 'copyToMask' is never used. [unusedFunction]

^
modules/dnn/src/opencl/conv_spatial_helper.cl:46:0: style: The function 'copyWeightsSwizzled_float' is never used. [unusedFunction]

^
modules/calib3d/src/epnp.cpp:199:0: style: The function 'copy_R_and_t' is never used. [unusedFunction]

^
modules/features2d/src/fast_score.cpp:213:0: style: The function 'cornerScore < 12 >' is never used. [unusedFunction]

^
modules/features2d/src/fast_score.cpp:120:0: style: The function 'cornerScore < 16 >' is never used. [unusedFunction]

^
modules/features2d/src/fast_score.cpp:298:0: style: The function 'cornerScore < 8 >' is never used. [unusedFunction]

^
3rdparty/zlib/crc32.c:428:0: style: The function 'crc32_combine' is never used. [unusedFunction]

^
3rdparty/zlib/crc32.c:436:0: style: The function 'crc32_combine64' is never used. [unusedFunction]

^
modules/shape/src/aff_trans.cpp:268:0: style: The function 'createAffineTransformer' is never used. [unusedFunction]

^
modules/imgproc/src/deriv.cpp:176:0: style: The function 'createDerivFilter' is never used. [unusedFunction]

^
modules/shape/src/hist_cost.cpp:310:0: style: The function 'createEMDHistogramCostExtractor' is never used. [unusedFunction]

^
modules/objdetect/src/cascadedetect.cpp:970:0: style: The function 'createFaceDetectionMaskGenerator' is never used. [unusedFunction]

^
modules/stitching/src/blenders.cpp:756:0: style: The function 'createLaplacePyrGpu' is never used. [unusedFunction]

^
modules/shape/src/hist_cost.cpp:170:0: style: The function 'createNormHistogramCostExtractor' is never used. [unusedFunction]

^
modules/stitching/src/stitcher.cpp:605:0: style: The function 'createStitcher' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:2025:0: style: The function 'cvAbsDiff' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:2035:0: style: The function 'cvAbsDiffS' is never used. [unusedFunction]

^
modules/imgproc/src/thresh.cpp:1606:0: style: The function 'cvAdaptiveThreshold' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:1966:0: style: The function 'cvAddS' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:2013:0: style: The function 'cvAddWeighted' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:1876:0: style: The function 'cvAnd' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:1912:0: style: The function 'cvAndS' is never used. [unusedFunction]

^
modules/imgproc/src/histogram.cpp:3488:0: style: The function 'cvCalcArrBackProject' is never used. [unusedFunction]

^
modules/imgproc/src/histogram.cpp:3541:0: style: The function 'cvCalcArrBackProjectPatch' is never used. [unusedFunction]

^
modules/imgproc/src/histogram.cpp:3422:0: style: The function 'cvCalcArrHist' is never used. [unusedFunction]

^
modules/core/src/matmul.cpp:3380:0: style: The function 'cvCalcCovarMatrix' is never used. [unusedFunction]

^
modules/video/src/compat_video.cpp:290:0: style: The function 'cvCalcOpticalFlowFarneback' is never used. [unusedFunction]

^
modules/imgproc/src/histogram.cpp:3650:0: style: The function 'cvCalcProbDensity' is never used. [unusedFunction]

^
modules/core/src/mathfuncs.cpp:1628:0: style: The function 'cvCbrt' is never used. [unusedFunction]

^
modules/core/src/array.cpp:3156:0: style: The function 'cvCheckTermCriteria' is never used. [unusedFunction]

^
modules/imgproc/src/histogram.cpp:2928:0: style: The function 'cvClearHist' is never used. [unusedFunction]

^
modules/imgproc/src/drawing.cpp:2680:0: style: The function 'cvClipLine' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:3251:0: style: The function 'cvCloneGraph' is never used. [unusedFunction]

^
modules/core/src/array.cpp:3116:0: style: The function 'cvCloneImage' is never used. [unusedFunction]

^
modules/core/src/array.cpp:602:0: style: The function 'cvCloneSparseMat' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:2066:0: style: The function 'cvCmp' is never used. [unusedFunction]

^
modules/imgproc/src/drawing.cpp:2698:0: style: The function 'cvColorToScalar' is never used. [unusedFunction]

^
modules/core/src/matrix.cpp:4567:0: style: The function 'cvCompleteSymm' is never used. [unusedFunction]

^
modules/core/src/convert.cpp:4824:0: style: The function 'cvConvertScaleAbs' is never used. [unusedFunction]

^
modules/imgproc/src/convhull.cpp:515:0: style: The function 'cvConvexityDefects' is never used. [unusedFunction]

^
modules/imgproc/src/utils.cpp:79:0: style: The function 'cvCopyMakeBorder' is never used. [unusedFunction]

^
modules/imgproc/src/corner.cpp:768:0: style: The function 'cvCornerHarris' is never used. [unusedFunction]

^
modules/videoio/src/cap_giganetix.cpp:751:0: style: The function 'cvCreateCameraCapture_Giganetix' is never used. [unusedFunction]

^
modules/videoio/src/cap_openni.cpp:1349:0: style: The function 'cvCreateCameraCapture_OpenNI' is never used. [unusedFunction]

^
modules/videoio/src/cap_openni2.cpp:1074:0: style: The function 'cvCreateCameraCapture_OpenNI2' is never used. [unusedFunction]

^
modules/videoio/src/cap_pvapi.cpp:602:0: style: The function 'cvCreateCameraCapture_PvAPI' is never used. [unusedFunction]

^
modules/videoio/src/cap_qt.cpp:1559:0: style: The function 'cvCreateCameraCapture_QT' is never used. [unusedFunction]

^
modules/videoio/src/cap_unicap.cpp:325:0: style: The function 'cvCreateCameraCapture_Unicap' is never used. [unusedFunction]

^
modules/videoio/src/cap_vfw.cpp:667:0: style: The function 'cvCreateCameraCapture_VFW' is never used. [unusedFunction]

^
modules/videoio/src/cap_ximea.cpp:45:0: style: The function 'cvCreateCameraCapture_XIMEA' is never used. [unusedFunction]

^
modules/videoio/src/cap_gstreamer.cpp:1245:0: style: The function 'cvCreateCapture_GStreamer' is never used. [unusedFunction]

^
modules/videoio/src/cap.cpp:369:0: style: The function 'cvCreateFileCapture' is never used. [unusedFunction]

^
modules/videoio/src/cap_ffmpeg.cpp:254:0: style: The function 'cvCreateFileCapture_FFMPEG_proxy' is never used. [unusedFunction]

^
modules/videoio/src/cap_openni.cpp:1360:0: style: The function 'cvCreateFileCapture_OpenNI' is never used. [unusedFunction]

^
modules/videoio/src/cap_openni2.cpp:1085:0: style: The function 'cvCreateFileCapture_OpenNI2' is never used. [unusedFunction]

^
modules/videoio/src/cap_qt.cpp:1490:0: style: The function 'cvCreateFileCapture_QT' is never used. [unusedFunction]

^
modules/videoio/src/cap_vfw.cpp:300:0: style: The function 'cvCreateFileCapture_VFW' is never used. [unusedFunction]

^
modules/videoio/src/cap_xine.cpp:834:0: style: The function 'cvCreateFileCapture_XINE' is never used. [unusedFunction]

^
modules/core/src/array.cpp:272:0: style: The function 'cvCreateMatND' is never used. [unusedFunction]

^
modules/imgproc/src/pyramids.cpp:1673:0: style: The function 'cvCreatePyramid' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:909:0: style: The function 'cvCreateSeqBlock' is never used. [unusedFunction]

^
modules/calib3d/src/compat_stereo.cpp:46:0: style: The function 'cvCreateStereoBMState' is never used. [unusedFunction]

^
modules/highgui/src/window.cpp:625:0: style: The function 'cvCreateTrackbar' is never used. [unusedFunction]

^
modules/videoio/src/cap.cpp:434:0: style: The function 'cvCreateVideoWriter' is never used. [unusedFunction]

^
modules/videoio/src/cap_ffmpeg.cpp:302:0: style: The function 'cvCreateVideoWriter_FFMPEG_proxy' is never used. [unusedFunction]

^
modules/videoio/src/cap_gstreamer.cpp:1811:0: style: The function 'cvCreateVideoWriter_GStreamer' is never used. [unusedFunction]

^
modules/videoio/src/cap_qt.cpp:1611:0: style: The function 'cvCreateVideoWriter_QT' is never used. [unusedFunction]

^
modules/videoio/src/cap_vfw.cpp:859:0: style: The function 'cvCreateVideoWriter_VFW' is never used. [unusedFunction]

^
modules/core/src/dxt.cpp:4519:0: style: The function 'cvDCT' is never used. [unusedFunction]

^
modules/core/src/dxt.cpp:4481:0: style: The function 'cvDFT' is never used. [unusedFunction]

^
modules/imgcodecs/src/loadsave.cpp:971:0: style: The function 'cvDecodeImage' is never used. [unusedFunction]

^
modules/imgcodecs/src/loadsave.cpp:979:0: style: The function 'cvDecodeImageM' is never used. [unusedFunction]

^
samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.Shared/main.cpp:128:0: style: The function 'cvDetectFaces' is never used. [unusedFunction]

^
modules/core/src/matmul.cpp:3430:0: style: The function 'cvDotProduct' is never used. [unusedFunction]

^
modules/core/src/lapack.cpp:1673:0: style: The function 'cvEigenVV' is never used. [unusedFunction]

^
modules/imgproc/src/drawing.cpp:2688:0: style: The function 'cvEllipse2Poly' is never used. [unusedFunction]

^
modules/imgcodecs/src/loadsave.cpp:987:0: style: The function 'cvEncodeImage' is never used. [unusedFunction]

^
modules/imgproc/src/histogram.cpp:3816:0: style: The function 'cvEqualizeHist' is never used. [unusedFunction]

^
modules/video/src/compat_video.cpp:305:0: style: The function 'cvEstimateRigidTransform' is never used. [unusedFunction]

^
modules/core/src/mathfuncs.cpp:1682:0: style: The function 'cvExp' is never used. [unusedFunction]

^
modules/imgproc/src/drawing.cpp:2824:0: style: The function 'cvFillConvexPoly' is never used. [unusedFunction]

^
modules/calib3d/src/compat_stereo.cpp:87:0: style: The function 'cvFindStereoCorrespondenceBM' is never used. [unusedFunction]

^
modules/core/src/alloc.cpp:106:0: style: The function 'cvFree_' is never used. [unusedFunction]

^
modules/core/src/array.cpp:1920:0: style: The function 'cvGet1D' is never used. [unusedFunction]

^
modules/core/src/array.cpp:1955:0: style: The function 'cvGet2D' is never used. [unusedFunction]

^
modules/imgproc/src/imgwarp.cpp:3307:0: style: The function 'cvGetAffineTransform' is never used. [unusedFunction]

^
modules/videoio/src/cap.cpp:122:0: style: The function 'cvGetCaptureDomain' is never used. [unusedFunction]

^
modules/videoio/src/cap.cpp:112:0: style: The function 'cvGetCaptureProperty' is never used. [unusedFunction]

^
modules/core/src/array.cpp:1392:0: style: The function 'cvGetDiag' is never used. [unusedFunction]

^
modules/core/src/array.cpp:1156:0: style: The function 'cvGetDimSize' is never used. [unusedFunction]

^
modules/core/src/array.cpp:3066:0: style: The function 'cvGetImageROI' is never used. [unusedFunction]

^
modules/core/src/parallel.cpp:717:0: style: The function 'cvGetNumThreads' is never used. [unusedFunction]

^
modules/core/src/dxt.cpp:4530:0: style: The function 'cvGetOptimalDFTSize' is never used. [unusedFunction]

^
modules/core/src/array.cpp:1007:0: style: The function 'cvGetRawData' is never used. [unusedFunction]

^
modules/imgproc/src/moments.cpp:819:0: style: The function 'cvGetSpatialMoment' is never used. [unusedFunction]

^
modules/imgproc/src/drawing.cpp:2880:0: style: The function 'cvGetTextSize' is never used. [unusedFunction]

^
modules/core/src/parallel.cpp:722:0: style: The function 'cvGetThreadNum' is never used. [unusedFunction]

^
modules/calib3d/src/compat_stereo.cpp:111:0: style: The function 'cvGetValidDisparityROI' is never used. [unusedFunction]

^
modules/highgui/src/window.cpp:668:0: style: The function 'cvGetWindowHandle' is never used. [unusedFunction]

^
modules/highgui/src/window.cpp:674:0: style: The function 'cvGetWindowName' is never used. [unusedFunction]

^
modules/imgproc/src/featureselect.cpp:516:0: style: The function 'cvGoodFeaturesToTrack' is never used. [unusedFunction]

^
modules/imgproc/src/hough.cpp:1649:0: style: The function 'cvHoughCircles' is never used. [unusedFunction]

^
modules/imgproc/src/hough.cpp:1537:0: style: The function 'cvHoughLines2' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:2045:0: style: The function 'cvInRange' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:2056:0: style: The function 'cvInRangeS' is never used. [unusedFunction]

^
modules/imgproc/src/drawing.cpp:2864:0: style: The function 'cvInitFont' is never used. [unusedFunction]

^
modules/imgproc/src/drawing.cpp:2762:0: style: The function 'cvInitLineIterator' is never used. [unusedFunction]

^
modules/core/src/matrix.cpp:4686:0: style: The function 'cvKMeans2' is never used. [unusedFunction]

^
modules/core/src/convert.cpp:4842:0: style: The function 'cvLUT' is never used. [unusedFunction]

^
modules/imgproc/src/imgwarp.cpp:3581:0: style: The function 'cvLinearPolar' is never used. [unusedFunction]

^
modules/imgcodecs/src/loadsave.cpp:950:0: style: The function 'cvLoadImageM' is never used. [unusedFunction]

^
modules/imgproc/src/imgwarp.cpp:3344:0: style: The function 'cvLogPolar' is never used. [unusedFunction]

^
modules/core/src/matmul.cpp:3412:0: style: The function 'cvMahalanobis' is never used. [unusedFunction]

^
modules/imgproc/src/histogram.cpp:2874:0: style: The function 'cvMakeHistHeaderForArray' is never used. [unusedFunction]

^
modules/imgproc/src/matchcontours.cpp:175:0: style: The function 'cvMatchShapes' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:2096:0: style: The function 'cvMax' is never used. [unusedFunction]

^
modules/imgproc/src/geometry.cpp:45:0: style: The function 'cvMaxRect' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:2116:0: style: The function 'cvMaxS' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:352:0: style: The function 'cvMemStorageAllocString' is never used. [unusedFunction]

^
modules/core/src/convert.cpp:4773:0: style: The function 'cvMerge' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:2086:0: style: The function 'cvMin' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:2106:0: style: The function 'cvMinS' is never used. [unusedFunction]

^
modules/core/src/convert.cpp:4809:0: style: The function 'cvMixChannels' is never used. [unusedFunction]

^
modules/core/src/dxt.cpp:4504:0: style: The function 'cvMulSpectrums' is never used. [unusedFunction]

^
modules/core/src/convert.cpp:4850:0: style: The function 'cvNormalize' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:1867:0: style: The function 'cvNot' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:1888:0: style: The function 'cvOr' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:1923:0: style: The function 'cvOrS' is never used. [unusedFunction]

^
modules/imgproc/src/geometry.cpp:248:0: style: The function 'cvPointPolygonTest' is never used. [unusedFunction]

^
modules/core/src/mathfuncs.cpp:1659:0: style: The function 'cvPolarToCart' is never used. [unusedFunction]

^
modules/imgproc/src/drawing.cpp:2842:0: style: The function 'cvPolyLine' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:3496:0: style: The function 'cvPrevTreeNode' is never used. [unusedFunction]

^
modules/imgproc/src/drawing.cpp:2853:0: style: The function 'cvPutText' is never used. [unusedFunction]

^
modules/imgproc/src/segmentation.cpp:563:0: style: The function 'cvPyrMeanShiftFiltering' is never used. [unusedFunction]

^
modules/videoio/src/cap.cpp:92:0: style: The function 'cvQueryFrame' is never used. [unusedFunction]

^
modules/calib3d/src/compat_ptsetreg.cpp:325:0: style: The function 'cvRANSACUpdateNumIters' is never used. [unusedFunction]

^
modules/core/src/rand.cpp:864:0: style: The function 'cvRandArr' is never used. [unusedFunction]

^
modules/core/src/rand.cpp:873:0: style: The function 'cvRandShuffle' is never used. [unusedFunction]

^
modules/core/src/matrix.cpp:4606:0: style: The function 'cvRange' is never used. [unusedFunction]

^
modules/imgproc/src/contours.cpp:78:0: style: The function 'cvReadChainPoint' is never used. [unusedFunction]

^
modules/imgproc/src/drawing.cpp:2797:0: style: The function 'cvRectangleR' is never used. [unusedFunction]

^
modules/core/src/matrix.cpp:4584:0: style: The function 'cvReduce' is never used. [unusedFunction]

^
modules/imgproc/src/pyramids.cpp:1659:0: style: The function 'cvReleasePyramid' is never used. [unusedFunction]

^
modules/calib3d/src/compat_stereo.cpp:71:0: style: The function 'cvReleaseStereoBMState' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:3407:0: style: The function 'cvRemoveNodeFromTree' is never used. [unusedFunction]

^
modules/core/src/copy.cpp:1346:0: style: The function 'cvRepeat' is never used. [unusedFunction]

^
modules/core/src/array.cpp:2503:0: style: The function 'cvReshapeMatND' is never used. [unusedFunction]

^
modules/core/src/lapack.cpp:1777:0: style: The function 'cvSVBkSb' is never used. [unusedFunction]

^
modules/imgproc/src/samplers.cpp:467:0: style: The function 'cvSampleLine' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:2329:0: style: The function 'cvSeqPartition' is never used. [unusedFunction]

^
modules/core/src/array.cpp:2162:0: style: The function 'cvSet1D' is never used. [unusedFunction]

^
modules/core/src/array.cpp:2193:0: style: The function 'cvSet2D' is never used. [unusedFunction]

^
modules/core/src/array.cpp:70:0: style: The function 'cvSetIPLAllocators' is never used. [unusedFunction]

^
modules/core/src/array.cpp:3083:0: style: The function 'cvSetImageCOI' is never used. [unusedFunction]

^
modules/core/src/parallel.cpp:712:0: style: The function 'cvSetNumThreads' is never used. [unusedFunction]

^
modules/highgui/src/window_w32.cpp:2443:0: style: The function 'cvSetPostprocessFuncWin32_' is never used. [unusedFunction]

^
modules/highgui/src/window_w32.cpp:2437:0: style: The function 'cvSetPreprocessFuncWin32_' is never used. [unusedFunction]

^
modules/core/src/mathfuncs.cpp:2007:0: style: The function 'cvSolveCubic' is never used. [unusedFunction]

^
modules/core/src/matrix.cpp:4663:0: style: The function 'cvSort' is never used. [unusedFunction]

^
modules/core/src/convert.cpp:4738:0: style: The function 'cvSplit' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:1977:0: style: The function 'cvSubRS' is never used. [unusedFunction]

^
modules/imgproc/src/contours.cpp:490:0: style: The function 'cvSubstituteContour' is never used. [unusedFunction]

^
modules/core/src/matmul.cpp:3340:0: style: The function 'cvTransform' is never used. [unusedFunction]

^
modules/calib3d/src/compat_stereo.cpp:118:0: style: The function 'cvValidateDisparity' is never used. [unusedFunction]

^
modules/imgproc/src/segmentation.cpp:555:0: style: The function 'cvWatershed' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:1900:0: style: The function 'cvXor' is never used. [unusedFunction]

^
modules/core/src/arithm.cpp:1934:0: style: The function 'cvXorS' is never used. [unusedFunction]

^
modules/core/src/convert.sse4_1.cpp:170:0: style: The function 'cvtScale_SIMD_f32u16f32_SSE41' is never used. [unusedFunction]

^
modules/core/src/convert.sse4_1.cpp:192:0: style: The function 'cvtScale_SIMD_f64u16f32_SSE41' is never used. [unusedFunction]

^
modules/core/src/convert.sse4_1.cpp:124:0: style: The function 'cvtScale_SIMD_s16u16f32_SSE41' is never used. [unusedFunction]

^
modules/core/src/convert.sse4_1.cpp:148:0: style: The function 'cvtScale_SIMD_s32u16f32_SSE41' is never used. [unusedFunction]

^
modules/core/src/convert.sse4_1.cpp:76:0: style: The function 'cvtScale_SIMD_s8u16f32_SSE41' is never used. [unusedFunction]

^
modules/core/src/convert.sse4_1.cpp:100:0: style: The function 'cvtScale_SIMD_u16u16f32_SSE41' is never used. [unusedFunction]

^
modules/core/src/convert.sse4_1.cpp:52:0: style: The function 'cvtScale_SIMD_u8u16f32_SSE41' is never used. [unusedFunction]

^
modules/core/src/convert.avx2.cpp:52:0: style: The function 'cvtScale_s16s32f32Line_AVX2' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfRgbaYca.cpp:132:0: style: The function 'decimateChromaHoriz' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfRgbaYca.cpp:187:0: style: The function 'decimateChromaVert' is never used. [unusedFunction]

^
3rdparty/zlib/deflate.c:652:0: style: The function 'deflateBound' is never used. [unusedFunction]

^
3rdparty/zlib/deflate.c:1102:0: style: The function 'deflateCopy' is never used. [unusedFunction]

^
3rdparty/zlib/deflate.c:445:0: style: The function 'deflateGetDictionary' is never used. [unusedFunction]

^
3rdparty/zlib/deflate.c:528:0: style: The function 'deflatePending' is never used. [unusedFunction]

^
3rdparty/zlib/deflate.c:542:0: style: The function 'deflatePrime' is never used. [unusedFunction]

^
3rdparty/zlib/deflate.c:376:0: style: The function 'deflateSetDictionary' is never used. [unusedFunction]

^
3rdparty/zlib/deflate.c:517:0: style: The function 'deflateSetHeader' is never used. [unusedFunction]

^
3rdparty/zlib/deflate.c:617:0: style: The function 'deflateTune' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:1065:0: style: The function 'destroyAllWindow' is never used. [unusedFunction]

^
3rdparty/tbb/arm_linux_stub.cpp:8:0: style: The function 'destroy_process_mask' is never used. [unusedFunction]

^
3rdparty/carotene/src/norm.cpp:895:0: style: The function 'diffNormInf' is never used. [unusedFunction]

^
3rdparty/carotene/src/norm.cpp:1016:0: style: The function 'diffNormL1' is never used. [unusedFunction]

^
3rdparty/carotene/src/norm.cpp:1159:0: style: The function 'diffNormL2' is never used. [unusedFunction]

^
modules/superres/src/opencl/superres_btvl1.cl:117:0: style: The function 'diffSign' is never used. [unusedFunction]

^
modules/superres/src/opencl/superres_btvl1.cl:108:0: style: The function 'diffSign3' is never used. [unusedFunction]

^
3rdparty/carotene/src/morph.cpp:258:0: style: The function 'dilate3x3' is never used. [unusedFunction]

^
modules/core/src/dxt.cpp:2551:0: style: The function 'dimsName' is never used. [unusedFunction]

^
3rdparty/carotene/src/div.cpp:90:0: style: The function 'divSaturate < int32x2_t >' is never used. [unusedFunction]

^
3rdparty/carotene/src/div.cpp:71:0: style: The function 'divSaturateQ < int32x4_t >' is never used. [unusedFunction]

^
3rdparty/carotene/src/div.cpp:119:0: style: The function 'divWrap < int32x2_t >' is never used. [unusedFunction]

^
3rdparty/carotene/src/div.cpp:107:0: style: The function 'divWrapQ < int32x4_t >' is never used. [unusedFunction]

^
modules/dnn/src/layers/region_layer.cpp:361:0: style: The function 'do_nms' is never used. [unusedFunction]

^
3rdparty/carotene/src/dot_product.cpp:44:0: style: The function 'dotProduct' is never used. [unusedFunction]

^
3rdparty/openexr/Imath/ImathRandom.cpp:135:0: style: The function 'drand48' is never used. [unusedFunction]

^
modules/calib3d/src/circlesgrid.cpp:1330:0: style: The function 'drawBasis' is never used. [unusedFunction]

^
modules/calib3d/src/circlesgrid.cpp:1339:0: style: The function 'drawBasisGraphs' is never used. [unusedFunction]

^
modules/calib3d/src/circlesgrid.cpp:1376:0: style: The function 'drawHoles' is never used. [unusedFunction]

^
modules/dnn/src/opencl/dummy.cl:41:0: style: The function 'dummy_kernel' is never used. [unusedFunction]

^
modules/ts/src/cuda_test.cpp:416:0: style: The function 'dumpImage' is never used. [unusedFunction]

^
modules/ts/src/ocl_test.cpp:95:0: style: The function 'dumpOpenCLDevice' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_enc.c:1465:0: style: The function 'dump_passes' is never used. [unusedFunction]

^
3rdparty/carotene/src/morph.cpp:236:0: style: The function 'erode3x3' is never used. [unusedFunction]

^
modules/video/src/opencl/optical_flow_tvl1.cl:235:0: style: The function 'estimateDualVariablesKernel' is never used. [unusedFunction]

^
modules/video/src/opencl/optical_flow_tvl1.cl:303:0: style: The function 'estimateUKernel' is never used. [unusedFunction]

^
3rdparty/carotene/src/channel_extract.cpp:45:0: style: The function 'extract2' is never used. [unusedFunction]

^
3rdparty/carotene/src/channel_extract.cpp:97:0: style: The function 'extract3' is never used. [unusedFunction]

^
3rdparty/carotene/src/channel_extract.cpp:149:0: style: The function 'extract4' is never used. [unusedFunction]

^
modules/objdetect/src/opencl/objdetect_hog.cl:530:0: style: The function 'extract_descrs_by_cols_kernel' is never used. [unusedFunction]

^
modules/objdetect/src/opencl/objdetect_hog.cl:503:0: style: The function 'extract_descrs_by_rows_kernel' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfEnvmap.cpp:206:0: style: The function 'faceAndPixelPosition' is never used. [unusedFunction]

^
modules/python/src2/cv2.cpp:124:0: style: The function 'failmsgp' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:611:0: style: The function 'fft_multi_radix_cols' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:532:0: style: The function 'fft_multi_radix_rows' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:127:0: style: The function 'fft_radix2' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:146:0: style: The function 'fft_radix2_B2' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:169:0: style: The function 'fft_radix2_B3' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:195:0: style: The function 'fft_radix2_B4' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:225:0: style: The function 'fft_radix2_B5' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:388:0: style: The function 'fft_radix3' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:406:0: style: The function 'fft_radix3_B2' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:429:0: style: The function 'fft_radix3_B3' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:455:0: style: The function 'fft_radix3_B4' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:258:0: style: The function 'fft_radix4' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:276:0: style: The function 'fft_radix4_B2' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:299:0: style: The function 'fft_radix4_B3' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:485:0: style: The function 'fft_radix5' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:504:0: style: The function 'fft_radix5_B2' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:325:0: style: The function 'fft_radix8' is never used. [unusedFunction]

^
3rdparty/carotene/src/fill_minmaxloc.cpp:83:0: style: The function 'fillMinMaxLocs' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/hough_lines.cl:59:0: style: The function 'fill_accum_global' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/hough_lines.cl:91:0: style: The function 'fill_accum_local' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/filter2DSmall.cl:278:0: style: The function 'filter2DSmall' is never used. [unusedFunction]

^
modules/calib3d/src/quadsubpix.cpp:82:0: style: The function 'findCurvesCross' is never used. [unusedFunction]

^
modules/calib3d/src/quadsubpix.cpp:77:0: style: The function 'fitCurve2Order' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfRgbaYca.cpp:440:0: style: The function 'fixSaturation' is never used. [unusedFunction]

^
modules/flann/src/flann.cpp:38:0: style: The function 'flann_distance_type' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfConvert.cpp:124:0: style: The function 'floatToHalf' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfConvert.cpp:101:0: style: The function 'floatToUint' is never used. [unusedFunction]

^
modules/dnn/src/dnn.cpp:1575:0: style: The function 'forwardAll' is never used. [unusedFunction]

^
modules/core/src/ocl.cpp:3326:0: style: The function 'fromSPIR' is never used. [unusedFunction]

^
3rdparty/carotene/src/gaussian_blur.cpp:53:0: style: The function 'gaussianBlur3x3' is never used. [unusedFunction]

^
3rdparty/carotene/src/gaussian_blur.cpp:178:0: style: The function 'gaussianBlur3x3Margin' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/gaussianBlur3x3.cl:11:0: style: The function 'gaussianBlur3x3_8UC1_cols16_rows2' is never used. [unusedFunction]

^
modules/video/src/opencl/optical_flow_farneback.cl:198:0: style: The function 'gaussianBlur5' is never used. [unusedFunction]

^
3rdparty/carotene/src/gaussian_blur.cpp:209:0: style: The function 'gaussianBlur5x5' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/gaussianBlur5x5.cl:18:0: style: The function 'gaussianBlur5x5_8UC1_cols4' is never used. [unusedFunction]

^
3rdparty/carotene/src/pyramid.cpp:259:0: style: The function 'gaussianPyramidDown' is never used. [unusedFunction]

^
3rdparty/carotene/src/pyramid.cpp:153:0: style: The function 'gaussianPyramidDownRTZ' is never used. [unusedFunction]

^
3rdparty/carotene/src/pyramid.cpp:857:0: style: The function 'gaussianPyramidUp' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:237:0: style: The function 'gemm_32_1_NN_0_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:238:0: style: The function 'gemm_32_1_NN_0_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:235:0: style: The function 'gemm_32_1_NN_1_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:236:0: style: The function 'gemm_32_1_NN_1_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:415:0: style: The function 'gemm_32_1_NT_BUFFER_0_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:416:0: style: The function 'gemm_32_1_NT_BUFFER_0_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:413:0: style: The function 'gemm_32_1_NT_BUFFER_1_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:414:0: style: The function 'gemm_32_1_NT_BUFFER_1_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:446:0: style: The function 'gemm_32_1_NT_SCALAR_0_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:447:0: style: The function 'gemm_32_1_NT_SCALAR_0_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:444:0: style: The function 'gemm_32_1_NT_SCALAR_1_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:445:0: style: The function 'gemm_32_1_NT_SCALAR_1_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:399:0: style: The function 'gemm_32_1_NT_VEC4_0_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:400:0: style: The function 'gemm_32_1_NT_VEC4_0_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:397:0: style: The function 'gemm_32_1_NT_VEC4_1_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:398:0: style: The function 'gemm_32_1_NT_VEC4_1_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:309:0: style: The function 'gemm_32_1_TN_0_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:310:0: style: The function 'gemm_32_1_TN_0_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:307:0: style: The function 'gemm_32_1_TN_1_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:308:0: style: The function 'gemm_32_1_TN_1_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:554:0: style: The function 'gemm_32_1_TT_BUFFER_0_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:555:0: style: The function 'gemm_32_1_TT_BUFFER_0_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:552:0: style: The function 'gemm_32_1_TT_BUFFER_1_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:553:0: style: The function 'gemm_32_1_TT_BUFFER_1_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:585:0: style: The function 'gemm_32_1_TT_SCALAR_0_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:586:0: style: The function 'gemm_32_1_TT_SCALAR_0_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:583:0: style: The function 'gemm_32_1_TT_SCALAR_1_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:584:0: style: The function 'gemm_32_1_TT_SCALAR_1_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:538:0: style: The function 'gemm_32_1_TT_VEC4_0_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:539:0: style: The function 'gemm_32_1_TT_VEC4_0_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:536:0: style: The function 'gemm_32_1_TT_VEC4_1_0_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:537:0: style: The function 'gemm_32_1_TT_VEC4_1_1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:617:0: style: The function 'gemm_buffer_copy_image_no_transpose_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/gemm_image.cl:601:0: style: The function 'gemm_buffer_copy_image_transpose_float' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:536:0: style: The function 'getAngleEpsilon' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:545:0: style: The function 'getAngleStep' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:548:0: style: The function 'getAngleThresh' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:88:0: style: The function 'getAngularBins' is never used. [unusedFunction]

^
modules/video/src/opencl/bgfg_mog2.cl:245:0: style: The function 'getBackgroundImage2_kernel' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:245:0: style: The function 'getBackgroundRatio' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:112:0: style: The function 'getBendingEnergyWeight' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:164:0: style: The function 'getBias' is never used. [unusedFunction]

^
modules/core/src/ocl.cpp:5592:0: style: The function 'getBufferPoolController' is never used. [unusedFunction]

^
modules/core/src/utils/filesystem.cpp:392:0: style: The function 'getCacheDirectory' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:344:0: style: The function 'getCannyHighThresh' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:341:0: style: The function 'getCannyLowThresh' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:348:0: style: The function 'getColorAdaptation' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:263:0: style: The function 'getComplexityReductionThreshold' is never used. [unusedFunction]

^
modules/photo/src/merge.cpp:265:0: style: The function 'getContrastWeight' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:103:0: style: The function 'getCostExtractor' is never used. [unusedFunction]

^
modules/photo/src/align.cpp:190:0: style: The function 'getCut' is never used. [unusedFunction]

^
modules/shape/src/hist_cost.cpp:84:0: style: The function 'getDefaultCost' is never used. [unusedFunction]

^
modules/features2d/src/mser.cpp:91:0: style: The function 'getDelta' is never used. [unusedFunction]

^
modules/videoio/src/cap_cmu.cpp:207:0: style: The function 'getDepth' is never used. [unusedFunction]

^
modules/features2d/src/akaze.cpp:87:0: style: The function 'getDescriptorChannels' is never used. [unusedFunction]

^
modules/features2d/src/akaze.cpp:81:0: style: The function 'getDescriptorType' is never used. [unusedFunction]

^
modules/video/src/bgfg_KNN.cpp:182:0: style: The function 'getDetectShadows' is never used. [unusedFunction]

^
samples/cpp/tutorial_code/features2D/AKAZE_tracking/planar_tracking.cpp:32:0: style: The function 'getDetector' is never used. [unusedFunction]

^
modules/features2d/src/akaze.cpp:99:0: style: The function 'getDiffusivity' is never used. [unusedFunction]

^
modules/calib3d/src/stereobm.cpp:1219:0: style: The function 'getDisp12MaxDiff' is never used. [unusedFunction]

^
modules/video/src/bgfg_KNN.cpp:179:0: style: The function 'getDist2Threshold' is never used. [unusedFunction]

^
modules/shape/src/haus_dis.cpp:68:0: style: The function 'getDistanceFlag' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:350:0: style: The function 'getDp' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:674:0: style: The function 'getEdgeThreshold' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/canny.cl:474:0: style: The function 'getEdges' is never used. [unusedFunction]

^
modules/cudacodec/src/video_writer.cpp:321:0: style: The function 'getEncoderParams' is never used. [unusedFunction]

^
modules/photo/src/align.cpp:187:0: style: The function 'getExcludeRange' is never used. [unusedFunction]

^
modules/photo/src/merge.cpp:271:0: style: The function 'getExposureWeight' is never used. [unusedFunction]

^
modules/features2d/src/kaze.cpp:73:0: style: The function 'getExtended' is never used. [unusedFunction]

^
modules/video/src/optflowgf.cpp:606:0: style: The function 'getFastPyramids' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:689:0: style: The function 'getFastThreshold' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:677:0: style: The function 'getFirstLevel' is never used. [unusedFunction]

^
modules/videoio/src/cap_mjpeg_decoder.cpp:389:0: style: The function 'getFrames' is never used. [unusedFunction]

^
modules/videoio/src/cap_mjpeg_decoder.cpp:384:0: style: The function 'getFramesCount' is never used. [unusedFunction]

^
modules/shape/src/aff_trans.cpp:79:0: style: The function 'getFullAffine' is never used. [unusedFunction]

^
modules/core/src/conjugate_gradient.cpp:183:0: style: The function 'getFunction' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:83:0: style: The function 'getGamma' is never used. [unusedFunction]

^
modules/features2d/src/gftt.cpp:71:0: style: The function 'getGradientSize' is never used. [unusedFunction]

^
modules/features2d/src/gftt.cpp:74:0: style: The function 'getHarrisDetector' is never used. [unusedFunction]

^
modules/video/src/bgfg_KNN.cpp:170:0: style: The function 'getHistory' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:109:0: style: The function 'getImageAppearanceWeight' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:125:0: style: The function 'getImages' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:94:0: style: The function 'getInnerRadius' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:342:0: style: The function 'getIntensity' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:133:0: style: The function 'getIterations' is never used. [unusedFunction]

^
modules/features2d/src/gftt.cpp:77:0: style: The function 'getK' is never used. [unusedFunction]

^
modules/photo/src/calibrate.cpp:164:0: style: The function 'getLambda' is never used. [unusedFunction]

^
modules/dnn/src/dnn.cpp:845:0: style: The function 'getLayerName' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:356:0: style: The function 'getLevels' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:345:0: style: The function 'getLightAdaptation' is never used. [unusedFunction]

^
modules/core/src/logger.cpp:55:0: style: The function 'getLogLevel' is never used. [unusedFunction]

^
modules/ts/src/cuda_test.cpp:511:0: style: The function 'getMatchedPointsCount' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:542:0: style: The function 'getMaxAngle' is never used. [unusedFunction]

^
modules/features2d/src/mser.cpp:97:0: style: The function 'getMaxArea' is never used. [unusedFunction]

^
modules/photo/src/align.cpp:184:0: style: The function 'getMaxBits' is never used. [unusedFunction]

^
modules/features2d/src/gftt.cpp:59:0: style: The function 'getMaxFeatures' is never used. [unusedFunction]

^
modules/photo/src/calibrate.cpp:275:0: style: The function 'getMaxIter' is never used. [unusedFunction]

^
modules/video/src/lkpyramid.cpp:825:0: style: The function 'getMaxLevel' is never used. [unusedFunction]

^
modules/core/src/ocl.cpp:4197:0: style: The function 'getMaxReservedSize' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:554:0: style: The function 'getMaxScale' is never used. [unusedFunction]

^
modules/videoio/src/cap_openni.cpp:125:0: style: The function 'getMaxTimeDuration' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:539:0: style: The function 'getMinAngle' is never used. [unusedFunction]

^
modules/features2d/src/mser.cpp:94:0: style: The function 'getMinArea' is never used. [unusedFunction]

^
modules/calib3d/src/stereobm.cpp:1204:0: style: The function 'getMinDisparity' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:347:0: style: The function 'getMinDist' is never used. [unusedFunction]

^
modules/features2d/src/gftt.cpp:65:0: style: The function 'getMinDistance' is never used. [unusedFunction]

^
modules/video/src/lkpyramid.cpp:834:0: style: The function 'getMinEigThreshold' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:551:0: style: The function 'getMinScale' is never used. [unusedFunction]

^
modules/calib3d/src/stereosgbm.cpp:2205:0: style: The function 'getMode' is never used. [unusedFunction]

^
modules/videoio/src/cap_cmu.cpp:229:0: style: The function 'getNChannels' is never used. [unusedFunction]

^
modules/shape/src/hist_cost.cpp:74:0: style: The function 'getNDummies' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:671:0: style: The function 'getNLevels' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:242:0: style: The function 'getNMixtures' is never used. [unusedFunction]

^
modules/features2d/src/akaze.cpp:96:0: style: The function 'getNOctaveLayers' is never used. [unusedFunction]

^
modules/features2d/src/akaze.cpp:93:0: style: The function 'getNOctaves' is never used. [unusedFunction]

^
modules/video/src/bgfg_KNN.cpp:173:0: style: The function 'getNSamples' is never used. [unusedFunction]

^
modules/features2d/src/agast.cpp:7997:0: style: The function 'getNonmaxSuppression' is never used. [unusedFunction]

^
modules/shape/src/hist_cost.cpp:94:0: style: The function 'getNormFlag' is never used. [unusedFunction]

^
modules/calib3d/src/stereobm.cpp:1207:0: style: The function 'getNumDisparities' is never used. [unusedFunction]

^
modules/core/src/ocl.cpp:6009:0: style: The function 'getOpenCLErrorString' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:97:0: style: The function 'getOuterRadius' is never used. [unusedFunction]

^
modules/calib3d/src/stereosgbm.cpp:2202:0: style: The function 'getP2' is never used. [unusedFunction]

^
modules/features2d/src/mser.cpp:100:0: style: The function 'getPass2Only' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:686:0: style: The function 'getPatchSize' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:563:0: style: The function 'getPosThresh' is never used. [unusedFunction]

^
modules/calib3d/src/stereobm.cpp:1228:0: style: The function 'getPreFilterCap' is never used. [unusedFunction]

^
modules/calib3d/src/stereobm.cpp:1225:0: style: The function 'getPreFilterSize' is never used. [unusedFunction]

^
modules/core/src/ocl.cpp:2083:0: style: The function 'getPrefixBase' is never used. [unusedFunction]

^
modules/core/src/ocl.cpp:2060:0: style: The function 'getPrefixString' is never used. [unusedFunction]

^
modules/features2d/src/gftt.cpp:62:0: style: The function 'getQualityLevel' is never used. [unusedFunction]

^
modules/calib3d/src/stereobm.cpp:1240:0: style: The function 'getROI1' is never used. [unusedFunction]

^
modules/calib3d/src/stereobm.cpp:1243:0: style: The function 'getROI2' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:91:0: style: The function 'getRadialBins' is never used. [unusedFunction]

^
modules/photo/src/calibrate.cpp:281:0: style: The function 'getRadiance' is never used. [unusedFunction]

^
modules/photo/src/calibrate.cpp:167:0: style: The function 'getRandom' is never used. [unusedFunction]

^
modules/shape/src/haus_dis.cpp:75:0: style: The function 'getRankProportion' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:876:0: style: The function 'getRatioWindow' is never used. [unusedFunction]

^
modules/shape/src/tps_trans.cpp:81:0: style: The function 'getRegularizationParameter' is never used. [unusedFunction]

^
modules/core/src/ocl.cpp:4196:0: style: The function 'getReservedSize' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:100:0: style: The function 'getRotationInvariant' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:161:0: style: The function 'getSaturation' is never used. [unusedFunction]

^
modules/photo/src/merge.cpp:268:0: style: The function 'getSaturationWeight' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:668:0: style: The function 'getScaleFactor' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:557:0: style: The function 'getScaleStep' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:560:0: style: The function 'getScaleThresh' is never used. [unusedFunction]

^
modules/features2d/src/brisk.cpp:1006:0: style: The function 'getScoreAbove' is never used. [unusedFunction]

^
modules/features2d/src/brisk.cpp:1049:0: style: The function 'getScoreBelow' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:683:0: style: The function 'getScoreType' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:3571:0: style: The function 'getSeqElem' is never used. [unusedFunction]

^
modules/video/src/bgfg_KNN.cpp:188:0: style: The function 'getShadowThreshold' is never used. [unusedFunction]

^
modules/video/src/bgfg_KNN.cpp:185:0: style: The function 'getShadowValue' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:106:0: style: The function 'getShapeContextWeight' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:245:0: style: The function 'getSigmaColor' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:248:0: style: The function 'getSigmaSpace' is never used. [unusedFunction]

^
modules/calib3d/src/stereobm.cpp:1237:0: style: The function 'getSmallerBlockSize' is never used. [unusedFunction]

^
modules/calib3d/src/stereobm.cpp:1216:0: style: The function 'getSpeckleRange' is never used. [unusedFunction]

^
modules/calib3d/src/stereobm.cpp:1213:0: style: The function 'getSpeckleWindowSize' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:115:0: style: The function 'getStdDev' is never used. [unusedFunction]

^
modules/core/src/conjugate_gradient.cpp:189:0: style: The function 'getTermCriteria' is never used. [unusedFunction]

^
modules/calib3d/src/stereobm.cpp:1231:0: style: The function 'getTextureThreshold' is never used. [unusedFunction]

^
modules/features2d/src/agast.cpp:7994:0: style: The function 'getThreshold' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:136:0: style: The function 'getTransformAlgorithm' is never used. [unusedFunction]

^
modules/core/src/directx.cpp:180:0: style: The function 'getTypeFromD3DFORMAT' is never used. [unusedFunction]

^
modules/core/src/directx.cpp:62:0: style: The function 'getTypeFromDXGI_FORMAT' is never used. [unusedFunction]

^
modules/calib3d/src/stereobm.cpp:1234:0: style: The function 'getUniquenessRatio' is never used. [unusedFunction]

^
modules/features2d/src/kaze.cpp:76:0: style: The function 'getUpright' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:254:0: style: The function 'getVarInit' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:260:0: style: The function 'getVarMax' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:257:0: style: The function 'getVarMin' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:248:0: style: The function 'getVarThreshold' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:251:0: style: The function 'getVarThresholdGen' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:359:0: style: The function 'getVotesThreshold' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:680:0: style: The function 'getWTA_K' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:910:0: style: The function 'getWindowVisible' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:530:0: style: The function 'getXi' is never used. [unusedFunction]

^
3rdparty/zlib/crc32.c:188:0: style: The function 'get_crc_table' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/descriptor.cc:3255:0: style: The function 'get_enforce_weak' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/hough_lines.cl:140:0: style: The function 'get_lines' is never used. [unusedFunction]

^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/Utils.cpp:179:0: style: The function 'get_rotation_error' is never used. [unusedFunction]

^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/Utils.cpp:173:0: style: The function 'get_translation_error' is never used. [unusedFunction]

^
modules/video/src/bgfg_KNN.cpp:176:0: style: The function 'getkNNSamples' is never used. [unusedFunction]

^
modules/core/src/lapack.cpp:268:0: style: The function 'givensx' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:497:0: style: The function 'gray2rgb' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:578:0: style: The function 'gray2rgbx' is never used. [unusedFunction]

^
3rdparty/zlib/gzlib.c:316:0: style: The function 'gzbuffer' is never used. [unusedFunction]

^
3rdparty/zlib/gzlib.c:553:0: style: The function 'gzclearerr' is never used. [unusedFunction]

^
3rdparty/zlib/gzclose.c:11:0: style: The function 'gzclose' is never used. [unusedFunction]

^
3rdparty/zlib/gzread.c:607:0: style: The function 'gzdirect' is never used. [unusedFunction]

^
3rdparty/zlib/gzlib.c:286:0: style: The function 'gzdopen' is never used. [unusedFunction]

^
3rdparty/zlib/gzlib.c:515:0: style: The function 'gzeof' is never used. [unusedFunction]

^
3rdparty/zlib/gzlib.c:532:0: style: The function 'gzerror' is never used. [unusedFunction]

^
3rdparty/zlib/gzwrite.c:553:0: style: The function 'gzflush' is never used. [unusedFunction]

^
3rdparty/zlib/gzread.c:411:0: style: The function 'gzfread' is never used. [unusedFunction]

^
3rdparty/zlib/gzwrite.c:274:0: style: The function 'gzfwrite' is never used. [unusedFunction]

^
3rdparty/zlib/gzread.c:476:0: style: The function 'gzgetc_' is never used. [unusedFunction]

^
3rdparty/zlib/gzread.c:543:0: style: The function 'gzgets' is never used. [unusedFunction]

^
3rdparty/zlib/gzlib.c:505:0: style: The function 'gzoffset' is never used. [unusedFunction]

^
3rdparty/zlib/gzlib.c:270:0: style: The function 'gzopen' is never used. [unusedFunction]

^
3rdparty/zlib/gzlib.c:278:0: style: The function 'gzopen64' is never used. [unusedFunction]

^
3rdparty/zlib/gzwrite.c:465:0: style: The function 'gzprintf' is never used. [unusedFunction]

^
3rdparty/zlib/gzwrite.c:304:0: style: The function 'gzputc' is never used. [unusedFunction]

^
3rdparty/zlib/gzwrite.c:352:0: style: The function 'gzputs' is never used. [unusedFunction]

^
3rdparty/zlib/gzread.c:375:0: style: The function 'gzread' is never used. [unusedFunction]

^
3rdparty/zlib/gzlib.c:443:0: style: The function 'gzseek' is never used. [unusedFunction]

^
3rdparty/zlib/gzwrite.c:585:0: style: The function 'gzsetparams' is never used. [unusedFunction]

^
3rdparty/zlib/gzlib.c:472:0: style: The function 'gztell' is never used. [unusedFunction]

^
3rdparty/zlib/gzread.c:483:0: style: The function 'gzungetc' is never used. [unusedFunction]

^
3rdparty/zlib/gzwrite.c:246:0: style: The function 'gzwrite' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfConvert.cpp:88:0: style: The function 'halfToUint' is never used. [unusedFunction]

^
modules/features2d/src/kaze/nldiffusion_functions.cpp:496:0: style: The function 'halfsample_image' is never used. [unusedFunction]

^
modules/core/src/ocl.cpp:1061:0: style: The function 'haveSVM' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:1593:0: style: The function 'hideEvent' is never used. [unusedFunction]

^
modules/imgproc/src/resize.cpp:395:0: style: The function 'hlineResizeCn < uint16_t , ufixedpoint32 , 2 , true , 1 >' is never used. [unusedFunction]

^
modules/imgproc/src/resize.cpp:344:0: style: The function 'hlineResizeCn < uint8_t , ufixedpoint16 , 2 , true , 1 >' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfHuf.cpp:1004:0: style: The function 'hufCompress' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfHuf.cpp:1038:0: style: The function 'hufUncompress' is never used. [unusedFunction]

^
3rdparty/ittnotify/src/ittnotify/jitprofiling.c:306:0: style: The function 'iJIT_GetNewMethodID' is never used. [unusedFunction]

^
3rdparty/ittnotify/src/ittnotify/jitprofiling.c:162:0: style: The function 'iJIT_IsProfilingActive' is never used. [unusedFunction]

^
3rdparty/ittnotify/src/ittnotify/jitprofiling.c:120:0: style: The function 'iJIT_NotifyEvent' is never used. [unusedFunction]

^
modules/imgcodecs/src/utils.cpp:328:0: style: The function 'icvCvt_CMYK2BGR_8u_C4C3R' is never used. [unusedFunction]

^
modules/imgcodecs/src/utils.cpp:348:0: style: The function 'icvCvt_CMYK2Gray_8u_C4C1R' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:778:0: style: The function 'ifft_multi_radix_cols' is never used. [unusedFunction]

^
modules/core/src/opencl/fft.cl:672:0: style: The function 'ifft_multi_radix_rows' is never used. [unusedFunction]

^
modules/dnn/src/opencl/im2col.cl:42:0: style: The function 'im2col' is never used. [unusedFunction]

^
modules/features2d/src/kaze/nldiffusion_functions.cpp:81:0: style: The function 'image_derivatives_scharr' is never used. [unusedFunction]

^
3rdparty/zlib/infback.c:250:0: style: The function 'inflateBack' is never used. [unusedFunction]

^
3rdparty/zlib/infback.c:631:0: style: The function 'inflateBackEnd' is never used. [unusedFunction]

^
3rdparty/zlib/infback.c:28:0: style: The function 'inflateBackInit_' is never used. [unusedFunction]

^
3rdparty/zlib/inflate.c:1554:0: style: The function 'inflateCodesUsed' is never used. [unusedFunction]

^
3rdparty/zlib/inflate.c:1461:0: style: The function 'inflateCopy' is never used. [unusedFunction]

^
3rdparty/zlib/inflate.c:1291:0: style: The function 'inflateGetDictionary' is never used. [unusedFunction]

^
3rdparty/zlib/inflate.c:1349:0: style: The function 'inflateGetHeader' is never used. [unusedFunction]

^
3rdparty/zlib/inflate.c:1541:0: style: The function 'inflateMark' is never used. [unusedFunction]

^
3rdparty/zlib/inflate.c:247:0: style: The function 'inflatePrime' is never used. [unusedFunction]

^
3rdparty/zlib/inflate.c:1314:0: style: The function 'inflateSetDictionary' is never used. [unusedFunction]

^
3rdparty/zlib/inflate.c:1400:0: style: The function 'inflateSync' is never used. [unusedFunction]

^
3rdparty/zlib/inflate.c:1451:0: style: The function 'inflateSyncPoint' is never used. [unusedFunction]

^
3rdparty/zlib/inflate.c:1508:0: style: The function 'inflateUndermine' is never used. [unusedFunction]

^
3rdparty/zlib/inflate.c:1526:0: style: The function 'inflateValidate' is never used. [unusedFunction]

^
modules/python/src2/cv2.cpp:1698:0: style: The function 'init_submodule' is never used. [unusedFunction]

^
modules/python/src2/cv2.cpp:1766:0: style: The function 'initcv2' is never used. [unusedFunction]

^
modules/core/src/directx.cpp:459:0: style: The function 'initializeContextFromDirect3DDevice9Ex' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:3192:0: style: The function 'initializeGL' is never used. [unusedFunction]

^
modules/core/src/opencl/inrange.cl:52:0: style: The function 'inrange' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/integral_sum.cl:24:0: style: The function 'integral_sum_cols' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/integral_sum.cl:90:0: style: The function 'integral_sum_rows' is never used. [unusedFunction]

^
modules/core/src/opencl/intel_gemm.cl:144:0: style: The function 'intelblas_gemm_buffer_NN' is never used. [unusedFunction]

^
modules/core/src/opencl/intel_gemm.cl:36:0: style: The function 'intelblas_gemm_buffer_NN_sp' is never used. [unusedFunction]

^
modules/core/src/opencl/intel_gemm.cl:396:0: style: The function 'intelblas_gemm_buffer_NT' is never used. [unusedFunction]

^
modules/core/src/opencl/intel_gemm.cl:608:0: style: The function 'intelblas_gemm_buffer_TN' is never used. [unusedFunction]

^
modules/core/src/opencl/intel_gemm.cl:827:0: style: The function 'intelblas_gemm_buffer_TT' is never used. [unusedFunction]

^
modules/core/src/mathfuncs_core.dispatch.cpp:199:0: style: The function 'invSqrt' is never used. [unusedFunction]

^
modules/imgproc/src/resize.cpp:3466:0: style: The function 'ipp_resize' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfVersion.cpp:49:0: style: The function 'isImfMagic' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfIO.cpp:61:0: style: The function 'isMemoryMapped' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:2826:0: style: The function 'isSameSize' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfCompressor.cpp:90:0: style: The function 'isValidCompression' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_malloc.c:158:0: style: The function 'jas_calloc' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_getopt.c:104:0: style: The function 'jas_getopt' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_icc.c:892:0: style: The function 'jas_iccattrval_allowmodify' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_icc.c:253:0: style: The function 'jas_iccprof_dump' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_icc.c:589:0: style: The function 'jas_iccprof_sethdr' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_image.c:789:0: style: The function 'jas_image_copycmpt' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_image.c:812:0: style: The function 'jas_image_dump' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_image.c:602:0: style: The function 'jas_image_fmtfromname' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_image.c:572:0: style: The function 'jas_image_fmttostr' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_seq.c:301:0: style: The function 'jas_matrix_asr' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_seq.c:238:0: style: The function 'jas_matrix_cmp' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_seq.c:178:0: style: The function 'jas_matrix_copy' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_seq.c:362:0: style: The function 'jas_matrix_setall' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_seq.c:162:0: style: The function 'jas_seq2d_copy' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_seq.c:380:0: style: The function 'jas_seq2d_input' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_seq.c:416:0: style: The function 'jas_seq2d_output' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_debug.c:84:0: style: The function 'jas_setdbglevel' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_stream.c:914:0: style: The function 'jas_stream_display' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_stream.c:405:0: style: The function 'jas_stream_fdopen' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_stream.c:296:0: style: The function 'jas_stream_freopen' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_stream.c:582:0: style: The function 'jas_stream_gets' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_stream.c:630:0: style: The function 'jas_stream_isseekable' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_stream.c:965:0: style: The function 'jas_stream_length' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_stream.c:558:0: style: The function 'jas_stream_printf' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_tmr.c:143:0: style: The function 'jas_tmr_get' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_tmr.c:135:0: style: The function 'jas_tmr_start' is never used. [unusedFunction]

^
3rdparty/libjasper/jas_tmr.c:139:0: style: The function 'jas_tmr_stop' is never used. [unusedFunction]

^
3rdparty/libjasper/jp2_cod.c:968:0: style: The function 'jp2_cdef_lookup' is never used. [unusedFunction]

^
3rdparty/libjasper/jp2_enc.c:397:0: style: The function 'jp2_encode_uuid' is never used. [unusedFunction]

^
3rdparty/libjasper/jp2_cod.c:734:0: style: The function 'jp2_putuint64' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_bs.c:273:0: style: The function 'jpc_bitstream_needalign' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_enc.c:883:0: style: The function 'jpc_calcssexp' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_enc.c:867:0: style: The function 'jpc_calcssmant' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_qmfb.c:980:0: style: The function 'jpc_ft_fwdlift_col' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_qmfb.c:1298:0: style: The function 'jpc_ft_invlift_col' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_t1cod.c:285:0: style: The function 'jpc_getsignmsedec_func' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_mqdec.c:210:0: style: The function 'jpc_mqdec_setctx' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_qmfb.c:2180:0: style: The function 'jpc_ns_fwdlift_col' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_qmfb.c:2894:0: style: The function 'jpc_ns_invlift_col' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_qmfb.c:682:0: style: The function 'jpc_qmfb_join_col' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_qmfb.c:372:0: style: The function 'jpc_qmfb_split_col' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_util.c:167:0: style: The function 'jpc_seq_conv' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_util.c:154:0: style: The function 'jpc_seq_norm' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_util.c:139:0: style: The function 'jpc_seq_upsample' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_dec.c:2118:0: style: The function 'jpc_streamlist_get' is never used. [unusedFunction]

^
3rdparty/libjasper/jpc_tagtree.c:380:0: style: The function 'jpc_tagtree_dump' is never used. [unusedFunction]

^
3rdparty/libjpeg/jcapimin.c:31:0: style: The function 'jpeg_CreateCompress' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdapimin.c:31:0: style: The function 'jpeg_CreateDecompress' is never used. [unusedFunction]

^
3rdparty/libjpeg/jcapimin.c:108:0: style: The function 'jpeg_abort_compress' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdapimin.c:104:0: style: The function 'jpeg_abort_decompress' is never used. [unusedFunction]

^
3rdparty/libjpeg/jctrans.c:64:0: style: The function 'jpeg_copy_critical_parameters' is never used. [unusedFunction]

^
3rdparty/libjpeg/jcparam.c:91:0: style: The function 'jpeg_default_qtables' is never used. [unusedFunction]

^
3rdparty/libjpeg/jcapimin.c:96:0: style: The function 'jpeg_destroy_compress' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdapimin.c:92:0: style: The function 'jpeg_destroy_decompress' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdapistd.c:254:0: style: The function 'jpeg_finish_output' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdapimin.c:338:0: style: The function 'jpeg_input_complete' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdatadst.c:235:0: style: The function 'jpeg_mem_dest' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdatasrc.c:249:0: style: The function 'jpeg_mem_src' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdmaster.c:497:0: style: The function 'jpeg_new_colormap' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdtrans.c:46:0: style: The function 'jpeg_read_coefficients' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdmarker.c:1451:0: style: The function 'jpeg_save_markers' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdmarker.c:1500:0: style: The function 'jpeg_set_marker_processor' is never used. [unusedFunction]

^
3rdparty/libjpeg/jcparam.c:598:0: style: The function 'jpeg_simple_progression' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdapistd.c:229:0: style: The function 'jpeg_start_output' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdatadst.c:196:0: style: The function 'jpeg_stdio_dest' is never used. [unusedFunction]

^
3rdparty/libjpeg/jdatasrc.c:210:0: style: The function 'jpeg_stdio_src' is never used. [unusedFunction]

^
3rdparty/libjpeg/jctrans.c:39:0: style: The function 'jpeg_write_coefficients' is never used. [unusedFunction]

^
3rdparty/libjpeg/jcapimin.c:234:0: style: The function 'jpeg_write_m_byte' is never used. [unusedFunction]

^
3rdparty/libjpeg/jcapimin.c:222:0: style: The function 'jpeg_write_m_header' is never used. [unusedFunction]

^
3rdparty/libjpeg/jcapimin.c:200:0: style: The function 'jpeg_write_marker' is never used. [unusedFunction]

^
modules/dnn/src/opencl/softmax.cl:66:0: style: The function 'kernel_channel_div' is never used. [unusedFunction]

^
modules/dnn/src/opencl/softmax.cl:27:0: style: The function 'kernel_channel_max' is never used. [unusedFunction]

^
modules/dnn/src/opencl/softmax.cl:41:0: style: The function 'kernel_channel_subtract' is never used. [unusedFunction]

^
modules/dnn/src/opencl/softmax.cl:52:0: style: The function 'kernel_channel_sum' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/laplacian5.cl:103:0: style: The function 'laplacian' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/laplacian3.cl:10:0: style: The function 'laplacian3_8UC1_cols16_rows2' is never used. [unusedFunction]

^
modules/videoio/src/cap_winrt_video.cpp:314:0: style: The function 'listDevices' is never used. [unusedFunction]

^
modules/video/src/opencl/pyrlk.cl:299:0: style: The function 'lkSparse' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:867:0: style: The function 'loadWindowParameters' is never used. [unusedFunction]

^
modules/dnn/src/opencl/region.cl:44:0: style: The function 'logistic_activ' is never used. [unusedFunction]

^
3rdparty/openexr/Imath/ImathRandom.cpp:156:0: style: The function 'lrand48' is never used. [unusedFunction]

^
modules/dnn/src/opencl/ocl4dnn_lrn.cl:47:0: style: The function 'lrn_full_no_scale_float' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/cvtcolor.cl:1619:0: style: The function 'mRGBA2RGBA' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/hough_lines.cl:12:0: style: The function 'make_point_list' is never used. [unusedFunction]

^
modules/photo/test/test_denoise_tvl1.cpp:58:0: style: The function 'make_spotty' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/match_template.cl:352:0: style: The function 'matchTemplate_Prepared_CCOEFF' is never used. [unusedFunction]

^
modules/dnn/src/opencl/matvec_mul.cl:128:0: style: The function 'matvec_mul1_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/matvec_mul.cl:46:0: style: The function 'matvec_mul4_float' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/gftt.cl:48:0: style: The function 'maxEigenVal' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/gftt.cl:94:0: style: The function 'maxEigenValTask' is never used. [unusedFunction]

^
modules/dnn/src/opencl/ocl4dnn_pooling.cl:53:0: style: The function 'max_pool_forward_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/ocl4dnn_pooling.cl:51:0: style: The function 'max_pool_forward_mask_float' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/medianFilter.cl:281:0: style: The function 'medianFilter3' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/medianFilter.cl:96:0: style: The function 'medianFilter3_u' is never used. [unusedFunction]

^
3rdparty/carotene/src/median_filter.cpp:122:0: style: The function 'medianFilter3x3' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/medianFilter.cl:328:0: style: The function 'medianFilter5' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/medianFilter.cl:157:0: style: The function 'medianFilter5_u' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/histogram.cl:125:0: style: The function 'merge_histogram' is never used. [unusedFunction]

^
modules/core/src/opencl/minmaxloc.cl:116:0: style: The function 'minmaxloc' is never used. [unusedFunction]

^
modules/core/src/dxt.cpp:2536:0: style: The function 'modeName' is never used. [unusedFunction]

^
modules/video/src/opencl/bgfg_mog2.cl:50:0: style: The function 'mog2_kernel' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/morph3x3.cl:30:0: style: The function 'morph3x3_8UC1_cols16_rows2' is never used. [unusedFunction]

^
modules/core/src/opencl/mulspectrums.cl:56:0: style: The function 'mulAndScaleSpectrums' is never used. [unusedFunction]

^
3rdparty/carotene/src/mul.cpp:932:0: style: The function 'mulSaturate < int32x2_t >' is never used. [unusedFunction]

^
3rdparty/carotene/src/mul.cpp:920:0: style: The function 'mulSaturateQ < int32x4_t >' is never used. [unusedFunction]

^
3rdparty/carotene/src/mul.cpp:961:0: style: The function 'mulWrap < int32x2_t >' is never used. [unusedFunction]

^
3rdparty/carotene/src/mul.cpp:949:0: style: The function 'mulWrapQ < int32x4_t >' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfCompressor.cpp:113:0: style: The function 'newCompressor' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfCompressor.cpp:153:0: style: The function 'newTileCompressor' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/match_template.cl:54:0: style: The function 'normAcc_SQDIFF' is never used. [unusedFunction]

^
modules/core/src/stat.cpp:4363:0: style: The function 'normL2Sqr_' is never used. [unusedFunction]

^
modules/objdetect/src/opencl/objdetect_hog.cl:159:0: style: The function 'normalize_hists_36_kernel' is never used. [unusedFunction]

^
modules/objdetect/src/opencl/objdetect_hog.cl:253:0: style: The function 'normalize_hists_kernel' is never used. [unusedFunction]

^
modules/core/src/opencl/normalize.cl:30:0: style: The function 'normalizek' is never used. [unusedFunction]

^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:500:0: style: The function 'ocl4dnnAXPY < float >' is never used. [unusedFunction]

^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:395:0: style: The function 'ocl4dnnGEMMCommon < float >' is never used. [unusedFunction]

^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:62:0: style: The function 'ocl4dnnGEMMCopyBufferToImage < float >' is never used. [unusedFunction]

^
modules/dnn/src/ocl4dnn/src/math_functions.cpp:438:0: style: The function 'ocl4dnnGEMV < float >' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:173:0: style: The function 'ovx_hal_absdiff < short >' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:173:0: style: The function 'ovx_hal_absdiff < uchar >' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:170:0: style: The function 'ovx_hal_add < short >' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:170:0: style: The function 'ovx_hal_add < uchar >' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:175:0: style: The function 'ovx_hal_and < uchar >' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:854:0: style: The function 'ovx_hal_cvtBGRtoBGR' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:1021:0: style: The function 'ovx_hal_cvtBGRtoThreePlaneYUV' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:890:0: style: The function 'ovx_hal_cvtGraytoBGR' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:1069:0: style: The function 'ovx_hal_cvtOnePlaneYUVtoBGR' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:971:0: style: The function 'ovx_hal_cvtThreePlaneYUVtoBGR' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:925:0: style: The function 'ovx_hal_cvtTwoPlaneYUVtoBGR' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:585:0: style: The function 'ovx_hal_filter' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:572:0: style: The function 'ovx_hal_filterFree' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:509:0: style: The function 'ovx_hal_filterInit' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:1108:0: style: The function 'ovx_hal_integral' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:281:0: style: The function 'ovx_hal_merge8u' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:180:0: style: The function 'ovx_hal_mul < short >' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:180:0: style: The function 'ovx_hal_mul < uchar >' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:250:0: style: The function 'ovx_hal_not' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:176:0: style: The function 'ovx_hal_or < uchar >' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:319:0: style: The function 'ovx_hal_resize' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:626:0: style: The function 'ovx_hal_sepFilterInit' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:171:0: style: The function 'ovx_hal_sub < short >' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:171:0: style: The function 'ovx_hal_sub < uchar >' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:372:0: style: The function 'ovx_hal_warpAffine' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:434:0: style: The function 'ovx_hal_warpPerspectve' is never used. [unusedFunction]

^
3rdparty/openvx/hal/openvx_hal.cpp:177:0: style: The function 'ovx_hal_xor < uchar >' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:3202:0: style: The function 'paintGL' is never used. [unusedFunction]

^
modules/core/src/trace.cpp:940:0: style: The function 'parallelForAttachNestedRegion' is never used. [unusedFunction]

^
modules/core/src/trace.cpp:965:0: style: The function 'parallelForFinalize' is never used. [unusedFunction]

^
modules/core/src/trace.cpp:910:0: style: The function 'parallelForSetRootRegion' is never used. [unusedFunction]

^
modules/ts/src/cuda_test.cpp:193:0: style: The function 'parseCudaDeviceOptions' is never used. [unusedFunction]

^
modules/ts/src/ts.cpp:699:0: style: The function 'parseCustomOptions' is never used. [unusedFunction]

^
modules/ts/src/ts_func.cpp:2676:0: style: The function 'patchZeros' is never used. [unusedFunction]

^
modules/video/src/opencl/optical_flow_farneback.cl:72:0: style: The function 'polynomialExpansion' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfTiledMisc.cpp:276:0: style: The function 'precalculateTileInfo' is never used. [unusedFunction]

^
3rdparty/openexr/Imath/ImathFun.cpp:147:0: style: The function 'predd' is never used. [unusedFunction]

^
3rdparty/openexr/Imath/ImathFun.cpp:77:0: style: The function 'predf' is never used. [unusedFunction]

^
modules/calib3d/src/opencl/stereobm.cl:285:0: style: The function 'prefilter_norm' is never used. [unusedFunction]

^
modules/calib3d/src/opencl/stereobm.cl:314:0: style: The function 'prefilter_xsobel' is never used. [unusedFunction]

^
3rdparty/openexr/Half/half.cpp:249:0: style: The function 'printBits' is never used. [unusedFunction]

^
modules/ts/src/ts_func.cpp:2979:0: style: The function 'printVersionInfo' is never used. [unusedFunction]

^
modules/dnn/src/opencl/prior_box.cl:45:0: style: The function 'prior_box' is never used. [unusedFunction]

^
3rdparty/libtiff/tif_getimage.c:1752:0: style: The function 'putcontig8bitCIELab' is never used. [unusedFunction]

^
3rdparty/carotene/src/opticalflow.cpp:52:0: style: The function 'pyrLKOptFlowLevel' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/pyramid_up.cl:10:0: style: The function 'pyrUp_cols2' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/pyr_up.cl:131:0: style: The function 'pyrUp_unrolled' is never used. [unusedFunction]

^
modules/dnn/src/torch/torch_importer.cpp:171:0: style: The function 'readFunction' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfIO.cpp:68:0: style: The function 'readMemoryMapped' is never used. [unusedFunction]

^
modules/ts/src/ts.cpp:169:0: style: The function 'readSeed' is never used. [unusedFunction]

^
modules/dnn/src/torch/torch_importer.cpp:1191:0: style: The function 'readTorchBlob' is never used. [unusedFunction]

^
3rdparty/carotene/src/div.cpp:267:0: style: The function 'recipSaturate < int32x2_t >' is never used. [unusedFunction]

^
3rdparty/carotene/src/div.cpp:255:0: style: The function 'recipSaturateQ < int32x4_t >' is never used. [unusedFunction]

^
3rdparty/carotene/src/div.cpp:294:0: style: The function 'recipWrap < int32x2_t >' is never used. [unusedFunction]

^
3rdparty/carotene/src/div.cpp:282:0: style: The function 'recipWrapQ < int32x4_t >' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfRgbaYca.cpp:256:0: style: The function 'reconstructChromaHoriz' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfRgbaYca.cpp:314:0: style: The function 'reconstructChromaVert' is never used. [unusedFunction]

^
modules/core/src/trace.cpp:182:0: style: The function 'recordRegionArg' is never used. [unusedFunction]

^
3rdparty/carotene/src/reduce.cpp:113:0: style: The function 'reduceColMax' is never used. [unusedFunction]

^
3rdparty/carotene/src/reduce.cpp:181:0: style: The function 'reduceColMin' is never used. [unusedFunction]

^
3rdparty/carotene/src/reduce.cpp:46:0: style: The function 'reduceColSum' is never used. [unusedFunction]

^
modules/features2d/src/opencl/brute_force_match.cl:145:0: style: The function 'reduce_block_match' is never used. [unusedFunction]

^
modules/core/src/opencl/reduce2.cl:94:0: style: The function 'reduce_horz_opt' is never used. [unusedFunction]

^
modules/imgproc/src/filter.cpp:280:0: style: The function 'remainingOutputRows' is never used. [unusedFunction]

^
3rdparty/carotene/src/remap.cpp:490:0: style: The function 'remapLinear' is never used. [unusedFunction]

^
3rdparty/carotene/src/remap.cpp:308:0: style: The function 'remapNearestNeighbor' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/remap.cl:326:0: style: The function 'remap_16SC2_16UC1' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/remap.cl:390:0: style: The function 'remap_2_32FC1' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/remap.cl:500:0: style: The function 'remap_32FC2' is never used. [unusedFunction]

^
modules/dnn/src/opencl/reorg.cl:42:0: style: The function 'reorg' is never used. [unusedFunction]

^
modules/dnn/src/layers/recurrent_layers.cpp:464:0: style: The function 'reshapeOutput' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/resize.cl:281:0: style: The function 'resizeAREA' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/resize.cl:248:0: style: The function 'resizeAREA_FAST' is never used. [unusedFunction]

^
3rdparty/carotene/src/resize.cpp:1088:0: style: The function 'resizeArea' is never used. [unusedFunction]

^
3rdparty/carotene/src/resize.cpp:1080:0: style: The function 'resizeAreaOpenCV' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:3197:0: style: The function 'resizeGL' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/resize.cl:169:0: style: The function 'resizeLN' is never used. [unusedFunction]

^
3rdparty/carotene/src/resize.cpp:1902:0: style: The function 'resizeLinear' is never used. [unusedFunction]

^
3rdparty/carotene/src/resize.cpp:1866:0: style: The function 'resizeLinearOpenCV' is never used. [unusedFunction]

^
3rdparty/carotene/src/resize.cpp:194:0: style: The function 'resizeNearestNeighbor' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/resize.cl:103:0: style: The function 'resizeSampler' is never used. [unusedFunction]

^
modules/stitching/src/blenders.cpp:797:0: style: The function 'restoreImageFromLaplacePyrGpu' is never used. [unusedFunction]

^
modules/stitching/src/util.cpp:156:0: style: The function 'resultTl' is never used. [unusedFunction]

^
samples/cpp/travelsalesman.cpp:41:0: style: The function 'reverseState' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:802:0: style: The function 'rgb2bgr' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2108:0: style: The function 'rgb2bgr565' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:1007:0: style: The function 'rgb2bgrx' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:90:0: style: The function 'rgb2gray' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:1846:0: style: The function 'rgb2hsv' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2216:0: style: The function 'rgb2rgb565' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:668:0: style: The function 'rgb2rgbx' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2270:0: style: The function 'rgb2ycrcb' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:940:0: style: The function 'rgbx2bgr' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2054:0: style: The function 'rgbx2bgr565' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:871:0: style: The function 'rgbx2bgrx' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:191:0: style: The function 'rgbx2gray' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:1898:0: style: The function 'rgbx2hsv' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:738:0: style: The function 'rgbx2rgb' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2162:0: style: The function 'rgbx2rgb565' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2314:0: style: The function 'rgbx2ycrcb' is never used. [unusedFunction]

^
modules/calib3d/src/rho.cpp:487:0: style: The function 'rhoSeed' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfLut.cpp:153:0: style: The function 'round12log' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfRgbaYca.cpp:235:0: style: The function 'roundYCA' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/filterSepRow.cl:293:0: style: The function 'row_filter' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/filterSepRow.cl:152:0: style: The function 'row_filter_C1_D0' is never used. [unusedFunction]

^
modules/objdetect/src/opencl/cascadedetect.cl:72:0: style: The function 'runHaarClassifier' is never used. [unusedFunction]

^
modules/objdetect/src/opencl/cascadedetect.cl:455:0: style: The function 'runLBPClassifierStump' is never used. [unusedFunction]

^
modules/objdetect/src/opencl/cascadedetect.cl:367:0: style: The function 'runLBPClassifierStumpSimple' is never used. [unusedFunction]

^
modules/calib3d/test/test_fundam.cpp:1302:0: style: The function 'sampson_error' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:858:0: style: The function 'saveWindowParameters' is never used. [unusedFunction]

^
modules/imgcodecs/src/loadsave.cpp:90:0: style: The function 'seekoff' is never used. [unusedFunction]

^
modules/stitching/src/util.cpp:168:0: style: The function 'selectRandomSubset' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/sepFilter3x3.cl:11:0: style: The function 'sepFilter3x3_8UC1_cols16_rows2' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/filterSep_singlePass.cl:106:0: style: The function 'sep_filter' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:3581:0: style: The function 'seqInsertSlice' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:3551:0: style: The function 'seqPop' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:3556:0: style: The function 'seqPopFront' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:3541:0: style: The function 'seqPush' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:3546:0: style: The function 'seqPushFront' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:3561:0: style: The function 'seqRemove' is never used. [unusedFunction]

^
modules/core/src/datastructs.cpp:3576:0: style: The function 'seqRemoveSlice' is never used. [unusedFunction]

^
modules/core/src/out.cpp:261:0: style: The function 'set32fPrecision' is never used. [unusedFunction]

^
modules/core/src/out.cpp:266:0: style: The function 'set64fPrecision' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:535:0: style: The function 'setAngleEpsilon' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:246:0: style: The function 'setBackgroundRatio' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:111:0: style: The function 'setBendingEnergyWeight' is never used. [unusedFunction]

^
modules/calib3d/src/levmarq.cpp:201:0: style: The function 'setCallback' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:343:0: style: The function 'setCannyHighThresh' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:340:0: style: The function 'setCannyLowThresh' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:349:0: style: The function 'setColorAdaptation' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:264:0: style: The function 'setComplexityReductionThreshold' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:243:0: style: The function 'setContrast' is never used. [unusedFunction]

^
modules/photo/src/merge.cpp:266:0: style: The function 'setContrastWeight' is never used. [unusedFunction]

^
modules/photo/src/align.cpp:191:0: style: The function 'setCut' is never used. [unusedFunction]

^
modules/shape/src/hist_cost.cpp:79:0: style: The function 'setDefaultCost' is never used. [unusedFunction]

^
modules/features2d/src/mser.cpp:90:0: style: The function 'setDelta' is never used. [unusedFunction]

^
modules/features2d/src/akaze.cpp:86:0: style: The function 'setDescriptorChannels' is never used. [unusedFunction]

^
modules/features2d/src/akaze.cpp:83:0: style: The function 'setDescriptorSize' is never used. [unusedFunction]

^
modules/features2d/src/akaze.cpp:80:0: style: The function 'setDescriptorType' is never used. [unusedFunction]

^
modules/features2d/src/akaze.cpp:98:0: style: The function 'setDiffusivity' is never used. [unusedFunction]

^
modules/video/src/bgfg_KNN.cpp:180:0: style: The function 'setDist2Threshold' is never used. [unusedFunction]

^
modules/shape/src/haus_dis.cpp:67:0: style: The function 'setDistanceFlag' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:673:0: style: The function 'setEdgeThreshold' is never used. [unusedFunction]

^
modules/core/misc/java/src/cpp/core_manual.cpp:13:0: style: The function 'setErrorVerbosity' is never used. [unusedFunction]

^
modules/photo/src/align.cpp:188:0: style: The function 'setExcludeRange' is never used. [unusedFunction]

^
modules/photo/src/merge.cpp:272:0: style: The function 'setExposureWeight' is never used. [unusedFunction]

^
modules/features2d/src/kaze.cpp:72:0: style: The function 'setExtended' is never used. [unusedFunction]

^
modules/video/src/optflowgf.cpp:607:0: style: The function 'setFastPyramids' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:688:0: style: The function 'setFastThreshold' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:676:0: style: The function 'setFirstLevel' is never used. [unusedFunction]

^
modules/shape/src/aff_trans.cpp:78:0: style: The function 'setFullAffine' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfThreading.cpp:55:0: style: The function 'setGlobalThreadCount' is never used. [unusedFunction]

^
modules/features2d/src/gftt.cpp:70:0: style: The function 'setGradientSize' is never used. [unusedFunction]

^
modules/video/src/bgfg_KNN.cpp:171:0: style: The function 'setHistory' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:108:0: style: The function 'setImageAppearanceWeight' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:117:0: style: The function 'setImages' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:343:0: style: The function 'setIntensity' is never used. [unusedFunction]

^
modules/features2d/src/gftt.cpp:76:0: style: The function 'setK' is never used. [unusedFunction]

^
modules/photo/src/calibrate.cpp:165:0: style: The function 'setLambda' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:346:0: style: The function 'setLightAdaptation' is never used. [unusedFunction]

^
modules/core/src/logger.cpp:48:0: style: The function 'setLogLevel' is never used. [unusedFunction]

^
modules/core/src/opencl/copyset.cl:115:0: style: The function 'setMask' is never used. [unusedFunction]

^
modules/photo/src/align.cpp:185:0: style: The function 'setMaxBits' is never used. [unusedFunction]

^
modules/photo/src/calibrate.cpp:276:0: style: The function 'setMaxIter' is never used. [unusedFunction]

^
modules/shape/src/emdL1.cpp:101:0: style: The function 'setMaxIteration' is never used. [unusedFunction]

^
modules/features2d/src/gftt.cpp:64:0: style: The function 'setMinDistance' is never used. [unusedFunction]

^
modules/video/src/lkpyramid.cpp:835:0: style: The function 'setMinEigThreshold' is never used. [unusedFunction]

^
modules/core/src/out.cpp:271:0: style: The function 'setMultiline' is never used. [unusedFunction]

^
modules/shape/src/hist_cost.cpp:69:0: style: The function 'setNDummies' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:670:0: style: The function 'setNLevels' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:243:0: style: The function 'setNMixtures' is never used. [unusedFunction]

^
modules/video/src/bgfg_KNN.cpp:174:0: style: The function 'setNSamples' is never used. [unusedFunction]

^
modules/features2d/src/agast.cpp:7996:0: style: The function 'setNonmaxSuppression' is never used. [unusedFunction]

^
modules/shape/src/hist_cost.cpp:89:0: style: The function 'setNormFlag' is never used. [unusedFunction]

^
modules/dnn/src/layers/recurrent_layers.cpp:152:0: style: The function 'setOutShape' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:685:0: style: The function 'setPatchSize' is never used. [unusedFunction]

^
modules/video/src/optflowgf.cpp:616:0: style: The function 'setPolyN' is never used. [unusedFunction]

^
modules/video/src/optflowgf.cpp:619:0: style: The function 'setPolySigma' is never used. [unusedFunction]

^
modules/dnn/src/layers/recurrent_layers.cpp:146:0: style: The function 'setProduceCellOutput' is never used. [unusedFunction]

^
modules/dnn/src/layers/recurrent_layers.cpp:387:0: style: The function 'setProduceHiddenOutput' is never used. [unusedFunction]

^
modules/video/src/optflowgf.cpp:604:0: style: The function 'setPyrScale' is never used. [unusedFunction]

^
modules/features2d/src/gftt.cpp:61:0: style: The function 'setQualityLevel' is never used. [unusedFunction]

^
modules/photo/src/calibrate.cpp:168:0: style: The function 'setRandom' is never used. [unusedFunction]

^
modules/shape/src/haus_dis.cpp:70:0: style: The function 'setRankProportion' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:887:0: style: The function 'setRatioWindow' is never used. [unusedFunction]

^
modules/photo/src/calibrate.cpp:162:0: style: The function 'setSamples' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:162:0: style: The function 'setSaturation' is never used. [unusedFunction]

^
modules/photo/src/merge.cpp:269:0: style: The function 'setSaturationWeight' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:682:0: style: The function 'setScoreType' is never used. [unusedFunction]

^
modules/video/src/bgfg_KNN.cpp:189:0: style: The function 'setShadowThreshold' is never used. [unusedFunction]

^
modules/video/src/bgfg_KNN.cpp:186:0: style: The function 'setShadowValue' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:105:0: style: The function 'setShapeContextWeight' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:246:0: style: The function 'setSigmaColor' is never used. [unusedFunction]

^
modules/photo/src/tonemap.cpp:249:0: style: The function 'setSigmaSpace' is never used. [unusedFunction]

^
modules/calib3d/src/stereobm.cpp:1238:0: style: The function 'setSmallerBlockSize' is never used. [unusedFunction]

^
3rdparty/openexr/Iex/IexBaseExc.cpp:56:0: style: The function 'setStackTracer' is never used. [unusedFunction]

^
modules/shape/src/sc_dis.cpp:114:0: style: The function 'setStdDev' is never used. [unusedFunction]

^
modules/features2d/src/kaze.cpp:75:0: style: The function 'setUpright' is never used. [unusedFunction]

^
modules/dnn/src/layers/recurrent_layers.cpp:140:0: style: The function 'setUseTimstampsDim' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:255:0: style: The function 'setVarInit' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:261:0: style: The function 'setVarMax' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:258:0: style: The function 'setVarMin' is never used. [unusedFunction]

^
modules/video/src/bgfg_gaussmix2.cpp:252:0: style: The function 'setVarThresholdGen' is never used. [unusedFunction]

^
modules/features2d/src/orb.cpp:679:0: style: The function 'setWTA_K' is never used. [unusedFunction]

^
modules/dnn/src/layers/recurrent_layers.cpp:158:0: style: The function 'setWeights' is never used. [unusedFunction]

^
modules/imgproc/src/generalized_hough.cpp:529:0: style: The function 'setXi' is never used. [unusedFunction]

^
modules/flann/src/flann.cpp:44:0: style: The function 'set_distance_type' is never used. [unusedFunction]

^
modules/dnn/src/opencl/prior_box.cl:131:0: style: The function 'set_variance' is never used. [unusedFunction]

^
modules/video/src/bgfg_KNN.cpp:177:0: style: The function 'setkNNSamples' is never used. [unusedFunction]

^
modules/ts/src/cuda_test.cpp:421:0: style: The function 'showDiff' is never used. [unusedFunction]

^
modules/highgui/src/window_QT.cpp:1572:0: style: The function 'showEvent' is never used. [unusedFunction]

^
modules/dnn/src/caffe/caffe_shrinker.cpp:68:0: style: The function 'shrinkCaffeModel' is never used. [unusedFunction]

^
samples/hal/slow_hal/impl.cpp:3:0: style: The function 'slow_and8u' is never used. [unusedFunction]

^
samples/hal/slow_hal/impl.cpp:27:0: style: The function 'slow_not8u' is never used. [unusedFunction]

^
samples/hal/slow_hal/impl.cpp:11:0: style: The function 'slow_or8u' is never used. [unusedFunction]

^
samples/hal/slow_hal/impl.cpp:19:0: style: The function 'slow_xor8u' is never used. [unusedFunction]

^
modules/ts/src/ts.cpp:634:0: style: The function 'smoothBorder' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/covardata.cl:86:0: style: The function 'sobel3' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/covardata.cl:125:0: style: The function 'sobel5' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/covardata.cl:196:0: style: The function 'sobel7' is never used. [unusedFunction]

^
modules/dnn/src/opencl/region.cl:57:0: style: The function 'softmax_activ' is never used. [unusedFunction]

^
modules/dnn/src/opencl/softmax_loss.cl:123:0: style: The function 'softmax_forward_float' is never used. [unusedFunction]

^
modules/dnn/src/opencl/softmax_loss.cl:51:0: style: The function 'softmax_forward_slm_float' is never used. [unusedFunction]

^
3rdparty/carotene/src/channel_extract.cpp:470:0: style: The function 'split2' is never used. [unusedFunction]

^
3rdparty/carotene/src/channel_extract.cpp:471:0: style: The function 'split3' is never used. [unusedFunction]

^
3rdparty/carotene/src/channel_extract.cpp:472:0: style: The function 'split4' is never used. [unusedFunction]

^
3rdparty/openexr/Imath/ImathRandom.cpp:163:0: style: The function 'srand48' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/canny.cl:119:0: style: The function 'stage1_with_sobel' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/canny.cl:280:0: style: The function 'stage1_without_sobel' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/canny.cl:385:0: style: The function 'stage2_hysteresis' is never used. [unusedFunction]

^
modules/calib3d/src/opencl/stereobm.cl:140:0: style: The function 'stereoBM' is never used. [unusedFunction]

^
modules/dnn/src/opencl/ocl4dnn_pooling.cl:137:0: style: The function 'sto_pool_forward_test_float' is never used. [unusedFunction]

^
modules/ml/test/test_mltests2.cpp:92:0: style: The function 'str_to_ann_activation_function' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:649:0: style: The function 'strto32_adaptor' is never used. [unusedFunction]

^
3rdparty/protobuf/src/google/protobuf/stubs/strutil.cc:669:0: style: The function 'strtou32_adaptor' is never used. [unusedFunction]

^
modules/cudev/src/stub.cpp:9:0: style: The function 'stubFunc' is never used. [unusedFunction]

^
3rdparty/carotene/src/sub.cpp:103:0: style: The function 'sub' is never used. [unusedFunction]

^
3rdparty/openexr/Imath/ImathFun.cpp:112:0: style: The function 'succd' is never used. [unusedFunction]

^
3rdparty/openexr/Imath/ImathFun.cpp:42:0: style: The function 'succf' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/laplacian5.cl:13:0: style: The function 'sumConvert' is never used. [unusedFunction]

^
3rdparty/openexr/IlmThread/IlmThread.cpp:53:0: style: The function 'supportsThreads' is never used. [unusedFunction]

^
modules/videoio/src/cap_winrt_bridge.cpp:59:0: style: The function 'swapInputBuffers' is never used. [unusedFunction]

^
modules/core/test/test_intrin.fp16.cpp:7:0: style: The function 'test_hal_intrin_float16x4' is never used. [unusedFunction]

^
3rdparty/carotene/src/threshold.cpp:44:0: style: The function 'thresholdBinary' is never used. [unusedFunction]

^
3rdparty/carotene/src/threshold.cpp:282:0: style: The function 'thresholdBinaryInv' is never used. [unusedFunction]

^
3rdparty/carotene/src/threshold.cpp:130:0: style: The function 'thresholdRange' is never used. [unusedFunction]

^
3rdparty/carotene/src/threshold.cpp:389:0: style: The function 'thresholdToZero' is never used. [unusedFunction]

^
3rdparty/carotene/src/threshold.cpp:441:0: style: The function 'thresholdToZeroInv' is never used. [unusedFunction]

^
3rdparty/carotene/src/threshold.cpp:337:0: style: The function 'thresholdTruncate' is never used. [unusedFunction]

^
modules/python/src2/cv2.cpp:1741:0: style: The function 'to_ok' is never used. [unusedFunction]

^
modules/core/src/trace.cpp:1124:0: style: The function 'traceArg' is never used. [unusedFunction]

^
modules/core/src/opencl/transpose.cl:121:0: style: The function 'transpose_inplace' is never used. [unusedFunction]

^
3rdparty/openexr/IlmThread/IlmThreadSemaphore.cpp:53:0: style: The function 'tryWait' is never used. [unusedFunction]

^
modules/ts/src/ts_func.cpp:21:0: style: The function 'typeByName' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfConvert.cpp:114:0: style: The function 'uintToHalf' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfPxr24Compressor.cpp:269:0: style: The function 'uncompressTile' is never used. [unusedFunction]

^
modules/video/src/opencl/optical_flow_farneback.cl:408:0: style: The function 'updateFlow' is never used. [unusedFunction]

^
modules/superres/src/opencl/superres_btvl1.cl:82:0: style: The function 'upscale' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:166:0: style: The function 'vector_Point2d_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:181:0: style: The function 'vector_Point3d_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:171:0: style: The function 'vector_Point3i_to_Mat' is never used. [unusedFunction]

^
modules/dnn/misc/java/src/cpp/dnn_converters.cpp:44:0: style: The function 'vector_Ptr_Layer_to_List' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:101:0: style: The function 'vector_Rect2d_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:87:0: style: The function 'vector_Rect_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/listconverters.cpp:11:0: style: The function 'vector_String_to_List' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:326:0: style: The function 'vector_Vec4f_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:321:0: style: The function 'vector_Vec4i_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:331:0: style: The function 'vector_Vec6f_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:30:0: style: The function 'vector_double_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:45:0: style: The function 'vector_float_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:15:0: style: The function 'vector_int_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:60:0: style: The function 'vector_uchar_to_Mat' is never used. [unusedFunction]

^
modules/features2d/misc/java/src/cpp/features2d_converters.cpp:101:0: style: The function 'vector_vector_DMatch_to_Mat' is never used. [unusedFunction]

^
modules/features2d/misc/java/src/cpp/features2d_converters.cpp:75:0: style: The function 'vector_vector_KeyPoint_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:295:0: style: The function 'vector_vector_Point2f_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:308:0: style: The function 'vector_vector_Point3f_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:282:0: style: The function 'vector_vector_Point_to_Mat' is never used. [unusedFunction]

^
modules/java/generator/src/cpp/converters.cpp:269:0: style: The function 'vector_vector_char_to_Mat' is never used. [unusedFunction]

^
modules/imgproc/src/resize.cpp:478:0: style: The function 'vlineResize < uint8_t , ufixedpoint16 , 2 >' is never used. [unusedFunction]

^
modules/imgproc/src/resize.cpp:448:0: style: The function 'vlineSet < uint8_t , ufixedpoint16 >' is never used. [unusedFunction]

^
3rdparty/carotene/src/warp_affine.cpp:213:0: style: The function 'warpAffineLinear' is never used. [unusedFunction]

^
3rdparty/carotene/src/warp_affine.cpp:68:0: style: The function 'warpAffineNearestNeighbor' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/warp_transform.cl:153:0: style: The function 'warpAffine_cubic_8u' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/warp_transform.cl:75:0: style: The function 'warpAffine_linear_8u' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/warp_transform.cl:9:0: style: The function 'warpAffine_nearest_8u' is never used. [unusedFunction]

^
modules/video/src/opencl/optical_flow_tvl1.cl:77:0: style: The function 'warpBackwardKernel' is never used. [unusedFunction]

^
modules/video/src/opencl/optical_flow_tvl1.cl:159:0: style: The function 'warpBackwardKernelNoImage2d' is never used. [unusedFunction]

^
3rdparty/carotene/src/warp_perspective.cpp:228:0: style: The function 'warpPerspectiveLinear' is never used. [unusedFunction]

^
3rdparty/carotene/src/warp_perspective.cpp:70:0: style: The function 'warpPerspectiveNearestNeighbor' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/warp_transform.cl:325:0: style: The function 'warpPerspective_cubic_8u' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/warp_transform.cl:271:0: style: The function 'warpPerspective_linear_8u' is never used. [unusedFunction]

^
modules/imgproc/src/opencl/warp_transform.cl:229:0: style: The function 'warpPerspective_nearest_8u' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfWav.cpp:264:0: style: The function 'wav2Decode' is never used. [unusedFunction]

^
3rdparty/openexr/IlmImf/ImfWav.cpp:144:0: style: The function 'wav2Encode' is never used. [unusedFunction]

^
modules/core/src/logger.cpp:62:0: style: The function 'writeLogMessage' is never used. [unusedFunction]

^
modules/imgcodecs/src/grfmt_tiff.cpp:584:0: style: The function 'writeTag' is never used. [unusedFunction]

^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/CsvWriter.cpp:28:0: style: The function 'writeUVXYZ' is never used. [unusedFunction]

^
samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/CsvWriter.cpp:14:0: style: The function 'writeXYZ' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:158:0: style: The function 'wrong_absdiff16s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:153:0: style: The function 'wrong_absdiff16u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:168:0: style: The function 'wrong_absdiff32f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:163:0: style: The function 'wrong_absdiff32s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:173:0: style: The function 'wrong_absdiff64f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:148:0: style: The function 'wrong_absdiff8s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:143:0: style: The function 'wrong_absdiff8u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:18:0: style: The function 'wrong_add16s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:13:0: style: The function 'wrong_add16u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:28:0: style: The function 'wrong_add32f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:23:0: style: The function 'wrong_add32s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:33:0: style: The function 'wrong_add64f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:8:0: style: The function 'wrong_add8s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:3:0: style: The function 'wrong_add8u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:353:0: style: The function 'wrong_addWeighted16s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:348:0: style: The function 'wrong_addWeighted16u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:363:0: style: The function 'wrong_addWeighted32f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:358:0: style: The function 'wrong_addWeighted32s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:368:0: style: The function 'wrong_addWeighted64f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:343:0: style: The function 'wrong_addWeighted8s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:338:0: style: The function 'wrong_addWeighted8u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:178:0: style: The function 'wrong_and8u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:213:0: style: The function 'wrong_cmp16s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:208:0: style: The function 'wrong_cmp16u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:223:0: style: The function 'wrong_cmp32f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:218:0: style: The function 'wrong_cmp32s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:228:0: style: The function 'wrong_cmp64f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:203:0: style: The function 'wrong_cmp8s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:198:0: style: The function 'wrong_cmp8u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:283:0: style: The function 'wrong_div16s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:278:0: style: The function 'wrong_div16u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:293:0: style: The function 'wrong_div32f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:288:0: style: The function 'wrong_div32s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:298:0: style: The function 'wrong_div64f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:273:0: style: The function 'wrong_div8s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:268:0: style: The function 'wrong_div8u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:88:0: style: The function 'wrong_max16s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:83:0: style: The function 'wrong_max16u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:98:0: style: The function 'wrong_max32f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:93:0: style: The function 'wrong_max32s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:103:0: style: The function 'wrong_max64f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:78:0: style: The function 'wrong_max8s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:73:0: style: The function 'wrong_max8u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:123:0: style: The function 'wrong_min16s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:118:0: style: The function 'wrong_min16u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:133:0: style: The function 'wrong_min32f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:128:0: style: The function 'wrong_min32s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:138:0: style: The function 'wrong_min64f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:113:0: style: The function 'wrong_min8s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:108:0: style: The function 'wrong_min8u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:248:0: style: The function 'wrong_mul16s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:243:0: style: The function 'wrong_mul16u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:258:0: style: The function 'wrong_mul32f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:253:0: style: The function 'wrong_mul32s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:263:0: style: The function 'wrong_mul64f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:238:0: style: The function 'wrong_mul8s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:233:0: style: The function 'wrong_mul8u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:193:0: style: The function 'wrong_not8u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:183:0: style: The function 'wrong_or8u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:318:0: style: The function 'wrong_recip16s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:313:0: style: The function 'wrong_recip16u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:328:0: style: The function 'wrong_recip32f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:323:0: style: The function 'wrong_recip32s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:333:0: style: The function 'wrong_recip64f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:308:0: style: The function 'wrong_recip8s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:303:0: style: The function 'wrong_recip8u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:53:0: style: The function 'wrong_sub16s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:48:0: style: The function 'wrong_sub16u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:63:0: style: The function 'wrong_sub32f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:58:0: style: The function 'wrong_sub32s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:68:0: style: The function 'wrong_sub64f' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:43:0: style: The function 'wrong_sub8s' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:38:0: style: The function 'wrong_sub8u' is never used. [unusedFunction]

^
samples/hal/c_hal/impl.c:188:0: style: The function 'wrong_xor8u' is never used. [unusedFunction]

^
modules/videoio/src/cap_giganetix.cpp:158:0: style: The function 'wrprUnregisterCallback' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2754:0: style: The function 'yuv420i2bgr' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2800:0: style: The function 'yuv420i2bgrx' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2570:0: style: The function 'yuv420i2rgb' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2616:0: style: The function 'yuv420i2rgbx' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2662:0: style: The function 'yuv420sp2bgr' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2708:0: style: The function 'yuv420sp2bgrx' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2446:0: style: The function 'yuv420sp2rgb' is never used. [unusedFunction]

^
3rdparty/carotene/src/colorconvert.cpp:2524:0: style: The function 'yuv420sp2rgbx' is never used. [unusedFunction]

^
3rdparty/zlib/zutil.c:133:0: style: The function 'zError' is never used. [unusedFunction]

^
3rdparty/zlib/zutil.c:32:0: style: The function 'zlibCompileFlags' is never used. [unusedFunction]

^
3rdparty/zlib/zutil.c:27:0: style: The function 'zlibVersion' is never used. [unusedFunction]

^
3rdparty/zlib/zutil.c:160:0: style: The function 'zmemcmp' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingInclude]


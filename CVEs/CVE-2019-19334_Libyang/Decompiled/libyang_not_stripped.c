typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned char    dwfenc;
typedef unsigned int    dword;
typedef long double    longdouble;
typedef long long    longlong;
typedef unsigned long    qword;
typedef int    sdword;
typedef long    sqword;
typedef short    sword;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined4;
typedef unsigned long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef struct eh_frame_hdr eh_frame_hdr, *Peh_frame_hdr;

struct eh_frame_hdr {
    byte eh_frame_hdr_version; // Exception Handler Frame Header Version
    dwfenc eh_frame_pointer_encoding; // Exception Handler Frame Pointer Encoding
    dwfenc eh_frame_desc_entry_count_encoding; // Encoding of # of Exception Handler FDEs
    dwfenc eh_frame_table_encoding; // Exception Handler Table Encoding
};

typedef struct NoteGnuPropertyElement_4 NoteGnuPropertyElement_4, *PNoteGnuPropertyElement_4;

struct NoteGnuPropertyElement_4 {
    dword prType;
    dword prDatasz;
    byte data[4];
};

typedef struct fde_table_entry fde_table_entry, *Pfde_table_entry;

struct fde_table_entry {
    dword initial_loc; // Initial Location
    dword data_loc; // Data location
};

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef long __off64_t;

typedef ulong size_t;

struct _IO_FILE {
    int _flags;
    char *_IO_read_ptr;
    char *_IO_read_end;
    char *_IO_read_base;
    char *_IO_write_base;
    char *_IO_write_ptr;
    char *_IO_write_end;
    char *_IO_buf_base;
    char *_IO_buf_end;
    char *_IO_save_base;
    char *_IO_backup_base;
    char *_IO_save_end;
    struct _IO_marker *_markers;
    struct _IO_FILE *_chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t *_lock;
    __off64_t _offset;
    void *__pad1;
    void *__pad2;
    void *__pad3;
    void *__pad4;
    size_t __pad5;
    int _mode;
    char _unused2[20];
};

struct _IO_marker {
    struct _IO_marker *_next;
    struct _IO_FILE *_sbuf;
    int _pos;
};

typedef struct stat stat, *Pstat;

typedef ulong __dev_t;

typedef ulong __ino_t;

typedef ulong __nlink_t;

typedef uint __mode_t;

typedef uint __uid_t;

typedef uint __gid_t;

typedef long __blksize_t;

typedef long __blkcnt_t;

typedef struct timespec timespec, *Ptimespec;

typedef long __time_t;

struct timespec {
    __time_t tv_sec;
    long tv_nsec;
};

struct stat {
    __dev_t st_dev;
    __ino_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;
    __uid_t st_uid;
    __gid_t st_gid;
    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;
    __blksize_t st_blksize;
    __blkcnt_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    long __unused[3];
};

typedef qword __uint64_t;

typedef uchar yytype_uint8;

typedef sword yytype_int16;

typedef long __syscall_slong_t;

typedef char __int8_t;


// WARNING! conflicting data type names: /DWARF/__off64_t - /types.h/__off64_t

typedef long intptr_t;

typedef uint pthread_key_t;

typedef word yytype_uint16;

typedef int yy_state_type;

typedef sqword __int64_t;

typedef long __ssize_t;

typedef dword __uint32_t;


// WARNING! conflicting data type names: /DWARF/uint - /uint

typedef uchar __uint8_t;

typedef sdword __int32_t;

typedef sword __int16_t;

typedef word __uint16_t;


// WARNING! conflicting data type names: /DWARF/stat.h/stat - /stat.h/stat

typedef struct dict_table dict_table, *Pdict_table;

typedef struct hash_table hash_table, *Phash_table;

typedef union pthread_mutex_t pthread_mutex_t, *Ppthread_mutex_t;

typedef __uint32_t uint32_t;

typedef int (*values_equal_cb)(void *, void *, int, void *);

typedef __uint16_t uint16_t;

typedef struct __pthread_mutex_s __pthread_mutex_s, *P__pthread_mutex_s;

typedef struct __pthread_internal_list __pthread_internal_list, *P__pthread_internal_list;

typedef struct __pthread_internal_list __pthread_list_t;

struct __pthread_internal_list {
    struct __pthread_internal_list *__prev;
    struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s {
    int __lock;
    uint __count;
    int __owner;
    uint __nusers;
    int __kind;
    short __spins;
    short __elision;
    __pthread_list_t __list;
};

union pthread_mutex_t {
    struct __pthread_mutex_s __data;
    char __size[40];
    long __align;
};

struct dict_table {
    struct hash_table *hash_tab;
    union pthread_mutex_t lock;
};

struct hash_table {
    uint32_t used;
    uint32_t size;
    values_equal_cb val_equal;
    void *cb_data;
    uint16_t resize;
    uint16_t rec_size;
    uchar *recs;
};

typedef struct dict_rec dict_rec, *Pdict_rec;

struct dict_rec {
    char *value;
    uint32_t refcount;
};

typedef struct ht_rec ht_rec, *Pht_rec;

typedef __int32_t int32_t;

struct ht_rec {
    uint32_t hash;
    int32_t hits;
    uchar val[1];
};


// WARNING! conflicting data type names: /DWARF/struct_timespec.h/timespec - /time.h/timespec

typedef enum anon_enum_32 {
    LYE_PATH=-2,
    LYE_SPEC=-1,
    LYD_UNKNOWN=0,
    LYE_SUCCESS=0,
    LYVE_SUCCESS=0,
    LY_LLERR=0,
    LY_SUCCESS=0,
    PTHREAD_MUTEX_DEFAULT=0,
    PTHREAD_MUTEX_FAST_NP=0,
    PTHREAD_MUTEX_NORMAL=0,
    PTHREAD_MUTEX_TIMED_NP=0,
    _SC_ARG_MAX=0,
    LYD_XML=1,
    LYE_XML_MISS=1,
    LYVE_XML_MISS=1,
    LY_EMEM=1,
    LY_LLWRN=1,
    PTHREAD_MUTEX_RECURSIVE=1,
    PTHREAD_MUTEX_RECURSIVE_NP=1,
    _ISblank=1,
    _SC_CHILD_MAX=1,
    LYD_JSON=2,
    LYE_XML_INVAL=2,
    LYVE_XML_INVAL=2,
    LY_ESYS=2,
    LY_LLVRB=2,
    PTHREAD_MUTEX_ERRORCHECK=2,
    PTHREAD_MUTEX_ERRORCHECK_NP=2,
    _IScntrl=2,
    _SC_CLK_TCK=2,
    LYD_LYB=3,
    LYE_XML_INCHAR=3,
    LYVE_XML_INCHAR=3,
    LY_EINVAL=3,
    LY_LLDBG=3,
    PTHREAD_MUTEX_ADAPTIVE_NP=3,
    _SC_NGROUPS_MAX=3,
    LYE_EOF=4,
    LYVE_EOF=4,
    LY_EINT=4,
    _ISpunct=4,
    _SC_OPEN_MAX=4,
    LYE_INSTMT=5,
    LYVE_INSTMT=5,
    LY_EVALID=5,
    _SC_STREAM_MAX=5,
    LYE_INCHILDSTMT=6,
    LYVE_INPAR=6,
    LY_EPLUGIN=6,
    _SC_TZNAME_MAX=6,
    LYE_INPAR=7,
    LYVE_INID=7,
    _SC_JOB_CONTROL=7,
    LYE_INID=8,
    LYVE_INDATE=8,
    _ISalnum=8,
    _SC_SAVED_IDS=8,
    LYE_INDATE=9,
    LYVE_INARG=9,
    _SC_REALTIME_SIGNALS=9,
    LYE_INARG=10,
    LYVE_MISSSTMT=10,
    _SC_PRIORITY_SCHEDULING=10,
    LYE_MISSSTMT=11,
    LYVE_MISSARG=11,
    _SC_TIMERS=11,
    LYE_MISSCHILDSTMT=12,
    LYVE_TOOMANY=12,
    _SC_ASYNCHRONOUS_IO=12,
    LYE_MISSARG=13,
    LYVE_DUPID=13,
    _SC_PRIORITIZED_IO=13,
    LYE_TOOMANY=14,
    LYVE_DUPLEAFLIST=14,
    _SC_SYNCHRONIZED_IO=14,
    LYE_DUPID=15,
    LYVE_DUPLIST=15,
    _SC_FSYNC=15,
    LYE_DUPLEAFLIST=16,
    LYVE_NOUNIQ=16,
    _SC_MAPPED_FILES=16,
    LYE_DUPLIST=17,
    LYVE_ENUM_INVAL=17,
    _SC_MEMLOCK=17,
    LYE_NOUNIQ=18,
    LYVE_ENUM_INNAME=18,
    _SC_MEMLOCK_RANGE=18,
    LYE_ENUM_INVAL=19,
    LYVE_ENUM_WS=19,
    _SC_MEMORY_PROTECTION=19,
    LYE_ENUM_INNAME=20,
    LYVE_BITS_INVAL=20,
    _SC_MESSAGE_PASSING=20,
    LYE_ENUM_DUPVAL=21,
    LYVE_BITS_INNAME=21,
    _SC_SEMAPHORES=21,
    LYE_ENUM_DUPNAME=22,
    LYVE_INMOD=22,
    _SC_SHARED_MEMORY_OBJECTS=22,
    LYE_ENUM_WS=23,
    LYVE_KEY_NLEAF=23,
    _SC_AIO_LISTIO_MAX=23,
    LYE_BITS_INVAL=24,
    LYVE_KEY_TYPE=24,
    _SC_AIO_MAX=24,
    LYE_BITS_INNAME=25,
    LYVE_KEY_CONFIG=25,
    _SC_AIO_PRIO_DELTA_MAX=25,
    LYE_BITS_DUPVAL=26,
    LYVE_KEY_MISS=26,
    _SC_DELAYTIMER_MAX=26,
    LYE_BITS_DUPNAME=27,
    LYVE_KEY_DUP=27,
    _SC_MQ_OPEN_MAX=27,
    LYE_INMOD=28,
    LYVE_INREGEX=28,
    _SC_MQ_PRIO_MAX=28,
    LYE_INMOD_LEN=29,
    LYVE_INRESOLV=29,
    _SC_VERSION=29,
    LYE_KEY_NLEAF=30,
    LYVE_INSTATUS=30,
    _SC_PAGESIZE=30,
    LYE_KEY_TYPE=31,
    LYVE_CIRC_LEAFREFS=31,
    _SC_RTSIG_MAX=31,
    LYE_KEY_CONFIG=32,
    LYVE_CIRC_FEATURES=32,
    _SC_SEM_NSEMS_MAX=32,
    LYE_KEY_MISS=33,
    LYVE_CIRC_IMPORTS=33,
    _SC_SEM_VALUE_MAX=33,
    LYE_KEY_DUP=34,
    LYVE_CIRC_INCLUDES=34,
    _SC_SIGQUEUE_MAX=34,
    LYE_INREGEX=35,
    LYVE_INVER=35,
    _SC_TIMER_MAX=35,
    LYE_INRESOLV=36,
    LYVE_SUBMODULE=36,
    _SC_BC_BASE_MAX=36,
    LYE_INSTATUS=37,
    LYVE_OBSDATA=37,
    _SC_BC_DIM_MAX=37,
    LYE_CIRC_LEAFREFS=38,
    LYVE_NORESOLV=38,
    _SC_BC_SCALE_MAX=38,
    LYE_CIRC_FEATURES=39,
    LYVE_INELEM=39,
    _SC_BC_STRING_MAX=39,
    LYE_CIRC_IMPORTS=40,
    LYVE_MISSELEM=40,
    _SC_COLL_WEIGHTS_MAX=40,
    LYE_CIRC_INCLUDES=41,
    LYVE_INVAL=41,
    _SC_EQUIV_CLASS_MAX=41,
    LYE_INVER=42,
    LYVE_INMETA=42,
    _SC_EXPR_NEST_MAX=42,
    LYE_SUBMODULE=43,
    LYVE_INATTR=43,
    _SC_LINE_MAX=43,
    LYE_OBSDATA=44,
    LYVE_MISSATTR=44,
    _SC_RE_DUP_MAX=44,
    LYE_OBSTYPE=45,
    LYVE_NOCONSTR=45,
    _SC_CHARCLASS_NAME_MAX=45,
    LYE_NORESOLV=46,
    LYVE_INCHAR=46,
    _SC_2_VERSION=46,
    LYE_INELEM=47,
    LYVE_INPRED=47,
    _SC_2_C_BIND=47,
    LYE_INELEM_LEN=48,
    LYVE_MCASEDATA=48,
    _SC_2_C_DEV=48,
    LYE_MISSELEM=49,
    LYVE_NOMUST=49,
    _SC_2_FORT_DEV=49,
    LYE_INVAL=50,
    LYVE_NOWHEN=50,
    _SC_2_FORT_RUN=50,
    LYE_INMETA=51,
    LYVE_INORDER=51,
    _SC_2_SW_DEV=51,
    LYE_INATTR=52,
    LYVE_INWHEN=52,
    _SC_2_LOCALEDEF=52,
    LYE_MISSATTR=53,
    LYVE_NOMIN=53,
    _SC_PII=53,
    LYE_NOCONSTR=54,
    LYVE_NOMAX=54,
    _SC_PII_XTI=54,
    LYE_INCHAR=55,
    LYVE_NOREQINS=55,
    _SC_PII_SOCKET=55,
    LYE_INPRED=56,
    LYVE_NOLEAFREF=56,
    _SC_PII_INTERNET=56,
    LYE_MCASEDATA=57,
    LYVE_NOMANDCHOICE=57,
    _SC_PII_OSI=57,
    LYE_NOMUST=58,
    LYVE_XPATH_INTOK=58,
    _SC_POLL=58,
    LYE_NOWHEN=59,
    LYVE_XPATH_EOF=59,
    _SC_SELECT=59,
    LYE_INORDER=60,
    LYVE_XPATH_INOP=60,
    _SC_IOV_MAX=60,
    _SC_UIO_MAXIOV=60,
    LYE_INWHEN=61,
    LYVE_XPATH_INCTX=61,
    _SC_PII_INTERNET_STREAM=61,
    LYE_NOMIN=62,
    LYVE_XPATH_INMOD=62,
    _SC_PII_INTERNET_DGRAM=62,
    LYE_NOMAX=63,
    LYVE_XPATH_INFUNC=63,
    _SC_PII_OSI_COTS=63,
    LYE_NOREQINS=64,
    LYVE_XPATH_INARGCOUNT=64,
    _SC_PII_OSI_CLTS=64,
    LYE_NOLEAFREF=65,
    LYVE_XPATH_INARGTYPE=65,
    _SC_PII_OSI_M=65,
    LYE_NOMANDCHOICE=66,
    LYVE_XPATH_DUMMY=66,
    _SC_T_IOV_MAX=66,
    LYE_XPATH_INTOK=67,
    LYVE_XPATH_NOEND=67,
    _SC_THREADS=67,
    LYE_XPATH_EOF=68,
    LYVE_PATH_INCHAR=68,
    _SC_THREAD_SAFE_FUNCTIONS=68,
    LYE_XPATH_INOP_1=69,
    LYVE_PATH_INMOD=69,
    _SC_GETGR_R_SIZE_MAX=69,
    LYE_XPATH_INOP_2=70,
    LYVE_PATH_MISSMOD=70,
    _SC_GETPW_R_SIZE_MAX=70,
    LYE_XPATH_INCTX=71,
    LYVE_PATH_INNODE=71,
    _SC_LOGIN_NAME_MAX=71,
    LYE_XPATH_INMOD=72,
    LYVE_PATH_INKEY=72,
    _SC_TTY_NAME_MAX=72,
    LYE_XPATH_INFUNC=73,
    LYVE_PATH_MISSKEY=73,
    _SC_THREAD_DESTRUCTOR_ITERATIONS=73,
    LYE_XPATH_INARGCOUNT=74,
    LYVE_PATH_INIDENTREF=74,
    _SC_THREAD_KEYS_MAX=74,
    LYE_XPATH_INARGTYPE=75,
    LYVE_PATH_EXISTS=75,
    _SC_THREAD_STACK_MIN=75,
    LYE_XPATH_DUMMY=76,
    LYVE_PATH_MISSPAR=76,
    _SC_THREAD_THREADS_MAX=76,
    LYE_XPATH_NOEND=77,
    LYVE_PATH_PREDTOOMANY=77,
    _SC_THREAD_ATTR_STACKADDR=77,
    LYE_PATH_INCHAR=78,
    _SC_THREAD_ATTR_STACKSIZE=78,
    LYE_PATH_INMOD=79,
    _SC_THREAD_PRIORITY_SCHEDULING=79,
    LYE_PATH_MISSMOD=80,
    _SC_THREAD_PRIO_INHERIT=80,
    LYE_PATH_INNODE=81,
    _SC_THREAD_PRIO_PROTECT=81,
    LYE_PATH_INKEY=82,
    _SC_THREAD_PROCESS_SHARED=82,
    LYE_PATH_MISSKEY=83,
    _SC_NPROCESSORS_CONF=83,
    LYE_PATH_INIDENTREF=84,
    _SC_NPROCESSORS_ONLN=84,
    LYE_PATH_EXISTS=85,
    _SC_PHYS_PAGES=85,
    LYE_PATH_MISSPAR=86,
    _SC_AVPHYS_PAGES=86,
    LYE_PATH_PREDTOOMANY=87,
    _SC_ATEXIT_MAX=87,
    _SC_PASS_MAX=88,
    _SC_XOPEN_VERSION=89,
    _SC_XOPEN_XCU_VERSION=90,
    _SC_XOPEN_UNIX=91,
    _SC_XOPEN_CRYPT=92,
    _SC_XOPEN_ENH_I18N=93,
    _SC_XOPEN_SHM=94,
    _SC_2_CHAR_TERM=95,
    _SC_2_C_VERSION=96,
    _SC_2_UPE=97,
    _SC_XOPEN_XPG2=98,
    _SC_XOPEN_XPG3=99,
    _SC_XOPEN_XPG4=100,
    _SC_CHAR_BIT=101,
    _SC_CHAR_MAX=102,
    _SC_CHAR_MIN=103,
    _SC_INT_MAX=104,
    _SC_INT_MIN=105,
    _SC_LONG_BIT=106,
    _SC_WORD_BIT=107,
    _SC_MB_LEN_MAX=108,
    _SC_NZERO=109,
    _SC_SSIZE_MAX=110,
    _SC_SCHAR_MAX=111,
    _SC_SCHAR_MIN=112,
    _SC_SHRT_MAX=113,
    _SC_SHRT_MIN=114,
    _SC_UCHAR_MAX=115,
    _SC_UINT_MAX=116,
    _SC_ULONG_MAX=117,
    _SC_USHRT_MAX=118,
    _SC_NL_ARGMAX=119,
    _SC_NL_LANGMAX=120,
    _SC_NL_MSGMAX=121,
    _SC_NL_NMAX=122,
    _SC_NL_SETMAX=123,
    _SC_NL_TEXTMAX=124,
    _SC_XBS5_ILP32_OFF32=125,
    _SC_XBS5_ILP32_OFFBIG=126,
    _SC_XBS5_LP64_OFF64=127,
    _SC_XBS5_LPBIG_OFFBIG=128,
    _SC_XOPEN_LEGACY=129,
    _SC_XOPEN_REALTIME=130,
    _SC_XOPEN_REALTIME_THREADS=131,
    _SC_ADVISORY_INFO=132,
    _SC_BARRIERS=133,
    _SC_BASE=134,
    _SC_C_LANG_SUPPORT=135,
    _SC_C_LANG_SUPPORT_R=136,
    _SC_CLOCK_SELECTION=137,
    _SC_CPUTIME=138,
    _SC_THREAD_CPUTIME=139,
    _SC_DEVICE_IO=140,
    _SC_DEVICE_SPECIFIC=141,
    _SC_DEVICE_SPECIFIC_R=142,
    _SC_FD_MGMT=143,
    _SC_FIFO=144,
    _SC_PIPE=145,
    _SC_FILE_ATTRIBUTES=146,
    _SC_FILE_LOCKING=147,
    _SC_FILE_SYSTEM=148,
    _SC_MONOTONIC_CLOCK=149,
    _SC_MULTI_PROCESS=150,
    _SC_SINGLE_PROCESS=151,
    _SC_NETWORKING=152,
    _SC_READER_WRITER_LOCKS=153,
    _SC_SPIN_LOCKS=154,
    _SC_REGEXP=155,
    _SC_REGEX_VERSION=156,
    _SC_SHELL=157,
    _SC_SIGNALS=158,
    _SC_SPAWN=159,
    _SC_SPORADIC_SERVER=160,
    _SC_THREAD_SPORADIC_SERVER=161,
    _SC_SYSTEM_DATABASE=162,
    _SC_SYSTEM_DATABASE_R=163,
    _SC_TIMEOUTS=164,
    _SC_TYPED_MEMORY_OBJECTS=165,
    _SC_USER_GROUPS=166,
    _SC_USER_GROUPS_R=167,
    _SC_2_PBS=168,
    _SC_2_PBS_ACCOUNTING=169,
    _SC_2_PBS_LOCATE=170,
    _SC_2_PBS_MESSAGE=171,
    _SC_2_PBS_TRACK=172,
    _SC_SYMLOOP_MAX=173,
    _SC_STREAMS=174,
    _SC_2_PBS_CHECKPOINT=175,
    _SC_V6_ILP32_OFF32=176,
    _SC_V6_ILP32_OFFBIG=177,
    _SC_V6_LP64_OFF64=178,
    _SC_V6_LPBIG_OFFBIG=179,
    _SC_HOST_NAME_MAX=180,
    _SC_TRACE=181,
    _SC_TRACE_EVENT_FILTER=182,
    _SC_TRACE_INHERIT=183,
    _SC_TRACE_LOG=184,
    _SC_LEVEL1_ICACHE_SIZE=185,
    _SC_LEVEL1_ICACHE_ASSOC=186,
    _SC_LEVEL1_ICACHE_LINESIZE=187,
    _SC_LEVEL1_DCACHE_SIZE=188,
    _SC_LEVEL1_DCACHE_ASSOC=189,
    _SC_LEVEL1_DCACHE_LINESIZE=190,
    _SC_LEVEL2_CACHE_SIZE=191,
    _SC_LEVEL2_CACHE_ASSOC=192,
    _SC_LEVEL2_CACHE_LINESIZE=193,
    _SC_LEVEL3_CACHE_SIZE=194,
    _SC_LEVEL3_CACHE_ASSOC=195,
    _SC_LEVEL3_CACHE_LINESIZE=196,
    _SC_LEVEL4_CACHE_SIZE=197,
    _SC_LEVEL4_CACHE_ASSOC=198,
    _SC_LEVEL4_CACHE_LINESIZE=199,
    _SC_IPV6=235,
    _SC_RAW_SOCKETS=236,
    _SC_V7_ILP32_OFF32=237,
    _SC_V7_ILP32_OFFBIG=238,
    _SC_V7_LP64_OFF64=239,
    _SC_V7_LPBIG_OFFBIG=240,
    _SC_SS_REPL_MAX=241,
    _SC_TRACE_EVENT_NAME_MAX=242,
    _SC_TRACE_NAME_MAX=243,
    _SC_TRACE_SYS_MAX=244,
    _SC_TRACE_USER_EVENT_MAX=245,
    _SC_XOPEN_STREAMS=246,
    _SC_THREAD_ROBUST_PRIO_INHERIT=247,
    _SC_THREAD_ROBUST_PRIO_PROTECT=248,
    _ISupper=256,
    _ISlower=512,
    _ISalpha=1024,
    _ISdigit=2048,
    _ISxdigit=4096,
    _ISspace=8192,
    _ISprint=16384,
    _ISgraph=32768
} anon_enum_32;

typedef struct tm tm, *Ptm;

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    char *tm_zone;
};

typedef enum LY_IDENT {
    LY_IDENT_SIMPLE=0,
    LY_IDENT_FEATURE=1,
    LY_IDENT_IDENTITY=2,
    LY_IDENT_TYPE=3,
    LY_IDENT_NODE=4,
    LY_IDENT_NAME=5,
    LY_IDENT_PREFIX=6,
    LY_IDENT_EXTENSION=7
} LY_IDENT;

typedef struct __dirstream __dirstream, *P__dirstream;

typedef struct __dirstream DIR;

struct __dirstream {
};

typedef struct dirent dirent, *Pdirent;

struct dirent {
    __ino_t d_ino;
    __off_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
};


// WARNING! conflicting data type names: /DWARF/_UNCATEGORIZED_/_IO_marker - /libio.h/_IO_marker

typedef struct __va_list_tag __va_list_tag, *P__va_list_tag;

struct __va_list_tag {
    uint gp_offset;
    uint fp_offset;
    void *overflow_arg_area;
    void *reg_save_area;
};

typedef struct __va_list_tag __builtin_va_list[1];

typedef struct real_pcre real_pcre, *Preal_pcre;

struct real_pcre {
};

typedef struct _IO_wide_data _IO_wide_data, *P_IO_wide_data;

struct _IO_wide_data {
};

typedef struct _IO_codecvt _IO_codecvt, *P_IO_codecvt;

struct _IO_codecvt {
};

typedef enum lyxml_attr_type {
    LYXML_ATTR_STD=1,
    LYXML_ATTR_NS=2
} lyxml_attr_type;

typedef struct lyxml_ns lyxml_ns, *Plyxml_ns;

typedef enum lyxml_attr_type LYXML_ATTR_TYPE;

typedef struct lyxml_elem lyxml_elem, *Plyxml_elem;

typedef struct lyxml_attr lyxml_attr, *Plyxml_attr;

struct lyxml_ns {
    LYXML_ATTR_TYPE type;
    struct lyxml_ns *next;
    struct lyxml_elem *parent;
    char *prefix;
    char *value;
};

struct lyxml_elem {
    char flags;
    struct lyxml_elem *parent;
    struct lyxml_attr *attr;
    struct lyxml_elem *child;
    struct lyxml_elem *next;
    struct lyxml_elem *prev;
    char *name;
    struct lyxml_ns *ns;
    char *content;
};

struct lyxml_attr {
    LYXML_ATTR_TYPE type;
    struct lyxml_attr *next;
    struct lyxml_ns *ns;
    char *name;
    char *value;
};

typedef enum LY_LOG_LEVEL {
    LY_LLERR=0,
    LY_LLWRN=1,
    LY_LLVRB=2,
    LY_LLDBG=3
} LY_LOG_LEVEL;

typedef enum LYS_INFORMAT {
    LYS_IN_UNKNOWN=0,
    LYS_IN_YANG=1,
    LYS_IN_YIN=2
} LYS_INFORMAT;

typedef char * (*ly_module_imp_clb)(char *, char *, char *, char *, void *, enum LYS_INFORMAT *, void (**)(void *, void *));

typedef union ly_set_set ly_set_set, *Ply_set_set;

typedef struct lys_node lys_node, *Plys_node;

typedef struct lyd_node lyd_node, *Plyd_node;

typedef __uint8_t uint8_t;

typedef struct lys_ext_instance lys_ext_instance, *Plys_ext_instance;

typedef struct lys_iffeature lys_iffeature, *Plys_iffeature;

typedef struct lys_module lys_module, *Plys_module;

typedef enum lys_nodetype {
    LYS_UNKNOWN=0,
    LYS_CONTAINER=1,
    LYS_CHOICE=2,
    LYS_LEAF=4,
    LYS_LEAFLIST=8,
    LYS_LIST=16,
    LYS_ANYXML=32,
    LYS_CASE=64,
    LYS_NOTIF=128,
    LYS_RPC=256,
    LYS_INPUT=512,
    LYS_OUTPUT=1024,
    LYS_GROUPING=2048,
    LYS_USES=4096,
    LYS_AUGMENT=8192,
    LYS_ACTION=16384,
    LYS_ANYDATA=32800,
    LYS_EXT=65536
} lys_nodetype;

typedef enum lys_nodetype LYS_NODE;

typedef struct lyd_attr lyd_attr, *Plyd_attr;

typedef struct lys_ext lys_ext, *Plys_ext;

typedef struct lys_feature lys_feature, *Plys_feature;

typedef struct ly_ctx ly_ctx, *Ply_ctx;

typedef struct lys_revision lys_revision, *Plys_revision;

typedef struct lys_import lys_import, *Plys_import;

typedef struct lys_include lys_include, *Plys_include;

typedef struct lys_tpdf lys_tpdf, *Plys_tpdf;

typedef struct lys_ident lys_ident, *Plys_ident;

typedef struct lys_node_augment lys_node_augment, *Plys_node_augment;

typedef struct lys_deviation lys_deviation, *Plys_deviation;

typedef struct lys_ext_instance_complex lys_ext_instance_complex, *Plys_ext_instance_complex;

typedef union lyd_value_u lyd_value_u, *Plyd_value_u;

typedef union lyd_value_u lyd_val;

typedef enum LY_DATA_TYPE {
    LY_TYPE_DER=0,
    LY_TYPE_BINARY=1,
    LY_TYPE_BITS=2,
    LY_TYPE_BOOL=3,
    LY_TYPE_DEC64=4,
    LY_TYPE_EMPTY=5,
    LY_TYPE_ENUM=6,
    LY_TYPE_IDENT=7,
    LY_TYPE_INST=8,
    LY_TYPE_LEAFREF=9,
    LY_TYPE_STRING=10,
    LY_TYPE_UNION=11,
    LY_TYPE_INT8=12,
    LY_TYPE_UINT8=13,
    LY_TYPE_INT16=14,
    LY_TYPE_UINT16=15,
    LY_TYPE_INT32=16,
    LY_TYPE_UINT32=17,
    LY_TYPE_INT64=18,
    LY_TYPE_UINT64=19,
    LY_TYPE_UNKNOWN=20
} LY_DATA_TYPE;

typedef struct lyext_plugin lyext_plugin, *Plyext_plugin;

typedef struct ly_set ly_set, *Ply_set;

typedef struct ly_modules_list ly_modules_list, *Ply_modules_list;

typedef lys_module * (*ly_module_data_clb)(struct ly_ctx *, char *, char *, int, void *);

typedef struct lys_submodule lys_submodule, *Plys_submodule;

typedef struct lys_type lys_type, *Plys_type;

typedef struct lys_when lys_when, *Plys_when;

typedef struct lys_deviate lys_deviate, *Plys_deviate;

typedef struct lyext_substmt lyext_substmt, *Plyext_substmt;

typedef struct lys_type_bit lys_type_bit, *Plys_type_bit;

typedef __int8_t int8_t;

typedef __int64_t int64_t;

typedef struct lys_type_enum lys_type_enum, *Plys_type_enum;

typedef __int16_t int16_t;

typedef __uint64_t uint64_t;

typedef enum LYEXT_TYPE {
    LYEXT_ERR=-1,
    LYEXT_FLAG=0,
    LYEXT_COMPLEX=1
} LYEXT_TYPE;

typedef enum LYEXT_PAR {
    LYEXT_PAR_MODULE=0,
    LYEXT_PAR_NODE=1,
    LYEXT_PAR_TPDF=2,
    LYEXT_PAR_TYPE=3,
    LYEXT_PAR_TYPE_BIT=4,
    LYEXT_PAR_TYPE_ENUM=5,
    LYEXT_PAR_FEATURE=6,
    LYEXT_PAR_RESTR=7,
    LYEXT_PAR_WHEN=8,
    LYEXT_PAR_IDENT=9,
    LYEXT_PAR_EXT=10,
    LYEXT_PAR_EXTINST=11,
    LYEXT_PAR_REFINE=12,
    LYEXT_PAR_DEVIATION=13,
    LYEXT_PAR_DEVIATE=14,
    LYEXT_PAR_IMPORT=15,
    LYEXT_PAR_INCLUDE=16,
    LYEXT_PAR_REVISION=17,
    LYEXT_PAR_IFFEATURE=18
} LYEXT_PAR;

typedef enum LYEXT_SUBSTMT {
    LYEXT_SUBSTMT_ALL=-1,
    LYEXT_SUBSTMT_SELF=0,
    LYEXT_SUBSTMT_ARGUMENT=1,
    LYEXT_SUBSTMT_BASE=2,
    LYEXT_SUBSTMT_BELONGSTO=3,
    LYEXT_SUBSTMT_CONTACT=4,
    LYEXT_SUBSTMT_DEFAULT=5,
    LYEXT_SUBSTMT_DESCRIPTION=6,
    LYEXT_SUBSTMT_ERRTAG=7,
    LYEXT_SUBSTMT_ERRMSG=8,
    LYEXT_SUBSTMT_KEY=9,
    LYEXT_SUBSTMT_NAMESPACE=10,
    LYEXT_SUBSTMT_ORGANIZATION=11,
    LYEXT_SUBSTMT_PATH=12,
    LYEXT_SUBSTMT_PREFIX=13,
    LYEXT_SUBSTMT_PRESENCE=14,
    LYEXT_SUBSTMT_REFERENCE=15,
    LYEXT_SUBSTMT_REVISIONDATE=16,
    LYEXT_SUBSTMT_UNITS=17,
    LYEXT_SUBSTMT_VALUE=18,
    LYEXT_SUBSTMT_VERSION=19,
    LYEXT_SUBSTMT_MODIFIER=20,
    LYEXT_SUBSTMT_REQINSTANCE=21,
    LYEXT_SUBSTMT_YINELEM=22,
    LYEXT_SUBSTMT_CONFIG=23,
    LYEXT_SUBSTMT_MANDATORY=24,
    LYEXT_SUBSTMT_ORDEREDBY=25,
    LYEXT_SUBSTMT_STATUS=26,
    LYEXT_SUBSTMT_DIGITS=27,
    LYEXT_SUBSTMT_MAX=28,
    LYEXT_SUBSTMT_MIN=29,
    LYEXT_SUBSTMT_POSITION=30,
    LYEXT_SUBSTMT_UNIQUE=31
} LYEXT_SUBSTMT;

typedef int (*lyext_check_position_clb)(void *, enum LYEXT_PAR, enum LYEXT_SUBSTMT);

typedef int (*lyext_check_result_clb)(struct lys_ext_instance *);

typedef int (*lyext_check_inherit_clb)(struct lys_ext_instance *, struct lys_node *);

typedef int (*lyext_valid_data_clb)(struct lys_ext_instance *, struct lyd_node *);

typedef union lys_type_info lys_type_info, *Plys_type_info;

typedef enum lys_deviate_type {
    LY_DEVIATE_NO=0,
    LY_DEVIATE_ADD=1,
    LY_DEVIATE_RPL=2,
    LY_DEVIATE_DEL=3
} lys_deviate_type;

typedef enum lys_deviate_type LYS_DEVIATE_TYPE;

typedef struct lys_restr lys_restr, *Plys_restr;

typedef struct lys_unique lys_unique, *Plys_unique;

typedef enum LY_STMT {
    LY_STMT_NODE=-1,
    LY_STMT_UNKNOWN=0,
    LY_STMT_ARGUMENT=1,
    LY_STMT_BASE=2,
    LY_STMT_BELONGSTO=3,
    LY_STMT_CONTACT=4,
    LY_STMT_DEFAULT=5,
    LY_STMT_DESCRIPTION=6,
    LY_STMT_ERRTAG=7,
    LY_STMT_ERRMSG=8,
    LY_STMT_KEY=9,
    LY_STMT_NAMESPACE=10,
    LY_STMT_ORGANIZATION=11,
    LY_STMT_PATH=12,
    LY_STMT_PREFIX=13,
    LY_STMT_PRESENCE=14,
    LY_STMT_REFERENCE=15,
    LY_STMT_REVISIONDATE=16,
    LY_STMT_UNITS=17,
    LY_STMT_VALUE=18,
    LY_STMT_VERSION=19,
    LY_STMT_MODIFIER=20,
    LY_STMT_REQINSTANCE=21,
    LY_STMT_YINELEM=22,
    LY_STMT_CONFIG=23,
    LY_STMT_MANDATORY=24,
    LY_STMT_ORDEREDBY=25,
    LY_STMT_STATUS=26,
    LY_STMT_DIGITS=27,
    LY_STMT_MAX=28,
    LY_STMT_MIN=29,
    LY_STMT_POSITION=30,
    LY_STMT_UNIQUE=31,
    LY_STMT_MODULE=32,
    LY_STMT_ACTION=33,
    LY_STMT_ANYDATA=34,
    LY_STMT_ANYXML=35,
    LY_STMT_CASE=36,
    LY_STMT_CHOICE=37,
    LY_STMT_CONTAINER=38,
    LY_STMT_GROUPING=39,
    LY_STMT_INPUT=40,
    LY_STMT_LEAF=41,
    LY_STMT_LEAFLIST=42,
    LY_STMT_LIST=43,
    LY_STMT_NOTIFICATION=44,
    LY_STMT_OUTPUT=45,
    LY_STMT_USES=46,
    LY_STMT_TYPEDEF=47,
    LY_STMT_TYPE=48,
    LY_STMT_IFFEATURE=49,
    LY_STMT_LENGTH=50,
    LY_STMT_MUST=51,
    LY_STMT_PATTERN=52,
    LY_STMT_RANGE=53,
    LY_STMT_WHEN=54,
    LY_STMT_REVISION=55,
    LY_STMT_SUBMODULE=56,
    LY_STMT_RPC=57,
    LY_STMT_BIT=58,
    LY_STMT_ENUM=59,
    LY_STMT_REFINE=60,
    LY_STMT_AUGMENT=61,
    LY_STMT_DEVIATE=62,
    LY_STMT_DEVIATION=63,
    LY_STMT_EXTENSION=64,
    LY_STMT_FEATURE=65,
    LY_STMT_IDENTITY=66,
    LY_STMT_IMPORT=67,
    LY_STMT_INCLUDE=68
} LY_STMT;

typedef enum LY_STMT_CARD {
    LY_STMT_CARD_OPT=0,
    LY_STMT_CARD_MAND=1,
    LY_STMT_CARD_SOME=2,
    LY_STMT_CARD_ANY=3
} LY_STMT_CARD;

typedef struct lys_type_info_binary lys_type_info_binary, *Plys_type_info_binary;

typedef struct lys_type_info_bits lys_type_info_bits, *Plys_type_info_bits;

typedef struct lys_type_info_dec64 lys_type_info_dec64, *Plys_type_info_dec64;

typedef struct lys_type_info_enums lys_type_info_enums, *Plys_type_info_enums;

typedef struct lys_type_info_ident lys_type_info_ident, *Plys_type_info_ident;

typedef struct lys_type_info_inst lys_type_info_inst, *Plys_type_info_inst;

typedef struct lys_type_info_num lys_type_info_num, *Plys_type_info_num;

typedef struct lys_type_info_lref lys_type_info_lref, *Plys_type_info_lref;

typedef struct lys_type_info_str lys_type_info_str, *Plys_type_info_str;

typedef struct lys_type_info_union lys_type_info_union, *Plys_type_info_union;

typedef struct lys_node_leaf lys_node_leaf, *Plys_node_leaf;

struct lys_ext_instance {
    struct lys_ext *def;
    void *parent;
    char *arg_value;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t insubstmt_index;
    uint8_t insubstmt;
    uint8_t parent_type;
    uint8_t ext_type;
    uint8_t padding;
    struct lys_ext_instance **ext;
    void *priv;
    struct lys_module *module;
    LYS_NODE nodetype;
};

struct lys_type_info_bits {
    struct lys_type_bit *bit;
    uint count;
};

struct lys_type_bit {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint32_t pos;
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
};

struct lys_type_enum {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    int32_t value;
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
};

struct lys_type_info_inst {
    int8_t req;
};

struct lyext_plugin {
    enum LYEXT_TYPE type;
    uint16_t flags;
    lyext_check_position_clb check_position;
    lyext_check_result_clb check_result;
    lyext_check_inherit_clb check_inherit;
    lyext_valid_data_clb valid_data;
};

struct lys_type_info_union {
    struct lys_type *types;
    uint count;
    int has_ptr_type;
};

struct ly_modules_list {
    char **search_paths;
    int size;
    int used;
    struct lys_module **list;
    struct lys_module **parsing_sub_modules;
    struct lys_module **parsed_submodules;
    uint8_t parsing_sub_modules_count;
    uint8_t parsed_submodules_count;
    uint16_t module_set_id;
    int flags;
};

union ly_set_set {
    struct lys_node **s;
    struct lyd_node **d;
    void **g;
};

struct ly_set {
    uint size;
    uint number;
    union ly_set_set set;
};

struct lys_type_info_str {
    struct lys_restr *length;
    struct lys_restr *patterns;
    uint pat_count;
    void **patterns_pcre;
};

struct lys_type_info_enums {
    struct lys_type_enum *enm;
    uint count;
};

struct lys_when {
    char *cond;
    char *dsc;
    char *ref;
    struct lys_ext_instance **ext;
    uint8_t ext_size;
    uint16_t flags;
};

struct ly_ctx {
    struct dict_table dict;
    struct ly_modules_list models;
    ly_module_imp_clb imp_clb;
    void *imp_clb_data;
    ly_module_data_clb data_clb;
    void *data_clb_data;
    pthread_key_t errlist_key;
    uint8_t internal_module_count;
};

struct lys_revision {
    char date[11];
    uint8_t ext_size;
    struct lys_ext_instance **ext;
    char *dsc;
    char *ref;
};

union lyd_value_u {
    char *binary;
    struct lys_type_bit **bit;
    int8_t bln;
    int64_t dec64;
    struct lys_type_enum *enm;
    struct lys_ident *ident;
    struct lyd_node *instance;
    int8_t int8;
    int16_t int16;
    int32_t int32;
    int64_t int64;
    struct lyd_node *leafref;
    char *string;
    uint8_t uint8;
    uint16_t uint16;
    uint32_t uint32;
    uint64_t uint64;
    void *ptr;
};

struct lyext_substmt {
    enum LY_STMT stmt;
    size_t offset;
    enum LY_STMT_CARD cardinality;
};

struct lys_feature {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t padding[4];
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    struct ly_set *depfeatures;
};

struct lys_deviate {
    LYS_DEVIATE_TYPE mod;
    uint8_t flags;
    uint8_t dflt_size;
    uint8_t ext_size;
    uint8_t min_set;
    uint8_t max_set;
    uint8_t must_size;
    uint8_t unique_size;
    uint32_t min;
    uint32_t max;
    struct lys_restr *must;
    struct lys_unique *unique;
    struct lys_type *type;
    char *units;
    char **dflt;
    struct lys_ext_instance **ext;
};

struct lys_submodule {
    struct ly_ctx *ctx;
    char *name;
    char *prefix;
    char *dsc;
    char *ref;
    char *org;
    char *contact;
    char *filepath;
    uint8_t type:1;
    uint8_t version:3;
    uint8_t deviated:2;
    uint8_t disabled:1;
    uint8_t implemented:1;
    uint8_t padding[3];
    uint8_t rev_size;
    uint8_t imp_size;
    uint8_t inc_size;
    uint16_t ident_size;
    uint16_t tpdf_size;
    uint8_t features_size;
    uint8_t augment_size;
    uint8_t deviation_size;
    uint8_t extensions_size;
    uint8_t ext_size;
    struct lys_revision *rev;
    struct lys_import *imp;
    struct lys_include *inc;
    struct lys_tpdf *tpdf;
    struct lys_ident *ident;
    struct lys_feature *features;
    struct lys_node_augment *augment;
    struct lys_deviation *deviation;
    struct lys_ext *extensions;
    struct lys_ext_instance **ext;
    struct lys_module *belongsto;
};

struct lys_type_info_lref {
    char *path;
    struct lys_node_leaf *target;
    int8_t req;
};

struct lys_ext_instance_complex {
    struct lys_ext *def;
    void *parent;
    char *arg_value;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t insubstmt_index;
    uint8_t insubstmt;
    uint8_t parent_type;
    uint8_t ext_type;
    uint8_t padding;
    struct lys_ext_instance **ext;
    void *priv;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lyext_substmt *substmt;
    char content[1];
};

struct lys_node {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t padding[4];
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct lys_node *child;
    struct lys_node *next;
    struct lys_node *prev;
    void *priv;
    uint8_t hash[4];
};

struct lys_iffeature {
    uint8_t *expr;
    uint8_t ext_size;
    struct lys_feature **features;
    struct lys_ext_instance **ext;
};

struct lyd_attr {
    struct lyd_node *parent;
    struct lyd_attr *next;
    struct lys_ext_instance_complex *annotation;
    char *name;
    char *value_str;
    lyd_val value;
    enum LY_DATA_TYPE value_type;
    uint8_t value_flags;
};

struct lys_include {
    struct lys_submodule *submodule;
    char rev[11];
    uint8_t ext_size;
    struct lys_ext_instance **ext;
    char *dsc;
    char *ref;
};

struct lys_type_info_dec64 {
    struct lys_restr *range;
    uint8_t dig;
    uint64_t div;
};

struct lys_type_info_num {
    struct lys_restr *range;
};

struct lys_type_info_ident {
    struct lys_ident **ref;
    uint count;
};

struct lys_type_info_binary {
    struct lys_restr *length;
};

union lys_type_info {
    struct lys_type_info_binary binary;
    struct lys_type_info_bits bits;
    struct lys_type_info_dec64 dec64;
    struct lys_type_info_enums enums;
    struct lys_type_info_ident ident;
    struct lys_type_info_inst inst;
    struct lys_type_info_num num;
    struct lys_type_info_lref lref;
    struct lys_type_info_str str;
    struct lys_type_info_union uni;
};

struct lys_type {
    enum LY_DATA_TYPE base;
    uint8_t value_flags;
    uint8_t ext_size;
    struct lys_ext_instance **ext;
    struct lys_tpdf *der;
    struct lys_tpdf *parent;
    union lys_type_info info;
};

struct lys_tpdf {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t padding_iffsize;
    uint8_t has_union_leafref;
    uint8_t padding[3];
    struct lys_ext_instance **ext;
    char *units;
    struct lys_module *module;
    struct lys_type type;
    char *dflt;
};

struct lyd_node {
    struct lys_node *schema;
    uint8_t validity;
    uint8_t dflt:1;
    uint8_t when_status:3;
    struct lyd_attr *attr;
    struct lyd_node *next;
    struct lyd_node *prev;
    struct lyd_node *parent;
    uint32_t hash;
    struct hash_table *ht;
    struct lyd_node *child;
};

struct lys_restr {
    char *expr;
    char *dsc;
    char *ref;
    char *eapptag;
    char *emsg;
    struct lys_ext_instance **ext;
    uint8_t ext_size;
    uint16_t flags;
};

struct lys_node_augment {
    char *target_name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t padding[4];
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct lys_node *child;
    struct lys_when *when;
    struct lys_node *target;
    void *priv;
};

struct lys_deviation {
    char *target_name;
    char *dsc;
    char *ref;
    struct lys_node *orig_node;
    uint8_t deviate_size;
    uint8_t ext_size;
    struct lys_deviate *deviate;
    struct lys_ext_instance **ext;
};

struct lys_import {
    struct lys_module *module;
    char *prefix;
    char rev[11];
    uint8_t ext_size;
    struct lys_ext_instance **ext;
    char *dsc;
    char *ref;
};

struct lys_module {
    struct ly_ctx *ctx;
    char *name;
    char *prefix;
    char *dsc;
    char *ref;
    char *org;
    char *contact;
    char *filepath;
    uint8_t type:1;
    uint8_t version:3;
    uint8_t deviated:2;
    uint8_t disabled:1;
    uint8_t implemented:1;
    uint8_t latest_revision:1;
    uint8_t padding1:7;
    uint8_t padding2[2];
    uint8_t rev_size;
    uint8_t imp_size;
    uint8_t inc_size;
    uint16_t ident_size;
    uint16_t tpdf_size;
    uint8_t features_size;
    uint8_t augment_size;
    uint8_t deviation_size;
    uint8_t extensions_size;
    uint8_t ext_size;
    struct lys_revision *rev;
    struct lys_import *imp;
    struct lys_include *inc;
    struct lys_tpdf *tpdf;
    struct lys_ident *ident;
    struct lys_feature *features;
    struct lys_node_augment *augment;
    struct lys_deviation *deviation;
    struct lys_ext *extensions;
    struct lys_ext_instance **ext;
    struct lys_node *data;
    char *ns;
};

struct lys_ext {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t padding[5];
    struct lys_ext_instance **ext;
    char *argument;
    struct lys_module *module;
    struct lyext_plugin *plugin;
};

struct lys_node_leaf {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t padding[3];
    uint8_t must_size;
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct ly_set *backlinks;
    struct lys_node *next;
    struct lys_node *prev;
    void *priv;
    uint8_t hash[4];
    struct lys_when *when;
    struct lys_restr *must;
    struct lys_type type;
    char *units;
    char *dflt;
};

struct lys_ident {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t padding[3];
    uint8_t base_size;
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    struct lys_ident **base;
    struct ly_set *der;
};

struct lys_unique {
    char **expr;
    uint8_t expr_size;
    uint8_t trg_type;
};

typedef struct ly_err_item ly_err_item, *Ply_err_item;

typedef enum LY_ERR {
    LY_SUCCESS=0,
    LY_EMEM=1,
    LY_ESYS=2,
    LY_EINVAL=3,
    LY_EINT=4,
    LY_EVALID=5,
    LY_EPLUGIN=6
} LY_ERR;

typedef enum LY_VECODE {
    LYVE_SUCCESS=0,
    LYVE_XML_MISS=1,
    LYVE_XML_INVAL=2,
    LYVE_XML_INCHAR=3,
    LYVE_EOF=4,
    LYVE_INSTMT=5,
    LYVE_INPAR=6,
    LYVE_INID=7,
    LYVE_INDATE=8,
    LYVE_INARG=9,
    LYVE_MISSSTMT=10,
    LYVE_MISSARG=11,
    LYVE_TOOMANY=12,
    LYVE_DUPID=13,
    LYVE_DUPLEAFLIST=14,
    LYVE_DUPLIST=15,
    LYVE_NOUNIQ=16,
    LYVE_ENUM_INVAL=17,
    LYVE_ENUM_INNAME=18,
    LYVE_ENUM_WS=19,
    LYVE_BITS_INVAL=20,
    LYVE_BITS_INNAME=21,
    LYVE_INMOD=22,
    LYVE_KEY_NLEAF=23,
    LYVE_KEY_TYPE=24,
    LYVE_KEY_CONFIG=25,
    LYVE_KEY_MISS=26,
    LYVE_KEY_DUP=27,
    LYVE_INREGEX=28,
    LYVE_INRESOLV=29,
    LYVE_INSTATUS=30,
    LYVE_CIRC_LEAFREFS=31,
    LYVE_CIRC_FEATURES=32,
    LYVE_CIRC_IMPORTS=33,
    LYVE_CIRC_INCLUDES=34,
    LYVE_INVER=35,
    LYVE_SUBMODULE=36,
    LYVE_OBSDATA=37,
    LYVE_NORESOLV=38,
    LYVE_INELEM=39,
    LYVE_MISSELEM=40,
    LYVE_INVAL=41,
    LYVE_INMETA=42,
    LYVE_INATTR=43,
    LYVE_MISSATTR=44,
    LYVE_NOCONSTR=45,
    LYVE_INCHAR=46,
    LYVE_INPRED=47,
    LYVE_MCASEDATA=48,
    LYVE_NOMUST=49,
    LYVE_NOWHEN=50,
    LYVE_INORDER=51,
    LYVE_INWHEN=52,
    LYVE_NOMIN=53,
    LYVE_NOMAX=54,
    LYVE_NOREQINS=55,
    LYVE_NOLEAFREF=56,
    LYVE_NOMANDCHOICE=57,
    LYVE_XPATH_INTOK=58,
    LYVE_XPATH_EOF=59,
    LYVE_XPATH_INOP=60,
    LYVE_XPATH_INCTX=61,
    LYVE_XPATH_INMOD=62,
    LYVE_XPATH_INFUNC=63,
    LYVE_XPATH_INARGCOUNT=64,
    LYVE_XPATH_INARGTYPE=65,
    LYVE_XPATH_DUMMY=66,
    LYVE_XPATH_NOEND=67,
    LYVE_PATH_INCHAR=68,
    LYVE_PATH_INMOD=69,
    LYVE_PATH_MISSMOD=70,
    LYVE_PATH_INNODE=71,
    LYVE_PATH_INKEY=72,
    LYVE_PATH_MISSKEY=73,
    LYVE_PATH_INIDENTREF=74,
    LYVE_PATH_EXISTS=75,
    LYVE_PATH_MISSPAR=76,
    LYVE_PATH_PREDTOOMANY=77
} LY_VECODE;

struct ly_err_item {
    enum LY_LOG_LEVEL level;
    enum LY_ERR no;
    enum LY_VECODE vecode;
    char *msg;
    char *path;
    char *apptag;
    struct ly_err_item *next;
    struct ly_err_item *prev;
};

typedef enum lyxp_node_type {
    LYXP_NODE_ROOT=0,
    LYXP_NODE_ROOT_CONFIG=1,
    LYXP_NODE_ELEM=2,
    LYXP_NODE_TEXT=3,
    LYXP_NODE_ATTR=4,
    LYXP_NODE_NONE=5
} lyxp_node_type;

typedef struct lys_node_leaflist lys_node_leaflist, *Plys_node_leaflist;

struct lys_node_leaflist {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t padding[2];
    uint8_t dflt_size;
    uint8_t must_size;
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct ly_set *backlinks;
    struct lys_node *next;
    struct lys_node *prev;
    void *priv;
    uint8_t hash[4];
    struct lys_when *when;
    struct lys_restr *must;
    struct lys_type type;
    char *units;
    char **dflt;
    uint32_t min;
    uint32_t max;
};

typedef struct lys_node_uses lys_node_uses, *Plys_node_uses;

typedef struct lys_refine lys_refine, *Plys_refine;

typedef struct lys_node_grp lys_node_grp, *Plys_node_grp;

typedef union lys_refine_mod lys_refine_mod, *Plys_refine_mod;

typedef struct lys_refine_mod_list lys_refine_mod_list, *Plys_refine_mod_list;

struct lys_node_uses {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t padding[2];
    uint8_t refine_size;
    uint8_t augment_size;
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct lys_node *child;
    struct lys_node *next;
    struct lys_node *prev;
    void *priv;
    struct lys_when *when;
    struct lys_refine *refine;
    struct lys_node_augment *augment;
    struct lys_node_grp *grp;
};

struct lys_refine_mod_list {
    uint32_t min;
    uint32_t max;
};

struct lys_node_grp {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t padding_iffsize;
    uint16_t unres_count;
    uint16_t tpdf_size;
    struct lys_ext_instance **ext;
    void *padding_iff;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct lys_node *child;
    struct lys_node *next;
    struct lys_node *prev;
    void *priv;
    struct lys_tpdf *tpdf;
};

union lys_refine_mod {
    char *presence;
    struct lys_refine_mod_list list;
};

struct lys_refine {
    char *target_name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint16_t target_type;
    uint8_t must_size;
    uint8_t dflt_size;
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    struct lys_restr *must;
    char **dflt;
    union lys_refine_mod mod;
};

typedef struct lys_node_case lys_node_case, *Plys_node_case;

struct lys_node_case {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t padding[4];
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct lys_node *child;
    struct lys_node *next;
    struct lys_node *prev;
    void *priv;
    struct lys_when *when;
};

typedef struct lys_node_inout lys_node_inout, *Plys_node_inout;

struct lys_node_inout {
    char *name;
    void *fill1[2];
    uint16_t flags;
    uint8_t ext_size;
    uint8_t padding_iffsize;
    uint8_t padding[1];
    uint8_t must_size;
    uint16_t tpdf_size;
    struct lys_ext_instance **ext;
    void *padding_iff;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct lys_node *child;
    struct lys_node *next;
    struct lys_node *prev;
    void *priv;
    struct lys_tpdf *tpdf;
    struct lys_restr *must;
};

typedef struct lys_node_container lys_node_container, *Plys_node_container;

struct lys_node_container {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t padding[1];
    uint8_t must_size;
    uint16_t tpdf_size;
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct lys_node *child;
    struct lys_node *next;
    struct lys_node *prev;
    void *priv;
    uint8_t hash[4];
    struct lys_when *when;
    struct lys_restr *must;
    struct lys_tpdf *tpdf;
    char *presence;
};

typedef enum LYS_VERSION {
    LYS_VERSION_UNDEF=0,
    LYS_VERSION_1=1,
    LYS_VERSION_1_1=2
} LYS_VERSION;

typedef struct lys_node_notif lys_node_notif, *Plys_node_notif;

struct lys_node_notif {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t padding[1];
    uint8_t must_size;
    uint16_t tpdf_size;
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct lys_node *child;
    struct lys_node *next;
    struct lys_node *prev;
    void *priv;
    uint8_t hash[4];
    struct lys_tpdf *tpdf;
    struct lys_restr *must;
};

typedef struct lys_node_rpc_action lys_node_rpc_action, *Plys_node_rpc_action;

struct lys_node_rpc_action {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t padding[2];
    uint16_t tpdf_size;
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct lys_node *child;
    struct lys_node *next;
    struct lys_node *prev;
    void *priv;
    uint8_t hash[4];
    struct lys_tpdf *tpdf;
};

typedef struct lys_node_list lys_node_list, *Plys_node_list;

struct lys_node_list {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t must_size;
    uint8_t tpdf_size;
    uint8_t keys_size;
    uint8_t unique_size;
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct lys_node *child;
    struct lys_node *next;
    struct lys_node *prev;
    void *priv;
    uint8_t hash[4];
    struct lys_when *when;
    struct lys_restr *must;
    struct lys_tpdf *tpdf;
    struct lys_node_leaf **keys;
    struct lys_unique *unique;
    uint32_t min;
    uint32_t max;
    char *keys_str;
};

typedef enum LYS_OUTFORMAT {
    LYS_OUT_UNKNOWN=0,
    LYS_OUT_YANG=1,
    LYS_OUT_YIN=2,
    LYS_OUT_TREE=3,
    LYS_OUT_INFO=4,
    LYS_OUT_JSON=5
} LYS_OUTFORMAT;

typedef struct lys_node_choice lys_node_choice, *Plys_node_choice;

struct lys_node_choice {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t padding[4];
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct lys_node *child;
    struct lys_node *next;
    struct lys_node *prev;
    void *priv;
    struct lys_when *when;
    struct lys_node *dflt;
};

typedef struct lys_node_anydata lys_node_anydata, *Plys_node_anydata;

struct lys_node_anydata {
    char *name;
    char *dsc;
    char *ref;
    uint16_t flags;
    uint8_t ext_size;
    uint8_t iffeature_size;
    uint8_t padding[3];
    uint8_t must_size;
    struct lys_ext_instance **ext;
    struct lys_iffeature *iffeature;
    struct lys_module *module;
    LYS_NODE nodetype;
    struct lys_node *parent;
    struct lys_node *child;
    struct lys_node *next;
    struct lys_node *prev;
    void *priv;
    uint8_t hash[4];
    struct lys_when *when;
    struct lys_restr *must;
};

typedef struct internal_modules_s internal_modules_s, *Pinternal_modules_s;

struct internal_modules_s {
    char *name;
    char *revision;
    char *data;
    uint8_t implemented;
    enum LYS_INFORMAT format;
};

typedef enum lyxml_data_type {
    LYXML_DATA_ATTR=1,
    LYXML_DATA_ELEM=2
} lyxml_data_type;

typedef enum lyxml_data_type LYXML_DATA_TYPE;

typedef struct pcre_extra pcre_extra, *Ppcre_extra;

struct pcre_extra {
    ulong flags;
    void *study_data;
    ulong match_limit;
    void *callout_data;
    uchar *tables;
    ulong match_limit_recursion;
    uchar **mark;
    void *executable_jit;
};

typedef struct pcre_callout_block pcre_callout_block, *Ppcre_callout_block;

struct pcre_callout_block {
    int version;
    int callout_number;
    int *offset_vector;
    char *subject;
    int subject_length;
    int start_match;
    int current_position;
    int capture_top;
    int capture_last;
    void *callout_data;
    int pattern_position;
    int next_item_length;
    uchar *mark;
};

typedef struct pcre16_callout_block pcre16_callout_block, *Ppcre16_callout_block;

struct pcre16_callout_block {
    int version;
    int callout_number;
    int *offset_vector;
    ushort *subject;
    int subject_length;
    int start_match;
    int current_position;
    int capture_top;
    int capture_last;
    void *callout_data;
    int pattern_position;
    int next_item_length;
    ushort *mark;
};

typedef struct real_pcre pcre;

typedef struct pcre32_callout_block pcre32_callout_block, *Ppcre32_callout_block;

struct pcre32_callout_block {
    int version;
    int callout_number;
    int *offset_vector;
    uint *subject;
    int subject_length;
    int start_match;
    int current_position;
    int capture_top;
    int capture_last;
    void *callout_data;
    int pattern_position;
    int next_item_length;
    uint *mark;
};

typedef __builtin_va_list __gnuc_va_list;

typedef __gnuc_va_list va_list;

typedef uint8_t flex_uint8_t;

typedef flex_uint8_t YY_CHAR;

typedef struct yyguts_t yyguts_t, *Pyyguts_t;


// WARNING! conflicting data type names: /DWARF/struct_FILE.h/_IO_FILE - /stdio.h/_IO_FILE

typedef struct _IO_FILE FILE;

typedef struct yy_buffer_state yy_buffer_state, *Pyy_buffer_state;

typedef struct yy_buffer_state *YY_BUFFER_STATE;

typedef union YYSTYPE YYSTYPE, *PYYSTYPE;

typedef struct YYLTYPE YYLTYPE, *PYYLTYPE;

typedef struct yang_type yang_type, *Pyang_type;

typedef union anon_union_16_11_f0b41fff_for_nodes anon_union_16_11_f0b41fff_for_nodes, *Panon_union_16_11_f0b41fff_for_nodes;

typedef enum yytokentype {
    UNION_KEYWORD=258,
    ANYXML_KEYWORD=259,
    WHITESPACE=260,
    ERROR=261,
    EOL=262,
    STRING=263,
    STRINGS=264,
    IDENTIFIER=265,
    IDENTIFIERPREFIX=266,
    REVISION_DATE=267,
    TAB=268,
    DOUBLEDOT=269,
    URI=270,
    INTEGER=271,
    NON_NEGATIVE_INTEGER=272,
    ZERO=273,
    DECIMAL=274,
    ARGUMENT_KEYWORD=275,
    AUGMENT_KEYWORD=276,
    BASE_KEYWORD=277,
    BELONGS_TO_KEYWORD=278,
    BIT_KEYWORD=279,
    CASE_KEYWORD=280,
    CHOICE_KEYWORD=281,
    CONFIG_KEYWORD=282,
    CONTACT_KEYWORD=283,
    CONTAINER_KEYWORD=284,
    DEFAULT_KEYWORD=285,
    DESCRIPTION_KEYWORD=286,
    ENUM_KEYWORD=287,
    ERROR_APP_TAG_KEYWORD=288,
    ERROR_MESSAGE_KEYWORD=289,
    EXTENSION_KEYWORD=290,
    DEVIATION_KEYWORD=291,
    DEVIATE_KEYWORD=292,
    FEATURE_KEYWORD=293,
    FRACTION_DIGITS_KEYWORD=294,
    GROUPING_KEYWORD=295,
    IDENTITY_KEYWORD=296,
    IF_FEATURE_KEYWORD=297,
    IMPORT_KEYWORD=298,
    INCLUDE_KEYWORD=299,
    INPUT_KEYWORD=300,
    KEY_KEYWORD=301,
    LEAF_KEYWORD=302,
    LEAF_LIST_KEYWORD=303,
    LENGTH_KEYWORD=304,
    LIST_KEYWORD=305,
    MANDATORY_KEYWORD=306,
    MAX_ELEMENTS_KEYWORD=307,
    MIN_ELEMENTS_KEYWORD=308,
    MODULE_KEYWORD=309,
    MUST_KEYWORD=310,
    NAMESPACE_KEYWORD=311,
    NOTIFICATION_KEYWORD=312,
    ORDERED_BY_KEYWORD=313,
    ORGANIZATION_KEYWORD=314,
    OUTPUT_KEYWORD=315,
    PATH_KEYWORD=316,
    PATTERN_KEYWORD=317,
    POSITION_KEYWORD=318,
    PREFIX_KEYWORD=319,
    PRESENCE_KEYWORD=320,
    RANGE_KEYWORD=321,
    REFERENCE_KEYWORD=322,
    REFINE_KEYWORD=323,
    REQUIRE_INSTANCE_KEYWORD=324,
    REVISION_KEYWORD=325,
    REVISION_DATE_KEYWORD=326,
    RPC_KEYWORD=327,
    STATUS_KEYWORD=328,
    SUBMODULE_KEYWORD=329,
    TYPE_KEYWORD=330,
    TYPEDEF_KEYWORD=331,
    UNIQUE_KEYWORD=332,
    UNITS_KEYWORD=333,
    USES_KEYWORD=334,
    VALUE_KEYWORD=335,
    WHEN_KEYWORD=336,
    YANG_VERSION_KEYWORD=337,
    YIN_ELEMENT_KEYWORD=338,
    ADD_KEYWORD=339,
    CURRENT_KEYWORD=340,
    DELETE_KEYWORD=341,
    DEPRECATED_KEYWORD=342,
    FALSE_KEYWORD=343,
    NOT_SUPPORTED_KEYWORD=344,
    OBSOLETE_KEYWORD=345,
    REPLACE_KEYWORD=346,
    SYSTEM_KEYWORD=347,
    TRUE_KEYWORD=348,
    UNBOUNDED_KEYWORD=349,
    USER_KEYWORD=350,
    ACTION_KEYWORD=351,
    MODIFIER_KEYWORD=352,
    ANYDATA_KEYWORD=353,
    NODE=354,
    NODE_PRINT=355,
    EXTENSION_INSTANCE=356,
    SUBMODULE_EXT_KEYWORD=357
} yytokentype;

typedef struct anon_struct_16_2_8e0241b6_for_backup_token anon_struct_16_2_8e0241b6_for_backup_token, *Panon_struct_16_2_8e0241b6_for_backup_token;

typedef struct anon_struct_16_2_8301bfa2_for_revisions anon_struct_16_2_8301bfa2_for_revisions, *Panon_struct_16_2_8301bfa2_for_revisions;

typedef struct type_node type_node, *Ptype_node;

typedef union anon_union_8_7_25e536bd_for_type_node_0 anon_union_8_7_25e536bd_for_type_node_0, *Panon_union_8_7_25e536bd_for_type_node_0;

struct anon_struct_16_2_8301bfa2_for_revisions {
    struct lys_revision **revision;
    int index;
};

union anon_union_8_7_25e536bd_for_type_node_0 {
    struct lys_node_leaflist *ptr_leaflist;
    struct lys_node_list *ptr_list;
    struct lys_node_leaf *ptr_leaf;
    struct lys_tpdf *ptr_tpdf;
    struct lys_node_anydata *ptr_anydata;
    struct lys_node_rpc_action *ptr_rpc;
    struct lys_node_choice *ptr_choice;
};

struct type_node {
    union anon_union_8_7_25e536bd_for_type_node_0 field_0;
    uint flag;
};

union anon_union_16_11_f0b41fff_for_nodes {
    uint32_t index;
    struct lys_node_container *container;
    struct lys_node_anydata *anydata;
    struct type_node node;
    struct lys_node_case *cs;
    struct lys_node_grp *grouping;
    struct lys_refine *refine;
    struct lys_node_notif *notif;
    struct lys_node_uses *uses;
    struct lys_node_inout *inout;
    struct lys_node_augment *augment;
};

struct anon_struct_16_2_8e0241b6_for_backup_token {
    void *actual;
    enum yytokentype token;
};

union YYSTYPE {
    int32_t i;
    uint32_t uint;
    char *str;
    char **p_str;
    void *v;
    char ch;
    struct yang_type *type;
    struct lys_deviation *dev;
    struct lys_deviate *deviate;
    union anon_union_16_11_f0b41fff_for_nodes nodes;
    enum yytokentype token;
    struct anon_struct_16_2_8e0241b6_for_backup_token backup_token;
    struct anon_struct_16_2_8301bfa2_for_revisions revisions;
};

struct YYLTYPE {
    int first_line;
    int first_column;
    int last_line;
    int last_column;
};

struct yyguts_t {
    void *yyextra_r;
    FILE *yyin_r;
    FILE *yyout_r;
    size_t yy_buffer_stack_top;
    size_t yy_buffer_stack_max;
    YY_BUFFER_STATE *yy_buffer_stack;
    char yy_hold_char;
    int yy_n_chars;
    int yyleng_r;
    char *yy_c_buf_p;
    int yy_init;
    int yy_start;
    int yy_did_buffer_switch_on_eof;
    int yy_start_stack_ptr;
    int yy_start_stack_depth;
    int *yy_start_stack;
    yy_state_type yy_last_accepting_state;
    char *yy_last_accepting_cpos;
    int yylineno_r;
    int yy_flex_debug_r;
    char *yytext_r;
    int yy_more_flag;
    int yy_more_len;
    union YYSTYPE *yylval_r;
    struct YYLTYPE *yylloc_r;
};

struct yy_buffer_state {
    FILE *yy_input_file;
    char *yy_ch_buf;
    char *yy_buf_pos;
    int yy_buf_size;
    int yy_n_chars;
    int yy_is_our_buffer;
    int yy_is_interactive;
    int yy_at_bol;
    int yy_bs_lineno;
    int yy_bs_column;
    int yy_fill_buffer;
    int yy_buffer_status;
};

struct yang_type {
    char flags;
    enum LY_DATA_TYPE base;
    char *name;
    struct lys_type *type;
};

typedef int16_t flex_int16_t;

typedef size_t yy_size_t;

typedef void *yyscan_t;

typedef enum LYD_ANYDATA_VALUETYPE {
    LYD_ANYDATA_CONSTSTRING=0,
    LYD_ANYDATA_STRING=1,
    LYD_ANYDATA_JSON=2,
    LYD_ANYDATA_JSOND=3,
    LYD_ANYDATA_SXML=4,
    LYD_ANYDATA_SXMLD=5,
    LYD_ANYDATA_XML=8,
    LYD_ANYDATA_DATATREE=16,
    LYD_ANYDATA_LYB=32,
    LYD_ANYDATA_LYBD=33
} LYD_ANYDATA_VALUETYPE;

typedef struct lyd_node_anydata lyd_node_anydata, *Plyd_node_anydata;

typedef union lyd_anydata_value lyd_anydata_value, *Plyd_anydata_value;

union lyd_anydata_value {
    char *str;
    char *mem;
    struct lyxml_elem *xml;
    struct lyd_node *tree;
};

struct lyd_node_anydata {
    struct lys_node *schema;
    uint8_t validity;
    uint8_t dflt:1;
    uint8_t when_status:3;
    struct lyd_attr *attr;
    struct lyd_node *next;
    struct lyd_node *prev;
    struct lyd_node *parent;
    uint32_t hash;
    enum LYD_ANYDATA_VALUETYPE value_type;
    union lyd_anydata_value value;
};

typedef struct lyd_difflist lyd_difflist, *Plyd_difflist;

typedef enum LYD_DIFFTYPE {
    LYD_DIFF_END=0,
    LYD_DIFF_DELETED=1,
    LYD_DIFF_CHANGED=2,
    LYD_DIFF_MOVEDAFTER1=3,
    LYD_DIFF_CREATED=4,
    LYD_DIFF_MOVEDAFTER2=5
} LYD_DIFFTYPE;

struct lyd_difflist {
    enum LYD_DIFFTYPE *type;
    struct lyd_node **first;
    struct lyd_node **second;
};

typedef struct lyd_node_leaf_list lyd_node_leaf_list, *Plyd_node_leaf_list;

struct lyd_node_leaf_list {
    struct lys_node *schema;
    uint8_t validity;
    uint8_t dflt:1;
    uint8_t when_status:3;
    struct lyd_attr *attr;
    struct lyd_node *next;
    struct lyd_node *prev;
    struct lyd_node *parent;
    uint32_t hash;
    char *value_str;
    lyd_val value;
    enum LY_DATA_TYPE value_type;
    uint8_t value_flags;
};

typedef enum LYD_FORMAT {
    LYD_UNKNOWN=0,
    LYD_XML=1,
    LYD_JSON=2,
    LYD_LYB=3
} LYD_FORMAT;

typedef struct yang_ext_substmt yang_ext_substmt, *Pyang_ext_substmt;

struct yang_ext_substmt {
    char *ext_substmt;
    char **ext_modules;
};

typedef struct yang_parameter yang_parameter, *Pyang_parameter;

typedef struct unres_schema unres_schema, *Punres_schema;

typedef enum UNRES_ITEM {
    UNRES_USES=1,
    UNRES_IFFEAT=2,
    UNRES_TYPE_DER=4,
    UNRES_TYPE_DER_TPDF=8,
    UNRES_TYPE_DER_EXT=16,
    UNRES_TYPE_LEAFREF=32,
    UNRES_AUGMENT=64,
    UNRES_CHOICE_DFLT=128,
    UNRES_IDENT=256,
    UNRES_TYPE_IDENTREF=512,
    UNRES_FEATURE=1024,
    UNRES_TYPEDEF_DFLT=2048,
    UNRES_TYPE_DFLT=4096,
    UNRES_LIST_KEYS=8192,
    UNRES_LIST_UNIQ=16384,
    UNRES_MOD_IMPLEMENT=32768,
    UNRES_EXT=65536,
    UNRES_XPATH=131072,
    UNRES_EXT_FINALIZE=262144,
    UNRES_LEAFREF=524288,
    UNRES_INSTID=1048576,
    UNRES_WHEN=2097152,
    UNRES_MUST=4194304,
    UNRES_MUST_INOUT=8388608,
    UNRES_UNION=16777216,
    UNRES_UNIQ_LEAVES=33554432,
    UNRES_RESOLVED=67108864,
    UNRES_DELETE=134217728
} UNRES_ITEM;

struct unres_schema {
    void **item;
    enum UNRES_ITEM *type;
    void **str_snode;
    struct lys_module **module;
    uint32_t count;
};

struct yang_parameter {
    struct lys_module *module;
    struct lys_submodule *submodule;
    struct unres_schema *unres;
    struct lys_node **node;
    char **value;
    void **data_node;
    void **actual_node;
    uint8_t flags;
};

typedef struct unres_ext unres_ext, *Punres_ext;

typedef union anon_union_8_2_630e5ec0_for_data anon_union_8_2_630e5ec0_for_data, *Panon_union_8_2_630e5ec0_for_data;

union anon_union_8_2_630e5ec0_for_data {
    struct lyxml_elem *yin;
    struct yang_ext_substmt *yang;
};

struct unres_ext {
    union anon_union_8_2_630e5ec0_for_data data;
    enum LYS_INFORMAT datatype;
    void *parent;
    struct lys_module *mod;
    enum LYEXT_PAR parent_type;
    enum LYEXT_SUBSTMT substmt;
    uint8_t substmt_index;
    uint8_t ext_index;
};

typedef struct len_ran_intv len_ran_intv, *Plen_ran_intv;

typedef union anon_union_16_3_88177617_for_value anon_union_16_3_88177617_for_value, *Panon_union_16_3_88177617_for_value;

typedef struct anon_struct_16_2_441cf13b_for_uval anon_struct_16_2_441cf13b_for_uval, *Panon_struct_16_2_441cf13b_for_uval;

typedef struct anon_struct_16_2_441cf13b_for_sval anon_struct_16_2_441cf13b_for_sval, *Panon_struct_16_2_441cf13b_for_sval;

typedef struct anon_struct_16_2_441cf13b_for_fval anon_struct_16_2_441cf13b_for_fval, *Panon_struct_16_2_441cf13b_for_fval;

struct anon_struct_16_2_441cf13b_for_sval {
    int64_t min;
    int64_t max;
};

struct anon_struct_16_2_441cf13b_for_uval {
    uint64_t min;
    uint64_t max;
};

struct anon_struct_16_2_441cf13b_for_fval {
    int64_t min;
    int64_t max;
};

union anon_union_16_3_88177617_for_value {
    struct anon_struct_16_2_441cf13b_for_uval uval;
    struct anon_struct_16_2_441cf13b_for_sval sval;
    struct anon_struct_16_2_441cf13b_for_fval fval;
};

struct len_ran_intv {
    uint8_t kind;
    union anon_union_16_3_88177617_for_value value;
    struct lys_type *type;
    struct len_ran_intv *next;
};

typedef struct unres_list_uniq unres_list_uniq, *Punres_list_uniq;

struct unres_list_uniq {
    struct lys_node *list;
    char *expr;
    uint8_t *trg_type;
};

typedef struct unres_data unres_data, *Punres_data;

struct unres_data {
    struct lyd_node **node;
    enum UNRES_ITEM *type;
    uint32_t count;
    int store_diff;
    struct lyd_difflist *diff;
    uint diff_size;
    uint diff_idx;
};

typedef struct lytype_plugin_list lytype_plugin_list, *Plytype_plugin_list;

typedef int (*lytype_store_clb)(struct ly_ctx *, char *, char **, lyd_val *, char **);

struct lytype_plugin_list {
    char *module;
    char *revision;
    char *name;
    lytype_store_clb store_clb;
    void (*free_clb)(void *);
};

typedef struct diff_ordered diff_ordered, *Pdiff_ordered;

typedef struct diff_ordered_item diff_ordered_item, *Pdiff_ordered_item;

typedef struct diff_ordered_dist diff_ordered_dist, *Pdiff_ordered_dist;

struct diff_ordered_item {
    struct lyd_node *first;
    struct lyd_node *second;
    struct diff_ordered_dist *dist;
};

struct diff_ordered_dist {
    struct diff_ordered_dist *next;
    int dist;
};

struct diff_ordered {
    struct lys_node *schema;
    struct lyd_node *parent;
    uint count;
    struct diff_ordered_item *items;
    struct diff_ordered_dist *dist;
    struct diff_ordered_dist *dist_last;
};

typedef struct matchlist_s matchlist_s, *Pmatchlist_s;

struct matchlist_s {
    struct matchlist_s *prev;
    struct ly_set *match;
    uint i;
};

typedef struct unres_iffeat_data unres_iffeat_data, *Punres_iffeat_data;

struct unres_iffeat_data {
    struct lys_node *node;
    char *fname;
    int infeature;
};

typedef struct anon_struct_48_6_89480d8a anon_struct_48_6_89480d8a, *Panon_struct_48_6_89480d8a;

struct anon_struct_48_6_89480d8a {
    char *mod_name;
    int mod_name_len;
    char *name;
    int nam_len;
    char *value;
    int val_len;
};

typedef struct iff_stack iff_stack, *Piff_stack;

struct iff_stack {
    int size;
    int index;
    uint8_t *stack;
};

typedef struct parsed_pred parsed_pred, *Pparsed_pred;

struct parsed_pred {
    struct lys_node *schema;
    int len;
    struct anon_struct_48_6_89480d8a *pred;
};

typedef enum LYEXT_VLOG_ELEM {
    LYEXT_VLOG_NONE=0,
    LYEXT_VLOG_XML=1,
    LYEXT_VLOG_LYS=2,
    LYEXT_VLOG_LYD=3,
    LYEXT_VLOG_STR=4,
    LYEXT_VLOG_PREV=5
} LYEXT_VLOG_ELEM;

typedef struct lyext_plugin_complex lyext_plugin_complex, *Plyext_plugin_complex;

struct lyext_plugin_complex {
    enum LYEXT_TYPE type;
    uint16_t flags;
    lyext_check_position_clb check_position;
    lyext_check_result_clb check_result;
    lyext_check_inherit_clb check_inherit;
    lyext_valid_data_clb valid_data;
    struct lyext_substmt *substmt;
    size_t instance_size;
};

typedef struct lyext_plugin_list lyext_plugin_list, *Plyext_plugin_list;

struct lyext_plugin_list {
    char *module;
    char *revision;
    char *name;
    struct lyext_plugin *plugin;
};

typedef enum int_log_opts {
    ILO_LOG=0,
    ILO_STORE=1,
    ILO_IGNORE=2,
    ILO_ERR2WRN=3
} int_log_opts;

typedef enum LY_VLOG_ELEM {
    LY_VLOG_NONE=0,
    LY_VLOG_XML=1,
    LY_VLOG_LYS=2,
    LY_VLOG_LYD=3,
    LY_VLOG_STR=4,
    LY_VLOG_PREV=5
} LY_VLOG_ELEM;

typedef enum LY_ECODE {
    LYE_PATH=-2,
    LYE_SPEC=-1,
    LYE_SUCCESS=0,
    LYE_XML_MISS=1,
    LYE_XML_INVAL=2,
    LYE_XML_INCHAR=3,
    LYE_EOF=4,
    LYE_INSTMT=5,
    LYE_INCHILDSTMT=6,
    LYE_INPAR=7,
    LYE_INID=8,
    LYE_INDATE=9,
    LYE_INARG=10,
    LYE_MISSSTMT=11,
    LYE_MISSCHILDSTMT=12,
    LYE_MISSARG=13,
    LYE_TOOMANY=14,
    LYE_DUPID=15,
    LYE_DUPLEAFLIST=16,
    LYE_DUPLIST=17,
    LYE_NOUNIQ=18,
    LYE_ENUM_INVAL=19,
    LYE_ENUM_INNAME=20,
    LYE_ENUM_DUPVAL=21,
    LYE_ENUM_DUPNAME=22,
    LYE_ENUM_WS=23,
    LYE_BITS_INVAL=24,
    LYE_BITS_INNAME=25,
    LYE_BITS_DUPVAL=26,
    LYE_BITS_DUPNAME=27,
    LYE_INMOD=28,
    LYE_INMOD_LEN=29,
    LYE_KEY_NLEAF=30,
    LYE_KEY_TYPE=31,
    LYE_KEY_CONFIG=32,
    LYE_KEY_MISS=33,
    LYE_KEY_DUP=34,
    LYE_INREGEX=35,
    LYE_INRESOLV=36,
    LYE_INSTATUS=37,
    LYE_CIRC_LEAFREFS=38,
    LYE_CIRC_FEATURES=39,
    LYE_CIRC_IMPORTS=40,
    LYE_CIRC_INCLUDES=41,
    LYE_INVER=42,
    LYE_SUBMODULE=43,
    LYE_OBSDATA=44,
    LYE_OBSTYPE=45,
    LYE_NORESOLV=46,
    LYE_INELEM=47,
    LYE_INELEM_LEN=48,
    LYE_MISSELEM=49,
    LYE_INVAL=50,
    LYE_INMETA=51,
    LYE_INATTR=52,
    LYE_MISSATTR=53,
    LYE_NOCONSTR=54,
    LYE_INCHAR=55,
    LYE_INPRED=56,
    LYE_MCASEDATA=57,
    LYE_NOMUST=58,
    LYE_NOWHEN=59,
    LYE_INORDER=60,
    LYE_INWHEN=61,
    LYE_NOMIN=62,
    LYE_NOMAX=63,
    LYE_NOREQINS=64,
    LYE_NOLEAFREF=65,
    LYE_NOMANDCHOICE=66,
    LYE_XPATH_INTOK=67,
    LYE_XPATH_EOF=68,
    LYE_XPATH_INOP_1=69,
    LYE_XPATH_INOP_2=70,
    LYE_XPATH_INCTX=71,
    LYE_XPATH_INMOD=72,
    LYE_XPATH_INFUNC=73,
    LYE_XPATH_INARGCOUNT=74,
    LYE_XPATH_INARGTYPE=75,
    LYE_XPATH_DUMMY=76,
    LYE_XPATH_NOEND=77,
    LYE_PATH_INCHAR=78,
    LYE_PATH_INMOD=79,
    LYE_PATH_MISSMOD=80,
    LYE_PATH_INNODE=81,
    LYE_PATH_INKEY=82,
    LYE_PATH_MISSKEY=83,
    LYE_PATH_INIDENTREF=84,
    LYE_PATH_EXISTS=85,
    LYE_PATH_MISSPAR=86,
    LYE_PATH_PREDTOOMANY=87
} LY_ECODE;

typedef struct tp_opts tp_opts, *Ptp_opts;

struct tp_opts {
    struct lys_module *module;
    uint8_t base_indent;
    uint64_t indent;
    uint16_t line_length;
    int spec_config;
    int options;
};

typedef struct lyxp_set_snode lyxp_set_snode, *Plyxp_set_snode;

struct lyxp_set_snode {
    struct lys_node *snode;
    enum lyxp_node_type type;
    uint32_t in_ctx;
};

typedef struct lyxp_set_hash_node lyxp_set_hash_node, *Plyxp_set_hash_node;

struct lyxp_set_hash_node {
    struct lyd_node *node;
    enum lyxp_node_type type;
};

typedef struct lyxp_set lyxp_set, *Plyxp_set;

typedef enum lyxp_set_type {
    LYXP_SET_EMPTY=0,
    LYXP_SET_NODE_SET=1,
    LYXP_SET_SNODE_SET=2,
    LYXP_SET_BOOLEAN=3,
    LYXP_SET_NUMBER=4,
    LYXP_SET_STRING=5
} lyxp_set_type;

typedef union anon_union_16_6_eb7c38b1_for_val anon_union_16_6_eb7c38b1_for_val, *Panon_union_16_6_eb7c38b1_for_val;

typedef struct lyxp_set_node lyxp_set_node, *Plyxp_set_node;

typedef struct lyxp_set_attr lyxp_set_attr, *Plyxp_set_attr;

union anon_union_16_6_eb7c38b1_for_val {
    struct lyxp_set_node *nodes;
    struct lyxp_set_snode *snodes;
    struct lyxp_set_attr *attrs;
    char *str;
    longdouble num;
    int bool;
    undefined1 field6[16]; // Automatically generated padding to match DWARF declared size
};

struct lyxp_set {
    enum lyxp_set_type type;
    union anon_union_16_6_eb7c38b1_for_val val;
    uint32_t used;
    uint32_t size;
    struct hash_table *ht;
    uint32_t ctx_pos;
    uint32_t ctx_size;
};

struct lyxp_set_attr {
    struct lyd_attr *attr;
    enum lyxp_node_type type;
    uint32_t pos;
};

struct lyxp_set_node {
    struct lyd_node *node;
    enum lyxp_node_type type;
    uint32_t pos;
};

typedef enum lyxp_expr_type {
    LYXP_EXPR_NONE=0,
    LYXP_EXPR_OR=1,
    LYXP_EXPR_AND=2,
    LYXP_EXPR_EQUALITY=3,
    LYXP_EXPR_RELATIONAL=4,
    LYXP_EXPR_ADDITIVE=5,
    LYXP_EXPR_MULTIPLICATIVE=6,
    LYXP_EXPR_UNARY=7,
    LYXP_EXPR_UNION=8
} lyxp_expr_type;

typedef struct lyxp_expr lyxp_expr, *Plyxp_expr;

typedef enum lyxp_token {
    LYXP_TOKEN_NONE=0,
    LYXP_TOKEN_PAR1=1,
    LYXP_TOKEN_PAR2=2,
    LYXP_TOKEN_BRACK1=3,
    LYXP_TOKEN_BRACK2=4,
    LYXP_TOKEN_DOT=5,
    LYXP_TOKEN_DDOT=6,
    LYXP_TOKEN_AT=7,
    LYXP_TOKEN_COMMA=8,
    LYXP_TOKEN_NAMETEST=9,
    LYXP_TOKEN_NODETYPE=10,
    LYXP_TOKEN_FUNCNAME=11,
    LYXP_TOKEN_OPERATOR_LOG=12,
    LYXP_TOKEN_OPERATOR_COMP=13,
    LYXP_TOKEN_OPERATOR_MATH=14,
    LYXP_TOKEN_OPERATOR_UNI=15,
    LYXP_TOKEN_OPERATOR_PATH=16,
    LYXP_TOKEN_LITERAL=17,
    LYXP_TOKEN_NUMBER=18
} lyxp_token;

struct lyxp_expr {
    enum lyxp_token *tokens;
    uint16_t *expr_pos;
    uint16_t *tok_len;
    enum lyxp_expr_type **repeat;
    uint16_t used;
    uint16_t size;
    char *expr;
};

typedef struct anon_struct_16_2_515384b0 anon_struct_16_2_515384b0, *Panon_struct_16_2_515384b0;

struct anon_struct_16_2_515384b0 {
    struct lys_node *first_sibling;
    struct hash_table *ht;
};

typedef struct lyb_state lyb_state, *Plyb_state;

struct lyb_state {
    size_t *written;
    size_t *position;
    uint8_t *inner_chunks;
    int used;
    int size;
    struct lys_module **models;
    int mod_count;
    struct ly_ctx *ctx;
    struct anon_struct_16_2_515384b0 *sib_ht;
    int sib_ht_count;
};

typedef struct lyd_node_pos lyd_node_pos, *Plyd_node_pos;

struct lyd_node_pos {
    struct lyd_node *node;
    uint32_t pos;
};

typedef __ssize_t ssize_t;

typedef struct attr_cont attr_cont, *Pattr_cont;

struct attr_cont {
    struct attr_cont *next;
    struct lyd_attr *attr;
    struct lys_node *schema;
    uint index;
};

typedef union yyalloc yyalloc, *Pyyalloc;

union yyalloc {
    yytype_int16 yyss_alloc;
    union YYSTYPE yyvs_alloc;
    struct YYLTYPE yyls_alloc;
};

typedef struct mlist mlist, *Pmlist;

struct mlist {
    struct mlist *next;
    struct lys_module *module;
    uint8_t printed;
};

typedef enum LYOUT_TYPE {
    LYOUT_FD=0,
    LYOUT_STREAM=1,
    LYOUT_MEMORY=2,
    LYOUT_CALLBACK=3
} LYOUT_TYPE;

typedef struct lyout lyout, *Plyout;

typedef union anon_union_24_4_7e982667_for_method anon_union_24_4_7e982667_for_method, *Panon_union_24_4_7e982667_for_method;

typedef struct anon_struct_24_3_fd62eb96_for_mem anon_struct_24_3_fd62eb96_for_mem, *Panon_struct_24_3_fd62eb96_for_mem;

typedef struct anon_struct_16_2_fa5d5a59_for_clb anon_struct_16_2_fa5d5a59_for_clb, *Panon_struct_16_2_fa5d5a59_for_clb;

struct anon_struct_24_3_fd62eb96_for_mem {
    char *buf;
    size_t len;
    size_t size;
};

struct anon_struct_16_2_fa5d5a59_for_clb {
    ssize_t (*f)(void *, void *, size_t);
    void *arg;
};

union anon_union_24_4_7e982667_for_method {
    int fd;
    FILE *f;
    struct anon_struct_24_3_fd62eb96_for_mem mem;
    struct anon_struct_16_2_fa5d5a59_for_clb clb;
};

struct lyout {
    enum LYOUT_TYPE type;
    union anon_union_24_4_7e982667_for_method method;
    char *buffered;
    size_t buf_len;
    size_t buf_size;
    size_t hole_count;
};

typedef struct ext_substmt_info_s ext_substmt_info_s, *Pext_substmt_info_s;

struct ext_substmt_info_s {
    char *name;
    char *arg;
    int flags;
};


// WARNING! conflicting data type names: /stdarg.h/__gnuc_va_list - /DWARF/stdarg.h/__gnuc_va_list

typedef __time_t time_t;


// WARNING! conflicting data type names: /stdio.h/FILE - /DWARF/FILE.h/FILE

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

struct evp_pkey_ctx_st {
};

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;


// WARNING! conflicting data type names: /dirent.h/__dirstream - /DWARF/_UNCATEGORIZED_/__dirstream


// WARNING! conflicting data type names: /dirent.h/DIR - /DWARF/dirent.h/DIR


// WARNING! conflicting data type names: /pthreadtypes.h/pthread_mutex_t - /DWARF/pthreadtypes.h/pthread_mutex_t


// WARNING! conflicting data type names: /pthreadtypes.h/__pthread_list_t - /DWARF/thread-shared-types.h/__pthread_list_t

typedef union pthread_mutexattr_t pthread_mutexattr_t, *Ppthread_mutexattr_t;

union pthread_mutexattr_t {
    char __size[4];
    int __align;
};


// WARNING! conflicting data type names: /pthreadtypes.h/__pthread_mutex_s - /DWARF/struct_mutex.h/__pthread_mutex_s


// WARNING! conflicting data type names: /pthreadtypes.h/__pthread_internal_list - /DWARF/thread-shared-types.h/__pthread_internal_list

typedef int (*__compar_fn_t)(void *, void *);

typedef struct Elf64_Shdr Elf64_Shdr, *PElf64_Shdr;

typedef enum Elf_SectionHeaderType {
    SHT_NULL=0,
    SHT_PROGBITS=1,
    SHT_SYMTAB=2,
    SHT_STRTAB=3,
    SHT_RELA=4,
    SHT_HASH=5,
    SHT_DYNAMIC=6,
    SHT_NOTE=7,
    SHT_NOBITS=8,
    SHT_REL=9,
    SHT_SHLIB=10,
    SHT_DYNSYM=11,
    SHT_INIT_ARRAY=14,
    SHT_FINI_ARRAY=15,
    SHT_PREINIT_ARRAY=16,
    SHT_GROUP=17,
    SHT_SYMTAB_SHNDX=18,
    SHT_ANDROID_REL=1610612737,
    SHT_ANDROID_RELA=1610612738,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_CHECKSUM=1879048184,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_syminfo=1879048188,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191
} Elf_SectionHeaderType;

struct Elf64_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType sh_type;
    qword sh_flags;
    qword sh_addr;
    qword sh_offset;
    qword sh_size;
    dword sh_link;
    dword sh_info;
    qword sh_addralign;
    qword sh_entsize;
};

typedef enum Elf_ProgramHeaderType {
    PT_NULL=0,
    PT_LOAD=1,
    PT_DYNAMIC=2,
    PT_INTERP=3,
    PT_NOTE=4,
    PT_SHLIB=5,
    PT_PHDR=6,
    PT_TLS=7,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_STACK=1685382481,
    PT_GNU_RELRO=1685382482
} Elf_ProgramHeaderType;

typedef struct Elf64_Dyn Elf64_Dyn, *PElf64_Dyn;

typedef enum Elf64_DynTag {
    DT_NULL=0,
    DT_NEEDED=1,
    DT_PLTRELSZ=2,
    DT_PLTGOT=3,
    DT_HASH=4,
    DT_STRTAB=5,
    DT_SYMTAB=6,
    DT_RELA=7,
    DT_RELASZ=8,
    DT_RELAENT=9,
    DT_STRSZ=10,
    DT_SYMENT=11,
    DT_INIT=12,
    DT_FINI=13,
    DT_SONAME=14,
    DT_RPATH=15,
    DT_SYMBOLIC=16,
    DT_REL=17,
    DT_RELSZ=18,
    DT_RELENT=19,
    DT_PLTREL=20,
    DT_DEBUG=21,
    DT_TEXTREL=22,
    DT_JMPREL=23,
    DT_BIND_NOW=24,
    DT_INIT_ARRAY=25,
    DT_FINI_ARRAY=26,
    DT_INIT_ARRAYSZ=27,
    DT_FINI_ARRAYSZ=28,
    DT_RUNPATH=29,
    DT_FLAGS=30,
    DT_PREINIT_ARRAY=32,
    DT_PREINIT_ARRAYSZ=33,
    DT_RELRSZ=35,
    DT_RELR=36,
    DT_RELRENT=37,
    DT_ANDROID_REL=1610612751,
    DT_ANDROID_RELSZ=1610612752,
    DT_ANDROID_RELA=1610612753,
    DT_ANDROID_RELASZ=1610612754,
    DT_ANDROID_RELR=1879040000,
    DT_ANDROID_RELRSZ=1879040001,
    DT_ANDROID_RELRENT=1879040003,
    DT_GNU_PRELINKED=1879047669,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_CHECKSUM=1879047672,
    DT_PLTPADSZ=1879047673,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_FEATURE_1=1879047676,
    DT_POSFLAG_1=1879047677,
    DT_SYMINSZ=1879047678,
    DT_SYMINENT=1879047679,
    DT_GNU_XHASH=1879047924,
    DT_GNU_HASH=1879047925,
    DT_TLSDESC_PLT=1879047926,
    DT_TLSDESC_GOT=1879047927,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_LIBLIST=1879047929,
    DT_CONFIG=1879047930,
    DT_DEPAUDIT=1879047931,
    DT_AUDIT=1879047932,
    DT_PLTPAD=1879047933,
    DT_MOVETAB=1879047934,
    DT_SYMINFO=1879047935,
    DT_VERSYM=1879048176,
    DT_RELACOUNT=1879048185,
    DT_RELCOUNT=1879048186,
    DT_FLAGS_1=1879048187,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_AUXILIARY=2147483645,
    DT_FILTER=2147483647
} Elf64_DynTag;

struct Elf64_Dyn {
    enum Elf64_DynTag d_tag;
    qword d_val;
};

typedef struct Elf64_Phdr Elf64_Phdr, *PElf64_Phdr;

struct Elf64_Phdr {
    enum Elf_ProgramHeaderType p_type;
    dword p_flags;
    qword p_offset;
    qword p_vaddr;
    qword p_paddr;
    qword p_filesz;
    qword p_memsz;
    qword p_align;
};

typedef struct GnuBuildId GnuBuildId, *PGnuBuildId;

struct GnuBuildId {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
    byte hash[20];
};

typedef struct NoteGnuProperty_4 NoteGnuProperty_4, *PNoteGnuProperty_4;

struct NoteGnuProperty_4 {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
};

typedef struct Elf64_Ehdr Elf64_Ehdr, *PElf64_Ehdr;

struct Elf64_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_osabi;
    byte e_ident_abiversion;
    byte e_ident_pad[7];
    word e_type;
    word e_machine;
    dword e_version;
    qword e_entry;
    qword e_phoff;
    qword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};

typedef struct Elf64_Rela Elf64_Rela, *PElf64_Rela;

struct Elf64_Rela {
    qword r_offset; // location to apply the relocation action
    qword r_info; // the symbol table index and the type of relocation
    qword r_addend; // a constant addend used to compute the relocatable field value
};

typedef struct Elf64_Sym Elf64_Sym, *PElf64_Sym;

struct Elf64_Sym {
    dword st_name;
    byte st_info;
    byte st_other;
    word st_shndx;
    qword st_value;
    qword st_size;
};




int _init(EVP_PKEY_CTX *ctx)

{
  int iVar1;
  
  iVar1 = 0x250140;
  if (true) {
    iVar1 = __gmon_start__();
  }
  return iVar1;
}



void FUN_00108020(void)

{
  (*(code *)(undefined *)0x0)();
  return;
}



lyd_node * lyd_parse_mem(ly_ctx *ctx,char *data,LYD_FORMAT format,int options,...)

{
  lyd_node *plVar1;
  
  plVar1 = lyd_parse_mem(ctx,data,format,options);
  return plVar1;
}



void __cxa_finalize(void)

{
  __cxa_finalize();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * getenv(char *__name)

{
  char *pcVar1;
  
  pcVar1 = getenv(__name);
  return pcVar1;
}



char * lydict_insert_zc(ly_ctx *ctx,char *value)

{
  char *pcVar1;
  size_t len;
  
  ly_log_dbg(0x20,"%s","lydict_insert_zc");
  if (value == (char *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    pthread_mutex_lock((pthread_mutex_t *)&(ctx->dict).lock);
    len = strlen(value);
    pcVar1 = dict_insert(ctx,value,len,1);
    pthread_mutex_unlock((pthread_mutex_t *)&(ctx->dict).lock);
  }
  return pcVar1;
}



LY_VECODE ly_vecode(ly_ctx *ctx)

{
  LY_VECODE LVar1;
  ly_err_item *plVar2;
  
  ly_log_dbg(0x20,"%s","ly_vecode");
  plVar2 = ly_err_first(ctx);
  if (plVar2 == (ly_err_item *)0x0) {
    LVar1 = LYVE_SUCCESS;
  }
  else {
    LVar1 = plVar2->prev->vecode;
  }
  return LVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void free(void *__ptr)

{
  free(__ptr);
  return;
}



int lyd_schema_sort(lyd_node *sibling,int recursive)

{
  int iVar1;
  
  iVar1 = lyd_schema_sort(sibling,recursive);
  return iVar1;
}



lys_node * lys_getnext(lys_node *last,lys_node *parent,lys_module *module,int options)

{
  lys_node *plVar1;
  
  plVar1 = lys_getnext(last,parent,module,options);
  return plVar1;
}



lys_node * lys_is_disabled(lys_node *node,int recursive)

{
  lys_node *plVar1;
  
  plVar1 = lys_is_disabled(node,recursive);
  return plVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ly_err_print(ly_err_item *eitem)

{
  undefined *puVar1;
  
  if ((ly_log_opts & 1) != 0) {
    if (ly_log_clb == (_func_void_LY_LOG_LEVEL_char_ptr_char_ptr *)0x0) {
      if (eitem->path == (char *)0x0) {
        puVar1 = &DAT_0020d279;
      }
      else {
        puVar1 = &DAT_0020d277;
      }
      fprintf(_stderr,"libyang[%d]: %s%s",(ulong)eitem->level,eitem->msg,puVar1);
      if (eitem->path != (char *)0x0) {
        fprintf(_stderr,"(path: %s)\n",eitem->path);
      }
    }
    else {
      (*ly_log_clb)(eitem->level,eitem->msg,eitem->path);
    }
  }
  return;
}



lys_type * lyd_leaf_type(lyd_node_leaf_list *leaf)

{
  lys_type *plVar1;
  
  plVar1 = lyd_leaf_type(leaf);
  return plVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}



int ly_set_clean(ly_set *set)

{
  int iVar1;
  
  iVar1 = ly_set_clean(set);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strncpy(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncpy(__dest,__src,__n);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}



lyd_node * lyd_new_leaf(lyd_node *parent,lys_module *module,char *name,char *val_str)

{
  lyd_node *plVar1;
  
  plVar1 = lyd_new_leaf(parent,module,name,val_str);
  return plVar1;
}



// WARNING: Unknown calling convention

LY_ERR * ly_errno_glob_address(void)

{
  LY_ERR *pLVar1;
  
  ly_log_dbg(0x20,"%s","ly_errno_glob_address");
  pLVar1 = (LY_ERR *)__tls_get_addr(&PTR_0023dfe0);
  return pLVar1;
}



int ly_register_exts(lyext_plugin_list *plugin,char *log_name)

{
  int iVar1;
  
  iVar1 = ly_register_exts(plugin,log_name);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcpy(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ferror(FILE *__stream)

{
  int iVar1;
  
  iVar1 = ferror(__stream);
  return iVar1;
}



int lys_ext_instance_presence(lys_ext *def,lys_ext_instance **ext,uint8_t ext_size)

{
  int iVar1;
  
  iVar1 = lys_ext_instance_presence(def,ext,ext_size);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  qsort(__base,__nmemb,__size,__compar);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int isatty(int __fd)

{
  int iVar1;
  
  iVar1 = isatty(__fd);
  return iVar1;
}



int ly_set_rm_index(ly_set *set,uint index)

{
  int iVar1;
  
  iVar1 = ly_set_rm_index(set,index);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double atof(char *__nptr)

{
  double dVar1;
  
  dVar1 = atof(__nptr);
  return dVar1;
}



int lyd_insert_after(lyd_node *sibling,lyd_node *node)

{
  int iVar1;
  
  iVar1 = lyd_insert_after(sibling,node);
  return iVar1;
}



int lyd_lyb_data_length(char *data)

{
  int iVar1;
  
  iVar1 = lyd_lyb_data_length(data);
  return iVar1;
}



lys_module * ly_ctx_get_module(ly_ctx *ctx,char *name,char *revision,int implemented)

{
  lys_module *plVar1;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_module");
  plVar1 = ly_ctx_get_module_by(ctx,name,0,8,revision,0,implemented);
  return plVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t readlink(char *__path,char *__buf,size_t __len)

{
  ssize_t sVar1;
  
  sVar1 = readlink(__path,__buf,__len);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t write(int __fd,void *__buf,size_t __n)

{
  ssize_t sVar1;
  
  sVar1 = write(__fd,__buf,__n);
  return sVar1;
}



uint lyd_list_pos(lyd_node *node)

{
  uint uVar1;
  
  uVar1 = lyd_list_pos(node);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int vasprintf(char **__ptr,char *__f,__gnuc_va_list __arg)

{
  int iVar1;
  
  iVar1 = vasprintf(__ptr,__f,__arg);
  return iVar1;
}



ly_set * lyd_find_instance(lyd_node *data,lys_node *schema)

{
  ly_set *plVar1;
  
  plVar1 = lyd_find_instance(data,schema);
  return plVar1;
}



lyd_node * ly_ctx_info(ly_ctx *ctx)

{
  bool bVar1;
  int iVar2;
  lyd_node *plVar3;
  char *val_str;
  lys_revision *val_str_00;
  long in_FS_OFFSET;
  int iStack_50;
  char *pcStack_48;
  lyd_node *plStack_40;
  lyd_node *plStack_38;
  lyd_node *plStack_30;
  lyd_node *plStack_28;
  lys_module *plStack_20;
  char acStack_18 [8];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","ly_ctx_info");
  plStack_38 = (lyd_node *)0x0;
  plStack_30 = (lyd_node *)0x0;
  plStack_28 = (lyd_node *)0x0;
  if (ctx == (ly_ctx *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_info");
    plVar3 = (lyd_node *)0x0;
    goto LAB_00113439;
  }
  plStack_20 = ly_ctx_get_module(ctx,"ietf-yang-library",(char *)0x0,1);
  if ((plStack_20 == (lys_module *)0x0) || (plStack_20->data == (lys_node *)0x0)) {
    ly_log(ctx,LY_LLERR,LY_EINVAL,"ietf-yang-library is not implemented.");
    plVar3 = (lyd_node *)0x0;
    goto LAB_00113439;
  }
  if ((plStack_20->rev == (lys_revision *)0x0) ||
     (iVar2 = strcmp(plStack_20->rev->date,"2016-04-09"), iVar2 != 0)) {
    if ((plStack_20->rev == (lys_revision *)0x0) ||
       (iVar2 = strcmp(plStack_20->rev->date,"2019-01-04"), iVar2 != 0)) {
      ly_log(ctx,LY_LLERR,LY_EINVAL,"Incompatible ietf-yang-library version in context.");
      plVar3 = (lyd_node *)0x0;
      goto LAB_00113439;
    }
    bVar1 = true;
  }
  else {
    bVar1 = false;
  }
  plStack_40 = lyd_new((lyd_node *)0x0,plStack_20,"modules-state");
  if (plStack_40 == (lyd_node *)0x0) {
    plVar3 = (lyd_node *)0x0;
    goto LAB_00113439;
  }
  if ((!bVar1) ||
     (((plStack_38 = lyd_new((lyd_node *)0x0,plStack_20,"yang-library"),
       plStack_38 != (lyd_node *)0x0 &&
       (plStack_28 = lyd_new(plStack_38,(lys_module *)0x0,"module-set"),
       plStack_28 != (lyd_node *)0x0)) &&
      (plVar3 = lyd_new_leaf(plStack_28,(lys_module *)0x0,"name","complete"),
      plVar3 != (lyd_node *)0x0)))) {
    for (iStack_50 = 0; iStack_50 < (ctx->models).used; iStack_50 = iStack_50 + 1) {
      if (((ctx->models).list[iStack_50]->field_0x40 & 0x40) == 0) {
        plStack_30 = lyd_new(plStack_40,(lys_module *)0x0,"module");
        if ((plStack_30 == (lyd_node *)0x0) ||
           (plVar3 = lyd_new_leaf(plStack_30,(lys_module *)0x0,"name",
                                  (ctx->models).list[iStack_50]->name), plVar3 == (lyd_node *)0x0))
        goto LAB_0011341c;
        if ((ctx->models).list[iStack_50]->rev_size == '\0') {
          val_str_00 = (lys_revision *)&DAT_0020cb6a;
        }
        else {
          val_str_00 = (ctx->models).list[iStack_50]->rev;
        }
        plVar3 = lyd_new_leaf(plStack_30,(lys_module *)0x0,"revision",val_str_00->date);
        if (plVar3 == (lyd_node *)0x0) goto LAB_0011341c;
        if ((ctx->models).list[iStack_50]->filepath != (char *)0x0) {
          iVar2 = asprintf(&pcStack_48,"file://%s",(ctx->models).list[iStack_50]->filepath);
          if (iVar2 == -1) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_info");
            goto LAB_0011341c;
          }
          plVar3 = lyd_new_leaf(plStack_30,(lys_module *)0x0,"schema",pcStack_48);
          if (plVar3 == (lyd_node *)0x0) {
            free(pcStack_48);
            goto LAB_0011341c;
          }
          free(pcStack_48);
        }
        plVar3 = lyd_new_leaf(plStack_30,(lys_module *)0x0,"namespace",
                              (ctx->models).list[iStack_50]->ns);
        if (((plVar3 == (lyd_node *)0x0) ||
            (iVar2 = ylib_feature(plStack_30,(ctx->models).list[iStack_50]), iVar2 != 0)) ||
           (iVar2 = ylib_deviation(plStack_30,(ctx->models).list[iStack_50],0), iVar2 != 0))
        goto LAB_0011341c;
        if (((ctx->models).list[iStack_50]->field_0x40 & 0x80) == 0) {
          val_str = "import";
        }
        else {
          val_str = "implement";
        }
        plVar3 = lyd_new_leaf(plStack_30,(lys_module *)0x0,"conformance-type",val_str);
        if ((plVar3 == (lyd_node *)0x0) ||
           (iVar2 = ylib_submodules(plStack_30,(ctx->models).list[iStack_50],0), iVar2 != 0))
        goto LAB_0011341c;
        if (bVar1) {
          if (((ctx->models).list[iStack_50]->field_0x40 & 0x80) == 0) {
            plStack_30 = lyd_new(plStack_28,(lys_module *)0x0,"import-only-module");
          }
          else {
            plStack_30 = lyd_new(plStack_28,(lys_module *)0x0,"module");
          }
          if (((plStack_30 == (lyd_node *)0x0) ||
              (plVar3 = lyd_new_leaf(plStack_30,(lys_module *)0x0,"name",
                                     (ctx->models).list[iStack_50]->name), plVar3 == (lyd_node *)0x0
              )) || ((((((ctx->models).list[iStack_50]->field_0x40 & 0x80) == 0 ||
                       ((ctx->models).list[iStack_50]->rev_size != '\0')) &&
                      (plVar3 = lyd_new_leaf(plStack_30,(lys_module *)0x0,"revision",
                                             (ctx->models).list[iStack_50]->rev->date),
                      plVar3 == (lyd_node *)0x0)) ||
                     (plVar3 = lyd_new_leaf(plStack_30,(lys_module *)0x0,"namespace",
                                            (ctx->models).list[iStack_50]->ns),
                     plVar3 == (lyd_node *)0x0)))) goto LAB_0011341c;
          if ((ctx->models).list[iStack_50]->filepath != (char *)0x0) {
            iVar2 = asprintf(&pcStack_48,"file://%s",(ctx->models).list[iStack_50]->filepath);
            if (iVar2 == -1) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_info");
              goto LAB_0011341c;
            }
            plVar3 = lyd_new_leaf(plStack_30,(lys_module *)0x0,"location",pcStack_48);
            if (plVar3 == (lyd_node *)0x0) {
              free(pcStack_48);
              goto LAB_0011341c;
            }
            free(pcStack_48);
          }
          iVar2 = ylib_submodules(plStack_30,(ctx->models).list[iStack_50],1);
          if ((iVar2 != 0) ||
             ((((ctx->models).list[iStack_50]->field_0x40 & 0x80) != 0 &&
              ((iVar2 = ylib_feature(plStack_30,(ctx->models).list[iStack_50]), iVar2 != 0 ||
               (iVar2 = ylib_deviation(plStack_30,(ctx->models).list[iStack_50],1), iVar2 != 0))))))
          goto LAB_0011341c;
        }
      }
    }
    sprintf(acStack_18,"%u",(ulong)(ctx->models).module_set_id);
    plVar3 = lyd_new_leaf(plStack_40,(lys_module *)0x0,"module-set-id",acStack_18);
    if ((plVar3 != (lyd_node *)0x0) &&
       ((!bVar1 ||
        (plVar3 = lyd_new_leaf(plStack_38,(lys_module *)0x0,"content-id",acStack_18),
        plVar3 != (lyd_node *)0x0)))) {
      if (plStack_38 != (lyd_node *)0x0) {
        iVar2 = lyd_insert_sibling(&plStack_38,plStack_40);
        if (iVar2 != 0) goto LAB_0011341c;
        plStack_40 = plStack_38;
        plStack_38 = (lyd_node *)0x0;
      }
      iVar2 = lyd_validate(&plStack_40,0x1000,(void *)0x0);
      plVar3 = plStack_40;
      if (iVar2 == 0) goto LAB_00113439;
    }
  }
LAB_0011341c:
  lyd_free_withsiblings(plStack_40);
  lyd_free_withsiblings(plStack_38);
  plVar3 = (lyd_node *)0x0;
LAB_00113439:
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar3;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

DIR * opendir(char *__name)

{
  DIR *pDVar1;
  
  pDVar1 = opendir(__name);
  return pDVar1;
}



int lys_set_enabled(lys_module *module)

{
  ly_ctx *ctx;
  lys_module *node;
  lys_submodule *plVar1;
  int iVar2;
  ly_set *mods;
  ly_set *set;
  uint uStack_38;
  uint uStack_34;
  uint uStack_30;
  uint uStack_2c;
  
  ly_log_dbg(0x20,"%s","lys_set_enabled");
  if (module == (lys_module *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_set_enabled");
    iVar2 = 1;
  }
  else {
    if ((module->field_0x40 & 0x40) != 0) {
      ctx = module->ctx;
      for (uStack_38 = 0; (int)uStack_38 < (int)(uint)ctx->internal_module_count;
          uStack_38 = uStack_38 + 1) {
        if (module == (ctx->models).list[(int)uStack_38]) {
          ly_log(ctx,LY_LLERR,LY_EINVAL,"Internal module \"%s\" cannot be removed.",module->name);
          return 1;
        }
      }
      mods = ly_set_new();
      set = ly_set_new();
      lys_set_enabled_(mods,module);
      do {
        uStack_38 = (uint)ctx->internal_module_count;
LAB_00111b72:
        if ((ctx->models).used <= (int)uStack_38) {
          ctx_modules_redo_backlinks(mods);
          for (uStack_30 = 0; uStack_30 < mods->number; uStack_30 = uStack_30 + 1) {
            if ((*(byte *)&(mods->set).s[uStack_30]->parent & 0x80) != 0) {
              lys_sub_module_apply_devs_augs((lys_module *)(mods->set).s[uStack_30]);
            }
          }
          ly_set_free(mods);
          ly_set_free(set);
          (ctx->models).module_set_id = (ctx->models).module_set_id + 1;
          return 0;
        }
        node = (ctx->models).list[(int)uStack_38];
        if (((node->field_0x40 & 0x40) == 0) || (iVar2 = ly_set_contains(set,node), iVar2 != -1))
        goto LAB_00111b6e;
        uStack_34 = 0;
        while ((uStack_34 < node->imp_size &&
               (((node->imp[uStack_34].module)->field_0x40 & 0x40) == 0))) {
          uStack_34 = uStack_34 + 1;
        }
        if (uStack_34 < node->imp_size) goto LAB_00111b6e;
        uStack_34 = 0;
LAB_00111b3c:
        if (node->imp_size <= uStack_34) goto code_r0x00111b50;
        uStack_30 = 0;
        while( true ) {
          if (mods->number <= uStack_30) goto code_r0x00111b38;
          if (node->imp[uStack_34].module == (lys_module *)(mods->set).s[uStack_30]) break;
          uStack_30 = uStack_30 + 1;
        }
        node->field_0x40 = node->field_0x40 & 0xbf;
        ly_set_add(mods,node,0);
        for (uStack_2c = 0; uStack_2c < node->inc_size; uStack_2c = uStack_2c + 1) {
          plVar1 = node->inc[uStack_2c].submodule;
          plVar1->field_0x40 = plVar1->field_0x40 & 0xbf;
        }
      } while( true );
    }
    iVar2 = 0;
  }
  return iVar2;
code_r0x00111b50:
  ly_set_add(set,node,0);
LAB_00111b6e:
  uStack_38 = uStack_38 + 1;
  goto LAB_00111b72;
code_r0x00111b38:
  uStack_34 = uStack_34 + 1;
  goto LAB_00111b3c;
}



lys_module * lyd_node_module(lyd_node *node)

{
  lys_module *plVar1;
  
  plVar1 = lyd_node_module(node);
  return plVar1;
}



int lys_search_localfile
              (char **searchpaths,int cwd,char *name,char *revision,char **localfile,
              LYS_INFORMAT *format)

{
  int iVar1;
  
  iVar1 = lys_search_localfile(searchpaths,cwd,name,revision,localfile,format);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



lys_module * ly_ctx_get_module_by_ns(ly_ctx *ctx,char *ns,char *revision,int implemented)

{
  lys_module *plVar1;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_module_by_ns");
  plVar1 = ly_ctx_get_module_by(ctx,ns,0,0xb0,revision,0,implemented);
  return plVar1;
}



void * lys_ext_complex_get_substmt(LY_STMT stmt,lys_ext_instance_complex *ext,lyext_substmt **info)

{
  void *pvVar1;
  
  pvVar1 = lys_ext_complex_get_substmt(stmt,ext,info);
  return pvVar1;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * mmap(void *__addr,size_t __len,int __prot,int __flags,int __fd,__off_t __offset)

{
  void *pvVar1;
  
  pvVar1 = mmap(__addr,__len,__prot,__flags,__fd,__offset);
  return pvVar1;
}



int lyd_change_leaf(lyd_node_leaf_list *leaf,char *val_str)

{
  int iVar1;
  
  iVar1 = lyd_change_leaf(leaf,val_str);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strchr(__s,__c);
  return pcVar1;
}



int lys_features_enable(lys_module *module,char *feature)

{
  int iVar1;
  
  iVar1 = lys_features_enable(module,feature);
  return iVar1;
}



void ly_set_free(ly_set *set)

{
  ly_set_free(set);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_setspecific(pthread_key_t __key,void *__pointer)

{
  int iVar1;
  
  iVar1 = pthread_setspecific(__key,__pointer);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_mutex_destroy(pthread_mutex_t *__mutex)

{
  int iVar1;
  
  iVar1 = pthread_mutex_destroy(__mutex);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strrchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strrchr(__s,__c);
  return pcVar1;
}



int lys_set_implemented(lys_module *module)

{
  int iVar1;
  
  iVar1 = lys_set_implemented(module);
  return iVar1;
}



int ly_set_contains(ly_set *set,void *node)

{
  int iVar1;
  
  iVar1 = ly_set_contains(set,node);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __assert_fail(char *__assertion,char *__file,uint __line,char *__function)

{
                    // WARNING: Subroutine does not return
  __assert_fail(__assertion,__file,__line,__function);
}



void lyd_free_attr(ly_ctx *ctx,lyd_node *parent,lyd_attr *attr,int recursive)

{
  lyd_free_attr(ctx,parent,attr,recursive);
  return;
}



lyd_node * lyd_dup_to_ctx(lyd_node *node,int options,ly_ctx *ctx)

{
  lyd_node *plVar1;
  
  plVar1 = lyd_dup_to_ctx(node,options,ctx);
  return plVar1;
}



void pcre_exec(void)

{
  pcre_exec();
  return;
}



lyxml_elem * lyxml_parse_mem(ly_ctx *ctx,char *data,int options)

{
  lyxml_elem *plVar1;
  
  plVar1 = lyxml_parse_mem(ctx,data,options);
  return plVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memset(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memset(__s,__c,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention

int ly_clean_plugins(void)

{
  int iVar1;
  
  iVar1 = ly_clean_plugins();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int close(int __fd)

{
  int iVar1;
  
  iVar1 = close(__fd);
  return iVar1;
}



lys_node * lys_parent(lys_node *node)

{
  lys_node *plVar1;
  
  plVar1 = lys_parent(node);
  return plVar1;
}



int lyd_insert_before(lyd_node *sibling,lyd_node *node)

{
  int iVar1;
  
  iVar1 = lyd_insert_before(sibling,node);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int closedir(DIR *__dirp)

{
  int iVar1;
  
  iVar1 = closedir(__dirp);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strtok_r(char *__s,char *__delim,char **__save_ptr)

{
  char *pcVar1;
  
  pcVar1 = strtok_r(__s,__delim,__save_ptr);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strndup(char *__string,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strndup(__string,__n);
  return pcVar1;
}



ly_set * lyd_find_path(lyd_node *ctx_node,char *path)

{
  ly_set *plVar1;
  
  plVar1 = lyd_find_path(ctx_node,path);
  return plVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int memcmp(void *__s1,void *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = memcmp(__s1,__s2,__n);
  return iVar1;
}



lys_module * ly_ctx_get_module_iter(ly_ctx *ctx,uint32_t *idx)

{
  uint uVar1;
  lys_module **pplVar2;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_module_iter");
  if ((ctx == (ly_ctx *)0x0) || (idx == (uint32_t *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_get_module_iter");
  }
  else {
    while (*idx < (uint)(ctx->models).used) {
      if (((ctx->models).list[*idx]->field_0x40 & 0x40) == 0) {
        pplVar2 = (ctx->models).list;
        uVar1 = *idx;
        *idx = uVar1 + 1;
        return pplVar2[uVar1];
      }
      *idx = *idx + 1;
    }
  }
  return (lys_module *)0x0;
}



void __tls_get_addr(void)

{
  __tls_get_addr();
  return;
}



int lyd_merge_to_ctx(lyd_node **trg,lyd_node *src,int options,ly_ctx *ctx)

{
  int iVar1;
  
  iVar1 = lyd_merge_to_ctx(trg,src,options,ctx);
  return iVar1;
}



void lyxml_free_withsiblings(ly_ctx *ctx,lyxml_elem *elem)

{
  lyxml_free_withsiblings(ctx,elem);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ulonglong strtoull(char *__nptr,char **__endptr,int __base)

{
  ulonglong uVar1;
  
  uVar1 = strtoull(__nptr,__endptr,__base);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * calloc(size_t __nmemb,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = calloc(__nmemb,__size);
  return pvVar1;
}



int ly_ctx_set_searchdir(ly_ctx *ctx,char *search_dir)

{
  int iVar1;
  int *piVar2;
  char *pcVar3;
  char **ppcVar4;
  int iStack_20;
  int iStack_1c;
  char *pcStack_18;
  
  ly_log_dbg(0x20,"%s","ly_ctx_set_searchdir");
  iStack_1c = 1;
  if (ctx == (ly_ctx *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_set_searchdir");
    return 1;
  }
  if (search_dir == (char *)0x0) {
    return 0;
  }
  iVar1 = access(search_dir,5);
  if (iVar1 != 0) {
    piVar2 = __errno_location();
    pcVar3 = strerror(*piVar2);
    ly_log(ctx,LY_LLERR,LY_ESYS,"Unable to use search directory \"%s\" (%s)",search_dir,pcVar3);
    return 1;
  }
  pcStack_18 = realpath(search_dir,(char *)0x0);
  if (pcStack_18 == (char *)0x0) {
    piVar2 = __errno_location();
    pcVar3 = strerror(*piVar2);
    ly_log(ctx,LY_LLERR,LY_ESYS,"realpath() call failed (%s).",pcVar3);
  }
  else {
    if ((ctx->models).search_paths == (char **)0x0) {
      ppcVar4 = (char **)malloc(0x10);
      (ctx->models).search_paths = ppcVar4;
      if ((ctx->models).search_paths == (char **)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_set_searchdir");
        goto LAB_0010f0d0;
      }
      iStack_20 = 0;
    }
    else {
      for (iStack_20 = 0; (ctx->models).search_paths[iStack_20] != (char *)0x0;
          iStack_20 = iStack_20 + 1) {
        iVar1 = strcmp(pcStack_18,(ctx->models).search_paths[iStack_20]);
        if (iVar1 == 0) goto LAB_0010f0c0;
      }
      ppcVar4 = (char **)realloc((ctx->models).search_paths,(long)(iStack_20 + 2) * 8);
      if (ppcVar4 == (char **)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_set_searchdir");
        goto LAB_0010f0d0;
      }
      (ctx->models).search_paths = ppcVar4;
    }
    (ctx->models).search_paths[iStack_20] = pcStack_18;
    pcStack_18 = (char *)0x0;
    (ctx->models).search_paths[(long)iStack_20 + 1] = (char *)0x0;
LAB_0010f0c0:
    iStack_1c = 0;
  }
LAB_0010f0d0:
  free(pcStack_18);
  return iStack_1c;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

longlong strtoll(char *__nptr,char **__endptr,int __base)

{
  longlong lVar1;
  
  lVar1 = strtoll(__nptr,__endptr,__base);
  return lVar1;
}



int ly_register_types(lytype_plugin_list *plugin,char *log_name)

{
  int iVar1;
  
  iVar1 = ly_register_types(plugin,log_name);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fprintf(FILE *__stream,char *__format,...)

{
  int iVar1;
  
  iVar1 = fprintf(__stream,__format);
  return iVar1;
}



void lyd_free_withsiblings(lyd_node *node)

{
  lyd_free_withsiblings(node);
  return;
}



char * lys_path(lys_node *node,int options)

{
  char *pcVar1;
  
  pcVar1 = lys_path(node,options);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,__endptr,__base);
  return lVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void clearerr(FILE *__stream)

{
  clearerr(__stream);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * realpath(char *__name,char *__resolved)

{
  char *pcVar1;
  
  pcVar1 = realpath(__name,__resolved);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fileno(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fileno(__stream);
  return iVar1;
}



void ly_ctx_destroy(ly_ctx *ctx,_func_void_lys_node_ptr_void_ptr *private_destructor)

{
  int iStack_c;
  
  ly_log_dbg(0x20,"%s","ly_ctx_destroy");
  if (ctx != (ly_ctx *)0x0) {
    while (0 < (ctx->models).used) {
      lys_sub_module_remove_devs_augs((ctx->models).list[(long)(ctx->models).used + -1]);
      lys_free((ctx->models).list[(long)(ctx->models).used + -1],private_destructor,1,0);
      (ctx->models).used = (ctx->models).used + -1;
    }
    if ((ctx->models).search_paths != (char **)0x0) {
      for (iStack_c = 0; (ctx->models).search_paths[iStack_c] != (char *)0x0;
          iStack_c = iStack_c + 1) {
        free((ctx->models).search_paths[iStack_c]);
      }
      free((ctx->models).search_paths);
    }
    free((ctx->models).list);
    ly_err_clean(ctx,(ly_err_item *)0x0);
    pthread_key_delete(ctx->errlist_key);
    lydict_clean(&ctx->dict);
    ly_clean_plugins();
    free(ctx);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __xstat(int __ver,char *__filename,stat *__stat_buf)

{
  int iVar1;
  
  iVar1 = __xstat(__ver,__filename,__stat_buf);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

dirent * readdir(DIR *__dirp)

{
  dirent *pdVar1;
  
  pdVar1 = readdir(__dirp);
  return pdVar1;
}



ly_err_item * ly_err_first(ly_ctx *ctx)

{
  ly_err_item *plVar1;
  
  ly_log_dbg(0x20,"%s","ly_err_first");
  if (ctx == (ly_ctx *)0x0) {
    plVar1 = (ly_err_item *)0x0;
  }
  else {
    plVar1 = (ly_err_item *)pthread_getspecific(ctx->errlist_key);
  }
  return plVar1;
}



int lyd_validate_value(lys_node *node,char *value)

{
  int iVar1;
  
  iVar1 = lyd_validate_value(node,value);
  return iVar1;
}



void dlopen(void)

{
  dlopen();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int tolower(int __c)

{
  int iVar1;
  
  iVar1 = tolower(__c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * get_current_dir_name(void)

{
  char *pcVar1;
  
  pcVar1 = get_current_dir_name();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * pthread_getspecific(pthread_key_t __key)

{
  void *pvVar1;
  
  pvVar1 = pthread_getspecific(__key);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_mutex_unlock(pthread_mutex_t *__mutex)

{
  int iVar1;
  
  iVar1 = pthread_mutex_unlock(__mutex);
  return iVar1;
}



void pcre_compile(void)

{
  pcre_compile();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fflush(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fflush(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention

ly_set * ly_set_new(void)

{
  ly_set *plVar1;
  
  plVar1 = ly_set_new();
  return plVar1;
}



void ly_err_clean(ly_ctx *ctx,ly_err_item *eitem)

{
  ly_err_item *ptr;
  LY_ERR *pLVar1;
  ly_err_item *plStack_28;
  ly_err_item *plStack_18;
  
  ly_log_dbg(0x20,"%s","ly_err_clean");
  ptr = ly_err_first(ctx);
  plStack_28 = eitem;
  if (ptr == eitem) {
    plStack_28 = (ly_err_item *)0x0;
  }
  plStack_18 = ptr;
  if (plStack_28 == (ly_err_item *)0x0) {
    ly_err_free(ptr);
    pthread_setspecific(ctx->errlist_key,(void *)0x0);
    pLVar1 = ly_errno_glob_address();
    *pLVar1 = LY_SUCCESS;
  }
  else {
    for (; (plStack_18 != (ly_err_item *)0x0 && (plStack_28 != plStack_18->next));
        plStack_18 = plStack_18->next) {
    }
    if (plStack_18 == (ly_err_item *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("i",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/common.c"
                    ,0x91,"ly_err_clean");
    }
    plStack_18->next = (ly_err_item *)0x0;
    ptr->prev = plStack_18;
    ly_err_free(plStack_28);
    pLVar1 = ly_errno_glob_address();
    *pLVar1 = plStack_18->no;
  }
  return;
}



lyd_node * lyd_first_sibling(lyd_node *node)

{
  lyd_node *plVar1;
  
  plVar1 = lyd_first_sibling(node);
  return plVar1;
}



lys_module * lys_parse_mem(ly_ctx *ctx,char *data,LYS_INFORMAT format)

{
  lys_module *plVar1;
  
  plVar1 = lys_parse_mem(ctx,data,format);
  return plVar1;
}



ly_set * lys_find_path(lys_module *cur_module,lys_node *cur_node,char *path)

{
  ly_set *plVar1;
  
  plVar1 = lys_find_path(cur_module,cur_node,path);
  return plVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __fxstat(int __ver,int __fildes,stat *__stat_buf)

{
  int iVar1;
  
  iVar1 = __fxstat(__ver,__fildes,__stat_buf);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t mktime(tm *__tp)

{
  time_t tVar1;
  
  tVar1 = mktime(__tp);
  return tVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strpbrk(char *__s,char *__accept)

{
  char *pcVar1;
  
  pcVar1 = strpbrk(__s,__accept);
  return pcVar1;
}



int lyd_unlink(lyd_node *node)

{
  int iVar1;
  
  iVar1 = lyd_unlink(node);
  return iVar1;
}



lys_node_list * lys_is_key(lys_node_leaf *node,uint8_t *index)

{
  lys_node_list *plVar1;
  
  plVar1 = lys_is_key(node,index);
  return plVar1;
}



void dlclose(void)

{
  dlclose();
  return;
}



char * lyxml_get_attr(lyxml_elem *elem,char *name,char *ns)

{
  char *pcVar1;
  
  pcVar1 = lyxml_get_attr(elem,name,ns);
  return pcVar1;
}



lyd_node * lyd_dup(lyd_node *node,int options)

{
  lyd_node *plVar1;
  
  plVar1 = lyd_dup(node,options);
  return plVar1;
}



lyxml_ns * lyxml_get_ns(lyxml_elem *elem,char *prefix)

{
  lyxml_ns *plVar1;
  
  plVar1 = lyxml_get_ns(elem,prefix);
  return plVar1;
}



void lyxml_free(ly_ctx *ctx,lyxml_elem *elem)

{
  lyxml_free(ctx,elem);
  return;
}



int lyd_validate(lyd_node **node,int options,void *var_arg,...)

{
  int iVar1;
  
  iVar1 = lyd_validate(node,options,var_arg);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * realloc(void *__ptr,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = realloc(__ptr,__size);
  return pvVar1;
}



lys_node * ly_ctx_get_node(ly_ctx *ctx,lys_node *start,char *nodeid,int output)

{
  lys_node *plVar1;
  ly_ctx *plStack_20;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_node");
  if ((((ctx == (ly_ctx *)0x0) && (start == (lys_node *)0x0)) || (nodeid == (char *)0x0)) ||
     ((*nodeid != '/' && (start == (lys_node *)0x0)))) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_get_node");
    plVar1 = (lys_node *)0x0;
  }
  else {
    plStack_20 = ctx;
    if (ctx == (ly_ctx *)0x0) {
      plStack_20 = start->module->ctx;
    }
    plVar1 = resolve_json_nodeid(nodeid,plStack_20,start,output);
  }
  return plVar1;
}



void pcre_free_study(void)

{
  pcre_free_study();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int asprintf(char **__ptr,char *__fmt,...)

{
  int iVar1;
  
  iVar1 = asprintf(__ptr,__fmt);
  return iVar1;
}



int ly_set_add(ly_set *set,void *node,int options)

{
  int iVar1;
  
  iVar1 = ly_set_add(set,node,options);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int munmap(void *__addr,size_t __len)

{
  int iVar1;
  
  iVar1 = munmap(__addr,__len);
  return iVar1;
}



char * lyd_path(lyd_node *node)

{
  char *pcVar1;
  
  pcVar1 = lyd_path(node);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_key_create(pthread_key_t *__key,__destr_function *__destr_function)

{
  int iVar1;
  
  iVar1 = pthread_key_create(__key,__destr_function);
  return iVar1;
}



lyd_node * lyd_parse_xml(ly_ctx *ctx,lyxml_elem **root,int options,...)

{
  lyd_node *plVar1;
  
  plVar1 = lyd_parse_xml(ctx,root,options);
  return plVar1;
}



lys_module * lys_main_module(lys_module *module)

{
  lys_module *plVar1;
  
  plVar1 = lys_main_module(module);
  return plVar1;
}



int lyd_print_mem(char **strp,lyd_node *root,LYD_FORMAT format,int options)

{
  int iVar1;
  
  iVar1 = lyd_print_mem(strp,root,format,options);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memmove(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memmove(__dest,__src,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double strtold(char *__nptr,char **__endptr)

{
  double dVar1;
  
  dVar1 = strtold(__nptr,__endptr);
  return dVar1;
}



int lyxml_print_mem(char **strp,lyxml_elem *elem,int options)

{
  int iVar1;
  
  iVar1 = lyxml_print_mem(strp,elem,options);
  return iVar1;
}



char ** ly_ctx_get_searchdirs(ly_ctx *ctx)

{
  char **ppcVar1;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_searchdirs");
  if (ctx == (ly_ctx *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_get_searchdirs");
    ppcVar1 = (char **)0x0;
  }
  else {
    ppcVar1 = (ctx->models).search_paths;
  }
  return ppcVar1;
}



void lys_iffeature_free(ly_ctx *ctx,lys_iffeature *iffeature,uint8_t iffeature_size,int shallow,
                       _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  lys_iffeature_free(ctx,iffeature,iffeature_size,shallow,private_destructor);
  return;
}



int lyd_wd_default(lyd_node_leaf_list *node)

{
  int iVar1;
  
  iVar1 = lyd_wd_default(node);
  return iVar1;
}



int lyd_insert_sibling(lyd_node **sibling,lyd_node *node)

{
  int iVar1;
  
  iVar1 = lyd_insert_sibling(sibling,node);
  return iVar1;
}



int lyd_insert(lyd_node *parent,lyd_node *node)

{
  int iVar1;
  
  iVar1 = lyd_insert(parent,node);
  return iVar1;
}



int lyd_print_file(FILE *f,lyd_node *root,LYD_FORMAT format,int options)

{
  int iVar1;
  
  iVar1 = lyd_print_file(f,root,format,options);
  return iVar1;
}



char * lydict_insert(ly_ctx *ctx,char *value,size_t len)

{
  char *pcVar1;
  size_t sStack_30;
  
  ly_log_dbg(0x20,"%s","lydict_insert");
  if (value == (char *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    sStack_30 = len;
    if (len == 0) {
      sStack_30 = strlen(value);
    }
    pthread_mutex_lock((pthread_mutex_t *)&(ctx->dict).lock);
    pcVar1 = dict_insert(ctx,value,sStack_30,0);
    pthread_mutex_unlock((pthread_mutex_t *)&(ctx->dict).lock);
  }
  return pcVar1;
}



void pcre_study(void)

{
  pcre_study();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int open(char *__file,int __oflag,...)

{
  int iVar1;
  
  iVar1 = open(__file,__oflag);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int vdprintf(int __fd,char *__fmt,__gnuc_va_list __arg)

{
  int iVar1;
  
  iVar1 = vdprintf(__fd,__fmt,__arg);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int access(char *__name,int __type)

{
  int iVar1;
  
  iVar1 = access(__name,__type);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * fopen(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen(__filename,__modes);
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long sysconf(int __name)

{
  long lVar1;
  
  lVar1 = sysconf(__name);
  return lVar1;
}



char * ly_errpath(ly_ctx *ctx)

{
  ly_err_item *plVar1;
  char *pcVar2;
  
  ly_log_dbg(0x20,"%s","ly_errpath");
  plVar1 = ly_err_first(ctx);
  if (plVar1 == (ly_err_item *)0x0) {
    pcVar2 = (char *)0x0;
  }
  else {
    pcVar2 = plVar1->prev->path;
  }
  return pcVar2;
}



int lys_print_file(FILE *f,lys_module *module,LYS_OUTFORMAT format,char *target_node,int line_length
                  ,int options)

{
  int iVar1;
  
  iVar1 = lys_print_file(f,module,format,target_node,line_length,options);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)

{
  int iVar1;
  
  iVar1 = vfprintf(__s,__format,__arg);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ulong strtoul(char *__nptr,char **__endptr,int __base)

{
  ulong uVar1;
  
  uVar1 = strtoul(__nptr,__endptr,__base);
  return uVar1;
}



lys_submodule * ly_ctx_get_submodule2(lys_module *main_module,char *submodule)

{
  lys_submodule *plVar1;
  int iVar2;
  int iStack_14;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_submodule2");
  if ((main_module == (lys_module *)0x0) || (submodule == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_get_submodule2");
  }
  else {
    for (iStack_14 = 0; iStack_14 < (int)(uint)main_module->inc_size; iStack_14 = iStack_14 + 1) {
      plVar1 = main_module->inc[iStack_14].submodule;
      iVar2 = ly_strequal_(submodule,plVar1->name);
      if (iVar2 != 0) {
        return plVar1;
      }
    }
  }
  return (lys_submodule *)0x0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int atoi(char *__nptr)

{
  int iVar1;
  
  iVar1 = atoi(__nptr);
  return iVar1;
}



lyd_node * lyd_new(lyd_node *parent,lys_module *module,char *name)

{
  lyd_node *plVar1;
  
  plVar1 = lyd_new(parent,module,name);
  return plVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_key_delete(pthread_key_t __key)

{
  int iVar1;
  
  iVar1 = pthread_key_delete(__key);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sprintf(char *__s,char *__format,...)

{
  int iVar1;
  
  iVar1 = sprintf(__s,__format);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void exit(int __status)

{
                    // WARNING: Subroutine does not return
  exit(__status);
}



uint ly_ctx_internal_modules_count(ly_ctx *ctx)

{
  uint uVar1;
  
  ly_log_dbg(0x20,"%s","ly_ctx_internal_modules_count");
  if (ctx == (ly_ctx *)0x0) {
    uVar1 = 0;
  }
  else {
    uVar1 = (uint)ctx->internal_module_count;
  }
  return uVar1;
}



void lyd_free_diff(lyd_difflist *diff)

{
  lyd_free_diff(diff);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}



int lyd_merge(lyd_node *target,lyd_node *source,int options)

{
  int iVar1;
  
  iVar1 = lyd_merge(target,source,options);
  return iVar1;
}



lys_module * lys_parse_fd(ly_ctx *ctx,int fd,LYS_INFORMAT format)

{
  lys_module *plVar1;
  
  plVar1 = lys_parse_fd(ctx,fd,format);
  return plVar1;
}



void lyxml_unlink(ly_ctx *ctx,lyxml_elem *elem)

{
  lyxml_unlink(ctx,elem);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strdup(char *__s)

{
  char *pcVar1;
  
  pcVar1 = strdup(__s);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strerror(int __errnum)

{
  char *pcVar1;
  
  pcVar1 = strerror(__errnum);
  return pcVar1;
}



void dlsym(void)

{
  dlsym();
  return;
}



lys_module * lys_node_module(lys_node *node)

{
  lys_module *plVar1;
  
  plVar1 = lys_node_module(node);
  return plVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strptime(char *__s,char *__fmt,tm *__tp)

{
  char *pcVar1;
  
  pcVar1 = strptime(__s,__fmt,__tp);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_mutex_init(pthread_mutex_t *__mutex,pthread_mutexattr_t *__mutexattr)

{
  int iVar1;
  
  iVar1 = pthread_mutex_init(__mutex,__mutexattr);
  return iVar1;
}



void lyd_free(lyd_node *node)

{
  lyd_free(node);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getc(FILE *__stream)

{
  int iVar1;
  
  iVar1 = getc(__stream);
  return iVar1;
}



lys_module * ly_ctx_load_module(ly_ctx *ctx,char *name,char *revision)

{
  lys_module *plVar1;
  
  ly_log_dbg(0x20,"%s","ly_ctx_load_module");
  if ((ctx == (ly_ctx *)0x0) || (name == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_load_module");
    plVar1 = (lys_module *)0x0;
  }
  else {
    if ((revision == (char *)0x0) || (*revision == '\0')) {
      revision = (char *)0x0;
    }
    plVar1 = ly_ctx_load_sub_module(ctx,(lys_module *)0x0,name,revision,1,(unres_schema *)0x0);
  }
  return plVar1;
}



void lydict_remove(ly_ctx *ctx,char *value)

{
  uint32_t hash;
  int iVar1;
  long in_FS_OFFSET;
  size_t sStack_38;
  undefined8 *puStack_30;
  void *pvStack_28;
  char *pcStack_1c;
  undefined4 uStack_14;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lydict_remove");
  puStack_30 = (undefined8 *)0x0;
  if ((value != (char *)0x0) && (ctx != (ly_ctx *)0x0)) {
    sStack_38 = strlen(value);
    hash = dict_hash(value,sStack_38);
    uStack_14 = 0;
    pcStack_1c = value;
    pthread_mutex_lock((pthread_mutex_t *)&(ctx->dict).lock);
    lyht_set_cb_data((ctx->dict).hash_tab,&sStack_38);
    iVar1 = lyht_find((ctx->dict).hash_tab,&pcStack_1c,hash,&puStack_30);
    if (iVar1 == 0) {
      if (puStack_30 == (undefined8 *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
               ,0xad);
      }
      else {
        *(int *)(puStack_30 + 1) = *(int *)(puStack_30 + 1) + -1;
        if (*(int *)(puStack_30 + 1) == 0) {
          pvStack_28 = (void *)*puStack_30;
          iVar1 = lyht_remove((ctx->dict).hash_tab,&pcStack_1c,hash);
          free(pvStack_28);
          if (iVar1 != 0) {
            ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                   ,0xba);
          }
        }
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)&(ctx->dict).lock);
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strstr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strstr(__haystack,__needle);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_mutex_lock(pthread_mutex_t *__mutex)

{
  int iVar1;
  
  iVar1 = pthread_mutex_lock(__mutex);
  return iVar1;
}



ly_ctx * ly_ctx_new(char *search_dir,int options)

{
  int iVar1;
  ly_ctx *ctx;
  lys_module **pplVar2;
  char *__ptr;
  char *pcVar3;
  lys_module *plVar4;
  int iStack_38;
  int iStack_34;
  char *pcStack_30;
  
  ly_log_dbg(0x20,"%s","ly_ctx_new");
  iStack_38 = 0;
  ctx = (ly_ctx *)calloc(1,0x88);
  if (ctx == (ly_ctx *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_new");
    return (ly_ctx *)0x0;
  }
  lydict_init((dict_table *)ctx);
  ly_load_plugins();
  iVar1 = pthread_key_create(&ctx->errlist_key,ly_err_free);
  if (iVar1 != 0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_ESYS,"pthread_key_create() in ly_ctx_new() failed");
    goto LAB_0010e4d2;
  }
  pplVar2 = (lys_module **)calloc(0x10,8);
  (ctx->models).list = pplVar2;
  if ((ctx->models).list == (lys_module **)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_new");
    free(ctx);
    return (ly_ctx *)0x0;
  }
  (ctx->models).flags = options;
  (ctx->models).used = 0;
  (ctx->models).size = 0x10;
  if (search_dir != (char *)0x0) {
    __ptr = strdup(search_dir);
    pcStack_30 = __ptr;
    if (__ptr == (char *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_new");
      goto LAB_0010e4d2;
    }
    while ((pcVar3 = strchr(pcStack_30,0x3a), pcVar3 != (char *)0x0 && (iStack_38 == 0))) {
      *pcVar3 = '\0';
      iStack_38 = ly_ctx_set_searchdir(ctx,pcStack_30);
      pcStack_30 = pcVar3 + 1;
    }
    if ((*pcStack_30 != '\0') && (iStack_38 == 0)) {
      iStack_38 = ly_ctx_set_searchdir(ctx,pcStack_30);
    }
    free(__ptr);
    if (iStack_38 != 0) goto LAB_0010e4d2;
  }
  (ctx->models).module_set_id = 1;
  if ((options & 4U) == 0) {
    ctx->internal_module_count = '\x06';
  }
  else {
    ctx->internal_module_count = '\x04';
  }
  iStack_34 = 0;
  while( true ) {
    if ((int)(uint)ctx->internal_module_count <= iStack_34) {
      return ctx;
    }
    plVar4 = lys_parse_mem(ctx,internal_modules[iStack_34].data,internal_modules[iStack_34].format);
    if (plVar4 == (lys_module *)0x0) break;
    plVar4->field_0x40 =
         plVar4->field_0x40 & 0x7f | (byte)((internal_modules[iStack_34].implemented & 1) << 7);
    iStack_34 = iStack_34 + 1;
  }
LAB_0010e4d2:
  ly_ctx_destroy(ctx,(_func_void_lys_node_ptr_void_ptr *)0x0);
  return (ly_ctx *)0x0;
}



void dlerror(void)

{
  dlerror();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ushort ** __ctype_b_loc(void)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  return ppuVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ly_load_plugins(void)

{
  ly_load_plugins();
  return;
}



undefined8 FUN_00109620(lys_module *param_1)

{
  ly_ctx *ctx;
  lys_module *node;
  lys_node *plVar1;
  long lVar2;
  bool bVar3;
  undefined8 uVar4;
  ly_set *set;
  byte bStack_32;
  uint uStack_30;
  uint uStack_2c;
  uint uStack_28;
  uint uStack_24;
  
  ly_log_dbg(0x20,"%s","lys_set_disabled");
  if (param_1 == (lys_module *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_set_disabled");
    uVar4 = 1;
  }
  else {
    if ((param_1->field_0x40 & 0x40) == 0) {
      ctx = param_1->ctx;
      for (uStack_30 = 0; (int)uStack_30 < (int)(uint)ctx->internal_module_count;
          uStack_30 = uStack_30 + 1) {
        if (param_1 == (ctx->models).list[(int)uStack_30]) {
          ly_log(ctx,LY_LLERR,LY_EINVAL,"Internal module \"%s\" cannot be disabled.",param_1->name);
          return 1;
        }
      }
      param_1->field_0x40 = param_1->field_0x40 | 0x40;
      set = ly_set_new();
      ly_set_add(set,param_1,0);
LAB_00111440:
      uStack_30 = (uint)ctx->internal_module_count;
      do {
        if ((ctx->models).used <= (int)uStack_30) {
          for (uStack_28 = 0; uStack_28 < set->number; uStack_28 = uStack_28 + 1) {
            *(byte *)&(set->set).s[uStack_28]->parent =
                 *(byte *)&(set->set).s[uStack_28]->parent & 0xbf;
          }
          ctx_modules_undo_backlinks(ctx,set);
          uStack_28 = set->number;
          while (uStack_28 != 0) {
            lys_sub_module_remove_devs_augs((lys_module *)(set->set).s[uStack_28 - 1]);
            uStack_28 = uStack_28 - 1;
          }
          for (uStack_28 = 0; uStack_28 < set->number; uStack_28 = uStack_28 + 1) {
            plVar1 = (set->set).s[uStack_28];
            *(byte *)&plVar1->parent = *(byte *)&plVar1->parent | 0x40;
            for (uStack_24 = 0; uStack_24 < *(byte *)((long)&plVar1->parent + 6);
                uStack_24 = uStack_24 + 1) {
              lVar2 = *(long *)((ulong)uStack_24 * 0x30 + *(long *)plVar1->hash);
              *(byte *)(lVar2 + 0x40) = *(byte *)(lVar2 + 0x40) | 0x40;
            }
          }
          ly_set_free(set);
          (ctx->models).module_set_id = (ctx->models).module_set_id + 1;
          return 0;
        }
        node = (ctx->models).list[(int)uStack_30];
        if ((node->field_0x40 & 0x40) == 0) {
          for (bStack_32 = 0; bStack_32 < node->imp_size; bStack_32 = bStack_32 + 1) {
            for (uStack_28 = 0; uStack_28 < set->number; uStack_28 = uStack_28 + 1) {
              if (node->imp[bStack_32].module == (lys_module *)(set->set).s[uStack_28]) {
                node->field_0x40 = node->field_0x40 | 0x40;
                ly_set_add(set,node,0);
                goto LAB_00111440;
              }
            }
          }
          if ((node->field_0x40 & 0x80) == 0) {
            bVar3 = false;
            for (uStack_2c = (uint)ctx->internal_module_count; (int)uStack_2c < (ctx->models).used;
                uStack_2c = uStack_2c + 1) {
              if (((ctx->models).list[(int)uStack_2c]->field_0x40 & 0x40) == 0) {
                for (bStack_32 = 0; bStack_32 < (ctx->models).list[(int)uStack_2c]->imp_size;
                    bStack_32 = bStack_32 + 1) {
                  if (node == (ctx->models).list[(int)uStack_2c]->imp[bStack_32].module) {
                    bVar3 = true;
                    goto LAB_00111600;
                  }
                }
              }
            }
LAB_00111600:
            if (!bVar3) {
              node->field_0x40 = node->field_0x40 | 0x40;
              ly_set_add(set,node,0);
              if (node->imp_size != '\0') goto LAB_00111440;
            }
          }
        }
        uStack_30 = uStack_30 + 1;
      } while( true );
    }
    uVar4 = 0;
  }
  return uVar4;
}



void processEntry deregister_tm_clones(void)

{
  if ((false) && (true)) {
    _ITM_deregisterTMCloneTable();
    return;
  }
  return;
}



void register_tm_clones(void)

{
  if ((false) && (true)) {
    _ITM_registerTMCloneTable();
    return;
  }
  return;
}



void __do_global_dtors_aux(undefined8 param_1,undefined8 param_2,undefined8 param_3)

{
  undefined8 extraout_RDX;
  
  if (completed_8061 == '\0') {
    if (true) {
      __cxa_finalize(__dso_handle);
      param_3 = extraout_RDX;
    }
    deregister_tm_clones(param_3,0x1096cc);
    completed_8061 = 1;
    return;
  }
  return;
}



void frame_dummy(void)

{
  register_tm_clones();
  return;
}



// WARNING: Unknown calling convention

LY_ERR * ly_errno_glob_address(void)

{
  LY_ERR *pLVar1;
  
  ly_log_dbg(0x20,"%s","ly_errno_glob_address");
  pLVar1 = (LY_ERR *)__tls_get_addr(&PTR_0023dfe0);
  return pLVar1;
}



LY_VECODE ly_vecode(ly_ctx *ctx)

{
  LY_VECODE LVar1;
  ly_err_item *plVar2;
  ly_ctx *ctx_local;
  ly_err_item *i;
  
  ly_log_dbg(0x20,"%s","ly_vecode");
  plVar2 = ly_err_first(ctx);
  if (plVar2 == (ly_err_item *)0x0) {
    LVar1 = LYVE_SUCCESS;
  }
  else {
    LVar1 = plVar2->prev->vecode;
  }
  return LVar1;
}



char * ly_errmsg(ly_ctx *ctx)

{
  ly_err_item *plVar1;
  char *pcVar2;
  ly_ctx *ctx_local;
  ly_err_item *i;
  
  ly_log_dbg(0x20,"%s","ly_errmsg");
  plVar1 = ly_err_first(ctx);
  if (plVar1 == (ly_err_item *)0x0) {
    pcVar2 = (char *)0x0;
  }
  else {
    pcVar2 = plVar1->prev->msg;
  }
  return pcVar2;
}



char * ly_errpath(ly_ctx *ctx)

{
  ly_err_item *plVar1;
  char *pcVar2;
  ly_ctx *ctx_local;
  ly_err_item *i;
  
  ly_log_dbg(0x20,"%s","ly_errpath");
  plVar1 = ly_err_first(ctx);
  if (plVar1 == (ly_err_item *)0x0) {
    pcVar2 = (char *)0x0;
  }
  else {
    pcVar2 = plVar1->prev->path;
  }
  return pcVar2;
}



char * ly_errapptag(ly_ctx *ctx)

{
  ly_err_item *plVar1;
  char *pcVar2;
  ly_ctx *ctx_local;
  ly_err_item *i;
  
  ly_log_dbg(0x20,"%s","ly_errapptag");
  plVar1 = ly_err_first(ctx);
  if (plVar1 == (ly_err_item *)0x0) {
    pcVar2 = (char *)0x0;
  }
  else {
    pcVar2 = plVar1->prev->apptag;
  }
  return pcVar2;
}



ly_err_item * ly_err_first(ly_ctx *ctx)

{
  ly_err_item *plVar1;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_err_first");
  if (ctx == (ly_ctx *)0x0) {
    plVar1 = (ly_err_item *)0x0;
  }
  else {
    plVar1 = (ly_err_item *)pthread_getspecific(ctx->errlist_key);
  }
  return plVar1;
}



void ly_err_free(void *ptr)

{
  ly_err_item *plVar1;
  void *ptr_local;
  ly_err_item *i;
  ly_err_item *next;
  
  i = (ly_err_item *)ptr;
  while (i != (ly_err_item *)0x0) {
    plVar1 = i->next;
    free(i->msg);
    free(i->path);
    free(i->apptag);
    free(i);
    i = plVar1;
  }
  return;
}



void ly_err_clean(ly_ctx *ctx,ly_err_item *eitem)

{
  ly_err_item *ptr;
  LY_ERR *pLVar1;
  ly_err_item *eitem_local;
  ly_ctx *ctx_local;
  ly_err_item *i;
  ly_err_item *first;
  
  ly_log_dbg(0x20,"%s","ly_err_clean");
  ptr = ly_err_first(ctx);
  eitem_local = eitem;
  if (ptr == eitem) {
    eitem_local = (ly_err_item *)0x0;
  }
  i = ptr;
  if (eitem_local == (ly_err_item *)0x0) {
    ly_err_free(ptr);
    pthread_setspecific(ctx->errlist_key,(void *)0x0);
    pLVar1 = ly_errno_glob_address();
    *pLVar1 = LY_SUCCESS;
  }
  else {
    for (; (i != (ly_err_item *)0x0 && (eitem_local != i->next)); i = i->next) {
    }
    if (i == (ly_err_item *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("i",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/common.c"
                    ,0x91,"ly_err_clean");
    }
    i->next = (ly_err_item *)0x0;
    ptr->prev = i;
    ly_err_free(eitem_local);
    pLVar1 = ly_errno_glob_address();
    *pLVar1 = i->no;
  }
  return;
}



char * strpbrk_backwards(char *s,char *accept,uint s_len)

{
  uint s_len_local;
  char *accept_local;
  char *s_local;
  char *sc;
  
  s_local = s;
  for (s_len_local = s_len; (*s_local != '\0' && (sc = accept, s_len_local != 0));
      s_len_local = s_len_local - 1) {
    for (; *sc != '\0'; sc = sc + 1) {
      if (*s_local == *sc) {
        return s_local;
      }
    }
    s_local = s_local + -1;
  }
  return s_local;
}



char * strnchr(char *s,int c,uint len)

{
  uint len_local;
  int c_local;
  char *s_local;
  
  len_local = len;
  s_local = s;
  while( true ) {
    if (*s_local == (char)c) {
      return s_local;
    }
    if ((*s_local == '\0') || (len_local == 0)) break;
    s_local = s_local + 1;
    len_local = len_local - 1;
  }
  return (char *)0x0;
}



char * strnodetype(LYS_NODE type)

{
  LYS_NODE type_local;
  
  if (type == LYS_EXT) {
    return "extension instance";
  }
  if (type < (LYS_CONTAINER|LYS_EXT)) {
    if (type == LYS_ANYDATA) {
      return "anydata";
    }
    if (type < (LYS_CONTAINER|LYS_ANYDATA)) {
      if (type == LYS_ACTION) {
        return "action";
      }
      if (type < (LYS_CONTAINER|LYS_ACTION)) {
        if (type == LYS_AUGMENT) {
          return "augment";
        }
        if (type < (LYS_CONTAINER|LYS_AUGMENT)) {
          if (type == LYS_USES) {
            return "uses";
          }
          if (type < (LYS_CONTAINER|LYS_USES)) {
            if (type == LYS_GROUPING) {
              return "grouping";
            }
            if (type < (LYS_CONTAINER|LYS_GROUPING)) {
              if (type == LYS_OUTPUT) {
                return "output";
              }
              if (type < (LYS_CONTAINER|LYS_OUTPUT)) {
                if (type == LYS_INPUT) {
                  return "input";
                }
                if (type < (LYS_CONTAINER|LYS_INPUT)) {
                  if (type == LYS_RPC) {
                    return "rpc";
                  }
                  if (type < (LYS_CONTAINER|LYS_RPC)) {
                    if (type == LYS_NOTIF) {
                      return "notification";
                    }
                    if (type < (LYS_CONTAINER|LYS_NOTIF)) {
                      if (type < (LYS_CONTAINER|LYS_ANYXML)) {
                        if (true) {
                          switch(type) {
                          case LYS_UNKNOWN:
                            return (char *)0x0;
                          case LYS_CONTAINER:
                            return "container";
                          case LYS_CHOICE:
                            return "choice";
                          case LYS_LEAF:
                            return "leaf";
                          case LYS_LEAFLIST:
                            return "leaf-list";
                          case LYS_LIST:
                            return "list";
                          case LYS_ANYXML:
                            return "anyxml";
                          }
                        }
                      }
                      else if (type == LYS_CASE) {
                        return "case";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (char *)0x0;
}



char * transform_module_name2import_prefix(lys_module *module,char *module_name)

{
  int iVar1;
  char *pcVar2;
  lys_module *plVar3;
  char *module_name_local;
  lys_module *module_local;
  uint16_t i;
  
  if (module_name == (char *)0x0) {
    pcVar2 = (char *)0x0;
  }
  else {
    plVar3 = lys_main_module(module);
    iVar1 = strcmp(plVar3->name,module_name);
    if (iVar1 == 0) {
      pcVar2 = module->prefix;
    }
    else {
      for (i = 0; i < module->imp_size; i = i + 1) {
        iVar1 = strcmp((module->imp[i].module)->name,module_name);
        if (iVar1 == 0) {
          return module->imp[i].prefix;
        }
      }
      pcVar2 = (char *)0x0;
    }
  }
  return pcVar2;
}



int _transform_json2xml_subexp
              (lys_module *module,char *expr,char **out,size_t *out_used,size_t *out_size,int schema
              ,int inst_id,char ***prefixes,char ***namespaces,uint32_t *ns_count)

{
  size_t sVar1;
  int iVar2;
  char **ppcVar3;
  size_t sVar4;
  char *pcVar5;
  long in_FS_OFFSET;
  uint32_t *ns_count_local;
  char ***namespaces_local;
  char ***prefixes_local;
  int schema_local;
  size_t *out_size_local;
  size_t *out_used_local;
  char **out_local;
  char *expr_local;
  lys_module *module_local;
  int_log_opts prev_ilo;
  uint32_t i;
  uint32_t j;
  char *end;
  char *prefix;
  size_t name_len;
  lys_module *mod;
  lys_module *prev_mod;
  ly_ctx *ctx;
  lyxp_expr *exp;
  char *cur_expr;
  char *name;
  char *literal;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  mod = (lys_module *)0x0;
  prev_mod = (lys_module *)0x0;
  ctx = module->ctx;
  if (((module == (lys_module *)0x0) || (expr == (char *)0x0)) ||
     (((prefixes != (char ***)0x0 ||
       ((namespaces != (char ***)0x0 || (ns_count != (uint32_t *)0x0)))) &&
      ((prefixes == (char ***)0x0 ||
       ((namespaces == (char ***)0x0 || (ns_count == (uint32_t *)0x0)))))))) {
                    // WARNING: Subroutine does not return
    __assert_fail("module && expr && ((!prefixes && !namespaces && !ns_count) || (prefixes && namespaces && ns_count))"
                  ,
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/common.c"
                  ,0x11e,"_transform_json2xml_subexp");
  }
  exp = lyxp_parse_expr(ctx,expr);
  if (exp == (lyxp_expr *)0x0) {
    iVar2 = 1;
  }
  else {
    for (i = 0; i < exp->used; i = i + 1) {
      cur_expr = exp->expr + exp->expr_pos[i];
      if ((i != 0) &&
         (end = exp->expr + (ulong)exp->tok_len[i - 1] + (ulong)exp->expr_pos[i - 1],
         end != cur_expr)) {
        strncpy(*out + *out_used,end,(long)cur_expr - (long)end);
        *out_used = (size_t)(cur_expr + (*out_used - (long)end));
      }
      if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) &&
         ((end = strnchr(cur_expr,0x3a,(uint)exp->tok_len[i]), end != (char *)0x0 || (inst_id != 0))
         )) {
        if (schema == 0) {
          if (end == (char *)0x0) {
            mod = prev_mod;
            if (prev_mod != (lys_module *)0x0) {
              name_len = 0;
              end = cur_expr;
              goto LAB_0010a1f4;
            }
            ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/common.c"
                   ,0x143);
          }
          else {
            name_len = (long)end - (long)cur_expr;
            name = strndup(cur_expr,name_len);
            mod = ly_ctx_get_module(module->ctx,name,(char *)0x0,0);
            if (module->ctx->data_clb != (ly_module_data_clb)0x0) {
              if (mod == (lys_module *)0x0) {
                mod = (*module->ctx->data_clb)
                                (module->ctx,name,(char *)0x0,0,module->ctx->data_clb_data);
              }
              else if ((mod->field_0x40 & 0x80) == 0) {
                mod = (*module->ctx->data_clb)
                                (module->ctx,name,mod->ns,1,module->ctx->data_clb_data);
              }
            }
            free(name);
            if (mod != (lys_module *)0x0) {
              prev_mod = mod;
LAB_0010a1f4:
              prefix = prev_mod->prefix;
              mod = prev_mod;
              goto LAB_0010a2a9;
            }
            ly_vlog(ctx,LYE_INMOD_LEN,LY_VLOG_NONE,(void *)0x0,name_len,cur_expr);
          }
          goto LAB_0010a8de;
        }
        if (end == (char *)0x0) {
          name_len = strlen(cur_expr);
          end = cur_expr;
        }
        else {
          name_len = (long)end - (long)cur_expr;
        }
        name = strndup(cur_expr,name_len);
        prefix = transform_module_name2import_prefix(module,name);
        free(name);
        if (prefix == (char *)0x0) {
          ly_vlog(ctx,LYE_INMOD_LEN,LY_VLOG_NONE,(void *)0x0,name_len,cur_expr);
          goto LAB_0010a8de;
        }
LAB_0010a2a9:
        if ((schema == 0) && (ns_count != (uint32_t *)0x0)) {
          for (j = 0; (j < *ns_count && ((*namespaces)[j] != mod->ns)); j = j + 1) {
          }
          if (j != *ns_count) goto LAB_0010a465;
          *ns_count = *ns_count + 1;
          ppcVar3 = (char **)ly_realloc(*prefixes,(ulong)*ns_count * 8);
          *prefixes = ppcVar3;
          if (*prefixes == (char **)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "_transform_json2xml_subexp");
          }
          else {
            ppcVar3 = (char **)ly_realloc(*namespaces,(ulong)*ns_count * 8);
            *namespaces = ppcVar3;
            if (*namespaces != (char **)0x0) {
              (*prefixes)[*ns_count - 1] = mod->prefix;
              (*namespaces)[*ns_count - 1] = mod->ns;
              goto LAB_0010a465;
            }
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "_transform_json2xml_subexp");
          }
        }
        else {
LAB_0010a465:
          sVar1 = *out_size;
          sVar4 = strlen(prefix);
          *out_size = (sVar4 - name_len) + sVar1 + 1;
          pcVar5 = (char *)ly_realloc(*out,*out_size);
          *out = pcVar5;
          if (*out != (char *)0x0) {
            strcpy(*out + *out_used,prefix);
            sVar1 = *out_used;
            sVar4 = strlen(prefix);
            *out_used = sVar1 + sVar4;
            if (name_len == 0) {
              (*out)[*out_used] = ':';
              *out_used = *out_used + 1;
            }
            strncpy(*out + *out_used,end,exp->tok_len[i] - name_len);
            *out_used = *out_used + (exp->tok_len[i] - name_len);
            goto LAB_0010a8b3;
          }
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "_transform_json2xml_subexp");
        }
LAB_0010a8de:
        if ((schema == 0) && (ns_count != (uint32_t *)0x0)) {
          free(*prefixes);
          free(*namespaces);
        }
        lyxp_expr_free(exp);
        iVar2 = 1;
        goto LAB_0010a926;
      }
      if ((exp->tokens[i] == LYXP_TOKEN_LITERAL) &&
         (end = strnchr(cur_expr,0x3a,(uint)exp->tok_len[i]), end != (char *)0x0)) {
        (*out)[*out_used] = *cur_expr;
        *out_used = *out_used + 1;
        literal = lydict_insert(module->ctx,cur_expr + 1,(long)(int)(exp->tok_len[i] - 2));
        ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
        iVar2 = _transform_json2xml_subexp
                          (module,literal,out,out_used,out_size,schema,inst_id,prefixes,namespaces,
                           ns_count);
        if (iVar2 != 0) {
          strncpy(*out + *out_used,literal,(long)(int)(exp->tok_len[i] - 2));
          *out_used = *out_used + (long)(int)(exp->tok_len[i] - 2);
        }
        ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
        lydict_remove(module->ctx,literal);
        (*out)[*out_used] = cur_expr[(ulong)exp->tok_len[i] - 1];
        *out_used = *out_used + 1;
      }
      else {
        strncpy(*out + *out_used,exp->expr + exp->expr_pos[i],(ulong)exp->tok_len[i]);
        *out_used = *out_used + (ulong)exp->tok_len[i];
      }
LAB_0010a8b3:
    }
    lyxp_expr_free(exp);
    iVar2 = 0;
  }
LAB_0010a926:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * _transform_json2xml(lys_module *module,char *expr,int schema,int inst_id,char ***prefixes,
                          char ***namespaces,uint32_t *ns_count)

{
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  long in_FS_OFFSET;
  uint32_t *ns_count_local;
  char ***namespaces_local;
  char ***prefixes_local;
  int inst_id_local;
  int schema_local;
  char *expr_local;
  lys_module *module_local;
  int ret;
  char *out;
  size_t out_size;
  size_t out_used;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (((module == (lys_module *)0x0) || (expr == (char *)0x0)) ||
     (((prefixes != (char ***)0x0 ||
       ((namespaces != (char ***)0x0 || (ns_count != (uint32_t *)0x0)))) &&
      ((prefixes == (char ***)0x0 ||
       ((namespaces == (char ***)0x0 || (ns_count == (uint32_t *)0x0)))))))) {
                    // WARNING: Subroutine does not return
    __assert_fail("module && expr && ((!prefixes && !namespaces && !ns_count) || (prefixes && namespaces && ns_count))"
                  ,
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/common.c"
                  ,0x1ad,"_transform_json2xml");
  }
  if (ns_count != (uint32_t *)0x0) {
    *ns_count = 0;
    *prefixes = (char **)0x0;
    *namespaces = (char **)0x0;
  }
  if (*expr == '\0') {
    pcVar2 = lydict_insert(module->ctx,expr,0);
  }
  else {
    sVar3 = strlen(expr);
    out_size = sVar3 + 1;
    out = (char *)malloc(out_size);
    if (out == (char *)0x0) {
      ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","_transform_json2xml");
      pcVar2 = (char *)0x0;
    }
    else {
      out_used = 0;
      iVar1 = _transform_json2xml_subexp
                        (module,expr,&out,&out_used,&out_size,schema,inst_id,prefixes,namespaces,
                         ns_count);
      if (iVar1 == 0) {
        out[out_used] = '\0';
        pcVar2 = lydict_insert_zc(module->ctx,out);
      }
      else {
        free(out);
        pcVar2 = (char *)0x0;
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pcVar2;
}



char * transform_json2xml(lys_module *module,char *expr,int inst_id,char ***prefixes,
                         char ***namespaces,uint32_t *ns_count)

{
  char *pcVar1;
  uint32_t *ns_count_local;
  char ***namespaces_local;
  char ***prefixes_local;
  int inst_id_local;
  char *expr_local;
  lys_module *module_local;
  
  pcVar1 = _transform_json2xml(module,expr,0,inst_id,prefixes,namespaces,ns_count);
  return pcVar1;
}



char * transform_json2schema(lys_module *module,char *expr)

{
  char *pcVar1;
  char *expr_local;
  lys_module *module_local;
  
  pcVar1 = _transform_json2xml(module,expr,1,0,(char ***)0x0,(char ***)0x0,(uint32_t *)0x0);
  return pcVar1;
}



int transform_xml2json_subexp
              (ly_ctx *ctx,char *expr,char **out,size_t *out_used,size_t *out_size,lyxml_elem *xml,
              int inst_id,int use_ctx_data_clb)

{
  undefined4 uVar1;
  size_t sVar2;
  int iVar3;
  lyxp_expr *expr_00;
  char *pcVar4;
  char *pcVar5;
  lyxml_ns *plVar6;
  size_t sVar7;
  undefined4 *puVar8;
  lyxml_elem *xml_local;
  size_t *out_size_local;
  size_t *out_used_local;
  char **out_local;
  char *expr_local;
  ly_ctx *ctx_local;
  uint16_t i;
  int_log_opts prev_ilo;
  char *end;
  size_t pref_len;
  lys_module *mod;
  lys_module *prev_mod;
  lyxp_expr *exp;
  char *cur_expr;
  char *prefix;
  lyxml_ns *ns;
  char *literal;
  
  prev_mod = (lys_module *)0x0;
  expr_00 = lyxp_parse_expr(ctx,expr);
  if (expr_00 == (lyxp_expr *)0x0) {
    iVar3 = 1;
  }
  else {
    for (i = 0; i < expr_00->used; i = i + 1) {
      pcVar4 = expr_00->expr + expr_00->expr_pos[i];
      if ((i != 0) &&
         (pcVar5 = expr_00->expr +
                   (ulong)expr_00->tok_len[(ulong)i - 1] + (ulong)expr_00->expr_pos[(ulong)i - 1],
         pcVar5 != pcVar4)) {
        strncpy(*out + *out_used,pcVar5,(long)pcVar4 - (long)pcVar5);
        *out_used = (size_t)(pcVar4 + (*out_used - (long)pcVar5));
      }
      if ((expr_00->tokens[i] == LYXP_TOKEN_NAMETEST) &&
         (end = strnchr(pcVar4,0x3a,(uint)expr_00->tok_len[i]), end != (char *)0x0)) {
        pref_len = (long)end - (long)pcVar4;
        pcVar5 = strndup(pcVar4,pref_len);
        if (pcVar5 == (char *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","transform_xml2json_subexp"
                );
LAB_0010b3e0:
          lyxp_expr_free(expr_00);
          return 1;
        }
        plVar6 = lyxml_get_ns(xml,pcVar5);
        free(pcVar5);
        if (plVar6 == (lyxml_ns *)0x0) {
          ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_XML,xml,"namespace prefix");
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                  "XML namespace with prefix \"%.*s\" not defined.",pref_len,pcVar4);
          goto LAB_0010b3e0;
        }
        mod = ly_ctx_get_module_by_ns(ctx,plVar6->value,(char *)0x0,0);
        if ((use_ctx_data_clb != 0) && (ctx->data_clb != (ly_module_data_clb)0x0)) {
          if (mod == (lys_module *)0x0) {
            mod = (*ctx->data_clb)(ctx,(char *)0x0,plVar6->value,0,ctx->data_clb_data);
          }
          else if ((mod->field_0x40 & 0x80) == 0) {
            mod = (*ctx->data_clb)(ctx,mod->name,mod->ns,1,ctx->data_clb_data);
          }
        }
        if (mod == (lys_module *)0x0) {
          ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_XML,xml,"module namespace");
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                  "Module with the namespace \"%s\" could not be found.",plVar6->value);
          goto LAB_0010b3e0;
        }
        if ((inst_id == 0) || (mod != prev_mod)) {
          sVar2 = *out_size;
          sVar7 = strlen(mod->name);
          *out_size = sVar2 + (sVar7 - pref_len);
          pcVar4 = (char *)ly_realloc(*out,*out_size);
          *out = pcVar4;
          if (*out == (char *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "transform_xml2json_subexp");
            goto LAB_0010b3e0;
          }
          strcpy(*out + *out_used,mod->name);
          sVar2 = *out_used;
          sVar7 = strlen(mod->name);
          *out_used = sVar2 + sVar7;
        }
        else {
          end = end + 1;
          pref_len = pref_len + 1;
        }
        prev_mod = mod;
        strncpy(*out + *out_used,end,expr_00->tok_len[i] - pref_len);
        *out_used = *out_used + (expr_00->tok_len[i] - pref_len);
      }
      else {
        if ((expr_00->tokens[i] == LYXP_TOKEN_NAMETEST) && (inst_id != 0)) {
          ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_XML,xml,"namespace prefix");
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Node name is missing module prefix.");
          goto LAB_0010b3e0;
        }
        if ((expr_00->tokens[i] == LYXP_TOKEN_LITERAL) &&
           (pcVar5 = strnchr(pcVar4,0x3a,(uint)expr_00->tok_len[i]), pcVar5 != (char *)0x0)) {
          (*out)[*out_used] = *pcVar4;
          *out_used = *out_used + 1;
          pcVar5 = lydict_insert(ctx,pcVar4 + 1,(long)(int)(expr_00->tok_len[i] - 2));
          puVar8 = (undefined4 *)__tls_get_addr(&PTR_0023dfc0);
          uVar1 = *puVar8;
          puVar8 = (undefined4 *)__tls_get_addr(&PTR_0023dfc0);
          *puVar8 = 2;
          iVar3 = transform_xml2json_subexp
                            (ctx,pcVar5,out,out_used,out_size,xml,inst_id,use_ctx_data_clb);
          if (iVar3 != 0) {
            strncpy(*out + *out_used,pcVar5,(long)(int)(expr_00->tok_len[i] - 2));
            *out_used = *out_used + (long)(int)(expr_00->tok_len[i] - 2);
          }
          puVar8 = (undefined4 *)__tls_get_addr(&PTR_0023dfc0);
          *puVar8 = uVar1;
          lydict_remove(ctx,pcVar5);
          (*out)[*out_used] = pcVar4[(ulong)expr_00->tok_len[i] - 1];
          *out_used = *out_used + 1;
        }
        else {
          strncpy(*out + *out_used,expr_00->expr + expr_00->expr_pos[i],(ulong)expr_00->tok_len[i]);
          *out_used = *out_used + (ulong)expr_00->tok_len[i];
        }
      }
    }
    lyxp_expr_free(expr_00);
    iVar3 = 0;
  }
  return iVar3;
}



char * transform_xml2json(ly_ctx *ctx,char *expr,lyxml_elem *xml,int inst_id,int use_ctx_data_clb)

{
  int iVar1;
  size_t sVar2;
  char *pcVar3;
  long in_FS_OFFSET;
  int use_ctx_data_clb_local;
  int inst_id_local;
  lyxml_elem *xml_local;
  char *expr_local;
  ly_ctx *ctx_local;
  int ret;
  char *out;
  size_t out_size;
  size_t out_used;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  sVar2 = strlen(expr);
  out_size = sVar2 + 1;
  out = (char *)malloc(out_size);
  if (out == (char *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","transform_xml2json");
    pcVar3 = (char *)0x0;
  }
  else {
    out_used = 0;
    iVar1 = transform_xml2json_subexp
                      (ctx,expr,&out,&out_used,&out_size,xml,inst_id,use_ctx_data_clb);
    if (iVar1 == 0) {
      out[out_used] = '\0';
      pcVar3 = lydict_insert_zc(ctx,out);
    }
    else {
      free(out);
      pcVar3 = (char *)0x0;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pcVar3;
}



char * ly_path_xml2json(ly_ctx *ctx,char *xml_path,lyxml_elem *xml)

{
  char *__s;
  lyxml_elem *xml_local;
  char *xml_path_local;
  ly_ctx *ctx_local;
  char *ret;
  char *json_path;
  
  ly_log_dbg(0x20,"%s","ly_path_xml2json");
  ret = (char *)0x0;
  if (((ctx == (ly_ctx *)0x0) || (xml_path == (char *)0x0)) || (xml == (lyxml_elem *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_path_xml2json");
    ret = (char *)0x0;
  }
  else {
    __s = transform_xml2json(ctx,xml_path,xml,0,1);
    if (__s != (char *)0x0) {
      ret = strdup(__s);
      lydict_remove(ctx,__s);
    }
  }
  return ret;
}



char * transform_schema2json(lys_module *module,char *expr)

{
  char *pcVar1;
  ly_ctx *ctx_00;
  size_t sVar2;
  char *pcVar3;
  lyxp_expr *expr_00;
  char *pcVar4;
  long lVar5;
  lys_module *plVar6;
  ushort **ppuVar7;
  char *expr_local;
  lys_module *module_local;
  uint16_t i;
  char *ptr;
  char *out;
  size_t out_size;
  size_t out_used;
  ly_ctx *ctx;
  lyxp_expr *exp;
  char *cur_expr;
  char *end;
  size_t pref_len;
  lys_module *mod;
  
  ctx_00 = module->ctx;
  sVar2 = strlen(expr);
  out_size = sVar2 + 1;
  out = (char *)malloc(out_size);
  if (out == (char *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","transform_schema2json");
    pcVar3 = (char *)0x0;
  }
  else {
    out_used = 0;
    expr_00 = lyxp_parse_expr(ctx_00,expr);
    if (expr_00 == (lyxp_expr *)0x0) {
LAB_0010bc75:
      free(out);
      lyxp_expr_free(expr_00);
      pcVar3 = (char *)0x0;
    }
    else {
      for (i = 0; i < expr_00->used; i = i + 1) {
        pcVar3 = expr_00->expr + expr_00->expr_pos[i];
        if ((i != 0) &&
           (pcVar4 = expr_00->expr +
                     (ulong)expr_00->tok_len[(ulong)i - 1] + (ulong)expr_00->expr_pos[(ulong)i - 1],
           pcVar4 != pcVar3)) {
          strncpy(out + out_used,pcVar4,(long)pcVar3 - (long)pcVar4);
          out_used = (size_t)(pcVar3 + (out_used - (long)pcVar4));
        }
        if ((expr_00->tokens[i] == LYXP_TOKEN_NAMETEST) &&
           (pcVar4 = strnchr(pcVar3,0x3a,(uint)expr_00->tok_len[i]), pcVar4 != (char *)0x0)) {
          lVar5 = (long)pcVar4 - (long)pcVar3;
          plVar6 = lyp_get_module(module,pcVar3,(int)lVar5,(char *)0x0,0,0);
          if (plVar6 == (lys_module *)0x0) {
            ly_vlog(ctx_00,LYE_INMOD_LEN,LY_VLOG_NONE,(void *)0x0,lVar5,pcVar3);
            goto LAB_0010bc75;
          }
          sVar2 = strlen(plVar6->name);
          out_size = out_size + (sVar2 - lVar5);
          out = (char *)ly_realloc(out,out_size);
          if (out == (char *)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "transform_schema2json");
            goto LAB_0010bc75;
          }
          strcpy(out + out_used,plVar6->name);
          sVar2 = strlen(plVar6->name);
          strncpy(out + out_used + sVar2,pcVar4,(ulong)expr_00->tok_len[i] - lVar5);
          out_used = out_used + sVar2 + ((ulong)expr_00->tok_len[i] - lVar5);
        }
        else if ((expr_00->tokens[i] == LYXP_TOKEN_LITERAL) &&
                (pcVar4 = strnchr(pcVar3,0x3a,(uint)expr_00->tok_len[i]), ptr = pcVar4,
                pcVar4 != (char *)0x0)) {
          for (; (((ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[ptr[-1]] & 8) != 0 || (ptr[-1] == '_'))
                  || (ptr[-1] == '-')) || (ptr[-1] == '.')); ptr = ptr + -1) {
          }
          lVar5 = (long)pcVar4 - (long)ptr;
          plVar6 = lyp_get_module(module,ptr,(int)lVar5,(char *)0x0,0,0);
          if (plVar6 == (lys_module *)0x0) {
            strncpy(out + out_used,expr_00->expr + expr_00->expr_pos[i],(ulong)expr_00->tok_len[i]);
            out_used = out_used + expr_00->tok_len[i];
          }
          else {
            sVar2 = strlen(plVar6->name);
            out_size = out_size + (sVar2 - lVar5);
            out = (char *)ly_realloc(out,out_size);
            if (out == (char *)0x0) {
              ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "transform_schema2json");
              goto LAB_0010bc75;
            }
            strncpy(out + out_used,pcVar3,(long)ptr - (long)pcVar3);
            pcVar1 = ptr + (out_used - (long)pcVar3);
            strcpy(out + (long)pcVar1,plVar6->name);
            sVar2 = strlen(plVar6->name);
            strncpy(out + (long)(pcVar1 + sVar2),pcVar4,
                    ((ulong)expr_00->tok_len[i] - lVar5) - ((long)ptr - (long)pcVar3));
            out_used = (size_t)(pcVar1 + sVar2 +
                               (((ulong)expr_00->tok_len[i] - lVar5) - ((long)ptr - (long)pcVar3)));
          }
        }
        else {
          strncpy(out + out_used,expr_00->expr + expr_00->expr_pos[i],(ulong)expr_00->tok_len[i]);
          out_used = out_used + expr_00->tok_len[i];
        }
      }
      out[out_used] = '\0';
      lyxp_expr_free(expr_00);
      pcVar3 = lydict_insert_zc(module->ctx,out);
    }
  }
  return pcVar3;
}



char * transform_iffeat_schema2json(lys_module *module,char *expr)

{
  char *pcVar1;
  ly_ctx *ctx_00;
  uint uVar2;
  size_t sVar3;
  char *pcVar4;
  ulong uVar5;
  ulong uVar6;
  lys_module *plVar7;
  char *expr_local;
  lys_module *module_local;
  char *in;
  char *id;
  char *out;
  size_t out_size;
  size_t out_used;
  ly_ctx *ctx;
  char *col;
  size_t id_len;
  size_t rc;
  lys_module *mod;
  
  ctx_00 = module->ctx;
  sVar3 = strlen(expr);
  out_size = sVar3 + 1;
  out = (char *)malloc(out_size);
  if (out == (char *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","transform_iffeat_schema2json"
          );
    pcVar4 = (char *)0x0;
  }
  else {
    out_used = 0;
    in = expr;
    while (pcVar4 = strchr(in,0x3a), pcVar4 != (char *)0x0) {
      id = strpbrk_backwards(pcVar4 + -1," \f\n\r\t\v(",((int)pcVar4 - (int)in) - 1);
      if ((((*id == ' ') || (*id == '\f')) || (*id == '\n')) ||
         (((*id == '\r' || (*id == '\t')) || ((*id == '\v' || (*id == '(')))))) {
        id = id + 1;
      }
      uVar5 = (long)pcVar4 - (long)id;
      uVar2 = parse_identifier(id);
      uVar6 = (ulong)uVar2;
      if (uVar6 < uVar5) {
        ly_vlog(ctx_00,LYE_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[uVar6],id + uVar6);
        free(out);
        return (char *)0x0;
      }
      plVar7 = lyp_get_module(module,id,(int)uVar5,(char *)0x0,0,0);
      if (plVar7 == (lys_module *)0x0) {
        ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Module prefix \"%.*s\" is unknown.",uVar5,
                id);
        free(out);
        return (char *)0x0;
      }
      sVar3 = strlen(plVar7->name);
      out_size = out_size + (sVar3 - uVar5);
      out = (char *)ly_realloc(out,out_size);
      if (out == (char *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "transform_iffeat_schema2json");
        return (char *)0x0;
      }
      strncpy(out + out_used,in,(long)id - (long)in);
      pcVar1 = id + (out_used - (long)in);
      strcpy(out + (long)pcVar1,plVar7->name);
      sVar3 = strlen(plVar7->name);
      out[(long)(pcVar1 + sVar3)] = ':';
      out_used = (size_t)(pcVar1 + sVar3 + 1);
      in = pcVar4 + 1;
    }
    strcpy(out + out_used,in);
    sVar3 = strlen(in);
    if (out_size != sVar3 + out_used + 1) {
                    // WARNING: Subroutine does not return
      __assert_fail("out_size == out_used",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/common.c"
                    ,0x2f1,"transform_iffeat_schema2json");
    }
    pcVar4 = lydict_insert_zc(ctx_00,out);
  }
  return pcVar4;
}



int transform_json2xpath_subexpr
              (lys_module *cur_module,lys_module *prev_mod,lyxp_expr *exp,uint32_t *i,
              lyxp_token end_token,char **out,size_t *out_used,size_t *out_size)

{
  ly_ctx *ctx_00;
  size_t sVar1;
  int iVar2;
  char *pcVar3;
  size_t sVar4;
  char *pcVar5;
  ushort **ppuVar6;
  lys_module *plVar7;
  size_t sVar8;
  char **out_local;
  lyxp_token end_token_local;
  uint32_t *i_local;
  lyxp_expr *exp_local;
  lys_module *prev_mod_local;
  lys_module *cur_module_local;
  char *end;
  char *ptr;
  size_t name_len;
  ly_ctx *ctx;
  char *cur_expr;
  char *name;
  lys_module *mod;
  
  ctx_00 = cur_module->ctx;
  prev_mod_local = prev_mod;
  do {
    if ((uint)exp->used <= *i) {
      return 0;
    }
    if (end_token == exp->tokens[*i]) {
      return 0;
    }
    end = exp->expr + exp->expr_pos[*i];
    if ((*i != 0) &&
       (pcVar3 = exp->expr + (ulong)exp->tok_len[*i - 1] + (ulong)exp->expr_pos[*i - 1],
       pcVar3 != end)) {
      strncpy(*out + *out_used,pcVar3,(long)end - (long)pcVar3);
      *out_used = (size_t)(end + (*out_used - (long)pcVar3));
    }
    if (exp->tokens[*i] == LYXP_TOKEN_BRACK1) {
      strncpy(*out + *out_used,exp->expr + exp->expr_pos[*i],(ulong)exp->tok_len[*i]);
      *out_used = *out_used + (ulong)exp->tok_len[*i];
      *i = *i + 1;
      iVar2 = transform_json2xpath_subexpr
                        (cur_module,prev_mod_local,exp,i,LYXP_TOKEN_BRACK2,out,out_used,out_size);
      if (iVar2 != 0) {
        return -1;
      }
      if ((uint)exp->used <= *i) {
        ly_vlog(ctx_00,LYE_XPATH_EOF,LY_VLOG_NONE,(void *)0x0);
        return -1;
      }
      strncpy(*out + *out_used,exp->expr + exp->expr_pos[*i],(ulong)exp->tok_len[*i]);
      *out_used = *out_used + (ulong)exp->tok_len[*i];
    }
    else if (exp->tokens[*i] == LYXP_TOKEN_NAMETEST) {
      pcVar3 = strnchr(end,0x3a,(uint)exp->tok_len[*i]);
      if (pcVar3 == (char *)0x0) {
        name_len = 0;
      }
      else {
        sVar4 = (long)pcVar3 - (long)end;
        pcVar5 = strndup(end,sVar4);
        prev_mod_local = ly_ctx_get_module(ctx_00,pcVar5,(char *)0x0,1);
        free(pcVar5);
        if (prev_mod_local == (lys_module *)0x0) {
          if (sVar4 == 0) {
            sVar4 = (size_t)exp->tok_len[*i];
          }
          ly_vlog(ctx_00,LYE_INMOD_LEN,LY_VLOG_NONE,(void *)0x0,sVar4,end);
          return -1;
        }
        end = pcVar3 + 1;
        name_len = sVar4 + 1;
      }
      if (((prev_mod_local != cur_module) && (*end != '*')) || ((name_len != 0 && (*end == '*')))) {
        sVar1 = *out_size;
        sVar4 = strlen(prev_mod_local->name);
        *out_size = (sVar4 - name_len) + sVar1 + 1;
        pcVar3 = (char *)ly_realloc(*out,*out_size);
        *out = pcVar3;
        if (*out == (char *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "transform_json2xpath_subexpr");
          return -1;
        }
        strcpy(*out + *out_used,prev_mod_local->name);
        sVar1 = *out_used;
        sVar4 = strlen(prev_mod_local->name);
        *out_used = sVar1 + sVar4;
        (*out)[*out_used] = ':';
        *out_used = *out_used + 1;
      }
      strncpy(*out + *out_used,end,exp->tok_len[*i] - name_len);
      *out_used = *out_used + (exp->tok_len[*i] - name_len);
    }
    else if ((exp->tokens[*i] == LYXP_TOKEN_LITERAL) &&
            (pcVar3 = strnchr(end,0x3a,(uint)exp->tok_len[*i]), ptr = pcVar3, pcVar3 != (char *)0x0)
            ) {
      for (; (((ppuVar6 = __ctype_b_loc(), ((*ppuVar6)[ptr[-1]] & 8) != 0 || (ptr[-1] == '_')) ||
              (ptr[-1] == '-')) || (ptr[-1] == '.')); ptr = ptr + -1) {
      }
      sVar4 = (long)pcVar3 - (long)ptr;
      pcVar5 = strndup(ptr,sVar4);
      plVar7 = ly_ctx_get_module(ctx_00,pcVar5,(char *)0x0,1);
      free(pcVar5);
      if ((plVar7 == (lys_module *)0x0) || (plVar7 == cur_module)) {
        strncpy(*out + *out_used,exp->expr + exp->expr_pos[*i],(ulong)exp->tok_len[*i]);
        *out_used = *out_used + (ulong)exp->tok_len[*i];
      }
      else {
        sVar1 = *out_size;
        sVar8 = strlen(plVar7->name);
        *out_size = sVar1 + (sVar8 - sVar4);
        pcVar5 = (char *)ly_realloc(*out,*out_size);
        *out = pcVar5;
        if (*out == (char *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "transform_json2xpath_subexpr");
          return -1;
        }
        strncpy(*out + *out_used,end,(long)ptr - (long)end);
        *out_used = (size_t)(ptr + (*out_used - (long)end));
        strcpy(*out + *out_used,plVar7->name);
        sVar1 = *out_used;
        sVar8 = strlen(plVar7->name);
        *out_used = sVar1 + sVar8;
        strncpy(*out + *out_used,pcVar3,(exp->tok_len[*i] - sVar4) - ((long)ptr - (long)end));
        *out_used = *out_used + ((exp->tok_len[*i] - sVar4) - ((long)ptr - (long)end));
      }
    }
    else {
      strncpy(*out + *out_used,exp->expr + exp->expr_pos[*i],(ulong)exp->tok_len[*i]);
      *out_used = *out_used + (ulong)exp->tok_len[*i];
    }
    *i = *i + 1;
  } while( true );
}



char * transform_json2xpath(lys_module *cur_module,char *expr)

{
  int iVar1;
  size_t sVar2;
  char *pcVar3;
  long in_FS_OFFSET;
  char *expr_local;
  lys_module *cur_module_local;
  uint32_t i;
  char *out;
  size_t out_size;
  size_t out_used;
  lyxp_expr *exp;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((cur_module == (lys_module *)0x0) || (expr == (char *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("cur_module && expr",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/common.c"
                  ,0x3a7,"transform_json2xpath");
  }
  sVar2 = strlen(expr);
  out_size = sVar2 + 1;
  out = (char *)malloc(out_size);
  if (out == (char *)0x0) {
    ly_log(cur_module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
           "transform_json2xpath");
    pcVar3 = (char *)0x0;
  }
  else {
    out_used = 0;
    exp = lyxp_parse_expr(cur_module->ctx,expr);
    if (exp == (lyxp_expr *)0x0) {
      free(out);
      pcVar3 = (char *)0x0;
    }
    else {
      i = 0;
      iVar1 = transform_json2xpath_subexpr
                        (cur_module,cur_module,exp,&i,LYXP_TOKEN_NONE,&out,&out_used,&out_size);
      if (iVar1 == 0) {
        out[out_used] = '\0';
        lyxp_expr_free(exp);
        pcVar3 = out;
      }
      else {
        free(out);
        lyxp_expr_free(exp);
        pcVar3 = (char *)0x0;
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pcVar3;
}



int ly_path_data2schema_copy_token
              (ly_ctx *ctx,lyxp_expr *exp,uint16_t cur_exp,char **out,uint16_t *out_used)

{
  int iVar1;
  ushort **ppuVar2;
  char *pcVar3;
  uint16_t *out_used_local;
  char **out_local;
  uint16_t cur_exp_local;
  lyxp_expr *exp_local;
  ly_ctx *ctx_local;
  uint16_t len;
  
  len = exp->tok_len[cur_exp];
  while( true ) {
    ppuVar2 = __ctype_b_loc();
    if (((*ppuVar2)[exp->expr[(int)((uint)len + (uint)exp->expr_pos[cur_exp])]] & 0x2000) == 0)
    break;
    len = len + 1;
  }
  pcVar3 = (char *)ly_realloc(*out,(long)(int)((uint)len + (uint)*out_used));
  *out = pcVar3;
  if (*out == (char *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_path_data2schema_copy_token")
    ;
    iVar1 = -1;
  }
  else {
    sprintf(*out + ((ulong)*out_used - 1),"%.*s",(ulong)len,exp->expr + exp->expr_pos[cur_exp]);
    *out_used = *out_used + len;
    iVar1 = 0;
  }
  return iVar1;
}



// WARNING: Type propagation algorithm not settling

int ly_path_data2schema_subexp
              (ly_ctx *ctx,lys_node *orig_parent,lys_module *cur_mod,lyxp_expr *exp,
              uint16_t *cur_exp,char **out,uint16_t *out_used)

{
  char cVar1;
  lyxp_token lVar2;
  bool bVar3;
  ushort uVar4;
  int iVar5;
  lys_module *plVar6;
  lys_module *plVar7;
  size_t sVar8;
  size_t sVar9;
  undefined *puVar10;
  ushort **ppuVar11;
  char *pcVar12;
  bool bVar13;
  char **out_local;
  uint16_t *cur_exp_local;
  lyxp_expr *exp_local;
  lys_module *cur_mod_local;
  lys_node *orig_parent_local;
  ly_ctx *ctx_local;
  uint16_t j;
  uint16_t k;
  uint16_t len;
  uint16_t slash;
  lyxp_token end_token;
  int first;
  int path_lost;
  char *str;
  char *col;
  lys_node *node;
  lys_node *node2;
  lys_node *parent;
  
  str = (char *)0x0;
  end_token = LYXP_TOKEN_NONE;
  lVar2 = exp->tokens[*cur_exp];
  if (lVar2 == LYXP_TOKEN_OPERATOR_PATH) {
    bVar13 = orig_parent == (lys_node *)0x0;
  }
  else if (lVar2 < LYXP_TOKEN_LITERAL) {
    if (lVar2 == LYXP_TOKEN_PAR1) {
      end_token = LYXP_TOKEN_PAR2;
      iVar5 = ly_path_data2schema_copy_token(ctx,exp,*cur_exp,out,out_used);
      if (iVar5 != 0) goto LAB_0010d7da;
      *cur_exp = *cur_exp + 1;
      bVar13 = false;
    }
    else {
      if (lVar2 != LYXP_TOKEN_BRACK1) goto LAB_0010ce11;
      end_token = LYXP_TOKEN_BRACK2;
      iVar5 = ly_path_data2schema_copy_token(ctx,exp,*cur_exp,out,out_used);
      if (iVar5 != 0) goto LAB_0010d7da;
      *cur_exp = *cur_exp + 1;
      bVar13 = false;
    }
  }
  else {
LAB_0010ce11:
    bVar13 = true;
  }
  bVar3 = false;
  cur_mod_local = cur_mod;
  parent = orig_parent;
  while( true ) {
    str = (char *)0x0;
    if (exp->used <= *cur_exp) {
      if (end_token != LYXP_TOKEN_NONE) {
        ly_vlog(ctx,LYE_XPATH_EOF,LY_VLOG_NONE,(void *)0x0);
        return -1;
      }
      return 0;
    }
    if (false) break;
    switch(exp->tokens[*cur_exp]) {
    default:
      goto switchD_0010ce70_caseD_0;
    case LYXP_TOKEN_PAR1:
    case LYXP_TOKEN_BRACK1:
      iVar5 = ly_path_data2schema_subexp(ctx,parent,cur_mod_local,exp,cur_exp,out,out_used);
      break;
    case LYXP_TOKEN_DOT:
    case LYXP_TOKEN_DDOT:
    case LYXP_TOKEN_NAMETEST:
      if (bVar3) {
        iVar5 = ly_path_data2schema_copy_token(ctx,exp,*cur_exp,out,out_used);
        break;
      }
      str = strndup(exp->expr + exp->expr_pos[*cur_exp],(ulong)exp->tok_len[*cur_exp]);
      if (str == (char *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_path_data2schema_subexp")
        ;
        goto LAB_0010d7da;
      }
      col = strchr(str,0x3a);
      if (col != (char *)0x0) {
        *col = '\0';
        col = col + 1;
      }
      if (bVar13) {
        if (col == (char *)0x0) {
          ly_vlog(ctx,LYE_PATH_MISSMOD,LY_VLOG_NONE,(void *)0x0);
          goto LAB_0010d7da;
        }
        cur_mod_local = ly_ctx_get_module(ctx,str,(char *)0x0,0);
        if (cur_mod_local == (lys_module *)0x0) {
          ly_vlog(ctx,LYE_PATH_INMOD,LY_VLOG_STR,str);
          goto LAB_0010d7da;
        }
        bVar13 = false;
      }
      if (col == (char *)0x0) {
        cVar1 = *str;
      }
      else {
        cVar1 = *col;
      }
      if (cVar1 == '.') {
LAB_0010d021:
        free(str);
        str = (char *)0x0;
        if (end_token == LYXP_TOKEN_NONE) {
          bVar3 = true;
          iVar5 = ly_path_data2schema_copy_token(ctx,exp,*cur_exp,out,out_used);
          break;
        }
        ly_log(ctx,LY_LLERR,LY_EINVAL,"Invalid path used (%s in a subexpression).",0);
      }
      else {
        if (col == (char *)0x0) {
          cVar1 = *str;
        }
        else {
          cVar1 = *col;
        }
        if (cVar1 == '*') goto LAB_0010d021;
        node = (lys_node *)0x0;
LAB_0010d418:
        do {
          do {
            node = lys_getnext(node,parent,cur_mod_local,0x100);
            if (node == (lys_node *)0x0) goto LAB_0010d440;
            pcVar12 = str;
            if (col != (char *)0x0) {
              pcVar12 = col;
            }
            iVar5 = strcmp(node->name,pcVar12);
          } while (iVar5 != 0);
          if (col != (char *)0x0) {
            plVar6 = lys_node_module(node);
            iVar5 = strcmp(plVar6->name,str);
            if (iVar5 != 0) goto LAB_0010d418;
          }
          if (col != (char *)0x0) break;
          plVar6 = lys_node_module(node);
          plVar7 = lys_node_module(parent);
        } while (plVar6 != plVar7);
        j = 0;
        node2 = node;
        while (node2 != parent) {
          node2 = lys_parent(node2);
          if ((node2 == (lys_node *)0x0) || (node2->nodetype != LYS_USES)) {
            j = j + 1;
          }
        }
        slash = 0;
        for (; j != 0; j = j - 1) {
          k = j - 1;
          node2 = node;
          while (k != 0) {
            node2 = lys_parent(node2);
            if (node2 == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
              __assert_fail("node2",
                            "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/common.c"
                            ,1099,"ly_path_data2schema_subexp");
            }
            if (node2->nodetype != LYS_USES) {
              k = k - 1;
            }
          }
          plVar6 = lys_node_module(node2);
          if ((cur_mod_local == plVar6) && (parent != (lys_node *)0x0)) {
            sVar8 = strlen(node2->name);
            uVar4 = slash + (short)sVar8;
            pcVar12 = (char *)ly_realloc(*out,(long)(int)((uint)uVar4 + (uint)*out_used));
            *out = pcVar12;
            if (*out == (char *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "ly_path_data2schema_subexp");
              goto LAB_0010d7da;
            }
            if (slash == 0) {
              puVar10 = &DAT_0020c393;
            }
            else {
              puVar10 = &DAT_0020c391;
            }
            sprintf(*out + ((ulong)*out_used - 1),"%s%s",puVar10,node2->name);
            *out_used = *out_used + uVar4;
          }
          else {
            plVar6 = lys_node_module(node2);
            sVar8 = strlen(plVar6->name);
            sVar9 = strlen(node2->name);
            uVar4 = (short)sVar9 + (short)sVar8 + slash + 1;
            pcVar12 = (char *)ly_realloc(*out,(long)(int)((uint)uVar4 + (uint)*out_used));
            *out = pcVar12;
            if (*out == (char *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "ly_path_data2schema_subexp");
              goto LAB_0010d7da;
            }
            pcVar12 = node2->name;
            plVar6 = lys_node_module(node2);
            if (slash == 0) {
              puVar10 = &DAT_0020c393;
            }
            else {
              puVar10 = &DAT_0020c391;
            }
            sprintf(*out + ((ulong)*out_used - 1),"%s%s:%s",puVar10,plVar6->name,pcVar12);
            *out_used = *out_used + uVar4;
          }
          slash = 1;
        }
LAB_0010d440:
        if (node != (lys_node *)0x0) {
          len = 0;
          while (ppuVar11 = __ctype_b_loc(),
                ((*ppuVar11)
                 [exp->expr[(int)((uint)len +
                                 (uint)exp->expr_pos[*cur_exp] + (uint)exp->tok_len[*cur_exp])]] &
                0x2000) != 0) {
            len = len + 1;
          }
          if (len != 0) {
            pcVar12 = (char *)ly_realloc(*out,(long)(int)((uint)len + (uint)*out_used));
            *out = pcVar12;
            if (*out == (char *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "ly_path_data2schema_subexp");
              goto LAB_0010d7da;
            }
            sprintf(*out + ((ulong)*out_used - 1),"%*s",(ulong)len,&DAT_0020c3a1);
            *out_used = *out_used + len;
          }
          free(str);
          parent = node;
          goto LAB_0010d776;
        }
        pcVar12 = str;
        if (col != (char *)0x0) {
          pcVar12 = col;
        }
        ly_vlog(ctx,LYE_PATH_INNODE,LY_VLOG_STR,pcVar12);
      }
      goto LAB_0010d7da;
    case LYXP_TOKEN_COMMA:
    case LYXP_TOKEN_OPERATOR_LOG:
    case LYXP_TOKEN_OPERATOR_COMP:
    case LYXP_TOKEN_OPERATOR_MATH:
    case LYXP_TOKEN_OPERATOR_UNI:
      bVar13 = true;
      bVar3 = false;
      parent = orig_parent;
    case LYXP_TOKEN_OPERATOR_PATH:
      if ((exp->tokens[*cur_exp] == LYXP_TOKEN_OPERATOR_PATH) && (exp->tok_len[*cur_exp] == 2)) {
        bVar3 = true;
      }
    case LYXP_TOKEN_NODETYPE:
    case LYXP_TOKEN_FUNCNAME:
    case LYXP_TOKEN_LITERAL:
    case LYXP_TOKEN_NUMBER:
      iVar5 = ly_path_data2schema_copy_token(ctx,exp,*cur_exp,out,out_used);
    }
    str = (char *)0x0;
    if (iVar5 != 0) goto LAB_0010d7da;
LAB_0010d776:
    *cur_exp = *cur_exp + 1;
  }
switchD_0010ce70_caseD_0:
  if ((end_token == LYXP_TOKEN_NONE) || (end_token != exp->tokens[*cur_exp])) {
    ly_log(ctx,LY_LLERR,LY_EINVAL,"Invalid token used (%.*s).",(ulong)exp->tok_len[*cur_exp],
           exp->expr + exp->expr_pos[*cur_exp]);
  }
  else {
    iVar5 = ly_path_data2schema_copy_token(ctx,exp,*cur_exp,out,out_used);
    if (iVar5 == 0) {
      return 0;
    }
  }
LAB_0010d7da:
  free(str);
  return -1;
}



char * ly_path_data2schema(ly_ctx *ctx,char *data_path)

{
  int iVar1;
  char *pcVar2;
  long in_FS_OFFSET;
  char *data_path_local;
  ly_ctx *ctx_local;
  uint16_t out_used;
  uint16_t cur_exp;
  int mod_name_len;
  int nam_len;
  int is_relative;
  int r;
  char *out;
  char *mod_name;
  char *name;
  lys_module *mod;
  lys_node *parent;
  char *str;
  lyxp_expr *exp;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","ly_path_data2schema");
  cur_exp = 0;
  is_relative = -1;
  mod = (lys_module *)0x0;
  parent = (lys_node *)0x0;
  if ((ctx == (ly_ctx *)0x0) || (data_path == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_path_data2schema");
    pcVar2 = (char *)0x0;
  }
  else {
    r = parse_schema_nodeid(data_path,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,(int *)0x0
                            ,(int *)0x0,1);
    if (r < 1) {
      ly_vlog(ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)data_path[-r],
              data_path + -r);
      pcVar2 = (char *)0x0;
    }
    else {
      if (*name == '#') {
        if (is_relative != 0) {
          ly_vlog(ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,0x23,name);
          pcVar2 = (char *)0x0;
          goto LAB_0010dd0c;
        }
        name = name + 1;
        nam_len = nam_len + -1;
        if (mod_name == (char *)0x0) {
          str = strndup(data_path,(size_t)(name + ((long)nam_len - (long)data_path)));
          ly_vlog(ctx,LYE_PATH_MISSMOD,LY_VLOG_STR,str);
          free(str);
          pcVar2 = (char *)0x0;
          goto LAB_0010dd0c;
        }
        str = strndup(mod_name,(long)mod_name_len);
        if (str == (char *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_path_data2schema");
          pcVar2 = (char *)0x0;
          goto LAB_0010dd0c;
        }
        mod = ly_ctx_get_module(ctx,str,(char *)0x0,1);
        free(str);
        if (mod == (lys_module *)0x0) {
          str = strndup(data_path,(size_t)(mod_name + ((long)mod_name_len - (long)data_path)));
          ly_vlog(ctx,LYE_PATH_INMOD,LY_VLOG_STR,str);
          free(str);
          pcVar2 = (char *)0x0;
          goto LAB_0010dd0c;
        }
        parent = lyp_get_yang_data_template(mod,name,nam_len);
        if (parent == (lys_node *)0x0) {
          str = strndup(data_path,(size_t)(name + ((long)nam_len - (long)data_path)));
          ly_vlog(ctx,LYE_PATH_INNODE,LY_VLOG_STR,str);
          free(str);
          pcVar2 = (char *)0x0;
          goto LAB_0010dd0c;
        }
        out_used = (((short)nam_len + (short)name) - (short)data_path) + 1;
        out = (char *)malloc((ulong)out_used);
        if (out == (char *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_path_data2schema");
          pcVar2 = (char *)0x0;
          goto LAB_0010dd0c;
        }
        memcpy(out,data_path,(long)(int)(out_used - 1));
        data_path_local = data_path + r;
      }
      else {
        out_used = 1;
        out = (char *)malloc(1);
        data_path_local = data_path;
        if (out == (char *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_path_data2schema");
          pcVar2 = (char *)0x0;
          goto LAB_0010dd0c;
        }
      }
      exp = lyxp_parse_expr(ctx,data_path_local);
      if (exp == (lyxp_expr *)0x0) {
        free(out);
        pcVar2 = (char *)0x0;
      }
      else {
        if (parent == (lys_node *)0x0) {
          iVar1 = ly_path_data2schema_subexp
                            (ctx,(lys_node *)0x0,(lys_module *)0x0,exp,&cur_exp,&out,&out_used);
          if (iVar1 != 0) {
            free(out);
            out = (char *)0x0;
          }
        }
        else {
          iVar1 = ly_path_data2schema_subexp(ctx,parent,mod,exp,&cur_exp,&out,&out_used);
          if (iVar1 != 0) {
            free(out);
            out = (char *)0x0;
          }
        }
        lyxp_expr_free(exp);
        pcVar2 = out;
      }
    }
  }
LAB_0010dd0c:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pcVar2;
}



int ly_new_node_validity(lys_node *schema)

{
  lys_node *schema_local;
  int validity;
  
  validity = 0;
  if (((schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) && (*(int *)&schema[1].ref == 9)
     ) {
    validity = 8;
  }
  if ((schema->nodetype & (LYS_LEAFLIST|LYS_LIST)) != LYS_UNKNOWN) {
    validity = validity | 1;
  }
  if ((schema->nodetype == LYS_LIST) && (schema->padding[3] != '\0')) {
    validity = validity | 2;
  }
  if ((schema->nodetype & 0xc1bd) != LYS_UNKNOWN) {
    validity = validity | 4;
  }
  return validity;
}



void * ly_realloc(void *ptr,size_t size)

{
  void *pvVar1;
  size_t size_local;
  void *ptr_local;
  void *new_mem;
  
  pvVar1 = realloc(ptr,size);
  if (pvVar1 == (void *)0x0) {
    free(ptr);
  }
  return pvVar1;
}



int ly_strequal_(char *s1,char *s2)

{
  int iVar1;
  char *s2_local;
  char *s1_local;
  
  if (s1 == s2) {
    iVar1 = 1;
  }
  else if ((s1 == (char *)0x0) || (s2_local = s2, s1_local = s1, s2 == (char *)0x0)) {
    iVar1 = 0;
  }
  else {
    for (; *s1_local == *s2_local; s1_local = s1_local + 1) {
      if (*s1_local == '\0') {
        return 1;
      }
      s2_local = s2_local + 1;
    }
    iVar1 = 0;
  }
  return iVar1;
}



int64_t dec_pow(uint8_t exp)

{
  uint8_t exp_local;
  uint8_t i;
  int64_t ret;
  
  ret = 1;
  for (i = '\0'; i < exp; i = i + '\x01') {
    ret = ret * 10;
  }
  return ret;
}



int dec64cmp(int64_t num1,uint8_t dig1,int64_t num2,uint8_t dig2)

{
  int iVar1;
  int64_t iVar2;
  int64_t num2_local;
  uint8_t dig2_local;
  uint8_t dig1_local;
  int64_t num1_local;
  
  num1_local = num1;
  if (dig1 < dig2) {
    iVar2 = dec_pow(dig2 - dig1);
    num2_local = num2 / iVar2;
  }
  else {
    num2_local = num2;
    if (dig2 < dig1) {
      iVar2 = dec_pow(dig1 - dig2);
      num1_local = num1 / iVar2;
    }
  }
  if (num1_local == num2_local) {
    iVar1 = 0;
  }
  else if (num2_local < num1_local) {
    iVar1 = 1;
  }
  else {
    iVar1 = -1;
  }
  return iVar1;
}



uint8_t lyb_hash(lys_node *sibling,uint8_t collision_id)

{
  byte bVar1;
  uint32_t uVar2;
  lys_module *plVar3;
  size_t sVar4;
  uint8_t collision_id_local;
  lys_node *sibling_local;
  uint8_t hash;
  int ext_len;
  uint32_t full_hash;
  lys_module *mod;
  
  if ((collision_id < 4) && (sibling->hash[(int)(uint)collision_id] != '\0')) {
    bVar1 = sibling->hash[(int)(uint)collision_id];
  }
  else {
    plVar3 = lys_node_module(sibling);
    sVar4 = strlen(plVar3->name);
    uVar2 = dict_hash_multi(0,plVar3->name,sVar4);
    sVar4 = strlen(sibling->name);
    full_hash = dict_hash_multi(uVar2,sibling->name,sVar4);
    if (collision_id != '\0') {
      sVar4 = strlen(plVar3->name);
      if (sVar4 < collision_id) {
        sVar4 = strlen(plVar3->name);
        ext_len = (int)sVar4;
      }
      else {
        ext_len = (int)collision_id;
      }
      full_hash = dict_hash_multi(full_hash,plVar3->name,(long)ext_len);
    }
    uVar2 = dict_hash_multi(full_hash,(char *)0x0,0);
    bVar1 = (byte)uVar2 & (byte)(0x7f >> (collision_id & 0x1f)) |
            (byte)(0x80 >> (collision_id & 0x1f));
    if (collision_id < 4) {
      sibling->hash[(int)(uint)collision_id] = bVar1;
    }
  }
  return bVar1;
}



int lyb_has_schema_model(lys_node *sibling,lys_module **models,int mod_count)

{
  lys_module *plVar1;
  int mod_count_local;
  lys_module **models_local;
  lys_node *sibling_local;
  int i;
  lys_module *mod;
  
  plVar1 = lys_node_module(sibling);
  i = 0;
  while( true ) {
    if (mod_count <= i) {
      return 0;
    }
    if (plVar1 == models[i]) break;
    i = i + 1;
  }
  return 1;
}



size_t ly_strlen_utf8(char *str)

{
  size_t sVar1;
  char *str_local;
  size_t len;
  char *ptr;
  size_t clen;
  
  len = 0;
  sVar1 = strlen(str);
  ptr = str;
  for (; (*ptr != '\0' && (len < sVar1)); len = len + 1) {
    ptr = ptr + "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                [(int)(uint)(byte)*ptr];
  }
  return len;
}



uint ly_ctx_internal_modules_count(ly_ctx *ctx)

{
  uint uVar1;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_internal_modules_count");
  if (ctx == (ly_ctx *)0x0) {
    uVar1 = 0;
  }
  else {
    uVar1 = (uint)ctx->internal_module_count;
  }
  return uVar1;
}



ly_ctx * ly_ctx_new(char *search_dir,int options)

{
  int iVar1;
  ly_ctx *ctx_00;
  lys_module **pplVar2;
  char *__ptr;
  char *pcVar3;
  lys_module *plVar4;
  int options_local;
  char *search_dir_local;
  int rc;
  int i;
  char *dir;
  ly_ctx *ctx;
  char *search_dir_list;
  char *sep;
  lys_module *module;
  
  ly_log_dbg(0x20,"%s","ly_ctx_new");
  rc = 0;
  ctx_00 = (ly_ctx *)calloc(1,0x88);
  if (ctx_00 == (ly_ctx *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_new");
    return (ly_ctx *)0x0;
  }
  lydict_init((dict_table *)ctx_00);
  ly_load_plugins();
  iVar1 = pthread_key_create(&ctx_00->errlist_key,ly_err_free);
  if (iVar1 != 0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_ESYS,"pthread_key_create() in ly_ctx_new() failed");
    goto LAB_0010e4d2;
  }
  pplVar2 = (lys_module **)calloc(0x10,8);
  (ctx_00->models).list = pplVar2;
  if ((ctx_00->models).list == (lys_module **)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_new");
    free(ctx_00);
    return (ly_ctx *)0x0;
  }
  (ctx_00->models).flags = options;
  (ctx_00->models).used = 0;
  (ctx_00->models).size = 0x10;
  if (search_dir != (char *)0x0) {
    __ptr = strdup(search_dir);
    dir = __ptr;
    if (__ptr == (char *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_new");
      goto LAB_0010e4d2;
    }
    while ((pcVar3 = strchr(dir,0x3a), pcVar3 != (char *)0x0 && (rc == 0))) {
      *pcVar3 = '\0';
      rc = ly_ctx_set_searchdir(ctx_00,dir);
      dir = pcVar3 + 1;
    }
    if ((*dir != '\0') && (rc == 0)) {
      rc = ly_ctx_set_searchdir(ctx_00,dir);
    }
    free(__ptr);
    if (rc != 0) goto LAB_0010e4d2;
  }
  (ctx_00->models).module_set_id = 1;
  if ((options & 4U) == 0) {
    ctx_00->internal_module_count = '\x06';
  }
  else {
    ctx_00->internal_module_count = '\x04';
  }
  i = 0;
  while( true ) {
    if ((int)(uint)ctx_00->internal_module_count <= i) {
      return ctx_00;
    }
    plVar4 = lys_parse_mem(ctx_00,internal_modules[i].data,internal_modules[i].format);
    if (plVar4 == (lys_module *)0x0) break;
    plVar4->field_0x40 =
         plVar4->field_0x40 & 0x7f | (byte)((internal_modules[i].implemented & 1) << 7);
    i = i + 1;
  }
LAB_0010e4d2:
  ly_ctx_destroy(ctx_00,(_func_void_lys_node_ptr_void_ptr *)0x0);
  return (ly_ctx *)0x0;
}



int ly_ctx_new_yl_legacy(ly_ctx *ctx,lyd_node *yltree)

{
  long lVar1;
  lys_node *plVar2;
  int iVar3;
  ly_set *set_00;
  lys_module *module_00;
  long in_FS_OFFSET;
  lyd_node *yltree_local;
  ly_ctx *ctx_local;
  uint i;
  uint u;
  lyd_node *node;
  char *name;
  char *revision;
  ly_set *set;
  lyd_node *module;
  lys_module *mod;
  ly_set features;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  features.size = 0;
  features.number = 0;
  features.set.s = (lys_node **)0x0;
  set_00 = lyd_find_path(yltree,"/ietf-yang-library:yang-library/modules-state/module");
  if (set_00 == (ly_set *)0x0) {
    iVar3 = 1;
  }
  else {
    for (i = 0; i < set_00->number; i = i + 1) {
      plVar2 = (set_00->set).s[i];
      name = (char *)0x0;
      revision = (char *)0x0;
      ly_set_clean(&features);
      for (node = (lyd_node *)plVar2->parent; node != (lyd_node *)0x0; node = node->next) {
        iVar3 = strcmp(node->schema->name,"name");
        if (iVar3 == 0) {
          name = (char *)node->ht;
        }
        else {
          iVar3 = strcmp(node->schema->name,"revision");
          if (iVar3 == 0) {
            revision = (char *)node->ht;
          }
          else {
            iVar3 = strcmp(node->schema->name,"feature");
            if (iVar3 == 0) {
              ly_set_add(&features,node,1);
            }
            else {
              strcmp(node->schema->name,"conformance-type");
            }
          }
        }
      }
      module_00 = ly_ctx_load_module(ctx,name,revision);
      if (module_00 == (lys_module *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EINVAL,"Unable to load module specified by yang library data.");
        ly_set_free(set_00);
        iVar3 = 1;
        goto LAB_0010e723;
      }
      for (u = 0; u < features.number; u = u + 1) {
        lys_features_enable(module_00,*(char **)&features.set.s[u]->nodetype);
      }
    }
    ly_set_free(set_00);
    iVar3 = 0;
  }
LAB_0010e723:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ly_ctx * ly_ctx_new_yl_common
                   (char *search_dir,char *input,LYD_FORMAT format,int options,
                   _func_lyd_node_ptr_ly_ctx_ptr_char_ptr_LYD_FORMAT_int_varargs *parser_func)

{
  long lVar1;
  lys_node *plVar2;
  bool bVar3;
  int iVar4;
  lys_module *module_00;
  long in_FS_OFFSET;
  _func_lyd_node_ptr_ly_ctx_ptr_char_ptr_LYD_FORMAT_int_varargs *parser_func_local;
  int options_local;
  LYD_FORMAT format_local;
  char *input_local;
  char *search_dir_local;
  uint i;
  uint u;
  int err;
  lyd_node *node;
  char *name;
  char *revision;
  lyd_node *yltree;
  ly_ctx *ctx;
  ly_set *set;
  lyd_node *module;
  lys_module *mod;
  ly_set features;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  features.size = 0;
  features.number = 0;
  features.set.s = (lys_node **)0x0;
  yltree = (lyd_node *)0x0;
  set = (ly_set *)0x0;
  bVar3 = false;
  ctx = ly_ctx_new(search_dir,options);
  if (((ctx != (ly_ctx *)0x0) &&
      (yltree = (*parser_func)(ctx,input,format,0,0), yltree != (lyd_node *)0x0)) &&
     (set = lyd_find_path(yltree,"/ietf-yang-library:yang-library/module-set[1]/module"),
     set != (ly_set *)0x0)) {
    if (set->number != 0) {
      for (i = 0; i < set->number; i = i + 1) {
        plVar2 = (set->set).s[i];
        name = (char *)0x0;
        revision = (char *)0x0;
        ly_set_clean(&features);
        for (node = (lyd_node *)plVar2->parent; node != (lyd_node *)0x0; node = node->next) {
          iVar4 = strcmp(node->schema->name,"name");
          if (iVar4 == 0) {
            name = (char *)node->ht;
          }
          else {
            iVar4 = strcmp(node->schema->name,"revision");
            if (iVar4 == 0) {
              revision = (char *)node->ht;
            }
            else {
              iVar4 = strcmp(node->schema->name,"feature");
              if (iVar4 == 0) {
                ly_set_add(&features,node,1);
              }
            }
          }
        }
        module_00 = ly_ctx_load_module(ctx,name,revision);
        if (module_00 == (lys_module *)0x0) {
          ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,
                 "Unable to load module specified by yang library data.");
          goto LAB_0010e9df;
        }
        for (u = 0; u < features.number; u = u + 1) {
          lys_features_enable(module_00,*(char **)&features.set.s[u]->nodetype);
        }
      }
      goto LAB_0010e9e6;
    }
    iVar4 = ly_ctx_new_yl_legacy(ctx,yltree);
    if (iVar4 == 0) goto LAB_0010e9e6;
  }
LAB_0010e9df:
  bVar3 = true;
LAB_0010e9e6:
  if (yltree != (lyd_node *)0x0) {
    lyd_free_withsiblings(yltree);
  }
  if (set != (ly_set *)0x0) {
    ly_set_free(set);
  }
  if (bVar3) {
    ly_ctx_destroy(ctx,(_func_void_lys_node_ptr_void_ptr *)0x0);
    ctx = (ly_ctx *)0x0;
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ctx;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ly_ctx * ly_ctx_new_ylpath(char *search_dir,char *path,LYD_FORMAT format,int options)

{
  ly_ctx *plVar1;
  int options_local;
  LYD_FORMAT format_local;
  char *path_local;
  char *search_dir_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_new_ylpath");
  plVar1 = ly_ctx_new_yl_common(search_dir,path,format,options,lyd_parse_path);
  return plVar1;
}



ly_ctx * ly_ctx_new_ylmem(char *search_dir,char *data,LYD_FORMAT format,int options)

{
  ly_ctx *plVar1;
  int options_local;
  LYD_FORMAT format_local;
  char *data_local;
  char *search_dir_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_new_ylmem");
  plVar1 = ly_ctx_new_yl_common(search_dir,data,format,options,lyd_parse_mem);
  return plVar1;
}



void ly_ctx_set_option(ly_ctx *ctx,int options)

{
  int options_local;
  ly_ctx *ctx_local;
  
  if (ctx != (ly_ctx *)0x0) {
    (ctx->models).flags = (ctx->models).flags | options;
  }
  return;
}



void ly_ctx_unset_option(ly_ctx *ctx,int options)

{
  int options_local;
  ly_ctx *ctx_local;
  
  if (ctx != (ly_ctx *)0x0) {
    (ctx->models).flags = ~options & (ctx->models).flags;
  }
  return;
}



void ly_ctx_set_disable_searchdirs(ly_ctx *ctx)

{
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_set_disable_searchdirs");
  ly_ctx_set_option(ctx,8);
  return;
}



void ly_ctx_unset_disable_searchdirs(ly_ctx *ctx)

{
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_unset_disable_searchdirs");
  ly_ctx_unset_option(ctx,8);
  return;
}



void ly_ctx_set_disable_searchdir_cwd(ly_ctx *ctx)

{
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_set_disable_searchdir_cwd");
  ly_ctx_set_option(ctx,0x10);
  return;
}



void ly_ctx_unset_disable_searchdir_cwd(ly_ctx *ctx)

{
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_unset_disable_searchdir_cwd");
  ly_ctx_unset_option(ctx,0x10);
  return;
}



void ly_ctx_set_prefer_searchdirs(ly_ctx *ctx)

{
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_set_prefer_searchdirs");
  ly_ctx_set_option(ctx,0x20);
  return;
}



void ly_ctx_unset_prefer_searchdirs(ly_ctx *ctx)

{
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_unset_prefer_searchdirs");
  ly_ctx_unset_option(ctx,0x20);
  return;
}



void ly_ctx_set_allimplemented(ly_ctx *ctx)

{
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_set_allimplemented");
  ly_ctx_set_option(ctx,1);
  return;
}



void ly_ctx_unset_allimplemented(ly_ctx *ctx)

{
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_unset_allimplemented");
  ly_ctx_unset_option(ctx,1);
  return;
}



void ly_ctx_set_trusted(ly_ctx *ctx)

{
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_set_trusted");
  ly_ctx_set_option(ctx,2);
  return;
}



void ly_ctx_unset_trusted(ly_ctx *ctx)

{
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_unset_trusted");
  ly_ctx_unset_option(ctx,2);
  return;
}



int ly_ctx_get_options(ly_ctx *ctx)

{
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_options");
  return (ctx->models).flags;
}



int ly_ctx_set_searchdir(ly_ctx *ctx,char *search_dir)

{
  int iVar1;
  int *piVar2;
  char *pcVar3;
  char **ppcVar4;
  char *search_dir_local;
  ly_ctx *ctx_local;
  int index;
  int rc;
  char *new_dir;
  void *r;
  
  ly_log_dbg(0x20,"%s","ly_ctx_set_searchdir");
  rc = 1;
  if (ctx == (ly_ctx *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_set_searchdir");
    return 1;
  }
  if (search_dir == (char *)0x0) {
    return 0;
  }
  iVar1 = access(search_dir,5);
  if (iVar1 != 0) {
    piVar2 = __errno_location();
    pcVar3 = strerror(*piVar2);
    ly_log(ctx,LY_LLERR,LY_ESYS,"Unable to use search directory \"%s\" (%s)",search_dir,pcVar3);
    return 1;
  }
  new_dir = realpath(search_dir,(char *)0x0);
  if (new_dir == (char *)0x0) {
    piVar2 = __errno_location();
    pcVar3 = strerror(*piVar2);
    ly_log(ctx,LY_LLERR,LY_ESYS,"realpath() call failed (%s).",pcVar3);
  }
  else {
    if ((ctx->models).search_paths == (char **)0x0) {
      ppcVar4 = (char **)malloc(0x10);
      (ctx->models).search_paths = ppcVar4;
      if ((ctx->models).search_paths == (char **)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_set_searchdir");
        goto LAB_0010f0d0;
      }
      index = 0;
    }
    else {
      for (index = 0; (ctx->models).search_paths[index] != (char *)0x0; index = index + 1) {
        iVar1 = strcmp(new_dir,(ctx->models).search_paths[index]);
        if (iVar1 == 0) goto LAB_0010f0c0;
      }
      ppcVar4 = (char **)realloc((ctx->models).search_paths,(long)(index + 2) * 8);
      if (ppcVar4 == (char **)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_set_searchdir");
        goto LAB_0010f0d0;
      }
      (ctx->models).search_paths = ppcVar4;
    }
    (ctx->models).search_paths[index] = new_dir;
    new_dir = (char *)0x0;
    (ctx->models).search_paths[(long)index + 1] = (char *)0x0;
LAB_0010f0c0:
    rc = 0;
  }
LAB_0010f0d0:
  free(new_dir);
  return rc;
}



char ** ly_ctx_get_searchdirs(ly_ctx *ctx)

{
  char **ppcVar1;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_searchdirs");
  if (ctx == (ly_ctx *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_get_searchdirs");
    ppcVar1 = (char **)0x0;
  }
  else {
    ppcVar1 = (ctx->models).search_paths;
  }
  return ppcVar1;
}



void ly_ctx_unset_searchdirs(ly_ctx *ctx,int index)

{
  int index_local;
  ly_ctx *ctx_local;
  int i;
  
  ly_log_dbg(0x20,"%s","ly_ctx_unset_searchdirs");
  if ((ctx->models).search_paths != (char **)0x0) {
    for (i = 0; (ctx->models).search_paths[i] != (char *)0x0; i = i + 1) {
      if ((index < 0) || (index == i)) {
        free((ctx->models).search_paths[i]);
        (ctx->models).search_paths[i] = (char *)0x0;
      }
      else if (index < i) {
        (ctx->models).search_paths[(long)i + -1] = (ctx->models).search_paths[i];
        (ctx->models).search_paths[i] = (char *)0x0;
      }
    }
    if ((index < 0) || (*(ctx->models).search_paths == (char *)0x0)) {
      free((ctx->models).search_paths);
      (ctx->models).search_paths = (char **)0x0;
    }
  }
  return;
}



void ly_ctx_destroy(ly_ctx *ctx,_func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  ly_ctx *ctx_local;
  int i;
  
  ly_log_dbg(0x20,"%s","ly_ctx_destroy");
  if (ctx != (ly_ctx *)0x0) {
    while (0 < (ctx->models).used) {
      lys_sub_module_remove_devs_augs((ctx->models).list[(long)(ctx->models).used + -1]);
      lys_free((ctx->models).list[(long)(ctx->models).used + -1],private_destructor,1,0);
      (ctx->models).used = (ctx->models).used + -1;
    }
    if ((ctx->models).search_paths != (char **)0x0) {
      for (i = 0; (ctx->models).search_paths[i] != (char *)0x0; i = i + 1) {
        free((ctx->models).search_paths[i]);
      }
      free((ctx->models).search_paths);
    }
    free((ctx->models).list);
    ly_err_clean(ctx,(ly_err_item *)0x0);
    pthread_key_delete(ctx->errlist_key);
    lydict_clean(&ctx->dict);
    ly_clean_plugins();
    free(ctx);
  }
  return;
}



lys_submodule * ly_ctx_get_submodule2(lys_module *main_module,char *submodule)

{
  lys_submodule *plVar1;
  int iVar2;
  char *submodule_local;
  lys_module *main_module_local;
  int i;
  lys_submodule *result;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_submodule2");
  if ((main_module == (lys_module *)0x0) || (submodule == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_get_submodule2");
  }
  else {
    for (i = 0; i < (int)(uint)main_module->inc_size; i = i + 1) {
      plVar1 = main_module->inc[i].submodule;
      iVar2 = ly_strequal_(submodule,plVar1->name);
      if (iVar2 != 0) {
        return plVar1;
      }
    }
  }
  return (lys_submodule *)0x0;
}



lys_submodule *
ly_ctx_get_submodule(ly_ctx *ctx,char *module,char *revision,char *submodule,char *sub_revision)

{
  int iVar1;
  lys_submodule *plVar2;
  long in_FS_OFFSET;
  char *sub_revision_local;
  char *submodule_local;
  char *revision_local;
  char *module_local;
  ly_ctx *ctx_local;
  uint32_t idx;
  lys_submodule *ret;
  lys_module *mainmod;
  lys_submodule *submod;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","ly_ctx_get_submodule");
  ret = (lys_submodule *)0x0;
  idx = 0;
  if (((ctx == (ly_ctx *)0x0) || (submodule == (char *)0x0)) ||
     ((plVar2 = ret, revision != (char *)0x0 && (module == (char *)0x0)))) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_get_submodule");
    plVar2 = (lys_submodule *)0x0;
  }
  else {
    do {
      while( true ) {
        do {
          ret = plVar2;
          mainmod = ly_ctx_get_module_iter(ctx,&idx);
          plVar2 = ret;
          if (mainmod == (lys_module *)0x0) goto LAB_0010f6d3;
        } while (((module != (char *)0x0) &&
                 (iVar1 = strcmp(mainmod->name,module), plVar2 = ret, iVar1 != 0)) ||
                (((revision != (char *)0x0 &&
                  ((plVar2 = ret, mainmod->rev == (lys_revision *)0x0 ||
                   (iVar1 = strcmp(revision,mainmod->rev->date), plVar2 = ret, iVar1 != 0)))) ||
                 (submod = ly_ctx_get_submodule2(mainmod,submodule), plVar2 = ret,
                 submod == (lys_submodule *)0x0))));
        if (sub_revision != (char *)0x0) break;
        plVar2 = submod;
        if (((ret != (lys_submodule *)0x0) && (plVar2 = ret, submod->rev != (lys_revision *)0x0)) &&
           ((ret->rev == (lys_revision *)0x0 ||
            (iVar1 = strcmp(submod->rev->date,ret->rev->date), plVar2 = ret, 0 < iVar1)))) {
          ret = submod;
          plVar2 = ret;
        }
      }
    } while ((submod->rev == (lys_revision *)0x0) ||
            (iVar1 = strcmp(sub_revision,submod->rev->date), plVar2 = ret, iVar1 != 0));
    ret = submod;
    plVar2 = submod;
  }
LAB_0010f6d3:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_module *
ly_ctx_get_module_by
          (ly_ctx *ctx,char *key,size_t key_len,int offset,char *revision,int with_disabled,
          int implemented)

{
  char *__s2;
  int iVar1;
  char *revision_local;
  int with_disabled_local;
  int offset_local;
  size_t key_len_local;
  char *key_local;
  ly_ctx *ctx_local;
  int i;
  lys_module *result;
  char *val;
  
  result = (lys_module *)0x0;
  if ((ctx == (ly_ctx *)0x0) || (key == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_get_module_by");
    result = (lys_module *)0x0;
  }
  else {
    for (i = 0; i < (ctx->models).used; i = i + 1) {
      if (((((with_disabled != 0) || (((ctx->models).list[i]->field_0x40 & 0x40) == 0)) &&
           (__s2 = *(char **)((ctx->models).list[i]->padding2 + (long)offset + -0x42),
           (ctx->models).list[i] != (lys_module *)0x0)) &&
          ((key_len != 0 || (iVar1 = strcmp(key,__s2), iVar1 == 0)))) &&
         ((key_len == 0 ||
          ((iVar1 = strncmp(key,__s2,key_len), iVar1 == 0 && (__s2[key_len] == '\0')))))) {
        if (revision == (char *)0x0) {
          if ((result == (lys_module *)0x0) ||
             (((ctx->models).list[i]->rev_size != '\0' &&
              ((result->rev_size == '\0' ||
               (iVar1 = strcmp((ctx->models).list[i]->rev->date,result->rev->date), -1 < iVar1))))))
          {
            if (implemented == 0) {
              result = (ctx->models).list[i];
            }
            else if (((ctx->models).list[i]->field_0x40 & 0x80) != 0) {
              return (ctx->models).list[i];
            }
          }
        }
        else if (((ctx->models).list[i]->rev_size != '\0') &&
                (iVar1 = strcmp(revision,(ctx->models).list[i]->rev->date), iVar1 == 0)) {
          return (ctx->models).list[i];
        }
      }
    }
  }
  return result;
}



lys_module * ly_ctx_get_module_by_ns(ly_ctx *ctx,char *ns,char *revision,int implemented)

{
  lys_module *plVar1;
  int implemented_local;
  char *revision_local;
  char *ns_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_module_by_ns");
  plVar1 = ly_ctx_get_module_by(ctx,ns,0,0xb0,revision,0,implemented);
  return plVar1;
}



lys_module * ly_ctx_get_module(ly_ctx *ctx,char *name,char *revision,int implemented)

{
  lys_module *plVar1;
  int implemented_local;
  char *revision_local;
  char *name_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_module");
  plVar1 = ly_ctx_get_module_by(ctx,name,0,8,revision,0,implemented);
  return plVar1;
}



lys_module *
ly_ctx_nget_module(ly_ctx *ctx,char *name,size_t name_len,char *revision,int implemented)

{
  lys_module *plVar1;
  int implemented_local;
  char *revision_local;
  size_t name_len_local;
  char *name_local;
  ly_ctx *ctx_local;
  
  plVar1 = ly_ctx_get_module_by(ctx,name,name_len,8,revision,0,implemented);
  return plVar1;
}



lys_module * ly_ctx_get_module_older(ly_ctx *ctx,lys_module *module)

{
  lys_module *plVar1;
  lys_module *plVar2;
  int iVar3;
  lys_module *module_local;
  ly_ctx *ctx_local;
  int i;
  lys_module *result;
  lys_module *iter;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_module_older");
  result = (lys_module *)0x0;
  if (((ctx == (ly_ctx *)0x0) || (module == (lys_module *)0x0)) || (module->rev_size == '\0')) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_get_module_older");
    result = (lys_module *)0x0;
  }
  else {
    for (i = 0; i < (ctx->models).used; i = i + 1) {
      plVar1 = (ctx->models).list[i];
      plVar2 = result;
      if ((((((plVar1->field_0x40 & 0x40) == 0) && (plVar1 != module)) &&
           ((plVar1->rev_size != '\0' &&
            ((iVar3 = ly_strequal_(module->name,plVar1->name), iVar3 != 0 &&
             (iVar3 = strcmp(plVar1->rev->date,module->rev->date), iVar3 < 0)))))) &&
          (plVar2 = plVar1, result != (lys_module *)0x0)) &&
         (iVar3 = strcmp(plVar1->rev->date,result->rev->date), plVar2 = result, 0 < iVar3)) {
        plVar2 = plVar1;
      }
      result = plVar2;
    }
  }
  return result;
}



void ly_ctx_set_module_imp_clb(ly_ctx *ctx,ly_module_imp_clb clb,void *user_data)

{
  void *user_data_local;
  ly_module_imp_clb clb_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_set_module_imp_clb");
  if (ctx == (ly_ctx *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_set_module_imp_clb")
    ;
  }
  else {
    ctx->imp_clb = clb;
    ctx->imp_clb_data = user_data;
  }
  return;
}



ly_module_imp_clb ly_ctx_get_module_imp_clb(ly_ctx *ctx,void **user_data)

{
  ly_module_imp_clb p_Var1;
  void **user_data_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_module_imp_clb");
  if (ctx == (ly_ctx *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_get_module_imp_clb")
    ;
    p_Var1 = (ly_module_imp_clb)0x0;
  }
  else {
    if (user_data != (void **)0x0) {
      *user_data = ctx->imp_clb_data;
    }
    p_Var1 = ctx->imp_clb;
  }
  return p_Var1;
}



void ly_ctx_set_module_data_clb(ly_ctx *ctx,ly_module_data_clb clb,void *user_data)

{
  void *user_data_local;
  ly_module_data_clb clb_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_set_module_data_clb");
  if (ctx == (ly_ctx *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_set_module_data_clb"
          );
  }
  else {
    ctx->data_clb = clb;
    ctx->data_clb_data = user_data;
  }
  return;
}



ly_module_data_clb ly_ctx_get_module_data_clb(ly_ctx *ctx,void **user_data)

{
  ly_module_data_clb p_Var1;
  void **user_data_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_module_data_clb");
  if (ctx == (ly_ctx *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_get_module_data_clb"
          );
    p_Var1 = (ly_module_data_clb)0x0;
  }
  else {
    if (user_data != (void **)0x0) {
      *user_data = ctx->data_clb_data;
    }
    p_Var1 = ctx->data_clb;
  }
  return p_Var1;
}



// WARNING: Variable defined which should be unmapped: result

lys_module *
ly_ctx_load_localfile
          (ly_ctx *ctx,lys_module *module,char *name,char *revision,int implement,
          unres_schema *unres)

{
  uint uVar1;
  long lVar2;
  int iVar3;
  char **searchpaths;
  size_t __n;
  int *piVar4;
  char *pcVar5;
  lys_revision *plVar6;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  int implement_local;
  char *revision_local;
  char *name_local;
  lys_module *module_local;
  ly_ctx *ctx_local;
  LYS_INFORMAT format;
  int i;
  int fd;
  char *filepath;
  char *filename;
  lys_module *result;
  char *dot;
  char *rev;
  size_t len;
  char rpath [4096];
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  filepath = (char *)0x0;
  result = (lys_module *)0x0;
  uVar1 = (ctx->models).flags;
  searchpaths = ly_ctx_get_searchdirs(ctx);
  iVar3 = lys_search_localfile
                    (searchpaths,(uint)((uVar1 & 0x10) == 0),name,revision,&filepath,&format);
  if (iVar3 == 0) {
    if (filepath == (char *)0x0) {
      if ((module == (lys_module *)0x0) && (revision == (char *)0x0)) {
        result = ly_ctx_get_module(ctx,name,(char *)0x0,0);
      }
      if (result == (lys_module *)0x0) {
        ly_log(ctx,LY_LLERR,LY_ESYS,"Data model \"%s\" not found.",name);
      }
      goto LAB_00110519;
    }
    ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,"Loading schema from \"%s\" file.",filepath);
    dot = strrchr(filepath,0x2e);
    dot[1] = '\0';
    if (revision == (char *)0x0) {
      for (i = 0; i < (ctx->models).used; i = i + 1) {
        if (((ctx->models).list[i]->filepath != (char *)0x0) &&
           (iVar3 = strcmp(name,(ctx->models).list[i]->name), iVar3 == 0)) {
          __n = strlen(filepath);
          iVar3 = strncmp(filepath,(ctx->models).list[i]->filepath,__n);
          if (iVar3 == 0) {
            result = (ctx->models).list[i];
            if ((implement == 0) || ((result->field_0x40 & 0x80) != 0)) {
              if ((result->field_0x40 & 0x40) != 0) {
                lys_set_enabled(result);
              }
            }
            else {
              iVar3 = lys_set_implemented(result);
              if (iVar3 != 0) {
                result = (lys_module *)0x0;
              }
            }
            goto LAB_00110503;
          }
        }
      }
    }
    dot[1] = 'y';
    fd = open(filepath,0);
    if (fd < 0) {
      piVar4 = __errno_location();
      pcVar5 = strerror(*piVar4);
      ly_log(ctx,LY_LLERR,LY_ESYS,"Unable to open data model file \"%s\" (%s).",filepath,pcVar5);
    }
    else {
      if (module == (lys_module *)0x0) {
        result = lys_parse_fd_(ctx,fd,format,revision,implement);
      }
      else {
        result = (lys_module *)lys_sub_parse_fd(module,fd,format,unres);
      }
      close(fd);
      if (result != (lys_module *)0x0) {
        pcVar5 = strrchr(filepath,0x2f);
        if (pcVar5 == (char *)0x0) {
          filename = filepath;
        }
        else {
          filename = pcVar5 + 1;
        }
        rev = strchr(filename,0x40);
        len = strlen(result->name);
        iVar3 = strncmp(filename,result->name,len);
        if (((iVar3 != 0) || ((rev != (char *)0x0 && (rev != filename + len)))) ||
           ((rev == (char *)0x0 && (dot != filename + len)))) {
          ly_log(ctx,LY_LLWRN,LY_SUCCESS,"File name \"%s\" does not match module name \"%s\".",
                 filename,result->name);
        }
        if (rev != (char *)0x0) {
          rev = rev + 1;
          len = (long)dot - (long)rev;
          if (((result->rev_size == '\0') || (len != 10)) ||
             (iVar3 = strncmp(result->rev->date,rev,10), iVar3 != 0)) {
            if (result->rev_size == '\0') {
              plVar6 = (lys_revision *)&DAT_0020caa0;
            }
            else {
              plVar6 = result->rev;
            }
            ly_log(ctx,LY_LLWRN,LY_SUCCESS,"File name \"%s\" does not match module revision \"%s\"."
                   ,filename,plVar6);
          }
        }
        if (result->filepath == (char *)0x0) {
          pcVar5 = realpath(filepath,rpath);
          if (pcVar5 == (char *)0x0) {
            pcVar5 = lydict_insert(ctx,filepath,0);
            result->filepath = pcVar5;
          }
          else {
            pcVar5 = lydict_insert(ctx,rpath,0);
            result->filepath = pcVar5;
          }
        }
      }
    }
  }
LAB_00110503:
  free(filepath);
LAB_00110519:
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return result;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_module *
ly_ctx_load_sub_module_clb
          (ly_ctx *ctx,lys_module *module,char *name,char *revision,int implement,
          unres_schema *unres)

{
  LY_ERR *pLVar1;
  lys_module *plVar2;
  lys_revision *plVar3;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  int implement_local;
  char *revision_local;
  char *name_local;
  lys_module *module_local;
  ly_ctx *ctx_local;
  LYS_INFORMAT format;
  _func_void_void_ptr_void_ptr *module_data_free;
  lys_module *mod;
  char *module_data;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  mod = (lys_module *)0x0;
  module_data = (char *)0x0;
  format = LYS_IN_UNKNOWN;
  module_data_free = (_func_void_void_ptr_void_ptr *)0x0;
  pLVar1 = ly_errno_glob_address();
  *pLVar1 = LY_SUCCESS;
  if (module == (lys_module *)0x0) {
    module_data = (*ctx->imp_clb)(name,revision,(char *)0x0,(char *)0x0,ctx->imp_clb_data,&format,
                                  &module_data_free);
  }
  else {
    mod = lys_main_module(module);
    if (mod->rev_size == '\0') {
      plVar3 = (lys_revision *)0x0;
    }
    else {
      plVar3 = mod->rev;
    }
    module_data = (*ctx->imp_clb)(mod->name,plVar3->date,name,revision,ctx->imp_clb_data,&format,
                                  &module_data_free);
  }
  if ((module_data == (char *)0x0) && (pLVar1 = ly_errno_glob_address(), *pLVar1 != LY_SUCCESS)) {
    pLVar1 = ly_errno_glob_address();
    ly_log(ctx,LY_LLERR,*pLVar1,"User module retrieval callback failed!");
    plVar2 = (lys_module *)0x0;
  }
  else {
    plVar2 = mod;
    if (module_data != (char *)0x0) {
      if (module == (lys_module *)0x0) {
        mod = lys_parse_mem_(ctx,module_data,format,(char *)0x0,0,implement);
      }
      else {
        mod = (lys_module *)lys_sub_parse_mem(module,module_data,format,unres);
      }
      plVar2 = mod;
      if (module_data_free != (_func_void_void_ptr_void_ptr *)0x0) {
        (*module_data_free)(module_data,ctx->imp_clb_data);
        plVar2 = mod;
      }
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Variable defined which should be unmapped: mod

lys_module *
ly_ctx_load_sub_module
          (ly_ctx *ctx,lys_module *module,char *name,char *revision,int implement,
          unres_schema *unres)

{
  lys_module *plVar1;
  int iVar2;
  unres_schema *unres_local;
  int implement_local;
  char *revision_local;
  char *name_local;
  lys_module *module_local;
  ly_ctx *ctx_local;
  int i;
  lys_module *mod;
  lys_module *latest_mod;
  
  mod = (lys_module *)0x0;
  latest_mod = (lys_module *)0x0;
  if (module == (lys_module *)0x0) {
    for (i = 0; mod = (lys_module *)0x0, i < (ctx->models).used; i = i + 1) {
      mod = (ctx->models).list[i];
      iVar2 = ly_strequal_(name,mod->name);
      if (iVar2 != 0) {
        plVar1 = mod;
        if ((((latest_mod != (lys_module *)0x0) && (plVar1 = latest_mod, mod->rev_size != '\0')) &&
            (latest_mod->rev_size != '\0')) &&
           (iVar2 = strcmp(mod->rev->date,latest_mod->rev->date), 0 < iVar2)) {
          plVar1 = mod;
        }
        latest_mod = plVar1;
        if ((((revision != (char *)0x0) && (mod->rev_size != '\0')) &&
            (iVar2 = strcmp(revision,mod->rev->date), iVar2 == 0)) ||
           (((revision == (char *)0x0 && ((mod->field_0x41 & 1) != 0)) ||
            ((implement != 0 && (((mod->field_0x40 & 0x80) != 0 && (revision == (char *)0x0))))))))
        break;
      }
    }
    if (mod != (lys_module *)0x0) {
      if ((mod->field_0x40 & 0x40) != 0) {
        lys_set_enabled(mod);
      }
      if (implement == 0) {
        return mod;
      }
      iVar2 = lys_set_implemented(mod);
      if (iVar2 == 0) {
        return mod;
      }
      return (lys_module *)0x0;
    }
  }
  if (ctx->imp_clb == (ly_module_imp_clb)0x0) goto LAB_00110937;
  if (((ctx->models).flags & 0x20U) != 0) goto LAB_00110937;
  while( true ) {
    if (ctx->imp_clb != (ly_module_imp_clb)0x0) {
      mod = ly_ctx_load_sub_module_clb(ctx,module,name,revision,implement,unres);
    }
    if ((mod != (lys_module *)0x0) || (((ctx->models).flags & 0x20U) != 0)) break;
LAB_00110937:
    if (((ctx->models).flags & 8U) == 0) {
      mod = ly_ctx_load_localfile(ctx,module,name,revision,implement,unres);
    }
    if ((mod != (lys_module *)0x0) || (((ctx->models).flags & 0x20U) == 0)) break;
  }
  if (((mod != (lys_module *)0x0) &&
      (((revision == (char *)0x0 && (latest_mod != (lys_module *)0x0)) && (mod->rev_size != '\0'))))
     && ((latest_mod->rev_size != '\0' &&
         (iVar2 = strcmp(mod->rev->date,latest_mod->rev->date), iVar2 < 0)))) {
    lys_free(mod,(_func_void_lys_node_ptr_void_ptr *)0x0,1,1);
    mod = (lys_module *)0x0;
  }
  if ((mod == (lys_module *)0x0) && (latest_mod != (lys_module *)0x0)) {
    mod = latest_mod;
  }
  if ((revision == (char *)0x0) && (mod != (lys_module *)0x0)) {
    mod->field_0x41 = mod->field_0x41 | 1;
  }
  return mod;
}



lys_module * ly_ctx_load_module(ly_ctx *ctx,char *name,char *revision)

{
  lys_module *plVar1;
  char *revision_local;
  char *name_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_load_module");
  if ((ctx == (ly_ctx *)0x0) || (name == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_load_module");
    plVar1 = (lys_module *)0x0;
  }
  else {
    if ((revision == (char *)0x0) || (*revision == '\0')) {
      revision = (char *)0x0;
    }
    plVar1 = ly_ctx_load_sub_module(ctx,(lys_module *)0x0,name,revision,1,(unres_schema *)0x0);
  }
  return plVar1;
}



void ctx_modules_undo_backlinks(ly_ctx *ctx,ly_set *mods)

{
  lys_module *plVar1;
  int iVar2;
  ly_set *mods_local;
  ly_ctx *ctx_local;
  uint8_t j;
  int o;
  uint u;
  uint v;
  lys_node *elem;
  lys_node *next;
  lys_module *mod;
  lys_node_leaf *leaf;
  
  for (o = ctx->internal_module_count - 1; o < (ctx->models).used; o = o + 1) {
    plVar1 = (ctx->models).list[o];
    for (j = '\0'; j < plVar1->features_size; j = j + '\x01') {
      if (plVar1->features[j].depfeatures != (ly_set *)0x0) {
        for (v = 0; v < (plVar1->features[j].depfeatures)->number; v = v + 1) {
          if ((mods == (ly_set *)0x0) ||
             (iVar2 = ly_set_contains(mods,((plVar1->features[j].depfeatures)->set).s[v]->module),
             iVar2 != -1)) {
            ly_set_rm_index(plVar1->features[j].depfeatures,v);
            v = v - 1;
          }
        }
        if ((plVar1->features[j].depfeatures)->number == 0) {
          ly_set_free(plVar1->features[j].depfeatures);
          plVar1->features[j].depfeatures = (ly_set *)0x0;
        }
      }
    }
    for (u = 0; u < plVar1->ident_size; u = u + 1) {
      if (plVar1->ident[u].der != (ly_set *)0x0) {
        for (v = 0; v < (plVar1->ident[u].der)->number; v = v + 1) {
          if ((mods == (ly_set *)0x0) ||
             (iVar2 = ly_set_contains(mods,((plVar1->ident[u].der)->set).s[v]->module), iVar2 != -1)
             ) {
            ly_set_rm_index(plVar1->ident[u].der,v);
            v = v - 1;
          }
        }
        if ((plVar1->ident[u].der)->number == 0) {
          ly_set_free(plVar1->ident[u].der);
          plVar1->ident[u].der = (ly_set *)0x0;
        }
      }
    }
    elem = plVar1->data;
    while (elem != (lys_node *)0x0) {
      if (((elem->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) &&
         (elem->child != (lys_node *)0x0)) {
        if (mods == (ly_set *)0x0) {
          ly_set_free((ly_set *)elem->child);
          elem->child = (lys_node *)0x0;
        }
        else {
          for (v = 0; v < *(uint *)((long)&elem->child->name + 4); v = v + 1) {
            iVar2 = ly_set_contains(mods,*(void **)(*(long *)(elem->child->dsc + (ulong)v * 8) +
                                                   0x30));
            if (iVar2 != -1) {
              ly_set_rm_index((ly_set *)elem->child,v);
              v = v - 1;
            }
          }
          if (*(int *)((long)&elem->child->name + 4) == 0) {
            ly_set_free((ly_set *)elem->child);
            elem->child = (lys_node *)0x0;
          }
        }
      }
      next = elem->child;
      if ((elem->nodetype & 0x882c) != LYS_UNKNOWN) {
        next = (lys_node *)0x0;
      }
      if (next == (lys_node *)0x0) {
        next = elem->next;
      }
      while ((next == (lys_node *)0x0 && (elem = lys_parent(elem), elem != (lys_node *)0x0))) {
        next = elem->next;
      }
      elem = next;
    }
  }
  return;
}



int ctx_modules_redo_backlinks(ly_set *mods)

{
  uint uVar1;
  ly_set *plVar2;
  lys_node *plVar3;
  lys_node *plVar4;
  long in_FS_OFFSET;
  ly_set *mods_local;
  uint s;
  uint i;
  uint j;
  uint k;
  lys_node *next;
  lys_node *elem;
  lys_module *mod;
  lys_type *type;
  lys_feature *feat;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  i = 0;
  do {
    if (mods->number <= i) {
      if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
        return 0;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    mod = (lys_module *)(mods->set).s[i];
    if ((mod->field_0x40 & 0x80) != 0) {
      for (j = 0; j < mod->ident_size; j = j + 1) {
        for (k = 0; k < mod->ident[j].base_size; k = k + 1) {
          resolve_identity_backlink_update(mod->ident + j,mod->ident[j].base[k]);
        }
      }
    }
    for (j = 0; j < mod->features_size; j = j + 1) {
      for (k = 0; k < mod->features[j].iffeature_size; k = k + 1) {
        resolve_iffeature_getsizes(mod->features[j].iffeature + k,(uint *)0x0,&s);
        while (uVar1 = s - 1, s != 0) {
          feat = mod->features[j].iffeature[k].features[uVar1];
          s = uVar1;
          if (feat->depfeatures == (ly_set *)0x0) {
            plVar2 = ly_set_new();
            feat->depfeatures = plVar2;
          }
          ly_set_add(feat->depfeatures,mod->features + j,1);
        }
        s = uVar1;
      }
    }
    next = mod->data;
LAB_001112c9:
    elem = next;
    if (next != (lys_node *)0x0) {
      if (next->nodetype == LYS_GROUPING) {
LAB_00111255:
        if (elem == mod->data) goto LAB_001112d7;
        next = elem->next;
      }
      else {
        if (((next->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) &&
           (type = (lys_type *)&next[1].ref, *(int *)type == 9)) {
          lys_leaf_add_leafref_target(*(lys_node_leaf **)&next[1].nodetype,next);
        }
        next = elem->child;
        if ((elem->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) != LYS_UNKNOWN) {
          next = (lys_node *)0x0;
        }
        if (next == (lys_node *)0x0) goto LAB_00111255;
      }
      while (next == (lys_node *)0x0) {
        elem = lys_parent(elem);
        plVar3 = lys_parent(elem);
        plVar4 = lys_parent(mod->data);
        if (plVar3 == plVar4) break;
        next = elem->next;
      }
      goto LAB_001112c9;
    }
LAB_001112d7:
    i = i + 1;
  } while( true );
}



int lys_set_disabled(lys_module *module)

{
  ly_ctx *ctx_00;
  lys_module *node;
  lys_node *plVar1;
  long lVar2;
  bool bVar3;
  int iVar4;
  ly_set *set;
  lys_module *module_local;
  uint8_t j;
  uint8_t imported;
  int i;
  int o;
  uint u;
  uint v;
  lys_module *mod;
  ly_ctx *ctx;
  ly_set *mods;
  
  ly_log_dbg(0x20,"%s","lys_set_disabled");
  if (module == (lys_module *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_set_disabled");
    iVar4 = 1;
  }
  else {
    if ((module->field_0x40 & 0x40) == 0) {
      ctx_00 = module->ctx;
      for (i = 0; i < (int)(uint)ctx_00->internal_module_count; i = i + 1) {
        if (module == (ctx_00->models).list[i]) {
          ly_log(ctx_00,LY_LLERR,LY_EINVAL,"Internal module \"%s\" cannot be disabled.",module->name
                );
          return 1;
        }
      }
      module->field_0x40 = module->field_0x40 | 0x40;
      set = ly_set_new();
      ly_set_add(set,module,0);
LAB_00111440:
      i = (int)ctx_00->internal_module_count;
      do {
        if ((ctx_00->models).used <= i) {
          for (u = 0; u < set->number; u = u + 1) {
            *(byte *)&(set->set).s[u]->parent = *(byte *)&(set->set).s[u]->parent & 0xbf;
          }
          ctx_modules_undo_backlinks(ctx_00,set);
          u = set->number;
          while (u != 0) {
            lys_sub_module_remove_devs_augs((lys_module *)(set->set).s[u - 1]);
            u = u - 1;
          }
          for (u = 0; u < set->number; u = u + 1) {
            plVar1 = (set->set).s[u];
            *(byte *)&plVar1->parent = *(byte *)&plVar1->parent | 0x40;
            for (v = 0; v < *(byte *)((long)&plVar1->parent + 6); v = v + 1) {
              lVar2 = *(long *)((ulong)v * 0x30 + *(long *)plVar1->hash);
              *(byte *)(lVar2 + 0x40) = *(byte *)(lVar2 + 0x40) | 0x40;
            }
          }
          ly_set_free(set);
          (ctx_00->models).module_set_id = (ctx_00->models).module_set_id + 1;
          return 0;
        }
        node = (ctx_00->models).list[i];
        if ((node->field_0x40 & 0x40) == 0) {
          for (j = '\0'; j < node->imp_size; j = j + '\x01') {
            for (u = 0; u < set->number; u = u + 1) {
              if (node->imp[j].module == (lys_module *)(set->set).s[u]) {
                node->field_0x40 = node->field_0x40 | 0x40;
                ly_set_add(set,node,0);
                goto LAB_00111440;
              }
            }
          }
          if ((node->field_0x40 & 0x80) == 0) {
            bVar3 = false;
            for (o = (int)ctx_00->internal_module_count; o < (ctx_00->models).used; o = o + 1) {
              if (((ctx_00->models).list[o]->field_0x40 & 0x40) == 0) {
                for (j = '\0'; j < (ctx_00->models).list[o]->imp_size; j = j + '\x01') {
                  if (node == (ctx_00->models).list[o]->imp[j].module) {
                    bVar3 = true;
                    goto LAB_00111600;
                  }
                }
              }
            }
LAB_00111600:
            if (!bVar3) {
              node->field_0x40 = node->field_0x40 | 0x40;
              ly_set_add(set,node,0);
              if (node->imp_size != '\0') goto LAB_00111440;
            }
          }
        }
        i = i + 1;
      } while( true );
    }
    iVar4 = 0;
  }
  return iVar4;
}



void lys_set_enabled_(ly_set *mods,lys_module *mod)

{
  lys_submodule *plVar1;
  lys_module *mod_local;
  ly_set *mods_local;
  uint i;
  
  ly_set_add(mods,mod,0);
  mod->field_0x40 = mod->field_0x40 & 0xbf;
  for (i = 0; i < mod->inc_size; i = i + 1) {
    plVar1 = mod->inc[i].submodule;
    plVar1->field_0x40 = plVar1->field_0x40 & 0xbf;
  }
  for (i = 0; i < mod->imp_size; i = i + 1) {
    if (((mod->imp[i].module)->field_0x40 & 0x40) != 0) {
      lys_set_enabled_(mods,mod->imp[i].module);
    }
  }
  return;
}



int lys_set_enabled(lys_module *module)

{
  ly_ctx *ctx_00;
  lys_module *node;
  lys_submodule *plVar1;
  int iVar2;
  ly_set *mods_00;
  ly_set *set;
  lys_module *module_local;
  int i;
  uint u;
  uint v;
  uint w;
  lys_module *mod;
  ly_ctx *ctx;
  ly_set *mods;
  ly_set *disabled;
  
  ly_log_dbg(0x20,"%s","lys_set_enabled");
  if (module == (lys_module *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_set_enabled");
    iVar2 = 1;
  }
  else {
    if ((module->field_0x40 & 0x40) != 0) {
      ctx_00 = module->ctx;
      for (i = 0; i < (int)(uint)ctx_00->internal_module_count; i = i + 1) {
        if (module == (ctx_00->models).list[i]) {
          ly_log(ctx_00,LY_LLERR,LY_EINVAL,"Internal module \"%s\" cannot be removed.",module->name)
          ;
          return 1;
        }
      }
      mods_00 = ly_set_new();
      set = ly_set_new();
      lys_set_enabled_(mods_00,module);
      do {
        i = (int)ctx_00->internal_module_count;
LAB_00111b72:
        if ((ctx_00->models).used <= i) {
          ctx_modules_redo_backlinks(mods_00);
          for (v = 0; v < mods_00->number; v = v + 1) {
            if ((*(byte *)&(mods_00->set).s[v]->parent & 0x80) != 0) {
              lys_sub_module_apply_devs_augs((lys_module *)(mods_00->set).s[v]);
            }
          }
          ly_set_free(mods_00);
          ly_set_free(set);
          (ctx_00->models).module_set_id = (ctx_00->models).module_set_id + 1;
          return 0;
        }
        node = (ctx_00->models).list[i];
        if (((node->field_0x40 & 0x40) == 0) || (iVar2 = ly_set_contains(set,node), iVar2 != -1))
        goto LAB_00111b6e;
        u = 0;
        while ((u < node->imp_size && (((node->imp[u].module)->field_0x40 & 0x40) == 0))) {
          u = u + 1;
        }
        if (u < node->imp_size) goto LAB_00111b6e;
        u = 0;
LAB_00111b3c:
        if (node->imp_size <= u) goto code_r0x00111b50;
        v = 0;
        while( true ) {
          if (mods_00->number <= v) goto code_r0x00111b38;
          if (node->imp[u].module == (lys_module *)(mods_00->set).s[v]) break;
          v = v + 1;
        }
        node->field_0x40 = node->field_0x40 & 0xbf;
        ly_set_add(mods_00,node,0);
        for (w = 0; w < node->inc_size; w = w + 1) {
          plVar1 = node->inc[w].submodule;
          plVar1->field_0x40 = plVar1->field_0x40 & 0xbf;
        }
      } while( true );
    }
    iVar2 = 0;
  }
  return iVar2;
code_r0x00111b50:
  ly_set_add(set,node,0);
LAB_00111b6e:
  i = i + 1;
  goto LAB_00111b72;
code_r0x00111b38:
  u = u + 1;
  goto LAB_00111b3c;
}



int ly_ctx_remove_module(lys_module *module,_func_void_lys_node_ptr_void_ptr *private_destructor)

{
  ly_ctx *ctx_00;
  lys_module *node;
  bool bVar1;
  ly_set *set;
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_module *module_local;
  uint8_t j;
  uint8_t imported;
  int i;
  int o;
  uint u;
  lys_module *mod;
  ly_ctx *ctx;
  ly_set *mods;
  
  ly_log_dbg(0x20,"%s","ly_ctx_remove_module");
  if (module == (lys_module *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_remove_module");
    return 1;
  }
  ctx_00 = module->ctx;
  for (i = 0; i < (int)(uint)ctx_00->internal_module_count; i = i + 1) {
    if (module == (ctx_00->models).list[i]) {
      ly_log(ctx_00,LY_LLERR,LY_EINVAL,"Internal module \"%s\" cannot be removed.",module->name);
      return 1;
    }
  }
  i = (int)ctx_00->internal_module_count;
  do {
    if ((ctx_00->models).used <= i) {
LAB_00111d6e:
      set = ly_set_new();
      ly_set_add(set,module,0);
LAB_00111d8f:
      i = (int)ctx_00->internal_module_count;
      do {
        if ((ctx_00->models).used <= i) {
          i = (int)ctx_00->internal_module_count;
          o = i;
          for (; i < (ctx_00->models).used; i = i + 1) {
            if ((ctx_00->models).list[o] == (lys_module *)0x0) {
              (ctx_00->models).list[o] = (ctx_00->models).list[i];
              (ctx_00->models).list[i] = (lys_module *)0x0;
            }
            else {
              o = o + 1;
            }
          }
          for (; (ctx_00->models).list[o] == (lys_module *)0x0; o = o + -1) {
          }
          (ctx_00->models).used = o + 1;
          (ctx_00->models).module_set_id = (ctx_00->models).module_set_id + 1;
          ctx_modules_undo_backlinks(ctx_00,set);
          for (u = 0; u < set->number; u = u + 1) {
            lys_sub_module_remove_devs_augs((lys_module *)(set->set).s[u]);
            lys_free((lys_module *)(set->set).s[u],private_destructor,1,0);
          }
          ly_set_free(set);
          return 0;
        }
        node = (ctx_00->models).list[i];
        if (node != (lys_module *)0x0) {
          for (j = '\0'; j < node->imp_size; j = j + '\x01') {
            for (u = 0; u < set->number; u = u + 1) {
              if (node->imp[j].module == (lys_module *)(set->set).s[u]) {
                ly_set_add(set,node,0);
                (ctx_00->models).list[i] = (lys_module *)0x0;
                goto LAB_00111d8f;
              }
            }
          }
          if ((node->field_0x40 & 0x80) == 0) {
            bVar1 = false;
            for (o = (int)ctx_00->internal_module_count; o < (ctx_00->models).used; o = o + 1) {
              if ((ctx_00->models).list[o] != (lys_module *)0x0) {
                for (j = '\0'; j < (ctx_00->models).list[o]->imp_size; j = j + '\x01') {
                  if (node == (ctx_00->models).list[o]->imp[j].module) {
                    bVar1 = true;
                    goto LAB_00111f53;
                  }
                }
              }
            }
LAB_00111f53:
            if (!bVar1) {
              ly_set_add(set,node,0);
              (ctx_00->models).list[i] = (lys_module *)0x0;
              if (node->imp_size != '\0') goto LAB_00111d8f;
            }
          }
        }
        i = i + 1;
      } while( true );
    }
    if (module == (ctx_00->models).list[i]) {
      (ctx_00->models).list[i] = (lys_module *)0x0;
      goto LAB_00111d6e;
    }
    i = i + 1;
  } while( true );
}



void ly_ctx_clean(ly_ctx *ctx,_func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_clean");
  if (ctx != (ly_ctx *)0x0) {
    while ((int)(uint)ctx->internal_module_count < (ctx->models).used) {
      lys_sub_module_remove_devs_augs((ctx->models).list[(long)(ctx->models).used + -1]);
      lys_free((ctx->models).list[(long)(ctx->models).used + -1],private_destructor,1,0);
      (ctx->models).list[(long)(ctx->models).used + -1] = (lys_module *)0x0;
      (ctx->models).used = (ctx->models).used + -1;
    }
    (ctx->models).module_set_id = (ctx->models).module_set_id + 1;
    ctx_modules_undo_backlinks(ctx,(ly_set *)0x0);
  }
  return;
}



lys_module * ly_ctx_get_module_iter(ly_ctx *ctx,uint32_t *idx)

{
  uint uVar1;
  lys_module **pplVar2;
  uint32_t *idx_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_module_iter");
  if ((ctx == (ly_ctx *)0x0) || (idx == (uint32_t *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_get_module_iter");
  }
  else {
    while (*idx < (uint)(ctx->models).used) {
      if (((ctx->models).list[*idx]->field_0x40 & 0x40) == 0) {
        pplVar2 = (ctx->models).list;
        uVar1 = *idx;
        *idx = uVar1 + 1;
        return pplVar2[uVar1];
      }
      *idx = *idx + 1;
    }
  }
  return (lys_module *)0x0;
}



lys_module * ly_ctx_get_disabled_module_iter(ly_ctx *ctx,uint32_t *idx)

{
  uint uVar1;
  lys_module **pplVar2;
  uint32_t *idx_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_disabled_module_iter");
  if ((ctx == (ly_ctx *)0x0) || (idx == (uint32_t *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).",
           "ly_ctx_get_disabled_module_iter");
  }
  else {
    while (*idx < (uint)(ctx->models).used) {
      if (((ctx->models).list[*idx]->field_0x40 & 0x40) != 0) {
        pplVar2 = (ctx->models).list;
        uVar1 = *idx;
        *idx = uVar1 + 1;
        return pplVar2[uVar1];
      }
      *idx = *idx + 1;
    }
  }
  return (lys_module *)0x0;
}



int ylib_feature(lyd_node *parent,lys_module *cur_mod)

{
  lyd_node *plVar1;
  lys_module *cur_mod_local;
  lyd_node *parent_local;
  int i;
  int j;
  
  i = 0;
  while( true ) {
    if ((int)(uint)cur_mod->features_size <= i) {
      i = 0;
      do {
        if (((int)(uint)cur_mod->inc_size <= i) ||
           (cur_mod->inc[i].submodule == (lys_submodule *)0x0)) {
          return 0;
        }
        for (j = 0; j < (int)(uint)(cur_mod->inc[i].submodule)->features_size; j = j + 1) {
          if ((((cur_mod->inc[i].submodule)->features[j].flags & 0x100) != 0) &&
             (plVar1 = lyd_new_leaf(parent,(lys_module *)0x0,"feature",
                                    (cur_mod->inc[i].submodule)->features[j].name),
             plVar1 == (lyd_node *)0x0)) {
            return 1;
          }
        }
        i = i + 1;
      } while( true );
    }
    if (((cur_mod->features[i].flags & 0x100) != 0) &&
       (plVar1 = lyd_new_leaf(parent,(lys_module *)0x0,"feature",cur_mod->features[i].name),
       plVar1 == (lyd_node *)0x0)) break;
    i = i + 1;
  }
  return 1;
}



int ylib_deviation(lyd_node *parent,lys_module *cur_mod,int bis)

{
  int iVar1;
  size_t sVar2;
  lyd_node *plVar3;
  lys_revision *val_str;
  long in_FS_OFFSET;
  int bis_local;
  lys_module *cur_mod_local;
  lyd_node *parent_local;
  uint32_t i;
  uint32_t j;
  lys_module *mod;
  char *ptr;
  lyd_node *cont;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  i = 0;
  if ((cur_mod->field_0x40 & 0x30) == 0) {
LAB_001127b0:
    iVar1 = 0;
LAB_001127b5:
    if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
      return iVar1;
    }
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  do {
    mod = ly_ctx_get_module_iter(cur_mod->ctx,&i);
    if (mod == (lys_module *)0x0) goto LAB_001127b0;
    if (mod != cur_mod) {
      for (j = 0; j < mod->deviation_size; j = j + 1) {
        ptr = strstr(mod->deviation[j].target_name,cur_mod->name);
        if ((ptr != (char *)0x0) && (sVar2 = strlen(cur_mod->name), ptr[sVar2] == ':')) {
          if (bis == 0) {
            cont = lyd_new(parent,(lys_module *)0x0,"deviation");
            if (cont == (lyd_node *)0x0) {
              iVar1 = 1;
              goto LAB_001127b5;
            }
            plVar3 = lyd_new_leaf(cont,(lys_module *)0x0,"name",mod->name);
            if (plVar3 == (lyd_node *)0x0) {
              iVar1 = 1;
              goto LAB_001127b5;
            }
            if (mod->rev_size == '\0') {
              val_str = (lys_revision *)&DAT_0020cb6a;
            }
            else {
              val_str = mod->rev;
            }
            plVar3 = lyd_new_leaf(cont,(lys_module *)0x0,"revision",val_str->date);
            if (plVar3 == (lyd_node *)0x0) {
              iVar1 = 1;
              goto LAB_001127b5;
            }
          }
          else {
            plVar3 = lyd_new_leaf(parent,(lys_module *)0x0,"deviation",mod->name);
            if (plVar3 == (lyd_node *)0x0) {
              iVar1 = 1;
              goto LAB_001127b5;
            }
          }
          break;
        }
      }
    }
  } while( true );
}



int ylib_submodules(lyd_node *parent,lys_module *cur_mod,int bis)

{
  int iVar1;
  lyd_node *plVar2;
  char *name;
  lys_revision *val_str;
  long in_FS_OFFSET;
  int bis_local;
  lys_module *cur_mod_local;
  lyd_node *parent_local;
  int i;
  char *str;
  lyd_node *item;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  i = 0;
  while ((i < (int)(uint)cur_mod->inc_size && (cur_mod->inc[i].submodule != (lys_submodule *)0x0)))
  {
    item = lyd_new(parent,(lys_module *)0x0,"submodule");
    if (item == (lyd_node *)0x0) {
      iVar1 = 1;
      goto LAB_00112a6b;
    }
    plVar2 = lyd_new_leaf(item,(lys_module *)0x0,"name",(cur_mod->inc[i].submodule)->name);
    if (plVar2 == (lyd_node *)0x0) {
      iVar1 = 1;
      goto LAB_00112a6b;
    }
    if ((bis == 0) || ((cur_mod->inc[i].submodule)->rev_size != '\0')) {
      if ((cur_mod->inc[i].submodule)->rev_size == '\0') {
        val_str = (lys_revision *)&DAT_0020cb6a;
      }
      else {
        val_str = (cur_mod->inc[i].submodule)->rev;
      }
      plVar2 = lyd_new_leaf(item,(lys_module *)0x0,"revision",val_str->date);
      if (plVar2 == (lyd_node *)0x0) {
        iVar1 = 1;
        goto LAB_00112a6b;
      }
    }
    if ((cur_mod->inc[i].submodule)->filepath != (char *)0x0) {
      iVar1 = asprintf(&str,"file://%s",(cur_mod->inc[i].submodule)->filepath);
      if (iVar1 == -1) {
        ly_log(cur_mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ylib_submodules");
        iVar1 = 1;
        goto LAB_00112a6b;
      }
      if (bis == 0) {
        name = "schema";
      }
      else {
        name = "location";
      }
      plVar2 = lyd_new_leaf(item,(lys_module *)0x0,name,str);
      if (plVar2 == (lyd_node *)0x0) {
        free(str);
        iVar1 = 1;
        goto LAB_00112a6b;
      }
      free(str);
    }
    i = i + 1;
  }
  iVar1 = 0;
LAB_00112a6b:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



uint16_t ly_ctx_get_module_set_id(ly_ctx *ctx)

{
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_module_set_id");
  return (ctx->models).module_set_id;
}



lyd_node * ly_ctx_info(ly_ctx *ctx)

{
  long lVar1;
  bool bVar2;
  int iVar3;
  lyd_node *plVar4;
  char *val_str;
  lys_revision *val_str_00;
  long in_FS_OFFSET;
  ly_ctx *ctx_local;
  int i;
  int bis;
  char *str;
  lyd_node *root;
  lyd_node *root_bis;
  lyd_node *cont;
  lyd_node *set_bis;
  lys_module *mod;
  char id [8];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","ly_ctx_info");
  root_bis = (lyd_node *)0x0;
  cont = (lyd_node *)0x0;
  set_bis = (lyd_node *)0x0;
  if (ctx == (ly_ctx *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_info");
    plVar4 = (lyd_node *)0x0;
    goto LAB_00113439;
  }
  mod = ly_ctx_get_module(ctx,"ietf-yang-library",(char *)0x0,1);
  if ((mod == (lys_module *)0x0) || (mod->data == (lys_node *)0x0)) {
    ly_log(ctx,LY_LLERR,LY_EINVAL,"ietf-yang-library is not implemented.");
    plVar4 = (lyd_node *)0x0;
    goto LAB_00113439;
  }
  if ((mod->rev == (lys_revision *)0x0) || (iVar3 = strcmp(mod->rev->date,"2016-04-09"), iVar3 != 0)
     ) {
    if ((mod->rev == (lys_revision *)0x0) ||
       (iVar3 = strcmp(mod->rev->date,"2019-01-04"), iVar3 != 0)) {
      ly_log(ctx,LY_LLERR,LY_EINVAL,"Incompatible ietf-yang-library version in context.");
      plVar4 = (lyd_node *)0x0;
      goto LAB_00113439;
    }
    bVar2 = true;
  }
  else {
    bVar2 = false;
  }
  root = lyd_new((lyd_node *)0x0,mod,"modules-state");
  if (root == (lyd_node *)0x0) {
    plVar4 = (lyd_node *)0x0;
    goto LAB_00113439;
  }
  if ((!bVar2) ||
     (((root_bis = lyd_new((lyd_node *)0x0,mod,"yang-library"), root_bis != (lyd_node *)0x0 &&
       (set_bis = lyd_new(root_bis,(lys_module *)0x0,"module-set"), set_bis != (lyd_node *)0x0)) &&
      (plVar4 = lyd_new_leaf(set_bis,(lys_module *)0x0,"name","complete"), plVar4 != (lyd_node *)0x0
      )))) {
    for (i = 0; i < (ctx->models).used; i = i + 1) {
      if (((ctx->models).list[i]->field_0x40 & 0x40) == 0) {
        cont = lyd_new(root,(lys_module *)0x0,"module");
        if ((cont == (lyd_node *)0x0) ||
           (plVar4 = lyd_new_leaf(cont,(lys_module *)0x0,"name",(ctx->models).list[i]->name),
           plVar4 == (lyd_node *)0x0)) goto LAB_0011341c;
        if ((ctx->models).list[i]->rev_size == '\0') {
          val_str_00 = (lys_revision *)&DAT_0020cb6a;
        }
        else {
          val_str_00 = (ctx->models).list[i]->rev;
        }
        plVar4 = lyd_new_leaf(cont,(lys_module *)0x0,"revision",val_str_00->date);
        if (plVar4 == (lyd_node *)0x0) goto LAB_0011341c;
        if ((ctx->models).list[i]->filepath != (char *)0x0) {
          iVar3 = asprintf(&str,"file://%s",(ctx->models).list[i]->filepath);
          if (iVar3 == -1) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_info");
            goto LAB_0011341c;
          }
          plVar4 = lyd_new_leaf(cont,(lys_module *)0x0,"schema",str);
          if (plVar4 == (lyd_node *)0x0) {
            free(str);
            goto LAB_0011341c;
          }
          free(str);
        }
        plVar4 = lyd_new_leaf(cont,(lys_module *)0x0,"namespace",(ctx->models).list[i]->ns);
        if (((plVar4 == (lyd_node *)0x0) ||
            (iVar3 = ylib_feature(cont,(ctx->models).list[i]), iVar3 != 0)) ||
           (iVar3 = ylib_deviation(cont,(ctx->models).list[i],0), iVar3 != 0)) goto LAB_0011341c;
        if (((ctx->models).list[i]->field_0x40 & 0x80) == 0) {
          val_str = "import";
        }
        else {
          val_str = "implement";
        }
        plVar4 = lyd_new_leaf(cont,(lys_module *)0x0,"conformance-type",val_str);
        if ((plVar4 == (lyd_node *)0x0) ||
           (iVar3 = ylib_submodules(cont,(ctx->models).list[i],0), iVar3 != 0)) goto LAB_0011341c;
        if (bVar2) {
          if (((ctx->models).list[i]->field_0x40 & 0x80) == 0) {
            cont = lyd_new(set_bis,(lys_module *)0x0,"import-only-module");
          }
          else {
            cont = lyd_new(set_bis,(lys_module *)0x0,"module");
          }
          if (((cont == (lyd_node *)0x0) ||
              (plVar4 = lyd_new_leaf(cont,(lys_module *)0x0,"name",(ctx->models).list[i]->name),
              plVar4 == (lyd_node *)0x0)) ||
             ((((((ctx->models).list[i]->field_0x40 & 0x80) == 0 ||
                ((ctx->models).list[i]->rev_size != '\0')) &&
               (plVar4 = lyd_new_leaf(cont,(lys_module *)0x0,"revision",
                                      (ctx->models).list[i]->rev->date), plVar4 == (lyd_node *)0x0))
              || (plVar4 = lyd_new_leaf(cont,(lys_module *)0x0,"namespace",(ctx->models).list[i]->ns
                                       ), plVar4 == (lyd_node *)0x0)))) goto LAB_0011341c;
          if ((ctx->models).list[i]->filepath != (char *)0x0) {
            iVar3 = asprintf(&str,"file://%s",(ctx->models).list[i]->filepath);
            if (iVar3 == -1) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_ctx_info");
              goto LAB_0011341c;
            }
            plVar4 = lyd_new_leaf(cont,(lys_module *)0x0,"location",str);
            if (plVar4 == (lyd_node *)0x0) {
              free(str);
              goto LAB_0011341c;
            }
            free(str);
          }
          iVar3 = ylib_submodules(cont,(ctx->models).list[i],1);
          if ((iVar3 != 0) ||
             ((((ctx->models).list[i]->field_0x40 & 0x80) != 0 &&
              ((iVar3 = ylib_feature(cont,(ctx->models).list[i]), iVar3 != 0 ||
               (iVar3 = ylib_deviation(cont,(ctx->models).list[i],1), iVar3 != 0))))))
          goto LAB_0011341c;
        }
      }
    }
    sprintf(id,"%u",(ulong)(ctx->models).module_set_id);
    plVar4 = lyd_new_leaf(root,(lys_module *)0x0,"module-set-id",id);
    if ((plVar4 != (lyd_node *)0x0) &&
       ((!bVar2 ||
        (plVar4 = lyd_new_leaf(root_bis,(lys_module *)0x0,"content-id",id),
        plVar4 != (lyd_node *)0x0)))) {
      if (root_bis != (lyd_node *)0x0) {
        iVar3 = lyd_insert_sibling(&root_bis,root);
        if (iVar3 != 0) goto LAB_0011341c;
        root = root_bis;
        root_bis = (lyd_node *)0x0;
      }
      iVar3 = lyd_validate(&root,0x1000,(void *)0x0);
      plVar4 = root;
      if (iVar3 == 0) goto LAB_00113439;
    }
  }
LAB_0011341c:
  lyd_free_withsiblings(root);
  lyd_free_withsiblings(root_bis);
  plVar4 = (lyd_node *)0x0;
LAB_00113439:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar4;
}



lys_node * ly_ctx_get_node(ly_ctx *ctx,lys_node *start,char *nodeid,int output)

{
  lys_node *plVar1;
  int output_local;
  char *nodeid_local;
  lys_node *start_local;
  ly_ctx *ctx_local;
  lys_node *node;
  
  ly_log_dbg(0x20,"%s","ly_ctx_get_node");
  if ((((ctx == (ly_ctx *)0x0) && (start == (lys_node *)0x0)) || (nodeid == (char *)0x0)) ||
     ((*nodeid != '/' && (start == (lys_node *)0x0)))) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_get_node");
    plVar1 = (lys_node *)0x0;
  }
  else {
    ctx_local = ctx;
    if (ctx == (ly_ctx *)0x0) {
      ctx_local = start->module->ctx;
    }
    plVar1 = resolve_json_nodeid(nodeid,ctx_local,start,output);
  }
  return plVar1;
}



ly_set * ly_ctx_find_path(ly_ctx *ctx,char *path)

{
  ly_set *plVar1;
  long in_FS_OFFSET;
  char *path_local;
  ly_ctx *ctx_local;
  ly_set *resultset;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","ly_ctx_find_path");
  resultset = (ly_set *)0x0;
  if ((ctx == (ly_ctx *)0x0) || (path == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_ctx_find_path");
    plVar1 = (ly_set *)0x0;
  }
  else {
    resolve_schema_nodeid(path,(lys_node *)0x0,*(ctx->models).list,&resultset,1,1);
    plVar1 = resultset;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar1;
}



LY_LOG_LEVEL ly_verb(LY_LOG_LEVEL level)

{
  LY_LOG_LEVEL LVar1;
  LY_LOG_LEVEL level_local;
  LY_LOG_LEVEL prev;
  
  LVar1 = (LY_LOG_LEVEL)ly_log_level;
  ly_log_level = (uint8_t)level;
  return LVar1;
}



int ly_log_options(int opts)

{
  uint8_t uVar1;
  int opts_local;
  uint8_t prev;
  
  uVar1 = ly_log_opts;
  ly_log_opts = (uint8_t)opts;
  return (int)uVar1;
}



void ly_verb_dbg(int dbg_groups)

{
  int dbg_groups_local;
  
  ly_log_dbg_groups = dbg_groups;
  return;
}



void ly_set_log_clb(_func_void_LY_LOG_LEVEL_char_ptr_char_ptr *clb,int path)

{
  int path_local;
  _func_void_LY_LOG_LEVEL_char_ptr_char_ptr *clb_local;
  
  ly_log_clb = clb;
  path_flag = path;
  return;
}



// WARNING: Unknown calling convention

_func_void_LY_LOG_LEVEL_char_ptr_char_ptr * ly_get_log_clb(void)

{
  return ly_log_clb;
}



int log_store(ly_ctx *ctx,LY_LOG_LEVEL level,LY_ERR no,LY_VECODE vecode,char *msg,char *path,
             char *apptag)

{
  ly_err_item *plVar1;
  int *piVar2;
  ly_err_item *plVar3;
  char *path_local;
  char *msg_local;
  LY_VECODE vecode_local;
  LY_ERR no_local;
  LY_LOG_LEVEL level_local;
  ly_ctx *ctx_local;
  ly_err_item *eitem;
  ly_err_item *last;
  
  if ((ctx == (ly_ctx *)0x0) || (LY_LLWRN < level)) {
                    // WARNING: Subroutine does not return
    __assert_fail("ctx && (level < LY_LLVRB)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                  ,0x55,"log_store");
  }
  eitem = (ly_err_item *)pthread_getspecific(ctx->errlist_key);
  if (eitem == (ly_err_item *)0x0) {
    if (msg == (char *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("msg",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                    ,0x5a,"log_store");
    }
    eitem = (ly_err_item *)malloc(0x38);
    if (eitem == (ly_err_item *)0x0) {
LAB_00113900:
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","log_store");
      free(msg);
      free(path);
      free(apptag);
      return -1;
    }
    eitem->prev = eitem;
    eitem->next = (ly_err_item *)0x0;
    pthread_setspecific(ctx->errlist_key,eitem);
  }
  else {
    if (msg == (char *)0x0) {
      if (path == (char *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("path",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                      ,0x65,"log_store");
      }
      eitem = eitem->prev;
      do {
        if (eitem->level == LY_LLERR) {
          free(eitem->path);
          eitem->path = path;
          return 0;
        }
        eitem = eitem->prev;
      } while (eitem->prev->next != (ly_err_item *)0x0);
                    // WARNING: Subroutine does not return
      __assert_fail("0",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                    ,0x73,"log_store");
    }
    piVar2 = (int *)__tls_get_addr(&PTR_0023dfc0);
    if ((*piVar2 == 1) || ((ly_log_opts & 6) != 6)) {
      plVar1 = eitem->prev;
      plVar3 = (ly_err_item *)malloc(0x38);
      eitem->prev = plVar3;
      if (eitem->prev == (ly_err_item *)0x0) goto LAB_00113900;
      eitem = eitem->prev;
      eitem->prev = plVar1;
      eitem->next = (ly_err_item *)0x0;
      plVar1->next = eitem;
    }
    else {
      free(eitem->msg);
      free(eitem->path);
      free(eitem->apptag);
    }
  }
  eitem->level = level;
  eitem->no = no;
  eitem->vecode = vecode;
  eitem->msg = msg;
  eitem->path = path;
  eitem->apptag = apptag;
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void log_vprintf(ly_ctx *ctx,LY_LOG_LEVEL level,LY_ERR no,LY_VECODE vecode,char *path,char *format,
                __va_list_tag *args)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  LY_ERR *pLVar4;
  undefined *puVar5;
  long in_FS_OFFSET;
  __va_list_tag *args_local;
  char *format_local;
  char *path_local;
  LY_VECODE vecode_local;
  LY_ERR no_local;
  LY_LOG_LEVEL level_local;
  ly_ctx *ctx_local;
  int free_strs;
  char *msg;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  msg = (char *)0x0;
  piVar3 = (int *)__tls_get_addr(&PTR_0023dfc0);
  level_local = level;
  if ((*piVar3 == 3) && (level == LY_LLERR)) {
    level_local = LY_LLWRN;
  }
  piVar3 = (int *)__tls_get_addr(&PTR_0023dfc0);
  if ((*piVar3 == 2) || (ly_log_level < level_local)) {
    free(path);
    goto LAB_00113cb0;
  }
  piVar3 = (int *)__tls_get_addr(&PTR_0023dfc0);
  if ((*piVar3 != 1) && (no != LY_SUCCESS)) {
    pLVar4 = ly_errno_glob_address();
    *pLVar4 = no;
  }
  vecode_local = vecode;
  if ((no == LY_EVALID) && (vecode == LYVE_SUCCESS)) {
    vecode_local = ly_vecode(ctx);
  }
  if (((level_local < LY_LLVRB) && (ctx != (ly_ctx *)0x0)) &&
     (((ly_log_opts & 2) != 0 || (piVar3 = (int *)__tls_get_addr(&PTR_0023dfc0), *piVar3 == 1)))) {
    if (format == (char *)0x0) {
      if (path == (char *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("path",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                      ,0xb7,"log_vprintf");
      }
      iVar2 = log_store(ctx,level_local,no,vecode_local,(char *)0x0,path,(char *)0x0);
      if (iVar2 != 0) goto LAB_00113cb0;
      msg = "Path is related to the previous error message.";
    }
    else {
      iVar2 = vasprintf(&msg,format,args);
      if (iVar2 == -1) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","log_vprintf");
        free(path);
        goto LAB_00113cb0;
      }
      iVar2 = log_store(ctx,level_local,no,vecode_local,msg,path,(char *)0x0);
      if (iVar2 != 0) goto LAB_00113cb0;
    }
    bVar1 = false;
  }
  else {
    iVar2 = vasprintf(&msg,format,args);
    if (iVar2 == -1) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","log_vprintf");
      free(path);
      goto LAB_00113cb0;
    }
    bVar1 = true;
  }
  if (((ly_log_opts & 1) != 0) && (piVar3 = (int *)__tls_get_addr(&PTR_0023dfc0), *piVar3 != 1)) {
    if (ly_log_clb == (_func_void_LY_LOG_LEVEL_char_ptr_char_ptr *)0x0) {
      if (path == (char *)0x0) {
        puVar5 = &DAT_0020d279;
      }
      else {
        puVar5 = &DAT_0020d277;
      }
      fprintf(_stderr,"libyang[%d]: %s%s",(ulong)level_local,msg,puVar5);
      if (path != (char *)0x0) {
        fprintf(_stderr,"(path: %s)\n",path);
      }
    }
    else {
      (*ly_log_clb)(level_local,msg,path);
    }
  }
  if (bVar1) {
    free(path);
    free(msg);
  }
LAB_00113cb0:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void ly_log(ly_ctx *ctx,LY_LOG_LEVEL level,LY_ERR no,char *format,...)

{
  long lVar1;
  char in_AL;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  char *format_local;
  LY_ERR no_local;
  LY_LOG_LEVEL level_local;
  ly_ctx *ctx_local;
  va_list ap;
  undefined local_b8 [32];
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ap[0].gp_offset = 0x20;
  ap[0].fp_offset = 0x30;
  ap[0].overflow_arg_area = &stack0x00000008;
  ap[0].reg_save_area = local_b8;
  local_98 = in_R8;
  local_90 = in_R9;
  log_vprintf(ctx,level,no,LYVE_SUCCESS,(char *)0x0,format,ap);
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void ly_log_dbg(int group,char *format,...)

{
  long lVar1;
  char in_AL;
  int iVar2;
  undefined8 in_RCX;
  undefined8 in_RDX;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  char *format_local;
  int group_local;
  char *dbg_format;
  char *str_group;
  va_list ap;
  undefined local_b8 [16];
  undefined8 local_a8;
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  local_a8 = in_RDX;
  local_a0 = in_RCX;
  local_98 = in_R8;
  local_90 = in_R9;
  if ((ly_log_dbg_groups & group) == 0) goto LAB_00114008;
  if (group < 0x21) {
    if ((0 < group) && (true)) {
      switch(group) {
      case 1:
        str_group = "DICT";
        break;
      case 2:
        str_group = "YANG";
        break;
      default:
        goto switchD_00113e83_caseD_3;
      case 4:
        str_group = "YIN";
        break;
      case 8:
        str_group = "XPATH";
        break;
      case 0x10:
        str_group = "DIFF";
        break;
      case 0x20:
        str_group = "API";
      }
LAB_00113f39:
      iVar2 = asprintf(&dbg_format,"%s: %s",str_group,format);
      if (iVar2 == -1) {
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_log_dbg");
      }
      else {
        ap[0].gp_offset = 0x10;
        ap[0].fp_offset = 0x30;
        ap[0].overflow_arg_area = &stack0x00000008;
        ap[0].reg_save_area = local_b8;
        log_vprintf((ly_ctx *)0x0,LY_LLDBG,LY_SUCCESS,LYVE_SUCCESS,(char *)0x0,dbg_format,ap);
        free(dbg_format);
      }
      goto LAB_00114008;
    }
  }
  else if (group == 0x40) {
    str_group = "HASH";
    goto LAB_00113f39;
  }
switchD_00113e83_caseD_3:
  ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
         ,0x111);
LAB_00114008:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void lyext_log(ly_ctx *ctx,LY_LOG_LEVEL level,char *plugin,char *function,char *format,...)

{
  long lVar1;
  char in_AL;
  LY_ERR no;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  char *format_local;
  char *function_local;
  char *plugin_local;
  LY_LOG_LEVEL level_local;
  ly_ctx *ctx_local;
  int ret;
  char *plugin_msg;
  va_list ap;
  undefined local_b8 [40];
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  local_90 = in_R9;
  if (level <= ly_log_level) {
    if (plugin == (char *)0x0) {
      ret = asprintf(&plugin_msg,"%s",format);
    }
    else {
      ret = asprintf(&plugin_msg,"%s (reported by plugin %s, %s())",format,plugin,function);
    }
    if (ret == -1) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyext_log");
    }
    else {
      ap[0].gp_offset = 0x28;
      ap[0].fp_offset = 0x30;
      ap[0].overflow_arg_area = &stack0x00000008;
      ap[0].reg_save_area = local_b8;
      if (level == LY_LLERR) {
        no = LY_EPLUGIN;
      }
      else {
        no = LY_SUCCESS;
      }
      log_vprintf(ctx,level,no,LYVE_SUCCESS,(char *)0x0,plugin_msg,ap);
      free(plugin_msg);
    }
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void lyext_vlog(ly_ctx *ctx,LY_VECODE vecode,char *plugin,char *function,LYEXT_VLOG_ELEM elem_type,
               void *elem,char *format,...)

{
  LY_VLOG_ELEM elem_type_00;
  long lVar1;
  char in_AL;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  char *format_local;
  void *elem_local;
  char *function_local;
  char *plugin_local;
  LYEXT_VLOG_ELEM elem_type_local;
  LY_VECODE vecode_local;
  ly_ctx *ctx_local;
  int ret;
  LY_VLOG_ELEM etype;
  char *plugin_msg;
  char *path;
  ly_err_item *first;
  va_list ap;
  undefined local_b8 [48];
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  elem_type_00 = extvelog2velog[elem_type];
  path = (char *)0x0;
  if ((path_flag != 0) && (elem_type_00 != LY_VLOG_NONE)) {
    if (elem_type_00 == LY_VLOG_PREV) {
      first = ly_err_first(ctx);
      if ((first != (ly_err_item *)0x0) && (first->prev->path != (char *)0x0)) {
        path = strdup(first->prev->path);
      }
    }
    else if (elem == (void *)0x0) {
      path = strdup("/");
    }
    else {
      ly_vlog_build_path(elem_type_00,elem,&path,0,0);
    }
  }
  if (plugin == (char *)0x0) {
    ret = asprintf(&plugin_msg,"%s",format);
  }
  else {
    ret = asprintf(&plugin_msg,"%s (reported by plugin %s, %s())",format,plugin,function);
  }
  if (ret == -1) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyext_vlog");
    free(path);
  }
  else {
    ap[0].gp_offset = 0x30;
    ap[0].fp_offset = 0x30;
    ap[0].overflow_arg_area = &stack0x00000010;
    ap[0].reg_save_area = local_b8;
    log_vprintf(ctx,LY_LLERR,LY_EVALID,vecode,path,plugin_msg,ap);
    free(plugin_msg);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int ly_vlog_build_path_print
              (char **path,uint16_t *index,char *str,uint16_t str_len,uint16_t *length)

{
  ushort uVar1;
  char *pcVar2;
  uint16_t *length_local;
  uint16_t str_len_local;
  char *str_local;
  uint16_t *index_local;
  char **path_local;
  uint16_t step;
  void *mem;
  
  if (*index < str_len) {
    uVar1 = 0x80;
    if (0x7f < str_len) {
      uVar1 = str_len;
    }
    pcVar2 = (char *)realloc(*path,(long)(int)((uint)uVar1 + (uint)*length + (uint)*index + 1));
    if (pcVar2 == (char *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
             "ly_vlog_build_path_print");
      return -1;
    }
    *path = pcVar2;
    memmove(*path + (int)((uint)uVar1 + (uint)*index),*path + *index,(ulong)*length);
    *index = *index + uVar1;
  }
  *index = *index - str_len;
  memcpy(*path + *index,str,(ulong)str_len);
  *length = *length + str_len;
  return 0;
}



int ly_vlog_build_path(LY_VLOG_ELEM elem_type,void *elem,char **path,int schema_all_prefixes,
                      int data_no_last_predicate)

{
  uint16_t str_len;
  int iVar1;
  char *pcVar2;
  lys_node *plVar3;
  lys_module *plVar4;
  size_t sVar5;
  lys_module *plVar6;
  long in_FS_OFFSET;
  int data_no_last_predicate_local;
  char **path_local;
  void *elem_local;
  int schema_all_prefixes_local;
  LY_VLOG_ELEM elem_type_local;
  uint16_t length;
  uint16_t index;
  int i;
  int j;
  int yang_data_extension;
  lys_node *sparent;
  lyd_node *diter;
  lys_module *top_smodule;
  char *name;
  char *prefix;
  char *val_end;
  char *val_start;
  size_t len;
  lyd_node *dlist;
  lys_node_list *slist;
  char *str;
  char *ext_name;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  yang_data_extension = 0;
  sparent = (lys_node *)0x0;
  top_smodule = (lys_module *)0x0;
  prefix = (char *)0x0;
  length = 0;
  pcVar2 = (char *)malloc(1);
  *path = pcVar2;
  if (*path == (char *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_vlog_build_path");
    iVar1 = -1;
  }
  else {
    index = 0;
    elem_local = elem;
    do {
      do {
        if (elem_local == (void *)0x0) {
LAB_001153be:
          memmove(*path,*path + index,(ulong)length);
          (*path)[length] = '\0';
          iVar1 = 0;
          goto LAB_00115413;
        }
        if (elem_type == LY_VLOG_STR) {
          len = strlen((char *)elem_local);
          iVar1 = ly_vlog_build_path_print(path,&index,(char *)elem_local,(uint16_t)len,&length);
          if (iVar1 == 0) goto LAB_001153be;
          iVar1 = -1;
          goto LAB_00115413;
        }
        if (LY_VLOG_STR < elem_type) {
LAB_001151b5:
          ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                 ,0x32e);
          iVar1 = -1;
          goto LAB_00115413;
        }
        if (elem_type == LY_VLOG_LYD) {
                    // WARNING: Load size is inaccurate
          name = (char *)**elem_local;
          if (*(long *)((long)elem_local + 0x28) == 0) {
LAB_00114a6b:
            plVar4 = lyd_node_module((lyd_node *)elem_local);
            prefix = plVar4->name;
          }
          else {
            plVar4 = lyd_node_module((lyd_node *)elem_local);
            plVar6 = lyd_node_module(*(lyd_node **)((long)elem_local + 0x28));
            if (plVar4 != plVar6) goto LAB_00114a6b;
            prefix = (char *)0x0;
          }
          if ((data_no_last_predicate == 0) || (index != 0)) {
                    // WARNING: Load size is inaccurate
            if (*(int *)(*elem_local + 0x38) == 0x10) {
              dlist = (lyd_node *)elem_local;
                    // WARNING: Load size is inaccurate
              slist = *elem_local;
              if (slist->keys_size == '\0') {
                i = lyd_list_pos((lyd_node *)elem_local);
                len = 1;
                for (j = i; 9 < j; j = j / 10) {
                  len = len + 1;
                }
                iVar1 = ly_vlog_build_path_print(path,&index,"]",1,&length);
                if (iVar1 != 0) {
                  iVar1 = -1;
                  goto LAB_00115413;
                }
                str = (char *)malloc(len + 1);
                if (str == (char *)0x0) {
                  ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                         "ly_vlog_build_path");
                  iVar1 = -1;
                  goto LAB_00115413;
                }
                sprintf(str,"%d",(ulong)(uint)i);
                iVar1 = ly_vlog_build_path_print(path,&index,str,(uint16_t)len,&length);
                if (iVar1 != 0) {
                  free(str);
                  iVar1 = -1;
                  goto LAB_00115413;
                }
                free(str);
                iVar1 = ly_vlog_build_path_print(path,&index,"[",1,&length);
                if (iVar1 != 0) {
                  iVar1 = -1;
                  goto LAB_00115413;
                }
              }
              else {
                i = (int)slist->keys_size;
                while (i = i - 1, -1 < i) {
                  for (diter = dlist->child;
                      (diter != (lyd_node *)0x0 &&
                      ((lys_node_leaf *)diter->schema != slist->keys[i])); diter = diter->next) {
                  }
                  if ((diter != (lyd_node *)0x0) && (diter->ht != (hash_table *)0x0)) {
                    pcVar2 = strchr((char *)diter->ht,0x27);
                    if (pcVar2 == (char *)0x0) {
                      val_start = "=\'";
                      val_end = "\']";
                    }
                    else {
                      val_start = "=\"";
                      val_end = "\"]";
                    }
                    iVar1 = ly_vlog_build_path_print(path,&index,val_end,2,&length);
                    if (iVar1 != 0) {
                      iVar1 = -1;
                      goto LAB_00115413;
                    }
                    len = strlen((char *)diter->ht);
                    iVar1 = ly_vlog_build_path_print
                                      (path,&index,(char *)diter->ht,(uint16_t)len,&length);
                    if (iVar1 != 0) {
                      iVar1 = -1;
                      goto LAB_00115413;
                    }
                    iVar1 = ly_vlog_build_path_print(path,&index,val_start,2,&length);
                    if (iVar1 != 0) {
                      iVar1 = -1;
                      goto LAB_00115413;
                    }
                    len = strlen(diter->schema->name);
                    iVar1 = ly_vlog_build_path_print
                                      (path,&index,diter->schema->name,(uint16_t)len,&length);
                    if (iVar1 != 0) {
                      iVar1 = -1;
                      goto LAB_00115413;
                    }
                    plVar4 = lyd_node_module(dlist);
                    plVar6 = lyd_node_module(diter);
                    if (plVar4 != plVar6) {
                      iVar1 = ly_vlog_build_path_print(path,&index,":",1,&length);
                      if (iVar1 != 0) {
                        iVar1 = -1;
                        goto LAB_00115413;
                      }
                      plVar4 = lyd_node_module(diter);
                      len = strlen(plVar4->name);
                      str_len = (uint16_t)len;
                      plVar4 = lyd_node_module(diter);
                      iVar1 = ly_vlog_build_path_print(path,&index,plVar4->name,str_len,&length);
                      if (iVar1 != 0) {
                        iVar1 = -1;
                        goto LAB_00115413;
                      }
                    }
                    iVar1 = ly_vlog_build_path_print(path,&index,"[",1,&length);
                    if (iVar1 != 0) {
                      iVar1 = -1;
                      goto LAB_00115413;
                    }
                  }
                }
              }
            }
            else {
                    // WARNING: Load size is inaccurate
              if ((*(int *)(*elem_local + 0x38) == 8) && (*(long *)((long)elem_local + 0x38) != 0))
              {
                pcVar2 = strchr(*(char **)((long)elem_local + 0x38),0x27);
                if (pcVar2 == (char *)0x0) {
                  val_start = "[.=\'";
                  val_end = "\']";
                }
                else {
                  val_start = "[.=\"";
                  val_end = "\"]";
                }
                iVar1 = ly_vlog_build_path_print(path,&index,val_end,2,&length);
                if (iVar1 != 0) {
                  iVar1 = -1;
                  goto LAB_00115413;
                }
                len = strlen(*(char **)((long)elem_local + 0x38));
                iVar1 = ly_vlog_build_path_print
                                  (path,&index,*(char **)((long)elem_local + 0x38),(uint16_t)len,
                                   &length);
                if (iVar1 != 0) {
                  iVar1 = -1;
                  goto LAB_00115413;
                }
                iVar1 = ly_vlog_build_path_print(path,&index,val_start,4,&length);
                if (iVar1 != 0) {
                  iVar1 = -1;
                  goto LAB_00115413;
                }
              }
            }
          }
          if ((*(long *)((long)elem_local + 0x28) == 0) &&
             (ext_name = lyp_get_yang_data_template_name((lyd_node *)elem_local),
             ext_name != (char *)0x0)) {
            sVar5 = strlen(name);
            iVar1 = ly_vlog_build_path_print(path,&index,name,(uint16_t)sVar5,&length);
            if (iVar1 != 0) {
              iVar1 = -1;
              goto LAB_00115413;
            }
            iVar1 = ly_vlog_build_path_print(path,&index,"/",1,&length);
            if (iVar1 != 0) {
              iVar1 = -1;
              goto LAB_00115413;
            }
            yang_data_extension = 1;
            name = ext_name;
          }
          elem_local = *(void **)((long)elem_local + 0x28);
        }
        else {
          if (LY_VLOG_LYD < elem_type) goto LAB_001151b5;
          if (elem_type == LY_VLOG_XML) {
            name = *(char **)((long)elem_local + 0x30);
            if (*(long *)((long)elem_local + 0x38) == 0) {
              prefix = (char *)0x0;
            }
            else {
              prefix = *(char **)(*(long *)((long)elem_local + 0x38) + 0x18);
            }
            elem_local = *(void **)((long)elem_local + 8);
          }
          else {
            if (elem_type != LY_VLOG_LYS) goto LAB_001151b5;
            if (top_smodule == (lys_module *)0x0) {
              sparent = (lys_node *)elem_local;
              while (plVar3 = lys_parent(sparent), plVar3 != (lys_node *)0x0) {
                sparent = lys_parent(sparent);
              }
              top_smodule = lys_node_module(sparent);
            }
            for (sparent = lys_parent((lys_node *)elem_local);
                (sparent != (lys_node *)0x0 && (sparent->nodetype == LYS_USES));
                sparent = lys_parent(sparent)) {
            }
            if (((sparent == (lys_node *)0x0) ||
                (plVar4 = lys_node_module((lys_node *)elem_local), top_smodule != plVar4)) ||
               (schema_all_prefixes != 0)) {
              plVar4 = lys_node_module((lys_node *)elem_local);
              prefix = plVar4->name;
            }
            else {
              prefix = (char *)0x0;
            }
            if ((*(uint *)((long)elem_local + 0x38) & 0x2800) == 0) {
              if (*(int *)((long)elem_local + 0x38) == 0x10000) {
                    // WARNING: Load size is inaccurate
                name = (char *)**elem_local;
                iVar1 = strcmp(name,"yang-data");
                if (iVar1 == 0) {
                  yang_data_extension = 1;
                  name = *(char **)((long)elem_local + 0x10);
                  plVar4 = lys_node_module((lys_node *)elem_local);
                  prefix = plVar4->name;
                }
              }
              else {
                    // WARNING: Load size is inaccurate
                name = *elem_local;
              }
            }
            else {
              iVar1 = ly_vlog_build_path_print(path,&index,"]",1,&length);
              if (iVar1 != 0) {
                iVar1 = -1;
                goto LAB_00115413;
              }
                    // WARNING: Load size is inaccurate
              name = *elem_local;
              sVar5 = strlen(name);
              iVar1 = ly_vlog_build_path_print(path,&index,name,(uint16_t)sVar5,&length);
              if (iVar1 != 0) {
                iVar1 = -1;
                goto LAB_00115413;
              }
              if (*(int *)((long)elem_local + 0x38) == 0x800) {
                name = "{grouping}[";
              }
              else {
                name = "{augment}[";
              }
            }
            if (*(int *)((long)elem_local + 0x38) == 0x10000) {
              if (*(char *)((long)elem_local + 0x1d) == '\x01') {
                elem_local = *(void **)((long)elem_local + 8);
              }
              else {
                sparent = (lys_node *)0x0;
                elem_local = (void *)0x0;
              }
            }
            else {
              do {
                sparent = *(lys_node **)((long)elem_local + 0x40);
                elem_local = lys_parent((lys_node *)elem_local);
                if ((lys_node *)elem_local == (lys_node *)0x0) break;
              } while (((lys_node *)elem_local)->nodetype == LYS_USES);
            }
          }
        }
        if (name != (char *)0x0) {
          sVar5 = strlen(name);
          iVar1 = ly_vlog_build_path_print(path,&index,name,(uint16_t)sVar5,&length);
          if (iVar1 != 0) {
            iVar1 = -1;
            goto LAB_00115413;
          }
          if (prefix != (char *)0x0) {
            if ((yang_data_extension != 0) &&
               (iVar1 = ly_vlog_build_path_print(path,&index,"#",1,&length), iVar1 != 0)) {
              iVar1 = -1;
              goto LAB_00115413;
            }
            iVar1 = ly_vlog_build_path_print(path,&index,":",1,&length);
            if (iVar1 != 0) {
              iVar1 = -1;
              goto LAB_00115413;
            }
            sVar5 = strlen(prefix);
            iVar1 = ly_vlog_build_path_print(path,&index,prefix,(uint16_t)sVar5,&length);
            if (iVar1 != 0) {
              iVar1 = -1;
              goto LAB_00115413;
            }
          }
        }
        iVar1 = ly_vlog_build_path_print(path,&index,"/",1,&length);
        if (iVar1 != 0) {
          iVar1 = -1;
          goto LAB_00115413;
        }
      } while (((elem_type != LY_VLOG_LYS) || (elem_local != (void *)0x0)) ||
              ((sparent == (lys_node *)0x0 || (sparent->nodetype != LYS_AUGMENT))));
      len = strlen(sparent->name);
      iVar1 = ly_vlog_build_path_print(path,&index,sparent->name,(uint16_t)len,&length);
    } while (iVar1 == 0);
    iVar1 = -1;
  }
LAB_00115413:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void ly_vlog(ly_ctx *ctx,LY_ECODE ecode,LY_VLOG_ELEM elem_type,void *elem,...)

{
  long lVar1;
  char in_AL;
  undefined8 *puVar2;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  void *elem_local;
  LY_VLOG_ELEM elem_type_local;
  LY_ECODE ecode_local;
  ly_ctx *ctx_local;
  char *path;
  ly_err_item *first;
  char *fmt;
  va_list ap;
  undefined local_b8 [32];
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  path = (char *)0x0;
  local_98 = in_R8;
  local_90 = in_R9;
  if ((ecode != LYE_PATH) || (path_flag != 0)) {
    if ((path_flag != 0) && (elem_type != LY_VLOG_NONE)) {
      if (elem_type == LY_VLOG_PREV) {
        first = ly_err_first(ctx);
        if ((first != (ly_err_item *)0x0) && (first->prev->path != (char *)0x0)) {
          path = strdup(first->prev->path);
        }
      }
      else if (elem == (void *)0x0) {
        path = strdup("/");
      }
      else {
        ly_vlog_build_path(elem_type,elem,&path,0,0);
      }
    }
    ap[0].gp_offset = 0x20;
    ap[0].fp_offset = 0x30;
    ap[0].overflow_arg_area = &stack0x00000008;
    ap[0].reg_save_area = local_b8;
    if (ecode == LYE_PATH) {
      if (path == (char *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("path",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                      ,0x378,"ly_vlog");
      }
      log_vprintf(ctx,LY_LLERR,LY_EVALID,LYVE_SUCCESS,path,(char *)0x0,ap);
    }
    else if (ecode == LYE_SPEC) {
      if (false) {
        puVar2 = (undefined8 *)ap[0].overflow_arg_area;
        ap[0].overflow_arg_area = &stack0x00000010;
      }
      else {
        ap[0].gp_offset = 0x28;
        puVar2 = &local_98;
      }
      fmt = (char *)*puVar2;
      log_vprintf(ctx,LY_LLERR,LY_EVALID,LYVE_SUCCESS,path,fmt,ap);
    }
    else {
      log_vprintf(ctx,LY_LLERR,LY_EVALID,ecode2vecode[ecode],path,ly_errs[ecode],ap);
    }
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void ly_vlog_str(ly_ctx *ctx,LY_VLOG_ELEM elem_type,char *str,...)

{
  long lVar1;
  char in_AL;
  ly_err_item *plVar2;
  char *pcVar3;
  size_t sVar4;
  undefined8 in_RCX;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  char *str_local;
  LY_VLOG_ELEM elem_type_local;
  ly_ctx *ctx_local;
  char *path;
  char *fmt;
  char *ptr;
  ly_err_item *first;
  va_list ap;
  undefined local_b8 [24];
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  path = (char *)0x0;
  local_a0 = in_RCX;
  local_98 = in_R8;
  local_90 = in_R9;
  if ((elem_type != LY_VLOG_NONE) && (elem_type != LY_VLOG_PREV)) {
                    // WARNING: Subroutine does not return
    __assert_fail("(elem_type == LY_VLOG_NONE) || (elem_type == LY_VLOG_PREV)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                  ,0x389,"ly_vlog_str");
  }
  if (((elem_type == LY_VLOG_PREV) && (plVar2 = ly_err_first(ctx), plVar2 != (ly_err_item *)0x0)) &&
     (plVar2->prev->path != (char *)0x0)) {
    path = strdup(plVar2->prev->path);
  }
  pcVar3 = strchr(str,0x25);
  if (pcVar3 == (char *)0x0) {
    fmt = strdup(str);
  }
  else {
    sVar4 = strlen(str);
    fmt = (char *)malloc(sVar4 * 2 + 1);
    strcpy(fmt,str);
    for (ptr = strchr(fmt,0x25); ptr != (char *)0x0; ptr = strchr(ptr + 2,0x25)) {
      sVar4 = strlen(ptr);
      memmove(ptr + 1,ptr,sVar4 + 1);
      *ptr = '%';
    }
  }
  ap[0].gp_offset = 0x18;
  ap[0].fp_offset = 0x30;
  ap[0].overflow_arg_area = &stack0x00000008;
  ap[0].reg_save_area = local_b8;
  log_vprintf(ctx,LY_LLERR,LY_EVALID,LYVE_SUCCESS,path,fmt,ap);
  free(fmt);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ly_err_print(ly_err_item *eitem)

{
  undefined *puVar1;
  ly_err_item *eitem_local;
  
  if ((ly_log_opts & 1) != 0) {
    if (ly_log_clb == (_func_void_LY_LOG_LEVEL_char_ptr_char_ptr *)0x0) {
      if (eitem->path == (char *)0x0) {
        puVar1 = &DAT_0020d279;
      }
      else {
        puVar1 = &DAT_0020d277;
      }
      fprintf(_stderr,"libyang[%d]: %s%s",(ulong)eitem->level,eitem->msg,puVar1);
      if (eitem->path != (char *)0x0) {
        fprintf(_stderr,"(path: %s)\n",eitem->path);
      }
    }
    else {
      (*ly_log_clb)(eitem->level,eitem->msg,eitem->path);
    }
  }
  return;
}



void err_print(ly_ctx *ctx,ly_err_item *last_eitem)

{
  int *piVar1;
  LY_ERR *pLVar2;
  ly_err_item *last_eitem_local;
  ly_ctx *ctx_local;
  
  if (last_eitem == (ly_err_item *)0x0) {
    last_eitem_local = (ly_err_item *)pthread_getspecific(ctx->errlist_key);
  }
  else {
    last_eitem_local = last_eitem->next;
  }
  piVar1 = (int *)__tls_get_addr(&PTR_0023dfc0);
  if ((*piVar1 != 1) && (piVar1 = (int *)__tls_get_addr(&PTR_0023dfc0), *piVar1 != 2)) {
    for (; last_eitem_local != (ly_err_item *)0x0; last_eitem_local = last_eitem_local->next) {
      ly_err_print(last_eitem_local);
      if (last_eitem_local->level == LY_LLERR) {
        pLVar2 = ly_errno_glob_address();
        *pLVar2 = last_eitem_local->no;
      }
    }
  }
  return;
}



void ly_err_free_next(ly_ctx *ctx,ly_err_item *last_eitem)

{
  ly_err_item *last_eitem_local;
  ly_ctx *ctx_local;
  
  if (last_eitem == (ly_err_item *)0x0) {
    ly_err_clean(ctx,(ly_err_item *)0x0);
  }
  else if (last_eitem->next != (ly_err_item *)0x0) {
    ly_err_clean(ctx,last_eitem->next);
  }
  return;
}



void err_clean(ly_ctx *ctx,ly_err_item *prev_eitem,int keep)

{
  void *__pointer;
  int *piVar1;
  void *ptr;
  int keep_local;
  ly_err_item *prev_eitem_local;
  ly_ctx *ctx_local;
  ly_err_item *first;
  
  piVar1 = (int *)__tls_get_addr(&PTR_0023dfc0);
  if (*piVar1 != 1) {
    piVar1 = (int *)__tls_get_addr(&PTR_0023dfc0);
    if (((*piVar1 == 2) || (keep == 0)) || ((ly_log_opts & 2) == 0)) {
      ly_err_free_next(ctx,prev_eitem);
    }
    else if ((ly_log_opts & 6) == 6) {
      ptr = pthread_getspecific(ctx->errlist_key);
      if (ptr != (void *)0x0) {
        __pointer = *(void **)((long)ptr + 0x30);
        pthread_setspecific(ctx->errlist_key,__pointer);
        if ((*(long *)(*(long *)((long)__pointer + 0x30) + 0x28) != 0) &&
           (__pointer != *(void **)(*(long *)((long)__pointer + 0x30) + 0x28))) {
                    // WARNING: Subroutine does not return
          __assert_fail("!prev_eitem->prev->next || (prev_eitem->prev->next == prev_eitem)",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                        ,0x3f7,"err_clean");
        }
        *(undefined8 *)(*(long *)((long)__pointer + 0x30) + 0x28) = 0;
        *(void **)((long)__pointer + 0x30) = __pointer;
        if (__pointer != ptr) {
          ly_err_free(ptr);
        }
      }
    }
  }
  return;
}



void ly_ilo_change(ly_ctx *ctx,int_log_opts new_ilo,int_log_opts *prev_ilo,
                  ly_err_item **prev_last_eitem)

{
  int_log_opts *piVar1;
  ly_err_item *plVar2;
  int *piVar3;
  ly_err_item **prev_last_eitem_local;
  int_log_opts *prev_ilo_local;
  int_log_opts new_ilo_local;
  ly_ctx *ctx_local;
  
  if (prev_ilo == (int_log_opts *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("prev_ilo",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                  ,0x405,"ly_ilo_change");
  }
  piVar1 = (int_log_opts *)__tls_get_addr(&PTR_0023dfc0);
  *prev_ilo = *piVar1;
  if (new_ilo == ILO_STORE) {
    if ((ctx == (ly_ctx *)0x0) || (prev_last_eitem == (ly_err_item **)0x0)) {
                    // WARNING: Subroutine does not return
      __assert_fail("ctx && prev_last_eitem",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                    ,0x40a,"ly_ilo_change");
    }
    plVar2 = ly_err_first(ctx);
    *prev_last_eitem = plVar2;
    if (*prev_last_eitem != (ly_err_item *)0x0) {
      *prev_last_eitem = (*prev_last_eitem)->prev;
    }
  }
  piVar3 = (int *)__tls_get_addr(&PTR_0023dfc0);
  if (*piVar3 != 2) {
    piVar1 = (int_log_opts *)__tls_get_addr(&PTR_0023dfc0);
    *piVar1 = new_ilo;
  }
  return;
}



void ly_ilo_restore(ly_ctx *ctx,int_log_opts prev_ilo,ly_err_item *prev_last_eitem,
                   int keep_and_print)

{
  int *piVar1;
  int_log_opts *piVar2;
  ly_err_item *prev_last_eitem_local;
  int keep_and_print_local;
  int_log_opts prev_ilo_local;
  ly_ctx *ctx_local;
  
  piVar1 = (int *)__tls_get_addr(&PTR_0023dfc0);
  if (*piVar1 == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("log_opt != ILO_LOG",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                  ,0x419,"ly_ilo_restore");
  }
  piVar1 = (int *)__tls_get_addr(&PTR_0023dfc0);
  if (*piVar1 == 1) {
    if (ctx == (ly_ctx *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("ctx",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                    ,0x421,"ly_ilo_restore");
    }
    piVar2 = (int_log_opts *)__tls_get_addr(&PTR_0023dfc0);
    *piVar2 = prev_ilo;
    if (keep_and_print != 0) {
      err_print(ctx,prev_last_eitem);
    }
    err_clean(ctx,prev_last_eitem,keep_and_print);
  }
  else {
    piVar2 = (int_log_opts *)__tls_get_addr(&PTR_0023dfc0);
    if ((prev_ilo != *piVar2) &&
       (((ctx != (ly_ctx *)0x0 || (prev_last_eitem != (ly_err_item *)0x0)) || (keep_and_print != 0))
       )) {
                    // WARNING: Subroutine does not return
      __assert_fail("log_opt == prev_ilo || (!ctx && !prev_last_eitem && !keep_and_print)",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/log.c"
                    ,0x41c,"ly_ilo_restore");
    }
    piVar2 = (int_log_opts *)__tls_get_addr(&PTR_0023dfc0);
    *piVar2 = prev_ilo;
  }
  return;
}



void ly_err_last_set_apptag(ly_ctx *ctx,char *apptag)

{
  int *piVar1;
  ly_err_item *plVar2;
  char *pcVar3;
  char *apptag_local;
  ly_ctx *ctx_local;
  ly_err_item *i;
  
  piVar1 = (int *)__tls_get_addr(&PTR_0023dfc0);
  if (*piVar1 != 2) {
    plVar2 = ly_err_first(ctx);
    if (plVar2 != (ly_err_item *)0x0) {
      plVar2 = plVar2->prev;
      pcVar3 = strdup(apptag);
      plVar2->apptag = pcVar3;
    }
  }
  return;
}



int lydict_val_eq(void *val1_p,void *val2_p,int UNUSED_mod,void *cb_data)

{
  int iVar1;
  void *cb_data_local;
  int UNUSED_mod_local;
  void *val2_p_local;
  void *val1_p_local;
  char *str1;
  char *str2;
  
  if ((val1_p == (void *)0x0) || (val2_p == (void *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lydict_val_eq");
    iVar1 = 0;
  }
  else {
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
    if ((*val1_p == (char *)0x0) || ((*val2_p == (char *)0x0 || (cb_data == (void *)0x0)))) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lydict_val_eq");
      iVar1 = 0;
    }
    else {
                    // WARNING: Load size is inaccurate
      iVar1 = strncmp(*val1_p,*val2_p,*cb_data);
      if (iVar1 == 0) {
        iVar1 = 1;
      }
      else {
        iVar1 = 0;
      }
    }
  }
  return iVar1;
}



void lydict_init(dict_table *dict)

{
  hash_table *phVar1;
  dict_table *dict_local;
  
  if (dict == (dict_table *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lydict_init");
  }
  else {
    phVar1 = lyht_new(0x400,0xc,lydict_val_eq,(void *)0x0,1);
    dict->hash_tab = phVar1;
    if (dict->hash_tab == (hash_table *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
             ,0x39);
    }
    else {
      pthread_mutex_init((pthread_mutex_t *)&dict->lock,(pthread_mutexattr_t *)0x0);
    }
  }
  return;
}



void lydict_clean(dict_table *dict)

{
  uchar *puVar1;
  uint uVar2;
  dict_table *dict_local;
  uint i;
  dict_rec *dict_rec;
  ht_rec *rec;
  
  if (dict == (dict_table *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lydict_clean");
  }
  else {
    for (i = 0; i < dict->hash_tab->size; i = i + 1) {
      puVar1 = dict->hash_tab->recs;
      uVar2 = dict->hash_tab->rec_size * i;
      if (*(int *)(puVar1 + (ulong)uVar2 + 4) == 1) {
        ly_log((ly_ctx *)0x0,LY_LLWRN,LY_SUCCESS,
               "String \"%s\" not freed from the dictionary, refcount %d",
               *(undefined8 *)(puVar1 + (ulong)uVar2 + 8),
               (ulong)*(uint *)(puVar1 + (ulong)uVar2 + 0x10));
      }
    }
    lyht_free(dict->hash_tab);
    pthread_mutex_destroy((pthread_mutex_t *)&dict->lock);
  }
  return;
}



uint32_t dict_hash(char *key,size_t len)

{
  uint uVar1;
  size_t len_local;
  char *key_local;
  uint32_t hash;
  uint32_t i;
  
  hash = 0;
  for (i = 0; i < len; i = i + 1) {
    uVar1 = (hash + (int)key[i]) * 0x401;
    hash = uVar1 ^ uVar1 >> 6;
  }
  return (hash * 9 ^ hash * 9 >> 0xb) * 0x8001;
}



uint32_t dict_hash_multi(uint32_t hash,char *key_part,size_t len)

{
  uint uVar1;
  size_t len_local;
  char *key_part_local;
  uint32_t hash_local;
  uint32_t i;
  
  if (key_part == (char *)0x0) {
    hash_local = (hash * 9 ^ hash * 9 >> 0xb) * 0x8001;
  }
  else {
    hash_local = hash;
    for (i = 0; i < len; i = i + 1) {
      uVar1 = (hash_local + (int)key_part[i]) * 0x401;
      hash_local = uVar1 ^ uVar1 >> 6;
    }
  }
  return hash_local;
}



void lydict_remove(ly_ctx *ctx,char *value)

{
  long lVar1;
  uint32_t hash_00;
  int iVar2;
  long in_FS_OFFSET;
  char *value_local;
  ly_ctx *ctx_local;
  uint32_t hash;
  int ret;
  size_t len;
  dict_rec *match;
  char *val_p;
  dict_rec rec;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lydict_remove");
  match = (dict_rec *)0x0;
  if ((value != (char *)0x0) && (ctx != (ly_ctx *)0x0)) {
    len = strlen(value);
    hash_00 = dict_hash(value,len);
    rec.refcount = 0;
    rec.value = value;
    pthread_mutex_lock((pthread_mutex_t *)&(ctx->dict).lock);
    lyht_set_cb_data((ctx->dict).hash_tab,&len);
    iVar2 = lyht_find((ctx->dict).hash_tab,&rec,hash_00,&match);
    if (iVar2 == 0) {
      if (match == (dict_rec *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
               ,0xad);
      }
      else {
        match->refcount = match->refcount - 1;
        if (match->refcount == 0) {
          val_p = match->value;
          iVar2 = lyht_remove((ctx->dict).hash_tab,&rec,hash_00);
          free(val_p);
          if (iVar2 != 0) {
            ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                   ,0xba);
          }
        }
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)&(ctx->dict).lock);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



char * dict_insert(ly_ctx *ctx,char *value,size_t len,int zerocopy)

{
  long lVar1;
  dict_rec *pdVar2;
  char *pcVar3;
  long in_FS_OFFSET;
  int zerocopy_local;
  size_t len_local;
  char *value_local;
  ly_ctx *ctx_local;
  int ret;
  uint32_t hash;
  dict_rec *match;
  dict_rec rec;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  match = (dict_rec *)0x0;
  ret = 0;
  len_local = len;
  value_local = value;
  ctx_local = ctx;
  hash = dict_hash(value,len);
  lyht_set_cb_data((ctx_local->dict).hash_tab,&len_local);
  rec.value = value_local;
  rec.refcount = 1;
  ly_log_dbg(1,"inserting \"%s\"",value_local);
  ret = lyht_insert((ctx_local->dict).hash_tab,&rec,hash,&match);
  pdVar2 = match;
  if (ret == 1) {
    match->refcount = match->refcount + 1;
    if (zerocopy != 0) {
      free(value_local);
    }
  }
  else {
    if (ret != 0) {
      ly_log(ctx_local,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
             ,0xe4);
      pcVar3 = (char *)0x0;
      goto LAB_0011667d;
    }
    if (zerocopy == 0) {
      pcVar3 = (char *)malloc(len_local + 1);
      pdVar2->value = pcVar3;
      if (match->value == (char *)0x0) {
        ly_log(ctx_local,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","dict_insert");
        pcVar3 = (char *)0x0;
        goto LAB_0011667d;
      }
      memcpy(match->value,value_local,len_local);
      match->value[len_local] = '\0';
    }
  }
  pcVar3 = match->value;
LAB_0011667d:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pcVar3;
}



char * lydict_insert(ly_ctx *ctx,char *value,size_t len)

{
  char *pcVar1;
  size_t len_local;
  char *value_local;
  ly_ctx *ctx_local;
  char *result;
  
  ly_log_dbg(0x20,"%s","lydict_insert");
  if (value == (char *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    len_local = len;
    if (len == 0) {
      len_local = strlen(value);
    }
    pthread_mutex_lock((pthread_mutex_t *)&(ctx->dict).lock);
    pcVar1 = dict_insert(ctx,value,len_local,0);
    pthread_mutex_unlock((pthread_mutex_t *)&(ctx->dict).lock);
  }
  return pcVar1;
}



char * lydict_insert_zc(ly_ctx *ctx,char *value)

{
  char *pcVar1;
  size_t len;
  char *value_local;
  ly_ctx *ctx_local;
  char *result;
  
  ly_log_dbg(0x20,"%s","lydict_insert_zc");
  if (value == (char *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    pthread_mutex_lock((pthread_mutex_t *)&(ctx->dict).lock);
    len = strlen(value);
    pcVar1 = dict_insert(ctx,value,len,1);
    pthread_mutex_unlock((pthread_mutex_t *)&(ctx->dict).lock);
  }
  return pcVar1;
}



ht_rec * lyht_get_rec(uchar *recs,uint16_t rec_size,uint32_t idx)

{
  uint32_t idx_local;
  uint16_t rec_size_local;
  uchar *recs_local;
  
  return (ht_rec *)(recs + rec_size * idx);
}



hash_table *
lyht_new(uint32_t size,uint16_t val_size,values_equal_cb val_equal,void *cb_data,int resize)

{
  hash_table *__ptr;
  uchar *puVar1;
  int resize_local;
  void *cb_data_local;
  values_equal_cb val_equal_local;
  uint16_t val_size_local;
  uint32_t size_local;
  hash_table *ht;
  
  if ((size == 0) || ((size - 1 & size) != 0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("size && !(size & (size - 1))",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                  ,0x11f,"lyht_new");
  }
  if ((val_equal != (values_equal_cb)0x0) && (val_size != 0)) {
    if ((resize != 0) && (resize != 1)) {
                    // WARNING: Subroutine does not return
      __assert_fail("resize == 0 || resize == 1",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                    ,0x121,"lyht_new");
    }
    size_local = size;
    if (size < 8) {
      size_local = 8;
    }
    __ptr = (hash_table *)malloc(0x28);
    if (__ptr == (hash_table *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyht_new");
      __ptr = (hash_table *)0x0;
    }
    else {
      __ptr->used = 0;
      __ptr->size = size_local;
      __ptr->val_equal = val_equal;
      __ptr->cb_data = cb_data;
      __ptr->resize = (uint16_t)resize;
      __ptr->rec_size = val_size + 8;
      puVar1 = (uchar *)calloc((ulong)size_local,(ulong)__ptr->rec_size);
      __ptr->recs = puVar1;
      if (__ptr->recs == (uchar *)0x0) {
        free(__ptr);
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyht_new");
        __ptr = (hash_table *)0x0;
      }
    }
    return __ptr;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("val_equal && val_size",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                ,0x120,"lyht_new");
}



values_equal_cb lyht_set_cb(hash_table *ht,values_equal_cb new_val_equal)

{
  values_equal_cb p_Var1;
  values_equal_cb new_val_equal_local;
  hash_table *ht_local;
  values_equal_cb prev;
  
  p_Var1 = ht->val_equal;
  ht->val_equal = new_val_equal;
  return p_Var1;
}



void * lyht_set_cb_data(hash_table *ht,void *new_cb_data)

{
  void *pvVar1;
  void *new_cb_data_local;
  hash_table *ht_local;
  void *prev;
  
  pvVar1 = ht->cb_data;
  ht->cb_data = new_cb_data;
  return pvVar1;
}



hash_table * lyht_dup(hash_table *orig)

{
  hash_table *phVar1;
  hash_table *orig_local;
  hash_table *ht;
  
  if (orig == (hash_table *)0x0) {
    phVar1 = (hash_table *)0x0;
  }
  else {
    phVar1 = lyht_new(orig->size,orig->rec_size - 8,orig->val_equal,orig->cb_data,
                      (uint)(orig->resize != 0));
    if (phVar1 == (hash_table *)0x0) {
      phVar1 = (hash_table *)0x0;
    }
    else {
      memcpy(phVar1->recs,orig->recs,(ulong)orig->used * (ulong)orig->rec_size);
      phVar1->used = orig->used;
    }
  }
  return phVar1;
}



void lyht_free(hash_table *ht)

{
  hash_table *ht_local;
  
  if (ht != (hash_table *)0x0) {
    free(ht->recs);
    free(ht);
  }
  return;
}



int lyht_resize(hash_table *ht,int enlarge)

{
  uint uVar1;
  uchar *recs;
  int iVar2;
  uchar *puVar3;
  ht_rec *phVar4;
  int enlarge_local;
  hash_table *ht_local;
  uint32_t i;
  uint32_t old_size;
  int ret;
  uchar *old_recs;
  ht_rec *rec;
  
  recs = ht->recs;
  uVar1 = ht->size;
  if (enlarge == 0) {
    ht->size = ht->size >> 1;
  }
  else {
    ht->size = ht->size * 2;
  }
  puVar3 = (uchar *)calloc((ulong)ht->size,(ulong)ht->rec_size);
  ht->recs = puVar3;
  if (ht->recs == (uchar *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyht_resize");
    ht->recs = recs;
    ht->size = uVar1;
    iVar2 = -1;
  }
  else {
    ht->used = 0;
    for (i = 0; i < uVar1; i = i + 1) {
      phVar4 = lyht_get_rec(recs,ht->rec_size,i);
      if (0 < phVar4->hits) {
        iVar2 = lyht_insert(ht,phVar4->val,phVar4->hash,(void **)0x0);
        if (iVar2 != 0) {
                    // WARNING: Subroutine does not return
          __assert_fail("!ret",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                        ,0x186,"lyht_resize");
        }
      }
    }
    free(recs);
    iVar2 = 0;
  }
  return iVar2;
}



int lyht_find_first(hash_table *ht,uint32_t hash,ht_rec **rec_p)

{
  uint idx_00;
  int iVar1;
  ht_rec **rec_p_local;
  uint32_t hash_local;
  hash_table *ht_local;
  uint32_t i;
  uint32_t idx;
  ht_rec *rec;
  ht_rec *inval_rec;
  
  inval_rec = (ht_rec *)0x0;
  if (rec_p != (ht_rec **)0x0) {
    *rec_p = (ht_rec *)0x0;
  }
  idx_00 = ht->size - 1 & hash;
  rec = lyht_get_rec(ht->recs,ht->rec_size,idx_00);
  i = idx_00;
  while( true ) {
    if ((rec->hits == 0) || ((rec->hits != -1 && (idx_00 == (ht->size - 1 & rec->hash))))) {
      if (rec->hits == 0) {
        if (rec_p != (ht_rec **)0x0) {
          if (inval_rec != (ht_rec *)0x0) {
            rec = inval_rec;
          }
          *rec_p = rec;
        }
        iVar1 = 1;
      }
      else {
        if (inval_rec != (ht_rec *)0x0) {
          memcpy(inval_rec,rec,(ulong)ht->rec_size);
          rec->hits = -1;
          rec = inval_rec;
        }
        if (rec_p != (ht_rec **)0x0) {
          *rec_p = rec;
        }
        iVar1 = 0;
      }
      return iVar1;
    }
    if ((rec->hits == -1) && (inval_rec == (ht_rec *)0x0)) {
      inval_rec = rec;
    }
    i = (i + 1) % ht->size;
    if (i == idx_00) break;
    rec = lyht_get_rec(ht->recs,ht->rec_size,i);
  }
  if (inval_rec != (ht_rec *)0x0) {
    if (rec_p != (ht_rec **)0x0) {
      *rec_p = inval_rec;
    }
    return 1;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("inval_rec",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                ,0x1a9,"lyht_find_first");
}



int lyht_find_collision(hash_table *ht,ht_rec **last,ht_rec *first)

{
  uint uVar1;
  uint32_t uVar2;
  int iVar3;
  ht_rec *phVar4;
  ht_rec *first_local;
  ht_rec **last_local;
  hash_table *ht_local;
  uint32_t i;
  uint32_t idx;
  ht_rec *inval_rec;
  
  inval_rec = (ht_rec *)0x0;
  if ((last != (ht_rec **)0x0) && (*last != (ht_rec *)0x0)) {
    uVar1 = (*last)->hash;
    uVar2 = ht->size;
    i = (uint32_t)(((long)*last - (long)ht->recs) / (long)(ulong)ht->rec_size);
    do {
      i = (i + 1) % ht->size;
      phVar4 = lyht_get_rec(ht->recs,ht->rec_size,i);
      *last = phVar4;
      if (first == *last) {
        if (inval_rec != (ht_rec *)0x0) {
          *last = inval_rec;
          return 1;
        }
                    // WARNING: Subroutine does not return
        __assert_fail("inval_rec",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                      ,0x1e2,"lyht_find_collision");
      }
      if (((*last)->hits == -1) && (inval_rec == (ht_rec *)0x0)) {
        inval_rec = *last;
      }
    } while (((*last)->hits != 0) &&
            (((*last)->hits == -1 || ((uVar2 - 1 & uVar1) != (ht->size - 1 & (*last)->hash)))));
    if ((*last)->hits < 1) {
      if (inval_rec != (ht_rec *)0x0) {
        *last = inval_rec;
      }
      iVar3 = 1;
    }
    else {
      if ((*last)->hits != 1) {
                    // WARNING: Subroutine does not return
        __assert_fail("(*last)->hits == 1",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                      ,0x1ee,"lyht_find_collision");
      }
      if (inval_rec != (ht_rec *)0x0) {
        memcpy(inval_rec,*last,(ulong)ht->rec_size);
        (*last)->hits = -1;
        *last = inval_rec;
      }
      iVar3 = 0;
    }
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("last && *last",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                ,0x1d7,"lyht_find_collision");
}



int lyht_find(hash_table *ht,void *val_p,uint32_t hash,void **match_p)

{
  uint uVar1;
  int iVar2;
  long in_FS_OFFSET;
  void **match_p_local;
  uint32_t hash_local;
  void *val_p_local;
  hash_table *ht_local;
  uint32_t i;
  uint32_t c;
  int r;
  ht_rec *rec;
  ht_rec *crec;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar2 = lyht_find_first(ht,hash,&rec);
  if (iVar2 == 0) {
    if (hash == rec->hash) {
      iVar2 = (*ht->val_equal)(val_p,rec->val,0,ht->cb_data);
      if (iVar2 != 0) {
        if (match_p != (void **)0x0) {
          *match_p = rec->val;
        }
        iVar2 = 0;
        goto LAB_001171b2;
      }
    }
    crec = rec;
    uVar1 = rec->hits;
    for (i = 1; i < uVar1; i = i + 1) {
      iVar2 = lyht_find_collision(ht,&rec,crec);
      if (iVar2 != 0) {
                    // WARNING: Subroutine does not return
        __assert_fail("!r",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                      ,0x216,"lyht_find");
      }
      if (hash == rec->hash) {
        iVar2 = (*ht->val_equal)(val_p,rec->val,0,ht->cb_data);
        if (iVar2 != 0) {
          if (match_p != (void **)0x0) {
            *match_p = rec->val;
          }
          iVar2 = 0;
          goto LAB_001171b2;
        }
      }
    }
    iVar2 = 1;
  }
  else {
    iVar2 = 1;
  }
LAB_001171b2:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lyht_find_next(hash_table *ht,void *val_p,uint32_t hash,void **match_p)

{
  uint uVar1;
  bool bVar2;
  int iVar3;
  long in_FS_OFFSET;
  void **match_p_local;
  uint32_t hash_local;
  void *val_p_local;
  hash_table *ht_local;
  uint32_t i;
  int found;
  uint32_t c;
  int r;
  ht_rec *rec;
  ht_rec *crec;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  bVar2 = false;
  iVar3 = lyht_find_first(ht,hash,&rec);
  if (iVar3 != 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("0",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                  ,0x22f,"lyht_find_next");
  }
  if ((hash == rec->hash) && (iVar3 = (*ht->val_equal)(val_p,rec->val,1,ht->cb_data), iVar3 != 0)) {
    bVar2 = true;
  }
  if (rec->hits == 1) {
    if (hash != rec->hash) {
                    // WARNING: Subroutine does not return
      __assert_fail("rec->hash == hash",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                    ,0x239,"lyht_find_next");
    }
    if (!bVar2) {
                    // WARNING: Subroutine does not return
      __assert_fail("found",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                    ,0x23a,"lyht_find_next");
    }
    iVar3 = 1;
  }
  else {
    crec = rec;
    uVar1 = rec->hits;
    for (i = 1; i < uVar1; i = i + 1) {
      iVar3 = lyht_find_collision(ht,&rec,crec);
      if (iVar3 != 0) {
                    // WARNING: Subroutine does not return
        __assert_fail("!r",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                      ,0x243,"lyht_find_next");
      }
      if (hash == rec->hash) {
        if (bVar2) {
          if (match_p != (void **)0x0) {
            *match_p = rec->val;
          }
          iVar3 = 0;
          goto LAB_001173d6;
        }
        iVar3 = (*ht->val_equal)(val_p,rec->val,1,ht->cb_data);
        if (iVar3 != 0) {
          bVar2 = true;
        }
      }
    }
    if (!bVar2) {
                    // WARNING: Subroutine does not return
      __assert_fail("found",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                    ,0x25d,"lyht_find_next");
    }
    iVar3 = 1;
  }
LAB_001173d6:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * lyht_dbgprint_val2str(void *val_p,int32_t hits,uint16_t rec_size)

{
  int iVar1;
  char *pcVar2;
  uint16_t rec_size_local;
  int32_t hits_local;
  void *val_p_local;
  int32_t i;
  int32_t j;
  int32_t val_size;
  char *val;
  
  iVar1 = rec_size - 8;
  pcVar2 = (char *)malloc((long)(iVar1 * 2 + 1));
  j = rec_size - 9;
  for (i = 0; i < iVar1; i = i + 1) {
    if (hits < 1) {
      sprintf(pcVar2 + i * 2,"  ");
    }
    else {
      sprintf(pcVar2 + i * 2,"%02x",(ulong)*(byte *)((long)val_p + (long)j));
    }
    j = j + -1;
  }
  return pcVar2;
}



void lyht_dbgprint_ht(hash_table *ht,char *info)

{
  char *pcVar1;
  size_t sVar2;
  ht_rec *phVar3;
  char *info_local;
  hash_table *ht_local;
  uint32_t i;
  uint32_t i_len;
  char *val;
  ht_rec *rec;
  
  if (2 < ly_log_level) {
    ly_log_dbg(0x40,"");
    ly_log_dbg(0x40,"hash table %s (used %u, size %u):",info,(ulong)ht->used,(ulong)ht->size);
    pcVar1 = (char *)malloc(0xb);
    sprintf(pcVar1,"%u",(ulong)ht->size);
    sVar2 = strlen(pcVar1);
    free(pcVar1);
    for (i = 0; i < ht->size; i = i + 1) {
      phVar3 = lyht_get_rec(ht->recs,ht->rec_size,i);
      pcVar1 = lyht_dbgprint_val2str(phVar3->val,phVar3->hits,ht->rec_size);
      if (phVar3->hits < 1) {
        ly_log_dbg(0x40,"[%*u] val  %s  hash  %10s %% %*s  hits  %2d",sVar2 & 0xffffffff,(ulong)i,
                   pcVar1,&DAT_0020e86c,sVar2 & 0xffffffff,&DAT_0020e86c,(ulong)(uint)phVar3->hits);
      }
      else {
        ly_log_dbg(0x40,"[%*u] val  %s  hash  %10u %% %*u  hits  %2d",sVar2 & 0xffffffff,(ulong)i,
                   pcVar1,(ulong)phVar3->hash,sVar2 & 0xffffffff,
                   (ulong)(phVar3->hash & ht->size - 1),(ulong)(uint)phVar3->hits);
      }
      free(pcVar1);
    }
    ly_log_dbg(0x40,"");
  }
  return;
}



void lyht_dbgprint_value(void *val_p,uint32_t hash,uint16_t rec_size,char *operation)

{
  char *__ptr;
  char *operation_local;
  uint16_t rec_size_local;
  uint32_t hash_local;
  void *val_p_local;
  char *val;
  
  if (2 < ly_log_level) {
    __ptr = lyht_dbgprint_val2str(val_p,1,rec_size);
    ly_log_dbg(0x40,"%s value %s with hash %u",operation,__ptr,(ulong)hash);
    free(__ptr);
  }
  return;
}



int lyht_insert_with_resize_cb
              (hash_table *ht,void *val_p,uint32_t hash,values_equal_cb resize_val_equal,
              void **match_p)

{
  int iVar1;
  uint uVar2;
  long in_FS_OFFSET;
  void **match_p_local;
  values_equal_cb resize_val_equal_local;
  uint32_t hash_local;
  void *val_p_local;
  hash_table *ht_local;
  int32_t i;
  int ret;
  int r;
  ht_rec *rec;
  ht_rec *crec;
  values_equal_cb old_val_equal;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  crec = (ht_rec *)0x0;
  lyht_dbgprint_ht(ht,"before");
  lyht_dbgprint_value(val_p,hash,ht->rec_size,"inserting");
  iVar1 = lyht_find_first(ht,hash,&rec);
  if (iVar1 == 0) {
    if (hash == rec->hash) {
      iVar1 = (*ht->val_equal)(val_p,rec->val,1,ht->cb_data);
      if (iVar1 != 0) {
        if (match_p != (void **)0x0) {
          *match_p = rec->val;
        }
        ret = 1;
        goto LAB_00117ac5;
      }
    }
    crec = rec;
    for (i = 1; i < crec->hits; i = i + 1) {
      iVar1 = lyht_find_collision(ht,&rec,crec);
      if (iVar1 != 0) {
                    // WARNING: Subroutine does not return
        __assert_fail("!r",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                      ,0x2be,"lyht_insert_with_resize_cb");
      }
      if (hash == rec->hash) {
        iVar1 = (*ht->val_equal)(val_p,rec->val,1,ht->cb_data);
        if (iVar1 != 0) {
          if (match_p != (void **)0x0) {
            *match_p = rec->val;
          }
          ret = 1;
          goto LAB_00117ac5;
        }
      }
    }
    iVar1 = lyht_find_collision(ht,&rec,crec);
    if (iVar1 == 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("r",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                    ,0x2cb,"lyht_insert_with_resize_cb");
    }
  }
  if (0 < rec->hits) {
                    // WARNING: Subroutine does not return
    __assert_fail("rec->hits < 1",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                  ,0x2cf,"lyht_insert_with_resize_cb");
  }
  rec->hash = hash;
  rec->hits = 1;
  memcpy(rec->val,val_p,(ulong)ht->rec_size - 8);
  if (match_p != (void **)0x0) {
    *match_p = rec->val;
  }
  if (crec != (ht_rec *)0x0) {
    if (crec->hits == 0x7fffffff) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
             ,0x2da);
    }
    crec->hits = crec->hits + 1;
  }
  ret = 0;
  ht->used = ht->used + 1;
  if (ht->resize != 0) {
    uVar2 = (ht->used * 100) / ht->size;
    if ((ht->resize == 1) && (0x31 < (int)uVar2)) {
      ht->resize = 2;
    }
    if ((ht->resize == 2) && (0x4a < (int)uVar2)) {
      if (resize_val_equal != (values_equal_cb)0x0) {
        old_val_equal = lyht_set_cb(ht,resize_val_equal);
      }
      ret = lyht_resize(ht,1);
      if ((ret == 0) && (match_p != (void **)0x0)) {
        lyht_find(ht,val_p,hash,match_p);
      }
      if (resize_val_equal != (values_equal_cb)0x0) {
        lyht_set_cb(ht,old_val_equal);
      }
    }
  }
  lyht_dbgprint_ht(ht,"after");
LAB_00117ac5:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return ret;
}



int lyht_insert(hash_table *ht,void *val_p,uint32_t hash,void **match_p)

{
  int iVar1;
  void **match_p_local;
  uint32_t hash_local;
  void *val_p_local;
  hash_table *ht_local;
  
  iVar1 = lyht_insert_with_resize_cb(ht,val_p,hash,(values_equal_cb)0x0,match_p);
  return iVar1;
}



int lyht_remove(hash_table *ht,void *val_p,uint32_t hash)

{
  bool bVar1;
  int iVar2;
  long in_FS_OFFSET;
  uint32_t hash_local;
  void *val_p_local;
  hash_table *ht_local;
  int32_t i;
  int first_matched;
  int ret;
  int r;
  ht_rec *rec;
  ht_rec *crec;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  bVar1 = false;
  lyht_dbgprint_ht(ht,"before");
  lyht_dbgprint_value(val_p,hash,ht->rec_size,"removing");
  iVar2 = lyht_find_first(ht,hash,&rec);
  if (iVar2 == 0) {
    if ((hash == rec->hash) && (iVar2 = (*ht->val_equal)(val_p,rec->val,1,ht->cb_data), iVar2 != 0))
    {
      bVar1 = true;
    }
    crec = rec;
    for (i = 1; i < crec->hits; i = i + 1) {
      iVar2 = lyht_find_collision(ht,&rec,crec);
      if (iVar2 != 0) {
                    // WARNING: Subroutine does not return
        __assert_fail("!r",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                      ,0x31c,"lyht_remove");
      }
      if (((!bVar1) && (hash == rec->hash)) &&
         (iVar2 = (*ht->val_equal)(val_p,rec->val,1,ht->cb_data), iVar2 != 0)) break;
    }
    if (i < crec->hits) {
      if (bVar1) {
                    // WARNING: Subroutine does not return
        __assert_fail("!first_matched",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                      ,0x326,"lyht_remove");
      }
      crec->hits = crec->hits + -1;
      rec->hits = -1;
    }
    else {
      if (!bVar1) {
        if (false) {
                    // WARNING: Subroutine does not return
          __assert_fail("!first_matched",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/hash_table.c"
                        ,0x335,"lyht_remove");
        }
        ly_log_dbg(0x40,"remove failed");
        ret = 1;
        goto LAB_00117df4;
      }
      if (crec != rec) {
        rec->hits = crec->hits + -1;
        memcpy(crec,rec,(ulong)ht->rec_size);
      }
      rec->hits = -1;
    }
    ret = 0;
    ht->used = ht->used - 1;
    if (((ht->resize == 2) && ((int)((ht->used * 100) / ht->size) < 0x19)) && (8 < ht->size)) {
      ret = lyht_resize(ht,0);
    }
    lyht_dbgprint_ht(ht,"after");
  }
  else {
    ly_log_dbg(0x40,"remove failed");
    ret = 1;
  }
LAB_00117df4:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int parse_range_dec64(char **str_num,uint8_t dig,int64_t *num)

{
  bool bVar1;
  bool bVar2;
  int iVar3;
  ushort **ppuVar4;
  int64_t iVar5;
  long lVar6;
  int64_t *num_local;
  uint8_t dig_local;
  char **str_num_local;
  int8_t str_exp;
  int8_t str_dig;
  int8_t trailing_zeros;
  int minus;
  char *ptr;
  int64_t ret;
  int64_t prev_ret;
  
  bVar2 = false;
  ret = 0;
  str_dig = -1;
  trailing_zeros = '\0';
  ptr = *str_num;
  if (*ptr == '-') {
    bVar2 = true;
    ptr = ptr + 1;
  }
  else if (*ptr == '+') {
    ptr = ptr + 1;
  }
  ppuVar4 = __ctype_b_loc();
  if (((*ppuVar4)[*ptr] & 0x800) == 0) {
    iVar3 = 1;
  }
  else {
    str_exp = '\0';
    while ((ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[*ptr] & 0x800) != 0 ||
           ((*ptr == '.' && (str_dig < '\0'))))) {
      if ('\x12' < str_exp) {
        return 1;
      }
      if (*ptr == '.') {
        if (ptr[1] == '.') break;
        str_dig = str_dig + '\x01';
      }
      else {
        if (bVar2) {
          lVar6 = ret * 10 - (long)(*ptr + -0x30);
          bVar1 = ret < lVar6;
          ret = lVar6;
          if (bVar1) {
            return 1;
          }
        }
        else {
          lVar6 = (long)(*ptr + -0x30) + ret * 10;
          bVar1 = lVar6 < ret;
          ret = lVar6;
          if (bVar1) {
            return 1;
          }
        }
        if (-1 < str_dig) {
          str_dig = str_dig + '\x01';
          if (*ptr == '0') {
            trailing_zeros = trailing_zeros + '\x01';
          }
          else {
            trailing_zeros = '\0';
          }
        }
        str_exp = str_exp + '\x01';
      }
      ptr = ptr + 1;
    }
    if (str_dig == '\0') {
      iVar3 = 1;
    }
    else {
      if (str_dig == -1) {
        str_dig = '\0';
      }
      if (trailing_zeros != '\0') {
        str_dig = str_dig - trailing_zeros;
        str_exp = str_exp - trailing_zeros;
        iVar5 = dec_pow(trailing_zeros);
        ret = ret / iVar5;
      }
      iVar5 = ret;
      if ((int)str_dig < (int)(uint)dig) {
        if (0x12 < (int)(((uint)dig - (int)str_dig) + str_exp + -1)) {
          return 1;
        }
        iVar5 = dec_pow(dig - str_dig);
        iVar5 = iVar5 * ret;
        if (((bVar2) && (ret < iVar5)) || ((!bVar2 && (iVar5 < ret)))) {
          return 1;
        }
      }
      ret = iVar5;
      if ((int)(uint)dig < (int)str_dig) {
        iVar3 = 1;
      }
      else {
        *str_num = ptr;
        *num = ret;
        iVar3 = 0;
      }
    }
  }
  return iVar3;
}



uint parse_identifier(char *id)

{
  ushort **ppuVar1;
  char *id_local;
  uint parsed;
  
  if (id != (char *)0x0) {
    ppuVar1 = __ctype_b_loc();
    if ((((*ppuVar1)[*id] & 0x400) == 0) && (*id != '_')) {
      parsed = 0;
    }
    else {
      parsed = 1;
      for (id_local = id + 1;
          (((ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[*id_local] & 8) != 0 || (*id_local == '_')) ||
           (*id_local == '-')) || (*id_local == '.')); id_local = id_local + 1) {
        parsed = parsed + 1;
      }
    }
    return parsed;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("id",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                ,0x9f,"parse_identifier");
}



int parse_node_identifier
              (char *id,char **mod_name,int *mod_name_len,char **name,int *nam_len,int *all_desc,
              int extended)

{
  char *pcVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  int *all_desc_local_1;
  int *nam_len_local;
  char **name_local;
  int *mod_name_len_local;
  char **mod_name_local;
  char *id_local;
  int ret;
  int all_desc_local;
  int parsed;
  int first_id_len;
  char *first_id;
  
  all_desc_local = 0;
  if (id == (char *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("id",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,199,"parse_node_identifier");
  }
  if (((mod_name == (char **)0x0) || (mod_name_len == (int *)0x0)) &&
     ((mod_name != (char **)0x0 || (mod_name_len != (int *)0x0)))) {
                    // WARNING: Subroutine does not return
    __assert_fail("(mod_name && mod_name_len) || (!mod_name && !mod_name_len)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,200,"parse_node_identifier");
  }
  if (((name == (char **)0x0) || (nam_len == (int *)0x0)) &&
     ((name != (char **)0x0 || (nam_len != (int *)0x0)))) {
                    // WARNING: Subroutine does not return
    __assert_fail("(name && nam_len) || (!name && !nam_len)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0xc9,"parse_node_identifier");
  }
  if (mod_name != (char **)0x0) {
    *mod_name = (char *)0x0;
    *mod_name_len = 0;
  }
  if (name != (char **)0x0) {
    *name = (char *)0x0;
    *nam_len = 0;
  }
  if (extended != 0) {
    if (*id == '/') {
      if (all_desc != (int *)0x0) {
        *all_desc = 1;
      }
      all_desc_local = 1;
    }
    else if (all_desc != (int *)0x0) {
      *all_desc = 0;
    }
    uVar2 = parse_identifier(id + all_desc_local);
    if ((int)uVar2 < 1) {
      ret = all_desc_local;
    }
    else {
      if (id[(int)(uVar2 + all_desc_local)] != ':') goto LAB_001184bb;
      if (mod_name != (char **)0x0) {
        *mod_name = id + all_desc_local;
        *mod_name_len = uVar2;
      }
      ret = uVar2 + all_desc_local + 1;
    }
    if (id[ret] == '*') {
      if (name != (char **)0x0) {
        *name = id + ret;
        *nam_len = 1;
      }
      return ret + 1;
    }
    if (id[ret] == '.') {
      if (all_desc_local == 0) {
        return -ret;
      }
      if (name != (char **)0x0) {
        *name = id + ret;
        *nam_len = 1;
      }
      return ret + 1;
    }
    if (id[ret] == '#') {
      if ((all_desc_local == 0) && (ret != 0)) {
        iVar3 = ret + 1;
        uVar2 = parse_identifier(id + iVar3);
        if ((int)uVar2 < 1) {
          return uVar2 - iVar3;
        }
        *name = id + (long)iVar3 + -1;
        *nam_len = uVar2 + 1;
        return uVar2 + iVar3;
      }
      return 0;
    }
  }
LAB_001184bb:
  uVar2 = parse_identifier(id);
  if (0 < (int)uVar2) {
    pcVar1 = id + (int)uVar2;
    if (*pcVar1 == ':') {
      uVar4 = parse_identifier(pcVar1 + 1);
      if ((int)uVar4 < 1) {
        uVar2 = uVar4 - (uVar2 + 1);
      }
      else {
        if (mod_name != (char **)0x0) {
          *mod_name = id;
          *mod_name_len = uVar2;
        }
        if (name != (char **)0x0) {
          *name = pcVar1 + 1;
          *nam_len = uVar4;
        }
        uVar2 = uVar4 + uVar2 + 1;
      }
    }
    else if (name != (char **)0x0) {
      *name = id;
      *nam_len = uVar2;
    }
  }
  return uVar2;
}



int parse_path_predicate
              (char *id,char **prefix,int *pref_len,char **name,int *nam_len,char **path_key_expr,
              int *pke_len,int *has_predicate)

{
  int iVar1;
  ushort **ppuVar2;
  char **path_key_expr_local;
  int *nam_len_local;
  char **name_local;
  int *pref_len_local;
  char **prefix_local;
  char *id_local;
  int parsed;
  int ret;
  char *ptr;
  
  if (id == (char *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("id",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x15e,"parse_path_predicate");
  }
  if (prefix != (char **)0x0) {
    *prefix = (char *)0x0;
  }
  if (pref_len != (int *)0x0) {
    *pref_len = 0;
  }
  if (name != (char **)0x0) {
    *name = (char *)0x0;
  }
  if (nam_len != (int *)0x0) {
    *nam_len = 0;
  }
  if (path_key_expr != (char **)0x0) {
    *path_key_expr = (char *)0x0;
  }
  if (pke_len != (int *)0x0) {
    *pke_len = 0;
  }
  if (has_predicate != (int *)0x0) {
    *has_predicate = 0;
  }
  if (*id == '[') {
    parsed = 1;
    id_local = id + 1;
    while (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[*id_local] & 0x2000) != 0) {
      parsed = parsed + 1;
      id_local = id_local + 1;
    }
    iVar1 = parse_node_identifier(id_local,prefix,pref_len,name,nam_len,(int *)0x0,0);
    if (iVar1 < 1) {
      iVar1 = iVar1 - parsed;
    }
    else {
      parsed = parsed + iVar1;
      id_local = id_local + iVar1;
      while (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[*id_local] & 0x2000) != 0) {
        parsed = parsed + 1;
        id_local = id_local + 1;
      }
      if (*id_local == '=') {
        do {
          parsed = parsed + 1;
          id_local = id_local + 1;
          ppuVar2 = __ctype_b_loc();
        } while (((*ppuVar2)[*id_local] & 0x2000) != 0);
        ptr = strchr(id_local,0x5d);
        if (ptr == (char *)0x0) {
          iVar1 = -parsed;
        }
        else {
          do {
            ptr = ptr + -1;
            ppuVar2 = __ctype_b_loc();
          } while (((*ppuVar2)[*ptr] & 0x2000) != 0);
          iVar1 = ((int)ptr + 1) - (int)id_local;
          if (path_key_expr != (char **)0x0) {
            *path_key_expr = id_local;
          }
          if (pke_len != (int *)0x0) {
            *pke_len = iVar1;
          }
          parsed = parsed + iVar1;
          id_local = id_local + iVar1;
          while (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[*id_local] & 0x2000) != 0) {
            parsed = parsed + 1;
            id_local = id_local + 1;
          }
          if (*id_local != ']') {
                    // WARNING: Subroutine does not return
            __assert_fail("id[0] == \']\'",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                          ,0x1b3,"parse_path_predicate");
          }
          if (id_local[1] == '[') {
            *has_predicate = 1;
          }
          iVar1 = parsed + 1;
        }
      }
      else {
        iVar1 = -parsed;
      }
    }
  }
  else {
    iVar1 = 0;
  }
  return iVar1;
}



int parse_path_key_expr(char *id,char **prefix,int *pref_len,char **name,int *nam_len,
                       int *parent_times)

{
  char *pcVar1;
  int iVar2;
  int iVar3;
  ushort **ppuVar4;
  int *parent_times_local;
  int *nam_len_local;
  char **name_local;
  int *pref_len_local;
  char **prefix_local;
  char *id_local;
  int parsed;
  int par_times;
  int ret;
  
  parsed = 0;
  par_times = 0;
  if (id == (char *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("id",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x1d7,"parse_path_key_expr");
  }
  if (parent_times == (int *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("parent_times",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x1d8,"parse_path_key_expr");
  }
  if (prefix != (char **)0x0) {
    *prefix = (char *)0x0;
  }
  if (pref_len != (int *)0x0) {
    *pref_len = 0;
  }
  if (name != (char **)0x0) {
    *name = (char *)0x0;
  }
  if (nam_len != (int *)0x0) {
    *nam_len = 0;
  }
  id_local = id;
  if (*parent_times == 0) {
    iVar2 = strncmp(id,"current()",9);
    if (iVar2 != 0) {
      return 0;
    }
    parsed = 9;
    id_local = id + 9;
    while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[*id_local] & 0x2000) != 0) {
      parsed = parsed + 1;
      id_local = id_local + 1;
    }
    if (*id_local != '/') {
      return -parsed;
    }
    do {
      iVar2 = parsed;
      pcVar1 = id_local;
      parsed = iVar2 + 1;
      id_local = pcVar1 + 1;
      ppuVar4 = __ctype_b_loc();
    } while (((*ppuVar4)[*id_local] & 0x2000) != 0);
    iVar3 = strncmp(id_local,"..",2);
    if (iVar3 != 0) {
      return -parsed;
    }
    par_times = 1;
    parsed = iVar2 + 3;
    id_local = pcVar1 + 3;
    while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[*id_local] & 0x2000) != 0) {
      parsed = parsed + 1;
      id_local = id_local + 1;
    }
  }
  if (*id_local == '/') {
    do {
      parsed = parsed + 1;
      id_local = id_local + 1;
      ppuVar4 = __ctype_b_loc();
    } while (((*ppuVar4)[*id_local] & 0x2000) != 0);
    while ((iVar2 = strncmp(id_local,"..",2), iVar2 == 0 && (*parent_times == 0))) {
      par_times = par_times + 1;
      parsed = parsed + 2;
      id_local = id_local + 2;
      while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[*id_local] & 0x2000) != 0) {
        parsed = parsed + 1;
        id_local = id_local + 1;
      }
      if (*id_local != '/') {
        return -parsed;
      }
      do {
        parsed = parsed + 1;
        id_local = id_local + 1;
        ppuVar4 = __ctype_b_loc();
      } while (((*ppuVar4)[*id_local] & 0x2000) != 0);
    }
    if (*parent_times == 0) {
      *parent_times = par_times;
    }
    iVar2 = parse_node_identifier(id_local,prefix,pref_len,name,nam_len,(int *)0x0,0);
    if (iVar2 < 1) {
      iVar2 = iVar2 - parsed;
    }
    else {
      iVar2 = parsed + iVar2;
    }
  }
  else {
    iVar2 = -parsed;
  }
  return iVar2;
}



int parse_path_arg(lys_module *mod,char *id,char **prefix,int *pref_len,char **name,int *nam_len,
                  int *parent_times,int *has_predicate)

{
  char *pcVar1;
  int iVar2;
  int iVar3;
  lys_module *plVar4;
  size_t sVar5;
  int *nam_len_local;
  char **name_local;
  int *pref_len_local;
  char **prefix_local;
  char *id_local;
  lys_module *mod_local;
  int parsed;
  int par_times;
  int ret;
  
  parsed = 0;
  par_times = 0;
  if (id == (char *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("id",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x261,"parse_path_arg");
  }
  if (parent_times != (int *)0x0) {
    if (prefix != (char **)0x0) {
      *prefix = (char *)0x0;
    }
    if (pref_len != (int *)0x0) {
      *pref_len = 0;
    }
    if (name != (char **)0x0) {
      *name = (char *)0x0;
    }
    if (nam_len != (int *)0x0) {
      *nam_len = 0;
    }
    if (has_predicate != (int *)0x0) {
      *has_predicate = 0;
    }
    id_local = id;
    if ((*parent_times == 0) && (iVar2 = strncmp(id,"..",2), iVar2 == 0)) {
      par_times = 1;
      parsed = 2;
      id_local = id + 2;
      while (iVar2 = strncmp(id_local,"/..",3), iVar2 == 0) {
        par_times = par_times + 1;
        parsed = parsed + 3;
        id_local = id_local + 3;
      }
    }
    if (*parent_times == 0) {
      if (par_times == 0) {
        *parent_times = -1;
      }
      else {
        *parent_times = par_times;
      }
    }
    if (*id_local == '/') {
      iVar2 = parse_node_identifier(id_local + 1,prefix,pref_len,name,nam_len,(int *)0x0,0);
      if (iVar2 < 1) {
        iVar3 = iVar2 - (parsed + 1);
      }
      else {
        if ((prefix != (char **)0x0) && (*prefix == (char *)0x0)) {
          plVar4 = lys_main_module(mod);
          *prefix = plVar4->name;
          sVar5 = strlen(*prefix);
          *pref_len = (int)sVar5;
        }
        iVar3 = parsed + 1 + iVar2;
        pcVar1 = id_local + 1 + iVar2;
        if ((*pcVar1 != '/') && (*pcVar1 != '\0')) {
          if (*pcVar1 == '[') {
            if (has_predicate != (int *)0x0) {
              *has_predicate = 1;
            }
          }
          else {
            iVar3 = -iVar3;
          }
        }
      }
    }
    else {
      iVar3 = -parsed;
    }
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("parent_times",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                ,0x262,"parse_path_arg");
}



int parse_instance_identifier
              (char *id,char **model,int *mod_len,char **name,int *nam_len,int *has_predicate)

{
  char *pcVar1;
  int iVar2;
  uint uVar3;
  int *has_predicate_local;
  int *nam_len_local;
  char **name_local;
  int *mod_len_local;
  char **model_local;
  char *id_local;
  int parsed;
  int ret;
  
  if ((((id != (char *)0x0) && (model != (char **)0x0)) && (mod_len != (int *)0x0)) &&
     ((name != (char **)0x0 && (nam_len != (int *)0x0)))) {
    if (has_predicate != (int *)0x0) {
      *has_predicate = 0;
    }
    if (*id == '/') {
      pcVar1 = id + 1;
      parsed = parse_identifier(pcVar1);
      if (0 < parsed) {
        *name = pcVar1;
        *nam_len = parsed;
        id_local = pcVar1 + parsed;
        iVar2 = parsed + 1;
        if (*id_local == ':') {
          *model = *name;
          *mod_len = *nam_len;
          pcVar1 = id_local + 1;
          uVar3 = parse_identifier(pcVar1);
          if ((int)uVar3 < 1) {
            return uVar3;
          }
          *name = pcVar1;
          *nam_len = uVar3;
          id_local = pcVar1 + (int)uVar3;
          iVar2 = parsed + 2U + uVar3;
        }
        parsed = iVar2;
        if ((*id_local == '[') && (has_predicate != (int *)0x0)) {
          *has_predicate = 1;
        }
      }
    }
    else {
      parsed = 0;
    }
    return parsed;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("id && model && mod_len && name && nam_len",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                ,0x2c2,"parse_instance_identifier");
}



int parse_predicate(char *id,char **model,int *mod_len,char **name,int *nam_len,char **value,
                   int *val_len,int *has_predicate)

{
  char *pcVar1;
  int iVar2;
  int iVar3;
  ushort **ppuVar4;
  char *pcVar5;
  char **value_local;
  int *nam_len_local;
  char **name_local;
  int *mod_len_local;
  char **model_local;
  char *id_local;
  char quote;
  int parsed;
  int ret;
  char *ptr;
  
  if (id == (char *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("id",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x312,"parse_predicate");
  }
  if (model != (char **)0x0) {
    if (mod_len == (int *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("mod_len",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                    ,0x314,"parse_predicate");
    }
    *model = (char *)0x0;
    *mod_len = 0;
  }
  if (name != (char **)0x0) {
    if (nam_len == (int *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("nam_len",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                    ,0x319,"parse_predicate");
    }
    *name = (char *)0x0;
    *nam_len = 0;
  }
  if (value != (char **)0x0) {
    if (val_len == (int *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("val_len",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                    ,0x31e,"parse_predicate");
    }
    *value = (char *)0x0;
    *val_len = 0;
  }
  if (has_predicate != (int *)0x0) {
    *has_predicate = 0;
  }
  if (*id != '[') {
    return 0;
  }
  parsed = 1;
  id_local = id + 1;
  while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[*id_local] & 0x2000) != 0) {
    parsed = parsed + 1;
    id_local = id_local + 1;
  }
  ppuVar4 = __ctype_b_loc();
  if (((*ppuVar4)[*id_local] & 0x800) == 0) {
    if (*id_local == '.') {
      if (name != (char **)0x0) {
        *name = id_local;
      }
      if (nam_len != (int *)0x0) {
        *nam_len = 1;
      }
      parsed = parsed + 1;
      id_local = id_local + 1;
    }
    else {
      iVar3 = parse_node_identifier(id_local,model,mod_len,name,nam_len,(int *)0x0,0);
      if (iVar3 < 1) {
        return iVar3 - parsed;
      }
      parsed = parsed + iVar3;
      id_local = id_local + iVar3;
    }
    while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[*id_local] & 0x2000) != 0) {
      parsed = parsed + 1;
      id_local = id_local + 1;
    }
    if (*id_local != '=') {
      return -parsed;
    }
    do {
      iVar3 = parsed;
      pcVar1 = id_local;
      parsed = iVar3 + 1;
      id_local = pcVar1 + 1;
      ppuVar4 = __ctype_b_loc();
    } while (((*ppuVar4)[*id_local] & 0x2000) != 0);
    if ((*id_local != '\"') && (*id_local != '\'')) {
      return -parsed;
    }
    iVar3 = iVar3 + 2;
    pcVar1 = pcVar1 + 2;
    pcVar5 = strchr(pcVar1,(int)*id_local);
    if (pcVar5 == (char *)0x0) {
      return -iVar3;
    }
    iVar2 = (int)pcVar5 - (int)pcVar1;
    if (value != (char **)0x0) {
      *value = pcVar1;
    }
    if (val_len != (int *)0x0) {
      *val_len = iVar2;
    }
    parsed = iVar3 + iVar2 + 1;
    id_local = pcVar1 + (long)iVar2 + 1;
  }
  else {
    if (name != (char **)0x0) {
      *name = id_local;
    }
    if (*id_local == '0') {
      return -parsed;
    }
    while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[*id_local] & 0x800) != 0) {
      parsed = parsed + 1;
      id_local = id_local + 1;
    }
    if (nam_len != (int *)0x0) {
      *nam_len = (int)id_local - (int)*name;
    }
  }
  while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[*id_local] & 0x2000) != 0) {
    parsed = parsed + 1;
    id_local = id_local + 1;
  }
  if (*id_local == ']') {
    iVar3 = parsed + 1;
    if ((id_local[1] == '[') && (has_predicate != (int *)0x0)) {
      *has_predicate = 1;
    }
  }
  else {
    iVar3 = -parsed;
  }
  return iVar3;
}



int parse_schema_nodeid(char *id,char **mod_name,int *mod_name_len,char **name,int *nam_len,
                       int *is_relative,int *has_predicate,int *all_desc,int extended)

{
  int iVar1;
  int iVar2;
  int *is_relative_local;
  int *nam_len_local;
  char **name_local;
  int *mod_name_len_local;
  char **mod_name_local;
  char *id_local;
  int parsed;
  int ret;
  
  parsed = 0;
  if (id == (char *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("id",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x3b7,"parse_schema_nodeid");
  }
  if (is_relative != (int *)0x0) {
    if (has_predicate != (int *)0x0) {
      *has_predicate = 0;
    }
    if (*id == '/') {
      if (*is_relative == -1) {
        *is_relative = 0;
      }
      parsed = 1;
      id_local = id + 1;
    }
    else {
      if (*is_relative != -1) {
        return 0;
      }
      *is_relative = 1;
      iVar1 = strncmp(id,"./",2);
      id_local = id;
      if (iVar1 == 0) {
        parsed = 2;
        id_local = id + 2;
      }
    }
    iVar1 = parse_node_identifier(id_local,mod_name,mod_name_len,name,nam_len,all_desc,extended);
    if (iVar1 < 1) {
      iVar2 = iVar1 - parsed;
    }
    else {
      iVar2 = parsed + iVar1;
      if ((id_local[iVar1] == '[') && (has_predicate != (int *)0x0)) {
        *has_predicate = 1;
      }
    }
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("is_relative",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                ,0x3b8,"parse_schema_nodeid");
}



int parse_schema_json_predicate
              (char *id,char **mod_name,int *mod_name_len,char **name,int *nam_len,char **value,
              int *val_len,int *has_predicate)

{
  char *pcVar1;
  int iVar2;
  int iVar3;
  ushort **ppuVar4;
  char *pcVar5;
  char **value_local;
  int *nam_len_local;
  char **name_local;
  int *mod_name_len_local;
  char **mod_name_local;
  char *id_local;
  char quote;
  int parsed;
  int ret;
  char *ptr;
  
  if (id == (char *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("id",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x3f8,"parse_schema_json_predicate");
  }
  if (mod_name != (char **)0x0) {
    *mod_name = (char *)0x0;
  }
  if (mod_name_len != (int *)0x0) {
    *mod_name_len = 0;
  }
  if (name != (char **)0x0) {
    *name = (char *)0x0;
  }
  if (nam_len != (int *)0x0) {
    *nam_len = 0;
  }
  if (value != (char **)0x0) {
    *value = (char *)0x0;
  }
  if (val_len != (int *)0x0) {
    *val_len = 0;
  }
  if (has_predicate != (int *)0x0) {
    *has_predicate = 0;
  }
  if (*id != '[') {
    return 0;
  }
  parsed = 1;
  id_local = id + 1;
  while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[*id_local] & 0x2000) != 0) {
    parsed = parsed + 1;
    id_local = id_local + 1;
  }
  if (*id_local == '.') {
    ret = 1;
    if (name != (char **)0x0) {
      *name = id_local;
    }
    if (nam_len != (int *)0x0) {
      *nam_len = 1;
    }
  }
  else {
    ppuVar4 = __ctype_b_loc();
    if (((*ppuVar4)[*id_local] & 0x800) == 0) {
      ret = parse_node_identifier(id_local,mod_name,mod_name_len,name,nam_len,(int *)0x0,0);
      if (ret < 1) {
        return ret - parsed;
      }
    }
    else {
      if (*id_local == '0') {
        return -parsed;
      }
      ret = 1;
      while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[id_local[ret]] & 0x800) != 0) {
        ret = ret + 1;
      }
      if (name != (char **)0x0) {
        *name = id_local;
      }
      if (nam_len != (int *)0x0) {
        *nam_len = ret;
      }
    }
  }
  parsed = parsed + ret;
  id_local = id_local + ret;
  while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[*id_local] & 0x2000) != 0) {
    parsed = parsed + 1;
    id_local = id_local + 1;
  }
  if (*id_local == '=') {
    if ((name != (char **)0x0) && (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[**name] & 0x800) != 0)) {
      return -parsed;
    }
    do {
      iVar3 = parsed;
      pcVar1 = id_local;
      parsed = iVar3 + 1;
      id_local = pcVar1 + 1;
      ppuVar4 = __ctype_b_loc();
    } while (((*ppuVar4)[*id_local] & 0x2000) != 0);
    if ((*id_local != '\"') && (*id_local != '\'')) {
      return -parsed;
    }
    iVar3 = iVar3 + 2;
    pcVar1 = pcVar1 + 2;
    pcVar5 = strchr(pcVar1,(int)*id_local);
    if (pcVar5 == (char *)0x0) {
      return -iVar3;
    }
    iVar2 = (int)pcVar5 - (int)pcVar1;
    if (value != (char **)0x0) {
      *value = pcVar1;
    }
    if (val_len != (int *)0x0) {
      *val_len = iVar2;
    }
    parsed = iVar3 + iVar2 + 1;
    id_local = pcVar1 + (long)iVar2 + 1;
    while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[*id_local] & 0x2000) != 0) {
      parsed = parsed + 1;
      id_local = id_local + 1;
    }
  }
  if (*id_local == ']') {
    iVar3 = parsed + 1;
    if ((id_local[1] == '[') && (has_predicate != (int *)0x0)) {
      *has_predicate = 1;
    }
  }
  else {
    iVar3 = -parsed;
  }
  return iVar3;
}



// WARNING: Variable defined which should be unmapped: UNUSED_cb_data_local

int resolve_hash_table_find_equal(void *val1_p,void *val2_p,int mod,void *UNUSED_cb_data)

{
  uint uVar1;
  lys_node *node;
  long lVar2;
  long *plVar3;
  char *pcVar4;
  hash_table *__s1;
  int iVar5;
  lys_module *plVar6;
  lys_module *plVar7;
  void *UNUSED_cb_data_local;
  int mod_local;
  void *val2_p_local;
  void *val1_p_local;
  int i;
  lyd_node *elem2;
  lyd_node *val2;
  char *str;
  parsed_pred pp;
  
  if (mod != 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("!mod",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x485,"resolve_hash_table_find_equal");
  }
                    // WARNING: Load size is inaccurate
  node = *val1_p;
  lVar2 = *(long *)((long)val1_p + 0x10);
                    // WARNING: Load size is inaccurate
  plVar3 = *val2_p;
  if ((lys_node *)*plVar3 != node) {
    return 0;
  }
  uVar1 = *(uint *)(*plVar3 + 0x38);
  if (uVar1 < 0x21) {
    if ((uVar1 != 0) && (true)) {
      switch(uVar1) {
      case 1:
      case 4:
      case 0x20:
        goto LAB_00119d97;
      case 8:
        pcVar4 = (char *)plVar3[7];
        iVar5 = strncmp(pcVar4,*(char **)(lVar2 + 0x20),(long)*(int *)(lVar2 + 0x28));
        if ((iVar5 == 0) && (pcVar4[*(int *)(lVar2 + 0x28)] == '\0')) {
          return 1;
        }
        return 0;
      case 0x10:
        if (*(char *)(*plVar3 + 0x1e) == '\0') {
                    // WARNING: Subroutine does not return
          __assert_fail("((struct lys_node_list *)val2->schema)->keys_size",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                        ,0x49c,"resolve_hash_table_find_equal");
        }
        pp.len = (int)*(undefined8 *)((long)val1_p + 8);
        if ((uint)*(byte *)(*plVar3 + 0x1e) != pp.len) {
                    // WARNING: Subroutine does not return
          __assert_fail("((struct lys_node_list *)val2->schema)->keys_size == pp.len",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                        ,0x49d,"resolve_hash_table_find_equal");
        }
        elem2 = (lyd_node *)plVar3[8];
        for (i = 0; (elem2 != (lyd_node *)0x0 && (i < pp.len)); i = i + 1) {
          if (*(long *)((long)i * 0x30 + lVar2) == 0) {
            plVar6 = lyd_node_module(elem2);
            plVar7 = lys_node_module(node);
            if (plVar6 != plVar7) break;
          }
          else {
            iVar5 = *(int *)((long)i * 0x30 + lVar2 + 8);
            pcVar4 = *(char **)((long)i * 0x30 + lVar2);
            plVar6 = lyd_node_module(elem2);
            iVar5 = strncmp(plVar6->name,pcVar4,(long)iVar5);
            if ((iVar5 != 0) ||
               (plVar6 = lyd_node_module(elem2),
               plVar6->name[*(int *)((long)i * 0x30 + lVar2 + 8)] != '\0')) break;
          }
          iVar5 = strncmp(elem2->schema->name,*(char **)((long)i * 0x30 + lVar2 + 0x10),
                          (long)*(int *)((long)i * 0x30 + lVar2 + 0x18));
          if ((iVar5 != 0) || (elem2->schema->name[*(int *)((long)i * 0x30 + lVar2 + 0x18)] != '\0')
             ) break;
          __s1 = elem2->ht;
          iVar5 = strncmp((char *)__s1,*(char **)((long)i * 0x30 + lVar2 + 0x20),
                          (long)*(int *)((long)i * 0x30 + lVar2 + 0x28));
          if ((iVar5 != 0) ||
             (*(char *)((long)&__s1->used + (long)*(int *)((long)i * 0x30 + lVar2 + 0x28)) != '\0'))
          break;
          elem2 = elem2->next;
        }
        if (i == pp.len) {
          return 1;
        }
        return 0;
      }
    }
  }
  else if (uVar1 == 0x8020) {
LAB_00119d97:
    return 1;
  }
  ly_log((ly_ctx *)**(undefined8 **)(*plVar3 + 0x30),LY_LLERR,LY_EINT,"Internal error (%s:%d).",
         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
         ,0x4c5,UNUSED_cb_data);
  return 0;
}



lyd_node * resolve_json_data_node_hash(lyd_node *parent,parsed_pred pp)

{
  uint32_t uVar1;
  int iVar2;
  lys_module *plVar3;
  size_t sVar4;
  lyd_node *plVar5;
  long in_FS_OFFSET;
  lyd_node *parent_local;
  uint32_t hash;
  int i;
  lyd_node **ret;
  values_equal_cb prev_cb;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ret = (lyd_node **)0x0;
  if ((parent == (lyd_node *)0x0) || (parent->hash == 0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("parent && parent->hash",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x4d1,"resolve_json_data_node_hash");
  }
  prev_cb = lyht_set_cb(parent->ht,resolve_hash_table_find_equal);
  plVar3 = lys_node_module(pp.schema);
  sVar4 = strlen(plVar3->name);
  plVar3 = lys_node_module(pp.schema);
  uVar1 = dict_hash_multi(0,plVar3->name,sVar4);
  sVar4 = strlen((pp.schema)->name);
  hash = dict_hash_multi(uVar1,(pp.schema)->name,sVar4);
  if ((pp.schema)->nodetype == LYS_LEAFLIST) {
    if (((pp.len != 1) || (*(pp.pred)->name != '.')) || ((pp.pred)->nam_len != 1)) {
                    // WARNING: Subroutine does not return
      __assert_fail("(pp.len == 1) && (pp.pred[0].name[0] == \'.\') && (pp.pred[0].nam_len == 1)",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                    ,0x4da,"resolve_json_data_node_hash");
    }
    hash = dict_hash_multi(hash,(pp.pred)->value,(long)(pp.pred)->val_len);
  }
  else if ((pp.schema)->nodetype == LYS_LIST) {
    for (i = 0; i < pp.len; i = i + 1) {
      hash = dict_hash_multi(hash,pp.pred[i].value,(long)pp.pred[i].val_len);
    }
  }
  uVar1 = dict_hash_multi(hash,(char *)0x0,0);
  iVar2 = lyht_find(parent->ht,&pp,uVar1,&ret);
  if ((iVar2 == 0) && (*ret == (lyd_node *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("i || *ret",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x4e7,"resolve_json_data_node_hash");
  }
  lyht_set_cb(parent->ht,prev_cb);
  if (iVar2 == 0) {
    plVar5 = *ret;
  }
  else {
    plVar5 = (lyd_node *)0x0;
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar5;
}



int resolve_feature(char *feat_name,uint16_t len,lys_node *node,lys_feature **feature)

{
  uint16_t uVar1;
  char *pcVar2;
  char *pcVar3;
  int iVar4;
  lys_module *plVar5;
  lys_module *plVar6;
  long in_FS_OFFSET;
  lys_feature **feature_local;
  lys_node *node_local;
  uint16_t len_local;
  char *feat_name_local;
  int mod_name_len;
  int nam_len;
  int i;
  int j;
  char *mod_name;
  char *name;
  lys_module *module;
  char *str;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  if (feature == (lys_feature **)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("feature",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x504,"resolve_feature");
  }
  i = parse_node_identifier(feat_name,&mod_name,&mod_name_len,&name,&nam_len,(int *)0x0,0);
  pcVar2 = mod_name;
  iVar4 = mod_name_len;
  if (i < 1) {
    ly_vlog(node->module->ctx,LYE_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)feat_name[-i],
            feat_name + -i);
    iVar4 = -1;
  }
  else {
    plVar5 = lys_node_module(node);
    module = lyp_get_module(plVar5,(char *)0x0,0,pcVar2,iVar4,0);
    if (module == (lys_module *)0x0) {
      ly_vlog(node->module->ctx,LYE_INMOD_LEN,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)mod_name_len,
              mod_name);
      iVar4 = -1;
    }
    else {
      if (module != node->module) {
        plVar5 = lys_node_module(node);
        if (module == plVar5) {
          for (j = 0; j < (int)(uint)node->module->features_size; j = j + 1) {
            iVar4 = strncmp(name,node->module->features[j].name,(long)nam_len);
            if ((iVar4 == 0) && (node->module->features[j].name[nam_len] == '\0')) {
              pcVar2 = node->module->features[j].name;
              plVar5 = node->module->features[j].module;
              uVar1 = node->module->features[j].flags;
              pcVar3 = node->name;
              plVar6 = lys_node_module(node);
              iVar4 = lyp_check_status(node->flags,plVar6,pcVar3,uVar1,plVar5,pcVar2,(lys_node *)0x0
                                      );
              if (iVar4 == 0) {
                *feature = node->module->features + j;
                iVar4 = 0;
              }
              else {
                iVar4 = -1;
              }
              goto LAB_0011a72f;
            }
          }
        }
      }
      for (j = 0; j < (int)(uint)module->features_size; j = j + 1) {
        iVar4 = strncmp(name,module->features[j].name,(long)nam_len);
        if ((iVar4 == 0) && (module->features[j].name[nam_len] == '\0')) {
          pcVar2 = module->features[j].name;
          plVar5 = module->features[j].module;
          uVar1 = module->features[j].flags;
          pcVar3 = node->name;
          plVar6 = lys_node_module(node);
          iVar4 = lyp_check_status(node->flags,plVar6,pcVar3,uVar1,plVar5,pcVar2,(lys_node *)0x0);
          if (iVar4 == 0) {
            *feature = module->features + j;
            iVar4 = 0;
          }
          else {
            iVar4 = -1;
          }
          goto LAB_0011a72f;
        }
      }
      i = 0;
      while ((i < (int)(uint)module->inc_size && (module->inc[i].submodule != (lys_submodule *)0x0))
            ) {
        for (j = 0; j < (int)(uint)(module->inc[i].submodule)->features_size; j = j + 1) {
          iVar4 = strncmp(name,(module->inc[i].submodule)->features[j].name,(long)nam_len);
          if ((iVar4 == 0) && ((module->inc[i].submodule)->features[j].name[nam_len] == '\0')) {
            pcVar2 = (module->inc[i].submodule)->features[j].name;
            plVar5 = (module->inc[i].submodule)->features[j].module;
            uVar1 = (module->inc[i].submodule)->features[j].flags;
            pcVar3 = node->name;
            plVar6 = lys_node_module(node);
            iVar4 = lyp_check_status(node->flags,plVar6,pcVar3,uVar1,plVar5,pcVar2,(lys_node *)0x0);
            if (iVar4 == 0) {
              *feature = (module->inc[i].submodule)->features + j;
              iVar4 = 0;
            }
            else {
              iVar4 = -1;
            }
            goto LAB_0011a72f;
          }
        }
        i = i + 1;
      }
      str = strndup(feat_name,(ulong)len);
      ly_vlog(node->module->ctx,LYE_INRESOLV,LY_VLOG_NONE,(void *)0x0,"feature",str);
      free(str);
      iVar4 = 1;
    }
  }
LAB_0011a72f:
  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar4;
}



int resolve_feature_value(lys_feature *feat)

{
  int iVar1;
  lys_feature *feat_local;
  int i;
  
  i = 0;
  while( true ) {
    if ((int)(uint)feat->iffeature_size <= i) {
      return (int)(uint)feat->flags >> 8 & 1;
    }
    iVar1 = resolve_iffeature(feat->iffeature + i);
    if (iVar1 == 0) break;
    i = i + 1;
  }
  return 0;
}



int resolve_iffeature_recursive(lys_iffeature *expr,int *index_e,int *index_f)

{
  lys_feature **pplVar1;
  byte bVar2;
  int iVar3;
  int iVar4;
  int *index_f_local;
  int *index_e_local;
  lys_iffeature *expr_local;
  uint8_t op;
  int a;
  int b;
  
  bVar2 = iff_getop(expr->expr,*index_e);
  *index_e = *index_e + 1;
  if (bVar2 == 3) {
    pplVar1 = expr->features;
    iVar3 = *index_f;
    *index_f = iVar3 + 1;
    iVar3 = resolve_feature_value(pplVar1[iVar3]);
    return iVar3;
  }
  if (bVar2 < 4) {
    if (bVar2 == 0) {
      iVar3 = resolve_iffeature_recursive(expr,index_e,index_f);
      return (uint)(iVar3 == 0);
    }
    if ((true) && (bVar2 - 1 < 2)) {
      iVar3 = resolve_iffeature_recursive(expr,index_e,index_f);
      iVar4 = resolve_iffeature_recursive(expr,index_e,index_f);
      if (bVar2 != 1) {
        if ((iVar3 == 0) && (iVar4 == 0)) {
          return 0;
        }
        return 1;
      }
      if ((iVar3 != 0) && (iVar4 != 0)) {
        return 1;
      }
      return 0;
    }
  }
  return 0;
}



int resolve_iffeature(lys_iffeature *expr)

{
  int iVar1;
  long in_FS_OFFSET;
  lys_iffeature *expr_local;
  int index_e;
  int index_f;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  index_e = 0;
  index_f = 0;
  if ((expr->expr == (uint8_t *)0x0) || (*expr->features == (lys_feature *)0x0)) {
    iVar1 = 0;
  }
  else {
    iVar1 = resolve_iffeature_recursive(expr,&index_e,&index_f);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int iff_stack_push(iff_stack *stack,uint8_t value)

{
  int iVar1;
  uint8_t *puVar2;
  uint8_t value_local;
  iff_stack *stack_local;
  
  if (stack->index == stack->size) {
    stack->size = stack->size + 4;
    puVar2 = (uint8_t *)ly_realloc(stack->stack,(long)stack->size);
    stack->stack = puVar2;
    if (stack->stack == (uint8_t *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","iff_stack_push");
      stack->size = 0;
      return 1;
    }
  }
  iVar1 = stack->index;
  stack->index = iVar1 + 1;
  stack->stack[iVar1] = value;
  return 0;
}



uint8_t iff_stack_pop(iff_stack *stack)

{
  iff_stack *stack_local;
  
  stack->index = stack->index + -1;
  return stack->stack[stack->index];
}



void iff_stack_clean(iff_stack *stack)

{
  iff_stack *stack_local;
  
  stack->size = 0;
  free(stack->stack);
  return;
}



void iff_setop(uint8_t *list,uint8_t op,int pos)

{
  int iVar1;
  byte *pbVar2;
  int pos_local;
  uint8_t op_local;
  uint8_t *list_local;
  uint8_t mask;
  uint8_t *item;
  
  if (pos < 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("pos >= 0",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x5aa,"iff_setop");
  }
  if (3 < op) {
                    // WARNING: Subroutine does not return
    __assert_fail("op <= 3",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x5ab,"iff_setop");
  }
  iVar1 = pos;
  if (pos < 0) {
    iVar1 = pos + 3;
  }
  pbVar2 = list + (iVar1 >> 2);
  *pbVar2 = ~('\x03' << ((char)(pos % 4) * '\x02' & 0x1fU)) & *pbVar2;
  *pbVar2 = op << ((char)(pos % 4) * '\x02' & 0x1fU) | *pbVar2;
  return;
}



uint8_t iff_getop(uint8_t *list,int pos)

{
  int iVar1;
  int pos_local;
  uint8_t *list_local;
  uint8_t mask;
  uint8_t result;
  uint8_t *item;
  
  if (pos < 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("pos >= 0",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x5b9,"iff_getop");
  }
  iVar1 = pos;
  if (pos < 0) {
    iVar1 = pos + 3;
  }
  return (uint8_t)((int)(uint)('\x03' << ((char)(pos % 4) * '\x02' & 0x1fU) & list[iVar1 >> 2]) >>
                  ((char)(pos % 4) * '\x02' & 0x1fU));
}



void resolve_iffeature_getsizes(lys_iffeature *iffeat,uint *expr_size,uint *feat_size)

{
  uint uVar1;
  byte bVar2;
  uint *feat_size_local;
  uint *expr_size_local;
  lys_iffeature *iffeat_local;
  uint8_t op;
  uint e;
  uint f;
  uint r;
  
  e = 0;
  f = 0;
  r = 0;
  if (iffeat != (lys_iffeature *)0x0) {
    if (iffeat->expr != (uint8_t *)0x0) {
      do {
        uVar1 = e + 1;
        bVar2 = iff_getop(iffeat->expr,e);
        if (bVar2 == 3) {
          f = f + 1;
          if (r != 0) {
            r = r - 1;
          }
        }
        else if (bVar2 < 4) {
          if (bVar2 == 0) {
            if (r == 0) {
              r = 1;
            }
          }
          else if ((true) && (bVar2 - 1 < 2)) {
            if (r == 0) {
              r = 2;
            }
            else {
              r = r + 1;
            }
          }
        }
        e = uVar1;
      } while (r != 0);
    }
    if (expr_size != (uint *)0x0) {
      *expr_size = e;
    }
    if (feat_size != (uint *)0x0) {
      *feat_size = f;
    }
    return;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("iffeat",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                ,0x5d0,"resolve_iffeature_getsizes");
}



int resolve_iffeature_compile
              (lys_iffeature *iffeat_expr,char *value,lys_node *node,int infeature,
              unres_schema *unres)

{
  long lVar1;
  ly_ctx *ctx_00;
  bool bVar2;
  bool bVar3;
  uint8_t uVar4;
  int iVar5;
  int iVar6;
  ushort **ppuVar7;
  uint8_t *puVar8;
  lys_feature **pplVar9;
  lys_node *snode;
  char *pcVar10;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  int infeature_local;
  lys_node *node_local;
  char *value_local;
  lys_iffeature *iffeat_expr_local;
  uint8_t op;
  int r;
  int rc;
  int i;
  int j;
  int last_not;
  int checkversion;
  uint f_size;
  uint expr_size;
  uint f_exp;
  char *c;
  ly_ctx *ctx;
  unres_iffeat_data *iff_data;
  iff_stack stack;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  rc = 1;
  bVar3 = false;
  f_size = 0;
  expr_size = 0;
  f_exp = 1;
  stack.size = 0;
  stack.index = 0;
  stack.stack = (uint8_t *)0x0;
  ctx_00 = node->module->ctx;
  if (value == (char *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("c",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x605,"resolve_iffeature_compile");
  }
  ppuVar7 = __ctype_b_loc();
  if (((*ppuVar7)[*value] & 0x2000) != 0) {
    ly_vlog(ctx_00,LYE_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)*value,value);
    rc = 1;
    goto LAB_0011b782;
  }
  bVar2 = false;
  j = 0;
  for (i = 0; value[i] != '\0'; i = i + 1) {
    if (value[i] == '(') {
      bVar3 = true;
      j = j + 1;
    }
    else if (value[i] == ')') {
      j = j + -1;
    }
    else {
      ppuVar7 = __ctype_b_loc();
      if (((*ppuVar7)[value[i]] & 0x2000) == 0) {
        r = 3;
        iVar6 = strncmp(value + i,"not",3);
        if (iVar6 == 0) {
LAB_0011af3b:
          if (value[r + i] == '\0') {
            ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"if-feature");
            rc = 1;
            goto LAB_0011b782;
          }
          ppuVar7 = __ctype_b_loc();
          if (((*ppuVar7)[value[r + i]] & 0x2000) == 0) {
            bVar2 = false;
            f_size = f_size + 1;
          }
          else if (value[i] == 'n') {
            if (bVar2) {
              expr_size = expr_size - 2;
              bVar2 = false;
            }
            else {
              bVar2 = true;
            }
          }
          else {
            f_exp = f_exp + 1;
            bVar2 = false;
          }
          i = i + r;
        }
        else {
          r = 3;
          iVar6 = strncmp(value + i,"and",3);
          if (iVar6 == 0) goto LAB_0011af3b;
          r = 2;
          iVar6 = strncmp(value + i,"or",2);
          if (iVar6 == 0) goto LAB_0011af3b;
          f_size = f_size + 1;
          bVar2 = false;
        }
        expr_size = expr_size + 1;
        while (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[value[i]] & 0x2000) == 0) {
          if (value[i] == '(') {
            ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"if-feature");
            rc = 1;
            goto LAB_0011b782;
          }
          if ((value[i] == '\0') || (value[i] == ')')) {
            i = i + -1;
            break;
          }
          i = i + 1;
        }
      }
    }
  }
  if ((j != 0) || (f_exp != f_size)) {
    ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"if-feature");
    rc = 1;
    goto LAB_0011b782;
  }
  if (((bVar3) || (1 < expr_size)) && ((node->module->field_0x40 & 0xe) != 4)) {
    ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"if-feature");
    ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
            "YANG 1.1 if-feature expression found in 1.0 module.");
    rc = 1;
    goto LAB_0011b782;
  }
  puVar8 = (uint8_t *)calloc((long)(int)((uint)((expr_size & 3) != 0) + (expr_size >> 2)),1);
  iffeat_expr->expr = puVar8;
  pplVar9 = (lys_feature **)calloc((ulong)f_size,8);
  iffeat_expr->features = pplVar9;
  stack.stack = (uint8_t *)malloc((ulong)expr_size);
  if (((stack.stack == (uint8_t *)0x0) || (iffeat_expr->expr == (uint8_t *)0x0)) ||
     (iffeat_expr->features == (lys_feature **)0x0)) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_iffeature_compile");
  }
  else {
    stack.size = expr_size;
    f_size = f_size - 1;
    expr_size = expr_size - 1;
    do {
      while( true ) {
        while( true ) {
          while( true ) {
            do {
              while( true ) {
                while( true ) {
                  iVar6 = i;
                  i = iVar6 + -1;
                  if (i < 0) goto LAB_0011b71a;
                  if (value[i] != ')') break;
                  iff_stack_push(&stack,'\b');
                }
                if (value[i] != '(') break;
                while (uVar4 = iff_stack_pop(&stack), uVar4 != '\b') {
                  iff_setop(iffeat_expr->expr,uVar4,expr_size);
                  expr_size = expr_size - 1;
                }
              }
              ppuVar7 = __ctype_b_loc();
            } while (((*ppuVar7)[value[i]] & 0x2000) != 0);
            for (; ((-1 < i && (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[value[i]] & 0x2000) == 0)) &&
                   (value[i] != '(')); i = i + -1) {
            }
            i = i + 1;
            iVar5 = strncmp(value + i,"not",3);
            if ((iVar5 != 0) ||
               (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[value[(long)i + 3]] & 0x2000) == 0)) break;
            if ((stack.index == 0) || (stack.stack[(long)stack.index + -1] != '\0')) {
              iff_stack_push(&stack,'\0');
            }
            else {
              iff_stack_pop(&stack);
            }
          }
          iVar5 = strncmp(value + i,"and",3);
          if ((iVar5 != 0) ||
             (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[value[(long)i + 3]] & 0x2000) == 0)) break;
          while ((stack.index != 0 && (stack.stack[(long)stack.index + -1] < 2))) {
            uVar4 = iff_stack_pop(&stack);
            iff_setop(iffeat_expr->expr,uVar4,expr_size);
            expr_size = expr_size - 1;
          }
          iff_stack_push(&stack,'\x01');
        }
        iVar5 = strncmp(value + i,"or",2);
        if ((iVar5 != 0) ||
           (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[value[(long)i + 2]] & 0x2000) == 0)) break;
        while ((stack.index != 0 && (stack.stack[(long)stack.index + -1] < 3))) {
          uVar4 = iff_stack_pop(&stack);
          iff_setop(iffeat_expr->expr,uVar4,expr_size);
          expr_size = expr_size - 1;
        }
        iff_stack_push(&stack,'\x02');
      }
      iff_setop(iffeat_expr->expr,'\x03',expr_size);
      snode = (lys_node *)malloc(0x18);
      if (snode == (lys_node *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "resolve_iffeature_compile");
        goto LAB_0011b773;
      }
      snode->name = (char *)node;
      pcVar10 = lydict_insert(node->module->ctx,value + i,(long)(iVar6 - i));
      snode->dsc = pcVar10;
      *(int *)&snode->ref = infeature;
      iVar6 = unres_schema_add_node
                        (node->module,unres,iffeat_expr->features + f_size,UNRES_IFFEAT,snode);
      f_size = f_size - 1;
      expr_size = expr_size - 1;
    } while (iVar6 != -1);
    lydict_remove(node->module->ctx,snode->dsc);
    free(snode);
  }
LAB_0011b773:
  iff_stack_clean(&stack);
LAB_0011b782:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return rc;
LAB_0011b71a:
  while (stack.index != 0) {
    uVar4 = iff_stack_pop(&stack);
    iff_setop(iffeat_expr->expr,uVar4,expr_size);
    expr_size = expr_size - 1;
  }
  if ((expr_size == 0xffffffff) && (f_size == 0xffffffff)) {
    rc = 0;
  }
  else {
    ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"if-feature");
    rc = 1;
  }
  goto LAB_0011b773;
}



lyd_node * resolve_data_descendant_schema_nodeid(char *nodeid,lyd_node *start)

{
  int iVar1;
  lys_node *plVar2;
  lyd_node *plVar3;
  long in_FS_OFFSET;
  lyd_node *start_local;
  char *nodeid_local;
  lys_node *schema;
  char *p;
  lyd_node *result;
  lyd_node *iter;
  char *str;
  char *token;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  result = (lyd_node *)0x0;
  schema = (lys_node *)0x0;
  if ((nodeid == (char *)0x0) || (start == (lyd_node *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("nodeid && start",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x6bf,"resolve_data_descendant_schema_nodeid");
  }
  if (*nodeid == '/') {
    plVar3 = (lyd_node *)0x0;
  }
  else {
    p = strdup(nodeid);
    str = p;
    if (p == (char *)0x0) {
      ly_log(start->schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
             "resolve_data_descendant_schema_nodeid");
      plVar3 = (lyd_node *)0x0;
    }
    else {
LAB_0011b9af:
      do {
        if (p == (char *)0x0) goto LAB_0011b9ba;
        token = p;
        p = strchr(p,0x2f);
        if (p != (char *)0x0) {
          *p = '\0';
          p = p + 1;
        }
        if (p == (char *)0x0) {
          if (schema == (lys_node *)0x0) {
            plVar2 = start->schema;
          }
          else {
            plVar2 = schema->child;
          }
          iVar1 = resolve_descendant_schema_nodeid(token,plVar2,4,0,&schema);
          if ((iVar1 != 0) || (schema == (lys_node *)0x0)) {
            result = (lyd_node *)0x0;
            goto LAB_0011b9ba;
          }
        }
        else {
          if (schema == (lys_node *)0x0) {
            plVar2 = start->schema;
          }
          else {
            plVar2 = schema->child;
          }
          iVar1 = resolve_descendant_schema_nodeid(token,plVar2,0x47,0,&schema);
          if ((iVar1 != 0) || (schema == (lys_node *)0x0)) {
            result = (lyd_node *)0x0;
            goto LAB_0011b9ba;
          }
          if ((schema->nodetype & (LYS_CHOICE|LYS_CASE)) != LYS_UNKNOWN) goto LAB_0011b9af;
        }
        iter = start;
        if (result != (lyd_node *)0x0) {
          iter = result->child;
        }
        for (; iter != (lyd_node *)0x0; iter = iter->next) {
          if (iter->schema == schema) {
            result = iter;
            break;
          }
        }
      } while (iter != (lyd_node *)0x0);
      result = (lyd_node *)0x0;
LAB_0011b9ba:
      free(str);
      plVar3 = result;
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int schema_nodeid_siblingcheck
              (lys_node *sibling,lys_module *cur_module,char *mod_name,int mod_name_len,char *name,
              int nam_len)

{
  int iVar1;
  lys_module *plVar2;
  char *name_local;
  int nam_len_local;
  int mod_name_len_local;
  char *mod_name_local;
  lys_module *cur_module_local;
  lys_node *sibling_local;
  lys_module *prefix_mod;
  
  if (*name == '*') {
    iVar1 = 2;
  }
  else if (*name == '.') {
    iVar1 = 3;
  }
  else {
    iVar1 = strncmp(name,sibling->name,(long)nam_len);
    if ((iVar1 == 0) && (sibling->name[nam_len] == '\0')) {
      prefix_mod = cur_module;
      if ((mod_name == (char *)0x0) ||
         (prefix_mod = lyp_get_module(cur_module,(char *)0x0,0,mod_name,mod_name_len,0),
         prefix_mod != (lys_module *)0x0)) {
        plVar2 = lys_node_module(sibling);
        if (prefix_mod == plVar2) {
          iVar1 = 0;
        }
        else {
          iVar1 = 1;
        }
      }
      else {
        iVar1 = -1;
      }
    }
    else {
      iVar1 = 1;
    }
  }
  return iVar1;
}



int resolve_extended_schema_nodeid_predicate
              (char *nodeid,lys_node *node,lys_module *cur_module,int *nodeid_end)

{
  char *__s2;
  lys_node_list *plVar1;
  int iVar2;
  lys_module *plVar3;
  size_t __n;
  long in_FS_OFFSET;
  int *nodeid_end_local;
  lys_module *cur_module_local;
  lys_node *node_local;
  char *nodeid_local;
  int mod_len;
  int nam_len;
  int has_predicate;
  int i;
  int r;
  char *model;
  char *name;
  lys_node_list *list;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  nodeid_local = nodeid;
  plVar1 = (lys_node_list *)node;
  if ((node->nodetype & (LYS_LEAFLIST|LYS_LIST)) == LYS_UNKNOWN) {
    iVar2 = 1;
  }
  else {
    do {
      list = plVar1;
      r = parse_schema_json_predicate
                    (nodeid_local,&model,&mod_len,&name,&nam_len,(char **)0x0,(int *)0x0,
                     &has_predicate);
      if (r < 1) {
        ly_vlog(cur_module->ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,
                (ulong)(uint)(int)nodeid_local[r],nodeid_local + r);
        iVar2 = -1;
        goto LAB_0011bd78;
      }
      nodeid_local = nodeid_local + r;
      if (node->nodetype == LYS_LEAFLIST) {
        if ((((model != (char *)0x0) || (name == (char *)0x0)) || (*name != '.')) ||
           (has_predicate != 0)) {
          iVar2 = 1;
          goto LAB_0011bd78;
        }
        break;
      }
      for (i = 0; i < (int)(uint)list->keys_size; i = i + 1) {
        iVar2 = strncmp(list->keys[i]->name,name,(long)nam_len);
        __s2 = model;
        if ((iVar2 == 0) && (list->keys[i]->name[nam_len] == '\0')) {
          if (model == (char *)0x0) {
            plVar3 = lys_node_module((lys_node *)list->keys[i]);
            if (cur_module == plVar3) break;
          }
          else {
            __n = (size_t)mod_len;
            plVar3 = lys_node_module((lys_node *)list->keys[i]);
            iVar2 = strncmp(plVar3->name,__s2,__n);
            if ((iVar2 == 0) &&
               (plVar3 = lys_node_module((lys_node *)list->keys[i]), plVar3->name[mod_len] == '\0'))
            break;
          }
        }
      }
      if (i == (uint)list->keys_size) {
        iVar2 = 1;
        goto LAB_0011bd78;
      }
      plVar1 = list;
    } while (has_predicate != 0);
    if (*nodeid_local == '\0') {
      *nodeid_end = 1;
    }
    iVar2 = 0;
  }
LAB_0011bd78:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int resolve_schema_nodeid
              (char *nodeid,lys_node *start_parent,lys_module *cur_module,ly_set **ret,int extended,
              int no_node_error)

{
  int iVar1;
  size_t sVar2;
  ly_set *plVar3;
  lys_node *plVar4;
  lys_node *plVar5;
  int *piVar6;
  long in_FS_OFFSET;
  int no_node_error_local;
  int extended_local;
  ly_set **ret_local;
  lys_module *cur_module_local;
  lys_node *start_parent_local;
  char *nodeid_local;
  int nam_len;
  int mod_name_len;
  int is_relative;
  int all_desc;
  int has_predicate;
  int nodeid_end;
  int r;
  int yang_data_name_len;
  int backup_mod_name_len;
  char *name;
  char *mod_name;
  char *id;
  char *backup_mod_name;
  char *yang_data_name;
  lys_node *sibling;
  lys_node *next;
  lys_node *elem;
  lys_node_augment *last_aug;
  lys_module *start_mod;
  lys_module *aux_mod;
  ly_ctx *ctx;
  char *str;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  backup_mod_name = (char *)0x0;
  yang_data_name = (char *)0x0;
  mod_name_len = 0;
  is_relative = -1;
  nodeid_end = 0;
  backup_mod_name_len = 0;
  aux_mod = (lys_module *)0x0;
  if ((nodeid == (char *)0x0) ||
     (((start_parent == (lys_node *)0x0 && (cur_module == (lys_module *)0x0)) ||
      (ret == (ly_set **)0x0)))) {
                    // WARNING: Subroutine does not return
    __assert_fail("nodeid && (start_parent || cur_module) && ret",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x766,"resolve_schema_nodeid");
  }
  *ret = (ly_set *)0x0;
  cur_module_local = cur_module;
  if (cur_module == (lys_module *)0x0) {
    cur_module_local = lys_node_module(start_parent);
  }
  ctx = cur_module_local->ctx;
  id = nodeid;
  r = parse_schema_nodeid(nodeid,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,(int *)0x0,
                          (int *)0x0,1);
  if (r < 1) {
    ly_vlog(ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[-r],id + -r);
    iVar1 = -1;
  }
  else {
    if (*name == '#') {
      if (is_relative != 0) {
        ly_vlog(ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,0x23,name);
        iVar1 = -1;
        goto LAB_0011cb40;
      }
      yang_data_name = name + 1;
      yang_data_name_len = nam_len + -1;
      backup_mod_name = mod_name;
      backup_mod_name_len = mod_name_len;
      id = id + r;
    }
    else {
      is_relative = -1;
    }
    if (extended == 0) {
      piVar6 = (int *)0x0;
    }
    else {
      piVar6 = &all_desc;
    }
    r = parse_schema_nodeid(id,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,&has_predicate,
                            piVar6,extended);
    if (r < 1) {
      ly_vlog(ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[-r],id + -r);
      iVar1 = -1;
    }
    else {
      id = id + r;
      if (backup_mod_name != (char *)0x0) {
        mod_name = backup_mod_name;
        mod_name_len = backup_mod_name_len;
      }
      if ((is_relative == 0) || (start_parent != (lys_node *)0x0)) {
        if (is_relative != 0) {
          cur_module_local = lys_node_module(start_parent);
          start_parent_local = start_parent;
          start_mod = cur_module_local;
LAB_0011c281:
          sibling = (lys_node *)0x0;
          last_aug = (lys_node_augment *)0x0;
          if (start_parent_local == (lys_node *)0x0) goto LAB_0011c8e9;
          if ((mod_name == (char *)0x0) ||
             ((iVar1 = strncmp(mod_name,cur_module_local->name,(long)mod_name_len), iVar1 == 0 &&
              (sVar2 = strlen(cur_module_local->name), (int)sVar2 == mod_name_len)))) {
            aux_mod = cur_module_local;
          }
          else {
            aux_mod = lyp_get_module(cur_module_local,(char *)0x0,0,mod_name,mod_name_len,0);
            if (aux_mod == (lys_module *)0x0) {
              str = strndup(mod_name,(long)mod_name_len);
              ly_vlog(ctx,LYE_PATH_INMOD,LY_VLOG_STR,str);
              free(str);
              iVar1 = -1;
              goto LAB_0011cb40;
            }
          }
          if (extended != 0) goto LAB_0011c8e9;
LAB_0011c3a0:
          last_aug = lys_getnext_target_aug(last_aug,aux_mod,start_parent_local);
LAB_0011c8e9:
          plVar4 = start_parent_local;
          if (last_aug != (lys_node_augment *)0x0) {
            plVar4 = (lys_node *)last_aug;
          }
          sibling = lys_getnext(sibling,plVar4,start_mod,0x18b);
          if (sibling != (lys_node *)0x0) {
            r = schema_nodeid_siblingcheck
                          (sibling,cur_module_local,mod_name,mod_name_len,name,nam_len);
            if ((extended != 0) && ((((r == 0 || (r == 2)) || (r == 3)) && (has_predicate != 0))))
            goto code_r0x0011c425;
            if (*id == '\0') {
              nodeid_end = 1;
            }
            goto LAB_0011c482;
          }
          goto LAB_0011c921;
        }
        start_mod = lyp_get_module(cur_module_local,(char *)0x0,0,mod_name,mod_name_len,0);
        if (start_mod == (lys_module *)0x0) {
          str = strndup(mod_name,(long)mod_name_len);
          ly_vlog(ctx,LYE_PATH_INMOD,LY_VLOG_STR,str);
          free(str);
          iVar1 = -1;
        }
        else {
          start_parent_local = (lys_node *)0x0;
          if ((yang_data_name == (char *)0x0) ||
             (start_parent_local =
                   lyp_get_yang_data_template(start_mod,yang_data_name,yang_data_name_len),
             start_parent_local != (lys_node *)0x0)) goto LAB_0011c281;
          str = strndup(nodeid,(size_t)(yang_data_name + ((long)yang_data_name_len - (long)nodeid)))
          ;
          ly_vlog(ctx,LYE_PATH_INNODE,LY_VLOG_STR,str);
          free(str);
          iVar1 = -1;
        }
      }
      else {
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_STR,nodeid,"Starting node must be provided for relative paths."
               );
        iVar1 = -1;
      }
    }
  }
LAB_0011cb40:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
code_r0x0011c425:
  r = resolve_extended_schema_nodeid_predicate(id,sibling,cur_module_local,&nodeid_end);
  if (r == 1) goto LAB_0011c8e9;
  if (r == -1) {
    iVar1 = -1;
    goto LAB_0011cb40;
  }
LAB_0011c482:
  if (r != 0) {
    if (r != 1) {
      if (r == 2) {
        if (*ret == (ly_set *)0x0) {
          plVar3 = ly_set_new();
          *ret = plVar3;
          if (*ret == (ly_set *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_schema_nodeid");
            iVar1 = -1;
            goto LAB_0011cb40;
          }
        }
        ly_set_add(*ret,sibling,1);
        if (all_desc != 0) {
          elem = sibling;
          while (elem != (lys_node *)0x0) {
            if (elem != sibling) {
              next = elem;
              ly_set_add(*ret,elem,1);
            }
            if ((elem->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
              next = elem->child;
            }
            else {
              next = (lys_node *)0x0;
            }
            if (next == (lys_node *)0x0) {
              if (elem == sibling) goto LAB_0011c8e9;
              next = elem->next;
            }
            while (next == (lys_node *)0x0) {
              if (elem->parent->nodetype == LYS_AUGMENT) {
                elem = elem->parent->prev;
              }
              else {
                elem = elem->parent;
              }
              plVar4 = lys_parent(elem);
              plVar5 = lys_parent(sibling);
              if (plVar4 == plVar5) break;
              next = elem->next;
            }
            elem = next;
          }
          next = (lys_node *)0x0;
        }
      }
      else {
        if (r != 3) {
          ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                 ,0x80e);
          iVar1 = -1;
          goto LAB_0011cb40;
        }
        if (*ret == (ly_set *)0x0) {
          plVar3 = ly_set_new();
          *ret = plVar3;
          if (*ret == (ly_set *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_schema_nodeid");
            iVar1 = -1;
            goto LAB_0011cb40;
          }
          if (start_parent_local != (lys_node *)0x0) {
            ly_set_add(*ret,start_parent_local,1);
          }
        }
        ly_set_add(*ret,sibling,1);
        if (all_desc != 0) {
          elem = sibling;
          while (elem != (lys_node *)0x0) {
            if (elem != sibling) {
              next = elem;
              ly_set_add(*ret,elem,1);
            }
            if ((elem->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
              next = elem->child;
            }
            else {
              next = (lys_node *)0x0;
            }
            if (next == (lys_node *)0x0) {
              if (elem == sibling) goto LAB_0011c8e9;
              next = elem->next;
            }
            while (next == (lys_node *)0x0) {
              if (elem->parent->nodetype == LYS_AUGMENT) {
                elem = elem->parent->prev;
              }
              else {
                elem = elem->parent;
              }
              plVar4 = lys_parent(elem);
              plVar5 = lys_parent(sibling);
              if (plVar4 == plVar5) break;
              next = elem->next;
            }
            elem = next;
          }
          next = (lys_node *)0x0;
        }
      }
    }
    goto LAB_0011c8e9;
  }
  if (nodeid_end == 0) {
    if ((sibling->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) != LYS_UNKNOWN) {
      iVar1 = -1;
      goto LAB_0011cb40;
    }
    start_parent_local = sibling;
  }
  else {
    plVar3 = ly_set_new();
    *ret = plVar3;
    if (*ret == (ly_set *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_schema_nodeid");
      iVar1 = -1;
      goto LAB_0011cb40;
    }
    ly_set_add(*ret,sibling,1);
  }
LAB_0011c921:
  if ((extended != 0) && (has_predicate != 0)) {
    for (; *id == '['; id = id + 1) {
      id = strchr(id,0x5d);
      if (id == (char *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
               ,0x818);
        iVar1 = -1;
        goto LAB_0011cb40;
      }
    }
  }
  if ((nodeid_end != 0) && (((r == 0 || (r == 2)) || (r == 3)))) {
    iVar1 = 0;
    goto LAB_0011cb40;
  }
  if (sibling != (lys_node *)0x0) goto LAB_0011ca6b;
  if (last_aug == (lys_node_augment *)0x0) {
    if (no_node_error == 0) {
      *ret = (ly_set *)0x0;
      iVar1 = 0;
    }
    else {
      str = strndup(nodeid,(size_t)(name + ((long)nam_len - (long)nodeid)));
      ly_vlog(ctx,LYE_PATH_INNODE,LY_VLOG_STR,str);
      free(str);
      iVar1 = -1;
    }
    goto LAB_0011cb40;
  }
  goto LAB_0011c3a0;
LAB_0011ca6b:
  if (extended == 0) {
    piVar6 = (int *)0x0;
  }
  else {
    piVar6 = &all_desc;
  }
  r = parse_schema_nodeid(id,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,&has_predicate,
                          piVar6,extended);
  if (r < 1) goto code_r0x0011cad7;
  id = id + r;
  goto LAB_0011c281;
code_r0x0011cad7:
  ly_vlog(ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[-r],id + -r);
  iVar1 = -1;
  goto LAB_0011cb40;
}



int resolve_descendant_schema_nodeid
              (char *nodeid,lys_node *start,int ret_nodetype,int no_innerlist,lys_node **ret)

{
  int iVar1;
  lys_node *plVar2;
  long in_FS_OFFSET;
  lys_node **ret_local;
  int no_innerlist_local;
  int ret_nodetype_local;
  lys_node *start_local;
  char *nodeid_local;
  int nam_len;
  int mod_name_len;
  int is_relative;
  int r;
  char *name;
  char *mod_name;
  char *id;
  lys_node *sibling;
  lys_node *start_parent;
  lys_module *module;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  is_relative = -1;
  if ((nodeid == (char *)0x0) || (ret == (lys_node **)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("nodeid && ret",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x850,"resolve_descendant_schema_nodeid");
  }
  if ((ret_nodetype & 0x3800U) != 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("!(ret_nodetype & (LYS_USES | LYS_AUGMENT | LYS_GROUPING))",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x851,"resolve_descendant_schema_nodeid");
  }
  if (start == (lys_node *)0x0) {
    iVar1 = 0;
  }
  else {
    id = nodeid;
    module = lys_node_module(start);
    r = parse_schema_nodeid(id,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,(int *)0x0,
                            (int *)0x0,0);
    if (r < 1) {
      iVar1 = (((int)id - (int)nodeid) - r) + 1;
    }
    else {
      id = id + r;
      if (is_relative != 0) {
        start_parent = lys_parent(start);
        while ((start_parent->nodetype == LYS_USES &&
               (plVar2 = lys_parent(start_parent), plVar2 != (lys_node *)0x0))) {
          start_parent = lys_parent(start_parent);
        }
        do {
          sibling = (lys_node *)0x0;
          while (sibling = lys_getnext(sibling,start_parent,module,0x183),
                sibling != (lys_node *)0x0) {
            r = schema_nodeid_siblingcheck(sibling,module,mod_name,mod_name_len,name,nam_len);
            if (r == 0) {
              if (*id != '\0') {
                start_parent = sibling;
                break;
              }
              if ((ret_nodetype & sibling->nodetype) != LYS_UNKNOWN) {
                *ret = sibling;
                iVar1 = 0;
                goto LAB_0011ce0f;
              }
            }
            else if (r != 1) {
              iVar1 = -1;
              goto LAB_0011ce0f;
            }
          }
          if (sibling == (lys_node *)0x0) {
            *ret = (lys_node *)0x0;
            iVar1 = 0;
            goto LAB_0011ce0f;
          }
          if ((no_innerlist != 0) && (sibling->nodetype == LYS_LIST)) {
            *ret = (lys_node *)0x0;
            iVar1 = -2;
            goto LAB_0011ce0f;
          }
          r = parse_schema_nodeid(id,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,(int *)0x0,
                                  (int *)0x0,0);
          if (r < 1) goto code_r0x0011cdeb;
          id = id + r;
        } while( true );
      }
      iVar1 = -1;
    }
  }
LAB_0011ce0f:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
code_r0x0011cdeb:
  iVar1 = (((int)id - (int)nodeid) - r) + 1;
  goto LAB_0011ce0f;
}



int resolve_choice_default_schema_nodeid(char *nodeid,lys_node *start,lys_node **ret)

{
  int iVar1;
  char *pcVar2;
  lys_node **ret_local;
  lys_node *start_local;
  char *nodeid_local;
  
  pcVar2 = strchr(nodeid,0x2f);
  if (pcVar2 == (char *)0x0) {
    iVar1 = resolve_descendant_schema_nodeid(nodeid,start,0x807f,0,ret);
  }
  else {
    iVar1 = -1;
  }
  return iVar1;
}



int resolve_uses_schema_nodeid(char *nodeid,lys_node *start,lys_node_grp **ret)

{
  int iVar1;
  lys_module *plVar2;
  lys_node_grp *plVar3;
  long in_FS_OFFSET;
  lys_node_grp **ret_local;
  lys_node *start_local;
  char *nodeid_local;
  int mod_prefix_len;
  int nam_len;
  int i;
  char *mod_prefix;
  char *name;
  lys_module *module;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  i = parse_node_identifier(nodeid,&mod_prefix,&mod_prefix_len,&name,&nam_len,(int *)0x0,0);
  if ((i < 1) || (nodeid[i] != '\0')) {
    iVar1 = 1 - i;
  }
  else {
    module = lyp_get_module(start->module,mod_prefix,mod_prefix_len,(char *)0x0,0,0);
    if (module == (lys_module *)0x0) {
      iVar1 = -1;
    }
    else {
      plVar2 = lys_main_module(start->module);
      start_local = start;
      if (module != plVar2) {
        start_local = module->data;
      }
      plVar3 = lys_find_grouping_up(name,start_local);
      *ret = plVar3;
      iVar1 = 0;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int resolve_absolute_schema_nodeid(char *nodeid,lys_module *module,int ret_nodetype,lys_node **ret)

{
  int iVar1;
  long in_FS_OFFSET;
  lys_node **ret_local;
  int ret_nodetype_local;
  lys_module *module_local;
  char *nodeid_local;
  int nam_len;
  int mod_name_len;
  int is_relative;
  int r;
  char *name;
  char *mod_name;
  char *id;
  lys_node *sibling;
  lys_node *start_parent;
  lys_module *abs_start_mod;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  is_relative = -1;
  if (((nodeid == (char *)0x0) || (module == (lys_module *)0x0)) || (ret == (lys_node **)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("nodeid && module && ret",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x8c3,"resolve_absolute_schema_nodeid");
  }
  if (((ret_nodetype & 0x3000U) != 0) || ((ret_nodetype != 0x800 && ((ret_nodetype & 0x800U) != 0)))
     ) {
                    // WARNING: Subroutine does not return
    __assert_fail("!(ret_nodetype & (LYS_USES | LYS_AUGMENT)) && ((ret_nodetype == LYS_GROUPING) || !(ret_nodetype & LYS_GROUPING))"
                  ,
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x8c4,"resolve_absolute_schema_nodeid");
  }
  start_parent = (lys_node *)0x0;
  id = nodeid;
  r = parse_schema_nodeid(nodeid,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,(int *)0x0,
                          (int *)0x0,0);
  if (r < 1) {
    iVar1 = (((int)id - (int)nodeid) - r) + 1;
  }
  else {
    id = id + r;
    if (is_relative == 0) {
      abs_start_mod = lyp_get_module(module,(char *)0x0,0,mod_name,mod_name_len,0);
      if (abs_start_mod != (lys_module *)0x0) {
        do {
          sibling = (lys_node *)0x0;
          while (sibling = lys_getnext(sibling,start_parent,abs_start_mod,0x10f),
                sibling != (lys_node *)0x0) {
            r = schema_nodeid_siblingcheck(sibling,module,mod_name,mod_name_len,name,nam_len);
            if (r == 0) {
              if (*id != '\0') {
                start_parent = sibling;
                break;
              }
              if ((ret_nodetype & sibling->nodetype) != LYS_UNKNOWN) {
                *ret = sibling;
                iVar1 = 0;
                goto LAB_0011d21a;
              }
            }
            else if (r != 1) {
              iVar1 = -1;
              goto LAB_0011d21a;
            }
          }
          if (sibling == (lys_node *)0x0) {
            *ret = (lys_node *)0x0;
            iVar1 = 0;
            goto LAB_0011d21a;
          }
          r = parse_schema_nodeid(id,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,(int *)0x0,
                                  (int *)0x0,0);
          if (r < 1) goto code_r0x0011d1f6;
          id = id + r;
        } while( true );
      }
      iVar1 = -1;
    }
    else {
      iVar1 = -1;
    }
  }
LAB_0011d21a:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
code_r0x0011d1f6:
  iVar1 = (((int)id - (int)nodeid) - r) + 1;
  goto LAB_0011d21a;
}



int resolve_json_schema_list_predicate(char *predicate,lys_node_list *list,int *parsed)

{
  int iVar1;
  long lVar2;
  ushort **ppuVar3;
  long in_FS_OFFSET;
  int *parsed_local;
  lys_node_list *list_local;
  char *predicate_local;
  int mod_name_len;
  int nam_len;
  int has_predicate;
  int i;
  char *mod_name;
  char *name;
  lys_node *key;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  i = parse_schema_json_predicate
                (predicate,&mod_name,&mod_name_len,&name,&nam_len,(char **)0x0,(int *)0x0,
                 &has_predicate);
  if ((i < 1) || (iVar1 = strncmp(name,".",(long)nam_len), iVar1 == 0)) {
    ly_vlog(list->module->ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,
            (ulong)(uint)(int)predicate[-i],predicate + -i);
    iVar1 = -1;
  }
  else {
    lVar2 = (long)i;
    *parsed = *parsed + i;
    ppuVar3 = __ctype_b_loc();
    if (((*ppuVar3)[*name] & 0x800) == 0) {
      for (i = 0; i < (int)(uint)list->keys_size; i = i + 1) {
        key = (lys_node *)list->keys[i];
        iVar1 = strncmp(((lys_node_leaf *)key)->name,name,(long)nam_len);
        if ((iVar1 == 0) && (key->name[nam_len] == '\0')) break;
      }
      if (i == (uint)list->keys_size) {
        ly_vlog(list->module->ctx,LYE_PATH_INKEY,LY_VLOG_NONE,(void *)0x0,name);
        iVar1 = -1;
        goto LAB_0011d42b;
      }
    }
    if (has_predicate == 0) {
      iVar1 = 0;
    }
    else {
      iVar1 = resolve_json_schema_list_predicate(predicate + lVar2,list,parsed);
    }
  }
LAB_0011d42b:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_node * resolve_json_nodeid(char *nodeid,ly_ctx *ctx,lys_node *start,int output)

{
  int iVar1;
  lys_module *plVar2;
  lys_node *plVar3;
  long in_FS_OFFSET;
  int output_local;
  lys_node *start_local;
  ly_ctx *ctx_local;
  char *nodeid_local;
  int r;
  int nam_len;
  int mod_name_len;
  int is_relative;
  int has_predicate;
  int yang_data_name_len;
  int backup_mod_name_len;
  char *name;
  char *mod_name;
  char *id;
  char *backup_mod_name;
  char *yang_data_name;
  lys_node *sibling;
  lys_node *start_parent;
  lys_node *parent;
  lys_module *prefix_mod;
  lys_module *module;
  lys_module *prev_mod;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  backup_mod_name = (char *)0x0;
  yang_data_name = (char *)0x0;
  is_relative = -1;
  if ((nodeid == (char *)0x0) || ((ctx == (ly_ctx *)0x0 && (start == (lys_node *)0x0)))) {
                    // WARNING: Subroutine does not return
    __assert_fail("nodeid && (ctx || start)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x931,"resolve_json_nodeid");
  }
  ctx_local = ctx;
  if (ctx == (ly_ctx *)0x0) {
    ctx_local = start->module->ctx;
  }
  id = nodeid;
  r = parse_schema_nodeid(nodeid,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,(int *)0x0,
                          (int *)0x0,1);
  if (r < 1) {
    ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[-r],id + -r);
    plVar3 = (lys_node *)0x0;
  }
  else {
    if (*name == '#') {
      if (is_relative != 0) {
        ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,0x23,name);
        plVar3 = (lys_node *)0x0;
        goto LAB_0011dde9;
      }
      yang_data_name = name + 1;
      yang_data_name_len = nam_len + -1;
      backup_mod_name = mod_name;
      backup_mod_name_len = mod_name_len;
      id = id + r;
    }
    else {
      is_relative = -1;
    }
    r = parse_schema_nodeid(id,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,&has_predicate,
                            (int *)0x0,0);
    if (r < 1) {
      ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[-r],id + -r);
      plVar3 = (lys_node *)0x0;
    }
    else {
      id = id + r;
      if (backup_mod_name != (char *)0x0) {
        mod_name = backup_mod_name;
        mod_name_len = backup_mod_name_len;
      }
      if (is_relative != 0) {
        start_parent = start;
        if (start == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
          __assert_fail("start",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                        ,0x957,"resolve_json_nodeid");
        }
        for (; (start_parent != (lys_node *)0x0 && (start_parent->nodetype == LYS_USES));
            start_parent = lys_parent(start_parent)) {
        }
        module = start->module;
LAB_0011d927:
        prev_mod = module;
        do {
          sibling = (lys_node *)0x0;
          do {
            do {
              do {
                sibling = lys_getnext(sibling,start_parent,module,0);
                plVar2 = prev_mod;
                if (sibling == (lys_node *)0x0) goto LAB_0011dcce;
              } while (((sibling->name == (char *)0x0) ||
                       (iVar1 = strncmp(name,sibling->name,(long)nam_len), iVar1 != 0)) ||
                      (sibling->name[nam_len] != '\0'));
              for (parent = lys_parent(sibling);
                  (parent != (lys_node *)0x0 && ((parent->nodetype & 0x600) == LYS_UNKNOWN));
                  parent = lys_parent(parent)) {
              }
            } while ((parent != (lys_node *)0x0) &&
                    (((output != 0 && (parent->nodetype == LYS_INPUT)) ||
                     ((output == 0 && (parent->nodetype == LYS_OUTPUT))))));
            if (mod_name == (char *)0x0) {
              prefix_mod = prev_mod;
            }
            else {
              prefix_mod = ly_ctx_nget_module(ctx_local,mod_name,(long)mod_name_len,(char *)0x0,1);
              if (prefix_mod == (lys_module *)0x0) {
                str = strndup(nodeid,(size_t)(mod_name + ((long)mod_name_len - (long)nodeid)));
                ly_vlog(ctx_local,LYE_PATH_INMOD,LY_VLOG_STR,str);
                free(str);
                plVar3 = (lys_node *)0x0;
                goto LAB_0011dde9;
              }
            }
            plVar2 = lys_node_module(sibling);
          } while (prefix_mod != plVar2);
          if (has_predicate != 0) {
            r = 0;
            if ((sibling->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
              if (sibling->nodetype != LYS_LIST) {
                ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)*id,id)
                ;
                plVar3 = (lys_node *)0x0;
                goto LAB_0011dde9;
              }
              iVar1 = resolve_json_schema_list_predicate(id,(lys_node_list *)sibling,&r);
              if (iVar1 != 0) {
                plVar3 = (lys_node *)0x0;
                goto LAB_0011dde9;
              }
            }
            else {
              r = parse_schema_json_predicate
                            (id,(char **)0x0,(int *)0x0,(char **)0x0,(int *)0x0,(char **)0x0,
                             (int *)0x0,&has_predicate);
              if (r < 1) {
                ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[-r],
                        id + -r);
                plVar3 = (lys_node *)0x0;
                goto LAB_0011dde9;
              }
            }
            id = id + r;
          }
          plVar3 = sibling;
          if (*id == '\0') goto LAB_0011dde9;
          if ((sibling->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) != LYS_UNKNOWN) {
            ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)*id,id);
            plVar3 = (lys_node *)0x0;
            goto LAB_0011dde9;
          }
          start_parent = sibling;
          plVar2 = module;
          if (sibling->child != (lys_node *)0x0) {
            plVar2 = lys_node_module(sibling->child);
          }
LAB_0011dcce:
          prev_mod = plVar2;
          if (sibling == (lys_node *)0x0) {
            str = strndup(nodeid,(size_t)(name + ((long)nam_len - (long)nodeid)));
            ly_vlog(ctx_local,LYE_PATH_INNODE,LY_VLOG_STR,str);
            free(str);
            plVar3 = (lys_node *)0x0;
            goto LAB_0011dde9;
          }
          r = parse_schema_nodeid(id,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,
                                  &has_predicate,(int *)0x0,0);
          if (r < 1) goto code_r0x0011dd7d;
          id = id + r;
        } while( true );
      }
      if (mod_name == (char *)0x0) {
        str = strndup(nodeid,(size_t)(name + ((long)nam_len - (long)nodeid)));
        ly_vlog(ctx_local,LYE_PATH_MISSMOD,LY_VLOG_STR,nodeid);
        free(str);
        plVar3 = (lys_node *)0x0;
      }
      else {
        str = strndup(mod_name,(long)mod_name_len);
        module = ly_ctx_get_module(ctx_local,str,(char *)0x0,1);
        free(str);
        if (module == (lys_module *)0x0) {
          str = strndup(nodeid,(size_t)(mod_name + ((long)mod_name_len - (long)nodeid)));
          ly_vlog(ctx_local,LYE_PATH_INMOD,LY_VLOG_STR,str);
          free(str);
          plVar3 = (lys_node *)0x0;
        }
        else {
          start_parent = (lys_node *)0x0;
          if ((yang_data_name == (char *)0x0) ||
             (start_parent = lyp_get_yang_data_template(module,yang_data_name,yang_data_name_len),
             start_parent != (lys_node *)0x0)) {
            mod_name = (char *)0x0;
            mod_name_len = 0;
            goto LAB_0011d927;
          }
          str = strndup(nodeid,(size_t)(yang_data_name + ((long)yang_data_name_len - (long)nodeid)))
          ;
          ly_vlog(ctx_local,LYE_PATH_INNODE,LY_VLOG_STR,str);
          free(str);
          plVar3 = (lys_node *)0x0;
        }
      }
    }
  }
LAB_0011dde9:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
code_r0x0011dd7d:
  ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[-r],id + -r);
  plVar3 = (lys_node *)0x0;
  goto LAB_0011dde9;
}



int resolve_partial_json_data_list_predicate(parsed_pred pp,lyd_node *node,int position)

{
  ly_ctx *ctx_00;
  lys_node *plVar1;
  int iVar2;
  ushort **ppuVar3;
  lys_module *plVar4;
  lys_module *plVar5;
  char *pcVar6;
  int position_local;
  lyd_node *node_local;
  uint16_t i;
  lyd_node_leaf_list *key;
  ly_ctx *ctx;
  lys_node_list *slist;
  char *val_str;
  
  if (node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x9e4,"resolve_partial_json_data_list_predicate");
  }
  if (node->schema->nodetype != LYS_LIST) {
                    // WARNING: Subroutine does not return
    __assert_fail("node->schema->nodetype == LYS_LIST",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x9e5,"resolve_partial_json_data_list_predicate");
  }
  if (pp.len == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("pp.len",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x9e6,"resolve_partial_json_data_list_predicate");
  }
  ctx_00 = node->schema->module->ctx;
  plVar1 = node->schema;
  ppuVar3 = __ctype_b_loc();
  if (((*ppuVar3)[*(pp.pred)->name] & 0x800) == 0) {
    key = (lyd_node_leaf_list *)node->child;
    if (key == (lyd_node_leaf_list *)0x0) {
      iVar2 = 1;
    }
    else {
      for (i = 0; i < plVar1->padding[2]; i = i + 1) {
        iVar2 = strncmp(key->schema->name,pp.pred[i].name,(long)pp.pred[i].nam_len);
        if ((iVar2 != 0) || (key->schema->name[pp.pred[i].nam_len] != '\0')) {
          ly_vlog(ctx_00,LYE_PATH_INKEY,LY_VLOG_NONE,(void *)0x0,pp.pred[i].name);
          return -1;
        }
        if (pp.pred[i].mod_name == (char *)0x0) {
          plVar4 = lyd_node_module((lyd_node *)key);
          plVar5 = lyd_node_module(node);
          if (plVar4 != plVar5) {
            ly_vlog(ctx_00,LYE_PATH_INKEY,LY_VLOG_NONE,(void *)0x0,pp.pred[i].name);
            return -1;
          }
        }
        else {
          iVar2 = pp.pred[i].mod_name_len;
          pcVar6 = pp.pred[i].mod_name;
          plVar4 = lyd_node_module((lyd_node *)key);
          iVar2 = strncmp(plVar4->name,pcVar6,(long)iVar2);
          if ((iVar2 != 0) ||
             (plVar4 = lyd_node_module((lyd_node *)key),
             plVar4->name[pp.pred[i].mod_name_len] != '\0')) {
            ly_vlog(ctx_00,LYE_PATH_INKEY,LY_VLOG_NONE,(void *)0x0,pp.pred[i].name);
            return -1;
          }
          plVar4 = lyd_node_module((lyd_node *)key);
          plVar5 = lyd_node_module(node);
          if (plVar4 == plVar5) {
            ly_vlog(ctx_00,LYE_PATH_INKEY,LY_VLOG_NONE,(void *)0x0,pp.pred[i].name);
            return -1;
          }
        }
        pcVar6 = lyd_make_canonical(key->schema,pp.pred[i].value,pp.pred[i].val_len);
        if (pcVar6 == (char *)0x0) {
          return -1;
        }
        iVar2 = strcmp(key->value_str,pcVar6);
        if (iVar2 != 0) {
          free(pcVar6);
          return 1;
        }
        free(pcVar6);
        key = (lyd_node_leaf_list *)key->next;
      }
      iVar2 = 0;
    }
  }
  else {
    iVar2 = atoi((pp.pred)->name);
    if (position == iVar2) {
      iVar2 = 0;
    }
    else {
      iVar2 = 1;
    }
  }
  return iVar2;
}



lyd_node *
resolve_partial_json_data_nodeid
          (char *nodeid,char *llist_value,lyd_node *start,int options,int *parsed)

{
  long lVar1;
  parsed_pred pp_00;
  parsed_pred pp_01;
  int iVar2;
  size_t sVar3;
  char *pcVar4;
  ushort **ppuVar5;
  lys_node *plVar6;
  lys_module *plVar7;
  lyd_node *plVar8;
  long in_FS_OFFSET;
  int *parsed_local;
  int options_local;
  lyd_node *start_local;
  char *llist_value_local;
  char *nodeid_local;
  int mod_name_len;
  int nam_len;
  int is_relative;
  int has_predicate;
  int r;
  int list_instance_position;
  int last_parsed;
  int llval_len;
  int ret;
  char *mod_name;
  char *name;
  char *id;
  char *data_val;
  char *llval;
  lyd_node *sibling;
  lyd_node *last_match;
  lys_module *prev_mod;
  lys_node *ssibling;
  ly_ctx *ctx;
  lys_node *sparent;
  lys_node_list *slist;
  lyd_node_leaf_list *llist;
  parsed_pred pp;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  is_relative = -1;
  last_parsed = 0;
  last_match = (lyd_node *)0x0;
  if (((nodeid == (char *)0x0) || (start == (lyd_node *)0x0)) || (parsed == (int *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("nodeid && start && parsed",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0xa43,"resolve_partial_json_data_nodeid");
  }
  memset(&pp,0,0x18);
  ctx = start->schema->module->ctx;
  id = nodeid;
  r = parse_schema_nodeid(nodeid,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,(int *)0x0,
                          (int *)0x0,1);
  if (r < 1) {
    ly_vlog(ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[-r],id + -r);
  }
  else {
    if (*name == '#') {
      if (is_relative != 0) {
        ly_vlog(ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,0x23,name);
        goto LAB_0011f296;
      }
      id = id + r;
      last_parsed = r;
    }
    else {
      is_relative = -1;
    }
    r = parse_schema_nodeid(id,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,&has_predicate,
                            (int *)0x0,0);
    if (0 < r) {
      id = id + r;
      last_parsed = last_parsed + r;
      start_local = start;
      if (is_relative == 0) {
        for (; start_local->parent != (lyd_node *)0x0; start_local = start_local->parent) {
        }
        prev_mod = lyd_node_module(start_local);
      }
      else {
        prev_mod = lyd_node_module(start);
        if ((start->schema->nodetype & 0x4191) == LYS_UNKNOWN) {
          start_local = (lyd_node *)0x0;
        }
        else {
          start_local = start->child;
        }
      }
      if (start_local != (lyd_node *)0x0) {
        do {
          free(pp.pred);
          pp.schema = (lys_node *)0x0;
          pp.len = 0;
          pp.pred = (anon_struct_48_6_89480d8a *)0x0;
          while (has_predicate != 0) {
            pp.len = pp.len + 1;
            pp.pred = (anon_struct_48_6_89480d8a *)ly_realloc(pp.pred,(long)pp.len * 0x30);
            if (pp.pred == (anon_struct_48_6_89480d8a *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "resolve_partial_json_data_nodeid");
              goto LAB_0011f296;
            }
            r = parse_schema_json_predicate
                          (id,&pp.pred[(long)pp.len + -1].mod_name,
                           &pp.pred[(long)pp.len + -1].mod_name_len,&pp.pred[(long)pp.len + -1].name
                           ,&pp.pred[(long)pp.len + -1].nam_len,&pp.pred[(long)pp.len + -1].value,
                           &pp.pred[(long)pp.len + -1].val_len,&has_predicate);
            if (r < 1) {
              ly_vlog(ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)*id,id);
              goto LAB_0011f296;
            }
            id = id + r;
            last_parsed = last_parsed + r;
          }
          ssibling = (lys_node *)0x0;
          if ((start_local == (lyd_node *)0x0) || (start_local->parent == (lyd_node *)0x0)) {
            sparent = (lys_node *)0x0;
          }
          else {
            sparent = start_local->parent->schema;
          }
LAB_0011e6af:
          do {
            ssibling = lys_getnext(ssibling,sparent,prev_mod,0);
            if (ssibling == (lys_node *)0x0) break;
            if ((sparent != (lys_node *)0x0) && ((sparent->nodetype & 0x4100) != LYS_UNKNOWN)) {
              if ((options & 4U) == 0) {
                plVar6 = lys_parent(ssibling);
                if (plVar6->nodetype == LYS_OUTPUT) goto LAB_0011e6af;
              }
              else {
                plVar6 = lys_parent(ssibling);
                if (plVar6->nodetype == LYS_INPUT) goto LAB_0011e6af;
              }
            }
            iVar2 = schema_nodeid_siblingcheck(ssibling,prev_mod,mod_name,mod_name_len,name,nam_len)
            ;
          } while (iVar2 != 0);
          if (ssibling == (lys_node *)0x0) {
            free(pp.pred);
            plVar8 = last_match;
            goto LAB_0011f2b4;
          }
          pp.schema = ssibling;
          if (((*id == '\0') && (pp.len == 0)) && (ssibling->nodetype == LYS_LEAFLIST)) {
            pp.len = 1;
            pp.pred = (anon_struct_48_6_89480d8a *)calloc(1,0x30);
            if (pp.pred == (anon_struct_48_6_89480d8a *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "resolve_partial_json_data_nodeid");
              goto LAB_0011f296;
            }
            (pp.pred)->name = ".";
            (pp.pred)->nam_len = 1;
            pcVar4 = llist_value;
            if (llist_value == (char *)0x0) {
              pcVar4 = "";
            }
            (pp.pred)->value = pcVar4;
            sVar3 = strlen((pp.pred)->value);
            (pp.pred)->val_len = (int)sVar3;
          }
          if ((ssibling->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
            if (ssibling->nodetype == LYS_LIST) {
              slist = (lys_node_list *)ssibling;
              plVar8 = last_match;
              if (pp.len == 0) goto LAB_0011f2b4;
              ppuVar5 = __ctype_b_loc();
              if (((*ppuVar5)[*(pp.pred)->name] & 0x800) == 0) {
                if ((int)(uint)slist->keys_size < pp.len) {
                  ly_vlog(ctx,LYE_PATH_PREDTOOMANY,LY_VLOG_NONE,(void *)0x0);
                  goto LAB_0011f296;
                }
                if (pp.len < (int)(uint)slist->keys_size) {
                  ly_vlog(ctx,LYE_PATH_MISSKEY,LY_VLOG_NONE,(void *)0x0,slist->keys[pp.len]->name);
                  goto LAB_0011f296;
                }
                for (r = 0; r < pp.len; r = r + 1) {
                  if (((slist->keys[r]->type).base == LY_TYPE_IDENT) &&
                     (pcVar4 = strnchr(pp.pred[r].value,0x3a,pp.pred[r].val_len),
                     pcVar4 == (char *)0x0)) {
                    ly_vlog(ctx,LYE_PATH_INIDENTREF,LY_VLOG_LYS,slist->keys[r],
                            (ulong)(uint)pp.pred[r].val_len,pp.pred[r].value);
                    goto LAB_0011f296;
                  }
                }
              }
            }
            else if (pp.pred != (anon_struct_48_6_89480d8a *)0x0) {
              ly_vlog(ctx,LYE_PATH_PREDTOOMANY,LY_VLOG_NONE,(void *)0x0);
              goto LAB_0011f296;
            }
          }
          else {
            if (1 < pp.len) {
              ly_vlog(ctx,LYE_PATH_PREDTOOMANY,LY_VLOG_NONE,(void *)0x0);
              goto LAB_0011f296;
            }
            if (pp.len != 0) {
              if ((*(pp.pred)->name != '.') || ((pp.pred)->nam_len != 1)) {
                ly_vlog(ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,
                        (ulong)(uint)(int)*(pp.pred)->name,(pp.pred)->name);
                goto LAB_0011f296;
              }
              if ((*(int *)&ssibling[1].ref == 7) &&
                 (pcVar4 = strnchr((pp.pred)->value,0x3a,(pp.pred)->val_len), pcVar4 == (char *)0x0)
                 ) {
                ly_vlog(ctx,LYE_PATH_INIDENTREF,LY_VLOG_LYS,ssibling,(ulong)(uint)(pp.pred)->val_len
                        ,(pp.pred)->value);
                goto LAB_0011f296;
              }
            }
          }
          if ((((start_local->parent == (lyd_node *)0x0) ||
               (start_local->parent->ht == (hash_table *)0x0)) ||
              (((pp.schema)->nodetype == LYS_LIST && ((pp.schema)->padding[2] == '\0')))) ||
             (((pp.schema)->nodetype == LYS_LEAFLIST && (((pp.schema)->flags & 1) == 0)))) {
            list_instance_position = 0;
            for (sibling = start_local; sibling != (lyd_node *)0x0; sibling = sibling->next) {
              plVar6 = lys_parent(sibling->schema);
              if (plVar6 != (lys_node *)0x0) {
                if ((options & 4U) == 0) {
                  plVar6 = lys_parent(sibling->schema);
                  if (plVar6->nodetype == LYS_OUTPUT) {
                    ly_log(ctx,LY_LLERR,LY_EINVAL,
                           "Provided data tree includes some RPC output nodes (%s).",
                           sibling->schema->name);
                    goto LAB_0011f296;
                  }
                }
                else {
                  plVar6 = lys_parent(sibling->schema);
                  if (plVar6->nodetype == LYS_INPUT) {
                    ly_log(ctx,LY_LLERR,LY_EINVAL,
                           "Provided data tree includes some RPC input nodes (%s).",
                           sibling->schema->name);
                    goto LAB_0011f296;
                  }
                }
              }
              if (ssibling == sibling->schema) {
                if (ssibling->nodetype == LYS_LEAFLIST) {
                  if ((ssibling->flags & 2) == 0) {
                    llist = (lyd_node_leaf_list *)sibling;
                    llval = (char *)0x0;
                    llval_len = 0;
                    if (pp.pred != (anon_struct_48_6_89480d8a *)0x0) {
                      llval = (pp.pred)->value;
                      llval_len = (pp.pred)->val_len;
                    }
                    if (((llval == (char *)0x0) ||
                        (pcVar4 = strchr(llval,0x3a), pcVar4 != (char *)0x0)) ||
                       ((llist->value_type & 7) == 0)) {
LAB_0011ede4:
                      data_val = llist->value_str;
                    }
                    else {
                      plVar7 = lyd_node_module(sibling);
                      sVar3 = strlen(plVar7->name);
                      plVar7 = lyd_node_module(sibling);
                      iVar2 = strncmp(llist->value_str,plVar7->name,sVar3);
                      if (iVar2 != 0) goto LAB_0011ede4;
                      pcVar4 = llist->value_str;
                      plVar7 = lyd_node_module(sibling);
                      sVar3 = strlen(plVar7->name);
                      if (pcVar4[sVar3] != ':') goto LAB_0011ede4;
                      pcVar4 = llist->value_str;
                      plVar7 = lyd_node_module(sibling);
                      sVar3 = strlen(plVar7->name);
                      data_val = pcVar4 + sVar3 + 1;
                    }
                    if ((((llval != (char *)0x0) || (data_val == (char *)0x0)) ||
                        (*data_val == '\0')) &&
                       ((llval == (char *)0x0 ||
                        ((iVar2 = strncmp(llval,data_val,(long)llval_len), iVar2 == 0 &&
                         (data_val[llval_len] == '\0')))))) break;
                  }
                }
                else {
                  if (ssibling->nodetype != LYS_LIST) break;
                  list_instance_position = list_instance_position + 1;
                  pp_01._12_4_ = pp._12_4_;
                  pp_01.len = pp.len;
                  pp_01.schema = pp.schema;
                  pp_01.pred._0_4_ = (int)pp.pred;
                  pp_01.pred._4_4_ = (int)((ulong)pp.pred >> 0x20);
                  ret = resolve_partial_json_data_list_predicate
                                  (pp_01,sibling,list_instance_position);
                  if (ret == -1) goto LAB_0011f296;
                  if (ret != 1) break;
                }
              }
            }
          }
          else {
            pp_00._12_4_ = pp._12_4_;
            pp_00.len = pp.len;
            pp_00.schema = pp.schema;
            pp_00.pred._0_4_ = (int)pp.pred;
            pp_00.pred._4_4_ = (int)((ulong)pp.pred >> 0x20);
            sibling = resolve_json_data_node_hash(start_local->parent,pp_00);
          }
          if (sibling == (lyd_node *)0x0) {
            free(pp.pred);
            plVar8 = last_match;
            goto LAB_0011f2b4;
          }
          *parsed = *parsed + last_parsed;
          last_match = sibling;
          prev_mod = lyd_node_module(sibling);
          if (*id == '\0') {
            free(pp.pred);
            plVar8 = last_match;
            goto LAB_0011f2b4;
          }
          if ((ssibling->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) != LYS_UNKNOWN) {
            ly_vlog(ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)*id,id);
            goto LAB_0011f296;
          }
          if (sibling->child == (lyd_node *)0x0) {
            free(pp.pred);
            plVar8 = last_match;
            goto LAB_0011f2b4;
          }
          start_local = sibling->child;
          r = parse_schema_nodeid(id,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,
                                  &has_predicate,(int *)0x0,0);
          if (r < 1) goto code_r0x0011f00e;
          id = id + r;
          last_parsed = r;
        } while( true );
      }
      plVar8 = (lyd_node *)0x0;
      goto LAB_0011f2b4;
    }
    ly_vlog(ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[-r],id + -r);
  }
LAB_0011f296:
  *parsed = -1;
  free(pp.pred);
  plVar8 = (lyd_node *)0x0;
LAB_0011f2b4:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar8;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
code_r0x0011f00e:
  ly_vlog(ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[-r],id + -r);
  goto LAB_0011f296;
}



int resolve_len_ran_interval(ly_ctx *ctx,char *str_restr,lys_type *type,len_ran_intv **ret)

{
  int iVar1;
  len_ran_intv *plVar2;
  ushort **ppuVar3;
  ulonglong uVar4;
  longlong lVar5;
  char *pcVar6;
  long in_FS_OFFSET;
  len_ran_intv **ret_local;
  lys_type *type_local;
  char *str_restr_local;
  ly_ctx *ctx_local;
  uint8_t local_fdig;
  int kind;
  char *ptr;
  len_ran_intv *intv;
  int64_t local_smin;
  int64_t local_smax;
  int64_t local_fmin;
  int64_t local_fmax;
  uint64_t local_umin;
  uint64_t local_umax;
  char *seg_ptr;
  len_ran_intv *local_intv;
  len_ran_intv *tmp_local_intv;
  len_ran_intv *tmp_intv;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_smin = 0;
  local_smax = 0;
  local_umax = 0;
  local_fdig = '\0';
  local_intv = (len_ran_intv *)0x0;
  tmp_local_intv = (len_ran_intv *)0x0;
  intv = (len_ran_intv *)0x0;
  if (false) {
switchD_0011f368_caseD_0:
    iVar1 = -1;
  }
  else {
    str_restr_local = str_restr;
    switch(type->base) {
    default:
      goto switchD_0011f368_caseD_0;
    case LY_TYPE_BINARY:
      kind = 0;
      local_umin = 0;
      local_umax = 0xffffffffffffffff;
      if ((str_restr == (char *)0x0) && ((type->info).bits.bit != (lys_type_bit *)0x0)) {
        str_restr_local = ((type->info).bits.bit)->name;
      }
      break;
    case LY_TYPE_DEC64:
      kind = 2;
      local_fmin = -0x8000000000000000;
      local_fmax = 0x7fffffffffffffff;
      local_fdig = (type->info).dec64.dig;
      if ((str_restr == (char *)0x0) && ((type->info).bits.bit != (lys_type_bit *)0x0)) {
        str_restr_local = ((type->info).bits.bit)->name;
      }
      break;
    case LY_TYPE_STRING:
      kind = 0;
      local_umin = 0;
      local_umax = 0xffffffffffffffff;
      if ((str_restr == (char *)0x0) && ((type->info).bits.bit != (lys_type_bit *)0x0)) {
        str_restr_local = ((type->info).bits.bit)->name;
      }
      break;
    case LY_TYPE_INT8:
      kind = 1;
      local_smin = -0x80;
      local_smax = 0x7f;
      if ((str_restr == (char *)0x0) && ((type->info).bits.bit != (lys_type_bit *)0x0)) {
        str_restr_local = ((type->info).bits.bit)->name;
      }
      break;
    case LY_TYPE_UINT8:
      kind = 0;
      local_umin = 0;
      local_umax = 0xff;
      if ((str_restr == (char *)0x0) && ((type->info).bits.bit != (lys_type_bit *)0x0)) {
        str_restr_local = ((type->info).bits.bit)->name;
      }
      break;
    case LY_TYPE_INT16:
      kind = 1;
      local_smin = -0x8000;
      local_smax = 0x7fff;
      if ((str_restr == (char *)0x0) && ((type->info).bits.bit != (lys_type_bit *)0x0)) {
        str_restr_local = ((type->info).bits.bit)->name;
      }
      break;
    case LY_TYPE_UINT16:
      kind = 0;
      local_umin = 0;
      local_umax = 0xffff;
      if ((str_restr == (char *)0x0) && ((type->info).bits.bit != (lys_type_bit *)0x0)) {
        str_restr_local = ((type->info).bits.bit)->name;
      }
      break;
    case LY_TYPE_INT32:
      kind = 1;
      local_smin = -0x80000000;
      local_smax = 0x7fffffff;
      if ((str_restr == (char *)0x0) && ((type->info).bits.bit != (lys_type_bit *)0x0)) {
        str_restr_local = ((type->info).bits.bit)->name;
      }
      break;
    case LY_TYPE_UINT32:
      kind = 0;
      local_umin = 0;
      local_umax = 0xffffffff;
      if ((str_restr == (char *)0x0) && ((type->info).bits.bit != (lys_type_bit *)0x0)) {
        str_restr_local = ((type->info).bits.bit)->name;
      }
      break;
    case LY_TYPE_INT64:
      kind = 1;
      local_smin = -0x8000000000000000;
      local_smax = 0x7fffffffffffffff;
      if ((str_restr == (char *)0x0) && ((type->info).bits.bit != (lys_type_bit *)0x0)) {
        str_restr_local = ((type->info).bits.bit)->name;
      }
      break;
    case LY_TYPE_UINT64:
      kind = 0;
      local_umin = 0;
      local_umax = 0xffffffffffffffff;
      if ((str_restr == (char *)0x0) && ((type->info).bits.bit != (lys_type_bit *)0x0)) {
        str_restr_local = ((type->info).bits.bit)->name;
      }
    }
    if (type->der != (lys_tpdf *)0x0) {
      iVar1 = resolve_len_ran_interval(ctx,(char *)0x0,&type->der->type,&intv);
      if (iVar1 != 0) {
        iVar1 = -1;
        goto LAB_0012014d;
      }
      if ((intv != (len_ran_intv *)0x0) && (kind != (uint)intv->kind)) {
                    // WARNING: Subroutine does not return
        __assert_fail("!intv || (intv->kind == kind)",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                      ,0xbdf,"resolve_len_ran_interval");
      }
    }
    if (str_restr_local == (char *)0x0) {
      *ret = intv;
      iVar1 = 0;
    }
    else {
      if (intv != (len_ran_intv *)0x0) {
        tmp_intv = intv;
        if (kind == 0) {
          local_umin = (intv->value).uval.min;
        }
        else if (kind == 1) {
          local_smin = (intv->value).sval.min;
        }
        else if (kind == 2) {
          local_fmin = (intv->value).sval.min;
        }
        for (; tmp_intv->next != (len_ran_intv *)0x0; tmp_intv = tmp_intv->next) {
        }
        if (kind == 0) {
          local_umax = (tmp_intv->value).uval.max;
        }
        else if (kind == 1) {
          local_smax = (tmp_intv->value).sval.max;
        }
        else if (kind == 2) {
          local_fmax = (tmp_intv->value).sval.max;
        }
      }
      seg_ptr = str_restr_local;
      tmp_intv = (len_ran_intv *)0x0;
      while( true ) {
        if (tmp_local_intv == (len_ran_intv *)0x0) {
          if (local_intv != (len_ran_intv *)0x0) {
                    // WARNING: Subroutine does not return
            __assert_fail("!local_intv",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                          ,0xc06,"resolve_len_ran_interval");
          }
          local_intv = (len_ran_intv *)malloc(0x28);
          tmp_local_intv = local_intv;
        }
        else {
          plVar2 = (len_ran_intv *)malloc(0x28);
          tmp_local_intv->next = plVar2;
          tmp_local_intv = tmp_local_intv->next;
        }
        if (tmp_local_intv == (len_ran_intv *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_len_ran_interval")
          ;
          goto LAB_00120116;
        }
        tmp_local_intv->kind = (uint8_t)kind;
        tmp_local_intv->type = type;
        tmp_local_intv->next = (len_ran_intv *)0x0;
        ptr = seg_ptr;
        while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*ptr] & 0x2000) != 0) {
          ptr = ptr + 1;
        }
        ppuVar3 = __ctype_b_loc();
        if (((((*ppuVar3)[*ptr] & 0x800) == 0) && (*ptr != '+')) && (*ptr != '-')) {
          iVar1 = strncmp(ptr,"min",3);
          if (iVar1 == 0) {
            if (kind == 0) {
              (tmp_local_intv->value).uval.min = local_umin;
            }
            else if (kind == 1) {
              (tmp_local_intv->value).sval.min = local_smin;
            }
            else if (kind == 2) {
              (tmp_local_intv->value).sval.min = local_fmin;
            }
            ptr = ptr + 3;
          }
          else {
            iVar1 = strncmp(ptr,"max",3);
            if (iVar1 != 0) goto LAB_00120116;
            if (kind == 0) {
              (tmp_local_intv->value).uval.min = local_umax;
            }
            else if (kind == 1) {
              (tmp_local_intv->value).sval.min = local_smax;
            }
            else if (kind == 2) {
              (tmp_local_intv->value).sval.min = local_fmax;
            }
            ptr = ptr + 3;
          }
        }
        else if (kind == 0) {
          uVar4 = strtoull(ptr,&ptr,10);
          (tmp_local_intv->value).uval.min = uVar4;
        }
        else if (kind == 1) {
          lVar5 = strtoll(ptr,&ptr,10);
          (tmp_local_intv->value).sval.min = lVar5;
        }
        else if ((kind == 2) &&
                (iVar1 = parse_range_dec64(&ptr,local_fdig,(int64_t *)&tmp_local_intv->value),
                iVar1 != 0)) {
          ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,ptr,"range");
          goto LAB_00120116;
        }
        while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*ptr] & 0x2000) != 0) {
          ptr = ptr + 1;
        }
        if ((*ptr == '|') || (*ptr == '\0')) {
          if (kind == 0) {
            (tmp_local_intv->value).uval.max = (tmp_local_intv->value).uval.min;
          }
          else if (kind == 1) {
            (tmp_local_intv->value).uval.max = (tmp_local_intv->value).uval.min;
          }
          else if (kind == 2) {
            (tmp_local_intv->value).uval.max = (tmp_local_intv->value).uval.min;
          }
        }
        else {
          iVar1 = strncmp(ptr,"..",2);
          if (iVar1 != 0) goto LAB_00120116;
          ptr = ptr + 2;
          while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*ptr] & 0x2000) != 0) {
            ptr = ptr + 1;
          }
          ppuVar3 = __ctype_b_loc();
          if (((((*ppuVar3)[*ptr] & 0x800) == 0) && (*ptr != '+')) && (*ptr != '-')) {
            iVar1 = strncmp(ptr,"max",3);
            if (iVar1 != 0) goto LAB_00120116;
            if (kind == 0) {
              (tmp_local_intv->value).uval.max = local_umax;
            }
            else if (kind == 1) {
              (tmp_local_intv->value).sval.max = local_smax;
            }
            else if (kind == 2) {
              (tmp_local_intv->value).sval.max = local_fmax;
            }
          }
          else if (kind == 0) {
            uVar4 = strtoull(ptr,&ptr,10);
            (tmp_local_intv->value).uval.max = uVar4;
          }
          else if (kind == 1) {
            lVar5 = strtoll(ptr,&ptr,10);
            (tmp_local_intv->value).sval.max = lVar5;
          }
          else if ((kind == 2) &&
                  (iVar1 = parse_range_dec64(&ptr,local_fdig,&(tmp_local_intv->value).sval.max),
                  iVar1 != 0)) {
            ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,ptr,"range");
            goto LAB_00120116;
          }
        }
        if (kind == 0) {
          if (((((tmp_local_intv->value).uval.max < (tmp_local_intv->value).uval.min) ||
               ((tmp_local_intv->value).uval.min < local_umin)) ||
              (local_umax < (tmp_local_intv->value).uval.max)) ||
             ((tmp_intv != (len_ran_intv *)0x0 &&
              ((tmp_local_intv->value).uval.min <= (tmp_intv->value).uval.max)))) goto LAB_00120116;
        }
        else if (kind == 1) {
          if (((tmp_local_intv->value).sval.max < (tmp_local_intv->value).sval.min) ||
             ((((tmp_local_intv->value).sval.min < local_smin ||
               (local_smax < (tmp_local_intv->value).sval.max)) ||
              ((tmp_intv != (len_ran_intv *)0x0 &&
               ((tmp_local_intv->value).sval.min <= (tmp_intv->value).sval.max))))))
          goto LAB_00120116;
        }
        else if ((kind == 2) &&
                ((((tmp_local_intv->value).sval.max < (tmp_local_intv->value).sval.min ||
                  ((tmp_local_intv->value).sval.min < local_fmin)) ||
                 ((local_fmax < (tmp_local_intv->value).sval.max ||
                  ((tmp_intv != (len_ran_intv *)0x0 &&
                   ((tmp_local_intv->value).sval.min <= (tmp_intv->value).sval.max))))))))
        goto LAB_00120116;
        pcVar6 = strchr(seg_ptr,0x7c);
        if (pcVar6 == (char *)0x0) break;
        seg_ptr = pcVar6 + 1;
        tmp_intv = tmp_local_intv;
      }
      seg_ptr = (char *)0x0;
      if (intv != (len_ran_intv *)0x0) {
        tmp_intv = intv;
        tmp_local_intv = local_intv;
        while ((tmp_local_intv != (len_ran_intv *)0x0 && (tmp_intv != (len_ran_intv *)0x0))) {
          if (kind == 0) {
            local_umin = (tmp_local_intv->value).uval.min;
            local_umax = (tmp_local_intv->value).uval.max;
            if ((local_umin < (tmp_intv->value).uval.min) ||
               ((tmp_intv->value).uval.max < local_umin)) {
LAB_00120049:
              tmp_intv = tmp_intv->next;
            }
            else {
              if ((tmp_intv->value).uval.max < local_umax) goto LAB_00120116;
              tmp_local_intv = tmp_local_intv->next;
            }
          }
          else if (kind == 1) {
            local_smin = (tmp_local_intv->value).sval.min;
            local_smax = (tmp_local_intv->value).sval.max;
            if ((local_smin < (tmp_intv->value).sval.min) ||
               ((tmp_intv->value).sval.max < local_smin)) goto LAB_00120049;
            if ((tmp_intv->value).sval.max < local_smax) goto LAB_00120116;
            tmp_local_intv = tmp_local_intv->next;
          }
          else {
            if (kind != 2) goto LAB_00120049;
            local_fmin = (tmp_local_intv->value).sval.min;
            local_fmax = (tmp_local_intv->value).sval.max;
            iVar1 = dec64cmp(local_fmin,local_fdig,(tmp_intv->value).sval.min,local_fdig);
            if ((iVar1 < 0) ||
               (iVar1 = dec64cmp(local_fmin,local_fdig,(tmp_intv->value).sval.max,local_fdig),
               0 < iVar1)) goto LAB_00120049;
            iVar1 = dec64cmp(local_fmax,local_fdig,(tmp_intv->value).sval.max,local_fdig);
            if (0 < iVar1) goto LAB_00120116;
            tmp_local_intv = tmp_local_intv->next;
          }
        }
        if (tmp_local_intv != (len_ran_intv *)0x0) {
LAB_00120116:
          while (intv != (len_ran_intv *)0x0) {
            tmp_intv = intv->next;
            free(intv);
            intv = tmp_intv;
          }
          while (local_intv != (len_ran_intv *)0x0) {
            tmp_local_intv = local_intv->next;
            free(local_intv);
            local_intv = tmp_local_intv;
          }
          iVar1 = -1;
          goto LAB_0012014d;
        }
      }
      if (intv == (len_ran_intv *)0x0) {
        intv = local_intv;
      }
      else {
        for (tmp_intv = intv; tmp_intv->next != (len_ran_intv *)0x0; tmp_intv = tmp_intv->next) {
        }
        tmp_intv->next = local_intv;
      }
      *ret = intv;
      iVar1 = 0;
    }
  }
LAB_0012014d:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int resolve_superior_type_check(lys_type *type)

{
  int iVar1;
  lys_type *type_local;
  uint32_t i;
  
  if (type->base == LY_TYPE_DER) {
    iVar1 = 1;
  }
  else {
    if (type->base == LY_TYPE_UNION) {
      for (i = 0; i < (type->info).bits.count; i = i + 1) {
        iVar1 = resolve_superior_type_check
                          ((lys_type *)((long)(type->info).bits.bit + (ulong)i * 0x40));
        if (iVar1 != 0) {
          return 1;
        }
      }
    }
    else {
      type_local = type;
      if (type->base == LY_TYPE_LEAFREF) {
        for (; (type_local->info).bits.bit == (lys_type_bit *)0x0;
            type_local = &type_local->der->type) {
          if (type_local->der == (lys_tpdf *)0x0) {
                    // WARNING: Subroutine does not return
            __assert_fail("type->der",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                          ,0xcfd,"resolve_superior_type_check");
          }
        }
      }
    }
    iVar1 = 0;
  }
  return iVar1;
}



int resolve_superior_type
              (char *name,char *mod_name,lys_module *module,lys_node *parent,lys_tpdf **ret)

{
  LYS_NODE LVar1;
  int iVar2;
  lys_tpdf **ret_local;
  lys_node *parent_local;
  lys_module *module_local;
  char *mod_name_local;
  char *name_local;
  int i;
  int j;
  int tpdf_size;
  lys_tpdf *tpdf;
  lys_tpdf *match;
  
  mod_name_local = mod_name;
  if (mod_name == (char *)0x0) {
    for (i = 1; i < 0x14; i = i + 1) {
      iVar2 = strcmp(ly_types[i]->name,name);
      if (iVar2 == 0) {
        if (ret != (lys_tpdf **)0x0) {
          *ret = ly_types[i];
        }
        return 0;
      }
    }
  }
  else {
    iVar2 = strcmp(mod_name,module->name);
    if (iVar2 == 0) {
      mod_name_local = (char *)0x0;
    }
  }
  if ((mod_name_local == (char *)0x0) && (parent_local = parent, parent != (lys_node *)0x0)) {
    while (module_local = module, parent_local != (lys_node *)0x0) {
      LVar1 = parent_local->nodetype;
      if (LVar1 == LYS_ACTION) {
LAB_001203f3:
        tpdf_size = (int)*(ushort *)(parent_local->padding + 2);
        tpdf = (lys_tpdf *)parent_local[1].name;
LAB_00120459:
        for (i = 0; i < tpdf_size; i = i + 1) {
          iVar2 = strcmp(tpdf[i].name,name);
          if (iVar2 == 0) {
            match = tpdf + i;
            goto LAB_00120686;
          }
        }
        parent_local = lys_parent(parent_local);
      }
      else {
        if (LVar1 < (LYS_CONTAINER|LYS_ACTION)) {
          if (LVar1 == LYS_GROUPING) {
            tpdf_size = (int)*(ushort *)(parent_local->padding + 2);
            tpdf = *(lys_tpdf **)parent_local->hash;
            goto LAB_00120459;
          }
          if (LVar1 < (LYS_CONTAINER|LYS_GROUPING)) {
            if (LVar1 == LYS_OUTPUT) {
LAB_0012042b:
              tpdf_size = (int)*(ushort *)(parent_local->padding + 2);
              tpdf = *(lys_tpdf **)parent_local->hash;
              goto LAB_00120459;
            }
            if (LVar1 < (LYS_CONTAINER|LYS_OUTPUT)) {
              if (LVar1 == LYS_INPUT) goto LAB_0012042b;
              if (LVar1 < (LYS_CONTAINER|LYS_INPUT)) {
                if (LVar1 == LYS_RPC) goto LAB_001203f3;
                if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
                  if (LVar1 == LYS_NOTIF) {
                    tpdf_size = (int)*(ushort *)(parent_local->padding + 2);
                    tpdf = (lys_tpdf *)parent_local[1].name;
                  }
                  else {
                    if (LYS_NOTIF < LVar1) goto LAB_00120447;
                    if (LVar1 == LYS_CONTAINER) {
                      tpdf_size = (int)*(ushort *)(parent_local->padding + 2);
                      tpdf = (lys_tpdf *)parent_local[1].ref;
                    }
                    else {
                      if (LVar1 != LYS_LIST) goto LAB_00120447;
                      tpdf_size = (int)parent_local->padding[1];
                      tpdf = (lys_tpdf *)parent_local[1].ref;
                    }
                  }
                  goto LAB_00120459;
                }
              }
            }
          }
        }
LAB_00120447:
        parent_local = lys_parent(parent_local);
      }
    }
  }
  else {
    module_local = lyp_get_module(module,(char *)0x0,0,mod_name_local,0,0);
    if (module_local == (lys_module *)0x0) {
      return -1;
    }
  }
  for (i = 0; i < (int)(uint)module_local->tpdf_size; i = i + 1) {
    iVar2 = strcmp(module_local->tpdf[i].name,name);
    if (iVar2 == 0) {
      match = module_local->tpdf + i;
LAB_00120686:
      iVar2 = resolve_superior_type_check(&match->type);
      if (iVar2 != 0) {
        return 1;
      }
      if (ret != (lys_tpdf **)0x0) {
        *ret = match;
      }
      return 0;
    }
  }
  i = 0;
  do {
    if (((int)(uint)module_local->inc_size <= i) ||
       (module_local->inc[i].submodule == (lys_submodule *)0x0)) {
      return 1;
    }
    for (j = 0; j < (int)(uint)(module_local->inc[i].submodule)->tpdf_size; j = j + 1) {
      iVar2 = strcmp((module_local->inc[i].submodule)->tpdf[j].name,name);
      if (iVar2 == 0) {
        match = (module_local->inc[i].submodule)->tpdf + j;
        goto LAB_00120686;
      }
    }
    i = i + 1;
  } while( true );
}



int check_default(lys_type *type,char **value,lys_module *module,int tpdf)

{
  uint uVar1;
  long lVar2;
  lys_node_leaf *plVar3;
  int iVar4;
  char *pcVar5;
  lys_module *plVar6;
  lys_type *plVar7;
  long in_FS_OFFSET;
  int tpdf_local;
  lys_module *module_local;
  char **value_local;
  lys_type *type_local;
  int ret;
  int r;
  char *dflt;
  char *s;
  lys_tpdf *base_tpdf;
  ly_ctx *ctx;
  lyd_node_leaf_list node;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  base_tpdf = (lys_tpdf *)0x0;
  dflt = (char *)0x0;
  ret = 0;
  ctx = module->ctx;
  if (value == (char **)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("value",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0xd96,"check_default");
  }
  memset(&node,0,0x50);
  if (type->base == LY_TYPE_DER) {
    ret = 1;
    goto LAB_00120f5e;
  }
  if ((tpdf == 0) && ((module->field_0x40 & 0x80) == 0)) goto LAB_00120f5e;
  if ((tpdf != 0) && (((module->field_0x40 & 0x80) == 0 && (type->base == LY_TYPE_IDENT)))) {
    if (*value != (char *)0x0) {
      pcVar5 = strchr(*value,0x3a);
      if (pcVar5 == (char *)0x0) {
        pcVar5 = *value;
        plVar6 = lys_main_module(module);
        iVar4 = asprintf(&s,"%s:%s",plVar6->name,pcVar5);
        if (iVar4 == -1) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","check_default");
          ret = -1;
          goto LAB_00120f5e;
        }
        dflt = lydict_insert_zc(ctx,s);
      }
      else {
        dflt = transform_schema2json(module,*value);
      }
      lydict_remove(ctx,*value);
      *value = dflt;
      dflt = (char *)0x0;
    }
    goto LAB_00120f5e;
  }
  if ((type->base == LY_TYPE_LEAFREF) && (tpdf != 0)) goto LAB_00120f5e;
  dflt = lydict_insert(ctx,*value,0);
  module_local = module;
  if (dflt != (char *)0x0) {
    if (type->base == LY_TYPE_EMPTY) {
      ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"default",type->parent->name);
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "The \"empty\" data type cannot have a default value.");
      ret = -1;
      goto LAB_00120f5e;
    }
    goto LAB_00120b80;
  }
  for (base_tpdf = type->der; (base_tpdf->type).der != (lys_tpdf *)0x0;
      base_tpdf = (base_tpdf->type).der) {
    if (base_tpdf->dflt != (char *)0x0) {
      dflt = lydict_insert(ctx,base_tpdf->dflt,0);
      break;
    }
  }
  if (dflt == (char *)0x0) goto LAB_00120f5e;
  if (false) {
switchD_001209e2_caseD_0:
    ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
           ,0xe05);
    ret = -1;
    goto LAB_00120f5e;
  }
  switch(type->base) {
  default:
    goto switchD_001209e2_caseD_0;
  case LY_TYPE_BINARY:
    plVar3 = (lys_node_leaf *)(type->info).bits.bit;
    goto joined_r0x00120a8a;
  case LY_TYPE_BITS:
    uVar1 = (type->info).bits.count;
    goto joined_r0x00120a3f;
  case LY_TYPE_BOOL:
  case LY_TYPE_EMPTY:
  case LY_TYPE_INST:
  case LY_TYPE_LEAFREF:
    goto LAB_00120f5e;
  case LY_TYPE_DEC64:
    plVar3 = (lys_node_leaf *)(type->info).bits.bit;
    goto joined_r0x00120a8a;
  case LY_TYPE_ENUM:
    uVar1 = (type->info).bits.count;
joined_r0x00120a3f:
    if (uVar1 == 0) goto LAB_00120f5e;
    break;
  case LY_TYPE_IDENT:
    plVar6 = lys_main_module(((base_tpdf->type).parent)->module);
    if ((plVar6->field_0x40 & 0x80) != 0) goto LAB_00120f5e;
    module_local = base_tpdf->module;
    break;
  case LY_TYPE_STRING:
    if ((type->info).bits.bit == (lys_type_bit *)0x0) {
      plVar3 = (type->info).lref.target;
      goto joined_r0x00120a8a;
    }
    break;
  case LY_TYPE_UNION:
    break;
  case LY_TYPE_INT8:
  case LY_TYPE_UINT8:
  case LY_TYPE_INT16:
  case LY_TYPE_UINT16:
  case LY_TYPE_INT32:
  case LY_TYPE_UINT32:
  case LY_TYPE_INT64:
  case LY_TYPE_UINT64:
    plVar3 = (lys_node_leaf *)(type->info).bits.bit;
joined_r0x00120a8a:
    if (plVar3 == (lys_node_leaf *)0x0) goto LAB_00120f5e;
  }
LAB_00120b80:
  memset(&node,0,0x50);
  node.value_str = lydict_insert(ctx,dflt,0);
  node.value_type = type->base;
  if (tpdf == 0) {
    node.schema = (lys_node *)type->parent;
  }
  else {
    node.schema = (lys_node *)calloc(1,0xd0);
    if (node.schema == (lys_node *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","check_default");
      ret = -1;
      goto LAB_00120f5e;
    }
    iVar4 = asprintf((char **)node.schema,"typedef-%s-default",type->parent->name);
    if (iVar4 == -1) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","check_default");
      ret = -1;
      goto LAB_00120f5e;
    }
    (node.schema)->module = module_local;
    memcpy(&node.schema[1].ref,type,0x40);
  }
  if (type->base == LY_TYPE_LEAFREF) {
    if ((type->info).lref.target == (lys_node_leaf *)0x0) {
      ret = 1;
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "Default value \"%s\" cannot be checked in an unresolved leafref.",dflt);
    }
    else {
      ret = check_default(&((type->info).lref.target)->type,&dflt,module_local,0);
      if ((ret == 0) && (*value != (char *)0x0)) {
        lydict_remove(ctx,*value);
        *value = dflt;
        dflt = (char *)0x0;
      }
    }
  }
  else {
    plVar7 = lyp_parse_value(type,&node.value_str,(lyxml_elem *)0x0,&node,(lyd_attr *)0x0,
                             module_local,1,1,0);
    if (plVar7 == (lys_type *)0x0) {
      ret = 1;
      if ((base_tpdf != (lys_tpdf *)0x0) &&
         (((type->base == LY_TYPE_BITS && ((type->der->type).der != (lys_tpdf *)0x0)) ||
          ((type->base == LY_TYPE_ENUM && ((type->der->type).der != (lys_tpdf *)0x0)))))) {
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                "Invalid value \"%s\" of the default statement inherited to \"%s\" from \"%s\" base type."
                ,dflt,type->parent->name,base_tpdf->name);
      }
    }
    else if (node.value_str != dflt) {
      if (*value != dflt) {
                    // WARNING: Subroutine does not return
        __assert_fail("ly_strequal(dflt, *value, 1)",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                      ,0xe4b,"check_default");
      }
      lydict_remove(ctx,*value);
      *value = node.value_str;
      node.value_str = (char *)0x0;
    }
  }
LAB_00120f5e:
  lyd_free_value(node.value,node.value_type,node.value_flags,type,node.value_str,(lyd_val *)0x0,
                 (LY_DATA_TYPE *)0x0,(uint8_t *)0x0);
  lydict_remove(ctx,node.value_str);
  if ((tpdf != 0) && (node.schema != (lys_node *)0x0)) {
    free((node.schema)->name);
    free(node.schema);
  }
  lydict_remove(ctx,dflt);
  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return ret;
}



int check_key(lys_node_list *list,int index,char *name,int len)

{
  lys_node_leaf *elem;
  ly_ctx *ctx_00;
  bool bVar1;
  char *pcVar2;
  char *name_local;
  int len_local;
  int index_local;
  lys_node_list *list_local;
  int j;
  char *dup;
  lys_node_leaf *key;
  ly_ctx *ctx;
  
  elem = list->keys[index];
  dup = (char *)0x0;
  ctx_00 = list->module->ctx;
  if (elem == (lys_node_leaf *)0x0) {
    name_local = name;
    if (name[len] != '\0') {
      name_local = strdup(name);
      if (name_local == (char *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","check_key");
        return -1;
      }
      name_local[len] = '\0';
      dup = name_local;
    }
    ly_vlog(ctx_00,LYE_KEY_MISS,LY_VLOG_LYS,list,name_local);
    free(dup);
  }
  else {
    for (j = index + -1; -1 < j; j = j + -1) {
      if (elem == list->keys[j]) {
        ly_vlog(ctx_00,LYE_KEY_DUP,LY_VLOG_LYS,list,elem->name);
        return -1;
      }
    }
    if (elem->nodetype == LYS_LEAF) {
      if (((elem->type).base == LY_TYPE_EMPTY) && (((byte)elem->module->field_0x40 >> 1 & 7) < 2)) {
        ly_vlog(ctx_00,LYE_KEY_TYPE,LY_VLOG_LYS,list,elem->name);
      }
      else if (((elem->flags & 3) == 0) ||
              (((list->flags & 3) == 0 || (((elem->flags ^ list->flags) & 3) == 0)))) {
        if (elem->parent->nodetype == LYS_AUGMENT) {
          ly_vlog(ctx_00,LYE_KEY_MISS,LY_VLOG_LYS,elem,elem->name);
          ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Key inserted from augment.");
        }
        else {
          bVar1 = false;
          if (elem->when == (lys_when *)0x0) {
            if (elem->iffeature_size == '\0') {
              return 0;
            }
            bVar1 = true;
          }
          if (bVar1) {
            pcVar2 = "if-feature";
          }
          else {
            pcVar2 = "when";
          }
          ly_vlog(ctx_00,LYE_INCHILDSTMT,LY_VLOG_LYS,elem,pcVar2,&DAT_0020f268);
          if (bVar1) {
            pcVar2 = "if-feature";
          }
          else {
            pcVar2 = "when";
          }
          ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                  "Key definition cannot depend on a \"%s\" condition.",pcVar2);
        }
      }
      else {
        ly_vlog(ctx_00,LYE_KEY_CONFIG,LY_VLOG_LYS,list,elem->name);
      }
    }
    else {
      ly_vlog(ctx_00,LYE_KEY_NLEAF,LY_VLOG_LYS,list,elem->name);
    }
  }
  return -1;
}



int resolve_unique(lys_node *parent,char *uniq_str_path,uint8_t *trg_type)

{
  int iVar1;
  lys_node **pplVar2;
  char *pcVar3;
  char *pcVar4;
  long in_FS_OFFSET;
  uint8_t *trg_type_local;
  char *uniq_str_path_local;
  lys_node *parent_local;
  int rc;
  lys_node *leaf;
  ly_ctx *ctx;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  leaf = (lys_node *)0x0;
  ctx = parent->module->ctx;
  pplVar2 = lys_child(parent,LYS_LEAF);
  iVar1 = resolve_descendant_schema_nodeid(uniq_str_path,*pplVar2,4,1,&leaf);
  if ((iVar1 == 0) && (leaf != (lys_node *)0x0)) {
    if (leaf->nodetype == LYS_LEAF) {
      if ((parent->nodetype == LYS_EXT) ||
         (iVar1 = lyp_check_status(parent->flags,parent->module,parent->name,leaf->flags,
                                   leaf->module,leaf->name,leaf), iVar1 == 0)) {
        if (*trg_type == '\0') {
          if ((leaf->flags & 1) == 0) {
            *trg_type = '\x02';
          }
          else {
            *trg_type = '\x01';
          }
        }
        else if (((*trg_type == '\x01') && ((leaf->flags & 2) != 0)) ||
                ((*trg_type == '\x02' && ((leaf->flags & 1) != 0)))) {
          ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,parent,uniq_str_path,"unique");
          if (*trg_type == '\x01') {
            pcVar4 = "true";
          }
          else {
            pcVar4 = "false";
          }
          if (*trg_type == '\x01') {
            pcVar3 = "false";
          }
          else {
            pcVar3 = "true";
          }
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                  "Leaf \"%s\" referenced in unique statement is config %s, but previous referenced leaf is config %s."
                  ,uniq_str_path,pcVar3,pcVar4);
          rc = -1;
          goto LAB_00121767;
        }
        leaf->flags = leaf->flags | 0x100;
        rc = 0;
      }
      else {
        rc = -1;
      }
    }
    else {
      ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,parent,uniq_str_path,"unique");
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Target is not a leaf.");
      rc = -1;
    }
  }
  else if (iVar1 == 0) {
    ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,parent,uniq_str_path,"unique");
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Target leaf not found.");
    rc = 1;
  }
  else {
    ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,parent,uniq_str_path,"unique");
    if (iVar1 < 1) {
      if (iVar1 == -2) {
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Unique argument references list.");
      }
    }
    else {
      ly_vlog(ctx,LYE_INCHAR,LY_VLOG_PREV,(void *)0x0,
              (ulong)(uint)(int)uniq_str_path[(long)iVar1 + -1],uniq_str_path + (long)iVar1 + -1);
    }
    rc = -1;
  }
LAB_00121767:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return rc;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void unres_data_del(unres_data *unres,uint32_t i)

{
  uint32_t i_local;
  unres_data *unres_local;
  
  if (i + 1 < unres->count) {
    memmove(unres->node + i,unres->node + (i + 1),(ulong)((unres->count - i) - 1) * 8);
  }
  else if (i == 0) {
    free(unres->node);
    unres->node = (lyd_node **)0x0;
  }
  unres->count = unres->count - 1;
  return;
}



int resolve_data(lys_module *mod,char *name,int nam_len,lyd_node *start,unres_data *parents)

{
  bool bVar1;
  int iVar2;
  lyd_node **pplVar3;
  lys_module *plVar4;
  unres_data *parents_local;
  lyd_node *start_local;
  int nam_len_local;
  char *name_local;
  lys_module *mod_local;
  int flag;
  uint32_t i;
  lyd_node *node;
  
  if (parents->count == 0) {
    parents->count = 1;
    pplVar3 = (lyd_node **)malloc(8);
    parents->node = pplVar3;
    if (parents->node == (lyd_node **)0x0) {
      ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_data");
      return -1;
    }
    *parents->node = (lyd_node *)0x0;
  }
  i = 0;
  do {
    while( true ) {
      if (parents->count <= i) {
        return (uint)(parents->count == 0);
      }
      if ((parents->node[i] == (lyd_node *)0x0) ||
         ((parents->node[i]->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN)
         ) break;
      i = i + 1;
    }
    bVar1 = false;
    node = start;
    if (parents->node[i] != (lyd_node *)0x0) {
      node = parents->node[i]->child;
    }
    for (; node != (lyd_node *)0x0; node = node->next) {
      plVar4 = lyd_node_module(node);
      if (((mod == plVar4) && (iVar2 = strncmp(node->schema->name,name,(long)nam_len), iVar2 == 0))
         && (node->schema->name[nam_len] == '\0')) {
        if (bVar1) {
          parents->count = parents->count + 1;
          pplVar3 = (lyd_node **)ly_realloc(parents->node,(ulong)parents->count * 8);
          parents->node = pplVar3;
          if (parents->node == (lyd_node **)0x0) {
            ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_data");
            return 1;
          }
          parents->node[parents->count - 1] = node;
          i = i + 1;
        }
        else {
          parents->node[i] = node;
          bVar1 = true;
        }
      }
    }
    if (bVar1) {
      i = i + 1;
    }
    else {
      unres_data_del(parents,i);
    }
  } while( true );
}



int resolve_schema_leafref_valid_dep_flag
              (lys_node *op_node,lys_module *param_2,lys_node *first_node,int abs_path)

{
  lys_module *plVar1;
  lys_node *plVar2;
  int abs_path_local;
  lys_node *first_node_local;
  lys_module *local_mod_local;
  lys_node *op_node_local;
  lys_node *node;
  
  if (op_node == (lys_node *)0x0) {
    plVar1 = lys_node_module(first_node);
    if (param_2 != plVar1) {
      return 1;
    }
  }
  else {
    plVar2 = lys_parent(op_node);
    if (plVar2 == (lys_node *)0x0) {
      if (op_node != first_node) {
        return 1;
      }
    }
    else {
      node = first_node;
      if (abs_path != 0) {
        return 1;
      }
      for (; (node != (lys_node *)0x0 && (node != op_node)); node = lys_parent(node)) {
      }
      if (node == (lys_node *)0x0) {
        return 1;
      }
    }
  }
  return 0;
}



int resolve_schema_leafref_predicate
              (char *path,lys_node *context_node,lys_node *parent,ly_set *node_set)

{
  int iVar1;
  lys_module *plVar2;
  char *pcVar3;
  char *pcVar4;
  long in_FS_OFFSET;
  ly_set *node_set_local;
  lys_node *parent_local;
  lys_node *context_node_local;
  char *path_local;
  int pke_len;
  int sour_len;
  int sour_pref_len;
  int dest_len;
  int dest_pref_len;
  int has_predicate;
  int dest_parent_times;
  int pke_parsed;
  int parsed;
  int i;
  int rc;
  lys_node *src_node;
  lys_node *dst_node;
  char *path_key_expr;
  char *source;
  char *sour_pref;
  char *dest;
  char *dest_pref;
  lys_module *trg_mod;
  lys_node_augment *last_aug;
  ly_ctx *ctx;
  lys_node *tmp_parent;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  parsed = 0;
  ctx = context_node->module->ctx;
  path_local = path;
  do {
    i = parse_path_predicate
                  (path_local,&sour_pref,&sour_pref_len,&source,&sour_len,&path_key_expr,&pke_len,
                   &has_predicate);
    pcVar3 = sour_pref;
    iVar1 = sour_pref_len;
    if (i < 1) {
      ly_vlog(ctx,LYE_INCHAR,LY_VLOG_LYS,parent,(ulong)(uint)(int)path_local[-i],
              (long)path_local - (long)i);
      iVar1 = i - parsed;
      break;
    }
    parsed = parsed + i;
    path_local = path_local + i;
    if (sour_pref == (char *)0x0) {
      trg_mod = lys_node_module(parent);
    }
    else {
      plVar2 = lys_node_module(parent);
      trg_mod = lyp_get_module(plVar2,(char *)0x0,0,pcVar3,iVar1,0);
    }
    rc = lys_getnext_data(trg_mod,context_node,source,sour_len,LYS_LEAF|LYS_LEAFLIST,0x100,&src_node
                         );
    if (rc != 0) {
      ly_vlog(ctx,LYE_NORESOLV,LY_VLOG_LYS,parent,"leafref predicate",
              (long)path_local - (long)parsed);
      iVar1 = 0;
      break;
    }
    dest_parent_times = 0;
    pke_parsed = 0;
    i = parse_path_key_expr(path_key_expr,&dest_pref,&dest_pref_len,&dest,&dest_len,
                            &dest_parent_times);
    if (i < 1) {
      ly_vlog(ctx,LYE_INCHAR,LY_VLOG_LYS,parent,(ulong)(uint)(int)path_key_expr[-i],
              (long)path_key_expr - (long)i);
      iVar1 = -parsed;
      break;
    }
    pke_parsed = pke_parsed + i;
    dst_node = parent;
    for (i = 0; i < dest_parent_times; i = i + 1) {
      if (dst_node == (lys_node *)0x0) {
        ly_vlog(ctx,LYE_NORESOLV,LY_VLOG_LYS,parent,"leafref predicate",path_key_expr);
        iVar1 = 0;
        goto LAB_00122232;
      }
      if (((dst_node->parent != (lys_node *)0x0) && (dst_node->parent->nodetype == LYS_AUGMENT)) &&
         (dst_node->parent->prev == (lys_node *)0x0)) {
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_LYS,dst_node->parent,
                "Cannot resolve leafref predicate \"%s\" because it is in an unresolved augment.",
                path_key_expr);
        iVar1 = 0;
        goto LAB_00122232;
      }
      for (dst_node = lys_parent(dst_node);
          (dst_node != (lys_node *)0x0 && ((dst_node->nodetype & 0x4191) == LYS_UNKNOWN));
          dst_node = lys_parent(dst_node)) {
      }
    }
    while( true ) {
      pcVar3 = dest_pref;
      iVar1 = dest_pref_len;
      last_aug = (lys_node_augment *)0x0;
      if (dest_pref == (char *)0x0) {
        trg_mod = lys_node_module(parent);
      }
      else {
        plVar2 = lys_node_module(parent);
        trg_mod = lyp_get_module(plVar2,(char *)0x0,0,pcVar3,iVar1,0);
      }
      if ((trg_mod->field_0x40 & 0x80) != 0) goto LAB_00121fc5;
      if (dst_node == (lys_node *)0x0) goto LAB_00121fc5;
      while( true ) {
        last_aug = lys_getnext_target_aug(last_aug,trg_mod,dst_node);
LAB_00121fc5:
        tmp_parent = dst_node;
        if (last_aug != (lys_node_augment *)0x0) {
          tmp_parent = (lys_node *)last_aug;
        }
        rc = lys_getnext_data(trg_mod,tmp_parent,dest,dest_len,LYS_CONTAINER|LYS_LEAF|LYS_LIST,0x100
                              ,&dst_node);
        if (rc == 0) break;
        if (last_aug == (lys_node_augment *)0x0) {
          ly_vlog(ctx,LYE_NORESOLV,LY_VLOG_LYS,parent,"leafref predicate",path_key_expr);
          iVar1 = 0;
          goto LAB_00122232;
        }
        dst_node = last_aug->target;
      }
      if (pke_parsed == pke_len) break;
      i = parse_path_key_expr(path_key_expr + pke_parsed,&dest_pref,&dest_pref_len,&dest,&dest_len,
                              &dest_parent_times);
      if (i < 1) {
        ly_vlog(ctx,LYE_INCHAR,LY_VLOG_LYS,parent,
                (ulong)(uint)(int)path_key_expr[(long)-i + (long)pke_parsed],
                path_key_expr + ((long)pke_parsed - (long)i));
        iVar1 = -parsed;
        goto LAB_00122232;
      }
      pke_parsed = pke_parsed + i;
    }
    if (dst_node->nodetype != src_node->nodetype) {
      ly_vlog(ctx,LYE_NORESOLV,LY_VLOG_LYS,parent,"leafref predicate",
              (long)path_local - (long)parsed);
      pcVar3 = strnodetype(dst_node->nodetype);
      pcVar4 = strnodetype(src_node->nodetype);
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Destination node is not a %s, but a %s.",pcVar4
              ,pcVar3);
      iVar1 = -parsed;
      break;
    }
    ly_set_add(node_set,dst_node,0);
    ly_set_add(node_set,src_node,0);
    iVar1 = parsed;
  } while (has_predicate != 0);
LAB_00122232:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int check_leafref_features(lys_type *type)

{
  uint uVar1;
  long in_FS_OFFSET;
  lys_type *type_local;
  uint size;
  uint i;
  uint j;
  int ret;
  uint x;
  lys_node *iter;
  ly_ctx *ctx;
  ly_set *src_parents;
  ly_set *trg_parents;
  ly_set *features;
  lys_node_augment *aug;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = type->parent->module->ctx;
  ret = 0;
  if (type->parent == (lys_tpdf *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("type->parent",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0xff7,"check_leafref_features");
  }
  src_parents = ly_set_new();
  trg_parents = ly_set_new();
  features = ly_set_new();
  for (iter = (lys_node *)type->parent; iter != (lys_node *)0x0; iter = lys_parent(iter)) {
    if ((iter->nodetype & 0x600) == LYS_UNKNOWN) {
      if ((iter->parent != (lys_node *)0x0) && (iter->parent->nodetype == LYS_AUGMENT)) {
        aug = (lys_node_augment *)iter->parent;
        if ((((((lys_node *)aug)->module->field_0x40 & 0x80) != 0) &&
            ((((lys_node *)aug)->flags & 1) != 0)) || (((lys_node *)aug)->prev == (lys_node *)0x0))
        {
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_LYS,aug,
                  "Cannot check leafref \"%s\" if-feature consistency because of an unresolved augment."
                  ,(type->info).bits.bit);
          ret = 1;
          goto LAB_001227d4;
        }
        ly_set_add(src_parents,aug,1);
      }
      ly_set_add(src_parents,iter,1);
    }
  }
  iter = (lys_node *)(type->info).lref.target;
  do {
    if (iter == (lys_node *)0x0) {
      for (i = 0; i < src_parents->number; i = i + 1) {
        iter = (src_parents->set).s[i];
        if (iter->iffeature_size != '\0') {
          for (j = 0; j < iter->iffeature_size; j = j + 1) {
            resolve_iffeature_getsizes(iter->iffeature + j,(uint *)0x0,&size);
            for (; size != 0; size = size - 1) {
              if (iter->iffeature[j].features[size - 1] == (lys_feature *)0x0) {
                ret = 1;
                goto LAB_001227d4;
              }
              ly_set_add(features,iter->iffeature[j].features[size - 1],0);
            }
          }
        }
      }
      x = features->number;
      for (i = 0; i < trg_parents->number; i = i + 1) {
        iter = (trg_parents->set).s[i];
        if (iter->iffeature_size != '\0') {
          for (j = 0; j < iter->iffeature_size; j = j + 1) {
            resolve_iffeature_getsizes(iter->iffeature + j,(uint *)0x0,&size);
            for (; size != 0; size = size - 1) {
              if (iter->iffeature[j].features[size - 1] == (lys_feature *)0x0) {
                ret = 1;
                goto LAB_001227d4;
              }
              uVar1 = ly_set_add(features,iter->iffeature[j].features[size - 1],0);
              if (x <= uVar1) {
                ly_vlog(ctx,LYE_NORESOLV,LY_VLOG_LYS,type->parent,"leafref",(type->info).bits.bit);
                ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                        "Leafref is not conditional based on \"%s\" feature as its target.",
                        iter->iffeature[j].features[size - 1]->name);
                ret = -1;
                goto LAB_001227d4;
              }
            }
          }
        }
      }
LAB_001227d4:
      ly_set_free(features);
      ly_set_free(src_parents);
      ly_set_free(trg_parents);
      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
        return ret;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    if ((iter->nodetype & 0x600) == LYS_UNKNOWN) {
      if (((iter->parent != (lys_node *)0x0) && (iter->parent->nodetype == LYS_AUGMENT)) &&
         (((aug = (lys_node_augment *)iter->parent,
           (((lys_node *)aug)->module->field_0x40 & 0x80) != 0 &&
           ((((lys_node *)aug)->flags & 1) != 0)) || (((lys_node *)aug)->prev == (lys_node *)0x0))))
      {
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_LYS,aug,
                "Cannot check leafref \"%s\" if-feature consistency because of an unresolved augment."
                ,(type->info).bits.bit);
        ret = 1;
        goto LAB_001227d4;
      }
      ly_set_add(trg_parents,iter,1);
    }
    iter = lys_parent(iter);
  } while( true );
}



int resolve_schema_leafref(lys_type *type,lys_node *parent,unres_schema *unres)

{
  int iVar1;
  lys_node *plVar2;
  lys_module *plVar3;
  lys_module *plVar4;
  long in_FS_OFFSET;
  bool bVar5;
  unres_schema *unres_local;
  lys_node *parent_local;
  lys_type *type_local;
  int pref_len;
  int nam_len;
  int parent_times;
  int has_predicate;
  int i;
  int first_iter;
  char *prefix;
  char *name;
  lys_node *node;
  lys_node *op_node;
  lys_node *tmp_parent;
  lys_node_augment *last_aug;
  char *id;
  ly_ctx *ctx;
  ly_set *node_set;
  lys_module *cur_module;
  lys_module *tmp_mod;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  op_node = (lys_node *)0x0;
  ctx = parent->module->ctx;
  node = parent;
  while (plVar2 = lys_parent(node), plVar2 != (lys_node *)0x0) {
    node = lys_parent(node);
  }
  if ((node->parent == (lys_node *)0x0) || (node->parent->nodetype != LYS_AUGMENT)) {
    first_iter = 1;
    parent_times = 0;
    id = (type->info).lref.path;
    node_set = ly_set_new();
    if (node_set != (ly_set *)0x0) {
      for (op_node = lys_parent(parent);
          (op_node != (lys_node *)0x0 && ((op_node->nodetype & 0x4180) == LYS_UNKNOWN));
          op_node = lys_parent(op_node)) {
      }
      cur_module = lys_node_module(parent);
LAB_001229a0:
      i = parse_path_arg(cur_module,id,&prefix,&pref_len,&name,&nam_len,&parent_times,&has_predicate
                        );
      if (i < 1) {
        ly_vlog(ctx,LYE_INCHAR,LY_VLOG_LYS,parent,(ulong)(uint)(int)id[-i],id + -i);
        ly_set_free(node_set);
        iVar1 = -1;
        goto LAB_0012318b;
      }
      id = id + i;
      plVar3 = cur_module;
      if (prefix != (char *)0x0) {
        plVar3 = lyp_get_module(cur_module,(char *)0x0,0,prefix,pref_len,0);
      }
      tmp_mod = plVar3;
      if (plVar3 == (lys_module *)0x0) {
        ly_vlog(ctx,LYE_NORESOLV,LY_VLOG_LYS,parent,"leafref",(type->info).bits.bit);
        ly_set_free(node_set);
        iVar1 = 1;
        goto LAB_0012318b;
      }
      last_aug = (lys_node_augment *)0x0;
      if (first_iter != 0) {
        if (parent_times == -1) {
          node = (lys_node *)0x0;
        }
        else {
          if (parent_times < 1) {
            ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                   ,0x10b2);
            ly_set_free(node_set);
            iVar1 = -1;
            goto LAB_0012318b;
          }
          node = parent;
          for (i = 0; i < parent_times; i = i + 1) {
            for (node = lys_parent(node);
                (node != (lys_node *)0x0 && ((node->nodetype & 0x4191) == LYS_UNKNOWN));
                node = lys_parent(node)) {
            }
            if (node == (lys_node *)0x0) {
              if (i != parent_times + -1) {
                ly_vlog(ctx,LYE_NORESOLV,LY_VLOG_LYS,parent,"leafref",(type->info).bits.bit);
                ly_set_free(node_set);
                iVar1 = 1;
                goto LAB_0012318b;
              }
              break;
            }
          }
        }
      }
      if ((tmp_mod->field_0x40 & 0x80) != 0) goto LAB_00122c54;
      if (node == (lys_node *)0x0) goto LAB_00122c54;
      do {
        last_aug = lys_getnext_target_aug(last_aug,tmp_mod,node);
LAB_00122c54:
        tmp_parent = node;
        if (last_aug != (lys_node_augment *)0x0) {
          tmp_parent = (lys_node *)last_aug;
        }
        node = (lys_node *)0x0;
        do {
          node = lys_getnext(node,tmp_parent,tmp_mod,0x100);
          if (node == (lys_node *)0x0) break;
          plVar3 = lys_node_module(node);
          plVar4 = lys_main_module(tmp_mod);
        } while (((plVar3 != plVar4) || (iVar1 = strncmp(node->name,name,(long)nam_len), iVar1 != 0)
                 ) || (node->name[nam_len] != '\0'));
        if (node != (lys_node *)0x0) goto LAB_00122d6c;
        if (last_aug == (lys_node_augment *)0x0) {
          ly_vlog(ctx,LYE_NORESOLV,LY_VLOG_LYS,parent,"leafref",(type->info).bits.bit);
          ly_set_free(node_set);
          iVar1 = 1;
          goto LAB_0012318b;
        }
        node = last_aug->target;
      } while( true );
    }
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_schema_leafref");
    iVar1 = -1;
  }
  else {
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_LYS,node->parent,
            "Cannot resolve leafref \"%s\" because it is in an unresolved augment.",
            (type->info).bits.bit);
    iVar1 = 1;
  }
  goto LAB_0012318b;
LAB_00122d6c:
  plVar2 = parent;
  if (first_iter != 0) {
    while (tmp_parent = plVar2, plVar2 = lys_parent(tmp_parent), plVar2 != (lys_node *)0x0) {
      plVar2 = lys_parent(tmp_parent);
    }
    bVar5 = parent_times == -1;
    plVar3 = lys_node_module(tmp_parent);
    iVar1 = resolve_schema_leafref_valid_dep_flag(op_node,plVar3,node,(uint)bVar5);
    if (iVar1 != 0) {
      parent->flags = parent->flags | 0x800;
    }
    first_iter = 0;
  }
  if (has_predicate != 0) {
    if (node->nodetype != LYS_LIST) {
      ly_vlog(ctx,LYE_NORESOLV,LY_VLOG_LYS,parent,"leafref",(type->info).bits.bit);
      ly_set_free(node_set);
      iVar1 = -1;
      goto LAB_0012318b;
    }
    i = resolve_schema_leafref_predicate(id,node,parent,node_set);
    if (i == 0) {
      ly_set_free(node_set);
      iVar1 = 1;
      goto LAB_0012318b;
    }
    if (i < 0) {
      ly_set_free(node_set);
      iVar1 = -1;
      goto LAB_0012318b;
    }
    id = id + i;
    has_predicate = 0;
  }
  if (*id == '\0') goto code_r0x00122ed3;
  goto LAB_001229a0;
code_r0x00122ed3:
  if ((node->nodetype == LYS_LEAF) || (node->nodetype == LYS_LEAFLIST)) {
    iVar1 = lyp_check_status(parent->flags,parent->module,parent->name,node->flags,node->module,
                             node->name,node);
    if (iVar1 == 0) {
      (type->info).lref.target = (lys_node_leaf *)node;
      ly_set_add(node_set,node,0);
      node = parent;
      while (plVar2 = lys_parent(node), plVar2 != (lys_node *)0x0) {
        node = lys_parent(node);
      }
      plVar3 = lys_node_module(node);
      if ((plVar3->field_0x40 & 0x80) != 0) {
        for (i = 0; (uint)i < node_set->number; i = i + 1) {
          for (node = (node_set->set).s[i]; node != (lys_node *)0x0; node = lys_parent(node)) {
            plVar3 = lys_node_module(node);
            if ((plVar3->field_0x40 & 0x80) == 0) {
              plVar3 = lys_node_module(node);
              plVar3->field_0x40 = plVar3->field_0x40 | 0x80;
              plVar3 = lys_node_module(node);
              iVar1 = unres_schema_add_node
                                (plVar3,unres,(void *)0x0,UNRES_MOD_IMPLEMENT,(lys_node *)0x0);
              if (iVar1 == -1) {
                ly_set_free(node_set);
                iVar1 = -1;
                goto LAB_0012318b;
              }
            }
          }
          iVar1 = lys_leaf_add_leafref_target
                            ((lys_node_leaf *)(node_set->set).s[i],(lys_node *)type->parent);
          if (iVar1 != 0) {
            ly_set_free(node_set);
            iVar1 = -1;
            goto LAB_0012318b;
          }
        }
      }
      ly_set_free(node_set);
      iVar1 = check_leafref_features(type);
    }
    else {
      ly_set_free(node_set);
      iVar1 = -1;
    }
  }
  else {
    ly_vlog(ctx,LYE_NORESOLV,LY_VLOG_LYS,parent,"leafref",(type->info).bits.bit);
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
            "Leafref target \"%s\" is not a leaf nor a leaf-list.",(type->info).bits.bit);
    ly_set_free(node_set);
    iVar1 = -1;
  }
LAB_0012318b:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int valequal(lys_node *node,char *noncan_val,int noncan_val_len,char *can_val)

{
  long lVar1;
  int iVar2;
  lys_type *plVar3;
  long in_FS_OFFSET;
  char *can_val_local;
  int noncan_val_len_local;
  char *noncan_val_local;
  lys_node *node_local;
  int ret;
  lys_node_leaf *sleaf;
  lyd_node_leaf_list leaf;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  memset(&leaf,0,0x50);
  leaf.value_str = lydict_insert(node->module->ctx,noncan_val,(long)noncan_val_len);
  sleaf = (lys_node_leaf *)node;
  do {
    leaf.value_type = (sleaf->type).base;
    leaf.schema = node;
    if (leaf.value_type != LY_TYPE_LEAFREF) {
      plVar3 = lyp_parse_value(&sleaf->type,&leaf.value_str,(lyxml_elem *)0x0,&leaf,(lyd_attr *)0x0,
                               (lys_module *)0x0,0,0,0);
      if (plVar3 == (lys_type *)0x0) {
        ret = -1;
      }
      else {
        iVar2 = strcmp(leaf.value_str,can_val);
        if (iVar2 == 0) {
          ret = 1;
        }
        else {
          ret = 0;
        }
      }
LAB_00123313:
      lydict_remove(node->module->ctx,leaf.value_str);
      if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return ret;
    }
    if ((sleaf->type).info.lref.target == (lys_node_leaf *)0x0) {
      ly_log(node->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
             ,0x1145);
      ret = -1;
      goto LAB_00123313;
    }
    sleaf = (sleaf->type).info.lref.target;
  } while( true );
}



int resolve_instid_predicate(lys_module *prev_mod,char *pred,lyd_node **node,int cur_idx)

{
  char *pcVar1;
  lys_node *plVar2;
  long lVar3;
  int iVar4;
  char *pcVar5;
  ushort **ppuVar6;
  long in_FS_OFFSET;
  int cur_idx_local;
  lyd_node **node_local;
  char *pred_local;
  lys_module *prev_mod_local;
  int mod_len;
  int nam_len;
  int val_len;
  int has_predicate;
  int i;
  int parsed;
  char *model;
  char *name;
  char *value;
  lyd_node_leaf_list *key;
  lys_node_leaf **list_keys;
  lys_node_list *slist;
  ly_ctx *ctx;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  list_keys = (lys_node_leaf **)0x0;
  slist = (lys_node_list *)0x0;
  ctx = prev_mod->ctx;
  if (((pred == (char *)0x0) || (node == (lyd_node **)0x0)) || (*node == (lyd_node *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("pred && node && *node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x1175,"resolve_instid_predicate");
  }
  parsed = 0;
  do {
    i = parse_predicate(pred + parsed,&model,&mod_len,&name,&nam_len,&value,&val_len,&has_predicate)
    ;
    if (i < 1) {
      iVar4 = i - parsed;
      goto LAB_00123bd7;
    }
    parsed = parsed + i;
    if (*node != (lyd_node *)0x0) {
      if (*name == '.') {
        if ((*node)->schema->nodetype != LYS_LEAFLIST) {
          pcVar1 = (*node)->schema->name;
          pcVar5 = strnodetype((*node)->schema->nodetype);
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                  "Instance identifier expects leaf-list, but have %s \"%s\".",pcVar5,pcVar1);
          parsed = -1;
          goto LAB_00123bc8;
        }
        iVar4 = valequal((*node)->schema,value,val_len,(char *)(*node)->ht);
        if (iVar4 == 0) {
          *node = (lyd_node *)0x0;
          goto LAB_00123bc8;
        }
      }
      else {
        ppuVar6 = __ctype_b_loc();
        if (((*ppuVar6)[*name] & 0x800) == 0) {
          if ((*node)->schema->nodetype != LYS_LIST) {
            pcVar1 = (*node)->schema->name;
            pcVar5 = strnodetype((*node)->schema->nodetype);
            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "Instance identifier expects list, but have %s \"%s\".",pcVar5,pcVar1);
            parsed = -1;
            goto LAB_00123bc8;
          }
          slist = (lys_node_list *)(*node)->schema;
          if (list_keys == (lys_node_leaf **)0x0) {
            list_keys = (lys_node_leaf **)malloc((ulong)slist->keys_size << 3);
            if (list_keys == (lys_node_leaf **)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "resolve_instid_predicate");
              iVar4 = -1;
              goto LAB_00123bd7;
            }
            for (i = 0; i < (int)(uint)slist->keys_size; i = i + 1) {
              list_keys[i] = slist->keys[i];
            }
          }
          i = 0;
          while ((i < (int)(uint)slist->keys_size &&
                 (((list_keys[i] == (lys_node_leaf *)0x0 ||
                   (iVar4 = strncmp(list_keys[i]->name,name,(long)nam_len), iVar4 != 0)) ||
                  (list_keys[i]->name[nam_len] != '\0'))))) {
            i = i + 1;
          }
          if (i == (uint)slist->keys_size) {
            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "Instance identifier expects list with the key \"%.*s\", but list \"%s\" does not define it."
                    ,(ulong)(uint)nam_len,name,slist->name);
            parsed = -1;
            goto LAB_00123bc8;
          }
          if (model == (char *)0x0) {
            if (prev_mod != list_keys[i]->module) {
              ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                      "Instance identifier expects key \"%s\" from module \"%s\", not \"%s\".",
                      list_keys[i]->name,prev_mod->name,list_keys[i]->module->name);
              parsed = -1;
              goto LAB_00123bc8;
            }
          }
          else {
            iVar4 = strncmp(list_keys[i]->module->name,model,(long)mod_len);
            if ((iVar4 != 0) || (list_keys[i]->module->name[mod_len] != '\0')) {
              ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                      "Instance identifier expects key \"%s\" from module \"%.*s\", not \"%s\".",
                      list_keys[i]->name,model,(ulong)(uint)mod_len,list_keys[i]->module->name);
              parsed = -1;
              goto LAB_00123bc8;
            }
          }
          for (key = (lyd_node_leaf_list *)(*node)->child;
              (key != (lyd_node_leaf_list *)0x0 && ((lys_node_leaf *)key->schema != list_keys[i]));
              key = (lyd_node_leaf_list *)key->next) {
          }
          if (key == (lyd_node_leaf_list *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                   ,0x11e5);
            parsed = -1;
            goto LAB_00123bc8;
          }
          iVar4 = valequal(key->schema,value,val_len,key->value_str);
          if (iVar4 == 0) {
            *node = (lyd_node *)0x0;
          }
          else {
            list_keys[i] = (lys_node_leaf *)0x0;
          }
        }
        else {
          if (value != (char *)0x0) {
                    // WARNING: Subroutine does not return
            __assert_fail("!value",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                          ,0x1194,"resolve_instid_predicate");
          }
          if ((*node)->schema->nodetype != LYS_LIST) {
            pcVar1 = (*node)->schema->name;
            pcVar5 = strnodetype((*node)->schema->nodetype);
            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "Instance identifier expects list, but have %s \"%s\".",pcVar5,pcVar1);
            parsed = -1;
            goto LAB_00123bc8;
          }
          plVar2 = (*node)->schema;
          lVar3._0_2_ = plVar2[1].flags;
          lVar3._2_1_ = plVar2[1].ext_size;
          lVar3._3_1_ = plVar2[1].iffeature_size;
          lVar3._4_1_ = plVar2[1].padding[0];
          lVar3._5_1_ = plVar2[1].padding[1];
          lVar3._6_1_ = plVar2[1].padding[2];
          lVar3._7_1_ = plVar2[1].padding[3];
          if (lVar3 != 0) {
            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "Instance identifier expects list without keys, but have list \"%s\".",
                    (*node)->schema->name);
            parsed = -1;
            goto LAB_00123bc8;
          }
          iVar4 = atoi(name);
          if (cur_idx != iVar4) {
            *node = (lyd_node *)0x0;
            goto LAB_00123bc8;
          }
        }
      }
    }
  } while (has_predicate != 0);
  if ((*node != (lyd_node *)0x0) && (list_keys != (lys_node_leaf **)0x0)) {
    for (i = 0; i < (int)(uint)slist->keys_size; i = i + 1) {
      if (list_keys[i] != (lys_node_leaf *)0x0) {
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                "Instance identifier is missing list key \"%s\".",list_keys[i]->name);
        parsed = -1;
        break;
      }
    }
  }
LAB_00123bc8:
  free(list_keys);
  iVar4 = parsed;
LAB_00123bd7:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int check_xpath(lys_node *node,int check_place)

{
  long lVar1;
  lys_node *plVar2;
  int iVar3;
  long in_FS_OFFSET;
  int check_place_local;
  lys_node *node_local;
  int_log_opts prev_ilo;
  lys_node *parent;
  lyxp_set set;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  plVar2 = node;
  if (check_place != 0) {
    while (parent = plVar2, parent != (lys_node *)0x0) {
      if (parent->nodetype == LYS_GROUPING) {
        iVar3 = 0;
        goto LAB_00123cfd;
      }
      if (parent->nodetype == LYS_AUGMENT) {
        if (parent->prev == (lys_node *)0x0) {
          iVar3 = 1;
          goto LAB_00123cfd;
        }
        plVar2 = parent->prev;
      }
      else {
        plVar2 = parent->parent;
      }
    }
  }
  memset(&set,0,0x40);
  ly_ilo_change((ly_ctx *)0x0,ILO_ERR2WRN,&prev_ilo,(ly_err_item **)0x0);
  lyxp_node_atomize(node,&set,1);
  ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
  if (set.val.nodes != (lyxp_set_node *)0x0) {
    free(set.val.nodes);
  }
  iVar3 = 0;
LAB_00123cfd:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int check_leafref_config(lys_node_leaf *leaf,lys_type *type)

{
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  lys_type *type_local;
  lys_node_leaf *leaf_local;
  uint i;
  
  if (type->base == LY_TYPE_LEAFREF) {
    if (((((leaf->flags & 1) != 0) && ((type->info).lref.target != (lys_node_leaf *)0x0)) &&
        ((type->info).lref.req != -1)) && ((((type->info).lref.target)->flags & 2) != 0)) {
      pcVar2 = strnodetype(((type->info).lref.target)->nodetype);
      pcVar3 = strnodetype(leaf->nodetype);
      ly_vlog(leaf->module->ctx,LYE_SPEC,LY_VLOG_LYS,leaf,
              "The leafref %s is config but refers to a non-config %s.",pcVar3,pcVar2);
      return -1;
    }
  }
  else if (type->base == LY_TYPE_UNION) {
    for (i = 0; i < (type->info).bits.count; i = i + 1) {
      iVar1 = check_leafref_config(leaf,(lys_type *)((ulong)i * 0x40 + (long)(type->info).bits.bit))
      ;
      if (iVar1 != 0) {
        return -1;
      }
    }
  }
  return 0;
}



int inherit_config_flag(lys_node *node,int flags,int clear)

{
  ly_ctx *ctx_00;
  int iVar1;
  int clear_local;
  int flags_local;
  lys_node *node_local;
  ly_ctx *ctx;
  lys_node_leaf *leaf;
  
  if (node != (lys_node *)0x0) {
    if ((flags & 0xfffffffcU) != 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("!(flags ^ (flags & LYS_CONFIG_MASK))",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                    ,0x125b,"inherit_config_flag");
    }
    ctx_00 = node->module->ctx;
    for (node_local = node; node_local != (lys_node *)0x0; node_local = node_local->next) {
      if (clear == 0) {
        if ((node_local->flags & 4) == 0) {
          if (((((node_local->nodetype & 0x1800) == LYS_UNKNOWN) &&
               (node_local->flags = (ushort)flags | node_local->flags & 0xfffc,
               node_local->nodetype == LYS_LIST)) && ((node_local->flags & 1) != 0)) &&
             (node_local->padding[2] == '\0')) {
            ly_vlog(ctx_00,LYE_MISSCHILDSTMT,LY_VLOG_LYS,node_local,&DAT_0020f7c6,&DAT_0020f7c1);
            return -1;
          }
          goto LAB_00124014;
        }
        if (((flags & 2U) != 0) && ((node_local->flags & 1) != 0)) {
          ly_vlog(ctx_00,LYE_INARG,LY_VLOG_LYS,node_local,&DAT_0020f2fe,"config");
          ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                  "State nodes cannot have configuration nodes as children.");
          return -1;
        }
      }
      else {
        node_local->flags = node_local->flags & 0xfffc;
        node_local->flags = node_local->flags & 0xfffb;
LAB_00124014:
        if ((node_local->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
          iVar1 = inherit_config_flag(node_local->child,flags,clear);
          if (iVar1 != 0) {
            return -1;
          }
        }
        else if (((node_local->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) &&
                (iVar1 = check_leafref_config
                                   ((lys_node_leaf *)node_local,(lys_type *)&node_local[1].ref),
                iVar1 != 0)) {
          return -1;
        }
      }
    }
  }
  return 0;
}



int resolve_augment(lys_node_augment *aug,lys_node *uses,unres_schema *unres)

{
  int iVar1;
  lys_module *plVar2;
  lys_module *plVar3;
  char *pcVar4;
  char *pcVar5;
  lys_node *plVar6;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  lys_node *uses_local;
  lys_node_augment *aug_local;
  int rc;
  ly_set *set;
  lys_node *sub;
  lys_node *next;
  lys_module *mod;
  ly_ctx *ctx;
  lys_node_case *c;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (aug == (lys_node_augment *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("aug",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x1299,"resolve_augment");
  }
  mod = lys_main_module(aug->module);
  ctx = mod->ctx;
  aug->flags = aug->flags | 1;
  if (aug->target == (lys_node *)0x0) {
    if (uses == (lys_node *)0x0) {
      plVar2 = lys_node_module((lys_node *)aug);
    }
    else {
      plVar2 = (lys_module *)0x0;
    }
    iVar1 = resolve_schema_nodeid(aug->target_name,uses,plVar2,&set,0,0);
    if (iVar1 == -1) {
      ly_vlog(ctx,LYE_PATH,LY_VLOG_LYS,aug);
      iVar1 = -1;
      goto LAB_0012490a;
    }
    if (set == (ly_set *)0x0) {
      ly_vlog(ctx,LYE_INRESOLV,LY_VLOG_LYS,aug,"augment",aug->target_name);
      iVar1 = 1;
      goto LAB_0012490a;
    }
    aug->target = *(set->set).s;
    ly_set_free(set);
  }
  if (((mod->field_0x40 & 0x80) != 0) &&
     (plVar2 = lys_node_module(aug->target), (plVar2->field_0x40 & 0x80) == 0)) {
    plVar2 = lys_node_module(aug->target);
    plVar2->field_0x40 = plVar2->field_0x40 | 0x80;
    plVar2 = lys_node_module(aug->target);
    iVar1 = unres_schema_add_node(plVar2,unres,(void *)0x0,UNRES_MOD_IMPLEMENT,(lys_node *)0x0);
    if (iVar1 == -1) {
      iVar1 = -1;
      goto LAB_0012490a;
    }
  }
  if (aug->parent == (lys_node *)0x0) {
    plVar2 = lys_node_module((lys_node *)aug);
    plVar3 = lys_node_module(aug->target);
    if ((plVar2 != plVar3) && (iVar1 = lyp_check_mandatory_augment(aug,aug->target), iVar1 != 0))
    goto LAB_0012490a;
  }
  if ((aug->target->nodetype & (LYS_CONTAINER|LYS_LIST)) == LYS_UNKNOWN) {
    if ((aug->target->nodetype & 0x6c0) == LYS_UNKNOWN) {
      if (aug->target->nodetype != LYS_CHOICE) {
        ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,aug,aug->target_name,"target-node");
        pcVar5 = strnodetype(aug->target->nodetype);
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Invalid augment target node type \"%s\".",
                pcVar5);
        iVar1 = -1;
        goto LAB_0012490a;
      }
      for (sub = aug->child; sub != (lys_node *)0x0; sub = sub->next) {
        if ((sub->nodetype & 0x807d) == LYS_UNKNOWN) {
          pcVar5 = strnodetype(sub->nodetype);
          ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,aug,pcVar5,"augment");
          pcVar5 = strnodetype(sub->nodetype);
          pcVar4 = strnodetype(aug->target->nodetype);
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Cannot augment \"%s\" with a \"%s\".",
                  pcVar4,pcVar5);
          iVar1 = -1;
          goto LAB_0012490a;
        }
      }
    }
    else {
      for (sub = aug->child; sub != (lys_node *)0x0; sub = sub->next) {
        if ((sub->nodetype & 0x903f) == LYS_UNKNOWN) {
          pcVar5 = strnodetype(sub->nodetype);
          ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,aug,pcVar5,"augment");
          pcVar5 = strnodetype(sub->nodetype);
          pcVar4 = strnodetype(aug->target->nodetype);
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Cannot augment \"%s\" with a \"%s\".",
                  pcVar4,pcVar5);
          iVar1 = -1;
          goto LAB_0012490a;
        }
      }
    }
  }
  else {
    for (sub = aug->child; sub != (lys_node *)0x0; sub = sub->next) {
      if ((sub->nodetype & 0xd0bf) == LYS_UNKNOWN) {
        pcVar5 = strnodetype(sub->nodetype);
        ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,aug,pcVar5,"augment");
        pcVar5 = strnodetype(sub->nodetype);
        pcVar4 = strnodetype(aug->target->nodetype);
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Cannot augment \"%s\" with a \"%s\".",pcVar4,
                pcVar5);
        iVar1 = -1;
        goto LAB_0012490a;
      }
    }
  }
  for (sub = aug->child; sub != (lys_node *)0x0; sub = sub->next) {
    iVar1 = lys_check_id(sub,aug->target,(lys_module *)0x0);
    if (iVar1 != 0) {
      iVar1 = -1;
      goto LAB_0012490a;
    }
  }
  if (aug->target->nodetype == LYS_CHOICE) {
    sub = aug->child;
    while (sub != (lys_node *)0x0) {
      next = sub->next;
      if (sub->nodetype != LYS_CASE) {
        c = (lys_node_case *)calloc(1,0x70);
        if (c == (lys_node_case *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_augment");
          iVar1 = 1;
          goto LAB_0012490a;
        }
        pcVar5 = lydict_insert(ctx,sub->name,0);
        c->name = pcVar5;
        c->flags = sub->flags & 3 | 0x40;
        c->module = sub->module;
        c->nodetype = LYS_CASE;
        c->parent = sub->parent;
        plVar6 = (lys_node *)c;
        if (sub != sub->prev) {
          plVar6 = sub->prev;
        }
        c->prev = plVar6;
        if (c->prev->next == (lys_node *)0x0) {
          c->parent->child = (lys_node *)c;
        }
        else {
          c->prev->next = (lys_node *)c;
        }
        c->next = sub->next;
        if (c->next == (lys_node *)0x0) {
          c->parent->child->prev = (lys_node *)c;
        }
        else {
          c->next->prev = (lys_node *)c;
        }
        c->child = sub;
        sub->prev = sub;
        sub->next = (lys_node *)0x0;
        sub->parent = (lys_node *)c;
      }
      sub = next;
    }
  }
  if (aug->child == (lys_node *)0x0) {
    ly_log(ctx,LY_LLWRN,LY_SUCCESS,"Augment \"%s\" without children.",aug->target_name);
    aug->flags = aug->flags & 0xfffe;
  }
  else if (((aug->parent != (lys_node *)0x0) || ((mod->field_0x40 & 0x80) != 0)) &&
          (iVar1 = apply_aug(aug,unres), iVar1 != 0)) {
    iVar1 = -1;
    goto LAB_0012490a;
  }
  iVar1 = 0;
LAB_0012490a:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int resolve_extension(unres_ext *info,lys_ext_instance **ext,unres_schema *unres)

{
  LYEXT_PAR LVar1;
  ly_ctx *plVar2;
  lyxml_elem *plVar3;
  lys_ext *__s;
  ushort uVar4;
  int iVar5;
  lys_module *plVar6;
  lys_ext_instance *plVar7;
  char *pcVar8;
  char *s2;
  uint8_t uVar9;
  unres_schema *unres_local;
  lys_ext_instance **ext_local;
  unres_ext *info_local;
  LY_VLOG_ELEM vlog_type;
  uint i;
  uint j;
  LYEXT_TYPE etype;
  void *vlog_node;
  lys_ext *e;
  lyxml_elem *next_yin;
  lyxml_elem *yin;
  ly_ctx *ctx;
  char *ext_prefix;
  char *tmp;
  char *ext_name;
  lys_module *mod;
  lys_ext_instance *tmp_ext;
  
  LVar1 = info->parent_type;
  if (LVar1 < LYEXT_PAR_REVISION) {
    if ((LVar1 < LYEXT_PAR_IMPORT) && (LVar1 != LYEXT_PAR_MODULE)) {
      if (LVar1 != LYEXT_PAR_NODE) goto LAB_0012498b;
      vlog_node = info->parent;
      vlog_type = LY_VLOG_LYS;
    }
    else {
      vlog_node = (void *)0x0;
      vlog_type = LY_VLOG_LYS;
    }
  }
  else {
LAB_0012498b:
    vlog_node = (void *)0x0;
    vlog_type = LY_VLOG_NONE;
  }
  if (info->datatype == LYS_IN_YIN) {
    plVar6 = lyp_get_import_module_ns(info->mod,((info->data).yin)->ns->value);
    if (plVar6 == (lys_module *)0x0) {
      ly_vlog((ly_ctx *)0x0,LYE_INSTMT,vlog_type,vlog_node,((info->data).yin)->name);
      return 1;
    }
    plVar2 = plVar6->ctx;
    e = (lys_ext *)0x0;
    for (i = 0; i < plVar6->extensions_size; i = i + 1) {
      if (plVar6->extensions[i].name == ((info->data).yin)->name) {
        e = plVar6->extensions + i;
        break;
      }
    }
    for (j = 0; (e == (lys_ext *)0x0 && (j < plVar6->inc_size)); j = j + 1) {
      for (i = 0; i < (plVar6->inc[j].submodule)->extensions_size; i = i + 1) {
        if ((plVar6->inc[j].submodule)->extensions[i].name == ((info->data).yin)->name) {
          e = (plVar6->inc[j].submodule)->extensions + i;
          break;
        }
      }
    }
    if (e == (lys_ext *)0x0) {
      ly_vlog(plVar2,LYE_INSTMT,vlog_type,vlog_node,((info->data).yin)->name);
      return 1;
    }
    if (((e->plugin != (lyext_plugin *)0x0) &&
        (e->plugin->check_position != (lyext_check_position_clb)0x0)) &&
       (iVar5 = (*e->plugin->check_position)(info->parent,info->parent_type,info->substmt),
       iVar5 != 0)) {
      ly_vlog(plVar2,LYE_INSTMT,vlog_type,vlog_node,e->name);
      return -1;
    }
    if (e->plugin == (lyext_plugin *)0x0) {
      etype = LYEXT_FLAG;
    }
    else {
      etype = e->plugin->type;
    }
    if (etype == LYEXT_COMPLEX) {
      plVar7 = (lys_ext_instance *)calloc(1,(size_t)e->plugin[1].check_position);
      *ext = plVar7;
    }
    else if (etype < 2) {
      if (etype == LYEXT_ERR) {
        ly_log(plVar2,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
               ,0x1377);
        return -1;
      }
      if (etype == LYEXT_FLAG) {
        plVar7 = (lys_ext_instance *)calloc(1,0x40);
        *ext = plVar7;
      }
    }
    if (*ext == (lys_ext_instance *)0x0) {
      ly_log(plVar2,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_extension");
      return -1;
    }
    (*ext)->def = e;
    (*ext)->parent = info->parent;
    (*ext)->parent_type = (uint8_t)info->parent_type;
    (*ext)->insubstmt = (uint8_t)info->substmt;
    (*ext)->insubstmt_index = info->substmt_index;
    if (e->plugin == (lyext_plugin *)0x0) {
      uVar9 = '\0';
    }
    else {
      uVar9 = (uint8_t)e->plugin->type;
    }
    (*ext)->ext_type = uVar9;
    if (e->plugin == (lyext_plugin *)0x0) {
      uVar4 = 0;
    }
    else {
      uVar4 = e->plugin->flags;
    }
    (*ext)->flags = (*ext)->flags | uVar4;
    if (e->argument != (char *)0x0) {
      if ((e->flags & 1) == 0) {
        plVar7 = *ext;
        pcVar8 = lyxml_get_attr((info->data).yin,e->argument,(char *)0x0);
        plVar7->arg_value = pcVar8;
        if ((*ext)->arg_value == (char *)0x0) {
          ly_vlog(plVar2,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,e->argument,((info->data).yin)->name);
          return -1;
        }
        plVar7 = *ext;
        pcVar8 = lydict_insert(plVar6->ctx,(*ext)->arg_value,0);
        plVar7->arg_value = pcVar8;
      }
      else {
        plVar3 = ((info->data).yin)->child;
        do {
          yin = plVar3;
          if (yin == (lyxml_elem *)0x0) goto LAB_00124f33;
          plVar3 = yin->next;
        } while (yin->name != e->argument);
        plVar7 = *ext;
        pcVar8 = lydict_insert(plVar6->ctx,yin->content,0);
        plVar7->arg_value = pcVar8;
        lyxml_free(plVar6->ctx,yin);
      }
    }
LAB_00124f33:
    if ((((*ext)->flags & 8) != 0) &&
       ((info->parent_type == LYEXT_PAR_NODE || (info->parent_type == LYEXT_PAR_TPDF)))) {
      *(ushort *)((long)info->parent + 0x18) = *(ushort *)((long)info->parent + 0x18) | 0x2000;
    }
    (*ext)->nodetype = LYS_EXT;
    (*ext)->module = info->mod;
    if (etype == LYEXT_FLAG) {
      yin = ((info->data).yin)->child;
      while (yin != (lyxml_elem *)0x0) {
        plVar3 = yin->next;
        if (yin->ns == (lyxml_ns *)0x0) {
          lyxml_free(plVar6->ctx,yin);
          yin = plVar3;
        }
        else {
          iVar5 = strcmp(yin->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
          if (iVar5 == 0) {
            ly_vlog(plVar2,LYE_INCHILDSTMT,vlog_type,vlog_node,yin->name,((info->data).yin)->name);
            return -1;
          }
          if (((yin->ns == ((info->data).yin)->ns) && ((e->flags & 1) != 0)) &&
             (yin->name == e->argument)) {
            if ((*ext)->arg_value != (char *)0x0) {
              ly_vlog(plVar2,LYE_TOOMANY,vlog_type,vlog_node,yin->name,((info->data).yin)->name);
              return -1;
            }
            (*ext)->arg_value = yin->content;
            yin->content = (char *)0x0;
            lyxml_free(plVar6->ctx,yin);
            yin = plVar3;
          }
          else {
            iVar5 = lyp_yin_parse_subnode_ext
                              (info->mod,*ext,LYEXT_PAR_EXTINST,yin,LYEXT_SUBSTMT_SELF,'\0',unres);
            yin = plVar3;
            if (iVar5 != 0) {
              return -1;
            }
          }
        }
      }
    }
    else if (etype == LYEXT_COMPLEX) {
      (*ext)[1].def = *(lys_ext **)(e->plugin + 1);
      iVar5 = lyp_yin_parse_complex_ext
                        (info->mod,(lys_ext_instance_complex *)*ext,(info->data).yin,unres);
      if (iVar5 != 0) {
        return -1;
      }
    }
LAB_00125835:
    iVar5 = 0;
  }
  else {
    __s = (*ext)->def;
    pcVar8 = strchr((char *)__s,0x3a);
    if (pcVar8 == (char *)0x0) {
      ly_vlog((ly_ctx *)0x0,LYE_INSTMT,vlog_type,vlog_node,__s);
    }
    else {
      s2 = pcVar8 + 1;
      plVar6 = lyp_get_module(info->mod,(char *)__s,(int)pcVar8 - (int)__s,(char *)0x0,0,0);
      if (plVar6 == (lys_module *)0x0) {
        ly_vlog((ly_ctx *)0x0,LYE_INSTMT,vlog_type,vlog_node,__s);
        return 1;
      }
      plVar2 = plVar6->ctx;
      e = (lys_ext *)0x0;
      for (i = 0; i < plVar6->extensions_size; i = i + 1) {
        iVar5 = ly_strequal_(plVar6->extensions[i].name,s2);
        if (iVar5 != 0) {
          e = plVar6->extensions + i;
          break;
        }
      }
      for (j = 0; (e == (lys_ext *)0x0 && (j < plVar6->inc_size)); j = j + 1) {
        for (i = 0; i < (plVar6->inc[j].submodule)->extensions_size; i = i + 1) {
          iVar5 = ly_strequal_((plVar6->inc[j].submodule)->extensions[i].name,s2);
          if (iVar5 != 0) {
            e = (plVar6->inc[j].submodule)->extensions + i;
            break;
          }
        }
      }
      if (e == (lys_ext *)0x0) {
        ly_vlog(plVar2,LYE_INSTMT,vlog_type,vlog_node,__s);
        return 1;
      }
      (*ext)->flags = (*ext)->flags & 0xfffd;
      (*ext)->def = (lys_ext *)0x0;
      if (((e->plugin == (lyext_plugin *)0x0) ||
          (e->plugin->check_position == (lyext_check_position_clb)0x0)) ||
         (iVar5 = (*e->plugin->check_position)(info->parent,info->parent_type,info->substmt),
         iVar5 == 0)) {
        if ((e->argument == (char *)0x0) || ((*ext)->arg_value != (char *)0x0)) {
          (*ext)->def = e;
          (*ext)->parent = info->parent;
          if (e->plugin == (lyext_plugin *)0x0) {
            uVar9 = '\0';
          }
          else {
            uVar9 = (uint8_t)e->plugin->type;
          }
          (*ext)->ext_type = uVar9;
          if (e->plugin == (lyext_plugin *)0x0) {
            uVar4 = 0;
          }
          else {
            uVar4 = e->plugin->flags;
          }
          (*ext)->flags = (*ext)->flags | uVar4;
          if ((((*ext)->flags & 8) != 0) &&
             ((info->parent_type == LYEXT_PAR_NODE || (info->parent_type == LYEXT_PAR_TPDF)))) {
            *(ushort *)((long)info->parent + 0x18) = *(ushort *)((long)info->parent + 0x18) | 0x2000
            ;
          }
          (*ext)->module = info->mod;
          (*ext)->nodetype = LYS_EXT;
          if (e->plugin == (lyext_plugin *)0x0) {
            etype = LYEXT_FLAG;
          }
          else {
            etype = e->plugin->type;
          }
          if (etype == LYEXT_COMPLEX) {
            plVar7 = (lys_ext_instance *)realloc(*ext,(size_t)e->plugin[1].check_position);
            if (plVar7 == (lys_ext_instance *)0x0) {
              ly_log(plVar2,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_extension")
              ;
            }
            else {
              memset(&plVar7[1].parent,0,(size_t)(e->plugin[1].check_position + -0x48));
              *ext = plVar7;
              (*ext)[1].def = *(lys_ext **)(e->plugin + 1);
              if ((info->data).yin != (lyxml_elem *)0x0) {
                *pcVar8 = ':';
                iVar5 = yang_parse_ext_substatement
                                  (info->mod,unres,((info->data).yang)->ext_substmt,(char *)__s,
                                   (lys_ext_instance_complex *)*ext);
                if ((iVar5 != 0) ||
                   (iVar5 = yang_fill_extcomplex_module
                                      (info->mod->ctx,(lys_ext_instance_complex *)*ext,(char *)__s,
                                       ((info->data).yang)->ext_modules,
                                       (uint)((byte)info->mod->field_0x40 >> 7)), iVar5 != 0))
                goto LAB_00125843;
              }
              iVar5 = lyp_mand_check_ext((lys_ext_instance_complex *)*ext,(char *)__s);
              if (iVar5 == 0) goto LAB_001257e8;
            }
          }
          else if ((etype < 2) && (etype == LYEXT_ERR)) {
            ly_log(plVar2,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                   ,0x143c);
          }
          else {
LAB_001257e8:
            iVar5 = yang_check_ext_instance
                              (info->mod,&(*ext)->ext,(uint)(*ext)->ext_size,*ext,unres);
            if (iVar5 == 0) {
              free(__s);
              goto LAB_00125835;
            }
          }
        }
        else {
          ly_vlog(plVar2,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,e->argument,s2);
        }
      }
      else {
        ly_vlog(plVar2,LYE_INSTMT,vlog_type,vlog_node,e->name);
      }
    }
LAB_00125843:
    free(__s);
    iVar5 = -1;
  }
  return iVar5;
}



lys_node * resolve_choice_dflt(lys_node_choice *choic,char *dflt)

{
  lys_node *plVar1;
  char *dflt_local;
  lys_node_choice *choic_local;
  lys_node *child;
  lys_node *ret;
  
  child = choic->child;
  while( true ) {
    if (child == (lys_node *)0x0) {
      return (lys_node *)0x0;
    }
    if ((child->nodetype == LYS_USES) &&
       (plVar1 = resolve_choice_dflt((lys_node_choice *)child,dflt), plVar1 != (lys_node *)0x0))
    break;
    if ((dflt == child->name) && ((child->nodetype & 0x807f) != LYS_UNKNOWN)) {
      return child;
    }
    child = child->next;
  }
  return plVar1;
}



int resolve_uses(lys_node_uses *uses,unres_schema *unres)

{
  lys_restr *plVar1;
  lys_iffeature *plVar2;
  LYS_NODE LVar3;
  lys_node *plVar4;
  lys_restr *plVar5;
  byte bVar6;
  int iVar7;
  lys_node **pplVar8;
  lys_module *plVar9;
  char **ppcVar10;
  uint8_t *puVar11;
  lys_feature **pplVar12;
  lys_node *plVar13;
  char *pcVar14;
  long lVar15;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  lys_node_uses *uses_local;
  uint8_t size;
  uint usize1;
  uint usize2;
  int i;
  int j;
  int k;
  int rc;
  uint usize;
  lys_node *node;
  lys_node *next;
  lys_node *iter;
  lys_node **refine_nodes;
  lys_node *node_aux;
  lys_node *parent;
  lys_node *tmp;
  lys_restr **old_must;
  uint8_t *old_size;
  ly_ctx *ctx;
  lys_refine *rfn;
  lys_node_leaf *leaf;
  lys_node_leaflist *llist;
  lys_restr *must;
  lys_iffeature **old_iff;
  lys_iffeature *iff;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = uses->module->ctx;
  node = (lys_node *)0x0;
  refine_nodes = (lys_node **)0x0;
  if (uses->grp == (lys_node_grp *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("uses->grp",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x1481,"resolve_uses");
  }
  if (uses->grp->unres_count != 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("!uses->grp->unres_count",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x1484,"resolve_uses");
  }
  for (node_aux = uses->grp->child; node_aux != (lys_node *)0x0; node_aux = node_aux->next) {
    if ((node_aux->nodetype & LYS_GROUPING) == LYS_UNKNOWN) {
      node = lys_node_dup(uses->module,(lys_node *)uses,node_aux,unres,0);
      if (node == (lys_node *)0x0) {
        ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,uses,uses->grp->name,&DAT_0020f894);
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Copying data from grouping failed.");
        goto LAB_0012748b;
      }
      if (uses->parent == (lys_node *)0x0) {
        plVar9 = lys_main_module(uses->module);
        tmp = plVar9->data;
      }
      else {
        pplVar8 = lys_child(uses->parent,LYS_USES);
        tmp = *pplVar8;
      }
      for (; tmp != (lys_node *)0x0; tmp = tmp->next) {
        if (((tmp->nodetype & 0x1840) == LYS_UNKNOWN) && (tmp->name == node_aux->name))
        goto LAB_0012748b;
      }
    }
  }
  if ((uses->refine_size == '\0') ||
     (refine_nodes = (lys_node **)malloc((ulong)uses->refine_size << 3),
     refine_nodes != (lys_node **)0x0)) {
    for (i = 0; i < (int)(uint)uses->refine_size; i = i + 1) {
      rfn = uses->refine + i;
      rc = resolve_descendant_schema_nodeid(rfn->target_name,uses->child,0xc0ff,0,&node);
      if ((rc != 0) || (node == (lys_node *)0x0)) {
        ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,uses,rfn->target_name,"refine");
        goto LAB_0012748b;
      }
      if ((rfn->target_type != 0) && (((uint)rfn->target_type & node->nodetype) == LYS_UNKNOWN)) {
        ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,uses,rfn->target_name,"refine");
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                "Refine substatements not applicable to the target-node.");
        goto LAB_0012748b;
      }
      refine_nodes[i] = node;
      if (rfn->dsc != (char *)0x0) {
        lydict_remove(ctx,node->dsc);
        plVar4 = node;
        pcVar14 = lydict_insert(ctx,rfn->dsc,0);
        plVar4->dsc = pcVar14;
      }
      if (rfn->ref != (char *)0x0) {
        lydict_remove(ctx,node->ref);
        plVar4 = node;
        pcVar14 = lydict_insert(ctx,rfn->ref,0);
        plVar4->ref = pcVar14;
      }
      if (((rfn->flags & 3) != 0) && ((node->flags & 3) != 0)) {
        node->flags = node->flags & 0xfffc;
        node->flags = node->flags | rfn->flags & 3;
      }
      if (rfn->dflt_size != '\0') {
        if (node->nodetype == LYS_LEAF) {
          leaf = (lys_node_leaf *)node;
          lydict_remove(ctx,(char *)node[1].prev);
          pcVar14 = lydict_insert(ctx,*rfn->dflt,0);
          leaf->dflt = pcVar14;
          iVar7 = unres_schema_add_node
                            (leaf->module,unres,&leaf->type,UNRES_TYPE_DFLT,(lys_node *)&leaf->dflt)
          ;
          if (iVar7 == -1) goto LAB_0012748b;
        }
        else if (node->nodetype == LYS_LEAFLIST) {
          llist = (lys_node_leaflist *)node;
          for (j = 0; j < (int)(uint)llist->dflt_size; j = j + 1) {
            lydict_remove(ctx,llist->dflt[j]);
          }
          free(llist->dflt);
          ppcVar10 = (char **)malloc((ulong)rfn->dflt_size << 3);
          llist->dflt = ppcVar10;
          if (llist->dflt == (char **)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_uses");
            goto LAB_0012748b;
          }
          llist->dflt_size = rfn->dflt_size;
          for (j = 0; j < (int)(uint)llist->dflt_size; j = j + 1) {
            ppcVar10 = llist->dflt;
            lVar15 = (long)j;
            pcVar14 = lydict_insert(ctx,rfn->dflt[j],0);
            ppcVar10[lVar15] = pcVar14;
          }
          for (j = 0; j < (int)(uint)llist->dflt_size; j = j + 1) {
            iVar7 = unres_schema_add_node
                              (llist->module,unres,&llist->type,UNRES_TYPE_DFLT,
                               (lys_node *)(llist->dflt + j));
            if (iVar7 == -1) goto LAB_0012748b;
          }
        }
      }
      if ((rfn->flags & 0xc0) != 0) {
        node->flags = node->flags & 0xff3f;
        node->flags = node->flags | rfn->flags & 0xc0;
        if ((rfn->flags & 0x40) != 0) {
          if (((node->nodetype & LYS_LEAF) != LYS_UNKNOWN) && (node[1].prev != (lys_node *)0x0)) {
            ly_vlog(ctx,LYE_SPEC,LY_VLOG_LYS,uses,
                    "The \"mandatory\" statement is forbidden on leaf with \"default\".");
            goto LAB_0012748b;
          }
          if (((node->nodetype & LYS_CHOICE) != LYS_UNKNOWN) && (node[1].name != (char *)0x0)) {
            ly_vlog(ctx,LYE_SPEC,LY_VLOG_LYS,uses,
                    "The \"mandatory\" statement is forbidden on choices with \"default\".");
            goto LAB_0012748b;
          }
        }
      }
      if (((node->nodetype & LYS_CONTAINER) != LYS_UNKNOWN) && ((rfn->mod).presence != (char *)0x0))
      {
        lydict_remove(ctx,*(char **)&node[1].flags);
        plVar4 = node;
        pcVar14 = lydict_insert(ctx,(rfn->mod).presence,0);
        *(char **)&plVar4[1].flags = pcVar14;
      }
      if (node->nodetype == LYS_LIST) {
        if ((rfn->flags & 0x10) != 0) {
          *(uint32_t *)&node[1].iffeature = (rfn->mod).list.min;
        }
        if ((rfn->flags & 8) != 0) {
          *(uint32_t *)((long)&node[1].iffeature + 4) = (rfn->mod).list.max;
        }
      }
      else if (node->nodetype == LYS_LEAFLIST) {
        if ((rfn->flags & 0x10) != 0) {
          *(uint32_t *)&node[1].priv = (rfn->mod).list.min;
        }
        if ((rfn->flags & 8) != 0) {
          *(uint32_t *)((long)&node[1].priv + 4) = (rfn->mod).list.max;
        }
      }
      if (rfn->must_size != '\0') {
        LVar3 = node->nodetype;
        if (LVar3 < (LYS_CONTAINER|LYS_ANYXML)) {
          if ((LVar3 != LYS_UNKNOWN) && (true)) {
            switch(LVar3) {
            case LYS_CONTAINER:
              old_size = node->padding + 1;
              break;
            default:
              goto switchD_001262fe_caseD_2;
            case LYS_LEAF:
              old_size = node->padding + 3;
              break;
            case LYS_LEAFLIST:
              old_size = node->padding + 3;
              break;
            case LYS_LIST:
              old_size = node->padding;
              break;
            case LYS_ANYXML:
              goto switchD_001262fe_caseD_20;
            }
LAB_001263eb:
            old_must = (lys_restr **)&node[1].dsc;
            bVar6 = rfn->must_size + *old_size;
            must = (lys_restr *)realloc(*old_must,(ulong)bVar6 * 0x38);
            if (must == (lys_restr *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_uses");
            }
            else {
              k = 0;
              j = (int)*old_size;
              for (; k < (int)(uint)rfn->must_size; k = k + 1) {
                must[j].ext_size = rfn->must[k].ext_size;
                lys_ext_dup(ctx,rfn->module,rfn->must[k].ext,rfn->must[k].ext_size,rfn->must + k,
                            LYEXT_PAR_RESTR,&must[j].ext,0,unres);
                plVar1 = must + j;
                pcVar14 = lydict_insert(ctx,rfn->must[k].expr,0);
                plVar5 = must;
                plVar1->expr = pcVar14;
                lVar15 = (long)j;
                pcVar14 = lydict_insert(ctx,rfn->must[k].dsc,0);
                plVar1 = must;
                plVar5[lVar15].dsc = pcVar14;
                lVar15 = (long)j;
                pcVar14 = lydict_insert(ctx,rfn->must[k].ref,0);
                plVar5 = must;
                plVar1[lVar15].ref = pcVar14;
                lVar15 = (long)j;
                pcVar14 = lydict_insert(ctx,rfn->must[k].eapptag,0);
                plVar1 = must;
                plVar5[lVar15].eapptag = pcVar14;
                lVar15 = (long)j;
                pcVar14 = lydict_insert(ctx,rfn->must[k].emsg,0);
                plVar1[lVar15].emsg = pcVar14;
                must[j].flags = rfn->must[k].flags;
                j = j + 1;
              }
              *old_must = must;
              *old_size = bVar6;
              iVar7 = unres_schema_add_node(node->module,unres,node,UNRES_XPATH,(lys_node *)0x0);
              if (iVar7 != -1) goto LAB_0012682b;
            }
            goto LAB_0012748b;
          }
        }
        else if (LVar3 == LYS_ANYDATA) {
switchD_001262fe_caseD_20:
          old_size = node->padding + 3;
          goto LAB_001263eb;
        }
switchD_001262fe_caseD_2:
        ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
               ,0x1538);
        goto LAB_0012748b;
      }
LAB_0012682b:
      if (rfn->iffeature_size != '\0') {
        old_size = &node->iffeature_size;
        old_iff = &node->iffeature;
        bVar6 = rfn->iffeature_size + *old_size;
        iff = (lys_iffeature *)realloc(*old_iff,(ulong)bVar6 << 5);
        if (iff == (lys_iffeature *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_uses");
          goto LAB_0012748b;
        }
        *old_iff = iff;
        k = 0;
        j = (int)*old_size;
        for (; k < (int)(uint)rfn->iffeature_size; k = k + 1) {
          resolve_iffeature_getsizes(rfn->iffeature + k,&usize1,&usize2);
          if (usize1 != 0) {
            usize = (uint)((usize1 & 3) + (usize1 >> 2) != 0);
            plVar2 = iff + j;
            puVar11 = (uint8_t *)malloc((ulong)usize);
            plVar2->expr = puVar11;
            if (iff[j].expr == (uint8_t *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_uses");
              goto LAB_0012748b;
            }
            memcpy(iff[j].expr,rfn->iffeature[k].expr,(ulong)usize);
            plVar2 = iff;
            lVar15 = (long)j;
            pplVar12 = (lys_feature **)malloc((ulong)usize2 << 3);
            plVar2[lVar15].features = pplVar12;
            if (iff[j].expr == (uint8_t *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_uses");
              goto LAB_0012748b;
            }
            memcpy(iff[j].features,rfn->iffeature[k].features,(ulong)usize2 * 8);
            iff[j].ext_size = rfn->iffeature[k].ext_size;
            lys_ext_dup(ctx,rfn->module,rfn->iffeature[k].ext,rfn->iffeature[k].ext_size,
                        rfn->iffeature + k,LYEXT_PAR_IFFEATURE,&iff[j].ext,0,unres);
          }
          *old_size = *old_size + '\x01';
          j = j + 1;
        }
        if (bVar6 != *old_size) {
                    // WARNING: Subroutine does not return
          __assert_fail("*old_size == size",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                        ,0x1574,"resolve_uses");
        }
      }
    }
    for (i = 0; i < (int)(uint)uses->augment_size; i = i + 1) {
      rc = resolve_augment(uses->augment + i,(lys_node *)uses,unres);
      if (rc != 0) goto LAB_0012748b;
    }
    for (i = 0; i < (int)(uint)uses->refine_size; i = i + 1) {
      node = refine_nodes[i];
      rfn = uses->refine + i;
      if (((rfn->flags & 3) != 0) && ((node->flags & 3) != 0)) {
        for (parent = lys_parent(node);
            (parent != (lys_node *)0x0 && (parent->nodetype == LYS_USES));
            parent = lys_parent(parent)) {
        }
        if ((((parent != (lys_node *)0x0) && (parent->nodetype != LYS_GROUPING)) &&
            ((parent->flags & 3) != 0)) &&
           ((((rfn->flags ^ parent->flags) & 3) != 0 && ((rfn->flags & 1) != 0)))) {
          ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,uses,"config","refine");
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                  "changing config from \'false\' to \'true\' is prohibited while the target\'s parent is still config \'false\'."
                 );
          goto LAB_0012748b;
        }
        next = node->child;
        while (iter = next, next != (lys_node *)0x0) {
          if ((rfn->flags & 1) == 0) {
            if (((next->flags & 4) != 0) && ((next->flags & 1) != 0)) {
              ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,uses,"config","refine");
              ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                      "changing config from \'true\' to \'false\' is prohibited while the target has still a children with explicit config \'true\'."
                     );
              goto LAB_0012748b;
            }
LAB_00126f1c:
            next->flags = next->flags & 0xfffc;
            next->flags = rfn->flags & 3 | next->flags;
            if ((next->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
              next = next->child;
            }
            else {
              next = (lys_node *)0x0;
            }
          }
          else {
            if ((next->flags & 4) == 0) goto LAB_00126f1c;
            next = (lys_node *)0x0;
          }
          if (next == (lys_node *)0x0) {
            next = iter->next;
          }
          while ((next == (lys_node *)0x0 && (iter = lys_parent(iter), iter != node))) {
            next = iter->next;
          }
        }
      }
      plVar4 = node;
      if ((rfn->dflt_size != '\0') && (node->nodetype == LYS_CHOICE)) {
        plVar13 = resolve_choice_dflt((lys_node_choice *)node,*rfn->dflt);
        plVar4[1].name = (char *)plVar13;
        if (node[1].name == (char *)0x0) {
          ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,uses,*rfn->dflt,"default");
          goto LAB_0012748b;
        }
        iVar7 = lyp_check_mandatory_choice(node);
        if (iVar7 != 0) goto LAB_0012748b;
      }
      if ((node->nodetype == LYS_LIST) && (*(int *)((long)&node[1].iffeature + 4) != 0)) {
        if (*(uint *)((long)&node[1].iffeature + 4) < *(uint *)&node[1].iffeature) {
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_LYS,uses,"Invalid value \"%d\" of \"%s\".",
                  (ulong)(rfn->mod).list.min,"min-elements");
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                  "\"min-elements\" is bigger than \"max-elements\".");
          goto LAB_0012748b;
        }
      }
      else if ((node->nodetype == LYS_LEAFLIST) &&
              ((*(int *)((long)&node[1].priv + 4) != 0 &&
               (*(uint *)((long)&node[1].priv + 4) < *(uint *)&node[1].priv)))) {
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_LYS,uses,"Invalid value \"%d\" of \"%s\".",
                (ulong)(rfn->mod).list.min,"min-elements");
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                "\"min-elements\" is bigger than \"max-elements\".");
        goto LAB_0012748b;
      }
      if (node->nodetype == LYS_LEAFLIST) {
        llist = (lys_node_leaflist *)node;
        if ((node->padding[2] != '\0') && (*(int *)&node[1].priv != 0)) {
          if (rfn->dflt_size == '\0') {
            pcVar14 = "min-elements";
          }
          else {
            pcVar14 = "default";
          }
          ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,uses,pcVar14,"refine");
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                  "The \"min-elements\" statement with non-zero value is forbidden on leaf-lists with the \"default\" statement."
                 );
          goto LAB_0012748b;
        }
      }
      else if (((node->nodetype == LYS_LEAF) &&
               (leaf = (lys_node_leaf *)node, node[1].prev != (lys_node *)0x0)) &&
              ((node->flags & 0x40) != 0)) {
        if (rfn->dflt_size == '\0') {
          pcVar14 = "mandatory";
        }
        else {
          pcVar14 = "default";
        }
        ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,uses,pcVar14,"refine");
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                "The \"mandatory\" statement is forbidden on leafs with the \"default\" statement.")
        ;
        goto LAB_0012748b;
      }
      if (((rfn->flags & 0x40) != 0) || ((rfn->mod).list.min != 0)) {
        parent = node->parent;
        while (((parent != (lys_node *)0x0 && ((parent->nodetype & 0x5802) == LYS_UNKNOWN)) &&
               ((parent->nodetype != LYS_CONTAINER ||
                (lVar15._0_2_ = parent[1].flags, lVar15._2_1_ = parent[1].ext_size,
                lVar15._3_1_ = parent[1].iffeature_size, lVar15._4_1_ = parent[1].padding[0],
                lVar15._5_1_ = parent[1].padding[1], lVar15._6_1_ = parent[1].padding[2],
                lVar15._7_1_ = parent[1].padding[3], lVar15 == 0))))) {
          parent = parent->parent;
        }
        if ((((parent != (lys_node *)0x0) && (parent->nodetype == LYS_CHOICE)) &&
            (parent[1].name != (char *)0x0)) &&
           (iVar7 = lyp_check_mandatory_choice(parent), iVar7 != 0)) goto LAB_0012748b;
      }
    }
    free(refine_nodes);
    iVar7 = 0;
  }
  else {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_uses");
LAB_0012748b:
    iter = uses->child;
    while (iter != (lys_node *)0x0) {
      next = iter->next;
      lys_node_free(iter,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
      iter = next;
    }
    free(refine_nodes);
    iVar7 = -1;
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar7;
}



void resolve_identity_backlink_update(lys_ident *der,lys_ident *base)

{
  ly_set *plVar1;
  lys_ident *base_local;
  lys_ident *der_local;
  int i;
  
  if ((der != (lys_ident *)0x0) && (base != (lys_ident *)0x0)) {
    if (base->der == (ly_set *)0x0) {
      plVar1 = ly_set_new();
      base->der = plVar1;
    }
    ly_set_add(base->der,der,1);
    for (i = 0; i < (int)(uint)base->base_size; i = i + 1) {
      resolve_identity_backlink_update(der,base->base[i]);
    }
    return;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("der && base",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                ,0x1618,"resolve_identity_backlink_update");
}



int resolve_base_ident_sub
              (lys_module *module,lys_ident *ident,char *basename,unres_schema *unres,
              lys_ident **ret)

{
  ly_ctx *ctx_00;
  int iVar1;
  lys_ident **ret_local;
  unres_schema *unres_local;
  char *basename_local;
  lys_ident *ident_local;
  lys_module *module_local;
  uint32_t i;
  uint32_t j;
  lys_ident *base;
  ly_ctx *ctx;
  
  base = (lys_ident *)0x0;
  ctx_00 = module->ctx;
  if (ret == (lys_ident **)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("ret",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x1639,"resolve_base_ident_sub");
  }
  i = 0;
  do {
    if (module->ident_size <= i) {
      j = 0;
      while ((j < module->inc_size && (module->inc[j].submodule != (lys_submodule *)0x0))) {
        for (i = 0; i < (module->inc[j].submodule)->ident_size; i = i + 1) {
          iVar1 = strcmp(basename,(module->inc[j].submodule)->ident[i].name);
          if (iVar1 == 0) {
            if (ident == (lys_ident *)0x0) {
              *ret = (module->inc[j].submodule)->ident + i;
              return 0;
            }
            base = (module->inc[j].submodule)->ident + i;
            goto LAB_00127846;
          }
        }
        j = j + 1;
      }
LAB_00127846:
      if (base == (lys_ident *)0x0) {
        iVar1 = 1;
      }
      else {
        for (i = 0; i < unres->count; i = i + 1) {
          if ((base == (lys_ident *)unres->item[i]) && (unres->type[i] == UNRES_IDENT)) {
            if ((char *)unres->str_snode[i] == ident->name) {
              ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,basename,&DAT_0020fc3c);
              ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                      "Circular reference of \"%s\" identity.",basename);
              return -1;
            }
            return 1;
          }
        }
        *ret = base;
        iVar1 = 0;
      }
      return iVar1;
    }
    iVar1 = strcmp(basename,module->ident[i].name);
    if (iVar1 == 0) {
      if (ident == (lys_ident *)0x0) {
        *ret = module->ident + i;
        return 0;
      }
      base = module->ident + i;
      goto LAB_00127846;
    }
    i = i + 1;
  } while( true );
}



int resolve_base_ident(lys_module *module,lys_ident *ident,char *basename,char *parent,
                      lys_type *type,unres_schema *unres)

{
  byte bVar1;
  int iVar2;
  lys_type_bit *plVar3;
  char *pcVar4;
  lys_module *plVar5;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  lys_type *type_local;
  char *parent_local;
  char *basename_local;
  lys_ident *ident_local;
  lys_module *module_local;
  uint16_t flags;
  int mod_name_len;
  int rc;
  lys_ident *target;
  char *name;
  lys_ident **ret;
  lys_module *mod;
  ly_ctx *ctx;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  mod_name_len = 0;
  ctx = module->ctx;
  if (((ident == (lys_ident *)0x0) || (type != (lys_type *)0x0)) &&
     ((ident != (lys_ident *)0x0 || (type == (lys_type *)0x0)))) {
                    // WARNING: Subroutine does not return
    __assert_fail("(ident && !type) || (!ident && type)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x168f,"resolve_base_ident");
  }
  if (type == (lys_type *)0x0) {
    ret = &target;
    flags = ident->flags;
    mod = ident->module;
  }
  else {
    (type->info).bits.count = (type->info).bits.count + 1;
    plVar3 = (lys_type_bit *)ly_realloc((type->info).bits.bit,(ulong)(type->info).bits.count * 8);
    (type->info).bits.bit = plVar3;
    if ((type->info).bits.bit == (lys_type_bit *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_base_ident");
      rc = -1;
      goto LAB_00127d24;
    }
    ret = (lys_ident **)(&((type->info).bits.bit)->name + ((type->info).bits.count - 1));
    flags = type->parent->flags;
    mod = type->parent->module;
  }
  *ret = (lys_ident *)0x0;
  pcVar4 = strchr(basename,0x3a);
  name = basename;
  if (pcVar4 != (char *)0x0) {
    mod_name_len = (int)pcVar4 - (int)basename;
    name = pcVar4 + 1;
    iVar2 = strncmp(basename,module->name,(long)mod_name_len);
    if ((iVar2 == 0) && (module->name[mod_name_len] == '\0')) {
      mod_name_len = 0;
    }
  }
  pcVar4 = basename;
  if (mod_name_len == 0) {
    pcVar4 = (char *)0x0;
  }
  plVar5 = lyp_get_module(module,(char *)0x0,0,pcVar4,mod_name_len,0);
  if (plVar5 == (lys_module *)0x0) {
    ly_vlog(ctx,LYE_INMOD,LY_VLOG_NONE,(void *)0x0,basename);
    rc = -1;
  }
  else {
    rc = resolve_base_ident_sub(plVar5,ident,name,unres,ret);
    if (rc == 0) {
      if (*ret == (lys_ident *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("*ret",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                      ,0x16bc,"resolve_base_ident");
      }
      if (ident == (lys_ident *)0x0) {
        pcVar4 = "of type";
      }
      else {
        pcVar4 = ident->name;
      }
      iVar2 = lyp_check_status(flags,mod,pcVar4,(*ret)->flags,(*ret)->module,(*ret)->name,
                               (lys_node *)0x0);
      if (iVar2 == 0) {
        if (ident != (lys_ident *)0x0) {
          bVar1 = ident->base_size;
          ident->base_size = bVar1 + 1;
          ident->base[bVar1] = *ret;
          plVar5 = lys_main_module(mod);
          if ((plVar5->field_0x40 & 0x80) != 0) {
            resolve_identity_backlink_update(ident,*ret);
          }
        }
      }
      else {
        rc = -1;
      }
    }
    else if ((rc == 1) &&
            (ly_vlog(ctx,LYE_INRESOLV,LY_VLOG_NONE,(void *)0x0,parent,basename),
            type != (lys_type *)0x0)) {
      (type->info).bits.count = (type->info).bits.count - 1;
    }
  }
LAB_00127d24:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return rc;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int search_base_identity(lys_ident *der,lys_ident *base)

{
  int iVar1;
  lys_ident *base_local;
  lys_ident *der_local;
  int i;
  
  if (der == base) {
    iVar1 = 1;
  }
  else {
    for (i = 0; i < (int)(uint)der->base_size; i = i + 1) {
      iVar1 = search_base_identity(der->base[i],base);
      if (iVar1 == 1) {
        return 1;
      }
    }
    iVar1 = 0;
  }
  return iVar1;
}



lys_ident *
resolve_identref(lys_type *type,char *ident_name,lyd_node *node,lys_module *mod,int dflt)

{
  char *pcVar1;
  char *pcVar2;
  int iVar3;
  size_t sVar4;
  lys_module *plVar5;
  LY_ERR *pLVar6;
  lys_ident *plVar7;
  LY_VLOG_ELEM LVar8;
  long in_FS_OFFSET;
  int dflt_local;
  lys_module *mod_local;
  lyd_node *node_local;
  char *ident_name_local;
  lys_type *type_local;
  int mod_name_len;
  int nam_len;
  int need_implemented;
  uint i;
  uint j;
  int rc;
  char *mod_name;
  char *name;
  lys_ident *cur;
  lys_module *imod;
  ly_ctx *ctx;
  lys_module *m;
  lys_module *tmod;
  char *str;
  lys_ident *der;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  need_implemented = 0;
  imod = (lys_module *)0x0;
  if (((type == (lys_type *)0x0) || (ident_name == (char *)0x0)) || (mod == (lys_module *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("type && ident_name && mod",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x1702,"resolve_identref");
  }
  ctx = mod->ctx;
  if (((type == (lys_type *)0x0) ||
      (((type->info).bits.count == 0 && (type->der->module == (lys_module *)0x0)))) ||
     (ident_name == (char *)0x0)) {
    plVar7 = (lys_ident *)0x0;
    goto LAB_001289e7;
  }
  rc = parse_node_identifier(ident_name,&mod_name,&mod_name_len,&name,&nam_len,(int *)0x0,0);
  if (rc < 1) {
    if (node == (lyd_node *)0x0) {
      LVar8 = LY_VLOG_NONE;
    }
    else {
      LVar8 = LY_VLOG_LYD;
    }
    ly_vlog(ctx,LYE_INCHAR,LVar8,node,(ulong)(uint)(int)ident_name[-rc],ident_name + -rc);
    plVar7 = (lys_ident *)0x0;
    goto LAB_001289e7;
  }
  sVar4 = strlen(ident_name);
  if (rc < (int)sVar4) {
    if (node == (lyd_node *)0x0) {
      LVar8 = LY_VLOG_NONE;
    }
    else {
      LVar8 = LY_VLOG_LYD;
    }
    ly_vlog(ctx,LYE_INCHAR,LVar8,node,(ulong)(uint)(int)ident_name[rc],ident_name + rc);
    plVar7 = (lys_ident *)0x0;
    goto LAB_001289e7;
  }
  m = lys_main_module(mod);
  if ((mod_name == (char *)0x0) ||
     ((iVar3 = strncmp(mod_name,m->name,(long)mod_name_len), iVar3 == 0 &&
      (m->name[mod_name_len] == '\0')))) {
    imod = m;
  }
  else if (dflt == 0) {
    for (i = 0; i < (uint)(mod->ctx->models).used; i = i + 1) {
      imod = (mod->ctx->models).list[i];
      iVar3 = strncmp(mod_name,imod->name,(long)mod_name_len);
      if ((iVar3 == 0) && (imod->name[mod_name_len] == '\0')) break;
      imod = (lys_module *)0x0;
    }
    if ((imod == (lys_module *)0x0) && ((mod->ctx->models).parsing_sub_modules_count != '\0')) {
      for (i = 0; i < (mod->ctx->models).parsing_sub_modules_count; i = i + 1) {
        imod = (mod->ctx->models).parsing_sub_modules[i];
        if ((imod->field_0x40 & 1) == 0) {
          iVar3 = strncmp(mod_name,imod->name,(long)mod_name_len);
          if ((iVar3 == 0) && (imod->name[mod_name_len] == '\0')) break;
          imod = (lys_module *)0x0;
        }
      }
    }
  }
  else {
    for (i = 0; i < mod->imp_size; i = i + 1) {
      iVar3 = strncmp(mod_name,(mod->imp[i].module)->name,(long)mod_name_len);
      if ((iVar3 == 0) && ((mod->imp[i].module)->name[mod_name_len] == '\0')) {
        imod = mod->imp[i].module;
        break;
      }
    }
    if (((imod == (lys_module *)0x0) && (type != (lys_type *)0x0)) &&
       (type->der->module != (lys_module *)0x0)) {
      tmod = type->der->module;
      for (i = 0; i < tmod->imp_size; i = i + 1) {
        iVar3 = strncmp(mod_name,(tmod->imp[i].module)->name,(long)mod_name_len);
        if ((iVar3 == 0) && ((tmod->imp[i].module)->name[mod_name_len] == '\0')) {
          imod = tmod->imp[i].module;
          break;
        }
      }
    }
    if (imod == (lys_module *)0x0) {
      str = strndup(mod_name,(long)mod_name_len);
      imod = ly_ctx_get_module(ctx,str,(char *)0x0,1);
      free(str);
    }
  }
  if (((dflt == 0) && ((imod == (lys_module *)0x0 || ((imod->field_0x40 & 0x80) == 0)))) &&
     (ctx->data_clb != (ly_module_data_clb)0x0)) {
    if (imod == (lys_module *)0x0) {
      if (mod_name != (char *)0x0) {
        str = strndup(mod_name,(long)mod_name_len);
        imod = (*ctx->data_clb)(ctx,str,(char *)0x0,0,ctx->data_clb_data);
        free(str);
      }
    }
    else {
      (*ctx->data_clb)(ctx,imod->name,imod->ns,1,ctx->data_clb_data);
    }
  }
  if (imod != (lys_module *)0x0) {
    type_local = type;
    if (((m == imod) && (plVar5 = lys_main_module(type->parent->module), mod == plVar5)) ||
       ((imod->field_0x40 & 0x80) != 0)) {
      for (; type_local->der != (lys_tpdf *)0x0; type_local = &type_local->der->type) {
        for (i = 0; i < (type_local->info).bits.count; i = i + 1) {
          cur = (lys_ident *)(&((type_local->info).bits.bit)->name)[i];
          if (cur->der != (ly_set *)0x0) {
            for (j = 0; j < cur->der->number; j = j + 1) {
              der = (lys_ident *)(cur->der->set).s[j];
              iVar3 = strcmp(((lys_node *)der)->name,name);
              if ((iVar3 == 0) && (plVar5 = lys_main_module(der->module), imod == plVar5)) {
                cur = der;
                goto LAB_00128824;
              }
            }
          }
        }
      }
    }
    else {
      cur = (lys_ident *)0x0;
      for (i = 0; i < imod->ident_size; i = i + 1) {
        iVar3 = strcmp(name,imod->ident[i].name);
        if (iVar3 == 0) {
          cur = imod->ident + i;
          break;
        }
      }
      if (cur == (lys_ident *)0x0) {
        for (j = 0; j < imod->inc_size; j = j + 1) {
          for (i = 0; i < (imod->inc[j].submodule)->ident_size; i = i + 1) {
            iVar3 = strcmp(name,(imod->inc[j].submodule)->ident[i].name);
            if (iVar3 == 0) {
              cur = (imod->inc[j].submodule)->ident + i;
              break;
            }
          }
        }
        if (cur == (lys_ident *)0x0) goto LAB_001287d1;
      }
      for (; type_local->der != (lys_tpdf *)0x0; type_local = &type_local->der->type) {
        i = 0;
LAB_00128665:
        if (i < (type_local->info).bits.count) {
          iVar3 = search_base_identity(cur,(lys_ident *)(&((type_local->info).bits.bit)->name)[i]);
          if (iVar3 == 0) goto LAB_00128661;
          need_implemented = 1;
LAB_00128824:
          for (i = 0; i < cur->iffeature_size; i = i + 1) {
            iVar3 = resolve_iffeature(cur->iffeature + i);
            if (iVar3 == 0) {
              if (node != (lyd_node *)0x0) {
                ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,node,cur->name,node->schema->name);
              }
              ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                      "Identity \"%s\" is disabled by its if-feature condition.",cur->name);
              plVar7 = (lys_ident *)0x0;
              goto LAB_001289e7;
            }
          }
          plVar7 = cur;
          if (need_implemented == 0) goto LAB_001289e7;
          if (dflt == 0) {
            plVar5 = lys_main_module(cur->module);
            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "Identity found, but in a non-implemented module \"%s\".",plVar5->name);
          }
          else {
            ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                   "Making \"%s\" module implemented because of identityref default value \"%s\" used in the implemented \"%s\" module"
                   ,imod->name,cur->name,mod->name);
            iVar3 = lys_set_implemented(imod);
            plVar7 = cur;
            if (iVar3 == 0) goto LAB_001289e7;
            pcVar1 = cur->name;
            pcVar2 = imod->name;
            pLVar6 = ly_errno_glob_address();
            ly_log(ctx,LY_LLERR,*pLVar6,
                   "Setting the module \"%s\" implemented because of used default identity \"%s\" failed."
                   ,pcVar2,pcVar1);
          }
          goto LAB_001287d1;
        }
      }
      if (node == (lyd_node *)0x0) {
        LVar8 = LY_VLOG_NONE;
      }
      else {
        LVar8 = LY_VLOG_LYD;
      }
      ly_vlog(ctx,LYE_SPEC,LVar8,node,"Identity used as identityref value is not implemented.");
    }
  }
LAB_001287d1:
  if (node == (lyd_node *)0x0) {
    LVar8 = LY_VLOG_NONE;
  }
  else {
    LVar8 = LY_VLOG_LYD;
  }
  ly_vlog(ctx,LYE_INRESOLV,LVar8,node,"identityref",ident_name);
  plVar7 = (lys_ident *)0x0;
LAB_001289e7:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar7;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_00128661:
  i = i + 1;
  goto LAB_00128665;
}



int resolve_unres_schema_uses(lys_node_uses *uses,unres_schema *unres)

{
  ly_ctx *ctx_00;
  int iVar1;
  unres_schema *unres_local;
  lys_node_uses *uses_local;
  int rc;
  lys_node *par_grp;
  ly_ctx *ctx;
  
  ctx_00 = uses->module->ctx;
  for (par_grp = lys_parent((lys_node *)uses);
      (par_grp != (lys_node *)0x0 && (par_grp->nodetype != LYS_GROUPING));
      par_grp = lys_parent(par_grp)) {
  }
  if ((par_grp != (lys_node *)0x0) && (par_grp->name == uses->name)) {
    ly_vlog(ctx_00,LYE_INRESOLV,LY_VLOG_LYS,uses,&DAT_0020f894,uses->name);
    return -1;
  }
  if (uses->grp == (lys_node_grp *)0x0) {
    iVar1 = resolve_uses_schema_nodeid(uses->name,(lys_node *)uses,&uses->grp);
    if (iVar1 == -1) {
      ly_vlog(ctx_00,LYE_INRESOLV,LY_VLOG_LYS,uses,&DAT_0020f894,uses->name);
      return -1;
    }
    if (0 < iVar1) {
      ly_vlog(ctx_00,LYE_INCHAR,LY_VLOG_LYS,uses,(ulong)(uint)(int)uses->name[(long)iVar1 + -1],
              uses->name + (long)iVar1 + -1);
      return -1;
    }
    if (uses->grp == (lys_node_grp *)0x0) {
      if ((par_grp != (lys_node *)0x0) && ((uses->flags & 1) == 0)) {
        *(short *)par_grp->padding = *(short *)par_grp->padding + 1;
        if (*(short *)par_grp->padding == 0) {
          ly_log(ctx_00,LY_LLERR,LY_EINT,"Too many unresolved items (uses) inside a grouping.");
          return -1;
        }
        uses->flags = uses->flags | 1;
      }
      ly_vlog(ctx_00,LYE_INRESOLV,LY_VLOG_LYS,uses,&DAT_0020f894,uses->name);
      return 1;
    }
  }
  if (uses->grp->unres_count == 0) {
    iVar1 = resolve_uses(uses,unres);
    if (iVar1 == 0) {
      if ((par_grp != (lys_node *)0x0) && ((uses->flags & 1) != 0)) {
        if (*(short *)par_grp->padding == 0) {
                    // WARNING: Subroutine does not return
          __assert_fail("((struct lys_node_grp *)par_grp)->unres_count",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                        ,0x17ff,"resolve_unres_schema_uses");
        }
        *(short *)par_grp->padding = *(short *)par_grp->padding + -1;
        uses->flags = uses->flags & 0xfffe;
      }
      iVar1 = lyp_check_status(uses->flags,uses->module,"of uses",uses->grp->flags,uses->grp->module
                               ,uses->grp->name,(lys_node *)uses);
      if (iVar1 == 0) {
        iVar1 = 0;
      }
      else {
        iVar1 = -1;
      }
    }
  }
  else {
    if ((par_grp == (lys_node *)0x0) || ((uses->flags & 1) != 0)) {
      uses->grp = (lys_node_grp *)0x0;
    }
    else {
      *(short *)par_grp->padding = *(short *)par_grp->padding + 1;
      if (*(short *)par_grp->padding == 0) {
        ly_log(ctx_00,LY_LLERR,LY_EINT,"Too many unresolved items (uses) inside a grouping.");
        return -1;
      }
      uses->flags = uses->flags | 1;
    }
    ly_vlog(ctx_00,LYE_INRESOLV,LY_VLOG_LYS,uses,&DAT_0020f894,uses->name);
    iVar1 = 1;
  }
  return iVar1;
}



int resolve_list_keys(lys_node_list *list,char *keys_str)

{
  ly_ctx *ctx_00;
  lys_node_leaf **pplVar1;
  int iVar2;
  ushort **ppuVar3;
  size_t sVar4;
  lys_module *mod;
  int *piVar5;
  undefined4 *puVar6;
  char *__ptr;
  char *keys_str_local;
  lys_node_list *list_local;
  int i;
  int len;
  int rc;
  char *value;
  char *s;
  ly_ctx *ctx;
  
  ctx_00 = list->module->ctx;
  i = 0;
  keys_str_local = keys_str;
  while( true ) {
    if ((int)(uint)list->keys_size <= i) {
      return 0;
    }
    if (keys_str_local == (char *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("keys_str",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                    ,0x1822,"resolve_list_keys");
    }
    if (list->child == (lys_node *)0x0) {
      ly_vlog(ctx_00,LYE_INRESOLV,LY_VLOG_LYS,list,"list keys",keys_str_local);
      return 1;
    }
    value = strpbrk(keys_str_local," \t\n");
    if (value == (char *)0x0) {
      sVar4 = strlen(keys_str_local);
      len = (int)sVar4;
    }
    else {
      len = (int)value - (int)keys_str_local;
      while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*value] & 0x2000) != 0) {
        value = value + 1;
      }
    }
    pplVar1 = list->keys;
    mod = lys_node_module((lys_node *)list);
    iVar2 = lys_getnext_data(mod,(lys_node *)list,keys_str_local,len,LYS_LEAF,0x100,
                             (lys_node **)(pplVar1 + i));
    if (iVar2 != 0) break;
    iVar2 = check_key(list,i,keys_str_local,len);
    if (iVar2 != 0) {
      return -1;
    }
    iVar2 = lyp_check_status(list->flags,list->module,list->name,list->keys[i]->flags,
                             list->keys[i]->module,list->keys[i]->name,(lys_node *)list->keys[i]);
    if (iVar2 != 0) {
      return -1;
    }
    if (list->keys[i]->dflt != (char *)0x0) {
      piVar5 = (int *)__tls_get_addr(&PTR_0023dfc0);
      if (*piVar5 != 1) {
                    // WARNING: Subroutine does not return
        __assert_fail("log_opt == ILO_STORE",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                      ,0x184b,"resolve_list_keys");
      }
      puVar6 = (undefined4 *)__tls_get_addr(&PTR_0023dfc0);
      *puVar6 = 0;
      __ptr = lys_path((lys_node *)list,1);
      ly_log(ctx_00,LY_LLWRN,LY_SUCCESS,
             "Default value \"%s\" in the list key \"%s\" is ignored. (%s)",list->keys[i]->dflt,
             list->keys[i]->name,__ptr);
      puVar6 = (undefined4 *)__tls_get_addr(&PTR_0023dfc0);
      *puVar6 = 1;
      free(__ptr);
    }
    while ((value != (char *)0x0 && (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*value] & 0x2000) != 0))
          ) {
      value = value + 1;
    }
    keys_str_local = value;
    i = i + 1;
  }
  ly_vlog(ctx_00,LYE_INRESOLV,LY_VLOG_LYS,list,"list key",keys_str_local);
  return 1;
}



int resolve_must(lyd_node *node,int inout_parent,int ignore_fail)

{
  LYS_NODE LVar1;
  long lVar2;
  ly_ctx *ctx_00;
  int iVar3;
  lys_module *plVar4;
  long in_FS_OFFSET;
  int ignore_fail_local;
  int inout_parent_local;
  lyd_node *node_local;
  uint8_t i;
  uint8_t must_size;
  lys_node *schema;
  lys_restr *must;
  ly_ctx *ctx;
  lyxp_set set;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  ctx_00 = node->schema->module->ctx;
  if (node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x186f,"resolve_must");
  }
  memset(&set,0,0x40);
  if (inout_parent == 0) {
    LVar1 = node->schema->nodetype;
    node_local = node;
    if (LVar1 == LYS_ANYDATA) {
switchD_00129414_caseD_20:
      must_size = node->schema->padding[3];
      must = (lys_restr *)node->schema[1].dsc;
    }
    else {
      if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
        if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
          if ((LVar1 != LYS_UNKNOWN) && (true)) {
            switch(LVar1) {
            case LYS_CONTAINER:
              must_size = node->schema->padding[1];
              must = (lys_restr *)node->schema[1].dsc;
              break;
            default:
              goto switchD_00129414_caseD_2;
            case LYS_LEAF:
              must_size = node->schema->padding[3];
              must = (lys_restr *)node->schema[1].dsc;
              break;
            case LYS_LEAFLIST:
              must_size = node->schema->padding[3];
              must = (lys_restr *)node->schema[1].dsc;
              break;
            case LYS_LIST:
              must_size = node->schema->padding[0];
              must = (lys_restr *)node->schema[1].dsc;
              break;
            case LYS_ANYXML:
              goto switchD_00129414_caseD_20;
            }
            goto LAB_001294ec;
          }
        }
        else if (LVar1 == LYS_NOTIF) {
          must_size = node->schema->padding[1];
          must = (lys_restr *)node->schema[1].dsc;
          goto LAB_001294ec;
        }
      }
switchD_00129414_caseD_2:
      must_size = '\0';
    }
  }
  else {
    for (schema = lys_parent(node->schema);
        (schema != (lys_node *)0x0 && ((schema->nodetype & 0x1042) != LYS_UNKNOWN));
        schema = lys_parent(schema)) {
    }
    if ((schema == (lys_node *)0x0) || ((schema->nodetype & 0x600) == LYS_UNKNOWN)) {
      ly_log(ctx_00,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
             ,0x1877);
      iVar3 = -1;
      goto LAB_00129713;
    }
    must_size = schema->padding[1];
    must = (lys_restr *)schema[1].name;
    node_local = node->parent;
    if ((node_local->schema->nodetype & 0x4100) == LYS_UNKNOWN) {
      ly_log(ctx_00,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
             ,0x1880);
      iVar3 = -1;
      goto LAB_00129713;
    }
  }
LAB_001294ec:
  for (i = '\0'; i < must_size; i = i + '\x01') {
    plVar4 = lyd_node_module(node_local);
    iVar3 = lyxp_eval(must[i].expr,node_local,LYXP_NODE_ELEM,plVar4,&set,1);
    if (iVar3 != 0) {
      iVar3 = -1;
      goto LAB_00129713;
    }
    plVar4 = lyd_node_module(node_local);
    lyxp_set_cast(&set,LYXP_SET_BOOLEAN,node_local,plVar4,1);
    if (set.val.bool == 0) {
      if ((ignore_fail != 1) && (((must[i].flags & 0x600) == 0 || (ignore_fail != 2)))) {
        ly_vlog(ctx_00,LYE_NOMUST,LY_VLOG_LYD,node_local,must[i].expr);
        if (must[i].emsg != (char *)0x0) {
          ly_vlog_str(ctx_00,LY_VLOG_PREV,must[i].emsg);
        }
        if (must[i].eapptag != (char *)0x0) {
          ly_err_last_set_apptag(ctx_00,must[i].eapptag);
        }
        iVar3 = 1;
        goto LAB_00129713;
      }
      ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
             "Must condition \"%s\" not satisfied, but it is not required.",must[i].expr);
    }
  }
  iVar3 = 0;
LAB_00129713:
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void resolve_when_ctx_snode(lys_node *schema,lys_node **ctx_snode,lyxp_node_type *ctx_snode_type)

{
  lys_module *module;
  lyxp_node_type *ctx_snode_type_local;
  lys_node **ctx_snode_local;
  lys_node *schema_local;
  lys_node *sparent;
  
  *ctx_snode_type = LYXP_NODE_ELEM;
  schema_local = schema;
  do {
    if ((schema_local->nodetype & 0x3642) == LYS_UNKNOWN) {
LAB_001297ec:
      *ctx_snode = schema_local;
      return;
    }
    if (schema_local->nodetype == LYS_AUGMENT) {
      sparent = schema_local->prev;
    }
    else {
      sparent = schema_local->parent;
    }
    if (sparent == (lys_node *)0x0) {
      if ((schema_local->flags & 1) == 0) {
        *ctx_snode_type = LYXP_NODE_ROOT;
      }
      else {
        *ctx_snode_type = LYXP_NODE_ROOT_CONFIG;
      }
      module = lys_node_module(schema_local);
      schema_local = lys_getnext((lys_node *)0x0,(lys_node *)0x0,module,0x100);
      goto LAB_001297ec;
    }
    schema_local = sparent;
  } while( true );
}



int resolve_when_ctx_node
              (lyd_node *node,lys_node *schema,lyd_node **ctx_node,lyxp_node_type *ctx_node_type)

{
  int iVar1;
  long in_FS_OFFSET;
  lyxp_node_type *ctx_node_type_local;
  lyd_node **ctx_node_local;
  lys_node *schema_local;
  lyd_node *node_local;
  uint16_t i;
  uint16_t data_depth;
  uint16_t schema_depth;
  lyxp_node_type node_type;
  lyd_node *parent;
  lys_node *sparent;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  schema_local = schema;
  node_local = node;
  resolve_when_ctx_snode(schema,&schema_local,&node_type);
  if (node_type == LYXP_NODE_ELEM) {
    data_depth = 0;
    for (parent = node_local; parent != (lyd_node *)0x0; parent = parent->parent) {
      data_depth = data_depth + 1;
    }
    sparent = schema_local;
    schema_depth = 0;
    while (sparent != (lys_node *)0x0) {
      if ((sparent->nodetype & 0x81bd) != LYS_UNKNOWN) {
        schema_depth = schema_depth + 1;
      }
      if (sparent->nodetype == LYS_AUGMENT) {
        sparent = sparent->prev;
      }
      else {
        sparent = sparent->parent;
      }
    }
    if (data_depth < schema_depth) {
      iVar1 = -1;
      goto LAB_00129969;
    }
    for (i = 0; (int)(uint)i < (int)((uint)data_depth - (uint)schema_depth); i = i + 1) {
      node_local = node_local->parent;
    }
    if (node_local->schema != schema_local) {
      iVar1 = -1;
      goto LAB_00129969;
    }
  }
  else {
    for (; node_local->parent != (lyd_node *)0x0; node_local = node_local->parent) {
    }
    while (node_local->prev->next != (lyd_node *)0x0) {
      node_local = node_local->prev;
    }
  }
  *ctx_node = node_local;
  *ctx_node_type = node_type;
  iVar1 = 0;
LAB_00129969:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int resolve_when_unlink_nodes
              (lys_node *snode,lyd_node **node,lyd_node **ctx_node,lyxp_node_type ctx_node_type,
              lyd_node **unlinked_nodes)

{
  LYS_NODE LVar1;
  ly_ctx *ctx_00;
  int iVar2;
  lyd_node *plVar3;
  lyd_node **unlinked_nodes_local;
  lyxp_node_type ctx_node_type_local;
  lyd_node **ctx_node_local;
  lyd_node **node_local;
  lys_node *snode_local;
  lyd_node *next;
  lyd_node *elem;
  lys_node *slast;
  ly_ctx *ctx;
  
  ctx_00 = snode->module->ctx;
  LVar1 = snode->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_00129a24_caseD_1:
    plVar3 = lyd_first_sibling(*node);
    do {
      do {
        elem = plVar3;
        if (elem == (lyd_node *)0x0) {
          return 0;
        }
        plVar3 = elem->next;
      } while (snode != elem->schema);
      if (elem == *ctx_node) {
        if (ctx_node_type == LYXP_NODE_ELEM) {
          ly_log(ctx_00,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                 ,0x1954);
          return -1;
        }
        if (elem == elem->prev) {
          *ctx_node = (lyd_node *)0x0;
        }
        else {
          *ctx_node = elem->prev;
        }
      }
      else if (elem == *node) {
        if ((*node)->prev == *node) {
          *node = (lyd_node *)0x0;
        }
        else {
          *node = (*node)->prev;
        }
      }
      lyd_unlink_internal(elem,0);
      if (*unlinked_nodes == (lyd_node *)0x0) {
        *unlinked_nodes = elem;
      }
      else {
        iVar2 = lyd_insert_after((*unlinked_nodes)->prev,elem);
        if (iVar2 != 0) {
          ly_log(ctx_00,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                 ,0x1970);
          return -1;
        }
      }
    } while ((snode->nodetype & (LYS_CONTAINER|LYS_LEAF|LYS_ANYDATA)) == LYS_UNKNOWN);
  }
  else {
    if (LYS_ANYDATA < LVar1) goto switchD_00129a24_caseD_3;
    if (LVar1 != LYS_AUGMENT) {
      if (LYS_AUGMENT < LVar1) goto switchD_00129a24_caseD_3;
      if (LVar1 != LYS_USES) {
        if (LYS_USES < LVar1) goto switchD_00129a24_caseD_3;
        if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
          if ((LVar1 == LYS_UNKNOWN) || (false)) {
switchD_00129a24_caseD_3:
            ly_log(ctx_00,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                   ,0x197f);
            return -1;
          }
          switch(LVar1) {
          case LYS_CONTAINER:
          case LYS_LEAF:
          case LYS_LEAFLIST:
          case LYS_LIST:
          case LYS_ANYXML:
            goto switchD_00129a24_caseD_1;
          case LYS_CHOICE:
            goto switchD_00129a24_caseD_2;
          default:
            goto switchD_00129a24_caseD_3;
          }
        }
        if (LVar1 != LYS_CASE) goto switchD_00129a24_caseD_3;
      }
    }
switchD_00129a24_caseD_2:
    slast = (lys_node *)0x0;
    while (slast = lys_getnext(slast,snode,(lys_module *)0x0,0x80), slast != (lys_node *)0x0) {
      if (((slast->nodetype & 0x4080) == LYS_UNKNOWN) &&
         (iVar2 = resolve_when_unlink_nodes(slast,node,ctx_node,ctx_node_type,unlinked_nodes),
         iVar2 != 0)) {
        return -1;
      }
    }
  }
  return 0;
}



int resolve_when_relink_nodes(lyd_node *node,lyd_node *unlinked_nodes,lyxp_node_type ctx_node_type)

{
  lyd_node *plVar1;
  int iVar2;
  lyxp_node_type ctx_node_type_local;
  lyd_node *unlinked_nodes_local;
  lyd_node *node_local;
  lyd_node *elem;
  
  elem = unlinked_nodes;
  do {
    while( true ) {
      if (elem == (lyd_node *)0x0) {
        return 0;
      }
      plVar1 = elem->next;
      lyd_unlink_internal(elem,0);
      if (ctx_node_type != LYXP_NODE_ELEM) break;
      iVar2 = lyd_insert_common(node,(lyd_node **)0x0,elem,0);
      elem = plVar1;
      if (iVar2 != 0) {
        return -1;
      }
    }
    iVar2 = lyd_insert_nextto(node,elem,0,0);
    elem = plVar1;
  } while (iVar2 == 0);
  return -1;
}



int resolve_applies_must(lyd_node *node)

{
  LYS_NODE LVar1;
  lys_node *node_00;
  lyd_node *node_local;
  uint8_t must_size;
  int ret;
  lys_node *iter;
  lys_node *schema;
  
  if (node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x19ad,"resolve_applies_must");
  }
  node_00 = node->schema;
  LVar1 = node_00->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_00129dcd_caseD_20:
    must_size = node_00->padding[3];
    goto LAB_00129e2c;
  }
  if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
    if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
      if ((LVar1 != LYS_UNKNOWN) && (true)) {
        switch(LVar1) {
        case LYS_CONTAINER:
          must_size = node_00->padding[1];
          break;
        default:
          goto switchD_00129dcd_caseD_2;
        case LYS_LEAF:
          must_size = node_00->padding[3];
          break;
        case LYS_LEAFLIST:
          must_size = node_00->padding[3];
          break;
        case LYS_LIST:
          must_size = node_00->padding[0];
          break;
        case LYS_ANYXML:
          goto switchD_00129dcd_caseD_20;
        }
        goto LAB_00129e2c;
      }
    }
    else if (LVar1 == LYS_NOTIF) {
      must_size = node_00->padding[1];
      goto LAB_00129e2c;
    }
  }
switchD_00129dcd_caseD_2:
  must_size = '\0';
LAB_00129e2c:
  ret = (int)(must_size != '\0');
  if (node->prev->next == (lyd_node *)0x0) {
    for (iter = lys_parent(node_00);
        (iter != (lys_node *)0x0 && ((iter->nodetype & 0x1042) != LYS_UNKNOWN));
        iter = lys_parent(iter)) {
    }
    if ((iter != (lys_node *)0x0) && ((iter->nodetype & 0x600) != LYS_UNKNOWN)) {
      ret = ret + 2;
    }
  }
  return ret;
}



lys_when * snode_get_when(lys_node *schema)

{
  LYS_NODE LVar1;
  lys_node *schema_local;
  
  LVar1 = schema->nodetype;
  if (LVar1 != LYS_ANYDATA) {
    if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
      if (LVar1 == LYS_AUGMENT) {
        return (lys_when *)schema->next;
      }
      if (LVar1 < (LYS_CONTAINER|LYS_AUGMENT)) {
        if (LVar1 == LYS_USES) {
          return *(lys_when **)schema->hash;
        }
        if (LVar1 < (LYS_CONTAINER|LYS_USES)) {
          if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
            if ((LVar1 != LYS_UNKNOWN) && (true)) {
              switch(LVar1) {
              case LYS_CONTAINER:
                return (lys_when *)schema[1].name;
              case LYS_CHOICE:
                return *(lys_when **)schema->hash;
              case LYS_LEAF:
                return (lys_when *)schema[1].name;
              case LYS_LEAFLIST:
                return (lys_when *)schema[1].name;
              case LYS_LIST:
                return (lys_when *)schema[1].name;
              case LYS_ANYXML:
                goto switchD_00129f2b_caseD_20;
              }
            }
          }
          else if (LVar1 == LYS_CASE) {
            return *(lys_when **)schema->hash;
          }
        }
      }
    }
    return (lys_when *)0x0;
  }
switchD_00129f2b_caseD_20:
  return (lys_when *)schema[1].name;
}



int resolve_applies_when(lys_node *schema,int mode,lys_node *stop)

{
  lys_when *plVar1;
  lys_node *stop_local;
  int mode_local;
  lys_node *schema_local;
  lys_node *parent;
  
  if (schema == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("schema",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x19fb,"resolve_applies_when");
  }
  parent = schema;
  if ((schema->nodetype & 0x180) != LYS_UNKNOWN) goto LAB_0012a043;
  plVar1 = snode_get_when(schema);
  while( true ) {
    if (plVar1 != (lys_when *)0x0) {
      return 1;
    }
LAB_0012a043:
    if (((parent->parent != (lys_node *)0x0) && (parent->parent->nodetype == LYS_AUGMENT)) &&
       (plVar1 = snode_get_when(parent->parent), plVar1 != (lys_when *)0x0)) break;
    parent = lys_parent(parent);
    if (parent == (lys_node *)0x0) {
      return 0;
    }
    if (mode == 0) {
      if ((parent->nodetype & 0x1042) == LYS_UNKNOWN) {
        return 0;
      }
    }
    else if (parent == stop) {
      return 0;
    }
    plVar1 = snode_get_when(parent);
  }
  return 1;
}



int resolve_when(lyd_node *node,int ignore_fail,lys_when **failed_when)

{
  long lVar1;
  lyxp_node_type lVar2;
  lyd_node *plVar3;
  int iVar4;
  lys_when *plVar5;
  lys_module *plVar6;
  long in_FS_OFFSET;
  lys_when **failed_when_local;
  int ignore_fail_local;
  lyd_node *node_local;
  lyxp_node_type ctx_node_type;
  int rc;
  lyd_node *ctx_node;
  lyd_node *unlinked_nodes;
  lyd_node *tmp_node;
  lys_node *sparent;
  ly_ctx *ctx;
  lyxp_set set;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ctx_node = (lyd_node *)0x0;
  ctx = node->schema->module->ctx;
  rc = 0;
  if (node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x1a38,"resolve_when");
  }
  memset(&set,0,0x40);
  if (((node->schema->nodetype & 0x4180) == LYS_UNKNOWN) &&
     (plVar5 = snode_get_when(node->schema), plVar5 != (lys_when *)0x0)) {
    node->validity = node->validity | 0x80;
    plVar6 = lyd_node_module(node);
    plVar5 = snode_get_when(node->schema);
    rc = lyxp_eval(plVar5->cond,node,LYXP_NODE_ELEM,plVar6,&set,2);
    node->validity = node->validity & 0x7f;
    if (rc != 0) {
      if (rc == 1) {
        plVar5 = snode_get_when(node->schema);
        ly_vlog(ctx,LYE_INWHEN,LY_VLOG_LYD,node,plVar5->cond);
      }
      goto LAB_0012aae1;
    }
    plVar6 = lyd_node_module(node);
    lyxp_set_cast(&set,LYXP_SET_BOOLEAN,node,plVar6,2);
    if (set.val.bool == 0) {
      node->field_0x9 = node->field_0x9 & 0xf1 | ((byte)node->field_0x9 >> 1 & 7 | 1) * '\x02';
      if ((ignore_fail != 1) &&
         ((plVar5 = snode_get_when(node->schema), (plVar5->flags & 0x600) == 0 || (ignore_fail != 2)
          ))) {
        plVar5 = snode_get_when(node->schema);
        ly_vlog(ctx,LYE_NOWHEN,LY_VLOG_LYD,node,plVar5->cond);
        if (failed_when != (lys_when **)0x0) {
          plVar5 = snode_get_when(node->schema);
          *failed_when = plVar5;
        }
        goto LAB_0012aae1;
      }
      plVar5 = snode_get_when(node->schema);
      ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
             "When condition \"%s\" is not satisfied, but it is not required.",plVar5->cond);
    }
    plVar6 = lyd_node_module(node);
    lyxp_set_cast(&set,LYXP_SET_EMPTY,node,plVar6,0);
  }
  sparent = node->schema;
  while( true ) {
    if (((sparent->parent != (lys_node *)0x0) && (sparent->parent->nodetype == LYS_AUGMENT)) &&
       (plVar5 = snode_get_when(sparent->parent), plVar5 != (lys_when *)0x0)) {
      if ((ctx_node == (lyd_node *)0x0) &&
         (rc = resolve_when_ctx_node(node,sparent->parent,&ctx_node,&ctx_node_type), rc != 0)) {
        ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
               ,0x1a9b);
        goto LAB_0012aae1;
      }
      unlinked_nodes = (lyd_node *)0x0;
      tmp_node = node;
      rc = resolve_when_unlink_nodes
                     (sparent->parent,&tmp_node,&ctx_node,ctx_node_type,&unlinked_nodes);
      if (rc != 0) goto LAB_0012aae1;
      plVar6 = lys_node_module(sparent->parent);
      plVar3 = ctx_node;
      lVar2 = ctx_node_type;
      plVar5 = snode_get_when(sparent->parent);
      rc = lyxp_eval(plVar5->cond,plVar3,lVar2,plVar6,&set,2);
      if (((unlinked_nodes != (lyd_node *)0x0) && (ctx_node != (lyd_node *)0x0)) &&
         (iVar4 = resolve_when_relink_nodes(ctx_node,unlinked_nodes,ctx_node_type), iVar4 != 0)) {
        rc = -1;
        goto LAB_0012aae1;
      }
      if (rc != 0) {
        if (rc == 1) {
          plVar5 = snode_get_when(sparent->parent);
          ly_vlog(ctx,LYE_INWHEN,LY_VLOG_LYD,node,plVar5->cond);
        }
        goto LAB_0012aae1;
      }
      plVar6 = lys_node_module(sparent->parent);
      lyxp_set_cast(&set,LYXP_SET_BOOLEAN,ctx_node,plVar6,2);
      if (set.val.bool == 0) {
        node->field_0x9 = node->field_0x9 & 0xf1 | ((byte)node->field_0x9 >> 1 & 7 | 1) * '\x02';
        if ((ignore_fail != 1) &&
           ((plVar5 = snode_get_when(sparent->parent), (plVar5->flags & 0x600) == 0 ||
            (ignore_fail != 2)))) {
          plVar5 = snode_get_when(sparent->parent);
          ly_vlog(ctx,LYE_NOWHEN,LY_VLOG_LYD,node,plVar5->cond);
          if (failed_when != (lys_when **)0x0) {
            plVar5 = snode_get_when(sparent->parent);
            *failed_when = plVar5;
          }
          goto LAB_0012aae1;
        }
        plVar5 = snode_get_when(sparent->parent);
        ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
               "When condition \"%s\" is not satisfied, but it is not required.",plVar5->cond);
      }
      plVar6 = lys_node_module(sparent->parent);
      lyxp_set_cast(&set,LYXP_SET_EMPTY,ctx_node,plVar6,0);
    }
    sparent = lys_parent(sparent);
    if ((sparent == (lys_node *)0x0) || ((sparent->nodetype & 0x1042) == LYS_UNKNOWN)) break;
    plVar5 = snode_get_when(sparent);
    if (plVar5 != (lys_when *)0x0) {
      if ((ctx_node == (lyd_node *)0x0) &&
         (rc = resolve_when_ctx_node(node,sparent,&ctx_node,&ctx_node_type), rc != 0)) {
        ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
               ,0x1a65);
        goto LAB_0012aae1;
      }
      unlinked_nodes = (lyd_node *)0x0;
      tmp_node = node;
      rc = resolve_when_unlink_nodes(sparent,&tmp_node,&ctx_node,ctx_node_type,&unlinked_nodes);
      if (rc != 0) goto LAB_0012aae1;
      plVar6 = lys_node_module(sparent);
      plVar3 = ctx_node;
      lVar2 = ctx_node_type;
      plVar5 = snode_get_when(sparent);
      rc = lyxp_eval(plVar5->cond,plVar3,lVar2,plVar6,&set,2);
      if (((unlinked_nodes != (lyd_node *)0x0) && (ctx_node != (lyd_node *)0x0)) &&
         (iVar4 = resolve_when_relink_nodes(ctx_node,unlinked_nodes,ctx_node_type), iVar4 != 0)) {
        rc = -1;
        goto LAB_0012aae1;
      }
      if (rc != 0) {
        if (rc == 1) {
          plVar5 = snode_get_when(sparent);
          ly_vlog(ctx,LYE_INWHEN,LY_VLOG_LYD,node,plVar5->cond);
        }
        goto LAB_0012aae1;
      }
      plVar6 = lys_node_module(sparent);
      lyxp_set_cast(&set,LYXP_SET_BOOLEAN,ctx_node,plVar6,2);
      if (set.val.bool == 0) {
        if ((ignore_fail != 1) &&
           ((plVar5 = snode_get_when(sparent), (plVar5->flags & 0x600) == 0 || (ignore_fail != 2))))
        {
          node->field_0x9 = node->field_0x9 & 0xf1 | ((byte)node->field_0x9 >> 1 & 7 | 1) * '\x02';
          plVar5 = snode_get_when(sparent);
          ly_vlog(ctx,LYE_NOWHEN,LY_VLOG_LYD,node,plVar5->cond);
          if (failed_when != (lys_when **)0x0) {
            plVar5 = snode_get_when(sparent);
            *failed_when = plVar5;
          }
          goto LAB_0012aae1;
        }
        plVar5 = snode_get_when(sparent);
        ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
               "When condition \"%s\" is not satisfied, but it is not required.",plVar5->cond);
      }
      plVar6 = lys_node_module(sparent);
      lyxp_set_cast(&set,LYXP_SET_EMPTY,ctx_node,plVar6,0);
    }
  }
  node->field_0x9 = node->field_0x9 & 0xf1 | ((byte)node->field_0x9 >> 1 & 7 | 2) * '\x02';
LAB_0012aae1:
  if (ctx_node != (lyd_node *)0x0) {
    node = ctx_node;
  }
  lyxp_set_cast(&set,LYXP_SET_EMPTY,node,(lys_module *)0x0,0);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return rc;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int check_type_union_leafref(lys_type *type)

{
  int iVar1;
  uint uVar2;
  lys_type *type_local;
  uint8_t i;
  
  if ((type->base == LY_TYPE_UNION) && ((type->info).bits.count != 0)) {
    for (i = '\0'; (uint)i < (type->info).bits.count; i = i + '\x01') {
      iVar1 = *(int *)((long)(type->info).bits.bit + (ulong)i * 0x40);
      if (iVar1 == 9) {
        return 1;
      }
      if ((iVar1 == 0xb) &&
         (iVar1 = check_type_union_leafref
                            ((lys_type *)((long)(type->info).bits.bit + (ulong)i * 0x40)),
         iVar1 != 0)) {
        return 1;
      }
    }
    uVar2 = 0;
  }
  else {
    uVar2 = (uint)type->der->has_union_leafref;
  }
  return uVar2;
}



int resolve_unres_schema_item
              (lys_module *mod,void *item,UNRES_ITEM type,void *str_snode,unres_schema *unres)

{
  lys_ext_instance **pplVar1;
  int iVar2;
  size_t sVar3;
  ly_set *plVar4;
  lys_node *plVar5;
  lys_ext_instance *plVar6;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  void *str_snode_local;
  UNRES_ITEM type_local;
  void *item_local;
  lys_module *mod_local;
  uint j;
  int rc;
  int has_str;
  int parent_type;
  int i;
  int k;
  lys_node *next;
  lys_node *node;
  lys_node *par_grp;
  ly_ctx *ctx;
  uint8_t *u;
  lys_ext_instance *ext;
  lyext_plugin *eplugin;
  lys_node *root;
  lys_ext_instance **extlist;
  unres_ext *ext_data;
  unres_list_uniq *unique_info;
  lys_type *stype;
  lys_feature *feat;
  ly_set *refs;
  ly_set *procs;
  lys_feature *ref;
  char *expr;
  lys_ident *ident;
  lys_node_choice *choic;
  lyxml_elem *yin;
  yang_type *yang;
  unres_iffeat_data *iff_data;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  rc = -1;
  has_str = 0;
  parent_type = 0;
  ctx = mod->ctx;
  if (type == UNRES_EXT_FINALIZE) {
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
    ext = *(lys_ext_instance **)((ulong)*str_snode * 8 + *item);
    u = (uint8_t *)str_snode;
    free(str_snode);
    eplugin = ext->def->plugin;
    if ((((eplugin->flags & 1) != 0) && (ext->parent_type == '\x01')) &&
       (root = (lys_node *)ext->parent,
       (root->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN)) {
      next = root->child;
      while (node = next, next != (lys_node *)0x0) {
        iVar2 = lys_ext_instance_presence(ext->def,next->ext,next->ext_size);
        if ((iVar2 == -1) &&
           (((root == node->parent || (node->parent->nodetype != LYS_AUGMENT)) ||
            (iVar2 = lys_ext_instance_presence(ext->def,node->parent->ext,node->parent->ext_size),
            iVar2 == -1)))) {
          if (eplugin->check_inherit == (lyext_check_inherit_clb)0x0) {
LAB_0012bc07:
            extlist = (lys_ext_instance **)realloc(node->ext,(long)(int)(node->ext_size + 1) * 8);
            if (extlist == (lys_ext_instance **)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "resolve_unres_schema_item");
              iVar2 = -1;
              goto LAB_0012bf64;
            }
            pplVar1 = extlist + node->ext_size;
            plVar6 = (lys_ext_instance *)malloc(0x40);
            *pplVar1 = plVar6;
            if (extlist[node->ext_size] == (lys_ext_instance *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "resolve_unres_schema_item");
              node->ext = extlist;
              iVar2 = -1;
              goto LAB_0012bf64;
            }
            memcpy(extlist[node->ext_size],ext,0x40);
            extlist[node->ext_size]->flags = extlist[node->ext_size]->flags | 1;
            node->ext = extlist;
            node->ext_size = node->ext_size + '\x01';
          }
          else {
            rc = (*eplugin->check_inherit)(ext,node);
            if (rc != 2) {
              if (rc < 3) {
                if (rc == 0) goto LAB_0012bc07;
                if (rc == 1) goto LAB_0012be1a;
              }
              ly_log(ctx,LY_LLERR,LY_EINT,
                     "Plugin\'s (%s:%s) check_inherit callback returns invalid value (%d),",
                     ext->def->module->name,ext->def->name,(ulong)(uint)rc);
              goto LAB_0012bc07;
            }
          }
          if ((node->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
            next = node->child;
          }
          else {
            next = (lys_node *)0x0;
          }
          if (next == (lys_node *)0x0) goto LAB_0012be1a;
        }
        else {
LAB_0012be1a:
          next = node->next;
        }
        while ((next == (lys_node *)0x0 && (node = lys_parent(node), node != root))) {
          next = node->next;
        }
      }
    }
    if ((eplugin->check_result != (lyext_check_result_clb)0x0) &&
       (iVar2 = (*eplugin->check_result)(ext), iVar2 != 0)) {
      ly_log(ctx,LY_LLERR,LY_EPLUGIN,"Resolving extension failed.");
      iVar2 = -1;
      goto LAB_0012bf64;
    }
    rc = 0;
    goto LAB_0012bf33;
  }
  if (UNRES_EXT_FINALIZE < type) goto switchD_0012ae1e_caseD_3;
  if (type == UNRES_XPATH) {
    node = (lys_node *)item;
    rc = check_xpath((lys_node *)item,1);
    goto LAB_0012bf33;
  }
  if (UNRES_XPATH < type) goto switchD_0012ae1e_caseD_3;
  if (type == UNRES_EXT) {
                    // WARNING: Load size is inaccurate
    extlist = (lys_ext_instance **)((ulong)*(byte *)((long)str_snode + 0x29) * 8 + *item);
    ext_data = (unres_ext *)str_snode;
    rc = resolve_extension((unres_ext *)str_snode,extlist,unres);
    if (((rc == 0) && (eplugin = (*extlist)->def->plugin, eplugin != (lyext_plugin *)0x0)) &&
       ((eplugin->check_result != (lyext_check_result_clb)0x0 || ((eplugin->flags & 1) != 0)))) {
      u = (uint8_t *)malloc(1);
      if ((lys_node *)u == (lys_node *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_unres_schema_item");
        iVar2 = -1;
        goto LAB_0012bf64;
      }
      *(uint8_t *)&((lys_node *)u)->name = ext_data->ext_index;
      iVar2 = unres_schema_add_node(mod,unres,item,UNRES_EXT_FINALIZE,(lys_node *)u);
      if (iVar2 == -1) {
        iVar2 = -1;
        goto LAB_0012bf64;
      }
    }
    if ((rc == 0) || (rc == -1)) {
      if (ext_data->datatype == LYS_IN_YIN) {
        lyxml_free(ctx,(ext_data->data).yin);
      }
      else {
        yang_free_ext_data((ext_data->data).yang);
      }
      free(ext_data);
    }
    goto LAB_0012bf33;
  }
  if (UNRES_EXT < type) goto switchD_0012ae1e_caseD_3;
  if (type == UNRES_MOD_IMPLEMENT) {
    rc = lys_make_implemented_r(mod,unres);
    goto LAB_0012bf33;
  }
  if (UNRES_MOD_IMPLEMENT < type) goto switchD_0012ae1e_caseD_3;
  if (type == UNRES_LIST_UNIQ) {
                    // WARNING: Load size is inaccurate
    unique_info = (unres_list_uniq *)item;
    rc = resolve_unique(*item,*(char **)((long)item + 8),*(uint8_t **)((long)item + 0x10));
    goto LAB_0012bf33;
  }
  if (UNRES_LIST_UNIQ < type) goto switchD_0012ae1e_caseD_3;
  if (type == UNRES_LIST_KEYS) {
    rc = resolve_list_keys((lys_node_list *)item,*(char **)((long)item + 0xa0));
    goto LAB_0012bf33;
  }
  if (UNRES_LIST_KEYS < type) goto switchD_0012ae1e_caseD_3;
  if (type == UNRES_TYPE_DFLT) {
LAB_0012b619:
    stype = (lys_type *)item;
    rc = check_default((lys_type *)item,(char **)str_snode,mod,parent_type);
    if (((rc == 1) && (parent_type == 0)) && (stype->base == LY_TYPE_LEAFREF)) {
      for (par_grp = (lys_node *)stype->parent;
          (par_grp != (lys_node *)0x0 && (par_grp->nodetype != LYS_GROUPING));
          par_grp = lys_parent(par_grp)) {
      }
      if (par_grp != (lys_node *)0x0) {
        rc = 0;
      }
    }
    goto LAB_0012bf33;
  }
  if (UNRES_TYPE_DFLT < type) goto switchD_0012ae1e_caseD_3;
  if (type == UNRES_TYPEDEF_DFLT) {
    parent_type = 1;
    goto LAB_0012b619;
  }
  if (UNRES_TYPEDEF_DFLT < type) goto switchD_0012ae1e_caseD_3;
  if (type == UNRES_FEATURE) {
    feat = (lys_feature *)item;
    if (*(char *)((long)item + 0x1b) != '\0') {
      refs = ly_set_new();
      procs = ly_set_new();
      ly_set_add(procs,feat,0);
      while (procs->number != 0) {
        ref = (lys_feature *)(procs->set).s[procs->number - 1];
        ly_set_rm_index(procs,procs->number - 1);
        for (i = 0; i < (int)(uint)ref->iffeature_size; i = i + 1) {
          resolve_iffeature_getsizes(ref->iffeature + i,(uint *)0x0,&j);
          for (; j != 0; j = j - 1) {
            if (ref->iffeature[i].features[j - 1] == (lys_feature *)0x0) {
              rc = 1;
              goto LAB_0012b5d1;
            }
            if (feat == ref->iffeature[i].features[j - 1]) {
              ly_vlog(ctx,LYE_CIRC_FEATURES,LY_VLOG_NONE,(void *)0x0,feat->name);
              goto LAB_0012b5d1;
            }
            if (ref->iffeature[i].features[j - 1]->iffeature_size != '\0') {
              k = refs->number;
              iVar2 = ly_set_add(refs,ref->iffeature[i].features[j - 1],0);
              if (k == iVar2) {
                ly_set_add(procs,ref->iffeature[i].features[j - 1],0);
              }
            }
          }
        }
      }
      rc = 0;
LAB_0012b5d1:
      ly_set_free(refs);
      ly_set_free(procs);
    }
    goto LAB_0012bf33;
  }
  if (UNRES_FEATURE < type) goto switchD_0012ae1e_caseD_3;
  if (type == UNRES_TYPE_IDENTREF) {
    has_str = 1;
    stype = (lys_type *)item;
    expr = (char *)str_snode;
    rc = resolve_base_ident(mod,(lys_ident *)0x0,(char *)str_snode,"type",(lys_type *)item,unres);
    goto LAB_0012bf33;
  }
  if (UNRES_TYPE_IDENTREF < type) goto switchD_0012ae1e_caseD_3;
  if (type == UNRES_IDENT) {
    has_str = 1;
    expr = (char *)str_snode;
    ident = (lys_ident *)item;
    rc = resolve_base_ident(mod,(lys_ident *)item,(char *)str_snode,"identity",(lys_type *)0x0,unres
                           );
    goto LAB_0012bf33;
  }
  if (UNRES_IDENT < type) goto switchD_0012ae1e_caseD_3;
  if (type == UNRES_CHOICE_DFLT) {
    has_str = 1;
    expr = (char *)str_snode;
    choic = (lys_node_choice *)item;
    if (*(long *)((long)item + 0x70) == 0) {
      plVar5 = resolve_choice_dflt((lys_node_choice *)item,(char *)str_snode);
      choic->dflt = plVar5;
    }
    if (choic->dflt == (lys_node *)0x0) {
      rc = 1;
    }
    else {
      rc = lyp_check_mandatory_choice((lys_node *)choic);
    }
    goto LAB_0012bf33;
  }
  if (UNRES_CHOICE_DFLT < type) {
switchD_0012ae1e_caseD_3:
    ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
           ,0x1c63);
    goto LAB_0012bf33;
  }
  if (UNRES_TYPE_LEAFREF < type) {
    if (type == UNRES_AUGMENT) {
      rc = resolve_augment((lys_node_augment *)item,(lys_node *)0x0,unres);
      goto LAB_0012bf33;
    }
    goto switchD_0012ae1e_caseD_3;
  }
  if ((type == 0) || (false)) goto switchD_0012ae1e_caseD_3;
  switch(type) {
  case UNRES_USES:
    rc = resolve_unres_schema_uses((lys_node_uses *)item,unres);
    break;
  case UNRES_IFFEAT:
                    // WARNING: Load size is inaccurate
    plVar5 = *str_snode;
    iff_data = (unres_iffeat_data *)str_snode;
    sVar3 = strlen(*(char **)((long)str_snode + 8));
    rc = resolve_feature(iff_data->fname,(uint16_t)sVar3,plVar5,(lys_feature **)item);
    if (rc == 0) {
      if (iff_data->infeature != 0) {
                    // WARNING: Load size is inaccurate
        feat = *item;
        if (feat->depfeatures == (ly_set *)0x0) {
          plVar4 = ly_set_new();
          feat->depfeatures = plVar4;
        }
        ly_set_add(feat->depfeatures,iff_data->node,1);
      }
      lydict_remove(ctx,iff_data->fname);
      free(iff_data);
    }
    break;
  default:
    goto switchD_0012ae1e_caseD_3;
  case UNRES_TYPE_DER:
    goto switchD_0012ae1e_caseD_4;
  case UNRES_TYPE_DER_TPDF:
    goto switchD_0012ae1e_caseD_8;
  case UNRES_TYPE_DER_EXT:
    parent_type = 1;
    goto switchD_0012ae1e_caseD_8;
  case UNRES_TYPE_LEAFREF:
    node = (lys_node *)str_snode;
    stype = (lys_type *)item;
    rc = resolve_schema_leafref((lys_type *)item,(lys_node *)str_snode,unres);
  }
  goto LAB_0012bf33;
switchD_0012ae1e_caseD_8:
  parent_type = parent_type + 1;
switchD_0012ae1e_caseD_4:
  yin = *(lyxml_elem **)((long)item + 0x10);
  *(undefined8 *)((long)item + 0x10) = 0;
  if (yin->flags < '\0') {
    node = (lys_node *)str_snode;
    stype = (lys_type *)item;
    yang = (yang_type *)yin;
    rc = yang_check_type(mod,(lys_node *)str_snode,(yang_type *)yin,(lys_type *)item,parent_type,
                         unres);
    if (rc == 0) {
      lydict_remove(ctx,yang->name);
      free(yang);
    }
    else {
      stype->der = (lys_tpdf *)yang;
    }
  }
  else {
    node = (lys_node *)str_snode;
    stype = (lys_type *)item;
    rc = fill_yin_type(mod,(lys_node *)str_snode,yin,(lys_type *)item,parent_type,unres);
    if ((rc == 0) || (rc == -1)) {
      lyxml_free(ctx,yin);
    }
    else {
      stype->der = (lys_tpdf *)yin;
    }
  }
  if (rc == 0) {
    if (((parent_type == 0) && (node->nodetype == LYS_LEAFLIST)) && (stype->base == LY_TYPE_EMPTY))
    {
      ly_log(ctx,LY_LLWRN,LY_SUCCESS,
             "The leaf-list \"%s\" is of \"empty\" type, which does not make sense.",node->name);
    }
    if ((type == UNRES_TYPE_DER_TPDF) && (stype->base == LY_TYPE_UNION)) {
      iVar2 = check_type_union_leafref(stype);
      stype->parent->has_union_leafref = (uint8_t)iVar2;
    }
    else if ((type == UNRES_TYPE_DER) &&
            ((stype->der->has_union_leafref != '\0' &&
             (iVar2 = lys_copy_union_leafrefs(mod,node,stype,(lys_type *)0x0,unres), iVar2 != 0))))
    {
      ly_log(ctx,LY_LLERR,LY_EINT,"Failed to duplicate type.");
      iVar2 = -1;
      goto LAB_0012bf64;
    }
  }
  else if ((rc == 1) && (-1 < (char)stype->value_flags)) {
    for (par_grp = node; (par_grp != (lys_node *)0x0 && (par_grp->nodetype != LYS_GROUPING));
        par_grp = lys_parent(par_grp)) {
    }
    if (par_grp != (lys_node *)0x0) {
      *(short *)par_grp->padding = *(short *)par_grp->padding + 1;
      if (*(short *)par_grp->padding == 0) {
        ly_log(ctx,LY_LLERR,LY_EINT,"Too many unresolved items (type) inside a grouping.");
        iVar2 = -1;
        goto LAB_0012bf64;
      }
      stype->value_flags = stype->value_flags | 0x80;
    }
  }
LAB_0012bf33:
  iVar2 = rc;
  if ((has_str != 0) && (rc == 0)) {
    lydict_remove(ctx,(char *)str_snode);
    iVar2 = rc;
  }
LAB_0012bf64:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void print_unres_schema_item_fail(void *item,UNRES_ITEM type,void *str_node)

{
  char *pcVar1;
  int iVar2;
  undefined8 uVar3;
  void *str_node_local;
  UNRES_ITEM type_local;
  void *item_local;
  lyxml_attr *attr;
  char *name;
  unres_ext *extinfo;
  lyxml_elem *xml;
  unres_iffeat_data *iff_data;
  
  name = (char *)0x0;
  if (type == UNRES_XPATH) {
                    // WARNING: Load size is inaccurate
    ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
           "Resolving %s \"%s\" failed, it will be attempted later.","XPath expressions of",*item);
    return;
  }
  if (type < (UNRES_USES|UNRES_XPATH)) {
    if (type == UNRES_EXT) {
      if (*(int *)((long)str_node + 8) == 2) {
                    // WARNING: Load size is inaccurate
        uVar3 = *(undefined8 *)(*str_node + 0x30);
      }
      else {
        uVar3 = 0;
      }
      ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
             "Resolving extension \"%s\" failed, it will be attempted later.",uVar3);
      return;
    }
    if (type < (UNRES_USES|UNRES_EXT)) {
      if (type == UNRES_LIST_UNIQ) {
        ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
               "Resolving %s \"%s\" failed, it will be attempted later.","list unique",str_node);
        return;
      }
      if (type < (UNRES_USES|UNRES_LIST_UNIQ)) {
        if (type == UNRES_LIST_KEYS) {
          ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                 "Resolving %s \"%s\" failed, it will be attempted later.","list keys",str_node);
          return;
        }
        if (type < (UNRES_USES|UNRES_LIST_KEYS)) {
          if (type == UNRES_TYPE_DFLT) {
LAB_0012c2fe:
                    // WARNING: Load size is inaccurate
            if (*str_node == 0) {
              return;
            }
                    // WARNING: Load size is inaccurate
            ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                   "Resolving %s \"%s\" failed, it will be attempted later.","type default",
                   *str_node);
            return;
          }
          if (type < (UNRES_USES|UNRES_TYPE_DFLT)) {
            if (type == UNRES_TYPEDEF_DFLT) goto LAB_0012c2fe;
            if (type < (UNRES_USES|UNRES_TYPEDEF_DFLT)) {
              if (type == UNRES_FEATURE) {
                    // WARNING: Load size is inaccurate
                ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                       "There are unresolved if-features for \"%s\" feature circular dependency check, it will be attempted later"
                       ,*item);
                return;
              }
              if (type < (UNRES_USES|UNRES_FEATURE)) {
                if (type == UNRES_TYPE_IDENTREF) {
                  ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                         "Resolving %s \"%s\" failed, it will be attempted later.","identityref",
                         str_node);
                  return;
                }
                if (type < (UNRES_USES|UNRES_TYPE_IDENTREF)) {
                  if (type == UNRES_IDENT) {
                    ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                           "Resolving %s \"%s\" failed, it will be attempted later.","identity",
                           str_node);
                    return;
                  }
                  if (type < (UNRES_USES|UNRES_IDENT)) {
                    if (type == UNRES_CHOICE_DFLT) {
                      ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                             "Resolving %s \"%s\" failed, it will be attempted later.",
                             "choice default",str_node);
                      return;
                    }
                    if (type < (UNRES_USES|UNRES_CHOICE_DFLT)) {
                      if (type < (UNRES_USES|UNRES_TYPE_LEAFREF)) {
                        if ((type != 0) && (true)) {
                          switch(type) {
                          case UNRES_USES:
                    // WARNING: Load size is inaccurate
                            ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                                   "Resolving %s \"%s\" failed, it will be attempted later.",
                                   &DAT_0020f894,*item);
                            return;
                          case UNRES_IFFEAT:
                            ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                                   "Resolving %s \"%s\" failed, it will be attempted later.",
                                   "if-feature",*(undefined8 *)((long)str_node + 8));
                            return;
                          case UNRES_TYPE_DER:
                          case UNRES_TYPE_DER_TPDF:
                          case UNRES_TYPE_DER_EXT:
                            pcVar1 = *(char **)((long)item + 0x10);
                            if (*pcVar1 < '\0') {
                              name = *(char **)(pcVar1 + 8);
                            }
                            else {
                              for (attr = *(lyxml_attr **)(pcVar1 + 0x10); attr != (lyxml_attr *)0x0
                                  ; attr = attr->next) {
                                if ((attr->type == LYXML_ATTR_STD) &&
                                   (iVar2 = strcmp(attr->name,"name"), iVar2 == 0)) {
                                  name = attr->value;
                                  break;
                                }
                              }
                              if (attr == (lyxml_attr *)0x0) {
                    // WARNING: Subroutine does not return
                                __assert_fail("attr",
                                              "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                                              ,0x1c92,"print_unres_schema_item_fail");
                              }
                            }
                            ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                                   "Resolving %s \"%s\" failed, it will be attempted later.",
                                   "derived type",name);
                            return;
                          case UNRES_TYPE_LEAFREF:
                            ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                                   "Resolving %s \"%s\" failed, it will be attempted later.",
                                   "leafref",*(undefined8 *)((long)item + 0x20));
                            return;
                          }
                        }
                      }
                      else if (type == UNRES_AUGMENT) {
                    // WARNING: Load size is inaccurate
                        ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                               "Resolving %s \"%s\" failed, it will be attempted later.",
                               "augment target",*item);
                        return;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
         ,0x1cc0);
  return;
}



int resolve_unres_schema_types
              (unres_schema *unres,UNRES_ITEM types,ly_ctx *ctx,int forward_ref,int print_all_errors
              ,uint32_t *resolved)

{
  int iVar1;
  LY_ERR *pLVar2;
  long in_FS_OFFSET;
  uint32_t *resolved_local;
  int print_all_errors_local;
  ly_ctx *ctx_local;
  int forward_ref_local;
  UNRES_ITEM types_local;
  unres_schema *unres_local;
  int_log_opts prev_ilo;
  uint32_t i;
  uint32_t unres_count;
  uint32_t res_count;
  int ret;
  LY_ERR prev_ly_errno;
  int rc;
  ly_err_item *prev_eitem;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  if (forward_ref != 0) {
    pLVar2 = ly_errno_glob_address();
    prev_ly_errno = *pLVar2;
    ly_ilo_change(ctx,ILO_STORE,&prev_ilo,&prev_eitem);
  }
  do {
    unres_count = 0;
    res_count = 0;
    for (i = 0; i < unres->count; i = i + 1) {
      if ((unres->type[i] & types) != 0) {
        unres_count = unres_count + 1;
        rc = resolve_unres_schema_item
                       (unres->module[i],unres->item[i],unres->type[i],unres->str_snode[i],unres);
        if (unres->type[i] == UNRES_EXT_FINALIZE) {
          unres->type[i] = UNRES_RESOLVED;
        }
        if ((rc == 0) || (unres->type[i] == UNRES_XPATH)) {
          if (unres->type[i] == UNRES_LIST_UNIQ) {
            free(unres->item[i]);
          }
          unres->type[i] = UNRES_RESOLVED;
          *resolved = *resolved + 1;
          res_count = res_count + 1;
        }
        else if ((rc == 1) && (forward_ref != 0)) {
          ly_err_free_next(ctx,prev_eitem);
        }
        else {
          if (print_all_errors == 0) {
            if (forward_ref != 0) {
              ly_ilo_restore(ctx,prev_ilo,prev_eitem,1);
            }
            iVar1 = -1;
            goto LAB_0012c822;
          }
          res_count = res_count + 1;
          ret = -1;
        }
      }
    }
  } while ((res_count != 0) && (res_count < unres_count));
  if (res_count < unres_count) {
    if (forward_ref == 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("forward_ref",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                    ,0x1d00,"resolve_unres_schema_types");
    }
    ly_ilo_restore(ctx,prev_ilo,prev_eitem,0);
    for (i = 0; i < unres->count; i = i + 1) {
      if ((unres->type[i] & types) != 0) {
        resolve_unres_schema_item
                  (unres->module[i],unres->item[i],unres->type[i],unres->str_snode[i],unres);
      }
    }
    iVar1 = -1;
  }
  else {
    iVar1 = ret;
    if (forward_ref != 0) {
      ly_ilo_restore(ctx,prev_ilo,prev_eitem,0);
      pLVar2 = ly_errno_glob_address();
      *pLVar2 = prev_ly_errno;
      iVar1 = ret;
    }
  }
LAB_0012c822:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int resolve_unres_schema(lys_module *mod,unres_schema *unres)

{
  int iVar1;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  lys_module *mod_local;
  uint32_t resolved;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  resolved = 0;
  if (unres == (unres_schema *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("unres",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x1d22,"resolve_unres_schema");
  }
  ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
         "Resolving \"%s\" unresolved schema nodes and their constraints...",mod->name);
  iVar1 = resolve_unres_schema_types
                    (unres,UNRES_USES|UNRES_IFFEAT|UNRES_TYPE_DER|UNRES_TYPE_DER_TPDF|
                           UNRES_TYPE_LEAFREF|UNRES_AUGMENT|UNRES_CHOICE_DFLT|UNRES_IDENT|
                           UNRES_MOD_IMPLEMENT,mod->ctx,1,0,&resolved);
  if (iVar1 == 0) {
    iVar1 = resolve_unres_schema_types
                      (unres,UNRES_TYPE_IDENTREF|UNRES_FEATURE|UNRES_TYPEDEF_DFLT|UNRES_TYPE_DFLT|
                             UNRES_LIST_KEYS|UNRES_LIST_UNIQ|UNRES_EXT,mod->ctx,1,0,&resolved);
    if (iVar1 == 0) {
      iVar1 = resolve_unres_schema_types
                        (unres,UNRES_XPATH|UNRES_EXT_FINALIZE,mod->ctx,0,1,&resolved);
      if (iVar1 == 0) {
        ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,"All \"%s\" schema nodes and constraints resolved."
               ,mod->name);
        unres->count = 0;
        iVar1 = 0;
      }
      else {
        iVar1 = -1;
      }
    }
    else {
      iVar1 = -1;
    }
  }
  else {
    iVar1 = -1;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int unres_schema_add_str(lys_module *mod,unres_schema *unres,void *item,UNRES_ITEM type,char *str)

{
  int iVar1;
  lys_node *snode;
  char *str_local;
  UNRES_ITEM type_local;
  void *item_local;
  unres_schema *unres_local;
  lys_module *mod_local;
  int rc;
  char *dictstr;
  
  snode = (lys_node *)lydict_insert(mod->ctx,str,0);
  iVar1 = unres_schema_add_node(mod,unres,item,type,snode);
  if (iVar1 < 0) {
    lydict_remove(mod->ctx,(char *)snode);
  }
  return iVar1;
}



int unres_schema_add_node
              (lys_module *mod,unres_schema *unres,void *item,UNRES_ITEM type,lys_node *snode)

{
  int iVar1;
  LY_ERR *pLVar2;
  void **ppvVar3;
  UNRES_ITEM *pUVar4;
  lys_module **pplVar5;
  long in_FS_OFFSET;
  lys_node *snode_local;
  UNRES_ITEM type_local;
  void *item_local;
  unres_schema *unres_local;
  lys_module *mod_local;
  int_log_opts prev_ilo;
  int rc;
  uint32_t u;
  LY_ERR prev_ly_errno;
  ly_err_item *prev_eitem;
  ly_ctx *ctx;
  lyxml_elem *yin;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = mod->ctx;
  if (((unres == (unres_schema *)0x0) ||
      ((((item == (void *)0x0 && (type != UNRES_MOD_IMPLEMENT)) || (type == UNRES_LEAFREF)) ||
       ((type == UNRES_INSTID || (type == UNRES_WHEN)))))) || (type == UNRES_MUST)) {
                    // WARNING: Subroutine does not return
    __assert_fail("unres && (item || (type == UNRES_MOD_IMPLEMENT)) && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID) && (type != UNRES_WHEN) && (type != UNRES_MUST))"
                  ,
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x1d71,"unres_schema_add_node");
  }
  for (u = 0; u < unres->count; u = u + 1) {
    if (((type == unres->type[u]) && (item == unres->item[u])) &&
       ((snode == (lys_node *)unres->str_snode[u] && (mod == unres->module[u])))) {
      iVar1 = 1;
      goto LAB_0012cee5;
    }
  }
  if (((type == UNRES_EXT_FINALIZE) || (type == UNRES_XPATH)) || (type == UNRES_MOD_IMPLEMENT)) {
    rc = 1;
  }
  else {
    pLVar2 = ly_errno_glob_address();
    prev_ly_errno = *pLVar2;
    ly_ilo_change(ctx,ILO_STORE,&prev_ilo,&prev_eitem);
    rc = resolve_unres_schema_item(mod,item,type,snode,unres);
    if (rc != 1) {
      ly_ilo_restore(ctx,prev_ilo,prev_eitem,(uint)(rc == -1));
      if (rc != -1) {
        pLVar2 = ly_errno_glob_address();
        *pLVar2 = prev_ly_errno;
      }
      if (type == UNRES_LIST_UNIQ) {
        free(item);
        iVar1 = rc;
      }
      else {
        iVar1 = rc;
        if ((rc == -1) && (type == UNRES_IFFEAT)) {
                    // WARNING: Load size is inaccurate
          free(*item);
          iVar1 = rc;
        }
      }
      goto LAB_0012cee5;
    }
    ly_ilo_restore(ctx,prev_ilo,prev_eitem,0);
    pLVar2 = ly_errno_glob_address();
    *pLVar2 = prev_ly_errno;
    print_unres_schema_item_fail(item,type,snode);
    if (((type == UNRES_TYPE_DER) || (type == UNRES_TYPE_DER_TPDF)) &&
       (yin = *(lyxml_elem **)((long)item + 0x10), -1 < yin->flags)) {
      lyxml_unlink_elem(mod->ctx,yin,1);
      *(lyxml_elem **)((long)item + 0x10) = yin;
    }
  }
  unres->count = unres->count + 1;
  ppvVar3 = (void **)ly_realloc(unres->item,(ulong)unres->count * 8);
  unres->item = ppvVar3;
  if (unres->item == (void **)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","unres_schema_add_node");
    iVar1 = -1;
  }
  else {
    unres->item[unres->count - 1] = item;
    pUVar4 = (UNRES_ITEM *)ly_realloc(unres->type,(ulong)unres->count * 4);
    unres->type = pUVar4;
    if (unres->type == (UNRES_ITEM *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","unres_schema_add_node");
      iVar1 = -1;
    }
    else {
      unres->type[unres->count - 1] = type;
      ppvVar3 = (void **)ly_realloc(unres->str_snode,(ulong)unres->count * 8);
      unres->str_snode = ppvVar3;
      if (unres->str_snode == (void **)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","unres_schema_add_node");
        iVar1 = -1;
      }
      else {
        unres->str_snode[unres->count - 1] = snode;
        pplVar5 = (lys_module **)ly_realloc(unres->module,(ulong)unres->count * 8);
        unres->module = pplVar5;
        if (unres->module == (lys_module **)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","unres_schema_add_node");
          iVar1 = -1;
        }
        else {
          unres->module[unres->count - 1] = mod;
          iVar1 = rc;
        }
      }
    }
  }
LAB_0012cee5:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int unres_schema_dup(lys_module *mod,unres_schema *unres,void *item,UNRES_ITEM type,void *new_item)

{
  long lVar1;
  int iVar2;
  lys_node *snode;
  char *pcVar3;
  long in_FS_OFFSET;
  void *new_item_local;
  UNRES_ITEM type_local;
  void *item_local;
  unres_schema *unres_local;
  lys_module *mod_local;
  int i;
  unres_iffeat_data *iff_data;
  unres_list_uniq aux_uniq;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if ((((item == (void *)0x0) || (new_item == (void *)0x0)) || (type == UNRES_LEAFREF)) ||
     ((type == UNRES_INSTID || (type == UNRES_WHEN)))) {
                    // WARNING: Subroutine does not return
    __assert_fail("item && new_item && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID) && (type != UNRES_WHEN))"
                  ,
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x1dcd,"unres_schema_dup");
  }
  item_local = item;
  if (type == UNRES_LIST_UNIQ) {
    aux_uniq.expr = *(char **)((long)new_item + 8);
    item_local = &aux_uniq;
    aux_uniq.list = (lys_node *)item;
  }
  iVar2 = unres_schema_find(unres,-1,item_local,type);
  if (iVar2 == -1) {
    if (type == UNRES_LIST_UNIQ) {
      free(new_item);
    }
    iVar2 = 1;
    goto LAB_0012d21d;
  }
  if (((type == UNRES_TYPE_LEAFREF) || (type == UNRES_USES)) ||
     ((type == UNRES_TYPE_DFLT || ((type == UNRES_FEATURE || (type == UNRES_LIST_UNIQ)))))) {
    iVar2 = unres_schema_add_node(mod,unres,new_item,type,(lys_node *)unres->str_snode[iVar2]);
    if (iVar2 == -1) {
      ly_log(mod->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
             ,0x1de1);
      iVar2 = -1;
      goto LAB_0012d21d;
    }
  }
  else if (type == UNRES_IFFEAT) {
    snode = (lys_node *)malloc(0x18);
    if (snode == (lys_node *)0x0) {
      ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","unres_schema_dup");
      iVar2 = -1;
      goto LAB_0012d21d;
    }
    pcVar3 = lydict_insert(mod->ctx,*(char **)((long)unres->str_snode[iVar2] + 8),0);
    snode->dsc = pcVar3;
                    // WARNING: Load size is inaccurate
    snode->name = *unres->str_snode[iVar2];
    *(undefined4 *)&snode->ref = *(undefined4 *)((long)unres->str_snode[iVar2] + 0x10);
    iVar2 = unres_schema_add_node(mod,unres,new_item,UNRES_IFFEAT,snode);
    if (iVar2 == -1) {
      ly_log(mod->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
             ,0x1dec);
      iVar2 = -1;
      goto LAB_0012d21d;
    }
  }
  else {
    iVar2 = unres_schema_add_str(mod,unres,new_item,type,(char *)unres->str_snode[iVar2]);
    if (iVar2 == -1) {
      ly_log(mod->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
             ,0x1df1);
      iVar2 = -1;
      goto LAB_0012d21d;
    }
  }
  iVar2 = 0;
LAB_0012d21d:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int unres_schema_find(unres_schema *unres,int start_on_backwards,void *item,UNRES_ITEM type)

{
  int iVar1;
  void *item_local;
  UNRES_ITEM type_local;
  int start_on_backwards_local;
  unres_schema *unres_local;
  int i;
  unres_list_uniq *aux_uniq1;
  unres_list_uniq *aux_uniq2;
  
  if (unres->count == 0) {
    i = -1;
  }
  else {
    i = start_on_backwards;
    if (start_on_backwards < 0) {
      i = unres->count - 1;
    }
    for (; -1 < i; i = i + -1) {
      if (type == unres->type[i]) {
        if (type == UNRES_LIST_UNIQ) {
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
          if ((*unres->item[i] == *item) &&
             (iVar1 = ly_strequal_(*(char **)((long)unres->item[i] + 8),*(char **)((long)item + 8)),
             iVar1 != 0)) {
            return i;
          }
        }
        else if (item == unres->item[i]) {
          return i;
        }
      }
    }
  }
  return i;
}



void unres_schema_free_item(ly_ctx *ctx,unres_schema *unres,uint32_t i)

{
  UNRES_ITEM UVar1;
  lyxml_elem *elem;
  uint32_t i_local;
  unres_schema *unres_local;
  ly_ctx *ctx_local;
  lyxml_elem *yin;
  yang_type *yang;
  unres_iffeat_data *iff_data;
  
  UVar1 = unres->type[i];
  if (UVar1 == UNRES_EXT_FINALIZE) {
    free(unres->str_snode[i]);
  }
  else if (UVar1 < (UNRES_USES|UNRES_EXT_FINALIZE)) {
    if (UVar1 == UNRES_EXT) {
      free(unres->str_snode[i]);
    }
    else if (UVar1 < (UNRES_USES|UNRES_EXT)) {
      if (UVar1 == UNRES_LIST_UNIQ) {
        free(unres->item[i]);
      }
      else if (UVar1 < (UNRES_USES|UNRES_LIST_UNIQ)) {
        if (UVar1 != UNRES_LIST_KEYS) {
          if (UNRES_LIST_KEYS < UVar1) goto LAB_0012d5c4;
          if (UVar1 != UNRES_TYPE_IDENTREF) {
            if (UNRES_TYPE_IDENTREF < UVar1) goto LAB_0012d5c4;
            if (UVar1 != UNRES_IDENT) {
              if (UNRES_IDENT < UVar1) goto LAB_0012d5c4;
              if (UVar1 != UNRES_CHOICE_DFLT) {
                if (UNRES_CHOICE_DFLT < UVar1) goto LAB_0012d5c4;
                if (UVar1 != UNRES_TYPE_DER_TPDF) {
                  if (UNRES_TYPE_DER_TPDF < UVar1) goto LAB_0012d5c4;
                  if (UVar1 == UNRES_IFFEAT) {
                    lydict_remove(ctx,*(char **)((long)unres->str_snode[i] + 8));
                    free(unres->str_snode[i]);
                    goto LAB_0012d5c4;
                  }
                  if (UVar1 != UNRES_TYPE_DER) goto LAB_0012d5c4;
                }
                elem = *(lyxml_elem **)((long)unres->item[i] + 0x10);
                if (elem->flags < '\0') {
                  *(undefined4 *)unres->item[i] = *(undefined4 *)&elem->field_0x4;
                  lydict_remove(ctx,&elem->parent->flags);
                  free(elem);
                    // WARNING: Load size is inaccurate
                  if (*unres->item[i] == 0xb) {
                    yang_free_type_union(ctx,(lys_type *)unres->item[i]);
                  }
                }
                else {
                  lyxml_free(ctx,elem);
                }
                goto LAB_0012d5c4;
              }
            }
          }
        }
        lydict_remove(ctx,(char *)unres->str_snode[i]);
      }
    }
  }
LAB_0012d5c4:
  unres->type[i] = UNRES_RESOLVED;
  return;
}



void unres_schema_free(lys_module *module,unres_schema **unres,int all)

{
  int all_local;
  unres_schema **unres_local;
  lys_module *module_local;
  uint32_t i;
  uint unresolved;
  
  unresolved = 0;
  if ((unres != (unres_schema **)0x0) && (*unres != (unres_schema *)0x0)) {
    if ((module == (lys_module *)0x0) && ((*unres)->count != 0)) {
                    // WARNING: Subroutine does not return
      __assert_fail("module || ((*unres)->count == 0)",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                    ,0x1e57,"unres_schema_free");
    }
    for (i = 0; i < (*unres)->count; i = i + 1) {
      if ((all == 0) && (module != (*unres)->module[i])) {
        if ((*unres)->type[i] != UNRES_RESOLVED) {
          unresolved = unresolved + 1;
        }
      }
      else {
        unres_schema_free_item(module->ctx,*unres,i);
      }
    }
    if (((module == (lys_module *)0x0) || (all != 0)) ||
       ((unresolved == 0 && ((module->field_0x40 & 1) == 0)))) {
      free((*unres)->item);
      free((*unres)->type);
      free((*unres)->str_snode);
      free((*unres)->module);
      free(*unres);
      *unres = (unres_schema *)0x0;
    }
  }
  return;
}



int check_instid_ext_dep(lys_node *sleaf,char *json_instid)

{
  int iVar1;
  lys_node *plVar2;
  size_t __n;
  lys_module *plVar3;
  lys_module *plVar4;
  long in_FS_OFFSET;
  char *json_instid_local;
  lys_node *sleaf_local;
  int_log_opts prev_ilo;
  lys_node *op_node;
  char *tmp;
  char *buf;
  lys_node *first_node;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if ((json_instid == (char *)0x0) || (*json_instid == '\0')) {
    iVar1 = 0;
  }
  else {
    for (op_node = lys_parent(sleaf);
        (op_node != (lys_node *)0x0 && ((op_node->nodetype & 0x4180) == LYS_UNKNOWN));
        op_node = lys_parent(op_node)) {
    }
    if (op_node != (lys_node *)0x0) {
      plVar2 = lys_parent(op_node);
      if (plVar2 != (lys_node *)0x0) {
        iVar1 = 1;
        goto LAB_0012d906;
      }
    }
    tmp = strchr(json_instid + 1,0x2f);
    if (tmp == (char *)0x0) {
      __n = strlen(json_instid);
    }
    else {
      __n = (long)tmp - (long)json_instid;
    }
    buf = strndup(json_instid,__n);
    if (buf == (char *)0x0) {
      iVar1 = 0;
    }
    else {
      ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
      first_node = ly_ctx_get_node((ly_ctx *)0x0,sleaf,buf,0);
      ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
      free(buf);
      if (first_node == (lys_node *)0x0) {
        iVar1 = 1;
      }
      else {
        if (op_node == (lys_node *)0x0) {
          plVar3 = lys_node_module(sleaf);
          plVar4 = lys_node_module(first_node);
          if (plVar3 != plVar4) {
            iVar1 = 1;
            goto LAB_0012d906;
          }
        }
        else if (op_node != first_node) {
          iVar1 = 1;
          goto LAB_0012d906;
        }
        iVar1 = 0;
      }
    }
  }
LAB_0012d906:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int resolve_instid(lyd_node *data,char *path,int req_inst,lyd_node **ret)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  lyd_node **ret_local;
  int req_inst_local;
  char *path_local;
  lyd_node *data_local;
  int mod_len;
  int name_len;
  int has_predicate;
  int i;
  int j;
  int parsed;
  int cur_idx;
  lyd_node *node;
  char *model;
  char *name;
  lys_module *mod;
  lys_module *prev_mod;
  lyd_node *root;
  ly_ctx *ctx;
  char *str;
  unres_data node_match;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  i = 0;
  prev_mod = (lys_module *)0x0;
  ctx = data->schema->module->ctx;
  model = (char *)0x0;
  memset(&node_match,0,0x28);
  *ret = (lyd_node *)0x0;
  for (root = data; root->parent != (lyd_node *)0x0; root = root->parent) {
  }
  if (root->prev != (lyd_node *)0x0) {
    while (root->prev->next != (lyd_node *)0x0) {
      root = root->prev;
    }
  }
  while (path[i] != '\0') {
    j = parse_instance_identifier(path + i,&model,&mod_len,&name,&name_len,&has_predicate);
    if (j < 1) {
      ly_vlog(ctx,LYE_INCHAR,LY_VLOG_LYD,data,(ulong)(uint)(int)path[i - j],path + (i - j));
      goto LAB_0012df0b;
    }
    i = i + j;
    if (model == (char *)0x0) {
      if (prev_mod == (lys_module *)0x0) {
        ly_vlog(ctx,LYE_INELEM_LEN,LY_VLOG_LYD,data,(ulong)(uint)name_len,name);
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                "Instance-identifier is missing prefix in the first node.");
        goto LAB_0012df0b;
      }
      mod = prev_mod;
    }
    else {
      str = strndup(model,(long)mod_len);
      if (str == (char *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","resolve_instid");
        goto LAB_0012df0b;
      }
      mod = ly_ctx_get_module(ctx,str,(char *)0x0,1);
      if (ctx->data_clb != (ly_module_data_clb)0x0) {
        if (mod == (lys_module *)0x0) {
          mod = (*ctx->data_clb)(ctx,str,(char *)0x0,0,ctx->data_clb_data);
        }
        else if ((mod->field_0x40 & 0x80) == 0) {
          mod = (*ctx->data_clb)(ctx,mod->name,mod->ns,1,ctx->data_clb_data);
        }
      }
      free(str);
      if (((mod == (lys_module *)0x0) || ((mod->field_0x40 & 0x80) == 0)) ||
         ((mod->field_0x40 & 0x40) != 0)) break;
    }
    iVar2 = resolve_data(mod,name,name_len,root,&node_match);
    if (iVar2 != 0) break;
    if (has_predicate == 0) {
      if (node_match.count != 0) {
        for (j = 0; iVar2 = j, (uint)j < node_match.count; j = j + 1) {
          if (node_match.node[j]->schema->nodetype == LYS_LIST) {
            j = j + -1;
            unres_data_del(&node_match,iVar2);
          }
        }
        if (node_match.count == 0) {
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_LYD,data,"Instance identifier is missing list keys.");
        }
      }
    }
    else {
      j = 0;
      parsed = 0;
      cur_idx = 1;
      while (j < (int)node_match.count) {
        node = node_match.node[j];
        parsed = resolve_instid_predicate(mod,path + i,&node,cur_idx);
        if (parsed < 1) {
          ly_vlog(ctx,LYE_INPRED,LY_VLOG_LYD,data,path + (i - parsed));
          goto LAB_0012df0b;
        }
        if (node == (lyd_node *)0x0) {
          unres_data_del(&node_match,j);
        }
        else {
          j = j + 1;
        }
        cur_idx = cur_idx + 1;
      }
      i = i + parsed;
    }
    prev_mod = mod;
  }
  if (node_match.count == 0) {
    if (req_inst < 0) {
      ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
             "There is no instance of \"%s\", but it is not required.",path);
      iVar2 = 0;
    }
    else {
      ly_vlog(ctx,LYE_NOREQINS,LY_VLOG_LYD,data,path);
      iVar2 = 1;
    }
  }
  else if (node_match.count < 2) {
    *ret = *node_match.node;
    free(node_match.node);
    iVar2 = 0;
  }
  else {
    ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYD,data,path,"data tree");
LAB_0012df0b:
    free(node_match.node);
    iVar2 = -1;
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int resolve_leafref(lyd_node_leaf_list *leaf,char *path,int req_inst,lyd_node **ret)

{
  long lVar1;
  int iVar2;
  lys_module *plVar3;
  long in_FS_OFFSET;
  lyd_node **ret_local;
  int req_inst_local;
  char *path_local;
  lyd_node_leaf_list *leaf_local;
  uint32_t i;
  lyxp_set xp_set;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  memset(&xp_set,0,0x40);
  *ret = (lyd_node *)0x0;
  plVar3 = lyd_node_module((lyd_node *)leaf);
  iVar2 = lyxp_eval(path,(lyd_node *)leaf,LYXP_NODE_ELEM,plVar3,&xp_set,0);
  if (iVar2 == 0) {
    if (xp_set.type == LYXP_SET_NODE_SET) {
      for (i = 0; i < xp_set.used; i = i + 1) {
        if (((xp_set.val.nodes[i].type == LYXP_NODE_ELEM) &&
            (((xp_set.val.nodes[i].node)->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN
            )) && ((hash_table *)leaf->value_str == (xp_set.val.nodes[i].node)->ht)) {
          *ret = xp_set.val.nodes[i].node;
          break;
        }
      }
    }
    lyxp_set_cast(&xp_set,LYXP_SET_EMPTY,(lyd_node *)leaf,(lys_module *)0x0,0);
    if (*ret == (lyd_node *)0x0) {
      if (-1 < req_inst) {
        ly_vlog(leaf->schema->module->ctx,LYE_NOLEAFREF,LY_VLOG_LYD,leaf,path,leaf->value_str);
        iVar2 = 1;
        goto LAB_0012e0ff;
      }
      ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
             "There is no leafref \"%s\" with the value \"%s\", but it is not required.",path,
             leaf->value_str);
    }
    iVar2 = 0;
  }
  else {
    iVar2 = -1;
  }
LAB_0012e0ff:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}


/*
Unable to decompile 'resolve_union'
Cause: Exception while decompiling 0012e115: process: timeout

*/

/*
Unable to decompile 'resolve_unres_data_item'
Cause: Exception while decompiling 0012e6f2: process: timeout

*/


int unres_data_add(unres_data *unres,lyd_node *node,UNRES_ITEM type)

{
  int iVar1;
  lyd_node **pplVar2;
  UNRES_ITEM *pUVar3;
  UNRES_ITEM type_local;
  lyd_node *node_local;
  unres_data *unres_local;
  
  if ((unres == (unres_data *)0x0) || (node == (lyd_node *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("unres && node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x207d,"unres_data_add");
  }
  if (((type != UNRES_LEAFREF) &&
      (((type != UNRES_INSTID && (type != UNRES_WHEN)) && (type != UNRES_MUST)))) &&
     (((type != UNRES_MUST_INOUT && (type != UNRES_UNION)) && (type != UNRES_UNIQ_LEAVES)))) {
                    // WARNING: Subroutine does not return
    __assert_fail("(type == UNRES_LEAFREF) || (type == UNRES_INSTID) || (type == UNRES_WHEN) || (type == UNRES_MUST) || (type == UNRES_MUST_INOUT) || (type == UNRES_UNION) || (type == UNRES_UNIQ_LEAVES)"
                  ,
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x207e,"unres_data_add");
  }
  unres->count = unres->count + 1;
  pplVar2 = (lyd_node **)ly_realloc(unres->node,(ulong)unres->count * 8);
  unres->node = pplVar2;
  if (unres->node == (lyd_node **)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","unres_data_add");
    iVar1 = -1;
  }
  else {
    unres->node[unres->count - 1] = node;
    pUVar3 = (UNRES_ITEM *)ly_realloc(unres->type,(ulong)unres->count * 4);
    unres->type = pUVar3;
    if (unres->type == (UNRES_ITEM *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","unres_data_add");
      iVar1 = -1;
    }
    else {
      unres->type[unres->count - 1] = type;
      iVar1 = 0;
    }
  }
  return iVar1;
}



void resolve_unres_data_autodel_diff(unres_data *unres,uint32_t unres_i)

{
  uint32_t unres_i_local;
  unres_data *unres_local;
  uint32_t i;
  lyd_node *next;
  lyd_node *child;
  lyd_node *parent;
  
  i = 0;
  do {
    if (unres->diff_idx <= i) {
LAB_0012efd2:
      unres_data_diff_new(unres,unres->node[unres_i],unres->node[unres_i]->parent,0);
      lyd_unlink(unres->node[unres_i]);
      unres->node[unres_i] = (lyd_node *)0x0;
      return;
    }
    if (unres->diff->type[i] != LYD_DIFF_DELETED) {
      if (unres->diff->second[i] == unres->node[unres_i]) {
        unres_data_diff_rem(unres,i);
        return;
      }
      for (parent = unres->diff->second[i]->parent;
          (parent != (lyd_node *)0x0 && (parent != unres->node[unres_i])); parent = parent->parent)
      {
      }
      if (parent != (lyd_node *)0x0) {
        unres_data_diff_rem(unres,i);
        goto LAB_0012efd2;
      }
      next = unres->diff->second[i];
      while (child = next, next != (lyd_node *)0x0) {
        if (next == unres->node[unres_i]) {
          return;
        }
        if ((next->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
          next = next->child;
        }
        else {
          next = (lyd_node *)0x0;
        }
        if (next == (lyd_node *)0x0) {
          if (child == unres->diff->second[i]) break;
          next = child->next;
        }
        while ((next == (lyd_node *)0x0 &&
               (child = child->parent, child->parent != unres->diff->second[i]->parent))) {
          next = child->next;
        }
      }
    }
    i = i + 1;
  } while( true );
}



int resolve_unres_data(ly_ctx *ctx,unres_data *unres,lyd_node **root,int options)

{
  byte bVar1;
  char *pcVar2;
  lys_node *plVar3;
  long lVar4;
  int iVar5;
  LY_ERR *pLVar6;
  char *pcVar7;
  long in_FS_OFFSET;
  int options_local;
  lyd_node **root_local;
  unres_data *unres_local;
  ly_ctx *ctx_local;
  uint8_t prev_when_status;
  int_log_opts prev_ilo;
  uint32_t i;
  uint32_t j;
  uint32_t first;
  uint32_t resolved;
  uint32_t del_items;
  uint32_t stmt_count;
  int progress;
  int ignore_fail;
  LY_ERR prev_ly_errno;
  int rc;
  ly_err_item *prev_eitem;
  lys_when *when;
  lyd_node *parent;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  pLVar6 = ly_errno_glob_address();
  prev_ly_errno = *pLVar6;
  if (root == (lyd_node **)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("root",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x20df,"resolve_unres_data");
  }
  if (unres == (unres_data *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("unres",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                  ,0x20e0,"resolve_unres_data");
  }
  if (unres->count == 0) {
    iVar5 = 0;
  }
  else {
    if ((options & 0x8eU) == 0) {
      if ((options & 0x8000U) == 0) {
        ignore_fail = 0;
      }
      else {
        ignore_fail = 2;
      }
    }
    else {
      ignore_fail = 1;
    }
    ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
           "Resolving unresolved data nodes and their constraints...");
    if (ignore_fail == 0) {
      ly_ilo_change(ctx,ILO_STORE,&prev_ilo,&prev_eitem);
    }
    first = 1;
    stmt_count = 0;
    resolved = 0;
    del_items = 0;
    do {
      if (ignore_fail == 0) {
        ly_err_free_next(ctx,prev_eitem);
      }
      progress = 0;
      for (i = 0; i < unres->count; i = i + 1) {
        if (unres->type[i] == UNRES_WHEN) {
          if (first != 0) {
            stmt_count = stmt_count + 1;
          }
          parent = unres->node[i]->parent;
          while( true ) {
            if ((parent == (lyd_node *)0x0) ||
               ((((byte)parent->field_0x9 >> 1 & 4) != 0 &&
                (((byte)parent->field_0x9 >> 1 & 3) == 0)))) goto LAB_0012f2b1;
            if ((parent->parent == (lyd_node *)0x0) && (((byte)parent->field_0x9 >> 1 & 1) != 0))
            break;
            parent = parent->parent;
          }
          unres->node[i]->field_0x9 =
               unres->node[i]->field_0x9 & 0xf1 |
               ((byte)unres->node[i]->field_0x9 >> 1 & 7 | 1) * '\x02';
          unres->type[i] = UNRES_RESOLVED;
          resolved = resolved + 1;
LAB_0012f2b1:
          if (parent == (lyd_node *)0x0) {
            bVar1 = unres->node[i]->field_0x9;
            rc = resolve_unres_data_item(unres->node[i],unres->type[i],ignore_fail,&when);
            if (rc == 0) {
              if ((((byte)unres->node[i]->field_0x9 >> 1 & 1) == 0) ||
                 (((when->flags & 0x600) != 0 && ((options & 0x8000U) != 0)))) {
                unres->type[i] = UNRES_RESOLVED;
              }
              else {
                if ((((bVar1 >> 1 & 2) == 0) || ((options & 0x4000U) == 0)) &&
                   ((unres->node[i]->field_0x9 & 1) == 0)) goto LAB_0012f9ca;
                pcVar2 = when->cond;
                pcVar7 = ly_errpath(ctx);
                ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                       "Auto-deleting node \"%s\" due to when condition (%s)",pcVar7,pcVar2);
                for (parent = unres->node[i];
                    ((parent->parent != (lyd_node *)0x0 &&
                     (parent->parent->schema->nodetype == LYS_CONTAINER)) &&
                    ((plVar3 = parent->parent->schema, lVar4._0_2_ = plVar3[1].flags,
                     lVar4._2_1_ = plVar3[1].ext_size, lVar4._3_1_ = plVar3[1].iffeature_size,
                     lVar4._4_1_ = plVar3[1].padding[0], lVar4._5_1_ = plVar3[1].padding[1],
                     lVar4._6_1_ = plVar3[1].padding[2], lVar4._7_1_ = plVar3[1].padding[3],
                     lVar4 == 0 && ((parent->next == (lyd_node *)0x0 && (parent == parent->prev)))))
                    ); parent = parent->parent) {
                }
                unres->node[i] = parent;
                if ((*root != (lyd_node *)0x0) && (*root == unres->node[i])) {
                  *root = (*root)->next;
                }
                unres->type[i] = UNRES_DELETE;
                del_items = del_items + 1;
                for (j = 0; j < unres->count; j = j + 1) {
                  if ((unres->type[j] != UNRES_RESOLVED) && (unres->type[j] != UNRES_DELETE)) {
                    for (parent = unres->node[j]; parent != (lyd_node *)0x0; parent = parent->parent
                        ) {
                      if (parent == unres->node[i]) {
                        unres->type[j] = UNRES_RESOLVED;
                        resolved = resolved + 1;
                        break;
                      }
                    }
                  }
                }
              }
              if (ignore_fail == 0) {
                ly_err_free_next(ctx,prev_eitem);
              }
              resolved = resolved + 1;
              progress = 1;
            }
            else if (rc == -1) goto LAB_0012f9ca;
          }
        }
      }
      first = 0;
    } while ((progress != 0) && (resolved < stmt_count));
    if (stmt_count <= resolved) {
      for (i = 0; (del_items != 0 && (i < unres->count)); i = i + 1) {
        if (unres->type[i] == UNRES_DELETE) {
          if (unres->node[i] == (lyd_node *)0x0) {
            unres->type[i] = UNRES_RESOLVED;
            del_items = del_items - 1;
          }
          else {
            if (unres->store_diff != 0) {
              resolve_unres_data_autodel_diff(unres,i);
            }
            lyd_free(unres->node[i]);
            unres->type[i] = UNRES_RESOLVED;
            del_items = del_items - 1;
          }
        }
      }
      if ((options & 0x2000U) != 0) {
        if (ignore_fail != 0) {
                    // WARNING: Subroutine does not return
          __assert_fail("!ignore_fail",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                        ,0x2182,"resolve_unres_data");
        }
        ignore_fail = 1;
        ly_ilo_restore(ctx,prev_ilo,prev_eitem,0);
        pLVar6 = ly_errno_glob_address();
        *pLVar6 = prev_ly_errno;
      }
      first = 1;
      stmt_count = 0;
      resolved = 0;
      do {
        progress = 0;
        for (i = 0; i < unres->count; i = i + 1) {
          if (unres->type[i] == UNRES_LEAFREF) {
            if (first != 0) {
              stmt_count = stmt_count + 1;
            }
            rc = resolve_unres_data_item(unres->node[i],unres->type[i],ignore_fail,(lys_when **)0x0)
            ;
            if (rc == 0) {
              unres->type[i] = UNRES_RESOLVED;
              if (ignore_fail == 0) {
                ly_err_free_next(ctx,prev_eitem);
              }
              resolved = resolved + 1;
              progress = 1;
            }
            else if (rc == -1) goto LAB_0012f9ca;
          }
        }
        first = 0;
      } while ((progress != 0) && (resolved < stmt_count));
      if (stmt_count <= resolved) {
        if (ignore_fail == 0) {
          ly_ilo_restore(ctx,prev_ilo,prev_eitem,0);
          pLVar6 = ly_errno_glob_address();
          *pLVar6 = prev_ly_errno;
        }
        for (i = 0; i < unres->count; i = i + 1) {
          if (unres->type[i] != UNRES_RESOLVED) {
            if (((options & 0x2000U) != 0) &&
               ((unres->type[i] == UNRES_MUST || (unres->type[i] == UNRES_MUST_INOUT)))) {
                    // WARNING: Subroutine does not return
              __assert_fail("!(options & LYD_OPT_TRUSTED) || ((unres->type[i] != UNRES_MUST) && (unres->type[i] != UNRES_MUST_INOUT))"
                            ,
                            "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/resolve.c"
                            ,0x21b7,"resolve_unres_data");
            }
            rc = resolve_unres_data_item(unres->node[i],unres->type[i],ignore_fail,(lys_when **)0x0)
            ;
            if (rc != 0) {
              iVar5 = -1;
              goto LAB_0012f9ed;
            }
            unres->type[i] = UNRES_RESOLVED;
          }
        }
        ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,"All data nodes and constraints resolved.");
        unres->count = 0;
        iVar5 = 0;
        goto LAB_0012f9ed;
      }
    }
LAB_0012f9ca:
    if (ignore_fail == 0) {
      ly_ilo_restore(ctx,prev_ilo,prev_eitem,1);
    }
    iVar5 = -1;
  }
LAB_0012f9ed:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar5;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyv_keys(lyd_node *list)

{
  lys_node *plVar1;
  lyd_node *list_local;
  int i;
  lyd_node *child;
  lys_node_list *schema;
  
  plVar1 = list->schema;
  i = 0;
  child = list->child;
  while( true ) {
    if ((int)(uint)plVar1->padding[2] <= i) {
      return 0;
    }
    if ((child == (lyd_node *)0x0) ||
       (child->schema != *(lys_node **)(*(long *)&plVar1[1].flags + (long)i * 8))) break;
    i = i + 1;
    child = child->next;
  }
  ly_vlog(plVar1->module->ctx,LYE_MISSELEM,LY_VLOG_LYD,list,
          **(undefined8 **)(*(long *)&plVar1[1].flags + (long)i * 8),plVar1->name);
  while( true ) {
    if (child == (lyd_node *)0x0) {
      return 1;
    }
    if (child->schema == *(lys_node **)(*(long *)&plVar1[1].flags + (long)i * 8)) break;
    child = child->next;
  }
  ly_vlog(plVar1->module->ctx,LYE_SPEC,LY_VLOG_LYD,child,"Invalid position of the key element.");
  return 1;
}



int lyv_data_context(lyd_node *node,int options,unres_data *unres)

{
  ly_ctx *ctx_00;
  int iVar1;
  lys_node *plVar2;
  lys_module *plVar3;
  unres_data *unres_local;
  int options_local;
  lyd_node *node_local;
  lys_node *siter;
  lys_node *sparent;
  lys_node *op;
  lyd_node_leaf_list *leaf;
  ly_ctx *ctx;
  
  ctx_00 = node->schema->module->ctx;
  if (node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                  ,0x3b,"lyv_data_context");
  }
  if (unres != (unres_data *)0x0) {
    plVar2 = lys_is_disabled(node->schema,2);
    if (plVar2 != (lys_node *)0x0) {
      ly_vlog(ctx_00,LYE_INELEM,LY_VLOG_LYD,node,node->schema->name);
      return 1;
    }
    for (op = node->schema; (op != (lys_node *)0x0 && ((op->nodetype & 0x4180) == LYS_UNKNOWN));
        op = lys_parent(op)) {
    }
    if (((options & 0x8eU) == 0) && (((options & 0x50U) == 0 || (op != (lys_node *)0x0)))) {
      if ((node->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) {
        if ((*(int *)&node->schema[1].ref == 0xb) && (*(int *)&node->schema[1].field_0x3c != 0)) {
          iVar1 = unres_data_add(unres,node,UNRES_UNION);
          if (iVar1 != 0) {
            return 1;
          }
        }
        else if ((*(int *)&node->schema[1].ref == 9) &&
                (((node->validity & 8) != 0 || ((*(byte *)((long)&node[1].schema + 4) & 1) != 0))))
        {
          *(byte *)((long)&node[1].schema + 4) = *(byte *)((long)&node[1].schema + 4) & 0xfe;
          node->validity = node->validity | 8;
          iVar1 = unres_data_add(unres,node,UNRES_LEAFREF);
          if (iVar1 != 0) {
            return 1;
          }
        }
        else if ((*(int *)&node->schema[1].ref == 8) &&
                (iVar1 = unres_data_add(unres,node,UNRES_INSTID), iVar1 != 0)) {
          return 1;
        }
      }
      if ((((byte)node->field_0x9 >> 1 & 4) != 0) &&
         (iVar1 = unres_data_add(unres,node,UNRES_WHEN), iVar1 != 0)) {
        return 1;
      }
    }
    else if ((node->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) {
      node->validity = node->validity & 0xf7;
    }
    if (((options & 0xdU) == 0) || ((node->schema->flags & 2) == 0)) {
      if (((options & 0x2080U) == 0) &&
         (((((options & 0x30U) != 0 && ((node->validity & 4) != 0)) && (op != (lys_node *)0x0)) &&
          ((node != node->prev && (node->prev->next != (lyd_node *)0x0)))))) {
        for (sparent = lys_parent(node->schema);
            (sparent != (lys_node *)0x0 && ((sparent->nodetype & 0x1042) != LYS_UNKNOWN));
            sparent = lys_parent(sparent)) {
        }
        plVar3 = lyd_node_module(node);
        for (siter = lys_getnext(node->schema,sparent,plVar3,0); siter != (lys_node *)0x0;
            siter = lys_getnext(siter,sparent,plVar3,0)) {
          if (siter == node->prev->schema) {
            ly_vlog(ctx_00,LYE_INORDER,LY_VLOG_LYD,node,node->schema->name,siter->name);
            return 1;
          }
          plVar3 = lyd_node_module(node);
        }
      }
      iVar1 = 0;
    }
    else {
      ly_vlog(ctx_00,LYE_INELEM,LY_VLOG_LYD,node,node->schema->name);
      iVar1 = 1;
    }
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("unres",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                ,0x3c,"lyv_data_context");
}



int lyv_list_uniq_equal(void *val1_p,void *val2_p,int UNUSED_mod,void *cb_data)

{
  char *buf;
  char *schema_id;
  int iVar1;
  int iVar2;
  lys_module *module;
  long in_FS_OFFSET;
  void *cb_data_local;
  int UNUSED_mod_local;
  void *val2_p_local;
  void *val1_p_local;
  uint16_t idx_uniq;
  int i;
  int j;
  int action;
  int r;
  char *val1;
  char *val2;
  char *path1;
  char *path2;
  lyd_node *first;
  lyd_node *second;
  ly_ctx *ctx;
  lys_node_list *slist;
  lyd_node *diter;
  char *uniq_str;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if ((val1_p == (void *)0x0) || (val2_p == (void *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("val1_p && val2_p",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                  ,0x9b,"lyv_list_uniq_equal");
  }
                    // WARNING: Load size is inaccurate
  first = *val1_p;
                    // WARNING: Load size is inaccurate
  second = *val2_p;
  iVar2 = (int)cb_data;
  if ((first == (lyd_node *)0x0) || (first->schema->nodetype != LYS_LIST)) {
                    // WARNING: Subroutine does not return
    __assert_fail("first && (first->schema->nodetype == LYS_LIST)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                  ,0xa1,"lyv_list_uniq_equal");
  }
  if ((second == (lyd_node *)0x0) || (second->schema != first->schema)) {
                    // WARNING: Subroutine does not return
    __assert_fail("second && (second->schema == first->schema)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                  ,0xa2,"lyv_list_uniq_equal");
  }
  ctx = first->schema->module->ctx;
  slist = (lys_node_list *)first->schema;
  if ((0 < iVar2) && (i = iVar2 + -1, i < (int)(uint)slist->unique_size)) goto LAB_00130111;
  for (i = 0; i < (int)(uint)slist->unique_size; i = i + 1) {
LAB_00130111:
    for (j = 0; j < (int)(uint)slist->unique[i].expr_size; j = j + 1) {
      diter = resolve_data_descendant_schema_nodeid(slist->unique[i].expr[j],first->child);
      if (diter == (lyd_node *)0x0) {
        iVar1 = lyd_get_unique_default(slist->unique[i].expr[j],first,&val1);
        if (iVar1 != 0) {
          iVar2 = 1;
          goto LAB_00130487;
        }
      }
      else {
        val1 = (char *)diter->ht;
      }
      diter = resolve_data_descendant_schema_nodeid(slist->unique[i].expr[j],second->child);
      if (diter == (lyd_node *)0x0) {
        iVar1 = lyd_get_unique_default(slist->unique[i].expr[j],second,&val2);
        if (iVar1 != 0) {
          iVar2 = 1;
          goto LAB_00130487;
        }
      }
      else {
        val2 = (char *)diter->ht;
      }
      if (((val1 == (char *)0x0) || (val2 == (char *)0x0)) || (val1 != val2)) break;
    }
    if ((j != 0) && (j == (uint)slist->unique[i].expr_size)) {
      ly_vlog_build_path(LY_VLOG_LYD,first,&path1,0,0);
      ly_vlog_build_path(LY_VLOG_LYD,second,&path2,0,0);
      uniq_str = (char *)malloc(0x400);
      idx_uniq = 0;
      j = 0;
      goto LAB_001303ca;
    }
    if (0 < iVar2) {
      iVar2 = 0;
      goto LAB_00130487;
    }
  }
  iVar2 = 0;
  goto LAB_00130487;
LAB_001303ca:
  if ((int)(uint)slist->unique[i].expr_size <= j) goto code_r0x001303f2;
  if (j != 0) {
    uniq_str[idx_uniq] = ' ';
    idx_uniq = idx_uniq + 1;
  }
  buf = uniq_str + idx_uniq;
  schema_id = slist->unique[i].expr[j];
  module = lys_node_module((lys_node *)slist);
  iVar2 = lyd_build_relative_data_path(module,first,schema_id,buf);
  if (iVar2 == -1) goto LAB_00130432;
  idx_uniq = idx_uniq + (short)iVar2;
  j = j + 1;
  goto LAB_001303ca;
code_r0x001303f2:
  ly_vlog(ctx,LYE_NOUNIQ,LY_VLOG_LYD,second,uniq_str,path1,path2);
LAB_00130432:
  free(path1);
  free(path2);
  free(uniq_str);
  iVar2 = 1;
LAB_00130487:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyv_data_unique(lyd_node *list)

{
  hash_table **pphVar1;
  int iVar2;
  uint32_t hash_00;
  hash_table *phVar3;
  size_t len;
  byte bVar4;
  long in_FS_OFFSET;
  lyd_node *list_local;
  uint32_t i;
  uint32_t j;
  uint32_t n;
  int ret;
  uint32_t hash;
  uint32_t u;
  uint32_t usize;
  char *id;
  char *path;
  hash_table **uniqtables;
  ly_ctx *ctx;
  lys_node_list *slist;
  ly_set *set;
  lyd_node *diter;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  n = 0;
  ret = 0;
  uniqtables = (hash_table **)0x0;
  ctx = list->schema->module->ctx;
  if ((list->validity & 2) == 0) {
    ret = 0;
  }
  else {
    slist = (lys_node_list *)list->schema;
    iVar2 = ly_vlog_build_path(LY_VLOG_LYD,list,&path,0,1);
    if (iVar2 == 0) {
      set = lyd_find_path(list,path);
      free(path);
      if (set == (ly_set *)0x0) {
        ret = -1;
      }
      else {
        for (i = 0; i < set->number; i = i + 1) {
          *(byte *)&(set->set).s[i]->dsc = *(byte *)&(set->set).s[i]->dsc & 0xfd;
        }
        if (set->number == 2) {
          iVar2 = lyv_list_uniq_equal((set->set).s,(set->set).s + 1,0,(void *)0x0);
          if (iVar2 != 0) {
            ly_set_free(set);
            ret = 1;
            goto LAB_00130a08;
          }
        }
        else if (2 < set->number) {
          for (u = 0x1f;
              (bVar4 = (byte)u, u != 0 &&
              ((set->number << (bVar4 & 0x1f)) >> (bVar4 & 0x1f) != set->number)); u = u - 1) {
          }
          if (u == 0) {
            ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                   ,0x128);
            ret = -1;
          }
          else {
            n = (uint32_t)slist->unique_size;
            uniqtables = (hash_table **)malloc((ulong)n << 3);
            if (uniqtables == (hash_table **)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyv_data_unique");
              ret = -1;
              n = 0;
            }
            else {
              for (j = 0; j < n; j = j + 1) {
                pphVar1 = uniqtables + j;
                phVar3 = lyht_new(1 << (0x20 - bVar4 & 0x1f),8,lyv_list_uniq_equal,
                                  (void *)((ulong)j + 1),0);
                *pphVar1 = phVar3;
                if (uniqtables[j] == (hash_table *)0x0) {
                  ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyv_data_unique");
                  ret = -1;
                  goto LAB_0013099e;
                }
              }
              for (u = 0; u < set->number; u = u + 1) {
                for (j = 0; j < n; j = j + 1) {
                  id = (char *)0x0;
                  hash = 0;
                  for (i = 0; i < slist->unique[j].expr_size; i = i + 1) {
                    diter = resolve_data_descendant_schema_nodeid
                                      (slist->unique[j].expr[i],(lyd_node *)(set->set).s[u]->parent)
                    ;
                    if (diter == (lyd_node *)0x0) {
                      iVar2 = lyd_get_unique_default
                                        (slist->unique[j].expr[i],(lyd_node *)(set->set).s[u],&id);
                      if (iVar2 != 0) {
                        ret = -1;
                        goto LAB_0013099e;
                      }
                    }
                    else {
                      id = (char *)diter->ht;
                    }
                    if (id == (char *)0x0) break;
                    len = strlen(id);
                    hash = dict_hash_multi(hash,id,len);
                  }
                  if (id != (char *)0x0) {
                    hash_00 = dict_hash_multi(hash,(char *)0x0,0);
                    iVar2 = lyht_insert(uniqtables[j],(set->set).s + u,hash_00,(void **)0x0);
                    if (iVar2 != 0) {
                      ret = 1;
                      goto LAB_0013099e;
                    }
                  }
                }
              }
            }
          }
        }
LAB_0013099e:
        ly_set_free(set);
        for (j = 0; (j < n && (uniqtables[j] != (hash_table *)0x0)); j = j + 1) {
          lyht_free(uniqtables[j]);
        }
        free(uniqtables);
      }
    }
    else {
      ret = -1;
    }
  }
LAB_00130a08:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Variable defined which should be unmapped: UNUSED_cb_data_local

int lyv_list_equal(void *val1_p,void *val2_p,int UNUSED_mod,void *UNUSED_cb_data)

{
  long *plVar1;
  long *elem;
  ly_ctx *ctx_00;
  long lVar2;
  lys_node *plVar3;
  int iVar4;
  undefined8 in_R9;
  void *UNUSED_cb_data_local;
  int UNUSED_mod_local;
  void *val2_p_local;
  void *val1_p_local;
  int i;
  lyd_node *diter;
  char *val1;
  char *val2;
  lys_node *snode;
  lyd_node *first;
  lyd_node *second;
  ly_ctx *ctx;
  lys_node_list *slist;
  
  if ((val1_p == (void *)0x0) || (val2_p == (void *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("val1_p && val2_p",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                  ,0x17f,"lyv_list_equal");
  }
                    // WARNING: Load size is inaccurate
  plVar1 = *val1_p;
                    // WARNING: Load size is inaccurate
  elem = *val2_p;
  if ((plVar1 == (long *)0x0) || ((*(uint *)(*plVar1 + 0x38) & 0x18) == 0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("first && (first->schema->nodetype & (LYS_LIST | LYS_LEAFLIST))",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                  ,0x184,"lyv_list_equal");
  }
  if ((elem == (long *)0x0) || (*elem != *plVar1)) {
                    // WARNING: Subroutine does not return
    __assert_fail("second && (second->schema == first->schema)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                  ,0x185,"lyv_list_equal");
  }
  ctx_00 = (ly_ctx *)**(undefined8 **)(*plVar1 + 0x30);
  if (*(int *)(*plVar1 + 0x38) == 8) {
    if (((*(ushort *)(*plVar1 + 0x18) & 2) == 0) ||
       ((*(byte *)(*(long *)(*plVar1 + 0x30) + 0x40) >> 1 & 7) < 2)) {
      if (plVar1[7] == elem[7]) {
        ly_vlog(ctx_00,LYE_DUPLEAFLIST,LY_VLOG_LYD,elem,*(undefined8 *)*elem,elem[7],UNUSED_cb_data)
        ;
        iVar4 = 1;
      }
      else {
        iVar4 = 0;
      }
    }
    else {
      iVar4 = 0;
    }
  }
  else if (*(int *)(*plVar1 + 0x38) == 0x10) {
    lVar2 = *plVar1;
    if (*(char *)(lVar2 + 0x1e) == '\0') {
      iVar4 = 0;
    }
    else {
      for (i = 0; i < (int)(uint)*(byte *)(lVar2 + 0x1e); i = i + 1) {
        plVar3 = *(lys_node **)(*(long *)(lVar2 + 0x88) + (long)i * 8);
        val2 = (char *)0x0;
        val1 = (char *)0x0;
        for (diter = (lyd_node *)plVar1[8]; diter != (lyd_node *)0x0; diter = diter->next) {
          if (plVar3 == diter->schema) {
            val1 = (char *)diter->ht;
            break;
          }
        }
        for (diter = (lyd_node *)elem[8]; diter != (lyd_node *)0x0; diter = diter->next) {
          if (plVar3 == diter->schema) {
            val2 = (char *)diter->ht;
            break;
          }
        }
        if (val1 != val2) {
          return 0;
        }
      }
      ly_vlog(ctx_00,LYE_DUPLIST,LY_VLOG_LYD,elem,*(undefined8 *)*elem,in_R9,UNUSED_cb_data);
      iVar4 = 1;
    }
  }
  else {
    ly_log(ctx_00,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
           ,0x1b8);
    iVar4 = 1;
  }
  return iVar4;
}



int lyv_data_dup(lyd_node *node,lyd_node *start)

{
  ly_ctx *ctx_00;
  char *__s;
  hash_table *__s_00;
  int iVar1;
  uint32_t hash_00;
  ly_set *set_00;
  size_t sVar2;
  byte bVar3;
  lyd_node *start_local;
  lyd_node *node_local;
  int i;
  int ret;
  uint32_t hash;
  uint32_t u;
  uint32_t usize;
  lyd_node *diter;
  lyd_node *key;
  hash_table *keystable;
  ly_ctx *ctx;
  ly_set *set;
  char *id;
  
  ret = 0;
  keystable = (hash_table *)0x0;
  ctx_00 = node->schema->module->ctx;
  start_local = start;
  if (start == (lyd_node *)0x0) {
    start_local = lyd_first_sibling(node);
  }
  set_00 = ly_set_new();
  for (diter = start_local; diter != (lyd_node *)0x0; diter = diter->next) {
    if (diter->schema == node->schema) {
      diter->validity = diter->validity & 0xfe;
      ly_set_add(set_00,diter,1);
    }
  }
  if (set_00->number == 2) {
    iVar1 = lyv_list_equal((set_00->set).s,(set_00->set).s + 1,0,(void *)0x0);
    if (iVar1 != 0) {
      ly_set_free(set_00);
      return 1;
    }
  }
  else if (2 < set_00->number) {
    for (u = 0x1f;
        (bVar3 = (byte)u, u != 0 &&
        ((set_00->number << (bVar3 & 0x1f)) >> (bVar3 & 0x1f) != set_00->number)); u = u - 1) {
    }
    if (u == 0) {
      ly_log(ctx_00,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
             ,0x1ee);
      ret = 1;
    }
    else {
      keystable = lyht_new(1 << (0x20 - bVar3 & 0x1f),8,lyv_list_equal,(void *)0x0,0);
      if (keystable == (hash_table *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyv_data_dup");
        ret = 1;
      }
      else {
        for (u = 0; u < set_00->number; u = u + 1) {
          if (node->schema->nodetype == LYS_LEAFLIST) {
            __s = *(char **)&(set_00->set).s[u]->nodetype;
            sVar2 = strlen(__s);
            hash = dict_hash_multi(0,__s,sVar2);
          }
          else {
            i = 0;
            hash = 0;
            key = (lyd_node *)(set_00->set).s[u]->parent;
            for (; i < (int)(uint)(byte)(set_00->set).s[u]->name[0x1e]; i = i + 1) {
              __s_00 = key->ht;
              sVar2 = strlen((char *)__s_00);
              hash = dict_hash_multi(hash,(char *)__s_00,sVar2);
              key = key->next;
            }
          }
          hash_00 = dict_hash_multi(hash,(char *)0x0,0);
          iVar1 = lyht_insert(keystable,(set_00->set).s + u,hash_00,(void **)0x0);
          if (iVar1 != 0) {
            ret = 1;
            break;
          }
        }
      }
    }
  }
  ly_set_free(set_00);
  lyht_free(keystable);
  return ret;
}



lys_type * find_orig_type(lys_type *par_type,LY_DATA_TYPE base_type)

{
  lys_type *plVar1;
  long in_FS_OFFSET;
  LY_DATA_TYPE base_type_local;
  lys_type *par_type_local;
  int found;
  lys_type *type;
  lys_type *prev_type;
  lys_type *tmp_type;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  type = par_type;
  while ((type->der->type).der != (lys_tpdf *)0x0) {
    type = &type->der->type;
  }
  plVar1 = type;
  if (base_type != type->base) {
    if ((type->base == LY_TYPE_LEAFREF) && ((type->value_flags & 1) == 0)) {
      if ((type->info).lref.target == (lys_node_leaf *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("type->info.lref.target",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                      ,0x229,"find_orig_type");
      }
      plVar1 = find_orig_type(&((type->info).lref.target)->type,base_type);
    }
    else if (type->base == LY_TYPE_UNION) {
      prev_type = (lys_type *)0x0;
      do {
        found = 0;
        prev_type = lyp_get_next_union_type(type,prev_type,&found);
        if (prev_type == (lys_type *)0x0) goto LAB_001311e0;
        tmp_type = find_orig_type(prev_type,base_type);
        plVar1 = tmp_type;
      } while (tmp_type == (lys_type *)0x0);
    }
    else {
LAB_001311e0:
      plVar1 = (lys_type *)0x0;
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyv_extension(lys_ext_instance **ext,uint8_t size,lyd_node *node)

{
  int iVar1;
  lyd_node *node_local;
  uint8_t size_local;
  lys_ext_instance **ext_local;
  uint i;
  
  i = 0;
  while( true ) {
    if (size <= i) {
      return 0;
    }
    if ((((ext[i]->flags & 8) != 0) &&
        (ext[i]->def->plugin->valid_data != (lyext_valid_data_clb)0x0)) &&
       (iVar1 = (*ext[i]->def->plugin->valid_data)(ext[i],node), iVar1 != 0)) break;
    i = i + 1;
  }
  return 1;
}



// WARNING: Type propagation algorithm not settling

int lyv_type_extension(lyd_node_leaf_list *leaf,lys_type *type,int first_type)

{
  lys_tpdf *plVar1;
  int iVar2;
  int first_type_local;
  lys_type *type_local;
  lyd_node_leaf_list *leaf_local;
  uint i;
  lyd_node *node;
  
  type_local = type;
  if (true) {
    switch(type->base) {
    case LY_TYPE_BITS:
      if (first_type != 0) {
        type_local = find_orig_type((lys_type *)&leaf->schema[1].ref,LY_TYPE_BITS);
        for (i = 0; i < (type_local->info).bits.count; i = i + 1) {
          if ((*(long *)((leaf->value).binary + (ulong)i * 8) != 0) &&
             (iVar2 = lyv_extension(*(lys_ext_instance ***)
                                     (*(long *)((leaf->value).binary + (ulong)i * 8) + 0x20),
                                    *(uint8_t *)
                                     (*(long *)((leaf->value).binary + (ulong)i * 8) + 0x1a),
                                    (lyd_node *)leaf), iVar2 != 0)) {
            return 1;
          }
        }
      }
      break;
    case LY_TYPE_DEC64:
      if (((type->info).bits.bit != (lys_type_bit *)0x0) &&
         (iVar2 = lyv_extension(((type->info).dec64.range)->ext,((type->info).dec64.range)->ext_size
                                ,(lyd_node *)leaf), iVar2 != 0)) {
        return 1;
      }
      break;
    case LY_TYPE_ENUM:
      if ((first_type != 0) &&
         (iVar2 = lyv_extension(((leaf->value).enm)->ext,((leaf->value).enm)->ext_size,
                                (lyd_node *)leaf), iVar2 != 0)) {
        return 1;
      }
      break;
    case LY_TYPE_STRING:
      if (((type->info).bits.bit != (lys_type_bit *)0x0) &&
         (iVar2 = lyv_extension(((type->info).dec64.range)->ext,((type->info).dec64.range)->ext_size
                                ,(lyd_node *)leaf), iVar2 != 0)) {
        return 1;
      }
      for (i = 0; i < (type->info).str.pat_count; i = i + 1) {
        iVar2 = lyv_extension(*(lys_ext_instance ***)
                               (((type->info).lref.target)->padding + (ulong)i * 0x38 + 0xc),
                              ((type->info).lref.target)->padding[(ulong)i * 0x38 + 0x14],
                              (lyd_node *)leaf);
        if (iVar2 != 0) {
          return 1;
        }
      }
      break;
    case LY_TYPE_UNION:
      i = 0;
      while ((i < (type->info).bits.count &&
             (*(LY_DATA_TYPE *)((long)(type->info).bits.bit + (ulong)i * 0x40) != leaf->value_type))
            ) {
        i = i + 1;
      }
      if ((i < (type->info).bits.count) &&
         (iVar2 = lyv_type_extension(leaf,(lys_type *)
                                          ((long)(type->info).bits.bit + (ulong)i * 0x40),first_type
                                    ), iVar2 != 0)) {
        return 1;
      }
      break;
    case LY_TYPE_INT8:
    case LY_TYPE_UINT8:
    case LY_TYPE_INT16:
    case LY_TYPE_UINT16:
    case LY_TYPE_INT32:
    case LY_TYPE_UINT32:
    case LY_TYPE_INT64:
    case LY_TYPE_UINT64:
      if (((type->info).bits.bit != (lys_type_bit *)0x0) &&
         (iVar2 = lyv_extension(((type->info).dec64.range)->ext,((type->info).dec64.range)->ext_size
                                ,(lyd_node *)leaf), iVar2 != 0)) {
        return 1;
      }
    }
  }
  iVar2 = lyv_extension(type_local->ext,type_local->ext_size,(lyd_node *)leaf);
  while( true ) {
    if (iVar2 != 0) {
      return 1;
    }
    do {
      if ((type_local->der->type).der == (lys_tpdf *)0x0) {
        return 0;
      }
      plVar1 = type_local->der;
      type_local = &plVar1->type;
    } while ((((plVar1->type).parent)->flags & 0x2000) == 0);
    iVar2 = lyv_type_extension(leaf,type_local,0);
    if (iVar2 != 0) break;
    iVar2 = lyv_extension(((plVar1->type).parent)->ext,((plVar1->type).parent)->ext_size,
                          (lyd_node *)leaf);
  }
  return 1;
}



int lyv_data_content(lyd_node *node,int options,unres_data *unres)

{
  lys_node *node_00;
  ly_ctx *ctx_00;
  lyd_node *plVar1;
  int iVar2;
  uint uVar3;
  lys_node *plVar4;
  char *pcVar5;
  unres_data *unres_local;
  int options_local;
  lyd_node *node_local;
  uint8_t iff_size;
  uint i;
  uint j;
  lys_node *siter;
  lyd_node *diter;
  lys_tpdf *tpdf;
  lys_type *type;
  lys_iffeature *iff;
  char *id;
  char *idname;
  lyd_node *start;
  lys_node *schema;
  ly_ctx *ctx;
  lys_node *parent;
  lys_ident *ident;
  lyd_node_leaf_list *leaf;
  
  type = (lys_type *)0x0;
  j = 0;
  if (node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                  ,0x2b2,"lyv_data_content");
  }
  if (node->schema == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node->schema",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                  ,0x2b3,"lyv_data_content");
  }
  if (unres == (unres_data *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("unres",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                  ,0x2b4,"lyv_data_content");
  }
  node_00 = node->schema;
  ctx_00 = node_00->module->ctx;
  options_local = options;
  if ((node->schema->nodetype & 0x4180) == LYS_UNKNOWN) {
    diter = node->parent;
    while ((diter != (lyd_node *)0x0 && ((diter->schema->nodetype & 0x4180) == LYS_UNKNOWN))) {
      diter = diter->parent;
    }
    if ((diter == (lyd_node *)0x0) && ((options & 0x50U) != 0)) {
      options_local = options | 0x2000;
    }
  }
  if ((node->validity & 4) != 0) {
    if ((options_local & 0x2080U) == 0) {
      if (((node_00->nodetype == LYS_LIST) && ((options_local & 6U) == 0)) &&
         (iVar2 = lyv_keys(node), iVar2 != 0)) {
        return 1;
      }
      if ((node_00->nodetype & (LYS_CONTAINER|LYS_LEAF|LYS_ANYDATA)) != LYS_UNKNOWN) {
        for (diter = lyd_first_sibling(node); diter != (lyd_node *)0x0; diter = diter->next) {
          if ((node_00 == diter->schema) && (diter != node)) {
            plVar4 = lys_parent(node_00);
            if (plVar4 == (lys_node *)0x0) {
              pcVar5 = "data tree";
            }
            else if (plVar4->nodetype == LYS_EXT) {
              pcVar5 = plVar4->ref;
            }
            else {
              pcVar5 = plVar4->name;
            }
            ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYD,node,node_00->name,pcVar5);
            return 1;
          }
        }
      }
      if ((options_local & 0x800U) != 0) {
        siter = node->schema;
        do {
          if (((siter->flags & 0x38) == 0x20) && ((options_local & 0x800U) != 0)) {
            ly_vlog(ctx_00,LYE_OBSDATA,LY_VLOG_LYD,node,node_00->name);
            return 1;
          }
          siter = lys_parent(siter);
        } while ((siter != (lys_node *)0x0) &&
                ((siter->nodetype & (LYS_CONTAINER|LYS_LEAF|LYS_LEAFLIST|LYS_LIST|LYS_ANYDATA)) ==
                 LYS_UNKNOWN));
        if ((node_00->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) {
          if ((options_local & 0x800U) != 0) {
            for (tpdf = (lys_tpdf *)node->schema[1].ext; tpdf != (lys_tpdf *)0x0;
                tpdf = (tpdf->type).der) {
              if ((tpdf->flags & 0x38) == 0x20) {
                ly_vlog(ctx_00,LYE_OBSTYPE,LY_VLOG_LYD,node,node_00->name,tpdf->name);
                return 1;
              }
            }
          }
          if (*(int *)&node[1].schema == 7) {
            plVar1 = node->child;
            iVar2 = lyp_check_status(node_00->flags,node_00->module,node_00->name,
                                     *(uint16_t *)&plVar1->next,*(lys_module **)&plVar1->hash,
                                     (char *)plVar1->schema,(lys_node *)0x0);
            if (iVar2 != 0) {
              ly_vlog(ctx_00,LYE_PATH,LY_VLOG_LYD,node);
              return 1;
            }
          }
        }
      }
    }
    if ((node_00->flags & 0x2000) != 0) {
      iVar2 = lyv_extension(node_00->ext,node_00->ext_size,node);
      if (iVar2 != 0) {
        return 1;
      }
      if ((node_00->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) {
        type = (lys_type *)&node_00[1].ref;
        iVar2 = lyv_type_extension((lyd_node_leaf_list *)node,type,1);
        if (iVar2 != 0) {
          return 1;
        }
      }
    }
    node->validity = node->validity & 0xfb;
  }
  if ((node_00->nodetype & 0x4191) != LYS_UNKNOWN) {
    siter = (lys_node *)0x0;
    do {
      siter = lys_getnext(siter,node_00,(lys_module *)0x0,0);
      if (siter == (lys_node *)0x0) break;
      if ((siter->nodetype & (LYS_LEAFLIST|LYS_LIST)) != LYS_UNKNOWN) {
        for (diter = node->child; diter != (lyd_node *)0x0; diter = diter->next) {
          if ((siter == diter->schema) && ((diter->validity & 1) != 0)) {
            if ((options_local & 0x2006U) == 0) {
              iVar2 = lyv_data_dup(diter,node->child);
              if (iVar2 != 0) {
                return 1;
              }
            }
            else {
              diter->validity = diter->validity & 0xfe;
            }
            break;
          }
        }
      }
    } while( true );
  }
  if ((node->validity & 2) != 0) {
    if ((options_local & 0x2000U) == 0) {
      iVar2 = unres_data_add(unres,node,UNRES_UNIQ_LEAVES);
      if (iVar2 != 0) {
        return 1;
      }
    }
    else {
      node->validity = node->validity & 0xfd;
    }
  }
  if ((node_00->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) goto LAB_00131f90;
  uVar3 = *(uint *)&node[1].schema;
  if (uVar3 == 7) {
    id = "Identity";
    idname = (char *)node->ht;
    iff_size = *(uint8_t *)((long)&node->child->next + 3);
    iff = (lys_iffeature *)node->child->parent;
  }
  else {
    if (uVar3 < 8) {
      if (uVar3 == 2) {
        id = "Bit";
        type = find_orig_type((lys_type *)&node->schema[1].ref,LY_TYPE_BITS);
        j = 0;
        goto LAB_00131e38;
      }
      if (uVar3 == 6) {
        id = "Enum";
        idname = (char *)node->ht;
        iff_size = *(uint8_t *)((long)&node->child->next + 3);
        iff = (lys_iffeature *)node->child->parent;
        goto LAB_00131ebf;
      }
    }
    iff_size = '\0';
  }
LAB_00131ebf:
  if (iff_size != '\0') {
    for (i = 0; i < iff_size; i = i + 1) {
      iVar2 = resolve_iffeature(iff + i);
      if (iVar2 == 0) {
        ly_vlog(ctx_00,LYE_INVAL,LY_VLOG_LYD,node,node->ht,node_00->name);
        ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                "%s \"%s\" is disabled by its if-feature condition.",id,idname);
        return 1;
      }
    }
    if (*(int *)&node[1].schema != 2) goto LAB_00131f90;
    do {
      j = j + 1;
LAB_00131e38:
      iff_size = '\0';
      if ((type->info).bits.count <= j) goto LAB_00131ebf;
    } while ((&node->child->schema)[j] == (lys_node *)0x0);
    idname = (&node->child->schema)[j]->name;
    iff_size = (&node->child->schema)[j]->iffeature_size;
    iff = (&node->child->schema)[j]->iffeature;
    goto LAB_00131ebf;
  }
LAB_00131f90:
  if ((options_local & 0x208eU) == 0) {
    uVar3 = resolve_applies_must(node);
    if (((uVar3 & 1) != 0) && (iVar2 = unres_data_add(unres,node,UNRES_MUST), iVar2 != 0)) {
      return 1;
    }
    if (((uVar3 & 2) != 0) && (iVar2 = unres_data_add(unres,node,UNRES_MUST_INOUT), iVar2 != 0)) {
      return 1;
    }
  }
  return 0;
}



int lyv_multicases(lyd_node *node,lys_node *schemanode,lyd_node **first_sibling,int autodelete,
                  lyd_node *nodel)

{
  lyd_node *plVar1;
  lys_node *plVar2;
  lyd_node *nodel_local;
  int autodelete_local;
  lyd_node **first_sibling_local;
  lys_node *schemanode_local;
  lyd_node *node_local;
  lys_node *sparent;
  lys_node *schoice;
  lys_node *scase;
  lyd_node *next;
  lyd_node *iter;
  lys_node *saux;
  
  if ((node == (lyd_node *)0x0) && (schemanode == (lys_node *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("node || schemanode",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/validation.c"
                  ,0x382,"lyv_multicases");
  }
  schemanode_local = schemanode;
  if (schemanode == (lys_node *)0x0) {
    schemanode_local = node->schema;
  }
  for (sparent = lys_parent(schemanode_local);
      (sparent != (lys_node *)0x0 && (sparent->nodetype == LYS_USES)); sparent = lys_parent(sparent)
      ) {
  }
  if ((((sparent != (lys_node *)0x0) && ((sparent->nodetype & (LYS_CHOICE|LYS_CASE)) != LYS_UNKNOWN)
       ) && (first_sibling != (lyd_node **)0x0)) && (*first_sibling != (lyd_node *)0x0)) {
    if (sparent->nodetype == LYS_CHOICE) {
      schoice = sparent;
      scase = schemanode_local;
    }
    else {
      schoice = lys_parent(sparent);
      scase = sparent;
    }
    while( true ) {
      plVar1 = *first_sibling;
      while (iter = plVar1, iter != (lyd_node *)0x0) {
        plVar1 = iter->next;
        if (schemanode_local != iter->schema) {
          for (sparent = lys_parent(iter->schema);
              (sparent != (lys_node *)0x0 && (sparent->nodetype == LYS_USES));
              sparent = lys_parent(sparent)) {
          }
          if ((sparent != (lys_node *)0x0) &&
             (((sparent->nodetype == LYS_CHOICE && (sparent == schoice)) ||
              ((sparent->nodetype == LYS_CASE &&
               ((sparent != scase && (plVar2 = lys_parent(sparent), schoice == plVar2)))))))) {
            if (autodelete == 0) {
              ly_vlog(schemanode_local->module->ctx,LYE_MCASEDATA,LY_VLOG_LYD,iter,schoice->name);
              return 1;
            }
            if (iter == nodel) {
              ly_vlog(schemanode_local->module->ctx,LYE_MCASEDATA,LY_VLOG_LYD,iter,schoice->name);
              return 2;
            }
            if (iter == *first_sibling) {
              *first_sibling = plVar1;
            }
            lyd_free(iter);
          }
        }
      }
      if (((*first_sibling == (lyd_node *)0x0) ||
          (scase = lys_parent(schoice), scase == (lys_node *)0x0)) ||
         ((scase->nodetype & LYS_CASE) == LYS_UNKNOWN)) break;
      schoice = lys_parent(scase);
    }
  }
  return 0;
}



lyxml_ns * lyxml_get_ns(lyxml_elem *elem,char *prefix)

{
  int iVar1;
  lyxml_ns *plVar2;
  char *prefix_local;
  lyxml_elem *elem_local;
  lyxml_attr *attr;
  
  ly_log_dbg(0x20,"%s","lyxml_get_ns");
  if (elem == (lyxml_elem *)0x0) {
    plVar2 = (lyxml_ns *)0x0;
  }
  else {
    for (attr = elem->attr; attr != (lyxml_attr *)0x0; attr = attr->next) {
      if (attr->type == LYXML_ATTR_NS) {
        if (attr->name == (char *)0x0) {
          if (prefix == (char *)0x0) {
            if (attr->value != (char *)0x0) {
              return (lyxml_ns *)attr;
            }
            return (lyxml_ns *)0x0;
          }
        }
        else if ((prefix != (char *)0x0) && (iVar1 = strcmp(attr->name,prefix), iVar1 == 0)) {
          return (lyxml_ns *)attr;
        }
      }
    }
    plVar2 = lyxml_get_ns(elem->parent,prefix);
  }
  return plVar2;
}



void lyxml_correct_attr_ns(ly_ctx *ctx,lyxml_attr *attr,lyxml_elem *attr_parent,int copy_ns)

{
  lyxml_ns *plVar1;
  lyxml_attr *plVar2;
  int copy_ns_local;
  lyxml_elem *attr_parent_local;
  lyxml_attr *attr_local;
  ly_ctx *ctx_local;
  lyxml_elem *ns_root;
  lyxml_elem *attr_root;
  lyxml_ns *tmp_ns;
  
  if ((attr->type != LYXML_ATTR_NS) && (attr_root = attr_parent, attr->ns != (lyxml_ns *)0x0)) {
    for (; attr_root->parent != (lyxml_elem *)0x0; attr_root = attr_root->parent) {
    }
    for (ns_root = attr->ns->parent; ns_root->parent != (lyxml_elem *)0x0; ns_root = ns_root->parent
        ) {
    }
    if (ns_root != attr_root) {
      if (copy_ns == 0) {
        attr->ns = (lyxml_ns *)0x0;
      }
      else {
        plVar2 = (lyxml_attr *)attr->ns;
        plVar1 = lyxml_get_ns(attr_parent,plVar2->name);
        attr->ns = plVar1;
        if (attr->ns == (lyxml_ns *)0x0) {
          plVar2 = lyxml_dup_attr(ctx,attr_parent,plVar2);
          attr->ns = (lyxml_ns *)plVar2;
        }
      }
    }
  }
  return;
}



lyxml_attr * lyxml_dup_attr(ly_ctx *ctx,lyxml_elem *parent,lyxml_attr *attr)

{
  char *pcVar1;
  lyxml_attr *attr_local;
  lyxml_elem *parent_local;
  ly_ctx *ctx_local;
  lyxml_attr *result;
  lyxml_attr *a;
  
  if ((attr == (lyxml_attr *)0x0) || (parent == (lyxml_elem *)0x0)) {
    result = (lyxml_attr *)0x0;
  }
  else {
    if (attr->type == LYXML_ATTR_NS) {
      result = (lyxml_attr *)calloc(1,0x28);
    }
    else {
      result = (lyxml_attr *)calloc(1,0x28);
    }
    if (result == (lyxml_attr *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxml_dup_attr");
      result = (lyxml_attr *)0x0;
    }
    else {
      pcVar1 = lydict_insert(ctx,attr->value,0);
      result->value = pcVar1;
      pcVar1 = lydict_insert(ctx,attr->name,0);
      result->name = pcVar1;
      result->type = attr->type;
      if ((result->type == LYXML_ATTR_STD) && (attr->ns != (lyxml_ns *)0x0)) {
        result->ns = attr->ns;
        lyxml_correct_attr_ns(ctx,result,parent,1);
      }
      if (result->type == LYXML_ATTR_NS) {
        result->ns = (lyxml_ns *)parent;
      }
      if (parent->attr == (lyxml_attr *)0x0) {
        parent->attr = result;
      }
      else {
        for (a = parent->attr; a->next != (lyxml_attr *)0x0; a = a->next) {
        }
        a->next = result;
      }
    }
  }
  return result;
}



void lyxml_correct_elem_ns(ly_ctx *ctx,lyxml_elem *elem,int copy_ns,int correct_attrs)

{
  lyxml_ns *plVar1;
  lyxml_attr *plVar2;
  int correct_attrs_local;
  int copy_ns_local;
  lyxml_elem *elem_local;
  ly_ctx *ctx_local;
  lyxml_elem *iter;
  lyxml_attr *attr;
  lyxml_elem *tmp;
  lyxml_elem *elem_root;
  lyxml_elem *ns_root;
  lyxml_ns *tmp_ns;
  
  for (elem_root = elem; iter = elem, elem_root->parent != (lyxml_elem *)0x0;
      elem_root = elem_root->parent) {
  }
  do {
    if (iter == (lyxml_elem *)0x0) {
      return;
    }
    if (iter->ns != (lyxml_ns *)0x0) {
      for (ns_root = iter->ns->parent; ns_root != (lyxml_elem *)0x0; ns_root = ns_root->parent) {
      }
      if (elem_root != (lyxml_elem *)0x0) {
        if (copy_ns == 0) {
          iter->ns = (lyxml_ns *)0x0;
        }
        else {
          plVar2 = (lyxml_attr *)iter->ns;
          plVar1 = lyxml_get_ns(iter,plVar2->name);
          iter->ns = plVar1;
          if (iter->ns == (lyxml_ns *)0x0) {
            plVar2 = lyxml_dup_attr(ctx,iter,plVar2);
            iter->ns = (lyxml_ns *)plVar2;
          }
        }
      }
    }
    if (correct_attrs != 0) {
      for (attr = iter->attr; attr != (lyxml_attr *)0x0; attr = attr->next) {
        lyxml_correct_attr_ns(ctx,attr,elem_root,copy_ns);
      }
    }
    tmp = iter->child;
    if (tmp == (lyxml_elem *)0x0) {
      if (iter == elem) {
        return;
      }
      tmp = iter->next;
    }
    while ((tmp == (lyxml_elem *)0x0 && (iter = iter->parent, iter->parent != elem->parent))) {
      tmp = iter->next;
    }
    iter = tmp;
  } while( true );
}



lyxml_elem *
lyxml_dup_elem(ly_ctx *ctx,lyxml_elem *elem,lyxml_elem *parent,int recursive,int with_siblings)

{
  lyxml_elem *elem_00;
  char *pcVar1;
  int with_siblings_local;
  int recursive_local;
  lyxml_elem *parent_local;
  lyxml_elem *elem_local;
  ly_ctx *ctx_local;
  lyxml_elem *result;
  lyxml_attr *attr;
  lyxml_elem *dup;
  
  result = (lyxml_elem *)0x0;
  elem_local = elem;
  if (elem == (lyxml_elem *)0x0) {
    result = (lyxml_elem *)0x0;
  }
  else {
    for (; elem_local != (lyxml_elem *)0x0; elem_local = elem_local->next) {
      elem_00 = (lyxml_elem *)calloc(1,0x48);
      if (elem_00 == (lyxml_elem *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxml_dup_elem");
        return (lyxml_elem *)0x0;
      }
      pcVar1 = lydict_insert(ctx,elem_local->content,0);
      elem_00->content = pcVar1;
      pcVar1 = lydict_insert(ctx,elem_local->name,0);
      elem_00->name = pcVar1;
      elem_00->flags = elem_local->flags;
      elem_00->prev = elem_00;
      if (parent == (lyxml_elem *)0x0) {
        if (result != (lyxml_elem *)0x0) {
          elem_00->prev = result->prev;
          elem_00->prev->next = elem_00;
          result->prev = elem_00;
        }
      }
      else {
        lyxml_add_child(ctx,parent,elem_00);
      }
      elem_00->ns = elem_local->ns;
      for (attr = elem_local->attr; attr != (lyxml_attr *)0x0; attr = attr->next) {
        lyxml_dup_attr(ctx,elem_00,attr);
      }
      lyxml_correct_elem_ns(ctx,elem_00,1,0);
      if (recursive != 0) {
        lyxml_dup_elem(ctx,elem_local->child,elem_00,1,1);
      }
      if (result == (lyxml_elem *)0x0) {
        result = elem_00;
      }
      if (with_siblings == 0) {
        return result;
      }
    }
  }
  return result;
}



lyxml_elem * lyxml_dup(ly_ctx *ctx,lyxml_elem *root)

{
  lyxml_elem *plVar1;
  lyxml_elem *root_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","lyxml_dup");
  plVar1 = lyxml_dup_elem(ctx,root,(lyxml_elem *)0x0,1,0);
  return plVar1;
}



void lyxml_unlink_elem(ly_ctx *ctx,lyxml_elem *elem,int copy_ns)

{
  lyxml_elem *plVar1;
  int copy_ns_local;
  lyxml_elem *elem_local;
  ly_ctx *ctx_local;
  lyxml_elem *first;
  lyxml_elem *parent;
  
  if (elem != (lyxml_elem *)0x0) {
    plVar1 = elem->parent;
    if (plVar1 != (lyxml_elem *)0x0) {
      if (elem == plVar1->child) {
        plVar1->child = elem->next;
      }
      elem->parent = (lyxml_elem *)0x0;
    }
    if (copy_ns < 2) {
      lyxml_correct_elem_ns(ctx,elem,copy_ns,1);
    }
    if (elem != elem->prev) {
      if (elem->next == (lyxml_elem *)0x0) {
        first = elem;
        if (plVar1 == (lyxml_elem *)0x0) {
          while (first->prev->next != (lyxml_elem *)0x0) {
            first = first->prev;
          }
        }
        else {
          first = plVar1->child;
        }
        first->prev = elem->prev;
      }
      else {
        elem->next->prev = elem->prev;
      }
      if (elem->prev->next != (lyxml_elem *)0x0) {
        elem->prev->next = elem->next;
      }
      elem->next = (lyxml_elem *)0x0;
      elem->prev = elem;
    }
  }
  return;
}



void lyxml_unlink(ly_ctx *ctx,lyxml_elem *elem)

{
  lyxml_elem *elem_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","lyxml_unlink");
  if (elem != (lyxml_elem *)0x0) {
    lyxml_unlink_elem(ctx,elem,1);
  }
  return;
}



void lyxml_free_attr(ly_ctx *ctx,lyxml_elem *parent,lyxml_attr *attr)

{
  lyxml_attr *attr_local;
  lyxml_elem *parent_local;
  ly_ctx *ctx_local;
  lyxml_attr *aiter;
  lyxml_attr *aprev;
  
  if (attr != (lyxml_attr *)0x0) {
    if (parent != (lyxml_elem *)0x0) {
      aprev = (lyxml_attr *)0x0;
      for (aiter = parent->attr; (aiter != (lyxml_attr *)0x0 && (aiter != attr));
          aiter = aiter->next) {
        aprev = aiter;
      }
      if (aiter == (lyxml_attr *)0x0) {
        return;
      }
      if (aprev == (lyxml_attr *)0x0) {
        parent->attr = attr->next;
      }
      else {
        aprev->next = attr->next;
      }
    }
    lydict_remove(ctx,attr->name);
    lydict_remove(ctx,attr->value);
    free(attr);
  }
  return;
}



void lyxml_free_attrs(ly_ctx *ctx,lyxml_elem *elem)

{
  lyxml_attr *plVar1;
  lyxml_elem *elem_local;
  ly_ctx *ctx_local;
  lyxml_attr *a;
  lyxml_attr *next;
  
  if ((elem != (lyxml_elem *)0x0) && (elem->attr != (lyxml_attr *)0x0)) {
    a = elem->attr;
    do {
      plVar1 = a->next;
      lydict_remove(ctx,a->name);
      lydict_remove(ctx,a->value);
      free(a);
      a = plVar1;
    } while (plVar1 != (lyxml_attr *)0x0);
  }
  return;
}



void lyxml_free_elem(ly_ctx *ctx,lyxml_elem *elem)

{
  lyxml_elem *plVar1;
  lyxml_elem *elem_local;
  ly_ctx *ctx_local;
  lyxml_elem *e;
  lyxml_elem *next;
  
  if (elem != (lyxml_elem *)0x0) {
    lyxml_free_attrs(ctx,elem);
    e = elem->child;
    while (e != (lyxml_elem *)0x0) {
      plVar1 = e->next;
      lyxml_free_elem(ctx,e);
      e = plVar1;
    }
    lydict_remove(ctx,elem->name);
    lydict_remove(ctx,elem->content);
    free(elem);
  }
  return;
}



void lyxml_free(ly_ctx *ctx,lyxml_elem *elem)

{
  lyxml_elem *elem_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","lyxml_free");
  if (elem != (lyxml_elem *)0x0) {
    lyxml_unlink_elem(ctx,elem,2);
    lyxml_free_elem(ctx,elem);
  }
  return;
}



void lyxml_free_withsiblings(ly_ctx *ctx,lyxml_elem *elem)

{
  lyxml_elem *plVar1;
  lyxml_elem *elem_local;
  ly_ctx *ctx_local;
  lyxml_elem *iter;
  lyxml_elem *aux;
  
  ly_log_dbg(0x20,"%s","lyxml_free_withsiblings");
  if (elem != (lyxml_elem *)0x0) {
    iter = elem->prev;
    while (plVar1 = elem, iter->next != (lyxml_elem *)0x0) {
      plVar1 = iter->prev;
      lyxml_free(ctx,iter);
      iter = plVar1;
    }
    while (iter = plVar1, iter != (lyxml_elem *)0x0) {
      plVar1 = iter->next;
      lyxml_free(ctx,iter);
    }
  }
  return;
}



char * lyxml_get_attr(lyxml_elem *elem,char *name,char *ns)

{
  int iVar1;
  char *ns_local;
  char *name_local;
  lyxml_elem *elem_local;
  lyxml_attr *a;
  
  ly_log_dbg(0x20,"%s","lyxml_get_attr");
  if (elem == (lyxml_elem *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("elem",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xml.c"
                  ,0x1bc,"lyxml_get_attr");
  }
  if (name != (char *)0x0) {
    a = elem->attr;
    while( true ) {
      if (a == (lyxml_attr *)0x0) {
        return (char *)0x0;
      }
      if (((a->type == LYXML_ATTR_STD) && (iVar1 = strcmp(name,a->name), iVar1 == 0)) &&
         (((ns == (char *)0x0 && (a->ns == (lyxml_ns *)0x0)) ||
          (((ns != (char *)0x0 && (a->ns != (lyxml_ns *)0x0)) &&
           (iVar1 = strcmp(ns,a->ns->value), iVar1 == 0)))))) break;
      a = a->next;
    }
    return a->value;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("name",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xml.c"
                ,0x1bd,"lyxml_get_attr");
}



int lyxml_add_child(ly_ctx *ctx,lyxml_elem *parent,lyxml_elem *elem)

{
  lyxml_elem *plVar1;
  lyxml_elem *elem_local;
  lyxml_elem *parent_local;
  ly_ctx *ctx_local;
  lyxml_elem *e;
  
  if (parent == (lyxml_elem *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("parent",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xml.c"
                  ,0x1d3,"lyxml_add_child");
  }
  if (elem == (lyxml_elem *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("elem",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xml.c"
                  ,0x1d4,"lyxml_add_child");
  }
  if (elem->parent != (lyxml_elem *)0x0) {
    lyxml_unlink_elem(ctx,elem,1);
  }
  elem->parent = parent;
  if (parent->child == (lyxml_elem *)0x0) {
    parent->child = elem;
    elem->prev = elem;
    elem->next = (lyxml_elem *)0x0;
  }
  else {
    plVar1 = parent->child;
    elem->prev = plVar1->prev;
    elem->next = (lyxml_elem *)0x0;
    elem->prev->next = elem;
    plVar1->prev = elem;
  }
  return 0;
}



int lyxml_getutf8(ly_ctx *ctx,char *buf,uint *read)

{
  uint *read_local;
  char *buf_local;
  ly_ctx *ctx_local;
  int c;
  int i;
  int aux;
  
  c = (int)*buf;
  *read = 0;
  if (c == 0) {
    ly_vlog(ctx,LYE_EOF,LY_VLOG_NONE,(void *)0x0);
    c = 0;
  }
  else {
    *read = 1;
    if ((c & 0xf8U) == 0xf0) {
      *read = 4;
      c = c & 7;
      for (i = 1; i < 4; i = i + 1) {
        if (((int)buf[i] & 0xc0U) != 0x80) {
          ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"input character");
          return 0;
        }
        c = (int)buf[i] & 0x3fU | c << 6;
      }
      if ((c < 0x1000) || (0x10ffff < c)) {
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"input character");
        c = 0;
      }
    }
    else if ((c & 0xf0U) == 0xe0) {
      *read = 3;
      c = c & 0xf;
      for (i = 1; i < 3; i = i + 1) {
        if (((int)buf[i] & 0xc0U) != 0x80) {
          ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"input character");
          return 0;
        }
        c = (int)buf[i] & 0x3fU | c << 6;
      }
      if (((c < 0x800) || ((0xd7ff < c && (c < 0xe000)))) || (0xfffd < c)) {
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"input character");
        c = 0;
      }
    }
    else if ((c & 0xe0U) == 0xc0) {
      *read = 2;
      if (((int)buf[1] & 0xc0U) == 0x80) {
        c = (int)buf[1] & 0x3fU | (c & 0x1fU) << 6;
        if ((uint)c < 0x80) {
          ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"input character");
          c = 0;
        }
      }
      else {
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"input character");
        c = 0;
      }
    }
    else if ((c & 0x80U) == 0) {
      if ((((c < 0x20) && (c != 9)) && (c != 10)) && (c != 0xd)) {
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"input character");
        c = 0;
      }
    }
    else {
      ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"input character");
      c = 0;
    }
  }
  return c;
}



int parse_ignore(ly_ctx *ctx,char *data,char *endstr,uint *len)

{
  char cVar1;
  int iVar2;
  size_t sVar3;
  uint *len_local;
  char *endstr_local;
  char *data_local;
  ly_ctx *ctx_local;
  uint slen;
  char *c;
  
  sVar3 = strlen(endstr);
  for (c = data; *c != '\0'; c = c + 1) {
    iVar2 = strncmp(c,endstr,sVar3 & 0xffffffff);
    if (iVar2 == 0) break;
  }
  cVar1 = *c;
  if (cVar1 != '\0') {
    *len = ((int)c + (int)sVar3) - (int)data;
  }
  else {
    ly_vlog(ctx,LYE_XML_MISS,LY_VLOG_NONE,(void *)0x0,"closing sequence",endstr);
  }
  return (int)(cVar1 == '\0');
}



char * parse_text(ly_ctx *ctx,char *data,char delim,uint *len)

{
  long lVar1;
  bool bVar2;
  uint uVar3;
  int iVar4;
  ushort **ppuVar5;
  long in_FS_OFFSET;
  uint *len_local;
  char delim_local;
  char *data_local;
  ly_ctx *ctx_local;
  uint r;
  int o;
  int size;
  int cdsect;
  int32_t n;
  char *result;
  char *aux;
  char buf [1024];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  result = (char *)0x0;
  size = 0;
  bVar2 = false;
  o = 0;
  *len = 0;
  do {
    if ((bVar2) || (delim != data[*len])) {
      if ((data[*len] == '\0') || ((!bVar2 && (iVar4 = strncmp(data + *len,"]]>",3), iVar4 == 0))))
      {
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"element content, \"]]>\" found");
        goto LAB_00134144;
      }
    }
    else if ((delim != '<') || (iVar4 = strncmp(data + *len,"<![CDATA[",9), iVar4 != 0)) {
      if (o != 0) {
        if (result == (char *)0x0) {
          size = o;
          result = (char *)malloc((long)(o + 1));
        }
        else {
          size = size + o;
          result = (char *)realloc(result,(long)(size + 1));
        }
        if (result == (char *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","parse_text");
          result = (char *)0x0;
          goto LAB_00134165;
        }
        memcpy(result + (size - o),buf,(long)o);
      }
      if (result == (char *)0x0) {
        result = strdup("");
        if (result == (char *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","parse_text");
          result = (char *)0x0;
        }
      }
      else {
        result[size] = '\0';
      }
      goto LAB_00134165;
    }
    if (0x3fc < o) {
      if (result == (char *)0x0) {
        size = o;
        result = (char *)malloc((long)(o + 1));
      }
      else {
        size = size + o;
        result = (char *)ly_realloc(result,(long)(size + 1));
      }
      if (result == (char *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","parse_text");
        result = (char *)0x0;
        goto LAB_00134165;
      }
      memcpy(result + (size - o),buf,(long)o);
      o = 0;
    }
    if ((bVar2) || (iVar4 = strncmp(data + *len,"<![CDATA[",9), iVar4 == 0)) {
      if (!bVar2) {
        bVar2 = true;
        *len = *len + 9;
      }
      if ((data[*len] == '\0') || (iVar4 = strncmp(data + *len,"]]>",3), iVar4 != 0)) {
        buf[o] = data[*len];
        *len = *len + 1;
      }
      else {
        *len = *len + 3;
        bVar2 = false;
        o = o + -1;
      }
    }
    else if (data[*len] == '&') {
      *len = *len + 1;
      if (data[*len] == '#') {
        *len = *len + 1;
        ppuVar5 = __ctype_b_loc();
        if (((*ppuVar5)[data[*len]] & 0x800) == 0) {
          uVar3 = *len;
          *len = uVar3 + 1;
          if ((data[uVar3] != 'x') ||
             (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[data[*len]] & 0x1000) == 0)) {
            ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"character reference");
            goto LAB_00134144;
          }
          n = 0;
          while (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[data[*len]] & 0x1000) != 0) {
            ppuVar5 = __ctype_b_loc();
            if (((*ppuVar5)[data[*len]] & 0x800) == 0) {
              if (data[*len] < 'G') {
                r = (int)data[*len] - 0x37;
              }
              else {
                r = (int)data[*len] - 0x57;
              }
            }
            else {
              r = (int)data[*len] - 0x30;
            }
            n = r + n * 0x10;
            *len = *len + 1;
          }
        }
        else {
          n = 0;
          while (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[data[*len]] & 0x800) != 0) {
            n = data[*len] + -0x30 + n * 10;
            *len = *len + 1;
          }
          if (data[*len] != ';') {
            ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,
                    "character reference, missing semicolon");
            goto LAB_00134144;
          }
        }
        uVar3 = pututf8(ctx,buf + o,n);
        if (uVar3 == 0) {
          ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"character reference value");
          goto LAB_00134144;
        }
        o = uVar3 + o + -1;
        *len = *len + 1;
      }
      else {
        iVar4 = strncmp(data + *len,"lt;",3);
        if (iVar4 == 0) {
          buf[o] = '<';
          *len = *len + 3;
        }
        else {
          iVar4 = strncmp(data + *len,"gt;",3);
          if (iVar4 == 0) {
            buf[o] = '>';
            *len = *len + 3;
          }
          else {
            iVar4 = strncmp(data + *len,"amp;",4);
            if (iVar4 == 0) {
              buf[o] = '&';
              *len = *len + 4;
            }
            else {
              iVar4 = strncmp(data + *len,"apos;",5);
              if (iVar4 == 0) {
                buf[o] = '\'';
                *len = *len + 5;
              }
              else {
                iVar4 = strncmp(data + *len,"quot;",5);
                if (iVar4 != 0) {
                  ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,
                          "entity reference (only predefined references are supported)");
LAB_00134144:
                  *len = 0;
                  free(result);
                  result = (char *)0x0;
LAB_00134165:
                  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
                    return result;
                  }
                    // WARNING: Subroutine does not return
                  __stack_chk_fail();
                }
                buf[o] = '\"';
                *len = *len + 5;
              }
            }
          }
        }
      }
    }
    else {
      uVar3 = copyutf8(ctx,buf + o,data + *len);
      if (uVar3 == 0) goto LAB_00134144;
      o = uVar3 + o + -1;
      *len = *len + uVar3;
    }
    o = o + 1;
  } while( true );
}



lyxml_attr * parse_attr(ly_ctx *ctx,char *data,uint *len,lyxml_elem *parent)

{
  char delim_00;
  int iVar1;
  lyxml_attr *plVar2;
  lyxml_ns *plVar3;
  char *pcVar4;
  long in_FS_OFFSET;
  lyxml_elem *parent_local;
  uint *len_local;
  char *data_local;
  ly_ctx *ctx_local;
  char xml_flag;
  uint size;
  int uc;
  char *c;
  char *start;
  char *prefix;
  lyxml_attr *attr;
  lyxml_attr *a;
  char *delim;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  prefix = (char *)0x0;
  attr = (lyxml_attr *)0x0;
  c = data;
  iVar1 = strncmp(data,"xmlns",5);
  if (iVar1 == 0) {
    attr = (lyxml_attr *)calloc(1,0x28);
    if (attr == (lyxml_attr *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","parse_attr");
      plVar2 = (lyxml_attr *)0x0;
      goto LAB_0013490e;
    }
    attr->type = LYXML_ATTR_NS;
    attr->ns = (lyxml_ns *)parent;
    pcVar4 = c + 5;
    if (c[5] == ':') {
      c = c + 6;
      goto LAB_001342af;
    }
  }
  else {
    attr = (lyxml_attr *)calloc(1,0x28);
    if (attr == (lyxml_attr *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","parse_attr");
      plVar2 = (lyxml_attr *)0x0;
      goto LAB_0013490e;
    }
    attr->type = LYXML_ATTR_STD;
LAB_001342af:
    start = c;
    uc = lyxml_getutf8(ctx,c,&size);
    if ((((((uc < 0x61) || (0x7a < uc)) && (uc != 0x5f)) && ((uc < 0x41 || (0x5a < uc)))) &&
        (((uc != 0x3a && (((uc < 0x370 || (0x1fff < uc)) || (uc == 0x37e)))) &&
         ((((uc < 0xc0 || (0x2ff < uc)) || (uc == 0xd7)) || (uc == 0xf7)))))) &&
       (((((uc != 0x200c && (uc != 0x200d)) &&
          (((uc < 0x2070 || (0x218f < uc)) && ((uc < 0x2c00 || (0x2fef < uc)))))) &&
         ((uc < 0x3001 || (0xd7ff < uc)))) &&
        ((((uc < 0xf900 || (0xfdcf < uc)) && ((uc < 0xfdf0 || (0xfffd < uc)))) &&
         ((uc < 0x10000 || (0xeffff < uc)))))))) {
      ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"NameStartChar of the attribute");
      free(attr);
      plVar2 = (lyxml_attr *)0x0;
      goto LAB_0013490e;
    }
    xml_flag = '\x04';
    if (*c == 'x') {
      xml_flag = '\x01';
    }
    c = c + size;
    uc = lyxml_getutf8(ctx,c,&size);
    while (((((((0x60 < uc && (uc < 0x7b)) || (uc == 0x5f)) ||
              ((uc == 0x2d || ((0x40 < uc && (uc < 0x5b)))))) || ((0x2f < uc && (uc < 0x3a)))) ||
            (((uc == 0x3a || (uc == 0x2e)) ||
             ((uc == 0xb7 || (((0x36f < uc && (uc < 0x2000)) && (uc != 0x37e)))))))) ||
           ((((((0xbf < uc && (uc < 0x300)) && ((uc != 0xd7 && (uc != 0xf7)))) ||
              (((((uc == 0x200c || (uc == 0x200d)) || ((0x2ff < uc && (uc < 0x370)))) ||
                (((0x206f < uc && (uc < 0x2190)) || ((0x2030e < uc && (uc < 0x2041)))))) ||
               ((((0x2bff < uc && (uc < 0x2ff0)) || ((0x3000 < uc && (uc < 0xd800)))) ||
                ((0xf8ff < uc && (uc < 0xfdd0)))))))) || ((0xfdef < uc && (uc < 0xfffe)))) ||
            ((0xffff < uc && (uc < 0xf0000))))))) {
      if (attr->type == LYXML_ATTR_STD) {
        if ((*c == ':') && (xml_flag != '\x03')) {
          start = c + 1;
          prefix = (char *)malloc((size_t)(c + (1 - (long)data)));
          if (prefix == (char *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","parse_attr");
            goto LAB_001348e8;
          }
          memcpy(prefix,data,(long)c - (long)data);
          prefix[(long)c - (long)data] = '\0';
          plVar3 = lyxml_get_ns(parent,prefix);
          attr->ns = plVar3;
        }
        else if (((*c == 'm') && (xml_flag == '\x01')) || ((*c == 'l' && (xml_flag == '\x02')))) {
          xml_flag = xml_flag + '\x01';
        }
        else {
          xml_flag = '\x04';
        }
      }
      c = c + size;
      uc = lyxml_getutf8(ctx,c,&size);
    }
    size = (int)c - (int)start;
    pcVar4 = lydict_insert(ctx,start,(ulong)size);
    attr->name = pcVar4;
    pcVar4 = c;
  }
  while ((((c = pcVar4, *c == ' ' || (*c == '\t')) || (*c == '\n')) || (*c == '\r'))) {
    pcVar4 = c + 1;
  }
  if (*c == '=') {
    do {
      do {
        pcVar4 = c;
        c = pcVar4 + 1;
      } while (*c == ' ');
    } while (((*c == '\t') || (*c == '\n')) || (*c == '\r'));
    if ((*c == '\0') || ((*c != '\"' && (*c != '\'')))) {
      ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"attribute value, \" or \' expected");
    }
    else {
      delim = c;
      delim_00 = *c;
      c = pcVar4 + 2;
      str = parse_text(ctx,c,delim_00,&size);
      if ((str != (char *)0x0) || (size != 0)) {
        pcVar4 = lydict_insert_zc(ctx,str);
        attr->value = pcVar4;
        *len = ((int)c + size + 1) - (int)data;
        if (parent->attr == (lyxml_attr *)0x0) {
          parent->attr = attr;
        }
        else {
          for (a = parent->attr; a->next != (lyxml_attr *)0x0; a = a->next) {
          }
          a->next = attr;
        }
        free(prefix);
        plVar2 = attr;
        goto LAB_0013490e;
      }
    }
  }
  else {
    ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"attribute definition, \"=\" expected");
  }
LAB_001348e8:
  lyxml_free_attr(ctx,(lyxml_elem *)0x0,attr);
  free(prefix);
  plVar2 = (lyxml_attr *)0x0;
LAB_0013490e:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lyxml_elem * lyxml_parse_elem(ly_ctx *ctx,char *data,uint *len,lyxml_elem *parent,int options)

{
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  lyxml_ns *plVar4;
  lyxml_elem *plVar5;
  ulong uVar6;
  long in_FS_OFFSET;
  int options_local;
  lyxml_elem *parent_local;
  uint *len_local;
  char *data_local;
  ly_ctx *ctx_local;
  uint size;
  int uc;
  uint prefix_len;
  int nons_flag;
  int closed_flag;
  char *c;
  char *e;
  char *lws;
  char *prefix;
  lyxml_elem *elem;
  lyxml_attr *attr;
  lyxml_elem *child;
  char *str;
  char *start;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  prefix = (char *)0x0;
  prefix_len = 0;
  elem = (lyxml_elem *)0x0;
  nons_flag = 0;
  closed_flag = 0;
  *len = 0;
  if (*data != '<') {
    plVar5 = (lyxml_elem *)0x0;
    c = data;
    goto LAB_00135b99;
  }
  c = data + 1;
  e = c;
  uc = lyxml_getutf8(ctx,c,&size);
  if ((((((((uc < 0x61) || (0x7a < uc)) && (uc != 0x5f)) && ((uc < 0x41 || (0x5a < uc)))) &&
        (uc != 0x3a)) && (((uc < 0x370 || (0x1fff < uc)) || (uc == 0x37e)))) &&
      ((((uc < 0xc0 || (0x2ff < uc)) || (uc == 0xd7)) || (uc == 0xf7)))) &&
     ((((uc != 0x200c && (uc != 0x200d)) &&
       (((uc < 0x2070 || (0x218f < uc)) && ((uc < 0x2c00 || (0x2fef < uc)))))) &&
      (((uc < 0x3001 || (0xd7ff < uc)) &&
       ((((uc < 0xf900 || (0xfdcf < uc)) && ((uc < 0xfdf0 || (0xfffd < uc)))) &&
        ((uc < 0x10000 || (0xeffff < uc)))))))))) {
    ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"NameStartChar of the element");
    plVar5 = (lyxml_elem *)0x0;
    goto LAB_00135b99;
  }
  e = e + size;
  uc = lyxml_getutf8(ctx,e,&size);
  while (((((((0x60 < uc && (uc < 0x7b)) || (uc == 0x5f)) ||
            ((uc == 0x2d || ((0x40 < uc && (uc < 0x5b)))))) || ((0x2f < uc && (uc < 0x3a)))) ||
          ((((uc == 0x3a || (uc == 0x2e)) ||
            ((uc == 0xb7 || (((0x36f < uc && (uc < 0x2000)) && (uc != 0x37e)))))) ||
           (((0xbf < uc && (uc < 0x300)) && ((uc != 0xd7 && (uc != 0xf7)))))))) ||
         (((((((uc == 0x200c || (uc == 0x200d)) || ((0x2ff < uc && (uc < 0x370)))) ||
             (((0x206f < uc && (uc < 0x2190)) || ((0x2030e < uc && (uc < 0x2041)))))) ||
            ((((0x2bff < uc && (uc < 0x2ff0)) || ((0x3000 < uc && (uc < 0xd800)))) ||
             ((0xf8ff < uc && (uc < 0xfdd0)))))) || ((0xfdef < uc && (uc < 0xfffe)))) ||
          ((0xffff < uc && (uc < 0xf0000))))))) {
    if (*e == ':') {
      if (prefix_len != 0) {
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"element name, multiple colons found");
        goto LAB_00135b72;
      }
      start = e + 1;
      prefix_len = (int)e - (int)c;
      if (prefix != (char *)0x0) {
        ly_vlog(ctx,LYE_XML_INCHAR,LY_VLOG_NONE,(void *)0x0,e);
        goto LAB_00135b72;
      }
      prefix = (char *)malloc((ulong)(prefix_len + 1));
      if (prefix == (char *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxml_parse_elem");
        goto LAB_00135b72;
      }
      memcpy(prefix,c,(ulong)prefix_len);
      prefix[prefix_len] = '\0';
      c = start;
    }
    e = e + size;
    uc = lyxml_getutf8(ctx,e,&size);
  }
  if (*e == '\0') {
    ly_vlog(ctx,LYE_EOF,LY_VLOG_NONE,(void *)0x0);
    free(prefix);
    plVar5 = (lyxml_elem *)0x0;
    goto LAB_00135b99;
  }
  elem = (lyxml_elem *)calloc(1,0x48);
  if (elem == (lyxml_elem *)0x0) {
    free(prefix);
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxml_parse_elem");
    plVar5 = (lyxml_elem *)0x0;
    goto LAB_00135b99;
  }
  elem->next = (lyxml_elem *)0x0;
  elem->prev = elem;
  if (parent != (lyxml_elem *)0x0) {
    lyxml_add_child(ctx,parent,elem);
  }
  pcVar2 = lydict_insert(ctx,c,(long)e - (long)c);
  elem->name = pcVar2;
  c = e;
  while( true ) {
    for (; (((*c == ' ' || (*c == '\t')) || (*c == '\n')) || (*c == '\r')); c = c + 1) {
    }
    iVar1 = strncmp("/>",c,2);
    if (iVar1 == 0) {
      c = c + 2;
      pcVar2 = lydict_insert(ctx,"",0);
      elem->content = pcVar2;
      closed_flag = 1;
      goto LAB_00135ab6;
    }
    if (*c == '>') {
      c = c + 1;
      lws = (char *)0x0;
      goto LAB_001359ba;
    }
    attr = parse_attr(ctx,c,&size,elem);
    if (attr == (lyxml_attr *)0x0) break;
    c = c + size;
    if (attr->type == LYXML_ATTR_NS) {
      if (((prefix == (char *)0x0) || (*prefix == '\0')) && (attr->name == (char *)0x0)) {
        if (attr->value == (char *)0x0) {
          nons_flag = 1;
        }
        else {
          elem->ns = (lyxml_ns *)attr;
        }
      }
      else if (((prefix != (char *)0x0) && (*prefix != '\0')) &&
              ((attr->name != (char *)0x0 &&
               (iVar1 = strncmp(attr->name,prefix,(ulong)(prefix_len + 1)), iVar1 == 0)))) {
        elem->ns = (lyxml_ns *)attr;
      }
    }
  }
  goto LAB_00135b72;
LAB_0013520b:
  if ((((((((uc < 0x61) || (0x7a < uc)) && (uc != 0x5f)) &&
         ((uc != 0x2d && ((uc < 0x41 || (0x5a < uc)))))) && ((uc < 0x30 || (0x39 < uc)))) &&
       (((uc != 0x3a && (uc != 0x2e)) &&
        ((uc != 0xb7 && (((uc < 0x370 || (0x1fff < uc)) || (uc == 0x37e)))))))) &&
      ((((((uc < 0xc0 || (0x2ff < uc)) || (uc == 0xd7)) || (uc == 0xf7)) &&
        ((((uc != 0x200c && (uc != 0x200d)) && ((uc < 0x300 || (0x36f < uc)))) &&
         ((uc < 0x2070 || (0x218f < uc)))))) && ((uc < 0x2030f || (0x2040 < uc)))))) &&
     ((((((uc < 0x2c00 || (0x2fef < uc)) && ((uc < 0x3001 || (0xd7ff < uc)))) &&
        ((uc < 0xf900 || (0xfdcf < uc)))) && ((uc < 0xfdf0 || (0xfffd < uc)))) &&
      ((uc < 0x10000 || (0xeffff < uc)))))) goto LAB_00135381;
  if (*e == ':') {
    start = e + 1;
    if ((prefix == (char *)0x0) || (iVar1 = memcmp(prefix,c,(long)e - (long)c), iVar1 != 0)) {
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_XML,elem,
              "Invalid (different namespaces) opening (%s) and closing element tags.",elem->name);
      goto LAB_00135b72;
    }
    c = start;
  }
  e = e + size;
  uc = lyxml_getutf8(ctx,e,&size);
  goto LAB_0013520b;
LAB_00135381:
  if (*e == '\0') {
    ly_vlog(ctx,LYE_EOF,LY_VLOG_NONE,(void *)0x0);
  }
  else {
    size = (int)e - (int)c;
    str = (char *)malloc((ulong)(size + 1));
    if (str == (char *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxml_parse_elem");
    }
    else {
      memcpy(str,c,(long)e - (long)c);
      str[(long)e - (long)c] = '\0';
      uVar6 = (ulong)size;
      sVar3 = strlen(elem->name);
      if ((uVar6 == sVar3) && (iVar1 = memcmp(str,elem->name,(ulong)size), iVar1 == 0)) {
        free(str);
        for (c = e; (((*c == ' ' || (*c == '\t')) || (*c == '\n')) || (*c == '\r')); c = c + 1) {
        }
        if (*c == '>') {
          c = c + 1;
          if (((elem->flags & 1U) == 0) && (elem->content == (char *)0x0)) {
            pcVar2 = lydict_insert(ctx,"",0);
            elem->content = pcVar2;
          }
          closed_flag = 1;
          goto LAB_00135ab6;
        }
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_XML,elem,"Data after closing element tag \"%s\".",elem->name);
      }
      else {
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_XML,elem,
                "Invalid (mixed names) opening (%s) and closing (%s) element tags.",elem->name,str);
        free(str);
      }
    }
  }
  goto LAB_00135b72;
LAB_001359ba:
  if (*c != '\0') {
    iVar1 = strncmp(c,"</",2);
    if (iVar1 == 0) {
      if ((lws == (char *)0x0) || (elem->child != (lyxml_elem *)0x0)) {
        c = c + 2;
        e = c;
        uc = lyxml_getutf8(ctx,c,&size);
        if (((((0x60 < uc) && (uc < 0x7b)) ||
             ((uc == 0x5f || (((0x40 < uc && (uc < 0x5b)) || (uc == 0x3a)))))) ||
            ((((0x36f < uc && (uc < 0x2000)) && (uc != 0x37e)) ||
             (((0xbf < uc && (uc < 0x300)) && ((uc != 0xd7 && (uc != 0xf7)))))))) ||
           (((((uc == 0x200c || (uc == 0x200d)) || ((0x206f < uc && (uc < 0x2190)))) ||
             (((((0x2bff < uc && (uc < 0x2ff0)) || ((0x3000 < uc && (uc < 0xd800)))) ||
               ((0xf8ff < uc && (uc < 0xfdd0)))) || ((0xfdef < uc && (uc < 0xfffe)))))) ||
            ((0xffff < uc && (uc < 0xf0000)))))) {
          e = e + size;
          uc = lyxml_getutf8(ctx,e,&size);
          goto LAB_0013520b;
        }
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_XML,elem,"NameStartChar of the element");
        goto LAB_00135b72;
      }
LAB_00135865:
      if (lws != (char *)0x0) {
        c = lws;
        lws = (char *)0x0;
      }
      str = parse_text(ctx,c,'<',&size);
      if ((str == (char *)0x0) && (size == 0)) goto LAB_00135b72;
      pcVar2 = lydict_insert_zc(ctx,str);
      elem->content = pcVar2;
      c = c + size;
      if (elem->child != (lyxml_elem *)0x0) {
        if ((options & 2U) != 0) {
          ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_XML,elem,"XML element with mixed content");
          goto LAB_00135b72;
        }
        child = (lyxml_elem *)calloc(1,0x48);
        if (child == (lyxml_elem *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxml_parse_elem");
          goto LAB_00135b72;
        }
        child->content = elem->content;
        elem->content = (char *)0x0;
        lyxml_add_child(ctx,elem,child);
        elem->flags = elem->flags | 1;
      }
    }
    else {
      iVar1 = strncmp(c,"<?",2);
      if (iVar1 == 0) {
        if (lws != (char *)0x0) {
          lws = (char *)0x0;
        }
        c = c + 2;
        iVar1 = parse_ignore(ctx,c,"?>",&size);
        if (iVar1 != 0) goto LAB_00135b72;
        c = c + size;
      }
      else {
        iVar1 = strncmp(c,"<!--",4);
        if (iVar1 == 0) {
          if (lws != (char *)0x0) {
            lws = (char *)0x0;
          }
          c = c + 4;
          iVar1 = parse_ignore(ctx,c,"-->",&size);
          if (iVar1 != 0) goto LAB_00135b72;
          c = c + size;
        }
        else {
          iVar1 = strncmp(c,"<![CDATA[",9);
          if (iVar1 == 0) goto LAB_00135865;
          if (*c == '<') {
            if (lws != (char *)0x0) {
              if ((elem->flags & 1U) != 0) goto LAB_00135865;
              lws = (char *)0x0;
            }
            if (elem->content != (char *)0x0) {
              if ((options & 2U) != 0) {
                ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_XML,elem,"XML element with mixed content");
                goto LAB_00135b72;
              }
              child = (lyxml_elem *)calloc(1,0x48);
              if (child == (lyxml_elem *)0x0) {
                ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxml_parse_elem");
                goto LAB_00135b72;
              }
              child->content = elem->content;
              elem->content = (char *)0x0;
              lyxml_add_child(ctx,elem,child);
              elem->flags = elem->flags | 1;
            }
            child = lyxml_parse_elem(ctx,c,&size,elem,options);
            if (child == (lyxml_elem *)0x0) goto LAB_00135b72;
            c = c + size;
          }
          else {
            if (((*c != ' ') && (*c != '\t')) && ((*c != '\n' && (*c != '\r')))) goto LAB_00135865;
            lws = c;
            for (; ((*c == ' ' || (*c == '\t')) || ((*c == '\n' || (*c == '\r')))); c = c + 1) {
            }
          }
        }
      }
    }
    goto LAB_001359ba;
  }
LAB_00135ab6:
  *len = (int)c - (int)data;
  if (closed_flag != 0) {
    if (((elem->ns == (lyxml_ns *)0x0) && (nons_flag == 0)) && (parent != (lyxml_elem *)0x0)) {
      pcVar2 = prefix;
      if (prefix_len == 0) {
        pcVar2 = (char *)0x0;
      }
      plVar4 = lyxml_get_ns(parent,pcVar2);
      elem->ns = plVar4;
    }
    free(prefix);
    plVar5 = elem;
    goto LAB_00135b99;
  }
  ly_vlog(ctx,LYE_XML_MISS,LY_VLOG_XML,elem,"closing element tag",elem->name);
LAB_00135b72:
  lyxml_free(ctx,elem);
  free(prefix);
  plVar5 = (lyxml_elem *)0x0;
LAB_00135b99:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar5;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lyxml_elem * lyxml_parse_mem(ly_ctx *ctx,char *data,int options)

{
  int iVar1;
  lyxml_elem *plVar2;
  long in_FS_OFFSET;
  int options_local;
  char *data_local;
  ly_ctx *ctx_local;
  uint len;
  char *c;
  lyxml_elem *root;
  lyxml_elem *first;
  lyxml_elem *next;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyxml_parse_mem");
  first = (lyxml_elem *)0x0;
  c = data;
  if (ctx == (ly_ctx *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyxml_parse_mem");
    plVar2 = (lyxml_elem *)0x0;
  }
  else {
LAB_00135c3f:
    do {
      while( true ) {
        while( true ) {
          plVar2 = first;
          if (*c == '\0') goto LAB_00135f25;
          if ((((*c != ' ') && (*c != '\t')) && (*c != '\n')) && (*c != '\r')) break;
          for (; ((*c == ' ' || (*c == '\t')) || ((*c == '\n' || (*c == '\r')))); c = c + 1) {
          }
        }
        iVar1 = strncmp(c,"<?",2);
        if (iVar1 != 0) break;
        c = c + 2;
        iVar1 = parse_ignore(ctx,c,"?>",&len);
        if (iVar1 != 0) {
LAB_00135ed8:
          root = first;
          while (root != (lyxml_elem *)0x0) {
            next = root->next;
            lyxml_free(ctx,root);
            root = next;
          }
          plVar2 = (lyxml_elem *)0x0;
          goto LAB_00135f25;
        }
        c = c + len;
      }
      iVar1 = strncmp(c,"<!--",4);
      if (iVar1 == 0) {
        c = c + 2;
        iVar1 = parse_ignore(ctx,c,"-->",&len);
        if (iVar1 != 0) goto LAB_00135ed8;
        c = c + len;
        goto LAB_00135c3f;
      }
      iVar1 = strncmp(c,"<!",2);
      if (iVar1 == 0) {
        ly_log(ctx,LY_LLERR,LY_EINVAL,"DOCTYPE not supported in XML documents.");
        goto LAB_00135ed8;
      }
      if (*c != '<') {
        ly_vlog(ctx,LYE_XML_INCHAR,LY_VLOG_NONE,(void *)0x0,c);
        goto LAB_00135ed8;
      }
      root = lyxml_parse_elem(ctx,c,&len,(lyxml_elem *)0x0,options);
      if (root == (lyxml_elem *)0x0) goto LAB_00135ed8;
      plVar2 = root;
      if (first != (lyxml_elem *)0x0) {
        first->prev->next = root;
        root->prev = first->prev;
        first->prev = root;
        plVar2 = first;
      }
      first = plVar2;
      for (c = c + len; ((*c == ' ' || (*c == '\t')) || ((*c == '\n' || (*c == '\r')))); c = c + 1)
      {
      }
      plVar2 = first;
      if (*c == '\0') goto LAB_00135f25;
    } while ((options & 1U) != 0);
    ly_log(ctx,LY_LLWRN,LY_SUCCESS,"There are some not parsed data:\n%s",c);
    plVar2 = first;
  }
LAB_00135f25:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar2;
}



lyxml_elem * lyxml_parse_path(ly_ctx *ctx,char *filename,int options)

{
  int fd_00;
  int iVar1;
  lyxml_elem *plVar2;
  long in_FS_OFFSET;
  int options_local;
  char *filename_local;
  ly_ctx *ctx_local;
  int fd;
  size_t length;
  char *addr;
  lyxml_elem *elem;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyxml_parse_path");
  elem = (lyxml_elem *)0x0;
  if ((filename == (char *)0x0) || (ctx == (ly_ctx *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyxml_parse_path");
    plVar2 = (lyxml_elem *)0x0;
  }
  else {
    fd_00 = open(filename,0);
    if (fd_00 == -1) {
      ly_log(ctx,LY_LLERR,LY_EINVAL,"Opening file \"%s\" failed.",filename);
      plVar2 = (lyxml_elem *)0x0;
    }
    else {
      iVar1 = lyp_mmap(ctx,fd_00,0,&length,&addr);
      if (iVar1 == 0) {
        if (addr != (char *)0x0) {
          elem = lyxml_parse_mem(ctx,addr,options);
          lyp_munmap(addr,length);
          close(fd_00);
          plVar2 = elem;
          goto LAB_001360c4;
        }
      }
      else {
        ly_log(ctx,LY_LLERR,LY_ESYS,"Mapping file descriptor into memory failed (%s()).",
               "lyxml_parse_path");
      }
      if (fd_00 != -1) {
        close(fd_00);
      }
      plVar2 = (lyxml_elem *)0x0;
    }
  }
LAB_001360c4:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar2;
}



int lyxml_dump_text(lyout *out,char *text,LYXML_DATA_TYPE type)

{
  char cVar1;
  int iVar2;
  LYXML_DATA_TYPE type_local;
  char *text_local;
  lyout *out_local;
  uint i;
  uint n;
  
  if (text == (char *)0x0) {
    n = 0;
  }
  else {
    n = 0;
    for (i = 0; text[i] != '\0'; i = i + 1) {
      cVar1 = text[i];
      if (cVar1 == '>') {
        iVar2 = ly_print(out,"&gt;");
        n = n + iVar2;
      }
      else if (cVar1 < '?') {
        if (cVar1 == '<') {
          iVar2 = ly_print(out,"&lt;");
          n = n + iVar2;
        }
        else {
          if ('<' < cVar1) goto LAB_001361c7;
          if (cVar1 == '\"') {
            if (type != LYXML_DATA_ATTR) goto LAB_001361c7;
            iVar2 = ly_print(out,"&quot;");
            n = n + iVar2;
          }
          else {
            if (cVar1 != '&') goto LAB_001361c7;
            iVar2 = ly_print(out,"&amp;");
            n = n + iVar2;
          }
        }
      }
      else {
LAB_001361c7:
        ly_write(out,text + i,1);
        n = n + 1;
      }
    }
  }
  return n;
}



int dump_elem(lyout *out,lyxml_elem *e,int level,int options,int last_elem)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  int last_elem_local;
  int options_local;
  int level_local;
  lyxml_elem *e_local;
  lyout *out_local;
  int size;
  int indent;
  lyxml_attr *a;
  lyxml_elem *child;
  char *delim;
  char *delim_outer;
  
  size = 0;
  if (e->name == (char *)0x0) {
    if (e->content != (char *)0x0) {
      iVar1 = lyxml_dump_text(out,e->content,LYXML_DATA_ELEM);
      return iVar1;
    }
    return 0;
  }
  if ((options & 2U) == 0) {
    delim_outer = "";
  }
  else {
    delim_outer = "\n";
  }
  indent = level * 2;
  if (((e->flags & 1U) != 0) ||
     ((delim = delim_outer, e->parent != (lyxml_elem *)0x0 && ((e->parent->flags & 1U) != 0)))) {
    delim = "";
  }
  if ((e->parent != (lyxml_elem *)0x0) && ((e->parent->flags & 1U) != 0)) {
    delim_outer = "";
    indent = 0;
  }
  if ((last_elem != 0) && ((options & 0x20U) != 0)) {
    delim_outer = "";
  }
  if (((options & 0xdU) == 0) || ((options & 1U) != 0)) {
    if ((e->ns == (lyxml_ns *)0x0) || (e->ns->prefix == (char *)0x0)) {
      size = ly_print(out,"%*s<%s",(ulong)(uint)indent,&DAT_002117f5,e->name);
    }
    else {
      size = ly_print(out,"%*s<%s:%s",(ulong)(uint)indent,&DAT_002117f5,e->ns->prefix,e->name);
    }
  }
  else if ((options & 4U) != 0) {
    indent = 0;
    goto LAB_0013677e;
  }
  for (a = e->attr; a != (lyxml_attr *)0x0; a = a->next) {
    if (a->type == LYXML_ATTR_NS) {
      if (a->name == (char *)0x0) {
        if (a->value == (char *)0x0) {
          pcVar3 = "";
        }
        else {
          pcVar3 = a->value;
        }
        iVar1 = ly_print(out," xmlns=\"%s\"",pcVar3);
        size = size + iVar1;
      }
      else {
        if (a->value == (char *)0x0) {
          pcVar3 = "";
        }
        else {
          pcVar3 = a->value;
        }
        iVar1 = ly_print(out," xmlns:%s=\"%s\"",a->name,pcVar3);
        size = size + iVar1;
      }
    }
    else if ((a->ns == (lyxml_ns *)0x0) || (a->ns->prefix == (char *)0x0)) {
      iVar1 = ly_print(out," %s=\"%s\"",a->name,a->value);
      size = size + iVar1;
    }
    else {
      iVar1 = ly_print(out," %s:%s=\"%s\"",a->ns->prefix,a->name,a->value);
      size = size + iVar1;
    }
  }
  if (((options & 4U) != 0) && ((options & 1U) != 0)) {
    iVar1 = ly_print(out,"/>%s",delim);
    return size + iVar1;
  }
  if ((options & 1U) != 0) {
    ly_print(out,">");
    return size + 1;
  }
  if ((options & 8U) != 0) {
    return size;
  }
  if ((e->child == (lyxml_elem *)0x0) && ((e->content == (char *)0x0 || (*e->content == '\0')))) {
    iVar1 = ly_print(out,"/>%s",delim);
    return size + iVar1;
  }
  if ((e->content != (char *)0x0) && (*e->content != '\0')) {
    ly_print(out,">");
    iVar1 = lyxml_dump_text(out,e->content,LYXML_DATA_ELEM);
    if ((e->ns == (lyxml_ns *)0x0) || (e->ns->prefix == (char *)0x0)) {
      iVar2 = ly_print(out,"</%s>%s",e->name,delim);
    }
    else {
      iVar2 = ly_print(out,"</%s:%s>%s",e->ns->prefix,e->name,delim);
    }
    size = size + 1 + iVar1 + iVar2;
    return size;
  }
  iVar1 = ly_print(out,">%s",delim);
  size = size + iVar1;
  for (child = e->child; child != (lyxml_elem *)0x0; child = child->next) {
    if ((options & 2U) == 0) {
      iVar1 = dump_elem(out,child,level,0,0);
    }
    else {
      iVar1 = dump_elem(out,child,level + 1,2,0);
    }
    size = size + iVar1;
  }
LAB_0013677e:
  if ((e->ns == (lyxml_ns *)0x0) || (e->ns->prefix == (char *)0x0)) {
    iVar1 = ly_print(out,"%*s</%s>%s",(ulong)(uint)indent,&DAT_002117f5,e->name,delim_outer);
  }
  else {
    iVar1 = ly_print(out,"%*s</%s:%s>%s",(ulong)(uint)indent,&DAT_002117f5,e->ns->prefix,e->name,
                     delim_outer);
  }
  size = size + iVar1;
  return size;
}



int dump_siblings(lyout *out,lyxml_elem *e,int options)

{
  lyxml_elem *plVar1;
  int iVar2;
  int options_local;
  lyxml_elem *e_local;
  lyout *out_local;
  int ret;
  lyxml_elem *start;
  lyxml_elem *iter;
  lyxml_elem *next;
  
  ret = 0;
  start = e;
  if (e->parent == (lyxml_elem *)0x0) {
    while ((start->prev != (lyxml_elem *)0x0 && (start->prev->next != (lyxml_elem *)0x0))) {
      start = start->prev;
    }
  }
  else {
    start = e->parent->child;
  }
  iter = start;
  while (iter != (lyxml_elem *)0x0) {
    plVar1 = iter->next;
    iVar2 = dump_elem(out,iter,0,options,(uint)(plVar1 == (lyxml_elem *)0x0));
    ret = ret + iVar2;
    iter = plVar1;
  }
  return ret;
}



int lyxml_print_file(FILE *stream,lyxml_elem *elem,int options)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  int options_local;
  lyxml_elem *elem_local;
  FILE *stream_local;
  lyout out;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyxml_print_file");
  if ((stream == (FILE *)0x0) || (elem == (lyxml_elem *)0x0)) {
    iVar2 = 0;
  }
  else {
    memset(&out,0,0x40);
    out.type = LYOUT_STREAM;
    out.method.f = stream;
    if ((options & 0x10U) == 0) {
      iVar2 = dump_elem(&out,elem,0,options,1);
    }
    else {
      iVar2 = dump_siblings(&out,elem,options);
    }
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lyxml_print_fd(int fd,lyxml_elem *elem,int options)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  lyxml_elem *elem_local;
  int options_local;
  int fd_local;
  lyout out;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyxml_print_fd");
  if ((fd < 0) || (elem == (lyxml_elem *)0x0)) {
    iVar2 = 0;
  }
  else {
    memset(&out,0,0x40);
    out.type = LYOUT_FD;
    out.method.fd = fd;
    if ((options & 0x10U) == 0) {
      iVar2 = dump_elem(&out,elem,0,options,1);
    }
    else {
      iVar2 = dump_siblings(&out,elem,options);
    }
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lyxml_print_mem(char **strp,lyxml_elem *elem,int options)

{
  long lVar1;
  long in_FS_OFFSET;
  int options_local;
  lyxml_elem *elem_local;
  char **strp_local;
  int r;
  lyout out;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyxml_print_mem");
  if ((strp == (char **)0x0) || (elem == (lyxml_elem *)0x0)) {
    r = 0;
  }
  else {
    memset(&out,0,0x40);
    out.type = LYOUT_MEMORY;
    if ((options & 0x10U) == 0) {
      r = dump_elem(&out,elem,0,options,1);
    }
    else {
      r = dump_siblings(&out,elem,options);
    }
    *strp = (char *)out.method.f;
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return r;
}



int lyxml_print_clb(_func_ssize_t_void_ptr_void_ptr_size_t *writeclb,void *arg,lyxml_elem *elem,
                   int options)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  int options_local;
  lyxml_elem *elem_local;
  void *arg_local;
  _func_ssize_t_void_ptr_void_ptr_size_t *writeclb_local;
  lyout out;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyxml_print_clb");
  if ((writeclb == (_func_ssize_t_void_ptr_void_ptr_size_t *)0x0) || (elem == (lyxml_elem *)0x0)) {
    iVar2 = 0;
  }
  else {
    memset(&out,0,0x40);
    out.type = LYOUT_CALLBACK;
    out.method.clb.f = writeclb;
    out.method.clb.arg = arg;
    if ((options & 0x10U) == 0) {
      iVar2 = dump_elem(&out,elem,0,options,1);
    }
    else {
      iVar2 = dump_siblings(&out,elem,options);
    }
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lyp_is_rpc_action(lys_node *node)

{
  lys_node *plVar1;
  lys_node *node_local;
  
  node_local = node;
  if (node == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                  ,0xcc,"lyp_is_rpc_action");
  }
  do {
    plVar1 = lys_parent(node_local);
    if (plVar1 == (lys_node *)0x0) break;
    node_local = lys_parent(node_local);
  } while (node_local->nodetype != LYS_ACTION);
  return (int)((node_local->nodetype & 0x4100) != LYS_UNKNOWN);
}



int lyp_data_check_options(ly_ctx *ctx,int options,char *func)

{
  uint uVar1;
  int iVar2;
  char *func_local;
  int options_local;
  ly_ctx *ctx_local;
  int x;
  
  uVar1 = options & 0x10000ff;
  if (((options & 0x4000U) == 0) || ((uVar1 != 8 && (uVar1 != 0x80)))) {
    if (((options & 0x30000U) == 0) || (uVar1 == 0)) {
      if ((uVar1 == 0) || ((uVar1 != 0 && ((uVar1 - 1 & uVar1) == 0)))) {
        iVar2 = 0;
      }
      else {
        ly_log(ctx,LY_LLERR,LY_EINVAL,"%s: Invalid options 0x%x (multiple data type flags set).",
               func,(ulong)(uint)options);
        iVar2 = 1;
      }
    }
    else {
      ly_log(ctx,LY_LLERR,LY_EINVAL,
             "%s: Invalid options 0x%x (LYD_OPT_DATA_*_YANGLIB can be used only with LYD_OPT_DATA)",
             func,(ulong)(uint)options);
      iVar2 = 1;
    }
  }
  else {
    ly_log(ctx,LY_LLERR,LY_EINVAL,
           "%s: Invalid options 0x%x (LYD_OPT_DATA_WHENAUTODEL can be used only with LYD_OPT_DATA or LYD_OPT_CONFIG)"
           ,func,(ulong)(uint)options);
    iVar2 = 1;
  }
  return iVar2;
}



int lyp_mmap(ly_ctx *ctx,int fd,size_t addsize,size_t *length,void **addr)

{
  long lVar1;
  int iVar2;
  int *piVar3;
  char *pcVar4;
  long lVar5;
  void *pvVar6;
  long in_FS_OFFSET;
  void **addr_local;
  size_t *length_local;
  size_t addsize_local;
  int fd_local;
  ly_ctx *ctx_local;
  long pagesize;
  size_t m;
  stat sb;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (fd < 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("fd >= 0",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                  ,0x102,"lyp_mmap");
  }
  iVar2 = fstat(fd,(stat *)&sb);
  if (iVar2 == -1) {
    piVar3 = __errno_location();
    pcVar4 = strerror(*piVar3);
    ly_log(ctx,LY_LLERR,LY_ESYS,"Failed to stat the file descriptor (%s) for the mmap().",pcVar4);
    iVar2 = 1;
  }
  else if ((sb.st_mode & 0xf000) == 0x8000) {
    if (sb.st_size == 0) {
      *addr = (void *)0x0;
      iVar2 = 0;
    }
    else {
      lVar5 = sysconf(0x1e);
      if ((sb.st_size % lVar5 == 0) || ((ulong)(lVar5 - sb.st_size % lVar5) < addsize + 1)) {
        *length = lVar5 + sb.st_size;
        pvVar6 = mmap((void *)0x0,*length,3,0x22,-1,0);
        *addr = pvVar6;
        pvVar6 = mmap(*addr,sb.st_size,3,0x12,fd,0);
        *addr = pvVar6;
      }
      else {
        *length = sb.st_size + addsize + 1;
        pvVar6 = mmap((void *)0x0,*length,3,2,fd,0);
        *addr = pvVar6;
      }
      if (*addr == (void *)0xffffffffffffffff) {
        piVar3 = __errno_location();
        pcVar4 = strerror(*piVar3);
        ly_log(ctx,LY_LLERR,LY_ESYS,"mmap() failed (%s).",pcVar4);
        iVar2 = 1;
      }
      else {
        iVar2 = 0;
      }
    }
  }
  else {
    ly_log(ctx,LY_LLERR,LY_EINVAL,"File to mmap() is not a regular file.");
    iVar2 = 1;
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lyp_munmap(void *addr,size_t length)

{
  int iVar1;
  size_t length_local;
  void *addr_local;
  
  iVar1 = munmap(addr,length);
  return iVar1;
}



int lyp_add_ietf_netconf_annotations_config(lys_module *mod)

{
  ly_ctx *ctx_00;
  undefined8 *puVar1;
  long lVar2;
  int iVar3;
  lys_ext_instance **pplVar4;
  lys_ext_instance *plVar5;
  char *pcVar6;
  void **ppvVar7;
  void *pvVar8;
  void *pvVar9;
  lys_node *child;
  lys_module *mod_local;
  int i;
  ly_ctx *ctx;
  void *reallocated;
  lys_ext_instance_complex *op;
  lys_type **type;
  lys_node_anydata *anyxml;
  
  ctx_00 = mod->ctx;
  pplVar4 = (lys_ext_instance **)realloc(mod->ext,(long)(int)(mod->ext_size + 3) * 8);
  if (pplVar4 == (lys_ext_instance **)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
           "lyp_add_ietf_netconf_annotations_config");
    iVar3 = 1;
  }
  else {
    mod->ext = pplVar4;
    plVar5 = (lys_ext_instance *)calloc(1,0x79);
    if (plVar5 == (lys_ext_instance *)0x0) {
      ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
             "lyp_add_ietf_netconf_annotations_config");
      iVar3 = 1;
    }
    else {
      mod->ext[mod->ext_size] = plVar5;
      pcVar6 = lydict_insert(ctx_00,"operation",9);
      plVar5->arg_value = pcVar6;
      plVar5->def = (*(ctx_00->models).list)->extensions;
      plVar5->ext_type = '\x01';
      plVar5->parent = mod;
      plVar5->module = (lys_module *)plVar5->parent;
      plVar5->parent_type = '\0';
      plVar5[1].def = *(lys_ext **)(plVar5->def->plugin + 1);
      plVar5->nodetype = LYS_EXT;
      ppvVar7 = &plVar5[1].parent;
      pvVar8 = calloc(1,0x40);
      *ppvVar7 = pvVar8;
      if (*ppvVar7 == (void *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "lyp_add_ietf_netconf_annotations_config");
        iVar3 = 1;
      }
      else {
        *(undefined4 *)*ppvVar7 = 6;
        *(lys_tpdf **)((long)*ppvVar7 + 0x10) = ly_types[6];
        *(lys_ext_instance **)((long)*ppvVar7 + 0x18) = plVar5;
        *(undefined4 *)((long)*ppvVar7 + 0x28) = 5;
        pvVar8 = *ppvVar7;
        pvVar9 = calloc(5,0x30);
        *(void **)((long)pvVar8 + 0x20) = pvVar9;
        if (*(long *)((long)*ppvVar7 + 0x20) == 0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "lyp_add_ietf_netconf_annotations_config");
          iVar3 = 1;
        }
        else {
          *(undefined4 *)(*(long *)((long)*ppvVar7 + 0x20) + 0x1c) = 0;
          puVar1 = *(undefined8 **)((long)*ppvVar7 + 0x20);
          pcVar6 = lydict_insert(ctx_00,"merge",5);
          *puVar1 = pcVar6;
          *(undefined4 *)(*(long *)((long)*ppvVar7 + 0x20) + 0x4c) = 1;
          lVar2 = *(long *)((long)*ppvVar7 + 0x20);
          pcVar6 = lydict_insert(ctx_00,"replace",7);
          *(char **)(lVar2 + 0x30) = pcVar6;
          *(undefined4 *)(*(long *)((long)*ppvVar7 + 0x20) + 0x7c) = 2;
          lVar2 = *(long *)((long)*ppvVar7 + 0x20);
          pcVar6 = lydict_insert(ctx_00,"create",6);
          *(char **)(lVar2 + 0x60) = pcVar6;
          *(undefined4 *)(*(long *)((long)*ppvVar7 + 0x20) + 0xac) = 3;
          lVar2 = *(long *)((long)*ppvVar7 + 0x20);
          pcVar6 = lydict_insert(ctx_00,"delete",6);
          *(char **)(lVar2 + 0x90) = pcVar6;
          *(undefined4 *)(*(long *)((long)*ppvVar7 + 0x20) + 0xdc) = 4;
          lVar2 = *(long *)((long)*ppvVar7 + 0x20);
          pcVar6 = lydict_insert(ctx_00,"remove",6);
          *(char **)(lVar2 + 0xc0) = pcVar6;
          mod->ext_size = mod->ext_size + '\x01';
          plVar5 = (lys_ext_instance *)calloc(1,0x79);
          if (plVar5 == (lys_ext_instance *)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "lyp_add_ietf_netconf_annotations_config");
            iVar3 = 1;
          }
          else {
            mod->ext[mod->ext_size] = plVar5;
            pcVar6 = lydict_insert(ctx_00,"type",4);
            plVar5->arg_value = pcVar6;
            plVar5->def = (*(ctx_00->models).list)->extensions;
            plVar5->ext_type = '\x01';
            plVar5->parent = mod;
            plVar5->module = (lys_module *)plVar5->parent;
            plVar5->parent_type = '\0';
            plVar5[1].def = *(lys_ext **)(plVar5->def->plugin + 1);
            plVar5->nodetype = LYS_EXT;
            ppvVar7 = &plVar5[1].parent;
            pvVar8 = calloc(1,0x40);
            *ppvVar7 = pvVar8;
            if (*ppvVar7 == (void *)0x0) {
              ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "lyp_add_ietf_netconf_annotations_config");
              iVar3 = 1;
            }
            else {
              *(undefined4 *)*ppvVar7 = 6;
              *(lys_tpdf **)((long)*ppvVar7 + 0x10) = ly_types[6];
              *(lys_ext_instance **)((long)*ppvVar7 + 0x18) = plVar5;
              *(undefined4 *)((long)*ppvVar7 + 0x28) = 2;
              pvVar8 = *ppvVar7;
              pvVar9 = calloc(2,0x30);
              *(void **)((long)pvVar8 + 0x20) = pvVar9;
              if (*(long *)((long)*ppvVar7 + 0x20) == 0) {
                ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                       "lyp_add_ietf_netconf_annotations_config");
                iVar3 = 1;
              }
              else {
                *(undefined4 *)(*(long *)((long)*ppvVar7 + 0x20) + 0x1c) = 0;
                puVar1 = *(undefined8 **)((long)*ppvVar7 + 0x20);
                pcVar6 = lydict_insert(ctx_00,"subtree",7);
                *puVar1 = pcVar6;
                *(undefined4 *)(*(long *)((long)*ppvVar7 + 0x20) + 0x4c) = 1;
                lVar2 = *(long *)((long)*ppvVar7 + 0x20);
                pcVar6 = lydict_insert(ctx_00,"xpath",5);
                *(char **)(lVar2 + 0x30) = pcVar6;
                for (i = (int)mod->features_size; 0 < i; i = i + -1) {
                  iVar3 = strcmp(mod->features[(long)i + -1].name,"xpath");
                  if (iVar3 == 0) {
                    *(undefined *)(*(long *)((long)*ppvVar7 + 0x20) + 0x4b) = 1;
                    lVar2 = *(long *)((long)*ppvVar7 + 0x20);
                    pvVar8 = calloc(1,0x40);
                    *(void **)(lVar2 + 0x58) = pvVar8;
                    if (*(long *)(*(long *)((long)*ppvVar7 + 0x20) + 0x58) == 0) {
                      ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                             "lyp_add_ietf_netconf_annotations_config");
                      return 1;
                    }
                    puVar1 = *(undefined8 **)(*(long *)((long)*ppvVar7 + 0x20) + 0x58);
                    pvVar8 = malloc(1);
                    *puVar1 = pvVar8;
                    if (**(long **)(*(long *)((long)*ppvVar7 + 0x20) + 0x58) == 0) {
                      ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                             "lyp_add_ietf_netconf_annotations_config");
                      return 1;
                    }
                    *(undefined *)**(undefined8 **)(*(long *)((long)*ppvVar7 + 0x20) + 0x58) = 3;
                    lVar2 = *(long *)(*(long *)((long)*ppvVar7 + 0x20) + 0x58);
                    pvVar8 = malloc(8);
                    *(void **)(lVar2 + 0x10) = pvVar8;
                    if (*(long *)(*(long *)(*(long *)((long)*ppvVar7 + 0x20) + 0x58) + 0x10) == 0) {
                      ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                             "lyp_add_ietf_netconf_annotations_config");
                      return 1;
                    }
                    **(long **)(*(long *)(*(long *)((long)*ppvVar7 + 0x20) + 0x58) + 0x10) =
                         (long)(mod->features + (long)i + -1);
                    break;
                  }
                }
                mod->ext_size = mod->ext_size + '\x01';
                plVar5 = (lys_ext_instance *)calloc(1,0x79);
                if (plVar5 == (lys_ext_instance *)0x0) {
                  ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                         "lyp_add_ietf_netconf_annotations_config");
                  iVar3 = 1;
                }
                else {
                  mod->ext[mod->ext_size] = plVar5;
                  pcVar6 = lydict_insert(ctx_00,"select",6);
                  plVar5->arg_value = pcVar6;
                  plVar5->def = (*(ctx_00->models).list)->extensions;
                  plVar5->ext_type = '\x01';
                  plVar5->parent = mod;
                  plVar5->module = (lys_module *)plVar5->parent;
                  plVar5->parent_type = '\0';
                  plVar5[1].def = *(lys_ext **)(plVar5->def->plugin + 1);
                  plVar5->nodetype = LYS_EXT;
                  ppvVar7 = &plVar5[1].parent;
                  pvVar8 = calloc(1,0x40);
                  *ppvVar7 = pvVar8;
                  if (*ppvVar7 == (void *)0x0) {
                    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                           "lyp_add_ietf_netconf_annotations_config");
                    iVar3 = 1;
                  }
                  else {
                    *(undefined4 *)*ppvVar7 = 10;
                    *(lys_tpdf **)((long)*ppvVar7 + 0x10) = ly_types[10];
                    *(lys_ext_instance **)((long)*ppvVar7 + 0x18) = plVar5;
                    mod->ext_size = mod->ext_size + '\x01';
                    child = (lys_node *)calloc(1,0x80);
                    if (child == (lys_node *)0x0) {
                      ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                             "lyp_add_ietf_netconf_annotations_config");
                      iVar3 = 1;
                    }
                    else {
                      child->nodetype = LYS_ANYXML;
                      child->prev = child;
                      pcVar6 = lydict_insert(ctx_00,"config",0);
                      child->name = pcVar6;
                      child->module = mod;
                      child->flags = 1;
                      iVar3 = lys_node_addchild((lys_node *)0x0,mod,child,0);
                      if (iVar3 == 0) {
                        iVar3 = 0;
                      }
                      else {
                        iVar3 = 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return iVar3;
}



int parse_int(char *val_str,int64_t min,int64_t max,int base,int64_t *ret,lyd_node *node)

{
  int iVar1;
  int *piVar2;
  longlong lVar3;
  ushort **ppuVar4;
  long in_FS_OFFSET;
  lyd_node *node_local;
  int64_t *ret_local;
  int base_local;
  int64_t max_local;
  int64_t min_local;
  char *val_str_local;
  char *strptr;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                  ,0x1b0,"parse_int");
  }
  if ((val_str != (char *)0x0) && (*val_str != '\0')) {
    piVar2 = __errno_location();
    *piVar2 = 0;
    strptr = (char *)0x0;
    lVar3 = strtoll(val_str,&strptr,base);
    *ret = lVar3;
    piVar2 = __errno_location();
    if ((*piVar2 == 0) && ((min <= *ret && (*ret <= max)))) {
      if ((strptr != (char *)0x0) && (*strptr != '\0')) {
        while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[*strptr] & 0x2000) != 0) {
          strptr = strptr + 1;
        }
        if (*strptr != '\0') goto LAB_00137cef;
      }
      iVar1 = 0;
      goto LAB_00137d41;
    }
  }
LAB_00137cef:
  if (val_str == (char *)0x0) {
    val_str = "";
  }
  ly_vlog(node->schema->module->ctx,LYE_INVAL,LY_VLOG_LYD,node,val_str,node->schema->name);
  iVar1 = 1;
LAB_00137d41:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int parse_uint(char *val_str,uint64_t max,int base,uint64_t *ret,lyd_node *node)

{
  int iVar1;
  int *piVar2;
  ushort **ppuVar3;
  long in_FS_OFFSET;
  lyd_node *node_local;
  uint64_t *ret_local;
  int base_local;
  uint64_t max_local;
  char *val_str_local;
  char *strptr;
  uint64_t u;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                  ,0x1d8,"parse_uint");
  }
  if ((val_str != (char *)0x0) && (*val_str != '\0')) {
    piVar2 = __errno_location();
    *piVar2 = 0;
    strptr = (char *)0x0;
    u = strtoull(val_str,&strptr,base);
    piVar2 = __errno_location();
    if ((*piVar2 == 0) && (u <= max)) {
      if ((strptr == (char *)0x0) || (*strptr == '\0')) {
        if ((u == 0) || (*val_str != '-')) goto LAB_00137e74;
      }
      else {
        while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*strptr] & 0x2000) != 0) {
          strptr = strptr + 1;
        }
        if (*strptr == '\0') {
LAB_00137e74:
          *ret = u;
          iVar1 = 0;
          goto LAB_00137edf;
        }
      }
    }
  }
  if (val_str == (char *)0x0) {
    val_str = "";
  }
  ly_vlog(node->schema->module->ctx,LYE_INVAL,LY_VLOG_LYD,node,val_str,node->schema->name);
  iVar1 = 1;
LAB_00137edf:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int validate_length_range
              (uint8_t kind,uint64_t unum,int64_t snum,int64_t fnum,uint8_t fnum_dig,lys_type *type,
              char *val_str,lyd_node *node)

{
  LY_DATA_TYPE LVar1;
  bool bVar2;
  int iVar3;
  char *pcVar4;
  long in_FS_OFFSET;
  lyd_node *node_local;
  char *val_str_local;
  lys_type *type_local;
  int64_t fnum_local;
  int64_t snum_local;
  uint64_t unum_local;
  uint8_t fnum_dig_local;
  uint8_t kind_local;
  int match;
  len_ran_intv *intv;
  lys_restr *restr;
  len_ran_intv *tmp_intv;
  lys_type *cur_type;
  ly_ctx *ctx;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  restr = (lys_restr *)0x0;
  intv = (len_ran_intv *)0x0;
  ctx = type->parent->module->ctx;
  iVar3 = resolve_len_ran_interval(ctx,(char *)0x0,type,&intv);
  if (iVar3 == 0) {
    if (intv != (len_ran_intv *)0x0) {
      tmp_intv = intv;
      cur_type = intv->type;
LAB_00137fdd:
      bVar2 = false;
      do {
        if ((tmp_intv == (len_ran_intv *)0x0) || (cur_type != tmp_intv->type)) goto LAB_0013811b;
        if (!bVar2) {
          if ((((kind == '\0') && (unum < (tmp_intv->value).uval.min)) ||
              ((kind == '\x01' && (snum < (tmp_intv->value).sval.min)))) ||
             ((kind == '\x02' &&
              (iVar3 = dec64cmp(fnum,fnum_dig,(tmp_intv->value).sval.min,(cur_type->info).dec64.dig)
              , iVar3 < 0)))) goto LAB_0013811b;
          if (((((kind == '\0') && ((tmp_intv->value).uval.min <= unum)) &&
               (unum <= (tmp_intv->value).uval.max)) ||
              (((kind == '\x01' && ((tmp_intv->value).sval.min <= snum)) &&
               (snum <= (tmp_intv->value).sval.max)))) ||
             (((kind == '\x02' &&
               (iVar3 = dec64cmp(fnum,fnum_dig,(tmp_intv->value).sval.min,(cur_type->info).dec64.dig
                                ), -1 < iVar3)) &&
              (iVar3 = dec64cmp(fnum,fnum_dig,(tmp_intv->value).sval.max,(cur_type->info).dec64.dig)
              , iVar3 < 1)))) {
            bVar2 = true;
          }
        }
        tmp_intv = tmp_intv->next;
      } while( true );
    }
    iVar3 = 0;
  }
  else {
    ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
           ,0x206);
    iVar3 = 1;
  }
  goto LAB_001382c4;
LAB_0013811b:
  if ((!bVar2) || (tmp_intv == (len_ran_intv *)0x0)) goto LAB_00138164;
  cur_type = tmp_intv->type;
  goto LAB_00137fdd;
LAB_00138164:
  while (intv != (len_ran_intv *)0x0) {
    tmp_intv = intv->next;
    free(intv);
    intv = tmp_intv;
  }
  if (bVar2) {
    iVar3 = 0;
    goto LAB_001382c4;
  }
  LVar1 = cur_type->base;
  if (LY_TYPE_UINT64 < LVar1) goto LAB_001381d5;
  if (LVar1 < LY_TYPE_INT8) {
    if (LVar1 == LY_TYPE_STRING) {
      restr = (cur_type->info).dec64.range;
    }
    else {
      if (LY_TYPE_STRING < LVar1) {
LAB_001381d5:
        ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
               ,0x249);
        iVar3 = 1;
        goto LAB_001382c4;
      }
      if (LVar1 == LY_TYPE_BINARY) {
        restr = (cur_type->info).dec64.range;
      }
      else {
        if (LVar1 != LY_TYPE_DEC64) goto LAB_001381d5;
        restr = (cur_type->info).dec64.range;
      }
    }
  }
  else {
    restr = (cur_type->info).dec64.range;
  }
  if (restr == (lys_restr *)0x0) {
    pcVar4 = "";
  }
  else {
    pcVar4 = restr->expr;
  }
  if (val_str == (char *)0x0) {
    val_str = "";
  }
  ly_vlog(ctx,LYE_NOCONSTR,LY_VLOG_LYD,node,val_str,pcVar4);
  if ((restr != (lys_restr *)0x0) && (restr->emsg != (char *)0x0)) {
    ly_vlog_str(ctx,LY_VLOG_PREV,restr->emsg);
  }
  if ((restr != (lys_restr *)0x0) && (restr->eapptag != (char *)0x0)) {
    ly_err_last_set_apptag(ctx,restr->eapptag);
  }
  iVar3 = 1;
LAB_001382c4:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar3;
}



int validate_pattern(ly_ctx *ctx,char *val_str,lys_type *type,lyd_node *node)

{
  int iVar1;
  void **ppvVar2;
  size_t sVar3;
  lyd_node *node_local;
  lys_type *type_local;
  char *val_str_local;
  ly_ctx *ctx_local;
  uint i;
  int rc;
  
  if ((ctx == (ly_ctx *)0x0) || (type->base != LY_TYPE_STRING)) {
                    // WARNING: Subroutine does not return
    __assert_fail("ctx && (type->base == LY_TYPE_STRING)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                  ,0x263,"validate_pattern");
  }
  val_str_local = val_str;
  if (val_str == (char *)0x0) {
    val_str_local = "";
  }
  if ((type->der != (lys_tpdf *)0x0) &&
     (iVar1 = validate_pattern(ctx,val_str_local,&type->der->type,node), iVar1 != 0)) {
    return 1;
  }
  if (((type->info).str.patterns_pcre == (void **)0x0) && ((type->info).str.pat_count != 0)) {
    ppvVar2 = (void **)malloc((ulong)((type->info).str.pat_count * 2) << 3);
    (type->info).str.patterns_pcre = ppvVar2;
    if ((type->info).str.patterns_pcre == (void **)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","validate_pattern");
      return -1;
    }
    for (i = 0; i < (type->info).str.pat_count; i = i + 1) {
      iVar1 = lyp_precompile_pattern
                        (ctx,(char *)(*(long *)(((type->info).lref.target)->padding +
                                               (ulong)i * 0x38 + -0x1c) + 1),
                         (pcre **)((type->info).str.patterns_pcre + i * 2),
                         (pcre_extra **)((type->info).str.patterns_pcre + (i * 2 + 1)));
      if (iVar1 != 0) {
        return 1;
      }
    }
  }
  i = 0;
  while( true ) {
    if ((type->info).str.pat_count <= i) {
      return 0;
    }
    sVar3 = strlen(val_str_local);
    iVar1 = pcre_exec((type->info).str.patterns_pcre[i * 2],
                      (type->info).str.patterns_pcre[i * 2 + 1],val_str_local,sVar3 & 0xffffffff,0,0
                      ,0,0);
    if (((iVar1 != 0) &&
        (**(char **)(((type->info).lref.target)->padding + (ulong)i * 0x38 + -0x1c) == '\x06')) ||
       ((iVar1 == 0 &&
        (**(char **)(((type->info).lref.target)->padding + (ulong)i * 0x38 + -0x1c) == '\x15'))))
    break;
    i = i + 1;
  }
  ly_vlog(ctx,LYE_NOCONSTR,LY_VLOG_LYD,node,val_str_local,
          *(long *)(((type->info).lref.target)->padding + (ulong)i * 0x38 + -0x1c) + 1);
  if (*(long *)(((type->info).lref.target)->padding + (ulong)i * 0x38 + 4) != 0) {
    ly_vlog_str(ctx,LY_VLOG_PREV,
                *(char **)(((type->info).lref.target)->padding + (ulong)i * 0x38 + 4));
  }
  if (*(long *)(((type->info).lref.target)->padding + (ulong)i * 0x38 + -4) != 0) {
    ly_err_last_set_apptag
              (ctx,*(char **)(((type->info).lref.target)->padding + (ulong)i * 0x38 + -4));
  }
  return 1;
}



void check_number(char *str_num,char **num_end,LY_DATA_TYPE base)

{
  ushort **ppuVar1;
  LY_DATA_TYPE base_local;
  char **num_end_local;
  char *str_num_local;
  
  ppuVar1 = __ctype_b_loc();
  if (((((*ppuVar1)[*str_num] & 0x800) == 0) && (*str_num != '-')) && (*str_num != '+')) {
    *num_end = str_num;
  }
  else {
    if ((*str_num == '-') || (str_num_local = str_num, *str_num == '+')) {
      str_num_local = str_num + 1;
    }
    while (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[*str_num_local] & 0x800) != 0) {
      str_num_local = str_num_local + 1;
    }
    if (((base == LY_TYPE_DEC64) && (*str_num_local == '.')) &&
       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[str_num_local[1]] & 0x800) != 0)) {
      do {
        str_num_local = str_num_local + 1;
        ppuVar1 = __ctype_b_loc();
      } while (((*ppuVar1)[*str_num_local] & 0x800) != 0);
      *num_end = str_num_local;
    }
    else {
      *num_end = str_num_local;
    }
  }
  return;
}



int lyp_check_length_range(ly_ctx *ctx,char *expr,lys_type *type)

{
  bool bVar1;
  int iVar2;
  ushort **ppuVar3;
  long in_FS_OFFSET;
  lys_type *type_local;
  char *expr_local;
  ly_ctx *ctx_local;
  int ret;
  int flg;
  len_ran_intv *intv;
  char *tail;
  char *c;
  len_ran_intv *tmp_intv;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  intv = (len_ran_intv *)0x0;
  ret = 1;
  bVar1 = true;
  c = expr;
  if (expr == (char *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("expr",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                  ,0x2c4,"lyp_check_length_range");
  }
LAB_00138828:
  do {
    while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*c] & 0x2000) != 0) {
      c = c + 1;
    }
    iVar2 = strncmp(c,"max",3);
    if (iVar2 == 0) {
LAB_00138870:
      c = c + 3;
      while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*c] & 0x2000) != 0) {
        c = c + 1;
      }
      if (*c == '\0') {
LAB_00138b3a:
        iVar2 = resolve_len_ran_interval(ctx,expr,type,&intv);
        if (iVar2 == 0) {
          ret = 0;
        }
      }
LAB_00138b97:
      while (intv != (len_ran_intv *)0x0) {
        tmp_intv = intv->next;
        free(intv);
        intv = tmp_intv;
      }
      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
        return ret;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    iVar2 = strncmp(c,"min",3);
    if (iVar2 == 0) {
      if (!bVar1) goto LAB_00138b97;
      bVar1 = false;
      c = c + 3;
      while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*c] & 0x2000) != 0) {
        c = c + 1;
      }
      if (*c == '|') {
        c = c + 1;
        goto LAB_00138828;
      }
      if (*c == '\0') goto LAB_00138b3a;
      iVar2 = strncmp(c,"..",2);
      if (iVar2 == 0) {
LAB_00138965:
        c = c + 2;
        while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*c] & 0x2000) != 0) {
          c = c + 1;
        }
        if (*c == '\0') goto LAB_00138b97;
        iVar2 = strncmp(c,"max",3);
        if (iVar2 == 0) goto LAB_00138870;
        check_number(c,&tail,type->base);
        if (c == tail) goto LAB_00138b97;
        c = tail;
        while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*c] & 0x2000) != 0) {
          c = c + 1;
        }
        if (*c == '\0') goto LAB_00138b3a;
        if (*c != '|') goto LAB_00138b97;
        c = c + 1;
        goto LAB_00138828;
      }
      goto LAB_00138b97;
    }
    ppuVar3 = __ctype_b_loc();
    if ((((((*ppuVar3)[*c] & 0x800) == 0) && (*c != '-')) && (*c != '+')) ||
       (check_number(c,&tail,type->base), c == tail)) goto LAB_00138b97;
    c = tail;
    while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*c] & 0x2000) != 0) {
      c = c + 1;
    }
    if (*c != '|') {
      if ((*c != '\0') && (iVar2 = strncmp(c,"..",2), iVar2 == 0)) goto LAB_00138965;
      goto LAB_00138b3a;
    }
    c = c + 1;
  } while( true );
}



int lyp_check_pattern(ly_ctx *ctx,char *pattern,pcre **pcre_precomp)

{
  int iVar1;
  size_t sVar2;
  long in_FS_OFFSET;
  pcre **pcre_precomp_local;
  char *pattern_local;
  ly_ctx *ctx_local;
  int err_offset;
  int idx;
  int idx2;
  int count;
  int start;
  int end;
  char *err_msg;
  char *perl_regex;
  char *ptr;
  char *orig_ptr;
  pcre *precomp;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  count = 0;
  for (ptr = strchr(pattern,0x24); ptr != (char *)0x0; ptr = strchr(ptr + 1,0x24)) {
    count = count + 1;
  }
  sVar2 = strlen(pattern);
  perl_regex = (char *)malloc(sVar2 + (long)count + 4);
  if (perl_regex == (char *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_check_pattern");
    iVar1 = 1;
  }
  else {
    *perl_regex = '\0';
    ptr = perl_regex;
    sVar2 = strlen(pattern);
    iVar1 = strncmp(pattern + (sVar2 - 2),".*",2);
    orig_ptr = pattern;
    if (iVar1 != 0) {
      *ptr = '(';
      ptr = ptr + 1;
    }
    for (; *orig_ptr != '\0'; orig_ptr = orig_ptr + 1) {
      if (*orig_ptr == '$') {
        iVar1 = sprintf(ptr,"\\$");
        ptr = ptr + iVar1;
      }
      else {
        *ptr = *orig_ptr;
        ptr = ptr + 1;
      }
    }
    sVar2 = strlen(pattern);
    iVar1 = strncmp(pattern + (sVar2 - 2),".*",2);
    if (iVar1 == 0) {
      *ptr = '\0';
      ptr = ptr + 1;
    }
    else {
      iVar1 = sprintf(ptr,")$");
      ptr = ptr + iVar1;
    }
    while (ptr = strstr(perl_regex,"\\p{Is"), ptr != (char *)0x0) {
      start = (int)ptr - (int)perl_regex;
      ptr = strchr(ptr,0x7d);
      if (ptr == (char *)0x0) {
        ly_vlog(ctx,LYE_INREGEX,LY_VLOG_NONE,(void *)0x0,pattern,perl_regex + (long)start + 2,
                "unterminated character property");
        free(perl_regex);
        iVar1 = 1;
        goto LAB_001391f7;
      }
      end = ((int)ptr - (int)perl_regex) + 1;
      if (end - start < 0x13) {
        sVar2 = strlen(perl_regex);
        perl_regex = (char *)ly_realloc(perl_regex,sVar2 + (long)(0x13 - (end - start)) + 1);
        if (perl_regex == (char *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_check_pattern");
          free(perl_regex);
          iVar1 = 1;
          goto LAB_001391f7;
        }
      }
      idx = 0;
      while (lyp_ublock2urange[idx][0] != (char *)0x0) {
        sVar2 = strlen(lyp_ublock2urange[idx][0]);
        iVar1 = strncmp(perl_regex + (long)start + 5,lyp_ublock2urange[idx][0],sVar2);
        if (iVar1 == 0) break;
        idx = idx + 1;
      }
      if (lyp_ublock2urange[idx][0] == (char *)0x0) {
        ly_vlog(ctx,LYE_INREGEX,LY_VLOG_NONE,(void *)0x0,pattern,perl_regex + (long)start + 5,
                "unknown block name");
        free(perl_regex);
        iVar1 = 1;
        goto LAB_001391f7;
      }
      count = 0;
      for (idx2 = 0; idx2 < start; idx2 = idx2 + 1) {
        if ((perl_regex[idx2] == '[') && ((idx2 == 0 || (perl_regex[(long)idx2 + -1] != '\\')))) {
          count = count + 1;
        }
        if ((perl_regex[idx2] == ']') && ((idx2 == 0 || (perl_regex[(long)idx2 + -1] != '\\')))) {
          count = count + -1;
        }
      }
      if (count == 0) {
        sVar2 = strlen(perl_regex + end);
        memmove(perl_regex + (long)start + 0x13,perl_regex + end,sVar2 + 1);
        memcpy(perl_regex + start,lyp_ublock2urange[idx][1],0x13);
      }
      else {
        sVar2 = strlen(perl_regex + end);
        memmove(perl_regex + (long)start + 0x11,perl_regex + end,sVar2 + 1);
        memcpy(perl_regex + start,lyp_ublock2urange[idx][1] + 1,0x11);
      }
    }
    precomp = (pcre *)pcre_compile(perl_regex,0x1030,&err_msg,&err_offset,0);
    if (precomp == (pcre *)0x0) {
      ly_vlog(ctx,LYE_INREGEX,LY_VLOG_NONE,(void *)0x0,pattern,perl_regex + err_offset,err_msg);
      free(perl_regex);
      iVar1 = 1;
    }
    else {
      free(perl_regex);
      if (pcre_precomp == (pcre **)0x0) {
        free(precomp);
      }
      else {
        *pcre_precomp = precomp;
      }
      iVar1 = 0;
    }
  }
LAB_001391f7:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyp_precompile_pattern(ly_ctx *ctx,char *pattern,pcre **pcre_cmp,pcre_extra **pcre_std)

{
  int iVar1;
  pcre_extra *ppVar2;
  long in_FS_OFFSET;
  pcre_extra **pcre_std_local;
  pcre **pcre_cmp_local;
  char *pattern_local;
  ly_ctx *ctx_local;
  char *err_msg;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  err_msg = (char *)0x0;
  iVar1 = lyp_check_pattern(ctx,pattern,pcre_cmp);
  if (iVar1 == 0) {
    if ((pcre_std != (pcre_extra **)0x0) && (pcre_cmp != (pcre **)0x0)) {
      ppVar2 = (pcre_extra *)pcre_study(*pcre_cmp,0,&err_msg);
      *pcre_std = ppVar2;
      if (err_msg != (char *)0x0) {
        ly_log(ctx,LY_LLWRN,LY_SUCCESS,"Studying pattern \"%s\" failed (%s).",pattern,err_msg);
      }
    }
    iVar1 = 0;
  }
  else {
    iVar1 = 1;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int make_canonical(ly_ctx *ctx,int type,char **value,void *data1,void *data2)

{
  ushort uVar1;
  ushort uVar2;
  long lVar3;
  int64_t iVar4;
  uint64_t uVar5;
  ly_ctx *plVar6;
  char_0_ *pcVar7;
  lyxp_expr *plVar8;
  uint uVar9;
  int iVar10;
  size_t sVar11;
  size_t sVar12;
  char *pcVar13;
  char *pcVar14;
  undefined *puVar15;
  long in_FS_OFFSET;
  undefined auStack_b8 [8];
  void *data2_local;
  void *data1_local;
  char **value_local;
  int type_local;
  ly_ctx *ctx_local;
  uint8_t c;
  uint16_t buf_len;
  int i;
  int j;
  int count;
  char *module_name;
  undefined8 local_70;
  char_0_ *buf;
  lys_type_bit **bits;
  uint64_t unum;
  int64_t num;
  lyxp_expr *exp;
  char *cur_expr;
  char *end;
  long local_30;
  
  ctx_local = ctx;
  type_local = type;
  value_local = value;
  data1_local = data1;
  data2_local = data2;
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  buf_len = 0x1ff;
  local_70 = 0x1ff;
  for (puVar15 = auStack_b8; puVar15 != auStack_b8; puVar15 = puVar15 + -0x1000) {
    *(undefined8 *)(puVar15 + -8) = *(undefined8 *)(puVar15 + -8);
  }
  if (true) {
    *(undefined8 *)(puVar15 + -8) = *(undefined8 *)(puVar15 + -8);
  }
  plVar6 = ctx_local;
  bits = (lys_type_bit **)0x0;
  if (false) {
switchD_00139429_caseD_0:
    iVar10 = 0;
    buf = puVar15 + -0x200;
  }
  else {
    switch(type_local) {
    default:
      goto switchD_00139429_caseD_0;
    case 2:
      bits = (lys_type_bit **)data1_local;
                    // WARNING: Load size is inaccurate
      count = *data2_local;
      buf = puVar15 + -0x200;
      puVar15[-0x200] = 0;
      for (i = 0; pcVar7 = buf, i < count; i = i + 1) {
        if (bits[i] != (lys_type_bit *)0x0) {
          if (*buf == '\0') {
            pcVar13 = bits[i]->name;
            *(undefined8 *)(puVar15 + -0x208) = 0x13957d;
            sVar12 = strlen(pcVar13);
            pcVar7 = buf;
            plVar6 = ctx_local;
            if (buf_len < sVar12) {
              pcVar13 = bits[i]->name;
              *(undefined8 *)(puVar15 + -0x208) = 0x1395c8;
              ly_log(plVar6,LY_LLERR,LY_EINVAL,"Value \"%s\" is too long.",pcVar13);
              iVar10 = -1;
              goto LAB_00139d9c;
            }
            pcVar13 = bits[i]->name;
            *(undefined8 *)(puVar15 + -0x208) = 0x1395fb;
            strcpy(pcVar7,pcVar13);
          }
          else {
            *(undefined8 *)(puVar15 + -0x208) = 0x139491;
            sVar12 = strlen(pcVar7);
            pcVar13 = bits[i]->name;
            *(undefined8 *)(puVar15 + -0x208) = 0x1394b6;
            sVar11 = strlen(pcVar13);
            pcVar7 = buf;
            plVar6 = ctx_local;
            if ((ulong)buf_len < sVar11 + sVar12 + 1) {
              pcVar13 = bits[i]->name;
              *(undefined8 *)(puVar15 + -0x208) = 0x139508;
              ly_log(plVar6,LY_LLERR,LY_EINVAL,"Value \"%s\" is too long.",pcVar13);
              iVar10 = -1;
              goto LAB_00139d9c;
            }
            pcVar13 = bits[i]->name;
            *(undefined8 *)(puVar15 + -0x208) = 0x139538;
            sVar12 = strlen(pcVar7);
            pcVar14 = buf + sVar12;
            *(undefined8 *)(puVar15 + -0x208) = 0x139556;
            sprintf(pcVar14," %s",pcVar13);
          }
        }
      }
      break;
    case 4:
                    // WARNING: Load size is inaccurate
      lVar3 = *data1_local;
                    // WARNING: Load size is inaccurate
      c = *data2_local;
      num = lVar3;
      if (lVar3 == 0) {
        buf = puVar15 + -0x200;
        *(undefined8 *)(puVar15 + -0x208) = 0x139cd1;
        sprintf(puVar15 + -0x200,"0.0");
      }
      else {
        buf = puVar15 + -0x200;
        *(undefined8 *)(puVar15 + -0x208) = 0x139bd1;
        count = sprintf(puVar15 + -0x200,"%ld ",lVar3);
        iVar4 = num;
        pcVar7 = buf;
        if (((0 < num) && (count + -1 <= (int)(uint)c)) || (count + -2 <= (int)(uint)c)) {
          if (num < 1) {
            uVar9 = c + 2;
          }
          else {
            uVar9 = c + 1;
          }
          *(undefined8 *)(puVar15 + -0x208) = 0x139c2c;
          count = sprintf(pcVar7,"%0*ld ",(ulong)uVar9,iVar4);
        }
        j = 1;
        for (i = (int)c; 0 < i; i = i + -1) {
          if (((j == 0) || (i < 2)) || (buf[count + -2] != '0')) {
            j = 0;
            buf[count + -1] = buf[count + -2];
          }
          else {
            buf[count + -1] = 0;
          }
          count = count + -1;
        }
        buf[count + -1] = 0x2e;
      }
      break;
    case 7:
      module_name = (char *)data1_local;
      pcVar13 = *value_local;
      buf = puVar15 + -0x200;
      *(undefined8 *)(puVar15 + -0x208) = 0x139635;
      pcVar14 = strchr(pcVar13,0x3a);
      pcVar7 = buf;
      pcVar13 = module_name;
      if (pcVar14 == (char *)0x0) {
        pcVar14 = *value_local;
        *(undefined8 *)(puVar15 + -0x208) = 0x139660;
        sprintf(pcVar7,"%s:%s",pcVar13,pcVar14);
      }
      else {
        pcVar13 = *value_local;
        *(undefined8 *)(puVar15 + -0x208) = 0x13967e;
        strcpy(pcVar7,pcVar13);
      }
      break;
    case 8:
      pcVar13 = *value_local;
      buf = puVar15 + -0x200;
      *(undefined8 *)(puVar15 + -0x208) = 0x13969f;
      exp = lyxp_parse_expr(plVar6,pcVar13);
      plVar6 = ctx_local;
      if (exp == (lyxp_expr *)0x0) {
        *(undefined8 *)(puVar15 + -0x208) = 0x1396dc;
        ly_log(plVar6,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
               ,0x408);
        iVar10 = -1;
        goto LAB_00139d9c;
      }
      module_name = (char *)0x0;
      count = 0;
      for (i = 0; plVar8 = exp, plVar6 = ctx_local, (uint)i < (uint)exp->used; i = i + 1) {
        cur_expr = exp->expr + exp->expr_pos[i];
        if ((i != 0) &&
           (pcVar13 = exp->expr +
                      (ulong)exp->tok_len[(long)i + -1] + (ulong)exp->expr_pos[(long)i + -1],
           end = pcVar13, pcVar13 != cur_expr)) {
          if ((long)(ulong)buf_len < (long)(cur_expr + ((long)count - (long)pcVar13))) {
            *(undefined8 *)(puVar15 + -0x208) = 0x1397b6;
            lyxp_expr_free(plVar8);
            pcVar13 = end;
            plVar6 = ctx_local;
            *(undefined8 *)(puVar15 + -0x208) = 0x1397e2;
            ly_log(plVar6,LY_LLERR,LY_EINVAL,"Value \"%s\" is too long.",pcVar13);
            iVar10 = -1;
            goto LAB_00139d9c;
          }
          sVar12 = (long)cur_expr - (long)pcVar13;
          pcVar14 = buf + count;
          *(undefined8 *)(puVar15 + -0x208) = 0x139817;
          strncpy(pcVar14,pcVar13,sVar12);
          count = count + ((int)cur_expr - (int)end);
        }
        pcVar13 = cur_expr;
        if (exp->tokens[i] == LYXP_TOKEN_NAMETEST) {
          uVar1 = exp->tok_len[i];
          *(undefined8 *)(puVar15 + -0x208) = 0x139873;
          end = strnchr(pcVar13,0x3a,(uint)uVar1);
          pcVar14 = cur_expr;
          pcVar13 = module_name;
          if (end == (char *)0x0) goto LAB_00139a07;
          end = end + 1;
          j = (int)end - (int)cur_expr;
          if (module_name == (char *)0x0) {
LAB_001398b6:
            pcVar13 = cur_expr;
            plVar8 = exp;
            if ((int)(uint)buf_len < count + j) {
              *(undefined8 *)(puVar15 + -0x208) = 0x1398d2;
              lyxp_expr_free(plVar8);
              pcVar13 = cur_expr;
              plVar6 = ctx_local;
              *(undefined8 *)(puVar15 + -0x208) = 0x1398fe;
              ly_log(plVar6,LY_LLERR,LY_EINVAL,"Value \"%s\" is too long.",pcVar13);
              iVar10 = -1;
              goto LAB_00139d9c;
            }
            sVar12 = (size_t)j;
            pcVar14 = buf + count;
            *(undefined8 *)(puVar15 + -0x208) = 0x13992a;
            strncpy(pcVar14,pcVar13,sVar12);
            count = count + j;
          }
          else {
            sVar12 = (size_t)j;
            *(undefined8 *)(puVar15 + -0x208) = 0x1398b2;
            iVar10 = strncmp(pcVar14,pcVar13,sVar12);
            if (iVar10 != 0) goto LAB_001398b6;
          }
          pcVar13 = end;
          plVar8 = exp;
          module_name = cur_expr;
          if ((int)(uint)buf_len < (int)(((uint)exp->tok_len[i] - j) + count)) {
            *(undefined8 *)(puVar15 + -0x208) = 0x139970;
            lyxp_expr_free(plVar8);
            pcVar13 = end;
            plVar6 = ctx_local;
            *(undefined8 *)(puVar15 + -0x208) = 0x13999c;
            ly_log(plVar6,LY_LLERR,LY_EINVAL,"Value \"%s\" is too long.",pcVar13);
            iVar10 = -1;
            goto LAB_00139d9c;
          }
          iVar10 = (uint)exp->tok_len[i] - j;
          pcVar14 = buf + count;
          *(undefined8 *)(puVar15 + -0x208) = 0x1399e2;
          strncpy(pcVar14,pcVar13,(long)iVar10);
          count = count + ((uint)exp->tok_len[i] - j);
        }
        else {
LAB_00139a07:
          plVar8 = exp;
          if ((int)(uint)buf_len < (int)((uint)exp->tok_len[i] + count)) {
            *(undefined8 *)(puVar15 + -0x208) = 0x139a3a;
            lyxp_expr_free(plVar8);
            plVar6 = ctx_local;
            pcVar13 = exp->expr;
            uVar1 = exp->expr_pos[i];
            *(undefined8 *)(puVar15 + -0x208) = 0x139a87;
            ly_log(plVar6,LY_LLERR,LY_EINVAL,"Value \"%s\" is too long.",pcVar13 + uVar1);
            iVar10 = -1;
            goto LAB_00139d9c;
          }
          uVar1 = exp->tok_len[i];
          pcVar13 = exp->expr;
          uVar2 = exp->expr_pos[i];
          pcVar14 = buf + count;
          *(undefined8 *)(puVar15 + -0x208) = 0x139ae9;
          strncpy(pcVar14,pcVar13 + uVar2,(ulong)uVar1);
          count = count + (uint)exp->tok_len[i];
        }
      }
      if ((int)(uint)buf_len < count) {
        *(undefined8 *)(puVar15 + -0x208) = 0x139b5b;
        ly_log(plVar6,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
               ,0x43e);
        plVar8 = exp;
        *(undefined8 *)(puVar15 + -0x208) = 0x139b67;
        lyxp_expr_free(plVar8);
        iVar10 = -1;
        goto LAB_00139d9c;
      }
      buf[count] = 0;
      *(undefined8 *)(puVar15 + -0x208) = 0x139b8a;
      lyxp_expr_free(plVar8);
      break;
    case 0xc:
    case 0xe:
    case 0x10:
    case 0x12:
                    // WARNING: Load size is inaccurate
      iVar4 = *data1_local;
      buf = puVar15 + -0x200;
      num = iVar4;
      *(undefined8 *)(puVar15 + -0x208) = 0x139cfd;
      sprintf(puVar15 + -0x200,"%ld",iVar4);
      break;
    case 0xd:
    case 0xf:
    case 0x11:
    case 0x13:
                    // WARNING: Load size is inaccurate
      uVar5 = *data1_local;
      buf = puVar15 + -0x200;
      unum = uVar5;
      *(undefined8 *)(puVar15 + -0x208) = 0x139d29;
      sprintf(puVar15 + -0x200,"%lu",uVar5);
    }
    pcVar7 = buf;
    pcVar13 = *value_local;
    *(undefined8 *)(puVar15 + -0x208) = 0x139d4b;
    iVar10 = strcmp(pcVar7,pcVar13);
    plVar6 = ctx_local;
    if (iVar10 == 0) {
      iVar10 = 0;
    }
    else {
      pcVar13 = *value_local;
      *(undefined8 *)(puVar15 + -0x208) = 0x139d6b;
      lydict_remove(plVar6,pcVar13);
      pcVar7 = buf;
      plVar6 = ctx_local;
      *(undefined8 *)(puVar15 + -0x208) = 0x139d86;
      pcVar13 = lydict_insert(plVar6,pcVar7,0);
      *value_local = pcVar13;
      iVar10 = 1;
    }
  }
LAB_00139d9c:
  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar10;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * ident_val_add_module_prefix(char *value,lyxml_elem *xml,ly_ctx *ctx)

{
  int iVar1;
  char *pcVar2;
  long in_FS_OFFSET;
  ly_ctx *ctx_local;
  lyxml_elem *xml_local;
  char *value_local;
  char *str;
  lyxml_ns *ns;
  lys_module *mod;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  xml_local = xml;
  do {
    for (ns = (lyxml_ns *)xml_local->attr;
        (ns != (lyxml_ns *)0x0 && ((ns->type != LYXML_ATTR_NS || (ns->prefix != (char *)0x0))));
        ns = ns->next) {
    }
  } while ((ns == (lyxml_ns *)0x0) &&
          (xml_local = xml_local->parent, xml_local != (lyxml_elem *)0x0));
  if (ns == (lyxml_ns *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
           ,0x49a);
    pcVar2 = (char *)0x0;
  }
  else {
    mod = ly_ctx_get_module_by_ns(ctx,ns->value,(char *)0x0,1);
    if (mod == (lys_module *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
             ,0x4a1);
      pcVar2 = (char *)0x0;
    }
    else {
      iVar1 = asprintf(&str,"%s:%s",mod->name,value);
      if (iVar1 == -1) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ident_val_add_module_prefix"
              );
        pcVar2 = (char *)0x0;
      }
      else {
        lydict_remove(ctx,value);
        pcVar2 = lydict_insert_zc(ctx,str);
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pcVar2;
}



lys_type *
lyp_parse_value(lys_type *type,char **value_,lyxml_elem *xml,lyd_node_leaf_list *leaf,lyd_attr *attr
               ,lys_module *param_6,int store,int dflt,int trusted)

{
  int iVar1;
  ushort **ppuVar2;
  lys_module *plVar3;
  uint64_t unum_00;
  char *pcVar4;
  long in_FS_OFFSET;
  lys_module *local_mod_local;
  lyd_attr *attr_local;
  lyd_node_leaf_list *leaf_local;
  lyxml_elem *xml_local;
  char **value__local;
  lys_type *type_local;
  uint8_t old_val_flags;
  int_log_opts prev_ilo;
  int found;
  LY_DATA_TYPE old_val_type;
  int c;
  int len;
  uint i;
  uint j;
  int64_t num;
  uint64_t unum;
  char *ptr;
  char *value;
  lyd_val old_val;
  lys_type *t;
  lys_tpdf *tpdf;
  uint64_t uind;
  uint64_t u;
  char *itemname;
  char *old_val_str;
  lys_type_bit **bits;
  lyd_val *val;
  LY_DATA_TYPE *val_type;
  uint8_t *val_flags;
  lyd_node *contextnode;
  lys_type *ret;
  ly_ctx *ctx;
  lys_ident *ident;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ret = (lys_type *)0x0;
  found = 0;
  u = 0;
  value = *value_;
  old_val_str = (char *)0x0;
  bits = (lys_type_bit **)0x0;
  ctx = type->parent->module->ctx;
  if ((leaf == (lyd_node_leaf_list *)0x0) && (attr == (lyd_attr *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("leaf || attr",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                  ,0x4cc,"lyp_parse_value");
  }
  local_mod_local = param_6;
  if (leaf == (lyd_node_leaf_list *)0x0) {
    if (false) {
                    // WARNING: Subroutine does not return
      __assert_fail("!leaf",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                    ,0x4d9,"lyp_parse_value");
    }
    if (param_6 == (lys_module *)0x0) {
      local_mod_local = attr->annotation->module;
    }
    val = &attr->value;
    val_type = &attr->value_type;
    val_flags = &attr->value_flags;
    contextnode = attr->parent;
    itemname = attr->name;
  }
  else {
    if (attr != (lyd_attr *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("!attr",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                    ,0x4cf,"lyp_parse_value");
    }
    if (param_6 == (lys_module *)0x0) {
      local_mod_local = leaf->schema->module;
    }
    val = &leaf->value;
    val_type = &leaf->value_type;
    val_flags = &leaf->value_flags;
    itemname = leaf->schema->name;
    contextnode = (lyd_node *)leaf;
  }
  if (store != 0) {
    old_val_str = lydict_insert(ctx,*value_,0);
    lyd_free_value(*val,*val_type,*val_flags,type,old_val_str,&old_val,&old_val_type,&old_val_flags)
    ;
    *val_flags = *val_flags & 0xfe;
  }
  pcVar4 = value;
  if (false) {
switchD_0013a22c_caseD_0:
    ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
           ,0x7ac);
    goto LAB_0013cad9;
  }
  type_local = type;
  switch(type->base) {
  default:
    goto switchD_0013a22c_caseD_0;
  case LY_TYPE_BINARY:
    unum = 0;
    ptr = (char *)0x0;
    if (value != (char *)0x0) {
      uind = 0;
      while (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[value[uind]] & 0x2000) != 0) {
        uind = uind + 1;
      }
      ptr = value + uind;
      u = strlen(ptr);
      while ((u != 0 && (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[ptr[u - 1]] & 0x2000) != 0))) {
        u = u - 1;
      }
      unum = u;
      for (uind = 0; uind < u; uind = uind + 1) {
        if (ptr[uind] == '\n') {
          unum = unum - 1;
        }
        else if ((((ptr[uind] < '/') && (ptr[uind] != '+')) ||
                 (('9' < ptr[uind] && (ptr[uind] < 'A')))) ||
                ((('Z' < ptr[uind] && (ptr[uind] < 'a')) || ('z' < ptr[uind])))) {
          if (ptr[uind] == '=') {
            if ((uind == u - 2) && (ptr[uind + 1] == '=')) {
              found = 2;
              uind = uind + 1;
            }
            else if (uind == u - 1) {
              found = 1;
            }
          }
          if (found == 0) {
            ly_vlog(ctx,LYE_INCHAR,LY_VLOG_LYD,contextnode,(ulong)(uint)(int)ptr[uind],ptr + uind);
            ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Invalid Base64 character.");
            goto LAB_0013cad9;
          }
        }
      }
    }
    if ((unum & 3) == 0) {
      len = (int)(unum >> 2) * 3 - found;
      if ((trusted != 0) ||
         (iVar1 = validate_length_range('\0',(long)len,0,0,'\0',type,value,contextnode), iVar1 == 0)
         ) {
        if ((value != (char *)0x0) && ((ptr != value || (ptr[u] != '\0')))) {
          ptr = lydict_insert(ctx,ptr,u);
          lydict_remove(ctx,*value_);
          *value_ = ptr;
        }
        if (store != 0) {
          val->binary = value;
          *val_type = LY_TYPE_BINARY;
        }
        goto LAB_0013c9a7;
      }
    }
    else {
      if (leaf == (lyd_node_leaf_list *)0x0) {
        ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,value);
      }
      else {
        ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,value,itemname);
      }
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
              "Base64 encoded value length must be divisible by 4.");
    }
    break;
  case LY_TYPE_BITS:
    for (; (type_local->info).bits.count == 0; type_local = &type_local->der->type) {
    }
    if (((value == (char *)0x0) && (store == 0)) ||
       (bits = (lys_type_bit **)calloc((ulong)(type_local->info).bits.count,8),
       bits != (lys_type_bit **)0x0)) {
      if (value == (char *)0x0) {
        if (store != 0) {
          val->bit = bits;
          *val_type = LY_TYPE_BITS;
        }
      }
      else {
        c = 0;
        i = 0;
LAB_0013ac82:
        if (value[c] != '\0') {
          while (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[value[c]] & 0x2000) != 0) {
            c = c + 1;
          }
          if (value[c] != '\0') {
            len = 0;
            while ((value[c] != '\0' &&
                   (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[value[c]] & 0x2000) == 0))) {
              c = c + 1;
              len = len + 1;
            }
            c = c - len;
            found = 0;
            for (i = 0; i < (type_local->info).bits.count; i = i + 1) {
              iVar1 = strncmp((type_local->info).bits.bit[i].name,value + c,(long)len);
              if ((iVar1 == 0) && ((type_local->info).bits.bit[i].name[len] == '\0')) {
                j = 0;
                goto LAB_0013aa39;
              }
            }
            goto LAB_0013abd8;
          }
        }
        iVar1 = make_canonical(ctx,2,value_,bits,(void *)((long)&type_local->info + 8));
        if (iVar1 == -1) {
          free(bits);
          break;
        }
        if (store == 0) {
          free(bits);
        }
        else {
          val->bit = bits;
          *val_type = LY_TYPE_BITS;
        }
      }
      goto LAB_0013c9a7;
    }
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_parse_value");
    break;
  case LY_TYPE_BOOL:
    if ((value == (char *)0x0) || (iVar1 = strcmp(value,"true"), iVar1 != 0)) {
      if ((value == (char *)0x0) || (iVar1 = strcmp(value,"false"), iVar1 != 0)) {
        if (leaf == (lyd_node_leaf_list *)0x0) {
          pcVar4 = value;
          if (value == (char *)0x0) {
            pcVar4 = "";
          }
          ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,pcVar4);
        }
        else {
          pcVar4 = value;
          if (value == (char *)0x0) {
            pcVar4 = "";
          }
          ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,pcVar4,itemname);
        }
        break;
      }
      if (store != 0) {
        val->bln = '\0';
      }
    }
    else if (store != 0) {
      val->bln = '\x01';
    }
    if (store != 0) {
      *val_type = LY_TYPE_BOOL;
    }
    goto LAB_0013c9a7;
  case LY_TYPE_DEC64:
    if ((value == (char *)0x0) || (*value == '\0')) {
      if (leaf == (lyd_node_leaf_list *)0x0) {
        ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,&DAT_002127ef);
      }
      else {
        ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,&DAT_002127ef,itemname);
      }
    }
    else {
      ptr = value;
      iVar1 = parse_range_dec64(&ptr,(type->info).dec64.dig,&num);
      if ((iVar1 == 0) && (*ptr == '\0')) {
        if (((trusted != 0) ||
            (iVar1 = validate_length_range
                               ('\x02',0,0,num,(type->info).dec64.dig,type,value,contextnode),
            iVar1 == 0)) &&
           (iVar1 = make_canonical(ctx,4,value_,&num,(void *)((long)&type->info + 8)), iVar1 != -1))
        {
          if (store != 0) {
            val->dec64 = num;
            *val_type = LY_TYPE_DEC64;
          }
          goto LAB_0013c9a7;
        }
      }
      else if (leaf == (lyd_node_leaf_list *)0x0) {
        ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,value);
      }
      else {
        ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,value,itemname);
      }
    }
    break;
  case LY_TYPE_EMPTY:
    if ((value == (char *)0x0) || (*value == '\0')) {
      if (store != 0) {
        *val_type = LY_TYPE_EMPTY;
      }
      goto LAB_0013c9a7;
    }
    if (leaf == (lyd_node_leaf_list *)0x0) {
      ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,value);
    }
    else {
      ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,value,itemname);
    }
    break;
  case LY_TYPE_ENUM:
    for (; (type_local->info).bits.count == 0; type_local = &type_local->der->type) {
    }
    found = 0;
    for (i = 0; i < (type_local->info).bits.count; i = i + 1) {
      if ((value != (char *)0x0) &&
         (iVar1 = strcmp(value,(type_local->info).bits.bit[i].name), iVar1 == 0)) {
        j = 0;
        goto LAB_0013b2dc;
      }
    }
    goto LAB_0013b378;
  case LY_TYPE_IDENT:
    if (value == (char *)0x0) {
      if (leaf == (lyd_node_leaf_list *)0x0) {
        ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,&DAT_002127ef);
      }
      else {
        ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,&DAT_002127ef,itemname);
      }
    }
    else if (xml == (lyxml_elem *)0x0) {
      if (dflt == 0) {
        value = lydict_insert(ctx,*value_,0);
      }
      else {
        ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
        value = transform_schema2json(local_mod_local,value);
        ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
        if (value == (char *)0x0) {
          value = lydict_insert(ctx,*value_,0);
        }
      }
LAB_0013b700:
      ident = resolve_identref(type,value,contextnode,local_mod_local,dflt);
      if (ident == (lys_ident *)0x0) {
        lydict_remove(ctx,value);
      }
      else {
        if (store != 0) {
          val->ident = ident;
          *val_type = LY_TYPE_IDENT;
        }
        if (dflt != 0) {
          type->parent->flags = type->parent->flags | 0x1000;
        }
        plVar3 = lys_main_module(local_mod_local);
        iVar1 = make_canonical(ctx,7,&value,plVar3->name,(void *)0x0);
        if (iVar1 != -1) {
          lydict_remove(ctx,*value_);
          *value_ = value;
          goto LAB_0013c9a7;
        }
        lydict_remove(ctx,value);
      }
    }
    else {
      ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
      value = transform_xml2json(ctx,value,xml,0,0);
      ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
      if (value == (char *)0x0) {
        if (leaf == (lyd_node_leaf_list *)0x0) {
          ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,*value_);
        }
        else {
          ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,*value_,itemname);
        }
      }
      else {
        pcVar4 = strchr(value,0x3a);
        if (((pcVar4 != (char *)0x0) || (xml->ns->prefix == (char *)0x0)) ||
           (value = ident_val_add_module_prefix(value,xml,ctx), value != (char *)0x0))
        goto LAB_0013b700;
      }
    }
    break;
  case LY_TYPE_INST:
    if (value != (char *)0x0) {
      if (xml == (lyxml_elem *)0x0) {
        if (dflt == 0) {
          c = make_canonical(ctx,8,&value,(void *)0x0,(void *)0x0);
          if (c != 0) {
            if (c == -1) break;
            *value_ = value;
          }
        }
        else {
          ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
          value = transform_schema2json(local_mod_local,value);
          if (value == (char *)0x0) {
            value = *value_;
          }
          else if (*value_ == value) {
            lydict_remove(ctx,value);
          }
          ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
        }
      }
      else {
        ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
        value = transform_xml2json(ctx,value,xml,1,1);
        ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
        if (value == (char *)0x0) {
          if (leaf == (lyd_node_leaf_list *)0x0) {
            ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,*value_);
          }
          else {
            ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,*value_,itemname);
          }
          break;
        }
        if (*value_ == value) {
          lydict_remove(ctx,value);
        }
      }
      if (store != 0) {
        val->binary = (char *)0x0;
        *val_type = LY_TYPE_INST;
        *val_flags = *val_flags | 1;
      }
      if (*value_ != value) {
        lydict_remove(ctx,*value_);
        *value_ = value;
        if (dflt != 0) {
          type->parent->flags = type->parent->flags | 0x1000;
        }
      }
      goto LAB_0013c9a7;
    }
    if (leaf == (lyd_node_leaf_list *)0x0) {
      ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,&DAT_002127ef);
    }
    else {
      ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,&DAT_002127ef,itemname);
    }
    break;
  case LY_TYPE_LEAFREF:
    if (value == (char *)0x0) {
      if (leaf == (lyd_node_leaf_list *)0x0) {
        ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,&DAT_002127ef);
      }
      else {
        ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,&DAT_002127ef,itemname);
      }
    }
    else {
      type_local = lyp_parse_value(&((type->info).lref.target)->type,value_,xml,leaf,attr,
                                   (lys_module *)0x0,store,dflt,trusted);
      value = *value_;
      t = type_local;
      if (type_local != (lys_type *)0x0) {
        if (store != 0) {
          *val_flags = *val_flags | 1;
        }
        goto LAB_0013c9a7;
      }
    }
    break;
  case LY_TYPE_STRING:
    if (trusted == 0) {
      if (value == (char *)0x0) {
        unum_00 = 0;
      }
      else {
        unum_00 = ly_strlen_utf8(value);
      }
      iVar1 = validate_length_range('\0',unum_00,0,0,'\0',type,pcVar4,contextnode);
      if (iVar1 != 0) break;
    }
    if ((trusted != 0) || (iVar1 = validate_pattern(ctx,value,type,contextnode), iVar1 == 0)) {
      tpdf = type->der;
      while ((tpdf->module != (lys_module *)0x0 &&
             ((iVar1 = strcmp(tpdf->name,"xpath1.0"), iVar1 != 0 ||
              (iVar1 = strcmp(tpdf->module->name,"ietf-yang-types"), iVar1 != 0))))) {
        tpdf = (tpdf->type).der;
      }
      if ((tpdf->module != (lys_module *)0x0) && (xml != (lyxml_elem *)0x0)) {
        pcVar4 = value;
        if (value == (char *)0x0) {
          pcVar4 = "";
        }
        value = transform_xml2json(ctx,pcVar4,xml,1,1);
        if (value == (char *)0x0) {
          if (leaf == (lyd_node_leaf_list *)0x0) {
            ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,*value_);
          }
          else {
            ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,*value_,itemname);
          }
          break;
        }
        if (*value_ != value) {
          lydict_remove(ctx,*value_);
          *value_ = value;
        }
      }
      if (store != 0) {
        val->binary = value;
        *val_type = LY_TYPE_STRING;
      }
      goto LAB_0013c9a7;
    }
    break;
  case LY_TYPE_UNION:
    if (store != 0) {
      memset(val,0,8);
      *val_type = LY_TYPE_UNION;
    }
    if ((type->info).uni.has_ptr_type == 0) {
      t = (lys_type *)0x0;
      found = 0;
      ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
      while (t = lyp_get_next_union_type(type,t,&found), type_local = type, t != (lys_type *)0x0) {
        found = 0;
        type_local = lyp_parse_value(t,value_,xml,leaf,attr,(lys_module *)0x0,store,dflt,0);
        ret = type_local;
        if (type_local != (lys_type *)0x0) break;
        if (store != 0) {
          lyd_free_value(*val,*val_type,*val_flags,t,*value_,(lyd_val *)0x0,(LY_DATA_TYPE *)0x0,
                         (uint8_t *)0x0);
          memset(val,0,8);
        }
      }
      ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
      if (t == (lys_type *)0x0) {
        if (store != 0) {
          *val_type = LY_TYPE_DER;
        }
        if (leaf == (lyd_node_leaf_list *)0x0) {
          ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,*value_);
        }
        else {
          if (*value_ == (char *)0x0) {
            pcVar4 = "";
          }
          else {
            pcVar4 = *value_;
          }
          ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,pcVar4,itemname);
        }
        break;
      }
    }
    else if (xml != (lyxml_elem *)0x0) {
      ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
      pcVar4 = transform_xml2json(ctx,value,xml,1,1);
      val->binary = pcVar4;
      ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
      if (val->binary == (char *)0x0) {
        pcVar4 = lydict_insert(ctx,value,0);
        val->binary = pcVar4;
      }
    }
LAB_0013c9a7:
    if (((store != 0) && (type_local->der != (lys_tpdf *)0x0)) &&
       (type_local->der->module != (lys_module *)0x0)) {
      c = lytype_store(type_local->der->module,type_local->der->name,value_,val);
      if (c == -1) break;
      if (c == 0) {
        *val_flags = *val_flags | 2;
      }
    }
    if (store != 0) {
      lyd_free_value(old_val,old_val_type,old_val_flags,type_local,old_val_str,(lyd_val *)0x0,
                     (LY_DATA_TYPE *)0x0,(uint8_t *)0x0);
      lydict_remove(ctx,old_val_str);
    }
    goto LAB_0013cb1e;
  case LY_TYPE_INT8:
    if (dflt == 0) {
      iVar1 = 10;
    }
    else {
      iVar1 = 0;
    }
    iVar1 = parse_int(value,-0x80,0x7f,iVar1,&num,contextnode);
    if ((iVar1 == 0) &&
       ((trusted != 0 ||
        (iVar1 = validate_length_range('\x01',0,num,0,'\0',type,value,contextnode), iVar1 == 0)))) {
      iVar1 = make_canonical(ctx,0xc,value_,&num,(void *)0x0);
      if (iVar1 != -1) {
        if (store != 0) {
          val->bln = (int8_t)num;
          *val_type = LY_TYPE_INT8;
        }
        goto LAB_0013c9a7;
      }
    }
    break;
  case LY_TYPE_UINT8:
    if (dflt == 0) {
      iVar1 = 10;
    }
    else {
      iVar1 = 0;
    }
    iVar1 = parse_uint(value,0xff,iVar1,&unum,contextnode);
    if (((iVar1 == 0) &&
        ((trusted != 0 ||
         (iVar1 = validate_length_range('\0',unum,0,0,'\0',type,value,contextnode), iVar1 == 0))))
       && (iVar1 = make_canonical(ctx,0xd,value_,&unum,(void *)0x0), iVar1 != -1)) {
      if (store != 0) {
        val->bln = (int8_t)unum;
        *val_type = LY_TYPE_UINT8;
      }
      goto LAB_0013c9a7;
    }
    break;
  case LY_TYPE_INT16:
    if (dflt == 0) {
      iVar1 = 10;
    }
    else {
      iVar1 = 0;
    }
    iVar1 = parse_int(value,-0x8000,0x7fff,iVar1,&num,contextnode);
    if ((iVar1 == 0) &&
       ((trusted != 0 ||
        (iVar1 = validate_length_range('\x01',0,num,0,'\0',type,value,contextnode), iVar1 == 0)))) {
      iVar1 = make_canonical(ctx,0xe,value_,&num,(void *)0x0);
      if (iVar1 != -1) {
        if (store != 0) {
          val->int16 = (int16_t)num;
          *val_type = LY_TYPE_INT16;
        }
        goto LAB_0013c9a7;
      }
    }
    break;
  case LY_TYPE_UINT16:
    if (dflt == 0) {
      iVar1 = 10;
    }
    else {
      iVar1 = 0;
    }
    iVar1 = parse_uint(value,0xffff,iVar1,&unum,contextnode);
    if ((iVar1 == 0) &&
       (((trusted != 0 ||
         (iVar1 = validate_length_range('\0',unum,0,0,'\0',type,value,contextnode), iVar1 == 0)) &&
        (iVar1 = make_canonical(ctx,0xf,value_,&unum,(void *)0x0), iVar1 != -1)))) {
      if (store != 0) {
        val->int16 = (int16_t)unum;
        *val_type = LY_TYPE_UINT16;
      }
      goto LAB_0013c9a7;
    }
    break;
  case LY_TYPE_INT32:
    if (dflt == 0) {
      iVar1 = 10;
    }
    else {
      iVar1 = 0;
    }
    iVar1 = parse_int(value,-0x80000000,0x7fffffff,iVar1,&num,contextnode);
    if ((iVar1 == 0) &&
       ((trusted != 0 ||
        (iVar1 = validate_length_range('\x01',0,num,0,'\0',type,value,contextnode), iVar1 == 0)))) {
      iVar1 = make_canonical(ctx,0x10,value_,&num,(void *)0x0);
      if (iVar1 != -1) {
        if (store != 0) {
          val->int32 = (int32_t)num;
          *val_type = LY_TYPE_INT32;
        }
        goto LAB_0013c9a7;
      }
    }
    break;
  case LY_TYPE_UINT32:
    if (dflt == 0) {
      iVar1 = 10;
    }
    else {
      iVar1 = 0;
    }
    iVar1 = parse_uint(value,0xffffffff,iVar1,&unum,contextnode);
    if (((iVar1 == 0) &&
        ((trusted != 0 ||
         (iVar1 = validate_length_range('\0',unum,0,0,'\0',type,value,contextnode), iVar1 == 0))))
       && (iVar1 = make_canonical(ctx,0x11,value_,&unum,(void *)0x0), iVar1 != -1)) {
      if (store != 0) {
        val->int32 = (int32_t)unum;
        *val_type = LY_TYPE_UINT32;
      }
      goto LAB_0013c9a7;
    }
    break;
  case LY_TYPE_INT64:
    if (dflt == 0) {
      iVar1 = 10;
    }
    else {
      iVar1 = 0;
    }
    iVar1 = parse_int(value,-0x8000000000000000,0x7fffffffffffffff,iVar1,&num,contextnode);
    if (((iVar1 == 0) &&
        ((trusted != 0 ||
         (iVar1 = validate_length_range('\x01',0,num,0,'\0',type,value,contextnode), iVar1 == 0))))
       && (iVar1 = make_canonical(ctx,0x12,value_,&num,(void *)0x0), iVar1 != -1)) {
      if (store != 0) {
        val->dec64 = num;
        *val_type = LY_TYPE_INT64;
      }
      goto LAB_0013c9a7;
    }
    break;
  case LY_TYPE_UINT64:
    if (dflt == 0) {
      iVar1 = 10;
    }
    else {
      iVar1 = 0;
    }
    iVar1 = parse_uint(value,0xffffffffffffffff,iVar1,&unum,contextnode);
    if ((iVar1 == 0) &&
       (((trusted != 0 ||
         (iVar1 = validate_length_range('\0',unum,0,0,'\0',type,value,contextnode), iVar1 == 0)) &&
        (iVar1 = make_canonical(ctx,0x13,value_,&unum,(void *)0x0), iVar1 != -1)))) {
      if (store != 0) {
        val->uint64 = unum;
        *val_type = LY_TYPE_UINT64;
      }
      goto LAB_0013c9a7;
    }
  }
LAB_0013cad9:
  if (store != 0) {
    *val = old_val;
    *val_type = old_val_type;
    *val_flags = old_val_flags;
    lydict_remove(ctx,old_val_str);
  }
  type_local = (lys_type *)0x0;
LAB_0013cb1e:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return type_local;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_0013b2dc:
  if ((trusted != 0) || ((type_local->info).bits.bit[i].iffeature_size <= j)) goto LAB_0013b316;
  iVar1 = resolve_iffeature((type_local->info).bits.bit[i].iffeature + j);
  if (iVar1 == 0) {
    if (leaf == (lyd_node_leaf_list *)0x0) {
      ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,value);
    }
    else {
      ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,value,itemname);
    }
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
            "Enum \"%s\" is disabled by its %d. if-feature condition.",value,(ulong)(j + 1));
    goto LAB_0013cad9;
  }
  j = j + 1;
  goto LAB_0013b2dc;
LAB_0013b316:
  if (store != 0) {
    val->binary = (char *)((type_local->info).bits.bit + i);
    *val_type = LY_TYPE_ENUM;
  }
  found = 1;
LAB_0013b378:
  if (found != 0) goto LAB_0013c9a7;
  if (leaf == (lyd_node_leaf_list *)0x0) {
    pcVar4 = value;
    if (value == (char *)0x0) {
      pcVar4 = "";
    }
    ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,pcVar4);
  }
  else {
    pcVar4 = value;
    if (value == (char *)0x0) {
      pcVar4 = "";
    }
    ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,pcVar4,itemname);
  }
  goto LAB_0013cad9;
LAB_0013aa39:
  if ((trusted != 0) || ((type_local->info).bits.bit[i].iffeature_size <= j)) goto LAB_0013aa73;
  iVar1 = resolve_iffeature((type_local->info).bits.bit[i].iffeature + j);
  if (iVar1 == 0) {
    if (leaf == (lyd_node_leaf_list *)0x0) {
      ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,value);
    }
    else {
      ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,value,itemname);
    }
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
            "Bit \"%s\" is disabled by its %d. if-feature condition.",
            (type_local->info).bits.bit[i].name,(ulong)(j + 1));
    free(bits);
    goto LAB_0013cad9;
  }
  j = j + 1;
  goto LAB_0013aa39;
LAB_0013aa73:
  if (bits[i] != (lys_type_bit *)0x0) {
    if (leaf == (lyd_node_leaf_list *)0x0) {
      ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,value);
    }
    else {
      ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,value,itemname);
    }
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Bit \"%s\" used multiple times.",
            (type_local->info).bits.bit[i].name);
    free(bits);
    goto LAB_0013cad9;
  }
  bits[i] = (type_local->info).bits.bit + i;
  found = 1;
LAB_0013abd8:
  if (found == 0) {
    if (leaf == (lyd_node_leaf_list *)0x0) {
      ly_vlog(ctx,LYE_INMETA,LY_VLOG_LYD,contextnode,"<none>",itemname,value);
    }
    else {
      ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,contextnode,value,itemname);
    }
    free(bits);
    goto LAB_0013cad9;
  }
  c = c + len;
  goto LAB_0013ac82;
}



lys_type * lyp_get_next_union_type(lys_type *type,lys_type *prev_type,int *found)

{
  int *found_local;
  lys_type *prev_type_local;
  lys_type *type_local;
  uint i;
  lys_type *ret;
  
  ret = (lys_type *)0x0;
  for (type_local = type; (type_local->info).bits.count == 0; type_local = &type_local->der->type) {
    if (type_local->der == (lys_tpdf *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("type->der",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                    ,0x7d4,"lyp_get_next_union_type");
    }
  }
  i = 0;
  do {
    if ((type_local->info).bits.count <= i) {
      return ret;
    }
    if (*(int *)((long)(type_local->info).bits.bit + (ulong)i * 0x40) == 0xb) {
      ret = lyp_get_next_union_type
                      ((lys_type *)((long)(type_local->info).bits.bit + (ulong)i * 0x40),prev_type,
                       found);
      if (ret != (lys_type *)0x0) {
        return ret;
      }
    }
    else {
      if ((prev_type == (lys_type *)0x0) || (*found != 0)) {
        return (lys_type *)((long)(type_local->info).bits.bit + (ulong)i * 0x40);
      }
      if (prev_type == (lys_type *)((long)(type_local->info).bits.bit + (ulong)i * 0x40)) {
        *found = 1;
      }
    }
    i = i + 1;
  } while( true );
}



int lyp_fill_attr(ly_ctx *ctx,lyd_node *parent,char *module_ns,char *module_name,char *attr_name,
                 char *attr_value,lyxml_elem *xml,int options,lyd_attr **ret)

{
  int iVar1;
  int iVar2;
  lyd_attr *attr;
  lys_ext_instance_complex *plVar3;
  char *pcVar4;
  undefined8 *puVar5;
  lys_type *plVar6;
  char *attr_value_local;
  char *attr_name_local;
  char *module_name_local;
  char *module_ns_local;
  lyd_node *parent_local;
  ly_ctx *ctx_local;
  int pos;
  int i;
  int k;
  int j;
  lys_module *mod;
  lys_submodule *submod;
  lyd_attr *dattr;
  lys_type **type;
  
  submod = (lys_submodule *)0x0;
  if (module_ns == (char *)0x0) {
    if (module_name == (char *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
             ,0x7ff);
      return -1;
    }
    mod = ly_ctx_get_module(ctx,module_name,(char *)0x0,0);
  }
  else {
    mod = ly_ctx_get_module_by_ns(ctx,module_ns,(char *)0x0,0);
  }
  if (mod == (lys_module *)0x0) {
    iVar1 = 1;
  }
  else {
    pos = -1;
    i = 0;
    while( true ) {
      if (((int)(uint)mod->ext_size <= i) ||
         (iVar1 = lys_ext_instance_presence
                            ((*(ctx->models).list)->extensions,mod->ext + i,mod->ext_size - (char)i)
         , iVar1 == -1)) goto LAB_0013cdfe;
      iVar2 = ly_strequal_(mod->ext[iVar1 + i]->arg_value,attr_name);
      if (iVar2 != 0) break;
      i = iVar1 + i + 1;
    }
    pos = iVar1 + i;
LAB_0013cdfe:
    if (pos == -1) {
      for (k = 0; k < (int)(uint)mod->inc_size; k = k + 1) {
        submod = mod->inc[k].submodule;
        i = 0;
        while( true ) {
          if (((int)(uint)submod->ext_size <= i) ||
             (iVar1 = lys_ext_instance_presence
                                ((*(ctx->models).list)->extensions,submod->ext + i,
                                 submod->ext_size - (char)i), iVar1 == -1)) goto LAB_0013cf03;
          iVar2 = ly_strequal_(submod->ext[iVar1 + i]->arg_value,attr_name);
          if (iVar2 != 0) break;
          i = iVar1 + i + 1;
        }
        pos = iVar1 + i;
LAB_0013cf03:
      }
    }
    if (pos == -1) {
      iVar1 = 1;
    }
    else {
      attr = (lyd_attr *)calloc(1,0x38);
      if (attr == (lyd_attr *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_fill_attr");
        iVar1 = -1;
      }
      else {
        attr->parent = parent;
        attr->next = (lyd_attr *)0x0;
        if (submod == (lys_submodule *)0x0) {
          plVar3 = (lys_ext_instance_complex *)mod->ext[pos];
        }
        else {
          plVar3 = (lys_ext_instance_complex *)submod->ext[pos];
        }
        attr->annotation = plVar3;
        pcVar4 = lydict_insert(ctx,attr_name,0);
        attr->name = pcVar4;
        pcVar4 = lydict_insert(ctx,attr_value,0);
        attr->value_str = pcVar4;
        puVar5 = (undefined8 *)
                 lys_ext_complex_get_substmt(LY_STMT_TYPE,attr->annotation,(lyext_substmt **)0x0);
        if ((puVar5 == (undefined8 *)0x0) ||
           (plVar6 = lyp_parse_value((lys_type *)*puVar5,&attr->value_str,xml,
                                     (lyd_node_leaf_list *)0x0,attr,(lys_module *)0x0,1,0,
                                     options & 0x2000), plVar6 == (lys_type *)0x0)) {
          lydict_remove(ctx,attr->name);
          lydict_remove(ctx,attr->value_str);
          free(attr);
          iVar1 = -1;
        }
        else {
          *ret = attr;
          iVar1 = 0;
        }
      }
    }
  }
  return iVar1;
}



int lyp_check_edit_attr(ly_ctx *ctx,lyd_attr *attr,lyd_node *parent,int *editbits)

{
  uint uVar1;
  int iVar2;
  char *pcVar3;
  int *editbits_local;
  lyd_node *parent_local;
  lyd_attr *attr_local;
  ly_ctx *ctx_local;
  int bits;
  lyd_attr *last;
  
  last = (lyd_attr *)0x0;
  bits = 0;
  attr_local = attr;
  do {
    if (attr_local == (lyd_attr *)0x0) {
      if ((last == (lyd_attr *)0x0) ||
         (((parent->schema->nodetype & (LYS_LEAFLIST|LYS_LIST)) != LYS_UNKNOWN &&
          ((parent->schema->flags & 0x100) != 0)))) {
        if (bits == 3) {
          if ((parent->schema->nodetype & LYS_LIST) == LYS_UNKNOWN) {
            ly_vlog(ctx,LYE_MISSATTR,LY_VLOG_LYD,parent,"value",parent->schema->name);
          }
          else {
            ly_vlog(ctx,LYE_MISSATTR,LY_VLOG_LYD,parent,&DAT_00212841,parent->schema->name);
          }
          iVar2 = -1;
        }
        else if (((bits & 0xcU) == 0) || ((bits & 2U) != 0)) {
          if ((bits & 0x21U) == 0x21) {
            ly_vlog(ctx,LYE_INATTR,LY_VLOG_LYD,parent,"insert");
            iVar2 = -1;
          }
          else {
            if (editbits != (int *)0x0) {
              *editbits = bits;
            }
            iVar2 = 0;
          }
        }
        else {
          if ((bits & 4U) == 0) {
            pcVar3 = "key";
          }
          else {
            pcVar3 = "value";
          }
          ly_vlog(ctx,LYE_INATTR,LY_VLOG_LYD,parent,pcVar3);
          iVar2 = -1;
        }
      }
      else {
        ly_vlog(ctx,LYE_INATTR,LY_VLOG_LYD,parent,last->name);
        iVar2 = -1;
      }
      return iVar2;
    }
    last = (lyd_attr *)0x0;
    iVar2 = strcmp(attr_local->annotation->arg_value,"operation");
    if ((iVar2 == 0) &&
       (iVar2 = strcmp(attr_local->annotation->module->name,"ietf-netconf"), iVar2 == 0)) {
      if ((bits & 0x10U) != 0) {
        ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYD,parent,"operation attributes",parent->schema->name);
        return -1;
      }
      uVar1 = bits | 0x10;
      if (2 < ((attr_local->value).enm)->value) {
        uVar1 = bits | 0x30;
      }
    }
    else if ((attr_local->annotation->module == (ctx->models).list[1]) &&
            (iVar2 = strcmp(attr_local->annotation->arg_value,"insert"), iVar2 == 0)) {
      if ((parent->schema->flags & 0x100) == 0) {
        ly_vlog(ctx,LYE_INATTR,LY_VLOG_LYD,parent,"insert");
        return -1;
      }
      if ((bits & 1U) != 0) {
        ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYD,parent,"insert attributes",parent->schema->name);
        return -1;
      }
      uVar1 = bits | 1;
      if (1 < ((attr_local->value).enm)->value) {
        uVar1 = bits | 3;
      }
      bits = uVar1;
      last = attr_local;
      uVar1 = bits;
    }
    else if ((attr_local->annotation->module == (ctx->models).list[1]) &&
            (iVar2 = strcmp(attr_local->annotation->arg_value,"value"), iVar2 == 0)) {
      if ((bits & 4U) != 0) {
        ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYD,parent,"value attributes",parent->schema->name);
        return -1;
      }
      if ((parent->schema->nodetype & LYS_LIST) != LYS_UNKNOWN) {
        ly_vlog(ctx,LYE_INATTR,LY_VLOG_LYD,parent,attr_local->name);
        return -1;
      }
      last = attr_local;
      uVar1 = bits | 4;
    }
    else {
      uVar1 = bits;
      if ((attr_local->annotation->module == (ctx->models).list[1]) &&
         (iVar2 = strcmp(attr_local->annotation->arg_value,"key"), iVar2 == 0)) {
        if ((bits & 8U) != 0) {
          ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYD,parent,"key attributes",parent->schema->name);
          return -1;
        }
        if ((parent->schema->nodetype & LYS_LEAFLIST) != LYS_UNKNOWN) {
          ly_vlog(ctx,LYE_INATTR,LY_VLOG_LYD,parent,attr_local->name);
          return -1;
        }
        last = attr_local;
        uVar1 = bits | 8;
      }
    }
    bits = uVar1;
    attr_local = attr_local->next;
  } while( true );
}



int dup_identity_check(char *id,lys_ident *ident,uint32_t size)

{
  uint32_t size_local;
  lys_ident *ident_local;
  char *id_local;
  uint32_t i;
  
  i = 0;
  while( true ) {
    if (size <= i) {
      return 0;
    }
    if (id == ident[i].name) break;
    i = i + 1;
  }
  return 1;
}



int dup_identities_check(char *id,lys_module *module)

{
  int iVar1;
  lys_module *plVar2;
  lys_module *module_local;
  char *id_local;
  int i;
  lys_module *mainmod;
  
  iVar1 = dup_identity_check(id,module->ident,(uint)module->ident_size);
  if (iVar1 == 0) {
    plVar2 = lys_main_module(module);
    i = 0;
    while ((i < (int)(uint)plVar2->inc_size && (plVar2->inc[i].submodule != (lys_submodule *)0x0)))
    {
      iVar1 = dup_identity_check(id,(plVar2->inc[i].submodule)->ident,
                                 (uint)(plVar2->inc[i].submodule)->ident_size);
      if (iVar1 != 0) {
        ly_vlog(module->ctx,LYE_DUPID,LY_VLOG_NONE,(void *)0x0,"identity",id);
        return 1;
      }
      i = i + 1;
    }
    iVar1 = 0;
  }
  else {
    ly_vlog(module->ctx,LYE_DUPID,LY_VLOG_NONE,(void *)0x0,"identity",id);
    iVar1 = 1;
  }
  return iVar1;
}



int dup_typedef_check(char *type,lys_tpdf *tpdf,int size)

{
  int iVar1;
  int size_local;
  lys_tpdf *tpdf_local;
  char *type_local;
  int i;
  
  i = 0;
  while( true ) {
    if (size <= i) {
      return 0;
    }
    iVar1 = strcmp(type,tpdf[i].name);
    if (iVar1 == 0) break;
    i = i + 1;
  }
  return 1;
}



int dup_feature_check(char *id,lys_module *module)

{
  int iVar1;
  lys_module *module_local;
  char *id_local;
  int i;
  
  i = 0;
  while( true ) {
    if ((int)(uint)module->features_size <= i) {
      return 0;
    }
    iVar1 = strcmp(id,module->features[i].name);
    if (iVar1 == 0) break;
    i = i + 1;
  }
  return 1;
}



int dup_prefix_check(char *prefix,lys_module *module)

{
  int iVar1;
  lys_module *module_local;
  char *prefix_local;
  int i;
  
  if ((module->prefix != (char *)0x0) && (iVar1 = strcmp(module->prefix,prefix), iVar1 == 0)) {
    return 1;
  }
  i = 0;
  while( true ) {
    if ((int)(uint)module->imp_size <= i) {
      return 0;
    }
    iVar1 = strcmp(module->imp[i].prefix,prefix);
    if (iVar1 == 0) break;
    i = i + 1;
  }
  return 1;
}



int lyp_check_identifier(ly_ctx *ctx,char *id,LY_IDENT type,lys_module *module,lys_node *parent)

{
  LYS_NODE LVar1;
  lys_submodule *plVar2;
  int iVar3;
  lys_module *plVar4;
  lys_node *parent_local;
  lys_module *module_local;
  LY_IDENT type_local;
  char *id_local;
  ly_ctx *ctx_local;
  int i;
  int j;
  int size;
  lys_tpdf *tpdf;
  lys_node *node;
  lys_module *mainmod;
  lys_submodule *submod;
  
  if ((ctx == (ly_ctx *)0x0) || (id == (char *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("ctx && id",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                  ,0x909,"lyp_check_identifier");
  }
  if ((((*id < 'A') || ('Z' < *id)) && ((*id < 'a' || ('z' < *id)))) && (*id != '_')) {
    ly_vlog(ctx,LYE_INID,LY_VLOG_NONE,(void *)0x0,id,"invalid start character");
    return 1;
  }
  for (i = 1; id[i] != '\0'; i = i + 1) {
    if (((id[i] < 'A') || ('Z' < id[i])) &&
       (((id[i] < 'a' || ('z' < id[i])) &&
        ((((id[i] < '0' || ('9' < id[i])) && (id[i] != '_')) && ((id[i] != '-' && (id[i] != '.')))))
        ))) {
      ly_vlog(ctx,LYE_INID,LY_VLOG_NONE,(void *)0x0,id,"invalid character");
      return 1;
    }
  }
  if (0x40 < i) {
    ly_log(ctx,LY_LLWRN,LY_SUCCESS,"Identifier \"%s\" is long, you should use something shorter.",id
          );
  }
  if (true) {
    switch(type) {
    case LY_IDENT_FEATURE:
      if (module == (lys_module *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("module",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                      ,0x96f,"lyp_check_identifier");
      }
      plVar4 = lys_main_module(module);
      iVar3 = dup_feature_check(id,module);
      if (iVar3 != 0) {
        ly_vlog(ctx,LYE_DUPID,LY_VLOG_NONE,(void *)0x0,"feature",id);
        return 1;
      }
      i = 0;
      while ((i < (int)(uint)plVar4->inc_size && (plVar4->inc[i].submodule != (lys_submodule *)0x0))
            ) {
        iVar3 = dup_feature_check(id,(lys_module *)plVar4->inc[i].submodule);
        if (iVar3 != 0) {
          ly_vlog(ctx,LYE_DUPID,LY_VLOG_NONE,(void *)0x0,"feature",id);
          return 1;
        }
        i = i + 1;
      }
      break;
    case LY_IDENT_TYPE:
      if (module == (lys_module *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("module",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                      ,0x92b,"lyp_check_identifier");
      }
      plVar4 = lys_main_module(module);
      iVar3 = strcmp(id,"binary");
      if (((((((iVar3 == 0) || (iVar3 = strcmp(id,"bits"), iVar3 == 0)) ||
             (iVar3 = strcmp(id,"boolean"), iVar3 == 0)) ||
            (((iVar3 = strcmp(id,"decimal64"), iVar3 == 0 ||
              (iVar3 = strcmp(id,"empty"), iVar3 == 0)) ||
             ((iVar3 = strcmp(id,"enumeration"), iVar3 == 0 ||
              ((iVar3 = strcmp(id,"identityref"), iVar3 == 0 ||
               (iVar3 = strcmp(id,"instance-identifier"), iVar3 == 0)))))))) ||
           (iVar3 = strcmp(id,"int8"), iVar3 == 0)) ||
          ((((iVar3 = strcmp(id,"int16"), iVar3 == 0 || (iVar3 = strcmp(id,"int32"), iVar3 == 0)) ||
            (iVar3 = strcmp(id,"int64"), iVar3 == 0)) ||
           (((iVar3 = strcmp(id,"leafref"), iVar3 == 0 || (iVar3 = strcmp(id,"string"), iVar3 == 0))
            || ((iVar3 = strcmp(id,"uint8"), iVar3 == 0 ||
                ((iVar3 = strcmp(id,"uint16"), iVar3 == 0 ||
                 (iVar3 = strcmp(id,"uint32"), iVar3 == 0)))))))))) ||
         ((iVar3 = strcmp(id,"uint64"), iVar3 == 0 ||
          (iVar3 = strcmp(id,"union"), parent_local = parent, iVar3 == 0)))) {
        ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,id,"typedef");
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Typedef name duplicates a built-in type.");
        return 1;
      }
      for (; parent_local != (lys_node *)0x0; parent_local = lys_parent(parent_local)) {
        LVar1 = parent_local->nodetype;
        if (LVar1 == LYS_GROUPING) {
          size = (int)*(ushort *)(parent_local->padding + 2);
          tpdf = *(lys_tpdf **)parent_local->hash;
LAB_0013df33:
          iVar3 = dup_typedef_check(id,tpdf,size);
          if (iVar3 != 0) {
            ly_vlog(ctx,LYE_DUPID,LY_VLOG_NONE,(void *)0x0,"typedef",id);
            return 1;
          }
        }
        else if (LVar1 < (LYS_CONTAINER|LYS_GROUPING)) {
          if (LVar1 == LYS_CONTAINER) {
            size = (int)*(ushort *)(parent_local->padding + 2);
            tpdf = (lys_tpdf *)parent_local[1].ref;
          }
          else {
            if (LVar1 != LYS_LIST) goto LAB_0013df86;
            size = (int)parent_local->padding[1];
            tpdf = (lys_tpdf *)parent_local[1].ref;
          }
          goto LAB_0013df33;
        }
LAB_0013df86:
      }
      iVar3 = dup_typedef_check(id,module->tpdf,(uint)module->tpdf_size);
      if (iVar3 != 0) {
        ly_vlog(ctx,LYE_DUPID,LY_VLOG_NONE,(void *)0x0,"typedef",id);
        return 1;
      }
      i = 0;
      while ((i < (int)(uint)plVar4->inc_size && (plVar4->inc[i].submodule != (lys_submodule *)0x0))
            ) {
        iVar3 = dup_typedef_check(id,(plVar4->inc[i].submodule)->tpdf,
                                  (uint)(plVar4->inc[i].submodule)->tpdf_size);
        if (iVar3 != 0) {
          ly_vlog(ctx,LYE_DUPID,LY_VLOG_NONE,(void *)0x0,"typedef",id);
          return 1;
        }
        i = i + 1;
      }
      break;
    case LY_IDENT_NAME:
      if (parent != (lys_node *)0x0) {
        for (node = parent->child; node != (lys_node *)0x0; node = node->next) {
          if (id == node->name) {
            ly_vlog(ctx,LYE_INID,LY_VLOG_NONE,(void *)0x0,id,"name duplication");
            return 1;
          }
        }
      }
      break;
    case LY_IDENT_PREFIX:
      if (module == (lys_module *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("module",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                      ,0x966,"lyp_check_identifier");
      }
      iVar3 = dup_prefix_check(id,module);
      if (iVar3 != 0) {
        ly_vlog(ctx,LYE_DUPID,LY_VLOG_NONE,(void *)0x0,"prefix",id);
        return 1;
      }
      break;
    case LY_IDENT_EXTENSION:
      if (module == (lys_module *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("module",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                      ,0x983,"lyp_check_identifier");
      }
      plVar4 = lys_main_module(module);
      for (i = 0; i < (int)(uint)plVar4->extensions_size; i = i + 1) {
        if (id == plVar4->extensions[i].name) {
          ly_vlog(ctx,LYE_DUPID,LY_VLOG_NONE,(void *)0x0,"extension",id);
          return 1;
        }
      }
      j = 0;
      while ((j < (int)(uint)plVar4->inc_size && (plVar4->inc[j].submodule != (lys_submodule *)0x0))
            ) {
        plVar2 = plVar4->inc[j].submodule;
        for (i = 0; i < (int)(uint)plVar2->extensions_size; i = i + 1) {
          if (id == plVar2->extensions[i].name) {
            ly_vlog(ctx,LYE_DUPID,LY_VLOG_NONE,(void *)0x0,"extension",id);
            return 1;
          }
        }
        j = j + 1;
      }
    }
  }
  return 0;
}



int lyp_check_date(ly_ctx *ctx,char *date)

{
  long lVar1;
  int iVar2;
  ushort **ppuVar3;
  char *pcVar4;
  long in_FS_OFFSET;
  char *date_local;
  ly_ctx *ctx_local;
  int i;
  char *r;
  tm tm;
  tm tm_;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (date == (char *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("date",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                  ,0x9ab,"lyp_check_date");
  }
  for (i = 0; i < 10; i = i + 1) {
    if ((i == 4) || (i == 7)) {
      if (date[i] != '-') goto LAB_0013e5e2;
    }
    else {
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[date[i]] & 0x800) == 0) goto LAB_0013e5e2;
    }
  }
  memset(&tm,0,0x38);
  pcVar4 = strptime(date,"%Y-%m-%d",(tm *)&tm);
  if ((pcVar4 != (char *)0x0) && (pcVar4 == date + 10)) {
    tm.tm_hour = 0xc;
    tm_.tm_mday = tm.tm_mday;
    tm_.tm_hour = 0xc;
    tm_.tm_sec = tm.tm_sec;
    tm_.tm_min = tm.tm_min;
    tm_.tm_mon = tm.tm_mon;
    tm_.tm_year = tm.tm_year;
    tm_.tm_wday = tm.tm_wday;
    tm_.tm_yday = tm.tm_yday;
    tm_.tm_isdst = tm.tm_isdst;
    tm_._36_4_ = tm._36_4_;
    tm_.tm_gmtoff = tm.tm_gmtoff;
    tm_.tm_zone = tm.tm_zone;
    mktime((tm *)&tm_);
    if (tm.tm_mday == tm_.tm_mday) {
      iVar2 = 0;
      goto LAB_0013e614;
    }
  }
LAB_0013e5e2:
  ly_vlog(ctx,LYE_INDATE,LY_VLOG_NONE,(void *)0x0,date);
  iVar2 = 1;
LAB_0013e614:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_node * lyp_check_mandatory_(lys_node *root)

{
  bool bVar1;
  lys_node *root_local;
  int mand_flag;
  lys_node *iter;
  
  bVar1 = false;
  iter = (lys_node *)0x0;
  do {
    do {
      while( true ) {
        iter = lys_getnext(iter,root,(lys_module *)0x0,0x171);
        if (iter == (lys_node *)0x0) {
          return (lys_node *)0x0;
        }
        if (iter->nodetype != LYS_USES) break;
        if (iter[1].ref == (char *)0x0) {
          return root;
        }
      }
    } while (iter->nodetype == LYS_CHOICE);
    if (iter->nodetype == LYS_LIST) {
      if (*(int *)&iter[1].iffeature != 0) {
        bVar1 = true;
      }
    }
    else if (iter->nodetype == LYS_LEAFLIST) {
      if (*(int *)&iter[1].priv != 0) {
        bVar1 = true;
      }
    }
    else if ((iter->flags & 0x40) != 0) {
      bVar1 = true;
    }
  } while (!bVar1);
  return iter;
}



int lyp_check_mandatory_augment(lys_node_augment *aug,lys_node *target)

{
  int iVar1;
  lys_node *plVar2;
  lys_node *target_local;
  lys_node_augment *aug_local;
  lys_node *node;
  
  if ((aug->when == (lys_when *)0x0) && (target->nodetype != LYS_CHOICE)) {
    plVar2 = lyp_check_mandatory_((lys_node *)aug);
    if (plVar2 == (lys_node *)0x0) {
      iVar1 = 0;
    }
    else if (plVar2 == (lys_node *)aug) {
      iVar1 = 1;
    }
    else {
      ly_vlog(target->module->ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"mandatory");
      ly_vlog(target->module->ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "Mandatory node \"%s\" appears in augment of \"%s\" without when condition.",
              plVar2->name,aug->target_name);
      iVar1 = -1;
    }
  }
  else {
    iVar1 = 0;
  }
  return iVar1;
}



int lyp_check_mandatory_choice(lys_node *node)

{
  lys_node *root;
  int iVar1;
  lys_node *plVar2;
  lys_node *node_local;
  lys_node *dflt;
  lys_node *mand;
  
  root = (lys_node *)node[1].name;
  plVar2 = lyp_check_mandatory_(root);
  if (plVar2 == (lys_node *)0x0) {
    iVar1 = 0;
  }
  else if (plVar2 == root) {
    iVar1 = 1;
  }
  else {
    ly_vlog(node->module->ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"mandatory");
    ly_vlog(node->module->ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
            "Mandatory node \"%s\" is directly under the default case \"%s\" of the \"%s\" choice.",
            plVar2->name,root->name,node->name);
    iVar1 = -1;
  }
  return iVar1;
}



int lyp_check_status(uint16_t flags1,lys_module *mod1,char *name1,uint16_t flags2,lys_module *mod2,
                    char *name2,lys_node *node)

{
  ushort uVar1;
  ushort uVar2;
  lys_module *plVar3;
  lys_module *plVar4;
  char *pcVar5;
  char *pcVar6;
  LY_VLOG_ELEM elem_type;
  char *name2_local;
  lys_module *mod2_local;
  char *name1_local;
  lys_module *mod1_local;
  uint16_t flags2_local;
  uint16_t flags1_local;
  uint16_t flg1;
  uint16_t flg2;
  
  if ((flags1 & 0x38) == 0) {
    uVar1 = 8;
  }
  else {
    uVar1 = flags1 & 0x38;
  }
  if ((flags2 & 0x38) == 0) {
    uVar2 = 8;
  }
  else {
    uVar2 = flags2 & 0x38;
  }
  if (uVar1 < uVar2) {
    plVar3 = lys_main_module(mod1);
    plVar4 = lys_main_module(mod2);
    if (plVar3 == plVar4) {
      if (uVar2 == 0x20) {
        pcVar5 = "obsolete";
      }
      else {
        pcVar5 = "deprecated";
      }
      if (uVar1 == 8) {
        pcVar6 = "current";
      }
      else {
        pcVar6 = "deprecated";
      }
      if (node == (lys_node *)0x0) {
        elem_type = LY_VLOG_NONE;
      }
      else {
        elem_type = LY_VLOG_LYS;
      }
      ly_vlog(mod1->ctx,LYE_INSTATUS,elem_type,node,pcVar6,name1,"references",pcVar5,name2);
      return 1;
    }
  }
  return 0;
}



void lyp_del_includedup(lys_module *mod,int free_subs)

{
  ly_ctx *plVar1;
  int free_subs_local;
  lys_module *mod_local;
  uint8_t i;
  ly_modules_list *models;
  
  plVar1 = mod->ctx;
  if ((mod != (lys_module *)0x0) && ((mod->field_0x40 & 1) == 0)) {
    if ((plVar1->models).parsed_submodules_count != '\0') {
      i = (plVar1->models).parsed_submodules_count;
      do {
        i = i + 0xff;
      } while (((plVar1->models).parsed_submodules[i]->field_0x40 & 1) != 0);
      if (mod == (plVar1->models).parsed_submodules[i]) {
        if (free_subs != 0) {
          i = (plVar1->models).parsed_submodules_count;
          while (i = i + 0xff, ((plVar1->models).parsed_submodules[i]->field_0x40 & 1) != 0) {
            lys_sub_module_remove_devs_augs((plVar1->models).parsed_submodules[i]);
            lys_submodule_module_data_free((lys_submodule *)(plVar1->models).parsed_submodules[i]);
            lys_submodule_free((lys_submodule *)(plVar1->models).parsed_submodules[i],
                               (_func_void_lys_node_ptr_void_ptr *)0x0);
          }
        }
        (plVar1->models).parsed_submodules_count = i;
        if ((plVar1->models).parsed_submodules_count == '\0') {
          free((plVar1->models).parsed_submodules);
          (plVar1->models).parsed_submodules = (lys_module **)0x0;
        }
      }
    }
    return;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("mod && !mod->type",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                ,0xa57,"lyp_del_includedup");
}



void lyp_add_includedup(lys_module *sub_mod,lys_submodule *parsed_submod)

{
  byte bVar1;
  ly_ctx *plVar2;
  lys_module *plVar3;
  lys_module **pplVar4;
  lys_module *plVar5;
  lys_submodule *parsed_submod_local;
  lys_module *sub_mod_local;
  int16_t i;
  ly_modules_list *models;
  
  plVar2 = sub_mod->ctx;
  if ((plVar2->models).parsed_submodules_count == '\0') {
    i = -1;
  }
  else {
    i = (int16_t)(plVar2->models).parsed_submodules_count;
    do {
      i = i - 1;
    } while (((plVar2->models).parsed_submodules[i]->field_0x40 & 1) != 0);
  }
  if ((i == -1) ||
     (plVar5 = (plVar2->models).parsed_submodules[i], plVar3 = lys_main_module(sub_mod),
     plVar5 != plVar3)) {
    (plVar2->models).parsed_submodules_count = (plVar2->models).parsed_submodules_count + '\x01';
    pplVar4 = (lys_module **)
              ly_realloc((plVar2->models).parsed_submodules,
                         (ulong)(plVar2->models).parsed_submodules_count * 8);
    (plVar2->models).parsed_submodules = pplVar4;
    if ((plVar2->models).parsed_submodules == (lys_module **)0x0) {
      ly_log(sub_mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_add_includedup");
      return;
    }
    pplVar4 = (plVar2->models).parsed_submodules;
    bVar1 = (plVar2->models).parsed_submodules_count;
    plVar5 = lys_main_module(sub_mod);
    pplVar4[(ulong)bVar1 - 1] = plVar5;
  }
  (plVar2->models).parsed_submodules_count = (plVar2->models).parsed_submodules_count + '\x01';
  pplVar4 = (lys_module **)
            ly_realloc((plVar2->models).parsed_submodules,
                       (ulong)(plVar2->models).parsed_submodules_count * 8);
  (plVar2->models).parsed_submodules = pplVar4;
  if ((plVar2->models).parsed_submodules == (lys_module **)0x0) {
    ly_log(sub_mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_add_includedup");
  }
  else {
    (plVar2->models).parsed_submodules[(ulong)(plVar2->models).parsed_submodules_count - 1] =
         (lys_module *)parsed_submod;
  }
  return;
}



int lyp_check_circmod(lys_module *module,char *value,int type)

{
  LY_ECODE ecode;
  int iVar1;
  int type_local;
  char *value_local;
  lys_module *module_local;
  uint8_t i;
  LY_ECODE code;
  ly_modules_list *models;
  
  if (type == 0) {
    ecode = LYE_CIRC_INCLUDES;
  }
  else {
    ecode = LYE_CIRC_IMPORTS;
  }
  if (value == module->name) {
    ly_vlog(module->ctx,ecode,LY_VLOG_NONE,(void *)0x0,value);
    iVar1 = -1;
  }
  else {
    for (i = '\0'; i < (module->ctx->models).parsing_sub_modules_count; i = i + '\x01') {
      if (value == (module->ctx->models).parsing_sub_modules[i]->name) {
        ly_vlog(module->ctx,ecode,LY_VLOG_NONE,(void *)0x0,value);
        return -1;
      }
    }
    iVar1 = 0;
  }
  return iVar1;
}



int lyp_check_circmod_add(lys_module *module)

{
  ly_ctx *plVar1;
  int iVar2;
  lys_module **pplVar3;
  lys_module *module_local;
  ly_modules_list *models;
  
  plVar1 = module->ctx;
  (plVar1->models).parsing_sub_modules_count = (plVar1->models).parsing_sub_modules_count + '\x01';
  pplVar3 = (lys_module **)
            ly_realloc((plVar1->models).parsing_sub_modules,
                       (ulong)(plVar1->models).parsing_sub_modules_count * 8);
  (plVar1->models).parsing_sub_modules = pplVar3;
  if ((plVar1->models).parsing_sub_modules == (lys_module **)0x0) {
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_check_circmod_add");
    iVar2 = -1;
  }
  else {
    (plVar1->models).parsing_sub_modules[(ulong)(plVar1->models).parsing_sub_modules_count - 1] =
         module;
    iVar2 = 0;
  }
  return iVar2;
}



void lyp_check_circmod_pop(ly_ctx *ctx)

{
  ly_ctx *ctx_local;
  
  if ((ctx->models).parsing_sub_modules_count == '\0') {
    ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
           ,0xab7);
  }
  else {
    (ctx->models).parsing_sub_modules_count = (ctx->models).parsing_sub_modules_count + 0xff;
    if ((ctx->models).parsing_sub_modules_count == '\0') {
      free((ctx->models).parsing_sub_modules);
      (ctx->models).parsing_sub_modules = (lys_module **)0x0;
    }
  }
  return;
}



int lyp_check_includedup(lys_module *mod,char *name,lys_include *inc,lys_submodule **sub)

{
  uint8_t uVar1;
  lys_module **pplVar2;
  int iVar3;
  lys_submodule **sub_local;
  lys_include *inc_local;
  char *name_local;
  lys_module *mod_local;
  uint8_t i;
  uint8_t parsed_sub_count;
  lys_module **parsed_sub;
  
  pplVar2 = (mod->ctx->models).parsed_submodules;
  uVar1 = (mod->ctx->models).parsed_submodules_count;
  if (sub == (lys_submodule **)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("sub",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                  ,0xace,"lyp_check_includedup");
  }
  for (i = '\0'; i < mod->inc_size; i = i + '\x01') {
    if (name == (mod->inc[i].submodule)->name) {
      ly_vlog(mod->ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,name,"include");
      ly_vlog(mod->ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "Submodule \"%s\" included twice in the same module \"%s\".",name,mod->name);
      return -1;
    }
  }
  if (uVar1 == '\0') {
LAB_0013f277:
    iVar3 = 0;
  }
  else {
    i = uVar1;
    if (((*pplVar2)->field_0x40 & 1) != 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("!parsed_sub[0]->type",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                    ,0xadb,"lyp_check_includedup");
    }
    do {
      i = i + 0xff;
      if ((pplVar2[i]->field_0x40 & 1) == 0) goto LAB_0013f277;
    } while (name != pplVar2[i]->name);
    if ((inc->rev[0] == '\0') ||
       ((pplVar2[i]->rev_size != '\0' &&
        (iVar3 = strcmp(pplVar2[i]->rev->date,inc->rev), iVar3 == 0)))) {
      *sub = (lys_submodule *)pplVar2[i];
      iVar3 = 1;
    }
    else {
      ly_vlog(mod->ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,name,"include");
      ly_vlog(mod->ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "Including multiple revisions of submodule \"%s\".",name);
      iVar3 = -1;
    }
  }
  return iVar3;
}



int lyp_check_include(lys_module *module,char *value,lys_include *inc,unres_schema *unres)

{
  int iVar1;
  lys_module *plVar2;
  LY_ERR *pLVar3;
  char *revision;
  unres_schema *unres_local;
  lys_include *inc_local;
  char *value_local;
  lys_module *module_local;
  int i;
  
  unres_local = unres;
  inc_local = inc;
  value_local = value;
  module_local = module;
  i = lyp_check_includedup(module,value,inc,&inc->submodule);
  if (i == -1) {
    iVar1 = -1;
  }
  else if (i == 1) {
    iVar1 = 0;
  }
  else {
    iVar1 = lyp_check_circmod(module_local,value_local,0);
    if (iVar1 == 0) {
      if (inc_local->rev[0] == '\0') {
        revision = (char *)0x0;
      }
      else {
        revision = inc_local->rev;
      }
      plVar2 = ly_ctx_load_sub_module
                         (module_local->ctx,module_local,value_local,revision,1,unres_local);
      inc_local->submodule = (lys_submodule *)plVar2;
      if (inc_local->submodule == (lys_submodule *)0x0) {
        pLVar3 = ly_errno_glob_address();
        if (*pLVar3 != LY_EVALID) {
          ly_vlog(module_local->ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value_local,"include");
        }
        ly_log(module_local->ctx,LY_LLERR,LY_EVALID,"Including \"%s\" module into \"%s\" failed.",
               value_local,module_local->name);
        iVar1 = -1;
      }
      else {
        if (((inc_local->rev[0] != '\0') && (inc_local->submodule->rev_size != '\0')) &&
           (iVar1 = strcmp(inc_local->rev,inc_local->submodule->rev->date), iVar1 != 0)) {
          ly_log(module_local->ctx,LY_LLERR,LY_EVALID,
                 "\"%s\" include of submodule \"%s\" in revision \"%s\" not found.",
                 module_local->name,value_local,inc_local->rev);
          unres_schema_free((lys_module *)inc_local->submodule,&unres_local,0);
          lys_sub_module_remove_devs_augs((lys_module *)inc_local->submodule);
          lys_submodule_module_data_free(inc_local->submodule);
          lys_submodule_free(inc_local->submodule,(_func_void_lys_node_ptr_void_ptr *)0x0);
          inc_local->submodule = (lys_submodule *)0x0;
          return -1;
        }
        lyp_add_includedup(module_local,inc_local->submodule);
        iVar1 = 0;
      }
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



int lyp_check_include_missing_recursive(lys_module *main_module,lys_submodule *sub)

{
  ly_ctx *ctx_00;
  int iVar1;
  lys_include *plVar2;
  lys_submodule *sub_local;
  lys_module *main_module_local;
  uint8_t i;
  uint8_t j;
  int ret;
  int tmp;
  ly_ctx *ctx;
  void *reallocated;
  
  ret = 0;
  ctx_00 = main_module->ctx;
  i = '\0';
  do {
    if (sub->inc_size <= i) {
      return ret;
    }
    j = '\0';
    while ((j < main_module->inc_size && (main_module->inc[j].submodule != sub->inc[i].submodule)))
    {
      j = j + '\x01';
    }
    if (j == main_module->inc_size) {
      if (((byte)main_module->field_0x40 >> 1 & 7) < 2) {
        ly_log(ctx_00,LY_LLWRN,LY_SUCCESS,
               "The main module \"%s\" misses include of the \"%s\" submodule used in another submodule \"%s\"."
               ,main_module->name,(sub->inc[i].submodule)->name,sub->name);
        ly_log(ctx_00,LY_LLWRN,LY_SUCCESS,
               "To avoid further issues, adding submodule \"%s\" into the main module \"%s\".",
               (sub->inc[i].submodule)->name,main_module->name);
      }
      else {
        ly_vlog(ctx_00,LYE_MISSSTMT,LY_VLOG_NONE,(void *)0x0,"include");
        ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                "The main module \"%s\" misses include of the \"%s\" submodule used in another submodule \"%s\"."
                ,main_module->name,(sub->inc[i].submodule)->name,sub->name);
        ret = 1;
      }
      main_module->inc_size = main_module->inc_size + '\x01';
      plVar2 = (lys_include *)realloc(main_module->inc,(ulong)main_module->inc_size * 0x30);
      if (plVar2 == (lys_include *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "lyp_check_include_missing_recursive");
        return 1;
      }
      main_module->inc = plVar2;
      memset(main_module->inc + ((ulong)main_module->inc_size - 1),0,0x30);
      memcpy(main_module->inc[(ulong)main_module->inc_size - 1].rev,sub->inc[i].rev,10);
      main_module->inc[(ulong)main_module->inc_size - 1].submodule = sub->inc[i].submodule;
    }
    iVar1 = lyp_check_include_missing_recursive(main_module,sub->inc[i].submodule);
    if ((ret == 0) && (iVar1 != 0)) {
      ret = 1;
    }
    i = i + '\x01';
  } while( true );
}



int lyp_check_include_missing(lys_module *main_module)

{
  int iVar1;
  lys_module *main_module_local;
  uint8_t i;
  int ret;
  
  ret = 0;
  for (i = '\0'; i < main_module->inc_size; i = i + '\x01') {
    iVar1 = lyp_check_include_missing_recursive(main_module,main_module->inc[i].submodule);
    if (iVar1 != 0) {
      ret = 1;
    }
  }
  return ret;
}



int lyp_check_import(lys_module *module,char *value,lys_import *imp)

{
  ly_ctx *ctx_00;
  int iVar1;
  lys_module *plVar2;
  char *revision;
  lys_import *imp_local;
  char *value_local;
  lys_module *module_local;
  int i;
  lys_module *dup;
  ly_ctx *ctx;
  
  dup = (lys_module *)0x0;
  ctx_00 = module->ctx;
  i = 0;
  do {
    if ((int)(uint)module->imp_size <= i) {
LAB_0013fb0d:
      iVar1 = lyp_check_circmod(module,value,1);
      if (iVar1 != 0) {
        return -1;
      }
      if (imp->rev[0] == '\0') {
        revision = (char *)0x0;
      }
      else {
        revision = imp->rev;
      }
      plVar2 = ly_ctx_load_sub_module
                         (module->ctx,(lys_module *)0x0,value,revision,
                          (module->ctx->models).flags & 1,(unres_schema *)0x0);
      imp->module = plVar2;
      if (imp->module != (lys_module *)0x0) {
        if (((imp->rev[0] != '\0') && (imp->module->rev_size != '\0')) &&
           (iVar1 = strcmp(imp->rev,imp->module->rev->date), iVar1 != 0)) {
          ly_log(ctx_00,LY_LLERR,LY_EVALID,
                 "\"%s\" import of module \"%s\" in revision \"%s\" not found.",module->name,value,
                 imp->rev);
          return -1;
        }
        if (dup != (lys_module *)0x0) {
          if (((dup != imp->module) ||
              ((dup->rev_size != imp->module->rev_size &&
               ((dup->rev_size == '\0' || (imp->module->rev_size != '\0')))))) ||
             ((dup->rev_size != '\0' &&
              (iVar1 = strcmp(dup->rev->date,imp->module->rev->date), iVar1 != 0)))) {
            ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"import");
            ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "Importing multiple revisions of module \"%s\".",value);
            return -1;
          }
          ly_log(ctx_00,LY_LLWRN,LY_SUCCESS,
                 "Module \"%s\" is imported by \"%s\" multiple times with different prefixes.",
                 dup->name,module->name);
        }
        return 0;
      }
      ly_log(ctx_00,LY_LLERR,LY_EVALID,"Importing \"%s\" module into \"%s\" failed.",value,
             module->name);
      return -1;
    }
    if ((module->imp[i].module != (lys_module *)0x0) && (value == (module->imp[i].module)->name)) {
      if ((imp->rev[0] != '\0') &&
         (((module->imp[i].module)->rev_size == '\0' ||
          (iVar1 = strcmp((module->imp[i].module)->rev->date,imp->rev), iVar1 != 0)))) {
        ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"import");
        ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                "Importing multiple revisions of module \"%s\".",value);
        return -1;
      }
      if (imp->rev[0] != '\0') {
        imp->module = module->imp[i].module;
        return 0;
      }
      dup = module->imp[i].module;
      goto LAB_0013fb0d;
    }
    i = i + 1;
  } while( true );
}



void lyp_sort_revisions(lys_module *module)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  lys_module *module_local;
  uint8_t i;
  uint8_t r;
  lys_revision rev;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  r = '\0';
  for (i = '\x01'; i < module->rev_size; i = i + '\x01') {
    iVar2 = strcmp(module->rev[i].date,module->rev[r].date);
    if (0 < iVar2) {
      r = i;
    }
  }
  if (r != '\0') {
    memcpy(&rev,module->rev,0x28);
    memcpy(module->rev,module->rev + r,0x28);
    memcpy(module->rev + r,&rev,0x28);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void lyp_ext_instance_rm(ly_ctx *ctx,lys_ext_instance ***ext,uint8_t *size,uint8_t index)

{
  uint8_t index_local;
  uint8_t *size_local;
  lys_ext_instance ***ext_local;
  ly_ctx *ctx_local;
  uint8_t i;
  
  lys_extension_instances_free
            (ctx,(*ext)[index]->ext,(uint)(*ext)[index]->ext_size,
             (_func_void_lys_node_ptr_void_ptr *)0x0);
  lydict_remove(ctx,(*ext)[index]->arg_value);
  free((*ext)[index]);
  for (i = index + '\x01'; i < *size; i = i + '\x01') {
    (*ext)[(ulong)i - 1] = (*ext)[i];
  }
  (*ext)[(ulong)*size - 1] = (lys_ext_instance *)0x0;
  *size = *size + 0xff;
  if (*size == '\0') {
    free(*ext);
  }
  return;
}



int lyp_rfn_apply_ext_(lys_refine *rfn,lys_node *target,LYEXT_SUBSTMT substmt,lys_ext *extdef)

{
  ly_ctx *ctx_00;
  lys_ext_instance *plVar1;
  lys_ext_instance **pplVar2;
  char *pcVar3;
  lys_ext *extdef_local;
  LYEXT_SUBSTMT substmt_local;
  lys_node *target_local;
  lys_refine *rfn_local;
  int m;
  int n;
  ly_ctx *ctx;
  lys_ext_instance *new;
  void *reallocated;
  
  ctx_00 = target->module->ctx;
  n = -1;
  m = -1;
  do {
    do {
      m = lys_ext_iter(rfn->ext,rfn->ext_size,(char)m + '\x01',substmt);
      if (m == -1) {
        while (n = lys_ext_iter(target->ext,target->ext_size,(char)n + '\x01',substmt), n != -1) {
          if ((substmt != LYEXT_SUBSTMT_SELF) || (extdef == target->ext[n]->def)) {
            lyp_ext_instance_rm(ctx_00,&target->ext,&target->ext_size,(uint8_t)n);
            n = n + -1;
          }
        }
        return 0;
      }
    } while ((substmt == LYEXT_SUBSTMT_SELF) && (extdef != rfn->ext[m]->def));
    while (n = lys_ext_iter(target->ext,target->ext_size,(char)n + '\x01',substmt), n != -1) {
      if ((substmt != LYEXT_SUBSTMT_SELF) || (extdef == target->ext[n]->def)) break;
    }
    if (n == -1) {
      plVar1 = (lys_ext_instance *)malloc(0x40);
      if (plVar1 == (lys_ext_instance *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_rfn_apply_ext_");
        return 1;
      }
      pplVar2 = (lys_ext_instance **)realloc(target->ext,(long)(int)(target->ext_size + 1) * 8);
      if (pplVar2 == (lys_ext_instance **)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_rfn_apply_ext_");
        free(plVar1);
        return 1;
      }
      target->ext = pplVar2;
      target->ext_size = target->ext_size + '\x01';
      n = target->ext_size - 1;
      target->ext[n] = plVar1;
      target->ext[n]->parent = target;
      target->ext[n]->parent_type = '\x01';
      target->ext[n]->flags = 0;
      target->ext[n]->insubstmt = (uint8_t)substmt;
      target->ext[n]->priv = (void *)0x0;
      target->ext[n]->nodetype = LYS_EXT;
      target->ext[n]->module = target->module;
    }
    else {
      lys_extension_instances_free
                (ctx_00,target->ext[n]->ext,(uint)target->ext[n]->ext_size,
                 (_func_void_lys_node_ptr_void_ptr *)0x0);
      lydict_remove(ctx_00,target->ext[n]->arg_value);
    }
    target->ext[n]->def = rfn->ext[m]->def;
    plVar1 = target->ext[n];
    pcVar3 = lydict_insert(ctx_00,rfn->ext[m]->arg_value,0);
    plVar1->arg_value = pcVar3;
    target->ext[n]->ext_size = rfn->ext[m]->ext_size;
    lys_ext_dup(ctx_00,target->module,rfn->ext[m]->ext,rfn->ext[m]->ext_size,target,LYEXT_PAR_NODE,
                &target->ext[n]->ext,0,(unres_schema *)0x0);
    target->ext[n]->insubstmt_index = rfn->ext[m]->insubstmt_index;
  } while( true );
}



int lyp_rfn_apply_ext(lys_module *module)

{
  int iVar1;
  lys_ext_instance **pplVar2;
  lys_node *plVar3;
  lys_node *plVar4;
  long in_FS_OFFSET;
  lys_module *module_local;
  int k;
  int a;
  int i;
  lys_node *target;
  lys_node *root;
  lys_node *nextroot;
  lys_node *next;
  lys_node *node;
  lys_node_uses *uses;
  lys_refine *rfn;
  ly_set *extset;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  a = 0;
  root = module->data;
  do {
    if (root == (lys_node *)0x0) {
      iVar1 = 0;
LAB_00140afb:
      if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return iVar1;
    }
    nextroot = root->next;
    node = root;
    while (next = node, node != (lys_node *)0x0) {
      if (node->nodetype == LYS_USES) {
        uses = (lys_node_uses *)node;
        for (i = 0; i < (int)(uint)uses->refine_size; i = i + 1) {
          if (uses->refine[i].ext_size != '\0') {
            rfn = uses->refine + i;
            target = (lys_node *)0x0;
            resolve_descendant_schema_nodeid(rfn->target_name,uses->child,0xc0ff,0,&target);
            if (target == (lys_node *)0x0) {
              ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                     "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                     ,0xc67);
              iVar1 = 1;
              goto LAB_00140afb;
            }
            extset = ly_set_new();
            k = -1;
            while (k = lys_ext_iter(rfn->ext,rfn->ext_size,(char)k + '\x01',LYEXT_SUBSTMT_SELF),
                  k != -1) {
              ly_set_add(extset,rfn->ext[k]->def,0);
            }
            for (k = 0; (uint)k < extset->number; k = k + 1) {
              iVar1 = lyp_rfn_apply_ext_(rfn,target,LYEXT_SUBSTMT_SELF,(lys_ext *)(extset->set).s[k]
                                        );
              if (iVar1 != 0) {
                ly_set_free(extset);
                iVar1 = 1;
                goto LAB_00140afb;
              }
            }
            ly_set_free(extset);
            if ((rfn->dsc != (char *)0x0) &&
               (iVar1 = lyp_rfn_apply_ext_(rfn,target,LYEXT_SUBSTMT_DESCRIPTION,(lys_ext *)0x0),
               iVar1 != 0)) {
              iVar1 = 1;
              goto LAB_00140afb;
            }
            if ((rfn->ref != (char *)0x0) &&
               (iVar1 = lyp_rfn_apply_ext_(rfn,target,LYEXT_SUBSTMT_REFERENCE,(lys_ext *)0x0),
               iVar1 != 0)) {
              iVar1 = 1;
              goto LAB_00140afb;
            }
            if ((((rfn->flags & 3) != 0) && ((target->flags & 3) != 0)) &&
               (iVar1 = lyp_rfn_apply_ext_(rfn,target,LYEXT_SUBSTMT_CONFIG,(lys_ext *)0x0),
               iVar1 != 0)) {
              iVar1 = 1;
              goto LAB_00140afb;
            }
            if ((rfn->dflt_size != '\0') &&
               (iVar1 = lyp_rfn_apply_ext_(rfn,target,LYEXT_SUBSTMT_DEFAULT,(lys_ext *)0x0),
               iVar1 != 0)) {
              iVar1 = 1;
              goto LAB_00140afb;
            }
            if (((rfn->flags & 0xc0) != 0) &&
               (iVar1 = lyp_rfn_apply_ext_(rfn,target,LYEXT_SUBSTMT_MANDATORY,(lys_ext *)0x0),
               iVar1 != 0)) {
              iVar1 = 1;
              goto LAB_00140afb;
            }
            if ((((target->nodetype & LYS_CONTAINER) != LYS_UNKNOWN) &&
                ((rfn->mod).presence != (char *)0x0)) &&
               (iVar1 = lyp_rfn_apply_ext_(rfn,target,LYEXT_SUBSTMT_PRESENCE,(lys_ext *)0x0),
               iVar1 != 0)) {
              iVar1 = 1;
              goto LAB_00140afb;
            }
            if (((rfn->flags & 0x10) != 0) &&
               (iVar1 = lyp_rfn_apply_ext_(rfn,target,LYEXT_SUBSTMT_MIN,(lys_ext *)0x0), iVar1 != 0)
               ) {
              iVar1 = 1;
              goto LAB_00140afb;
            }
            if (((rfn->flags & 8) != 0) &&
               (iVar1 = lyp_rfn_apply_ext_(rfn,target,LYEXT_SUBSTMT_MAX,(lys_ext *)0x0), iVar1 != 0)
               ) {
              iVar1 = 1;
              goto LAB_00140afb;
            }
            plVar3 = target;
            if (target->ext_size != '\0') {
              pplVar2 = (lys_ext_instance **)realloc(target->ext,(ulong)target->ext_size * 8);
              plVar3->ext = pplVar2;
            }
          }
        }
      }
      if ((node->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
        next = node->child;
      }
      else {
        next = (lys_node *)0x0;
      }
      if (next == (lys_node *)0x0) {
        if (node == root) break;
        next = node->next;
      }
      while (next == (lys_node *)0x0) {
        if (node->parent->nodetype == LYS_AUGMENT) {
          node = node->parent->prev;
        }
        else {
          node = node->parent;
        }
        plVar3 = lys_parent(node);
        plVar4 = lys_parent(root);
        if (plVar3 == plVar4) break;
        next = node->next;
      }
      node = next;
    }
    if ((nextroot == (lys_node *)0x0) && (a < (int)(uint)module->augment_size)) {
      nextroot = module->augment[a].child;
      a = a + 1;
    }
    root = nextroot;
  } while( true );
}



int lyp_mand_check_ext(lys_ext_instance_complex *ext,char *ext_name)

{
  ly_ctx *ctx_00;
  char *pcVar1;
  ushort *puVar2;
  long *plVar3;
  char *ext_name_local;
  lys_ext_instance_complex *ext_local;
  int i;
  ly_ctx *ctx;
  void *p;
  
  ctx_00 = ext->module->ctx;
  i = 0;
  do {
    if (ext->substmt[i].stmt == LY_STMT_UNKNOWN) {
      return 0;
    }
    if ((ext->substmt[i].cardinality == LY_STMT_CARD_OPT) ||
       (ext->substmt[i].cardinality == LY_STMT_CARD_ANY)) goto LAB_00140f85;
    if ((ext->substmt[i].cardinality == LY_STMT_CARD_SOME) || (false)) {
switchD_00140c0e_caseD_16:
      plVar3 = (long *)lys_ext_complex_get_substmt(ext->substmt[i].stmt,ext,(lyext_substmt **)0x0);
      if (*plVar3 == 0) {
        ly_vlog(ctx_00,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,
                *(undefined8 *)(ly_stmt_str + (long)ext->substmt[i].stmt * 8),ext_name);
        return 1;
      }
    }
    else {
      switch(ext->substmt[i].stmt) {
      case LY_STMT_MODIFIER:
      case LY_STMT_REQINSTANCE:
      case LY_STMT_DIGITS:
        pcVar1 = (char *)lys_ext_complex_get_substmt(ext->substmt[i].stmt,ext,(lyext_substmt **)0x0)
        ;
        if (*pcVar1 == '\0') {
          ly_vlog(ctx_00,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,
                  *(undefined8 *)(ly_stmt_str + (long)ext->substmt[i].stmt * 8),ext_name);
          return 1;
        }
        break;
      default:
        goto switchD_00140c0e_caseD_16;
      case LY_STMT_CONFIG:
        puVar2 = (ushort *)
                 lys_ext_complex_get_substmt(ext->substmt[i].stmt,ext,(lyext_substmt **)0x0);
        if ((*puVar2 & 3) == 0) {
          ly_vlog(ctx_00,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,
                  *(undefined8 *)(ly_stmt_str + (long)ext->substmt[i].stmt * 8),ext_name);
          return 1;
        }
        break;
      case LY_STMT_MANDATORY:
        puVar2 = (ushort *)
                 lys_ext_complex_get_substmt(ext->substmt[i].stmt,ext,(lyext_substmt **)0x0);
        if ((*puVar2 & 0xc0) == 0) {
          ly_vlog(ctx_00,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,
                  *(undefined8 *)(ly_stmt_str + (long)ext->substmt[i].stmt * 8),ext_name);
          return 1;
        }
        break;
      case LY_STMT_ORDEREDBY:
        break;
      case LY_STMT_STATUS:
        puVar2 = (ushort *)
                 lys_ext_complex_get_substmt(ext->substmt[i].stmt,ext,(lyext_substmt **)0x0);
        if ((*puVar2 & 0x38) == 0) {
          ly_vlog(ctx_00,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,
                  *(undefined8 *)(ly_stmt_str + (long)ext->substmt[i].stmt * 8),ext_name);
          return 1;
        }
      }
    }
LAB_00140f85:
    i = i + 1;
  } while( true );
}



int lyp_deviate_del_ext(lys_node *target,lys_ext_instance *ext)

{
  char *__ptr;
  lys_ext_instance *ext_local;
  lys_node *target_local;
  int n;
  int found;
  char *path;
  
  n = -1;
  found = 0;
  while (n = lys_ext_iter(target->ext,target->ext_size,(char)n + '\x01',(uint)ext->insubstmt),
        n != -1) {
    if ((target->ext[n]->def == ext->def) &&
       ((ext->def->argument == (char *)0x0 || (target->ext[n]->arg_value == ext->arg_value)))) {
      found = found + 1;
      lyp_ext_instance_rm(target->module->ctx,&target->ext,&target->ext_size,(uint8_t)n);
      n = n + -1;
    }
  }
  if (found == 0) {
    __ptr = lys_path(target,1);
    ly_log(target->module->ctx,LY_LLERR,LY_EVALID,
           "Extension deviation: extension \"%s\" to delete not found in \"%s\".",ext->def->name,
           __ptr);
    free(__ptr);
  }
  return (int)(found == 0);
}



int lyp_deviate_apply_ext(lys_deviate *dev,lys_node *target,LYEXT_SUBSTMT substmt,lys_ext *extdef)

{
  ly_ctx *ctx_00;
  lys_ext_instance *plVar1;
  lys_ext_instance **pplVar2;
  char *pcVar3;
  lys_ext *extdef_local;
  LYEXT_SUBSTMT substmt_local;
  lys_node *target_local;
  lys_deviate *dev_local;
  int m;
  int n;
  lys_ext_instance *new;
  ly_ctx *ctx;
  void *reallocated;
  
  ctx_00 = target->module->ctx;
  n = -1;
  m = -1;
  do {
    do {
      m = lys_ext_iter(dev->ext,dev->ext_size,(char)m + '\x01',substmt);
      if (m == -1) {
        while (n = lys_ext_iter(target->ext,target->ext_size,(char)n + '\x01',substmt), n != -1) {
          if ((substmt != LYEXT_SUBSTMT_SELF) ||
             ((extdef == target->ext[n]->def &&
              ((dev->mod != LY_DEVIATE_ADD || ((target->ext[n]->flags & 1) != 0)))))) {
            lyp_ext_instance_rm(ctx_00,&target->ext,&target->ext_size,(uint8_t)n);
            n = n + -1;
          }
        }
        return 0;
      }
    } while ((substmt == LYEXT_SUBSTMT_SELF) && (extdef != dev->ext[m]->def));
    if ((substmt == LYEXT_SUBSTMT_SELF) && (dev->mod == LY_DEVIATE_ADD)) {
      do {
        n = lys_ext_iter(target->ext,target->ext_size,(char)n + '\x01',LYEXT_SUBSTMT_SELF);
        if (n == -1) break;
      } while ((extdef != target->ext[n]->def) || ((target->ext[n]->flags & 1) == 0));
    }
    else {
      do {
        n = lys_ext_iter(target->ext,target->ext_size,(char)n + '\x01',substmt);
        if ((n == -1) || (substmt != LYEXT_SUBSTMT_SELF)) break;
      } while (extdef != target->ext[n]->def);
    }
    if (n == -1) {
      new = (lys_ext_instance *)malloc(0x40);
      if (new == (lys_ext_instance *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_deviate_apply_ext");
        return 1;
      }
      pplVar2 = (lys_ext_instance **)realloc(target->ext,(long)(int)(target->ext_size + 1) * 8);
      if (pplVar2 == (lys_ext_instance **)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_deviate_apply_ext");
        free(new);
        return 1;
      }
      target->ext = pplVar2;
      target->ext_size = target->ext_size + '\x01';
      n = target->ext_size - 1;
    }
    else {
      lys_extension_instances_free
                (ctx_00,target->ext[n]->ext,(uint)target->ext[n]->ext_size,
                 (_func_void_lys_node_ptr_void_ptr *)0x0);
      lydict_remove(ctx_00,target->ext[n]->arg_value);
      free(target->ext[n]);
      new = (lys_ext_instance *)malloc(0x40);
      if (new == (lys_ext_instance *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_deviate_apply_ext");
        return 1;
      }
    }
    target->ext[n] = new;
    target->ext[n]->def = dev->ext[m]->def;
    plVar1 = target->ext[n];
    pcVar3 = lydict_insert(ctx_00,dev->ext[m]->arg_value,0);
    plVar1->arg_value = pcVar3;
    target->ext[n]->flags = 0;
    target->ext[n]->parent = target;
    target->ext[n]->parent_type = '\x01';
    target->ext[n]->insubstmt = (uint8_t)substmt;
    target->ext[n]->insubstmt_index = dev->ext[m]->insubstmt_index;
    target->ext[n]->ext_size = dev->ext[m]->ext_size;
    lys_ext_dup(ctx_00,target->module,dev->ext[m]->ext,dev->ext[m]->ext_size,target,LYEXT_PAR_NODE,
                &target->ext[n]->ext,1,(unres_schema *)0x0);
    target->ext[n]->nodetype = LYS_EXT;
    target->ext[n]->module = target->module;
    target->ext[n]->priv = (void *)0x0;
  } while( true );
}



int lyp_deviation_apply_ext(lys_module *module)

{
  int iVar1;
  long in_FS_OFFSET;
  lys_module *module_local;
  int i;
  int j;
  int k;
  ly_set *extset;
  lys_node *target;
  lys_deviate *dev;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  i = 0;
  do {
    if ((int)(uint)module->deviation_size <= i) {
      iVar1 = 0;
LAB_00141c19:
      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
        return iVar1;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    target = (lys_node *)0x0;
    extset = (ly_set *)0x0;
    iVar1 = resolve_schema_nodeid
                      (module->deviation[i].target_name,(lys_node *)0x0,module,&extset,0,0);
    if (iVar1 == -1) {
      iVar1 = 1;
      goto LAB_00141c19;
    }
    if (extset == (ly_set *)0x0) {
      ly_set_free((ly_set *)0x0);
    }
    else {
      target = *(extset->set).s;
      ly_set_free(extset);
      for (j = 0; j < (int)(uint)module->deviation[i].deviate_size; j = j + 1) {
        dev = module->deviation[i].deviate + j;
        if (dev->ext_size != '\0') {
          if (dev->mod == LY_DEVIATE_DEL) {
            k = -1;
            while (k = lys_ext_iter(dev->ext,dev->ext_size,(char)k + '\x01',LYEXT_SUBSTMT_SELF),
                  k != -1) {
              iVar1 = lyp_deviate_del_ext(target,dev->ext[k]);
              if (iVar1 != 0) {
                iVar1 = 1;
                goto LAB_00141c19;
              }
            }
          }
          else {
            extset = ly_set_new();
            k = -1;
            while (k = lys_ext_iter(dev->ext,dev->ext_size,(char)k + '\x01',LYEXT_SUBSTMT_SELF),
                  k != -1) {
              ly_set_add(extset,dev->ext[k]->def,0);
            }
            for (k = 0; (uint)k < extset->number; k = k + 1) {
              iVar1 = lyp_deviate_apply_ext
                                (dev,target,LYEXT_SUBSTMT_SELF,(lys_ext *)(extset->set).s[k]);
              if (iVar1 != 0) {
                ly_set_free(extset);
                iVar1 = 1;
                goto LAB_00141c19;
              }
            }
            ly_set_free(extset);
            if ((dev->unique_size != '\0') &&
               (iVar1 = lyp_deviate_apply_ext(dev,target,LYEXT_SUBSTMT_UNIQUE,(lys_ext *)0x0),
               iVar1 != 0)) {
              iVar1 = 1;
              goto LAB_00141c19;
            }
            if ((dev->units != (char *)0x0) &&
               (iVar1 = lyp_deviate_apply_ext(dev,target,LYEXT_SUBSTMT_UNITS,(lys_ext *)0x0),
               iVar1 != 0)) {
              iVar1 = 1;
              goto LAB_00141c19;
            }
            if ((dev->dflt_size != '\0') &&
               (iVar1 = lyp_deviate_apply_ext(dev,target,LYEXT_SUBSTMT_DEFAULT,(lys_ext *)0x0),
               iVar1 != 0)) {
              iVar1 = 1;
              goto LAB_00141c19;
            }
            if (((dev->flags & 3) != 0) &&
               (iVar1 = lyp_deviate_apply_ext(dev,target,LYEXT_SUBSTMT_CONFIG,(lys_ext *)0x0),
               iVar1 != 0)) {
              iVar1 = 1;
              goto LAB_00141c19;
            }
            if (((dev->flags & 0xc0) != 0) &&
               (iVar1 = lyp_deviate_apply_ext(dev,target,LYEXT_SUBSTMT_MANDATORY,(lys_ext *)0x0),
               iVar1 != 0)) {
              iVar1 = 1;
              goto LAB_00141c19;
            }
            if ((dev->min_set != '\0') &&
               (iVar1 = lyp_deviate_apply_ext(dev,target,LYEXT_SUBSTMT_MIN,(lys_ext *)0x0),
               iVar1 != 0)) {
              iVar1 = 1;
              goto LAB_00141c19;
            }
            if ((dev->min_set != '\0') &&
               (iVar1 = lyp_deviate_apply_ext(dev,target,LYEXT_SUBSTMT_MAX,(lys_ext *)0x0),
               iVar1 != 0)) {
              iVar1 = 1;
              goto LAB_00141c19;
            }
          }
        }
      }
    }
    i = i + 1;
  } while( true );
}



int lyp_ctx_check_module(lys_module *module)

{
  ly_ctx *ctx_00;
  int iVar1;
  char *pcVar2;
  lys_module *module_local;
  int i;
  int match_i;
  int to_implement;
  char *last_rev;
  ly_ctx *ctx;
  
  match_i = -1;
  last_rev = (char *)0x0;
  if (module == (lys_module *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("module",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                  ,0xdf3,"lyp_ctx_check_module");
  }
  to_implement = 0;
  ctx_00 = module->ctx;
  for (i = 0; i < (int)(uint)module->rev_size; i = i + 1) {
    if ((last_rev == (char *)0x0) || (iVar1 = strcmp(last_rev,module->rev[i].date), iVar1 < 0)) {
      last_rev = module->rev[i].date;
    }
  }
  i = 0;
  do {
    if ((ctx_00->models).used <= i) {
      if (to_implement == 0) {
        iVar1 = 0;
      }
      else {
        iVar1 = lys_set_implemented((ctx_00->models).list[match_i]);
        if (iVar1 == 0) {
          iVar1 = 1;
        }
        else {
          iVar1 = -1;
        }
      }
      return iVar1;
    }
    iVar1 = strcmp((ctx_00->models).list[i]->name,module->name);
    if (iVar1 == 0) {
      if (to_implement == 0) {
        if (((ctx_00->models).list[i]->rev_size == '\0') && (module->rev_size != '\0')) {
          ly_log(ctx_00,LY_LLERR,LY_EINVAL,"Module \"%s\" without revision already in context.",
                 module->name);
          return -1;
        }
        if (((ctx_00->models).list[i]->rev_size != '\0') && (module->rev_size == '\0')) {
          ly_log(ctx_00,LY_LLERR,LY_EINVAL,"Module \"%s\" with revision \"%s\" already in context.",
                 module->name,(ctx_00->models).list[i]->rev);
          return -1;
        }
        if (((module->rev_size == '\0') && ((ctx_00->models).list[i]->rev_size == '\0')) ||
           (iVar1 = strcmp((ctx_00->models).list[i]->rev->date,last_rev), iVar1 == 0)) {
          pcVar2 = last_rev;
          if (last_rev == (char *)0x0) {
            pcVar2 = "<latest>";
          }
          ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,"Module \"%s@%s\" already in context.",
                 module->name,pcVar2);
          if (((ctx_00->models).list[i]->field_0x40 & 0x40) != 0) {
            lys_set_enabled((ctx_00->models).list[i]);
          }
          to_implement = (int)((byte)module->field_0x40 >> 7);
          match_i = i;
          if ((to_implement == 0) || (((ctx_00->models).list[i]->field_0x40 & 0x80) != 0)) {
            return 1;
          }
          i = -1;
        }
        else if (((module->field_0x40 & 0x80) != 0) &&
                (((ctx_00->models).list[i]->field_0x40 & 0x80) != 0)) {
          if (last_rev == (char *)0x0) {
            last_rev = "<latest>";
          }
          ly_log(ctx_00,LY_LLERR,LY_EINVAL,
                 "Module \"%s@%s\" in another revision \"%s\" already implemented.",module->name,
                 last_rev,(ctx_00->models).list[i]->rev);
          return -1;
        }
      }
      else if (i != match_i) {
        if (last_rev == (char *)0x0) {
          last_rev = "<latest>";
        }
        ly_log(ctx_00,LY_LLERR,LY_EINVAL,
               "Module \"%s@%s\" in another revision \"%s\" already implemented.",module->name,
               last_rev,(ctx_00->models).list[i]->rev);
        return -1;
      }
    }
    else {
      iVar1 = strcmp((ctx_00->models).list[i]->ns,module->ns);
      if (iVar1 == 0) {
        ly_log(ctx_00,LY_LLERR,LY_EINVAL,
               "Two different modules (\"%s\" and \"%s\") have the same namespace \"%s\".",
               (ctx_00->models).list[i]->name,module->name,module->ns);
        return -1;
      }
    }
    i = i + 1;
  } while( true );
}



int lyp_ctx_add_module(lys_module *module)

{
  int iVar1;
  lys_module **pplVar2;
  lys_module *module_local;
  int i;
  int j;
  lys_module **newlist;
  
  iVar1 = lyp_ctx_check_module(module);
  if (iVar1 != 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("!lyp_ctx_check_module(module)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                  ,0xe41,"lyp_ctx_add_module");
  }
  for (i = 0; i < (int)(uint)module->augment_size; i = i + 1) {
    if (module->augment[i].target == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("module->augment[i].target",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                    ,0xe47,"lyp_ctx_add_module");
    }
  }
  for (i = 0; i < (int)(uint)module->inc_size; i = i + 1) {
    for (j = 0; j < (int)(uint)(module->inc[i].submodule)->augment_size; j = j + 1) {
      if ((module->inc[i].submodule)->augment[j].target == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("module->inc[i].submodule->augment[j].target",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                      ,0xe4b,"lyp_ctx_add_module");
      }
    }
  }
  if ((module->ctx->models).used == (module->ctx->models).size) {
    pplVar2 = (lys_module **)
              realloc((module->ctx->models).list,(long)((module->ctx->models).size * 2) * 8);
    if (pplVar2 == (lys_module **)0x0) {
      ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_ctx_add_module");
      return -1;
    }
    for (i = (module->ctx->models).size; i < (module->ctx->models).size * 2; i = i + 1) {
      pplVar2[i] = (lys_module *)0x0;
    }
    (module->ctx->models).size = (module->ctx->models).size * 2;
    (module->ctx->models).list = pplVar2;
  }
  pplVar2 = (module->ctx->models).list;
  iVar1 = (module->ctx->models).used;
  (module->ctx->models).used = iVar1 + 1;
  pplVar2[iVar1] = module;
  (module->ctx->models).module_set_id = (module->ctx->models).module_set_id + 1;
  return 0;
}



uint pututf8(ly_ctx *ctx,char *dst,int32_t value)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  int32_t value_local;
  char *dst_local;
  ly_ctx *ctx_local;
  
  bVar3 = (byte)value;
  if (value < 0x80) {
    if ((((0x1f < value) || (value == 9)) || (value == 10)) || (value == 0xd)) {
      *dst = bVar3;
      return 1;
    }
  }
  else {
    bVar1 = (byte)(value >> 6);
    if (value < 0x800) {
      *dst = bVar1 | 0xc0;
      dst[1] = bVar3 & 0x3f | 0x80;
      return 2;
    }
    bVar2 = (byte)(value >> 0xc);
    if (value < 0xfffe) {
      if (((value & 0xf800U) != 0xd800) && ((value < 0xfdd0 || (0xfdef < value)))) {
        *dst = bVar2 | 0xe0;
        dst[1] = bVar1 & 0x3f | 0x80;
        dst[2] = bVar3 & 0x3f | 0x80;
        return 3;
      }
    }
    else if ((value < 0x10fffe) && ((value & 0xffeU) != 0xffe)) {
      *dst = (byte)(value >> 0x12) | 0xf0;
      dst[1] = bVar2 & 0x3f | 0x80;
      dst[2] = bVar1 & 0x3f | 0x80;
      dst[3] = bVar3 & 0x3f | 0x80;
      return 4;
    }
  }
  ly_vlog(ctx,LYE_XML_INCHAR,LY_VLOG_NONE,(void *)0x0,0);
  ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid UTF-8 value 0x%08x",(ulong)(uint)value);
  return 0;
}



uint copyutf8(ly_ctx *ctx,char *dst,char *src)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  char *src_local;
  char *dst_local;
  ly_ctx *ctx_local;
  uint32_t value;
  
  if (*src < '\0') {
    if ((*src & 0x20U) == 0) {
      *dst = *src;
      dst[1] = src[1];
      uVar1 = 2;
    }
    else if ((*src & 0x10U) == 0) {
      uVar1 = ((int)*src & 0xfU) << 0xc;
      uVar3 = ((int)src[1] & 0x3fU) << 6;
      uVar2 = (int)src[2] & 0x3fU | uVar3 | uVar1;
      if (((uVar3 & 0xf800 | uVar1) == 0xd800) ||
         (((0xfdcf < uVar2 && (uVar2 < 0xfdf0)) || ((uVar2 & 0xffe) == 0xffe)))) {
        ly_vlog(ctx,LYE_XML_INCHAR,LY_VLOG_NONE,(void *)0x0,src);
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid UTF-8 value 0x%08x",(ulong)uVar2);
        uVar1 = 0;
      }
      else {
        *dst = *src;
        dst[1] = src[1];
        dst[2] = src[2];
        uVar1 = 3;
      }
    }
    else if ((*src & 8U) == 0) {
      uVar1 = (int)src[3] & 0x3fU |
              ((int)*src & 7U) << 0x12 | ((int)src[1] & 0x3fU) << 0xc | ((int)src[2] & 0x3fU) << 6;
      if ((uVar1 & 0xffe) == 0xffe) {
        ly_vlog(ctx,LYE_XML_INCHAR,LY_VLOG_NONE,(void *)0x0,src);
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid UTF-8 value 0x%08x",(ulong)uVar1);
        uVar1 = 0;
      }
      else {
        *dst = *src;
        dst[1] = src[1];
        dst[2] = src[2];
        dst[3] = src[3];
        uVar1 = 4;
      }
    }
    else {
      ly_vlog(ctx,LYE_XML_INCHAR,LY_VLOG_NONE,(void *)0x0,src);
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid UTF-8 leading byte 0x%02x",
              (ulong)(uint)(int)*src);
      uVar1 = 0;
    }
  }
  else if (((*src < ' ') && (*src != '\t')) && ((*src != '\n' && (*src != '\r')))) {
    ly_vlog(ctx,LYE_XML_INCHAR,LY_VLOG_NONE,(void *)0x0,src);
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid UTF-8 value 0x%02x",
            (ulong)(uint)(int)*src);
    uVar1 = 0;
  }
  else {
    *dst = *src;
    uVar1 = 1;
  }
  return uVar1;
}



lys_module *
lyp_get_module(lys_module *module,char *prefix,int pref_len,char *name,int name_len,int in_data)

{
  int iVar1;
  size_t sVar2;
  char *name_00;
  int in_data_local;
  char *name_local;
  int name_len_local;
  int pref_len_local;
  char *prefix_local;
  lys_module *module_local;
  int i;
  lys_module *main_module;
  char *str;
  
  if ((prefix != (char *)0x0) && (name != (char *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("!prefix || !name",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                  ,0xeec,"lyp_get_module");
  }
  pref_len_local = pref_len;
  if ((prefix != (char *)0x0) && (pref_len == 0)) {
    sVar2 = strlen(prefix);
    pref_len_local = (int)sVar2;
  }
  name_len_local = name_len;
  if ((name != (char *)0x0) && (name_len == 0)) {
    sVar2 = strlen(name);
    name_len_local = (int)sVar2;
  }
  main_module = lys_main_module(module);
  if ((((prefix != (char *)0x0) &&
       ((((module->field_0x40 & 1) != 0 ||
         (iVar1 = strncmp(main_module->prefix,prefix,(long)pref_len_local), iVar1 != 0)) ||
        (main_module->prefix[pref_len_local] != '\0')))) &&
      ((((module->field_0x40 & 1) == 0 ||
        (iVar1 = strncmp(module->prefix,prefix,(long)pref_len_local), iVar1 != 0)) ||
       (module->prefix[pref_len_local] != '\0')))) ||
     ((name != (char *)0x0 &&
      ((iVar1 = strncmp(main_module->name,name,(long)name_len_local), iVar1 != 0 ||
       (main_module->name[name_len_local] != '\0')))))) {
    for (i = 0; i < (int)(uint)module->imp_size; i = i + 1) {
      if (((prefix == (char *)0x0) ||
          ((iVar1 = strncmp(module->imp[i].prefix,prefix,(long)pref_len_local), iVar1 == 0 &&
           (module->imp[i].prefix[pref_len_local] == '\0')))) &&
         ((name == (char *)0x0 ||
          ((iVar1 = strncmp((module->imp[i].module)->name,name,(long)name_len_local), iVar1 == 0 &&
           ((module->imp[i].module)->name[name_len_local] == '\0')))))) {
        return module->imp[i].module;
      }
    }
    if (name == (char *)0x0) {
      main_module = (lys_module *)0x0;
    }
    else {
      name_00 = strndup(name,(long)name_len_local);
      if (name_00 == (char *)0x0) {
        ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_get_module");
        main_module = (lys_module *)0x0;
      }
      else {
        main_module = ly_ctx_get_module(module->ctx,name_00,(char *)0x0,0);
        if (((main_module == (lys_module *)0x0) && (in_data != 0)) &&
           (module->ctx->data_clb != (ly_module_data_clb)0x0)) {
          main_module = (*module->ctx->data_clb)
                                  (module->ctx,name_00,(char *)0x0,0,module->ctx->data_clb_data);
        }
        free(name_00);
      }
    }
  }
  return main_module;
}



lys_module * lyp_get_import_module_ns(lys_module *module,char *ns)

{
  int iVar1;
  char *ns_local;
  lys_module *module_local;
  int i;
  lys_module *mod;
  
  if ((module != (lys_module *)0x0) && (ns != (char *)0x0)) {
    if ((module->field_0x40 & 1) == 0) {
      iVar1 = ly_strequal_(module->ns,ns);
      if (iVar1 != 0) {
        return module;
      }
    }
    else {
      iVar1 = ly_strequal_((char *)module->data[1].parent,ns);
      if (iVar1 != 0) {
        return (lys_module *)module->data;
      }
    }
    i = 0;
    while( true ) {
      if ((int)(uint)module->imp_size <= i) {
        return (lys_module *)0x0;
      }
      iVar1 = ly_strequal_((module->imp[i].module)->ns,ns);
      if (iVar1 != 0) break;
      i = i + 1;
    }
    return module->imp[i].module;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("module && ns",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser.c"
                ,0xf21,"lyp_get_import_module_ns");
}



char * lyp_get_yang_data_template_name(lyd_node *node)

{
  int iVar1;
  lyd_node *node_local;
  lys_node *snode;
  
  for (snode = lys_parent(node->schema);
      (snode != (lys_node *)0x0 && ((snode->nodetype & 0x1042) != LYS_UNKNOWN));
      snode = lys_parent(snode)) {
  }
  if (((snode != (lys_node *)0x0) && (snode->nodetype == LYS_EXT)) &&
     (iVar1 = strcmp(*(char **)snode->name,"yang-data"), iVar1 == 0)) {
    return snode->ref;
  }
  return (char *)0x0;
}



lys_node *
lyp_get_yang_data_template(lys_module *module,char *yang_data_name,int yang_data_name_len)

{
  lys_submodule *plVar1;
  int iVar2;
  int yang_data_name_len_local;
  char *yang_data_name_local;
  lys_module *module_local;
  int i;
  int j;
  lys_node *ret;
  lys_submodule *submodule;
  
  ret = (lys_node *)0x0;
  i = 0;
  do {
    if ((int)(uint)module->ext_size <= i) {
LAB_00143050:
      j = 0;
      do {
        if ((ret != (lys_node *)0x0) || ((int)(uint)module->inc_size <= j)) {
          return ret;
        }
        plVar1 = module->inc[j].submodule;
        for (i = 0; i < (int)(uint)plVar1->ext_size; i = i + 1) {
          iVar2 = strcmp(plVar1->ext[i]->def->name,"yang-data");
          if (iVar2 == 0) {
            iVar2 = strncmp(plVar1->ext[i]->arg_value,yang_data_name,(long)yang_data_name_len);
            if ((iVar2 == 0) && (plVar1->ext[i]->arg_value[yang_data_name_len] == '\0')) {
              ret = (lys_node *)plVar1->ext[i];
              break;
            }
          }
        }
        j = j + 1;
      } while( true );
    }
    iVar2 = strcmp(module->ext[i]->def->name,"yang-data");
    if (iVar2 == 0) {
      iVar2 = strncmp(module->ext[i]->arg_value,yang_data_name,(long)yang_data_name_len);
      if ((iVar2 == 0) && (module->ext[i]->arg_value[yang_data_name_len] == '\0')) {
        ret = (lys_node *)module->ext[i];
        goto LAB_00143050;
      }
    }
    i = i + 1;
  } while( true );
}



int lyp_yin_fill_ext(void *parent,LYEXT_PAR parent_type,LYEXT_SUBSTMT substmt,uint8_t substmt_index,
                    lys_module *module,lyxml_elem *yin,lys_ext_instance ***ext,uint8_t ext_index,
                    unres_schema *unres)

{
  int iVar1;
  lys_node *snode;
  lyxml_elem *yin_local;
  lys_module *module_local;
  uint8_t ext_index_local;
  uint8_t substmt_index_local;
  LYEXT_SUBSTMT substmt_local;
  LYEXT_PAR parent_type_local;
  void *parent_local;
  unres_ext *info;
  
  snode = (lys_node *)malloc(0x30);
  if (snode == (lys_node *)0x0) {
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_yin_fill_ext");
    iVar1 = 1;
  }
  else {
    lyxml_unlink(module->ctx,yin);
    snode->name = &yin->flags;
    *(undefined4 *)&snode->dsc = 2;
    snode->ref = (char *)parent;
    *(lys_module **)&snode->flags = module;
    *(LYEXT_PAR *)&snode->ext = parent_type;
    *(LYEXT_SUBSTMT *)((long)&snode->ext + 4) = substmt;
    *(uint8_t *)&snode->iffeature = substmt_index;
    *(uint8_t *)((long)&snode->iffeature + 1) = ext_index;
    iVar1 = unres_schema_add_node(module,unres,ext,UNRES_EXT,snode);
    if (iVar1 == -1) {
      iVar1 = 1;
    }
    else {
      iVar1 = 0;
    }
  }
  return iVar1;
}



char * read_yin_subnode(ly_ctx *ctx,lyxml_elem *node,char *name)

{
  int iVar1;
  size_t sVar2;
  char *pcVar3;
  char *name_local;
  lyxml_elem *node_local;
  ly_ctx *ctx_local;
  int len;
  
  if (((node->child != (lyxml_elem *)0x0) && (node->child->name != (char *)0x0)) &&
     (iVar1 = strcmp(node->child->name,name), iVar1 == 0)) {
    if (node->child->content != (char *)0x0) {
      sVar2 = strlen(node->child->content);
      pcVar3 = lydict_insert(ctx,node->child->content,(long)(int)sVar2);
      return pcVar3;
    }
    pcVar3 = lydict_insert(ctx,"",0);
    return pcVar3;
  }
  ly_log(ctx,LY_LLERR,LY_EVALID,"Expected \"%s\" element in \"%s\" element.",name,node->name);
  ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,name,node->name);
  return (char *)0x0;
}



int lyp_yin_parse_subnode_ext
              (lys_module *mod,void *elem,LYEXT_PAR elem_type,lyxml_elem *yin,LYEXT_SUBSTMT type,
              uint8_t i,unres_schema *unres)

{
  int iVar1;
  lys_ext_instance **pplVar2;
  uint8_t i_local;
  lyxml_elem *yin_local;
  LYEXT_SUBSTMT type_local;
  LYEXT_PAR elem_type_local;
  void *elem_local;
  lys_module *mod_local;
  int r;
  lyxml_elem *next;
  lyxml_elem *child;
  lys_ext_instance ***ext;
  uint8_t *ext_size;
  char *statement;
  void *reallocated;
  
  switch(elem_type) {
  case LYEXT_PAR_MODULE:
    ext_size = (uint8_t *)((long)elem + 0x50);
    ext = (lys_ext_instance ***)((long)elem + 0xa0);
    if ((*(byte *)((long)elem + 0x40) & 1) == 0) {
      statement = "module";
    }
    else {
      statement = "submodule";
    }
    break;
  case LYEXT_PAR_NODE:
    ext_size = (uint8_t *)((long)elem + 0x1a);
    ext = (lys_ext_instance ***)((long)elem + 0x20);
    statement = strnodetype(*(LYS_NODE *)((long)elem + 0x38));
    break;
  case LYEXT_PAR_TPDF:
    ext_size = (uint8_t *)((long)elem + 0x1a);
    ext = (lys_ext_instance ***)((long)elem + 0x20);
    statement = " typedef";
    break;
  case LYEXT_PAR_TYPE:
    ext_size = (uint8_t *)((long)elem + 5);
    ext = (lys_ext_instance ***)((long)elem + 8);
    statement = "type";
    break;
  case LYEXT_PAR_TYPE_BIT:
    ext_size = (uint8_t *)((long)elem + 0x1a);
    ext = (lys_ext_instance ***)((long)elem + 0x20);
    statement = "bit";
    break;
  case LYEXT_PAR_TYPE_ENUM:
    ext_size = (uint8_t *)((long)elem + 0x1a);
    ext = (lys_ext_instance ***)((long)elem + 0x20);
    statement = "enum";
    break;
  case LYEXT_PAR_FEATURE:
    ext_size = (uint8_t *)((long)elem + 0x1a);
    ext = (lys_ext_instance ***)((long)elem + 0x20);
    statement = "feature";
    break;
  case LYEXT_PAR_RESTR:
    ext_size = (uint8_t *)((long)elem + 0x30);
    ext = (lys_ext_instance ***)((long)elem + 0x28);
    statement = "YANG restriction";
    break;
  case LYEXT_PAR_WHEN:
    ext_size = (uint8_t *)((long)elem + 0x20);
    ext = (lys_ext_instance ***)((long)elem + 0x18);
    statement = "when";
    break;
  case LYEXT_PAR_IDENT:
    ext_size = (uint8_t *)((long)elem + 0x1a);
    ext = (lys_ext_instance ***)((long)elem + 0x20);
    statement = "identity";
    break;
  case LYEXT_PAR_EXT:
    ext_size = (uint8_t *)((long)elem + 0x1a);
    ext = (lys_ext_instance ***)((long)elem + 0x20);
    statement = "extension";
    break;
  case LYEXT_PAR_EXTINST:
    ext_size = (uint8_t *)((long)elem + 0x1a);
    ext = (lys_ext_instance ***)((long)elem + 0x20);
    statement = "extension instance";
    break;
  case LYEXT_PAR_REFINE:
    ext_size = (uint8_t *)((long)elem + 0x1a);
    ext = (lys_ext_instance ***)((long)elem + 0x20);
    statement = "refine";
    break;
  case LYEXT_PAR_DEVIATION:
    ext_size = (uint8_t *)((long)elem + 0x21);
    ext = (lys_ext_instance ***)((long)elem + 0x30);
    statement = "deviation";
    break;
  case LYEXT_PAR_DEVIATE:
    ext_size = (uint8_t *)((long)elem + 6);
    ext = (lys_ext_instance ***)((long)elem + 0x40);
    statement = "deviate";
    break;
  case LYEXT_PAR_IMPORT:
    ext_size = (uint8_t *)((long)elem + 0x1b);
    ext = (lys_ext_instance ***)((long)elem + 0x20);
    statement = "import";
    break;
  case LYEXT_PAR_INCLUDE:
    ext_size = (uint8_t *)((long)elem + 0x13);
    ext = (lys_ext_instance ***)((long)elem + 0x18);
    statement = "include";
    break;
  case LYEXT_PAR_REVISION:
    ext_size = (uint8_t *)((long)elem + 0xb);
    ext = (lys_ext_instance ***)((long)elem + 0x10);
    statement = "revision";
    break;
  default:
    ly_log(mod->ctx,LY_LLERR,LY_EINT,"parent type %d",(ulong)elem_type);
    return 1;
  }
  if (type == LYEXT_SUBSTMT_SELF) {
    next = (lyxml_elem *)0x0;
    child = yin;
    while( true ) {
      if (*ext_size == 0xff) {
        ly_log(mod->ctx,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",0xff,
               "extension",statement);
        return 1;
      }
      pplVar2 = (lys_ext_instance **)realloc(*ext,(long)(int)(*ext_size + 1) * 8);
      if (pplVar2 == (lys_ext_instance **)0x0) break;
      *ext = pplVar2;
      (*ext)[*ext_size] = (lys_ext_instance *)0x0;
      iVar1 = lyp_yin_fill_ext(elem,elem_type,type,i,mod,child,ext,*ext_size,unres);
      *ext_size = *ext_size + '\x01';
      if (iVar1 != 0) {
        return 1;
      }
      do {
        child = next;
LAB_00143919:
        if (child == (lyxml_elem *)0x0) {
          return 0;
        }
        next = child->next;
        if (child->ns == (lyxml_ns *)0x0) {
          ly_vlog(mod->ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                  "Extension instance \"%s\" is missing namespace.",child->name);
          return 1;
        }
        iVar1 = strcmp(child->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
      } while (iVar1 == 0);
    }
    ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyp_yin_parse_subnode_ext")
    ;
    return 1;
  }
  child = yin->child;
  goto LAB_00143919;
}



int fill_yin_iffeature(lys_node *parent,int parent_is_feature,lyxml_elem *yin,lys_iffeature *iffeat,
                      unres_schema *unres)

{
  ly_ctx *ctx_00;
  lyxml_elem *plVar1;
  int iVar2;
  char *pcVar3;
  lys_module *plVar4;
  char *pcVar5;
  lys_ext_instance **pplVar6;
  unres_schema *unres_local;
  lys_iffeature *iffeat_local;
  lyxml_elem *yin_local;
  int parent_is_feature_local;
  lys_node *parent_local;
  int c_ext;
  int r;
  lyxml_elem *node;
  lyxml_elem *next;
  ly_ctx *ctx;
  char *value;
  
  c_ext = 0;
  ctx_00 = parent->module->ctx;
  pcVar3 = lyxml_get_attr(yin,"name",(char *)0x0);
  if (pcVar3 == (char *)0x0) {
    ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,yin->name);
  }
  else {
    plVar4 = lys_node_module(parent);
    if (((plVar4->field_0x40 & 0xe) == 4) ||
       ((*pcVar3 != '(' && (pcVar5 = strchr(pcVar3,0x20), pcVar5 == (char *)0x0)))) {
      pcVar3 = transform_iffeat_schema2json(parent->module,pcVar3);
      if (pcVar3 == (char *)0x0) {
        return 1;
      }
      iVar2 = resolve_iffeature_compile(iffeat,pcVar3,parent,parent_is_feature,unres);
      lydict_remove(ctx_00,pcVar3);
      if (iVar2 != 0) {
        return 1;
      }
      node = yin->child;
      while( true ) {
        while( true ) {
          if (node == (lyxml_elem *)0x0) {
            if (c_ext != 0) {
              pplVar6 = (lys_ext_instance **)calloc((long)c_ext,8);
              iffeat->ext = pplVar6;
              if (iffeat->ext == (lys_ext_instance **)0x0) {
                ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                       "fill_yin_iffeature");
                return 1;
              }
              node = yin->child;
              while (node != (lyxml_elem *)0x0) {
                plVar1 = node->next;
                iVar2 = lyp_yin_fill_ext(iffeat,LYEXT_PAR_IDENT,LYEXT_SUBSTMT_SELF,'\0',
                                         parent->module,node,&iffeat->ext,iffeat->ext_size,unres);
                iffeat->ext_size = iffeat->ext_size + '\x01';
                node = plVar1;
                if (iVar2 != 0) {
                  return 1;
                }
              }
            }
            return 0;
          }
          plVar1 = node->next;
          if (node->ns != (lyxml_ns *)0x0) break;
          lyxml_free(ctx_00,node);
          node = plVar1;
        }
        iVar2 = strcmp(node->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar2 == 0) {
          ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,node->name,"if-feature");
          return 1;
        }
        if (c_ext == 0xff) break;
        c_ext = c_ext + 1;
        node = plVar1;
      }
      ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",0xff,
             "extensions","if-feature");
      return 1;
    }
    ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,pcVar3,"if-feature");
  }
  return 1;
}



int fill_yin_identity(lys_module *module,lyxml_elem *yin,lys_ident *ident,unres_schema *unres)

{
  ly_ctx *ctx_00;
  lyxml_elem *plVar1;
  int iVar2;
  char *pcVar3;
  lys_ident **pplVar4;
  lys_iffeature *plVar5;
  lys_ext_instance **pplVar6;
  unres_schema *unres_local;
  lys_ident *ident_local;
  lyxml_elem *yin_local;
  lys_module *module_local;
  int c_ftrs;
  int c_base;
  int c_ext;
  int rc;
  lyxml_elem *node;
  lyxml_elem *next;
  ly_ctx *ctx;
  char *value;
  void *reallocated;
  
  ctx_00 = module->ctx;
  c_ftrs = 0;
  c_base = 0;
  c_ext = 0;
  pcVar3 = lyxml_get_attr(yin,"name",(char *)0x0);
  if (pcVar3 == (char *)0x0) {
    ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,yin->name);
  }
  else {
    ident->name = pcVar3;
    iVar2 = read_yin_common(module,(lys_node *)0x0,ident,LYEXT_PAR_IDENT,yin,0x11,unres);
    if ((iVar2 == 0) && (iVar2 = dup_identities_check(ident->name,module), iVar2 == 0)) {
      for (node = yin->child; node != (lyxml_elem *)0x0; node = node->next) {
        iVar2 = strcmp(node->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar2 == 0) {
          iVar2 = strcmp(node->name,"base");
          if (iVar2 == 0) {
            if ((c_base != 0) && (((byte)module->field_0x40 >> 1 & 7) < 2)) {
              ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,&DAT_00213c6f,"identity");
              return 1;
            }
            if (c_base == 0xff) {
              ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                     0xff,"bases","identity");
              return 1;
            }
            iVar2 = lyp_yin_parse_subnode_ext
                              (module,ident,LYEXT_PAR_IDENT,node,LYEXT_SUBSTMT_BASE,(uint8_t)c_base,
                               unres);
            if (iVar2 != 0) {
              return 1;
            }
            c_base = c_base + 1;
          }
          else {
            if ((((byte)module->field_0x40 >> 1 & 7) < 2) ||
               (iVar2 = strcmp(node->name,"if-feature"), iVar2 != 0)) {
              ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,node->name,"identity");
              return 1;
            }
            if (c_ftrs == 0xff) {
              ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                     0xff,"if-features","identity");
              return 1;
            }
            c_ftrs = c_ftrs + 1;
          }
        }
        else {
          if (c_ext == 0xff) {
            ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                   0xff,"extensions","identity");
            return 1;
          }
          c_ext = c_ext + 1;
        }
      }
      if (c_base != 0) {
        ident->base_size = '\0';
        pplVar4 = (lys_ident **)calloc((long)c_base,8);
        ident->base = pplVar4;
        if (ident->base == (lys_ident **)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_identity");
          return 1;
        }
      }
      if (c_ftrs != 0) {
        plVar5 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
        ident->iffeature = plVar5;
        if (ident->iffeature == (lys_iffeature *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_identity");
          return 1;
        }
      }
      if (c_ext != 0) {
        pplVar6 = (lys_ext_instance **)
                  realloc(ident->ext,(long)(int)(c_ext + (uint)ident->ext_size) * 8);
        if (pplVar6 == (lys_ext_instance **)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_identity");
          return 1;
        }
        ident->ext = pplVar6;
        memset(ident->ext + ident->ext_size,0,(long)c_ext * 8);
      }
      plVar1 = yin->child;
      do {
        do {
          while( true ) {
            while( true ) {
              node = plVar1;
              if (node == (lyxml_elem *)0x0) {
                return 0;
              }
              plVar1 = node->next;
              iVar2 = strcmp(node->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
              if (iVar2 == 0) break;
              iVar2 = lyp_yin_fill_ext(ident,LYEXT_PAR_IDENT,LYEXT_SUBSTMT_SELF,'\0',module,node,
                                       &ident->ext,ident->ext_size,unres);
              ident->ext_size = ident->ext_size + '\x01';
              if (iVar2 != 0) {
                return 1;
              }
            }
            iVar2 = strcmp(node->name,"base");
            if (iVar2 != 0) break;
            pcVar3 = lyxml_get_attr(node,"name",(char *)0x0);
            if (pcVar3 == (char *)0x0) {
              ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,node->name);
              return 1;
            }
            pcVar3 = transform_schema2json(module,pcVar3);
            if (pcVar3 == (char *)0x0) {
              return 1;
            }
            iVar2 = unres_schema_add_str(module,unres,ident,UNRES_IDENT,pcVar3);
            if (iVar2 == -1) {
              lydict_remove(ctx_00,pcVar3);
              return 1;
            }
            lydict_remove(ctx_00,pcVar3);
          }
          iVar2 = strcmp(node->name,"if-feature");
        } while (iVar2 != 0);
        iVar2 = fill_yin_iffeature((lys_node *)ident,0,node,ident->iffeature + ident->iffeature_size
                                   ,unres);
        ident->iffeature_size = ident->iffeature_size + '\x01';
      } while (iVar2 == 0);
    }
  }
  return 1;
}



int read_restr_substmt(lys_module *module,lys_restr *restr,lyxml_elem *yin,unres_schema *unres)

{
  ly_ctx *ctx_00;
  lyxml_elem *plVar1;
  int iVar2;
  char *pcVar3;
  unres_schema *unres_local;
  lyxml_elem *yin_local;
  lys_restr *restr_local;
  lys_module *module_local;
  lyxml_elem *child;
  lyxml_elem *next;
  ly_ctx *ctx;
  char *value;
  
  ctx_00 = module->ctx;
  plVar1 = yin->child;
  do {
    while( true ) {
      while( true ) {
        while( true ) {
          while( true ) {
            do {
              child = plVar1;
              if (child == (lyxml_elem *)0x0) {
                return 0;
              }
              plVar1 = child->next;
            } while (child->ns == (lyxml_ns *)0x0);
            iVar2 = strcmp(child->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
            if (iVar2 == 0) break;
            iVar2 = lyp_yin_parse_subnode_ext
                              (module,restr,LYEXT_PAR_RESTR,child,LYEXT_SUBSTMT_SELF,'\0',unres);
            if (iVar2 != 0) {
              return 1;
            }
          }
          iVar2 = strcmp(child->name,"description");
          if (iVar2 != 0) break;
          if (restr->dsc != (char *)0x0) {
            ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
            return 1;
          }
          iVar2 = lyp_yin_parse_subnode_ext
                            (module,restr,LYEXT_PAR_RESTR,child,LYEXT_SUBSTMT_DESCRIPTION,'\0',unres
                            );
          if (iVar2 != 0) {
            return 1;
          }
          pcVar3 = read_yin_subnode(ctx_00,child,"text");
          restr->dsc = pcVar3;
          if (restr->dsc == (char *)0x0) {
            return 1;
          }
        }
        iVar2 = strcmp(child->name,"reference");
        if (iVar2 != 0) break;
        if (restr->ref != (char *)0x0) {
          ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
          return 1;
        }
        iVar2 = lyp_yin_parse_subnode_ext
                          (module,restr,LYEXT_PAR_RESTR,child,LYEXT_SUBSTMT_REFERENCE,'\0',unres);
        if (iVar2 != 0) {
          return 1;
        }
        pcVar3 = read_yin_subnode(ctx_00,child,"text");
        restr->ref = pcVar3;
        if (restr->ref == (char *)0x0) {
          return 1;
        }
      }
      iVar2 = strcmp(child->name,"error-app-tag");
      if (iVar2 != 0) break;
      if (restr->eapptag != (char *)0x0) {
        ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
        return 1;
      }
      iVar2 = lyp_yin_parse_subnode_ext
                        (module,restr,LYEXT_PAR_RESTR,child,LYEXT_SUBSTMT_ERRTAG,'\0',unres);
      if (iVar2 != 0) {
        return 1;
      }
      pcVar3 = lyxml_get_attr(child,"value",(char *)0x0);
      if (pcVar3 == (char *)0x0) {
        ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",child->name);
        return 1;
      }
      pcVar3 = lydict_insert(ctx_00,pcVar3,0);
      restr->eapptag = pcVar3;
    }
    iVar2 = strcmp(child->name,"error-message");
    if (iVar2 != 0) {
      ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
      return 1;
    }
    if (restr->emsg != (char *)0x0) {
      ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
      return 1;
    }
    iVar2 = lyp_yin_parse_subnode_ext
                      (module,restr,LYEXT_PAR_RESTR,child,LYEXT_SUBSTMT_ERRMSG,'\0',unres);
    if (iVar2 != 0) {
      return 1;
    }
    pcVar3 = read_yin_subnode(ctx_00,child,"value");
    restr->emsg = pcVar3;
  } while (restr->emsg != (char *)0x0);
  return 1;
}


/*
Unable to decompile 'fill_yin_type'
Cause: Exception while decompiling 001448e6: process: timeout

*/


int fill_yin_typedef(lys_module *module,lys_node *parent,lyxml_elem *yin,lys_tpdf *tpdf,
                    unres_schema *unres)

{
  ly_ctx *ctx_00;
  lyxml_elem *plVar1;
  bool bVar2;
  int iVar3;
  size_t sVar4;
  char *pcVar5;
  lys_ext_instance **pplVar6;
  unres_schema *unres_local;
  lys_tpdf *tpdf_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int has_type;
  int c_ext;
  int i;
  int rc;
  char *value;
  lyxml_elem *node;
  lyxml_elem *next;
  ly_ctx *ctx;
  void *reallocated;
  
  ctx_00 = module->ctx;
  bVar2 = false;
  c_ext = 0;
  value = lyxml_get_attr(yin,"name",(char *)0x0);
  if (value == (char *)0x0) {
    ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,yin->name);
  }
  else {
    iVar3 = lyp_check_identifier(ctx_00,value,LY_IDENT_TYPE,module,parent);
    if (iVar3 == 0) {
      sVar4 = strlen(value);
      pcVar5 = lydict_insert(ctx_00,value,sVar4);
      tpdf->name = pcVar5;
      iVar3 = read_yin_common(module,(lys_node *)0x0,tpdf,LYEXT_PAR_TPDF,yin,0x10,unres);
      if (iVar3 == 0) {
        node = yin->child;
        while (node != (lyxml_elem *)0x0) {
          plVar1 = node->next;
          iVar3 = strcmp(node->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
          if (iVar3 == 0) {
            iVar3 = strcmp(node->name,"type");
            if (iVar3 == 0) {
              if (bVar2) {
                ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node->name,yin->name);
                return 1;
              }
              (tpdf->type).der = (lys_tpdf *)node;
              (tpdf->type).parent = tpdf;
              iVar3 = unres_schema_add_node(module,unres,&tpdf->type,UNRES_TYPE_DER_TPDF,parent);
              if (iVar3 == -1) {
                return 1;
              }
              bVar2 = true;
              node = plVar1;
            }
            else {
              iVar3 = strcmp(node->name,"default");
              if (iVar3 == 0) {
                if (tpdf->dflt != (char *)0x0) {
                  ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node->name,yin->name);
                  return 1;
                }
                value = lyxml_get_attr(node,"value",(char *)0x0);
                if (value == (char *)0x0) {
                  ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",node->name);
                  return 1;
                }
                sVar4 = strlen(value);
                pcVar5 = lydict_insert(ctx_00,value,sVar4);
                tpdf->dflt = pcVar5;
                iVar3 = lyp_yin_parse_subnode_ext
                                  (module,tpdf,LYEXT_PAR_TPDF,node,LYEXT_SUBSTMT_DEFAULT,'\0',unres)
                ;
              }
              else {
                iVar3 = strcmp(node->name,"units");
                if (iVar3 != 0) {
                  ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,value);
                  return 1;
                }
                if (tpdf->units != (char *)0x0) {
                  ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node->name,yin->name);
                  return 1;
                }
                value = lyxml_get_attr(node,"name",(char *)0x0);
                if (value == (char *)0x0) {
                  ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,node->name);
                  return 1;
                }
                sVar4 = strlen(value);
                pcVar5 = lydict_insert(ctx_00,value,sVar4);
                tpdf->units = pcVar5;
                iVar3 = lyp_yin_parse_subnode_ext
                                  (module,tpdf,LYEXT_PAR_TPDF,node,LYEXT_SUBSTMT_UNITS,'\0',unres);
              }
              if (iVar3 != 0) {
                return 1;
              }
              lyxml_free(ctx_00,node);
              node = plVar1;
            }
          }
          else {
            if (c_ext == 0xff) {
              ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                     0xff,"extensions","typedef");
              return 1;
            }
            c_ext = c_ext + 1;
            node = plVar1;
          }
        }
        if (bVar2) {
          if ((((ctx_00->models).flags & 2U) != 0) ||
             (iVar3 = unres_schema_add_node
                                (module,unres,&tpdf->type,UNRES_TYPEDEF_DFLT,(lys_node *)&tpdf->dflt
                                ), iVar3 != -1)) {
            if (c_ext == 0) {
LAB_0014a07f:
              i = 0;
              while( true ) {
                if ((int)(uint)tpdf->ext_size <= i) {
                  return 0;
                }
                if ((tpdf->ext[i]->flags & 8) != 0) break;
                i = i + 1;
              }
              tpdf->flags = tpdf->flags | 0x2000;
              return 0;
            }
            pplVar6 = (lys_ext_instance **)
                      realloc(tpdf->ext,(long)(int)(c_ext + (uint)tpdf->ext_size) * 8);
            if (pplVar6 == (lys_ext_instance **)0x0) {
              ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_typedef");
            }
            else {
              tpdf->ext = pplVar6;
              memset(tpdf->ext + tpdf->ext_size,0,(long)c_ext * 8);
              node = yin->child;
              do {
                if (node == (lyxml_elem *)0x0) goto LAB_0014a07f;
                plVar1 = node->next;
                iVar3 = lyp_yin_fill_ext(tpdf,LYEXT_PAR_TYPE,LYEXT_SUBSTMT_SELF,'\0',module,node,
                                         &tpdf->ext,tpdf->ext_size,unres);
                tpdf->ext_size = tpdf->ext_size + '\x01';
                node = plVar1;
              } while (iVar3 == 0);
            }
          }
        }
        else {
          ly_vlog(ctx_00,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,&DAT_00213b02,yin->name);
        }
      }
    }
  }
  return 1;
}



int fill_yin_extension(lys_module *module,lyxml_elem *yin,lys_ext *ext,unres_schema *unres)

{
  ly_ctx *ctx_00;
  lyxml_elem *plVar1;
  lyxml_elem *plVar2;
  int iVar3;
  char *pcVar4;
  size_t sVar5;
  lys_ext_instance **pplVar6;
  lyext_plugin *plVar7;
  lys_revision *revision;
  unres_schema *unres_local;
  lys_ext *ext_local;
  lyxml_elem *yin_local;
  lys_module *module_local;
  int c_ext;
  int rc;
  lyxml_elem *child;
  lyxml_elem *node;
  lyxml_elem *next;
  lyxml_elem *next2;
  ly_ctx *ctx;
  char *value;
  void *reallocated;
  
  ctx_00 = module->ctx;
  c_ext = 0;
  pcVar4 = lyxml_get_attr(yin,"name",(char *)0x0);
  if (pcVar4 == (char *)0x0) {
    ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,yin->name);
  }
  else {
    iVar3 = lyp_check_identifier(ctx_00,pcVar4,LY_IDENT_EXTENSION,module,(lys_node *)0x0);
    if (iVar3 == 0) {
      sVar5 = strlen(pcVar4);
      pcVar4 = lydict_insert(ctx_00,pcVar4,sVar5);
      ext->name = pcVar4;
      iVar3 = read_yin_common(module,(lys_node *)0x0,ext,LYEXT_PAR_EXT,yin,0x10,unres);
      if (iVar3 == 0) {
        node = yin->child;
        while (node != (lyxml_elem *)0x0) {
          plVar2 = node->next;
          iVar3 = strcmp(node->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
          if (iVar3 == 0) {
            iVar3 = strcmp(node->name,"argument");
            if (iVar3 != 0) {
              ly_vlog(ctx_00,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,node->name,node->name);
              return 1;
            }
            pcVar4 = lyxml_get_attr(node,"name",(char *)0x0);
            if (pcVar4 == (char *)0x0) {
              ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,node->name);
              return 1;
            }
            sVar5 = strlen(pcVar4);
            pcVar4 = lydict_insert(ctx_00,pcVar4,sVar5);
            ext->argument = pcVar4;
            iVar3 = lyp_yin_parse_subnode_ext
                              (module,ext,LYEXT_PAR_EXT,node,LYEXT_SUBSTMT_ARGUMENT,'\0',unres);
            if (iVar3 != 0) {
              return 1;
            }
            plVar1 = node->child;
            while (child = plVar1, child != (lyxml_elem *)0x0) {
              plVar1 = child->next;
              if ((child->ns == node->ns) && (iVar3 = strcmp(child->name,"yin-element"), iVar3 == 0)
                 ) {
                pcVar4 = lyxml_get_attr(child,"value",(char *)0x0);
                if (pcVar4 == (char *)0x0) {
                  ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",child->name);
                  return 1;
                }
                iVar3 = ly_strequal_(pcVar4,"true");
                if (iVar3 != 0) {
                  ext->flags = ext->flags | 1;
                }
                iVar3 = lyp_yin_parse_subnode_ext
                                  (module,ext,LYEXT_PAR_EXT,child,LYEXT_SUBSTMT_YINELEM,'\0',unres);
                if (iVar3 != 0) {
                  return 1;
                }
              }
              else if (child->ns != (lyxml_ns *)0x0) {
                ly_vlog(ctx_00,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,child->name,child->name);
                return 1;
              }
            }
            lyxml_free(ctx_00,node);
            node = plVar2;
          }
          else {
            if (c_ext == 0xff) {
              ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                     0xff,"extensions","extension");
              return 1;
            }
            c_ext = c_ext + 1;
            node = plVar2;
          }
        }
        if (c_ext == 0) {
LAB_0014a6c3:
          if (ext->module->rev == (lys_revision *)0x0) {
            revision = (lys_revision *)0x0;
          }
          else {
            revision = ext->module->rev;
          }
          plVar7 = ext_get_plugin(ext->name,ext->module->name,revision->date);
          ext->plugin = plVar7;
          return 0;
        }
        pplVar6 = (lys_ext_instance **)
                  realloc(ext->ext,(long)(int)(c_ext + (uint)ext->ext_size) * 8);
        if (pplVar6 == (lys_ext_instance **)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_extension");
        }
        else {
          ext->ext = pplVar6;
          memset(ext->ext + ext->ext_size,0,(long)c_ext * 8);
          node = yin->child;
          do {
            if (node == (lyxml_elem *)0x0) goto LAB_0014a6c3;
            plVar2 = node->next;
            iVar3 = lyp_yin_fill_ext(ext,LYEXT_PAR_EXT,LYEXT_SUBSTMT_SELF,'\0',module,node,&ext->ext
                                     ,ext->ext_size,unres);
            ext->ext_size = ext->ext_size + '\x01';
            node = plVar2;
          } while (iVar3 == 0);
        }
      }
    }
  }
  return 1;
}



int fill_yin_feature(lys_module *module,lyxml_elem *yin,lys_feature *f,unres_schema *unres)

{
  ly_ctx *ctx_00;
  lyxml_elem *plVar1;
  int iVar2;
  char *pcVar3;
  size_t len;
  lys_iffeature *plVar4;
  lys_ext_instance **pplVar5;
  unres_schema *unres_local;
  lys_feature *f_local;
  lyxml_elem *yin_local;
  lys_module *module_local;
  int c_ftrs;
  int c_ext;
  int ret;
  lyxml_elem *child;
  lyxml_elem *next;
  ly_ctx *ctx;
  char *value;
  void *reallocated;
  
  ctx_00 = module->ctx;
  c_ftrs = 0;
  c_ext = 0;
  pcVar3 = lyxml_get_attr(yin,"name",(char *)0x0);
  if (pcVar3 == (char *)0x0) {
    ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,yin->name);
  }
  else {
    iVar2 = lyp_check_identifier(ctx_00,pcVar3,LY_IDENT_FEATURE,module,(lys_node *)0x0);
    if (iVar2 == 0) {
      len = strlen(pcVar3);
      pcVar3 = lydict_insert(ctx_00,pcVar3,len);
      f->name = pcVar3;
      f->module = module;
      iVar2 = read_yin_common(module,(lys_node *)0x0,f,LYEXT_PAR_FEATURE,yin,0,unres);
      if (iVar2 == 0) {
        for (child = yin->child; child != (lyxml_elem *)0x0; child = child->next) {
          iVar2 = strcmp(child->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
          if (iVar2 == 0) {
            iVar2 = strcmp(child->name,"if-feature");
            if (iVar2 != 0) {
              ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
              return 1;
            }
            if (c_ftrs == 0xff) {
              ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                     0xff,"if-feature","feature");
              return 1;
            }
            c_ftrs = c_ftrs + 1;
          }
          else {
            if (c_ext == 0xff) {
              ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                     0xff,"extensions","feature");
              return 1;
            }
            c_ext = c_ext + 1;
          }
        }
        if (c_ftrs != 0) {
          plVar4 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
          f->iffeature = plVar4;
          if (f->iffeature == (lys_iffeature *)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_feature");
            return 1;
          }
        }
        if (c_ext != 0) {
          pplVar5 = (lys_ext_instance **)realloc(f->ext,(long)(int)(c_ext + (uint)f->ext_size) * 8);
          if (pplVar5 == (lys_ext_instance **)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_feature");
            return 1;
          }
          f->ext = pplVar5;
          memset(f->ext + f->ext_size,0,(long)c_ext * 8);
        }
        child = yin->child;
        do {
          while( true ) {
            if (child == (lyxml_elem *)0x0) {
              if ((f->iffeature_size != '\0') &&
                 (iVar2 = unres_schema_add_node(module,unres,f,UNRES_FEATURE,(lys_node *)0x0),
                 iVar2 == -1)) {
                return 1;
              }
              return 0;
            }
            plVar1 = child->next;
            iVar2 = strcmp(child->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
            if (iVar2 == 0) break;
            iVar2 = lyp_yin_fill_ext(f,LYEXT_PAR_FEATURE,LYEXT_SUBSTMT_SELF,'\0',module,child,
                                     &f->ext,f->ext_size,unres);
            f->ext_size = f->ext_size + '\x01';
            child = plVar1;
            if (iVar2 != 0) {
              return 1;
            }
          }
          iVar2 = fill_yin_iffeature((lys_node *)f,1,child,f->iffeature + f->iffeature_size,unres);
          f->iffeature_size = f->iffeature_size + '\x01';
          child = plVar1;
        } while (iVar2 == 0);
      }
    }
  }
  return 1;
}



int fill_yin_must(lys_module *module,lyxml_elem *yin,lys_restr *must,unres_schema *unres)

{
  char *pcVar1;
  unres_schema *unres_local;
  lys_restr *must_local;
  lyxml_elem *yin_local;
  lys_module *module_local;
  int ret;
  char *value;
  
  ret = 1;
  must->expr = (char *)0x0;
  pcVar1 = lyxml_get_attr(yin,"condition",(char *)0x0);
  if (pcVar1 == (char *)0x0) {
    ly_vlog(module->ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"condition",yin->name);
  }
  else {
    pcVar1 = transform_schema2json(module,pcVar1);
    must->expr = pcVar1;
    if (must->expr != (char *)0x0) {
      ret = read_restr_substmt(module,must,yin,unres);
    }
  }
  if (ret != 0) {
    lydict_remove(module->ctx,must->expr);
    must->expr = (char *)0x0;
  }
  return ret;
}



int fill_yin_revision(lys_module *module,lyxml_elem *yin,lys_revision *rev,unres_schema *unres)

{
  ly_ctx *ctx_00;
  lyxml_elem *plVar1;
  int iVar2;
  char *pcVar3;
  unres_schema *unres_local;
  lys_revision *rev_local;
  lyxml_elem *yin_local;
  lys_module *module_local;
  lyxml_elem *next;
  lyxml_elem *child;
  ly_ctx *ctx;
  char *value;
  
  ctx_00 = module->ctx;
  pcVar3 = lyxml_get_attr(yin,"date",(char *)0x0);
  if (pcVar3 == (char *)0x0) {
    ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213f0d,yin->name);
  }
  else {
    iVar2 = lyp_check_date(ctx_00,pcVar3);
    if (iVar2 == 0) {
      memcpy(rev,pcVar3,10);
      plVar1 = yin->child;
      do {
        while( true ) {
          while( true ) {
            do {
              child = plVar1;
              if (child == (lyxml_elem *)0x0) {
                return 0;
              }
              plVar1 = child->next;
            } while (child->ns == (lyxml_ns *)0x0);
            iVar2 = strcmp(child->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
            if (iVar2 == 0) break;
            iVar2 = lyp_yin_parse_subnode_ext
                              (module,rev,LYEXT_PAR_REVISION,child,LYEXT_SUBSTMT_SELF,'\0',unres);
            if (iVar2 != 0) {
              return 1;
            }
          }
          iVar2 = strcmp(child->name,"description");
          if (iVar2 != 0) break;
          if (rev->dsc != (char *)0x0) {
            ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
            return 1;
          }
          iVar2 = lyp_yin_parse_subnode_ext
                            (module,rev,LYEXT_PAR_REVISION,child,LYEXT_SUBSTMT_DESCRIPTION,'\0',
                             unres);
          if (iVar2 != 0) {
            return 1;
          }
          pcVar3 = read_yin_subnode(ctx_00,child,"text");
          rev->dsc = pcVar3;
          if (rev->dsc == (char *)0x0) {
            return 1;
          }
        }
        iVar2 = strcmp(child->name,"reference");
        if (iVar2 != 0) {
          ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
          return 1;
        }
        if (rev->ref != (char *)0x0) {
          ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
          return 1;
        }
        iVar2 = lyp_yin_parse_subnode_ext
                          (module,rev,LYEXT_PAR_REVISION,child,LYEXT_SUBSTMT_REFERENCE,'\0',unres);
        if (iVar2 != 0) {
          return 1;
        }
        pcVar3 = read_yin_subnode(ctx_00,child,"text");
        rev->ref = pcVar3;
      } while (rev->ref != (char *)0x0);
    }
  }
  return 1;
}



int fill_yin_unique(lys_module *module,lys_node *parent,lyxml_elem *yin,lys_unique *unique,
                   unres_schema *unres)

{
  ly_ctx *ctx_00;
  int iVar1;
  char *pcVar2;
  char **ppcVar3;
  char *pcVar4;
  undefined8 *item;
  ushort **ppuVar5;
  unres_schema *unres_local;
  lys_unique *unique_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  char c;
  int i;
  int j;
  int ret;
  char *value;
  char *vaux;
  char *start;
  ly_ctx *ctx;
  char *orig;
  unres_list_uniq *unique_info;
  
  ctx_00 = module->ctx;
  ret = 1;
  start = (char *)0x0;
  pcVar2 = lyxml_get_attr(yin,"tag",(char *)0x0);
  if (pcVar2 == (char *)0x0) {
    ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213f12,yin->name);
  }
  else {
    start = strdup(pcVar2);
    vaux = start;
    if (start == (char *)0x0) {
      ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_unique");
    }
    else {
      while (vaux = strpbrk(vaux," \t\n"), vaux != (char *)0x0) {
        if (unique->expr_size == 0xff) {
          ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",0xff,
                 "referenced items","unique");
          unique->expr_size = '\0';
          goto LAB_0014b4d7;
        }
        unique->expr_size = unique->expr_size + '\x01';
        while (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[*vaux] & 0x2000) != 0) {
          vaux = vaux + 1;
        }
      }
      unique->expr_size = unique->expr_size + '\x01';
      ppcVar3 = (char **)calloc((ulong)unique->expr_size,8);
      unique->expr = ppcVar3;
      if (unique->expr == (char **)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_unique");
      }
      else {
        value = start;
        for (i = 0; i < (int)(uint)unique->expr_size; i = i + 1) {
          pcVar2 = strpbrk(value," \t\n");
          if (pcVar2 != (char *)0x0) {
            c = *pcVar2;
            *pcVar2 = '\0';
          }
          ppcVar3 = unique->expr;
          pcVar4 = transform_schema2json(module,value);
          ppcVar3[i] = pcVar4;
          if (pcVar2 != (char *)0x0) {
            *pcVar2 = c;
          }
          for (j = 0; j < i; j = j + 1) {
            if (unique->expr[j] == unique->expr[i]) {
              ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,unique->expr[i],"unique");
              ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"The identifier is not unique");
              goto LAB_0014b4d7;
            }
          }
          value = pcVar2;
          if (unres == (unres_schema *)0x0) {
            iVar1 = resolve_unique(parent,unique->expr[i],&unique->trg_type);
            if (iVar1 != 0) goto LAB_0014b4d7;
          }
          else {
            item = (undefined8 *)malloc(0x18);
            if (item == (undefined8 *)0x0) {
              ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_unique");
              goto LAB_0014b4d7;
            }
            *item = parent;
            item[1] = unique->expr[i];
            item[2] = &unique->trg_type;
            iVar1 = unres_schema_add_node(module,unres,item,UNRES_LIST_UNIQ,(lys_node *)0x0);
            if (iVar1 == -1) goto LAB_0014b4d7;
          }
          while ((value != (char *)0x0 &&
                 (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[*value] & 0x2000) != 0))) {
            value = value + 1;
          }
        }
        ret = 0;
      }
    }
  }
LAB_0014b4d7:
  free(start);
  return ret;
}



int deviate_minmax(lys_node *target,lyxml_elem *node,lys_deviate *d,int type)

{
  lys_iffeature **pplVar1;
  int iVar2;
  char *pcVar3;
  ushort **ppuVar4;
  int *piVar5;
  long in_FS_OFFSET;
  int type_local;
  lys_deviate *d_local;
  lyxml_elem *node_local;
  lys_node *target_local;
  char *endptr;
  char *value;
  ulong val;
  uint32_t *ui32val;
  uint32_t *min;
  uint32_t *max;
  ly_ctx *ctx;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = target->module->ctx;
  if (d->mod == LY_DEVIATE_DEL) {
    if (type == 0) {
      pcVar3 = "min-elements";
    }
    else {
      pcVar3 = "max-elements";
    }
    ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,pcVar3,"deviate delete");
  }
  else {
    if (target->nodetype == LYS_LEAFLIST) {
      pplVar1 = (lys_iffeature **)&target[1].priv;
      min = (uint32_t *)&target[1].priv;
    }
    else {
      if (target->nodetype != LYS_LIST) {
        ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,node->name);
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Target node does not allow \"%s\" property.",
                node->name);
        goto LAB_0014b920;
      }
      pplVar1 = &target[1].iffeature;
      min = (uint32_t *)&target[1].iffeature;
    }
    max = (uint32_t *)((long)pplVar1 + 4);
    value = lyxml_get_attr(node,"value",(char *)0x0);
    if (value == (char *)0x0) {
      ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",node->name);
    }
    else {
      while( true ) {
        ppuVar4 = __ctype_b_loc();
        if (((*ppuVar4)[*value] & 0x2000) == 0) break;
        value = value + 1;
      }
      if (type == 0) {
LAB_0014b6f7:
        piVar5 = __errno_location();
        *piVar5 = 0;
        endptr = (char *)0x0;
        val = strtoul(value,&endptr,10);
        if ((*endptr == '\0') && (*value != '-')) {
          piVar5 = __errno_location();
          if ((*piVar5 == 0) && (val < 0x100000000)) {
            if (type == 0) {
              d->min = (uint32_t)val;
              d->min_set = '\x01';
              ui32val = min;
            }
            else {
              d->max = (uint32_t)val;
              d->max_set = '\x01';
              ui32val = max;
            }
            goto LAB_0014b7cb;
          }
        }
        ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,node->name);
      }
      else {
        iVar2 = strcmp(value,"unbounded");
        if (iVar2 != 0) goto LAB_0014b6f7;
        val = 0;
        d->max = 0;
        d->max_set = '\x01';
        ui32val = max;
LAB_0014b7cb:
        if ((d->mod == LY_DEVIATE_ADD) && (*ui32val != 0)) {
          ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,node->name);
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Adding property that already exists.");
        }
        else {
          *ui32val = (uint32_t)val;
          if ((*max == 0) || (*min <= *max)) {
            iVar2 = 0;
            goto LAB_0014b925;
          }
          if (type == 0) {
            ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"min-elements");
            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "\"min-elements\" is bigger than \"max-elements\".");
          }
          else {
            ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"max-elements");
            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "\"max-elements\" is smaller than \"min-elements\".");
          }
        }
      }
    }
  }
LAB_0014b920:
  iVar2 = 1;
LAB_0014b925:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int fill_yin_deviation(lys_module *module,lyxml_elem *yin,lys_deviation *dev,unres_schema *unres)

{
  byte bVar1;
  long lVar2;
  lys_module *plVar3;
  long lVar4;
  bool bVar5;
  bool bVar6;
  int iVar7;
  LYS_NODE LVar8;
  char *pcVar9;
  lys_module *plVar10;
  lys_deviate *plVar11;
  lys_node *plVar12;
  lys_restr *plVar13;
  lys_unique *plVar14;
  char **ppcVar15;
  char *pcVar16;
  size_t sVar17;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  lys_deviation *dev_local;
  lyxml_elem *yin_local;
  lys_module *module_local;
  int c_dev;
  int c_must;
  int c_uniq;
  int c_dflt;
  int c_ext;
  int f_min;
  int f_max;
  int i;
  int j;
  int k;
  int rc;
  uint u;
  lys_node *node;
  ly_set *set;
  char *value;
  char **stritem;
  lyxml_elem *next;
  lyxml_elem *next2;
  lyxml_elem *child;
  lyxml_elem *develem;
  lys_node *parent;
  lys_node_list *list;
  lys_type *t;
  uint8_t *trg_must_size;
  lys_restr **trg_must;
  size_t deviate_must_index;
  ly_ctx *ctx;
  lys_deviate *d;
  lys_node *dev_target;
  lys_node_choice *choice;
  lys_node_leaf *leaf;
  ly_set *dflt_check;
  lys_node_leaflist *llist;
  void *reallocated;
  lys_module *mod;
  lys_node_inout *inout;
  lys_restr *must;
  unres_schema tmp_unres;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  c_dev = 0;
  c_ext = 0;
  ctx = module->ctx;
  d = (lys_deviate *)0x0;
  dev_target = (lys_node *)0x0;
  choice = (lys_node_choice *)0x0;
  leaf = (lys_node_leaf *)0x0;
  dflt_check = ly_set_new();
  list = (lys_node_list *)0x0;
  llist = (lys_node_leaflist *)0x0;
  t = (lys_type *)0x0;
  trg_must_size = (uint8_t *)0x0;
  trg_must = (lys_restr **)0x0;
  value = lyxml_get_attr(yin,"target-node",(char *)0x0);
  if (value == (char *)0x0) {
    ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"target-node",yin->name);
  }
  else {
    pcVar9 = transform_schema2json(module,value);
    dev->target_name = pcVar9;
    if (dev->target_name != (char *)0x0) {
      iVar7 = resolve_schema_nodeid(dev->target_name,(lys_node *)0x0,module,&set,0,1);
      if (iVar7 == -1) {
        ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,dev->target_name,yin->name);
        ly_set_free(set);
      }
      else {
        dev_target = *(set->set).s;
        ly_set_free(set);
        plVar3 = dev_target->module;
        plVar10 = lys_main_module(module);
        if (plVar3 == plVar10) {
          ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,dev->target_name,yin->name);
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Deviating own module is not allowed.");
        }
        else {
          child = yin->child;
          while (child != (lyxml_elem *)0x0) {
            next = child->next;
            if (child->ns == (lyxml_ns *)0x0) {
              lyxml_free(ctx,child);
            }
            else {
              iVar7 = strcmp(child->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
              if (iVar7 == 0) {
                iVar7 = strcmp(child->name,"description");
                if (iVar7 == 0) {
                  if (dev->dsc != (char *)0x0) {
                    ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
                    goto LAB_001504cd;
                  }
                  iVar7 = lyp_yin_parse_subnode_ext
                                    (module,dev,LYEXT_PAR_DEVIATION,child,LYEXT_SUBSTMT_DESCRIPTION,
                                     '\0',unres);
                  if (iVar7 != 0) goto LAB_001504cd;
                  pcVar9 = read_yin_subnode(ctx,child,"text");
                  dev->dsc = pcVar9;
                  pcVar9 = dev->dsc;
                }
                else {
                  iVar7 = strcmp(child->name,"reference");
                  if (iVar7 != 0) {
                    iVar7 = strcmp(child->name,"deviate");
                    if (iVar7 == 0) {
                      if (c_dev != 0xff) {
                        c_dev = c_dev + 1;
                        goto LAB_0014bf84;
                      }
                      ly_log(ctx,LY_LLERR,LY_EINT,
                             "Reached limit (%lu) for storing %s in %s statement.",0xff,"deviates",
                             "deviation");
                    }
                    else {
                      ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
                    }
                    goto LAB_001504cd;
                  }
                  if (dev->ref != (char *)0x0) {
                    ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
                    goto LAB_001504cd;
                  }
                  iVar7 = lyp_yin_parse_subnode_ext
                                    (module,dev,LYEXT_PAR_DEVIATION,child,LYEXT_SUBSTMT_REFERENCE,
                                     '\0',unres);
                  if (iVar7 != 0) goto LAB_001504cd;
                  pcVar9 = read_yin_subnode(ctx,child,"text");
                  dev->ref = pcVar9;
                  pcVar9 = dev->ref;
                }
                if (pcVar9 == (char *)0x0) goto LAB_001504cd;
                lyxml_free(ctx,child);
              }
              else {
                if (c_ext == 0xff) {
                  ly_log(ctx,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                         0xff,"extensions","deviation");
                  goto LAB_001504cd;
                }
                c_ext = c_ext + 1;
              }
            }
LAB_0014bf84:
            child = next;
          }
          if (c_dev == 0) {
            ly_vlog(ctx,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"deviate","deviation");
          }
          else {
            plVar11 = (lys_deviate *)calloc((long)c_dev,0x48);
            dev->deviate = plVar11;
            if (dev->deviate != (lys_deviate *)0x0) {
              if (c_ext != 0) {
                reallocated = realloc(dev->ext,(long)(int)(c_ext + (uint)dev->ext_size) * 8);
                if ((lys_ext_instance **)reallocated == (lys_ext_instance **)0x0) {
                  ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                         "fill_yin_deviation");
                  goto LAB_001504cd;
                }
                dev->ext = (lys_ext_instance **)reallocated;
                memset(dev->ext + dev->ext_size,0,(long)c_ext * 8);
              }
              develem = yin->child;
LAB_00150183:
              if (develem != (lyxml_elem *)0x0) {
                next = develem->next;
                iVar7 = strcmp(develem->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
                if (iVar7 != 0) {
                  iVar7 = lyp_yin_fill_ext(dev,LYEXT_PAR_DEVIATION,LYEXT_SUBSTMT_SELF,'\0',module,
                                           develem,&dev->ext,dev->ext_size,unres);
                  dev->ext_size = dev->ext_size + '\x01';
                  if (iVar7 == 0) goto LAB_00150175;
                  goto LAB_001504cd;
                }
                bVar5 = false;
                bVar6 = false;
                c_must = 0;
                c_uniq = 0;
                c_dflt = 0;
                c_ext = 0;
                value = lyxml_get_attr(develem,"value",(char *)0x0);
                if (value == (char *)0x0) {
                  ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",develem->name);
                  goto LAB_001504cd;
                }
                iVar7 = strcmp(value,"not-supported");
                if (iVar7 == 0) {
                  dev->deviate[dev->deviate_size].mod = LY_DEVIATE_NO;
                  if ((dev->deviate_size != '\0') || (develem->next != (lyxml_elem *)0x0)) {
                    ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,develem->name);
                    ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                            "\"not-supported\" deviation cannot be combined with any other deviation."
                           );
                    goto LAB_001504cd;
                  }
                  if (((dev_target->nodetype == LYS_LEAF) &&
                      (plVar12 = lys_parent(dev_target), plVar12 != (lys_node *)0x0)) &&
                     (plVar12 = lys_parent(dev_target), plVar12->nodetype == LYS_LIST)) {
                    for (i = 0; plVar12 = lys_parent(dev_target), i < (int)(uint)plVar12->padding[2]
                        ; i = i + 1) {
                      plVar12 = lys_parent(dev_target);
                      if (dev_target == *(lys_node **)(*(long *)&plVar12[1].flags + (long)i * 8)) {
                        ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,develem->name);
                        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                "\"not-supported\" deviation cannot remove a list key.");
                        goto LAB_001504cd;
                      }
                    }
                  }
                  parent = dev_target->parent;
                  lys_node_unlink(dev_target);
                  if (parent != (lys_node *)0x0) {
                    if ((parent->nodetype & 0x3000) == LYS_UNKNOWN) {
                      if ((parent->nodetype & 0x4100) != LYS_UNKNOWN) {
                        inout = (lys_node_inout *)calloc(1,0x78);
                        if (inout == (lys_node_inout *)0x0) {
                          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                                 "fill_yin_deviation");
                          goto LAB_001504cd;
                        }
                        inout->nodetype = dev_target->nodetype;
                        if (inout->nodetype == LYS_INPUT) {
                          pcVar9 = "input";
                        }
                        else {
                          pcVar9 = "output";
                        }
                        pcVar9 = lydict_insert(ctx,pcVar9,0);
                        inout->name = pcVar9;
                        inout->module = dev_target->module;
                        inout->flags = 0x40;
                        if ((parent->child == (lys_node *)0x0) ||
                           (parent->child->next != (lys_node *)0x0)) {
LAB_0014c603:
                    // WARNING: Subroutine does not return
                          __assert_fail("parent->child && !parent->child->next && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUTPUT : LYS_INPUT))"
                                        ,
                                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yin.c"
                                        ,0x93a,"fill_yin_deviation");
                        }
                        if (inout->nodetype == LYS_INPUT) {
                          LVar8 = LYS_OUTPUT;
                        }
                        else {
                          LVar8 = LYS_INPUT;
                        }
                        if (LVar8 != parent->child->nodetype) goto LAB_0014c603;
                        parent->child->next = (lys_node *)inout;
                        inout->prev = parent->child;
                        parent->child->prev = (lys_node *)inout;
                        inout->parent = parent;
                      }
                    }
                    else {
                      dev_target->parent = parent;
                    }
                  }
                  dev->orig_node = dev_target;
                }
                else {
                  iVar7 = strcmp(value,"add");
                  if (iVar7 == 0) {
                    dev->deviate[dev->deviate_size].mod = LY_DEVIATE_ADD;
                  }
                  else {
                    iVar7 = strcmp(value,"replace");
                    if (iVar7 == 0) {
                      dev->deviate[dev->deviate_size].mod = LY_DEVIATE_RPL;
                    }
                    else {
                      iVar7 = strcmp(value,"delete");
                      if (iVar7 != 0) {
                        ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,develem->name);
                        goto LAB_001504cd;
                      }
                      dev->deviate[dev->deviate_size].mod = LY_DEVIATE_DEL;
                    }
                  }
                }
                d = dev->deviate + dev->deviate_size;
                dev->deviate_size = dev->deviate_size + '\x01';
                if (dev->orig_node == (lys_node *)0x0) {
                  memset(&tmp_unres,0,0x28);
                  plVar12 = lys_node_dup(dev_target->module,(lys_node *)0x0,dev_target,&tmp_unres,1)
                  ;
                  dev->orig_node = plVar12;
                  if (tmp_unres.count != 0) {
                    ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yin.c"
                           ,0x957);
                    goto LAB_001504cd;
                  }
                }
                child = develem->child;
LAB_0014df4e:
                if (child == (lyxml_elem *)0x0) goto code_r0x0014df7e;
                next2 = child->next;
                if (child->ns == (lyxml_ns *)0x0) {
                  lyxml_free(ctx,child);
                }
                else {
                  iVar7 = strcmp(child->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
                  if (iVar7 == 0) {
                    if (d->mod == LY_DEVIATE_NO) {
                      ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
                      goto LAB_001504cd;
                    }
                    iVar7 = strcmp(child->name,"config");
                    if (iVar7 == 0) {
                      if ((d->flags & 3) != 0) {
                        ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
                        goto LAB_001504cd;
                      }
                      value = lyxml_get_attr(child,"value",(char *)0x0);
                      if (value == (char *)0x0) {
                        ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",child->name);
                        goto LAB_001504cd;
                      }
                      iVar7 = strcmp(value,"false");
                      if (iVar7 == 0) {
                        d->flags = d->flags | 2;
                      }
                      else {
                        iVar7 = strcmp(value,"true");
                        if (iVar7 != 0) {
                          ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,child->name);
                          goto LAB_001504cd;
                        }
                        d->flags = d->flags | 1;
                      }
                      if (d->mod == LY_DEVIATE_DEL) {
                        ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"config",
                                "deviate delete");
                        goto LAB_001504cd;
                      }
                      dev_target->flags = dev_target->flags & 0xfffc;
                      dev_target->flags = d->flags & 3 | dev_target->flags;
                      iVar7 = lyp_yin_parse_subnode_ext
                                        (module,d,LYEXT_PAR_DEVIATE,child,LYEXT_SUBSTMT_CONFIG,'\0',
                                         unres);
                    }
                    else {
                      iVar7 = strcmp(child->name,"default");
                      if (iVar7 == 0) {
                        iVar7 = lyp_yin_parse_subnode_ext
                                          (module,d,LYEXT_PAR_DEVIATE,child,LYEXT_SUBSTMT_DEFAULT,
                                           (uint8_t)c_dflt,unres);
                        if (iVar7 == 0) {
                          if (c_dflt == 0xff) {
                            ly_log(ctx,LY_LLERR,LY_EINT,
                                   "Reached limit (%lu) for storing %s in %s statement.",0xff,
                                   "defaults","deviate");
                          }
                          else {
                            c_dflt = c_dflt + 1;
                            if ((((byte)module->field_0x40 >> 1 & 7) < 2) &&
                               (dev_target->nodetype == LYS_LEAFLIST)) {
                              ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"default");
                              ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                      "Target node does not allow \"default\" property.");
                            }
                            else if ((c_dflt < 2) || (dev_target->nodetype == LYS_LEAFLIST)) {
                              if ((c_dflt != 1) ||
                                 ((dev_target->nodetype & (LYS_CHOICE|LYS_LEAF|LYS_LEAFLIST)) !=
                                  LYS_UNKNOWN)) goto LAB_0014df40;
                              ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"default");
                              ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                      "Target node does not allow \"default\" property.");
                            }
                            else {
                              ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"default");
                              ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                      "Target node does not allow multiple \"default\" properties.")
                              ;
                            }
                          }
                        }
                        goto LAB_001504cd;
                      }
                      iVar7 = strcmp(child->name,"mandatory");
                      if (iVar7 == 0) {
                        if ((d->flags & 0xc0) != 0) {
                          ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
                          goto LAB_001504cd;
                        }
                        if ((dev_target->nodetype & (LYS_CHOICE|LYS_LEAF|LYS_ANYDATA)) ==
                            LYS_UNKNOWN) {
                          ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
                          ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                  "Target node does not allow \"%s\" property.",child->name);
                          goto LAB_001504cd;
                        }
                        value = lyxml_get_attr(child,"value",(char *)0x0);
                        if (value == (char *)0x0) {
                          ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",child->name);
                          goto LAB_001504cd;
                        }
                        iVar7 = strcmp(value,"false");
                        if (iVar7 == 0) {
                          d->flags = d->flags | 0x80;
                        }
                        else {
                          iVar7 = strcmp(value,"true");
                          if (iVar7 != 0) {
                            ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,child->name);
                            goto LAB_001504cd;
                          }
                          d->flags = d->flags | 0x40;
                        }
                        if (d->mod == LY_DEVIATE_ADD) {
                          if ((dev_target->flags & 0xc0) != 0) {
                            ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
                            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                    "Adding property that already exists.");
                            goto LAB_001504cd;
                          }
                          if ((d->flags & 0x40) != 0) {
                            if (dev_target->nodetype == LYS_CHOICE) {
                              if (dev_target[1].name != (char *)0x0) {
                                ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,child->name,
                                        child->parent->name);
                                ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                        "Adding the \"mandatory\" statement is forbidden on choice with the \"default\" statement."
                                       );
                                goto LAB_001504cd;
                              }
                            }
                            else if ((dev_target->nodetype == LYS_LEAF) &&
                                    (dev_target[1].prev != (lys_node *)0x0)) {
                              ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,child->name,
                                      child->parent->name);
                              ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                      "Adding the \"mandatory\" statement is forbidden on leaf with the \"default\" statement."
                                     );
                              goto LAB_001504cd;
                            }
                          }
                          dev_target->flags = d->flags & 0xc0 | dev_target->flags;
                        }
                        else if (d->mod == LY_DEVIATE_RPL) {
                          if ((dev_target->flags & 0xc0) == 0) {
                            ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
                            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                    "Replacing a property that does not exist.");
                            goto LAB_001504cd;
                          }
                          dev_target->flags = dev_target->flags & 0xff3f;
                          dev_target->flags = d->flags & 0xc0 | dev_target->flags;
                        }
                        else if (d->mod == LY_DEVIATE_DEL) {
                          ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"mandatory",
                                  "deviate delete");
                          goto LAB_001504cd;
                        }
                        parent = dev_target->parent;
                        while (((parent != (lys_node *)0x0 &&
                                ((parent->nodetype & 0x4802) == LYS_UNKNOWN)) &&
                               ((parent->nodetype != LYS_CONTAINER ||
                                (lVar4._0_2_ = parent[1].flags, lVar4._2_1_ = parent[1].ext_size,
                                lVar4._3_1_ = parent[1].iffeature_size,
                                lVar4._4_1_ = parent[1].padding[0],
                                lVar4._5_1_ = parent[1].padding[1],
                                lVar4._6_1_ = parent[1].padding[2],
                                lVar4._7_1_ = parent[1].padding[3], lVar4 == 0))))) {
                          parent = parent->parent;
                        }
                        if ((((parent != (lys_node *)0x0) && (parent->nodetype == LYS_CHOICE)) &&
                            (parent[1].name != (char *)0x0)) &&
                           (iVar7 = lyp_check_mandatory_choice(parent), iVar7 != 0))
                        goto LAB_001504cd;
                        iVar7 = lyp_yin_parse_subnode_ext
                                          (module,d,LYEXT_PAR_DEVIATE,child,LYEXT_SUBSTMT_MANDATORY,
                                           '\0',unres);
                      }
                      else {
                        iVar7 = strcmp(child->name,"min-elements");
                        if (iVar7 == 0) {
                          if (bVar5) {
                            ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
                            goto LAB_001504cd;
                          }
                          bVar5 = true;
                          iVar7 = deviate_minmax(dev_target,child,d,0);
                          if (iVar7 != 0) goto LAB_001504cd;
                          iVar7 = lyp_yin_parse_subnode_ext
                                            (module,d,LYEXT_PAR_DEVIATE,child,LYEXT_SUBSTMT_MIN,'\0'
                                             ,unres);
                        }
                        else {
                          iVar7 = strcmp(child->name,"max-elements");
                          if (iVar7 != 0) {
                            iVar7 = strcmp(child->name,"must");
                            if (iVar7 == 0) {
                              if (c_must == 0xff) {
                                ly_log(ctx,LY_LLERR,LY_EINT,
                                       "Reached limit (%lu) for storing %s in %s statement.",0xff,
                                       "musts","deviate");
                                goto LAB_001504cd;
                              }
                              c_must = c_must + 1;
                            }
                            else {
                              iVar7 = strcmp(child->name,"type");
                              if (iVar7 != 0) {
                                iVar7 = strcmp(child->name,"unique");
                                if (iVar7 == 0) {
                                  iVar7 = lyp_yin_parse_subnode_ext
                                                    (module,d,LYEXT_PAR_DEVIATE,child,
                                                     LYEXT_SUBSTMT_UNIQUE,(uint8_t)c_uniq,unres);
                                  if (iVar7 == 0) {
                                    if (c_uniq != 0xff) {
                                      c_uniq = c_uniq + 1;
                                      goto LAB_0014df40;
                                    }
                                    ly_log(ctx,LY_LLERR,LY_EINT,
                                           "Reached limit (%lu) for storing %s in %s statement.",
                                           0xff,"uniques","deviate");
                                  }
                                  goto LAB_001504cd;
                                }
                                iVar7 = strcmp(child->name,"units");
                                if (iVar7 == 0) {
                                  if (d->units == (char *)0x0) {
                                    if ((dev_target->nodetype == LYS_LEAFLIST) ||
                                       (dev_target->nodetype == LYS_LEAF)) {
                                      stritem = (char **)&dev_target[1].next;
                                      value = lyxml_get_attr(child,"name",(char *)0x0);
                                      if (value != (char *)0x0) {
                                        pcVar9 = lydict_insert(ctx,value,0);
                                        d->units = pcVar9;
                                        if (d->mod == LY_DEVIATE_ADD) {
                                          if (*stritem != (char *)0x0) {
                                            ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,
                                                    child->name);
                                            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                                    "Adding property that already exists.");
                                            goto LAB_001504cd;
                                          }
                                          pcVar9 = lydict_insert(ctx,value,0);
                                          *stritem = pcVar9;
                                        }
                                        else if (d->mod == LY_DEVIATE_RPL) {
                                          if (*stritem == (char *)0x0) {
                                            ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,
                                                    child->name);
                                            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                                    "Replacing a property that does not exist.");
                                            goto LAB_001504cd;
                                          }
                                          lydict_remove(ctx,*stritem);
                                          pcVar9 = lydict_insert(ctx,value,0);
                                          *stritem = pcVar9;
                                        }
                                        else if (d->mod == LY_DEVIATE_DEL) {
                                          if (*stritem != d->units) {
                                            ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,
                                                    child->name);
                                            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                                    "Value differs from the target being deleted.");
                                            goto LAB_001504cd;
                                          }
                                          lydict_remove(ctx,*stritem);
                                          *stritem = (char *)0x0;
                                          j = -1;
                                          while (iVar7 = lys_ext_iter(dev_target->ext,
                                                                      dev_target->ext_size,
                                                                      (char)j + '\x01',
                                                                      LYEXT_SUBSTMT_UNITS),
                                                iVar7 != -1) {
                                            lyp_ext_instance_rm(ctx,&dev_target->ext,
                                                                &dev_target->ext_size,(uint8_t)iVar7
                                                               );
                                            j = iVar7 + -1;
                                          }
                                        }
                                        iVar7 = lyp_yin_parse_subnode_ext
                                                          (module,d,LYEXT_PAR_DEVIATE,child,
                                                           LYEXT_SUBSTMT_UNITS,'\0',unres);
                                        goto joined_r0x0014d629;
                                      }
                                      ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54
                                              ,child->name);
                                    }
                                    else {
                                      ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
                                      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                              "Target node does not allow \"%s\" property.",
                                              child->name);
                                    }
                                  }
                                  else {
                                    ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,
                                            yin->name);
                                  }
                                }
                                else {
                                  ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
                                }
                                goto LAB_001504cd;
                              }
                              if (d->type != (lys_type *)0x0) {
                                ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,
                                        yin->name);
                                goto LAB_001504cd;
                              }
                              if (d->mod == LY_DEVIATE_ADD) {
                                ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,&DAT_00213b02,
                                        "deviate add");
                                goto LAB_001504cd;
                              }
                              if (d->mod == LY_DEVIATE_DEL) {
                                ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,&DAT_00213b02,
                                        "deviate delete");
                                goto LAB_001504cd;
                              }
                              if (dev_target->nodetype == LYS_LEAF) {
                                t = (lys_type *)&dev_target[1].ref;
                                if (dev_target[1].prev != (lys_node *)0x0) {
                                  ly_set_add(dflt_check,dev_target,0);
                                }
                              }
                              else {
                                if (dev_target->nodetype != LYS_LEAFLIST) {
                                  ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
                                  ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                          "Target node does not allow \"%s\" property.",child->name)
                                  ;
                                  goto LAB_001504cd;
                                }
                                t = (lys_type *)&dev_target[1].ref;
                                if (dev_target[1].prev != (lys_node *)0x0) {
                                  ly_set_add(dflt_check,dev_target,0);
                                }
                              }
                              lys_type_free(ctx,t,(_func_void_lys_node_ptr_void_ptr *)0x0);
                              memset(t,0,0x40);
                              t->der = (lys_tpdf *)child;
                              t->parent = (lys_tpdf *)dev_target;
                              iVar7 = unres_schema_add_node
                                                (module,unres,t,UNRES_TYPE_DER,dev_target);
                              if (iVar7 == -1) goto LAB_001504cd;
                              d->type = t;
                            }
                            goto LAB_0014df40;
                          }
                          if (bVar6) {
                            ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
                            goto LAB_001504cd;
                          }
                          bVar6 = true;
                          iVar7 = deviate_minmax(dev_target,child,d,1);
                          if (iVar7 != 0) goto LAB_001504cd;
                          iVar7 = lyp_yin_parse_subnode_ext
                                            (module,d,LYEXT_PAR_DEVIATE,child,LYEXT_SUBSTMT_MAX,'\0'
                                             ,unres);
                        }
                      }
                    }
joined_r0x0014d629:
                    if (iVar7 != 0) goto LAB_001504cd;
                  }
                  else {
                    if (c_ext == 0xff) {
                      ly_log(ctx,LY_LLERR,LY_EINT,
                             "Reached limit (%lu) for storing %s in %s statement.",0xff,"extensions"
                             ,"deviate");
                      goto LAB_001504cd;
                    }
                    c_ext = c_ext + 1;
                  }
                }
LAB_0014df40:
                child = next2;
                goto LAB_0014df4e;
              }
              if (((ctx->models).flags & 2U) == 0) {
                for (u = 0; u < dflt_check->number; u = u + 1) {
                  value = (char *)0x0;
                  rc = 0;
                  if ((dflt_check->set).s[u]->nodetype == LYS_LEAF) {
                    leaf = (lys_node_leaf *)(dflt_check->set).s[u];
                    value = leaf->dflt;
                    rc = unres_schema_add_node
                                   (module,unres,&leaf->type,UNRES_TYPE_DFLT,(lys_node *)&leaf->dflt
                                   );
                  }
                  else {
                    llist = (lys_node_leaflist *)(dflt_check->set).s[u];
                    for (j = 0; j < (int)(uint)llist->dflt_size; j = j + 1) {
                      rc = unres_schema_add_node
                                     (module,unres,&llist->type,UNRES_TYPE_DFLT,
                                      (lys_node *)(llist->dflt + j));
                      if (rc == -1) {
                        value = llist->dflt[j];
                        break;
                      }
                    }
                  }
                  if (rc == -1) {
                    ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
                    ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                            "The default value \"%s\" of the deviated node \"%s\" no longer matches its type."
                            ,dev->target_name);
                    goto LAB_001504cd;
                  }
                }
              }
              for (parent = dev_target; parent != (lys_node *)0x0; parent = lys_parent(parent)) {
                mod = lys_node_module(parent);
                if (module != mod) {
                  mod->field_0x40 = mod->field_0x40 & 0xcf | 0x10;
                  parent->module->field_0x40 = parent->module->field_0x40 & 0xcf | 0x10;
                  if ((mod->field_0x40 & 0x80) == 0) {
                    mod->field_0x40 = mod->field_0x40 | 0x80;
                    iVar7 = unres_schema_add_node
                                      (mod,unres,(void *)0x0,UNRES_MOD_IMPLEMENT,(lys_node *)0x0);
                    if (iVar7 == -1) goto LAB_001504cd;
                  }
                }
              }
              ly_set_free(dflt_check);
              iVar7 = 0;
              goto LAB_001504de;
            }
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_deviation");
          }
        }
      }
    }
  }
LAB_001504cd:
  ly_set_free(dflt_check);
  iVar7 = 1;
LAB_001504de:
  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar7;
code_r0x0014df7e:
  if (c_must == 0) goto LAB_0014e292;
  LVar8 = dev_target->nodetype;
  if (LVar8 < (LYS_CONTAINER|LYS_ANYXML)) {
    if ((LVar8 == LYS_UNKNOWN) || (false)) {
switchD_0014dfcb_caseD_2:
      ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,&DAT_00214312);
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Target node does not allow \"must\" property.")
      ;
      goto LAB_001504cd;
    }
    switch(LVar8) {
    case LYS_CONTAINER:
      trg_must_size = dev_target->padding + 1;
      break;
    default:
      goto switchD_0014dfcb_caseD_2;
    case LYS_LEAF:
      trg_must_size = dev_target->padding + 3;
      break;
    case LYS_LEAFLIST:
      trg_must_size = dev_target->padding + 3;
      break;
    case LYS_LIST:
      trg_must_size = dev_target->padding;
      break;
    case LYS_ANYXML:
      goto switchD_0014dfcb_caseD_20;
    }
  }
  else {
    if (LVar8 != LYS_ANYDATA) goto switchD_0014dfcb_caseD_2;
switchD_0014dfcb_caseD_20:
    trg_must_size = dev_target->padding + 3;
  }
  trg_must = (lys_restr **)&dev_target[1].dsc;
  dev_target->flags = dev_target->flags & 63999;
  if (d->mod == LY_DEVIATE_RPL) {
    ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,&DAT_00214312,"deviate replace");
    goto LAB_001504cd;
  }
  if (d->mod == LY_DEVIATE_ADD) {
    must = (lys_restr *)ly_realloc(*trg_must,(long)(int)(c_must + (uint)*trg_must_size) * 0x38);
    if (must == (lys_restr *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_deviation");
      goto LAB_001504cd;
    }
    *trg_must = must;
    plVar13 = (lys_restr *)calloc((long)c_must,0x38);
    d->must = plVar13;
    d->must_size = (uint8_t)c_must;
  }
  else {
    plVar13 = (lys_restr *)calloc((long)c_must,0x38);
    d->must = plVar13;
  }
  if (d->must == (lys_restr *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_deviation");
    goto LAB_001504cd;
  }
LAB_0014e292:
  if (c_uniq != 0) {
    if (d->mod == LY_DEVIATE_RPL) {
      ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"unique","deviate replace");
      goto LAB_001504cd;
    }
    if (dev_target->nodetype != LYS_LIST) {
      ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"unique");
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "Target node does not allow \"unique\" property.");
      goto LAB_001504cd;
    }
    list = (lys_node_list *)dev_target;
    if (d->mod == LY_DEVIATE_ADD) {
      plVar14 = (lys_unique *)
                ly_realloc(dev_target[1].ext,(long)(int)(c_uniq + (uint)dev_target->padding[3]) << 4
                          );
      d->unique = plVar14;
      if (d->unique == (lys_unique *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_deviation");
        goto LAB_001504cd;
      }
      list->unique = d->unique;
      d->unique = list->unique + list->unique_size;
      d->unique_size = (uint8_t)c_uniq;
    }
    else {
      plVar14 = (lys_unique *)calloc((long)c_uniq,0x10);
      d->unique = plVar14;
      if (d->unique == (lys_unique *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_deviation");
        goto LAB_001504cd;
      }
    }
  }
  if (c_dflt != 0) {
    if (d->mod == LY_DEVIATE_ADD) {
      if (((dev_target->nodetype == LYS_LEAF) && (dev_target[1].prev != (lys_node *)0x0)) ||
         ((dev_target->nodetype == LYS_CHOICE && (dev_target[1].name != (char *)0x0)))) {
        ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"default");
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Adding property that already exists.");
        goto LAB_001504cd;
      }
      if (((dev_target->flags & 0x40) != 0) ||
         ((dev_target->nodetype == LYS_LEAFLIST && (*(int *)&dev_target[1].priv != 0)))) {
        ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"default","deviation");
        if ((dev_target->flags & 0x40) == 0) {
          pcVar9 = "leaflists with non-zero \"min-elements\"";
        }
        else {
          pcVar9 = "nodes with the \"mandatory\"";
        }
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                "Adding the \"default\" statement is forbidden on %s statement.",pcVar9);
        goto LAB_001504cd;
      }
    }
    else if ((d->mod == LY_DEVIATE_RPL) &&
            ((((dev_target->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN &&
              (dev_target[1].prev == (lys_node *)0x0)) ||
             ((dev_target->nodetype == LYS_CHOICE && (dev_target[1].name == (char *)0x0)))))) {
      ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"default");
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Replacing a property that does not exist.");
      goto LAB_001504cd;
    }
    if (dev_target->nodetype == LYS_LEAFLIST) {
      llist = (lys_node_leaflist *)dev_target;
      if (d->mod == LY_DEVIATE_ADD) {
        ppcVar15 = (char **)ly_realloc(dev_target[1].prev,
                                       (long)(int)(c_dflt + (uint)dev_target->padding[2]) * 8);
        llist->dflt = ppcVar15;
        if (llist->dflt == (char **)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_deviation");
          goto LAB_001504cd;
        }
      }
      else if (d->mod == LY_DEVIATE_RPL) {
        for (i = 0; i < (int)(uint)llist->dflt_size; i = i + 1) {
          lydict_remove(ctx,llist->dflt[i]);
        }
        ppcVar15 = (char **)ly_realloc(llist->dflt,(long)c_dflt * 8);
        llist->dflt = ppcVar15;
        llist->dflt_size = '\0';
        if (llist->dflt == (char **)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_deviation");
          goto LAB_001504cd;
        }
      }
    }
    ppcVar15 = (char **)calloc((long)c_dflt,8);
    d->dflt = ppcVar15;
    if (d->dflt == (char **)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_deviation");
      goto LAB_001504cd;
    }
  }
  if (c_ext != 0) {
    reallocated = realloc(d->ext,(long)(int)(c_ext + (uint)d->ext_size) * 8);
    if ((lys_ext_instance **)reallocated == (lys_ext_instance **)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_deviation");
      goto LAB_001504cd;
    }
    d->ext = (lys_ext_instance **)reallocated;
    memset(d->ext + d->ext_size,0,(long)c_ext * 8);
  }
  deviate_must_index = 0;
  child = develem->child;
  while (child != (lyxml_elem *)0x0) {
    next2 = child->next;
    iVar7 = strcmp(child->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
    if (iVar7 == 0) {
      iVar7 = strcmp(child->name,"must");
      if (iVar7 == 0) {
        if (d->mod == LY_DEVIATE_DEL) {
          iVar7 = fill_yin_must(module,child,d->must + d->must_size,unres);
          if (iVar7 != 0) goto LAB_001504cd;
          for (i = 0; i < (int)(uint)*trg_must_size; i = i + 1) {
            if (d->must[d->must_size].expr == (*trg_must)[i].expr) {
              lys_restr_free(ctx,*trg_must + i,(_func_void_lys_node_ptr_void_ptr *)0x0);
              *trg_must_size = *trg_must_size + 0xff;
              if (i != (uint)*trg_must_size) {
                (*trg_must)[i].expr = (*trg_must)[*trg_must_size].expr;
                (*trg_must)[i].dsc = (*trg_must)[*trg_must_size].dsc;
                (*trg_must)[i].ref = (*trg_must)[*trg_must_size].ref;
                (*trg_must)[i].eapptag = (*trg_must)[*trg_must_size].eapptag;
                (*trg_must)[i].emsg = (*trg_must)[*trg_must_size].emsg;
              }
              if (*trg_must_size == '\0') {
                free(*trg_must);
                *trg_must = (lys_restr *)0x0;
              }
              else {
                (*trg_must)[*trg_must_size].expr = (char *)0x0;
                (*trg_must)[*trg_must_size].dsc = (char *)0x0;
                (*trg_must)[*trg_must_size].ref = (char *)0x0;
                (*trg_must)[*trg_must_size].eapptag = (char *)0x0;
                (*trg_must)[*trg_must_size].emsg = (char *)0x0;
              }
              i = -1;
              break;
            }
          }
          d->must_size = d->must_size + '\x01';
          if (i != -1) {
            ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,d->must[(ulong)d->must_size - 1].expr,
                    child->name);
            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "Value does not match any must from the target.");
            goto LAB_001504cd;
          }
        }
        else {
          memset(*trg_must + *trg_must_size,0,0x38);
          iVar7 = fill_yin_must(module,child,*trg_must + *trg_must_size,unres);
          if (iVar7 != 0) goto LAB_001504cd;
          memcpy(d->must + deviate_must_index,*trg_must + *trg_must_size,0x38);
          deviate_must_index = deviate_must_index + 1;
          *trg_must_size = *trg_must_size + '\x01';
        }
        if (((*trg_must_size != '\0') && (((ctx->models).flags & 2U) == 0)) &&
           (iVar7 = unres_schema_add_node(module,unres,dev_target,UNRES_XPATH,(lys_node *)0x0),
           iVar7 == -1)) goto LAB_001504cd;
      }
      else {
        iVar7 = strcmp(child->name,"unique");
        if (iVar7 == 0) {
          if (d->mod == LY_DEVIATE_DEL) {
            memset(d->unique + d->unique_size,0,0x10);
            iVar7 = fill_yin_unique(module,dev_target,child,d->unique + d->unique_size,
                                    (unres_schema *)0x0);
            if (iVar7 == 0) {
              i = 0;
LAB_0014f504:
              if (i < (int)(uint)list->unique_size) {
                if (list->unique[i].expr_size != d->unique[d->unique_size].expr_size)
                goto LAB_0014f4fd;
                for (j = 0; (j < (int)(uint)d->unique[d->unique_size].expr_size &&
                            (list->unique[i].expr[j] == d->unique[d->unique_size].expr[j]));
                    j = j + 1) {
                }
                if (j != (uint)d->unique[d->unique_size].expr_size) goto LAB_0014f4fd;
                for (j = 0; j < (int)(uint)list->unique[i].expr_size; j = j + 1) {
                  lydict_remove(ctx,list->unique[i].expr[j]);
                }
                free(list->unique[i].expr);
                list->unique_size = list->unique_size + 0xff;
                if (i != (uint)list->unique_size) {
                  list->unique[i].expr_size = list->unique[list->unique_size].expr_size;
                  list->unique[i].expr = list->unique[list->unique_size].expr;
                }
                if (list->unique_size == '\0') {
                  free(list->unique);
                  list->unique = (lys_unique *)0x0;
                }
                else {
                  list->unique[list->unique_size].expr_size = '\0';
                  list->unique[list->unique_size].expr = (char **)0x0;
                }
                k = i;
                i = -1;
              }
              d->unique_size = d->unique_size + '\x01';
              if (i == -1) {
                j = -1;
                while (j = lys_ext_iter(dev_target->ext,dev_target->ext_size,(char)j + '\x01',
                                        LYEXT_SUBSTMT_UNIQUE), j != -1) {
                  if (k == (uint)dev_target->ext[j]->insubstmt_index) {
                    lyp_ext_instance_rm(ctx,&dev_target->ext,&dev_target->ext_size,(uint8_t)j);
                    j = j + -1;
                  }
                  else if (k < (int)(uint)dev_target->ext[j]->insubstmt_index) {
                    dev_target->ext[j]->insubstmt_index = dev_target->ext[j]->insubstmt_index + 0xff
                    ;
                  }
                }
                goto LAB_0015004a;
              }
              pcVar9 = child->name;
              pcVar16 = lyxml_get_attr(child,"tag",(char *)0x0);
              ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,pcVar16,pcVar9);
              ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                      "Value differs from the target being deleted.");
              goto LAB_001504cd;
            }
            d->unique_size = d->unique_size + '\x01';
            goto LAB_001504cd;
          }
          memset(list->unique + list->unique_size,0,0x10);
          iVar7 = fill_yin_unique(module,dev_target,child,list->unique + list->unique_size,
                                  (unres_schema *)0x0);
          list->unique_size = list->unique_size + '\x01';
          if (iVar7 != 0) goto LAB_001504cd;
        }
        else {
          iVar7 = strcmp(child->name,"default");
          if (iVar7 == 0) {
            value = lyxml_get_attr(child,"value",(char *)0x0);
            if (value == (char *)0x0) {
              ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",child->name);
              goto LAB_001504cd;
            }
            sVar17 = strlen(value);
            ppcVar15 = d->dflt;
            bVar1 = d->dflt_size;
            d->dflt_size = bVar1 + 1;
            pcVar9 = lydict_insert(ctx,value,sVar17 & 0xffffffff);
            ppcVar15[bVar1] = pcVar9;
            if (dev_target->nodetype == LYS_CHOICE) {
              choice = (lys_node_choice *)dev_target;
              iVar7 = resolve_choice_default_schema_nodeid(value,dev_target->child,&node);
              if ((iVar7 != 0) || (node == (lys_node *)0x0)) {
                ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
                goto LAB_001504cd;
              }
              if (d->mod == LY_DEVIATE_DEL) {
                if ((choice->dflt == (lys_node *)0x0) || (choice->dflt != node)) {
                  ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
                  ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                          "Value differs from the target being deleted.");
                  goto LAB_001504cd;
                }
                choice->dflt = (lys_node *)0x0;
                j = -1;
                while (iVar7 = lys_ext_iter(dev_target->ext,dev_target->ext_size,(char)j + '\x01',
                                            LYEXT_SUBSTMT_DEFAULT), iVar7 != -1) {
                  lyp_ext_instance_rm(ctx,&dev_target->ext,&dev_target->ext_size,(uint8_t)iVar7);
                  j = iVar7 + -1;
                }
              }
              else {
                choice->dflt = node;
                if (choice->dflt == (lys_node *)0x0) {
                  ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
                  goto LAB_001504cd;
                }
              }
            }
            else if (dev_target->nodetype == LYS_LEAF) {
              leaf = (lys_node_leaf *)dev_target;
              if (d->mod == LY_DEVIATE_DEL) {
                if ((dev_target[1].prev == (lys_node *)0x0) ||
                   ((lys_node *)value != dev_target[1].prev)) {
                  ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
                  ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                          "Value differs from the target being deleted.");
                  goto LAB_001504cd;
                }
                lydict_remove(ctx,(char *)dev_target[1].prev);
                leaf->dflt = (char *)0x0;
                leaf->flags = leaf->flags & 0xefff;
                j = -1;
                while (iVar7 = lys_ext_iter(dev_target->ext,dev_target->ext_size,(char)j + '\x01',
                                            LYEXT_SUBSTMT_DEFAULT), iVar7 != -1) {
                  lyp_ext_instance_rm(ctx,&dev_target->ext,&dev_target->ext_size,(uint8_t)iVar7);
                  j = iVar7 + -1;
                }
              }
              else {
                lydict_remove(ctx,(char *)dev_target[1].prev);
                leaf->flags = leaf->flags & 0xefff;
                pcVar9 = lydict_insert(ctx,value,sVar17 & 0xffffffff);
                leaf->dflt = pcVar9;
                ly_set_add(dflt_check,dev_target,0);
              }
            }
            else {
              llist = (lys_node_leaflist *)dev_target;
              if (d->mod == LY_DEVIATE_DEL) {
                i = 0;
LAB_0014fe7d:
                if (i < (int)(uint)dev_target->padding[2]) {
                  if ((*(long *)((dev_target[1].prev)->padding + (long)i * 8 + -0x1c) == 0) ||
                     (value != *(char **)((dev_target[1].prev)->padding + (long)i * 8 + -0x1c)))
                  goto LAB_0014fe76;
                  lydict_remove(ctx,*(char **)((dev_target[1].prev)->padding + (long)i * 8 + -0x1c))
                  ;
                  llist->dflt[i] = (char *)0x0;
                  j = -1;
                  while (j = lys_ext_iter(dev_target->ext,dev_target->ext_size,(char)j + '\x01',
                                          LYEXT_SUBSTMT_DEFAULT), j != -1) {
                    if (i == (uint)dev_target->ext[j]->insubstmt_index) {
                      lyp_ext_instance_rm(ctx,&dev_target->ext,&dev_target->ext_size,(uint8_t)j);
                      j = j + -1;
                    }
                    else if (i < (int)(uint)dev_target->ext[j]->insubstmt_index) {
                      dev_target->ext[j]->insubstmt_index =
                           dev_target->ext[j]->insubstmt_index + 0xff;
                    }
                  }
                }
                if (i != (uint)llist->dflt_size) goto LAB_0015004a;
                ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
                ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                        "The default value to delete not found in the target node.");
                goto LAB_001504cd;
              }
              for (i = 0; i < (int)(uint)dev_target->padding[2]; i = i + 1) {
                if (value == *(char **)((dev_target[1].prev)->padding + (long)i * 8 + -0x1c)) {
                  ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
                  ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Duplicated default value \"%s\".",
                          value);
                  goto LAB_001504cd;
                }
              }
              plVar12 = dev_target[1].prev;
              bVar1 = dev_target->padding[2];
              dev_target->padding[2] = bVar1 + 1;
              pcVar9 = lydict_insert(ctx,value,sVar17 & 0xffffffff);
              *(char **)(plVar12->padding + (ulong)bVar1 * 8 + -0x1c) = pcVar9;
              ly_set_add(dflt_check,dev_target,0);
              llist->flags = llist->flags & 0xefff;
            }
          }
        }
      }
    }
    else {
      iVar7 = lyp_yin_fill_ext(d,LYEXT_PAR_DEVIATE,LYEXT_SUBSTMT_SELF,'\0',module,child,&d->ext,
                               d->ext_size,unres);
      if (iVar7 != 0) goto LAB_001504cd;
      d->ext_size = d->ext_size + '\x01';
    }
LAB_0015004a:
    child = next2;
  }
  if (((c_dflt != 0) && (dev_target->nodetype == LYS_LEAFLIST)) && (d->mod == LY_DEVIATE_DEL)) {
    llist = (lys_node_leaflist *)dev_target;
    i = 0;
    for (j = 0; j < (int)(uint)dev_target->padding[2]; j = j + 1) {
      *(undefined8 *)((dev_target[1].prev)->padding + (long)i * 8 + -0x1c) =
           *(undefined8 *)((dev_target[1].prev)->padding + (long)j * 8 + -0x1c);
      if (*(long *)((dev_target[1].prev)->padding + (long)i * 8 + -0x1c) != 0) {
        i = i + 1;
      }
    }
    dev_target->padding[2] = (char)i + '\x01';
  }
LAB_00150175:
  develem = next;
  goto LAB_00150183;
LAB_0014fe76:
  i = i + 1;
  goto LAB_0014fe7d;
LAB_0014f4fd:
  i = i + 1;
  goto LAB_0014f504;
}



int fill_yin_augment(lys_module *module,lys_node *parent,lyxml_elem *yin,lys_node_augment *aug,
                    int options,unres_schema *unres)

{
  ly_ctx *ctx_00;
  lyxml_elem *plVar1;
  int iVar2;
  char *pcVar3;
  lys_when *plVar4;
  lys_iffeature *plVar5;
  lys_ext_instance **pplVar6;
  unres_schema *unres_local;
  int options_local;
  lys_node_augment *aug_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int c_ftrs;
  int c_ext;
  int ret;
  lyxml_elem *sub;
  lyxml_elem *next;
  lys_node *node;
  ly_ctx *ctx;
  char *value;
  void *reallocated;
  
  ctx_00 = module->ctx;
  c_ftrs = 0;
  c_ext = 0;
  aug->nodetype = LYS_AUGMENT;
  pcVar3 = lyxml_get_attr(yin,"target-node",(char *)0x0);
  if (pcVar3 == (char *)0x0) {
    ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"target-node",yin->name);
  }
  else {
    pcVar3 = transform_schema2json(module,pcVar3);
    aug->target_name = pcVar3;
    if (aug->target_name != (char *)0x0) {
      aug->parent = parent;
      iVar2 = read_yin_common(module,(lys_node *)0x0,aug,LYEXT_PAR_NODE,yin,0x10,unres);
      if (iVar2 == 0) {
        sub = yin->child;
        while (sub != (lyxml_elem *)0x0) {
          plVar1 = sub->next;
          iVar2 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
          if (iVar2 == 0) {
            iVar2 = strcmp(sub->name,"if-feature");
            if (iVar2 == 0) {
              if (c_ftrs == 0xff) {
                ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement."
                       ,0xff,"if-features","augment");
                return 1;
              }
              c_ftrs = c_ftrs + 1;
              sub = plVar1;
            }
            else {
              iVar2 = strcmp(sub->name,"when");
              if (iVar2 == 0) {
                if (aug->when != (lys_when *)0x0) {
                  ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name);
                  return 1;
                }
                plVar4 = read_yin_when(module,sub,unres);
                aug->when = plVar4;
                if (aug->when == (lys_when *)0x0) {
                  lyxml_free(ctx_00,sub);
                  return 1;
                }
                lyxml_free(ctx_00,sub);
                sub = plVar1;
              }
              else {
                iVar2 = strcmp(sub->name,"container");
                if (iVar2 == 0) {
                  node = read_yin_container(module,(lys_node *)aug,sub,options,unres);
                }
                else {
                  iVar2 = strcmp(sub->name,"leaf-list");
                  if (iVar2 == 0) {
                    node = read_yin_leaflist(module,(lys_node *)aug,sub,options,unres);
                  }
                  else {
                    iVar2 = strcmp(sub->name,"leaf");
                    if (iVar2 == 0) {
                      node = read_yin_leaf(module,(lys_node *)aug,sub,options,unres);
                    }
                    else {
                      iVar2 = strcmp(sub->name,"list");
                      if (iVar2 == 0) {
                        node = read_yin_list(module,(lys_node *)aug,sub,options,unres);
                      }
                      else {
                        iVar2 = strcmp(sub->name,"uses");
                        if (iVar2 == 0) {
                          node = read_yin_uses(module,(lys_node *)aug,sub,options,unres);
                        }
                        else {
                          iVar2 = strcmp(sub->name,"choice");
                          if (iVar2 == 0) {
                            node = read_yin_choice(module,(lys_node *)aug,sub,options,unres);
                          }
                          else {
                            iVar2 = strcmp(sub->name,"case");
                            if (iVar2 == 0) {
                              node = read_yin_case(module,(lys_node *)aug,sub,options,unres);
                            }
                            else {
                              iVar2 = strcmp(sub->name,"anyxml");
                              if (iVar2 == 0) {
                                node = read_yin_anydata(module,(lys_node *)aug,sub,LYS_ANYXML,
                                                        options,unres);
                              }
                              else {
                                iVar2 = strcmp(sub->name,"anydata");
                                if (iVar2 == 0) {
                                  node = read_yin_anydata(module,(lys_node *)aug,sub,LYS_ANYDATA,
                                                          options,unres);
                                }
                                else {
                                  iVar2 = strcmp(sub->name,"action");
                                  if (iVar2 == 0) {
                                    node = read_yin_rpc_action(module,(lys_node *)aug,sub,options,
                                                               unres);
                                  }
                                  else {
                                    iVar2 = strcmp(sub->name,"notification");
                                    if (iVar2 != 0) {
                                      ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,sub->name);
                                      return 1;
                                    }
                                    node = read_yin_notif(module,(lys_node *)aug,sub,options,unres);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                if (node == (lys_node *)0x0) {
                  return 1;
                }
                lyxml_free(ctx_00,sub);
                sub = plVar1;
              }
            }
          }
          else {
            if (c_ext == 0xff) {
              ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                     0xff,"extensions","augment");
              return 1;
            }
            c_ext = c_ext + 1;
            sub = plVar1;
          }
        }
        if (c_ftrs != 0) {
          plVar5 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
          aug->iffeature = plVar5;
          if (aug->iffeature == (lys_iffeature *)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_augment");
            return 1;
          }
        }
        if (c_ext != 0) {
          pplVar6 = (lys_ext_instance **)
                    realloc(aug->ext,(long)(int)(c_ext + (uint)aug->ext_size) * 8);
          if (pplVar6 == (lys_ext_instance **)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_augment");
            return 1;
          }
          aug->ext = pplVar6;
          memset(aug->ext + aug->ext_size,0,(long)c_ext * 8);
        }
        plVar1 = yin->child;
        do {
          while( true ) {
            sub = plVar1;
            if (sub == (lyxml_elem *)0x0) {
              if ((parent == (lys_node *)0x0) &&
                 (iVar2 = unres_schema_add_node(module,unres,aug,UNRES_AUGMENT,(lys_node *)0x0),
                 iVar2 == -1)) {
                return 1;
              }
              if ((((ctx_00->models).flags & 2U) == 0) && (aug->when != (lys_when *)0x0)) {
                if ((options & 4U) == 0) {
                  iVar2 = unres_schema_add_node(module,unres,aug,UNRES_XPATH,(lys_node *)0x0);
                  if (iVar2 == -1) {
                    return 1;
                  }
                }
                else {
                  iVar2 = lyxp_node_check_syntax((lys_node *)aug);
                  if (iVar2 != 0) {
                    return 1;
                  }
                }
              }
              return 0;
            }
            plVar1 = sub->next;
            iVar2 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
            if (iVar2 != 0) break;
            iVar2 = strcmp(sub->name,"if-feature");
            if (iVar2 == 0) {
              iVar2 = fill_yin_iffeature((lys_node *)aug,0,sub,aug->iffeature + aug->iffeature_size,
                                         unres);
              aug->iffeature_size = aug->iffeature_size + '\x01';
              if (iVar2 != 0) {
                return 1;
              }
              lyxml_free(ctx_00,sub);
            }
          }
          iVar2 = lyp_yin_fill_ext(aug,LYEXT_PAR_NODE,LYEXT_SUBSTMT_SELF,'\0',module,sub,&aug->ext,
                                   aug->ext_size,unres);
          aug->ext_size = aug->ext_size + '\x01';
        } while (iVar2 == 0);
      }
    }
  }
  return 1;
}



// WARNING: Type propagation algorithm not settling

int fill_yin_refine(lys_node *uses,lyxml_elem *yin,lys_refine *rfn,unres_schema *unres)

{
  byte bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  int iVar5;
  char *pcVar6;
  ushort **ppuVar7;
  int *piVar8;
  lys_restr *plVar9;
  lys_iffeature *plVar10;
  char **ppcVar11;
  size_t sVar12;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  lys_refine *rfn_local;
  lyxml_elem *yin_local;
  lys_node *uses_local;
  int f_mand;
  int f_min;
  int f_max;
  int c_must;
  int c_ftrs;
  int c_dflt;
  int c_ext;
  int r;
  char *endptr;
  lyxml_elem *sub;
  lyxml_elem *next;
  char *value;
  ly_ctx *ctx;
  lys_module *module;
  void *reallocated;
  ulong val;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = uses->module->ctx;
  bVar2 = false;
  bVar3 = false;
  bVar4 = false;
  c_must = 0;
  c_ftrs = 0;
  c_dflt = 0;
  c_ext = 0;
  if (uses == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("uses",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yin.c"
                  ,0xcff,"fill_yin_refine");
  }
  module = uses->module;
  value = lyxml_get_attr(yin,"target-node",(char *)0x0);
  if (value == (char *)0x0) {
    ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"target-node",yin->name);
  }
  else {
    pcVar6 = transform_schema2json(module,value);
    rfn->target_name = pcVar6;
    if (rfn->target_name != (char *)0x0) {
      sub = yin->child;
LAB_00152248:
      if (sub == (lyxml_elem *)0x0) goto code_r0x0015226f;
      next = sub->next;
      if (sub->ns == (lyxml_ns *)0x0) {
LAB_0015222d:
        lyxml_free(ctx,sub);
      }
      else {
        iVar5 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar5 == 0) {
          iVar5 = strcmp(sub->name,"description");
          if (iVar5 == 0) {
            if (rfn->dsc != (char *)0x0) {
              ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name);
              goto LAB_001527ba;
            }
            iVar5 = lyp_yin_parse_subnode_ext
                              (module,rfn,LYEXT_PAR_REFINE,sub,LYEXT_SUBSTMT_DESCRIPTION,'\0',unres)
            ;
            if (iVar5 != 0) goto LAB_001527ba;
            pcVar6 = read_yin_subnode(ctx,sub,"text");
            rfn->dsc = pcVar6;
            pcVar6 = rfn->dsc;
          }
          else {
            iVar5 = strcmp(sub->name,"reference");
            if (iVar5 != 0) {
              iVar5 = strcmp(sub->name,"config");
              if (iVar5 == 0) {
                if ((rfn->flags & 3) != 0) {
                  ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name);
                  goto LAB_001527ba;
                }
                value = lyxml_get_attr(sub,"value",(char *)0x0);
                if (value == (char *)0x0) {
                  ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                  goto LAB_001527ba;
                }
                iVar5 = strcmp(value,"false");
                if (iVar5 == 0) {
                  rfn->flags = rfn->flags | 2;
                }
                else {
                  iVar5 = strcmp(value,"true");
                  if (iVar5 != 0) {
                    ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,sub->name);
                    goto LAB_001527ba;
                  }
                  rfn->flags = rfn->flags | 1;
                }
                rfn->flags = rfn->flags | 4;
                iVar5 = lyp_yin_parse_subnode_ext
                                  (module,rfn,LYEXT_PAR_REFINE,sub,LYEXT_SUBSTMT_CONFIG,'\0',unres);
              }
              else {
                iVar5 = strcmp(sub->name,"default");
                if (iVar5 == 0) {
                  if (rfn->target_type == 0) {
                    if (((byte)module->field_0x40 >> 1 & 7) < 2) {
                      rfn->target_type = 6;
                    }
                    else {
                      rfn->target_type = 0xe;
                    }
                  }
                  else {
                    if (c_dflt == 0) {
                      if (((byte)module->field_0x40 >> 1 & 7) < 2) {
                        rfn->target_type = rfn->target_type & 6;
                      }
                      else {
                        rfn->target_type = rfn->target_type & 0xe;
                      }
                    }
                    else {
                      if (((byte)module->field_0x40 >> 1 & 7) < 2) {
                        ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name);
                        goto LAB_001527ba;
                      }
                      rfn->target_type = rfn->target_type & 8;
                    }
                    if (rfn->target_type == 0) {
                      ly_vlog(ctx,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name);
                      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                              "Invalid refine target nodetype for the substatements.");
                      goto LAB_001527ba;
                    }
                  }
                  if (c_dflt == 0xff) {
                    ly_log(ctx,LY_LLERR,LY_EINT,
                           "Reached limit (%lu) for storing %s in %s statement.",0xff,"defaults",
                           "refine");
                  }
                  else {
                    iVar5 = lyp_yin_parse_subnode_ext
                                      (module,rfn,LYEXT_PAR_REFINE,sub,LYEXT_SUBSTMT_DEFAULT,
                                       (uint8_t)c_dflt,unres);
                    if (iVar5 == 0) {
                      c_dflt = c_dflt + 1;
                      goto LAB_00152240;
                    }
                  }
                  goto LAB_001527ba;
                }
                iVar5 = strcmp(sub->name,"mandatory");
                if (iVar5 == 0) {
                  if (bVar2) {
                    ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name);
                    goto LAB_001527ba;
                  }
                  bVar2 = true;
                  if (rfn->target_type == 0) {
                    rfn->target_type = 0x8026;
                  }
                  else {
                    rfn->target_type = rfn->target_type & 0x8026;
                    if (rfn->target_type == 0) {
                      ly_vlog(ctx,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name);
                      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                              "Invalid refine target nodetype for the substatements.");
                      goto LAB_001527ba;
                    }
                  }
                  value = lyxml_get_attr(sub,"value",(char *)0x0);
                  if (value == (char *)0x0) {
                    ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                    goto LAB_001527ba;
                  }
                  iVar5 = strcmp(value,"true");
                  if (iVar5 == 0) {
                    rfn->flags = rfn->flags | 0x40;
                  }
                  else {
                    iVar5 = strcmp(value,"false");
                    if (iVar5 != 0) {
                      ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,sub->name);
                      goto LAB_001527ba;
                    }
                    rfn->flags = rfn->flags | 0x80;
                  }
                  iVar5 = lyp_yin_parse_subnode_ext
                                    (module,rfn,LYEXT_PAR_REFINE,sub,LYEXT_SUBSTMT_MANDATORY,'\0',
                                     unres);
                }
                else {
                  iVar5 = strcmp(sub->name,"min-elements");
                  if (iVar5 == 0) {
                    if (bVar3) {
                      ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name);
                      goto LAB_001527ba;
                    }
                    bVar3 = true;
                    if (rfn->target_type == 0) {
                      rfn->target_type = 0x18;
                    }
                    else {
                      rfn->target_type = rfn->target_type & 0x18;
                      if (rfn->target_type == 0) {
                        ly_vlog(ctx,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name);
                        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                "Invalid refine target nodetype for the substatements.");
                        goto LAB_001527ba;
                      }
                    }
                    value = lyxml_get_attr(sub,"value",(char *)0x0);
                    if (value == (char *)0x0) {
                      ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                      goto LAB_001527ba;
                    }
                    while (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[*value] & 0x2000) != 0) {
                      value = value + 1;
                    }
                    piVar8 = __errno_location();
                    *piVar8 = 0;
                    endptr = (char *)0x0;
                    val = strtoul(value,&endptr,10);
                    if ((((*endptr != '\0') || (*value == '-')) ||
                        (piVar8 = __errno_location(), *piVar8 != 0)) || (0xffffffff < val)) {
                      ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,sub->name);
                      goto LAB_001527ba;
                    }
                    (rfn->mod).list.min = (uint32_t)val;
                    rfn->flags = rfn->flags | 0x10;
                    iVar5 = lyp_yin_parse_subnode_ext
                                      (module,rfn,LYEXT_PAR_REFINE,sub,LYEXT_SUBSTMT_MIN,'\0',unres)
                    ;
                  }
                  else {
                    iVar5 = strcmp(sub->name,"max-elements");
                    if (iVar5 == 0) {
                      if (bVar4) {
                        ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name);
                        goto LAB_001527ba;
                      }
                      bVar4 = true;
                      if (rfn->target_type == 0) {
                        rfn->target_type = 0x18;
                      }
                      else {
                        rfn->target_type = rfn->target_type & 0x18;
                        if (rfn->target_type == 0) {
                          ly_vlog(ctx,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name
                                 );
                          ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                  "Invalid refine target nodetype for the substatements.");
                          goto LAB_001527ba;
                        }
                      }
                      value = lyxml_get_attr(sub,"value",(char *)0x0);
                      if (value == (char *)0x0) {
                        ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                        goto LAB_001527ba;
                      }
                      while (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[*value] & 0x2000) != 0) {
                        value = value + 1;
                      }
                      iVar5 = strcmp(value,"unbounded");
                      if (iVar5 == 0) {
                        (rfn->mod).list.max = 0;
                      }
                      else {
                        piVar8 = __errno_location();
                        *piVar8 = 0;
                        endptr = (char *)0x0;
                        val = strtoul(value,&endptr,10);
                        if (((*endptr != '\0') || (*value == '-')) ||
                           ((piVar8 = __errno_location(), *piVar8 != 0 ||
                            ((val == 0 || (0xffffffff < val)))))) {
                          ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,sub->name);
                          goto LAB_001527ba;
                        }
                        (rfn->mod).list.max = (uint32_t)val;
                      }
                      rfn->flags = rfn->flags | 8;
                      iVar5 = lyp_yin_parse_subnode_ext
                                        (module,rfn,LYEXT_PAR_REFINE,sub,LYEXT_SUBSTMT_MAX,'\0',
                                         unres);
                    }
                    else {
                      iVar5 = strcmp(sub->name,"presence");
                      if (iVar5 != 0) {
                        iVar5 = strcmp(sub->name,"must");
                        if (iVar5 != 0) {
                          if ((1 < ((byte)module->field_0x40 >> 1 & 7)) &&
                             (iVar5 = strcmp(sub->name,"if-feature"), iVar5 == 0)) {
                            if (rfn->target_type == 0) {
                              rfn->target_type = 0x807f;
                            }
                            else {
                              rfn->target_type = rfn->target_type & 0x807f;
                              if (rfn->target_type == 0) {
                                ly_vlog(ctx,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,sub->name,
                                        yin->name);
                                ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                        "Invalid refine target nodetype for the substatements.");
                                goto LAB_001527ba;
                              }
                            }
                            if (c_ftrs != 0xff) {
                              c_ftrs = c_ftrs + 1;
                              goto LAB_00152240;
                            }
                            ly_log(ctx,LY_LLERR,LY_EINT,
                                   "Reached limit (%lu) for storing %s in %s statement.",0xff,
                                   "if-feature","refine");
                            goto LAB_001527ba;
                          }
                          ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,sub->name);
                          goto LAB_001527ba;
                        }
                        if (rfn->target_type == 0) {
                          rfn->target_type = 0x803d;
                        }
                        else {
                          rfn->target_type = rfn->target_type & 0x803d;
                          if (rfn->target_type == 0) {
                            ly_vlog(ctx,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,sub->name,
                                    yin->name);
                            ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                    "Invalid refine target nodetype for the substatements.");
                            goto LAB_001527ba;
                          }
                        }
                        if (c_must == 0xff) {
                          ly_log(ctx,LY_LLERR,LY_EINT,
                                 "Reached limit (%lu) for storing %s in %s statement.",0xff,"musts",
                                 "refine");
                          goto LAB_001527ba;
                        }
                        c_must = c_must + 1;
                        goto LAB_00152240;
                      }
                      if ((rfn->mod).presence != (char *)0x0) {
                        ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name);
                        goto LAB_001527ba;
                      }
                      if (rfn->target_type == 0) {
                        rfn->target_type = 1;
                      }
                      else {
                        rfn->target_type = rfn->target_type & 1;
                        if (rfn->target_type == 0) {
                          ly_vlog(ctx,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name
                                 );
                          ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                  "Invalid refine target nodetype for the substatements.");
                          goto LAB_001527ba;
                        }
                      }
                      value = lyxml_get_attr(sub,"value",(char *)0x0);
                      if (value == (char *)0x0) {
                        ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                        goto LAB_001527ba;
                      }
                      sVar12 = strlen(value);
                      pcVar6 = lydict_insert(ctx,value,sVar12);
                      (rfn->mod).presence = pcVar6;
                      iVar5 = lyp_yin_parse_subnode_ext
                                        (module,rfn,LYEXT_PAR_REFINE,sub,LYEXT_SUBSTMT_PRESENCE,'\0'
                                         ,unres);
                    }
                  }
                }
              }
              if (iVar5 == 0) goto LAB_0015222d;
              goto LAB_001527ba;
            }
            if (rfn->ref != (char *)0x0) {
              ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,sub->name,yin->name);
              goto LAB_001527ba;
            }
            iVar5 = lyp_yin_parse_subnode_ext
                              (module,rfn,LYEXT_PAR_REFINE,sub,LYEXT_SUBSTMT_REFERENCE,'\0',unres);
            if (iVar5 != 0) goto LAB_001527ba;
            pcVar6 = read_yin_subnode(ctx,sub,"text");
            rfn->ref = pcVar6;
            pcVar6 = rfn->ref;
          }
          if (pcVar6 != (char *)0x0) goto LAB_0015222d;
          goto LAB_001527ba;
        }
        if (c_ext == 0xff) {
          ly_log(ctx,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",0xff,
                 "extensions","refine");
          goto LAB_001527ba;
        }
        c_ext = c_ext + 1;
      }
LAB_00152240:
      sub = next;
      goto LAB_00152248;
    }
  }
LAB_001527ba:
  iVar5 = 1;
LAB_001527bf:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar5;
code_r0x0015226f:
  if (c_must != 0) {
    plVar9 = (lys_restr *)calloc((long)c_must,0x38);
    rfn->must = plVar9;
    if (rfn->must == (lys_restr *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_refine");
      goto LAB_001527ba;
    }
  }
  if (c_ftrs != 0) {
    plVar10 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
    rfn->iffeature = plVar10;
    if (rfn->iffeature == (lys_iffeature *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_refine");
      goto LAB_001527ba;
    }
  }
  if (c_dflt != 0) {
    ppcVar11 = (char **)calloc((long)c_dflt,8);
    rfn->dflt = ppcVar11;
    if (rfn->dflt == (char **)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_refine");
      goto LAB_001527ba;
    }
  }
  if (c_ext != 0) {
    reallocated = realloc(rfn->ext,(long)(int)(c_ext + (uint)rfn->ext_size) * 8);
    if ((lys_ext_instance **)reallocated == (lys_ext_instance **)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_refine");
      goto LAB_001527ba;
    }
    rfn->ext = (lys_ext_instance **)reallocated;
    memset(rfn->ext + rfn->ext_size,0,(long)c_ext * 8);
  }
  sub = yin->child;
  while (sub != (lyxml_elem *)0x0) {
    next = sub->next;
    iVar5 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
    if (iVar5 == 0) {
      iVar5 = strcmp(sub->name,"if-feature");
      if (iVar5 == 0) {
        iVar5 = fill_yin_iffeature(uses,0,sub,rfn->iffeature + rfn->iffeature_size,unres);
        rfn->iffeature_size = rfn->iffeature_size + '\x01';
        goto joined_r0x00152589;
      }
      iVar5 = strcmp(sub->name,"must");
      if (iVar5 == 0) {
        iVar5 = fill_yin_must(module,sub,rfn->must + rfn->must_size,unres);
        rfn->must_size = rfn->must_size + '\x01';
        goto joined_r0x00152589;
      }
      value = lyxml_get_attr(sub,"value",(char *)0x0);
      if (value == (char *)0x0) {
        ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
        goto LAB_001527ba;
      }
      for (r = 0; r < (int)(uint)rfn->dflt_size; r = r + 1) {
        if (value == rfn->dflt[r]) {
          ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Duplicated default value \"%s\".",value);
          goto LAB_001527ba;
        }
      }
      sVar12 = strlen(value);
      ppcVar11 = rfn->dflt;
      bVar1 = rfn->dflt_size;
      rfn->dflt_size = bVar1 + 1;
      pcVar6 = lydict_insert(ctx,value,sVar12);
      ppcVar11[bVar1] = pcVar6;
    }
    else {
      iVar5 = lyp_yin_fill_ext(rfn,LYEXT_PAR_REFINE,LYEXT_SUBSTMT_SELF,'\0',module,sub,&rfn->ext,
                               rfn->ext_size,unres);
      rfn->ext_size = rfn->ext_size + '\x01';
joined_r0x00152589:
      if (iVar5 != 0) goto LAB_001527ba;
    }
    sub = next;
  }
  iVar5 = 0;
  goto LAB_001527bf;
}



int fill_yin_import(lys_module *module,lyxml_elem *yin,lys_import *imp,unres_schema *unres)

{
  long lVar1;
  ly_ctx *ctx_00;
  lyxml_elem *plVar2;
  int iVar3;
  size_t len;
  lys_ext_instance **pplVar4;
  char *pcVar5;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  lys_import *imp_local;
  lyxml_elem *yin_local;
  lys_module *module_local;
  int c_ext;
  int r;
  lyxml_elem *child;
  lyxml_elem *next;
  ly_ctx *ctx;
  void *reallocated;
  char *value;
  lyxml_elem exts;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ctx_00 = module->ctx;
  c_ext = 0;
  memset(&exts,0,0x48);
  plVar2 = yin->child;
LAB_00152db3:
  do {
    while( true ) {
      while( true ) {
        do {
          child = plVar2;
          if (child == (lyxml_elem *)0x0) {
            if (imp->prefix == (char *)0x0) {
              ly_vlog(ctx_00,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"prefix",yin->name);
            }
            else {
              if (c_ext == 0) goto LAB_00152f9c;
              pplVar4 = (lys_ext_instance **)
                        realloc(imp->ext,(long)(int)(c_ext + (uint)imp->ext_size) * 8);
              if (pplVar4 != (lys_ext_instance **)0x0) {
                imp->ext = pplVar4;
                memset(imp->ext + imp->ext_size,0,(long)c_ext * 8);
                child = exts.child;
                goto LAB_00152f75;
              }
              ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_import");
            }
            goto LAB_0015303a;
          }
          plVar2 = child->next;
        } while (child->ns == (lyxml_ns *)0x0);
        iVar3 = strcmp(child->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar3 == 0) break;
        if (c_ext == 0xff) {
          ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",0xff,
                 "extensions","import");
          goto LAB_0015303a;
        }
        c_ext = c_ext + 1;
        lyxml_unlink_elem(ctx_00,child,2);
        lyxml_add_child(ctx_00,&exts,child);
      }
      iVar3 = strcmp(child->name,"prefix");
      if (iVar3 != 0) break;
      pcVar5 = lyxml_get_attr(child,"value",(char *)0x0);
      if (pcVar5 == (char *)0x0) {
        ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",child->name);
        goto LAB_0015303a;
      }
      iVar3 = lyp_check_identifier(ctx_00,pcVar5,LY_IDENT_PREFIX,module,(lys_node *)0x0);
      if (iVar3 != 0) goto LAB_0015303a;
      len = strlen(pcVar5);
      pcVar5 = lydict_insert(ctx_00,pcVar5,len);
      imp->prefix = pcVar5;
      iVar3 = lyp_yin_parse_subnode_ext
                        (module,imp,LYEXT_PAR_IMPORT,child,LYEXT_SUBSTMT_PREFIX,'\0',unres);
joined_r0x00152b65:
      if (iVar3 != 0) goto LAB_0015303a;
    }
    iVar3 = strcmp(child->name,"revision-date");
    if (iVar3 == 0) {
      if (imp->rev[0] == '\0') {
        pcVar5 = lyxml_get_attr(child,"date",(char *)0x0);
        if (pcVar5 == (char *)0x0) {
          ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213f0d,child->name);
        }
        else {
          iVar3 = lyp_check_date(ctx_00,pcVar5);
          if (iVar3 == 0) {
            memcpy(imp->rev,pcVar5,10);
            iVar3 = lyp_yin_parse_subnode_ext
                              (module,imp,LYEXT_PAR_IMPORT,child,LYEXT_SUBSTMT_REVISIONDATE,'\0',
                               unres);
            goto joined_r0x00152b65;
          }
        }
      }
      else {
        ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
      }
      break;
    }
    if ((1 < ((byte)module->field_0x40 >> 1 & 7)) &&
       (iVar3 = strcmp(child->name,"description"), iVar3 == 0)) {
      if (imp->dsc != (char *)0x0) {
        ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
        break;
      }
      iVar3 = lyp_yin_parse_subnode_ext
                        (module,imp,LYEXT_PAR_IMPORT,child,LYEXT_SUBSTMT_DESCRIPTION,'\0',unres);
      if (iVar3 != 0) break;
      pcVar5 = read_yin_subnode(ctx_00,child,"text");
      imp->dsc = pcVar5;
      if (imp->dsc == (char *)0x0) break;
      goto LAB_00152db3;
    }
    if ((((byte)module->field_0x40 >> 1 & 7) < 2) ||
       (iVar3 = strcmp(child->name,"reference"), iVar3 != 0)) {
      ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
      break;
    }
    if (imp->ref != (char *)0x0) {
      ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
      break;
    }
    iVar3 = lyp_yin_parse_subnode_ext
                      (module,imp,LYEXT_PAR_IMPORT,child,LYEXT_SUBSTMT_REFERENCE,'\0',unres);
    if (iVar3 != 0) break;
    pcVar5 = read_yin_subnode(ctx_00,child,"text");
    imp->ref = pcVar5;
  } while (imp->ref != (char *)0x0);
  goto LAB_0015303a;
LAB_00152f9c:
  pcVar5 = lyxml_get_attr(yin,"module",(char *)0x0);
  if (pcVar5 != (char *)0x0) {
    iVar3 = lyp_check_import(module,pcVar5,imp);
    goto LAB_00153048;
  }
  ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"module",yin->name);
  goto LAB_0015303a;
  while( true ) {
    plVar2 = child->next;
    iVar3 = lyp_yin_fill_ext(imp,LYEXT_PAR_IMPORT,LYEXT_SUBSTMT_SELF,'\0',module,child,&imp->ext,
                             imp->ext_size,unres);
    imp->ext_size = imp->ext_size + '\x01';
    child = plVar2;
    if (iVar3 != 0) break;
LAB_00152f75:
    if (child == (lyxml_elem *)0x0) goto LAB_00152f9c;
  }
LAB_0015303a:
  while (exts.child != (lyxml_elem *)0x0) {
    lyxml_free(ctx_00,exts.child);
  }
  iVar3 = 1;
LAB_00153048:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int fill_yin_include(lys_module *module,lys_submodule *submodule,lyxml_elem *yin,lys_include *inc,
                    unres_schema *unres)

{
  long lVar1;
  ly_ctx *ctx_00;
  lyxml_elem *plVar2;
  int iVar3;
  lys_ext_instance **pplVar4;
  char *pcVar5;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  lys_include *inc_local;
  lyxml_elem *yin_local;
  lys_submodule *submodule_local;
  lys_module *module_local;
  int c_ext;
  int r;
  lyxml_elem *child;
  lyxml_elem *next;
  ly_ctx *ctx;
  void *reallocated;
  char *value;
  lyxml_elem exts;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ctx_00 = module->ctx;
  c_ext = 0;
  memset(&exts,0,0x48);
  plVar2 = yin->child;
  do {
    while( true ) {
      while( true ) {
        while( true ) {
          do {
            child = plVar2;
            if (child == (lyxml_elem *)0x0) {
              if (c_ext == 0) goto LAB_001536be;
              pplVar4 = (lys_ext_instance **)
                        realloc(inc->ext,(long)(int)(c_ext + (uint)inc->ext_size) * 8);
              if (pplVar4 != (lys_ext_instance **)0x0) {
                inc->ext = pplVar4;
                memset(inc->ext + inc->ext_size,0,(long)c_ext * 8);
                child = exts.child;
                goto LAB_00153697;
              }
              ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","fill_yin_include");
              goto LAB_0015375b;
            }
            plVar2 = child->next;
          } while (child->ns == (lyxml_ns *)0x0);
          iVar3 = strcmp(child->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
          if (iVar3 == 0) break;
          if (c_ext == 0xff) {
            ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                   0xff,"extensions","include");
            goto LAB_0015375b;
          }
          c_ext = c_ext + 1;
          lyxml_unlink_elem(ctx_00,child,2);
          lyxml_add_child(ctx_00,&exts,child);
        }
        iVar3 = strcmp(child->name,"revision-date");
        if (iVar3 != 0) break;
        if (inc->rev[0] != '\0') {
          ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,"revision-date",yin->name);
          goto LAB_0015375b;
        }
        pcVar5 = lyxml_get_attr(child,"date",(char *)0x0);
        if (pcVar5 == (char *)0x0) {
          ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213f0d,child->name);
          goto LAB_0015375b;
        }
        iVar3 = lyp_check_date(ctx_00,pcVar5);
        if (iVar3 != 0) goto LAB_0015375b;
        memcpy(inc->rev,pcVar5,10);
        iVar3 = lyp_yin_parse_subnode_ext
                          (module,inc,LYEXT_PAR_INCLUDE,child,LYEXT_SUBSTMT_REVISIONDATE,'\0',unres)
        ;
        if (iVar3 != 0) goto LAB_0015375b;
      }
      if ((((byte)module->field_0x40 >> 1 & 7) < 2) ||
         (iVar3 = strcmp(child->name,"description"), iVar3 != 0)) break;
      if (inc->dsc != (char *)0x0) {
        ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
        goto LAB_0015375b;
      }
      iVar3 = lyp_yin_parse_subnode_ext
                        (module,inc,LYEXT_PAR_INCLUDE,child,LYEXT_SUBSTMT_DESCRIPTION,'\0',unres);
      if (iVar3 != 0) goto LAB_0015375b;
      pcVar5 = read_yin_subnode(ctx_00,child,"text");
      inc->dsc = pcVar5;
      if (inc->dsc == (char *)0x0) goto LAB_0015375b;
    }
    if ((((byte)module->field_0x40 >> 1 & 7) < 2) ||
       (iVar3 = strcmp(child->name,"reference"), iVar3 != 0)) {
      ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
      break;
    }
    if (inc->ref != (char *)0x0) {
      ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
      break;
    }
    iVar3 = lyp_yin_parse_subnode_ext
                      (module,inc,LYEXT_PAR_INCLUDE,child,LYEXT_SUBSTMT_REFERENCE,'\0',unres);
    if (iVar3 != 0) break;
    pcVar5 = read_yin_subnode(ctx_00,child,"text");
    inc->ref = pcVar5;
  } while (inc->ref != (char *)0x0);
  goto LAB_0015375b;
LAB_001536be:
  pcVar5 = lyxml_get_attr(yin,"module",(char *)0x0);
  if (pcVar5 != (char *)0x0) {
    if (submodule != (lys_submodule *)0x0) {
      module = (lys_module *)submodule;
    }
    iVar3 = lyp_check_include(module,pcVar5,inc,unres);
    goto LAB_00153760;
  }
  ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"module",yin->name);
  goto LAB_0015375b;
  while( true ) {
    plVar2 = child->next;
    iVar3 = lyp_yin_fill_ext(inc,LYEXT_PAR_INCLUDE,LYEXT_SUBSTMT_SELF,'\0',module,child,&inc->ext,
                             inc->ext_size,unres);
    inc->ext_size = inc->ext_size + '\x01';
    child = plVar2;
    if (iVar3 != 0) break;
LAB_00153697:
    if (child == (lyxml_elem *)0x0) goto LAB_001536be;
  }
LAB_0015375b:
  iVar3 = -1;
LAB_00153760:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar3;
}



int read_yin_common(lys_module *module,lys_node *parent,void *stmt,LYEXT_PAR stmt_type,
                   lyxml_elem *xmlnode,int opt,unres_schema *unres)

{
  ly_ctx *ctx_00;
  long lVar1;
  lyxml_elem *plVar2;
  undefined8 uVar3;
  ushort uVar4;
  int iVar5;
  char *pcVar6;
  size_t len;
  lyxml_elem *xmlnode_local;
  int opt_local;
  LYEXT_PAR stmt_type_local;
  void *stmt_local;
  lys_node *parent_local;
  lys_module *module_local;
  lyxml_elem *sub;
  lyxml_elem *next;
  char *str;
  lys_node *node;
  ly_ctx *ctx;
  char *value;
  lys_node *p;
  
  ctx_00 = module->ctx;
  if ((opt & 0x10U) != 0) {
    *(lys_module **)((long)stmt + 0x30) = module;
  }
  if ((opt & 1U) == 0) {
LAB_0015387b:
    plVar2 = xmlnode->child;
LAB_00153e25:
    sub = plVar2;
    if (sub != (lyxml_elem *)0x0) {
      plVar2 = sub->next;
      if (sub->ns == (lyxml_ns *)0x0) {
        lyxml_free(ctx_00,sub);
      }
      else {
        iVar5 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar5 == 0) {
          iVar5 = strcmp(sub->name,"description");
          if (iVar5 == 0) {
            if (*(long *)((long)stmt + 8) != 0) {
              ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,sub->name,xmlnode->name);
              goto LAB_001540e4;
            }
            iVar5 = lyp_yin_parse_subnode_ext
                              (module,stmt,stmt_type,sub,LYEXT_SUBSTMT_DESCRIPTION,'\0',unres);
            if (iVar5 != 0) goto LAB_001540e4;
            pcVar6 = read_yin_subnode(ctx_00,sub,"text");
            *(char **)((long)stmt + 8) = pcVar6;
            lVar1 = *(long *)((long)stmt + 8);
joined_r0x00153a73:
            if (lVar1 == 0) goto LAB_001540e4;
          }
          else {
            iVar5 = strcmp(sub->name,"reference");
            if (iVar5 == 0) {
              if (*(long *)((long)stmt + 0x10) == 0) {
                iVar5 = lyp_yin_parse_subnode_ext
                                  (module,stmt,stmt_type,sub,LYEXT_SUBSTMT_REFERENCE,'\0',unres);
                if (iVar5 == 0) {
                  pcVar6 = read_yin_subnode(ctx_00,sub,"text");
                  *(char **)((long)stmt + 0x10) = pcVar6;
                  lVar1 = *(long *)((long)stmt + 0x10);
                  goto joined_r0x00153a73;
                }
              }
              else {
                ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,sub->name,xmlnode->name);
              }
              goto LAB_001540e4;
            }
            iVar5 = strcmp(sub->name,"status");
            if (iVar5 == 0) {
              if ((*(ushort *)((long)stmt + 0x18) & 0x38) != 0) {
                ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,sub->name,xmlnode->name);
                goto LAB_001540e4;
              }
              pcVar6 = lyxml_get_attr(sub,"value",(char *)0x0);
              if (pcVar6 == (char *)0x0) {
                ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                goto LAB_001540e4;
              }
              iVar5 = strcmp(pcVar6,"current");
              if (iVar5 == 0) {
                *(ushort *)((long)stmt + 0x18) = *(ushort *)((long)stmt + 0x18) | 8;
              }
              else {
                iVar5 = strcmp(pcVar6,"deprecated");
                if (iVar5 == 0) {
                  *(ushort *)((long)stmt + 0x18) = *(ushort *)((long)stmt + 0x18) | 0x10;
                }
                else {
                  iVar5 = strcmp(pcVar6,"obsolete");
                  if (iVar5 != 0) {
                    ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,pcVar6,sub->name);
                    goto LAB_001540e4;
                  }
                  *(ushort *)((long)stmt + 0x18) = *(ushort *)((long)stmt + 0x18) | 0x20;
                }
              }
              iVar5 = lyp_yin_parse_subnode_ext
                                (module,stmt,stmt_type,sub,LYEXT_SUBSTMT_STATUS,'\0',unres);
joined_r0x00153dfd:
              if (iVar5 != 0) goto LAB_001540e4;
            }
            else {
              if (((opt & 10U) == 0) || (iVar5 = strcmp(sub->name,"config"), iVar5 != 0))
              goto LAB_00153e25;
              if ((opt & 2U) != 0) {
                if ((*(ushort *)((long)stmt + 0x18) & 3) == 0) {
                  pcVar6 = lyxml_get_attr(sub,"value",(char *)0x0);
                  if (pcVar6 != (char *)0x0) {
                    iVar5 = strcmp(pcVar6,"false");
                    if (iVar5 == 0) {
                      *(ushort *)((long)stmt + 0x18) = *(ushort *)((long)stmt + 0x18) | 2;
                    }
                    else {
                      iVar5 = strcmp(pcVar6,"true");
                      if (iVar5 != 0) {
                        ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,pcVar6,sub->name);
                        goto LAB_001540e4;
                      }
                      *(ushort *)((long)stmt + 0x18) = *(ushort *)((long)stmt + 0x18) | 1;
                    }
                    *(ushort *)((long)stmt + 0x18) = *(ushort *)((long)stmt + 0x18) | 4;
                    iVar5 = lyp_yin_parse_subnode_ext
                                      (module,stmt,stmt_type,sub,LYEXT_SUBSTMT_CONFIG,'\0',unres);
                    goto joined_r0x00153dfd;
                  }
                  ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                }
                else {
                  ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,sub->name,xmlnode->name);
                }
                goto LAB_001540e4;
              }
            }
          }
          lyxml_free(ctx_00,sub);
        }
      }
      goto LAB_00153e25;
    }
    if (((opt & 4U) != 0) && ((*(ushort *)((long)stmt + 0x18) & 3) == 0)) {
      if (parent == (lys_node *)0x0) {
        if (true) {
          *(ushort *)((long)stmt + 0x18) = *(ushort *)((long)stmt + 0x18) | 1;
        }
      }
      else {
        *(uint16_t *)((long)stmt + 0x18) = parent->flags & 3 | *(ushort *)((long)stmt + 0x18);
      }
    }
    if ((parent != (lys_node *)0x0) && ((parent->flags & 0x30) != 0)) {
      if ((*(ushort *)((long)stmt + 0x18) & 0x38) == 0) {
        if (stmt_type == LYEXT_PAR_NODE) {
          uVar3 = *(undefined8 *)((long)stmt + 0x40);
          *(lys_node **)((long)stmt + 0x40) = parent;
          str = lys_path((lys_node *)stmt,1);
          *(undefined8 *)((long)stmt + 0x40) = uVar3;
        }
        else {
          str = lys_path(parent,1);
        }
        if ((parent->flags & 0x10) == 0) {
          pcVar6 = "obsolete";
        }
        else {
          pcVar6 = "deprecated";
        }
        ly_log(ctx_00,LY_LLWRN,LY_SUCCESS,"Missing status in %s subtree (%s), inheriting.",pcVar6,
               str);
        free(str);
        *(uint16_t *)((long)stmt + 0x18) = parent->flags & 0x38 | *(ushort *)((long)stmt + 0x18);
      }
      else if ((*(ushort *)((long)stmt + 0x18) & 0x38) < (parent->flags & 0x38)) {
        uVar4 = *(ushort *)((long)stmt + 0x18) & 0x38;
        if (uVar4 == 0x10) {
          ly_vlog(ctx_00,LYE_INSTATUS,LY_VLOG_LYS,parent,"deprecated",xmlnode->name,"is child of",
                  "obsolete",parent->name);
        }
        else if ((uVar4 < 0x11) && (((*(ushort *)((long)stmt + 0x18) & 0x38) == 0 || (uVar4 == 8))))
        {
          if ((parent->flags & 0x10) == 0) {
            pcVar6 = "obsolete";
          }
          else {
            pcVar6 = "deprecated";
          }
          ly_vlog(ctx_00,LYE_INSTATUS,LY_VLOG_LYS,parent,"current",xmlnode->name,"is child of",
                  pcVar6,parent->name);
        }
        goto LAB_001540e4;
      }
    }
    iVar5 = 0;
  }
  else {
    pcVar6 = lyxml_get_attr(xmlnode,"name",(char *)0x0);
    if (pcVar6 == (char *)0x0) {
      ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,xmlnode->name);
    }
    else {
      iVar5 = lyp_check_identifier(ctx_00,pcVar6,LY_IDENT_NAME,(lys_module *)0x0,(lys_node *)0x0);
      if (iVar5 == 0) {
        len = strlen(pcVar6);
        pcVar6 = lydict_insert(ctx_00,pcVar6,len);
        *(char **)stmt = pcVar6;
        goto LAB_0015387b;
      }
    }
LAB_001540e4:
    iVar5 = 1;
  }
  return iVar5;
}



lys_when * read_yin_when(lys_module *module,lyxml_elem *yin,unres_schema *unres)

{
  ly_ctx *ctx_00;
  lyxml_elem *plVar1;
  int iVar2;
  lys_when *w;
  char *pcVar3;
  unres_schema *unres_local;
  lyxml_elem *yin_local;
  lys_module *module_local;
  lyxml_elem *child;
  lyxml_elem *next;
  ly_ctx *ctx;
  lys_when *retval;
  char *value;
  
  ctx_00 = module->ctx;
  w = (lys_when *)calloc(1,0x28);
  if (w == (lys_when *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_when");
  }
  else {
    pcVar3 = lyxml_get_attr(yin,"condition",(char *)0x0);
    if (pcVar3 == (char *)0x0) {
      ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"condition",yin->name);
    }
    else {
      pcVar3 = transform_schema2json(module,pcVar3);
      w->cond = pcVar3;
      if (w->cond != (char *)0x0) {
        plVar1 = yin->child;
        do {
          while( true ) {
            while( true ) {
              do {
                child = plVar1;
                if (child == (lyxml_elem *)0x0) {
                  return w;
                }
                plVar1 = child->next;
              } while (child->ns == (lyxml_ns *)0x0);
              iVar2 = strcmp(child->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
              if (iVar2 == 0) break;
              iVar2 = lyp_yin_parse_subnode_ext
                                (module,w,LYEXT_PAR_WHEN,child,LYEXT_SUBSTMT_SELF,'\0',unres);
              if (iVar2 != 0) goto LAB_0015447f;
            }
            iVar2 = strcmp(child->name,"description");
            if (iVar2 != 0) break;
            if (w->dsc != (char *)0x0) {
              ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
              goto LAB_0015447f;
            }
            iVar2 = lyp_yin_parse_subnode_ext
                              (module,w,LYEXT_PAR_WHEN,child,LYEXT_SUBSTMT_DESCRIPTION,'\0',unres);
            if (iVar2 != 0) goto LAB_0015447f;
            pcVar3 = read_yin_subnode(ctx_00,child,"text");
            w->dsc = pcVar3;
            if (w->dsc == (char *)0x0) goto LAB_0015447f;
          }
          iVar2 = strcmp(child->name,"reference");
          if (iVar2 != 0) {
            ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
            break;
          }
          if (w->ref != (char *)0x0) {
            ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
            break;
          }
          iVar2 = lyp_yin_parse_subnode_ext
                            (module,w,LYEXT_PAR_WHEN,child,LYEXT_SUBSTMT_REFERENCE,'\0',unres);
          if (iVar2 != 0) break;
          pcVar3 = read_yin_subnode(ctx_00,child,"text");
          w->ref = pcVar3;
        } while (w->ref != (char *)0x0);
      }
    }
LAB_0015447f:
    lys_when_free(ctx_00,w,(_func_void_lys_node_ptr_void_ptr *)0x0);
  }
  return (lys_when *)0x0;
}



lys_node *
read_yin_case(lys_module *module,lys_node *parent,lyxml_elem *yin,int options,unres_schema *unres)

{
  long lVar1;
  ly_ctx *ctx_00;
  long lVar2;
  long lVar3;
  lyxml_elem *plVar4;
  long lVar5;
  int iVar6;
  lys_node *child;
  lys_module *module_00;
  lys_when *plVar7;
  lys_iffeature *plVar8;
  lys_ext_instance **pplVar9;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  int options_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int c_ftrs;
  int c_ext;
  int ret;
  lyxml_elem *sub;
  lyxml_elem *next;
  lys_node *node;
  ly_ctx *ctx;
  lys_node_case *cs;
  lys_node *retval;
  void *reallocated;
  lyxml_elem root;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ctx_00 = module->ctx;
  node = (lys_node *)0x0;
  c_ftrs = 0;
  c_ext = 0;
  memset(&root,0,0x48);
  child = (lys_node *)calloc(1,0x70);
  if (child == (lys_node *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_case");
    child = (lys_node *)0x0;
    goto LAB_00154fcf;
  }
  child->nodetype = LYS_CASE;
  child->prev = child;
  if ((options & 3U) == 0) {
    iVar6 = 0x15;
  }
  else {
    iVar6 = 0x11;
  }
  iVar6 = read_yin_common(module,parent,child,LYEXT_PAR_NODE,yin,iVar6,unres);
  if (iVar6 == 0) {
    ly_log_dbg(4,"parsing %s statement \"%s\"",yin->name,child->name);
    module_00 = lys_main_module(module);
    iVar6 = lys_node_addchild(parent,module_00,child,options);
    if (iVar6 == 0) {
      sub = yin->child;
      while (sub != (lyxml_elem *)0x0) {
        plVar4 = sub->next;
        iVar6 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar6 == 0) {
          iVar6 = strcmp(sub->name,"container");
          if (((((iVar6 == 0) || (iVar6 = strcmp(sub->name,"leaf-list"), iVar6 == 0)) ||
               (iVar6 = strcmp(sub->name,"leaf"), iVar6 == 0)) ||
              ((iVar6 = strcmp(sub->name,"list"), iVar6 == 0 ||
               (iVar6 = strcmp(sub->name,"uses"), iVar6 == 0)))) ||
             ((iVar6 = strcmp(sub->name,"choice"), iVar6 == 0 ||
              ((iVar6 = strcmp(sub->name,"anyxml"), iVar6 == 0 ||
               (iVar6 = strcmp(sub->name,"anydata"), iVar6 == 0)))))) {
            lyxml_unlink_elem(ctx_00,sub,2);
            lyxml_add_child(ctx_00,&root,sub);
            sub = plVar4;
          }
          else {
            iVar6 = strcmp(sub->name,"if-feature");
            if (iVar6 == 0) {
              if (c_ftrs == 0xff) {
                ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement."
                       ,0xff,"if-features",&DAT_002145f6);
                goto LAB_00154fab;
              }
              c_ftrs = c_ftrs + 1;
              sub = plVar4;
            }
            else {
              iVar6 = strcmp(sub->name,"when");
              if (iVar6 != 0) {
                ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_LYS,child,sub->name);
                goto LAB_00154fab;
              }
              lVar2._0_1_ = child->hash[0];
              lVar2._1_1_ = child->hash[1];
              lVar2._2_1_ = child->hash[2];
              lVar2._3_1_ = child->hash[3];
              lVar2._4_4_ = *(undefined4 *)&child->field_0x6c;
              if (lVar2 != 0) {
                ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
                goto LAB_00154fab;
              }
              plVar7 = read_yin_when(module,sub,unres);
              *(lys_when **)child->hash = plVar7;
              lVar3._0_1_ = child->hash[0];
              lVar3._1_1_ = child->hash[1];
              lVar3._2_1_ = child->hash[2];
              lVar3._3_1_ = child->hash[3];
              lVar3._4_4_ = *(undefined4 *)&child->field_0x6c;
              if (lVar3 == 0) goto LAB_00154fab;
              lyxml_free(ctx_00,sub);
              sub = plVar4;
            }
          }
        }
        else {
          if (c_ext == 0xff) {
            ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                   0xff,"extensions",&DAT_002145f6);
            goto LAB_00154fab;
          }
          c_ext = c_ext + 1;
          sub = plVar4;
        }
      }
      if (c_ftrs != 0) {
        plVar8 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
        child->iffeature = plVar8;
        if (child->iffeature == (lys_iffeature *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_case");
          goto LAB_00154fab;
        }
      }
      if (c_ext != 0) {
        pplVar9 = (lys_ext_instance **)
                  realloc(child->ext,(long)(int)(c_ext + (uint)child->ext_size) * 8);
        if (pplVar9 == (lys_ext_instance **)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_case");
          goto LAB_00154fab;
        }
        child->ext = pplVar9;
        memset(child->ext + child->ext_size,0,(long)c_ext * 8);
      }
      sub = yin->child;
      do {
        while( true ) {
          if (sub == (lyxml_elem *)0x0) {
            sub = root.child;
            goto LAB_00154eef;
          }
          plVar4 = sub->next;
          iVar6 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
          if (iVar6 == 0) break;
          iVar6 = lyp_yin_fill_ext(child,LYEXT_PAR_NODE,LYEXT_SUBSTMT_SELF,'\0',module,sub,
                                   &child->ext,child->ext_size,unres);
          child->ext_size = child->ext_size + '\x01';
          sub = plVar4;
          if (iVar6 != 0) goto LAB_00154fab;
        }
        iVar6 = fill_yin_iffeature(child,0,sub,child->iffeature + child->iffeature_size,unres);
        child->iffeature_size = child->iffeature_size + '\x01';
        sub = plVar4;
      } while (iVar6 == 0);
    }
  }
  goto LAB_00154fab;
LAB_00154eef:
  if (sub == (lyxml_elem *)0x0) goto code_r0x00154f1c;
  plVar4 = sub->next;
  iVar6 = strcmp(sub->name,"container");
  if (iVar6 == 0) {
    node = read_yin_container(module,child,sub,options,unres);
  }
  else {
    iVar6 = strcmp(sub->name,"leaf-list");
    if (iVar6 == 0) {
      node = read_yin_leaflist(module,child,sub,options,unres);
    }
    else {
      iVar6 = strcmp(sub->name,"leaf");
      if (iVar6 == 0) {
        node = read_yin_leaf(module,child,sub,options,unres);
      }
      else {
        iVar6 = strcmp(sub->name,"list");
        if (iVar6 == 0) {
          node = read_yin_list(module,child,sub,options,unres);
        }
        else {
          iVar6 = strcmp(sub->name,"choice");
          if (iVar6 == 0) {
            node = read_yin_choice(module,child,sub,options,unres);
          }
          else {
            iVar6 = strcmp(sub->name,"uses");
            if (iVar6 == 0) {
              node = read_yin_uses(module,child,sub,options,unres);
            }
            else {
              iVar6 = strcmp(sub->name,"anyxml");
              if (iVar6 == 0) {
                node = read_yin_anydata(module,child,sub,LYS_ANYXML,options,unres);
              }
              else {
                iVar6 = strcmp(sub->name,"anydata");
                if (iVar6 == 0) {
                  node = read_yin_anydata(module,child,sub,LYS_ANYDATA,options,unres);
                }
              }
            }
          }
        }
      }
    }
  }
  if (node == (lys_node *)0x0) goto LAB_00154fab;
  lyxml_free(ctx_00,sub);
  sub = plVar4;
  goto LAB_00154eef;
code_r0x00154f1c:
  if ((((ctx_00->models).flags & 2U) != 0) ||
     (lVar5._0_1_ = child->hash[0], lVar5._1_1_ = child->hash[1], lVar5._2_1_ = child->hash[2],
     lVar5._3_1_ = child->hash[3], lVar5._4_4_ = *(undefined4 *)&child->field_0x6c, lVar5 == 0))
  goto LAB_00154fcf;
  if ((options & 4U) == 0) {
    iVar6 = unres_schema_add_node(module,unres,child,UNRES_XPATH,(lys_node *)0x0);
    if (iVar6 != -1) goto LAB_00154fcf;
  }
  else {
    iVar6 = lyxp_node_check_syntax(child);
    if (iVar6 == 0) goto LAB_00154fcf;
  }
LAB_00154fab:
  while (root.child != (lyxml_elem *)0x0) {
    lyxml_free(ctx_00,root.child);
  }
  lys_node_free(child,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
  child = (lys_node *)0x0;
LAB_00154fcf:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return child;
}



// WARNING: Type propagation algorithm not settling

lys_node *
read_yin_choice(lys_module *module,lys_node *parent,lyxml_elem *yin,int options,unres_schema *unres)

{
  ly_ctx *ctx_00;
  long lVar1;
  lyxml_elem *plVar2;
  long lVar3;
  bool bVar4;
  int iVar5;
  lys_node *child;
  lys_module *module_00;
  lys_node *plVar6;
  lys_when *plVar7;
  lys_iffeature *plVar8;
  lys_ext_instance **pplVar9;
  char *pcVar10;
  unres_schema *unres_local;
  int options_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int f_mand;
  int c_ftrs;
  int c_ext;
  int ret;
  lyxml_elem *sub;
  lyxml_elem *next;
  lyxml_elem *dflt;
  ly_ctx *ctx;
  lys_node *node;
  lys_node_choice *choice;
  lys_node *retval;
  void *reallocated;
  char *value;
  
  dflt = (lyxml_elem *)0x0;
  ctx_00 = module->ctx;
  bVar4 = false;
  c_ftrs = 0;
  c_ext = 0;
  child = (lys_node *)calloc(1,0x78);
  if (child == (lys_node *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_choice");
    return (lys_node *)0x0;
  }
  child->nodetype = LYS_CHOICE;
  child->prev = child;
  if ((options & 2U) == 0) {
    if ((options & 1U) == 0) {
      iVar5 = 0x17;
    }
    else {
      iVar5 = 0x13;
    }
  }
  else {
    iVar5 = 0x19;
  }
  iVar5 = read_yin_common(module,parent,child,LYEXT_PAR_NODE,yin,iVar5,unres);
  if (iVar5 != 0) goto LAB_00155c2b;
  ly_log_dbg(4,"parsing %s statement \"%s\"",yin->name,child->name);
  module_00 = lys_main_module(module);
  iVar5 = lys_node_addchild(parent,module_00,child,options);
  if (iVar5 != 0) goto LAB_00155c2b;
  sub = yin->child;
LAB_00155845:
  if (sub == (lyxml_elem *)0x0) goto code_r0x0015586c;
  plVar2 = sub->next;
  iVar5 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
  if (iVar5 != 0) {
    if (c_ext == 0xff) {
      ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",0xff,
             "extensions","choice");
      goto LAB_00155c2b;
    }
    c_ext = c_ext + 1;
    sub = plVar2;
    goto LAB_00155845;
  }
  iVar5 = strcmp(sub->name,"container");
  if (iVar5 == 0) {
    plVar6 = read_yin_container(module,child,sub,options,unres);
  }
  else {
    iVar5 = strcmp(sub->name,"leaf-list");
    if (iVar5 == 0) {
      plVar6 = read_yin_leaflist(module,child,sub,options,unres);
      goto joined_r0x00155316;
    }
    iVar5 = strcmp(sub->name,"leaf");
    if (iVar5 == 0) {
      plVar6 = read_yin_leaf(module,child,sub,options,unres);
      goto joined_r0x00155316;
    }
    iVar5 = strcmp(sub->name,"list");
    if (iVar5 == 0) {
      plVar6 = read_yin_list(module,child,sub,options,unres);
      goto joined_r0x00155316;
    }
    iVar5 = strcmp(sub->name,"case");
    if (iVar5 == 0) {
      plVar6 = read_yin_case(module,child,sub,options,unres);
      goto joined_r0x00155316;
    }
    iVar5 = strcmp(sub->name,"anyxml");
    if (iVar5 == 0) {
      plVar6 = read_yin_anydata(module,child,sub,LYS_ANYXML,options,unres);
      goto joined_r0x00155316;
    }
    iVar5 = strcmp(sub->name,"anydata");
    if (iVar5 == 0) {
      plVar6 = read_yin_anydata(module,child,sub,LYS_ANYDATA,options,unres);
      goto joined_r0x00155316;
    }
    iVar5 = strcmp(sub->name,"default");
    if (iVar5 == 0) {
      if (dflt != (lyxml_elem *)0x0) {
        ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
        goto LAB_00155c2b;
      }
      iVar5 = lyp_yin_parse_subnode_ext
                        (module,child,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_DEFAULT,'\0',unres);
      if (iVar5 != 0) goto LAB_00155c2b;
      dflt = sub;
      lyxml_unlink_elem(ctx_00,sub,0);
      sub = plVar2;
      goto LAB_00155845;
    }
    iVar5 = strcmp(sub->name,"mandatory");
    if (iVar5 == 0) {
      if (bVar4) {
        ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
        goto LAB_00155c2b;
      }
      bVar4 = true;
      pcVar10 = lyxml_get_attr(sub,"value",(char *)0x0);
      if (pcVar10 == (char *)0x0) {
        ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
        goto LAB_00155c2b;
      }
      iVar5 = strcmp(pcVar10,"true");
      if (iVar5 == 0) {
        child->flags = child->flags | 0x40;
      }
      else {
        iVar5 = strcmp(pcVar10,"false");
        if (iVar5 != 0) {
          ly_vlog(ctx_00,LYE_INARG,LY_VLOG_LYS,child,pcVar10,sub->name);
          goto LAB_00155c2b;
        }
        child->flags = child->flags | 0x80;
      }
      iVar5 = lyp_yin_parse_subnode_ext
                        (module,child,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_MANDATORY,'\0',unres);
      if (iVar5 != 0) goto LAB_00155c2b;
      goto LAB_00155822;
    }
    iVar5 = strcmp(sub->name,"when");
    if (iVar5 == 0) {
      lVar1._0_1_ = child->hash[0];
      lVar1._1_1_ = child->hash[1];
      lVar1._2_1_ = child->hash[2];
      lVar1._3_1_ = child->hash[3];
      lVar1._4_4_ = *(undefined4 *)&child->field_0x6c;
      if (lVar1 == 0) {
        plVar7 = read_yin_when(module,sub,unres);
        *(lys_when **)child->hash = plVar7;
        plVar6._0_1_ = child->hash[0];
        plVar6._1_1_ = child->hash[1];
        plVar6._2_1_ = child->hash[2];
        plVar6._3_1_ = child->hash[3];
        plVar6._4_4_ = *(undefined4 *)&child->field_0x6c;
        goto joined_r0x00155316;
      }
      ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
      goto LAB_00155c2b;
    }
    iVar5 = strcmp(sub->name,"if-feature");
    if (iVar5 == 0) {
      if (c_ftrs == 0xff) {
        ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",0xff,
               "if-features","choice");
        goto LAB_00155c2b;
      }
      c_ftrs = c_ftrs + 1;
      sub = plVar2;
      goto LAB_00155845;
    }
    if ((((byte)module->field_0x40 >> 1 & 7) < 2) ||
       (iVar5 = strcmp(sub->name,"choice"), iVar5 != 0)) {
      ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_LYS,child,sub->name);
      goto LAB_00155c2b;
    }
    plVar6 = read_yin_choice(module,child,sub,options,unres);
  }
joined_r0x00155316:
  if (plVar6 == (lys_node *)0x0) goto LAB_00155c2b;
LAB_00155822:
  lyxml_free(ctx_00,sub);
  sub = plVar2;
  goto LAB_00155845;
code_r0x0015586c:
  if (c_ftrs != 0) {
    plVar8 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
    child->iffeature = plVar8;
    if (child->iffeature == (lys_iffeature *)0x0) {
      ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_choice");
      goto LAB_00155c2b;
    }
  }
  if (c_ext != 0) {
    pplVar9 = (lys_ext_instance **)
              realloc(child->ext,(long)(int)(c_ext + (uint)child->ext_size) * 8);
    if (pplVar9 == (lys_ext_instance **)0x0) {
      ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_choice");
      goto LAB_00155c2b;
    }
    child->ext = pplVar9;
    memset(child->ext + child->ext_size,0,(long)c_ext * 8);
  }
  sub = yin->child;
  do {
    while( true ) {
      if (sub == (lyxml_elem *)0x0) {
        if ((dflt != (lyxml_elem *)0x0) && ((child->flags & 0x40) != 0)) {
          ly_vlog(ctx_00,LYE_INCHILDSTMT,LY_VLOG_LYS,child,"default","choice");
          ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                  "The \"default\" statement is forbidden on choices with \"mandatory\".");
          goto LAB_00155c2b;
        }
        if (dflt != (lyxml_elem *)0x0) {
          pcVar10 = lyxml_get_attr(dflt,"value",(char *)0x0);
          if (pcVar10 == (char *)0x0) {
            ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",dflt->name);
            goto LAB_00155c2b;
          }
          iVar5 = unres_schema_add_str(module,unres,child,UNRES_CHOICE_DFLT,pcVar10);
          if (iVar5 == -1) goto LAB_00155c2b;
          lyxml_free(ctx_00,dflt);
        }
        if (((ctx_00->models).flags & 2U) != 0) {
          return child;
        }
        lVar3._0_1_ = child->hash[0];
        lVar3._1_1_ = child->hash[1];
        lVar3._2_1_ = child->hash[2];
        lVar3._3_1_ = child->hash[3];
        lVar3._4_4_ = *(undefined4 *)&child->field_0x6c;
        if (lVar3 == 0) {
          return child;
        }
        if ((options & 4U) == 0) {
          iVar5 = unres_schema_add_node(module,unres,child,UNRES_XPATH,(lys_node *)0x0);
          if (iVar5 != -1) {
            return child;
          }
        }
        else {
          iVar5 = lyxp_node_check_syntax(child);
          if (iVar5 == 0) {
            return child;
          }
        }
        goto LAB_00155c2b;
      }
      plVar2 = sub->next;
      iVar5 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
      if (iVar5 == 0) break;
      iVar5 = lyp_yin_fill_ext(child,LYEXT_PAR_NODE,LYEXT_SUBSTMT_SELF,'\0',module,sub,&child->ext,
                               child->ext_size,unres);
      child->ext_size = child->ext_size + '\x01';
      sub = plVar2;
      if (iVar5 != 0) goto LAB_00155c2b;
    }
    iVar5 = fill_yin_iffeature(child,0,sub,child->iffeature + child->iffeature_size,unres);
    child->iffeature_size = child->iffeature_size + '\x01';
    sub = plVar2;
  } while (iVar5 == 0);
LAB_00155c2b:
  lyxml_free(ctx_00,dflt);
  lys_node_free(child,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
  return (lys_node *)0x0;
}



lys_node *
read_yin_anydata(lys_module *module,lys_node *parent,lyxml_elem *yin,LYS_NODE type,int options,
                unres_schema *unres)

{
  ly_ctx *ctx_00;
  lyxml_elem *plVar1;
  bool bVar2;
  int iVar3;
  lys_node *child;
  lys_module *module_00;
  lys_when *plVar4;
  char *pcVar5;
  lys_iffeature *plVar6;
  lys_ext_instance **pplVar7;
  unres_schema *unres_local;
  int options_local;
  LYS_NODE type_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int r;
  int f_mand;
  int c_must;
  int c_ftrs;
  int c_ext;
  lyxml_elem *sub;
  lyxml_elem *next;
  ly_ctx *ctx;
  lys_node_anydata *anyxml;
  lys_node *retval;
  void *reallocated;
  char *value;
  
  ctx_00 = module->ctx;
  bVar2 = false;
  c_must = 0;
  c_ftrs = 0;
  c_ext = 0;
  child = (lys_node *)calloc(1,0x80);
  if (child == (lys_node *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_anydata");
    return (lys_node *)0x0;
  }
  child->nodetype = type;
  child->prev = child;
  if ((options & 2U) == 0) {
    if ((options & 1U) == 0) {
      iVar3 = 0x17;
    }
    else {
      iVar3 = 0x13;
    }
  }
  else {
    iVar3 = 0x19;
  }
  iVar3 = read_yin_common(module,parent,child,LYEXT_PAR_NODE,yin,iVar3,unres);
  if (iVar3 == 0) {
    ly_log_dbg(4,"parsing %s statement \"%s\"",yin->name,child->name);
    module_00 = lys_main_module(module);
    iVar3 = lys_node_addchild(parent,module_00,child,options);
    if (iVar3 == 0) {
      sub = yin->child;
      while (sub != (lyxml_elem *)0x0) {
        plVar1 = sub->next;
        iVar3 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar3 == 0) {
          iVar3 = strcmp(sub->name,"mandatory");
          if (iVar3 == 0) {
            if (bVar2) {
              ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
              goto LAB_001565f2;
            }
            bVar2 = true;
            pcVar5 = lyxml_get_attr(sub,"value",(char *)0x0);
            if (pcVar5 == (char *)0x0) {
              ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
              goto LAB_001565f2;
            }
            iVar3 = strcmp(pcVar5,"true");
            if (iVar3 == 0) {
              child->flags = child->flags | 0x40;
            }
            else {
              iVar3 = strcmp(pcVar5,"false");
              if (iVar3 != 0) {
                ly_vlog(ctx_00,LYE_INARG,LY_VLOG_LYS,child,pcVar5,sub->name);
                goto LAB_001565f2;
              }
              child->flags = child->flags | 0x80;
            }
            iVar3 = lyp_yin_parse_subnode_ext
                              (module,child,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_MANDATORY,'\0',unres);
            if (iVar3 != 0) goto LAB_001565f2;
            lyxml_free(ctx_00,sub);
            sub = plVar1;
          }
          else {
            iVar3 = strcmp(sub->name,"when");
            if (iVar3 == 0) {
              if (child[1].name != (char *)0x0) {
                ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
                goto LAB_001565f2;
              }
              plVar4 = read_yin_when(module,sub,unres);
              child[1].name = (char *)plVar4;
              if (child[1].name == (char *)0x0) {
                lyxml_free(ctx_00,sub);
                goto LAB_001565f2;
              }
              lyxml_free(ctx_00,sub);
              sub = plVar1;
            }
            else {
              iVar3 = strcmp(sub->name,"must");
              if (iVar3 == 0) {
                if (c_must == 0xff) {
                  ly_log(ctx_00,LY_LLERR,LY_EINT,
                         "Reached limit (%lu) for storing %s in %s statement.",0xff,"musts",
                         "anydata");
                  goto LAB_001565f2;
                }
                c_must = c_must + 1;
                sub = plVar1;
              }
              else {
                iVar3 = strcmp(sub->name,"if-feature");
                if (iVar3 != 0) {
                  ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_LYS,child,sub->name);
                  goto LAB_001565f2;
                }
                if (c_ftrs == 0xff) {
                  ly_log(ctx_00,LY_LLERR,LY_EINT,
                         "Reached limit (%lu) for storing %s in %s statement.",0xff,"if-features",
                         "anydata");
                  goto LAB_001565f2;
                }
                c_ftrs = c_ftrs + 1;
                sub = plVar1;
              }
            }
          }
        }
        else {
          if (c_ext == 0xff) {
            ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                   0xff,"extensions","anydata");
            goto LAB_001565f2;
          }
          c_ext = c_ext + 1;
          sub = plVar1;
        }
      }
      if (c_must != 0) {
        pcVar5 = (char *)calloc((long)c_must,0x38);
        child[1].dsc = pcVar5;
        if (child[1].dsc == (char *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_anydata");
          goto LAB_001565f2;
        }
      }
      if (c_ftrs != 0) {
        plVar6 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
        child->iffeature = plVar6;
        if (child->iffeature == (lys_iffeature *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_anydata");
          goto LAB_001565f2;
        }
      }
      if (c_ext != 0) {
        pplVar7 = (lys_ext_instance **)
                  realloc(child->ext,(long)(int)(c_ext + (uint)child->ext_size) * 8);
        if (pplVar7 == (lys_ext_instance **)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_anydata");
          goto LAB_001565f2;
        }
        child->ext = pplVar7;
        memset(child->ext + child->ext_size,0,(long)c_ext * 8);
      }
      plVar1 = yin->child;
      do {
        do {
          while( true ) {
            sub = plVar1;
            if (sub == (lyxml_elem *)0x0) {
              if ((((ctx_00->models).flags & 2U) == 0) &&
                 ((child[1].name != (char *)0x0 || (child[1].dsc != (char *)0x0)))) {
                if ((options & 4U) == 0) {
                  iVar3 = unres_schema_add_node(module,unres,child,UNRES_XPATH,(lys_node *)0x0);
                  if (iVar3 == -1) goto LAB_001565f2;
                }
                else {
                  iVar3 = lyxp_node_check_syntax(child);
                  if (iVar3 != 0) goto LAB_001565f2;
                }
              }
              r = 0;
              while( true ) {
                if ((int)(uint)child->ext_size <= r) {
                  return child;
                }
                if ((child->ext[r]->flags & 8) != 0) break;
                r = r + 1;
              }
              child->flags = child->flags | 0x2000;
              return child;
            }
            plVar1 = sub->next;
            iVar3 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
            if (iVar3 == 0) break;
            iVar3 = lyp_yin_fill_ext(child,LYEXT_PAR_NODE,LYEXT_SUBSTMT_SELF,'\0',module,sub,
                                     &child->ext,child->ext_size,unres);
            child->ext_size = child->ext_size + '\x01';
joined_r0x00156473:
            if (iVar3 != 0) goto LAB_001565f2;
          }
          iVar3 = strcmp(sub->name,"must");
          if (iVar3 == 0) {
            iVar3 = fill_yin_must(module,sub,
                                  (lys_restr *)(child[1].dsc + (ulong)child->padding[3] * 0x38),
                                  unres);
            child->padding[3] = child->padding[3] + '\x01';
            goto joined_r0x00156473;
          }
          iVar3 = strcmp(sub->name,"if-feature");
        } while (iVar3 != 0);
        iVar3 = fill_yin_iffeature(child,0,sub,child->iffeature + child->iffeature_size,unres);
        child->iffeature_size = child->iffeature_size + '\x01';
      } while (iVar3 == 0);
    }
  }
LAB_001565f2:
  lys_node_free(child,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
  return (lys_node *)0x0;
}



// WARNING: Type propagation algorithm not settling

lys_node *
read_yin_leaf(lys_module *module,lys_node *parent,lyxml_elem *yin,int options,unres_schema *unres)

{
  ly_ctx *ctx_00;
  lyxml_elem *plVar1;
  bool bVar2;
  bool bVar3;
  int iVar4;
  lys_node *child;
  lys_module *module_00;
  size_t sVar5;
  lys_node *plVar6;
  lys_when *plVar7;
  char *pcVar8;
  lys_iffeature *plVar9;
  lys_ext_instance **pplVar10;
  unres_schema *unres_local;
  int options_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int r;
  int has_type;
  int c_must;
  int c_ftrs;
  int f_mand;
  int c_ext;
  lyxml_elem *sub;
  lyxml_elem *next;
  ly_ctx *ctx;
  lys_node_leaf *leaf;
  lys_node *retval;
  void *reallocated;
  char *value;
  
  ctx_00 = module->ctx;
  bVar2 = false;
  c_must = 0;
  c_ftrs = 0;
  bVar3 = false;
  c_ext = 0;
  child = (lys_node *)calloc(1,0xd0);
  if (child == (lys_node *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_leaf");
    return (lys_node *)0x0;
  }
  child->nodetype = LYS_LEAF;
  child->prev = child;
  if ((options & 2U) == 0) {
    if ((options & 1U) == 0) {
      iVar4 = 0x17;
    }
    else {
      iVar4 = 0x13;
    }
  }
  else {
    iVar4 = 0x19;
  }
  iVar4 = read_yin_common(module,parent,child,LYEXT_PAR_NODE,yin,iVar4,unres);
  if (iVar4 == 0) {
    ly_log_dbg(4,"parsing %s statement \"%s\"",yin->name,child->name);
    module_00 = lys_main_module(module);
    iVar4 = lys_node_addchild(parent,module_00,child,options);
    if (iVar4 == 0) {
      sub = yin->child;
LAB_00156e38:
      do {
        while( true ) {
          while( true ) {
            while( true ) {
              if (sub == (lyxml_elem *)0x0) {
                if (!bVar2) {
                  ly_vlog(ctx_00,LYE_MISSCHILDSTMT,LY_VLOG_LYS,child,&DAT_00213b02,yin->name);
                  goto LAB_0015739c;
                }
                if ((child[1].prev != (lys_node *)0x0) && ((child->flags & 0x40) != 0)) {
                  ly_vlog(ctx_00,LYE_INCHILDSTMT,LY_VLOG_LYS,child,"mandatory",&DAT_002145e0);
                  ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                          "The \"mandatory\" statement is forbidden on leaf with the \"default\" statement."
                         );
                  goto LAB_0015739c;
                }
                if (c_must != 0) {
                  pcVar8 = (char *)calloc((long)c_must,0x38);
                  child[1].dsc = pcVar8;
                  if (child[1].dsc == (char *)0x0) {
                    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                           "read_yin_leaf");
                    goto LAB_0015739c;
                  }
                }
                if (c_ftrs != 0) {
                  plVar9 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
                  child->iffeature = plVar9;
                  if (child->iffeature == (lys_iffeature *)0x0) {
                    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                           "read_yin_leaf");
                    goto LAB_0015739c;
                  }
                }
                if (c_ext != 0) {
                  pplVar10 = (lys_ext_instance **)
                             realloc(child->ext,(long)(int)(c_ext + (uint)child->ext_size) * 8);
                  if (pplVar10 == (lys_ext_instance **)0x0) {
                    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                           "read_yin_leaf");
                    goto LAB_0015739c;
                  }
                  child->ext = pplVar10;
                  memset(child->ext + child->ext_size,0,(long)c_ext * 8);
                }
                plVar1 = yin->child;
                goto LAB_00157218;
              }
              plVar1 = sub->next;
              iVar4 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
              if (iVar4 == 0) break;
              if (c_ext == 0xff) {
                ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement."
                       ,0xff,"extensions",&DAT_002145e0);
                goto LAB_0015739c;
              }
              c_ext = c_ext + 1;
              sub = plVar1;
            }
            iVar4 = strcmp(sub->name,"type");
            if (iVar4 != 0) break;
            if (bVar2) {
              ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
              goto LAB_0015739c;
            }
            child[1].ext = (lys_ext_instance **)sub;
            child[1].iffeature = (lys_iffeature *)child;
            bVar2 = true;
            sub = plVar1;
          }
          iVar4 = strcmp(sub->name,"default");
          if (iVar4 != 0) break;
          if (child[1].prev != (lys_node *)0x0) {
            ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
            goto LAB_0015739c;
          }
          pcVar8 = lyxml_get_attr(sub,"value",(char *)0x0);
          if (pcVar8 == (char *)0x0) {
            ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
            goto LAB_0015739c;
          }
          sVar5 = strlen(pcVar8);
          plVar6 = (lys_node *)lydict_insert(ctx_00,pcVar8,sVar5);
          child[1].prev = plVar6;
          iVar4 = lyp_yin_parse_subnode_ext
                            (module,child,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_DEFAULT,'\0',unres);
joined_r0x00156ae3:
          sub = plVar1;
          if (iVar4 != 0) goto LAB_0015739c;
        }
        iVar4 = strcmp(sub->name,"units");
        if (iVar4 == 0) {
          if (child[1].next == (lys_node *)0x0) {
            pcVar8 = lyxml_get_attr(sub,"name",(char *)0x0);
            if (pcVar8 != (char *)0x0) {
              sVar5 = strlen(pcVar8);
              plVar6 = (lys_node *)lydict_insert(ctx_00,pcVar8,sVar5);
              child[1].next = plVar6;
              iVar4 = lyp_yin_parse_subnode_ext
                                (module,child,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_UNITS,'\0',unres);
              goto joined_r0x00156ae3;
            }
            ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,sub->name);
          }
          else {
            ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
          }
          break;
        }
        iVar4 = strcmp(sub->name,"mandatory");
        if (iVar4 == 0) {
          if (bVar3) {
            ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
          }
          else {
            bVar3 = true;
            pcVar8 = lyxml_get_attr(sub,"value",(char *)0x0);
            if (pcVar8 != (char *)0x0) {
              iVar4 = strcmp(pcVar8,"true");
              if (iVar4 == 0) {
                child->flags = child->flags | 0x40;
              }
              else {
                iVar4 = strcmp(pcVar8,"false");
                if (iVar4 != 0) {
                  ly_vlog(ctx_00,LYE_INARG,LY_VLOG_LYS,child,pcVar8,sub->name);
                  break;
                }
                child->flags = child->flags | 0x80;
              }
              iVar4 = lyp_yin_parse_subnode_ext
                                (module,child,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_MANDATORY,'\0',unres)
              ;
              goto joined_r0x00156ae3;
            }
            ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
          }
          break;
        }
        iVar4 = strcmp(sub->name,"when");
        if (iVar4 != 0) {
          iVar4 = strcmp(sub->name,"must");
          if (iVar4 == 0) {
            if (c_must == 0xff) {
              ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                     0xff,"musts",&DAT_002145e0);
              break;
            }
            c_must = c_must + 1;
            sub = plVar1;
          }
          else {
            iVar4 = strcmp(sub->name,"if-feature");
            if (iVar4 != 0) {
              ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_LYS,child,sub->name);
              break;
            }
            if (c_ftrs == 0xff) {
              ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                     0xff,"musts",&DAT_002145e0);
              break;
            }
            c_ftrs = c_ftrs + 1;
            sub = plVar1;
          }
          goto LAB_00156e38;
        }
        if (child[1].name != (char *)0x0) {
          ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
          break;
        }
        plVar7 = read_yin_when(module,sub,unres);
        child[1].name = (char *)plVar7;
        sub = plVar1;
      } while (child[1].name != (char *)0x0);
    }
  }
  goto LAB_0015739c;
  while (iVar4 == 0) {
LAB_00157218:
    sub = plVar1;
    if (sub == (lyxml_elem *)0x0) {
      iVar4 = unres_schema_add_node(module,unres,&child[1].ref,UNRES_TYPE_DER,child);
      if (iVar4 == -1) {
        child[1].ext = (lys_ext_instance **)0x0;
        break;
      }
      if ((((ctx_00->models).flags & 2U) == 0) &&
         (iVar4 = unres_schema_add_node
                            (module,unres,&child[1].ref,UNRES_TYPE_DFLT,(lys_node *)&child[1].prev),
         iVar4 == -1)) break;
      if ((((ctx_00->models).flags & 2U) == 0) &&
         ((child[1].name != (char *)0x0 || (child[1].dsc != (char *)0x0)))) {
        if ((options & 4U) == 0) {
          iVar4 = unres_schema_add_node(module,unres,child,UNRES_XPATH,(lys_node *)0x0);
          if (iVar4 == -1) break;
        }
        else {
          iVar4 = lyxp_node_check_syntax(child);
          if (iVar4 != 0) break;
        }
      }
      r = 0;
      while( true ) {
        if ((int)(uint)child->ext_size <= r) {
          return child;
        }
        if ((child->ext[r]->flags & 8) != 0) break;
        r = r + 1;
      }
      child->flags = child->flags | 0x2000;
      return child;
    }
    plVar1 = sub->next;
    iVar4 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
    if (iVar4 == 0) {
      iVar4 = strcmp(sub->name,"must");
      if (iVar4 == 0) {
        iVar4 = fill_yin_must(module,sub,
                              (lys_restr *)(child[1].dsc + (ulong)child->padding[3] * 0x38),unres);
        child->padding[3] = child->padding[3] + '\x01';
      }
      else {
        iVar4 = strcmp(sub->name,"if-feature");
        if (iVar4 != 0) goto LAB_00157218;
        iVar4 = fill_yin_iffeature(child,0,sub,child->iffeature + child->iffeature_size,unres);
        child->iffeature_size = child->iffeature_size + '\x01';
      }
    }
    else {
      iVar4 = lyp_yin_fill_ext(child,LYEXT_PAR_NODE,LYEXT_SUBSTMT_SELF,'\0',module,sub,&child->ext,
                               child->ext_size,unres);
      child->ext_size = child->ext_size + '\x01';
    }
  }
LAB_0015739c:
  lys_node_free(child,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
  return (lys_node *)0x0;
}



lys_node *
read_yin_leaflist(lys_module *module,lys_node *parent,lyxml_elem *yin,int options,
                 unres_schema *unres)

{
  byte bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  int iVar6;
  lys_module *module_00;
  ushort **ppuVar7;
  int *piVar8;
  lys_when *plVar9;
  lys_restr *plVar10;
  lys_iffeature *plVar11;
  char **ppcVar12;
  size_t sVar13;
  char *pcVar14;
  lys_node *plVar15;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  int options_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int r;
  int has_type;
  int c_must;
  int c_ftrs;
  int c_dflt;
  int c_ext;
  int f_ordr;
  int f_min;
  int f_max;
  char *endptr;
  lyxml_elem *sub;
  lyxml_elem *next;
  char *value;
  ly_ctx *ctx;
  lys_node_leaflist *llist;
  lys_node *retval;
  void *reallocated;
  ulong val;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = module->ctx;
  bVar2 = false;
  c_must = 0;
  c_ftrs = 0;
  c_dflt = 0;
  c_ext = 0;
  bVar3 = false;
  bVar4 = false;
  bVar5 = false;
  llist = (lys_node_leaflist *)calloc(1,0xd8);
  if (llist == (lys_node_leaflist *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_leaflist");
    plVar15 = (lys_node *)0x0;
    goto LAB_001588ef;
  }
  llist->nodetype = LYS_LEAFLIST;
  llist->prev = (lys_node *)llist;
  if ((options & 2U) == 0) {
    if ((options & 1U) == 0) {
      iVar6 = 0x17;
    }
    else {
      iVar6 = 0x13;
    }
  }
  else {
    iVar6 = 0x19;
  }
  retval = (lys_node *)llist;
  iVar6 = read_yin_common(module,parent,llist,LYEXT_PAR_NODE,yin,iVar6,unres);
  if (iVar6 == 0) {
    ly_log_dbg(4,"parsing %s statement \"%s\"",yin->name,retval->name);
    module_00 = lys_main_module(module);
    iVar6 = lys_node_addchild(parent,module_00,retval,options);
    if (iVar6 == 0) {
      sub = yin->child;
      while (sub != (lyxml_elem *)0x0) {
        next = sub->next;
        iVar6 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar6 == 0) {
          iVar6 = strcmp(sub->name,"type");
          if (iVar6 == 0) {
            if (bVar2) {
              ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYS,retval,sub->name,yin->name);
              goto LAB_001588d4;
            }
            (llist->type).der = (lys_tpdf *)sub;
            (llist->type).parent = (lys_tpdf *)llist;
            bVar2 = true;
          }
          else {
            iVar6 = strcmp(sub->name,"units");
            if (iVar6 == 0) {
              if (llist->units == (char *)0x0) {
                value = lyxml_get_attr(sub,"name",(char *)0x0);
                if (value != (char *)0x0) {
                  sVar13 = strlen(value);
                  pcVar14 = lydict_insert(ctx,value,sVar13);
                  llist->units = pcVar14;
                  iVar6 = lyp_yin_parse_subnode_ext
                                    (module,retval,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_UNITS,'\0',unres
                                    );
                  goto joined_r0x00158011;
                }
                ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,sub->name);
              }
              else {
                ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYS,retval,sub->name,yin->name);
              }
              goto LAB_001588d4;
            }
            iVar6 = strcmp(sub->name,"ordered-by");
            if (iVar6 == 0) {
              if (bVar3) {
                ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYS,retval,sub->name,yin->name);
                goto LAB_001588d4;
              }
              bVar3 = true;
              if ((llist->flags & 2) == 0) {
                value = lyxml_get_attr(sub,"value",(char *)0x0);
                if (value != (char *)0x0) {
                  iVar6 = strcmp(value,"user");
                  if (iVar6 == 0) {
                    llist->flags = llist->flags | 0x100;
                  }
                  else {
                    iVar6 = strcmp(value,"system");
                    if (iVar6 != 0) {
                      ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,retval,value,sub->name);
                      goto LAB_001588d4;
                    }
                  }
                  iVar6 = lyp_yin_parse_subnode_ext
                                    (module,retval,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_ORDEREDBY,'\0',
                                     unres);
                  goto joined_r0x00158011;
                }
                ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                goto LAB_001588d4;
              }
              lyxml_free(ctx,sub);
            }
            else {
              iVar6 = strcmp(sub->name,"must");
              if (iVar6 == 0) {
                if (c_must == 0xff) {
                  ly_log(ctx,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                         0xff,"musts","leaf-list");
                  goto LAB_001588d4;
                }
                c_must = c_must + 1;
              }
              else {
                iVar6 = strcmp(sub->name,"if-feature");
                if (iVar6 == 0) {
                  if (c_ftrs == 0xff) {
                    ly_log(ctx,LY_LLERR,LY_EINT,
                           "Reached limit (%lu) for storing %s in %s statement.",0xff,"if-features",
                           "leaf-list");
                    goto LAB_001588d4;
                  }
                  c_ftrs = c_ftrs + 1;
                }
                else if ((((byte)module->field_0x40 >> 1 & 7) < 2) ||
                        (iVar6 = strcmp(sub->name,"default"), iVar6 != 0)) {
                  iVar6 = strcmp(sub->name,"min-elements");
                  if (iVar6 == 0) {
                    if (bVar4) {
                      ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYS,retval,sub->name,yin->name);
                      goto LAB_001588d4;
                    }
                    bVar4 = true;
                    value = lyxml_get_attr(sub,"value",(char *)0x0);
                    if (value == (char *)0x0) {
                      ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                      goto LAB_001588d4;
                    }
                    while (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[*value] & 0x2000) != 0) {
                      value = value + 1;
                    }
                    piVar8 = __errno_location();
                    *piVar8 = 0;
                    endptr = (char *)0x0;
                    val = strtoul(value,&endptr,10);
                    if ((((*endptr != '\0') || (*value == '-')) ||
                        (piVar8 = __errno_location(), *piVar8 != 0)) || (0xffffffff < val)) {
                      ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,retval,value,sub->name);
                      goto LAB_001588d4;
                    }
                    llist->min = (uint32_t)val;
                    if ((llist->max != 0) && (llist->max < llist->min)) {
                      ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,retval,value,sub->name);
                      ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                              "\"min-elements\" is bigger than \"max-elements\".");
                      goto LAB_001588d4;
                    }
                    iVar6 = lyp_yin_parse_subnode_ext
                                      (module,retval,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_MIN,'\0',unres
                                      );
                  }
                  else {
                    iVar6 = strcmp(sub->name,"max-elements");
                    if (iVar6 != 0) {
                      iVar6 = strcmp(sub->name,"when");
                      if (iVar6 == 0) {
                        if (llist->when == (lys_when *)0x0) {
                          plVar9 = read_yin_when(module,sub,unres);
                          llist->when = plVar9;
                          if (llist->when != (lys_when *)0x0) goto LAB_001580f1;
                        }
                        else {
                          ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYS,retval,sub->name,yin->name);
                        }
                      }
                      else {
                        ly_vlog(ctx,LYE_INSTMT,LY_VLOG_LYS,retval,sub->name);
                      }
                      goto LAB_001588d4;
                    }
                    if (bVar5) {
                      ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYS,retval,sub->name,yin->name);
                      goto LAB_001588d4;
                    }
                    bVar5 = true;
                    value = lyxml_get_attr(sub,"value",(char *)0x0);
                    if (value == (char *)0x0) {
                      ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                      goto LAB_001588d4;
                    }
                    while (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[*value] & 0x2000) != 0) {
                      value = value + 1;
                    }
                    iVar6 = strcmp(value,"unbounded");
                    if (iVar6 == 0) {
                      llist->max = 0;
                    }
                    else {
                      piVar8 = __errno_location();
                      *piVar8 = 0;
                      endptr = (char *)0x0;
                      val = strtoul(value,&endptr,10);
                      if (((*endptr != '\0') || (*value == '-')) ||
                         ((piVar8 = __errno_location(), *piVar8 != 0 ||
                          ((val == 0 || (0xffffffff < val)))))) {
                        ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,retval,value,sub->name);
                        goto LAB_001588d4;
                      }
                      llist->max = (uint32_t)val;
                      if (llist->max < llist->min) {
                        ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,retval,value,sub->name);
                        ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                                "\"max-elements\" is smaller than \"min-elements\".");
                        goto LAB_001588d4;
                      }
                    }
                    iVar6 = lyp_yin_parse_subnode_ext
                                      (module,retval,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_MAX,'\0',unres
                                      );
                  }
joined_r0x00158011:
                  if (iVar6 != 0) goto LAB_001588d4;
                }
                else {
                  iVar6 = lyp_yin_parse_subnode_ext
                                    (module,retval,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_DEFAULT,
                                     (uint8_t)c_dflt,unres);
                  if (iVar6 != 0) goto LAB_001588d4;
                  if (c_dflt == 0xff) {
                    ly_log(ctx,LY_LLERR,LY_EINT,
                           "Reached limit (%lu) for storing %s in %s statement.",0xff,"defaults",
                           "leaf-list");
                    goto LAB_001588d4;
                  }
                  c_dflt = c_dflt + 1;
                }
              }
            }
          }
        }
        else {
          if (c_ext == 0xff) {
            ly_log(ctx,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",0xff,
                   "extensions","leaf-list");
            goto LAB_001588d4;
          }
          c_ext = c_ext + 1;
        }
LAB_001580f1:
        sub = next;
      }
      if (bVar2) {
        if (c_must != 0) {
          plVar10 = (lys_restr *)calloc((long)c_must,0x38);
          llist->must = plVar10;
          if (llist->must == (lys_restr *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_leaflist");
            goto LAB_001588d4;
          }
        }
        if (c_ftrs != 0) {
          plVar11 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
          llist->iffeature = plVar11;
          if (llist->iffeature == (lys_iffeature *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_leaflist");
            goto LAB_001588d4;
          }
        }
        if (c_dflt != 0) {
          ppcVar12 = (char **)calloc((long)c_dflt,8);
          llist->dflt = ppcVar12;
          if (llist->dflt == (char **)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_leaflist");
            goto LAB_001588d4;
          }
        }
        if (c_ext != 0) {
          reallocated = realloc(retval->ext,(long)(int)(c_ext + (uint)retval->ext_size) * 8);
          if ((lys_ext_instance **)reallocated == (lys_ext_instance **)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_leaflist");
            goto LAB_001588d4;
          }
          retval->ext = (lys_ext_instance **)reallocated;
          memset(retval->ext + retval->ext_size,0,(long)c_ext * 8);
        }
        sub = yin->child;
        while (sub != (lyxml_elem *)0x0) {
          next = sub->next;
          iVar6 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
          if (iVar6 == 0) {
            iVar6 = strcmp(sub->name,"must");
            if (iVar6 == 0) {
              iVar6 = fill_yin_must(module,sub,llist->must + llist->must_size,unres);
              llist->must_size = llist->must_size + '\x01';
              goto joined_r0x0015845d;
            }
            iVar6 = strcmp(sub->name,"if-feature");
            if (iVar6 == 0) {
              iVar6 = fill_yin_iffeature(retval,0,sub,llist->iffeature + llist->iffeature_size,unres
                                        );
              llist->iffeature_size = llist->iffeature_size + '\x01';
              goto joined_r0x0015845d;
            }
            iVar6 = strcmp(sub->name,"default");
            if (iVar6 == 0) {
              value = lyxml_get_attr(sub,"value",(char *)0x0);
              if (value == (char *)0x0) {
                ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                goto LAB_001588d4;
              }
              if ((llist->flags & 1) != 0) {
                for (r = 0; r < (int)(uint)llist->dflt_size; r = r + 1) {
                  if (value == llist->dflt[r]) {
                    ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,retval,value,"default");
                    ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Duplicated default value \"%s\"."
                            ,value);
                    goto LAB_001588d4;
                  }
                }
              }
              sVar13 = strlen(value);
              ppcVar12 = llist->dflt;
              bVar1 = llist->dflt_size;
              llist->dflt_size = bVar1 + 1;
              pcVar14 = lydict_insert(ctx,value,sVar13);
              ppcVar12[bVar1] = pcVar14;
            }
          }
          else {
            iVar6 = lyp_yin_fill_ext(retval,LYEXT_PAR_NODE,LYEXT_SUBSTMT_SELF,'\0',module,sub,
                                     &retval->ext,retval->ext_size,unres);
            retval->ext_size = retval->ext_size + '\x01';
joined_r0x0015845d:
            if (iVar6 != 0) goto LAB_001588d4;
          }
          sub = next;
        }
        iVar6 = unres_schema_add_node(module,unres,&llist->type,UNRES_TYPE_DER,retval);
        if (iVar6 == -1) {
          (llist->type).der = (lys_tpdf *)0x0;
        }
        else if ((llist->dflt_size == '\0') || (llist->min == 0)) {
          for (r = 0; r < (int)(uint)llist->dflt_size; r = r + 1) {
            if ((((ctx->models).flags & 2U) == 0) &&
               (iVar6 = unres_schema_add_node
                                  (module,unres,&llist->type,UNRES_TYPE_DFLT,
                                   (lys_node *)(llist->dflt + r)), iVar6 == -1)) goto LAB_001588d4;
          }
          if ((((ctx->models).flags & 2U) != 0) ||
             ((llist->when == (lys_when *)0x0 && (llist->must == (lys_restr *)0x0)))) {
LAB_0015885b:
            for (r = 0; plVar15 = retval, r < (int)(uint)retval->ext_size; r = r + 1) {
              if ((retval->ext[r]->flags & 8) != 0) {
                retval->flags = retval->flags | 0x2000;
                break;
              }
            }
            goto LAB_001588ef;
          }
          if ((options & 4U) == 0) {
            iVar6 = unres_schema_add_node(module,unres,retval,UNRES_XPATH,(lys_node *)0x0);
            if (iVar6 != -1) goto LAB_0015885b;
          }
          else {
            iVar6 = lyxp_node_check_syntax(retval);
            if (iVar6 == 0) goto LAB_0015885b;
          }
        }
        else {
          ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,retval,"min-elements","leaf-list");
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                  "The \"min-elements\" statement with non-zero value is forbidden on leaf-lists with the \"default\" statement."
                 );
        }
      }
      else {
        ly_vlog(ctx,LYE_MISSCHILDSTMT,LY_VLOG_LYS,retval,&DAT_00213b02,yin->name);
      }
    }
  }
LAB_001588d4:
  lys_node_free(retval,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
  plVar15 = (lys_node *)0x0;
LAB_001588ef:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar15;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_node *
read_yin_list(lys_module *module,lys_node *parent,lyxml_elem *yin,int options,unres_schema *unres)

{
  long lVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  int iVar5;
  lys_module *module_00;
  char *pcVar6;
  ushort **ppuVar7;
  lys_node_leaf **pplVar8;
  int *piVar9;
  lys_when *plVar10;
  lys_tpdf *plVar11;
  lys_restr *plVar12;
  lys_iffeature *plVar13;
  lys_unique *plVar14;
  lys_node *plVar15;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  int options_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int r;
  int c_tpdf;
  int c_must;
  int c_uniq;
  int c_ftrs;
  int c_ext;
  int f_ordr;
  int f_max;
  int f_min;
  char *auxs;
  lys_node *node;
  lyxml_elem *sub;
  lyxml_elem *next;
  char *value;
  ly_ctx *ctx;
  lys_node_list *list;
  lys_node *retval;
  void *reallocated;
  ulong val;
  lyxml_elem root;
  lyxml_elem uniq;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = module->ctx;
  c_tpdf = 0;
  c_must = 0;
  c_uniq = 0;
  c_ftrs = 0;
  c_ext = 0;
  bVar2 = false;
  bVar4 = false;
  bVar3 = false;
  memset(&root,0,0x48);
  memset(&uniq,0,0x48);
  list = (lys_node_list *)calloc(1,0xa8);
  if (list == (lys_node_list *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_list");
    plVar15 = (lys_node *)0x0;
    goto LAB_0015a986;
  }
  list->nodetype = LYS_LIST;
  list->prev = (lys_node *)list;
  if ((options & 2U) == 0) {
    if ((options & 1U) == 0) {
      iVar5 = 0x17;
    }
    else {
      iVar5 = 0x13;
    }
  }
  else {
    iVar5 = 0x19;
  }
  retval = (lys_node *)list;
  iVar5 = read_yin_common(module,parent,list,LYEXT_PAR_NODE,yin,iVar5,unres);
  if (iVar5 == 0) {
    ly_log_dbg(4,"parsing %s statement \"%s\"",yin->name,retval->name);
    module_00 = lys_main_module(module);
    iVar5 = lys_node_addchild(parent,module_00,retval,options);
    if (iVar5 == 0) {
      sub = yin->child;
      while (sub != (lyxml_elem *)0x0) {
        next = sub->next;
        iVar5 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar5 == 0) {
          iVar5 = strcmp(sub->name,"container");
          if ((((((iVar5 == 0) || (iVar5 = strcmp(sub->name,"leaf-list"), iVar5 == 0)) ||
                (iVar5 = strcmp(sub->name,"leaf"), iVar5 == 0)) ||
               ((iVar5 = strcmp(sub->name,"list"), iVar5 == 0 ||
                (iVar5 = strcmp(sub->name,"choice"), iVar5 == 0)))) ||
              (iVar5 = strcmp(sub->name,"uses"), iVar5 == 0)) ||
             (((iVar5 = strcmp(sub->name,"grouping"), iVar5 == 0 ||
               (iVar5 = strcmp(sub->name,"anyxml"), iVar5 == 0)) ||
              ((iVar5 = strcmp(sub->name,"anydata"), iVar5 == 0 ||
               ((iVar5 = strcmp(sub->name,"action"), iVar5 == 0 ||
                (iVar5 = strcmp(sub->name,"notification"), iVar5 == 0)))))))) {
            lyxml_unlink_elem(ctx,sub,2);
            lyxml_add_child(ctx,&root,sub);
          }
          else {
            iVar5 = strcmp(sub->name,"key");
            if (iVar5 == 0) {
              if (list->keys_size != '\0') {
                ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYS,retval,sub->name,list->name);
                goto LAB_0015a920;
              }
              value = lyxml_get_attr(sub,"value",(char *)0x0);
              if (value == (char *)0x0) {
                ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                goto LAB_0015a920;
              }
              pcVar6 = lydict_insert(ctx,value,0);
              list->keys_str = pcVar6;
              while (value = strpbrk(value," \t\n"), value != (char *)0x0) {
                list->keys_size = list->keys_size + '\x01';
                while (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[*value] & 0x2000) != 0) {
                  value = value + 1;
                }
              }
              list->keys_size = list->keys_size + '\x01';
              pplVar8 = (lys_node_leaf **)calloc((ulong)list->keys_size,8);
              list->keys = pplVar8;
              if (list->keys == (lys_node_leaf **)0x0) {
                ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_list");
                goto LAB_0015a920;
              }
              iVar5 = lyp_yin_parse_subnode_ext
                                (module,retval,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_KEY,'\0',unres);
              if (iVar5 != 0) goto LAB_0015a920;
              lyxml_free(ctx,sub);
            }
            else {
              iVar5 = strcmp(sub->name,"unique");
              if (iVar5 == 0) {
                if (c_uniq == 0xff) {
                  ly_log(ctx,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                         0xff,"uniques",&DAT_002145e5);
                  goto LAB_0015a920;
                }
                c_uniq = c_uniq + 1;
                lyxml_unlink_elem(ctx,sub,2);
                lyxml_add_child(ctx,&uniq,sub);
              }
              else {
                iVar5 = strcmp(sub->name,"typedef");
                if (iVar5 == 0) {
                  if (c_tpdf == 0xff) {
                    ly_log(ctx,LY_LLERR,LY_EINT,
                           "Reached limit (%lu) for storing %s in %s statement.",0xff,"typedefs",
                           &DAT_002145e5);
                    goto LAB_0015a920;
                  }
                  c_tpdf = c_tpdf + 1;
                }
                else {
                  iVar5 = strcmp(sub->name,"must");
                  if (iVar5 == 0) {
                    if (c_must == 0xff) {
                      ly_log(ctx,LY_LLERR,LY_EINT,
                             "Reached limit (%lu) for storing %s in %s statement.",0xff,"musts",
                             &DAT_002145e5);
                      goto LAB_0015a920;
                    }
                    c_must = c_must + 1;
                  }
                  else {
                    iVar5 = strcmp(sub->name,"if-feature");
                    if (iVar5 == 0) {
                      if (c_ftrs == 0xff) {
                        ly_log(ctx,LY_LLERR,LY_EINT,
                               "Reached limit (%lu) for storing %s in %s statement.",0xff,
                               "if-features",&DAT_002145e5);
                        goto LAB_0015a920;
                      }
                      c_ftrs = c_ftrs + 1;
                    }
                    else {
                      iVar5 = strcmp(sub->name,"ordered-by");
                      if (iVar5 == 0) {
                        if (bVar2) {
                          ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYS,retval,sub->name,yin->name);
                          goto LAB_0015a920;
                        }
                        bVar2 = true;
                        if ((list->flags & 2) == 0) {
                          value = lyxml_get_attr(sub,"value",(char *)0x0);
                          if (value == (char *)0x0) {
                            ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                            goto LAB_0015a920;
                          }
                          iVar5 = strcmp(value,"user");
                          if (iVar5 == 0) {
                            list->flags = list->flags | 0x100;
                          }
                          else {
                            iVar5 = strcmp(value,"system");
                            if (iVar5 != 0) {
                              ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,retval,value,sub->name);
                              goto LAB_0015a920;
                            }
                          }
                          iVar5 = lyp_yin_parse_subnode_ext
                                            (module,retval,LYEXT_PAR_NODE,sub,
                                             LYEXT_SUBSTMT_ORDEREDBY,'\0',unres);
                          if (iVar5 != 0) goto LAB_0015a920;
                          lyxml_free(ctx,sub);
                        }
                        else {
                          lyxml_free(ctx,sub);
                        }
                      }
                      else {
                        iVar5 = strcmp(sub->name,"min-elements");
                        if (iVar5 == 0) {
                          if (bVar3) {
                            ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYS,retval,sub->name,yin->name);
                            goto LAB_0015a920;
                          }
                          bVar3 = true;
                          value = lyxml_get_attr(sub,"value",(char *)0x0);
                          if (value == (char *)0x0) {
                            ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                            goto LAB_0015a920;
                          }
                          while (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[*value] & 0x2000) != 0) {
                            value = value + 1;
                          }
                          piVar9 = __errno_location();
                          *piVar9 = 0;
                          auxs = (char *)0x0;
                          val = strtoul(value,&auxs,10);
                          if ((((*auxs != '\0') || (*value == '-')) ||
                              (piVar9 = __errno_location(), *piVar9 != 0)) || (0xffffffff < val)) {
                            ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,retval,value,sub->name);
                            goto LAB_0015a920;
                          }
                          list->min = (uint32_t)val;
                          if ((list->max != 0) && (list->max < list->min)) {
                            ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,retval,value,sub->name);
                            ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                                    "\"min-elements\" is bigger than \"max-elements\".");
                            lyxml_free(ctx,sub);
                            goto LAB_0015a920;
                          }
                          iVar5 = lyp_yin_parse_subnode_ext
                                            (module,retval,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_MIN,'\0'
                                             ,unres);
                          if (iVar5 != 0) goto LAB_0015a920;
                          lyxml_free(ctx,sub);
                        }
                        else {
                          iVar5 = strcmp(sub->name,"max-elements");
                          if (iVar5 == 0) {
                            if (bVar4) {
                              ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYS,retval,sub->name,yin->name);
                              goto LAB_0015a920;
                            }
                            bVar4 = true;
                            value = lyxml_get_attr(sub,"value",(char *)0x0);
                            if (value == (char *)0x0) {
                              ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
                              goto LAB_0015a920;
                            }
                            while (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[*value] & 0x2000) != 0) {
                              value = value + 1;
                            }
                            iVar5 = strcmp(value,"unbounded");
                            if (iVar5 == 0) {
                              list->max = 0;
                            }
                            else {
                              piVar9 = __errno_location();
                              *piVar9 = 0;
                              auxs = (char *)0x0;
                              val = strtoul(value,&auxs,10);
                              if (((*auxs != '\0') || (*value == '-')) ||
                                 ((piVar9 = __errno_location(), *piVar9 != 0 ||
                                  ((val == 0 || (0xffffffff < val)))))) {
                                ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,retval,value,sub->name);
                                goto LAB_0015a920;
                              }
                              list->max = (uint32_t)val;
                              if (list->max < list->min) {
                                ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,retval,value,sub->name);
                                ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                                        "\"max-elements\" is smaller than \"min-elements\".");
                                goto LAB_0015a920;
                              }
                            }
                            iVar5 = lyp_yin_parse_subnode_ext
                                              (module,retval,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_MAX,
                                               '\0',unres);
                            if (iVar5 != 0) goto LAB_0015a920;
                            lyxml_free(ctx,sub);
                          }
                          else {
                            iVar5 = strcmp(sub->name,"when");
                            if (iVar5 != 0) {
                              ly_vlog(ctx,LYE_INSTMT,LY_VLOG_LYS,retval,sub->name);
                              goto LAB_0015a920;
                            }
                            if (list->when != (lys_when *)0x0) {
                              ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYS,retval,sub->name,yin->name);
                              goto LAB_0015a920;
                            }
                            plVar10 = read_yin_when(module,sub,unres);
                            list->when = plVar10;
                            if (list->when == (lys_when *)0x0) {
                              lyxml_free(ctx,sub);
                              goto LAB_0015a920;
                            }
                            lyxml_free(ctx,sub);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else {
          if (c_ext == 0xff) {
            ly_log(ctx,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",0xff,
                   "extensions",&DAT_002145e5);
            goto LAB_0015a920;
          }
          c_ext = c_ext + 1;
        }
        sub = next;
      }
      for (node = retval; (node != (lys_node *)0x0 && ((node->nodetype & 0x12800) == LYS_UNKNOWN));
          node = node->parent) {
      }
      if (((node == (lys_node *)0x0) && ((list->flags & 1) != 0)) && (list->keys_str == (char *)0x0)
         ) {
        ly_vlog(ctx,LYE_MISSCHILDSTMT,LY_VLOG_LYS,retval,&DAT_00214813,&DAT_002145e5);
      }
      else {
        if (c_tpdf != 0) {
          plVar11 = (lys_tpdf *)calloc((long)c_tpdf,0x80);
          list->tpdf = plVar11;
          if (list->tpdf == (lys_tpdf *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_list");
            goto LAB_0015a920;
          }
        }
        if (c_must != 0) {
          plVar12 = (lys_restr *)calloc((long)c_must,0x38);
          list->must = plVar12;
          if (list->must == (lys_restr *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_list");
            goto LAB_0015a920;
          }
        }
        if (c_ftrs != 0) {
          plVar13 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
          list->iffeature = plVar13;
          if (list->iffeature == (lys_iffeature *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_list");
            goto LAB_0015a920;
          }
        }
        if (c_ext != 0) {
          reallocated = realloc(retval->ext,(long)(int)(c_ext + (uint)retval->ext_size) * 8);
          if ((lys_ext_instance **)reallocated == (lys_ext_instance **)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_list");
            goto LAB_0015a920;
          }
          retval->ext = (lys_ext_instance **)reallocated;
          memset(retval->ext + retval->ext_size,0,(long)c_ext * 8);
        }
        sub = yin->child;
        while (sub != (lyxml_elem *)0x0) {
          next = sub->next;
          iVar5 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
          if (iVar5 == 0) {
            iVar5 = strcmp(sub->name,"typedef");
            if (iVar5 == 0) {
              iVar5 = fill_yin_typedef(module,retval,sub,list->tpdf + list->tpdf_size,unres);
              list->tpdf_size = list->tpdf_size + '\x01';
              goto joined_r0x0015a065;
            }
            iVar5 = strcmp(sub->name,"if-feature");
            if (iVar5 == 0) {
              iVar5 = fill_yin_iffeature(retval,0,sub,list->iffeature + list->iffeature_size,unres);
              list->iffeature_size = list->iffeature_size + '\x01';
              goto joined_r0x0015a065;
            }
            iVar5 = strcmp(sub->name,"must");
            if (iVar5 == 0) {
              iVar5 = fill_yin_must(module,sub,list->must + list->must_size,unres);
              list->must_size = list->must_size + '\x01';
              goto joined_r0x0015a065;
            }
          }
          else {
            iVar5 = lyp_yin_fill_ext(retval,LYEXT_PAR_NODE,LYEXT_SUBSTMT_SELF,'\0',module,sub,
                                     &retval->ext,retval->ext_size,unres);
            retval->ext_size = retval->ext_size + '\x01';
joined_r0x0015a065:
            if (iVar5 != 0) goto LAB_0015a920;
          }
          sub = next;
        }
        sub = root.child;
        while (sub != (lyxml_elem *)0x0) {
          next = sub->next;
          iVar5 = strcmp(sub->name,"container");
          if (iVar5 == 0) {
            node = read_yin_container(module,retval,sub,options,unres);
          }
          else {
            iVar5 = strcmp(sub->name,"leaf-list");
            if (iVar5 == 0) {
              node = read_yin_leaflist(module,retval,sub,options,unres);
            }
            else {
              iVar5 = strcmp(sub->name,"leaf");
              if (iVar5 == 0) {
                node = read_yin_leaf(module,retval,sub,options,unres);
              }
              else {
                iVar5 = strcmp(sub->name,"list");
                if (iVar5 == 0) {
                  node = read_yin_list(module,retval,sub,options,unres);
                }
                else {
                  iVar5 = strcmp(sub->name,"choice");
                  if (iVar5 == 0) {
                    node = read_yin_choice(module,retval,sub,options,unres);
                  }
                  else {
                    iVar5 = strcmp(sub->name,"uses");
                    if (iVar5 == 0) {
                      node = read_yin_uses(module,retval,sub,options,unres);
                    }
                    else {
                      iVar5 = strcmp(sub->name,"grouping");
                      if (iVar5 == 0) {
                        node = read_yin_grouping(module,retval,sub,options,unres);
                      }
                      else {
                        iVar5 = strcmp(sub->name,"anyxml");
                        if (iVar5 == 0) {
                          node = read_yin_anydata(module,retval,sub,LYS_ANYXML,options,unres);
                        }
                        else {
                          iVar5 = strcmp(sub->name,"anydata");
                          if (iVar5 == 0) {
                            node = read_yin_anydata(module,retval,sub,LYS_ANYDATA,options,unres);
                          }
                          else {
                            iVar5 = strcmp(sub->name,"action");
                            if (iVar5 == 0) {
                              node = read_yin_rpc_action(module,retval,sub,options,unres);
                            }
                            else {
                              iVar5 = strcmp(sub->name,"notification");
                              if (iVar5 != 0) {
                                ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                                       "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yin.c"
                                       ,0x156c);
                                goto LAB_0015a920;
                              }
                              node = read_yin_notif(module,retval,sub,options,unres);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (node == (lys_node *)0x0) goto LAB_0015a920;
          lyxml_free(ctx,sub);
          sub = next;
        }
        if ((list->keys_str == (char *)0x0) ||
           (iVar5 = unres_schema_add_node(module,unres,list,UNRES_LIST_KEYS,(lys_node *)0x0),
           iVar5 != -1)) {
          if (c_uniq != 0) {
            plVar14 = (lys_unique *)calloc((long)c_uniq,0x10);
            list->unique = plVar14;
            if (list->unique == (lys_unique *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_list");
              goto LAB_0015a920;
            }
            sub = uniq.child;
            while (sub != (lyxml_elem *)0x0) {
              next = sub->next;
              iVar5 = fill_yin_unique(module,retval,sub,list->unique + list->unique_size,unres);
              list->unique_size = list->unique_size + '\x01';
              if ((iVar5 != 0) ||
                 (iVar5 = lyp_yin_parse_subnode_ext
                                    (module,retval,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_UNIQUE,
                                     list->unique_size + 0xff,unres), iVar5 != 0))
              goto LAB_0015a920;
              lyxml_free(ctx,sub);
              sub = next;
            }
          }
          if ((((ctx->models).flags & 2U) != 0) ||
             ((list->when == (lys_when *)0x0 && (list->must == (lys_restr *)0x0)))) {
LAB_0015a832:
            for (r = 0; plVar15 = retval, r < (int)(uint)retval->ext_size; r = r + 1) {
              if (((retval->ext[r]->flags & 8) != 0) &&
                 (retval->flags = retval->flags | 0x2000, (retval->ext[r]->flags & 0x10) != 0)) {
                retval->flags = retval->flags | 0x4000;
                break;
              }
            }
            goto LAB_0015a986;
          }
          if ((options & 4U) == 0) {
            iVar5 = unres_schema_add_node(module,unres,retval,UNRES_XPATH,(lys_node *)0x0);
            if (iVar5 != -1) goto LAB_0015a832;
          }
          else {
            iVar5 = lyxp_node_check_syntax(retval);
            if (iVar5 == 0) goto LAB_0015a832;
          }
        }
      }
    }
  }
LAB_0015a920:
  lys_node_free(retval,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
  while (root.child != (lyxml_elem *)0x0) {
    lyxml_free(ctx,root.child);
  }
  while (uniq.child != (lyxml_elem *)0x0) {
    lyxml_free(ctx,uniq.child);
  }
  plVar15 = (lys_node *)0x0;
LAB_0015a986:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar15;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_node *
read_yin_container(lys_module *module,lys_node *parent,lyxml_elem *yin,int options,
                  unres_schema *unres)

{
  long lVar1;
  ly_ctx *ctx_00;
  long lVar2;
  lyxml_elem *plVar3;
  int iVar4;
  lys_node *child;
  lys_module *module_00;
  size_t len;
  lys_when *plVar5;
  char *pcVar6;
  lys_iffeature *plVar7;
  lys_ext_instance **pplVar8;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  int options_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int r;
  int c_tpdf;
  int c_must;
  int c_ftrs;
  int c_ext;
  lyxml_elem *sub;
  lyxml_elem *next;
  lys_node *node;
  ly_ctx *ctx;
  lys_node_container *cont;
  lys_node *retval;
  void *reallocated;
  char *value;
  lyxml_elem root;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ctx_00 = module->ctx;
  node = (lys_node *)0x0;
  c_tpdf = 0;
  c_must = 0;
  c_ftrs = 0;
  c_ext = 0;
  memset(&root,0,0x48);
  child = (lys_node *)calloc(1,0x90);
  if (child == (lys_node *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_container");
    child = (lys_node *)0x0;
    goto LAB_0015bb96;
  }
  child->nodetype = LYS_CONTAINER;
  child->prev = child;
  if ((options & 2U) == 0) {
    if ((options & 1U) == 0) {
      iVar4 = 0x17;
    }
    else {
      iVar4 = 0x13;
    }
  }
  else {
    iVar4 = 0x19;
  }
  iVar4 = read_yin_common(module,parent,child,LYEXT_PAR_NODE,yin,iVar4,unres);
  if (iVar4 == 0) {
    ly_log_dbg(4,"parsing %s statement \"%s\"",yin->name,child->name);
    module_00 = lys_main_module(module);
    iVar4 = lys_node_addchild(parent,module_00,child,options);
    if (iVar4 == 0) {
      sub = yin->child;
      while (sub != (lyxml_elem *)0x0) {
        plVar3 = sub->next;
        iVar4 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar4 == 0) {
          iVar4 = strcmp(sub->name,"presence");
          if (iVar4 == 0) {
            lVar2._0_2_ = child[1].flags;
            lVar2._2_1_ = child[1].ext_size;
            lVar2._3_1_ = child[1].iffeature_size;
            lVar2._4_1_ = child[1].padding[0];
            lVar2._5_1_ = child[1].padding[1];
            lVar2._6_1_ = child[1].padding[2];
            lVar2._7_1_ = child[1].padding[3];
            if (lVar2 != 0) {
              ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
              goto LAB_0015bb5d;
            }
            pcVar6 = lyxml_get_attr(sub,"value",(char *)0x0);
            if (pcVar6 == (char *)0x0) {
              ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",sub->name);
              goto LAB_0015bb5d;
            }
            len = strlen(pcVar6);
            pcVar6 = lydict_insert(ctx_00,pcVar6,len);
            *(char **)&child[1].flags = pcVar6;
            iVar4 = lyp_yin_parse_subnode_ext
                              (module,child,LYEXT_PAR_NODE,sub,LYEXT_SUBSTMT_PRESENCE,'\0',unres);
            if (iVar4 != 0) goto LAB_0015bb5d;
            lyxml_free(ctx_00,sub);
            sub = plVar3;
          }
          else {
            iVar4 = strcmp(sub->name,"when");
            if (iVar4 == 0) {
              if (child[1].name != (char *)0x0) {
                ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
                goto LAB_0015bb5d;
              }
              plVar5 = read_yin_when(module,sub,unres);
              child[1].name = (char *)plVar5;
              if (child[1].name == (char *)0x0) {
                lyxml_free(ctx_00,sub);
                goto LAB_0015bb5d;
              }
              lyxml_free(ctx_00,sub);
              sub = plVar3;
            }
            else {
              iVar4 = strcmp(sub->name,"container");
              if (((((((iVar4 == 0) || (iVar4 = strcmp(sub->name,"leaf-list"), iVar4 == 0)) ||
                     (iVar4 = strcmp(sub->name,"leaf"), iVar4 == 0)) ||
                    ((iVar4 = strcmp(sub->name,"list"), iVar4 == 0 ||
                     (iVar4 = strcmp(sub->name,"choice"), iVar4 == 0)))) ||
                   ((iVar4 = strcmp(sub->name,"uses"), iVar4 == 0 ||
                    ((iVar4 = strcmp(sub->name,"grouping"), iVar4 == 0 ||
                     (iVar4 = strcmp(sub->name,"anyxml"), iVar4 == 0)))))) ||
                  (iVar4 = strcmp(sub->name,"anydata"), iVar4 == 0)) ||
                 ((iVar4 = strcmp(sub->name,"action"), iVar4 == 0 ||
                  (iVar4 = strcmp(sub->name,"notification"), iVar4 == 0)))) {
                lyxml_unlink_elem(ctx_00,sub,2);
                lyxml_add_child(ctx_00,&root,sub);
                sub = plVar3;
              }
              else {
                iVar4 = strcmp(sub->name,"typedef");
                if (iVar4 == 0) {
                  if (c_tpdf == 0xffff) {
                    ly_log(ctx_00,LY_LLERR,LY_EINT,
                           "Reached limit (%lu) for storing %s in %s statement.",0xffff,"typedefs",
                           "container");
                    goto LAB_0015bb5d;
                  }
                  c_tpdf = c_tpdf + 1;
                  sub = plVar3;
                }
                else {
                  iVar4 = strcmp(sub->name,"must");
                  if (iVar4 == 0) {
                    if (c_must == 0xff) {
                      ly_log(ctx_00,LY_LLERR,LY_EINT,
                             "Reached limit (%lu) for storing %s in %s statement.",0xff,"musts",
                             "container");
                      goto LAB_0015bb5d;
                    }
                    c_must = c_must + 1;
                    sub = plVar3;
                  }
                  else {
                    iVar4 = strcmp(sub->name,"if-feature");
                    if (iVar4 != 0) {
                      ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_LYS,child,sub->name);
                      goto LAB_0015bb5d;
                    }
                    if (c_ftrs == 0xff) {
                      ly_log(ctx_00,LY_LLERR,LY_EINT,
                             "Reached limit (%lu) for storing %s in %s statement.",0xff,
                             "if-features","container");
                      goto LAB_0015bb5d;
                    }
                    c_ftrs = c_ftrs + 1;
                    sub = plVar3;
                  }
                }
              }
            }
          }
        }
        else {
          if (c_ext == 0xff) {
            ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                   0xff,"extensions","container");
            goto LAB_0015bb5d;
          }
          c_ext = c_ext + 1;
          sub = plVar3;
        }
      }
      if (c_tpdf != 0) {
        pcVar6 = (char *)calloc((long)c_tpdf,0x80);
        child[1].ref = pcVar6;
        if (child[1].ref == (char *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_container");
          goto LAB_0015bb5d;
        }
      }
      if (c_must != 0) {
        pcVar6 = (char *)calloc((long)c_must,0x38);
        child[1].dsc = pcVar6;
        if (child[1].dsc == (char *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_container");
          goto LAB_0015bb5d;
        }
      }
      if (c_ftrs != 0) {
        plVar7 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
        child->iffeature = plVar7;
        if (child->iffeature == (lys_iffeature *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_container");
          goto LAB_0015bb5d;
        }
      }
      if (c_ext != 0) {
        pplVar8 = (lys_ext_instance **)
                  realloc(child->ext,(long)(int)(c_ext + (uint)child->ext_size) * 8);
        if (pplVar8 == (lys_ext_instance **)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_container");
          goto LAB_0015bb5d;
        }
        child->ext = pplVar8;
        memset(child->ext + child->ext_size,0,(long)c_ext * 8);
      }
      plVar3 = yin->child;
      do {
        do {
          while( true ) {
            sub = plVar3;
            if (sub == (lyxml_elem *)0x0) {
              sub = root.child;
              goto LAB_0015b9f4;
            }
            plVar3 = sub->next;
            iVar4 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
            if (iVar4 == 0) break;
            iVar4 = lyp_yin_fill_ext(child,LYEXT_PAR_NODE,LYEXT_SUBSTMT_SELF,'\0',module,sub,
                                     &child->ext,child->ext_size,unres);
            child->ext_size = child->ext_size + '\x01';
joined_r0x0015b4d9:
            if (iVar4 != 0) goto LAB_0015bb5d;
          }
          iVar4 = strcmp(sub->name,"typedef");
          if (iVar4 == 0) {
            iVar4 = fill_yin_typedef(module,child,sub,
                                     (lys_tpdf *)
                                     (child[1].ref + (ulong)*(ushort *)(child->padding + 2) * 0x80),
                                     unres);
            *(short *)(child->padding + 2) = *(short *)(child->padding + 2) + 1;
            goto joined_r0x0015b4d9;
          }
          iVar4 = strcmp(sub->name,"must");
          if (iVar4 == 0) {
            iVar4 = fill_yin_must(module,sub,
                                  (lys_restr *)(child[1].dsc + (ulong)child->padding[1] * 0x38),
                                  unres);
            child->padding[1] = child->padding[1] + '\x01';
            goto joined_r0x0015b4d9;
          }
          iVar4 = strcmp(sub->name,"if-feature");
        } while (iVar4 != 0);
        iVar4 = fill_yin_iffeature(child,0,sub,child->iffeature + child->iffeature_size,unres);
        child->iffeature_size = child->iffeature_size + '\x01';
      } while (iVar4 == 0);
    }
  }
  goto LAB_0015bb5d;
LAB_0015b9f4:
  if (sub == (lyxml_elem *)0x0) goto code_r0x0015ba24;
  plVar3 = sub->next;
  iVar4 = strcmp(sub->name,"container");
  if (iVar4 == 0) {
    node = read_yin_container(module,child,sub,options,unres);
  }
  else {
    iVar4 = strcmp(sub->name,"leaf-list");
    if (iVar4 == 0) {
      node = read_yin_leaflist(module,child,sub,options,unres);
    }
    else {
      iVar4 = strcmp(sub->name,"leaf");
      if (iVar4 == 0) {
        node = read_yin_leaf(module,child,sub,options,unres);
      }
      else {
        iVar4 = strcmp(sub->name,"list");
        if (iVar4 == 0) {
          node = read_yin_list(module,child,sub,options,unres);
        }
        else {
          iVar4 = strcmp(sub->name,"choice");
          if (iVar4 == 0) {
            node = read_yin_choice(module,child,sub,options,unres);
          }
          else {
            iVar4 = strcmp(sub->name,"uses");
            if (iVar4 == 0) {
              node = read_yin_uses(module,child,sub,options,unres);
            }
            else {
              iVar4 = strcmp(sub->name,"grouping");
              if (iVar4 == 0) {
                node = read_yin_grouping(module,child,sub,options,unres);
              }
              else {
                iVar4 = strcmp(sub->name,"anyxml");
                if (iVar4 == 0) {
                  node = read_yin_anydata(module,child,sub,LYS_ANYXML,options,unres);
                }
                else {
                  iVar4 = strcmp(sub->name,"anydata");
                  if (iVar4 == 0) {
                    node = read_yin_anydata(module,child,sub,LYS_ANYDATA,options,unres);
                  }
                  else {
                    iVar4 = strcmp(sub->name,"action");
                    if (iVar4 == 0) {
                      node = read_yin_rpc_action(module,child,sub,options,unres);
                    }
                    else {
                      iVar4 = strcmp(sub->name,"notification");
                      if (iVar4 == 0) {
                        node = read_yin_notif(module,child,sub,options,unres);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (node == (lys_node *)0x0) goto LAB_0015bb5d;
  lyxml_free(ctx_00,sub);
  sub = plVar3;
  goto LAB_0015b9f4;
code_r0x0015ba24:
  if ((((ctx_00->models).flags & 2U) == 0) &&
     ((child[1].name != (char *)0x0 || (child[1].dsc != (char *)0x0)))) {
    if ((options & 4U) == 0) {
      iVar4 = unres_schema_add_node(module,unres,child,UNRES_XPATH,(lys_node *)0x0);
      if (iVar4 != -1) goto LAB_0015ba9c;
    }
    else {
      iVar4 = lyxp_node_check_syntax(child);
      if (iVar4 == 0) goto LAB_0015ba9c;
    }
LAB_0015bb5d:
    lys_node_free(child,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
    while (root.child != (lyxml_elem *)0x0) {
      lyxml_free(ctx_00,root.child);
    }
    child = (lys_node *)0x0;
  }
  else {
LAB_0015ba9c:
    for (r = 0; r < (int)(uint)child->ext_size; r = r + 1) {
      if (((child->ext[r]->flags & 8) != 0) &&
         (child->flags = child->flags | 0x2000, (child->ext[r]->flags & 0x10) != 0)) {
        child->flags = child->flags | 0x4000;
        break;
      }
    }
  }
LAB_0015bb96:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return child;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_node *
read_yin_grouping(lys_module *module,lys_node *parent,lyxml_elem *yin,int options,
                 unres_schema *unres)

{
  uint options_00;
  long lVar1;
  ly_ctx *ctx_00;
  lyxml_elem *plVar2;
  long lVar3;
  int iVar4;
  lys_node *child;
  lys_module *module_00;
  void *pvVar5;
  lys_ext_instance **pplVar6;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  int options_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int c_tpdf;
  int c_ext;
  int r;
  lyxml_elem *sub;
  lyxml_elem *next;
  lys_node *node;
  ly_ctx *ctx;
  lys_node_grp *grp;
  lys_node *retval;
  void *reallocated;
  lyxml_elem root;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ctx_00 = module->ctx;
  node = (lys_node *)0x0;
  c_tpdf = 0;
  c_ext = 0;
  memset(&root,0,0x48);
  child = (lys_node *)calloc(1,0x70);
  if (child == (lys_node *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_grouping");
    child = (lys_node *)0x0;
    goto LAB_0015c72b;
  }
  child->nodetype = LYS_GROUPING;
  child->prev = child;
  iVar4 = read_yin_common(module,parent,child,LYEXT_PAR_NODE,yin,0x11,unres);
  if (iVar4 == 0) {
    ly_log_dbg(4,"parsing %s statement \"%s\"",yin->name,child->name);
    module_00 = lys_main_module(module);
    iVar4 = lys_node_addchild(parent,module_00,child,options);
    if (iVar4 == 0) {
      sub = yin->child;
      while (sub != (lyxml_elem *)0x0) {
        plVar2 = sub->next;
        iVar4 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar4 == 0) {
          iVar4 = strcmp(sub->name,"container");
          if ((((((iVar4 == 0) || (iVar4 = strcmp(sub->name,"leaf-list"), iVar4 == 0)) ||
                (iVar4 = strcmp(sub->name,"leaf"), iVar4 == 0)) ||
               ((iVar4 = strcmp(sub->name,"list"), iVar4 == 0 ||
                (iVar4 = strcmp(sub->name,"choice"), iVar4 == 0)))) ||
              ((iVar4 = strcmp(sub->name,"uses"), iVar4 == 0 ||
               ((iVar4 = strcmp(sub->name,"grouping"), iVar4 == 0 ||
                (iVar4 = strcmp(sub->name,"anyxml"), iVar4 == 0)))))) ||
             ((iVar4 = strcmp(sub->name,"anydata"), iVar4 == 0 ||
              ((iVar4 = strcmp(sub->name,"action"), iVar4 == 0 ||
               (iVar4 = strcmp(sub->name,"notification"), iVar4 == 0)))))) {
            lyxml_unlink_elem(ctx_00,sub,2);
            lyxml_add_child(ctx_00,&root,sub);
            sub = plVar2;
          }
          else {
            iVar4 = strcmp(sub->name,"typedef");
            if (iVar4 != 0) {
              ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_LYS,child,sub->name);
              goto LAB_0015c6f2;
            }
            if (c_tpdf == 0xffff) {
              ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                     0xffff,"typedefs","grouping");
              goto LAB_0015c6f2;
            }
            c_tpdf = c_tpdf + 1;
            sub = plVar2;
          }
        }
        else {
          if (c_ext == 0xff) {
            ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                   0xff,"extensions","grouping");
            goto LAB_0015c6f2;
          }
          c_ext = c_ext + 1;
          sub = plVar2;
        }
      }
      if (c_tpdf != 0) {
        pvVar5 = calloc((long)c_tpdf,0x80);
        *(void **)child->hash = pvVar5;
        lVar3._0_1_ = child->hash[0];
        lVar3._1_1_ = child->hash[1];
        lVar3._2_1_ = child->hash[2];
        lVar3._3_1_ = child->hash[3];
        lVar3._4_4_ = *(undefined4 *)&child->field_0x6c;
        if (lVar3 == 0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_grouping");
          goto LAB_0015c6f2;
        }
      }
      if (c_ext != 0) {
        pplVar6 = (lys_ext_instance **)
                  realloc(child->ext,(long)(int)(c_ext + (uint)child->ext_size) * 8);
        if (pplVar6 == (lys_ext_instance **)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_grouping");
          goto LAB_0015c6f2;
        }
        child->ext = pplVar6;
        memset(child->ext + child->ext_size,0,(long)c_ext * 8);
      }
      sub = yin->child;
      do {
        while( true ) {
          if (sub == (lyxml_elem *)0x0) {
            if (root.child == (lyxml_elem *)0x0) {
              ly_log(ctx_00,LY_LLWRN,LY_SUCCESS,"Grouping \"%s\" without children.",child->name);
            }
            options_00 = options | 4;
            sub = root.child;
            goto LAB_0015c6b5;
          }
          plVar2 = sub->next;
          iVar4 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
          if (iVar4 == 0) break;
          iVar4 = lyp_yin_fill_ext(child,LYEXT_PAR_NODE,LYEXT_SUBSTMT_SELF,'\0',module,sub,
                                   &child->ext,child->ext_size,unres);
          child->ext_size = child->ext_size + '\x01';
          sub = plVar2;
          if (iVar4 != 0) goto LAB_0015c6f2;
        }
        iVar4 = fill_yin_typedef(module,child,sub,
                                 (lys_tpdf *)
                                 (*(long *)child->hash +
                                 (ulong)*(ushort *)(child->padding + 2) * 0x80),unres);
        *(short *)(child->padding + 2) = *(short *)(child->padding + 2) + 1;
        sub = plVar2;
      } while (iVar4 == 0);
    }
  }
LAB_0015c6f2:
  lys_node_free(child,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
  while (root.child != (lyxml_elem *)0x0) {
    lyxml_free(ctx_00,root.child);
  }
  child = (lys_node *)0x0;
LAB_0015c72b:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return child;
LAB_0015c6b5:
  if (sub == (lyxml_elem *)0x0) goto LAB_0015c72b;
  plVar2 = sub->next;
  iVar4 = strcmp(sub->name,"container");
  if (iVar4 == 0) {
    node = read_yin_container(module,child,sub,options_00,unres);
  }
  else {
    iVar4 = strcmp(sub->name,"leaf-list");
    if (iVar4 == 0) {
      node = read_yin_leaflist(module,child,sub,options_00,unres);
    }
    else {
      iVar4 = strcmp(sub->name,"leaf");
      if (iVar4 == 0) {
        node = read_yin_leaf(module,child,sub,options_00,unres);
      }
      else {
        iVar4 = strcmp(sub->name,"list");
        if (iVar4 == 0) {
          node = read_yin_list(module,child,sub,options_00,unres);
        }
        else {
          iVar4 = strcmp(sub->name,"choice");
          if (iVar4 == 0) {
            node = read_yin_choice(module,child,sub,options_00,unres);
          }
          else {
            iVar4 = strcmp(sub->name,"uses");
            if (iVar4 == 0) {
              node = read_yin_uses(module,child,sub,options_00,unres);
            }
            else {
              iVar4 = strcmp(sub->name,"grouping");
              if (iVar4 == 0) {
                node = read_yin_grouping(module,child,sub,options_00,unres);
              }
              else {
                iVar4 = strcmp(sub->name,"anyxml");
                if (iVar4 == 0) {
                  node = read_yin_anydata(module,child,sub,LYS_ANYXML,options_00,unres);
                }
                else {
                  iVar4 = strcmp(sub->name,"anydata");
                  if (iVar4 == 0) {
                    node = read_yin_anydata(module,child,sub,LYS_ANYDATA,options_00,unres);
                  }
                  else {
                    iVar4 = strcmp(sub->name,"action");
                    if (iVar4 == 0) {
                      node = read_yin_rpc_action(module,child,sub,options_00,unres);
                    }
                    else {
                      iVar4 = strcmp(sub->name,"notification");
                      if (iVar4 == 0) {
                        node = read_yin_notif(module,child,sub,options_00,unres);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (node == (lys_node *)0x0) goto LAB_0015c6f2;
  lyxml_free(ctx_00,sub);
  sub = plVar2;
  goto LAB_0015c6b5;
}



lys_node *
read_yin_input_output
          (lys_module *module,lys_node *parent,lyxml_elem *yin,int options,unres_schema *unres)

{
  uint options_00;
  long lVar1;
  ly_ctx *ctx_00;
  lyxml_elem *plVar2;
  long lVar3;
  int iVar4;
  lys_node *child;
  char *pcVar5;
  lys_module *module_00;
  void *pvVar6;
  lys_ext_instance **pplVar7;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  int options_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int c_tpdf;
  int c_must;
  int c_ext;
  int r;
  lyxml_elem *sub;
  lyxml_elem *next;
  lys_node *node;
  lys_node *retval;
  ly_ctx *ctx;
  lys_node_inout *inout;
  lyxml_elem root;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ctx_00 = module->ctx;
  node = (lys_node *)0x0;
  retval = (lys_node *)0x0;
  c_tpdf = 0;
  c_must = 0;
  c_ext = 0;
  memset(&root,0,0x48);
  child = (lys_node *)calloc(1,0x78);
  if (child == (lys_node *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_input_output");
    child = (lys_node *)0x0;
    goto LAB_0015d3ae;
  }
  child->prev = child;
  iVar4 = strcmp(yin->name,"input");
  if (iVar4 == 0) {
    child->nodetype = LYS_INPUT;
    pcVar5 = lydict_insert(ctx_00,"input",0);
    child->name = pcVar5;
  }
  else {
    iVar4 = strcmp(yin->name,"output");
    if (iVar4 != 0) {
      ly_log(ctx_00,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yin.c"
             ,0x173d);
      free(child);
      goto LAB_0015d375;
    }
    child->nodetype = LYS_OUTPUT;
    pcVar5 = lydict_insert(ctx_00,"output",0);
    child->name = pcVar5;
  }
  child->module = module;
  ly_log_dbg(4,"parsing %s statement \"%s\"",yin->name,child->name);
  module_00 = lys_main_module(module);
  iVar4 = lys_node_addchild(parent,module_00,child,options);
  retval = child;
  if (iVar4 == 0) {
    sub = yin->child;
    while (sub != (lyxml_elem *)0x0) {
      plVar2 = sub->next;
      if (sub->ns == (lyxml_ns *)0x0) {
        lyxml_free(ctx_00,sub);
        sub = plVar2;
      }
      else {
        iVar4 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar4 == 0) {
          iVar4 = strcmp(sub->name,"container");
          if ((((((iVar4 == 0) || (iVar4 = strcmp(sub->name,"leaf-list"), iVar4 == 0)) ||
                (iVar4 = strcmp(sub->name,"leaf"), iVar4 == 0)) ||
               ((iVar4 = strcmp(sub->name,"list"), iVar4 == 0 ||
                (iVar4 = strcmp(sub->name,"choice"), iVar4 == 0)))) ||
              ((iVar4 = strcmp(sub->name,"uses"), iVar4 == 0 ||
               ((iVar4 = strcmp(sub->name,"grouping"), iVar4 == 0 ||
                (iVar4 = strcmp(sub->name,"anyxml"), iVar4 == 0)))))) ||
             (iVar4 = strcmp(sub->name,"anydata"), iVar4 == 0)) {
            lyxml_unlink_elem(ctx_00,sub,2);
            lyxml_add_child(ctx_00,&root,sub);
            sub = plVar2;
          }
          else {
            iVar4 = strcmp(sub->name,"typedef");
            if (iVar4 == 0) {
              if (c_tpdf == 0xffff) {
                if (child->nodetype == LYS_INPUT) {
                  pcVar5 = "input";
                }
                else {
                  pcVar5 = "output";
                }
                ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement."
                       ,0xffff,"typedefs",pcVar5);
                goto LAB_0015d375;
              }
              c_tpdf = c_tpdf + 1;
              sub = plVar2;
            }
            else {
              if ((((byte)module->field_0x40 >> 1 & 7) < 2) ||
                 (iVar4 = strcmp(sub->name,"must"), iVar4 != 0)) {
                ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_LYS,child,sub->name);
                goto LAB_0015d375;
              }
              if (c_must == 0xff) {
                if (child->nodetype == LYS_INPUT) {
                  pcVar5 = "input";
                }
                else {
                  pcVar5 = "output";
                }
                ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement."
                       ,0xff,"musts",pcVar5);
                goto LAB_0015d375;
              }
              c_must = c_must + 1;
              sub = plVar2;
            }
          }
        }
        else {
          if (c_ext == 0xff) {
            if (child->nodetype == LYS_INPUT) {
              pcVar5 = "input";
            }
            else {
              pcVar5 = "output";
            }
            ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                   0xff,"extensions",pcVar5);
            goto LAB_0015d375;
          }
          c_ext = c_ext + 1;
          sub = plVar2;
        }
      }
    }
    if (c_tpdf != 0) {
      pvVar6 = calloc((long)c_tpdf,0x80);
      *(void **)child->hash = pvVar6;
      lVar3._0_1_ = child->hash[0];
      lVar3._1_1_ = child->hash[1];
      lVar3._2_1_ = child->hash[2];
      lVar3._3_1_ = child->hash[3];
      lVar3._4_4_ = *(undefined4 *)&child->field_0x6c;
      if (lVar3 == 0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_input_output");
        goto LAB_0015d375;
      }
    }
    if (c_must != 0) {
      pcVar5 = (char *)calloc((long)c_must,0x38);
      child[1].name = pcVar5;
      if (child[1].name == (char *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_input_output");
        goto LAB_0015d375;
      }
    }
    if (c_ext != 0) {
      pplVar7 = (lys_ext_instance **)calloc((long)c_ext,8);
      child->ext = pplVar7;
      if (child->ext == (lys_ext_instance **)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_input_output");
        goto LAB_0015d375;
      }
    }
    sub = yin->child;
    do {
      while( true ) {
        if (sub == (lyxml_elem *)0x0) {
          options_00 = options | 2;
          sub = root.child;
          goto LAB_0015d2da;
        }
        plVar2 = sub->next;
        iVar4 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar4 == 0) break;
        iVar4 = lyp_yin_fill_ext(child,LYEXT_PAR_NODE,LYEXT_SUBSTMT_SELF,'\0',module,sub,&child->ext
                                 ,child->ext_size,unres);
        child->ext_size = child->ext_size + '\x01';
joined_r0x0015cf5d:
        sub = plVar2;
        if (iVar4 != 0) goto LAB_0015d375;
      }
      iVar4 = strcmp(sub->name,"must");
      if (iVar4 == 0) {
        iVar4 = fill_yin_must(module,sub,
                              (lys_restr *)(child[1].name + (ulong)child->padding[1] * 0x38),unres);
        child->padding[1] = child->padding[1] + '\x01';
        goto joined_r0x0015cf5d;
      }
      iVar4 = fill_yin_typedef(module,child,sub,
                               (lys_tpdf *)
                               (*(long *)child->hash + (ulong)*(ushort *)(child->padding + 2) * 0x80
                               ),unres);
      *(short *)(child->padding + 2) = *(short *)(child->padding + 2) + 1;
      sub = plVar2;
    } while (iVar4 == 0);
  }
  goto LAB_0015d375;
LAB_0015d2da:
  if (sub == (lyxml_elem *)0x0) goto code_r0x0015d301;
  plVar2 = sub->next;
  iVar4 = strcmp(sub->name,"container");
  if (iVar4 == 0) {
    node = read_yin_container(module,child,sub,options_00,unres);
  }
  else {
    iVar4 = strcmp(sub->name,"leaf-list");
    if (iVar4 == 0) {
      node = read_yin_leaflist(module,child,sub,options_00,unres);
    }
    else {
      iVar4 = strcmp(sub->name,"leaf");
      if (iVar4 == 0) {
        node = read_yin_leaf(module,child,sub,options_00,unres);
      }
      else {
        iVar4 = strcmp(sub->name,"list");
        if (iVar4 == 0) {
          node = read_yin_list(module,child,sub,options_00,unres);
        }
        else {
          iVar4 = strcmp(sub->name,"choice");
          if (iVar4 == 0) {
            node = read_yin_choice(module,child,sub,options_00,unres);
          }
          else {
            iVar4 = strcmp(sub->name,"uses");
            if (iVar4 == 0) {
              node = read_yin_uses(module,child,sub,options_00,unres);
            }
            else {
              iVar4 = strcmp(sub->name,"grouping");
              if (iVar4 == 0) {
                node = read_yin_grouping(module,child,sub,options_00,unres);
              }
              else {
                iVar4 = strcmp(sub->name,"anyxml");
                if (iVar4 == 0) {
                  node = read_yin_anydata(module,child,sub,LYS_ANYXML,options_00,unres);
                }
                else {
                  iVar4 = strcmp(sub->name,"anydata");
                  if (iVar4 == 0) {
                    node = read_yin_anydata(module,child,sub,LYS_ANYDATA,options_00,unres);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (node == (lys_node *)0x0) goto LAB_0015d375;
  lyxml_free(ctx_00,sub);
  sub = plVar2;
  goto LAB_0015d2da;
code_r0x0015d301:
  if ((((ctx_00->models).flags & 2U) != 0) || (child[1].name == (char *)0x0)) goto LAB_0015d3ae;
  if ((options & 4U) == 0) {
    iVar4 = unres_schema_add_node(module,unres,child,UNRES_XPATH,(lys_node *)0x0);
    if (iVar4 != -1) goto LAB_0015d3ae;
  }
  else {
    iVar4 = lyxp_node_check_syntax(child);
    if (iVar4 == 0) goto LAB_0015d3ae;
  }
LAB_0015d375:
  lys_node_free(retval,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
  while (root.child != (lyxml_elem *)0x0) {
    lyxml_free(ctx_00,root.child);
  }
  child = (lys_node *)0x0;
LAB_0015d3ae:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return child;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_node *
read_yin_notif(lys_module *module,lys_node *parent,lyxml_elem *yin,int options,unres_schema *unres)

{
  uint options_00;
  long lVar1;
  ly_ctx *ctx_00;
  lyxml_elem *plVar2;
  int iVar3;
  lys_node *child;
  lys_module *module_00;
  char *pcVar4;
  lys_iffeature *plVar5;
  lys_ext_instance **pplVar6;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  int options_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int c_tpdf;
  int c_ftrs;
  int c_must;
  int c_ext;
  int r;
  lyxml_elem *sub;
  lyxml_elem *next;
  lys_node *node;
  ly_ctx *ctx;
  lys_node_notif *notif;
  lys_node *retval;
  void *reallocated;
  lyxml_elem root;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ctx_00 = module->ctx;
  node = (lys_node *)0x0;
  c_tpdf = 0;
  c_ftrs = 0;
  c_must = 0;
  c_ext = 0;
  if ((parent != (lys_node *)0x0) && (((byte)module->field_0x40 >> 1 & 7) < 2)) {
    ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_LYS,parent,"notification");
    child = (lys_node *)0x0;
    goto LAB_0015e202;
  }
  memset(&root,0,0x48);
  child = (lys_node *)calloc(1,0x80);
  if (child == (lys_node *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_notif");
    child = (lys_node *)0x0;
    goto LAB_0015e202;
  }
  child->nodetype = LYS_NOTIF;
  child->prev = child;
  iVar3 = read_yin_common(module,parent,child,LYEXT_PAR_NODE,yin,0x11,unres);
  if (iVar3 == 0) {
    ly_log_dbg(4,"parsing %s statement \"%s\"",yin->name,child->name);
    module_00 = lys_main_module(module);
    iVar3 = lys_node_addchild(parent,module_00,child,options);
    if (iVar3 == 0) {
      sub = yin->child;
      while (sub != (lyxml_elem *)0x0) {
        plVar2 = sub->next;
        iVar3 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar3 == 0) {
          iVar3 = strcmp(sub->name,"container");
          if ((((((iVar3 == 0) || (iVar3 = strcmp(sub->name,"leaf-list"), iVar3 == 0)) ||
                (iVar3 = strcmp(sub->name,"leaf"), iVar3 == 0)) ||
               ((iVar3 = strcmp(sub->name,"list"), iVar3 == 0 ||
                (iVar3 = strcmp(sub->name,"choice"), iVar3 == 0)))) ||
              ((iVar3 = strcmp(sub->name,"uses"), iVar3 == 0 ||
               ((iVar3 = strcmp(sub->name,"grouping"), iVar3 == 0 ||
                (iVar3 = strcmp(sub->name,"anyxml"), iVar3 == 0)))))) ||
             (iVar3 = strcmp(sub->name,"anydata"), iVar3 == 0)) {
            lyxml_unlink_elem(ctx_00,sub,2);
            lyxml_add_child(ctx_00,&root,sub);
            sub = plVar2;
          }
          else {
            iVar3 = strcmp(sub->name,"typedef");
            if (iVar3 == 0) {
              if (c_tpdf == 0xffff) {
                ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement."
                       ,0xffff,"typedefs","notification");
                goto LAB_0015e1c9;
              }
              c_tpdf = c_tpdf + 1;
              sub = plVar2;
            }
            else {
              iVar3 = strcmp(sub->name,"if-feature");
              if (iVar3 == 0) {
                if (c_ftrs == 0xff) {
                  ly_log(ctx_00,LY_LLERR,LY_EINT,
                         "Reached limit (%lu) for storing %s in %s statement.",0xff,"if-features",
                         "notification");
                  goto LAB_0015e1c9;
                }
                c_ftrs = c_ftrs + 1;
                sub = plVar2;
              }
              else {
                if ((((byte)module->field_0x40 >> 1 & 7) < 2) ||
                   (iVar3 = strcmp(sub->name,"must"), iVar3 != 0)) {
                  ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_LYS,child,sub->name);
                  goto LAB_0015e1c9;
                }
                if (c_must == 0xff) {
                  ly_log(ctx_00,LY_LLERR,LY_EINT,
                         "Reached limit (%lu) for storing %s in %s statement.",0xff,"musts",
                         "notification");
                  goto LAB_0015e1c9;
                }
                c_must = c_must + 1;
                sub = plVar2;
              }
            }
          }
        }
        else {
          if (c_ext == 0xff) {
            ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                   0xff,"extensions","notification");
            goto LAB_0015e1c9;
          }
          c_ext = c_ext + 1;
          sub = plVar2;
        }
      }
      if (c_tpdf != 0) {
        pcVar4 = (char *)calloc((long)c_tpdf,0x80);
        child[1].name = pcVar4;
        if (child[1].name == (char *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_notif");
          goto LAB_0015e1c9;
        }
      }
      if (c_ftrs != 0) {
        plVar5 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
        child->iffeature = plVar5;
        if (child->iffeature == (lys_iffeature *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_notif");
          goto LAB_0015e1c9;
        }
      }
      if (c_must != 0) {
        pcVar4 = (char *)calloc((long)c_must,0x38);
        child[1].dsc = pcVar4;
        if (child[1].dsc == (char *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_notif");
          goto LAB_0015e1c9;
        }
      }
      if (c_ext != 0) {
        pplVar6 = (lys_ext_instance **)
                  realloc(child->ext,(long)(int)(c_ext + (uint)child->ext_size) * 8);
        if (pplVar6 == (lys_ext_instance **)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_notif");
          goto LAB_0015e1c9;
        }
        child->ext = pplVar6;
        memset(child->ext + child->ext_size,0,(long)c_ext * 8);
      }
      plVar2 = yin->child;
      do {
        do {
          while( true ) {
            sub = plVar2;
            if (sub == (lyxml_elem *)0x0) {
              options_00 = options | 2;
              sub = root.child;
              goto LAB_0015e125;
            }
            plVar2 = sub->next;
            iVar3 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
            if (iVar3 == 0) break;
            iVar3 = lyp_yin_fill_ext(child,LYEXT_PAR_NODE,LYEXT_SUBSTMT_SELF,'\0',module,sub,
                                     &child->ext,child->ext_size,unres);
            child->ext_size = child->ext_size + '\x01';
joined_r0x0015dcae:
            if (iVar3 != 0) goto LAB_0015e1c9;
          }
          iVar3 = strcmp(sub->name,"typedef");
          if (iVar3 == 0) {
            iVar3 = fill_yin_typedef(module,child,sub,
                                     (lys_tpdf *)
                                     (child[1].name + (ulong)*(ushort *)(child->padding + 2) * 0x80)
                                     ,unres);
            *(short *)(child->padding + 2) = *(short *)(child->padding + 2) + 1;
            goto joined_r0x0015dcae;
          }
          iVar3 = strcmp(sub->name,"if-feature");
          if (iVar3 == 0) {
            iVar3 = fill_yin_iffeature(child,0,sub,child->iffeature + child->iffeature_size,unres);
            child->iffeature_size = child->iffeature_size + '\x01';
            goto joined_r0x0015dcae;
          }
          iVar3 = strcmp(sub->name,"must");
        } while (iVar3 != 0);
        iVar3 = fill_yin_must(module,sub,
                              (lys_restr *)(child[1].dsc + (ulong)child->padding[1] * 0x38),unres);
        child->padding[1] = child->padding[1] + '\x01';
      } while (iVar3 == 0);
    }
  }
LAB_0015e1c9:
  lys_node_free(child,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
  while (root.child != (lyxml_elem *)0x0) {
    lyxml_free(ctx_00,root.child);
  }
  child = (lys_node *)0x0;
LAB_0015e202:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return child;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_0015e125:
  if (sub == (lyxml_elem *)0x0) goto code_r0x0015e152;
  plVar2 = sub->next;
  iVar3 = strcmp(sub->name,"container");
  if (iVar3 == 0) {
    node = read_yin_container(module,child,sub,options_00,unres);
  }
  else {
    iVar3 = strcmp(sub->name,"leaf-list");
    if (iVar3 == 0) {
      node = read_yin_leaflist(module,child,sub,options_00,unres);
    }
    else {
      iVar3 = strcmp(sub->name,"leaf");
      if (iVar3 == 0) {
        node = read_yin_leaf(module,child,sub,options_00,unres);
      }
      else {
        iVar3 = strcmp(sub->name,"list");
        if (iVar3 == 0) {
          node = read_yin_list(module,child,sub,options_00,unres);
        }
        else {
          iVar3 = strcmp(sub->name,"choice");
          if (iVar3 == 0) {
            node = read_yin_choice(module,child,sub,options_00,unres);
          }
          else {
            iVar3 = strcmp(sub->name,"uses");
            if (iVar3 == 0) {
              node = read_yin_uses(module,child,sub,options_00,unres);
            }
            else {
              iVar3 = strcmp(sub->name,"grouping");
              if (iVar3 == 0) {
                node = read_yin_grouping(module,child,sub,options_00,unres);
              }
              else {
                iVar3 = strcmp(sub->name,"anyxml");
                if (iVar3 == 0) {
                  node = read_yin_anydata(module,child,sub,LYS_ANYXML,options_00,unres);
                }
                else {
                  iVar3 = strcmp(sub->name,"anydata");
                  if (iVar3 == 0) {
                    node = read_yin_anydata(module,child,sub,LYS_ANYDATA,options_00,unres);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (node == (lys_node *)0x0) goto LAB_0015e1c9;
  lyxml_free(ctx_00,sub);
  sub = plVar2;
  goto LAB_0015e125;
code_r0x0015e152:
  if ((((ctx_00->models).flags & 2U) != 0) || (child[1].dsc == (char *)0x0)) goto LAB_0015e202;
  if ((options & 4U) == 0) {
    iVar3 = unres_schema_add_node(module,unres,child,UNRES_XPATH,(lys_node *)0x0);
    if (iVar3 != -1) goto LAB_0015e202;
  }
  else {
    iVar3 = lyxp_node_check_syntax(child);
    if (iVar3 == 0) goto LAB_0015e202;
  }
  goto LAB_0015e1c9;
}



lys_node *
read_yin_rpc_action(lys_module *module,lys_node *parent,lyxml_elem *yin,int options,
                   unres_schema *unres)

{
  long lVar1;
  ly_ctx *ctx_00;
  lyxml_elem *plVar2;
  bool bVar3;
  bool bVar4;
  int iVar5;
  lys_node *child;
  lys_module *module_00;
  char *pcVar6;
  lys_iffeature *plVar7;
  lys_ext_instance **pplVar8;
  LYS_NODE LVar9;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  int options_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int c_tpdf;
  int c_ftrs;
  int c_input;
  int c_output;
  int c_ext;
  int r;
  lyxml_elem *sub;
  lyxml_elem *next;
  lys_node *node;
  ly_ctx *ctx;
  lys_node_rpc_action *rpc;
  lys_node *retval;
  void *reallocated;
  lyxml_elem root;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ctx_00 = module->ctx;
  node = (lys_node *)0x0;
  c_tpdf = 0;
  c_ftrs = 0;
  bVar3 = false;
  bVar4 = false;
  c_ext = 0;
  iVar5 = strcmp(yin->name,"action");
  if (iVar5 == 0) {
    node = parent;
    if (((byte)module->field_0x40 >> 1 & 7) < 2) {
      ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_LYS,parent,"action");
      child = (lys_node *)0x0;
      goto LAB_0015edb8;
    }
    for (; node != (lys_node *)0x0; node = lys_parent(node)) {
      if (((node->nodetype & 0x4180) != LYS_UNKNOWN) ||
         ((node->nodetype == LYS_LIST && (node->padding[2] == '\0')))) {
        pcVar6 = strnodetype(node->nodetype);
        ly_vlog(ctx_00,LYE_INPAR,LY_VLOG_LYS,parent,pcVar6,"action");
        child = (lys_node *)0x0;
        goto LAB_0015edb8;
      }
    }
  }
  memset(&root,0,0x48);
  child = (lys_node *)calloc(1,0x78);
  if (child == (lys_node *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_rpc_action");
    child = (lys_node *)0x0;
    goto LAB_0015edb8;
  }
  iVar5 = strcmp(yin->name,"rpc");
  if (iVar5 == 0) {
    LVar9 = LYS_RPC;
  }
  else {
    LVar9 = LYS_ACTION;
  }
  child->nodetype = LVar9;
  child->prev = child;
  iVar5 = read_yin_common(module,parent,child,LYEXT_PAR_NODE,yin,0x11,unres);
  if (iVar5 == 0) {
    ly_log_dbg(4,"parsing %s statement \"%s\"",yin->name,child->name);
    module_00 = lys_main_module(module);
    iVar5 = lys_node_addchild(parent,module_00,child,options);
    if (iVar5 == 0) {
      sub = yin->child;
      while (sub != (lyxml_elem *)0x0) {
        plVar2 = sub->next;
        iVar5 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
        if (iVar5 == 0) {
          iVar5 = strcmp(sub->name,"input");
          if (iVar5 == 0) {
            if (bVar3) {
              ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
              goto LAB_0015ed7f;
            }
            bVar3 = true;
            lyxml_unlink_elem(ctx_00,sub,2);
            lyxml_add_child(ctx_00,&root,sub);
            sub = plVar2;
          }
          else {
            iVar5 = strcmp(sub->name,"output");
            if (iVar5 == 0) {
              if (bVar4) {
                ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
                goto LAB_0015ed7f;
              }
              bVar4 = true;
              lyxml_unlink_elem(ctx_00,sub,2);
              lyxml_add_child(ctx_00,&root,sub);
              sub = plVar2;
            }
            else {
              iVar5 = strcmp(sub->name,"grouping");
              if (iVar5 == 0) {
                lyxml_unlink_elem(ctx_00,sub,2);
                lyxml_add_child(ctx_00,&root,sub);
                sub = plVar2;
              }
              else {
                iVar5 = strcmp(sub->name,"typedef");
                if (iVar5 == 0) {
                  if (c_tpdf == 0xffff) {
                    if (child->nodetype == LYS_RPC) {
                      pcVar6 = "rpc";
                    }
                    else {
                      pcVar6 = "action";
                    }
                    ly_log(ctx_00,LY_LLERR,LY_EINT,
                           "Reached limit (%lu) for storing %s in %s statement.",0xffff,"typedefs",
                           pcVar6);
                    goto LAB_0015ed7f;
                  }
                  c_tpdf = c_tpdf + 1;
                  sub = plVar2;
                }
                else {
                  iVar5 = strcmp(sub->name,"if-feature");
                  if (iVar5 != 0) {
                    ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_LYS,child,sub->name);
                    goto LAB_0015ed7f;
                  }
                  if (c_ftrs == 0xff) {
                    if (child->nodetype == LYS_RPC) {
                      pcVar6 = "rpc";
                    }
                    else {
                      pcVar6 = "action";
                    }
                    ly_log(ctx_00,LY_LLERR,LY_EINT,
                           "Reached limit (%lu) for storing %s in %s statement.",0xff,"if-features",
                           pcVar6);
                    goto LAB_0015ed7f;
                  }
                  c_ftrs = c_ftrs + 1;
                  sub = plVar2;
                }
              }
            }
          }
        }
        else {
          if (c_ext == 0xff) {
            if (child->nodetype == LYS_RPC) {
              pcVar6 = "rpc";
            }
            else {
              pcVar6 = "action";
            }
            ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                   0xff,"extensions",pcVar6);
            goto LAB_0015ed7f;
          }
          c_ext = c_ext + 1;
          sub = plVar2;
        }
      }
      if (c_tpdf != 0) {
        pcVar6 = (char *)calloc((long)c_tpdf,0x80);
        child[1].name = pcVar6;
        if (child[1].name == (char *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_rpc_action");
          goto LAB_0015ed7f;
        }
      }
      if (c_ftrs != 0) {
        plVar7 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
        child->iffeature = plVar7;
        if (child->iffeature == (lys_iffeature *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_rpc_action");
          goto LAB_0015ed7f;
        }
      }
      if (c_ext != 0) {
        pplVar8 = (lys_ext_instance **)
                  realloc(child->ext,(long)(int)(c_ext + (uint)child->ext_size) * 8);
        if (pplVar8 == (lys_ext_instance **)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_rpc_action");
          goto LAB_0015ed7f;
        }
        child->ext = pplVar8;
        memset(child->ext + child->ext_size,0,(long)c_ext * 8);
      }
      plVar2 = yin->child;
      do {
        do {
          while( true ) {
            sub = plVar2;
            if (sub == (lyxml_elem *)0x0) {
              sub = root.child;
              goto LAB_0015ed42;
            }
            plVar2 = sub->next;
            iVar5 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
            if (iVar5 == 0) break;
            iVar5 = lyp_yin_fill_ext(child,LYEXT_PAR_NODE,LYEXT_SUBSTMT_SELF,'\0',module,sub,
                                     &child->ext,child->ext_size,unres);
            child->ext_size = child->ext_size + '\x01';
joined_r0x0015eb8f:
            if (iVar5 != 0) goto LAB_0015ed7f;
          }
          iVar5 = strcmp(sub->name,"typedef");
          if (iVar5 == 0) {
            iVar5 = fill_yin_typedef(module,child,sub,
                                     (lys_tpdf *)
                                     (child[1].name + (ulong)*(ushort *)(child->padding + 2) * 0x80)
                                     ,unres);
            *(short *)(child->padding + 2) = *(short *)(child->padding + 2) + 1;
            goto joined_r0x0015eb8f;
          }
          iVar5 = strcmp(sub->name,"if-feature");
        } while (iVar5 != 0);
        iVar5 = fill_yin_iffeature(child,0,sub,child->iffeature + child->iffeature_size,unres);
        child->iffeature_size = child->iffeature_size + '\x01';
      } while (iVar5 == 0);
    }
  }
LAB_0015ed7f:
  lys_node_free(child,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
  while (root.child != (lyxml_elem *)0x0) {
    lyxml_free(ctx_00,root.child);
  }
  child = (lys_node *)0x0;
LAB_0015edb8:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return child;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_0015ed42:
  if (sub == (lyxml_elem *)0x0) goto LAB_0015edb8;
  plVar2 = sub->next;
  iVar5 = strcmp(sub->name,"grouping");
  if (iVar5 == 0) {
    node = read_yin_grouping(module,child,sub,options,unres);
  }
  else {
    iVar5 = strcmp(sub->name,"input");
    if ((iVar5 == 0) || (iVar5 = strcmp(sub->name,"output"), iVar5 == 0)) {
      node = read_yin_input_output(module,child,sub,options,unres);
    }
  }
  if (node == (lys_node *)0x0) goto LAB_0015ed7f;
  lyxml_free(ctx_00,sub);
  sub = plVar2;
  goto LAB_0015ed42;
}



lys_node *
read_yin_uses(lys_module *module,lys_node *parent,lyxml_elem *yin,int options,unres_schema *unres)

{
  ly_ctx *ctx_00;
  long lVar1;
  long lVar2;
  lyxml_elem *plVar3;
  long lVar4;
  int iVar5;
  lys_node *child;
  char *pcVar6;
  lys_module *module_00;
  lys_when *plVar7;
  lys_iffeature *plVar8;
  lys_ext_instance **pplVar9;
  unres_schema *unres_local;
  int options_local;
  lyxml_elem *yin_local;
  lys_node *parent_local;
  lys_module *module_local;
  int c_ref;
  int c_aug;
  int c_ftrs;
  int c_ext;
  int r;
  lyxml_elem *sub;
  lyxml_elem *next;
  ly_ctx *ctx;
  lys_node_uses *uses;
  lys_node *retval;
  char *value;
  void *reallocated;
  
  ctx_00 = module->ctx;
  c_ref = 0;
  c_aug = 0;
  c_ftrs = 0;
  c_ext = 0;
  child = (lys_node *)calloc(1,0x88);
  if (child == (lys_node *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_uses");
    return (lys_node *)0x0;
  }
  child->nodetype = LYS_USES;
  child->prev = child;
  pcVar6 = lyxml_get_attr(yin,"name",(char *)0x0);
  if (pcVar6 == (char *)0x0) {
    ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,yin->name);
  }
  else {
    pcVar6 = lydict_insert(ctx_00,pcVar6,0);
    child->name = pcVar6;
    iVar5 = read_yin_common(module,parent,child,LYEXT_PAR_NODE,yin,0x10,unres);
    if (iVar5 == 0) {
      ly_log_dbg(4,"parsing %s statement \"%s\"",yin->name,child->name);
      module_00 = lys_main_module(module);
      iVar5 = lys_node_addchild(parent,module_00,child,options);
      if (iVar5 == 0) {
        sub = yin->child;
        while (sub != (lyxml_elem *)0x0) {
          plVar3 = sub->next;
          iVar5 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
          if (iVar5 == 0) {
            iVar5 = strcmp(sub->name,"refine");
            if (iVar5 == 0) {
              if (c_ref == 0xff) {
                ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement."
                       ,0xff,"refines",&DAT_002145ea);
                goto LAB_0015f720;
              }
              c_ref = c_ref + 1;
              sub = plVar3;
            }
            else {
              iVar5 = strcmp(sub->name,"augment");
              if (iVar5 == 0) {
                if (c_aug == 0xff) {
                  ly_log(ctx_00,LY_LLERR,LY_EINT,
                         "Reached limit (%lu) for storing %s in %s statement.",0xff,"augments",
                         &DAT_002145ea);
                  goto LAB_0015f720;
                }
                c_aug = c_aug + 1;
                sub = plVar3;
              }
              else {
                iVar5 = strcmp(sub->name,"if-feature");
                if (iVar5 == 0) {
                  if (c_ftrs == 0xff) {
                    ly_log(ctx_00,LY_LLERR,LY_EINT,
                           "Reached limit (%lu) for storing %s in %s statement.",0xff,"if-features",
                           &DAT_002145ea);
                    goto LAB_0015f720;
                  }
                  c_ftrs = c_ftrs + 1;
                  sub = plVar3;
                }
                else {
                  iVar5 = strcmp(sub->name,"when");
                  if (iVar5 != 0) {
                    ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_LYS,child,sub->name);
                    goto LAB_0015f720;
                  }
                  lVar1._0_1_ = child->hash[0];
                  lVar1._1_1_ = child->hash[1];
                  lVar1._2_1_ = child->hash[2];
                  lVar1._3_1_ = child->hash[3];
                  lVar1._4_4_ = *(undefined4 *)&child->field_0x6c;
                  if (lVar1 != 0) {
                    ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_LYS,child,sub->name,yin->name);
                    goto LAB_0015f720;
                  }
                  plVar7 = read_yin_when(module,sub,unres);
                  *(lys_when **)child->hash = plVar7;
                  lVar2._0_1_ = child->hash[0];
                  lVar2._1_1_ = child->hash[1];
                  lVar2._2_1_ = child->hash[2];
                  lVar2._3_1_ = child->hash[3];
                  lVar2._4_4_ = *(undefined4 *)&child->field_0x6c;
                  if (lVar2 == 0) {
                    lyxml_free(ctx_00,sub);
                    goto LAB_0015f720;
                  }
                  lyxml_free(ctx_00,sub);
                  sub = plVar3;
                }
              }
            }
          }
          else {
            if (c_ext == 0xff) {
              ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                     0xff,"extensions",&DAT_002145ea);
              goto LAB_0015f720;
            }
            c_ext = c_ext + 1;
            sub = plVar3;
          }
        }
        if (c_ref != 0) {
          pcVar6 = (char *)calloc((long)c_ref,0x50);
          child[1].name = pcVar6;
          if (child[1].name == (char *)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_uses");
            goto LAB_0015f720;
          }
        }
        if (c_aug != 0) {
          pcVar6 = (char *)calloc((long)c_aug,0x68);
          child[1].dsc = pcVar6;
          if (child[1].dsc == (char *)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_uses");
            goto LAB_0015f720;
          }
        }
        if (c_ftrs != 0) {
          plVar8 = (lys_iffeature *)calloc((long)c_ftrs,0x20);
          child->iffeature = plVar8;
          if (child->iffeature == (lys_iffeature *)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_uses");
            goto LAB_0015f720;
          }
        }
        if (c_ext != 0) {
          pplVar9 = (lys_ext_instance **)
                    realloc(child->ext,(long)(int)(c_ext + (uint)child->ext_size) * 8);
          if (pplVar9 == (lys_ext_instance **)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_yin_uses");
            goto LAB_0015f720;
          }
          child->ext = pplVar9;
          memset(child->ext + child->ext_size,0,(long)c_ext * 8);
        }
        plVar3 = yin->child;
        do {
          do {
            while( true ) {
              sub = plVar3;
              if (sub == (lyxml_elem *)0x0) {
                iVar5 = unres_schema_add_node(module,unres,child,UNRES_USES,(lys_node *)0x0);
                if (iVar5 != -1) {
                  if (((ctx_00->models).flags & 2U) != 0) {
                    return child;
                  }
                  lVar4._0_1_ = child->hash[0];
                  lVar4._1_1_ = child->hash[1];
                  lVar4._2_1_ = child->hash[2];
                  lVar4._3_1_ = child->hash[3];
                  lVar4._4_4_ = *(undefined4 *)&child->field_0x6c;
                  if (lVar4 == 0) {
                    return child;
                  }
                  if ((options & 4U) == 0) {
                    iVar5 = unres_schema_add_node(module,unres,child,UNRES_XPATH,(lys_node *)0x0);
                    if (iVar5 != -1) {
                      return child;
                    }
                  }
                  else {
                    iVar5 = lyxp_node_check_syntax(child);
                    if (iVar5 == 0) {
                      return child;
                    }
                  }
                }
                goto LAB_0015f720;
              }
              plVar3 = sub->next;
              iVar5 = strcmp(sub->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
              if (iVar5 == 0) break;
              iVar5 = lyp_yin_fill_ext(child,LYEXT_PAR_NODE,LYEXT_SUBSTMT_SELF,'\0',module,sub,
                                       &child->ext,child->ext_size,unres);
              child->ext_size = child->ext_size + '\x01';
joined_r0x0015f55d:
              if (iVar5 != 0) goto LAB_0015f720;
            }
            iVar5 = strcmp(sub->name,"refine");
            if (iVar5 == 0) {
              iVar5 = fill_yin_refine(child,sub,
                                      (lys_refine *)
                                      (child[1].name + (ulong)child->padding[2] * 0x50),unres);
              child->padding[2] = child->padding[2] + '\x01';
              goto joined_r0x0015f55d;
            }
            iVar5 = strcmp(sub->name,"augment");
            if (iVar5 == 0) {
              iVar5 = fill_yin_augment(module,child,sub,
                                       (lys_node_augment *)
                                       (child[1].dsc + (ulong)child->padding[3] * 0x68),options,
                                       unres);
              child->padding[3] = child->padding[3] + '\x01';
              goto joined_r0x0015f55d;
            }
            iVar5 = strcmp(sub->name,"if-feature");
          } while (iVar5 != 0);
          iVar5 = fill_yin_iffeature(child,0,sub,child->iffeature + child->iffeature_size,unres);
          child->iffeature_size = child->iffeature_size + '\x01';
        } while (iVar5 == 0);
      }
    }
  }
LAB_0015f720:
  lys_node_free(child,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
  return (lys_node *)0x0;
}



// WARNING: Type propagation algorithm not settling

int read_sub_module(lys_module *module,lys_submodule *submodule,lyxml_elem *yin,unres_schema *unres)

{
  long lVar1;
  ly_ctx *ctx_00;
  lyxml_elem *plVar2;
  bool bVar3;
  int iVar4;
  lys_module *mod;
  char *pcVar5;
  size_t sVar6;
  lys_import *plVar7;
  lys_revision *plVar8;
  lys_tpdf *plVar9;
  lys_ident *plVar10;
  lys_include *plVar11;
  lys_node_augment *plVar12;
  lys_feature *plVar13;
  lys_deviation *plVar14;
  lys_ext *plVar15;
  lys_ext_instance **pplVar16;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  lyxml_elem *yin_local;
  lys_submodule *submodule_local;
  lys_module *module_local;
  int i;
  int ret;
  int version_flag;
  int substmt_group;
  int c_imp;
  int c_rev;
  int c_tpdf;
  int c_ident;
  int c_inc;
  int c_aug;
  int c_ftrs;
  int c_dev;
  int c_ext;
  int c_extinst;
  int r;
  lyxml_elem *next;
  lyxml_elem *child;
  lys_node *node;
  char *substmt_prev;
  ly_ctx *ctx;
  lys_module *trg;
  void *reallocated;
  char *value;
  lyxml_elem root;
  lyxml_elem grps;
  lyxml_elem augs;
  lyxml_elem revs;
  lyxml_elem exts;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ctx_00 = module->ctx;
  node = (lys_node *)0x0;
  ret = -1;
  bVar3 = false;
  c_imp = 0;
  c_rev = 0;
  c_tpdf = 0;
  c_ident = 0;
  c_inc = 0;
  c_aug = 0;
  c_ftrs = 0;
  c_dev = 0;
  c_ext = 0;
  c_extinst = 0;
  mod = module;
  if (submodule != (lys_submodule *)0x0) {
    mod = (lys_module *)submodule;
  }
  memset(&root,0,0x48);
  memset(&grps,0,0x48);
  memset(&augs,0,0x48);
  memset(&exts,0,0x48);
  memset(&revs,0,0x48);
  substmt_group = 0;
  substmt_prev = (char *)0x0;
  child = yin->child;
  while (child != (lyxml_elem *)0x0) {
    plVar2 = child->next;
    if (child->ns == (lyxml_ns *)0x0) {
      lyxml_free(ctx_00,child);
      child = plVar2;
    }
    else {
      iVar4 = strcmp(child->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
      if (iVar4 == 0) {
        if ((submodule == (lys_submodule *)0x0) &&
           (iVar4 = strcmp(child->name,"namespace"), iVar4 == 0)) {
          if (substmt_group != 0) {
            ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
            ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "Statement \"%s\" cannot appear after \"%s\" statement.",child->name,
                    substmt_prev);
            goto LAB_00162ae1;
          }
          if (mod->ns != (char *)0x0) {
            ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
            goto LAB_00162ae1;
          }
          pcVar5 = lyxml_get_attr(child,"uri",(char *)0x0);
          if (pcVar5 == (char *)0x0) {
            ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_002148ab,child->name);
            goto LAB_00162ae1;
          }
          sVar6 = strlen(pcVar5);
          pcVar5 = lydict_insert(ctx_00,pcVar5,sVar6);
          mod->ns = pcVar5;
          iVar4 = lyp_yin_parse_subnode_ext
                            (mod,mod,LYEXT_PAR_MODULE,child,LYEXT_SUBSTMT_NAMESPACE,'\0',unres);
          if (iVar4 != 0) goto LAB_00162ae1;
          lyxml_free(ctx_00,child);
          substmt_prev = "namespace";
          child = plVar2;
        }
        else if ((submodule == (lys_submodule *)0x0) &&
                (iVar4 = strcmp(child->name,"prefix"), iVar4 == 0)) {
          if (substmt_group != 0) {
            ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
            ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "Statement \"%s\" cannot appear after \"%s\" statement.",child->name,
                    substmt_prev);
            goto LAB_00162ae1;
          }
          if (mod->prefix != (char *)0x0) {
            ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
            goto LAB_00162ae1;
          }
          pcVar5 = lyxml_get_attr(child,"value",(char *)0x0);
          if (pcVar5 == (char *)0x0) {
            ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",child->name);
            goto LAB_00162ae1;
          }
          iVar4 = lyp_check_identifier(ctx_00,pcVar5,LY_IDENT_PREFIX,mod,(lys_node *)0x0);
          if (iVar4 != 0) goto LAB_00162ae1;
          sVar6 = strlen(pcVar5);
          pcVar5 = lydict_insert(ctx_00,pcVar5,sVar6);
          mod->prefix = pcVar5;
          iVar4 = lyp_yin_parse_subnode_ext
                            (mod,mod,LYEXT_PAR_MODULE,child,LYEXT_SUBSTMT_PREFIX,'\0',unres);
          if (iVar4 != 0) goto LAB_00162ae1;
          lyxml_free(ctx_00,child);
          substmt_prev = "prefix";
          child = plVar2;
        }
        else if ((submodule == (lys_submodule *)0x0) ||
                (iVar4 = strcmp(child->name,"belongs-to"), iVar4 != 0)) {
          iVar4 = strcmp(child->name,"import");
          if (iVar4 == 0) {
            if (1 < (uint)substmt_group) {
              ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
              ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                      "Statement \"%s\" cannot appear after \"%s\" statement.",child->name,
                      substmt_prev);
              goto LAB_00162ae1;
            }
            substmt_group = 1;
            if (c_imp == 0xff) {
              if (submodule == (lys_submodule *)0x0) {
                pcVar5 = "module";
              }
              else {
                pcVar5 = "submodule";
              }
              ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",
                     0xff,"imports",pcVar5);
              goto LAB_00162ae1;
            }
            c_imp = c_imp + 1;
            substmt_prev = "import";
            child = plVar2;
          }
          else {
            iVar4 = strcmp(child->name,"revision");
            if (iVar4 == 0) {
              if (3 < (uint)substmt_group) {
                ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
                ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                        "Statement \"%s\" cannot appear after \"%s\" statement.",child->name,
                        substmt_prev);
                goto LAB_00162ae1;
              }
              substmt_group = 3;
              if (c_rev == 0xff) {
                if (submodule == (lys_submodule *)0x0) {
                  pcVar5 = "module";
                }
                else {
                  pcVar5 = "submodule";
                }
                ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement."
                       ,0xff,"revisions",pcVar5);
                goto LAB_00162ae1;
              }
              c_rev = c_rev + 1;
              lyxml_unlink_elem(ctx_00,child,2);
              lyxml_add_child(ctx_00,&revs,child);
              substmt_prev = "revision";
              child = plVar2;
            }
            else {
              iVar4 = strcmp(child->name,"typedef");
              if (iVar4 == 0) {
                substmt_group = 4;
                if (c_tpdf == 0xffff) {
                  if (submodule == (lys_submodule *)0x0) {
                    pcVar5 = "module";
                  }
                  else {
                    pcVar5 = "submodule";
                  }
                  ly_log(ctx_00,LY_LLERR,LY_EINT,
                         "Reached limit (%lu) for storing %s in %s statement.",0xffff,"typedefs",
                         pcVar5);
                  goto LAB_00162ae1;
                }
                c_tpdf = c_tpdf + 1;
                substmt_prev = "typedef";
                child = plVar2;
              }
              else {
                iVar4 = strcmp(child->name,"identity");
                if (iVar4 == 0) {
                  substmt_group = 4;
                  if (c_ident == 0xffff) {
                    if (submodule == (lys_submodule *)0x0) {
                      pcVar5 = "module";
                    }
                    else {
                      pcVar5 = "submodule";
                    }
                    ly_log(ctx_00,LY_LLERR,LY_EINT,
                           "Reached limit (%lu) for storing %s in %s statement.",0xffff,"identities"
                           ,pcVar5);
                    goto LAB_00162ae1;
                  }
                  c_ident = c_ident + 1;
                  substmt_prev = "identity";
                  child = plVar2;
                }
                else {
                  iVar4 = strcmp(child->name,"include");
                  if (iVar4 == 0) {
                    if (1 < (uint)substmt_group) {
                      ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
                      ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                              "Statement \"%s\" cannot appear after \"%s\" statement.",child->name,
                              substmt_prev);
                      goto LAB_00162ae1;
                    }
                    substmt_group = 1;
                    if (c_inc == 0xff) {
                      if (submodule == (lys_submodule *)0x0) {
                        pcVar5 = "module";
                      }
                      else {
                        pcVar5 = "submodule";
                      }
                      ly_log(ctx_00,LY_LLERR,LY_EINT,
                             "Reached limit (%lu) for storing %s in %s statement.",0xff,"includes",
                             pcVar5);
                      goto LAB_00162ae1;
                    }
                    c_inc = c_inc + 1;
                    substmt_prev = "include";
                    child = plVar2;
                  }
                  else {
                    iVar4 = strcmp(child->name,"augment");
                    if (iVar4 == 0) {
                      substmt_group = 4;
                      if (c_aug == 0xff) {
                        if (submodule == (lys_submodule *)0x0) {
                          pcVar5 = "module";
                        }
                        else {
                          pcVar5 = "submodule";
                        }
                        ly_log(ctx_00,LY_LLERR,LY_EINT,
                               "Reached limit (%lu) for storing %s in %s statement.",0xff,"augments"
                               ,pcVar5);
                        goto LAB_00162ae1;
                      }
                      c_aug = c_aug + 1;
                      lyxml_unlink_elem(ctx_00,child,2);
                      lyxml_add_child(ctx_00,&augs,child);
                      substmt_prev = "augment";
                      child = plVar2;
                    }
                    else {
                      iVar4 = strcmp(child->name,"feature");
                      if (iVar4 == 0) {
                        substmt_group = 4;
                        if (c_ftrs == 0xff) {
                          if (submodule == (lys_submodule *)0x0) {
                            pcVar5 = "module";
                          }
                          else {
                            pcVar5 = "submodule";
                          }
                          ly_log(ctx_00,LY_LLERR,LY_EINT,
                                 "Reached limit (%lu) for storing %s in %s statement.",0xff,
                                 "features",pcVar5);
                          goto LAB_00162ae1;
                        }
                        c_ftrs = c_ftrs + 1;
                        substmt_prev = "feature";
                        child = plVar2;
                      }
                      else {
                        iVar4 = strcmp(child->name,"container");
                        if (((((((iVar4 == 0) ||
                                (iVar4 = strcmp(child->name,"leaf-list"), iVar4 == 0)) ||
                               (iVar4 = strcmp(child->name,"leaf"), iVar4 == 0)) ||
                              ((iVar4 = strcmp(child->name,"list"), iVar4 == 0 ||
                               (iVar4 = strcmp(child->name,"choice"), iVar4 == 0)))) ||
                             ((iVar4 = strcmp(child->name,"uses"), iVar4 == 0 ||
                              ((iVar4 = strcmp(child->name,"anyxml"), iVar4 == 0 ||
                               (iVar4 = strcmp(child->name,"anydata"), iVar4 == 0)))))) ||
                            (iVar4 = strcmp(child->name,"rpc"), iVar4 == 0)) ||
                           (iVar4 = strcmp(child->name,"notification"), iVar4 == 0)) {
                          substmt_group = 4;
                          lyxml_unlink_elem(ctx_00,child,2);
                          lyxml_add_child(ctx_00,&root,child);
                          substmt_prev = "data definition";
                          child = plVar2;
                        }
                        else {
                          iVar4 = strcmp(child->name,"grouping");
                          if (iVar4 == 0) {
                            substmt_group = 4;
                            lyxml_unlink_elem(ctx_00,child,2);
                            lyxml_add_child(ctx_00,&grps,child);
                            substmt_prev = "grouping";
                            child = plVar2;
                          }
                          else {
                            iVar4 = strcmp(child->name,"description");
                            if (iVar4 == 0) {
                              if (2 < (uint)substmt_group) {
                                ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
                                ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                        "Statement \"%s\" cannot appear after \"%s\" statement.",
                                        child->name,substmt_prev);
                                goto LAB_00162ae1;
                              }
                              substmt_group = 2;
                              if (mod->dsc != (char *)0x0) {
                                ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,
                                        yin->name);
                                goto LAB_00162ae1;
                              }
                              iVar4 = lyp_yin_parse_subnode_ext
                                                (mod,mod,LYEXT_PAR_MODULE,child,
                                                 LYEXT_SUBSTMT_DESCRIPTION,'\0',unres);
                              if (iVar4 != 0) goto LAB_00162ae1;
                              pcVar5 = read_yin_subnode(ctx_00,child,"text");
                              mod->dsc = pcVar5;
                              lyxml_free(ctx_00,child);
                              if (mod->dsc == (char *)0x0) goto LAB_00162ae1;
                              substmt_prev = "description";
                              child = plVar2;
                            }
                            else {
                              iVar4 = strcmp(child->name,"reference");
                              if (iVar4 == 0) {
                                if (2 < (uint)substmt_group) {
                                  ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
                                  ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                          "Statement \"%s\" cannot appear after \"%s\" statement.",
                                          child->name,substmt_prev);
                                  goto LAB_00162ae1;
                                }
                                substmt_group = 2;
                                if (mod->ref != (char *)0x0) {
                                  ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,
                                          yin->name);
                                  goto LAB_00162ae1;
                                }
                                iVar4 = lyp_yin_parse_subnode_ext
                                                  (mod,mod,LYEXT_PAR_MODULE,child,
                                                   LYEXT_SUBSTMT_REFERENCE,'\0',unres);
                                if (iVar4 != 0) goto LAB_00162ae1;
                                pcVar5 = read_yin_subnode(ctx_00,child,"text");
                                mod->ref = pcVar5;
                                lyxml_free(ctx_00,child);
                                if (mod->ref == (char *)0x0) goto LAB_00162ae1;
                                substmt_prev = "reference";
                                child = plVar2;
                              }
                              else {
                                iVar4 = strcmp(child->name,"organization");
                                if (iVar4 == 0) {
                                  if (2 < (uint)substmt_group) {
                                    ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
                                    ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                            "Statement \"%s\" cannot appear after \"%s\" statement."
                                            ,child->name,substmt_prev);
                                    goto LAB_00162ae1;
                                  }
                                  substmt_group = 2;
                                  if (mod->org != (char *)0x0) {
                                    ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,
                                            yin->name);
                                    goto LAB_00162ae1;
                                  }
                                  iVar4 = lyp_yin_parse_subnode_ext
                                                    (mod,mod,LYEXT_PAR_MODULE,child,
                                                     LYEXT_SUBSTMT_ORGANIZATION,'\0',unres);
                                  if (iVar4 != 0) goto LAB_00162ae1;
                                  pcVar5 = read_yin_subnode(ctx_00,child,"text");
                                  mod->org = pcVar5;
                                  lyxml_free(ctx_00,child);
                                  if (mod->org == (char *)0x0) goto LAB_00162ae1;
                                  substmt_prev = "organization";
                                  child = plVar2;
                                }
                                else {
                                  iVar4 = strcmp(child->name,"contact");
                                  if (iVar4 == 0) {
                                    if (2 < (uint)substmt_group) {
                                      ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name
                                             );
                                      ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                              "Statement \"%s\" cannot appear after \"%s\" statement."
                                              ,child->name,substmt_prev);
                                      goto LAB_00162ae1;
                                    }
                                    substmt_group = 2;
                                    if (mod->contact != (char *)0x0) {
                                      ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,
                                              child->name,yin->name);
                                      goto LAB_00162ae1;
                                    }
                                    iVar4 = lyp_yin_parse_subnode_ext
                                                      (mod,mod,LYEXT_PAR_MODULE,child,
                                                       LYEXT_SUBSTMT_CONTACT,'\0',unres);
                                    if (iVar4 != 0) goto LAB_00162ae1;
                                    pcVar5 = read_yin_subnode(ctx_00,child,"text");
                                    mod->contact = pcVar5;
                                    lyxml_free(ctx_00,child);
                                    if (mod->contact == (char *)0x0) goto LAB_00162ae1;
                                    substmt_prev = "contact";
                                    child = plVar2;
                                  }
                                  else {
                                    iVar4 = strcmp(child->name,"yang-version");
                                    if (iVar4 == 0) {
                                      if (substmt_group != 0) {
                                        ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,
                                                child->name);
                                        ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                                                "Statement \"%s\" cannot appear after \"%s\" statement."
                                                ,child->name,substmt_prev);
                                        goto LAB_00162ae1;
                                      }
                                      if (bVar3) {
                                        ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,
                                                child->name,yin->name);
                                        goto LAB_00162ae1;
                                      }
                                      pcVar5 = lyxml_get_attr(child,"value",(char *)0x0);
                                      if (pcVar5 == (char *)0x0) {
                                        ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",
                                                child->name);
                                        goto LAB_00162ae1;
                                      }
                                      iVar4 = strcmp(pcVar5,"1");
                                      if ((iVar4 != 0) && (iVar4 = strcmp(pcVar5,"1.1"), iVar4 != 0)
                                         ) {
                                        ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,pcVar5,
                                                "yang-version");
                                        goto LAB_00162ae1;
                                      }
                                      bVar3 = true;
                                      iVar4 = strcmp(pcVar5,"1");
                                      if (iVar4 == 0) {
                                        if (submodule == (lys_submodule *)0x0) {
                                          module->field_0x40 = module->field_0x40 & 0xf1 | 2;
                                        }
                                        else {
                                          if (1 < ((byte)module->field_0x40 >> 1 & 7)) {
                                            ly_vlog(ctx_00,LYE_INVER,LY_VLOG_NONE,(void *)0x0);
                                            goto LAB_00162ae1;
                                          }
                                          submodule->field_0x40 = submodule->field_0x40 & 0xf1 | 2;
                                        }
                                      }
                                      else if (submodule == (lys_submodule *)0x0) {
                                        module->field_0x40 = module->field_0x40 & 0xf1 | 4;
                                      }
                                      else {
                                        if (((byte)module->field_0x40 >> 1 & 7) < 2) {
                                          ly_vlog(ctx_00,LYE_INVER,LY_VLOG_NONE,(void *)0x0);
                                          goto LAB_00162ae1;
                                        }
                                        submodule->field_0x40 = submodule->field_0x40 & 0xf1 | 4;
                                      }
                                      iVar4 = lyp_yin_parse_subnode_ext
                                                        (mod,mod,LYEXT_PAR_MODULE,child,
                                                         LYEXT_SUBSTMT_VERSION,'\0',unres);
                                      if (iVar4 != 0) goto LAB_00162ae1;
                                      lyxml_free(ctx_00,child);
                                      substmt_prev = "yang-version";
                                      child = plVar2;
                                    }
                                    else {
                                      iVar4 = strcmp(child->name,"extension");
                                      if (iVar4 == 0) {
                                        substmt_group = 4;
                                        if (c_ext == 0xff) {
                                          if (submodule == (lys_submodule *)0x0) {
                                            pcVar5 = "module";
                                          }
                                          else {
                                            pcVar5 = "submodule";
                                          }
                                          ly_log(ctx_00,LY_LLERR,LY_EINT,
                                                 "Reached limit (%lu) for storing %s in %s statement."
                                                 ,0xff,"extensions",pcVar5);
                                          goto LAB_00162ae1;
                                        }
                                        c_ext = c_ext + 1;
                                        substmt_prev = "extension";
                                        child = plVar2;
                                      }
                                      else {
                                        iVar4 = strcmp(child->name,"deviation");
                                        if (iVar4 != 0) {
                                          ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,
                                                  child->name);
                                          goto LAB_00162ae1;
                                        }
                                        substmt_group = 4;
                                        if (c_dev == 0xff) {
                                          if (submodule == (lys_submodule *)0x0) {
                                            pcVar5 = "module";
                                          }
                                          else {
                                            pcVar5 = "submodule";
                                          }
                                          ly_log(ctx_00,LY_LLERR,LY_EINT,
                                                 "Reached limit (%lu) for storing %s in %s statement."
                                                 ,0xff,"deviations",pcVar5);
                                          goto LAB_00162ae1;
                                        }
                                        c_dev = c_dev + 1;
                                        substmt_prev = "deviation";
                                        child = plVar2;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else {
          if (substmt_group != 0) {
            ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->name);
            ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "Statement \"%s\" cannot appear after \"%s\" statement.",child->name,
                    substmt_prev);
            goto LAB_00162ae1;
          }
          if (mod->prefix != (char *)0x0) {
            ly_vlog(ctx_00,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,child->name,yin->name);
            goto LAB_00162ae1;
          }
          pcVar5 = lyxml_get_attr(child,"module",(char *)0x0);
          if (pcVar5 == (char *)0x0) {
            ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"module",child->name);
            goto LAB_00162ae1;
          }
          if (pcVar5 != submodule->belongsto->name) {
            ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,pcVar5,child->name);
            goto LAB_00162ae1;
          }
          iVar4 = lyp_yin_parse_subnode_ext
                            (mod,mod,LYEXT_PAR_MODULE,child,LYEXT_SUBSTMT_BELONGSTO,'\0',unres);
          if (iVar4 != 0) goto LAB_00162ae1;
          if (child->child == (lyxml_elem *)0x0) {
            ly_vlog(ctx_00,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"prefix",child->name);
            goto LAB_00162ae1;
          }
          iVar4 = strcmp(child->child->name,"prefix");
          if (iVar4 != 0) {
            ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->child->name);
            goto LAB_00162ae1;
          }
          if (child->child->next != (lyxml_elem *)0x0) {
            ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,child->child->next->name);
            goto LAB_00162ae1;
          }
          pcVar5 = lyxml_get_attr(child->child,"value",(char *)0x0);
          if (pcVar5 == (char *)0x0) {
            ly_vlog(ctx_00,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",child->child->name);
            goto LAB_00162ae1;
          }
          iVar4 = lyp_check_identifier
                            (ctx_00,pcVar5,LY_IDENT_NAME,(lys_module *)0x0,(lys_node *)0x0);
          if (iVar4 != 0) goto LAB_00162ae1;
          sVar6 = strlen(pcVar5);
          pcVar5 = lydict_insert(ctx_00,pcVar5,sVar6);
          submodule->prefix = pcVar5;
          iVar4 = lyp_yin_parse_subnode_ext
                            (mod,mod,LYEXT_PAR_MODULE,child->child,LYEXT_SUBSTMT_PREFIX,'\0',unres);
          if (iVar4 != 0) goto LAB_00162ae1;
          lyxml_free(ctx_00,child);
          substmt_prev = "belongs-to";
          child = plVar2;
        }
      }
      else {
        if (c_extinst == 0xff) {
          if (submodule == (lys_submodule *)0x0) {
            pcVar5 = "module";
          }
          else {
            pcVar5 = "submodule";
          }
          ly_log(ctx_00,LY_LLERR,LY_EINT,"Reached limit (%lu) for storing %s in %s statement.",0xff,
                 "extension instances",pcVar5);
          goto LAB_00162ae1;
        }
        lyxml_unlink_elem(ctx_00,child,2);
        lyxml_add_child(ctx_00,&exts,child);
        c_extinst = c_extinst + 1;
        child = plVar2;
      }
    }
  }
  if (submodule == (lys_submodule *)0x0) {
    if (mod->ns == (char *)0x0) {
      ly_vlog(ctx_00,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"namespace","module");
    }
    else {
      if (mod->prefix != (char *)0x0) goto LAB_0016186d;
      ly_vlog(ctx_00,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"prefix","module");
    }
  }
  else if (submodule->prefix == (char *)0x0) {
    ly_vlog(ctx_00,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"belongs-to","submodule");
  }
  else if ((bVar3) || (((byte)module->field_0x40 >> 1 & 7) < 2)) {
LAB_0016186d:
    if (c_imp != 0) {
      plVar7 = (lys_import *)calloc((long)c_imp,0x38);
      mod->imp = plVar7;
      if (mod->imp == (lys_import *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_sub_module");
        goto LAB_00162ae1;
      }
    }
    if (c_rev != 0) {
      plVar8 = (lys_revision *)calloc((long)c_rev,0x28);
      mod->rev = plVar8;
      if (mod->rev == (lys_revision *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_sub_module");
        goto LAB_00162ae1;
      }
    }
    if (c_tpdf != 0) {
      plVar9 = (lys_tpdf *)calloc((long)c_tpdf,0x80);
      mod->tpdf = plVar9;
      if (mod->tpdf == (lys_tpdf *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_sub_module");
        goto LAB_00162ae1;
      }
    }
    if (c_ident != 0) {
      plVar10 = (lys_ident *)calloc((long)c_ident,0x48);
      mod->ident = plVar10;
      if (mod->ident == (lys_ident *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_sub_module");
        goto LAB_00162ae1;
      }
    }
    if (c_inc != 0) {
      plVar11 = (lys_include *)calloc((long)c_inc,0x30);
      mod->inc = plVar11;
      if (mod->inc == (lys_include *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_sub_module");
        goto LAB_00162ae1;
      }
    }
    if (c_aug != 0) {
      plVar12 = (lys_node_augment *)calloc((long)c_aug,0x68);
      mod->augment = plVar12;
      if (mod->augment == (lys_node_augment *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_sub_module");
        goto LAB_00162ae1;
      }
    }
    if (c_ftrs != 0) {
      plVar13 = (lys_feature *)calloc((long)c_ftrs,0x40);
      mod->features = plVar13;
      if (mod->features == (lys_feature *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_sub_module");
        goto LAB_00162ae1;
      }
    }
    if (c_dev != 0) {
      plVar14 = (lys_deviation *)calloc((long)c_dev,0x38);
      mod->deviation = plVar14;
      if (mod->deviation == (lys_deviation *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_sub_module");
        goto LAB_00162ae1;
      }
    }
    if (c_ext != 0) {
      plVar15 = (lys_ext *)calloc((long)c_ext,0x40);
      mod->extensions = plVar15;
      if (mod->extensions == (lys_ext *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_sub_module");
        goto LAB_00162ae1;
      }
    }
    child = revs.child;
    while (child != (lyxml_elem *)0x0) {
      plVar2 = child->next;
      iVar4 = fill_yin_revision(mod,child,mod->rev + mod->rev_size,unres);
      mod->rev_size = mod->rev_size + '\x01';
      if (iVar4 != 0) goto LAB_00162ae1;
      for (i = 0; i < (int)(mod->rev_size - 1); i = i + 1) {
        iVar4 = strcmp(mod->rev[i].date,mod->rev[(ulong)mod->rev_size - 1].date);
        if (iVar4 == 0) {
          ly_log(ctx_00,LY_LLWRN,LY_SUCCESS,"Module\'s revisions are not unique (%s).",
                 mod->rev + ((ulong)mod->rev_size - 1));
          break;
        }
      }
      lyxml_free(ctx_00,child);
      child = plVar2;
    }
    if (submodule == (lys_submodule *)0x0) {
      iVar4 = lyp_ctx_check_module(module);
      if (iVar4 == 1) {
        ret = 1;
      }
      else if ((1 < iVar4) || (iVar4 != -1)) goto LAB_00161e6d;
    }
    else {
LAB_00161e6d:
      if (c_ext == 0) {
LAB_00161f5f:
        plVar2 = yin->child;
LAB_00162338:
        do {
          child = plVar2;
          if (child == (lyxml_elem *)0x0) {
            if (c_extinst == 0) goto LAB_0016251c;
            pplVar16 = (lys_ext_instance **)
                       realloc(mod->ext,(long)(int)(c_extinst + (uint)mod->ext_size) * 8);
            if (pplVar16 != (lys_ext_instance **)0x0) {
              mod->ext = pplVar16;
              memset(mod->ext + mod->ext_size,0,(long)c_extinst * 8);
              child = exts.child;
              goto LAB_001624ec;
            }
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","read_sub_module");
            break;
          }
          plVar2 = child->next;
          iVar4 = strcmp(child->name,"import");
          if (iVar4 == 0) {
            iVar4 = fill_yin_import(mod,child,mod->imp + mod->imp_size,unres);
            mod->imp_size = mod->imp_size + '\x01';
          }
          else {
            iVar4 = strcmp(child->name,"include");
            if (iVar4 == 0) {
              iVar4 = fill_yin_include(module,submodule,child,mod->inc + mod->inc_size,unres);
              mod->inc_size = mod->inc_size + '\x01';
            }
            else {
              iVar4 = strcmp(child->name,"typedef");
              if (iVar4 == 0) {
                iVar4 = fill_yin_typedef(mod,(lys_node *)0x0,child,mod->tpdf + mod->tpdf_size,unres)
                ;
                mod->tpdf_size = mod->tpdf_size + 1;
              }
              else {
                iVar4 = strcmp(child->name,"identity");
                if (iVar4 == 0) {
                  iVar4 = fill_yin_identity(mod,child,mod->ident + mod->ident_size,unres);
                  mod->ident_size = mod->ident_size + 1;
                }
                else {
                  iVar4 = strcmp(child->name,"feature");
                  if (iVar4 == 0) {
                    iVar4 = fill_yin_feature(mod,child,mod->features + mod->features_size,unres);
                    mod->features_size = mod->features_size + '\x01';
                  }
                  else {
                    iVar4 = strcmp(child->name,"deviation");
                    if (iVar4 != 0) goto LAB_00162338;
                    mod->field_0x40 = mod->field_0x40 | 0x80;
                    iVar4 = fill_yin_deviation(mod,child,mod->deviation + mod->deviation_size,unres)
                    ;
                    mod->deviation_size = mod->deviation_size + '\x01';
                  }
                }
              }
            }
          }
        } while (iVar4 == 0);
      }
      else {
        plVar2 = yin->child;
        do {
          do {
            child = plVar2;
            if (child == (lyxml_elem *)0x0) goto LAB_00161f5f;
            plVar2 = child->next;
            iVar4 = strcmp(child->name,"extension");
          } while (iVar4 != 0);
          iVar4 = fill_yin_extension(mod,child,mod->extensions + mod->extensions_size,unres);
          mod->extensions_size = mod->extensions_size + '\x01';
        } while (iVar4 == 0);
      }
    }
  }
  else {
    ly_vlog(ctx_00,LYE_INVER,LY_VLOG_NONE,(void *)0x0);
  }
  goto LAB_00162ae1;
LAB_0016251c:
  child = grps.child;
  while (child != (lyxml_elem *)0x0) {
    plVar2 = child->next;
    node = read_yin_grouping(mod,(lys_node *)0x0,child,0,unres);
    if (node == (lys_node *)0x0) goto LAB_00162ae1;
    lyxml_free(ctx_00,child);
    child = plVar2;
  }
  child = root.child;
  while (child != (lyxml_elem *)0x0) {
    plVar2 = child->next;
    iVar4 = strcmp(child->name,"container");
    if (iVar4 == 0) {
      node = read_yin_container(mod,(lys_node *)0x0,child,0,unres);
    }
    else {
      iVar4 = strcmp(child->name,"leaf-list");
      if (iVar4 == 0) {
        node = read_yin_leaflist(mod,(lys_node *)0x0,child,0,unres);
      }
      else {
        iVar4 = strcmp(child->name,"leaf");
        if (iVar4 == 0) {
          node = read_yin_leaf(mod,(lys_node *)0x0,child,0,unres);
        }
        else {
          iVar4 = strcmp(child->name,"list");
          if (iVar4 == 0) {
            node = read_yin_list(mod,(lys_node *)0x0,child,0,unres);
          }
          else {
            iVar4 = strcmp(child->name,"choice");
            if (iVar4 == 0) {
              node = read_yin_choice(mod,(lys_node *)0x0,child,0,unres);
            }
            else {
              iVar4 = strcmp(child->name,"uses");
              if (iVar4 == 0) {
                node = read_yin_uses(mod,(lys_node *)0x0,child,0,unres);
              }
              else {
                iVar4 = strcmp(child->name,"anyxml");
                if (iVar4 == 0) {
                  node = read_yin_anydata(mod,(lys_node *)0x0,child,LYS_ANYXML,0,unres);
                }
                else {
                  iVar4 = strcmp(child->name,"anydata");
                  if (iVar4 == 0) {
                    node = read_yin_anydata(mod,(lys_node *)0x0,child,LYS_ANYDATA,0,unres);
                  }
                  else {
                    iVar4 = strcmp(child->name,"rpc");
                    if (iVar4 == 0) {
                      node = read_yin_rpc_action(mod,(lys_node *)0x0,child,0,unres);
                    }
                    else {
                      iVar4 = strcmp(child->name,"notification");
                      if (iVar4 == 0) {
                        node = read_yin_notif(mod,(lys_node *)0x0,child,0,unres);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (node == (lys_node *)0x0) goto LAB_00162ae1;
    lyxml_free(ctx_00,child);
    child = plVar2;
  }
  child = augs.child;
  while (child != (lyxml_elem *)0x0) {
    plVar2 = child->next;
    iVar4 = fill_yin_augment(mod,(lys_node *)0x0,child,mod->augment + mod->augment_size,0,unres);
    mod->augment_size = mod->augment_size + '\x01';
    if (iVar4 != 0) goto LAB_00162ae1;
    lyxml_free(ctx_00,child);
    child = plVar2;
  }
  ret = 0;
  goto LAB_00162b89;
  while( true ) {
    plVar2 = child->next;
    iVar4 = lyp_yin_fill_ext(mod,LYEXT_PAR_MODULE,LYEXT_SUBSTMT_SELF,'\0',mod,child,&mod->ext,
                             mod->ext_size,unres);
    mod->ext_size = mod->ext_size + '\x01';
    child = plVar2;
    if (iVar4 != 0) break;
LAB_001624ec:
    if (child == (lyxml_elem *)0x0) goto LAB_0016251c;
  }
LAB_00162ae1:
  while (root.child != (lyxml_elem *)0x0) {
    lyxml_free(ctx_00,root.child);
  }
  while (grps.child != (lyxml_elem *)0x0) {
    lyxml_free(ctx_00,grps.child);
  }
  while (augs.child != (lyxml_elem *)0x0) {
    lyxml_free(ctx_00,augs.child);
  }
  while (revs.child != (lyxml_elem *)0x0) {
    lyxml_free(ctx_00,revs.child);
  }
  while (exts.child != (lyxml_elem *)0x0) {
    lyxml_free(ctx_00,exts.child);
  }
LAB_00162b89:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return ret;
}



lys_submodule * yin_read_submodule(lys_module *module,char *data,unres_schema *unres)

{
  int iVar1;
  size_t len;
  char *pcVar2;
  LY_ERR *pLVar3;
  unres_schema *unres_local;
  char *data_local;
  lys_module *module_local;
  lys_submodule *submodule;
  ly_ctx *ctx;
  lyxml_elem *yin;
  char *value;
  
  ctx = module->ctx;
  submodule = (lys_submodule *)0x0;
  unres_local = unres;
  data_local = data;
  module_local = module;
  yin = lyxml_parse_mem(ctx,data,2);
  if (yin != (lyxml_elem *)0x0) {
    if ((yin->name == (char *)0x0) || (iVar1 = strcmp(yin->name,"submodule"), iVar1 != 0)) {
      ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,yin->name);
    }
    else {
      value = lyxml_get_attr(yin,"name",(char *)0x0);
      if (value == (char *)0x0) {
        ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,yin->name);
      }
      else {
        iVar1 = lyp_check_identifier(ctx,value,LY_IDENT_NAME,(lys_module *)0x0,(lys_node *)0x0);
        if (iVar1 == 0) {
          submodule = (lys_submodule *)calloc(1,0xb0);
          if (submodule == (lys_submodule *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yin_read_submodule");
          }
          else {
            submodule->ctx = ctx;
            len = strlen(value);
            pcVar2 = lydict_insert(ctx,value,len);
            submodule->name = pcVar2;
            submodule->field_0x40 = submodule->field_0x40 | 1;
            submodule->field_0x40 = submodule->field_0x40 & 0x7f | module_local->field_0x40 & 0x80;
            submodule->belongsto = module_local;
            iVar1 = lyp_check_circmod_add((lys_module *)submodule);
            if (iVar1 == 0) {
              ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,"Reading submodule \"%s\".",submodule->name);
              iVar1 = read_sub_module(module_local,submodule,yin,unres_local);
              if (iVar1 == 0) {
                lyp_sort_revisions((lys_module *)submodule);
                lyxml_free(ctx,yin);
                lyp_check_circmod_pop(ctx);
                ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,"Submodule \"%s\" successfully parsed.",
                       submodule->name);
                return submodule;
              }
            }
          }
        }
      }
    }
    lyxml_free(ctx,yin);
    if (submodule == (lys_submodule *)0x0) {
      pLVar3 = ly_errno_glob_address();
      ly_log(ctx,LY_LLERR,*pLVar3,"Submodule parsing failed.");
    }
    else {
      pcVar2 = submodule->name;
      pLVar3 = ly_errno_glob_address();
      ly_log(ctx,LY_LLERR,*pLVar3,"Submodule \"%s\" parsing failed.",pcVar2);
      unres_schema_free((lys_module *)submodule,&unres_local,0);
      lyp_check_circmod_pop(ctx);
      lys_sub_module_remove_devs_augs((lys_module *)submodule);
      lys_submodule_module_data_free(submodule);
      lys_submodule_free(submodule,(_func_void_lys_node_ptr_void_ptr *)0x0);
    }
  }
  return (lys_submodule *)0x0;
}



lys_module * yin_read_module_(ly_ctx *ctx,lyxml_elem *yin,char *revision,int implement)

{
  int iVar1;
  int iVar2;
  LY_VECODE LVar3;
  size_t len;
  char *pcVar4;
  LY_ERR *pLVar5;
  lys_module *plVar6;
  lys_revision *plVar7;
  undefined *puVar8;
  long in_FS_OFFSET;
  int implement_local;
  char *revision_local;
  lyxml_elem *yin_local;
  ly_ctx *ctx_local;
  int ret;
  unres_schema *unres;
  lys_module *module;
  char *value;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  module = (lys_module *)0x0;
  unres = (unres_schema *)calloc(1,0x28);
  if (unres == (unres_schema *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yin_read_module_");
    plVar6 = (lys_module *)0x0;
    goto LAB_0016354f;
  }
  if ((yin->name == (char *)0x0) || (iVar1 = strcmp(yin->name,"module"), iVar1 != 0)) {
    iVar1 = ly_strequal_("submodule",yin->name);
    if (iVar1 == 0) {
      ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,yin->name);
    }
    else {
      ly_vlog(ctx,LYE_SUBMODULE,LY_VLOG_NONE,(void *)0x0);
    }
  }
  else {
    value = lyxml_get_attr(yin,"name",(char *)0x0);
    if (value == (char *)0x0) {
      ly_vlog(ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,&DAT_00213c54,yin->name);
    }
    else {
      iVar1 = lyp_check_identifier(ctx,value,LY_IDENT_NAME,(lys_module *)0x0,(lys_node *)0x0);
      if (iVar1 == 0) {
        module = (lys_module *)calloc(1,0xb8);
        if (module == (lys_module *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yin_read_module_");
        }
        else {
          module->ctx = ctx;
          len = strlen(value);
          pcVar4 = lydict_insert(ctx,value,len);
          module->name = pcVar4;
          module->field_0x40 = module->field_0x40 & 0xfe;
          module->field_0x40 = module->field_0x40 & 0x7f | (implement != 0) << 7;
          iVar1 = lyp_check_circmod_add(module);
          if (iVar1 == 0) {
            ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,"Reading module \"%s\".",module->name);
            iVar1 = read_sub_module(module,(lys_submodule *)0x0,yin,unres);
            if (iVar1 != -1) {
              if (iVar1 == 1) {
                if (unres->count != 0) {
                    // WARNING: Subroutine does not return
                  __assert_fail("!unres->count",
                                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yin.c"
                                ,0x1cc8,"yin_read_module_");
                }
              }
              else if (((((implement == 0) && ((module->field_0x40 & 0x80) != 0)) &&
                        (iVar2 = unres_schema_add_node
                                           (module,unres,(void *)0x0,UNRES_MOD_IMPLEMENT,
                                            (lys_node *)0x0), iVar2 == -1)) ||
                       ((unres->count != 0 &&
                        (iVar2 = resolve_unres_schema(module,unres), iVar2 != 0)))) ||
                      (iVar2 = lyp_check_include_missing(module), iVar2 != 0)) goto LAB_0016347c;
              lyp_sort_revisions(module);
              iVar2 = lyp_rfn_apply_ext(module);
              if ((iVar2 == 0) && (iVar2 = lyp_deviation_apply_ext(module), iVar2 == 0)) {
                if ((revision == (char *)0x0) ||
                   ((module->rev_size != '\0' &&
                    (iVar2 = strcmp(revision,module->rev->date), iVar2 == 0)))) {
                  if (iVar1 == 0) {
                    iVar1 = lyp_ctx_add_module(module);
                    if (iVar1 != 0) goto LAB_0016347c;
                    lyp_del_includedup(module,0);
                  }
                  else {
                    lys_free(module,(_func_void_lys_node_ptr_void_ptr *)0x0,0,0);
                    module = ly_ctx_get_module(ctx,value,revision,0);
                    if (module == (lys_module *)0x0) {
                    // WARNING: Subroutine does not return
                      __assert_fail("module",
                                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yin.c"
                                    ,0x1cf7,"yin_read_module_");
                    }
                  }
                  unres_schema_free((lys_module *)0x0,&unres,0);
                  lyp_check_circmod_pop(ctx);
                  if ((module->field_0x40 & 0x80) == 0) {
                    pcVar4 = "imported";
                  }
                  else {
                    pcVar4 = "implemented";
                  }
                  if (module->rev_size == '\0') {
                    plVar7 = (lys_revision *)&DAT_00213acf;
                  }
                  else {
                    plVar7 = module->rev;
                  }
                  if (module->rev_size == '\0') {
                    puVar8 = &DAT_00213acf;
                  }
                  else {
                    puVar8 = &DAT_00214a4d;
                  }
                  ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                         "Module \"%s%s%s\" successfully parsed as %s.",module->name,puVar8,plVar7,
                         pcVar4);
                  plVar6 = module;
                  goto LAB_0016354f;
                }
                ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                       "Module \"%s\" parsed with the wrong revision (\"%s\" instead \"%s\").",
                       module->name,module->rev,revision);
              }
            }
          }
        }
      }
    }
  }
LAB_0016347c:
  unres_schema_free(module,&unres,1);
  if (module == (lys_module *)0x0) {
    LVar3 = ly_vecode(ctx);
    if (LVar3 != LYVE_SUBMODULE) {
      pLVar5 = ly_errno_glob_address();
      ly_log(ctx,LY_LLERR,*pLVar5,"Module parsing failed.");
    }
    plVar6 = (lys_module *)0x0;
  }
  else {
    pcVar4 = module->name;
    pLVar5 = ly_errno_glob_address();
    ly_log(ctx,LY_LLERR,*pLVar5,"Module \"%s\" parsing failed.",pcVar4);
    lyp_check_circmod_pop(ctx);
    lys_sub_module_remove_devs_augs(module);
    lyp_del_includedup(module,1);
    lys_free(module,(_func_void_lys_node_ptr_void_ptr *)0x0,0,1);
    plVar6 = (lys_module *)0x0;
  }
LAB_0016354f:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_module * yin_read_module(ly_ctx *ctx,char *data,char *revision,int implement)

{
  lyxml_elem *yin_00;
  LY_ERR *pLVar1;
  lys_module *plVar2;
  int implement_local;
  char *revision_local;
  char *data_local;
  ly_ctx *ctx_local;
  lyxml_elem *yin;
  lys_module *result;
  
  yin_00 = lyxml_parse_mem(ctx,data,2);
  if (yin_00 == (lyxml_elem *)0x0) {
    pLVar1 = ly_errno_glob_address();
    ly_log(ctx,LY_LLERR,*pLVar1,"Module parsing failed.");
    plVar2 = (lys_module *)0x0;
  }
  else {
    plVar2 = yin_read_module_(ctx,yin_00,revision,implement);
    lyxml_free(ctx,yin_00);
  }
  return plVar2;
}



int yin_parse_extcomplex_bool
              (lys_module *mod,lyxml_elem *node,lys_ext_instance_complex *ext,LY_STMT stmt,
              char *true_val,char *false_val,unres_schema *unres)

{
  int iVar1;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  char *false_val_local;
  char *true_val_local;
  LY_STMT stmt_local;
  lys_ext_instance_complex *ext_local;
  lyxml_elem *node_local;
  lys_module *mod_local;
  lyext_substmt *info;
  uint8_t *val;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  val = (uint8_t *)lys_ext_complex_get_substmt(stmt,ext,&info);
  if (val == (uint8_t *)0x0) {
    ly_vlog(mod->ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,node->name,node->parent->name);
    iVar1 = 1;
    goto LAB_00163826;
  }
  if (*val != '\0') {
    ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node->name,node->parent->name);
    iVar1 = 1;
    goto LAB_00163826;
  }
  iVar1 = lyp_yin_parse_subnode_ext(mod,ext,LYEXT_PAR_EXTINST,node,stmt,'\0',unres);
  if (iVar1 != 0) {
    iVar1 = 1;
    goto LAB_00163826;
  }
  str = lyxml_get_attr(node,"value",(char *)0x0);
  if (str == (char *)0x0) {
    ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",node->name);
LAB_00163821:
    iVar1 = 0;
  }
  else {
    if (true_val != (char *)0x0) {
      iVar1 = strcmp(true_val,str);
      if (iVar1 == 0) {
        *val = '\x01';
        goto LAB_00163821;
      }
    }
    if (false_val != (char *)0x0) {
      iVar1 = strcmp(false_val,str);
      if (iVar1 == 0) {
        *val = '\x02';
        goto LAB_00163821;
      }
    }
    ly_vlog(mod->ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,str,node->name);
    iVar1 = 1;
  }
LAB_00163826:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int yin_parse_extcomplex_str
              (lys_module *mod,lyxml_elem *node,lys_ext_instance_complex *ext,LY_STMT stmt,
              int argelem,char *argname,unres_schema *unres)

{
  char ***pppcVar1;
  int iVar2;
  char **ppcVar3;
  char *pcVar4;
  uint8_t i;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  char *argname_local;
  int argelem_local;
  LY_STMT stmt_local;
  lys_ext_instance_complex *ext_local;
  lyxml_elem *node_local;
  lys_module *mod_local;
  int c;
  lyext_substmt *info;
  char **str;
  char ***p;
  char *value;
  void *reallocated;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  p = (char ***)0x0;
  str = (char **)lys_ext_complex_get_substmt(stmt,ext,&info);
  if ((char ***)str == (char ***)0x0) {
    ly_vlog(mod->ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,node->name,node->parent->name);
    iVar2 = 1;
    goto LAB_00164358;
  }
  if ((info->cardinality < LY_STMT_CARD_SOME) && ((char **)*str != (char **)0x0)) {
    ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node->name,node->parent->name);
    iVar2 = 1;
    goto LAB_00164358;
  }
  c = 0;
  if (LY_STMT_CARD_MAND < info->cardinality) {
    p = (char ***)str;
    if ((char **)*str == (char **)0x0) {
      ppcVar3 = (char **)malloc(0x10);
      *p = ppcVar3;
      if (*p == (char **)0x0) {
        ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "yin_parse_extcomplex_str");
        iVar2 = 1;
        goto LAB_00164358;
      }
      if (stmt == LY_STMT_BELONGSTO) {
        pppcVar1 = p + 1;
        ppcVar3 = (char **)malloc(0x10);
        *pppcVar1 = ppcVar3;
        if (p[1] == (char **)0x0) {
          ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "yin_parse_extcomplex_str");
          iVar2 = 1;
          goto LAB_00164358;
        }
      }
      else if (stmt == LY_STMT_ARGUMENT) {
        pppcVar1 = p + 1;
        ppcVar3 = (char **)malloc(2);
        *pppcVar1 = ppcVar3;
        if (p[1] == (char **)0x0) {
          ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "yin_parse_extcomplex_str");
          iVar2 = 1;
          goto LAB_00164358;
        }
      }
    }
    else {
      for (c = 0; *(char **)((long)*str + (long)c * 8) != (char *)0x0; c = c + 1) {
      }
    }
    str = *p;
  }
  i = (uint8_t)c;
  iVar2 = lyp_yin_parse_subnode_ext(mod,ext,LYEXT_PAR_EXTINST,node,stmt,i,unres);
  if (iVar2 != 0) {
    iVar2 = 1;
    goto LAB_00164358;
  }
  if (argelem == 0) {
    ppcVar3 = str + c;
    pcVar4 = lyxml_get_attr(node,argname,(char *)0x0);
    *ppcVar3 = pcVar4;
    if (str[c] == (char *)0x0) {
      ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,argname,node->name);
      iVar2 = 1;
      goto LAB_00164358;
    }
    ppcVar3 = str + c;
    pcVar4 = lydict_insert(mod->ctx,str[c],0);
    *ppcVar3 = pcVar4;
    if (stmt == LY_STMT_BELONGSTO) {
      if (node->child == (lyxml_elem *)0x0) {
        ly_vlog(mod->ctx,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"prefix",node->name);
        iVar2 = 1;
        goto LAB_00164358;
      }
      iVar2 = strcmp(node->child->name,"prefix");
      if (iVar2 != 0) {
        ly_vlog(mod->ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,node->child->name);
        iVar2 = 1;
        goto LAB_00164358;
      }
      if (node->child->next != (lyxml_elem *)0x0) {
        ly_vlog(mod->ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,node->child->next->name);
        iVar2 = 1;
        goto LAB_00164358;
      }
      if (p == (char ***)0x0) {
        str = str + 1;
      }
      else {
        str = p[1];
      }
      ppcVar3 = str + c;
      pcVar4 = lyxml_get_attr(node->child,"value",(char *)0x0);
      *ppcVar3 = pcVar4;
      if (str[c] == (char *)0x0) {
        ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",node->child->name);
        iVar2 = 1;
        goto LAB_00164358;
      }
      ppcVar3 = str + c;
      pcVar4 = lydict_insert(mod->ctx,str[c],0);
      *ppcVar3 = pcVar4;
      if (str[c] != (char *)0x0) {
        iVar2 = lyp_yin_parse_subnode_ext
                          (mod,ext,LYEXT_PAR_EXTINST,node->child,LYEXT_SUBSTMT_PREFIX,i,unres);
        if (iVar2 == 0) goto LAB_001640d8;
      }
      iVar2 = 1;
      goto LAB_00164358;
    }
    if (stmt == LY_STMT_ARGUMENT) {
      if (p == (char ***)0x0) {
        str = str + 1;
      }
      else {
        str = p[1];
      }
      if (node->child == (lyxml_elem *)0x0) {
        *(undefined *)((long)str + (long)c) = 2;
      }
      else {
        iVar2 = strcmp(node->child->name,"yin-element");
        if (iVar2 != 0) {
          ly_vlog(mod->ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,node->child->name);
          iVar2 = 1;
          goto LAB_00164358;
        }
        if (node->child->next != (lyxml_elem *)0x0) {
          ly_vlog(mod->ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,node->child->next->name);
          iVar2 = 1;
          goto LAB_00164358;
        }
        value = lyxml_get_attr(node->child,"value",(char *)0x0);
        if (value == (char *)0x0) {
          ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",node->child->name);
          iVar2 = 1;
          goto LAB_00164358;
        }
        iVar2 = ly_strequal_(value,"true");
        if (iVar2 == 0) {
          iVar2 = ly_strequal_(value,"false");
          if (iVar2 == 0) {
            ly_vlog(mod->ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,str,node->name);
            iVar2 = 1;
            goto LAB_00164358;
          }
          *(undefined *)((long)str + (long)c) = 2;
        }
        else {
          *(undefined *)((long)str + (long)c) = 1;
        }
        iVar2 = lyp_yin_parse_subnode_ext
                          (mod,ext,LYEXT_PAR_EXTINST,node->child,LYEXT_SUBSTMT_YINELEM,i,unres);
        if (iVar2 != 0) {
          iVar2 = 1;
          goto LAB_00164358;
        }
      }
    }
  }
  else {
    ppcVar3 = str + c;
    pcVar4 = read_yin_subnode(mod->ctx,node,argname);
    *ppcVar3 = pcVar4;
    if (str[c] == (char *)0x0) {
      iVar2 = 1;
      goto LAB_00164358;
    }
  }
LAB_001640d8:
  if (p != (char ***)0x0) {
    reallocated = realloc(*p,(long)(c + 2) * 8);
    if ((char **)reallocated == (char **)0x0) {
      ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yin_parse_extcomplex_str"
            );
      lydict_remove(mod->ctx,(*p)[c]);
      (*p)[c] = (char *)0x0;
      iVar2 = 1;
      goto LAB_00164358;
    }
    *p = (char **)reallocated;
    (*p)[(long)c + 1] = (char *)0x0;
    if (stmt == LY_STMT_BELONGSTO) {
      reallocated = realloc(p[1],(long)(c + 2) * 8);
      if ((char **)reallocated == (char **)0x0) {
        ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "yin_parse_extcomplex_str");
        lydict_remove(mod->ctx,p[1][c]);
        p[1][c] = (char *)0x0;
        iVar2 = 1;
        goto LAB_00164358;
      }
      p[1] = (char **)reallocated;
      p[1][(long)c + 1] = (char *)0x0;
    }
    else if (stmt == LY_STMT_ARGUMENT) {
      reallocated = realloc(p[1],(long)(c + 2));
      if ((char **)reallocated == (char **)0x0) {
        ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "yin_parse_extcomplex_str");
        *(undefined *)((long)c + (long)p[1]) = 0;
        iVar2 = 1;
        goto LAB_00164358;
      }
      p[1] = (char **)reallocated;
      *(undefined *)((long)p[1] + (long)c + 1) = 0;
    }
  }
  iVar2 = 0;
LAB_00164358:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



void * yin_getplace_for_extcomplex_flags
                 (lyxml_elem *node,lys_ext_instance_complex *ext,LY_STMT stmt,uint16_t mask)

{
  ushort *puVar1;
  long in_FS_OFFSET;
  uint16_t mask_local;
  LY_STMT stmt_local;
  lys_ext_instance_complex *ext_local;
  lyxml_elem *node_local;
  lyext_substmt *info;
  void *data;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  puVar1 = (ushort *)lys_ext_complex_get_substmt(stmt,ext,&info);
  data = puVar1;
  if (puVar1 == (ushort *)0x0) {
    ly_vlog(ext->module->ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,node->name,node->parent->name)
    ;
    puVar1 = (ushort *)0x0;
  }
  else if ((info->cardinality < LY_STMT_CARD_SOME) && ((*puVar1 & mask) != 0)) {
    ly_vlog(ext->module->ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node->name,node->parent->name);
    puVar1 = (ushort *)0x0;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return puVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int yin_parse_extcomplex_flag
              (lys_module *mod,lyxml_elem *node,lys_ext_instance_complex *ext,LY_STMT stmt,
              char *val1_str,char *val2_str,uint16_t mask,uint16_t val1,uint16_t val2,
              unres_schema *unres)

{
  int iVar1;
  ushort *puVar2;
  char *__s2;
  uint16_t val2_local;
  uint16_t val1_local;
  char *val2_str_local;
  char *val1_str_local;
  uint16_t mask_local;
  LY_STMT stmt_local;
  lys_ext_instance_complex *ext_local;
  lyxml_elem *node_local;
  lys_module *mod_local;
  uint16_t *val;
  char *str;
  
  puVar2 = (ushort *)yin_getplace_for_extcomplex_flags(node,ext,stmt,mask);
  if (puVar2 == (ushort *)0x0) {
    iVar1 = 1;
  }
  else {
    __s2 = lyxml_get_attr(node,"value",(char *)0x0);
    if (__s2 == (char *)0x0) {
      ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",node->name);
    }
    else {
      iVar1 = strcmp(val1_str,__s2);
      if (iVar1 == 0) {
        *puVar2 = *puVar2 | val1;
      }
      else {
        iVar1 = strcmp(val2_str,__s2);
        if (iVar1 != 0) {
          ly_vlog(mod->ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,__s2,node->name);
          return 1;
        }
        *puVar2 = *puVar2 | val2;
      }
    }
    iVar1 = lyp_yin_parse_subnode_ext(mod,ext,LYEXT_PAR_EXTINST,node,stmt,'\0',unres);
    if (iVar1 == 0) {
      iVar1 = 0;
    }
    else {
      iVar1 = 1;
    }
  }
  return iVar1;
}



lys_node **
yin_getplace_for_extcomplex_node(lyxml_elem *node,lys_ext_instance_complex *ext,LY_STMT stmt)

{
  LY_STMT LVar1;
  lys_node **pplVar2;
  long in_FS_OFFSET;
  LY_STMT stmt_local;
  lys_ext_instance_complex *ext_local;
  lyxml_elem *node_local;
  lyext_substmt *info;
  lys_node *siter;
  lys_node **snode;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  snode = (lys_node **)lys_ext_complex_get_substmt(stmt,ext,&info);
  if (snode == (lys_node **)0x0) {
    ly_vlog(ext->module->ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,node->name,node->parent->name)
    ;
    pplVar2 = (lys_node **)0x0;
  }
  else {
    pplVar2 = snode;
    if (info->cardinality < LY_STMT_CARD_SOME) {
      for (siter = *snode; pplVar2 = snode, siter != (lys_node *)0x0; siter = siter->next) {
        LVar1 = lys_snode2stmt(siter->nodetype);
        if (stmt == LVar1) {
          ly_vlog(ext->module->ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node->name,
                  node->parent->name);
          pplVar2 = (lys_node **)0x0;
          break;
        }
      }
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return pplVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void ** yin_getplace_for_extcomplex_struct
                  (lyxml_elem *node,lys_ext_instance_complex *ext,LY_STMT stmt)

{
  void ***pppvVar1;
  void **ppvVar2;
  long in_FS_OFFSET;
  LY_STMT stmt_local;
  lys_ext_instance_complex *ext_local;
  lyxml_elem *node_local;
  int c;
  lyext_substmt *info;
  void **data;
  void ***p;
  void *reallocated;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  p = (void ***)0x0;
  pppvVar1 = (void ***)lys_ext_complex_get_substmt(stmt,ext,&info);
  data = pppvVar1;
  if (pppvVar1 == (void ***)0x0) {
    ly_vlog(ext->module->ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,node->name,node->parent->name)
    ;
    ppvVar2 = (void **)0x0;
  }
  else if ((info->cardinality < LY_STMT_CARD_SOME) && (*pppvVar1 != (void **)0x0)) {
    ly_vlog(ext->module->ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node->name,node->parent->name);
    ppvVar2 = (void **)0x0;
  }
  else {
    c = 0;
    if (LY_STMT_CARD_MAND < info->cardinality) {
      data = *pppvVar1;
      p = pppvVar1;
      if (data == (void **)0x0) {
        data = (void **)malloc(0x10);
        *p = data;
        if (data == (void **)0x0) {
          ly_log(ext->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "yin_getplace_for_extcomplex_struct");
          ppvVar2 = (void **)0x0;
          goto LAB_001649af;
        }
      }
      else {
        c = 0;
        for (; *data != (void *)0x0; data = data + 1) {
          c = c + 1;
        }
      }
    }
    if (p != (void ***)0x0) {
      reallocated = realloc(*p,(long)(c + 2) * 8);
      if ((void **)reallocated == (void **)0x0) {
        ly_log(ext->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "yin_getplace_for_extcomplex_struct");
        ppvVar2 = (void **)0x0;
        goto LAB_001649af;
      }
      *p = (void **)reallocated;
      data = *p;
      data[(long)c + 1] = (void *)0x0;
    }
    ppvVar2 = data + c;
  }
LAB_001649af:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return ppvVar2;
}



// WARNING: Type propagation algorithm not settling

int lyp_yin_parse_complex_ext
              (lys_module *mod,lys_ext_instance_complex *ext,lyxml_elem *yin,unres_schema *unres)

{
  undefined8 *puVar1;
  int iVar2;
  lys_type *plVar3;
  void *pvVar4;
  ushort **ppuVar5;
  int *piVar6;
  lys_module *plVar7;
  lys_when *plVar8;
  lys_node *plVar9;
  char *pcVar10;
  size_t sVar11;
  LY_ERR *pLVar12;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  lyxml_elem *yin_local;
  lys_ext_instance_complex *ext_local;
  lys_module *mod_local;
  char modifier;
  int i;
  int j;
  char *endptr;
  lyext_substmt *info;
  lyxml_elem *next;
  lyxml_elem *node;
  lyxml_elem *child;
  void **pp;
  void *p;
  char *value;
  char *name;
  ulong u;
  void *reallocated;
  longlong ll;
  long v;
  lys_type **type;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  node = yin->child;
  do {
    if (node == (lyxml_elem *)0x0) {
      if ((ext->substmt == (lyext_substmt *)0x0) ||
         (iVar2 = lyp_mand_check_ext(ext,yin->name), iVar2 == 0)) {
        iVar2 = 0;
      }
      else {
        iVar2 = 1;
      }
LAB_00168b7f:
      if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
        return iVar2;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    next = node->next;
    if (node->ns == (lyxml_ns *)0x0) {
LAB_00168a8f:
      lyxml_free(mod->ctx,node);
    }
    else {
      if (((node->ns == yin->ns) && ((ext->flags & 1) != 0)) && (node->name == ext->def->argument))
      {
        if (ext->arg_value != (char *)0x0) {
          ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node->name,yin->name);
          goto LAB_00168b7a;
        }
        ext->arg_value = node->content;
        node->content = (char *)0x0;
        goto LAB_00168a8f;
      }
      iVar2 = strcmp(node->ns->value,"urn:ietf:params:xml:ns:yang:yin:1");
      if (iVar2 != 0) {
        iVar2 = lyp_yin_parse_subnode_ext
                          (mod,ext,LYEXT_PAR_EXTINST,node,LYEXT_SUBSTMT_SELF,'\0',unres);
joined_r0x0016566c:
        if (iVar2 == 0) goto LAB_00168a8f;
LAB_00168b7a:
        iVar2 = 1;
        goto LAB_00168b7f;
      }
      iVar2 = strcmp(node->name,"description");
      if (iVar2 == 0) {
        iVar2 = yin_parse_extcomplex_str(mod,node,ext,LY_STMT_DESCRIPTION,1,"text",unres);
        goto joined_r0x0016566c;
      }
      iVar2 = strcmp(node->name,"reference");
      if (iVar2 == 0) {
        iVar2 = yin_parse_extcomplex_str(mod,node,ext,LY_STMT_REFERENCE,1,"text",unres);
        goto joined_r0x0016566c;
      }
      iVar2 = strcmp(node->name,"units");
      if (iVar2 == 0) {
        iVar2 = yin_parse_extcomplex_str(mod,node,ext,LY_STMT_UNITS,0,"name",unres);
        goto joined_r0x0016566c;
      }
      iVar2 = strcmp(node->name,"type");
      if (iVar2 != 0) {
        iVar2 = strcmp(node->name,"typedef");
        if (iVar2 == 0) {
          pp = yin_getplace_for_extcomplex_struct(node,ext,LY_STMT_TYPEDEF);
          if (pp != (void **)0x0) {
            pvVar4 = calloc(1,0x80);
            *pp = pvVar4;
            if (*pp != (void *)0x0) {
              iVar2 = fill_yin_typedef(mod,(lys_node *)ext,node,(lys_tpdf *)*pp,unres);
              goto joined_r0x0016566c;
            }
            ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "lyp_yin_parse_complex_ext");
          }
        }
        else {
          iVar2 = strcmp(node->name,"if-feature");
          if (iVar2 == 0) {
            pp = yin_getplace_for_extcomplex_struct(node,ext,LY_STMT_IFFEATURE);
            if (pp != (void **)0x0) {
              pvVar4 = calloc(1,0x20);
              *pp = pvVar4;
              if (*pp != (void *)0x0) {
                iVar2 = fill_yin_iffeature((lys_node *)ext,0,node,(lys_iffeature *)*pp,unres);
                goto joined_r0x0016566c;
              }
              ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "lyp_yin_parse_complex_ext");
            }
          }
          else {
            iVar2 = strcmp(node->name,"status");
            if (iVar2 != 0) {
              iVar2 = strcmp(node->name,"config");
              if (iVar2 == 0) {
                iVar2 = yin_parse_extcomplex_flag
                                  (mod,node,ext,LY_STMT_MANDATORY,"true","false",3,5,6,unres);
              }
              else {
                iVar2 = strcmp(node->name,"argument");
                if (iVar2 == 0) {
                  iVar2 = yin_parse_extcomplex_str(mod,node,ext,LY_STMT_ARGUMENT,0,"name",unres);
                }
                else {
                  iVar2 = strcmp(node->name,"default");
                  if (iVar2 == 0) {
                    iVar2 = yin_parse_extcomplex_str(mod,node,ext,LY_STMT_DEFAULT,0,"value",unres);
                  }
                  else {
                    iVar2 = strcmp(node->name,"mandatory");
                    if (iVar2 == 0) {
                      iVar2 = yin_parse_extcomplex_flag
                                        (mod,node,ext,LY_STMT_MANDATORY,"true","false",0xc0,0x40,
                                         0x80,unres);
                    }
                    else {
                      iVar2 = strcmp(node->name,"error-app-tag");
                      if (iVar2 == 0) {
                        iVar2 = yin_parse_extcomplex_str
                                          (mod,node,ext,LY_STMT_ERRTAG,0,"value",unres);
                      }
                      else {
                        iVar2 = strcmp(node->name,"error-message");
                        if (iVar2 == 0) {
                          iVar2 = yin_parse_extcomplex_str
                                            (mod,node,ext,LY_STMT_ERRMSG,1,"value",unres);
                        }
                        else {
                          iVar2 = strcmp(node->name,"prefix");
                          if (iVar2 == 0) {
                            iVar2 = yin_parse_extcomplex_str
                                              (mod,node,ext,LY_STMT_PREFIX,0,"value",unres);
                          }
                          else {
                            iVar2 = strcmp(node->name,"namespace");
                            if (iVar2 == 0) {
                              iVar2 = yin_parse_extcomplex_str
                                                (mod,node,ext,LY_STMT_NAMESPACE,0,"uri",unres);
                            }
                            else {
                              iVar2 = strcmp(node->name,"presence");
                              if (iVar2 == 0) {
                                iVar2 = yin_parse_extcomplex_str
                                                  (mod,node,ext,LY_STMT_PRESENCE,0,"value",unres);
                              }
                              else {
                                iVar2 = strcmp(node->name,"revision-date");
                                if (iVar2 == 0) {
                                  iVar2 = yin_parse_extcomplex_str
                                                    (mod,node,ext,LY_STMT_REVISIONDATE,0,"date",
                                                     unres);
                                }
                                else {
                                  iVar2 = strcmp(node->name,"key");
                                  if (iVar2 == 0) {
                                    iVar2 = yin_parse_extcomplex_str
                                                      (mod,node,ext,LY_STMT_KEY,0,"value",unres);
                                  }
                                  else {
                                    iVar2 = strcmp(node->name,"base");
                                    if (iVar2 == 0) {
                                      iVar2 = yin_parse_extcomplex_str
                                                        (mod,node,ext,LY_STMT_BASE,0,"name",unres);
                                    }
                                    else {
                                      iVar2 = strcmp(node->name,"ordered-by");
                                      if (iVar2 == 0) {
                                        iVar2 = yin_parse_extcomplex_flag
                                                          (mod,node,ext,LY_STMT_ORDEREDBY,"user",
                                                           "system",0x100,0x100,0,unres);
                                      }
                                      else {
                                        iVar2 = strcmp(node->name,"belongs-to");
                                        if (iVar2 == 0) {
                                          iVar2 = yin_parse_extcomplex_str
                                                            (mod,node,ext,LY_STMT_BELONGSTO,0,
                                                             "module",unres);
                                        }
                                        else {
                                          iVar2 = strcmp(node->name,"contact");
                                          if (iVar2 == 0) {
                                            iVar2 = yin_parse_extcomplex_str
                                                              (mod,node,ext,LY_STMT_CONTACT,1,"text"
                                                               ,unres);
                                          }
                                          else {
                                            iVar2 = strcmp(node->name,"organization");
                                            if (iVar2 == 0) {
                                              iVar2 = yin_parse_extcomplex_str
                                                                (mod,node,ext,LY_STMT_ORGANIZATION,1
                                                                 ,"text",unres);
                                            }
                                            else {
                                              iVar2 = strcmp(node->name,"path");
                                              if (iVar2 == 0) {
                                                iVar2 = yin_parse_extcomplex_str
                                                                  (mod,node,ext,LY_STMT_PATH,0,
                                                                   "value",unres);
                                              }
                                              else {
                                                iVar2 = strcmp(node->name,"require-instance");
                                                if (iVar2 == 0) {
                                                  iVar2 = yin_parse_extcomplex_bool
                                                                    (mod,node,ext,
                                                                     LY_STMT_REQINSTANCE,"true",
                                                                     "false",unres);
                                                }
                                                else {
                                                  iVar2 = strcmp(node->name,"modifier");
                                                  if (iVar2 != 0) {
                                                    iVar2 = strcmp(node->name,"fraction-digits");
                                                    if (iVar2 == 0) {
                                                      p = lys_ext_complex_get_substmt
                                                                    (LY_STMT_DIGITS,ext,&info);
                                                      if ((void **)p == (void **)0x0) {
                                                        ly_vlog(mod->ctx,LYE_INCHILDSTMT,
                                                                LY_VLOG_NONE,(void *)0x0,node->name,
                                                                node->parent->name);
                                                      }
                                                      else {
                    // WARNING: Load size is inaccurate
                                                        if ((info->cardinality < LY_STMT_CARD_SOME)
                                                           && (*p != '\0')) {
                                                          ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,
                                                                  (void *)0x0,node->name,
                                                                  node->parent->name);
                                                        }
                                                        else {
                                                          pp = (void **)0x0;
                                                          i = 0;
                                                          if (LY_STMT_CARD_MAND < info->cardinality)
                                                          {
                    // WARNING: Load size is inaccurate
                                                            pp = (void **)p;
                                                            if (*p == (void *)0x0) {
                                                              pvVar4 = malloc(2);
                                                              *pp = pvVar4;
                                                              if (*pp == (void *)0x0) {
                                                                ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                              
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  }
                                                  else {
                    // WARNING: Load size is inaccurate
                                                    for (i = 0; *(char *)((long)i + (long)*p) !=
                                                                '\0'; i = i + 1) {
                                                    }
                                                  }
                                                  p = (void *)((long)i + (long)*pp);
                                                  }
                                                  value = lyxml_get_attr(node,"value",(char *)0x0);
                                                  if (value == (char *)0x0) {
                                                    ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,
                                                            (void *)0x0,"value",node->name);
                                                  }
                                                  else {
                                                    v = strtol(value,(char **)0x0,10);
                                                    if ((v < 1) || (0x12 < v)) {
                                                      ly_vlog(mod->ctx,LYE_INARG,LY_VLOG_NONE,
                                                              (void *)0x0,value,node->name);
                                                    }
                                                    else {
                                                      iVar2 = lyp_yin_parse_subnode_ext
                                                                        (mod,ext,LYEXT_PAR_EXTINST,
                                                                         node,LYEXT_SUBSTMT_STATUS,
                                                                         (uint8_t)i,unres);
                                                      if (iVar2 == 0) {
                                                        *(char *)p = (char)v;
                                                        if (pp != (void **)0x0) {
                                                          reallocated = realloc(*pp,(long)(i + 2) *
                                                                                    8);
                                                          if (reallocated == (void *)0x0) {
                                                            ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                      
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  *pp = reallocated;
                                                  *(undefined *)((long)*pp + (long)i + 1) = 0;
                                                  }
                                                  goto LAB_00168a8f;
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"max-elements");
                                                    if (iVar2 == 0) {
                                                      p = lys_ext_complex_get_substmt
                                                                    (LY_STMT_MAX,ext,&info);
                                                      if ((void **)p == (void **)0x0) {
                                                        ly_vlog(mod->ctx,LYE_INCHILDSTMT,
                                                                LY_VLOG_NONE,(void *)0x0,node->name,
                                                                node->parent->name);
                                                      }
                                                      else {
                    // WARNING: Load size is inaccurate
                                                        if ((info->cardinality < LY_STMT_CARD_SOME)
                                                           && (*p != (void *)0x0)) {
                                                          ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,
                                                                  (void *)0x0,node->name,
                                                                  node->parent->name);
                                                        }
                                                        else {
                                                          pp = (void **)0x0;
                                                          i = 0;
                                                          if (LY_STMT_CARD_MAND < info->cardinality)
                                                          {
                    // WARNING: Load size is inaccurate
                                                            pp = (void **)p;
                                                            if (*p == (void *)0x0) {
                                                              pvVar4 = malloc(0x10);
                                                              *pp = pvVar4;
                                                              if (*pp == (void *)0x0) {
                                                                ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                              
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  }
                                                  else {
                                                    i = 0;
                    // WARNING: Load size is inaccurate
                                                    while (*(long *)((long)*p + (long)i * 8) != 0) {
                                                      i = i + 1;
                                                    }
                                                  }
                                                  p = (void *)((long)*pp + (long)i * 8);
                                                  }
                                                  value = lyxml_get_attr(node,"value",(char *)0x0);
                                                  if (value == (char *)0x0) {
                                                    ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,
                                                            (void *)0x0,"value",node->name);
                                                  }
                                                  else {
                                                    while (ppuVar5 = __ctype_b_loc(),
                                                          ((*ppuVar5)[*value] & 0x2000) != 0) {
                                                      value = value + 1;
                                                    }
                                                    iVar2 = strcmp(value,"unbounded");
                                                    if (iVar2 == 0) {
                                                      u = 0;
                                                    }
                                                    else {
                                                      piVar6 = __errno_location();
                                                      *piVar6 = 0;
                                                      endptr = (char *)0x0;
                                                      u = strtoul(value,&endptr,10);
                                                      if (((*endptr != '\0') || (*value == '-')) ||
                                                         ((piVar6 = __errno_location(), *piVar6 != 0
                                                          || ((u == 0 || (0xffffffff < u)))))) {
                                                        ly_vlog(mod->ctx,LYE_INARG,LY_VLOG_NONE,
                                                                (void *)0x0,value,node->name);
                                                        goto LAB_00168b7a;
                                                      }
                                                    }
                                                    iVar2 = lyp_yin_parse_subnode_ext
                                                                      (mod,ext,LYEXT_PAR_EXTINST,
                                                                       node,LYEXT_SUBSTMT_MAX,
                                                                       (uint8_t)i,unres);
                                                    if (iVar2 == 0) {
                                                      pvVar4 = malloc(4);
                                                      *(void **)p = pvVar4;
                    // WARNING: Load size is inaccurate
                                                      if (*p != 0) {
                    // WARNING: Load size is inaccurate
                                                        **p = (int)u;
                                                        if (pp != (void **)0x0) {
                                                          reallocated = realloc(*pp,(long)(i + 2) *
                                                                                    8);
                                                          if (reallocated == (void *)0x0) {
                                                            ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                      
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  *pp = reallocated;
                                                  *(undefined8 *)((long)*pp + ((long)i + 1) * 8) = 0
                                                  ;
                                                  }
                                                  goto LAB_00168a8f;
                                                  }
                                                  ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                         "Memory allocation failed (%s()).",
                                                         "lyp_yin_parse_complex_ext");
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"min-elements");
                                                    if (iVar2 == 0) {
                                                      p = lys_ext_complex_get_substmt
                                                                    (LY_STMT_MIN,ext,&info);
                                                      if ((void **)p == (void **)0x0) {
                                                        ly_vlog(mod->ctx,LYE_INCHILDSTMT,
                                                                LY_VLOG_NONE,(void *)0x0,node->name,
                                                                node->parent->name);
                                                      }
                                                      else {
                    // WARNING: Load size is inaccurate
                                                        if ((info->cardinality < LY_STMT_CARD_SOME)
                                                           && (*p != (void *)0x0)) {
                                                          ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,
                                                                  (void *)0x0,node->name,
                                                                  node->parent->name);
                                                        }
                                                        else {
                                                          pp = (void **)0x0;
                                                          i = 0;
                                                          if (LY_STMT_CARD_MAND < info->cardinality)
                                                          {
                    // WARNING: Load size is inaccurate
                                                            pp = (void **)p;
                                                            if (*p == (void *)0x0) {
                                                              pvVar4 = malloc(0x10);
                                                              *pp = pvVar4;
                                                              if (*pp == (void *)0x0) {
                                                                ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                              
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  }
                                                  else {
                                                    i = 0;
                    // WARNING: Load size is inaccurate
                                                    while (*(long *)((long)*p + (long)i * 8) != 0) {
                                                      i = i + 1;
                                                    }
                                                  }
                                                  p = (void *)((long)*pp + (long)i * 8);
                                                  }
                                                  value = lyxml_get_attr(node,"value",(char *)0x0);
                                                  if (value == (char *)0x0) {
                                                    ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,
                                                            (void *)0x0,"value",node->name);
                                                  }
                                                  else {
                                                    while (ppuVar5 = __ctype_b_loc(),
                                                          ((*ppuVar5)[*value] & 0x2000) != 0) {
                                                      value = value + 1;
                                                    }
                                                    piVar6 = __errno_location();
                                                    *piVar6 = 0;
                                                    endptr = (char *)0x0;
                                                    u = strtoul(value,&endptr,10);
                                                    if ((((*endptr == '\0') && (*value != '-')) &&
                                                        (piVar6 = __errno_location(), *piVar6 == 0))
                                                       && (u < 0x100000000)) {
                                                      iVar2 = lyp_yin_parse_subnode_ext
                                                                        (mod,ext,LYEXT_PAR_EXTINST,
                                                                         node,LYEXT_SUBSTMT_MAX,
                                                                         (uint8_t)i,unres);
                                                      if (iVar2 == 0) {
                                                        pvVar4 = malloc(4);
                                                        *(void **)p = pvVar4;
                    // WARNING: Load size is inaccurate
                                                        if (*p != 0) {
                    // WARNING: Load size is inaccurate
                                                          **p = (int)u;
                                                          if (pp != (void **)0x0) {
                                                            reallocated = realloc(*pp,(long)(i + 2)
                                                                                      * 8);
                                                            if (reallocated == (void *)0x0) {
                                                              ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                          
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  *pp = reallocated;
                                                  *(undefined8 *)((long)*pp + ((long)i + 1) * 8) = 0
                                                  ;
                                                  }
                                                  goto LAB_00168a8f;
                                                  }
                                                  ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                         "Memory allocation failed (%s()).",
                                                         "lyp_yin_parse_complex_ext");
                                                  }
                                                  }
                                                  else {
                                                    ly_vlog(mod->ctx,LYE_INARG,LY_VLOG_NONE,
                                                            (void *)0x0,value,node->name);
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"value");
                                                    if (iVar2 == 0) {
                                                      p = lys_ext_complex_get_substmt
                                                                    (LY_STMT_VALUE,ext,&info);
                                                      if ((void **)p == (void **)0x0) {
                                                        ly_vlog(mod->ctx,LYE_INCHILDSTMT,
                                                                LY_VLOG_NONE,(void *)0x0,node->name,
                                                                node->parent->name);
                                                      }
                                                      else {
                    // WARNING: Load size is inaccurate
                                                        if ((info->cardinality < LY_STMT_CARD_SOME)
                                                           && (*p != (void *)0x0)) {
                                                          ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,
                                                                  (void *)0x0,node->name,
                                                                  node->parent->name);
                                                        }
                                                        else {
                                                          pp = (void **)0x0;
                                                          i = 0;
                                                          if (LY_STMT_CARD_MAND < info->cardinality)
                                                          {
                    // WARNING: Load size is inaccurate
                                                            pp = (void **)p;
                                                            if (*p == (void *)0x0) {
                                                              pvVar4 = malloc(0x10);
                                                              *pp = pvVar4;
                                                              if (*pp == (void *)0x0) {
                                                                ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                              
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  }
                                                  else {
                                                    i = 0;
                    // WARNING: Load size is inaccurate
                                                    while (*(long *)((long)*p + (long)i * 8) != 0) {
                                                      i = i + 1;
                                                    }
                                                  }
                                                  p = (void *)((long)*pp + (long)i * 8);
                                                  }
                                                  value = lyxml_get_attr(node,"value",(char *)0x0);
                                                  if (value == (char *)0x0) {
                                                    ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,
                                                            (void *)0x0,"value",node->name);
                                                  }
                                                  else {
                                                    while (ppuVar5 = __ctype_b_loc(),
                                                          ((*ppuVar5)[*value] & 0x2000) != 0) {
                                                      value = value + 1;
                                                    }
                                                    ll = strtoll(value,(char **)0x0,10);
                                                    if ((ll < -0x80000000) || (0x7fffffff < ll)) {
                                                      ly_vlog(mod->ctx,LYE_INARG,LY_VLOG_NONE,
                                                              (void *)0x0,value,node->name);
                                                    }
                                                    else {
                                                      iVar2 = lyp_yin_parse_subnode_ext
                                                                        (mod,ext,LYEXT_PAR_EXTINST,
                                                                         node,LYEXT_SUBSTMT_VALUE,
                                                                         (uint8_t)i,unres);
                                                      if (iVar2 == 0) {
                                                        pvVar4 = malloc(4);
                                                        *(void **)p = pvVar4;
                    // WARNING: Load size is inaccurate
                                                        if (*p != 0) {
                    // WARNING: Load size is inaccurate
                                                          **p = (int)ll;
                                                          if (pp != (void **)0x0) {
                                                            reallocated = realloc(*pp,(long)(i + 2)
                                                                                      * 8);
                                                            if (reallocated == (void *)0x0) {
                                                              ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                          
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  *pp = reallocated;
                                                  *(undefined8 *)((long)*pp + ((long)i + 1) * 8) = 0
                                                  ;
                                                  }
                                                  goto LAB_00168a8f;
                                                  }
                                                  ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                         "Memory allocation failed (%s()).",
                                                         "lyp_yin_parse_complex_ext");
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"position");
                                                    if (iVar2 == 0) {
                                                      p = lys_ext_complex_get_substmt
                                                                    (LY_STMT_POSITION,ext,&info);
                                                      if ((void **)p == (void **)0x0) {
                                                        ly_vlog(mod->ctx,LYE_INCHILDSTMT,
                                                                LY_VLOG_NONE,(void *)0x0,node->name,
                                                                node->parent->name);
                                                      }
                                                      else {
                    // WARNING: Load size is inaccurate
                                                        if ((info->cardinality < LY_STMT_CARD_SOME)
                                                           && (*p != (void *)0x0)) {
                                                          ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,
                                                                  (void *)0x0,node->name,
                                                                  node->parent->name);
                                                        }
                                                        else {
                                                          pp = (void **)0x0;
                                                          i = 0;
                                                          if (LY_STMT_CARD_MAND < info->cardinality)
                                                          {
                    // WARNING: Load size is inaccurate
                                                            pp = (void **)p;
                                                            if (*p == (void *)0x0) {
                                                              pvVar4 = malloc(0x10);
                                                              *pp = pvVar4;
                                                              if (*pp == (void *)0x0) {
                                                                ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                              
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  }
                                                  else {
                                                    i = 0;
                    // WARNING: Load size is inaccurate
                                                    while (*(long *)((long)*p + (long)i * 8) != 0) {
                                                      i = i + 1;
                                                    }
                                                  }
                                                  p = (void *)((long)*pp + (long)i * 8);
                                                  }
                                                  value = lyxml_get_attr(node,"value",(char *)0x0);
                                                  if (value == (char *)0x0) {
                                                    ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,
                                                            (void *)0x0,"value",node->name);
                                                  }
                                                  else {
                                                    ll = strtoll(value,(char **)0x0,10);
                                                    if ((ll < 0) || (0xffffffff < ll)) {
                                                      ly_vlog(mod->ctx,LYE_INARG,LY_VLOG_NONE,
                                                              (void *)0x0,value,node->name);
                                                    }
                                                    else {
                                                      iVar2 = lyp_yin_parse_subnode_ext
                                                                        (mod,ext,LYEXT_PAR_EXTINST,
                                                                         node,LYEXT_SUBSTMT_POSITION
                                                                         ,(uint8_t)i,unres);
                                                      if (iVar2 == 0) {
                                                        pvVar4 = malloc(4);
                                                        *(void **)p = pvVar4;
                    // WARNING: Load size is inaccurate
                                                        if (*p != 0) {
                    // WARNING: Load size is inaccurate
                                                          **p = (int)ll;
                                                          if (pp != (void **)0x0) {
                                                            reallocated = realloc(*pp,(long)(i + 2)
                                                                                      * 8);
                                                            if (reallocated == (void *)0x0) {
                                                              ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                          
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  *pp = reallocated;
                                                  *(undefined8 *)((long)*pp + ((long)i + 1) * 8) = 0
                                                  ;
                                                  }
                                                  goto LAB_00168a8f;
                                                  }
                                                  ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                         "Memory allocation failed (%s()).",
                                                         "lyp_yin_parse_complex_ext");
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"module");
                                                    if (iVar2 == 0) {
                                                      pp = yin_getplace_for_extcomplex_struct
                                                                     (node,ext,LY_STMT_MODULE);
                                                      if (pp != (void **)0x0) {
                                                        plVar7 = yin_read_module_(mod->ctx,node,
                                                                                  (char *)0x0,
                                                                                  (uint)((byte)mod->
                                                  field_0x40 >> 7));
                                                  *pp = plVar7;
                                                  plVar9 = (lys_node *)*pp;
                                                  goto joined_r0x00167acc;
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"when");
                                                    if (iVar2 == 0) {
                                                      p = lys_ext_complex_get_substmt
                                                                    (LY_STMT_WHEN,ext,&info);
                                                      if ((void **)p == (void **)0x0) {
                                                        ly_vlog(mod->ctx,LYE_INCHILDSTMT,
                                                                LY_VLOG_NONE,(void *)0x0,node->name,
                                                                node->parent->name);
                                                      }
                                                      else {
                    // WARNING: Load size is inaccurate
                                                        if ((info->cardinality < LY_STMT_CARD_SOME)
                                                           && (*p != (void *)0x0)) {
                                                          ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,
                                                                  (void *)0x0,node->name,
                                                                  node->parent->name);
                                                        }
                                                        else {
                                                          pp = (void **)0x0;
                                                          i = 0;
                                                          if (LY_STMT_CARD_MAND < info->cardinality)
                                                          {
                    // WARNING: Load size is inaccurate
                                                            pp = (void **)p;
                                                            if (*p == (void *)0x0) {
                                                              pvVar4 = malloc(0x10);
                                                              *pp = pvVar4;
                                                              if (*pp == (void *)0x0) {
                                                                ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                              
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  }
                                                  else {
                                                    i = 0;
                    // WARNING: Load size is inaccurate
                                                    while (*(long *)((long)*p + (long)i * 8) != 0) {
                                                      i = i + 1;
                                                    }
                                                  }
                                                  p = (void *)((long)*pp + (long)i * 8);
                                                  }
                                                  plVar8 = read_yin_when(mod,node,unres);
                                                  *(lys_when **)p = plVar8;
                    // WARNING: Load size is inaccurate
                                                  if (*p != 0) {
                                                    if (pp != (void **)0x0) {
                                                      reallocated = realloc(*pp,(long)(i + 2) * 8);
                                                      if (reallocated == (void *)0x0) {
                                                        ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                               "Memory allocation failed (%s()).",
                                                               "lyp_yin_parse_complex_ext");
                                                        goto LAB_00168b7a;
                                                      }
                                                      *pp = reallocated;
                                                      *(undefined8 *)((long)*pp + ((long)i + 1) * 8)
                                                           = 0;
                                                    }
                                                    goto LAB_00168a8f;
                                                  }
                                                  }
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"revision");
                                                    if (iVar2 == 0) {
                                                      p = lys_ext_complex_get_substmt
                                                                    (LY_STMT_REVISION,ext,&info);
                                                      if ((void **)p == (void **)0x0) {
                                                        ly_vlog(mod->ctx,LYE_INCHILDSTMT,
                                                                LY_VLOG_NONE,(void *)0x0,node->name,
                                                                node->parent->name);
                                                      }
                                                      else {
                    // WARNING: Load size is inaccurate
                                                        if ((info->cardinality < LY_STMT_CARD_SOME)
                                                           && (*p != (void *)0x0)) {
                                                          ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,
                                                                  (void *)0x0,node->name,
                                                                  node->parent->name);
                                                        }
                                                        else {
                                                          pp = (void **)0x0;
                                                          i = 0;
                                                          if (LY_STMT_CARD_MAND < info->cardinality)
                                                          {
                    // WARNING: Load size is inaccurate
                                                            pp = (void **)p;
                                                            if (*p == (void *)0x0) {
                                                              pvVar4 = malloc(0x10);
                                                              *pp = pvVar4;
                                                              if (*pp == (void *)0x0) {
                                                                ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                              
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  }
                                                  else {
                                                    i = 0;
                    // WARNING: Load size is inaccurate
                                                    while (*(long *)((long)*p + (long)i * 8) != 0) {
                                                      i = i + 1;
                                                    }
                                                  }
                                                  p = (void *)((long)*pp + (long)i * 8);
                                                  }
                                                  pvVar4 = calloc(1,0x28);
                                                  *(void **)p = pvVar4;
                    // WARNING: Load size is inaccurate
                                                  if (*p == 0) {
                                                    ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                           "Memory allocation failed (%s()).",
                                                           "lyp_yin_parse_complex_ext");
                                                  }
                                                  else {
                    // WARNING: Load size is inaccurate
                                                    iVar2 = fill_yin_revision(mod,node,*p,unres);
                                                    if (iVar2 == 0) {
                                                      if (pp != (void **)0x0) {
                                                        for (j = 0; j < i; j = j + 1) {
                    // WARNING: Load size is inaccurate
                                                          iVar2 = strcmp(*(char **)((long)*pp +
                                                                                   (long)j * 8),*p);
                                                          if (iVar2 == 0) {
                    // WARNING: Load size is inaccurate
                                                            ly_log(mod->ctx,LY_LLWRN,LY_SUCCESS,
                                                                                                                                      
                                                  "Module\'s revisions are not unique (%s).",*p);
                                                  }
                                                  }
                                                  }
                                                  if (pp != (void **)0x0) {
                                                    reallocated = realloc(*pp,(long)(i + 2) * 8);
                                                    if (reallocated == (void *)0x0) {
                                                      ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                             "Memory allocation failed (%s()).",
                                                             "lyp_yin_parse_complex_ext");
                                                      goto LAB_00168b7a;
                                                    }
                                                    *pp = reallocated;
                                                    *(undefined8 *)((long)*pp + ((long)i + 1) * 8) =
                                                         0;
                                                  }
                                                  goto LAB_00168a8f;
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"unique");
                                                    if (iVar2 == 0) {
                                                      p = lys_ext_complex_get_substmt
                                                                    (LY_STMT_UNIQUE,ext,&info);
                                                      if ((void **)p == (void **)0x0) {
                                                        ly_vlog(mod->ctx,LYE_INCHILDSTMT,
                                                                LY_VLOG_NONE,(void *)0x0,node->name,
                                                                node->parent->name);
                                                      }
                                                      else {
                    // WARNING: Load size is inaccurate
                                                        if ((info->cardinality < LY_STMT_CARD_SOME)
                                                           && (*p != (void *)0x0)) {
                                                          ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,
                                                                  (void *)0x0,node->name,
                                                                  node->parent->name);
                                                        }
                                                        else {
                                                          pp = (void **)0x0;
                                                          i = 0;
                                                          if (LY_STMT_CARD_MAND < info->cardinality)
                                                          {
                    // WARNING: Load size is inaccurate
                                                            pp = (void **)p;
                                                            if (*p == (void *)0x0) {
                                                              pvVar4 = malloc(0x10);
                                                              *pp = pvVar4;
                                                              if (*pp == (void *)0x0) {
                                                                ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                              
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  }
                                                  else {
                                                    i = 0;
                    // WARNING: Load size is inaccurate
                                                    while (*(long *)((long)*p + (long)i * 8) != 0) {
                                                      i = i + 1;
                                                    }
                                                  }
                                                  p = (void *)((long)*pp + (long)i * 8);
                                                  }
                                                  pvVar4 = calloc(1,0x10);
                                                  *(void **)p = pvVar4;
                    // WARNING: Load size is inaccurate
                                                  if (*p == 0) {
                                                    ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                           "Memory allocation failed (%s()).",
                                                           "lyp_yin_parse_complex_ext");
                                                  }
                                                  else {
                    // WARNING: Load size is inaccurate
                                                    iVar2 = fill_yin_unique(mod,(lys_node *)ext,node
                                                                            ,*p,unres);
                                                    if ((iVar2 == 0) &&
                                                       (iVar2 = lyp_yin_parse_subnode_ext
                                                                          (mod,ext,LYEXT_PAR_EXTINST
                                                                           ,node,
                                                  LYEXT_SUBSTMT_UNIQUE,(uint8_t)i,unres), iVar2 == 0
                                                  )) {
                                                    if (pp != (void **)0x0) {
                                                      reallocated = realloc(*pp,(long)(i + 2) * 8);
                                                      if (reallocated == (void *)0x0) {
                                                        ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                               "Memory allocation failed (%s()).",
                                                               "lyp_yin_parse_complex_ext");
                                                        goto LAB_00168b7a;
                                                      }
                                                      *pp = reallocated;
                                                      *(undefined8 *)((long)*pp + ((long)i + 1) * 8)
                                                           = 0;
                                                    }
                                                    goto LAB_00168a8f;
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"action");
                                                    if (iVar2 == 0) {
                                                      pp = yin_getplace_for_extcomplex_node
                                                                     (node,ext,LY_STMT_ACTION);
                                                      if ((lys_node **)pp != (lys_node **)0x0) {
                                                        plVar9 = read_yin_rpc_action(mod,(lys_node *
                                                                                         )ext,node,1
                                                                                     ,unres);
joined_r0x00167acc:
                                                        if (plVar9 != (lys_node *)0x0)
                                                        goto LAB_00168a8f;
                                                      }
                                                    }
                                                    else {
                                                      iVar2 = strcmp(node->name,"anydata");
                                                      if (iVar2 == 0) {
                                                        pp = yin_getplace_for_extcomplex_node
                                                                       (node,ext,LY_STMT_ANYDATA);
                                                        if ((lys_node **)pp != (lys_node **)0x0) {
                                                          plVar9 = read_yin_anydata(mod,(lys_node *)
                                                                                        ext,node,
                                                                                    LYS_ANYDATA,1,
                                                                                    unres);
                                                          goto joined_r0x00167acc;
                                                        }
                                                      }
                                                      else {
                                                        iVar2 = strcmp(node->name,"anyxml");
                                                        if (iVar2 == 0) {
                                                          pp = yin_getplace_for_extcomplex_node
                                                                         (node,ext,LY_STMT_ANYXML);
                                                          if ((lys_node **)pp != (lys_node **)0x0) {
                                                            plVar9 = read_yin_anydata(mod,(lys_node 
                                                  *)ext,node,LYS_ANYXML,1,unres);
                                                  goto joined_r0x00167acc;
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"case");
                                                    if (iVar2 == 0) {
                                                      pp = yin_getplace_for_extcomplex_node
                                                                     (node,ext,LY_STMT_CASE);
                                                      if ((lys_node **)pp != (lys_node **)0x0) {
                                                        plVar9 = read_yin_case(mod,(lys_node *)ext,
                                                                               node,1,unres);
                                                        goto joined_r0x00167acc;
                                                      }
                                                    }
                                                    else {
                                                      iVar2 = strcmp(node->name,"choice");
                                                      if (iVar2 == 0) {
                                                        pp = yin_getplace_for_extcomplex_node
                                                                       (node,ext,LY_STMT_CHOICE);
                                                        if ((lys_node **)pp != (lys_node **)0x0) {
                                                          plVar9 = read_yin_choice(mod,(lys_node *)
                                                                                       ext,node,1,
                                                                                   unres);
                                                          goto joined_r0x00167acc;
                                                        }
                                                      }
                                                      else {
                                                        iVar2 = strcmp(node->name,"container");
                                                        if (iVar2 == 0) {
                                                          pp = yin_getplace_for_extcomplex_node
                                                                         (node,ext,LY_STMT_CONTAINER
                                                                         );
                                                          if ((lys_node **)pp != (lys_node **)0x0) {
                                                            plVar9 = read_yin_container(mod,(
                                                  lys_node *)ext,node,1,unres);
                                                  goto joined_r0x00167acc;
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"grouping");
                                                    if (iVar2 == 0) {
                                                      pp = yin_getplace_for_extcomplex_node
                                                                     (node,ext,LY_STMT_GROUPING);
                                                      if ((lys_node **)pp != (lys_node **)0x0) {
                                                        plVar9 = read_yin_grouping(mod,(lys_node *)
                                                                                       ext,node,1,
                                                                                   unres);
                                                        goto joined_r0x00167acc;
                                                      }
                                                    }
                                                    else {
                                                      iVar2 = strcmp(node->name,"output");
                                                      if (iVar2 == 0) {
                                                        pp = yin_getplace_for_extcomplex_node
                                                                       (node,ext,LY_STMT_OUTPUT);
                                                        if ((lys_node **)pp != (lys_node **)0x0) {
                                                          plVar9 = read_yin_input_output
                                                                             (mod,(lys_node *)ext,
                                                                              node,1,unres);
                                                          goto joined_r0x00167acc;
                                                        }
                                                      }
                                                      else {
                                                        iVar2 = strcmp(node->name,"input");
                                                        if (iVar2 == 0) {
                                                          pp = yin_getplace_for_extcomplex_node
                                                                         (node,ext,LY_STMT_INPUT);
                                                          if ((lys_node **)pp != (lys_node **)0x0) {
                                                            plVar9 = read_yin_input_output
                                                                               (mod,(lys_node *)ext,
                                                                                node,1,unres);
                                                            goto joined_r0x00167acc;
                                                          }
                                                        }
                                                        else {
                                                          iVar2 = strcmp(node->name,"leaf");
                                                          if (iVar2 == 0) {
                                                            pp = yin_getplace_for_extcomplex_node
                                                                           (node,ext,LY_STMT_LEAF);
                                                            if ((lys_node **)pp != (lys_node **)0x0)
                                                            {
                                                              plVar9 = read_yin_leaf(mod,(lys_node *
                                                                                         )ext,node,1
                                                                                     ,unres);
                                                              goto joined_r0x00167acc;
                                                            }
                                                          }
                                                          else {
                                                            iVar2 = strcmp(node->name,"leaf-list");
                                                            if (iVar2 == 0) {
                                                              pp = yin_getplace_for_extcomplex_node
                                                                             (node,ext,
                                                  LY_STMT_LEAFLIST);
                                                  if ((lys_node **)pp != (lys_node **)0x0) {
                                                    plVar9 = read_yin_leaflist(mod,(lys_node *)ext,
                                                                               node,1,unres);
                                                    goto joined_r0x00167acc;
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"list");
                                                    if (iVar2 == 0) {
                                                      pp = yin_getplace_for_extcomplex_node
                                                                     (node,ext,LY_STMT_LIST);
                                                      if ((lys_node **)pp != (lys_node **)0x0) {
                                                        plVar9 = read_yin_list(mod,(lys_node *)ext,
                                                                               node,1,unres);
                                                        goto joined_r0x00167acc;
                                                      }
                                                    }
                                                    else {
                                                      iVar2 = strcmp(node->name,"notification");
                                                      if (iVar2 == 0) {
                                                        pp = yin_getplace_for_extcomplex_node
                                                                       (node,ext,
                                                  LY_STMT_NOTIFICATION);
                                                  if ((lys_node **)pp != (lys_node **)0x0) {
                                                    plVar9 = read_yin_notif(mod,(lys_node *)ext,node
                                                                            ,1,unres);
                                                    goto joined_r0x00167acc;
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"uses");
                                                    if (iVar2 == 0) {
                                                      pp = yin_getplace_for_extcomplex_node
                                                                     (node,ext,LY_STMT_USES);
                                                      if ((lys_node **)pp != (lys_node **)0x0) {
                                                        plVar9 = read_yin_uses(mod,(lys_node *)ext,
                                                                               node,1,unres);
                                                        goto joined_r0x00167acc;
                                                      }
                                                    }
                                                    else {
                                                      iVar2 = strcmp(node->name,"length");
                                                      if (iVar2 == 0) {
                                                        p = lys_ext_complex_get_substmt
                                                                      (LY_STMT_LENGTH,ext,&info);
                                                        if ((void **)p == (void **)0x0) {
                                                          ly_vlog(mod->ctx,LYE_INCHILDSTMT,
                                                                  LY_VLOG_NONE,(void *)0x0,
                                                                  node->name,node->parent->name);
                                                        }
                                                        else {
                    // WARNING: Load size is inaccurate
                                                          if ((info->cardinality < LY_STMT_CARD_SOME
                                                              ) && (*p != (void *)0x0)) {
                                                            ly_vlog(mod->ctx,LYE_TOOMANY,
                                                                    LY_VLOG_NONE,(void *)0x0,
                                                                    node->name,node->parent->name);
                                                          }
                                                          else {
                                                            pp = (void **)0x0;
                                                            i = 0;
                                                            if (LY_STMT_CARD_MAND <
                                                                info->cardinality) {
                    // WARNING: Load size is inaccurate
                                                              pp = (void **)p;
                                                              if (*p == (void *)0x0) {
                                                                pvVar4 = malloc(0x10);
                                                                *pp = pvVar4;
                                                                if (*pp == (void *)0x0) {
                                                                  ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                                  
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  }
                                                  else {
                                                    i = 0;
                    // WARNING: Load size is inaccurate
                                                    while (*(long *)((long)*p + (long)i * 8) != 0) {
                                                      i = i + 1;
                                                    }
                                                  }
                                                  p = (void *)((long)*pp + (long)i * 8);
                                                  }
                                                  value = lyxml_get_attr(node,"value",(char *)0x0);
                                                  if (value == (char *)0x0) {
                                                    ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,
                                                            (void *)0x0,"value",node->name);
                                                  }
                                                  else {
                                                    pvVar4 = calloc(1,0x38);
                                                    *(void **)p = pvVar4;
                    // WARNING: Load size is inaccurate
                                                    if (*p == 0) {
                                                      ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                             "Memory allocation failed (%s()).",
                                                             "lyp_yin_parse_complex_ext");
                                                    }
                                                    else {
                    // WARNING: Load size is inaccurate
                                                      puVar1 = *p;
                                                      pcVar10 = lydict_insert(mod->ctx,value,0);
                                                      *puVar1 = pcVar10;
                    // WARNING: Load size is inaccurate
                                                      iVar2 = read_restr_substmt(mod,*p,node,unres);
                                                      if (iVar2 == 0) {
                                                        if (pp != (void **)0x0) {
                                                          reallocated = realloc(*pp,(long)(i + 2) *
                                                                                    8);
                                                          if (reallocated == (void *)0x0) {
                                                            ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                      
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  *pp = reallocated;
                                                  *(undefined8 *)((long)*pp + ((long)i + 1) * 8) = 0
                                                  ;
                                                  }
                                                  goto LAB_00168a8f;
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"must");
                                                    if (iVar2 == 0) {
                                                      pp = yin_getplace_for_extcomplex_struct
                                                                     (node,ext,LY_STMT_MUST);
                                                      if (pp != (void **)0x0) {
                                                        pvVar4 = calloc(1,0x38);
                                                        *pp = pvVar4;
                                                        if (*pp != (void *)0x0) {
                                                          iVar2 = fill_yin_must(mod,node,(lys_restr 
                                                  *)*pp,unres);
                                                  goto joined_r0x0016566c;
                                                  }
                                                  ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                         "Memory allocation failed (%s()).",
                                                         "lyp_yin_parse_complex_ext");
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"pattern");
                                                    if (iVar2 == 0) {
                                                      p = lys_ext_complex_get_substmt
                                                                    (LY_STMT_PATTERN,ext,&info);
                                                      if ((void **)p == (void **)0x0) {
                                                        ly_vlog(mod->ctx,LYE_INCHILDSTMT,
                                                                LY_VLOG_NONE,(void *)0x0,node->name,
                                                                node->parent->name);
                                                      }
                                                      else {
                    // WARNING: Load size is inaccurate
                                                        if ((info->cardinality < LY_STMT_CARD_SOME)
                                                           && (*p != (void *)0x0)) {
                                                          ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,
                                                                  (void *)0x0,node->name,
                                                                  node->parent->name);
                                                        }
                                                        else {
                                                          pp = (void **)0x0;
                                                          i = 0;
                                                          if (LY_STMT_CARD_MAND < info->cardinality)
                                                          {
                    // WARNING: Load size is inaccurate
                                                            pp = (void **)p;
                                                            if (*p == (void *)0x0) {
                                                              pvVar4 = malloc(0x10);
                                                              *pp = pvVar4;
                                                              if (*pp == (void *)0x0) {
                                                                ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                              
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  }
                                                  else {
                                                    i = 0;
                    // WARNING: Load size is inaccurate
                                                    while (*(long *)((long)*p + (long)i * 8) != 0) {
                                                      i = i + 1;
                                                    }
                                                  }
                                                  p = (void *)((long)*pp + (long)i * 8);
                                                  }
                                                  value = lyxml_get_attr(node,"value",(char *)0x0);
                                                  if (value == (char *)0x0) {
                                                    ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,
                                                            (void *)0x0,"value",node->name);
                                                  }
                                                  else {
                                                    iVar2 = lyp_check_pattern(mod->ctx,value,
                                                                              (pcre **)0x0);
                                                    if (iVar2 == 0) {
                                                      pvVar4 = calloc(1,0x38);
                                                      *(void **)p = pvVar4;
                    // WARNING: Load size is inaccurate
                                                      if (*p == 0) {
                                                        ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                               "Memory allocation failed (%s()).",
                                                               "lyp_yin_parse_complex_ext");
                                                      }
                                                      else {
                                                        modifier = '\x06';
                                                        if (1 < ((byte)mod->field_0x40 >> 1 & 7)) {
                                                          name = (char *)0x0;
                                                          for (child = node->child;
                                                              child != (lyxml_elem *)0x0;
                                                              child = child->next) {
                                                            if (((child->ns != (lyxml_ns *)0x0) &&
                                                                (iVar2 = strcmp(child->ns->value,
                                                                                                                                                                
                                                  "urn:ietf:params:xml:ns:yang:yin:1"), iVar2 == 0))
                                                  && (iVar2 = strcmp(child->name,"modifier"),
                                                     iVar2 == 0)) {
                                                    if (name != (char *)0x0) {
                                                      ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,
                                                              (void *)0x0,"modifier",node->name);
                                                      goto LAB_00168b7a;
                                                    }
                                                    name = lyxml_get_attr(child,"value",(char *)0x0)
                                                    ;
                                                    if (name == (char *)0x0) {
                                                      ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,
                                                              (void *)0x0,"value",child->name);
                                                      goto LAB_00168b7a;
                                                    }
                                                    iVar2 = strcmp(name,"invert-match");
                                                    if (iVar2 != 0) {
                                                      ly_vlog(mod->ctx,LYE_INARG,LY_VLOG_NONE,
                                                              (void *)0x0,name,"modifier");
                                                      goto LAB_00168b7a;
                                                    }
                                                    modifier = '\x15';
                    // WARNING: Load size is inaccurate
                                                    iVar2 = lyp_yin_parse_subnode_ext
                                                                      (mod,*p,LYEXT_PAR_RESTR,child,
                                                                       LYEXT_SUBSTMT_MODIFIER,'\0',
                                                                       unres);
                                                    if (iVar2 != 0) goto LAB_00168b7a;
                                                  }
                                                  }
                                                  }
                                                  sVar11 = strlen(value);
                    // WARNING: Load size is inaccurate
                                                  puVar1 = *p;
                                                  pvVar4 = malloc(sVar11 + 2);
                                                  *puVar1 = pvVar4;
                    // WARNING: Load size is inaccurate
                                                  if (**p == 0) {
                                                    ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                           "Memory allocation failed (%s()).",
                                                           "lyp_yin_parse_complex_ext");
                                                  }
                                                  else {
                    // WARNING: Load size is inaccurate
                                                    *(char *)**p = modifier;
                    // WARNING: Load size is inaccurate
                                                    strcpy((char *)(**p + 1),value);
                    // WARNING: Load size is inaccurate
                                                    lydict_insert_zc(mod->ctx,(char *)**p);
                    // WARNING: Load size is inaccurate
                                                    iVar2 = read_restr_substmt(mod,*p,node,unres);
                                                    if (iVar2 == 0) {
                                                      if (pp != (void **)0x0) {
                                                        reallocated = realloc(*pp,(long)(i + 2) * 8)
                                                        ;
                                                        if (reallocated == (void *)0x0) {
                                                          ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                 "Memory allocation failed (%s()).",
                                                                 "lyp_yin_parse_complex_ext");
                                                          goto LAB_00168b7a;
                                                        }
                                                        *pp = reallocated;
                                                        *(undefined8 *)
                                                         ((long)*pp + ((long)i + 1) * 8) = 0;
                                                      }
                                                      goto LAB_00168a8f;
                                                    }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  else {
                                                    iVar2 = strcmp(node->name,"range");
                                                    if (iVar2 != 0) {
                                                      pcVar10 = node->name;
                                                      pLVar12 = ly_errno_glob_address();
                                                      ly_log(mod->ctx,LY_LLERR,*pLVar12,
                                                                                                                          
                                                  "Extension\'s substatement \"%s\" not supported.",
                                                  pcVar10);
                                                  goto LAB_00168a8f;
                                                  }
                                                  p = lys_ext_complex_get_substmt
                                                                (LY_STMT_RANGE,ext,&info);
                                                  if ((void **)p == (void **)0x0) {
                                                    ly_vlog(mod->ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,
                                                            (void *)0x0,node->name,
                                                            node->parent->name);
                                                  }
                                                  else {
                    // WARNING: Load size is inaccurate
                                                    if ((info->cardinality < LY_STMT_CARD_SOME) &&
                                                       (*p != (void *)0x0)) {
                                                      ly_vlog(mod->ctx,LYE_TOOMANY,LY_VLOG_NONE,
                                                              (void *)0x0,node->name,
                                                              node->parent->name);
                                                    }
                                                    else {
                                                      pp = (void **)0x0;
                                                      i = 0;
                                                      if (LY_STMT_CARD_MAND < info->cardinality) {
                    // WARNING: Load size is inaccurate
                                                        pp = (void **)p;
                                                        if (*p == (void *)0x0) {
                                                          pvVar4 = malloc(0x10);
                                                          *pp = pvVar4;
                                                          if (*pp == (void *)0x0) {
                                                            ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                      
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  }
                                                  else {
                                                    i = 0;
                    // WARNING: Load size is inaccurate
                                                    while (*(long *)((long)*p + (long)i * 8) != 0) {
                                                      i = i + 1;
                                                    }
                                                  }
                                                  p = (void *)((long)*pp + (long)i * 8);
                                                  }
                                                  value = lyxml_get_attr(node,"value",(char *)0x0);
                                                  if (value == (char *)0x0) {
                                                    ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,
                                                            (void *)0x0,"value",node->name);
                                                  }
                                                  else {
                                                    pvVar4 = calloc(1,0x38);
                                                    *(void **)p = pvVar4;
                    // WARNING: Load size is inaccurate
                                                    if (*p == 0) {
                                                      ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                             "Memory allocation failed (%s()).",
                                                             "lyp_yin_parse_complex_ext");
                                                    }
                                                    else {
                    // WARNING: Load size is inaccurate
                                                      puVar1 = *p;
                                                      pcVar10 = lydict_insert(mod->ctx,value,0);
                                                      *puVar1 = pcVar10;
                    // WARNING: Load size is inaccurate
                                                      iVar2 = read_restr_substmt(mod,*p,node,unres);
                                                      if (iVar2 == 0) {
                                                        if (pp != (void **)0x0) {
                                                          reallocated = realloc(*pp,(long)(i + 2) *
                                                                                    8);
                                                          if (reallocated == (void *)0x0) {
                                                            ly_log(mod->ctx,LY_LLERR,LY_EMEM,
                                                                                                                                      
                                                  "Memory allocation failed (%s()).",
                                                  "lyp_yin_parse_complex_ext");
                                                  goto LAB_00168b7a;
                                                  }
                                                  *pp = reallocated;
                                                  *(undefined8 *)((long)*pp + ((long)i + 1) * 8) = 0
                                                  ;
                                                  }
                                                  goto LAB_00168a8f;
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  goto LAB_00168b7a;
                                                  }
                                                  iVar2 = yin_parse_extcomplex_bool
                                                                    (mod,node,ext,LY_STMT_MODIFIER,
                                                                     "invert-match",(char *)0x0,
                                                                     unres);
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              goto joined_r0x0016566c;
            }
            p = yin_getplace_for_extcomplex_flags(node,ext,LY_STMT_STATUS,0x38);
            if (p != (void *)0x0) {
              value = lyxml_get_attr(node,"value",(char *)0x0);
              if (value != (char *)0x0) {
                iVar2 = strcmp(value,"current");
                if (iVar2 == 0) {
                    // WARNING: Load size is inaccurate
                  *(ushort *)p = *p | 8;
                }
                else {
                  iVar2 = strcmp(value,"deprecated");
                  if (iVar2 == 0) {
                    // WARNING: Load size is inaccurate
                    *(ushort *)p = *p | 0x10;
                  }
                  else {
                    iVar2 = strcmp(value,"obsolete");
                    if (iVar2 != 0) {
                      ly_vlog(mod->ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,node->name);
                      goto LAB_00168b7a;
                    }
                    // WARNING: Load size is inaccurate
                    *(ushort *)p = *p | 0x20;
                  }
                }
                iVar2 = lyp_yin_parse_subnode_ext
                                  (mod,ext,LYEXT_PAR_EXTINST,node,LYEXT_SUBSTMT_STATUS,'\0',unres);
                goto joined_r0x0016566c;
              }
              ly_vlog(mod->ctx,LYE_MISSARG,LY_VLOG_NONE,(void *)0x0,"value",node->name);
            }
          }
        }
        goto LAB_00168b7a;
      }
      type = (lys_type **)yin_getplace_for_extcomplex_struct(node,ext,LY_STMT_TYPE);
      if (type == (lys_type **)0x0) goto LAB_00168b7a;
      plVar3 = (lys_type *)calloc(1,0x40);
      *type = plVar3;
      if (*type == (lys_type *)0x0) {
        ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "lyp_yin_parse_complex_ext");
        goto LAB_00168b7a;
      }
      lyxml_unlink(mod->ctx,node);
      (*type)->der = (lys_tpdf *)node;
      (*type)->parent = (lys_tpdf *)ext;
      iVar2 = unres_schema_add_node(mod,unres,*type,UNRES_TYPE_DER_EXT,(lys_node *)0x0);
      if (iVar2 == -1) {
        (*type)->der = (lys_tpdf *)0x0;
        goto LAB_00168b7a;
      }
    }
    node = next;
  } while( true );
}



lys_node * xml_data_search_schemanode(lyxml_elem *xml,lys_node *start,int options)

{
  lys_node *plVar1;
  lys_module *plVar2;
  int options_local;
  lys_node *start_local;
  lyxml_elem *xml_local;
  lys_node *result;
  lys_node *aux;
  
  result = start;
  do {
    if (result == (lys_node *)0x0) {
      return (lys_node *)0x0;
    }
    if (((result->nodetype != LYS_GROUPING) &&
        ((result->nodetype != LYS_OUTPUT || ((options & 0x10U) == 0)))) &&
       ((result->nodetype != LYS_INPUT || ((options & 0x20U) == 0)))) {
      if ((result->nodetype & 0x1642) == LYS_UNKNOWN) {
        if ((result->name == xml->name) &&
           (plVar2 = lys_main_module(result->module), plVar2->ns == xml->ns->value)) {
          return result;
        }
      }
      else {
        plVar1 = xml_data_search_schemanode(xml,result->child,options);
        if (plVar1 != (lys_node *)0x0) {
          return plVar1;
        }
      }
    }
    result = result->next;
  } while( true );
}



int xml_get_value(lyd_node *node,lyxml_elem *xml,int editbits,int trusted)

{
  int iVar1;
  hash_table *phVar2;
  lys_type *plVar3;
  int trusted_local;
  int editbits_local;
  lyxml_elem *xml_local;
  lyd_node *node_local;
  lyd_node_leaf_list *leaf;
  
  if (((node != (lyd_node *)0x0) &&
      ((node->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN)) &&
     (xml != (lyxml_elem *)0x0)) {
    phVar2 = (hash_table *)lydict_insert(node->schema->module->ctx,xml->content,0);
    node->ht = phVar2;
    if ((((editbits & 0x20U) == 0) || ((node->schema->nodetype & LYS_LEAF) == LYS_UNKNOWN)) ||
       ((node->ht != (hash_table *)0x0 && (*(char *)&node->ht->used != '\0')))) {
      plVar3 = lyp_parse_value((lys_type *)&node->schema[1].ref,(char **)&node->ht,xml,
                               (lyd_node_leaf_list *)node,(lyd_attr *)0x0,(lys_module *)0x0,1,0,
                               trusted);
      if (plVar3 == (lys_type *)0x0) {
        iVar1 = 1;
      }
      else {
        iVar1 = 0;
      }
    }
    else {
      *(undefined4 *)&node[1].schema = 0x14;
      iVar1 = 0;
    }
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("node && (node->schema->nodetype & (LYS_LEAFLIST | LYS_LEAF)) && xml",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_xml.c"
                ,0x52,"xml_get_value");
}



int xml_parse_data(ly_ctx *ctx,lyxml_elem *xml,lyd_node *parent,lyd_node *first_sibling,
                  lyd_node *prev,int options,unres_data *unres,lyd_node **result,
                  lyd_node **act_notif,char *yang_data_name)

{
  LYS_NODE LVar1;
  ly_module_data_clb p_Var2;
  void *pvVar3;
  long lVar4;
  lyd_attr *plVar5;
  int iVar6;
  size_t sVar7;
  undefined8 *puVar8;
  lys_module *plVar9;
  lyd_node *plVar10;
  lys_node_list *plVar11;
  hash_table *phVar12;
  char *pcVar13;
  lyd_node **first_sibling_00;
  LY_VLOG_ELEM elem_type;
  long in_FS_OFFSET;
  char *yang_data_name_local;
  lyd_node **act_notif_local;
  lyd_node **result_local;
  unres_data *unres_local;
  int options_local;
  lyd_node *prev_local;
  lyd_node *first_sibling_local;
  lyd_node *parent_local;
  lyxml_elem *xml_local;
  ly_ctx *ctx_local;
  uint8_t pos;
  int editbits;
  int i;
  int j;
  int havechildren;
  int filterflag;
  int found;
  int ret;
  int r;
  lyd_node *diter;
  lyd_attr *dattr;
  lys_module *mod;
  lyd_node *dlast;
  lys_node *schema;
  lys_node *target;
  lyd_attr *dattr_iter;
  lyxml_attr *attr;
  lyxml_elem *child;
  lyxml_elem *next;
  char *str;
  lys_node_augment *aug;
  lys_node *ext_node;
  char *msg;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  mod = (lys_module *)0x0;
  schema = (lys_node *)0x0;
  editbits = 0;
  filterflag = 0;
  ret = 0;
  str = (char *)0x0;
  first_sibling_local = first_sibling;
  parent_local = parent;
  xml_local = xml;
  ctx_local = ctx;
  if (xml == (lyxml_elem *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("xml",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_xml.c"
                  ,0x7a,"xml_parse_data");
  }
  if (result == (lyd_node **)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("result",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_xml.c"
                  ,0x7b,"xml_parse_data");
  }
  *result = (lyd_node *)0x0;
  if ((xml->flags & 1U) != 0) {
    if ((options & 0x200U) == 0) {
      iVar6 = 0;
    }
    else {
      ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_XML,xml,"XML element with mixed content");
      iVar6 = -1;
    }
    goto LAB_0016a9af;
  }
  if ((xml->ns == (lyxml_ns *)0x0) || (xml->ns->value == (char *)0x0)) {
    if ((options & 0x200U) == 0) {
      iVar6 = 0;
    }
    else {
      ly_vlog(ctx,LYE_XML_MISS,LY_VLOG_XML,xml,"element\'s","namespace");
      iVar6 = -1;
    }
    goto LAB_0016a9af;
  }
  if (parent == (lyd_node *)0x0) {
    mod = ly_ctx_get_module_by_ns(ctx,xml->ns->value,(char *)0x0,0);
    if (ctx_local->data_clb != (ly_module_data_clb)0x0) {
      if (mod == (lys_module *)0x0) {
        mod = (*ctx_local->data_clb)
                        (ctx_local,(char *)0x0,xml_local->ns->value,0,ctx_local->data_clb_data);
      }
      else if ((mod->field_0x40 & 0x80) == 0) {
        mod = (*ctx_local->data_clb)(ctx_local,mod->name,mod->ns,1,ctx_local->data_clb_data);
      }
    }
    if (((mod != (lys_module *)0x0) && ((mod->field_0x40 & 0x80) != 0)) &&
       ((mod->field_0x40 & 0x40) == 0)) {
      if ((options & 0x1000000U) == 0) {
        schema = xml_data_search_schemanode(xml_local,mod->data,options);
        if (schema == (lys_node *)0x0) {
          for (j = 0; j < (int)(uint)mod->augment_size; j = j + 1) {
            aug = mod->augment + j;
            target = aug->target;
            if ((target->nodetype & (LYS_CHOICE|LYS_CASE)) != LYS_UNKNOWN) {
              for (; (target != (lys_node *)0x0 && ((target->nodetype & 0x1042) != LYS_UNKNOWN));
                  target = lys_parent(target)) {
              }
              if (target == (lys_node *)0x0) {
                do {
                  schema = lys_getnext(schema,(lys_node *)aug,(lys_module *)0x0,0);
                  if (schema == (lys_node *)0x0) break;
                } while (schema->name != xml_local->name);
              }
            }
            if (schema != (lys_node *)0x0) break;
          }
        }
      }
      else if (yang_data_name != (char *)0x0) {
        sVar7 = strlen(yang_data_name);
        ext_node = lyp_get_yang_data_template(mod,yang_data_name,(int)sVar7);
        if (ext_node != (lys_node *)0x0) {
          puVar8 = (undefined8 *)
                   lys_ext_complex_get_substmt
                             (LY_STMT_CONTAINER,(lys_ext_instance_complex *)ext_node,
                              (lyext_substmt **)0x0);
          schema = (lys_node *)*puVar8;
          schema = xml_data_search_schemanode(xml_local,schema,options);
        }
      }
    }
  }
  else {
    schema = xml_data_search_schemanode(xml,parent->schema->child,options);
    if (ctx_local->data_clb != (ly_module_data_clb)0x0) {
      if ((schema == (lys_node *)0x0) ||
         (plVar9 = lys_node_module(schema), (plVar9->field_0x40 & 0x80) != 0)) {
        if ((schema == (lys_node *)0x0) &&
           (plVar9 = (*ctx_local->data_clb)
                               (ctx_local,(char *)0x0,xml_local->ns->value,0,
                                ctx_local->data_clb_data), plVar9 != (lys_module *)0x0)) {
          schema = xml_data_search_schemanode(xml_local,parent_local->schema->child,options);
        }
      }
      else {
        p_Var2 = ctx_local->data_clb;
        pvVar3 = ctx_local->data_clb_data;
        plVar9 = lys_node_module(schema);
        pcVar13 = plVar9->ns;
        plVar9 = lys_node_module(schema);
        (*p_Var2)(ctx_local,plVar9->name,pcVar13,1,pvVar3);
      }
    }
  }
  mod = lys_node_module(schema);
  if (((mod == (lys_module *)0x0) || ((mod->field_0x40 & 0x80) == 0)) ||
     ((mod->field_0x40 & 0x40) != 0)) {
    if ((options & 0x200U) == 0) {
      iVar6 = 0;
    }
    else {
      if (parent_local == (lyd_node *)0x0) {
        plVar10 = (lyd_node *)&DAT_00214fb3;
        elem_type = LY_VLOG_STR;
      }
      else {
        elem_type = LY_VLOG_LYD;
        plVar10 = parent_local;
      }
      ly_vlog(ctx_local,LYE_INELEM,elem_type,plVar10,xml_local->name);
      iVar6 = -1;
    }
    goto LAB_0016a9af;
  }
  LVar1 = schema->nodetype;
  if (LVar1 != LYS_ANYDATA) {
    if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
      if (LVar1 == LYS_ACTION) {
switchD_00169536_caseD_1:
        for (i = 0; (xml_local->content != (char *)0x0 && (xml_local->content[i] != '\0'));
            i = i + 1) {
          if ((xml_local->content[i] != ' ') &&
             (((xml_local->content[i] != '\t' && (xml_local->content[i] != '\n')) &&
              (xml_local->content[i] != '\r')))) {
            sVar7 = strlen(xml_local->content);
            msg = (char *)malloc(sVar7 + 0x17);
            if (msg == (char *)0x0) {
              ly_log(ctx_local,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","xml_parse_data")
              ;
              iVar6 = -1;
            }
            else {
              sprintf(msg,"node with text data \"%s\"",xml_local->content);
              ly_vlog(ctx_local,LYE_XML_INVAL,LY_VLOG_XML,xml_local,msg);
              free(msg);
              iVar6 = -1;
            }
            goto LAB_0016a9af;
          }
        }
        plVar10 = (lyd_node *)calloc(1,0x48);
        *result = plVar10;
        havechildren = 1;
        goto LAB_0016978e;
      }
      if (LVar1 < (LYS_CONTAINER|LYS_ACTION)) {
        if (LVar1 == LYS_RPC) goto switchD_00169536_caseD_1;
        if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
          if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
            if ((LVar1 != LYS_UNKNOWN) && (true)) {
              switch(LVar1) {
              case LYS_CONTAINER:
              case LYS_LIST:
                goto switchD_00169536_caseD_1;
              case LYS_LEAF:
              case LYS_LEAFLIST:
                plVar10 = (lyd_node *)calloc(1,0x50);
                *result = plVar10;
                havechildren = 0;
                goto LAB_0016978e;
              case LYS_ANYXML:
                goto switchD_00169536_caseD_20;
              }
            }
          }
          else if (LVar1 == LYS_NOTIF) goto switchD_00169536_caseD_1;
        }
      }
    }
    ly_log(ctx_local,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_xml.c"
           ,0xfe);
    iVar6 = -1;
    goto LAB_0016a9af;
  }
switchD_00169536_caseD_20:
  plVar10 = (lyd_node *)calloc(1,0x40);
  *result = plVar10;
  havechildren = 0;
LAB_0016978e:
  if (*result == (lyd_node *)0x0) {
    ly_log(ctx_local,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","xml_parse_data");
    iVar6 = -1;
    goto LAB_0016a9af;
  }
  (*result)->prev = *result;
  (*result)->schema = schema;
  (*result)->parent = parent_local;
  diter = (lyd_node *)0x0;
  if ((schema->nodetype == LYS_LEAF) &&
     (plVar11 = lys_is_key((lys_node_leaf *)schema,&pos), plVar11 != (lys_node_list *)0x0)) {
    if (parent_local == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("parent",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_xml.c"
                    ,0x109,"xml_parse_data");
    }
    i = 0;
    diter = parent_local->child;
    while (((diter != (lyd_node *)0x0 && (i < (int)(uint)pos)) &&
           ((diter->schema->nodetype == LYS_LEAF &&
            (plVar11 = lys_is_key((lys_node_leaf *)diter->schema,(uint8_t *)0x0),
            plVar11 != (lys_node_list *)0x0))))) {
      i = i + 1;
      diter = diter->next;
    }
    if (diter != (lyd_node *)0x0) {
      if ((options & 0x200U) != 0) {
        ly_vlog(ctx_local,LYE_INORDER,LY_VLOG_LYD,*result,schema->name,diter->schema->name);
        ly_vlog(ctx_local,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                "Invalid position of the key \"%s\" in a list \"%s\".",schema->name,
                parent_local->schema->name);
        free(*result);
        *result = (lyd_node *)0x0;
        iVar6 = -1;
        goto LAB_0016a9af;
      }
      ly_log(ctx_local,LY_LLWRN,LY_SUCCESS,"Invalid position of the key \"%s\" in a list \"%s\".",
             schema->name,parent_local->schema->name);
      if (parent_local->child == diter) {
        parent_local->child = *result;
        first_sibling_local = *result;
      }
      if (diter->prev->next != (lyd_node *)0x0) {
        diter->prev->next = *result;
      }
      (*result)->prev = diter->prev;
      diter->prev = *result;
      (*result)->next = diter;
    }
  }
  if (diter == (lyd_node *)0x0) {
    if ((parent_local != (lyd_node *)0x0) && (parent_local->child == (lyd_node *)0x0)) {
      parent_local->child = *result;
    }
    if (prev == (lyd_node *)0x0) {
      (*result)->prev = *result;
      first_sibling_local = *result;
    }
    else {
      (*result)->prev = prev;
      prev->next = *result;
      first_sibling_local->prev = *result;
    }
  }
  iVar6 = ly_new_node_validity((*result)->schema);
  (*result)->validity = (uint8_t)iVar6;
  iVar6 = resolve_applies_when(schema,0,(lys_node *)0x0);
  if (iVar6 != 0) {
    (*result)->field_0x9 = (*result)->field_0x9 & 0xf1 | 8;
  }
  for (attr = xml_local->attr; attr != (lyxml_attr *)0x0; attr = attr->next) {
    if (attr->type == LYXML_ATTR_STD) {
      if (attr->ns == (lyxml_ns *)0x0) {
        if ((((*result)->schema->nodetype == LYS_ANYXML) &&
            (iVar6 = ly_strequal_((*result)->schema->name,"filter"), iVar6 != 0)) &&
           ((iVar6 = ly_strequal_((*result)->schema->module->name,"ietf-netconf"), iVar6 != 0 ||
            (iVar6 = ly_strequal_((*result)->schema->module->name,"notifications"), iVar6 != 0)))) {
          str = "urn:ietf:params:xml:ns:netconf:base:1.0";
          filterflag = 1;
          goto LAB_00169cb6;
        }
      }
      else {
        str = attr->ns->value;
LAB_00169cb6:
        r = lyp_fill_attr(ctx_local,*result,str,(char *)0x0,attr->name,attr->value,xml_local,options
                          ,&dattr);
        if (r == -1) goto LAB_0016a902;
        if (r != 1) {
          if ((filterflag != 0) && (iVar6 = strcmp(attr->name,"select"), plVar5 = dattr, iVar6 == 0)
             ) {
            pcVar13 = transform_xml2json(ctx_local,dattr->value_str,xml_local,0,0);
            (plVar5->value).binary = pcVar13;
            if ((dattr->value).binary == (char *)0x0) {
              dattr->value = (lyd_val)dattr->value_str;
              goto LAB_0016a902;
            }
            lydict_remove(ctx_local,dattr->value_str);
            dattr->value_str = (char *)dattr->value;
          }
          if ((*result)->attr == (lyd_attr *)0x0) {
            (*result)->attr = dattr;
          }
          else {
            for (dattr_iter = (*result)->attr; dattr_iter->next != (lyd_attr *)0x0;
                dattr_iter = dattr_iter->next) {
            }
            dattr_iter->next = dattr;
          }
          goto LAB_00169f0a;
        }
      }
      if ((options & 0x200U) != 0) {
        ly_vlog(ctx_local,LYE_INATTR,LY_VLOG_LYD,*result,attr->name);
        goto LAB_0016a902;
      }
      if (attr->ns == (lyxml_ns *)0x0) {
        pcVar13 = "<none>";
      }
      else {
        pcVar13 = attr->ns->prefix;
      }
      ly_log(ctx_local,LY_LLWRN,LY_SUCCESS,"Unknown \"%s:%s\" metadata with value \"%s\", ignoring."
             ,pcVar13,attr->name,attr->value);
    }
LAB_00169f0a:
  }
  if ((options & 8U) == 0) {
    if (filterflag == 0) goto LAB_0016a393;
    found = 0;
    for (dattr_iter = (*result)->attr; dattr_iter != (lyd_attr *)0x0; dattr_iter = dattr_iter->next)
    {
      iVar6 = strcmp(dattr_iter->name,"type");
      if (iVar6 == 0) {
        if (((found == 1) || (found == 2)) || (found == 4)) {
          ly_vlog(ctx_local,LYE_TOOMANY,LY_VLOG_LYD,*result,&DAT_002150db,xml_local->name);
          goto LAB_0016a902;
        }
        iVar6 = ((dattr_iter->value).enm)->value;
        if (iVar6 == 0) {
          if (found == 3) {
            ly_vlog(ctx_local,LYE_INATTR,LY_VLOG_LYD,*result,dattr_iter->name);
            goto LAB_0016a902;
          }
          if (found != 0) {
                    // WARNING: Subroutine does not return
            __assert_fail("!found",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_xml.c"
                          ,0x18d,"xml_parse_data");
          }
          found = 1;
        }
        else {
          if (iVar6 != 1) {
            ly_log(ctx_local,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_xml.c"
                   ,0x19a);
            goto LAB_0016a902;
          }
          if (found == 3) {
            found = 4;
          }
          else {
            if (found != 0) {
                    // WARNING: Subroutine does not return
              __assert_fail("!found",
                            "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_xml.c"
                            ,0x195,"xml_parse_data");
            }
            found = 2;
          }
        }
      }
      else {
        iVar6 = strcmp(dattr_iter->name,"select");
        if (iVar6 == 0) {
          if (4 < found) goto LAB_0016a235;
          if (2 < found) {
            ly_vlog(ctx_local,LYE_TOOMANY,LY_VLOG_LYD,*result,"select",xml_local->name);
            goto LAB_0016a902;
          }
          if (found != 2) {
            if (found < 3) {
              if (found == 0) {
                found = 3;
                goto LAB_0016a26d;
              }
              if (found == 1) {
                ly_vlog(ctx_local,LYE_INATTR,LY_VLOG_LYD,*result,dattr_iter->name);
                goto LAB_0016a902;
              }
            }
LAB_0016a235:
            ly_log(ctx_local,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_xml.c"
                   ,0x1ad);
            goto LAB_0016a902;
          }
          found = 4;
        }
      }
LAB_0016a26d:
    }
    if (found == 4) goto LAB_0016a393;
    if (found < 5) {
      if (found != 3) {
        if (found < 4) {
          if (found == 1) goto LAB_0016a393;
          if (found == 2) {
            ly_vlog(ctx_local,LYE_MISSATTR,LY_VLOG_LYD,*result,"select",xml_local->name);
            goto LAB_0016a902;
          }
        }
        goto LAB_0016a358;
      }
      ly_vlog(ctx_local,LYE_MISSATTR,LY_VLOG_LYD,*result,&DAT_002150db,xml_local->name);
    }
    else {
LAB_0016a358:
      ly_log(ctx_local,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_xml.c"
             ,0x1c0);
    }
LAB_0016a902:
    lyd_unlink_internal(*result,2);
  }
  else {
    iVar6 = lyp_check_edit_attr(ctx_local,(*result)->attr,*result,&editbits);
    if (iVar6 != 0) goto LAB_0016a902;
LAB_0016a393:
    if ((schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
      if ((schema->nodetype & LYS_ANYDATA) == LYS_UNKNOWN) {
        if ((schema->nodetype & 0x4100) == LYS_UNKNOWN) {
          if (schema->nodetype == LYS_NOTIF) {
            if (((options & 0x40U) == 0) || (*act_notif != (lyd_node *)0x0)) {
              ly_vlog(ctx_local,LYE_INELEM,LY_VLOG_LYD,*result,schema->name);
              ly_vlog(ctx_local,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                      "Unexpected notification node \"%s\".",schema->name);
              goto LAB_0016a902;
            }
            *act_notif = *result;
          }
        }
        else {
          if (((options & 0x10U) == 0) || (*act_notif != (lyd_node *)0x0)) {
            ly_vlog(ctx_local,LYE_INELEM,LY_VLOG_LYD,*result,schema->name);
            if (schema->nodetype == LYS_RPC) {
              pcVar13 = "rpc";
            }
            else {
              pcVar13 = "action";
            }
            ly_vlog(ctx_local,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Unexpected %s node \"%s\".",pcVar13
                    ,schema->name);
            goto LAB_0016a902;
          }
          *act_notif = *result;
        }
      }
      else if (xml_local->child == (lyxml_elem *)0x0) {
        *(undefined4 *)&(*result)->field_0x34 = 0;
        plVar10 = *result;
        phVar12 = (hash_table *)lydict_insert(ctx_local,xml_local->content,0);
        plVar10->ht = phVar12;
      }
      else {
        child = xml_local->child;
        xml_local->child = (lyxml_elem *)0x0;
        for (next = child; next != (lyxml_elem *)0x0; next = next->next) {
          next->parent = (lyxml_elem *)0x0;
          lyxml_correct_elem_ns(ctx_local,next,1,1);
        }
        *(undefined4 *)&(*result)->field_0x34 = 8;
        (*result)->ht = (hash_table *)child;
      }
    }
    else {
      iVar6 = xml_get_value(*result,xml_local,editbits,options & 0x2000);
      if (iVar6 != 0) goto LAB_0016a902;
    }
    if (((*result)->schema->nodetype != LYS_LIST) || ((*result)->schema->padding[2] == '\0')) {
      lyd_hash(*result);
      lyd_insert_hash(*result);
    }
    iVar6 = lyv_data_context(*result,options,unres);
    if (iVar6 == 0) {
      if ((havechildren != 0) && (xml_local->child != (lyxml_elem *)0x0)) {
        dlast = (lyd_node *)0x0;
        diter = (lyd_node *)0x0;
        child = xml_local->child;
        while (child != (lyxml_elem *)0x0) {
          next = child->next;
          r = xml_parse_data(ctx_local,child,*result,(*result)->child,dlast,options,unres,&diter,
                             act_notif,yang_data_name);
          if (r != 0) goto LAB_0016a922;
          if ((options & 0x400U) != 0) {
            lyxml_free(ctx_local,child);
          }
          if ((diter != (lyd_node *)0x0) && (diter->next == (lyd_node *)0x0)) {
            dlast = diter;
          }
          child = next;
        }
      }
      if ((((schema->nodetype == LYS_CONTAINER) && ((*result)->child == (lyd_node *)0x0)) &&
          ((*result)->attr == (lyd_attr *)0x0)) &&
         (lVar4._0_2_ = schema[1].flags, lVar4._2_1_ = schema[1].ext_size,
         lVar4._3_1_ = schema[1].iffeature_size, lVar4._4_1_ = schema[1].padding[0],
         lVar4._5_1_ = schema[1].padding[1], lVar4._6_1_ = schema[1].padding[2],
         lVar4._7_1_ = schema[1].padding[3], lVar4 == 0)) {
        (*result)->field_0x9 = (*result)->field_0x9 | 1;
      }
      iVar6 = lyv_data_content(*result,options,unres);
      if (iVar6 == 0) {
        if (prev == (lyd_node *)0x0) {
          first_sibling_00 = (lyd_node **)0x0;
        }
        else {
          first_sibling_00 = &first_sibling_local;
        }
        iVar6 = lyv_multicases(*result,(lys_node *)0x0,first_sibling_00,0,(lyd_node *)0x0);
        if (iVar6 == 0) {
          iVar6 = ret;
          if (((*result)->schema->nodetype & (LYS_LEAFLIST|LYS_LIST)) != LYS_UNKNOWN) {
            (*result)->validity = (*result)->validity | 1;
          }
          goto LAB_0016a9af;
        }
      }
    }
  }
LAB_0016a922:
  i = unres->count;
  while (i = i - 1, -1 < i) {
    if (unres->node[i] == *result) {
      unres_data_del(unres,i);
    }
  }
  lyd_free(*result);
  *result = (lyd_node *)0x0;
  iVar6 = -1;
LAB_0016a9af:
  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lyd_node * lyd_parse_xml(ly_ctx *ctx,lyxml_elem **root,int options,...)

{
  long lVar1;
  char in_AL;
  int iVar2;
  long *plVar3;
  undefined8 *puVar4;
  char *pcVar5;
  lyd_node *plVar6;
  undefined8 in_RCX;
  ulong uVar7;
  LY_VLOG_ELEM elem_type;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  int options_local;
  lyxml_elem **root_local;
  ly_ctx *ctx_local;
  int r;
  lyd_node *result;
  lyd_node *iter;
  lyd_node *act_notif;
  lyd_node *data_tree;
  lyd_node *last;
  lyd_node *rpc_act;
  lyd_node *reply_parent;
  lyd_node *reply_top;
  lyxml_elem *xmlstart;
  lyxml_elem *xmlelem;
  lyxml_elem *xmlaux;
  lyxml_elem *xmlfree;
  char *yang_data_name;
  unres_data *unres;
  va_list ap;
  undefined local_b8 [24];
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  local_a0 = in_RCX;
  local_98 = in_R8;
  local_90 = in_R9;
  ly_log_dbg(0x20,"%s","lyd_parse_xml");
  unres = (unres_data *)0x0;
  rpc_act = (lyd_node *)0x0;
  data_tree = (lyd_node *)0x0;
  result = (lyd_node *)0x0;
  reply_parent = (lyd_node *)0x0;
  reply_top = (lyd_node *)0x0;
  act_notif = (lyd_node *)0x0;
  xmlfree = (lyxml_elem *)0x0;
  yang_data_name = (char *)0x0;
  if ((ctx == (ly_ctx *)0x0) || (root == (lyxml_elem **)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_parse_xml");
    plVar6 = (lyd_node *)0x0;
    goto LAB_0016b6ce;
  }
  iVar2 = lyp_data_check_options(ctx,options,"lyd_parse_xml");
  if (iVar2 != 0) {
    plVar6 = (lyd_node *)0x0;
    goto LAB_0016b6ce;
  }
  if ((*root == (lyxml_elem *)0x0) && ((options & 0x20U) == 0)) {
    if ((options & 0x50U) != 0) {
      ly_log(ctx,LY_LLERR,LY_EINVAL,"%s: *root identifies RPC/Notification so it cannot be NULL.",
             "lyd_parse_xml");
      plVar6 = (lyd_node *)0x0;
      goto LAB_0016b6ce;
    }
    if ((options & 0x20U) == 0) {
      lyd_validate(&result,options,ctx);
      plVar6 = result;
      goto LAB_0016b6ce;
    }
  }
  unres = (unres_data *)calloc(1,0x28);
  if (unres == (unres_data *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_parse_xml");
    plVar6 = (lyd_node *)0x0;
    goto LAB_0016b6ce;
  }
  ap[0].gp_offset = 0x18;
  ap[0].fp_offset = 0x30;
  ap[0].overflow_arg_area = &stack0x00000008;
  ap[0].reg_save_area = local_b8;
  if ((options & 0x20U) != 0) {
    if (false) {
      puVar4 = (undefined8 *)ap[0].overflow_arg_area;
      ap[0].overflow_arg_area = &stack0x00000010;
    }
    else {
      ap[0].gp_offset = 0x20;
      puVar4 = &local_a0;
    }
    rpc_act = (lyd_node *)*puVar4;
    if (((rpc_act != (lyd_node *)0x0) && (rpc_act->parent == (lyd_node *)0x0)) &&
       ((rpc_act->schema->nodetype & (LYS_CONTAINER|LYS_LIST|LYS_RPC)) != LYS_UNKNOWN)) {
      if (rpc_act->schema->nodetype == LYS_RPC) {
        reply_parent = _lyd_new((lyd_node *)0x0,rpc_act->schema,0);
        reply_top = reply_parent;
      }
      else {
        reply_top = lyd_dup(rpc_act,1);
        iter = reply_top;
        while ((reply_parent = iter, iter != (lyd_node *)0x0 &&
               (iter->schema->nodetype != LYS_ACTION))) {
          if ((iter->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
            iter = iter->child;
          }
          else {
            iter = (lyd_node *)0x0;
          }
          if (iter == (lyd_node *)0x0) {
            if (reply_parent == reply_top) break;
            iter = reply_parent->next;
          }
          while ((iter == (lyd_node *)0x0 &&
                 (reply_parent = reply_parent->parent, reply_parent->parent != reply_top->parent)))
          {
            iter = reply_parent->next;
          }
        }
        if (reply_parent == (lyd_node *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EINVAL,
                 "%s: invalid variable parameter (const struct lyd_node *rpc_act).","lyd_parse_xml")
          ;
          lyd_free_withsiblings(reply_top);
          goto LAB_0016b663;
        }
        lyd_free_withsiblings(reply_parent->child);
      }
      goto LAB_0016aedf;
    }
    ly_log(ctx,LY_LLERR,LY_EINVAL,"%s: invalid variable parameter (const struct lyd_node *rpc_act)."
           ,"lyd_parse_xml");
    goto LAB_0016b663;
  }
LAB_0016aedf:
  if ((options & 0x70U) == 0) {
LAB_0016b05f:
    if ((options & 0x1000000U) != 0) {
      if (ap[0].gp_offset < 0x30) {
        uVar7 = (ulong)ap[0].gp_offset;
        ap[0].gp_offset = ap[0].gp_offset + 8;
        puVar4 = (undefined8 *)((long)ap[0].reg_save_area + uVar7);
      }
      else {
        puVar4 = (undefined8 *)ap[0].overflow_arg_area;
        ap[0].overflow_arg_area = (void *)((long)ap[0].overflow_arg_area + 8);
      }
      yang_data_name = (char *)*puVar4;
    }
    if ((*root == (lyxml_elem *)0x0) || ((options & 0x1000U) != 0)) {
      xmlstart = *root;
    }
    else if ((*root)->parent == (lyxml_elem *)0x0) {
      xmlstart = *root;
      while (xmlstart->prev->next != (lyxml_elem *)0x0) {
        xmlstart = xmlstart->prev;
      }
    }
    else {
      xmlstart = (*root)->parent->child;
    }
    if (((((options & 0x10U) != 0) && (iVar2 = strcmp(xmlstart->name,"action"), iVar2 == 0)) &&
        (iVar2 = strcmp(xmlstart->ns->value,"urn:ietf:params:xml:ns:yang:1"), iVar2 == 0)) &&
       (xmlstart = xmlstart->child, (options & 0x400U) != 0)) {
      xmlfree = xmlstart->parent;
    }
    last = (lyd_node *)0x0;
    iter = (lyd_node *)0x0;
    xmlelem = xmlstart;
    options_local = options;
    while (xmlelem != (lyxml_elem *)0x0) {
      xmlaux = xmlelem->next;
      iVar2 = xml_parse_data(ctx,xmlelem,reply_parent,result,last,options_local,unres,&iter,
                             &act_notif,yang_data_name);
      if (iVar2 != 0) {
        if (reply_top != (lyd_node *)0x0) {
          result = reply_top;
        }
        goto LAB_0016b663;
      }
      if ((options_local & 0x400U) != 0) {
        lyxml_free(ctx,xmlelem);
        *root = xmlaux;
      }
      if (((iter != (lyd_node *)0x0) && (last = iter, (options_local & 0x20000U) != 0)) &&
         (iter->schema->module == (ctx->models).list[(ulong)ctx->internal_module_count - 1])) {
        options_local = options_local & 0xfffdffff;
      }
      if (result == (lyd_node *)0x0) {
        result = iter;
      }
      if ((options_local & 0x1000U) != 0) break;
      xmlelem = xmlaux;
    }
    if (reply_top != (lyd_node *)0x0) {
      result = reply_top;
    }
    if (((options_local & 0x20U) == 0) || (rpc_act->schema->nodetype == LYS_RPC)) {
      if (((options_local & 0x50U) != 0) && (act_notif == (lyd_node *)0x0)) {
        if ((options_local & 0x10U) == 0) {
          pcVar5 = "notification";
        }
        else {
          pcVar5 = "action";
        }
        if (result == (lyd_node *)0x0) {
          elem_type = LY_VLOG_NONE;
        }
        else {
          elem_type = LY_VLOG_LYD;
        }
        ly_vlog(ctx,LYE_INELEM,elem_type,result,pcVar5);
        goto LAB_0016b663;
      }
    }
    else {
      act_notif = reply_parent;
    }
    if ((options_local & 0x20000U) != 0) {
      if (result == (lyd_node *)0x0) {
        result = ly_ctx_info(ctx);
      }
      else {
        plVar6 = ly_ctx_info(ctx);
        iVar2 = lyd_merge(result,plVar6,0x500);
        if (iVar2 != 0) {
          ly_log(ctx,LY_LLERR,LY_EINT,"Adding ietf-yang-library data failed.");
          goto LAB_0016b663;
        }
      }
    }
    for (iter = result; iter != (lyd_node *)0x0; iter = iter->next) {
      if ((((iter->schema->nodetype & (LYS_LEAFLIST|LYS_LIST)) != LYS_UNKNOWN) &&
          ((iter->validity & 1) != 0)) && (iVar2 = lyv_data_dup(iter,result), iVar2 != 0))
      goto LAB_0016b663;
    }
    iVar2 = lyd_defaults_add_unres
                      (&result,options_local,ctx,(lys_module **)0x0,0,data_tree,act_notif,unres,1);
    if (iVar2 == 0) {
      if ((options_local & 0x2080U) == 0) {
        plVar6 = result;
        if (act_notif != (lyd_node *)0x0) {
          plVar6 = act_notif;
        }
        iVar2 = lyd_check_mandatory_tree(plVar6,ctx,(lys_module **)0x0,0,options_local);
        if (iVar2 != 0) goto LAB_0016b663;
      }
      if (xmlfree != (lyxml_elem *)0x0) {
        lyxml_free(ctx,xmlfree);
      }
      free(unres->node);
      free(unres->type);
      free(unres);
      plVar6 = result;
      goto LAB_0016b6ce;
    }
  }
  else {
    if (ap[0].gp_offset < 0x30) {
      uVar7 = (ulong)ap[0].gp_offset;
      ap[0].gp_offset = ap[0].gp_offset + 8;
      plVar3 = (long *)((long)ap[0].reg_save_area + uVar7);
    }
    else {
      plVar3 = (long *)ap[0].overflow_arg_area;
      ap[0].overflow_arg_area = (void *)((long)ap[0].overflow_arg_area + 8);
    }
    data_tree = (lyd_node *)*plVar3;
    if (data_tree == (lyd_node *)0x0) goto LAB_0016b05f;
    plVar6 = data_tree;
    if ((options & 0x8000U) == 0) {
      while (iter = plVar6, iter != (lyd_node *)0x0) {
        if (iter->parent != (lyd_node *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EINVAL,
                 "%s: invalid variable parameter (const struct lyd_node *data_tree).",
                 "lyd_parse_xml");
          goto LAB_0016b663;
        }
        plVar6 = iter->next;
      }
      while (data_tree->prev->next != (lyd_node *)0x0) {
        data_tree = data_tree->prev;
      }
      if ((options & 0x1000U) == 0) goto LAB_0016b05f;
      ly_log(ctx,LY_LLERR,LY_EINVAL,
             "%s: invalid parameter (variable arg const struct lyd_node *data_tree with LYD_OPT_NOSIBLINGS)."
             ,"lyd_parse_xml");
    }
    else {
      ly_log(ctx,LY_LLERR,LY_EINVAL,
             "%s: invalid parameter (variable arg const struct lyd_node *data_tree and LYD_OPT_NOEXTDEPS set)."
             ,"lyd_parse_xml");
    }
  }
LAB_0016b663:
  lyd_free_withsiblings(result);
  if (xmlfree != (lyxml_elem *)0x0) {
    lyxml_free(ctx,xmlfree);
  }
  free(unres->node);
  free(unres->type);
  free(unres);
  plVar6 = (lyd_node *)0x0;
LAB_0016b6ce:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar6;
}



int lyjson_isspace(int c)

{
  int iVar1;
  int c_local;
  
  if (((uint)c < 0x21) && ((1L << ((byte)c & 0x3f) & 0x100002600U) != 0)) {
    iVar1 = 1;
  }
  else {
    iVar1 = 0;
  }
  return iVar1;
}



uint skip_ws(char *data)

{
  int iVar1;
  char *data_local;
  uint len;
  
  len = 0;
  while( true ) {
    if (data[len] == '\0') {
      return len;
    }
    iVar1 = lyjson_isspace((int)data[len]);
    if (iVar1 == 0) break;
    len = len + 1;
  }
  return len;
}



char * lyjson_parse_text(ly_ctx *ctx,char *data,uint *len)

{
  long lVar1;
  int iVar2;
  ushort **ppuVar3;
  long in_FS_OFFSET;
  uint *len_local;
  char *data_local;
  ly_ctx *ctx_local;
  int o;
  int size;
  uint r;
  uint i;
  int32_t value;
  char *result;
  char *aux;
  char buf [1024];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  result = (char *)0x0;
  size = 0;
  o = 0;
  *len = 0;
  while ((data[*len] != '\0' && (data[*len] != '\"'))) {
    if (0x3fd < o) {
      if (result == (char *)0x0) {
        size = o;
        result = (char *)malloc((long)(o + 1));
        if (result == (char *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyjson_parse_text");
          result = (char *)0x0;
          goto LAB_0016bf34;
        }
      }
      else {
        size = size + o;
        result = (char *)ly_realloc(result,(long)(size + 1));
        if (result == (char *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyjson_parse_text");
          result = (char *)0x0;
          goto LAB_0016bf34;
        }
      }
      memcpy(result + (size - o),buf,(long)o);
      o = 0;
    }
    if (data[*len] == '\\') {
      *len = *len + 1;
      i = 1;
      iVar2 = (int)data[*len];
      if (0x75 < iVar2) goto switchD_0016b9c6_caseD_5d;
      if (iVar2 < 0x5c) {
        if (iVar2 == 0x22) {
          value = 0x22;
        }
        else {
          if (iVar2 != 0x2f) goto switchD_0016b9c6_caseD_5d;
          value = 0x2f;
        }
        goto LAB_0016bbba;
      }
      if (false) {
switchD_0016b9c6_caseD_5d:
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"character escape sequence");
      }
      else {
        switch(iVar2) {
        case 0x5c:
          value = 0x5c;
          break;
        default:
          goto switchD_0016b9c6_caseD_5d;
        case 0x62:
          value = 8;
          break;
        case 0x66:
          value = 0xc;
          break;
        case 0x6e:
          value = 10;
          break;
        case 0x72:
          value = 0xd;
          break;
        case 0x74:
          value = 9;
          break;
        case 0x75:
          *len = *len + 1;
          value = 0;
          for (i = 0; i < 4; i = i + 1) {
            ppuVar3 = __ctype_b_loc();
            if (((*ppuVar3)[data[i + *len]] & 0x800) == 0) {
              if (data[i + *len] < 'G') {
                r = (int)data[i + *len] - 0x37;
              }
              else {
                r = (int)data[i + *len] - 0x57;
              }
            }
            else {
              r = (int)data[i + *len] - 0x30;
            }
            value = r + value * 0x10;
          }
        }
LAB_0016bbba:
        r = pututf8(ctx,buf + o,value);
        if (r != 0) {
          *len = *len + i;
          goto LAB_0016bd21;
        }
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"character UTF8 character");
      }
LAB_0016bf20:
      free(result);
      result = (char *)0x0;
      goto LAB_0016bf34;
    }
    if ((byte)data[*len] < 0x20) {
      ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"control character (unescaped)");
      goto LAB_0016bf20;
    }
    r = copyutf8(ctx,buf + o,data + *len);
    if (r == 0) goto LAB_0016bf20;
    *len = *len + r;
LAB_0016bd21:
    o = r + o;
  }
  if (o != 0) {
    if (result == (char *)0x0) {
      size = o;
      result = (char *)malloc((long)(o + 1));
      if (result == (char *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyjson_parse_text");
        result = (char *)0x0;
        goto LAB_0016bf34;
      }
    }
    else {
      size = size + o;
      result = (char *)ly_realloc(result,(long)(size + 1));
      if (result == (char *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyjson_parse_text");
        result = (char *)0x0;
        goto LAB_0016bf34;
      }
    }
    memcpy(result + (size - o),buf,(long)o);
  }
  if (result == (char *)0x0) {
    result = strdup("");
    if (result == (char *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyjson_parse_text");
      result = (char *)0x0;
    }
  }
  else {
    result[size] = '\0';
  }
LAB_0016bf34:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return result;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



uint lyjson_parse_number(ly_ctx *ctx,char *data)

{
  uint uVar1;
  int iVar2;
  ushort **ppuVar3;
  char *data_local;
  ly_ctx *ctx_local;
  uint len;
  
  len = (uint)(*data == '-');
  if (data[len] == '0') {
    len = len + 1;
  }
  else {
    ppuVar3 = __ctype_b_loc();
    if (((*ppuVar3)[data[len]] & 0x800) == 0) {
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "Invalid character in JSON Number value (\'%c\').",(ulong)(uint)(int)data[len]);
      return 0;
    }
    do {
      len = len + 1;
      ppuVar3 = __ctype_b_loc();
    } while (((*ppuVar3)[data[len]] & 0x800) != 0);
  }
  if (data[len] == '.') {
    len = len + 1;
    ppuVar3 = __ctype_b_loc();
    if (((*ppuVar3)[data[len]] & 0x800) == 0) {
      if (data[len] == '\0') {
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                "Invalid character in JSON Number value (EOF).");
      }
      else {
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                "Invalid character in JSON Number value (\'%c\').",(ulong)(uint)(int)data[len]);
      }
      return 0;
    }
    while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[data[len]] & 0x800) != 0) {
      len = len + 1;
    }
  }
  if ((data[len] == 'e') || (data[len] == 'E')) {
    uVar1 = len + 1;
    if ((data[uVar1] == '+') || (data[uVar1] == '-')) {
      uVar1 = len + 2;
    }
    while (len = uVar1, ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[data[len]] & 0x800) != 0) {
      uVar1 = len + 1;
    }
  }
  if ((((data[len] != '\0') && (data[len] != ',')) && (data[len] != ']')) &&
     ((data[len] != '}' && (iVar2 = lyjson_isspace((int)data[len]), iVar2 == 0)))) {
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid character in JSON Number value (\'%c\')."
            ,(ulong)(uint)(int)data[len]);
    len = 0;
  }
  return len;
}



char * lyjson_convert_enumber(ly_ctx *ctx,char *number,uint num_len,char *e_ptr)

{
  char cVar1;
  int iVar2;
  uint len;
  int iVar3;
  int *piVar4;
  char *pcVar5;
  size_t sVar6;
  ushort **ppuVar7;
  int iVar8;
  ulong uVar9;
  long in_FS_OFFSET;
  bool bVar10;
  byte bVar11;
  char *e_ptr_local;
  uint num_len_local;
  char *number_local;
  ly_ctx *ctx_local;
  int dot_pos;
  int chars_to_dot;
  int minus;
  uint num_len_no_e;
  char *ptr;
  char *num;
  char *number_ptr;
  long e_val;
  long local_20;
  
  bVar11 = 0;
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  bVar10 = *number == '-';
  num_len_local = num_len;
  number_local = number;
  if (bVar10) {
    number_local = number + 1;
    num_len_local = num_len - 1;
  }
  iVar2 = (int)number_local;
  len = (int)e_ptr - iVar2;
  piVar4 = __errno_location();
  *piVar4 = 0;
  pcVar5 = e_ptr + 1;
  e_val = strtol(pcVar5,&ptr,10);
  piVar4 = __errno_location();
  if (*piVar4 == 0) {
    if (number_local + num_len_local == ptr) {
      ptr = strnchr(number_local,0x2e,len);
      dot_pos = len;
      if (ptr != (char *)0x0) {
        dot_pos = (int)ptr - iVar2;
      }
      iVar3 = dot_pos + (int)e_val;
      if (iVar3 < 1) {
        num = (char *)malloc((ulong)((len - (ptr != (char *)0x0)) + ((uint)bVar10 - iVar3) + 3));
      }
      else if (iVar3 < (int)len) {
        num = (char *)malloc((ulong)((uint)(ptr == (char *)0x0) + bVar10 + len + 1));
      }
      else {
        if (ptr == (char *)0x0) {
          iVar8 = 1;
        }
        else {
          iVar8 = 2;
        }
        num = (char *)malloc((long)(int)((iVar3 - iVar8) + (uint)bVar10 + 1));
      }
      if (num == (char *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyjson_convert_enumber");
        pcVar5 = (char *)0x0;
      }
      else {
        if (bVar10) {
          num[0] = '-';
          num[1] = '\0';
        }
        else {
          *num = '\0';
        }
        if (iVar3 < 1) {
          uVar9 = 0xffffffffffffffff;
          pcVar5 = num;
          do {
            if (uVar9 == 0) break;
            uVar9 = uVar9 - 1;
            cVar1 = *pcVar5;
            pcVar5 = pcVar5 + (ulong)bVar11 * -2 + 1;
          } while (cVar1 != '\0');
          pcVar5 = num + (~uVar9 - 1);
          pcVar5[0] = '0';
          pcVar5[1] = '.';
          pcVar5[2] = '\0';
        }
        if (iVar3 < 0) {
          sVar6 = strlen(num);
          sprintf(num + sVar6,"%0*d",(ulong)(uint)-iVar3,0);
        }
        sVar6 = strlen(num);
        ptr = num + sVar6;
        number_ptr = number_local;
        chars_to_dot = iVar3;
        while ((uint)((int)number_ptr - iVar2) < len) {
          if (chars_to_dot == 0) {
            *ptr = '.';
            ptr = ptr + 1;
            chars_to_dot = -1;
          }
          else {
            ppuVar7 = __ctype_b_loc();
            if (((*ppuVar7)[*number_ptr] & 0x800) == 0) {
              if (*number_ptr != '.') {
                ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                       "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_json.c"
                       ,0x14f);
                free(num);
                pcVar5 = (char *)0x0;
                goto LAB_0016c6a0;
              }
              number_ptr = number_ptr + 1;
            }
            else {
              *ptr = *number_ptr;
              ptr = ptr + 1;
              number_ptr = number_ptr + 1;
              if (0 < chars_to_dot) {
                chars_to_dot = chars_to_dot + -1;
              }
            }
          }
        }
        *ptr = '\0';
        pcVar5 = num;
        if ((int)len < iVar3) {
          sVar6 = strlen(num);
          sprintf(num + sVar6,"%0*d",(ulong)(iVar3 - len),0);
          pcVar5 = num;
        }
      }
    }
    else {
      ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_json.c"
             ,0x11a);
      pcVar5 = (char *)0x0;
    }
  }
  else {
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
            "Exponent out-of-bounds in a JSON Number value (%.*s).",
            (ulong)num_len_local - ((long)pcVar5 - (long)number_local),pcVar5);
    pcVar5 = (char *)0x0;
  }
LAB_0016c6a0:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pcVar5;
}



uint lyjson_parse_boolean(ly_ctx *ctx,char *data)

{
  int iVar1;
  char *data_local;
  ly_ctx *ctx_local;
  uint len;
  
  len = 0;
  iVar1 = strncmp(data,"false",5);
  if (iVar1 == 0) {
    len = 5;
  }
  else {
    iVar1 = strncmp(data,"true",4);
    if (iVar1 == 0) {
      len = 4;
    }
  }
  if ((((data[len] != '\0') && (data[len] != ',')) && (data[len] != ']')) &&
     ((data[len] != '}' && (iVar1 = lyjson_isspace((int)data[len]), iVar1 == 0)))) {
    ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"JSON literal value (expected true or false)"
           );
    len = 0;
  }
  return len;
}



uint json_get_anydata(lyd_node_anydata *any,char *data)

{
  uint uVar1;
  char *pcVar2;
  long in_FS_OFFSET;
  char *data_local;
  lyd_node_anydata *any_local;
  uint c;
  uint len;
  ly_ctx *ctx;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = any->schema->module->ctx;
  len = 0;
  c = 0;
  if (*data == '\"') {
    len = 1;
    str = lyjson_parse_text(ctx,data + 1,&c);
    if (str == (char *)0x0) {
      uVar1 = 0;
    }
    else if (data[len + c] == '\"') {
      pcVar2 = lydict_insert_zc(ctx,str);
      (any->value).str = pcVar2;
      any->value_type = LYD_ANYDATA_CONSTSTRING;
      uVar1 = len + c + 1;
    }
    else {
      free(str);
      ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_LYD,any,
              "JSON data (missing quotation-mark at the end of string)");
      uVar1 = 0;
    }
  }
  else if (*data == '{') {
    len = 0;
    c = 0;
    do {
      if (data[len] == '{') {
        c = c + 1;
      }
      else if (data[len] == '}') {
        c = c - 1;
      }
      len = len + 1;
    } while ((data[len] != '\0') && (c != 0));
    if (c == 0) {
      any->value_type = LYD_ANYDATA_JSON;
      pcVar2 = lydict_insert(ctx,data,(ulong)len);
      (any->value).str = pcVar2;
      uVar1 = len;
    }
    else {
      ly_vlog(ctx,LYE_EOF,LY_VLOG_LYD,any);
      uVar1 = 0;
    }
  }
  else {
    ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_LYD,any,"anydata/anyxml content (not an object nor string)");
    uVar1 = 0;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



uint json_get_value(lyd_node_leaf_list *leaf,lyd_node **first_sibling,char *data,int options,
                   unres_data *unres)

{
  uint uVar1;
  int iVar2;
  char *pcVar3;
  ushort **ppuVar4;
  lys_type *plVar5;
  long in_FS_OFFSET;
  unres_data *unres_local;
  int options_local;
  char *data_local;
  lyd_node **first_sibling_local;
  lyd_node_leaf_list *leaf_local;
  uint r;
  uint len;
  char *str;
  ly_ctx *ctx;
  lys_type *stype;
  lyd_node_leaf_list *new;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  len = 0;
  if ((leaf == (lyd_node_leaf_list *)0x0) || (data == (char *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("leaf && data",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_json.c"
                  ,0x1b0,"json_get_value");
  }
  ctx = leaf->schema->module->ctx;
  stype = (lys_type *)&leaf->schema[1].ref;
  leaf_local = leaf;
  if (leaf->schema->nodetype != LYS_LEAFLIST) goto LAB_0016cad2;
  len = 1;
  leaf_local = leaf;
  if (*data == '[') {
    do {
      uVar1 = skip_ws(data + len);
      len = len + uVar1;
LAB_0016cad2:
      leaf_local->value_type = stype->base;
      if (data[len] == '\"') {
        len = len + 1;
        str = lyjson_parse_text(ctx,data + len,&r);
        if (str == (char *)0x0) {
          ly_vlog(ctx,LYE_PATH,LY_VLOG_LYD,leaf_local);
          uVar1 = 0;
          goto LAB_0016d16e;
        }
        pcVar3 = lydict_insert_zc(ctx,str);
        leaf_local->value_str = pcVar3;
        if (data[len + r] != '\"') {
          ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_LYD,leaf_local,
                  "JSON data (missing quotation-mark at the end of string)");
          uVar1 = 0;
          goto LAB_0016d16e;
        }
        len = len + r + 1;
      }
      else if ((data[len] == '-') ||
              (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[data[len]] & 0x800) != 0)) {
        r = lyjson_parse_number(ctx,data + len);
        if (r == 0) {
          ly_vlog(ctx,LYE_PATH,LY_VLOG_LYD,leaf_local);
          uVar1 = 0;
          goto LAB_0016d16e;
        }
        str = strnchr(data + len,0x65,r);
        if ((str == (char *)0x0) && (str = strnchr(data + len,0x45,r), str == (char *)0x0)) {
          pcVar3 = lydict_insert(ctx,data + len,(ulong)r);
          leaf_local->value_str = pcVar3;
        }
        else {
          str = lyjson_convert_enumber(ctx,data + len,r,str);
          if (str == (char *)0x0) {
            uVar1 = 0;
            goto LAB_0016d16e;
          }
          pcVar3 = lydict_insert_zc(ctx,str);
          leaf_local->value_str = pcVar3;
        }
        len = len + r;
      }
      else {
        if ((data[len] != 'f') && (data[len] != 't')) {
          uVar1 = len;
          if (data[len] == '[') {
            do {
              r = uVar1 + 1;
              ppuVar4 = __ctype_b_loc();
              uVar1 = r;
            } while (((*ppuVar4)[data[r]] & 0x2000) != 0);
            iVar2 = strncmp(data + r,"null",4);
            if (iVar2 == 0) {
              r = r + 4;
              while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[data[r]] & 0x2000) != 0) {
                r = r + 1;
              }
              if (data[r] == ']') {
                pcVar3 = lydict_insert(ctx,"",0);
                leaf_local->value_str = pcVar3;
                len = r + 1;
                goto LAB_0016cf12;
              }
            }
          }
          ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_LYD,leaf_local,"JSON data (unexpected value)");
          uVar1 = 0;
          goto LAB_0016d16e;
        }
        r = lyjson_parse_boolean(ctx,data + len);
        if (r == 0) {
          ly_vlog(ctx,LYE_PATH,LY_VLOG_LYD,leaf_local);
          uVar1 = 0;
          goto LAB_0016d16e;
        }
        pcVar3 = lydict_insert(ctx,data + len,(ulong)r);
        leaf_local->value_str = pcVar3;
        len = len + r;
      }
LAB_0016cf12:
      plVar5 = lyp_parse_value((lys_type *)&leaf_local->schema[1].ref,&leaf_local->value_str,
                               (lyxml_elem *)0x0,leaf_local,(lyd_attr *)0x0,(lys_module *)0x0,1,0,
                               options & 0x2000);
      if (plVar5 == (lys_type *)0x0) {
        uVar1 = 0;
        goto LAB_0016d16e;
      }
      lyd_hash((lyd_node *)leaf_local);
      lyd_insert_hash((lyd_node *)leaf_local);
      if (leaf_local->schema->nodetype != LYS_LEAFLIST) {
LAB_0016d156:
        uVar1 = skip_ws(data + len);
        uVar1 = len + uVar1;
        len = uVar1;
        goto LAB_0016d16e;
      }
      uVar1 = skip_ws(data + len);
      len = len + uVar1;
      if (data[len] != ',') {
        if (data[len] == ']') {
          len = len + 1;
          uVar1 = skip_ws(data + len);
          len = len + uVar1;
          goto LAB_0016d156;
        }
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_LYD,leaf_local,
                "JSON data (expecting value-separator or end-array)");
        uVar1 = 0;
        goto LAB_0016d16e;
      }
      iVar2 = lyv_data_context((lyd_node *)leaf_local,options | 0x2000,unres);
      if (((iVar2 != 0) ||
          (iVar2 = lyv_data_content((lyd_node *)leaf_local,options,unres), iVar2 != 0)) ||
         (iVar2 = lyv_multicases((lyd_node *)leaf_local,(lys_node *)0x0,first_sibling,0,
                                 (lyd_node *)0x0), iVar2 != 0)) {
        uVar1 = 0;
        goto LAB_0016d16e;
      }
      new = (lyd_node_leaf_list *)calloc(1,0x50);
      if (new == (lyd_node_leaf_list *)0x0) goto code_r0x0016d03f;
      new->parent = leaf_local->parent;
      new->prev = (lyd_node *)leaf_local;
      leaf_local->next = (lyd_node *)new;
      new->validity = leaf_local->validity;
      new->field_0x9 = new->field_0x9 & 0xf1 | ((byte)leaf_local->field_0x9 >> 1 & 7) * '\x02';
      (*first_sibling)->prev = (lyd_node *)new;
      new->schema = leaf_local->schema;
      len = len + 1;
      leaf_local = new;
    } while( true );
  }
  ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_LYD,leaf,"JSON data (expected begin-array)");
  uVar1 = 0;
LAB_0016d16e:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
code_r0x0016d03f:
  ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","json_get_value");
  uVar1 = 0;
  goto LAB_0016d16e;
}



uint json_parse_attr(lys_module *parent_module,lyd_attr **attr,char *data,int options)

{
  int iVar1;
  uint uVar2;
  char *pcVar3;
  long in_FS_OFFSET;
  int options_local;
  char *data_local;
  lyd_attr **attr_local;
  lys_module *parent_module_local;
  uint r;
  uint len;
  int ret;
  lyd_attr *attr_new;
  char *str;
  char *name;
  char *prefix;
  lys_module *module;
  lyd_attr *attr_last;
  ly_ctx *ctx;
  char *value;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = parent_module->ctx;
  len = 0;
  str = (char *)0x0;
  prefix = (char *)0x0;
  attr_last = (lyd_attr *)0x0;
  *attr = (lyd_attr *)0x0;
  module = parent_module;
  if (*data == '{') {
    do {
      str = (char *)0x0;
      prefix = (char *)0x0;
      len = len + 1;
      uVar2 = skip_ws(data + len);
      len = len + uVar2;
      if (data[len] != '\"') {
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,
                "JSON data (missing quotation-mark at the beginning of string)");
        uVar2 = 0;
        goto LAB_0016d745;
      }
      len = len + 1;
      str = lyjson_parse_text(ctx,data + len,&r);
      if (r == 0) goto LAB_0016d6fd;
      if (data[len + r] != '\"') {
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,
                "JSON data (missing quotation-mark at the end of string)");
        goto LAB_0016d6fd;
      }
      pcVar3 = strchr(str,0x3a);
      if (pcVar3 == (char *)0x0) {
        name = str;
      }
      else {
        *pcVar3 = '\0';
        name = pcVar3 + 1;
        prefix = str;
        module = ly_ctx_get_module(parent_module->ctx,str,(char *)0x0,0);
        if (module == (lys_module *)0x0) {
          ly_vlog(ctx,LYE_INELEM,LY_VLOG_NONE,(void *)0x0,name);
          goto LAB_0016d6fd;
        }
      }
      len = len + r + 1;
      uVar2 = skip_ws(data + len);
      len = len + uVar2;
      if (data[len] != ':') {
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"JSON data (missing name-separator)");
        goto LAB_0016d6fd;
      }
      len = len + 1;
      uVar2 = skip_ws(data + len);
      len = len + uVar2;
      if (data[len] != '\"') {
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,
                "JSON data (missing quotation-mark at the beginning of string)");
        goto LAB_0016d6fd;
      }
      len = len + 1;
      value = lyjson_parse_text(ctx,data + len,&r);
      if (r == 0) goto LAB_0016d6fd;
      if (data[len + r] != '\"') {
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,
                "JSON data (missing quotation-mark at the end of string)");
        free(value);
        goto LAB_0016d6fd;
      }
      len = len + r + 1;
      uVar2 = skip_ws(data + len);
      len = len + uVar2;
      ret = lyp_fill_attr(parent_module->ctx,(lyd_node *)0x0,(char *)0x0,prefix,name,value,
                          (lyxml_elem *)0x0,options,&attr_new);
      if (ret == -1) {
        free(value);
        goto LAB_0016d6fd;
      }
      if (ret == 1) {
        if ((options & 0x200U) != 0) {
          ly_vlog(ctx,LYE_INMETA,LY_VLOG_NONE,(void *)0x0,prefix,name,value);
          free(value);
          goto LAB_0016d6fd;
        }
        pcVar3 = prefix;
        if (prefix == (char *)0x0) {
          pcVar3 = "<none>";
        }
        ly_log(ctx,LY_LLWRN,LY_SUCCESS,"Unknown \"%s:%s\" metadata with value \"%s\", ignoring.",
               pcVar3,name,value);
        free(value);
      }
      else {
        free(value);
        if (attr_last == (lyd_attr *)0x0) {
          attr_last = attr_new;
          *attr = attr_new;
        }
        else {
          attr_last->next = attr_new;
          attr_last = attr_new;
        }
      }
      free(str);
      str = (char *)0x0;
    } while (data[len] == ',');
    if (data[len] == '}') {
      len = len + 1;
      uVar2 = skip_ws(data + len);
      uVar2 = len + uVar2;
      len = uVar2;
      goto LAB_0016d745;
    }
    ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"JSON data (missing end-object)");
  }
  else {
    iVar1 = strncmp(data,"null",4);
    if (iVar1 == 0) {
      len = len + 4;
      uVar2 = skip_ws(data + len);
      uVar2 = len + uVar2;
      len = uVar2;
      goto LAB_0016d745;
    }
    ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"JSON data (missing begin-object)");
  }
LAB_0016d6fd:
  free(str);
  if (*attr != (lyd_attr *)0x0) {
    lyd_free_attr(module->ctx,(lyd_node *)0x0,*attr,1);
    *attr = (lyd_attr *)0x0;
  }
  uVar2 = 0;
LAB_0016d745:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int store_attrs(ly_ctx *ctx,attr_cont *attrs,lyd_node *first,int options)

{
  attr_cont *paVar1;
  int iVar2;
  int options_local;
  lyd_node *first_local;
  attr_cont *attrs_local;
  ly_ctx *ctx_local;
  uint flag_leaflist;
  lyd_node *diter;
  lyd_attr *aiter;
  attr_cont *iter;
  
  flag_leaflist = 0;
  attrs_local = attrs;
  do {
    if (attrs_local == (attr_cont *)0x0) {
      return 0;
    }
    paVar1 = attrs_local->next;
    diter = first;
    if (attrs_local->index != 0) {
      flag_leaflist = 1;
    }
LAB_0016d879:
    if (diter == (lyd_node *)0x0) goto LAB_0016d884;
    if (attrs_local->schema != diter->schema) {
LAB_0016d86d:
      diter = diter->next;
      goto LAB_0016d879;
    }
    if ((flag_leaflist != 0) && (flag_leaflist != attrs_local->index)) {
      flag_leaflist = flag_leaflist + 1;
      goto LAB_0016d86d;
    }
    if (diter->attr != (lyd_attr *)0x0) {
      ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_LYD,diter,
              "attribute (multiple attribute definitions belong to a single element)");
      free(attrs_local);
      attrs_local = paVar1;
      goto LAB_0016d981;
    }
    diter->attr = attrs_local->attr;
    for (aiter = attrs_local->attr; aiter != (lyd_attr *)0x0; aiter = aiter->next) {
      aiter->parent = diter;
    }
LAB_0016d884:
    if (diter == (lyd_node *)0x0) {
      ly_vlog(ctx,LYE_XML_MISS,LY_VLOG_NONE,(void *)0x0,"element for the specified attribute",
              attrs_local->attr->name);
      lyd_free_attr(attrs_local->schema->module->ctx,(lyd_node *)0x0,attrs_local->attr,1);
      free(attrs_local);
      attrs_local = paVar1;
      goto LAB_0016d981;
    }
    free(attrs_local);
    attrs_local = paVar1;
    if (((options & 8U) != 0) &&
       (iVar2 = lyp_check_edit_attr(ctx,diter->attr,diter,(int *)0x0), iVar2 != 0)) {
LAB_0016d981:
      while (attrs_local != (attr_cont *)0x0) {
        paVar1 = attrs_local->next;
        lyd_free_attr(ctx,(lyd_node *)0x0,attrs_local->attr,1);
        free(attrs_local);
        attrs_local = paVar1;
      }
      return -1;
    }
  } while( true );
}



int json_skip_unknown(ly_ctx *ctx,lyd_node *parent,char *data,uint *len)

{
  char cVar1;
  bool bVar2;
  uint *len_local;
  char *data_local;
  lyd_node *parent_local;
  ly_ctx *ctx_local;
  int qstr;
  int objects;
  int arrays;
  
  bVar2 = false;
  objects = 0;
  arrays = 0;
  while( true ) {
    if (data[*len] == '\0') {
      return 0;
    }
    cVar1 = data[*len];
    if (cVar1 == '}') {
      if (!bVar2) {
        objects = objects + -1;
      }
    }
    else if (cVar1 < '~') {
      if (cVar1 == '{') {
        if (!bVar2) {
          objects = objects + 1;
        }
      }
      else if (cVar1 < '|') {
        if (cVar1 == ']') {
          if (!bVar2) {
            arrays = arrays + -1;
          }
        }
        else if (cVar1 < '^') {
          if (cVar1 == '[') {
            if (!bVar2) {
              arrays = arrays + 1;
            }
          }
          else if (cVar1 < '\\') {
            if (cVar1 == '\"') {
              if (bVar2) {
                if (data[*len - 1] != '\\') {
                  bVar2 = false;
                }
              }
              else {
                if (data[*len - 1] == '\\') {
                  ly_vlog(ctx,LYE_INVAL,LY_VLOG_LYD,parent,
                          "JSON data (missing quotation mark for a string data) ");
                  return -1;
                }
                bVar2 = true;
              }
            }
            else if ((((cVar1 == ',') && (!bVar2)) && (objects == 0)) && (arrays == 0)) {
              return 0;
            }
          }
        }
      }
    }
    if (objects < 0) {
      if (arrays != 0) {
        ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_LYD,parent,"JSON data (missing end-array)");
        return -1;
      }
      return 0;
    }
    if (arrays < 0) break;
    *len = *len + 1;
  }
  if (objects != 0) {
    ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_LYD,parent,"JSON data (missing end-object)");
    return -1;
  }
  return 0;
}



uint json_parse_data(ly_ctx *ctx,char *data,lys_node *schema_parent,lyd_node **parent,
                    lyd_node *first_sibling,lyd_node *prev,attr_cont **attrs,int options,
                    unres_data *unres,lyd_node **act_notif,char *yang_data_name)

{
  LYS_NODE LVar1;
  long lVar2;
  uint uVar3;
  int iVar4;
  char *pcVar5;
  size_t sVar6;
  lys_node *plVar7;
  lys_module *plVar8;
  lys_module *plVar9;
  lys_node_list *plVar10;
  lyd_node **pplVar11;
  LY_VLOG_ELEM elem_type;
  long in_FS_OFFSET;
  char *yang_data_name_local;
  lyd_node **act_notif_local;
  unres_data *unres_local;
  attr_cont **attrs_local;
  lyd_node *prev_local;
  lyd_node *first_sibling_local;
  lyd_node **parent_local;
  lys_node *schema_parent_local;
  char *data_local;
  ly_ctx *ctx_local;
  uint8_t pos;
  uint len;
  uint r;
  uint flag_leaflist;
  int i;
  lyd_node *result;
  lyd_node *list;
  lyd_attr *attr;
  attr_cont *attrs_aux;
  char *name;
  char *prefix;
  lys_module *module;
  lys_node *schema;
  lyd_node *diter;
  char *str;
  lys_node *sparent;
  lyd_node *new;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  len = 0;
  flag_leaflist = 0;
  prefix = (char *)0x0;
  str = (char *)0x0;
  module = (lys_module *)0x0;
  schema = (lys_node *)0x0;
  sparent = (lys_node *)0x0;
  result = (lyd_node *)0x0;
  diter = (lyd_node *)0x0;
  first_sibling_local = first_sibling;
  parent_local = parent;
  schema_parent_local = schema_parent;
  data_local = data;
  ctx_local = ctx;
  if (*data != '\"') {
    ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_LYD,*parent,
            "JSON data (missing quotation-mark at the beginning of string)");
    uVar3 = 0;
    goto LAB_0016f894;
  }
  len = 1;
  str = lyjson_parse_text(ctx,data + 1,&r);
  if (r != 0) {
    if (data_local[r + len] == '\"') {
      pcVar5 = strchr(str,0x3a);
      if (pcVar5 == (char *)0x0) {
        name = str;
        if (*str == '@') {
          name = str + 1;
        }
      }
      else {
        *pcVar5 = '\0';
        name = pcVar5 + 1;
        prefix = str;
        if (*str == '@') {
          prefix = str + 1;
        }
      }
      len = len + r + 1;
      uVar3 = skip_ws(data_local + len);
      len = uVar3 + len;
      if (data_local[len] == ':') {
        len = len + 1;
        uVar3 = skip_ws(data_local + len);
        len = uVar3 + len;
        if ((*str == '@') && (str[1] == '\0')) {
          if (*parent_local == (lyd_node *)0x0) {
            ly_vlog(ctx_local,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,
                    "attribute with no corresponding element to belongs to");
          }
          else {
            r = json_parse_attr((*parent_local)->schema->module,&attr,data_local + len,options);
            if (r == 0) {
              ly_vlog(ctx_local,LYE_PATH,LY_VLOG_LYD,*parent_local);
            }
            else {
              len = r + len;
              if ((*parent_local)->attr == (lyd_attr *)0x0) {
                (*parent_local)->attr = attr;
                for (; attr != (lyd_attr *)0x0; attr = attr->next) {
                  attr->parent = *parent_local;
                }
              }
              else {
                lyd_free_attr(ctx_local,(lyd_node *)0x0,attr,1);
              }
              if (((options & 8U) == 0) ||
                 (iVar4 = lyp_check_edit_attr(ctx_local,(*parent_local)->attr,*parent_local,
                                              (int *)0x0), iVar4 == 0)) {
                free(str);
                uVar3 = len;
                goto LAB_0016f894;
              }
            }
          }
        }
        else {
          if (*parent_local == (lyd_node *)0x0) {
            module = ly_ctx_get_module(ctx_local,prefix,(char *)0x0,0);
            if (ctx_local->data_clb != (ly_module_data_clb)0x0) {
              if (module == (lys_module *)0x0) {
                module = (*ctx_local->data_clb)
                                   (ctx_local,prefix,(char *)0x0,0,ctx_local->data_clb_data);
              }
              else if ((module->field_0x40 & 0x80) == 0) {
                module = (*ctx_local->data_clb)
                                   (ctx_local,module->name,module->ns,1,ctx_local->data_clb_data);
              }
            }
            if ((module != (lys_module *)0x0) && ((module->field_0x40 & 0x80) != 0)) {
              if (yang_data_name == (char *)0x0) {
                do {
                  schema = lys_getnext(schema,(lys_node *)0x0,module,0);
                  if (schema == (lys_node *)0x0) break;
                  iVar4 = strcmp(schema->name,name);
                } while (iVar4 != 0);
              }
              else {
                sVar6 = strlen(yang_data_name);
                sparent = lyp_get_yang_data_template(module,yang_data_name,(int)sVar6);
                schema = (lys_node *)0x0;
                if (sparent != (lys_node *)0x0) {
                  do {
                    schema = lys_getnext(schema,sparent,module,0);
                    if (schema == (lys_node *)0x0) break;
                    iVar4 = strcmp(schema->name,name);
                  } while (iVar4 != 0);
                }
              }
            }
          }
          else {
            if ((prefix != (char *)0x0) &&
               (module = ly_ctx_get_module(ctx_local,prefix,(char *)0x0,1),
               ctx_local->data_clb != (ly_module_data_clb)0x0)) {
              if (module == (lys_module *)0x0) {
                (*ctx_local->data_clb)(ctx_local,prefix,(char *)0x0,0,ctx_local->data_clb_data);
              }
              else if ((module->field_0x40 & 0x80) == 0) {
                (*ctx_local->data_clb)(ctx_local,module->name,module->ns,1,ctx_local->data_clb_data)
                ;
              }
            }
            if (((*parent_local)->schema->nodetype == LYS_RPC) ||
               ((*parent_local)->schema->nodetype == LYS_ACTION)) {
              do {
                plVar7 = lys_getnext(schema,(*parent_local)->schema,(lys_module *)0x0,8);
                if ((plVar7 == (lys_node *)0x0) ||
                   (((options & 0x10U) != 0 && (plVar7->nodetype == LYS_INPUT)))) break;
                schema = plVar7;
              } while (((options & 0x20U) == 0) || (plVar7->nodetype != LYS_OUTPUT));
              schema = (lys_node *)0x0;
              schema_parent_local = plVar7;
            }
            if (schema_parent_local == (lys_node *)0x0) {
              do {
                do {
                  do {
                    schema = lys_getnext(schema,(*parent_local)->schema,(lys_module *)0x0,0);
                    if (schema == (lys_node *)0x0) goto LAB_0016e4f0;
                    iVar4 = strcmp(schema->name,name);
                  } while (iVar4 != 0);
                  if (prefix != (char *)0x0) {
                    plVar8 = lys_node_module(schema);
                    iVar4 = strcmp(plVar8->name,prefix);
                    if (iVar4 == 0) goto LAB_0016e4f0;
                  }
                } while (prefix != (char *)0x0);
                plVar8 = lys_node_module(schema);
                plVar9 = lyd_node_module(*parent_local);
              } while (plVar8 != plVar9);
            }
            else {
              do {
                do {
                  do {
                    schema = lys_getnext(schema,schema_parent_local,(lys_module *)0x0,0);
                    if (schema == (lys_node *)0x0) goto LAB_0016e4f0;
                    iVar4 = strcmp(schema->name,name);
                  } while (iVar4 != 0);
                  if (prefix != (char *)0x0) {
                    plVar8 = lys_node_module(schema);
                    iVar4 = strcmp(plVar8->name,prefix);
                    if (iVar4 == 0) goto LAB_0016e4f0;
                  }
                } while (prefix != (char *)0x0);
                plVar8 = lys_node_module(schema);
                plVar9 = lys_node_module(schema_parent_local);
              } while (plVar8 != plVar9);
            }
          }
LAB_0016e4f0:
          module = lys_node_module(schema);
          if (((module == (lys_module *)0x0) || ((module->field_0x40 & 0x80) == 0)) ||
             ((module->field_0x40 & 0x40) != 0)) {
            if ((options & 0x200U) == 0) {
              iVar4 = json_skip_unknown(ctx_local,*parent_local,data_local,&len);
              if (iVar4 == 0) {
                free(str);
                uVar3 = len;
                goto LAB_0016f894;
              }
            }
            else {
              if (*parent_local == (lyd_node *)0x0) {
                elem_type = LY_VLOG_NONE;
              }
              else {
                elem_type = LY_VLOG_LYD;
              }
              ly_vlog(ctx_local,LYE_INELEM,elem_type,*parent_local,name);
            }
          }
          else if (*str == '@') {
            if (data_local[len] == '[') {
              flag_leaflist = 1;
              len = len + 1;
              uVar3 = skip_ws(data_local + len);
              len = uVar3 + len;
            }
            while (r = json_parse_attr(module,&attr,data_local + len,options), r != 0) {
              len = r + len;
              if (attr != (lyd_attr *)0x0) {
                attrs_aux = (attr_cont *)malloc(0x20);
                if (attrs_aux == (attr_cont *)0x0) {
                  ly_log(ctx_local,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                         "json_parse_data");
                  goto LAB_0016f7c1;
                }
                attrs_aux->attr = attr;
                attrs_aux->index = flag_leaflist;
                attrs_aux->schema = schema;
                attrs_aux->next = *attrs;
                *attrs = attrs_aux;
              }
              if (flag_leaflist == 0) {
LAB_0016e832:
                free(str);
                uVar3 = len;
                goto LAB_0016f894;
              }
              if (data_local[len] != ',') {
                if (data_local[len] == ']') {
                  len = len + 1;
                  uVar3 = skip_ws(data_local + len);
                  len = uVar3 + len;
                  goto LAB_0016e832;
                }
                ly_vlog(ctx_local,LYE_XML_INVAL,LY_VLOG_LYD,*parent_local,
                        "JSON data (missing end-array)");
                goto LAB_0016f7c1;
              }
              len = len + 1;
              uVar3 = skip_ws(data_local + len);
              len = uVar3 + len;
              flag_leaflist = flag_leaflist + 1;
            }
            ly_vlog(ctx_local,LYE_PATH,LY_VLOG_LYD,*parent_local);
          }
          else {
            LVar1 = schema->nodetype;
            if (LVar1 == LYS_ANYDATA) {
switchD_0016e8b4_caseD_20:
              result = (lyd_node *)calloc(1,0x40);
LAB_0016e934:
              if (result == (lyd_node *)0x0) {
                ly_log(ctx_local,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                       "json_parse_data");
              }
              else {
                result->prev = result;
                result->schema = schema;
                result->parent = *parent_local;
                diter = (lyd_node *)0x0;
                if ((schema->nodetype == LYS_LEAF) &&
                   (plVar10 = lys_is_key((lys_node_leaf *)schema,&pos),
                   plVar10 != (lys_node_list *)0x0)) {
                  if (*parent_local == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
                    __assert_fail("*parent",
                                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_json.c"
                                  ,0x453,"json_parse_data");
                  }
                  i = 0;
                  diter = (*parent_local)->child;
                  while ((((diter != (lyd_node *)0x0 && (i < (int)(uint)pos)) &&
                          (diter->schema->nodetype == LYS_LEAF)) &&
                         (plVar10 = lys_is_key((lys_node_leaf *)diter->schema,(uint8_t *)0x0),
                         plVar10 != (lys_node_list *)0x0))) {
                    i = i + 1;
                    diter = diter->next;
                  }
                  if (diter != (lyd_node *)0x0) {
                    if (diter == (*parent_local)->child) {
                      (*parent_local)->child = result;
                      first_sibling_local = result;
                    }
                    if (diter->prev->next != (lyd_node *)0x0) {
                      diter->prev->next = result;
                    }
                    result->prev = diter->prev;
                    diter->prev = result;
                    result->next = diter;
                  }
                }
                if (diter == (lyd_node *)0x0) {
                  if ((*parent_local != (lyd_node *)0x0) &&
                     ((*parent_local)->child == (lyd_node *)0x0)) {
                    (*parent_local)->child = result;
                  }
                  if (prev == (lyd_node *)0x0) {
                    result->prev = result;
                    first_sibling_local = result;
                  }
                  else {
                    result->prev = prev;
                    prev->next = result;
                    first_sibling_local->prev = result;
                  }
                }
                iVar4 = ly_new_node_validity(result->schema);
                result->validity = (uint8_t)iVar4;
                iVar4 = resolve_applies_when(schema,0,(lys_node *)0x0);
                if (iVar4 != 0) {
                  result->field_0x9 = result->field_0x9 & 0xf1 | 8;
                }
                LVar1 = schema->nodetype;
                if (LVar1 == LYS_ANYDATA) {
switchD_0016ec37_caseD_20:
                  r = json_get_anydata((lyd_node_anydata *)result,data_local + len);
                  if (r != 0) {
                    lyd_hash(result);
                    lyd_insert_hash(result);
                    len = r + len;
                    uVar3 = skip_ws(data_local + len);
                    len = uVar3 + len;
                    goto LAB_0016f6ce;
                  }
                }
                else {
                  if (LYS_ANYDATA < LVar1) goto switchD_0016ec37_caseD_2;
                  if (LVar1 == LYS_ACTION) {
switchD_0016ec37_caseD_1:
                    if ((schema->nodetype & 0x4100) == LYS_UNKNOWN) {
                      if (schema->nodetype == LYS_NOTIF) {
                        if (((options & 0x40U) == 0) || (*act_notif != (lyd_node *)0x0)) {
                          ly_vlog(ctx_local,LYE_INELEM,LY_VLOG_LYD,result,schema->name);
                          ly_vlog(ctx_local,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                                  "Unexpected notification node \"%s\".",schema->name);
                          goto LAB_0016f7c1;
                        }
                        *act_notif = result;
                      }
                    }
                    else {
                      if (((options & 0x10U) == 0) || (*act_notif != (lyd_node *)0x0)) {
                        ly_vlog(ctx_local,LYE_INELEM,LY_VLOG_LYD,result,schema->name);
                        if (schema->nodetype == LYS_RPC) {
                          pcVar5 = "rpc";
                        }
                        else {
                          pcVar5 = "action";
                        }
                        ly_vlog(ctx_local,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                                "Unexpected %s node \"%s\".",pcVar5,schema->name);
                        goto LAB_0016f7c1;
                      }
                      *act_notif = result;
                    }
                    lyd_hash(result);
                    lyd_insert_hash(result);
                    if (data_local[len] == '{') {
                      len = len + 1;
                      uVar3 = skip_ws(data_local + len);
                      len = uVar3 + len;
                      if (data_local[len] != '}') {
                        len = len - 1;
                        diter = (lyd_node *)0x0;
                        attrs_aux = (attr_cont *)0x0;
                        do {
                          len = len + 1;
                          uVar3 = skip_ws(data_local + len);
                          len = uVar3 + len;
                          r = json_parse_data(ctx_local,data_local + len,(lys_node *)0x0,&result,
                                              result->child,diter,&attrs_aux,options,unres,act_notif
                                              ,yang_data_name);
                          if (r == 0) goto LAB_0016f7c1;
                          len = r + len;
                          if (result->child != (lyd_node *)0x0) {
                            diter = result->child->prev;
                          }
                        } while (data_local[len] == ',');
                        iVar4 = store_attrs(ctx_local,attrs_aux,result->child,options);
                        if (iVar4 != 0) goto LAB_0016f7c1;
                      }
                      if (data_local[len] == '}') {
                        len = len + 1;
                        uVar3 = skip_ws(data_local + len);
                        len = uVar3 + len;
                        if ((((schema->nodetype == LYS_CONTAINER) &&
                             (result->child == (lyd_node *)0x0)) &&
                            (result->attr == (lyd_attr *)0x0)) &&
                           (lVar2._0_2_ = schema[1].flags, lVar2._2_1_ = schema[1].ext_size,
                           lVar2._3_1_ = schema[1].iffeature_size,
                           lVar2._4_1_ = schema[1].padding[0], lVar2._5_1_ = schema[1].padding[1],
                           lVar2._6_1_ = schema[1].padding[2], lVar2._7_1_ = schema[1].padding[3],
                           lVar2 == 0)) {
                          result->field_0x9 = result->field_0x9 | 1;
                        }
LAB_0016f6ce:
                        iVar4 = lyv_data_context(result,options | 0x2000,unres);
                        if ((iVar4 == 0) &&
                           (iVar4 = lyv_data_content(result,options,unres), iVar4 == 0)) {
                          if (prev == (lyd_node *)0x0) {
                            pplVar11 = (lyd_node **)0x0;
                          }
                          else {
                            pplVar11 = &first_sibling_local;
                          }
                          iVar4 = lyv_multicases(result,(lys_node *)0x0,pplVar11,0,(lyd_node *)0x0);
                          if (iVar4 == 0) {
                            if ((result->schema->nodetype & (LYS_LEAFLIST|LYS_LIST)) != LYS_UNKNOWN)
                            {
                              result->validity = result->validity | 1;
                            }
                            if (*parent_local == (lyd_node *)0x0) {
                              *parent_local = result;
                            }
                            free(str);
                            uVar3 = len;
                            goto LAB_0016f894;
                          }
                        }
                      }
                      else {
                        ly_vlog(ctx_local,LYE_XML_INVAL,LY_VLOG_LYD,result,
                                "JSON data (missing end-object)");
                      }
                    }
                    else {
                      ly_vlog(ctx_local,LYE_XML_INVAL,LY_VLOG_LYD,result,
                              "JSON data (missing begin-object)");
                    }
                    goto LAB_0016f7c1;
                  }
                  if (LYS_ACTION < LVar1) goto switchD_0016ec37_caseD_2;
                  if (LVar1 == LYS_RPC) goto switchD_0016ec37_caseD_1;
                  if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
                    if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
                      if ((LVar1 != LYS_UNKNOWN) && (true)) {
                        switch(LVar1) {
                        case LYS_CONTAINER:
                          goto switchD_0016ec37_caseD_1;
                        default:
                          goto switchD_0016ec37_caseD_2;
                        case LYS_LEAF:
                        case LYS_LEAFLIST:
                          r = json_get_value((lyd_node_leaf_list *)result,&first_sibling_local,
                                             data_local + len,options,unres);
                          if (r != 0) {
                            for (; (result->next != (lyd_node *)0x0 &&
                                   (result->next->schema == result->schema)); result = result->next)
                            {
                            }
                            len = r + len;
                            uVar3 = skip_ws(data_local + len);
                            len = uVar3 + len;
                            goto LAB_0016f6ce;
                          }
                          break;
                        case LYS_LIST:
                          if (data_local[len] == '[') {
                            list = result;
                            do {
                              len = len + 1;
                              uVar3 = skip_ws(data_local + len);
                              len = uVar3 + len;
                              if (data_local[len] != '{') {
                                ly_vlog(ctx_local,LYE_XML_INVAL,LY_VLOG_LYD,result,
                                        "JSON data (missing list instance\'s begin-object)");
                                goto LAB_0016f7c1;
                              }
                              diter = (lyd_node *)0x0;
                              attrs_aux = (attr_cont *)0x0;
                              do {
                                len = len + 1;
                                uVar3 = skip_ws(data_local + len);
                                len = uVar3 + len;
                                r = json_parse_data(ctx_local,data_local + len,(lys_node *)0x0,&list
                                                    ,list->child,diter,&attrs_aux,options,unres,
                                                    act_notif,yang_data_name);
                                if (r == 0) goto LAB_0016f7c1;
                                len = r + len;
                                if (list->child != (lyd_node *)0x0) {
                                  diter = list->child->prev;
                                }
                              } while (data_local[len] == ',');
                              if (list->schema->padding[2] == '\0') {
                                lyd_hash(list);
                                lyd_insert_hash(list);
                              }
                              iVar4 = store_attrs(ctx_local,attrs_aux,list->child,options);
                              if (iVar4 != 0) goto LAB_0016f7c1;
                              if (data_local[len] != '}') {
                                ly_vlog(ctx_local,LYE_XML_INVAL,LY_VLOG_LYD,result,
                                        "JSON data (missing list instance\'s end-object)");
                                goto LAB_0016f7c1;
                              }
                              len = len + 1;
                              uVar3 = skip_ws(data_local + len);
                              len = uVar3 + len;
                              if (data_local[len] == ',') {
                                iVar4 = lyv_data_context(list,options | 0x2000,unres);
                                if ((iVar4 != 0) ||
                                   (iVar4 = lyv_data_content(list,options,unres), iVar4 != 0))
                                goto LAB_0016f7c1;
                                if (prev == (lyd_node *)0x0) {
                                  pplVar11 = (lyd_node **)0x0;
                                }
                                else {
                                  pplVar11 = &first_sibling_local;
                                }
                                iVar4 = lyv_multicases(list,(lys_node *)0x0,pplVar11,0,
                                                       (lyd_node *)0x0);
                                if (iVar4 != 0) goto LAB_0016f7c1;
                                new = (lyd_node *)calloc(1,0x48);
                                if (new == (lyd_node *)0x0) {
                                  ly_log(ctx_local,LY_LLERR,LY_EMEM,
                                         "Memory allocation failed (%s()).","json_parse_data");
                                  goto LAB_0016f7c1;
                                }
                                new->parent = list->parent;
                                new->prev = list;
                                list->next = new;
                                new->validity = list->validity;
                                new->field_0x9 =
                                     new->field_0x9 & 0xf1 |
                                     ((byte)list->field_0x9 >> 1 & 7) * '\x02';
                                first_sibling_local->prev = new;
                                new->schema = list->schema;
                                list = new;
                              }
                            } while (data_local[len] == ',');
                            result = list;
                            if (data_local[len] == ']') {
                              len = len + 1;
                              uVar3 = skip_ws(data_local + len);
                              len = uVar3 + len;
                              goto LAB_0016f6ce;
                            }
                            ly_vlog(ctx_local,LYE_XML_INVAL,LY_VLOG_LYD,list,
                                    "JSON data (missing end-array)");
                          }
                          else {
                            ly_vlog(ctx_local,LYE_XML_INVAL,LY_VLOG_LYD,result,
                                    "JSON data (missing begin-array)");
                          }
                          break;
                        case LYS_ANYXML:
                          goto switchD_0016ec37_caseD_20;
                        }
                        goto LAB_0016f7c1;
                      }
                    }
                    else if (LVar1 == LYS_NOTIF) goto switchD_0016ec37_caseD_1;
                  }
switchD_0016ec37_caseD_2:
                  ly_log(ctx_local,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_json.c"
                         ,0x540);
                }
              }
            }
            else {
              if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
                if (LVar1 == LYS_ACTION) {
switchD_0016e8b4_caseD_1:
                  result = (lyd_node *)calloc(1,0x48);
                  goto LAB_0016e934;
                }
                if (LVar1 < (LYS_CONTAINER|LYS_ACTION)) {
                  if (LVar1 == LYS_RPC) goto switchD_0016e8b4_caseD_1;
                  if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
                    if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
                      if ((LVar1 != LYS_UNKNOWN) && (true)) {
                        switch(LVar1) {
                        case LYS_CONTAINER:
                        case LYS_LIST:
                          goto switchD_0016e8b4_caseD_1;
                        case LYS_LEAF:
                        case LYS_LEAFLIST:
                          result = (lyd_node *)calloc(1,0x50);
                          goto LAB_0016e934;
                        case LYS_ANYXML:
                          goto switchD_0016e8b4_caseD_20;
                        }
                      }
                    }
                    else if (LVar1 == LYS_NOTIF) goto switchD_0016e8b4_caseD_1;
                  }
                }
              }
              ly_log(ctx_local,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                     "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_json.c"
                     ,0x448);
            }
          }
        }
      }
      else {
        ly_vlog(ctx_local,LYE_XML_INVAL,LY_VLOG_LYD,*parent_local,
                "JSON data (missing name-separator)");
      }
    }
    else {
      ly_vlog(ctx_local,LYE_XML_INVAL,LY_VLOG_LYD,*parent_local,
              "JSON data (missing quotation-mark at the end of string)");
    }
  }
LAB_0016f7c1:
  i = unres->count;
  while (i = i - 1, -1 < i) {
    if (unres->node[i] == result) {
      unres_data_del(unres,i);
    }
  }
  while (*attrs != (attr_cont *)0x0) {
    attrs_aux = *attrs;
    *attrs = (*attrs)->next;
    lyd_free_attr(ctx_local,(lyd_node *)0x0,attrs_aux->attr,1);
    free(attrs_aux);
  }
  lyd_free(result);
  free(str);
  uVar3 = 0;
LAB_0016f894:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lyd_node *
lyd_parse_json(ly_ctx *ctx,char *data,int options,lyd_node *rpc_act,lyd_node *data_tree,
              char *yang_data_name)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  char *pcVar4;
  lyd_node *plVar5;
  long in_FS_OFFSET;
  char *yang_data_name_local;
  lyd_node *data_tree_local;
  lyd_node *rpc_act_local;
  int options_local;
  char *data_local;
  ly_ctx *ctx_local;
  uint len;
  int act_cont;
  uint r;
  lyd_node *result;
  lyd_node *next;
  lyd_node *act_notif;
  attr_cont *attrs;
  lyd_node *iter;
  lyd_node *reply_parent;
  lyd_node *reply_top;
  unres_data *unres;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  result = (lyd_node *)0x0;
  reply_parent = (lyd_node *)0x0;
  reply_top = (lyd_node *)0x0;
  act_notif = (lyd_node *)0x0;
  unres = (unres_data *)0x0;
  act_cont = 0;
  attrs = (attr_cont *)0x0;
  if ((ctx == (ly_ctx *)0x0) || (data == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_parse_json");
    plVar5 = (lyd_node *)0x0;
    goto LAB_00170223;
  }
  len = skip_ws(data);
  if (data[len] != '{') {
    ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"JSON data (missing top level begin-object)")
    ;
    plVar5 = (lyd_node *)0x0;
    goto LAB_00170223;
  }
  uVar1 = skip_ws(data + (len + 1));
  if (data[len + 1 + uVar1] == '}') {
    if ((options & 0x20000U) != 0) {
      result = ly_ctx_info(ctx);
    }
    lyd_validate(&result,options,ctx);
    plVar5 = result;
    goto LAB_00170223;
  }
  unres = (unres_data *)calloc(1,0x28);
  if (unres == (unres_data *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_parse_json");
    plVar5 = (lyd_node *)0x0;
    goto LAB_00170223;
  }
  if (rpc_act == (lyd_node *)0x0) {
LAB_0016fc03:
    iter = (lyd_node *)0x0;
    next = reply_parent;
    options_local = options;
    do {
      uVar1 = skip_ws(data + (len + 1));
      len = len + 1 + uVar1;
      if (act_cont == 0) {
        iVar2 = strncmp(data + len,"\"yang:action\"",0xd);
        if (iVar2 == 0) {
          uVar1 = skip_ws(data + (len + 0xd));
          uVar1 = len + 0xd + uVar1;
          if (data[uVar1] != ':') {
            ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,
                    "JSON data (missing top-level begin-object)");
            goto LAB_001701ca;
          }
          uVar1 = uVar1 + 1;
          uVar3 = skip_ws(data + uVar1);
          uVar1 = uVar1 + uVar3;
          if (data[uVar1] != '{') {
            ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,
                    "JSON data (missing top level yang:action object)");
            goto LAB_001701ca;
          }
          uVar1 = uVar1 + 1;
          uVar3 = skip_ws(data + uVar1);
          len = uVar1 + uVar3;
          act_cont = 1;
        }
        else {
          act_cont = -1;
        }
      }
      uVar1 = json_parse_data(ctx,data + len,(lys_node *)0x0,&next,result,iter,&attrs,options_local,
                              unres,&act_notif,yang_data_name);
      if (uVar1 == 0) goto LAB_001701ca;
      len = len + uVar1;
      if (result == (lyd_node *)0x0) {
        if (reply_parent == (lyd_node *)0x0) {
          iter = next;
          while ((iter != (lyd_node *)0x0 && (iter->prev->next != (lyd_node *)0x0))) {
            iter = iter->prev;
          }
          result = iter;
          if (((iter != (lyd_node *)0x0) && ((options_local & 0x20000U) != 0)) &&
             (iter->schema->module == (ctx->models).list[(ulong)ctx->internal_module_count - 1])) {
            options_local = options_local & 0xfffdffff;
          }
          iter = next;
        }
        else {
          result = next->child;
          if (next->child == (lyd_node *)0x0) {
            iter = (lyd_node *)0x0;
          }
          else {
            iter = next->child->prev;
          }
        }
      }
      else {
        iter = result->prev;
      }
      if (reply_parent == (lyd_node *)0x0) {
        next = (lyd_node *)0x0;
      }
    } while (data[len] == ',');
    if (data[len] == '}') {
      uVar1 = skip_ws(data + (len + 1));
      uVar1 = len + 1 + uVar1;
      if (act_cont == 1) {
        if (data[uVar1] != '}') {
          ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,
                  "JSON data (missing top-level end-object)");
          goto LAB_001701ca;
        }
        skip_ws(data + (uVar1 + 1));
      }
      iVar2 = store_attrs(ctx,attrs,result,options_local);
      if (iVar2 == 0) {
        if (reply_top != (lyd_node *)0x0) {
          result = reply_top;
        }
        if (result == (lyd_node *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EVALID,"Model for the data to be linked with not found.");
        }
        else if (((options_local & 0x30U) == 0) || (iVar2 = lyd_schema_sort(result,1), iVar2 == 0))
        {
          if (((options_local & 0x20U) == 0) || (rpc_act->schema->nodetype == LYS_RPC)) {
            if (((options_local & 0x50U) != 0) && (act_notif == (lyd_node *)0x0)) {
              if ((options_local & 0x10U) == 0) {
                pcVar4 = "notification";
              }
              else {
                pcVar4 = "action";
              }
              ly_vlog(ctx,LYE_MISSELEM,LY_VLOG_LYD,result,pcVar4,result->schema->name);
              goto LAB_001701ca;
            }
          }
          else {
            act_notif = reply_parent;
          }
          if ((options_local & 0x20000U) != 0) {
            plVar5 = ly_ctx_info(ctx);
            iVar2 = lyd_merge(result,plVar5,0x500);
            if (iVar2 != 0) {
              ly_log(ctx,LY_LLERR,LY_EINT,"Adding ietf-yang-library data failed.");
              goto LAB_001701ca;
            }
          }
          for (iter = result; iter != (lyd_node *)0x0; iter = iter->next) {
            if ((((iter->schema->nodetype & (LYS_LEAFLIST|LYS_LIST)) != LYS_UNKNOWN) &&
                ((iter->validity & 1) != 0)) && (iVar2 = lyv_data_dup(iter,result), iVar2 != 0))
            goto LAB_001701ca;
          }
          iVar2 = lyd_defaults_add_unres
                            (&result,options_local,ctx,(lys_module **)0x0,0,data_tree,act_notif,
                             unres,1);
          if (iVar2 == 0) {
            if ((options_local & 0x2080U) == 0) {
              plVar5 = result;
              if (act_notif != (lyd_node *)0x0) {
                plVar5 = act_notif;
              }
              iVar2 = lyd_check_mandatory_tree(plVar5,ctx,(lys_module **)0x0,0,options_local);
              if (iVar2 != 0) goto LAB_001701ca;
            }
            free(unres->node);
            free(unres->type);
            free(unres);
            plVar5 = result;
            goto LAB_00170223;
          }
        }
      }
    }
    else {
      ly_vlog(ctx,LYE_XML_INVAL,LY_VLOG_NONE,(void *)0x0,"JSON data (missing top-level end-object)")
      ;
    }
  }
  else {
    if ((options & 0x20U) == 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("options & LYD_OPT_RPCREPLY",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_json.c"
                    ,0x596,"lyd_parse_json");
    }
    if (rpc_act->schema->nodetype == LYS_RPC) {
      reply_parent = _lyd_new((lyd_node *)0x0,rpc_act->schema,0);
      reply_top = reply_parent;
      goto LAB_0016fc03;
    }
    reply_top = lyd_dup(rpc_act,1);
    iter = reply_top;
    while ((reply_parent = iter, iter != (lyd_node *)0x0 && (iter->schema->nodetype != LYS_ACTION)))
    {
      if ((iter->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
        iter = iter->child;
      }
      else {
        iter = (lyd_node *)0x0;
      }
      if (iter == (lyd_node *)0x0) {
        if (reply_parent == reply_top) break;
        iter = reply_parent->next;
      }
      while ((iter == (lyd_node *)0x0 &&
             (reply_parent = reply_parent->parent, reply_parent->parent != reply_top->parent))) {
        iter = reply_parent->next;
      }
    }
    if (reply_parent != (lyd_node *)0x0) {
      lyd_free_withsiblings(reply_parent->child);
      goto LAB_0016fc03;
    }
    ly_log(ctx,LY_LLERR,LY_EINVAL,"%s: invalid variable parameter (const struct lyd_node *rpc_act)."
           ,"lyd_parse_json");
  }
LAB_001701ca:
  lyd_free_withsiblings(result);
  if ((reply_top != (lyd_node *)0x0) && (reply_top != result)) {
    lyd_free_withsiblings(reply_top);
  }
  free(unres->node);
  free(unres->type);
  free(unres);
  plVar5 = (lyd_node *)0x0;
LAB_00170223:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar5;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



__uint64_t __uint64_identity(__uint64_t __x)

{
  __uint64_t __x_local;
  
  return __x;
}



int lyb_read(char *data,uint8_t *buf,size_t count,lyb_state *lybs)

{
  undefined2 uVar1;
  long lVar2;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  size_t count_local;
  uint8_t *buf_local;
  char *data_local;
  int ret;
  int i;
  int empty_chunk_i;
  size_t to_read;
  uint8_t meta_buf [2];
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  if ((data != (char *)0x0) && (count_local = count, buf_local = buf, lybs != (lyb_state *)0x0)) {
    while( true ) {
      to_read = count_local;
      empty_chunk_i = -1;
      for (i = 0; i < lybs->used; i = i + 1) {
        if ((lybs->written[i] <= to_read) && (lybs->position[i] != 0)) {
          to_read = lybs->written[i];
          empty_chunk_i = i;
        }
      }
      if ((empty_chunk_i == -1) && (count_local == 0)) break;
      if (to_read != 0) {
        if (buf_local != (uint8_t *)0x0) {
          memcpy(buf_local,data + ret,to_read);
        }
        for (i = 0; i < lybs->used; i = i + 1) {
          lybs->written[i] = lybs->written[i] - to_read;
          if (0xff < lybs->written[i]) {
                    // WARNING: Subroutine does not return
            __assert_fail("lybs->written[i] <= LYB_SIZE_MAX",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
                          ,0x52,"lyb_read");
          }
        }
        count_local = count_local - to_read;
        if (buf_local != (uint8_t *)0x0) {
          buf_local = buf_local + to_read;
        }
        ret = ret + (int)to_read;
      }
      if (-1 < empty_chunk_i) {
        uVar1 = *(undefined2 *)(data + ret);
        meta_buf[0] = (uint8_t)uVar1;
        lybs->written[empty_chunk_i] = (ulong)meta_buf[0];
        meta_buf[1] = (uint8_t)((ushort)uVar1 >> 8);
        lybs->inner_chunks[empty_chunk_i] = meta_buf[1];
        lybs->position[empty_chunk_i] = (ulong)(lybs->written[empty_chunk_i] == 0xff);
        ret = ret + 2;
      }
    }
    if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
      return ret;
    }
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
                    // WARNING: Subroutine does not return
  __assert_fail("data && lybs",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
                ,0x35,"lyb_read");
}



int lyb_read_number(void *num,size_t num_size,size_t bytes,char *data,lyb_state *lybs)

{
  int iVar1;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  char *data_local;
  size_t bytes_local;
  size_t num_size_local;
  void *num_local;
  int ret;
  int r;
  uint64_t buf;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  buf = 0;
  iVar1 = lyb_read(data,(uint8_t *)&buf,bytes,lybs);
  if (iVar1 < 0) {
    iVar1 = -1;
  }
  else {
    buf = __uint64_identity(buf);
    if (num_size == 8) {
      *(uint64_t *)num = buf;
    }
    else {
      if (num_size < 9) {
        if (num_size == 4) {
          *(int *)num = (int)buf;
          goto LAB_001705f6;
        }
        if (num_size < 5) {
          if (num_size == 1) {
            *(char *)num = (char)buf;
            goto LAB_001705f6;
          }
          if (num_size == 2) {
            *(short *)num = (short)buf;
            goto LAB_001705f6;
          }
        }
      }
      ly_log(lybs->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
             ,0x87);
      iVar1 = -1;
    }
  }
LAB_001705f6:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_read_enum(uint64_t *enum_idx,uint32_t count,char *data,lyb_state *lybs)

{
  int iVar1;
  lyb_state *lybs_local;
  char *data_local;
  uint32_t count_local;
  uint64_t *enum_idx_local;
  size_t bytes;
  
  if (count < 0x100) {
    bytes = 1;
  }
  else if (count < 0x10000) {
    bytes = 2;
  }
  else if (count < 0x1000000) {
    bytes = 3;
  }
  else {
    bytes = 4;
  }
  *enum_idx = 0;
  iVar1 = lyb_read_number(enum_idx,8,bytes,data,lybs);
  return iVar1;
}



int lyb_read_string(char *data,char **str,int with_length,lyb_state *lybs)

{
  int iVar1;
  char *pcVar2;
  long in_FS_OFFSET;
  bool bVar3;
  lyb_state *lybs_local;
  int with_length_local;
  char **str_local;
  char *data_local;
  int next_chunk;
  int ret;
  int r;
  size_t len;
  size_t cur_len;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  bVar3 = false;
  ret = 0;
  len = 0;
  if (with_length == 0) {
    len = lybs->written[(long)lybs->used + -1];
    data_local = data;
    if (lybs->position[(long)lybs->used + -1] != 0) {
      bVar3 = true;
    }
LAB_0017076a:
    pcVar2 = (char *)malloc(len + 1);
    *str = pcVar2;
    if (*str == (char *)0x0) {
      ly_log(lybs->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyb_read_string");
      ret = -1;
      goto LAB_00170954;
    }
    iVar1 = lyb_read(data_local,(uint8_t *)*str,len,lybs);
    ret = ret + iVar1;
    if (-1 < iVar1) {
      data_local = data_local + iVar1;
      while (bVar3) {
        cur_len = lybs->written[(long)lybs->used + -1];
        bVar3 = lybs->position[(long)lybs->used + -1] != 0;
        pcVar2 = (char *)ly_realloc(*str,cur_len + len + 1);
        *str = pcVar2;
        if (*str == (char *)0x0) {
          ly_log(lybs->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyb_read_string");
          ret = -1;
          goto LAB_00170954;
        }
        iVar1 = lyb_read(data_local,(uint8_t *)(*str + len),cur_len,lybs);
        ret = ret + iVar1;
        if (iVar1 < 0) goto LAB_00170935;
        data_local = data_local + iVar1;
        len = cur_len + len;
      }
      (*str)[len] = '\0';
      goto LAB_00170954;
    }
  }
  else {
    ret = lyb_read_number(&len,8,2,data,lybs);
    if (-1 < ret) {
      data_local = data + ret;
      goto LAB_0017076a;
    }
  }
LAB_00170935:
  free(*str);
  *str = (char *)0x0;
  ret = -1;
LAB_00170954:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return ret;
}



void lyb_read_stop_subtree(lyb_state *lybs)

{
  lyb_state *lybs_local;
  
  if (lybs->written[(long)lybs->used + -1] != 0) {
    ly_log(lybs->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
           ,0xd7);
  }
  lybs->used = lybs->used + -1;
  return;
}



int lyb_read_start_subtree(char *data,lyb_state *lybs)

{
  undefined2 uVar1;
  long lVar2;
  int iVar3;
  size_t *psVar4;
  uint8_t *puVar5;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  char *data_local;
  uint8_t meta_buf [2];
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  if (lybs->used == lybs->size) {
    lybs->size = lybs->size + 4;
    psVar4 = (size_t *)ly_realloc(lybs->written,(long)lybs->size * 8);
    lybs->written = psVar4;
    psVar4 = (size_t *)ly_realloc(lybs->position,(long)lybs->size * 8);
    lybs->position = psVar4;
    puVar5 = (uint8_t *)ly_realloc(lybs->inner_chunks,(long)lybs->size);
    lybs->inner_chunks = puVar5;
    if (((lybs->written == (size_t *)0x0) || (lybs->position == (size_t *)0x0)) ||
       (lybs->inner_chunks == (uint8_t *)0x0)) {
      ly_log(lybs->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyb_read_start_subtree")
      ;
      iVar3 = -1;
      goto LAB_00170bb3;
    }
  }
  uVar1 = *(undefined2 *)data;
  lybs->used = lybs->used + 1;
  meta_buf[0] = (uint8_t)uVar1;
  lybs->written[(long)lybs->used + -1] = (ulong)meta_buf[0];
  meta_buf[1] = (uint8_t)((ushort)uVar1 >> 8);
  lybs->inner_chunks[(long)lybs->used + -1] = meta_buf[1];
  lybs->position[(long)lybs->used + -1] = (ulong)(lybs->written[(long)lybs->used + -1] == 0xff);
  iVar3 = 2;
LAB_00170bb3:
  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar3;
}



int lyb_parse_model(char *data,lys_module **mod,lyb_state *lybs)

{
  long lVar1;
  int iVar2;
  lys_module *plVar3;
  char *pcVar4;
  undefined *puVar5;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  lys_module **mod_local;
  char *data_local;
  uint16_t rev;
  int ret;
  int r;
  char *mod_name;
  char mod_rev [11];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  mod_name = (char *)0x0;
  r = lyb_read_string(data,&mod_name,1,lybs);
  ret = ret + r;
  if (-1 < r) {
    r = lyb_read_number(&rev,2,2,data + r,lybs);
    ret = ret + r;
    if (-1 < r) {
      if (rev == 0) {
        plVar3 = ly_ctx_get_module(lybs->ctx,mod_name,(char *)0x0,0);
        *mod = plVar3;
      }
      else {
        sprintf(mod_rev,"%04u-%02u-%02u",(ulong)((rev >> 9) + 2000),
                (ulong)((int)(uint)rev >> 5 & 0xf),(ulong)(rev & 0x1f));
        plVar3 = ly_ctx_get_module(lybs->ctx,mod_name,mod_rev,0);
        *mod = plVar3;
      }
      if (lybs->ctx->data_clb != (ly_module_data_clb)0x0) {
        if (*mod == (lys_module *)0x0) {
          plVar3 = (*lybs->ctx->data_clb)(lybs->ctx,mod_name,(char *)0x0,0,lybs->ctx->data_clb_data)
          ;
          *mod = plVar3;
        }
        else if (((*mod)->field_0x40 & 0x80) == 0) {
          plVar3 = (*lybs->ctx->data_clb)(lybs->ctx,mod_name,(*mod)->ns,1,lybs->ctx->data_clb_data);
          *mod = plVar3;
        }
      }
      if (*mod == (lys_module *)0x0) {
        if (rev == 0) {
          pcVar4 = "";
          puVar5 = &DAT_00215e90;
        }
        else {
          pcVar4 = mod_rev;
          puVar5 = &DAT_00215e91;
        }
        ly_log(lybs->ctx,LY_LLERR,LY_EINVAL,
               "Invalid context for LYB data parsing, missing module \"%s%s%s\".",mod_name,puVar5,
               pcVar4);
      }
      else {
        if (((*mod)->field_0x40 & 0x80) != 0) {
          free(mod_name);
          iVar2 = ret;
          goto LAB_00170ee1;
        }
        if (rev == 0) {
          pcVar4 = "";
          puVar5 = &DAT_00215e90;
        }
        else {
          pcVar4 = mod_rev;
          puVar5 = &DAT_00215e91;
        }
        ly_log(lybs->ctx,LY_LLERR,LY_EINVAL,
               "Invalid context for LYB data parsing, module \"%s%s%s\" not implemented.",mod_name,
               puVar5,pcVar4);
      }
    }
  }
  free(mod_name);
  iVar2 = -1;
LAB_00170ee1:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



lyd_node * lyb_new_node(lys_node *schema)

{
  LYS_NODE LVar1;
  int iVar2;
  lys_node *schema_local;
  lyd_node *node;
  
  LVar1 = schema->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_00170f7e_caseD_20:
    node = (lyd_node *)calloc(0x40,1);
LAB_00170ff5:
    if (node == (lyd_node *)0x0) {
      ly_log(schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyb_new_node")
      ;
      node = (lyd_node *)0x0;
    }
    else {
      node->schema = schema;
      iVar2 = resolve_applies_when(schema,0,(lys_node *)0x0);
      if (iVar2 != 0) {
        node->field_0x9 = node->field_0x9 & 0xf1 | 0xc;
      }
      node->prev = node;
    }
  }
  else {
    if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
      if (LVar1 == LYS_ACTION) {
switchD_00170f7e_caseD_1:
        node = (lyd_node *)calloc(0x48,1);
        goto LAB_00170ff5;
      }
      if (LVar1 < (LYS_CONTAINER|LYS_ACTION)) {
        if (LVar1 == LYS_RPC) goto switchD_00170f7e_caseD_1;
        if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
          if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
            if ((LVar1 != LYS_UNKNOWN) && (true)) {
              switch(LVar1) {
              case LYS_CONTAINER:
              case LYS_LIST:
                goto switchD_00170f7e_caseD_1;
              case LYS_LEAF:
              case LYS_LEAFLIST:
                node = (lyd_node *)calloc(0x50,1);
                if (*(int *)&schema[1].ref == 9) {
                  node->validity = node->validity | 8;
                }
                goto LAB_00170ff5;
              case LYS_ANYXML:
                goto switchD_00170f7e_caseD_20;
              }
            }
          }
          else if (LVar1 == LYS_NOTIF) goto switchD_00170f7e_caseD_1;
        }
      }
    }
    node = (lyd_node *)0x0;
  }
  return node;
}



int lyb_parse_anydata(lyd_node *node,char *data,lyb_state *lybs)

{
  int iVar1;
  char *pcVar2;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  char *data_local;
  lyd_node *node_local;
  int ret;
  int r;
  char *str;
  lyd_node_anydata *any;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  str = (char *)0x0;
  any = (lyd_node_anydata *)node;
  iVar1 = lyb_read(data,&node->field_0x34,4,lybs);
  if (iVar1 < 0) {
    ret = -1;
  }
  else if (any->value_type == LYD_ANYDATA_DATATREE) {
    ly_log(node->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
           ,0x15a);
    ret = -1;
  }
  else {
    if (any->value_type == LYD_ANYDATA_LYB) {
      r = lyb_read_string(data + iVar1,&(any->value).str,0,lybs);
      if (r < 0) {
        ret = -1;
        goto LAB_001711fa;
      }
    }
    else {
      r = lyb_read_string(data + iVar1,&str,0,lybs);
      if (r < 0) {
        ret = -1;
        goto LAB_001711fa;
      }
      pcVar2 = lydict_insert_zc(node->schema->module->ctx,str);
      (any->value).str = pcVar2;
    }
    ret = iVar1 + r;
  }
LAB_001711fa:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_parse_val_1(lys_type *type,LY_DATA_TYPE value_type,uint8_t value_flags,char *data,
                   char **value_str,lyd_val *value,lyb_state *lybs)

{
  int iVar1;
  char *pcVar2;
  void *pvVar3;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  lyd_val *value_local;
  char **value_str_local;
  char *data_local;
  uint8_t value_flags_local;
  LY_DATA_TYPE value_type_local;
  lys_type *type_local;
  uint8_t byte;
  int ret;
  int r;
  char *str;
  uint64_t num;
  size_t i;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  str = (char *)0x0;
  if ((value_flags & 2) != 0) {
    ret = lyb_read_string(data,&str,0,lybs);
    iVar1 = ret;
    if (-1 < ret) {
      pcVar2 = lydict_insert_zc(lybs->ctx,str);
      *value_str = pcVar2;
      iVar1 = ret;
    }
    goto LAB_001716b3;
  }
  type_local = type;
  if (value_type == LY_TYPE_BITS) {
    for (; type_local->base == LY_TYPE_LEAFREF; type_local = &((type_local->info).lref.target)->type
        ) {
    }
    for (; (type_local->info).bits.count == 0; type_local = &type_local->der->type) {
    }
  }
  else if (value_type == LY_TYPE_ENUM) {
    for (; type_local->base == LY_TYPE_LEAFREF; type_local = &((type_local->info).lref.target)->type
        ) {
    }
    for (; (type_local->info).bits.count == 0; type_local = &type_local->der->type) {
    }
  }
  if (false) {
switchD_00171357_caseD_0:
    iVar1 = -1;
  }
  else {
    switch(value_type) {
    default:
      goto switchD_00171357_caseD_0;
    case LY_TYPE_BINARY:
    case LY_TYPE_STRING:
    case LY_TYPE_UNKNOWN:
      ret = lyb_read_string(data,&str,0,lybs);
      iVar1 = ret;
      if (-1 < ret) {
        pcVar2 = lydict_insert_zc(lybs->ctx,str);
        value->binary = pcVar2;
        iVar1 = ret;
      }
      break;
    case LY_TYPE_BITS:
      pvVar3 = calloc((ulong)(type_local->info).bits.count,8);
      value->ptr = pvVar3;
      if (value->binary == (char *)0x0) {
        ly_log(lybs->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyb_parse_val_1");
        iVar1 = -1;
      }
      else {
        ret = 0;
        for (i = 0; iVar1 = ret, i < (type_local->info).bits.count; i = i + 1) {
          if ((i & 7) == 0) {
            r = lyb_read(data + ret,&byte,1,lybs);
            ret = ret + r;
            if (r < 0) {
              iVar1 = -1;
              break;
            }
          }
          if (((int)(uint)byte >> ((byte)i & 7) & 1U) != 0) {
            *(lys_type_bit **)(value->binary + i * 8) = (type_local->info).bits.bit + i;
          }
        }
      }
      break;
    case LY_TYPE_BOOL:
      ret = lyb_read(data,&byte,1,lybs);
      iVar1 = ret;
      if ((0 < ret) && (byte != '\0')) {
        value->bln = '\x01';
      }
      break;
    case LY_TYPE_DEC64:
    case LY_TYPE_INT64:
    case LY_TYPE_UINT64:
      ret = lyb_read_number(value,8,8,data,lybs);
      iVar1 = ret;
      break;
    case LY_TYPE_EMPTY:
      ret = 0;
      iVar1 = ret;
      break;
    case LY_TYPE_ENUM:
      num = 0;
      ret = lyb_read_enum(&num,(type_local->info).bits.count,data,lybs);
      iVar1 = ret;
      if (0 < ret) {
        if ((type_local->info).bits.count <= num) {
                    // WARNING: Subroutine does not return
          __assert_fail("num < type->info.enums.count",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
                        ,0x1c3,"lyb_parse_val_1");
        }
        value->binary = (char *)((type_local->info).bits.bit + num);
      }
      break;
    case LY_TYPE_IDENT:
    case LY_TYPE_INST:
    case LY_TYPE_UNION:
      ret = lyb_read_string(data,&str,0,lybs);
      iVar1 = ret;
      if (-1 < ret) {
        pcVar2 = lydict_insert_zc(lybs->ctx,str);
        *value_str = pcVar2;
        iVar1 = ret;
      }
      break;
    case LY_TYPE_INT8:
    case LY_TYPE_UINT8:
      ret = lyb_read_number(value,1,1,data,lybs);
      iVar1 = ret;
      break;
    case LY_TYPE_INT16:
    case LY_TYPE_UINT16:
      ret = lyb_read_number(value,2,2,data,lybs);
      iVar1 = ret;
      break;
    case LY_TYPE_INT32:
    case LY_TYPE_UINT32:
      ret = lyb_read_number(value,4,4,data,lybs);
      iVar1 = ret;
    }
  }
LAB_001716b3:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_parse_val_2(lys_type *type,lyd_node_leaf_list *leaf,lyd_attr *attr,unres_data *unres)

{
  long lVar1;
  int iVar2;
  lys_type *plVar3;
  lys_ident *plVar4;
  size_t sVar5;
  char *pcVar6;
  long lVar7;
  undefined *puVar8;
  uint uVar9;
  long in_FS_OFFSET;
  unres_data *unres_local;
  lyd_attr *attr_local;
  lyd_node_leaf_list *leaf_local;
  lys_type *type_local;
  uint8_t dig;
  uint32_t i;
  uint32_t str_len;
  LY_DATA_TYPE value_type;
  ly_ctx *ctx;
  lys_module *mod;
  lys_type *rtype;
  char *str;
  int64_t frac;
  uint8_t *value_flags;
  char **value_str;
  lyd_val *value;
  int64_t num;
  char num_str [22];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  rtype = (lys_type *)0x0;
  if (leaf == (lyd_node_leaf_list *)0x0) {
    ctx = attr->annotation->module->ctx;
    mod = lys_main_module(attr->annotation->module);
    value = &attr->value;
    value_str = &attr->value_str;
    value_flags = &attr->value_flags;
    value_type = attr->value_type;
  }
  else {
    ctx = leaf->schema->module->ctx;
    mod = lys_node_module(leaf->schema);
    value = &leaf->value;
    value_str = &leaf->value_str;
    value_flags = &leaf->value_flags;
    value_type = leaf->value_type;
  }
  if ((*value_flags & 2) != 0) {
    *value_flags = *value_flags & 0xfd;
    if (leaf == (lyd_node_leaf_list *)0x0) {
      uVar9 = 0;
    }
    else {
      uVar9 = (uint)(leaf->field_0x9 & 1);
    }
    plVar3 = lyp_parse_value(type,value_str,(lyxml_elem *)0x0,leaf,attr,(lys_module *)0x0,1,uVar9,1)
    ;
    if (plVar3 == (lys_type *)0x0) {
      iVar2 = -1;
    }
    else {
      if ((*value_flags & 2) == 0) {
        ly_log(ctx,LY_LLWRN,LY_SUCCESS,
               "Value \"%s\" was stored as a user type, but it is not in the current context.",
               value_str);
      }
      iVar2 = 0;
    }
    goto LAB_001721af;
  }
  if ((((type->base == LY_TYPE_LEAFREF) || (type->base == LY_TYPE_INST)) ||
      ((type->base == LY_TYPE_UNION && ((type->info).uni.has_ptr_type != 0)))) &&
     (((value_type == LY_TYPE_INST || (value_type == LY_TYPE_IDENT)) ||
      (value_type == LY_TYPE_UNION)))) {
LAB_001720a5:
    if (*value_str == (char *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("*value_str",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
                    ,0x295,"lyb_parse_val_2");
    }
    if (attr != (lyd_attr *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
             ,0x299);
      iVar2 = -1;
      goto LAB_001721af;
    }
    if (type->base == LY_TYPE_INST) {
      iVar2 = unres_data_add(unres,(lyd_node *)leaf,UNRES_INSTID);
      if (iVar2 != 0) {
        iVar2 = -1;
        goto LAB_001721af;
      }
    }
    else if (type->base == LY_TYPE_LEAFREF) {
      iVar2 = unres_data_add(unres,(lyd_node *)leaf,UNRES_LEAFREF);
      if (iVar2 != 0) {
        iVar2 = -1;
        goto LAB_001721af;
      }
    }
    else {
      iVar2 = unres_data_add(unres,(lyd_node *)leaf,UNRES_UNION);
      if (iVar2 != 0) {
        iVar2 = -1;
        goto LAB_001721af;
      }
    }
  }
  else {
    plVar3 = type;
    if (value_type == LY_TYPE_BITS) {
      while (rtype = plVar3, rtype->base == LY_TYPE_LEAFREF) {
        plVar3 = &((rtype->info).lref.target)->type;
      }
      for (; (rtype->info).bits.count == 0; rtype = &rtype->der->type) {
      }
    }
    else {
      plVar3 = type;
      if (value_type == LY_TYPE_DEC64) {
        while (rtype = plVar3, rtype->base == LY_TYPE_LEAFREF) {
          plVar3 = &((type->info).lref.target)->type;
        }
      }
    }
    if (false) {
switchD_001719c5_caseD_0:
      iVar2 = -1;
      goto LAB_001721af;
    }
    switch(value_type) {
    default:
      goto switchD_001719c5_caseD_0;
    case LY_TYPE_BINARY:
    case LY_TYPE_STRING:
    case LY_TYPE_UNKNOWN:
      *value_str = (char *)*value;
      break;
    case LY_TYPE_BITS:
      str = (char *)malloc(1);
      if (str == (char *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyb_parse_val_2");
        iVar2 = -1;
        goto LAB_001721af;
      }
      *str = '\0';
      str_len = 0;
      for (i = 0; i < (rtype->info).bits.count; i = i + 1) {
        if (*(long *)(value->binary + (ulong)i * 8) != 0) {
          sVar5 = strlen((char *)**(undefined8 **)(value->binary + (ulong)i * 8));
          str = (char *)ly_realloc(str,sVar5 + str_len + (ulong)(str_len != 0) + 1);
          if (str == (char *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyb_parse_val_2");
            iVar2 = -1;
            goto LAB_001721af;
          }
          if (str_len == 0) {
            puVar8 = &DAT_00215e90;
          }
          else {
            puVar8 = &DAT_00216064;
          }
          iVar2 = sprintf(str + str_len,"%s%s",puVar8,
                          **(undefined8 **)(value->binary + (ulong)i * 8));
          str_len = str_len + iVar2;
        }
      }
      pcVar6 = lydict_insert_zc(ctx,str);
      *value_str = pcVar6;
      break;
    case LY_TYPE_BOOL:
      if (value->bln == '\0') {
        pcVar6 = "false";
      }
      else {
        pcVar6 = "true";
      }
      pcVar6 = lydict_insert(ctx,pcVar6,0);
      *value_str = pcVar6;
      break;
    case LY_TYPE_DEC64:
      lVar7 = value->dec64 / (long)(rtype->info).dec64.div;
      frac = value->dec64 % (long)(rtype->info).dec64.div;
      dig = (rtype->info).dec64.dig;
      if (frac < 0) {
        frac = -frac;
      }
      for (; (1 < dig && (frac % 10 == 0)); frac = frac / 10) {
        dig = dig + 0xff;
      }
      if ((lVar7 == 0) && (value->dec64 < 0)) {
        puVar8 = &DAT_00216084;
      }
      else {
        puVar8 = &DAT_00215e90;
      }
      sprintf(num_str,"%s%ld.%.*ld",puVar8,lVar7,(ulong)dig,frac);
      pcVar6 = lydict_insert(ctx,num_str,0);
      *value_str = pcVar6;
      break;
    case LY_TYPE_EMPTY:
      pcVar6 = lydict_insert(ctx,"",0);
      *value_str = pcVar6;
      break;
    case LY_TYPE_ENUM:
      pcVar6 = lydict_insert(ctx,value->enm->name,0);
      *value_str = pcVar6;
      break;
    case LY_TYPE_IDENT:
      if (leaf == (lyd_node_leaf_list *)0x0) {
        uVar9 = 0;
      }
      else {
        uVar9 = (uint)(leaf->field_0x9 & 1);
      }
      plVar4 = resolve_identref(type,*value_str,(lyd_node *)leaf,mod,uVar9);
      value->ident = plVar4;
      if (value->binary == (char *)0x0) {
        iVar2 = -1;
        goto LAB_001721af;
      }
      break;
    case LY_TYPE_INST:
      value->binary = (char *)0x0;
      break;
    case LY_TYPE_UNION:
      if (attr != (lyd_attr *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
               ,0x250);
        iVar2 = -1;
        goto LAB_001721af;
      }
      iVar2 = resolve_union(leaf,type,1,2,(lys_type **)0x0);
      if (iVar2 != 0) {
        iVar2 = -1;
        goto LAB_001721af;
      }
      break;
    case LY_TYPE_INT8:
      sprintf(num_str,"%d",(ulong)(uint)(int)value->bln);
      pcVar6 = lydict_insert(ctx,num_str,0);
      *value_str = pcVar6;
      break;
    case LY_TYPE_UINT8:
      sprintf(num_str,"%u",(ulong)value->uint8);
      pcVar6 = lydict_insert(ctx,num_str,0);
      *value_str = pcVar6;
      break;
    case LY_TYPE_INT16:
      sprintf(num_str,"%d",(ulong)(uint)(int)value->int16);
      pcVar6 = lydict_insert(ctx,num_str,0);
      *value_str = pcVar6;
      break;
    case LY_TYPE_UINT16:
      sprintf(num_str,"%u",(ulong)value->uint16);
      pcVar6 = lydict_insert(ctx,num_str,0);
      *value_str = pcVar6;
      break;
    case LY_TYPE_INT32:
      sprintf(num_str,"%d",(ulong)value->uint32);
      pcVar6 = lydict_insert(ctx,num_str,0);
      *value_str = pcVar6;
      break;
    case LY_TYPE_UINT32:
      sprintf(num_str,"%u",(ulong)value->uint32);
      pcVar6 = lydict_insert(ctx,num_str,0);
      *value_str = pcVar6;
      break;
    case LY_TYPE_INT64:
      sprintf(num_str,"%ld",value->binary);
      pcVar6 = lydict_insert(ctx,num_str,0);
      *value_str = pcVar6;
      break;
    case LY_TYPE_UINT64:
      sprintf(num_str,"%lu",value->binary);
      pcVar6 = lydict_insert(ctx,num_str,0);
      *value_str = pcVar6;
    }
    if (((type->base == LY_TYPE_LEAFREF) || (type->base == LY_TYPE_INST)) ||
       ((type->base == LY_TYPE_UNION && ((type->info).uni.has_ptr_type != 0)))) goto LAB_001720a5;
  }
  iVar2 = 0;
LAB_001721af:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lyb_parse_value(lys_type *type,lyd_node_leaf_list *leaf,lyd_attr *attr,char *data,
                   unres_data *unres,lyb_state *lybs)

{
  int iVar1;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  unres_data *unres_local;
  char *data_local;
  lyd_attr *attr_local;
  lyd_node_leaf_list *leaf_local;
  lys_type *type_local;
  uint8_t start_byte;
  int ret;
  int r;
  char **value_str;
  lyd_val *value;
  LY_DATA_TYPE *value_type;
  uint8_t *value_flags;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  if (((leaf == (lyd_node_leaf_list *)0x0) && (attr == (lyd_attr *)0x0)) ||
     ((leaf != (lyd_node_leaf_list *)0x0 && (attr != (lyd_attr *)0x0)))) {
                    // WARNING: Subroutine does not return
    __assert_fail("(leaf || attr) && (!leaf || !attr)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
                  ,699,"lyb_parse_value");
  }
  if (leaf == (lyd_node_leaf_list *)0x0) {
    value_str = &attr->value_str;
    value = &attr->value;
    value_type = &attr->value_type;
    value_flags = &attr->value_flags;
  }
  else {
    value_str = &leaf->value_str;
    value = &leaf->value;
    value_type = &leaf->value_type;
    value_flags = &leaf->value_flags;
  }
  r = lyb_read(data,&start_byte,1,lybs);
  ret = ret + r;
  if (r < 0) {
    iVar1 = -1;
  }
  else {
    *value_type = start_byte & 0x1f;
    if ((char)start_byte < '\0') {
      if (leaf == (lyd_node_leaf_list *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("leaf",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
                      ,0x2d0,"lyb_parse_value");
      }
      leaf->field_0x9 = leaf->field_0x9 | 1;
    }
    if ((start_byte & 0x40) != 0) {
      *value_flags = *value_flags | 2;
    }
    if ((start_byte & 0x20) != 0) {
      *value_flags = *value_flags | 1;
    }
    r = lyb_parse_val_1(type,*value_type,*value_flags,data + r,value_str,value,lybs);
    ret = ret + r;
    if (r < 0) {
      iVar1 = -1;
    }
    else {
      if ((type->base == LY_TYPE_UNION) && ((*value_flags & 2) == 0)) {
        if (*value_type != LY_TYPE_STRING) {
                    // WARNING: Subroutine does not return
          __assert_fail("*value_type == LY_TYPE_STRING",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
                        ,0x2df,"lyb_parse_value");
        }
        *value_str = (char *)*value;
        value->binary = (char *)0x0;
        *value_type = LY_TYPE_UNION;
      }
      r = lyb_parse_val_2(type,leaf,attr,unres);
      ret = ret + r;
      iVar1 = ret;
      if (r < 0) {
        iVar1 = -1;
      }
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_parse_attr_name(lys_module *mod,char *data,lys_ext_instance_complex **ext,int options,
                       lyb_state *lybs)

{
  int iVar1;
  int iVar2;
  int iVar3;
  lys_ext_instance_complex *plVar4;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  int options_local;
  lys_ext_instance_complex **ext_local;
  char *data_local;
  lys_module *mod_local;
  int pos;
  int i;
  int k;
  int ret;
  int r;
  int j;
  char *attr_name;
  lys_submodule *submod;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  submod = (lys_submodule *)0x0;
  attr_name = (char *)0x0;
  iVar1 = lyb_read_string(data,&attr_name,1,lybs);
  if (iVar1 < 0) {
    iVar1 = -1;
  }
  else {
    pos = -1;
    i = 0;
    while( true ) {
      if (((int)(uint)mod->ext_size <= i) ||
         (iVar2 = lys_ext_instance_presence
                            ((*(mod->ctx->models).list)->extensions,mod->ext + i,
                             mod->ext_size - (char)i), iVar2 == -1)) goto LAB_001725df;
      iVar3 = ly_strequal_(mod->ext[iVar2 + i]->arg_value,attr_name);
      if (iVar3 != 0) break;
      i = iVar2 + i + 1;
    }
    pos = iVar2 + i;
LAB_001725df:
    if (pos == -1) {
      for (k = 0; k < (int)(uint)mod->inc_size; k = k + 1) {
        submod = mod->inc[k].submodule;
        i = 0;
        while( true ) {
          if (((int)(uint)submod->ext_size <= i) ||
             (iVar2 = lys_ext_instance_presence
                                ((*(mod->ctx->models).list)->extensions,submod->ext + i,
                                 submod->ext_size - (char)i), iVar2 == -1)) goto LAB_001726e7;
          iVar3 = ly_strequal_(submod->ext[iVar2 + i]->arg_value,attr_name);
          if (iVar3 != 0) break;
          i = iVar2 + i + 1;
        }
        pos = iVar2 + i;
LAB_001726e7:
      }
    }
    if (pos == -1) {
      *ext = (lys_ext_instance_complex *)0x0;
    }
    else {
      if (submod == (lys_submodule *)0x0) {
        plVar4 = (lys_ext_instance_complex *)mod->ext[pos];
      }
      else {
        plVar4 = (lys_ext_instance_complex *)submod->ext[pos];
      }
      *ext = plVar4;
    }
    if ((*ext == (lys_ext_instance_complex *)0x0) && ((options & 0x200U) != 0)) {
      ly_vlog(mod->ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "Failed to find annotation \"%s\" in \"%s\".",attr_name,mod->name);
      free(attr_name);
      iVar1 = -1;
    }
    else {
      free(attr_name);
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_parse_attributes(lyd_node *node,char *data,int options,unres_data *unres,lyb_state *lybs)

{
  int iVar1;
  long lVar2;
  lyd_attr *plVar3;
  char *pcVar4;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  unres_data *unres_local;
  int options_local;
  char *data_local;
  lyd_node *node_local;
  uint8_t count;
  uint8_t i;
  int ret;
  int r;
  lys_module *mod;
  lys_ext_instance_complex *ext;
  lyd_attr *attr;
  lys_type **type;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  count = '\0';
  attr = (lyd_attr *)0x0;
  r = lyb_read(data,&count,1,lybs);
  ret = ret + r;
  if (r < 0) {
LAB_00172b70:
    lyd_free_attr(lybs->ctx,node,node->attr,1);
    iVar1 = -1;
  }
  else {
    data_local = data + r;
    for (i = '\0'; iVar1 = ret, i < count; i = i + '\x01') {
      r = lyb_read_start_subtree(data_local,lybs);
      ret = ret + r;
      if (r < 0) goto LAB_00172b70;
      lVar2 = (long)r;
      r = lyb_parse_model(data_local + lVar2,&mod,lybs);
      ret = ret + r;
      if (r < 0) goto LAB_00172b70;
      data_local = data_local + lVar2 + r;
      if (mod != (lys_module *)0x0) {
        r = lyb_parse_attr_name(mod,data_local,&ext,options,lybs);
        ret = ret + r;
        if (r < 0) goto LAB_00172b70;
        data_local = data_local + r;
      }
      if ((mod == (lys_module *)0x0) || (ext == (lys_ext_instance_complex *)0x0)) {
        do {
          r = lyb_read(data_local,(uint8_t *)0x0,lybs->written[(long)lybs->used + -1],lybs);
          ret = ret + r;
          if (r < 0) goto LAB_00172b70;
          data_local = data_local + r;
        } while (lybs->written[(long)lybs->used + -1] != 0);
      }
      else {
        if (attr == (lyd_attr *)0x0) {
          if (node->attr != (lyd_attr *)0x0) {
                    // WARNING: Subroutine does not return
            __assert_fail("!node->attr",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
                          ,0x34e,"lyb_parse_attributes");
          }
          attr = (lyd_attr *)calloc(1,0x38);
          if (attr == (lyd_attr *)0x0) {
            ly_log(lybs->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "lyb_parse_attributes");
            goto LAB_00172b70;
          }
          node->attr = attr;
        }
        else {
          plVar3 = (lyd_attr *)calloc(1,0x38);
          attr->next = plVar3;
          if (attr->next == (lyd_attr *)0x0) {
            ly_log(lybs->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "lyb_parse_attributes");
            goto LAB_00172b70;
          }
          attr = attr->next;
        }
        attr->annotation = ext;
        pcVar4 = lydict_insert(lybs->ctx,attr->annotation->arg_value,0);
        attr->name = pcVar4;
        type = (lys_type **)
               lys_ext_complex_get_substmt(LY_STMT_TYPE,attr->annotation,(lyext_substmt **)0x0);
        if ((type == (lys_type **)0x0) || (*type == (lys_type *)0x0)) goto LAB_00172b70;
        r = lyb_parse_value(*type,(lyd_node_leaf_list *)0x0,attr,data_local,unres,lybs);
        ret = ret + r;
        if (r < 0) goto LAB_00172b70;
        data_local = data_local + r;
      }
      lyb_read_stop_subtree(lybs);
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_is_schema_hash_match(lys_node *sibling,uint8_t *hash,uint8_t hash_count)

{
  uint8_t uVar1;
  uint8_t hash_count_local;
  uint8_t *hash_local;
  lys_node *sibling_local;
  uint8_t i;
  uint8_t sibling_hash;
  
  i = '\0';
  while( true ) {
    if (hash_count <= i) {
      return 1;
    }
    uVar1 = lyb_hash(sibling,i);
    if (uVar1 != hash[i]) break;
    i = i + '\x01';
  }
  return 0;
}



int lyb_parse_schema_hash
              (lys_node *sparent,lys_module *mod,char *data,char *yang_data_name,int options,
              lys_node **snode,lyb_state *lybs)

{
  long lVar1;
  int iVar2;
  size_t sVar3;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  lys_node **snode_local;
  int options_local;
  char *yang_data_name_local;
  char *data_local;
  lys_module *mod_local;
  lys_node *sparent_local;
  uint8_t i;
  uint8_t j;
  int ret;
  int r;
  lys_node *sibling;
  uint8_t hash [7];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (((sparent == (lys_node *)0x0) && (mod == (lys_module *)0x0)) ||
     ((sparent != (lys_node *)0x0 && (mod != (lys_module *)0x0)))) {
                    // WARNING: Subroutine does not return
    __assert_fail("(sparent || mod) && (!sparent || !mod)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
                  ,0x390,"lyb_parse_schema_hash");
  }
  ret = lyb_read(data,hash,1,lybs);
  if (ret < 0) {
    ret = -1;
    goto LAB_00173004;
  }
  data_local = data + ret;
  for (i = '\0'; (0x80 >> (i & 0x1f) & (uint)hash[0]) == 0; i = i + '\x01') {
    if (8 < i) {
      ret = -1;
      goto LAB_00173004;
    }
  }
  hash[(int)(uint)i] = hash[0];
  for (j = i; j != '\0'; j = j + 0xff) {
    iVar2 = lyb_read(data_local,hash + (int)(j - 1),1,lybs);
    ret = ret + iVar2;
    if (iVar2 < 0) {
      ret = -1;
      goto LAB_00173004;
    }
    data_local = data_local + iVar2;
    if (((uint)hash[(int)(j - 1)] & 0x80 >> (j - 1 & 0x1f)) == 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("hash[j - 1] & (LYB_HASH_COLLISION_ID >> (j - 1))",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
                    ,0x3a6,"lyb_parse_schema_hash");
    }
    if (((uint)hash[(int)(j - 1)] & 0x7f << (9 - j & 0x1f)) != 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("!(hash[j - 1] & (LYB_HASH_MASK << (LYB_HASH_BITS - (j - 1))))",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
                    ,0x3a8,"lyb_parse_schema_hash");
    }
  }
  sparent_local = sparent;
  if ((((options & 0x1000000U) == 0) || (yang_data_name == (char *)0x0)) ||
     (mod == (lys_module *)0x0)) {
LAB_00172e5c:
    sibling = sparent_local;
    if ((sparent_local != (lys_node *)0x0) && ((sparent_local->nodetype & 0x4100) != LYS_UNKNOWN)) {
      sibling = (lys_node *)0x0;
      do {
        sibling = lys_getnext(sibling,sparent_local,(lys_module *)0x0,8);
        if ((sibling == (lys_node *)0x0) ||
           ((sibling->nodetype == LYS_INPUT && ((options & 0x10U) != 0)))) break;
      } while ((sibling->nodetype != LYS_OUTPUT) || ((options & 0x20U) == 0));
      if (sibling == (lys_node *)0x0) {
        sibling = (lys_node *)0x0;
        goto LAB_00172f62;
      }
    }
    sparent_local = sibling;
    sibling = (lys_node *)0x0;
    do {
      sibling = lys_getnext(sibling,sparent_local,mod,0);
      if (sibling == (lys_node *)0x0) break;
      iVar2 = lyb_has_schema_model(sibling,lybs->models,lybs->mod_count);
    } while ((iVar2 == 0) || (iVar2 = lyb_is_schema_hash_match(sibling,hash,i + '\x01'), iVar2 == 0)
            );
  }
  else {
    sVar3 = strlen(yang_data_name);
    sparent_local = lyp_get_yang_data_template(mod,yang_data_name,(int)sVar3);
    if (sparent_local != (lys_node *)0x0) goto LAB_00172e5c;
    sibling = (lys_node *)0x0;
  }
LAB_00172f62:
  *snode = sibling;
  if ((sibling == (lys_node *)0x0) && ((options & 0x200U) != 0)) {
    if (mod == (lys_module *)0x0) {
      ly_vlog(lybs->ctx,LYE_SPEC,LY_VLOG_LYS,sparent_local,
              "Failed to find matching hash for a child of \"%s\".",sparent_local->name);
    }
    else {
      ly_vlog(lybs->ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "Failed to find matching hash for a top-level node from \"%s\".",mod->name);
    }
    ret = -1;
  }
LAB_00173004:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_skip_subtree(char *data,lyb_state *lybs)

{
  int iVar1;
  int iVar2;
  lyb_state *lybs_local;
  char *data_local;
  int ret;
  int r;
  
  ret = 0;
  data_local = data;
  do {
    iVar1 = (uint)lybs->inner_chunks[(long)lybs->used + -1] * 2;
    iVar2 = lyb_read(data_local + iVar1,(uint8_t *)0x0,lybs->written[(long)lybs->used + -1],lybs);
    ret = ret + iVar1 + iVar2;
    if (iVar2 < 0) {
      return -1;
    }
    data_local = data_local + iVar1 + iVar2;
  } while (lybs->written[(long)lybs->used + -1] != 0);
  return ret;
}



int lyb_parse_subtree(char *data,lyd_node *parent,lyd_node **first_sibling,char *yang_data_name,
                     int options,unres_data *unres,lyb_state *lybs)

{
  char *data_00;
  LYS_NODE LVar1;
  lys_node *plVar2;
  long lVar3;
  int iVar4;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  unres_data *unres_local;
  int options_local;
  char *yang_data_name_local;
  lyd_node **first_sibling_local;
  lyd_node *parent_local;
  char *data_local;
  int r;
  int ret;
  lys_module *mod;
  lys_node *snode;
  lyd_node *node;
  lyd_node *iter;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  node = (lyd_node *)0x0;
  if (((parent == (lyd_node *)0x0) || (first_sibling != (lyd_node **)0x0)) &&
     ((parent != (lyd_node *)0x0 || (first_sibling == (lyd_node **)0x0)))) {
                    // WARNING: Subroutine does not return
    __assert_fail("(parent && !first_sibling) || (!parent && first_sibling)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_lyb.c"
                  ,0x3fe,"lyb_parse_subtree");
  }
  ret = lyb_read_start_subtree(data,lybs);
  if (-1 < ret) {
    data_local = data + ret;
    if (parent == (lyd_node *)0x0) {
      r = lyb_parse_model(data_local,&mod,lybs);
      ret = ret + r;
      if (r < 0) goto LAB_00173624;
      data_local = data_local + r;
      if (mod != (lys_module *)0x0) {
        r = lyb_parse_schema_hash((lys_node *)0x0,mod,data_local,yang_data_name,options,&snode,lybs)
        ;
      }
    }
    else {
      mod = lyd_node_module(parent);
      r = lyb_parse_schema_hash
                    (parent->schema,(lys_module *)0x0,data_local,(char *)0x0,options,&snode,lybs);
    }
    if (-1 < r) {
      data_00 = data_local + r;
      if ((mod == (lys_module *)0x0) || (snode == (lys_node *)0x0)) {
        iVar4 = lyb_skip_subtree(data_00,lybs);
        ret = ret + r + iVar4;
        if (iVar4 < 0) goto LAB_00173624;
LAB_001735f7:
        lyb_read_stop_subtree(lybs);
        goto LAB_00173654;
      }
      node = lyb_new_node(snode);
      if (node != (lyd_node *)0x0) {
        iVar4 = lyb_parse_attributes(node,data_00,options,unres,lybs);
        ret = ret + r + iVar4;
        if (-1 < iVar4) {
          data_local = data_00 + iVar4;
          LVar1 = snode->nodetype;
          if (LVar1 == LYS_ANYDATA) {
switchD_0017338d_caseD_20:
            iVar4 = lyb_parse_anydata(node,data_local,lybs);
            ret = ret + iVar4;
            if (-1 < iVar4) {
              data_local = data_local + iVar4;
              goto LAB_00173428;
            }
          }
          else if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
            if (LVar1 == LYS_ACTION) goto LAB_00173428;
            if (LYS_ACTION < LVar1) goto LAB_00173624;
            if (LVar1 == LYS_RPC) goto LAB_00173428;
            if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
              if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
                if ((LVar1 != LYS_UNKNOWN) && (true)) {
                  switch(LVar1) {
                  case LYS_CONTAINER:
                  case LYS_LIST:
LAB_00173428:
                    if (parent == (lyd_node *)0x0) {
                      if (*first_sibling == (lyd_node *)0x0) {
                        *first_sibling = node;
                      }
                      else {
                        (*first_sibling)->prev->next = node;
                        node->prev = (*first_sibling)->prev;
                        (*first_sibling)->prev = node;
                      }
                    }
                    else {
                      if (parent->child == (lyd_node *)0x0) {
                        parent->child = node;
                      }
                      else {
                        parent->child->prev->next = node;
                        node->prev = parent->child->prev;
                        parent->child->prev = node;
                      }
                      node->parent = parent;
                    }
                    while (lybs->written[(long)lybs->used + -1] != 0) {
                      iVar4 = lyb_parse_subtree(data_local,node,(lyd_node **)0x0,(char *)0x0,options
                                                ,unres,lybs);
                      ret = ret + iVar4;
                      if (iVar4 < 0) goto LAB_00173624;
                      data_local = data_local + iVar4;
                    }
                    if ((node->schema->nodetype == LYS_CONTAINER) &&
                       (plVar2 = node->schema, lVar3._0_2_ = plVar2[1].flags,
                       lVar3._2_1_ = plVar2[1].ext_size, lVar3._3_1_ = plVar2[1].iffeature_size,
                       lVar3._4_1_ = plVar2[1].padding[0], lVar3._5_1_ = plVar2[1].padding[1],
                       lVar3._6_1_ = plVar2[1].padding[2], lVar3._7_1_ = plVar2[1].padding[3],
                       lVar3 == 0)) {
                      for (iter = node->child;
                          (iter != (lyd_node *)0x0 && ((iter->field_0x9 & 1) != 0));
                          iter = iter->next) {
                      }
                      if (iter == (lyd_node *)0x0) {
                        node->field_0x9 = node->field_0x9 | 1;
                      }
                    }
                    if ((node->schema->nodetype != LYS_LIST) || (node->schema->padding[2] == '\0'))
                    {
                      lyd_hash(node);
                      lyd_insert_hash(node);
                    }
                    goto LAB_001735f7;
                  case LYS_LEAF:
                  case LYS_LEAFLIST:
                    iVar4 = lyb_parse_value((lys_type *)&node->schema[1].ref,
                                            (lyd_node_leaf_list *)node,(lyd_attr *)0x0,data_local,
                                            unres,lybs);
                    ret = ret + iVar4;
                    if (-1 < iVar4) {
                      data_local = data_local + iVar4;
                      goto LAB_00173428;
                    }
                    break;
                  case LYS_ANYXML:
                    goto switchD_0017338d_caseD_20;
                  }
                }
              }
              else if (LVar1 == LYS_NOTIF) goto LAB_00173428;
            }
          }
        }
      }
    }
  }
LAB_00173624:
  lyd_free(node);
  if ((first_sibling != (lyd_node **)0x0) && (node == *first_sibling)) {
    *first_sibling = (lyd_node *)0x0;
  }
  ret = -1;
LAB_00173654:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_parse_data_models(char *data,lyb_state *lybs)

{
  int iVar1;
  lys_module **pplVar2;
  lyb_state *lybs_local;
  char *data_local;
  int i;
  int ret;
  int r;
  
  ret = lyb_read_number(&lybs->mod_count,4,2,data,lybs);
  if (ret < 0) {
    ret = -1;
  }
  else {
    data_local = data + ret;
    if (lybs->mod_count != 0) {
      pplVar2 = (lys_module **)malloc((long)lybs->mod_count << 3);
      lybs->models = pplVar2;
      if (lybs->models == (lys_module **)0x0) {
        ly_log(lybs->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyb_parse_data_models"
              );
        ret = -1;
      }
      else {
        for (i = 0; i < lybs->mod_count; i = i + 1) {
          iVar1 = lyb_parse_model(data_local,lybs->models + i,lybs);
          ret = ret + iVar1;
          if (iVar1 < 0) {
            return -1;
          }
          data_local = data_local + iVar1;
        }
      }
    }
  }
  return ret;
}



// WARNING: Variable defined which should be unmapped: lybs_local
// WARNING: Variable defined which should be unmapped: data_local

int lyb_parse_magic_number(char *data,lyb_state *lybs)

{
  char *data_00;
  int iVar1;
  long lVar2;
  undefined8 in_R9;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  char *data_local;
  char magic_byte;
  int ret;
  int r;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  magic_byte = '\0';
  r = lyb_read(data,(uint8_t *)&magic_byte,1,lybs);
  ret = ret + r;
  if (r < 0) {
    iVar1 = -1;
  }
  else {
    data_00 = data + r;
    if (magic_byte == 'l') {
      r = lyb_read(data_00,(uint8_t *)&magic_byte,1,lybs);
      ret = ret + r;
      if (r < 0) {
        iVar1 = -1;
      }
      else {
        lVar2 = (long)r;
        if (magic_byte == 'y') {
          r = lyb_read(data_00 + lVar2,(uint8_t *)&magic_byte,1,lybs);
          ret = ret + r;
          if (r < 0) {
            iVar1 = -1;
          }
          else {
            iVar1 = ret;
            if (magic_byte != 'b') {
              ly_log(lybs->ctx,LY_LLERR,LY_EINVAL,"Invalid third magic number byte \"0x%02x\".",
                     (ulong)(uint)(int)magic_byte,in_R9,lybs,data_00 + lVar2 + r);
              iVar1 = -1;
            }
          }
        }
        else {
          ly_log(lybs->ctx,LY_LLERR,LY_EINVAL,"Invalid second magic number byte \"0x%02x\".",
                 (ulong)(uint)(int)magic_byte);
          iVar1 = -1;
        }
      }
    }
    else {
      ly_log(lybs->ctx,LY_LLERR,LY_EINVAL,"Invalid first magic number byte \"0x%02x\".",
             (ulong)(uint)(int)magic_byte);
      iVar1 = -1;
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_parse_header(char *data,lyb_state *lybs)

{
  int iVar1;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  char *data_local;
  uint8_t byte;
  int ret;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  byte = '\0';
  iVar1 = lyb_read(data,&byte,1,lybs);
  ret = ret + iVar1;
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return ret;
}



lyd_node *
lyd_parse_lyb(ly_ctx *ctx,char *data,int options,lyd_node *data_tree,char *yang_data_name,
             int *parsed)

{
  char *data_00;
  long lVar1;
  int iVar2;
  long lVar3;
  lyd_node *plVar4;
  long in_FS_OFFSET;
  int *parsed_local;
  char *yang_data_name_local;
  lyd_node *data_tree_local;
  int options_local;
  char *data_local;
  ly_ctx *ctx_local;
  int r;
  int ret;
  lyd_node *node;
  lyd_node *next;
  lyd_node *act_notif;
  unres_data *unres;
  lyb_state lybs;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  r = 0;
  node = (lyd_node *)0x0;
  act_notif = (lyd_node *)0x0;
  unres = (unres_data *)0x0;
  if ((ctx == (ly_ctx *)0x0) || (data == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_parse_lyb");
    plVar4 = (lyd_node *)0x0;
    goto LAB_00173ec3;
  }
  lybs.written = (size_t *)malloc(0x20);
  lybs.position = (size_t *)malloc(0x20);
  lybs.inner_chunks = (uint8_t *)malloc(4);
  if (((lybs.written == (size_t *)0x0) || (lybs.position == (size_t *)0x0)) ||
     (lybs.inner_chunks == (uint8_t *)0x0)) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_parse_lyb");
  }
  else {
    lybs.used = 0;
    lybs.size = 4;
    lybs.models = (lys_module **)0x0;
    lybs.mod_count = 0;
    lybs.ctx = ctx;
    unres = (unres_data *)calloc(1,0x28);
    if (unres == (unres_data *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_parse_lyb");
    }
    else {
      iVar2 = lyb_parse_magic_number(data,&lybs);
      r = iVar2;
      if (-1 < iVar2) {
        data_00 = data + iVar2;
        r = lyb_parse_header(data_00,&lybs);
        iVar2 = iVar2 + r;
        if (-1 < r) {
          lVar3 = (long)r;
          r = lyb_parse_data_models(data_00 + lVar3,&lybs);
          ret = iVar2 + r;
          if (-1 < r) {
            for (data_local = data_00 + lVar3 + r; *data_local != '\0'; data_local = data_local + r)
            {
              r = lyb_parse_subtree(data_local,(lyd_node *)0x0,&node,yang_data_name,options,unres,
                                    &lybs);
              ret = ret + r;
              if (r < 0) {
                lyd_free_withsiblings(node);
                node = (lyd_node *)0x0;
                goto LAB_00173e47;
              }
            }
            r = ret + 1;
            if ((options & 0x20000U) != 0) {
              plVar4 = ly_ctx_info(ctx);
              iVar2 = lyd_merge(node,plVar4,0x500);
              if (iVar2 != 0) {
                ly_log(ctx,LY_LLERR,LY_EINT,"Adding ietf-yang-library data failed.");
                lyd_free_withsiblings(node);
                node = (lyd_node *)0x0;
                goto LAB_00173e47;
              }
            }
            if (unres->count != 0) {
              if ((options & 0x70U) != 0) {
                act_notif = node;
                while ((next = act_notif, act_notif != (lyd_node *)0x0 &&
                       ((act_notif->schema->nodetype & 0x4180) == LYS_UNKNOWN))) {
                  if ((act_notif->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) ==
                      LYS_UNKNOWN) {
                    next = act_notif->child;
                  }
                  else {
                    next = (lyd_node *)0x0;
                  }
                  if (next == (lyd_node *)0x0) {
                    if (act_notif == node) break;
                    next = act_notif->next;
                  }
                  while ((next == (lyd_node *)0x0 &&
                         (act_notif = act_notif->parent, act_notif->parent != node->parent))) {
                    next = act_notif->next;
                  }
                  act_notif = next;
                }
              }
              iVar2 = lyd_defaults_add_unres
                                (&node,options,ctx,(lys_module **)0x0,0,data_tree,act_notif,unres,0)
              ;
              if (iVar2 != 0) {
                lyd_free_withsiblings(node);
                node = (lyd_node *)0x0;
              }
            }
          }
        }
      }
    }
  }
LAB_00173e47:
  free(lybs.written);
  free(lybs.position);
  free(lybs.inner_chunks);
  free(lybs.models);
  if (unres != (unres_data *)0x0) {
    free(unres->node);
    free(unres->type);
    free(unres);
  }
  plVar4 = node;
  if (parsed != (int *)0x0) {
    *parsed = r;
  }
LAB_00173ec3:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyd_lyb_data_length(char *data)

{
  char *pcVar1;
  long lVar2;
  int iVar3;
  int iVar4;
  long in_FS_OFFSET;
  char *data_local;
  int ret;
  int i;
  int r;
  size_t len;
  lyb_state lybs;
  uint8_t buf [255];
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_lyb_data_length");
  ret = 0;
  if (data == (char *)0x0) {
    ret = -1;
  }
  else {
    lybs.written = (size_t *)malloc(0x20);
    lybs.position = (size_t *)malloc(0x20);
    lybs.inner_chunks = (uint8_t *)malloc(4);
    if (((lybs.written == (size_t *)0x0) || (lybs.position == (size_t *)0x0)) ||
       (lybs.inner_chunks == (uint8_t *)0x0)) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_lyb_data_length"
            );
    }
    else {
      lybs.used = 0;
      lybs.size = 4;
      lybs.models = (lys_module **)0x0;
      lybs.mod_count = 0;
      lybs.ctx = (ly_ctx *)0x0;
      ret = lyb_parse_magic_number(data,&lybs);
      if (-1 < ret) {
        pcVar1 = data + ret;
        iVar3 = lyb_parse_header(pcVar1,&lybs);
        ret = ret + iVar3;
        if (-1 < iVar3) {
          iVar4 = lyb_read_number(&lybs.mod_count,4,2,pcVar1 + iVar3,&lybs);
          ret = ret + iVar4;
          if (-1 < iVar4) {
            data_local = pcVar1 + iVar3 + iVar4;
            for (i = 0; i < lybs.mod_count; i = i + 1) {
              len = 0;
              iVar3 = lyb_read_number(&len,8,2,data_local,&lybs);
              ret = ret + iVar3;
              if (iVar3 < 0) goto LAB_001742e6;
              pcVar1 = data_local + iVar3;
              iVar3 = lyb_read(pcVar1,buf,len,&lybs);
              ret = ret + iVar3;
              if (iVar3 < 0) goto LAB_001742e6;
              iVar4 = lyb_read(pcVar1 + iVar3,buf,2,&lybs);
              ret = ret + iVar4;
              if (iVar4 < 0) goto LAB_001742e6;
              data_local = pcVar1 + iVar3 + iVar4;
            }
            for (; *data_local != '\0'; data_local = data_local + iVar3 + iVar4) {
              iVar3 = lyb_read_start_subtree(data_local,&lybs);
              ret = ret + iVar3;
              if (iVar3 < 0) goto LAB_001742e6;
              iVar4 = lyb_skip_subtree(data_local + iVar3,&lybs);
              ret = ret + iVar4;
              if (iVar4 < 0) goto LAB_001742e6;
              lyb_read_stop_subtree(&lybs);
            }
            ret = ret + 1;
          }
        }
      }
    }
LAB_001742e6:
    free(lybs.written);
    free(lybs.position);
    free(lybs.inner_chunks);
    free(lybs.models);
  }
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void yydestruct(char *yymsg,int yytype,YYSTYPE *yyvaluep,YYLTYPE *yylocationp,void *scanner,
               yang_parameter *param)

{
  char *__ptr;
  yang_parameter *param_local;
  void *scanner_local;
  YYLTYPE *yylocationp_local;
  YYSTYPE *yyvaluep_local;
  int yytype_local;
  char *yymsg_local;
  
  if (yytype < 0x1b0) {
    if (yytype < 399) {
      if (yytype == 0x73) {
        if (yyvaluep->str == (char *)0x0) {
          __ptr = (char *)0x0;
        }
        else {
          __ptr = *yyvaluep->p_str;
        }
        free(__ptr);
      }
      else if (yytype == 0xd2) {
        free(yyvaluep->v);
      }
    }
    else if (true) {
      switch(yytype) {
      case 399:
        free(yyvaluep->v);
        break;
      case 0x191:
        free(yyvaluep->v);
        break;
      case 0x195:
        free(yyvaluep->v);
        break;
      case 0x1ae:
        yang_type_free(param->module->ctx,(lys_type *)yyvaluep->type);
        break;
      case 0x1af:
        yang_type_free(param->module->ctx,(lys_type *)&yyvaluep->deviate->dflt);
      }
    }
  }
  return;
}


/*
Unable to decompile 'yyparse'
Cause: Exception while decompiling 00174483: process: timeout

*/


void yyerror(YYLTYPE *yylloc,void *scanner,yang_parameter *param,...)

{
  char *pcVar1;
  yang_parameter *param_local;
  void *scanner_local;
  YYLTYPE *yylloc_local;
  
  free(*param->value);
  *param->value = (char *)0x0;
  if (yylloc->first_line != -1) {
    if ((*param->data_node == (void *)0x0) || (*param->data_node != *param->actual_node)) {
      pcVar1 = yyget_text(scanner);
      ly_vlog(param->module->ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,pcVar1);
    }
    else {
      pcVar1 = yyget_text(scanner);
      ly_vlog(param->module->ctx,LYE_INSTMT,LY_VLOG_LYS,*param->data_node,pcVar1);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int yylex(YYSTYPE *yylval_param,YYLTYPE *yylloc_param,yyscan_t yyscanner)

{
  char cVar1;
  long lVar2;
  long lVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  yy_state_type yy_current_state_00;
  int iVar8;
  YY_BUFFER_STATE pyVar9;
  ly_ctx *plVar10;
  char *pcVar11;
  uint uVar12;
  yyscan_t yyscanner_local;
  YYLTYPE *yylloc_param_local;
  YYSTYPE *yylval_param_local;
  YY_CHAR yy_c;
  yy_state_type yy_current_state;
  int yy_act;
  int tab_count;
  int size_str;
  int column;
  int _state;
  int i;
  int yy_amount_of_matched_text;
  yy_state_type yy_next_state;
  int yyless_macro_arg;
  int yyless_macro_arg_1;
  uint32_t value;
  int yyless_macro_arg_5;
  int yyless_macro_arg_4;
  int yyless_macro_arg_3;
  int yyless_macro_arg_2;
  char *yy_cp;
  char *yy_bp;
  char *str;
  yyguts_t *yyg;
  
  *(YYSTYPE **)((long)yyscanner + 0x90) = yylval_param;
  *(YYLTYPE **)((long)yyscanner + 0x98) = yylloc_param;
  if (*(int *)((long)yyscanner + 0x48) == 0) {
    *(undefined4 *)((long)yyscanner + 0x48) = 1;
    if (*(int *)((long)yyscanner + 0x4c) == 0) {
      *(undefined4 *)((long)yyscanner + 0x4c) = 1;
    }
    if (*(long *)((long)yyscanner + 8) == 0) {
      *(undefined8 *)((long)yyscanner + 8) = _stdin;
    }
    if (*(long *)((long)yyscanner + 0x10) == 0) {
      *(undefined8 *)((long)yyscanner + 0x10) = _stdout;
    }
    if ((*(long *)((long)yyscanner + 0x28) == 0) ||
       (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) == 0))
    {
      yyensure_buffer_stack(yyscanner);
      lVar2 = *(long *)((long)yyscanner + 0x28);
      lVar3 = *(long *)((long)yyscanner + 0x18);
      pyVar9 = yy_create_buffer(*(FILE **)((long)yyscanner + 8),0x4000,yyscanner);
      *(YY_BUFFER_STATE *)(lVar2 + lVar3 * 8) = pyVar9;
    }
    yy_load_buffer_state(yyscanner);
  }
  tab_count = 0;
  size_str = 0;
  column = 0;
  str = (char *)0x0;
  _state = (*(int *)((long)yyscanner + 0x4c) + -1) / 2;
LAB_001885e0:
  yy_cp = *(char **)((long)yyscanner + 0x40);
  *yy_cp = *(char *)((long)yyscanner + 0x30);
  yy_current_state = *(yy_state_type *)((long)yyscanner + 0x4c);
  yy_bp = yy_cp;
LAB_0018860f:
  do {
    yy_c = ""[(int)(uint)(byte)*yy_cp];
    if (yy_accept[yy_current_state] != 0) {
      *(yy_state_type *)((long)yyscanner + 0x68) = yy_current_state;
      *(char **)((long)yyscanner + 0x70) = yy_cp;
    }
    while (yy_current_state != yy_chk[(int)((uint)yy_c + (int)yy_base[yy_current_state])]) {
      yy_current_state = (yy_state_type)yy_def[yy_current_state];
      if (0x29f < yy_current_state) {
        yy_c = ""[(int)(uint)yy_c];
      }
    }
    yy_current_state = (yy_state_type)yy_nxt[(int)((uint)yy_c + (int)yy_base[yy_current_state])];
    yy_cp = yy_cp + 1;
  } while (yy_base[yy_current_state] != 0x12c0);
LAB_00188719:
  yy_act = (int)yy_accept[yy_current_state];
  if (yy_act == 0) {
    yy_cp = *(char **)((long)yyscanner + 0x70);
    yy_act = (int)yy_accept[*(int *)((long)yyscanner + 0x68)];
  }
  *(char **)((long)yyscanner + 0x80) = yy_bp;
  iVar4 = (int)yy_bp;
  *(int *)((long)yyscanner + 0x38) = (int)yy_cp - iVar4;
  *(char *)((long)yyscanner + 0x30) = *yy_cp;
  *yy_cp = '\0';
  *(char **)((long)yyscanner + 0x40) = yy_cp;
  do {
    switch(yy_act) {
    case 0:
      goto switchD_001887d4_caseD_0;
    case 1:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      _state = (*(int *)((long)yyscanner + 0x4c) + -1) / 2;
      *(undefined4 *)((long)yyscanner + 0x4c) = 3;
      goto LAB_001885e0;
    case 2:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      goto LAB_001885e0;
    case 3:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      *(undefined4 *)(*(long *)((long)yyscanner + 0x98) + 0xc) = 0;
      goto LAB_001885e0;
    case 4:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      *(int *)((long)yyscanner + 0x4c) = _state * 2 + 1;
      goto LAB_001885e0;
    case 5:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      _state = (*(int *)((long)yyscanner + 0x4c) + -1) / 2;
      *(undefined4 *)((long)yyscanner + 0x4c) = 5;
      goto LAB_001885e0;
    case 6:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      *(int *)((long)yyscanner + 0x4c) = _state * 2 + 1;
      *(undefined4 *)(*(long *)((long)yyscanner + 0x98) + 0xc) = 0;
      return 0x106;
    case 7:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x103;
    case 8:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x113;
    case 9:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      *(undefined4 *)((long)yyscanner + 0x4c) = 7;
      return 0x114;
    case 10:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x115;
    case 0xb:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x116;
    case 0xc:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x117;
    case 0xd:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x118;
    case 0xe:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x119;
    case 0xf:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x11a;
    case 0x10:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x11b;
    case 0x11:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x11c;
    case 0x12:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x11d;
    case 0x13:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x11e;
    case 0x14:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x11f;
    case 0x15:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x120;
    case 0x16:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x121;
    case 0x17:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x122;
    case 0x18:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      *(undefined4 *)((long)yyscanner + 0x4c) = 7;
      return 0x123;
    case 0x19:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x124;
    case 0x1a:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x125;
    case 0x1b:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x126;
    case 0x1c:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x127;
    case 0x1d:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x128;
    case 0x1e:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x129;
    case 0x1f:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x12a;
    case 0x20:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 299;
    case 0x21:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 300;
    case 0x22:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x12d;
    case 0x23:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x12e;
    case 0x24:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x12f;
    case 0x25:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x130;
    case 0x26:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x131;
    case 0x27:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x132;
    case 0x28:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x133;
    case 0x29:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x134;
    case 0x2a:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x135;
    case 0x2b:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x136;
    case 0x2c:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x137;
    case 0x2d:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x138;
    case 0x2e:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x139;
    case 0x2f:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x13a;
    case 0x30:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x13b;
    case 0x31:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      *(undefined4 *)((long)yyscanner + 0x4c) = 7;
      return 0x13c;
    case 0x32:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x13d;
    case 0x33:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x13e;
    case 0x34:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x13f;
    case 0x35:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x140;
    case 0x36:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x141;
    case 0x37:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x142;
    case 0x38:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      *(undefined4 *)((long)yyscanner + 0x4c) = 7;
      return 0x143;
    case 0x39:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x144;
    case 0x3a:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x145;
    case 0x3b:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x146;
    case 0x3c:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x147;
    case 0x3d:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x148;
    case 0x3e:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      if (*(int *)(*(long *)((long)yyscanner + 0x98) + 8) != 0) {
        return 0x165;
      }
      return 0x149;
    case 0x3f:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x14a;
    case 0x40:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x14b;
    case 0x41:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      *(undefined4 *)((long)yyscanner + 0x4c) = 7;
      return 0x14c;
    case 0x42:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x14d;
    case 0x43:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x14e;
    case 0x44:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x14f;
    case 0x45:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x150;
    case 0x46:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x151;
    case 0x47:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x152;
    case 0x48:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x153;
    case 0x49:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x154;
    case 0x4a:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x154;
    case 0x4b:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x155;
    case 0x4c:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x156;
    case 0x4d:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x157;
    case 0x4e:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x158;
    case 0x4f:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x159;
    case 0x50:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x15a;
    case 0x51:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x15b;
    case 0x52:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x15c;
    case 0x53:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x15d;
    case 0x54:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x15e;
    case 0x55:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x15f;
    case 0x56:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x160;
    case 0x57:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x161;
    case 0x58:
    case 0x59:
    case 0x5a:
    case 0x5b:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return (int)**(char **)((long)yyscanner + 0x80);
    case 0x5c:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      _state = (*(int *)((long)yyscanner + 0x4c) + -1) / 2;
      *(undefined4 *)((long)yyscanner + 0x4c) = 9;
      str = *(char **)((long)yyscanner + 0x80);
      column = *(int *)(*(long *)((long)yyscanner + 0x98) + 4);
      goto LAB_001885e0;
    case 0x5d:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      tab_count = tab_count + 1;
      size_str = size_str + *(int *)((long)yyscanner + 0x38);
      goto LAB_001885e0;
    case 0x5e:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      size_str = size_str + *(int *)((long)yyscanner + 0x38);
      goto LAB_001885e0;
    case 0x5f:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      size_str = size_str + *(int *)((long)yyscanner + 0x38);
      goto LAB_001885e0;
    case 0x60:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      *(undefined4 *)(*(long *)((long)yyscanner + 0x98) + 0xc) = 0;
      size_str = size_str + 1;
      goto LAB_001885e0;
    case 0x61:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      uVar12 = ((int)**(char **)((long)yyscanner + 0x80) & 0xfU) << 0xc;
      uVar5 = ((int)*(char *)(*(long *)((long)yyscanner + 0x80) + 1) & 0x3fU) << 6;
      uVar6 = (int)*(char *)(*(long *)((long)yyscanner + 0x80) + 2) & 0x3fU | uVar12 | uVar5;
      if ((((uVar12 | uVar5 & 0xf800) == 0xd800) || ((0xfdcf < uVar6 && (uVar6 < 0xfdf0)))) ||
         ((uVar6 & 0xffe) == 0xffe)) {
        plVar10 = (ly_ctx *)yyget_extra(yyscanner);
        ly_vlog(plVar10,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid UTF-8 value 0x%08x",(ulong)uVar6)
        ;
        **(undefined4 **)((long)yyscanner + 0x98) = 0xffffffff;
        return 0x105;
      }
      size_str = size_str + 3;
      goto LAB_001885e0;
    case 0x62:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      uVar5 = (int)*(char *)(*(long *)((long)yyscanner + 0x80) + 3) & 0x3fU |
              ((int)**(char **)((long)yyscanner + 0x80) & 7U) << 0x12 |
              ((int)*(char *)(*(long *)((long)yyscanner + 0x80) + 1) & 0x3fU) << 0xc |
              ((int)*(char *)(*(long *)((long)yyscanner + 0x80) + 2) & 0x3fU) << 6;
      if ((uVar5 & 0xffe) == 0xffe) {
        plVar10 = (ly_ctx *)yyget_extra(yyscanner);
        ly_vlog(plVar10,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid UTF-8 value 0x%08x",(ulong)uVar5)
        ;
        **(undefined4 **)((long)yyscanner + 0x98) = 0xffffffff;
        return 0x105;
      }
      size_str = size_str + 4;
      goto LAB_001885e0;
    case 99:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      **(int **)((long)yyscanner + 0x90) = tab_count;
      *(int *)((long)yyscanner + 0x4c) = _state * 2 + 1;
      *(char **)((long)yyscanner + 0x80) = str;
      *(int *)((long)yyscanner + 0x38) = size_str + 2;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) = column;
      return 0x107;
    case 100:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      _state = (*(int *)((long)yyscanner + 0x4c) + -1) / 2;
      *(undefined4 *)((long)yyscanner + 0x4c) = 0xb;
      str = *(char **)((long)yyscanner + 0x80);
      column = *(int *)(*(long *)((long)yyscanner + 0x98) + 4);
      goto LAB_001885e0;
    case 0x65:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      size_str = size_str + *(int *)((long)yyscanner + 0x38);
      goto LAB_001885e0;
    case 0x66:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      *(int *)((long)yyscanner + 0x4c) = _state * 2 + 1;
      *(char **)((long)yyscanner + 0x80) = str;
      *(int *)((long)yyscanner + 0x38) = size_str + 2;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) = column;
      return 0x107;
    case 0x67:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x111;
    case 0x68:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x10f;
    case 0x69:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x110;
    case 0x6a:
    case 0x6b:
    case 0x6c:
    case 0x6d:
    case 0x6e:
    case 0x6f:
    case 0x70:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return (int)**(char **)((long)yyscanner + 0x80);
    case 0x71:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x10d;
    case 0x72:
    case 0x73:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      *(undefined4 *)(*(long *)((long)yyscanner + 0x98) + 0xc) = 0;
      return 0x106;
    case 0x74:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x104;
    case 0x75:
    case 0x76:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      *(undefined4 *)((long)yyscanner + 0x4c) = 1;
      return (int)**(char **)((long)yyscanner + 0x80);
    case 0x77:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      _state = (*(int *)((long)yyscanner + 0x4c) + -1) / 2;
      *(undefined4 *)((long)yyscanner + 0x4c) = 9;
      str = *(char **)((long)yyscanner + 0x80);
      column = *(int *)(*(long *)((long)yyscanner + 0x98) + 4);
      goto LAB_001885e0;
    case 0x78:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      _state = (*(int *)((long)yyscanner + 0x4c) + -1) / 2;
      *(undefined4 *)((long)yyscanner + 0x4c) = 5;
      goto LAB_001885e0;
    case 0x79:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      _state = (*(int *)((long)yyscanner + 0x4c) + -1) / 2;
      *(undefined4 *)((long)yyscanner + 0x4c) = 3;
      goto LAB_001885e0;
    case 0x7a:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x109;
    case 0x7b:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x10a;
    case 0x7c:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x10b;
    case 0x7d:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x109;
    case 0x7e:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x10a;
    case 0x7f:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      if ((**(char **)((long)yyscanner + 0x80) == '/') &&
         (*(char *)(*(long *)((long)yyscanner + 0x80) + 1) == '/')) {
        iVar7 = *(int *)((long)yyscanner + 0x4c);
        *yy_cp = *(char *)((long)yyscanner + 0x30);
        pcVar11 = yy_bp + 2;
        *(char **)((long)yyscanner + 0x40) = pcVar11;
        *(char **)((long)yyscanner + 0x80) = yy_bp;
        *(int *)((long)yyscanner + 0x38) = (int)pcVar11 - iVar4;
        *(char *)((long)yyscanner + 0x30) = *pcVar11;
        *pcVar11 = '\0';
        *(char **)((long)yyscanner + 0x40) = pcVar11;
        *(undefined4 *)((long)yyscanner + 0x4c) = 5;
      }
      else {
        if ((**(char **)((long)yyscanner + 0x80) != '/') ||
           (*(char *)(*(long *)((long)yyscanner + 0x80) + 1) != '*')) {
          i = 0;
          do {
            while( true ) {
              if (*(int *)((long)yyscanner + 0x38) <= i) {
                return 0x108;
              }
              if (-1 < *(char *)((long)i + *(long *)((long)yyscanner + 0x80))) break;
              if ((*(byte *)((long)i + *(long *)((long)yyscanner + 0x80)) & 0x20) == 0) {
                i = i + 2;
              }
              else if ((*(byte *)((long)i + *(long *)((long)yyscanner + 0x80)) & 0x10) == 0) {
                uVar12 = ((int)*(char *)((long)i + *(long *)((long)yyscanner + 0x80)) & 0xfU) << 0xc
                ;
                uVar5 = ((int)*(char *)(*(long *)((long)yyscanner + 0x80) + (long)i + 1) & 0x3fU) <<
                        6;
                uVar6 = (int)*(char *)(*(long *)((long)yyscanner + 0x80) + (long)i + 2) & 0x3fU |
                        uVar12 | uVar5;
                if (((uVar12 | uVar5 & 0xf800) == 0xd800) ||
                   (((0xfdcf < uVar6 && (uVar6 < 0xfdf0)) || ((uVar6 & 0xffe) == 0xffe)))) {
                  plVar10 = (ly_ctx *)yyget_extra(yyscanner);
                  ly_vlog(plVar10,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid UTF-8 value 0x%08x",
                          (ulong)uVar6);
                  **(undefined4 **)((long)yyscanner + 0x98) = 0xffffffff;
                  return 0x105;
                }
                i = i + 3;
              }
              else {
                uVar5 = (int)*(char *)(*(long *)((long)yyscanner + 0x80) + (long)i + 3) & 0x3fU |
                        ((int)*(char *)((long)i + *(long *)((long)yyscanner + 0x80)) & 7U) << 0x12 |
                        ((int)*(char *)(*(long *)((long)yyscanner + 0x80) + (long)i + 1) & 0x3fU) <<
                        0xc | ((int)*(char *)(*(long *)((long)yyscanner + 0x80) + (long)i + 2) &
                              0x3fU) << 6;
                if ((uVar5 & 0xffe) == 0xffe) {
                  plVar10 = (ly_ctx *)yyget_extra(yyscanner);
                  ly_vlog(plVar10,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid UTF-8 value 0x%08x",
                          (ulong)uVar5);
                  **(undefined4 **)((long)yyscanner + 0x98) = 0xffffffff;
                  return 0x105;
                }
                i = i + 4;
              }
            }
            if (*(char *)((long)i + *(long *)((long)yyscanner + 0x80)) == '/') {
              if (*(char *)(*(long *)((long)yyscanner + 0x80) + (long)i + 1) == '/') {
                *yy_cp = *(char *)((long)yyscanner + 0x30);
                pcVar11 = yy_bp + i;
                *(char **)((long)yyscanner + 0x40) = pcVar11;
                *(char **)((long)yyscanner + 0x80) = yy_bp;
                *(int *)((long)yyscanner + 0x38) = (int)pcVar11 - iVar4;
                *(char *)((long)yyscanner + 0x30) = *pcVar11;
                *pcVar11 = '\0';
                *(char **)((long)yyscanner + 0x40) = pcVar11;
                return 0x108;
              }
              if (*(char *)(*(long *)((long)yyscanner + 0x80) + (long)i + 1) == '*') {
                *yy_cp = *(char *)((long)yyscanner + 0x30);
                pcVar11 = yy_bp + i;
                *(char **)((long)yyscanner + 0x40) = pcVar11;
                *(char **)((long)yyscanner + 0x80) = yy_bp;
                *(int *)((long)yyscanner + 0x38) = (int)pcVar11 - iVar4;
                *(char *)((long)yyscanner + 0x30) = *pcVar11;
                *pcVar11 = '\0';
                *(char **)((long)yyscanner + 0x40) = pcVar11;
                return 0x108;
              }
            }
            else if ((*(char *)((long)i + *(long *)((long)yyscanner + 0x80)) == '*') &&
                    (*(char *)(*(long *)((long)yyscanner + 0x80) + (long)i + 1) == '/')) {
              if (i == 0) {
                *yy_cp = *(char *)((long)yyscanner + 0x30);
                pcVar11 = yy_bp + 1;
                *(char **)((long)yyscanner + 0x40) = pcVar11;
                *(char **)((long)yyscanner + 0x80) = yy_bp;
                *(int *)((long)yyscanner + 0x38) = (int)pcVar11 - iVar4;
                *(char *)((long)yyscanner + 0x30) = *pcVar11;
                *pcVar11 = '\0';
                *(char **)((long)yyscanner + 0x40) = pcVar11;
                return 0x105;
              }
              *yy_cp = *(char *)((long)yyscanner + 0x30);
              pcVar11 = yy_bp + i;
              *(char **)((long)yyscanner + 0x40) = pcVar11;
              *(char **)((long)yyscanner + 0x80) = yy_bp;
              *(int *)((long)yyscanner + 0x38) = (int)pcVar11 - iVar4;
              *(char *)((long)yyscanner + 0x30) = *pcVar11;
              *pcVar11 = '\0';
              *(char **)((long)yyscanner + 0x40) = pcVar11;
              return 0x108;
            }
            i = i + 1;
          } while( true );
        }
        iVar7 = *(int *)((long)yyscanner + 0x4c);
        *yy_cp = *(char *)((long)yyscanner + 0x30);
        pcVar11 = yy_bp + 2;
        *(char **)((long)yyscanner + 0x40) = pcVar11;
        *(char **)((long)yyscanner + 0x80) = yy_bp;
        *(int *)((long)yyscanner + 0x38) = (int)pcVar11 - iVar4;
        *(char *)((long)yyscanner + 0x30) = *pcVar11;
        *pcVar11 = '\0';
        *(char **)((long)yyscanner + 0x40) = pcVar11;
        *(undefined4 *)((long)yyscanner + 0x4c) = 3;
      }
      _state = (iVar7 + -1) / 2;
      goto LAB_001885e0;
    case 0x80:
    case 0x81:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      *(undefined4 *)(*(long *)((long)yyscanner + 0x98) + 0xc) = 0;
      return 0x106;
    case 0x82:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      return 0x104;
    case 0x83:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      cVar1 = **(char **)((long)yyscanner + 0x80);
      plVar10 = (ly_ctx *)yyget_extra(yyscanner);
      ly_vlog(plVar10,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid UTF-8 leading byte 0x%02x",
              (ulong)(uint)(int)cVar1);
      **(undefined4 **)((long)yyscanner + 0x98) = 0xffffffff;
      return 0x105;
    case 0x84:
      *(int *)(*(long *)((long)yyscanner + 0x98) + 4) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) + 1;
      *(int *)(*(long *)((long)yyscanner + 0x98) + 0xc) =
           *(int *)(*(long *)((long)yyscanner + 0x98) + 4) + *(int *)((long)yyscanner + 0x38) + -1;
      fwrite(*(void **)((long)yyscanner + 0x80),(long)*(int *)((long)yyscanner + 0x38),1,
             *(FILE **)((long)yyscanner + 0x10));
      goto LAB_001885e0;
    case 0x85:
      iVar7 = ((int)yy_cp - (int)*(undefined8 *)((long)yyscanner + 0x80)) + -1;
      *yy_cp = *(char *)((long)yyscanner + 0x30);
      if (*(int *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                            *(long *)((long)yyscanner + 0x28)) + 0x38) == 0) {
        *(undefined4 *)((long)yyscanner + 0x34) =
             *(undefined4 *)
              (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28))
              + 0x1c);
        **(undefined8 **)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28))
             = *(undefined8 *)((long)yyscanner + 8);
        *(undefined4 *)
         (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) +
         0x38) = 1;
      }
      if (*(ulong *)((long)yyscanner + 0x40) <=
          (ulong)((long)*(int *)((long)yyscanner + 0x34) +
                 *(long *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                                    *(long *)((long)yyscanner + 0x28)) + 8))) {
        *(long *)((long)yyscanner + 0x40) = *(long *)((long)yyscanner + 0x80) + (long)iVar7;
        yy_current_state_00 = yy_get_previous_state(yyscanner);
        yy_current_state = yy_try_NUL_trans(yy_current_state_00,yyscanner);
        yy_bp = *(char **)((long)yyscanner + 0x80);
        if (yy_current_state != 0) {
          *(long *)((long)yyscanner + 0x40) = *(long *)((long)yyscanner + 0x40) + 1;
          yy_cp = *(char **)((long)yyscanner + 0x40);
          goto LAB_0018860f;
        }
        yy_cp = *(char **)((long)yyscanner + 0x40);
        yy_current_state = yy_current_state_00;
        goto LAB_00188719;
      }
      iVar8 = yy_get_next_buffer(yyscanner);
      if (iVar8 == 2) {
        *(long *)((long)yyscanner + 0x40) =
             *(long *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                                *(long *)((long)yyscanner + 0x28)) + 8) +
             (long)*(int *)((long)yyscanner + 0x34);
        yy_current_state = yy_get_previous_state(yyscanner);
        yy_cp = *(char **)((long)yyscanner + 0x40);
        yy_bp = *(char **)((long)yyscanner + 0x80);
        goto LAB_00188719;
      }
      if (2 < iVar8) goto LAB_001885e0;
      if (iVar8 == 0) {
        *(long *)((long)yyscanner + 0x40) = *(long *)((long)yyscanner + 0x80) + (long)iVar7;
        yy_current_state = yy_get_previous_state(yyscanner);
        yy_cp = *(char **)((long)yyscanner + 0x40);
        yy_bp = *(char **)((long)yyscanner + 0x80);
        goto LAB_0018860f;
      }
      if (iVar8 != 1) goto LAB_001885e0;
      *(undefined4 *)((long)yyscanner + 0x50) = 0;
      *(undefined8 *)((long)yyscanner + 0x40) = *(undefined8 *)((long)yyscanner + 0x80);
      yy_act = (*(int *)((long)yyscanner + 0x4c) + -1) / 2 + 0x86;
      break;
    case 0x86:
    case 0x87:
    case 0x88:
    case 0x89:
      return 0;
    case 0x8a:
      plVar10 = (ly_ctx *)yyget_extra(yyscanner);
      ly_vlog(plVar10,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Unterminated double-quoted string.");
      **(undefined4 **)((long)yyscanner + 0x98) = 0xffffffff;
      return 0x105;
    case 0x8b:
      plVar10 = (ly_ctx *)yyget_extra(yyscanner);
      ly_vlog(plVar10,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Unterminated single-quoted string.");
      **(undefined4 **)((long)yyscanner + 0x98) = 0xffffffff;
      return 0x105;
    default:
                    // WARNING: Subroutine does not return
      yy_fatal_error("fatal flex scanner internal error--no action found",yyscanner);
    }
  } while( true );
switchD_001887d4_caseD_0:
  *yy_cp = *(char *)((long)yyscanner + 0x30);
  yy_cp = *(char **)((long)yyscanner + 0x70);
  yy_current_state = *(yy_state_type *)((long)yyscanner + 0x68);
  goto LAB_00188719;
}



int yy_get_next_buffer(yyscan_t yyscanner)

{
  undefined8 uVar1;
  undefined8 uVar2;
  long lVar3;
  int iVar4;
  int iVar5;
  int *piVar6;
  size_t sVar7;
  void *pvVar8;
  yyscan_t yyscanner_local;
  int i;
  int ret_val;
  int num_to_read;
  int c;
  int n;
  int number_to_move;
  int yy_c_buf_p_offset;
  int new_size;
  int new_size_1;
  char *dest;
  char *source;
  yyguts_t *yyg;
  YY_BUFFER_STATE b;
  
  if ((ulong)((long)*(int *)((long)yyscanner + 0x34) + 1 +
             *(long *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                                *(long *)((long)yyscanner + 0x28)) + 8)) <
      *(ulong *)((long)yyscanner + 0x40)) {
                    // WARNING: Subroutine does not return
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed",yyscanner);
  }
  if (*(int *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28))
              + 0x34) == 0) {
    if (*(long *)((long)yyscanner + 0x40) - *(long *)((long)yyscanner + 0x80) == 1) {
      ret_val = 1;
    }
    else {
      ret_val = 2;
    }
  }
  else {
    iVar4 = ((int)*(undefined8 *)((long)yyscanner + 0x40) -
            (int)*(undefined8 *)((long)yyscanner + 0x80)) + -1;
    dest = *(char **)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                               *(long *)((long)yyscanner + 0x28)) + 8);
    source = *(char **)((long)yyscanner + 0x80);
    for (i = 0; i < iVar4; i = i + 1) {
      *dest = *source;
      dest = dest + 1;
      source = source + 1;
    }
    if (*(int *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)
                          ) + 0x38) == 2) {
      *(undefined4 *)((long)yyscanner + 0x34) = 0;
      *(undefined4 *)
       (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) + 0x1c)
           = *(undefined4 *)((long)yyscanner + 0x34);
    }
    else {
      iVar5 = *(int *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                                *(long *)((long)yyscanner + 0x28)) + 0x18) - iVar4;
      while (num_to_read = iVar5 + -1, num_to_read < 1) {
        lVar3 = *(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28))
        ;
        uVar1 = *(undefined8 *)((long)yyscanner + 0x40);
        uVar2 = *(undefined8 *)(lVar3 + 8);
        if (*(int *)(lVar3 + 0x20) == 0) {
          *(undefined8 *)(lVar3 + 8) = 0;
        }
        else {
          if (*(int *)(lVar3 + 0x18) * 2 < 1) {
            iVar5 = *(int *)(lVar3 + 0x18);
            if (iVar5 < 0) {
              iVar5 = iVar5 + 7;
            }
            *(int *)(lVar3 + 0x18) = *(int *)(lVar3 + 0x18) + (iVar5 >> 3);
          }
          else {
            *(int *)(lVar3 + 0x18) = *(int *)(lVar3 + 0x18) * 2;
          }
          pvVar8 = yyrealloc(*(void **)(lVar3 + 8),(long)(*(int *)(lVar3 + 0x18) + 2),yyscanner);
          *(void **)(lVar3 + 8) = pvVar8;
        }
        if (*(long *)(lVar3 + 8) == 0) {
                    // WARNING: Subroutine does not return
          yy_fatal_error("fatal error - scanner input buffer overflow",yyscanner);
        }
        *(long *)((long)yyscanner + 0x40) = *(long *)(lVar3 + 8) + (long)((int)uVar1 - (int)uVar2);
        iVar5 = *(int *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                                  *(long *)((long)yyscanner + 0x28)) + 0x18) - iVar4;
      }
      if (0x2000 < num_to_read) {
        num_to_read = 0x2000;
      }
      if (*(int *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                            *(long *)((long)yyscanner + 0x28)) + 0x24) == 0) {
        piVar6 = __errno_location();
        *piVar6 = 0;
        while( true ) {
          sVar7 = fread((void *)(*(long *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                                                    *(long *)((long)yyscanner + 0x28)) + 8) +
                                (long)iVar4),1,(long)num_to_read,*(FILE **)((long)yyscanner + 8));
          *(int *)((long)yyscanner + 0x34) = (int)sVar7;
          if (*(int *)((long)yyscanner + 0x34) != 0) break;
          iVar5 = ferror(*(FILE **)((long)yyscanner + 8));
          if (iVar5 == 0) break;
          piVar6 = __errno_location();
          if (*piVar6 != 4) {
                    // WARNING: Subroutine does not return
            yy_fatal_error("input in flex scanner failed",yyscanner);
          }
          piVar6 = __errno_location();
          *piVar6 = 0;
          clearerr(*(FILE **)((long)yyscanner + 8));
        }
      }
      else {
        c = 0x2a;
        for (n = 0; n < num_to_read; n = n + 1) {
          c = getc(*(FILE **)((long)yyscanner + 8));
          if ((c == -1) || (c == 10)) break;
          *(char *)(*(long *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                                       *(long *)((long)yyscanner + 0x28)) + 8) +
                   (long)n + (long)iVar4) = (char)c;
        }
        if (c == 10) {
          *(undefined *)
           ((long)n + (long)iVar4 +
           *(long *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                              *(long *)((long)yyscanner + 0x28)) + 8)) = 10;
          n = n + 1;
        }
        if (c == -1) {
          iVar5 = ferror(*(FILE **)((long)yyscanner + 8));
          if (iVar5 != 0) {
                    // WARNING: Subroutine does not return
            yy_fatal_error("input in flex scanner failed",yyscanner);
          }
        }
        *(int *)((long)yyscanner + 0x34) = n;
      }
      *(undefined4 *)
       (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) + 0x1c)
           = *(undefined4 *)((long)yyscanner + 0x34);
    }
    if (*(int *)((long)yyscanner + 0x34) == 0) {
      if (iVar4 == 0) {
        ret_val = 1;
        yyrestart(*(FILE **)((long)yyscanner + 8),yyscanner);
      }
      else {
        ret_val = 2;
        *(undefined4 *)
         (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) +
         0x38) = 2;
      }
    }
    else {
      ret_val = 0;
    }
    if (*(int *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)
                          ) + 0x18) < *(int *)((long)yyscanner + 0x34) + iVar4) {
      iVar5 = (*(int *)((long)yyscanner + 0x34) >> 1) + *(int *)((long)yyscanner + 0x34) + iVar4;
      lVar3 = *(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28));
      pvVar8 = yyrealloc(*(void **)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                                             *(long *)((long)yyscanner + 0x28)) + 8),(long)iVar5,
                         yyscanner);
      *(void **)(lVar3 + 8) = pvVar8;
      if (*(long *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                             *(long *)((long)yyscanner + 0x28)) + 8) == 0) {
                    // WARNING: Subroutine does not return
        yy_fatal_error("out of dynamic memory in yy_get_next_buffer()",yyscanner);
      }
      *(int *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28))
              + 0x18) = iVar5 + -2;
    }
    *(int *)((long)yyscanner + 0x34) = *(int *)((long)yyscanner + 0x34) + iVar4;
    *(undefined *)
     ((long)*(int *)((long)yyscanner + 0x34) +
     *(long *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28))
              + 8)) = 0;
    *(undefined *)
     ((long)*(int *)((long)yyscanner + 0x34) + 1 +
     *(long *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28))
              + 8)) = 0;
    *(undefined8 *)((long)yyscanner + 0x80) =
         *(undefined8 *)
          (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) + 8)
    ;
  }
  return ret_val;
}



yy_state_type yy_get_previous_state(yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  YY_CHAR yy_c;
  yy_state_type yy_current_state;
  char *yy_cp;
  yyguts_t *yyg;
  
  yy_current_state = *(yy_state_type *)((long)yyscanner + 0x4c);
  for (yy_cp = *(char **)((long)yyscanner + 0x80); yy_cp < *(char **)((long)yyscanner + 0x40);
      yy_cp = yy_cp + 1) {
    if (*yy_cp == '\0') {
      yy_c = '\x01';
    }
    else {
      yy_c = ""[(int)(uint)(byte)*yy_cp];
    }
    if (yy_accept[yy_current_state] != 0) {
      *(yy_state_type *)((long)yyscanner + 0x68) = yy_current_state;
      *(char **)((long)yyscanner + 0x70) = yy_cp;
    }
    while (yy_current_state != yy_chk[(int)((uint)yy_c + (int)yy_base[yy_current_state])]) {
      yy_current_state = (yy_state_type)yy_def[yy_current_state];
      if (0x29f < yy_current_state) {
        yy_c = ""[(int)(uint)yy_c];
      }
    }
    yy_current_state = (yy_state_type)yy_nxt[(int)((uint)yy_c + (int)yy_base[yy_current_state])];
  }
  return yy_current_state;
}



yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state,yyscan_t yyscanner)

{
  int iVar1;
  yyscan_t yyscanner_local;
  yy_state_type yy_current_state_local;
  YY_CHAR yy_c;
  int yy_is_jam;
  yyguts_t *yyg;
  char *yy_cp;
  
  yy_c = '\x01';
  yy_current_state_local = yy_current_state;
  if (yy_accept[yy_current_state] != 0) {
    *(yy_state_type *)((long)yyscanner + 0x68) = yy_current_state;
    *(undefined8 *)((long)yyscanner + 0x70) = *(undefined8 *)((long)yyscanner + 0x40);
  }
  while (yy_current_state_local != yy_chk[(int)((uint)yy_c + (int)yy_base[yy_current_state_local])])
  {
    yy_current_state_local = (yy_state_type)yy_def[yy_current_state_local];
    if (0x29f < yy_current_state_local) {
      yy_c = ""[(int)(uint)yy_c];
    }
  }
  iVar1 = (int)yy_nxt[(int)((uint)yy_c + (int)yy_base[yy_current_state_local])];
  if (iVar1 == 0x29f) {
    iVar1 = 0;
  }
  return iVar1;
}



void yyrestart(FILE *input_file,yyscan_t yyscanner)

{
  long lVar1;
  long lVar2;
  YY_BUFFER_STATE pyVar3;
  yyscan_t yyscanner_local;
  FILE *input_file_local;
  yyguts_t *yyg;
  
  if ((*(long *)((long)yyscanner + 0x28) == 0) ||
     (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) == 0)) {
    yyensure_buffer_stack(yyscanner);
    lVar1 = *(long *)((long)yyscanner + 0x28);
    lVar2 = *(long *)((long)yyscanner + 0x18);
    pyVar3 = yy_create_buffer(*(FILE **)((long)yyscanner + 8),0x4000,yyscanner);
    *(YY_BUFFER_STATE *)(lVar1 + lVar2 * 8) = pyVar3;
  }
  if (*(long *)((long)yyscanner + 0x28) == 0) {
    pyVar3 = (YY_BUFFER_STATE)0x0;
  }
  else {
    pyVar3 = *(YY_BUFFER_STATE *)
              (*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28));
  }
  yy_init_buffer(pyVar3,input_file,yyscanner);
  yy_load_buffer_state(yyscanner);
  return;
}



void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer,yyscan_t yyscanner)

{
  YY_BUFFER_STATE pyVar1;
  yyscan_t yyscanner_local;
  YY_BUFFER_STATE new_buffer_local;
  yyguts_t *yyg;
  
  yyensure_buffer_stack(yyscanner);
  if (*(long *)((long)yyscanner + 0x28) == 0) {
    pyVar1 = (YY_BUFFER_STATE)0x0;
  }
  else {
    pyVar1 = *(YY_BUFFER_STATE *)
              (*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28));
  }
  if (pyVar1 != new_buffer) {
    if ((*(long *)((long)yyscanner + 0x28) != 0) &&
       (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) != 0))
    {
      **(undefined **)((long)yyscanner + 0x40) = *(undefined *)((long)yyscanner + 0x30);
      *(undefined8 *)
       (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) + 0x10)
           = *(undefined8 *)((long)yyscanner + 0x40);
      *(undefined4 *)
       (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) + 0x1c)
           = *(undefined4 *)((long)yyscanner + 0x34);
    }
    *(YY_BUFFER_STATE *)(*(long *)((long)yyscanner + 0x28) + *(long *)((long)yyscanner + 0x18) * 8)
         = new_buffer;
    yy_load_buffer_state(yyscanner);
    *(undefined4 *)((long)yyscanner + 0x50) = 1;
  }
  return;
}



void yy_load_buffer_state(yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
  *(undefined4 *)((long)yyscanner + 0x34) =
       *(undefined4 *)
        (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) + 0x1c
        );
  *(undefined8 *)((long)yyscanner + 0x40) =
       *(undefined8 *)
        (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) + 0x10
        );
  *(undefined8 *)((long)yyscanner + 0x80) = *(undefined8 *)((long)yyscanner + 0x40);
  *(undefined8 *)((long)yyscanner + 8) =
       **(undefined8 **)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28));
  *(undefined *)((long)yyscanner + 0x30) = **(undefined **)((long)yyscanner + 0x40);
  return;
}



YY_BUFFER_STATE yy_create_buffer(FILE *file,int size,yyscan_t yyscanner)

{
  YY_BUFFER_STATE b_00;
  char *pcVar1;
  yyscan_t yyscanner_local;
  int size_local;
  FILE *file_local;
  YY_BUFFER_STATE b;
  
  b_00 = (YY_BUFFER_STATE)yyalloc(0x40,yyscanner);
  if (b_00 == (YY_BUFFER_STATE)0x0) {
                    // WARNING: Subroutine does not return
    yy_fatal_error("out of dynamic memory in yy_create_buffer()",yyscanner);
  }
  b_00->yy_buf_size = size;
  pcVar1 = (char *)yyalloc((long)(b_00->yy_buf_size + 2),yyscanner);
  b_00->yy_ch_buf = pcVar1;
  if (b_00->yy_ch_buf == (char *)0x0) {
                    // WARNING: Subroutine does not return
    yy_fatal_error("out of dynamic memory in yy_create_buffer()",yyscanner);
  }
  b_00->yy_is_our_buffer = 1;
  yy_init_buffer(b_00,file,yyscanner);
  return b_00;
}



void yy_delete_buffer(YY_BUFFER_STATE b,yyscan_t yyscanner)

{
  YY_BUFFER_STATE pyVar1;
  yyscan_t yyscanner_local;
  YY_BUFFER_STATE b_local;
  yyguts_t *yyg;
  
  if (b != (YY_BUFFER_STATE)0x0) {
    if (*(long *)((long)yyscanner + 0x28) == 0) {
      pyVar1 = (YY_BUFFER_STATE)0x0;
    }
    else {
      pyVar1 = *(YY_BUFFER_STATE *)
                (*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28));
    }
    if (pyVar1 == b) {
      *(undefined8 *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) = 0
      ;
    }
    if (b->yy_is_our_buffer != 0) {
      yyfree(b->yy_ch_buf,yyscanner);
    }
    yyfree(b,yyscanner);
  }
  return;
}



void yy_init_buffer(YY_BUFFER_STATE b,FILE *file,yyscan_t yyscanner)

{
  int iVar1;
  int iVar2;
  int *piVar3;
  YY_BUFFER_STATE pyVar4;
  yyscan_t yyscanner_local;
  FILE *file_local;
  YY_BUFFER_STATE b_local;
  int oerrno;
  yyguts_t *yyg;
  
  piVar3 = __errno_location();
  iVar1 = *piVar3;
  yy_flush_buffer(b,yyscanner);
  b->yy_input_file = file;
  b->yy_fill_buffer = 1;
  if (*(long *)((long)yyscanner + 0x28) == 0) {
    pyVar4 = (YY_BUFFER_STATE)0x0;
  }
  else {
    pyVar4 = *(YY_BUFFER_STATE *)
              (*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28));
  }
  if (pyVar4 != b) {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }
  if (file != (FILE *)0x0) {
    iVar2 = fileno((FILE *)file);
    iVar2 = isatty(iVar2);
    if (0 < iVar2) {
      iVar2 = 1;
      goto LAB_0018cb12;
    }
  }
  iVar2 = 0;
LAB_0018cb12:
  b->yy_is_interactive = iVar2;
  piVar3 = __errno_location();
  *piVar3 = iVar1;
  return;
}



void yy_flush_buffer(YY_BUFFER_STATE b,yyscan_t yyscanner)

{
  YY_BUFFER_STATE pyVar1;
  yyscan_t yyscanner_local;
  YY_BUFFER_STATE b_local;
  yyguts_t *yyg;
  
  if (b != (YY_BUFFER_STATE)0x0) {
    b->yy_n_chars = 0;
    *b->yy_ch_buf = '\0';
    b->yy_ch_buf[1] = '\0';
    b->yy_buf_pos = b->yy_ch_buf;
    b->yy_at_bol = 1;
    b->yy_buffer_status = 0;
    if (*(long *)((long)yyscanner + 0x28) == 0) {
      pyVar1 = (YY_BUFFER_STATE)0x0;
    }
    else {
      pyVar1 = *(YY_BUFFER_STATE *)
                (*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28));
    }
    if (pyVar1 == b) {
      yy_load_buffer_state(yyscanner);
    }
  }
  return;
}



void yypush_buffer_state(YY_BUFFER_STATE new_buffer,yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  YY_BUFFER_STATE new_buffer_local;
  yyguts_t *yyg;
  
  if (new_buffer != (YY_BUFFER_STATE)0x0) {
    yyensure_buffer_stack(yyscanner);
    if ((*(long *)((long)yyscanner + 0x28) != 0) &&
       (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) != 0))
    {
      **(undefined **)((long)yyscanner + 0x40) = *(undefined *)((long)yyscanner + 0x30);
      *(undefined8 *)
       (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) + 0x10)
           = *(undefined8 *)((long)yyscanner + 0x40);
      *(undefined4 *)
       (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) + 0x1c)
           = *(undefined4 *)((long)yyscanner + 0x34);
    }
    if ((*(long *)((long)yyscanner + 0x28) != 0) &&
       (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) != 0))
    {
      *(long *)((long)yyscanner + 0x18) = *(long *)((long)yyscanner + 0x18) + 1;
    }
    *(YY_BUFFER_STATE *)(*(long *)((long)yyscanner + 0x28) + *(long *)((long)yyscanner + 0x18) * 8)
         = new_buffer;
    yy_load_buffer_state(yyscanner);
    *(undefined4 *)((long)yyscanner + 0x50) = 1;
  }
  return;
}



void yypop_buffer_state(yyscan_t yyscanner)

{
  YY_BUFFER_STATE b;
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
  if ((*(long *)((long)yyscanner + 0x28) != 0) &&
     (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) != 0)) {
    if (*(long *)((long)yyscanner + 0x28) == 0) {
      b = (YY_BUFFER_STATE)0x0;
    }
    else {
      b = *(YY_BUFFER_STATE *)
           (*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28));
    }
    yy_delete_buffer(b,yyscanner);
    *(undefined8 *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) = 0;
    if (*(long *)((long)yyscanner + 0x18) != 0) {
      *(long *)((long)yyscanner + 0x18) = *(long *)((long)yyscanner + 0x18) + -1;
    }
    if ((*(long *)((long)yyscanner + 0x28) != 0) &&
       (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) != 0))
    {
      yy_load_buffer_state(yyscanner);
      *(undefined4 *)((long)yyscanner + 0x50) = 1;
    }
  }
  return;
}



void yyensure_buffer_stack(yyscan_t yyscanner)

{
  void *pvVar1;
  long lVar2;
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  yy_size_t grow_size;
  yy_size_t num_to_alloc;
  
  if (*(long *)((long)yyscanner + 0x28) == 0) {
    pvVar1 = yyalloc(8,yyscanner);
    *(void **)((long)yyscanner + 0x28) = pvVar1;
    if (*(long *)((long)yyscanner + 0x28) == 0) {
                    // WARNING: Subroutine does not return
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()",yyscanner);
    }
    memset(*(void **)((long)yyscanner + 0x28),0,8);
    *(undefined8 *)((long)yyscanner + 0x20) = 1;
    *(undefined8 *)((long)yyscanner + 0x18) = 0;
  }
  else if (*(long *)((long)yyscanner + 0x20) - 1U <= *(ulong *)((long)yyscanner + 0x18)) {
    lVar2 = *(long *)((long)yyscanner + 0x20) + 8;
    pvVar1 = yyrealloc(*(void **)((long)yyscanner + 0x28),lVar2 * 8,yyscanner);
    *(void **)((long)yyscanner + 0x28) = pvVar1;
    if (*(long *)((long)yyscanner + 0x28) == 0) {
                    // WARNING: Subroutine does not return
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()",yyscanner);
    }
    memset((void *)(*(long *)((long)yyscanner + 0x20) * 8 + *(long *)((long)yyscanner + 0x28)),0,
           0x40);
    *(long *)((long)yyscanner + 0x20) = lVar2;
  }
  return;
}



YY_BUFFER_STATE yy_scan_buffer(char *base,yy_size_t size,yyscan_t yyscanner)

{
  YY_BUFFER_STATE new_buffer;
  yyscan_t yyscanner_local;
  yy_size_t size_local;
  char *base_local;
  YY_BUFFER_STATE b;
  
  if (((size < 2) || (base[size - 2] != '\0')) || (base[size - 1] != '\0')) {
    new_buffer = (YY_BUFFER_STATE)0x0;
  }
  else {
    new_buffer = (YY_BUFFER_STATE)yyalloc(0x40,yyscanner);
    if (new_buffer == (YY_BUFFER_STATE)0x0) {
                    // WARNING: Subroutine does not return
      yy_fatal_error("out of dynamic memory in yy_scan_buffer()",yyscanner);
    }
    new_buffer->yy_buf_size = (int)size + -2;
    new_buffer->yy_ch_buf = base;
    new_buffer->yy_buf_pos = new_buffer->yy_ch_buf;
    new_buffer->yy_is_our_buffer = 0;
    new_buffer->yy_input_file = (FILE *)0x0;
    new_buffer->yy_n_chars = new_buffer->yy_buf_size;
    new_buffer->yy_is_interactive = 0;
    new_buffer->yy_at_bol = 1;
    new_buffer->yy_fill_buffer = 0;
    new_buffer->yy_buffer_status = 0;
    yy_switch_to_buffer(new_buffer,yyscanner);
  }
  return new_buffer;
}



YY_BUFFER_STATE yy_scan_string(char *yystr,yyscan_t yyscanner)

{
  size_t sVar1;
  YY_BUFFER_STATE pyVar2;
  yyscan_t yyscanner_local;
  char *yystr_local;
  
  sVar1 = strlen(yystr);
  pyVar2 = yy_scan_bytes(yystr,(int)sVar1,yyscanner);
  return pyVar2;
}



YY_BUFFER_STATE yy_scan_bytes(char *yybytes,int _yybytes_len,yyscan_t yyscanner)

{
  char *base;
  YY_BUFFER_STATE pyVar1;
  yyscan_t yyscanner_local;
  int _yybytes_len_local;
  char *yybytes_local;
  int i;
  yy_size_t n;
  char *buf;
  YY_BUFFER_STATE b;
  
  base = (char *)yyalloc((long)(_yybytes_len + 2),yyscanner);
  if (base == (char *)0x0) {
                    // WARNING: Subroutine does not return
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()",yyscanner);
  }
  for (i = 0; i < _yybytes_len; i = i + 1) {
    base[i] = yybytes[i];
  }
  base[(long)_yybytes_len + 1] = '\0';
  base[_yybytes_len] = base[(long)_yybytes_len + 1];
  pyVar1 = yy_scan_buffer(base,(long)(_yybytes_len + 2),yyscanner);
  if (pyVar1 == (YY_BUFFER_STATE)0x0) {
                    // WARNING: Subroutine does not return
    yy_fatal_error("bad buffer in yy_scan_bytes()",yyscanner);
  }
  pyVar1->yy_is_our_buffer = 1;
  return pyVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void yy_fatal_error(char *msg,yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  char *msg_local;
  yyguts_t *yyg;
  
  fprintf(_stderr,"%s\n",msg);
                    // WARNING: Subroutine does not return
  exit(2);
}



void * yyget_extra(yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
                    // WARNING: Load size is inaccurate
  return *yyscanner;
}



int yyget_lineno(yyscan_t yyscanner)

{
  int iVar1;
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
  if ((*(long *)((long)yyscanner + 0x28) == 0) ||
     (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) == 0)) {
    iVar1 = 0;
  }
  else {
    iVar1 = *(int *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                              *(long *)((long)yyscanner + 0x28)) + 0x2c);
  }
  return iVar1;
}



int yyget_column(yyscan_t yyscanner)

{
  int iVar1;
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
  if ((*(long *)((long)yyscanner + 0x28) == 0) ||
     (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) == 0)) {
    iVar1 = 0;
  }
  else {
    iVar1 = *(int *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 +
                              *(long *)((long)yyscanner + 0x28)) + 0x30);
  }
  return iVar1;
}



FILE * yyget_in(yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
  return *(FILE **)((long)yyscanner + 8);
}



FILE * yyget_out(yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
  return *(FILE **)((long)yyscanner + 0x10);
}



int yyget_leng(yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
  return *(int *)((long)yyscanner + 0x38);
}



char * yyget_text(yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
  return *(char **)((long)yyscanner + 0x80);
}



void yyset_extra(void *user_defined,yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  void *user_defined_local;
  yyguts_t *yyg;
  
  *(void **)yyscanner = user_defined;
  return;
}



void yyset_lineno(int _line_number,yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  int _line_number_local;
  yyguts_t *yyg;
  
  if ((*(long *)((long)yyscanner + 0x28) != 0) &&
     (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) != 0)) {
    *(int *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) +
            0x2c) = _line_number;
    return;
  }
                    // WARNING: Subroutine does not return
  yy_fatal_error("yyset_lineno called with no buffer",yyscanner);
}



void yyset_column(int _column_no,yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  int _column_no_local;
  yyguts_t *yyg;
  
  if ((*(long *)((long)yyscanner + 0x28) != 0) &&
     (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) != 0)) {
    *(int *)(*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) +
            0x30) = _column_no;
    return;
  }
                    // WARNING: Subroutine does not return
  yy_fatal_error("yyset_column called with no buffer",yyscanner);
}



void yyset_in(FILE *_in_str,yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  FILE *_in_str_local;
  yyguts_t *yyg;
  
  *(FILE **)((long)yyscanner + 8) = _in_str;
  return;
}



void yyset_out(FILE *_out_str,yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  FILE *_out_str_local;
  yyguts_t *yyg;
  
  *(FILE **)((long)yyscanner + 0x10) = _out_str;
  return;
}



int yyget_debug(yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
  return *(int *)((long)yyscanner + 0x7c);
}



void yyset_debug(int _bdebug,yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  int _bdebug_local;
  yyguts_t *yyg;
  
  *(int *)((long)yyscanner + 0x7c) = _bdebug;
  return;
}



YYSTYPE * yyget_lval(yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
  return *(YYSTYPE **)((long)yyscanner + 0x90);
}



void yyset_lval(YYSTYPE *yylval_param,yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  YYSTYPE *yylval_param_local;
  yyguts_t *yyg;
  
  *(YYSTYPE **)((long)yyscanner + 0x90) = yylval_param;
  return;
}



YYLTYPE * yyget_lloc(yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
  return *(YYLTYPE **)((long)yyscanner + 0x98);
}



void yyset_lloc(YYLTYPE *yylloc_param,yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  YYLTYPE *yylloc_param_local;
  yyguts_t *yyg;
  
  *(YYLTYPE **)((long)yyscanner + 0x98) = yylloc_param;
  return;
}



int yylex_init(yyscan_t *ptr_yy_globals)

{
  int iVar1;
  int *piVar2;
  void *pvVar3;
  yyscan_t *ptr_yy_globals_local;
  
  if (ptr_yy_globals == (yyscan_t *)0x0) {
    piVar2 = __errno_location();
    *piVar2 = 0x16;
    iVar1 = 1;
  }
  else {
    pvVar3 = yyalloc(0xa0,(yyscan_t)0x0);
    *ptr_yy_globals = pvVar3;
    if (*ptr_yy_globals == (yyscan_t)0x0) {
      piVar2 = __errno_location();
      *piVar2 = 0xc;
      iVar1 = 1;
    }
    else {
      memset(*ptr_yy_globals,0,0xa0);
      iVar1 = yy_init_globals(*ptr_yy_globals);
    }
  }
  return iVar1;
}



int yylex_init_extra(void *yy_user_defined,yyscan_t *ptr_yy_globals)

{
  long lVar1;
  int iVar2;
  int *piVar3;
  void *pvVar4;
  long in_FS_OFFSET;
  yyscan_t *ptr_yy_globals_local;
  void *yy_user_defined_local;
  yyguts_t dummy_yyguts;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  yyset_extra(yy_user_defined,&dummy_yyguts);
  if (ptr_yy_globals == (yyscan_t *)0x0) {
    piVar3 = __errno_location();
    *piVar3 = 0x16;
    iVar2 = 1;
  }
  else {
    pvVar4 = yyalloc(0xa0,&dummy_yyguts);
    *ptr_yy_globals = pvVar4;
    if (*ptr_yy_globals == (yyscan_t)0x0) {
      piVar3 = __errno_location();
      *piVar3 = 0xc;
      iVar2 = 1;
    }
    else {
      memset(*ptr_yy_globals,0,0xa0);
      yyset_extra(yy_user_defined,*ptr_yy_globals);
      iVar2 = yy_init_globals(*ptr_yy_globals);
    }
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int yy_init_globals(yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
  *(undefined8 *)((long)yyscanner + 0x28) = 0;
  *(undefined8 *)((long)yyscanner + 0x18) = 0;
  *(undefined8 *)((long)yyscanner + 0x20) = 0;
  *(undefined8 *)((long)yyscanner + 0x40) = 0;
  *(undefined4 *)((long)yyscanner + 0x48) = 0;
  *(undefined4 *)((long)yyscanner + 0x4c) = 0;
  *(undefined4 *)((long)yyscanner + 0x54) = 0;
  *(undefined4 *)((long)yyscanner + 0x58) = 0;
  *(undefined8 *)((long)yyscanner + 0x60) = 0;
  *(undefined8 *)((long)yyscanner + 8) = 0;
  *(undefined8 *)((long)yyscanner + 0x10) = 0;
  return 0;
}



int yylex_destroy(yyscan_t yyscanner)

{
  YY_BUFFER_STATE b;
  yyscan_t yyscanner_local;
  yyguts_t *yyg;
  
  while ((*(long *)((long)yyscanner + 0x28) != 0 &&
         (*(long *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) != 0)
         )) {
    if (*(long *)((long)yyscanner + 0x28) == 0) {
      b = (YY_BUFFER_STATE)0x0;
    }
    else {
      b = *(YY_BUFFER_STATE *)
           (*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28));
    }
    yy_delete_buffer(b,yyscanner);
    *(undefined8 *)(*(long *)((long)yyscanner + 0x18) * 8 + *(long *)((long)yyscanner + 0x28)) = 0;
    yypop_buffer_state(yyscanner);
  }
  yyfree(*(void **)((long)yyscanner + 0x28),yyscanner);
  *(undefined8 *)((long)yyscanner + 0x28) = 0;
  yyfree(*(void **)((long)yyscanner + 0x60),yyscanner);
  *(undefined8 *)((long)yyscanner + 0x60) = 0;
  yy_init_globals(yyscanner);
  yyfree(yyscanner,yyscanner);
  return 0;
}



void * yyalloc(yy_size_t size,yyscan_t yyscanner)

{
  void *pvVar1;
  yyscan_t yyscanner_local;
  yy_size_t size_local;
  yyguts_t *yyg;
  
  pvVar1 = malloc(size);
  return pvVar1;
}



void * yyrealloc(void *ptr,yy_size_t size,yyscan_t yyscanner)

{
  void *pvVar1;
  yyscan_t yyscanner_local;
  yy_size_t size_local;
  void *ptr_local;
  yyguts_t *yyg;
  
  pvVar1 = realloc(ptr,size);
  return pvVar1;
}



void yyfree(void *ptr,yyscan_t yyscanner)

{
  yyscan_t yyscanner_local;
  void *ptr_local;
  yyguts_t *yyg;
  
  free(ptr);
  return;
}



int yang_check_string(lys_module *module,char **target,char *what,char *where,char *value,
                     lys_node *node)

{
  int iVar1;
  char *pcVar2;
  LY_VLOG_ELEM elem_type;
  lys_node *node_local;
  char *value_local;
  char *where_local;
  char *what_local;
  char **target_local;
  lys_module *module_local;
  
  if (*target == (char *)0x0) {
    pcVar2 = lydict_insert_zc(module->ctx,value);
    *target = pcVar2;
    iVar1 = 0;
  }
  else {
    if (node == (lys_node *)0x0) {
      elem_type = LY_VLOG_NONE;
    }
    else {
      elem_type = LY_VLOG_LYS;
    }
    ly_vlog(module->ctx,LYE_TOOMANY,elem_type,node,what,where);
    free(value);
    iVar1 = 1;
  }
  return iVar1;
}



int yang_read_common(lys_module *module,char *value,yytokentype type)

{
  int iVar1;
  char *pcVar2;
  yytokentype type_local;
  char *value_local;
  lys_module *module_local;
  int ret;
  
  if (type == ORGANIZATION_KEYWORD) {
    iVar1 = yang_check_string(module,&module->org,"organization","module",value,(lys_node *)0x0);
    return iVar1;
  }
  if (type < OUTPUT_KEYWORD) {
    if (type == NAMESPACE_KEYWORD) {
      iVar1 = yang_check_string(module,&module->ns,"namespace","module",value,(lys_node *)0x0);
      return iVar1;
    }
    if (type < NOTIFICATION_KEYWORD) {
      if (type == CONTACT_KEYWORD) {
        iVar1 = yang_check_string(module,&module->contact,"contact","module",value,(lys_node *)0x0);
        return iVar1;
      }
      if (type == MODULE_KEYWORD) {
        pcVar2 = lydict_insert_zc(module->ctx,value);
        module->name = pcVar2;
        return 0;
      }
    }
  }
  free(value);
  ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
         ,0x44);
  return 1;
}



int yang_check_version(lys_module *module,lys_submodule *submodule,char *value,int repeat)

{
  int iVar1;
  bool bVar2;
  int repeat_local;
  char *value_local;
  lys_submodule *submodule_local;
  lys_module *module_local;
  int ret;
  
  ret = 0;
  if (repeat == 0) {
    iVar1 = strcmp(value,"1");
    if (iVar1 == 0) {
      if (submodule == (lys_submodule *)0x0) {
        module->field_0x40 = module->field_0x40 & 0xf1 | 2;
      }
      else {
        bVar2 = 1 < ((byte)module->field_0x40 >> 1 & 7);
        if (bVar2) {
          ly_vlog(module->ctx,LYE_INVER,LY_VLOG_NONE,(void *)0x0);
        }
        ret = (int)bVar2;
        submodule->field_0x40 = submodule->field_0x40 & 0xf1 | 2;
      }
    }
    else {
      iVar1 = strcmp(value,"1.1");
      if (iVar1 == 0) {
        if (submodule == (lys_submodule *)0x0) {
          module->field_0x40 = module->field_0x40 & 0xf1 | 4;
        }
        else {
          bVar2 = (module->field_0x40 & 0xe) != 4;
          if (bVar2) {
            ly_vlog(module->ctx,LYE_INVER,LY_VLOG_NONE,(void *)0x0);
          }
          ret = (int)bVar2;
          submodule->field_0x40 = submodule->field_0x40 & 0xf1 | 4;
        }
      }
      else {
        ly_vlog(module->ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"yang-version");
        ret = 1;
      }
    }
  }
  else {
    ly_vlog(module->ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,"yang version","module");
    ret = 1;
  }
  free(value);
  return ret;
}



int yang_read_prefix(lys_module *module,lys_import *imp,char *value)

{
  int iVar1;
  char *value_local;
  lys_import *imp_local;
  lys_module *module_local;
  int ret;
  
  if ((imp == (lys_import *)0x0) &&
     (iVar1 = lyp_check_identifier(module->ctx,value,LY_IDENT_PREFIX,module,(lys_node *)0x0),
     iVar1 != 0)) {
    free(value);
    iVar1 = 1;
  }
  else if (imp == (lys_import *)0x0) {
    iVar1 = yang_check_string(module,&module->prefix,"prefix","module",value,(lys_node *)0x0);
  }
  else {
    iVar1 = yang_check_string(module,&imp->prefix,"prefix","import",value,(lys_node *)0x0);
  }
  return iVar1;
}



int yang_fill_import(lys_module *module,lys_import *imp_old,lys_import *imp_new,char *value,
                    unres_schema *unres)

{
  int iVar1;
  char *value_00;
  unres_schema *unres_local;
  char *value_local;
  lys_import *imp_new_local;
  lys_import *imp_old_local;
  lys_module *module_local;
  int rc;
  char *exp;
  
  if (imp_old->prefix == (char *)0x0) {
    ly_vlog(module->ctx,LYE_MISSCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"prefix","import");
  }
  else {
    iVar1 = lyp_check_identifier(module->ctx,imp_old->prefix,LY_IDENT_PREFIX,module,(lys_node *)0x0)
    ;
    if (iVar1 == 0) {
      memcpy(imp_new,imp_old,0x38);
      value_00 = lydict_insert_zc(module->ctx,value);
      iVar1 = lyp_check_import(module,value_00,imp_new);
      lydict_remove(module->ctx,value_00);
      module->imp_size = module->imp_size + '\x01';
      if ((iVar1 == 0) &&
         (iVar1 = yang_check_ext_instance
                            (module,&imp_new->ext,(uint)imp_new->ext_size,imp_new,unres), iVar1 == 0
         )) {
        return 0;
      }
      return 1;
    }
  }
  free(value);
  lydict_remove(module->ctx,imp_old->dsc);
  lydict_remove(module->ctx,imp_old->ref);
  lydict_remove(module->ctx,imp_old->prefix);
  lys_extension_instances_free
            (module->ctx,imp_old->ext,(uint)imp_old->ext_size,
             (_func_void_lys_node_ptr_void_ptr *)0x0);
  return 1;
}



int yang_read_description(lys_module *module,void *node,char *value,char *where,yytokentype type)

{
  int iVar1;
  yytokentype type_local;
  char *where_local;
  char *value_local;
  void *node_local;
  lys_module *module_local;
  int ret;
  char *dsc;
  
  if (type == NODE_PRINT) {
    iVar1 = yang_check_string(module,(char **)((long)node + 8),"description",where,value,
                              (lys_node *)node);
    return iVar1;
  }
  if (type < EXTENSION_INSTANCE) {
    if (type == REVISION_KEYWORD) {
      iVar1 = yang_check_string(module,(char **)((long)node + 0x18),"description",where,value,
                                (lys_node *)0x0);
      return iVar1;
    }
    if (type < REVISION_DATE_KEYWORD) {
      if (type == MODULE_KEYWORD) {
        iVar1 = yang_check_string(module,&module->dsc,"description","module",value,(lys_node *)0x0);
        return iVar1;
      }
      if (type < MUST_KEYWORD) {
        if (type == IMPORT_KEYWORD) {
          iVar1 = yang_check_string(module,(char **)((long)node + 0x28),"description",where,value,
                                    (lys_node *)0x0);
          return iVar1;
        }
        if (type == INCLUDE_KEYWORD) {
          iVar1 = yang_check_string(module,(char **)((long)node + 0x20),"description",where,value,
                                    (lys_node *)0x0);
          return iVar1;
        }
      }
    }
  }
  iVar1 = yang_check_string(module,(char **)((long)node + 8),"description",where,value,
                            (lys_node *)0x0);
  return iVar1;
}



int yang_read_reference(lys_module *module,void *node,char *value,char *where,yytokentype type)

{
  int iVar1;
  yytokentype type_local;
  char *where_local;
  char *value_local;
  void *node_local;
  lys_module *module_local;
  int ret;
  char *ref;
  
  if (type == NODE_PRINT) {
    iVar1 = yang_check_string(module,(char **)((long)node + 0x10),"reference",where,value,
                              (lys_node *)node);
    return iVar1;
  }
  if (type < EXTENSION_INSTANCE) {
    if (type == REVISION_KEYWORD) {
      iVar1 = yang_check_string(module,(char **)((long)node + 0x20),"reference",where,value,
                                (lys_node *)0x0);
      return iVar1;
    }
    if (type < REVISION_DATE_KEYWORD) {
      if (type == MODULE_KEYWORD) {
        iVar1 = yang_check_string(module,&module->ref,"reference","module",value,(lys_node *)0x0);
        return iVar1;
      }
      if (type < MUST_KEYWORD) {
        if (type == IMPORT_KEYWORD) {
          iVar1 = yang_check_string(module,(char **)((long)node + 0x30),"reference",where,value,
                                    (lys_node *)0x0);
          return iVar1;
        }
        if (type == INCLUDE_KEYWORD) {
          iVar1 = yang_check_string(module,(char **)((long)node + 0x28),"reference",where,value,
                                    (lys_node *)0x0);
          return iVar1;
        }
      }
    }
  }
  iVar1 = yang_check_string(module,(char **)((long)node + 0x10),"reference",where,value,
                            (lys_node *)0x0);
  return iVar1;
}



int yang_fill_iffeature(lys_module *module,lys_iffeature *iffeature,void *parent,char *value,
                       unres_schema *unres,int parent_is_feature)

{
  uint uVar1;
  int iVar2;
  char *pcVar3;
  int parent_is_feature_local;
  unres_schema *unres_local;
  char *value_local;
  void *parent_local;
  lys_iffeature *iffeature_local;
  lys_module *module_local;
  int ret;
  char *exp;
  
  if ((module->field_0x40 & 0xe) == 4) {
LAB_0018e414:
    pcVar3 = transform_iffeat_schema2json(module,value);
    if (pcVar3 == (char *)0x0) {
      free(value);
      uVar1 = 1;
    }
    else {
      free(value);
      iVar2 = resolve_iffeature_compile(iffeature,pcVar3,(lys_node *)parent,parent_is_feature,unres)
      ;
      lydict_remove(module->ctx,pcVar3);
      uVar1 = (uint)(iVar2 != 0);
    }
  }
  else {
    if (*value != '(') {
      pcVar3 = strchr(value,0x20);
      if (pcVar3 == (char *)0x0) goto LAB_0018e414;
    }
    ly_vlog(module->ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"if-feature");
    free(value);
    uVar1 = 1;
  }
  return uVar1;
}



int yang_read_base(lys_module *module,lys_ident *ident,char *value,unres_schema *unres)

{
  int iVar1;
  char *str;
  unres_schema *unres_local;
  char *value_local;
  lys_ident *ident_local;
  lys_module *module_local;
  char *exp;
  
  str = transform_schema2json(module,value);
  free(value);
  if (str == (char *)0x0) {
    iVar1 = 1;
  }
  else {
    iVar1 = unres_schema_add_str(module,unres,ident,UNRES_IDENT,str);
    if (iVar1 == -1) {
      lydict_remove(module->ctx,str);
      iVar1 = 1;
    }
    else {
      lydict_remove(module->ctx,str);
      iVar1 = 0;
    }
  }
  return iVar1;
}



int yang_read_message(lys_module *module,lys_restr *save,char *value,char *what,int message)

{
  int message_local;
  char *what_local;
  char *value_local;
  lys_restr *save_local;
  lys_module *module_local;
  int ret;
  
  if (message == 0x120) {
    ret = yang_check_string(module,&save->eapptag,"error_app_tag",what,value,(lys_node *)0x0);
  }
  else {
    ret = yang_check_string(module,&save->emsg,"error_message",what,value,(lys_node *)0x0);
  }
  return ret;
}



int yang_read_presence(lys_module *module,lys_node_container *cont,char *value)

{
  char *pcVar1;
  bool bVar2;
  char *value_local;
  lys_node_container *cont_local;
  lys_module *module_local;
  
  bVar2 = cont->presence == (char *)0x0;
  if (bVar2) {
    pcVar1 = lydict_insert_zc(module->ctx,value);
    cont->presence = pcVar1;
  }
  else {
    ly_vlog(module->ctx,LYE_TOOMANY,LY_VLOG_LYS,cont,"presence","container");
    free(value);
  }
  return (int)!bVar2;
}



void * yang_read_when(lys_module *module,lys_node *node,yytokentype type,char *value)

{
  long lVar1;
  long lVar2;
  long lVar3;
  lys_node *__ptr;
  char *pcVar4;
  char *value_local;
  yytokentype type_local;
  lys_node *node_local;
  lys_module *module_local;
  lys_when *retval;
  
  __ptr = (lys_node *)calloc(1,0x28);
  if (__ptr == (lys_node *)0x0) {
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_when");
    free(value);
    return (void *)0x0;
  }
  pcVar4 = transform_schema2json(module,value);
  __ptr->name = pcVar4;
  if (__ptr->name == (char *)0x0) goto LAB_0018eacc;
  if (type == EXTENSION_INSTANCE) {
    node->name = (char *)__ptr;
    goto LAB_0018eab6;
  }
  if (EXTENSION_INSTANCE < type) goto LAB_0018eacc;
  if (type == ANYDATA_KEYWORD) {
switchD_0018e786_caseD_103:
    if (node[1].name == (char *)0x0) {
      node[1].name = (char *)__ptr;
LAB_0018eab6:
      free(value);
      return __ptr;
    }
    if (type == ANYXML_KEYWORD) {
      pcVar4 = "anyxml";
    }
    else {
      pcVar4 = "anydata";
    }
    ly_vlog(module->ctx,LYE_TOOMANY,LY_VLOG_LYS,node,&DAT_00224961,pcVar4);
  }
  else {
    if (ANYDATA_KEYWORD < type) goto LAB_0018eacc;
    if (LIST_KEYWORD < type) {
      if (type == USES_KEYWORD) {
        lVar3._0_1_ = node->hash[0];
        lVar3._1_1_ = node->hash[1];
        lVar3._2_1_ = node->hash[2];
        lVar3._3_1_ = node->hash[3];
        lVar3._4_4_ = *(undefined4 *)&node->field_0x6c;
        if (lVar3 == 0) {
          *(lys_node **)node->hash = __ptr;
          goto LAB_0018eab6;
        }
        ly_vlog(module->ctx,LYE_TOOMANY,LY_VLOG_LYS,node,&DAT_00224961,&DAT_00224994);
      }
      goto LAB_0018eacc;
    }
    if ((type < ANYXML_KEYWORD) || (false)) goto LAB_0018eacc;
    switch(type) {
    case ANYXML_KEYWORD:
      goto switchD_0018e786_caseD_103;
    case AUGMENT_KEYWORD:
      if (node->next != (lys_node *)0x0) {
        ly_vlog(module->ctx,LYE_TOOMANY,LY_VLOG_LYS,node,&DAT_00224961,"augment");
        break;
      }
      node->next = __ptr;
      goto LAB_0018eab6;
    case CASE_KEYWORD:
      lVar2._0_1_ = node->hash[0];
      lVar2._1_1_ = node->hash[1];
      lVar2._2_1_ = node->hash[2];
      lVar2._3_1_ = node->hash[3];
      lVar2._4_4_ = *(undefined4 *)&node->field_0x6c;
      if (lVar2 == 0) {
        *(lys_node **)node->hash = __ptr;
        goto LAB_0018eab6;
      }
      ly_vlog(module->ctx,LYE_TOOMANY,LY_VLOG_LYS,node,&DAT_00224961,&DAT_0022497c);
      break;
    case CHOICE_KEYWORD:
      lVar1._0_1_ = node->hash[0];
      lVar1._1_1_ = node->hash[1];
      lVar1._2_1_ = node->hash[2];
      lVar1._3_1_ = node->hash[3];
      lVar1._4_4_ = *(undefined4 *)&node->field_0x6c;
      if (lVar1 == 0) {
        *(lys_node **)node->hash = __ptr;
        goto LAB_0018eab6;
      }
      ly_vlog(module->ctx,LYE_TOOMANY,LY_VLOG_LYS,node,&DAT_00224961,"choice");
      break;
    case CONTAINER_KEYWORD:
      if (node[1].name == (char *)0x0) {
        node[1].name = (char *)__ptr;
        goto LAB_0018eab6;
      }
      ly_vlog(module->ctx,LYE_TOOMANY,LY_VLOG_LYS,node,&DAT_00224961,"container");
      break;
    case LEAF_KEYWORD:
      if (node[1].name == (char *)0x0) {
        node[1].name = (char *)__ptr;
        goto LAB_0018eab6;
      }
      ly_vlog(module->ctx,LYE_TOOMANY,LY_VLOG_LYS,node,&DAT_00224961,&DAT_00224981);
      break;
    case LEAF_LIST_KEYWORD:
      if (node[1].name == (char *)0x0) {
        node[1].name = (char *)__ptr;
        goto LAB_0018eab6;
      }
      ly_vlog(module->ctx,LYE_TOOMANY,LY_VLOG_LYS,node,&DAT_00224961,"leaflist");
      break;
    case LIST_KEYWORD:
      if (node[1].name == (char *)0x0) {
        node[1].name = (char *)__ptr;
        goto LAB_0018eab6;
      }
      ly_vlog(module->ctx,LYE_TOOMANY,LY_VLOG_LYS,node,&DAT_00224961,&DAT_0022498f);
    }
  }
LAB_0018eacc:
  free(value);
  lydict_remove(module->ctx,__ptr->name);
  free(__ptr);
  return (void *)0x0;
}



void * yang_read_node(lys_module *module,lys_node *parent,lys_node **root,char *value,int nodetype,
                     int sizeof_struct)

{
  lys_node *plVar1;
  char *pcVar2;
  int sizeof_struct_local;
  int nodetype_local;
  char *value_local;
  lys_node **root_local;
  lys_node *parent_local;
  lys_module *module_local;
  lys_node *node;
  lys_node **child;
  
  plVar1 = (lys_node *)calloc(1,(long)sizeof_struct);
  if (plVar1 == (lys_node *)0x0) {
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_node");
    free(value);
    plVar1 = (lys_node *)0x0;
  }
  else {
    pcVar2 = strnodetype(nodetype);
    ly_log_dbg(2,"parsing %s statement \"%s\"",pcVar2,value);
    pcVar2 = lydict_insert_zc(module->ctx,value);
    plVar1->name = pcVar2;
    plVar1->module = module;
    plVar1->nodetype = nodetype;
    plVar1->parent = parent;
    if (parent != (lys_node *)0x0) {
      root = &parent->child;
    }
    if (*root == (lys_node *)0x0) {
      *root = plVar1;
      plVar1->prev = plVar1;
    }
    else {
      (*root)->prev->next = plVar1;
      (*root)->prev = plVar1;
    }
  }
  return plVar1;
}



int yang_read_default(lys_module *module,void *node,char *value,yytokentype type)

{
  yytokentype type_local;
  char *value_local;
  void *node_local;
  lys_module *module_local;
  int ret;
  
  if (type == LEAF_KEYWORD) {
    ret = yang_check_string(module,(char **)((long)node + 200),"default","leaf",value,
                            (lys_node *)node);
  }
  else if (type == TYPEDEF_KEYWORD) {
    ret = yang_check_string(module,(char **)((long)node + 0x78),"default","typedef",value,
                            (lys_node *)0x0);
  }
  else {
    free(value);
    ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
           ,0x1af);
    ret = 1;
  }
  return ret;
}



int yang_read_units(lys_module *module,void *node,char *value,yytokentype type)

{
  yytokentype type_local;
  char *value_local;
  void *node_local;
  lys_module *module_local;
  int ret;
  
  if (false) {
switchD_0018ed88_caseD_130:
    free(value);
    ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
           ,0x1cc);
    ret = 1;
  }
  else {
    switch(type) {
    case LEAF_KEYWORD:
      ret = yang_check_string(module,(char **)((long)node + 0xc0),"units","leaf",value,
                              (lys_node *)node);
      break;
    case LEAF_LIST_KEYWORD:
      ret = yang_check_string(module,(char **)((long)node + 0xc0),"units","leaflist",value,
                              (lys_node *)node);
      break;
    default:
      goto switchD_0018ed88_caseD_130;
    case TYPEDEF_KEYWORD:
      ret = yang_check_string(module,(char **)((long)node + 0x28),"units","typedef",value,
                              (lys_node *)0x0);
      break;
    case ADD_KEYWORD:
    case DELETE_KEYWORD:
    case REPLACE_KEYWORD:
      ret = yang_check_string(module,(char **)((long)node + 0x30),"units","deviate",value,
                              (lys_node *)0x0);
    }
  }
  return ret;
}



int yang_read_key(lys_module *module,lys_node_list *list,unres_schema *unres)

{
  int iVar1;
  ushort **ppuVar2;
  char *pcVar3;
  lys_node_leaf **pplVar4;
  unres_schema *unres_local;
  lys_node_list *list_local;
  lys_module *module_local;
  char *value;
  char *exp;
  
  pplVar4 = list->keys;
  value = (char *)pplVar4;
  while( true ) {
    value = strpbrk(value," \t\n");
    if (value == (char *)0x0) break;
    list->keys_size = list->keys_size + '\x01';
    while( true ) {
      ppuVar2 = __ctype_b_loc();
      if (((*ppuVar2)[*value] & 0x2000) == 0) break;
      value = value + 1;
    }
  }
  list->keys_size = list->keys_size + '\x01';
  pcVar3 = lydict_insert_zc(module->ctx,(char *)pplVar4);
  list->keys_str = pcVar3;
  pplVar4 = (lys_node_leaf **)calloc((ulong)list->keys_size,8);
  list->keys = pplVar4;
  if (list->keys == (lys_node_leaf **)0x0) {
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_key");
    iVar1 = 1;
  }
  else {
    iVar1 = unres_schema_add_node(module,unres,list,UNRES_LIST_KEYS,(lys_node *)0x0);
    if (iVar1 == -1) {
      iVar1 = 1;
    }
    else {
      iVar1 = 0;
    }
  }
  return iVar1;
}



int yang_fill_unique(lys_module *module,lys_node_list *list,lys_unique *unique,char *value,
                    unres_schema *unres)

{
  int iVar1;
  char **ppcVar2;
  char *pcVar3;
  char *pcVar4;
  undefined8 *item;
  ushort **ppuVar5;
  unres_schema *unres_local;
  char *value_local;
  lys_unique *unique_local;
  lys_node_list *list_local;
  lys_module *module_local;
  char c;
  int i;
  int j;
  char *vaux;
  unres_list_uniq *unique_info;
  
  vaux = value;
  while (vaux = strpbrk(vaux," \t\n"), vaux != (char *)0x0) {
    unique->expr_size = unique->expr_size + '\x01';
    while (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[*vaux] & 0x2000) != 0) {
      vaux = vaux + 1;
    }
  }
  unique->expr_size = unique->expr_size + '\x01';
  ppcVar2 = (char **)calloc((ulong)unique->expr_size,8);
  unique->expr = ppcVar2;
  if (unique->expr == (char **)0x0) {
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_fill_unique");
LAB_0018f3e2:
    iVar1 = 1;
  }
  else {
    value_local = value;
    for (i = 0; i < (int)(uint)unique->expr_size; i = i + 1) {
      pcVar3 = strpbrk(value_local," \t\n");
      if (pcVar3 != (char *)0x0) {
        c = *pcVar3;
        *pcVar3 = '\0';
      }
      ppcVar2 = unique->expr;
      pcVar4 = transform_schema2json(module,value_local);
      ppcVar2[i] = pcVar4;
      if (unique->expr[i] == (char *)0x0) {
        ly_vlog(module->ctx,LYE_INARG,LY_VLOG_LYS,list,value_local,"unique");
        goto LAB_0018f3e2;
      }
      if (pcVar3 != (char *)0x0) {
        *pcVar3 = c;
      }
      for (j = 0; j < i; j = j + 1) {
        if (unique->expr[j] == unique->expr[i]) {
          ly_vlog(module->ctx,LYE_INARG,LY_VLOG_LYS,list,unique->expr[i],"unique");
          ly_vlog(module->ctx,LYE_SPEC,LY_VLOG_LYS,list,"The identifier is not unique");
          goto LAB_0018f3e2;
        }
      }
      value_local = pcVar3;
      if (unres == (unres_schema *)0x0) {
        iVar1 = resolve_unique((lys_node *)list,unique->expr[i],&unique->trg_type);
        if (iVar1 != 0) goto LAB_0018f3e2;
      }
      else {
        item = (undefined8 *)malloc(0x18);
        if (item == (undefined8 *)0x0) {
          ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_fill_unique")
          ;
          goto LAB_0018f3e2;
        }
        *item = list;
        item[1] = unique->expr[i];
        item[2] = &unique->trg_type;
        iVar1 = unres_schema_add_node(module,unres,item,UNRES_LIST_UNIQ,(lys_node *)0x0);
        if (iVar1 == -1) goto LAB_0018f3e2;
      }
      while ((value_local != (char *)0x0 &&
             (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[*value_local] & 0x2000) != 0))) {
        value_local = value_local + 1;
      }
    }
    iVar1 = 0;
  }
  return iVar1;
}



int yang_read_unique(lys_module *module,lys_node_list *list,unres_schema *unres)

{
  char **value;
  int iVar1;
  unres_schema *unres_local;
  lys_node_list *list_local;
  lys_module *module_local;
  uint8_t k;
  char *str;
  
  k = '\0';
  while( true ) {
    if (list->unique_size <= k) {
      return 0;
    }
    value = list->unique[k].expr;
    iVar1 = yang_fill_unique(module,list,list->unique + k,(char *)value,unres);
    if (iVar1 != 0) break;
    free(value);
    k = k + '\x01';
  }
  free(value);
  return 1;
}



int yang_read_leafref_path(lys_module *module,yang_type *stype,char *value)

{
  lys_type *plVar1;
  char *pcVar2;
  char *value_local;
  yang_type *stype_local;
  lys_module *module_local;
  
  if ((stype->base == LY_TYPE_DER) || (stype->base == LY_TYPE_LEAFREF)) {
    if ((stype->type->info).bits.bit == (lys_type_bit *)0x0) {
      plVar1 = stype->type;
      pcVar2 = lydict_insert_zc(module->ctx,value);
      (plVar1->info).lref.path = pcVar2;
      stype->base = LY_TYPE_LEAFREF;
      return 0;
    }
    ly_vlog(module->ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,&DAT_00224b8a,&DAT_00224b85);
  }
  else {
    ly_vlog(module->ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"require-instance");
  }
  free(value);
  return 1;
}



int yang_read_require_instance(ly_ctx *ctx,yang_type *stype,int req)

{
  int iVar1;
  int req_local;
  yang_type *stype_local;
  ly_ctx *ctx_local;
  
  if ((stype->base == LY_TYPE_DER) || (stype->base == LY_TYPE_LEAFREF)) {
    if ((stype->type->info).lref.req == '\0') {
      (stype->type->info).lref.req = (int8_t)req;
      stype->base = LY_TYPE_LEAFREF;
      iVar1 = 0;
    }
    else {
      ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,"require-instance",&DAT_00224b85);
      iVar1 = 1;
    }
  }
  else {
    ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"require-instance");
    iVar1 = 1;
  }
  return iVar1;
}


/*
Unable to decompile 'yang_check_type'
Cause: Exception while decompiling 0018f654: process: timeout

*/


void yang_free_type_union(ly_ctx *ctx,lys_type *type)

{
  lys_tpdf *__ptr;
  lys_type *type_00;
  lys_type *type_local;
  ly_ctx *ctx_local;
  uint i;
  lys_type *stype;
  yang_type *yang;
  
  for (i = 0; i < (type->info).bits.count; i = i + 1) {
    type_00 = (lys_type *)((long)(type->info).bits.bit + (ulong)i * 0x40);
    if (type_00->base == LY_TYPE_DER) {
      __ptr = type_00->der;
      type_00->base = *(LY_DATA_TYPE *)((long)&__ptr->name + 4);
      lydict_remove(ctx,__ptr->dsc);
      free(__ptr);
    }
    else if (type_00->base == LY_TYPE_UNION) {
      yang_free_type_union(ctx,type_00);
    }
  }
  return;
}



void * yang_read_type(ly_ctx *ctx,void *parent,char *value,yytokentype type)

{
  undefined *__ptr;
  void *pvVar1;
  char *pcVar2;
  yytokentype type_local;
  char *value_local;
  void *parent_local;
  ly_ctx *ctx_local;
  yang_type *typ;
  lys_deviate *dev;
  
  __ptr = (undefined *)calloc(1,0x18);
  if (__ptr == (undefined *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_type");
    return (void *)0x0;
  }
  *__ptr = 0x80;
  if (type == EXTENSION_INSTANCE) {
    *(undefined **)((long)parent + 0x10) = __ptr;
    *(void **)(__ptr + 0x10) = parent;
    goto LAB_00191483;
  }
  if (type < SUBMODULE_EXT_KEYWORD) {
    if (type == REPLACE_KEYWORD) {
      if (*(long *)((long)parent + 0x28) == 0) {
        pvVar1 = calloc(1,0x40);
        *(void **)((long)parent + 0x28) = pvVar1;
        if (*(long *)((long)parent + 0x28) != 0) {
          *(undefined **)(*(long *)((long)parent + 0x28) + 0x10) = __ptr;
          *(undefined8 *)(__ptr + 0x10) = *(undefined8 *)((long)parent + 0x28);
          goto LAB_00191483;
        }
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_type");
      }
      else {
        ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,&DAT_00224b85,"deviation");
      }
    }
    else if (type < SYSTEM_KEYWORD) {
      if (type == TYPEDEF_KEYWORD) {
        if (*(long *)((long)parent + 0x48) == 0) {
          *(undefined **)((long)parent + 0x48) = __ptr;
          *(long *)(__ptr + 0x10) = (long)parent + 0x38;
          goto LAB_00191483;
        }
        ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,&DAT_00224b85,"typedef");
      }
      else if (type < UNIQUE_KEYWORD) {
        if (type == LEAF_LIST_KEYWORD) {
          if (*(long *)((long)parent + 0x90) == 0) {
            *(undefined **)((long)parent + 0x90) = __ptr;
            *(void **)((long)parent + 0x98) = parent;
            *(long *)(__ptr + 0x10) = (long)parent + 0x80;
            goto LAB_00191483;
          }
          ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYS,parent,&DAT_00224b85,"leaf-list");
        }
        else if (type < LENGTH_KEYWORD) {
          if (type == UNION_KEYWORD) {
            *(undefined **)((long)parent + 0x10) = __ptr;
            *(void **)(__ptr + 0x10) = parent;
LAB_00191483:
            pcVar2 = lydict_insert_zc(ctx,value);
            *(char **)(__ptr + 8) = pcVar2;
            return __ptr;
          }
          if (type == LEAF_KEYWORD) {
            if (*(long *)((long)parent + 0x90) == 0) {
              *(undefined **)((long)parent + 0x90) = __ptr;
              *(void **)((long)parent + 0x98) = parent;
              *(long *)(__ptr + 0x10) = (long)parent + 0x80;
              goto LAB_00191483;
            }
            ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_LYS,parent,&DAT_00224b85,&DAT_00224981);
          }
        }
      }
    }
  }
  free(value);
  free(__ptr);
  return (void *)0x0;
}



void * yang_read_length(ly_ctx *ctx,yang_type *stype,char *value,int is_ext_instance)

{
  char *pcVar1;
  int is_ext_instance_local;
  char *value_local;
  yang_type *stype_local;
  ly_ctx *ctx_local;
  lys_restr *length;
  
  length = (lys_restr *)stype;
  if (is_ext_instance == 0) {
    if ((stype->base == LY_TYPE_DER) || (stype->base == LY_TYPE_STRING)) {
      stype->base = LY_TYPE_STRING;
      if ((stype->type->info).bits.bit == (lys_type_bit *)0x0) {
        length = (lys_restr *)calloc(1,0x38);
        if (length != (lys_restr *)0x0) {
          (stype->type->info).dec64.range = length;
          goto LAB_001915d8;
        }
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_length");
      }
      else {
        ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,"length",&DAT_00224b85);
      }
    }
    else {
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Unexpected length statement.");
    }
    free(value);
    length = (lys_restr *)0x0;
  }
  else {
LAB_001915d8:
    pcVar1 = lydict_insert_zc(ctx,value);
    length->expr = pcVar1;
  }
  return length;
}



int yang_read_pattern(ly_ctx *ctx,lys_restr *pattern,void **precomp,char *value,char modifier)

{
  int iVar1;
  size_t sVar2;
  char *value_00;
  char *pcVar3;
  char modifier_local;
  char *value_local;
  void **precomp_local;
  lys_restr *pattern_local;
  ly_ctx *ctx_local;
  size_t len;
  char *buf;
  
  if ((precomp != (void **)0x0) &&
     (iVar1 = lyp_precompile_pattern(ctx,value,(pcre **)precomp,(pcre_extra **)(precomp + 1)),
     iVar1 != 0)) {
    free(value);
    return 1;
  }
  sVar2 = strlen(value);
  value_00 = (char *)malloc(sVar2 + 2);
  if (value_00 != (char *)0x0) {
    *value_00 = modifier;
    strcpy(value_00 + 1,value);
    free(value);
    pcVar3 = lydict_insert_zc(ctx,value_00);
    pattern->expr = pcVar3;
  }
  else {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_pattern");
    free(value);
  }
  return (uint)(value_00 == (char *)0x0);
}



void * yang_read_range(ly_ctx *ctx,yang_type *stype,char *value,int is_ext_instance)

{
  char *pcVar1;
  int is_ext_instance_local;
  char *value_local;
  yang_type *stype_local;
  ly_ctx *ctx_local;
  lys_restr *range;
  
  range = (lys_restr *)stype;
  if (is_ext_instance == 0) {
    if ((stype->base == LY_TYPE_DER) || (stype->base == LY_TYPE_DEC64)) {
      stype->base = LY_TYPE_DEC64;
      if ((stype->type->info).bits.bit == (lys_type_bit *)0x0) {
        range = (lys_restr *)calloc(1,0x38);
        if (range != (lys_restr *)0x0) {
          (stype->type->info).dec64.range = range;
          goto LAB_00191831;
        }
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_range");
      }
      else {
        ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,"range",&DAT_00224b85);
      }
    }
    else {
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Unexpected range statement.");
    }
    free(value);
    range = (lys_restr *)0x0;
  }
  else {
LAB_00191831:
    pcVar1 = lydict_insert_zc(ctx,value);
    range->expr = pcVar1;
  }
  return range;
}



int yang_read_fraction(ly_ctx *ctx,yang_type *typ,uint32_t value)

{
  uint32_t value_local;
  yang_type *typ_local;
  ly_ctx *ctx_local;
  uint32_t i;
  
  if ((typ->base == LY_TYPE_DER) || (typ->base == LY_TYPE_DEC64)) {
    typ->base = LY_TYPE_DEC64;
    if ((typ->type->info).dec64.dig == '\0') {
      if ((value != 0) && (value < 0x13)) {
        (typ->type->info).dec64.dig = (uint8_t)value;
        (typ->type->info).dec64.div = 10;
        for (i = 1; i < value; i = i + 1) {
          (typ->type->info).dec64.div = (typ->type->info).dec64.div * 10;
        }
        return 0;
      }
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid value \"%d\" of \"%s\".",(ulong)value,
              "fraction-digits");
    }
    else {
      ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,"fraction-digits",&DAT_00224b85);
    }
  }
  else {
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Unexpected fraction-digits statement.");
  }
  return 1;
}



int yang_read_enum(ly_ctx *ctx,yang_type *typ,lys_type_enum *enm,char *value)

{
  ushort *puVar1;
  char *pcVar2;
  ushort **ppuVar3;
  size_t sVar4;
  char *value_local;
  lys_type_enum *enm_local;
  yang_type *typ_local;
  ly_ctx *ctx_local;
  int i;
  int j;
  
  typ->base = LY_TYPE_ENUM;
  if (*value == '\0') {
    ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"enum name");
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Enum name must not be empty.");
    free(value);
  }
  else {
    pcVar2 = lydict_insert_zc(ctx,value);
    enm->name = pcVar2;
    ppuVar3 = __ctype_b_loc();
    if (((*ppuVar3)[*enm->name] & 0x2000) == 0) {
      ppuVar3 = __ctype_b_loc();
      puVar1 = *ppuVar3;
      pcVar2 = enm->name;
      sVar4 = strlen(enm->name);
      if ((puVar1[pcVar2[sVar4 - 1]] & 0x2000) == 0) {
        i = 0;
        while( true ) {
          if ((int)((typ->type->info).bits.count - 1) <= i) {
            return 0;
          }
          if ((typ->type->info).bits.bit[i].name == enm->name) break;
          i = i + 1;
        }
        ly_vlog(ctx,LYE_ENUM_DUPNAME,LY_VLOG_NONE,(void *)0x0,enm->name);
        return 1;
      }
    }
    ly_vlog(ctx,LYE_ENUM_WS,LY_VLOG_NONE,(void *)0x0,enm->name);
  }
  return 1;
}



int yang_check_enum(ly_ctx *ctx,yang_type *typ,lys_type_enum *enm,int64_t *value,int assign)

{
  int iVar1;
  int assign_local;
  int64_t *value_local;
  lys_type_enum *enm_local;
  yang_type *typ_local;
  ly_ctx *ctx_local;
  int i;
  int j;
  
  if (assign == 0) {
    if (0x7fffffff < *value) {
      ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,"2147483648","enum/value");
      return 1;
    }
    enm->value = (int32_t)*value;
    enm->flags = enm->flags | 1;
    *value = *value + 1;
  }
  else if ((lys_type_bit *)enm == (typ->type->info).bits.bit) {
    *value = (long)((typ->type->info).enums.enm)->value;
    *value = *value + 1;
  }
  iVar1 = (typ->type->info).bits.count - 1;
  i = 0;
  while( true ) {
    if (iVar1 <= i) {
      return 0;
    }
    if ((typ->type->info).bits.bit[i].pos == (typ->type->info).bits.bit[iVar1].pos) break;
    i = i + 1;
  }
  ly_vlog(ctx,LYE_ENUM_DUPVAL,LY_VLOG_NONE,(void *)0x0,(ulong)(typ->type->info).bits.bit[iVar1].pos,
          (typ->type->info).bits.bit[iVar1].name,(typ->type->info).bits.bit[i].name);
  return 1;
}



int yang_read_bit(ly_ctx *ctx,yang_type *typ,lys_type_bit *bit,char *value)

{
  int iVar1;
  char *pcVar2;
  char *value_local;
  lys_type_bit *bit_local;
  yang_type *typ_local;
  ly_ctx *ctx_local;
  int i;
  int j;
  
  typ->base = LY_TYPE_BITS;
  pcVar2 = lydict_insert_zc(ctx,value);
  bit->name = pcVar2;
  iVar1 = lyp_check_identifier(ctx,bit->name,LY_IDENT_SIMPLE,(lys_module *)0x0,(lys_node *)0x0);
  if (iVar1 == 0) {
    for (i = 0; i < (int)((typ->type->info).bits.count - 1); i = i + 1) {
      if ((typ->type->info).bits.bit[i].name == bit->name) {
        ly_vlog(ctx,LYE_BITS_DUPNAME,LY_VLOG_NONE,(void *)0x0,bit->name);
        goto LAB_00191eab;
      }
    }
    iVar1 = 0;
  }
  else {
LAB_00191eab:
    iVar1 = 1;
  }
  return iVar1;
}



int yang_check_bit(ly_ctx *ctx,yang_type *typ,lys_type_bit *bit,int64_t *value,int assign)

{
  int assign_local;
  int64_t *value_local;
  lys_type_bit *bit_local;
  yang_type *typ_local;
  ly_ctx *ctx_local;
  int i;
  int j;
  
  if (assign == 0) {
    if (0xffffffff < *value) {
      ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,"4294967295","bit/position");
      return 1;
    }
    bit->pos = (uint32_t)*value;
    bit->flags = bit->flags | 1;
    *value = *value + 1;
  }
  i = 0;
  while( true ) {
    if ((int)((typ->type->info).bits.count - 1) <= i) {
      return 0;
    }
    if ((typ->type->info).bits.bit[i].pos == bit->pos) break;
    i = i + 1;
  }
  ly_vlog(ctx,LYE_BITS_DUPVAL,LY_VLOG_NONE,(void *)0x0,(ulong)bit->pos,bit->name,
          (typ->type->info).bits.bit[i].name);
  return 1;
}



int yang_read_augment(lys_module *module,lys_node *parent,lys_node_augment *aug,char *value)

{
  char *pcVar1;
  bool bVar2;
  char *value_local;
  lys_node_augment *aug_local;
  lys_node *parent_local;
  lys_module *module_local;
  
  aug->nodetype = LYS_AUGMENT;
  pcVar1 = transform_schema2json(module,value);
  aug->target_name = pcVar1;
  free(value);
  bVar2 = aug->target_name != (char *)0x0;
  if (bVar2) {
    aug->parent = parent;
    aug->module = module;
  }
  return (int)!bVar2;
}



void * yang_read_deviate_unsupported(ly_ctx *ctx,lys_deviation *dev)

{
  lys_deviate *plVar1;
  lys_deviation *dev_local;
  ly_ctx *ctx_local;
  
  if (dev->deviate_size == '\0') {
    plVar1 = (lys_deviate *)calloc(1,0x48);
    dev->deviate = plVar1;
    if (dev->deviate == (lys_deviate *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_deviate_unsupported"
            );
      plVar1 = (lys_deviate *)0x0;
    }
    else {
      dev->deviate[dev->deviate_size].mod = LY_DEVIATE_NO;
      dev->deviate_size = '\x01';
      plVar1 = dev->deviate;
    }
  }
  else {
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
            "\"not-supported\" deviation cannot be combined with any other deviation.");
    plVar1 = (lys_deviate *)0x0;
  }
  return plVar1;
}



void * yang_read_deviate(ly_ctx *ctx,lys_deviation *dev,LYS_DEVIATE_TYPE mod)

{
  byte bVar1;
  lys_deviate *plVar2;
  LYS_DEVIATE_TYPE mod_local;
  lys_deviation *dev_local;
  ly_ctx *ctx_local;
  lys_deviate *deviate;
  
  if ((dev->deviate_size == '\0') || (dev->deviate->mod != LY_DEVIATE_NO)) {
    if ((dev->deviate_size & 7) == 0) {
      plVar2 = (lys_deviate *)realloc(dev->deviate,(long)(int)(dev->deviate_size + 8) * 0x48);
      if (plVar2 == (lys_deviate *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_deviate");
        return (void *)0x0;
      }
      memset(plVar2 + dev->deviate_size,0,0x240);
      dev->deviate = plVar2;
    }
    dev->deviate[dev->deviate_size].mod = mod;
    bVar1 = dev->deviate_size;
    dev->deviate_size = bVar1 + 1;
    plVar2 = dev->deviate + bVar1;
  }
  else {
    ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"not-supported");
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
            "\"not-supported\" deviation cannot be combined with any other deviation.");
    plVar2 = (lys_deviate *)0x0;
  }
  return plVar2;
}



int yang_read_deviate_units(ly_ctx *ctx,lys_deviate *deviate,lys_node *dev_target)

{
  int iVar1;
  char *pcVar2;
  lys_node *dev_target_local;
  lys_deviate *deviate_local;
  ly_ctx *ctx_local;
  int j;
  char **stritem;
  
  if ((dev_target->nodetype != LYS_LEAFLIST) && (dev_target->nodetype != LYS_LEAF)) {
    ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"units");
    ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Target node does not allow \"units\" property.");
    return 1;
  }
  stritem = (char **)&dev_target[1].next;
  if (deviate->mod == LY_DEVIATE_DEL) {
    if (*stritem != deviate->units) {
      ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,deviate->units,"units");
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Value differs from the target being deleted.");
      return 1;
    }
    lydict_remove(ctx,*stritem);
    *stritem = (char *)0x0;
    j = -1;
    while (iVar1 = lys_ext_iter(dev_target->ext,dev_target->ext_size,(char)j + '\x01',
                                LYEXT_SUBSTMT_UNITS), iVar1 != -1) {
      lyp_ext_instance_rm(ctx,&dev_target->ext,&dev_target->ext_size,(uint8_t)iVar1);
      j = iVar1 + -1;
    }
  }
  else {
    if (deviate->mod == LY_DEVIATE_ADD) {
      if (*stritem != (char *)0x0) {
        ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"units");
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Adding property that already exists.");
        return 1;
      }
    }
    else if (*stritem == (char *)0x0) {
      ly_vlog(ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"units");
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Replacing a property that does not exist.");
      return 1;
    }
    lydict_remove(ctx,*stritem);
    pcVar2 = lydict_insert(ctx,deviate->units,0);
    *stritem = pcVar2;
  }
  return 0;
}



int yang_read_deviate_unique(lys_deviate *deviate,lys_node *dev_target)

{
  ly_ctx *ctx_00;
  int iVar1;
  lys_ext_instance **pplVar2;
  lys_node *dev_target_local;
  lys_deviate *deviate_local;
  ly_ctx *ctx;
  lys_node_list *list;
  lys_unique *unique;
  
  ctx_00 = dev_target->module->ctx;
  if (dev_target->nodetype == LYS_LIST) {
    if (deviate->mod == LY_DEVIATE_ADD) {
      pplVar2 = (lys_ext_instance **)
                ly_realloc(dev_target[1].ext,
                           (long)(int)((uint)dev_target->padding[3] + (uint)deviate->unique_size) <<
                           4);
      if (pplVar2 == (lys_ext_instance **)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_deviate_unique"
              );
        goto LAB_00192744;
      }
      dev_target[1].ext = pplVar2;
      memset(pplVar2 + (ulong)dev_target->padding[3] * 2,0,(ulong)deviate->unique_size << 4);
    }
    iVar1 = 0;
  }
  else {
    ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"unique");
    ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
            "Target node does not allow \"unique\" property.");
LAB_00192744:
    iVar1 = 1;
  }
  return iVar1;
}



int yang_fill_deviate_default
              (ly_ctx *ctx,lys_deviate *deviate,lys_node *dev_target,ly_set *dflt_check,char *value)

{
  byte bVar1;
  lys_node *plVar2;
  int iVar3;
  size_t sVar4;
  char *pcVar5;
  long in_FS_OFFSET;
  char *value_local;
  ly_set *dflt_check_local;
  lys_node *dev_target_local;
  lys_deviate *deviate_local;
  ly_ctx *ctx_local;
  int i;
  int j;
  uint u;
  int rc;
  lys_node *node;
  lys_node_leaflist *llist;
  lys_node_leaf *leaf;
  lys_node_choice *choice;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  sVar4 = strlen(value);
  if (dev_target->nodetype != LYS_CHOICE) {
    if (dev_target->nodetype == LYS_LEAF) {
      leaf = (lys_node_leaf *)dev_target;
      if (deviate->mod == LY_DEVIATE_DEL) {
        if ((dev_target[1].prev == (lys_node *)0x0) || ((lys_node *)value != dev_target[1].prev)) {
          ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                  "Value differs from the target being deleted.");
          goto LAB_00192e41;
        }
        lydict_remove(ctx,(char *)dev_target[1].prev);
        leaf->dflt = (char *)0x0;
        leaf->flags = leaf->flags & 0xefff;
        j = -1;
        while (iVar3 = lys_ext_iter(dev_target->ext,dev_target->ext_size,(char)j + '\x01',
                                    LYEXT_SUBSTMT_DEFAULT), iVar3 != -1) {
          lyp_ext_instance_rm(ctx,&dev_target->ext,&dev_target->ext_size,(uint8_t)iVar3);
          j = iVar3 + -1;
        }
      }
      else {
        lydict_remove(ctx,(char *)dev_target[1].prev);
        leaf->flags = leaf->flags & 0xefff;
        pcVar5 = lydict_insert(ctx,value,sVar4 & 0xffffffff);
        leaf->dflt = pcVar5;
        ly_set_add(dflt_check,dev_target,0);
      }
    }
    else {
      llist = (lys_node_leaflist *)dev_target;
      if (deviate->mod == LY_DEVIATE_DEL) {
        i = 0;
LAB_00192ca3:
        if (i < (int)(uint)dev_target->padding[2]) {
          if ((*(long *)((dev_target[1].prev)->padding + (long)i * 8 + -0x1c) == 0) ||
             (value != *(char **)((dev_target[1].prev)->padding + (long)i * 8 + -0x1c)))
          goto LAB_00192c9f;
          lydict_remove(dev_target->module->ctx,
                        *(char **)((dev_target[1].prev)->padding + (long)i * 8 + -0x1c));
          llist->dflt[i] = (char *)0x0;
          j = -1;
          while (j = lys_ext_iter(dev_target->ext,dev_target->ext_size,(char)j + '\x01',
                                  LYEXT_SUBSTMT_DEFAULT), j != -1) {
            if (i == (uint)dev_target->ext[j]->insubstmt_index) {
              lyp_ext_instance_rm(ctx,&dev_target->ext,&dev_target->ext_size,(uint8_t)j);
              j = j + -1;
            }
            else if (i < (int)(uint)dev_target->ext[j]->insubstmt_index) {
              dev_target->ext[j]->insubstmt_index = dev_target->ext[j]->insubstmt_index + 0xff;
            }
          }
        }
        if (i != (uint)llist->dflt_size) goto LAB_00192e3a;
        ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                "The default value to delete not found in the target node.");
        goto LAB_00192e41;
      }
      for (i = 0; i < (int)(uint)dev_target->padding[2]; i = i + 1) {
        if (value == *(char **)((dev_target[1].prev)->padding + (long)i * 8 + -0x1c)) {
          ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Duplicated default value \"%s\".",value);
          goto LAB_00192e41;
        }
      }
      plVar2 = dev_target[1].prev;
      bVar1 = dev_target->padding[2];
      dev_target->padding[2] = bVar1 + 1;
      pcVar5 = lydict_insert(ctx,value,sVar4 & 0xffffffff);
      *(char **)(plVar2->padding + (ulong)bVar1 * 8 + -0x1c) = pcVar5;
      ly_set_add(dflt_check,dev_target,0);
      llist->flags = llist->flags & 0xefff;
    }
    goto LAB_00192e3a;
  }
  choice = (lys_node_choice *)dev_target;
  iVar3 = resolve_choice_default_schema_nodeid(value,dev_target->child,&node);
  if ((iVar3 == 0) && (node != (lys_node *)0x0)) {
    if (deviate->mod == LY_DEVIATE_DEL) {
      if ((choice->dflt != (lys_node *)0x0) && (choice->dflt == node)) {
        choice->dflt = (lys_node *)0x0;
        j = -1;
        while (iVar3 = lys_ext_iter(dev_target->ext,dev_target->ext_size,(char)j + '\x01',
                                    LYEXT_SUBSTMT_DEFAULT), iVar3 != -1) {
          lyp_ext_instance_rm(ctx,&dev_target->ext,&dev_target->ext_size,(uint8_t)iVar3);
          j = iVar3 + -1;
        }
LAB_00192e3a:
        iVar3 = 0;
        goto LAB_00192e46;
      }
      ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Value differs from the target being deleted.");
    }
    else {
      choice->dflt = node;
      if (choice->dflt != (lys_node *)0x0) goto LAB_00192e3a;
      ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
    }
  }
  else {
    ly_vlog(ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
  }
LAB_00192e41:
  iVar3 = 1;
LAB_00192e46:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_00192c9f:
  i = i + 1;
  goto LAB_00192ca3;
}



int yang_read_deviate_default
              (lys_module *module,lys_deviate *deviate,lys_node *dev_target,ly_set *dflt_check)

{
  ly_ctx *ctx_00;
  int iVar1;
  char *pcVar2;
  lys_node *plVar3;
  ly_set *dflt_check_local;
  lys_node *dev_target_local;
  lys_deviate *deviate_local;
  lys_module *module_local;
  int i;
  ly_ctx *ctx;
  lys_node_leaflist *llist;
  char **dflt;
  
  ctx_00 = module->ctx;
  if ((((byte)module->field_0x40 >> 1 & 7) < 2) && (dev_target->nodetype == LYS_LEAFLIST)) {
    ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"default");
    ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
            "Target node does not allow \"default\" property.");
  }
  else if ((deviate->dflt_size < 2) || (dev_target->nodetype == LYS_LEAFLIST)) {
    if ((dev_target->nodetype & (LYS_CHOICE|LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
      ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"default");
      ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "Target node does not allow \"default\" property.");
    }
    else {
      if (deviate->mod == LY_DEVIATE_ADD) {
        if (((dev_target->nodetype == LYS_LEAF) && (dev_target[1].prev != (lys_node *)0x0)) ||
           ((dev_target->nodetype == LYS_CHOICE && (dev_target[1].name != (char *)0x0)))) {
          ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"default");
          ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Adding property that already exists.");
          return 1;
        }
        if (((dev_target->flags & 0x40) != 0) ||
           ((dev_target->nodetype == LYS_LEAFLIST && (*(int *)&dev_target[1].priv != 0)))) {
          ly_vlog(ctx_00,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"default","deviation");
          if ((dev_target->flags & 0x40) == 0) {
            pcVar2 = "leaflists with non-zero \"min-elements\"";
          }
          else {
            pcVar2 = "nodes with the \"mandatory\"";
          }
          ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                  "Adding the \"default\" statement is forbidden on %s statement.",pcVar2);
          return 1;
        }
      }
      else if ((deviate->mod == LY_DEVIATE_RPL) &&
              ((((dev_target->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN &&
                (dev_target[1].prev == (lys_node *)0x0)) ||
               ((dev_target->nodetype == LYS_CHOICE && (dev_target[1].name == (char *)0x0)))))) {
        ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"default");
        ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Replacing a property that does not exist."
               );
        return 1;
      }
      if (dev_target->nodetype == LYS_LEAFLIST) {
        if (deviate->mod == LY_DEVIATE_ADD) {
          plVar3 = (lys_node *)
                   realloc(dev_target[1].prev,
                           (long)(int)((uint)dev_target->padding[2] + (uint)deviate->dflt_size) * 8)
          ;
          if (plVar3 == (lys_node *)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "yang_read_deviate_default");
            return 1;
          }
          dev_target[1].prev = plVar3;
        }
        else if (deviate->mod == LY_DEVIATE_RPL) {
          for (i = 0; i < (int)(uint)dev_target->padding[2]; i = i + 1) {
            lydict_remove(ctx_00,*(char **)((dev_target[1].prev)->padding + (long)i * 8 + -0x1c));
          }
          plVar3 = (lys_node *)realloc(dev_target[1].prev,(ulong)deviate->dflt_size * 8);
          if (plVar3 == (lys_node *)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "yang_read_deviate_default");
            return 1;
          }
          dev_target[1].prev = plVar3;
          dev_target->padding[2] = '\0';
        }
      }
      i = 0;
      while( true ) {
        if ((int)(uint)deviate->dflt_size <= i) {
          return 0;
        }
        iVar1 = yang_fill_deviate_default(ctx_00,deviate,dev_target,dflt_check,deviate->dflt[i]);
        if (iVar1 != 0) break;
        i = i + 1;
      }
    }
  }
  else {
    ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"default");
    ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
            "Target node does not allow multiple \"default\" properties.");
  }
  return 1;
}



int yang_check_deviate_mandatory(lys_deviate *deviate,lys_node *dev_target)

{
  ly_ctx *ctx_00;
  long lVar1;
  int iVar2;
  lys_node *dev_target_local;
  lys_deviate *deviate_local;
  lys_node *parent;
  ly_ctx *ctx;
  
  ctx_00 = dev_target->module->ctx;
  if ((dev_target->nodetype & (LYS_CHOICE|LYS_LEAF|LYS_ANYDATA)) == LYS_UNKNOWN) {
    ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"mandatory");
    ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
            "Target node does not allow \"mandatory\" property.");
    return 1;
  }
  if (deviate->mod == LY_DEVIATE_ADD) {
    if ((dev_target->flags & 0xc0) != 0) {
      ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"mandatory");
      ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Adding property that already exists.");
      return 1;
    }
    if ((dev_target->nodetype == LYS_LEAF) && (dev_target[1].prev != (lys_node *)0x0)) {
      ly_vlog(ctx_00,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"mandatory",&DAT_00224981);
      ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "The \"mandatory\" statement is forbidden on leaf with \"default\".");
      return 1;
    }
    if ((dev_target->nodetype == LYS_CHOICE) && (dev_target[1].name != (char *)0x0)) {
      ly_vlog(ctx_00,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"mandatory","choice");
      ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "The \"mandatory\" statement is forbidden on choices with \"default\".");
      return 1;
    }
  }
  else if ((dev_target->flags & 0xc0) == 0) {
    ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,"mandatory");
    ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Replacing a property that does not exist.");
    return 1;
  }
  dev_target->flags = dev_target->flags & 0xff3f;
  dev_target->flags = deviate->flags & 0xc0 | dev_target->flags;
  parent = dev_target->parent;
  while (((parent != (lys_node *)0x0 && ((parent->nodetype & 0x4802) == LYS_UNKNOWN)) &&
         ((parent->nodetype != LYS_CONTAINER ||
          (lVar1._0_2_ = parent[1].flags, lVar1._2_1_ = parent[1].ext_size,
          lVar1._3_1_ = parent[1].iffeature_size, lVar1._4_1_ = parent[1].padding[0],
          lVar1._5_1_ = parent[1].padding[1], lVar1._6_1_ = parent[1].padding[2],
          lVar1._7_1_ = parent[1].padding[3], lVar1 == 0))))) {
    parent = parent->parent;
  }
  if ((((parent != (lys_node *)0x0) && (parent->nodetype == LYS_CHOICE)) &&
      (parent[1].name != (char *)0x0)) && (iVar2 = lyp_check_mandatory_choice(parent), iVar2 != 0))
  {
    return 1;
  }
  return 0;
}



int yang_read_deviate_minmax(lys_deviate *deviate,lys_node *dev_target,uint32_t value,int type)

{
  ly_ctx *ctx_00;
  lys_iffeature **pplVar1;
  uint32_t *puVar2;
  char *pcVar3;
  int type_local;
  uint32_t value_local;
  lys_node *dev_target_local;
  lys_deviate *deviate_local;
  uint32_t *min;
  uint32_t *max;
  ly_ctx *ctx;
  uint32_t *ui32val;
  
  ctx_00 = dev_target->module->ctx;
  if (dev_target->nodetype == LYS_LEAFLIST) {
    pplVar1 = (lys_iffeature **)&dev_target[1].priv;
    min = (uint32_t *)&dev_target[1].priv;
  }
  else {
    if (dev_target->nodetype != LYS_LIST) {
      if (type == 0) {
        pcVar3 = "min-elements";
      }
      else {
        pcVar3 = "max-elements";
      }
      ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,pcVar3);
      if (type == 0) {
        pcVar3 = "min-elements";
      }
      else {
        pcVar3 = "max-elements";
      }
      ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Target node does not allow \"%s\" property."
              ,pcVar3);
      return 1;
    }
    pplVar1 = &dev_target[1].iffeature;
    min = (uint32_t *)&dev_target[1].iffeature;
  }
  max = (uint32_t *)((long)pplVar1 + 4);
  puVar2 = min;
  if (type != 0) {
    puVar2 = max;
  }
  if ((deviate->mod == LY_DEVIATE_ADD) && (*puVar2 != 0)) {
    if (type == 0) {
      pcVar3 = "min-elements";
    }
    else {
      pcVar3 = "max-elements";
    }
    ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,pcVar3);
    ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Adding property that already exists.");
  }
  else {
    *puVar2 = value;
    if ((*max == 0) || (*min <= *max)) {
      return 0;
    }
    if (type == 0) {
      ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid value \"%d\" of \"min-elements\".",
              (ulong)value);
      ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "\"min-elements\" is bigger than \"max-elements\".");
    }
    else {
      ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Invalid value \"%d\" of \"max-elements\".",
              (ulong)value);
      ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "\"max-elements\" is smaller than \"min-elements\".");
    }
  }
  return 1;
}



int yang_check_deviate_must
              (lys_module *module,unres_schema *unres,lys_deviate *deviate,lys_node *dev_target)

{
  LYS_NODE LVar1;
  ly_ctx *ctx_00;
  bool bVar2;
  int iVar3;
  lys_restr *plVar4;
  lys_node *dev_target_local;
  lys_deviate *deviate_local;
  unres_schema *unres_local;
  lys_module *module_local;
  int i;
  int j;
  int erase_must;
  lys_restr **trg_must;
  uint8_t *trg_must_size;
  ly_ctx *ctx;
  lys_restr *must;
  
  ctx_00 = module->ctx;
  bVar2 = true;
  LVar1 = dev_target->nodetype;
  if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
    if ((LVar1 != LYS_UNKNOWN) && (true)) {
      switch(LVar1) {
      case LYS_CONTAINER:
        trg_must_size = dev_target->padding + 1;
        break;
      default:
        goto switchD_00193974_caseD_2;
      case LYS_LEAF:
        trg_must_size = dev_target->padding + 3;
        break;
      case LYS_LEAFLIST:
        trg_must_size = dev_target->padding + 3;
        break;
      case LYS_LIST:
        trg_must_size = dev_target->padding;
        break;
      case LYS_ANYXML:
        goto switchD_00193974_caseD_20;
      }
LAB_00193a61:
      trg_must = (lys_restr **)&dev_target[1].dsc;
      dev_target->flags = dev_target->flags & 63999;
      if (deviate->mod == LY_DEVIATE_ADD) {
        plVar4 = (lys_restr *)
                 ly_realloc(*trg_must,
                            (long)(int)((uint)*trg_must_size + (uint)deviate->must_size) * 0x38);
        if (plVar4 == (lys_restr *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "yang_check_deviate_must");
          goto LAB_00193e17;
        }
        *trg_must = plVar4;
        memcpy(*trg_must + *trg_must_size,deviate->must,(ulong)deviate->must_size * 0x38);
        *trg_must_size = *trg_must_size + deviate->must_size;
        bVar2 = false;
      }
      else if (deviate->mod == LY_DEVIATE_DEL) {
        for (j = 0; j < (int)(uint)deviate->must_size; j = j + 1) {
          for (i = 0; i < (int)(uint)*trg_must_size; i = i + 1) {
            if (deviate->must[j].expr == (*trg_must)[i].expr) {
              lys_restr_free(module->ctx,*trg_must + i,(_func_void_lys_node_ptr_void_ptr *)0x0);
              *trg_must_size = *trg_must_size + 0xff;
              if (i != (uint)*trg_must_size) {
                memcpy(*trg_must + i,*trg_must + *trg_must_size,0x38);
              }
              if (*trg_must_size == '\0') {
                free(*trg_must);
                *trg_must = (lys_restr *)0x0;
              }
              else {
                memset(*trg_must + *trg_must_size,0,0x38);
              }
              i = -1;
              break;
            }
          }
          if (i != -1) {
            ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,deviate->must[j].expr,&DAT_00225226);
            ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "Value does not match any must from the target.");
            goto LAB_00193e17;
          }
        }
      }
      iVar3 = yang_check_must(module,deviate->must,(uint)deviate->must_size,unres);
      if ((iVar3 == 0) &&
         (((((module->ctx->models).flags & 2U) != 0 || (*trg_must_size == '\0')) ||
          (iVar3 = unres_schema_add_node(module,unres,dev_target,UNRES_XPATH,(lys_node *)0x0),
          iVar3 != -1)))) {
        return 0;
      }
      goto LAB_00193e17;
    }
  }
  else if (LVar1 == LYS_ANYDATA) {
switchD_00193974_caseD_20:
    trg_must_size = dev_target->padding + 3;
    goto LAB_00193a61;
  }
switchD_00193974_caseD_2:
  ly_vlog(ctx_00,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,&DAT_00225226);
  ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Target node does not allow \"must\" property.");
LAB_00193e17:
  if ((deviate->mod == LY_DEVIATE_ADD) && (bVar2)) {
    for (i = 0; i < (int)(uint)deviate->must_size; i = i + 1) {
      lys_restr_free(module->ctx,deviate->must + i,(_func_void_lys_node_ptr_void_ptr *)0x0);
    }
    free(deviate->must);
  }
  return 1;
}



int yang_deviate_delete_unique
              (lys_module *module,lys_deviate *deviate,lys_node_list *list,int index,char *value)

{
  ly_ctx *ctx_00;
  int iVar1;
  char *value_local;
  int index_local;
  lys_node_list *list_local;
  lys_deviate *deviate_local;
  lys_module *module_local;
  int i;
  int j;
  int k;
  ly_ctx *ctx;
  
  ctx_00 = module->ctx;
  i = 0;
  do {
    if ((int)(uint)list->unique_size <= i) goto LAB_00194179;
    if (list->unique[i].expr_size == deviate->unique[index].expr_size) {
      for (j = 0; (j < (int)(uint)deviate->unique[index].expr_size &&
                  (list->unique[i].expr[j] == deviate->unique[index].expr[j])); j = j + 1) {
      }
      if (j == (uint)deviate->unique[index].expr_size) {
        for (j = 0; j < (int)(uint)list->unique[i].expr_size; j = j + 1) {
          lydict_remove(ctx_00,list->unique[i].expr[j]);
        }
        free(list->unique[i].expr);
        list->unique_size = list->unique_size + 0xff;
        if (i != (uint)list->unique_size) {
          list->unique[i].expr_size = list->unique[list->unique_size].expr_size;
          list->unique[i].expr = list->unique[list->unique_size].expr;
        }
        if (list->unique_size == '\0') {
          free(list->unique);
          list->unique = (lys_unique *)0x0;
        }
        else {
          list->unique[list->unique_size].expr_size = '\0';
          list->unique[list->unique_size].expr = (char **)0x0;
        }
        k = i;
        i = -1;
LAB_00194179:
        if (i == -1) {
          j = -1;
          while (j = lys_ext_iter(list->ext,list->ext_size,(char)j + '\x01',LYEXT_SUBSTMT_UNIQUE),
                j != -1) {
            if (k == (uint)list->ext[j]->insubstmt_index) {
              lyp_ext_instance_rm(ctx_00,&list->ext,&list->ext_size,(uint8_t)j);
              j = j + -1;
            }
            else if (k < (int)(uint)list->ext[j]->insubstmt_index) {
              list->ext[j]->insubstmt_index = list->ext[j]->insubstmt_index + 0xff;
            }
          }
          iVar1 = 0;
        }
        else {
          ly_vlog(ctx_00,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"unique");
          ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                  "Value differs from the target being deleted.");
          iVar1 = 1;
        }
        return iVar1;
      }
    }
    i = i + 1;
  } while( true );
}



int yang_check_deviate_unique(lys_module *module,lys_deviate *deviate,lys_node *dev_target)

{
  char **value;
  int iVar1;
  lys_node *dev_target_local;
  lys_deviate *deviate_local;
  lys_module *module_local;
  uint i;
  lys_unique *last_unique;
  lys_node_list *list;
  char *str;
  
  i = 0;
  last_unique = (lys_unique *)0x0;
  iVar1 = yang_read_deviate_unique(deviate,dev_target);
  if (iVar1 == 0) {
    last_unique = (lys_unique *)(dev_target[1].ext + (ulong)dev_target->padding[3] * 2);
    for (i = 0; i < deviate->unique_size; i = i + 1) {
      value = deviate->unique[i].expr;
      if (deviate->mod == LY_DEVIATE_ADD) {
        iVar1 = yang_fill_unique(module,(lys_node_list *)dev_target,
                                 (lys_unique *)
                                 (dev_target[1].ext + (ulong)dev_target->padding[3] * 2),
                                 (char *)value,(unres_schema *)0x0);
        if (iVar1 != 0) {
          free(value);
          goto LAB_00194499;
        }
        dev_target->padding[3] = dev_target->padding[3] + '\x01';
      }
      else if (deviate->mod == LY_DEVIATE_DEL) {
        iVar1 = yang_fill_unique(module,(lys_node_list *)dev_target,deviate->unique + i,
                                 (char *)value,(unres_schema *)0x0);
        if (iVar1 != 0) {
          free(value);
          goto LAB_00194499;
        }
        iVar1 = yang_deviate_delete_unique
                          (module,deviate,(lys_node_list *)dev_target,i,(char *)value);
        if (iVar1 != 0) {
          free(value);
          goto LAB_00194499;
        }
      }
      free(value);
    }
    if (deviate->mod == LY_DEVIATE_ADD) {
      free(deviate->unique);
      deviate->unique = last_unique;
    }
    iVar1 = 0;
  }
  else {
LAB_00194499:
    if (deviate->mod == LY_DEVIATE_ADD) {
      while (i = i + 1, i < deviate->unique_size) {
        free(deviate->unique[i].expr);
      }
      free(deviate->unique);
      deviate->unique = last_unique;
    }
    iVar1 = 1;
  }
  return iVar1;
}



int yang_fill_include(lys_module *trg,char *value,lys_include *inc,unres_schema *unres)

{
  int iVar1;
  char *value_00;
  unres_schema *unres_local;
  lys_include *inc_local;
  char *value_local;
  lys_module *trg_local;
  int ret;
  int rc;
  char *str;
  
  ret = 0;
  value_00 = lydict_insert_zc(trg->ctx,value);
  iVar1 = lyp_check_include(trg,value_00,inc,unres);
  if (iVar1 == 0) {
    memcpy(trg->inc + trg->inc_size,inc,0x30);
    iVar1 = yang_check_ext_instance
                      (trg,&trg->inc[trg->inc_size].ext,(uint)trg->inc[trg->inc_size].ext_size,
                       trg->inc + trg->inc_size,unres);
    if (iVar1 != 0) {
      ret = -1;
    }
    trg->inc_size = trg->inc_size + '\x01';
  }
  else if (iVar1 == -1) {
    lys_extension_instances_free
              (trg->ctx,inc->ext,(uint)inc->ext_size,(_func_void_lys_node_ptr_void_ptr *)0x0);
    ret = -1;
  }
  lydict_remove(trg->ctx,value_00);
  return ret;
}



lys_ext_instance * yang_ext_instance(void *node,yytokentype type,int is_ext_instance)

{
  lys_ext_instance *__ptr;
  lys_ext_instance **pplVar1;
  int is_ext_instance_local;
  yytokentype type_local;
  void *node_local;
  LYEXT_PAR parent_type;
  lys_ext_instance ***ext;
  uint8_t *size;
  lys_ext_instance *instance;
  lys_ext_instance **tmp;
  
  if (false) {
switchD_001946e0_caseD_104:
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
           ,0x8bd);
  }
  else {
    switch(type) {
    case ANYXML_KEYWORD:
    case AUGMENT_KEYWORD:
    case CASE_KEYWORD:
    case CHOICE_KEYWORD:
    case CONTAINER_KEYWORD:
    case GROUPING_KEYWORD:
    case INPUT_KEYWORD:
    case LEAF_KEYWORD:
    case LEAF_LIST_KEYWORD:
    case LIST_KEYWORD:
    case NOTIFICATION_KEYWORD:
    case OUTPUT_KEYWORD:
    case RPC_KEYWORD:
    case USES_KEYWORD:
    case ACTION_KEYWORD:
    case ANYDATA_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x20);
      size = (uint8_t *)((long)node + 0x1a);
      parent_type._0_1_ = '\x01';
      break;
    default:
      goto switchD_001946e0_caseD_104;
    case ARGUMENT_KEYWORD:
      if (is_ext_instance == 0) {
        ext = (lys_ext_instance ***)((long)node + 0x20);
        size = (uint8_t *)((long)node + 0x1a);
        parent_type._0_1_ = '\n';
      }
      else {
        ext = (lys_ext_instance ***)((long)node + 0x20);
        size = (uint8_t *)((long)node + 0x1a);
        parent_type._0_1_ = '\v';
      }
      break;
    case BELONGS_TO_KEYWORD:
      if (is_ext_instance == 0) {
        ext = (lys_ext_instance ***)((long)node + 0xa0);
        size = (uint8_t *)((long)node + 0x50);
        parent_type._0_1_ = '\0';
      }
      else {
        ext = (lys_ext_instance ***)((long)node + 0x20);
        size = (uint8_t *)((long)node + 0x1a);
        parent_type._0_1_ = '\v';
      }
      break;
    case BIT_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x20);
      size = (uint8_t *)((long)node + 0x1a);
      parent_type._0_1_ = '\x04';
      break;
    case ENUM_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x20);
      size = (uint8_t *)((long)node + 0x1a);
      parent_type._0_1_ = '\x05';
      break;
    case EXTENSION_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x20);
      size = (uint8_t *)((long)node + 0x1a);
      parent_type._0_1_ = '\n';
      break;
    case DEVIATION_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x30);
      size = (uint8_t *)((long)node + 0x21);
      parent_type._0_1_ = '\r';
      break;
    case FEATURE_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x20);
      size = (uint8_t *)((long)node + 0x1a);
      parent_type._0_1_ = '\x06';
      break;
    case IDENTITY_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x20);
      size = (uint8_t *)((long)node + 0x1a);
      parent_type._0_1_ = '\t';
      break;
    case IF_FEATURE_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x18);
      size = (uint8_t *)((long)node + 8);
      parent_type._0_1_ = '\x12';
      break;
    case IMPORT_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x20);
      size = (uint8_t *)((long)node + 0x1b);
      parent_type._0_1_ = '\x0f';
      break;
    case INCLUDE_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x18);
      size = (uint8_t *)((long)node + 0x13);
      parent_type._0_1_ = '\x10';
      break;
    case LENGTH_KEYWORD:
    case MUST_KEYWORD:
    case PATTERN_KEYWORD:
    case RANGE_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x28);
      size = (uint8_t *)((long)node + 0x30);
      parent_type._0_1_ = '\a';
      break;
    case MODULE_KEYWORD:
    case SUBMODULE_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0xa0);
      size = (uint8_t *)((long)node + 0x50);
      parent_type._0_1_ = '\0';
      break;
    case REFINE_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x20);
      size = (uint8_t *)((long)node + 0x1a);
      parent_type._0_1_ = '\f';
      break;
    case REVISION_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x10);
      size = (uint8_t *)((long)node + 0xb);
      parent_type._0_1_ = '\x11';
      break;
    case TYPE_KEYWORD:
      ext = (lys_ext_instance ***)(*(long *)((long)node + 0x10) + 8);
      size = (uint8_t *)(*(long *)((long)node + 0x10) + 5);
      parent_type._0_1_ = '\x03';
      break;
    case TYPEDEF_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x20);
      size = (uint8_t *)((long)node + 0x1a);
      parent_type._0_1_ = '\x02';
      break;
    case WHEN_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x18);
      size = (uint8_t *)((long)node + 0x20);
      parent_type._0_1_ = '\a';
      break;
    case ADD_KEYWORD:
    case DELETE_KEYWORD:
    case NOT_SUPPORTED_KEYWORD:
    case REPLACE_KEYWORD:
      ext = (lys_ext_instance ***)((long)node + 0x40);
      size = (uint8_t *)((long)node + 6);
      parent_type._0_1_ = '\x0e';
      break;
    case EXTENSION_INSTANCE:
      ext = (lys_ext_instance ***)((long)node + 0x20);
      size = (uint8_t *)((long)node + 0x1a);
      parent_type._0_1_ = '\v';
    }
    __ptr = (lys_ext_instance *)calloc(1,0x40);
    if (__ptr != (lys_ext_instance *)0x0) {
      __ptr->parent_type = (uint8_t)parent_type;
      pplVar1 = (lys_ext_instance **)realloc(*ext,(long)(int)(*size + 1) * 8);
      if (pplVar1 != (lys_ext_instance **)0x0) {
        pplVar1[*size] = __ptr;
        *ext = pplVar1;
        *size = *size + '\x01';
        return __ptr;
      }
    }
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_ext_instance");
    free(__ptr);
  }
  return (lys_ext_instance *)0x0;
}



void * yang_read_ext(lys_module *module,void *actual,char *ext_name,char *ext_arg,
                    yytokentype actual_type,yytokentype backup_type,int is_ext_instance)

{
  int iVar1;
  char *pcVar2;
  yytokentype backup_type_local;
  yytokentype actual_type_local;
  char *ext_arg_local;
  char *ext_name_local;
  void *actual_local;
  lys_module *module_local;
  uint8_t insubstmt_index;
  LY_STMT stmt;
  LYEXT_SUBSTMT insubstmt;
  lys_ext_instance *instance;
  
  stmt = LY_STMT_UNKNOWN;
  insubstmt_index = '\0';
  if (backup_type == NODE) {
    if (actual_type == ARGUMENT_KEYWORD) {
      insubstmt._0_1_ = '\x01';
      stmt = LY_STMT_ARGUMENT;
    }
    else if (actual_type == BELONGS_TO_KEYWORD) {
      insubstmt._0_1_ = '\x03';
      stmt = LY_STMT_BELONGSTO;
    }
    else {
      insubstmt._0_1_ = '\0';
    }
    instance = yang_ext_instance(actual,actual_type,is_ext_instance);
    goto LAB_00194f56;
  }
  if (false) {
switchD_00194baf_caseD_116:
    ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
           ,0x975);
    return (void *)0x0;
  }
  switch(actual_type) {
  case BASE_KEYWORD:
    insubstmt._0_1_ = '\x02';
    stmt = LY_STMT_BASE;
    if (backup_type == IDENTITY_KEYWORD) {
      insubstmt_index = *(uint8_t *)((long)actual + 0x1f);
    }
    else if (backup_type == TYPE_KEYWORD) {
      insubstmt_index = (uint8_t)*(undefined4 *)(*(long *)((long)actual + 0x10) + 0x28);
    }
    break;
  default:
    goto switchD_00194baf_caseD_116;
  case CONFIG_KEYWORD:
    insubstmt._0_1_ = '\x17';
    stmt = LY_STMT_CONFIG;
    break;
  case CONTACT_KEYWORD:
    insubstmt._0_1_ = '\x04';
    stmt = LY_STMT_CONTACT;
    break;
  case DEFAULT_KEYWORD:
    insubstmt._0_1_ = '\x05';
    stmt = LY_STMT_DEFAULT;
    if (backup_type == ADD_KEYWORD) {
      insubstmt_index = *(uint8_t *)((long)actual + 5);
    }
    else if (backup_type < CURRENT_KEYWORD) {
      if (backup_type == LEAF_LIST_KEYWORD) {
        insubstmt_index = *(uint8_t *)((long)actual + 0x1e);
      }
      else if (backup_type == REFINE_KEYWORD) {
        insubstmt_index = *(uint8_t *)((long)actual + 0x1f);
      }
    }
    break;
  case DESCRIPTION_KEYWORD:
    insubstmt._0_1_ = '\x06';
    stmt = LY_STMT_DESCRIPTION;
    break;
  case ERROR_APP_TAG_KEYWORD:
    insubstmt._0_1_ = '\a';
    stmt = LY_STMT_ERRTAG;
    break;
  case ERROR_MESSAGE_KEYWORD:
    insubstmt._0_1_ = '\b';
    stmt = LY_STMT_ERRMSG;
    break;
  case FRACTION_DIGITS_KEYWORD:
    insubstmt._0_1_ = '\x1b';
    stmt = LY_STMT_DIGITS;
    break;
  case KEY_KEYWORD:
    insubstmt._0_1_ = '\t';
    stmt = LY_STMT_KEY;
    break;
  case MANDATORY_KEYWORD:
    insubstmt._0_1_ = '\x18';
    stmt = LY_STMT_MANDATORY;
    break;
  case MAX_ELEMENTS_KEYWORD:
    insubstmt._0_1_ = '\x1c';
    stmt = LY_STMT_MAX;
    break;
  case MIN_ELEMENTS_KEYWORD:
    insubstmt._0_1_ = '\x1d';
    stmt = LY_STMT_MIN;
    break;
  case NAMESPACE_KEYWORD:
    insubstmt._0_1_ = '\n';
    stmt = LY_STMT_NAMESPACE;
    break;
  case ORDERED_BY_KEYWORD:
    insubstmt._0_1_ = '\x19';
    stmt = LY_STMT_ORDEREDBY;
    break;
  case ORGANIZATION_KEYWORD:
    insubstmt._0_1_ = '\v';
    stmt = LY_STMT_ORGANIZATION;
    break;
  case PATH_KEYWORD:
    insubstmt._0_1_ = '\f';
    stmt = LY_STMT_PATH;
    break;
  case POSITION_KEYWORD:
    insubstmt._0_1_ = '\x1e';
    stmt = LY_STMT_POSITION;
    break;
  case PREFIX_KEYWORD:
    insubstmt._0_1_ = '\r';
    stmt = LY_STMT_PREFIX;
    break;
  case PRESENCE_KEYWORD:
    insubstmt._0_1_ = '\x0e';
    stmt = LY_STMT_PRESENCE;
    break;
  case REFERENCE_KEYWORD:
    insubstmt._0_1_ = '\x0f';
    stmt = LY_STMT_REFERENCE;
    break;
  case REQUIRE_INSTANCE_KEYWORD:
    insubstmt._0_1_ = '\x15';
    stmt = LY_STMT_REQINSTANCE;
    break;
  case REVISION_DATE_KEYWORD:
    insubstmt._0_1_ = '\x10';
    stmt = LY_STMT_REVISIONDATE;
    break;
  case STATUS_KEYWORD:
    insubstmt._0_1_ = '\x1a';
    stmt = LY_STMT_STATUS;
    break;
  case UNIQUE_KEYWORD:
    insubstmt._0_1_ = '\x1f';
    stmt = LY_STMT_UNIQUE;
    if (backup_type == REPLACE_KEYWORD) {
LAB_00194e9b:
      insubstmt_index = *(uint8_t *)((long)actual + 10);
    }
    else if (backup_type < SYSTEM_KEYWORD) {
      if (backup_type == DELETE_KEYWORD) goto LAB_00194e9b;
      if (backup_type < DEPRECATED_KEYWORD) {
        if (backup_type == LIST_KEYWORD) {
          insubstmt_index = *(uint8_t *)((long)actual + 0x1f);
        }
        else if (backup_type == ADD_KEYWORD) goto LAB_00194e9b;
      }
    }
    break;
  case UNITS_KEYWORD:
    insubstmt._0_1_ = '\x11';
    stmt = LY_STMT_UNITS;
    break;
  case VALUE_KEYWORD:
    insubstmt._0_1_ = '\x12';
    stmt = LY_STMT_VALUE;
    break;
  case YANG_VERSION_KEYWORD:
    insubstmt._0_1_ = '\x13';
    stmt = LY_STMT_VERSION;
    break;
  case YIN_ELEMENT_KEYWORD:
    insubstmt._0_1_ = '\x16';
    stmt = LY_STMT_YINELEM;
    break;
  case MODIFIER_KEYWORD:
    insubstmt._0_1_ = '\x14';
    stmt = LY_STMT_MODIFIER;
  }
  instance = yang_ext_instance(actual,backup_type,is_ext_instance);
LAB_00194f56:
  if (instance == (lys_ext_instance *)0x0) {
    instance = (lys_ext_instance *)0x0;
  }
  else {
    instance->insubstmt = (uint8_t)insubstmt;
    instance->insubstmt_index = insubstmt_index;
    instance->flags = instance->flags | 2;
    instance->def = (lys_ext *)ext_name;
    pcVar2 = lydict_insert_zc(module->ctx,ext_arg);
    instance->arg_value = pcVar2;
    if (((is_ext_instance != 0) && (stmt != LY_STMT_UNKNOWN)) && (instance->parent_type == '\v')) {
      iVar1 = yang_fill_ext_substm_index((lys_ext_instance_complex *)actual,stmt,backup_type);
      instance->insubstmt_index = (uint8_t)iVar1;
    }
  }
  return instance;
}



int check_status_flag(lys_node *node,lys_node *parent)

{
  ly_ctx *ctx_00;
  ushort uVar1;
  char *pcVar2;
  char *pcVar3;
  char *pcVar4;
  lys_node *parent_local;
  lys_node *node_local;
  ly_ctx *ctx;
  char *str;
  
  ctx_00 = node->module->ctx;
  if ((((node->nodetype & 0x600) == LYS_UNKNOWN) && (parent != (lys_node *)0x0)) &&
     ((parent->flags & 0x30) != 0)) {
    if ((node->flags & 0x38) == 0) {
      pcVar2 = lys_path(node,1);
      if ((parent->flags & 0x10) == 0) {
        pcVar3 = "obsolete";
      }
      else {
        pcVar3 = "deprecated";
      }
      ly_log(ctx_00,LY_LLWRN,LY_SUCCESS,"Missing status in %s subtree (%s), inheriting.",pcVar3,
             pcVar2);
      free(pcVar2);
      node->flags = parent->flags & 0x38 | node->flags;
    }
    else if ((node->flags & 0x38) < (parent->flags & 0x38)) {
      uVar1 = node->flags & 0x38;
      if (uVar1 == 0x10) {
        pcVar2 = parent->name;
        pcVar3 = strnodetype(node->nodetype);
        ly_vlog(ctx_00,LYE_INSTATUS,LY_VLOG_LYS,parent,"deprecated",pcVar3,"is child of","obsolete",
                pcVar2);
      }
      else if ((uVar1 < 0x11) && (((node->flags & 0x38) == 0 || (uVar1 == 8)))) {
        pcVar2 = parent->name;
        if ((parent->flags & 0x10) == 0) {
          pcVar3 = "obsolete";
        }
        else {
          pcVar3 = "deprecated";
        }
        pcVar4 = strnodetype(node->nodetype);
        ly_vlog(ctx_00,LYE_INSTATUS,LY_VLOG_LYS,parent,"current",pcVar4,"is child of",pcVar3,pcVar2)
        ;
      }
      return 1;
    }
  }
  return 0;
}



int store_config_flag(lys_node *node,int options)

{
  LYS_NODE LVar1;
  int options_local;
  lys_node *node_local;
  
  LVar1 = node->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_0019529f_caseD_1:
    if ((options & 2U) == 0) {
      if (((options & 1U) == 0) && ((node->flags & 3) == 0)) {
        if (node->parent == (lys_node *)0x0) {
          node->flags = node->flags | 1;
        }
        else {
          node->flags = node->parent->flags & 3 | node->flags;
        }
      }
    }
    else {
      node->flags = node->flags;
    }
  }
  else if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
    if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
      if ((LVar1 != LYS_UNKNOWN) && (true)) {
        switch(LVar1) {
        case LYS_CONTAINER:
        case LYS_CHOICE:
        case LYS_LEAF:
        case LYS_LEAFLIST:
        case LYS_LIST:
        case LYS_ANYXML:
          goto switchD_0019529f_caseD_1;
        default:
          break;
        }
      }
    }
    else if (((LVar1 == LYS_CASE) && ((options & 3U) == 0)) && ((node->flags & 3) == 0)) {
      if (node->parent == (lys_node *)0x0) {
        node->flags = node->flags | 1;
      }
      else {
        node->flags = node->parent->flags & 3 | node->flags;
      }
    }
  }
  return 0;
}



int yang_parse_mem(lys_module *module,lys_submodule *submodule,unres_schema *unres,char *data,
                  uint size_data,lys_node **node)

{
  long lVar1;
  int iVar2;
  size_t sVar3;
  long in_FS_OFFSET;
  lys_node **node_local;
  uint size_data_local;
  char *data_local;
  unres_schema *unres_local;
  lys_submodule *submodule_local;
  lys_module *module_local;
  int ret;
  uint size;
  yyscan_t scanner;
  YY_BUFFER_STATE bp;
  lys_module *trg;
  yang_parameter param;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  scanner = (yyscan_t)0x0;
  ret = 0;
  if (size_data == 0) {
    sVar3 = strlen(data);
    size_data = (int)sVar3 + 2;
  }
  yylex_init(&scanner);
  yyset_extra(module->ctx,scanner);
  bp = yy_scan_buffer(data,(ulong)size_data,scanner);
  yy_switch_to_buffer(bp,scanner);
  memset(&param,0,0x40);
  param.flags = param.flags | 1;
  param.module = module;
  param.submodule = submodule;
  param.unres = unres;
  param.node = node;
  iVar2 = yyparse(scanner,&param);
  if (iVar2 != 0) {
    if ((param.flags & 1) != 0) {
      trg = module;
      if (submodule != (lys_submodule *)0x0) {
        trg = (lys_module *)submodule;
      }
      yang_free_import(trg->ctx,trg->imp,'\0',trg->imp_size);
      yang_free_include(trg->ctx,trg->inc,'\0',trg->inc_size);
      trg->inc_size = '\0';
      trg->imp_size = '\0';
    }
    if ((param.flags & 2) == 0) {
      ret = -1;
    }
    else {
      ret = 1;
    }
  }
  yy_delete_buffer(bp,scanner);
  yylex_destroy(scanner);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int yang_parse_ext_substatement
              (lys_module *module,unres_schema *unres,char *data,char *ext_name,
              lys_ext_instance_complex *ext)

{
  long lVar1;
  int iVar2;
  size_t sVar3;
  long in_FS_OFFSET;
  lys_ext_instance_complex *ext_local;
  char *ext_name_local;
  char *data_local;
  unres_schema *unres_local;
  lys_module *module_local;
  int ret;
  uint size;
  yyscan_t scanner;
  lys_node *node;
  YY_BUFFER_STATE bp;
  yang_parameter param;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  scanner = (yyscan_t)0x0;
  ret = 0;
  node = (lys_node *)0x0;
  if (data == (char *)0x0) {
    ret = 0;
  }
  else {
    sVar3 = strlen(data);
    yylex_init(&scanner);
    bp = yy_scan_buffer(data,(ulong)((int)sVar3 + 2),scanner);
    yy_switch_to_buffer(bp,scanner);
    memset(&param,0,0x40);
    param.node = &node;
    param.flags = param.flags | 4;
    param.module = module;
    param.unres = unres;
    param.data_node = (void **)ext_name;
    param.actual_node = &ext->def;
    iVar2 = yyparse(scanner,&param);
    if (iVar2 == 0) {
      if (node != (lys_node *)0x0) {
        iVar2 = yang_check_nodes(module,(lys_node *)ext,node,1,unres);
        if (iVar2 != 0) {
          ret = -1;
        }
      }
    }
    else {
      yang_free_nodes(module->ctx,node);
      ret = -1;
    }
    yy_delete_buffer(bp,scanner);
    yylex_destroy(scanner);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return ret;
}



lys_module * yang_read_module(ly_ctx *ctx,char *data,uint size,char *revision,int implement)

{
  int iVar1;
  int iVar2;
  LY_VECODE LVar3;
  char *pcVar4;
  LY_ERR *pLVar5;
  lys_module *plVar6;
  lys_revision *plVar7;
  undefined *puVar8;
  long in_FS_OFFSET;
  char *revision_local;
  int implement_local;
  uint size_local;
  char *data_local;
  ly_ctx *ctx_local;
  int ret;
  unres_schema *unres;
  lys_node *node;
  lys_module *module;
  lys_module *tmp_mod;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  module = (lys_module *)0x0;
  unres = (unres_schema *)0x0;
  node = (lys_node *)0x0;
  unres = (unres_schema *)calloc(1,0x28);
  if (unres == (unres_schema *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_module");
  }
  else {
    module = (lys_module *)calloc(1,0xb8);
    if (module == (lys_module *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_module");
    }
    else {
      module->ctx = ctx;
      module->field_0x40 = module->field_0x40 & 0xfe;
      module->field_0x40 = module->field_0x40 & 0x7f | (implement != 0) << 7;
      iVar1 = lyp_check_circmod_add(module);
      if (iVar1 == 0) {
        iVar1 = yang_parse_mem(module,(lys_submodule *)0x0,unres,data,size,&node);
        if (iVar1 == -1) {
          LVar3 = ly_vecode(ctx);
          if ((LVar3 == LYVE_SUBMODULE) && (module->name == (char *)0x0)) {
            lyp_check_circmod_pop(ctx);
            free(module);
            module = (lys_module *)0x0;
          }
          else {
            free_yang_common(module,node);
          }
        }
        else {
          if (iVar1 == 1) {
            if (unres->count != 0) {
                    // WARNING: Subroutine does not return
              __assert_fail("!unres->count",
                            "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
                            ,0xa62,"yang_read_module");
            }
          }
          else {
            iVar2 = yang_check_sub_module(module,unres,node);
            if (((iVar2 != 0) ||
                ((((implement == 0 && ((module->field_0x40 & 0x80) != 0)) &&
                  (iVar2 = lys_make_implemented_r(module,unres), iVar2 != 0)) ||
                 ((unres->count != 0 && (iVar2 = resolve_unres_schema(module,unres), iVar2 != 0)))))
                ) || (iVar2 = lyp_check_include_missing(module), iVar2 != 0)) goto LAB_00195bdf;
          }
          lyp_sort_revisions(module);
          iVar2 = lyp_rfn_apply_ext(module);
          if ((iVar2 == 0) && (iVar2 = lyp_deviation_apply_ext(module), iVar2 == 0)) {
            if ((revision == (char *)0x0) ||
               ((module->rev_size != '\0' &&
                (iVar2 = strcmp(revision,module->rev->date), iVar2 == 0)))) {
              if (iVar1 == 0) {
                iVar1 = lyp_ctx_add_module(module);
                if (iVar1 != 0) goto LAB_00195bdf;
                lyp_del_includedup(module,0);
              }
              else {
                tmp_mod = module;
                module = ly_ctx_get_module(ctx,module->name,revision,0);
                if (module == (lys_module *)0x0) {
                    // WARNING: Subroutine does not return
                  __assert_fail("module",
                                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
                                ,0xa92,"yang_read_module");
                }
                lys_free(tmp_mod,(_func_void_lys_node_ptr_void_ptr *)0x0,0,0);
              }
              unres_schema_free((lys_module *)0x0,&unres,0);
              lyp_check_circmod_pop(ctx);
              if ((module->field_0x40 & 0x80) == 0) {
                pcVar4 = "imported";
              }
              else {
                pcVar4 = "implemented";
              }
              if (module->rev_size == '\0') {
                plVar7 = (lys_revision *)&DAT_0022570d;
              }
              else {
                plVar7 = module->rev;
              }
              if (module->rev_size == '\0') {
                puVar8 = &DAT_0022570d;
              }
              else {
                puVar8 = &DAT_0022570e;
              }
              ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                     "Module \"%s%s%s\" successfully parsed as %s.",module->name,puVar8,plVar7,
                     pcVar4);
              plVar6 = module;
              goto LAB_00195ce8;
            }
            ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,
                   "Module \"%s\" parsed with the wrong revision (\"%s\" instead \"%s\").",
                   module->name,module->rev,revision);
          }
        }
      }
    }
  }
LAB_00195bdf:
  unres_schema_free(module,&unres,1);
  if (module == (lys_module *)0x0) {
    LVar3 = ly_vecode(ctx);
    if (LVar3 != LYVE_SUBMODULE) {
      pLVar5 = ly_errno_glob_address();
      ly_log(ctx,LY_LLERR,*pLVar5,"Module parsing failed.");
    }
    plVar6 = (lys_module *)0x0;
  }
  else {
    if (module->name == (char *)0x0) {
      pLVar5 = ly_errno_glob_address();
      ly_log(ctx,LY_LLERR,*pLVar5,"Module parsing failed.");
    }
    else {
      pcVar4 = module->name;
      pLVar5 = ly_errno_glob_address();
      ly_log(ctx,LY_LLERR,*pLVar5,"Module \"%s\" parsing failed.",pcVar4);
    }
    lyp_check_circmod_pop(ctx);
    lys_sub_module_remove_devs_augs(module);
    lyp_del_includedup(module,1);
    lys_free(module,(_func_void_lys_node_ptr_void_ptr *)0x0,0,1);
    plVar6 = (lys_module *)0x0;
  }
LAB_00195ce8:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_submodule * yang_read_submodule(lys_module *module,char *data,uint size,unres_schema *unres)

{
  char *pcVar1;
  int iVar2;
  LY_ERR *pLVar3;
  lys_submodule *plVar4;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  uint size_local;
  char *data_local;
  lys_module *module_local;
  lys_node *node;
  lys_submodule *submodule;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  node = (lys_node *)0x0;
  unres_local = unres;
  size_local = size;
  data_local = data;
  module_local = module;
  submodule = (lys_submodule *)calloc(1,0xb0);
  if ((lys_module *)submodule == (lys_module *)0x0) {
    ly_log(module_local->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
           "yang_read_submodule");
  }
  else {
    ((lys_module *)submodule)->ctx = module_local->ctx;
    ((lys_module *)submodule)->field_0x40 = ((lys_module *)submodule)->field_0x40 | 1;
    ((lys_module *)submodule)->field_0x40 =
         ((lys_module *)submodule)->field_0x40 & 0x7f | module_local->field_0x40 & 0x80;
    ((lys_module *)submodule)->data = (lys_node *)module_local;
    iVar2 = lyp_check_circmod_add((lys_module *)submodule);
    if (iVar2 == 0) {
      iVar2 = yang_parse_mem(module_local,submodule,unres_local,data_local,size_local,&node);
      if (iVar2 == 0) {
        lyp_sort_revisions((lys_module *)submodule);
        iVar2 = yang_check_sub_module((lys_module *)submodule,unres_local,node);
        if (iVar2 == 0) {
          lyp_check_circmod_pop(module_local->ctx);
          ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,"Submodule \"%s\" successfully parsed.",
                 submodule->name);
          plVar4 = submodule;
          goto LAB_00195f65;
        }
      }
      else {
        free_yang_common((lys_module *)submodule,node);
      }
    }
  }
  if ((submodule == (lys_submodule *)0x0) || (submodule->name == (char *)0x0)) {
    free(submodule);
    pLVar3 = ly_errno_glob_address();
    ly_log(module_local->ctx,LY_LLERR,*pLVar3,"Submodule parsing failed.");
    plVar4 = (lys_submodule *)0x0;
  }
  else {
    pcVar1 = submodule->name;
    pLVar3 = ly_errno_glob_address();
    ly_log(module_local->ctx,LY_LLERR,*pLVar3,"Submodule \"%s\" parsing failed.",pcVar1);
    unres_schema_free((lys_module *)submodule,&unres_local,0);
    lyp_check_circmod_pop(module_local->ctx);
    lys_sub_module_remove_devs_augs((lys_module *)submodule);
    lys_submodule_module_data_free(submodule);
    lys_submodule_free(submodule,(_func_void_lys_node_ptr_void_ptr *)0x0);
    plVar4 = (lys_submodule *)0x0;
  }
LAB_00195f65:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int read_indent(char *input,int indent,int size,int in_index,int *out_index,char *output)

{
  char *output_local;
  int *out_index_local;
  int in_index_local;
  int size_local;
  int indent_local;
  char *input_local;
  int k;
  int j;
  
  k = 0;
  in_index_local = in_index;
  do {
    if (size <= in_index_local) goto LAB_00196028;
    if (input[in_index_local] == ' ') {
      k = k + 1;
    }
    else {
      if (input[in_index_local] != '\t') goto LAB_00196028;
      k = k + 8;
    }
    in_index_local = in_index_local + 1;
  } while (k < indent);
  for (j = k - indent; 0 < j; j = j + -1) {
    *out_index = *out_index + 1;
    output[*out_index] = ' ';
  }
LAB_00196028:
  return in_index_local + -1;
}



char * yang_read_string(ly_ctx *ctx,char *input,char *output,int size,int offset,int indent)

{
  char cVar1;
  long in_FS_OFFSET;
  int indent_local;
  int offset_local;
  int size_local;
  char *output_local;
  char *input_local;
  ly_ctx *ctx_local;
  int out_index;
  int i;
  int space;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  i = 0;
  space = 0;
  out_index = offset;
  do {
    if (size <= i) {
      output[out_index] = '\0';
      if ((size != out_index) &&
         (output = (char *)realloc(output,(long)(out_index + 1)), output == (char *)0x0)) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_read_string");
        output = (char *)0x0;
      }
LAB_001962dd:
      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
        return output;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    cVar1 = input[i];
    if (cVar1 == '\\') {
      space = 0;
      if (input[(long)i + 1] == 'n') {
        output[out_index] = '\n';
      }
      else if (input[(long)i + 1] == 't') {
        output[out_index] = '\t';
      }
      else if (input[(long)i + 1] == '\\') {
        output[out_index] = '\\';
      }
      else {
        if ((size == i + 1) || (input[(long)i + 1] != '\"')) {
          ly_vlog(ctx,LYE_XML_INCHAR,LY_VLOG_NONE,(void *)0x0,input + i);
          output = (char *)0x0;
          goto LAB_001962dd;
        }
        output[out_index] = '\"';
      }
      i = i + 1;
    }
    else {
      if (cVar1 < ']') {
        if (cVar1 == ' ') {
LAB_0019610a:
          output[out_index] = input[i];
          space = space + 1;
          goto LAB_00196255;
        }
        if (cVar1 < '!') {
          if (cVar1 == '\t') goto LAB_0019610a;
          if (cVar1 == '\n') {
            out_index = out_index - space;
            output[out_index] = '\n';
            space = 0;
            i = read_indent(input,indent,size,i + 1,&out_index,output);
            goto LAB_00196255;
          }
        }
      }
      output[out_index] = input[i];
      space = 0;
    }
LAB_00196255:
    i = i + 1;
    out_index = out_index + 1;
  } while( true );
}



void yang_type_free(ly_ctx *ctx,lys_type *type)

{
  lys_tpdf *__ptr;
  lys_type *type_local;
  ly_ctx *ctx_local;
  uint i;
  yang_type *stype;
  
  __ptr = type->der;
  if (__ptr != (lys_tpdf *)0x0) {
    if ((type->base == LY_TYPE_DER) || (type->base == LY_TYPE_UNION)) {
      lydict_remove(ctx,__ptr->dsc);
      if ((*(int *)((long)&__ptr->name + 4) == 7) && ((*(byte *)&__ptr->name & 0x20) == 0)) {
        for (i = 0; i < (type->info).bits.count; i = i + 1) {
          free((&((type->info).bits.bit)->name)[i]);
        }
      }
      if (*(int *)((long)&__ptr->name + 4) == 0xb) {
        for (i = 0; i < (type->info).bits.count; i = i + 1) {
          yang_type_free(ctx,(lys_type *)((ulong)i * 0x40 + (long)(type->info).bits.bit));
        }
        free((type->info).bits.bit);
        type->base = LY_TYPE_DER;
      }
      else {
        type->base = *(LY_DATA_TYPE *)((long)&__ptr->name + 4);
      }
      free(__ptr);
      type->der = (lys_tpdf *)0x0;
    }
    lys_type_free(ctx,type,(_func_void_lys_node_ptr_void_ptr *)0x0);
    memset(type,0,0x40);
  }
  return;
}



void yang_tpdf_free(ly_ctx *ctx,lys_tpdf *tpdf,uint16_t start,uint16_t size)

{
  uint16_t size_local;
  uint16_t start_local;
  lys_tpdf *tpdf_local;
  ly_ctx *ctx_local;
  uint16_t i;
  
  if (ctx != (ly_ctx *)0x0) {
    i = start;
    if (tpdf != (lys_tpdf *)0x0) {
      for (; i < size; i = i + 1) {
        lydict_remove(ctx,tpdf[i].name);
        lydict_remove(ctx,tpdf[i].dsc);
        lydict_remove(ctx,tpdf[i].ref);
        yang_type_free(ctx,&tpdf[i].type);
        lydict_remove(ctx,tpdf[i].units);
        lydict_remove(ctx,tpdf[i].dflt);
        lys_extension_instances_free
                  (ctx,tpdf[i].ext,(uint)tpdf[i].ext_size,(_func_void_lys_node_ptr_void_ptr *)0x0);
      }
    }
    return;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("ctx",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
                ,0xb60,"yang_tpdf_free");
}



void yang_free_import(ly_ctx *ctx,lys_import *imp,uint8_t start,uint8_t size)

{
  uint8_t size_local;
  uint8_t start_local;
  lys_import *imp_local;
  ly_ctx *ctx_local;
  uint8_t i;
  
  for (i = start; i < size; i = i + '\x01') {
    free(imp[i].module);
    lydict_remove(ctx,imp[i].prefix);
    lydict_remove(ctx,imp[i].dsc);
    lydict_remove(ctx,imp[i].ref);
    lys_extension_instances_free
              (ctx,imp[i].ext,(uint)imp[i].ext_size,(_func_void_lys_node_ptr_void_ptr *)0x0);
  }
  return;
}



void yang_free_include(ly_ctx *ctx,lys_include *inc,uint8_t start,uint8_t size)

{
  uint8_t size_local;
  uint8_t start_local;
  lys_include *inc_local;
  ly_ctx *ctx_local;
  uint8_t i;
  
  for (i = start; i < size; i = i + '\x01') {
    free(inc[i].submodule);
    lydict_remove(ctx,inc[i].dsc);
    lydict_remove(ctx,inc[i].ref);
    lys_extension_instances_free
              (ctx,inc[i].ext,(uint)inc[i].ext_size,(_func_void_lys_node_ptr_void_ptr *)0x0);
  }
  return;
}



void yang_free_ident_base(lys_ident *ident,uint32_t start,uint32_t size)

{
  uint32_t size_local;
  uint32_t start_local;
  lys_ident *ident_local;
  uint8_t j;
  uint32_t i;
  
  for (i = start; i < size; i = i + 1) {
    for (j = '\0'; j < ident[i].base_size; j = j + '\x01') {
      free(ident[i].base[j]);
    }
  }
  return;
}



void yang_free_grouping(ly_ctx *ctx,lys_node_grp *grp)

{
  lys_node_grp *grp_local;
  ly_ctx *ctx_local;
  
  yang_tpdf_free(ctx,grp->tpdf,0,grp->tpdf_size);
  free(grp->tpdf);
  return;
}



void yang_free_container(ly_ctx *ctx,lys_node_container *cont)

{
  lys_node_container *cont_local;
  ly_ctx *ctx_local;
  uint8_t i;
  
  yang_tpdf_free(ctx,cont->tpdf,0,cont->tpdf_size);
  free(cont->tpdf);
  lydict_remove(ctx,cont->presence);
  for (i = '\0'; i < cont->must_size; i = i + '\x01') {
    lys_restr_free(ctx,cont->must + i,(_func_void_lys_node_ptr_void_ptr *)0x0);
  }
  free(cont->must);
  lys_when_free(ctx,cont->when,(_func_void_lys_node_ptr_void_ptr *)0x0);
  return;
}



void yang_free_leaf(ly_ctx *ctx,lys_node_leaf *leaf)

{
  lys_node_leaf *leaf_local;
  ly_ctx *ctx_local;
  uint8_t i;
  
  for (i = '\0'; i < leaf->must_size; i = i + '\x01') {
    lys_restr_free(ctx,leaf->must + i,(_func_void_lys_node_ptr_void_ptr *)0x0);
  }
  free(leaf->must);
  lys_when_free(ctx,leaf->when,(_func_void_lys_node_ptr_void_ptr *)0x0);
  yang_type_free(ctx,&leaf->type);
  lydict_remove(ctx,leaf->units);
  lydict_remove(ctx,leaf->dflt);
  return;
}



void yang_free_leaflist(ly_ctx *ctx,lys_node_leaflist *leaflist)

{
  lys_node_leaflist *leaflist_local;
  ly_ctx *ctx_local;
  uint8_t i;
  
  for (i = '\0'; i < leaflist->must_size; i = i + '\x01') {
    lys_restr_free(ctx,leaflist->must + i,(_func_void_lys_node_ptr_void_ptr *)0x0);
  }
  free(leaflist->must);
  for (i = '\0'; i < leaflist->dflt_size; i = i + '\x01') {
    lydict_remove(ctx,leaflist->dflt[i]);
  }
  free(leaflist->dflt);
  lys_when_free(ctx,leaflist->when,(_func_void_lys_node_ptr_void_ptr *)0x0);
  yang_type_free(ctx,&leaflist->type);
  lydict_remove(ctx,leaflist->units);
  return;
}



void yang_free_list(ly_ctx *ctx,lys_node_list *list)

{
  lys_node_list *list_local;
  ly_ctx *ctx_local;
  uint8_t i;
  
  yang_tpdf_free(ctx,list->tpdf,0,(ushort)list->tpdf_size);
  free(list->tpdf);
  for (i = '\0'; i < list->must_size; i = i + '\x01') {
    lys_restr_free(ctx,list->must + i,(_func_void_lys_node_ptr_void_ptr *)0x0);
  }
  free(list->must);
  lys_when_free(ctx,list->when,(_func_void_lys_node_ptr_void_ptr *)0x0);
  for (i = '\0'; i < list->unique_size; i = i + '\x01') {
    free(list->unique[i].expr);
  }
  free(list->unique);
  free(list->keys);
  return;
}



void yang_free_choice(ly_ctx *ctx,lys_node_choice *choice)

{
  lys_node_choice *choice_local;
  ly_ctx *ctx_local;
  
  free(choice->dflt);
  lys_when_free(ctx,choice->when,(_func_void_lys_node_ptr_void_ptr *)0x0);
  return;
}



void yang_free_anydata(ly_ctx *ctx,lys_node_anydata *anydata)

{
  lys_node_anydata *anydata_local;
  ly_ctx *ctx_local;
  uint8_t i;
  
  for (i = '\0'; i < anydata->must_size; i = i + '\x01') {
    lys_restr_free(ctx,anydata->must + i,(_func_void_lys_node_ptr_void_ptr *)0x0);
  }
  free(anydata->must);
  lys_when_free(ctx,anydata->when,(_func_void_lys_node_ptr_void_ptr *)0x0);
  return;
}



void yang_free_inout(ly_ctx *ctx,lys_node_inout *inout)

{
  lys_node_inout *inout_local;
  ly_ctx *ctx_local;
  uint8_t i;
  
  yang_tpdf_free(ctx,inout->tpdf,0,inout->tpdf_size);
  free(inout->tpdf);
  for (i = '\0'; i < inout->must_size; i = i + '\x01') {
    lys_restr_free(ctx,inout->must + i,(_func_void_lys_node_ptr_void_ptr *)0x0);
  }
  free(inout->must);
  return;
}



void yang_free_notif(ly_ctx *ctx,lys_node_notif *notif)

{
  lys_node_notif *notif_local;
  ly_ctx *ctx_local;
  uint8_t i;
  
  yang_tpdf_free(ctx,notif->tpdf,0,notif->tpdf_size);
  free(notif->tpdf);
  for (i = '\0'; i < notif->must_size; i = i + '\x01') {
    lys_restr_free(ctx,notif->must + i,(_func_void_lys_node_ptr_void_ptr *)0x0);
  }
  free(notif->must);
  return;
}



void yang_free_uses(ly_ctx *ctx,lys_node_uses *uses)

{
  lys_node_uses *uses_local;
  ly_ctx *ctx_local;
  int i;
  int j;
  
  for (i = 0; i < (int)(uint)uses->refine_size; i = i + 1) {
    lydict_remove(ctx,uses->refine[i].target_name);
    lydict_remove(ctx,uses->refine[i].dsc);
    lydict_remove(ctx,uses->refine[i].ref);
    for (j = 0; j < (int)(uint)uses->refine[i].must_size; j = j + 1) {
      lys_restr_free(ctx,uses->refine[i].must + j,(_func_void_lys_node_ptr_void_ptr *)0x0);
    }
    free(uses->refine[i].must);
    for (j = 0; j < (int)(uint)uses->refine[i].dflt_size; j = j + 1) {
      lydict_remove(ctx,uses->refine[i].dflt[j]);
    }
    free(uses->refine[i].dflt);
    if ((uses->refine[i].target_type & 1) != 0) {
      lydict_remove(ctx,uses->refine[i].mod.presence);
    }
    lys_extension_instances_free
              (ctx,uses->refine[i].ext,(uint)uses->refine[i].ext_size,
               (_func_void_lys_node_ptr_void_ptr *)0x0);
  }
  free(uses->refine);
  lys_when_free(ctx,uses->when,(_func_void_lys_node_ptr_void_ptr *)0x0);
  return;
}



void yang_free_nodes(ly_ctx *ctx,lys_node *node)

{
  LYS_NODE LVar1;
  lys_node *node_00;
  lys_node *plVar2;
  lys_node *node_local;
  ly_ctx *ctx_local;
  lys_node *tmp;
  lys_node *child;
  lys_node *sibling;
  
  tmp = node;
  if (node != (lys_node *)0x0) {
    while (tmp != (lys_node *)0x0) {
      node_00 = tmp->child;
      plVar2 = tmp->next;
      lydict_remove(ctx,tmp->name);
      if ((tmp->nodetype & 0x600) == LYS_UNKNOWN) {
        lys_iffeature_free(ctx,tmp->iffeature,tmp->iffeature_size,0,
                           (_func_void_lys_node_ptr_void_ptr *)0x0);
        lydict_remove(ctx,tmp->dsc);
        lydict_remove(ctx,tmp->ref);
      }
      LVar1 = tmp->nodetype;
      if (LVar1 == LYS_ANYDATA) {
switchD_001973f6_caseD_20:
        yang_free_anydata(ctx,(lys_node_anydata *)tmp);
      }
      else if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
        if (LVar1 == LYS_ACTION) {
LAB_00197407:
          yang_free_grouping(ctx,(lys_node_grp *)tmp);
        }
        else if (LVar1 < (LYS_CONTAINER|LYS_ACTION)) {
          if (LVar1 == LYS_USES) {
            yang_free_uses(ctx,(lys_node_uses *)tmp);
          }
          else if (LVar1 < (LYS_CONTAINER|LYS_USES)) {
            if (LVar1 == LYS_GROUPING) goto LAB_00197407;
            if (LVar1 < (LYS_CONTAINER|LYS_GROUPING)) {
              if (LVar1 == LYS_OUTPUT) {
LAB_001974c7:
                yang_free_inout(ctx,(lys_node_inout *)tmp);
              }
              else if (LVar1 < (LYS_CONTAINER|LYS_OUTPUT)) {
                if (LVar1 == LYS_INPUT) goto LAB_001974c7;
                if (LVar1 < (LYS_CONTAINER|LYS_INPUT)) {
                  if (LVar1 == LYS_RPC) goto LAB_00197407;
                  if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
                    if (LVar1 == LYS_NOTIF) {
                      yang_free_notif(ctx,(lys_node_notif *)tmp);
                    }
                    else if (LVar1 < (LYS_CONTAINER|LYS_NOTIF)) {
                      if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
                        if ((LVar1 != LYS_UNKNOWN) && (true)) {
                          switch(LVar1) {
                          case LYS_CONTAINER:
                            yang_free_container(ctx,(lys_node_container *)tmp);
                            break;
                          case LYS_CHOICE:
                            yang_free_choice(ctx,(lys_node_choice *)tmp);
                            break;
                          case LYS_LEAF:
                            yang_free_leaf(ctx,(lys_node_leaf *)tmp);
                            break;
                          case LYS_LEAFLIST:
                            yang_free_leaflist(ctx,(lys_node_leaflist *)tmp);
                            break;
                          case LYS_LIST:
                            yang_free_list(ctx,(lys_node_list *)tmp);
                            break;
                          case LYS_ANYXML:
                            goto switchD_001973f6_caseD_20;
                          }
                        }
                      }
                      else if (LVar1 == LYS_CASE) {
                        lys_when_free(ctx,*(lys_when **)tmp->hash,
                                      (_func_void_lys_node_ptr_void_ptr *)0x0);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      lys_extension_instances_free
                (ctx,tmp->ext,(uint)tmp->ext_size,(_func_void_lys_node_ptr_void_ptr *)0x0);
      yang_free_nodes(ctx,node_00);
      free(tmp);
      tmp = plVar2;
    }
  }
  return;
}



void yang_free_augment(ly_ctx *ctx,lys_node_augment *aug)

{
  lys_node_augment *aug_local;
  ly_ctx *ctx_local;
  
  lydict_remove(ctx,aug->target_name);
  lydict_remove(ctx,aug->dsc);
  lydict_remove(ctx,aug->ref);
  lys_iffeature_free(ctx,aug->iffeature,aug->iffeature_size,0,
                     (_func_void_lys_node_ptr_void_ptr *)0x0);
  lys_when_free(ctx,aug->when,(_func_void_lys_node_ptr_void_ptr *)0x0);
  yang_free_nodes(ctx,aug->child);
  lys_extension_instances_free
            (ctx,aug->ext,(uint)aug->ext_size,(_func_void_lys_node_ptr_void_ptr *)0x0);
  return;
}



void yang_free_deviate(ly_ctx *ctx,lys_deviation *dev,uint index)

{
  uint index_local;
  lys_deviation *dev_local;
  ly_ctx *ctx_local;
  uint i;
  uint j;
  
  for (i = index; i < dev->deviate_size; i = i + 1) {
    lydict_remove(ctx,dev->deviate[i].units);
    if (dev->deviate[i].type != (lys_type *)0x0) {
      yang_type_free(ctx,dev->deviate[i].type);
      free(dev->deviate[i].type);
    }
    for (j = 0; j < dev->deviate[i].dflt_size; j = j + 1) {
      lydict_remove(ctx,dev->deviate[i].dflt[j]);
    }
    free(dev->deviate[i].dflt);
    for (j = 0; j < dev->deviate[i].must_size; j = j + 1) {
      lys_restr_free(ctx,dev->deviate[i].must + j,(_func_void_lys_node_ptr_void_ptr *)0x0);
    }
    free(dev->deviate[i].must);
    for (j = 0; j < dev->deviate[i].unique_size; j = j + 1) {
      free(dev->deviate[i].unique[j].expr);
    }
    free(dev->deviate[i].unique);
    lys_extension_instances_free
              (ctx,dev->deviate[i].ext,(uint)dev->deviate[i].ext_size,
               (_func_void_lys_node_ptr_void_ptr *)0x0);
  }
  return;
}



void yang_free_ext_data(yang_ext_substmt *substmt)

{
  yang_ext_substmt *substmt_local;
  int i;
  
  if (substmt != (yang_ext_substmt *)0x0) {
    free(substmt->ext_substmt);
    if (substmt->ext_modules != (char **)0x0) {
      for (i = 0; substmt->ext_modules[i] != (char *)0x0; i = i + 1) {
        free(substmt->ext_modules[i]);
      }
      free(substmt->ext_modules);
    }
    free(substmt);
  }
  return;
}



void free_yang_common(lys_module *module,lys_node *node)

{
  lys_node *node_local;
  lys_module *module_local;
  uint i;
  
  yang_tpdf_free(module->ctx,module->tpdf,0,module->tpdf_size);
  module->tpdf_size = 0;
  yang_free_ident_base(module->ident,0,(uint)module->ident_size);
  yang_free_nodes(module->ctx,node);
  for (i = 0; i < module->augment_size; i = i + 1) {
    yang_free_augment(module->ctx,module->augment + i);
  }
  module->augment_size = '\0';
  for (i = 0; i < module->deviation_size; i = i + 1) {
    yang_free_deviate(module->ctx,module->deviation + i,0);
    free(module->deviation[i].deviate);
    lydict_remove(module->ctx,module->deviation[i].target_name);
    lydict_remove(module->ctx,module->deviation[i].dsc);
    lydict_remove(module->ctx,module->deviation[i].ref);
  }
  module->deviation_size = '\0';
  return;
}



int yang_check_ext_instance
              (lys_module *module,lys_ext_instance ***ext,uint size,void *parent,unres_schema *unres
              )

{
  int iVar1;
  lys_node *snode;
  unres_schema *unres_local;
  void *parent_local;
  uint size_local;
  lys_ext_instance ***ext_local;
  lys_module *module_local;
  uint i;
  unres_ext *info;
  
  i = 0;
  while( true ) {
    if (size <= i) {
      return 0;
    }
    snode = (lys_node *)malloc(0x30);
    if (snode == (lys_node *)0x0) break;
    snode->name = (char *)(*ext)[i]->parent;
    *(undefined4 *)&snode->dsc = 1;
    snode->ref = (char *)parent;
    *(lys_module **)&snode->flags = module;
    *(uint *)&snode->ext = (uint)(*ext)[i]->parent_type;
    *(uint *)((long)&snode->ext + 4) = (uint)(*ext)[i]->insubstmt;
    *(uint8_t *)&snode->iffeature = (*ext)[i]->insubstmt_index;
    *(char *)((long)&snode->iffeature + 1) = (char)i;
    iVar1 = unres_schema_add_node(module,unres,ext,UNRES_EXT,snode);
    if (iVar1 == -1) {
      return 1;
    }
    i = i + 1;
  }
  ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_check_ext_instance");
  return 1;
}



int yang_check_imports(lys_module *module,unres_schema *unres)

{
  byte size;
  byte size_00;
  lys_import *imp_00;
  lys_include *inc_00;
  lys_module *value;
  lys_submodule *value_00;
  int iVar1;
  lys_import *plVar2;
  lys_include *plVar3;
  unres_schema *unres_local;
  lys_module *module_local;
  uint8_t j;
  uint8_t i;
  uint8_t imp_size;
  uint8_t inc_size;
  lys_import *imp;
  lys_include *inc;
  char *s;
  
  j = '\0';
  i = '\0';
  imp_00 = module->imp;
  size = module->imp_size;
  inc_00 = module->inc;
  size_00 = module->inc_size;
  if (size == 0) {
LAB_00197e13:
    if (size_00 != 0) {
      plVar3 = (lys_include *)calloc((ulong)size_00,0x30);
      module->inc = plVar3;
      module->inc_size = '\0';
      if (module->inc == (lys_include *)0x0) {
        ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_check_imports")
        ;
        goto LAB_00198004;
      }
    }
    for (i = '\0'; i < size; i = i + '\x01') {
      value = imp_00[i].module;
      imp_00[i].module = (lys_module *)0x0;
      iVar1 = yang_fill_import(module,imp_00 + i,module->imp + module->imp_size,(char *)value,unres)
      ;
      if (iVar1 != 0) {
        i = i + '\x01';
        goto LAB_00198004;
      }
    }
    for (j = '\0'; j < size_00; j = j + '\x01') {
      value_00 = inc_00[j].submodule;
      inc_00[j].submodule = (lys_submodule *)0x0;
      iVar1 = yang_fill_include(module,(char *)value_00,inc_00 + j,unres);
      if (iVar1 != 0) {
        j = j + '\x01';
        goto LAB_00198004;
      }
    }
    free(inc_00);
    free(imp_00);
    iVar1 = 0;
  }
  else {
    plVar2 = (lys_import *)calloc((ulong)size,0x38);
    module->imp = plVar2;
    module->imp_size = '\0';
    if (module->imp != (lys_import *)0x0) goto LAB_00197e13;
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_check_imports");
LAB_00198004:
    yang_free_import(module->ctx,imp_00,i,size);
    yang_free_include(module->ctx,inc_00,j,size_00);
    free(imp_00);
    free(inc_00);
    iVar1 = 1;
  }
  return iVar1;
}



int yang_check_iffeatures
              (lys_module *module,void *ptr,void *parent,yytokentype type,unres_schema *unres)

{
  lys_feature **value;
  int iVar1;
  unres_schema *unres_local;
  yytokentype type_local;
  void *parent_local;
  void *ptr_local;
  lys_module *module_local;
  uint8_t size;
  uint8_t i;
  int parent_is_feature;
  lys_iffeature *iffeature;
  uint8_t *ptr_size;
  char *s;
  
  parent_is_feature = 0;
  if (type == REFINE_KEYWORD) {
    iffeature = *(lys_iffeature **)((long)ptr + 0x28);
    size = *(uint8_t *)((long)ptr + 0x1b);
    ptr_size = (uint8_t *)((long)ptr + 0x1b);
    goto LAB_001981ca;
  }
  if (type < REQUIRE_INSTANCE_KEYWORD) {
    if (type == IDENTITY_KEYWORD) {
      iffeature = *(lys_iffeature **)((long)parent + 0x28);
      size = *(uint8_t *)((long)parent + 0x1b);
      ptr_size = (uint8_t *)((long)parent + 0x1b);
      goto LAB_001981ca;
    }
    if (type < IF_FEATURE_KEYWORD) {
      if (type == FEATURE_KEYWORD) {
        iffeature = *(lys_iffeature **)((long)parent + 0x28);
        size = *(uint8_t *)((long)parent + 0x1b);
        ptr_size = (uint8_t *)((long)parent + 0x1b);
        parent_is_feature = 1;
        goto LAB_001981ca;
      }
      if (type < FRACTION_DIGITS_KEYWORD) {
        if (type == BIT_KEYWORD) {
          iffeature = *(lys_iffeature **)((long)ptr + 0x28);
          size = *(uint8_t *)((long)ptr + 0x1b);
          ptr_size = (uint8_t *)((long)ptr + 0x1b);
          goto LAB_001981ca;
        }
        if (type == ENUM_KEYWORD) {
          iffeature = *(lys_iffeature **)((long)ptr + 0x28);
          size = *(uint8_t *)((long)ptr + 0x1b);
          ptr_size = (uint8_t *)((long)ptr + 0x1b);
          goto LAB_001981ca;
        }
      }
    }
  }
  iffeature = *(lys_iffeature **)((long)parent + 0x28);
  size = *(uint8_t *)((long)parent + 0x1b);
  ptr_size = (uint8_t *)((long)parent + 0x1b);
LAB_001981ca:
  *ptr_size = '\0';
  i = '\0';
  while( true ) {
    if (size <= i) {
      return 0;
    }
    value = iffeature[i].features;
    iffeature[i].features = (lys_feature **)0x0;
    iVar1 = yang_fill_iffeature(module,iffeature + i,parent,(char *)value,unres,parent_is_feature);
    if (iVar1 != 0) break;
    iVar1 = yang_check_ext_instance
                      (module,&iffeature[i].ext,(uint)iffeature[i].ext_size,iffeature + i,unres);
    if (iVar1 != 0) {
      *ptr_size = size;
      return 1;
    }
    *ptr_size = *ptr_size + '\x01';
    i = i + '\x01';
  }
  *ptr_size = size;
  return 1;
}



int yang_check_identityref(lys_module *module,lys_type *type,unres_schema *unres)

{
  uint uVar1;
  lys_type_bit *__ptr;
  char *expr_00;
  int iVar2;
  char *str;
  unres_schema *unres_local;
  lys_type *type_local;
  lys_module *module_local;
  uint i;
  uint size;
  int rc;
  lys_ident **ref;
  char *expr;
  char *value;
  
  __ptr = (type->info).bits.bit;
  uVar1 = (type->info).bits.count;
  (type->info).bits.count = 0;
  (type->info).bits.bit = (lys_type_bit *)0x0;
  *(byte *)&type->der->name = *(byte *)&type->der->name | 0x20;
  i = 0;
  while( true ) {
    if (uVar1 <= i) {
      free(__ptr);
      return 0;
    }
    expr_00 = (&__ptr->name)[i];
    str = transform_schema2json(module,expr_00);
    free(expr_00);
    if (str == (char *)0x0) break;
    iVar2 = unres_schema_add_str(module,unres,type,UNRES_TYPE_IDENTREF,str);
    lydict_remove(module->ctx,str);
    if (iVar2 == -1) break;
    i = i + 1;
  }
  while (i = i + 1, i < uVar1) {
    free((&__ptr->name)[i]);
  }
  free(__ptr);
  return 1;
}



int yang_fill_type(lys_module *module,lys_type *type,yang_type *stype,void *parent,
                  unres_schema *unres)

{
  int iVar1;
  unres_schema *unres_local;
  void *parent_local;
  yang_type *stype_local;
  lys_type *type_local;
  lys_module *module_local;
  uint i;
  uint j;
  
  type->parent = (lys_tpdf *)parent;
  iVar1 = yang_check_ext_instance(module,&type->ext,(uint)type->ext_size,type,unres);
  if (iVar1 == 0) {
    for (j = 0; j < type->ext_size; j = j + 1) {
      if ((type->ext[j]->flags & 8) != 0) {
        type->parent->flags = type->parent->flags | 0x2000;
        break;
      }
    }
    if (true) {
      switch(stype->base) {
      case LY_TYPE_BITS:
        for (i = 0; i < (type->info).bits.count; i = i + 1) {
          iVar1 = yang_check_iffeatures(module,(type->info).bits.bit + i,parent,BIT_KEYWORD,unres);
          if (iVar1 != 0) {
            return 1;
          }
          iVar1 = yang_check_ext_instance
                            (module,&(type->info).bits.bit[i].ext,
                             (uint)(type->info).bits.bit[i].ext_size,(type->info).bits.bit + i,unres
                            );
          if (iVar1 != 0) {
            return 1;
          }
          for (j = 0; j < (type->info).bits.bit[i].ext_size; j = j + 1) {
            if (((type->info).bits.bit[i].ext[j]->flags & 8) != 0) {
              type->parent->flags = type->parent->flags | 0x2000;
              break;
            }
          }
        }
        break;
      case LY_TYPE_DEC64:
        if ((type->info).bits.bit != (lys_type_bit *)0x0) {
          iVar1 = yang_check_ext_instance
                            (module,&((type->info).dec64.range)->ext,
                             (uint)((type->info).dec64.range)->ext_size,(type->info).bits.bit,unres)
          ;
          if (iVar1 != 0) {
            return 1;
          }
          for (j = 0; j < ((type->info).dec64.range)->ext_size; j = j + 1) {
            if ((*(ushort *)((&((type->info).bits.bit)->iffeature->expr)[j] + 0x18) & 8) != 0) {
              type->parent->flags = type->parent->flags | 0x2000;
              break;
            }
          }
        }
        break;
      case LY_TYPE_ENUM:
        for (i = 0; i < (type->info).bits.count; i = i + 1) {
          iVar1 = yang_check_iffeatures(module,(type->info).bits.bit + i,parent,ENUM_KEYWORD,unres);
          if (iVar1 != 0) {
            return 1;
          }
          iVar1 = yang_check_ext_instance
                            (module,&(type->info).bits.bit[i].ext,
                             (uint)(type->info).bits.bit[i].ext_size,(type->info).bits.bit + i,unres
                            );
          if (iVar1 != 0) {
            return 1;
          }
          for (j = 0; j < (type->info).bits.bit[i].ext_size; j = j + 1) {
            if (((type->info).bits.bit[i].ext[j]->flags & 8) != 0) {
              type->parent->flags = type->parent->flags | 0x2000;
              break;
            }
          }
        }
        break;
      case LY_TYPE_IDENT:
        iVar1 = yang_check_identityref(module,type,unres);
        if (iVar1 != 0) {
          return 1;
        }
        break;
      case LY_TYPE_STRING:
        if ((type->info).bits.bit != (lys_type_bit *)0x0) {
          iVar1 = yang_check_ext_instance
                            (module,&((type->info).dec64.range)->ext,
                             (uint)((type->info).dec64.range)->ext_size,(type->info).bits.bit,unres)
          ;
          if (iVar1 != 0) {
            return 1;
          }
          for (j = 0; j < ((type->info).dec64.range)->ext_size; j = j + 1) {
            if ((*(ushort *)((&((type->info).bits.bit)->iffeature->expr)[j] + 0x18) & 8) != 0) {
              type->parent->flags = type->parent->flags | 0x2000;
              break;
            }
          }
        }
        for (i = 0; i < (type->info).str.pat_count; i = i + 1) {
          iVar1 = yang_check_ext_instance
                            (module,(lys_ext_instance ***)
                                    (((type->info).lref.target)->padding + (ulong)i * 0x38 + 0xc),
                             (uint)((type->info).lref.target)->padding[(ulong)i * 0x38 + 0x14],
                             ((type->info).lref.target)->padding + (ulong)i * 0x38 + -0x1c,unres);
          if (iVar1 != 0) {
            return 1;
          }
          for (j = 0; j < ((type->info).lref.target)->padding[(ulong)i * 0x38 + 0x14]; j = j + 1) {
            if ((*(ushort *)
                  (*(long *)(*(long *)(((type->info).lref.target)->padding + (ulong)i * 0x38 + 0xc)
                            + (ulong)j * 8) + 0x18) & 8) != 0) {
              type->parent->flags = type->parent->flags | 0x2000;
              break;
            }
          }
        }
        break;
      case LY_TYPE_UNION:
        for (i = 0; i < (type->info).bits.count; i = i + 1) {
          iVar1 = yang_fill_type(module,(lys_type *)((long)(type->info).bits.bit + (ulong)i * 0x40),
                                 *(yang_type **)
                                  ((long)(type->info).bits.bit + (ulong)i * 0x40 + 0x10),parent,
                                 unres);
          if (iVar1 != 0) {
            return 1;
          }
        }
      }
    }
    iVar1 = 0;
  }
  else {
    iVar1 = 1;
  }
  return iVar1;
}



int yang_check_typedef(lys_module *module,lys_node *parent,unres_schema *unres)

{
  LYS_NODE LVar1;
  int iVar2;
  unres_schema *unres_local;
  lys_node *parent_local;
  lys_module *module_local;
  uint16_t j;
  uint16_t i;
  uint16_t tpdf_size;
  lys_tpdf *tpdf;
  uint8_t *ptr_tpdf_size;
  uint16_t *ptr_tpdf_size16;
  
  ptr_tpdf_size = (uint8_t *)0x0;
  ptr_tpdf_size16 = (uint16_t *)0x0;
  if (parent == (lys_node *)0x0) {
    tpdf = module->tpdf;
    ptr_tpdf_size16 = &module->tpdf_size;
    goto LAB_00198d48;
  }
  LVar1 = parent->nodetype;
  if (LVar1 == LYS_ACTION) {
LAB_00198cbe:
    tpdf = (lys_tpdf *)parent[1].name;
    ptr_tpdf_size16 = (uint16_t *)(parent->padding + 2);
  }
  else {
    if (LYS_ACTION < LVar1) {
LAB_00198d0c:
      ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
             ,0xe2a);
      return 1;
    }
    if (LVar1 == LYS_GROUPING) {
      tpdf = *(lys_tpdf **)parent->hash;
      ptr_tpdf_size16 = (uint16_t *)(parent->padding + 2);
      goto LAB_00198d48;
    }
    if (LYS_GROUPING < LVar1) goto LAB_00198d0c;
    if (LVar1 != LYS_OUTPUT) {
      if (LYS_OUTPUT < LVar1) goto LAB_00198d0c;
      if (LVar1 != LYS_INPUT) {
        if (LYS_INPUT < LVar1) goto LAB_00198d0c;
        if (LVar1 != LYS_RPC) {
          if (LYS_RPC < LVar1) goto LAB_00198d0c;
          if (LVar1 == LYS_NOTIF) {
            tpdf = (lys_tpdf *)parent[1].name;
            ptr_tpdf_size16 = (uint16_t *)(parent->padding + 2);
          }
          else {
            if (LYS_NOTIF < LVar1) goto LAB_00198d0c;
            if (LVar1 == LYS_CONTAINER) {
              tpdf = (lys_tpdf *)parent[1].ref;
              ptr_tpdf_size16 = (uint16_t *)(parent->padding + 2);
            }
            else {
              if (LVar1 != LYS_LIST) goto LAB_00198d0c;
              tpdf = (lys_tpdf *)parent[1].ref;
              ptr_tpdf_size = parent->padding + 1;
            }
          }
          goto LAB_00198d48;
        }
        goto LAB_00198cbe;
      }
    }
    tpdf = *(lys_tpdf **)parent->hash;
    ptr_tpdf_size16 = (uint16_t *)(parent->padding + 2);
  }
LAB_00198d48:
  if (ptr_tpdf_size16 == (uint16_t *)0x0) {
    tpdf_size = (uint16_t)*ptr_tpdf_size;
    *ptr_tpdf_size = '\0';
  }
  else {
    tpdf_size = *ptr_tpdf_size16;
    *ptr_tpdf_size16 = 0;
  }
  i = 0;
  while( true ) {
    if (tpdf_size <= i) {
      return 0;
    }
    iVar2 = lyp_check_identifier(module->ctx,tpdf[i].name,LY_IDENT_TYPE,module,parent);
    if (((iVar2 != 0) ||
        (iVar2 = yang_fill_type(module,&tpdf[i].type,(yang_type *)tpdf[i].type.der,tpdf + i,unres),
        iVar2 != 0)) ||
       (iVar2 = yang_check_ext_instance(module,&tpdf[i].ext,(uint)tpdf[i].ext_size,tpdf + i,unres),
       iVar2 != 0)) break;
    for (j = 0; j < tpdf[i].ext_size; j = j + 1) {
      if ((tpdf[i].ext[j]->flags & 8) != 0) {
        tpdf[i].flags = tpdf[i].flags | 0x2000;
        break;
      }
    }
    iVar2 = unres_schema_add_node(module,unres,&tpdf[i].type,UNRES_TYPE_DER_TPDF,parent);
    if (iVar2 == -1) break;
    if (ptr_tpdf_size16 == (uint16_t *)0x0) {
      *ptr_tpdf_size = *ptr_tpdf_size + '\x01';
    }
    else {
      *ptr_tpdf_size16 = *ptr_tpdf_size16 + 1;
    }
    if ((((module->ctx->models).flags & 2U) == 0) &&
       (iVar2 = unres_schema_add_node
                          (module,unres,&tpdf[i].type,UNRES_TYPEDEF_DFLT,(lys_node *)&tpdf[i].dflt),
       iVar2 == -1)) {
      i = i + 1;
      break;
    }
    i = i + 1;
  }
  yang_tpdf_free(module->ctx,tpdf,i,tpdf_size);
  return 1;
}



int yang_check_identities(lys_module *module,unres_schema *unres)

{
  byte bVar1;
  ushort uVar2;
  int iVar3;
  unres_schema *unres_local;
  lys_module *module_local;
  uint8_t j;
  uint32_t i;
  uint32_t size;
  uint32_t base_size;
  
  uVar2 = module->ident_size;
  module->ident_size = 0;
  i = 0;
  while( true ) {
    if (uVar2 <= i) {
      return 0;
    }
    bVar1 = module->ident[i].base_size;
    module->ident[i].base_size = '\0';
    for (j = '\0'; j < bVar1; j = j + '\x01') {
      iVar3 = yang_read_base(module,module->ident + i,(char *)module->ident[i].base[j],unres);
      if (iVar3 != 0) {
        j = j + '\x01';
        module->ident_size = uVar2;
        goto LAB_0019925a;
      }
    }
    module->ident_size = module->ident_size + 1;
    iVar3 = yang_check_iffeatures(module,(void *)0x0,module->ident + i,IDENTITY_KEYWORD,unres);
    if ((iVar3 != 0) ||
       (iVar3 = yang_check_ext_instance
                          (module,&module->ident[i].ext,(uint)module->ident[i].ext_size,
                           module->ident + i,unres), iVar3 != 0)) break;
    i = i + 1;
  }
LAB_0019925a:
  for (; j < module->ident[i].base_size; j = j + '\x01') {
    free(module->ident[i].base[j]);
  }
  yang_free_ident_base(module->ident,i + 1,(uint)uVar2);
  return 1;
}



int yang_check_must(lys_module *module,lys_restr *must,uint size,unres_schema *unres)

{
  int iVar1;
  unres_schema *unres_local;
  uint size_local;
  lys_restr *must_local;
  lys_module *module_local;
  uint i;
  
  i = 0;
  while( true ) {
    if (size <= i) {
      return 0;
    }
    iVar1 = yang_check_ext_instance(module,&must[i].ext,(uint)must[i].ext_size,must + i,unres);
    if (iVar1 != 0) break;
    i = i + 1;
  }
  return 1;
}



int yang_check_container
              (lys_module *module,lys_node_container *cont,lys_node **child,int options,
              unres_schema *unres)

{
  int iVar1;
  unres_schema *unres_local;
  int options_local;
  lys_node **child_local;
  lys_node_container *cont_local;
  lys_module *module_local;
  
  iVar1 = yang_check_typedef(module,(lys_node *)cont,unres);
  if ((iVar1 == 0) &&
     (iVar1 = yang_check_iffeatures(module,(void *)0x0,cont,CONTAINER_KEYWORD,unres), iVar1 == 0)) {
    iVar1 = yang_check_nodes(module,(lys_node *)cont,*child,options,unres);
    if (iVar1 == 0) {
      *child = (lys_node *)0x0;
      if (((cont->when == (lys_when *)0x0) ||
          (iVar1 = yang_check_ext_instance
                             (module,&cont->when->ext,(uint)cont->when->ext_size,cont->when,unres),
          iVar1 == 0)) &&
         (iVar1 = yang_check_must(module,cont->must,(uint)cont->must_size,unres), iVar1 == 0)) {
        if ((((module->ctx->models).flags & 2U) != 0) ||
           ((cont->when == (lys_when *)0x0 && (cont->must_size == '\0')))) {
          return 0;
        }
        if ((options & 4U) == 0) {
          iVar1 = unres_schema_add_node(module,unres,cont,UNRES_XPATH,(lys_node *)0x0);
          if (iVar1 != -1) {
            return 0;
          }
        }
        else {
          iVar1 = lyxp_node_check_syntax((lys_node *)cont);
          if (iVar1 == 0) {
            return 0;
          }
        }
      }
    }
    else {
      *child = (lys_node *)0x0;
    }
  }
  return 1;
}



int yang_check_leaf(lys_module *module,lys_node_leaf *leaf,int options,unres_schema *unres)

{
  int iVar1;
  unres_schema *unres_local;
  int options_local;
  lys_node_leaf *leaf_local;
  lys_module *module_local;
  
  iVar1 = yang_fill_type(module,&leaf->type,(yang_type *)(leaf->type).der,leaf,unres);
  if (iVar1 == 0) {
    iVar1 = yang_check_iffeatures(module,(void *)0x0,leaf,LEAF_KEYWORD,unres);
    if (iVar1 == 0) {
      iVar1 = unres_schema_add_node(module,unres,&leaf->type,UNRES_TYPE_DER,(lys_node *)leaf);
      if (iVar1 == -1) {
        yang_type_free(module->ctx,&leaf->type);
      }
      else if ((((((module->ctx->models).flags & 2U) != 0) ||
                (iVar1 = unres_schema_add_node
                                   (module,unres,&leaf->type,UNRES_TYPE_DFLT,(lys_node *)&leaf->dflt
                                   ), iVar1 != -1)) &&
               ((leaf->when == (lys_when *)0x0 ||
                (iVar1 = yang_check_ext_instance
                                   (module,&leaf->when->ext,(uint)leaf->when->ext_size,leaf->when,
                                    unres), iVar1 == 0)))) &&
              (iVar1 = yang_check_must(module,leaf->must,(uint)leaf->must_size,unres), iVar1 == 0))
      {
        if ((((module->ctx->models).flags & 2U) != 0) ||
           ((leaf->when == (lys_when *)0x0 && (leaf->must_size == '\0')))) {
          return 0;
        }
        if ((options & 4U) == 0) {
          iVar1 = unres_schema_add_node(module,unres,leaf,UNRES_XPATH,(lys_node *)0x0);
          if (iVar1 != -1) {
            return 0;
          }
        }
        else {
          iVar1 = lyxp_node_check_syntax((lys_node *)leaf);
          if (iVar1 == 0) {
            return 0;
          }
        }
      }
    }
    else {
      yang_type_free(module->ctx,&leaf->type);
    }
  }
  else {
    yang_type_free(module->ctx,&leaf->type);
  }
  return 1;
}



int yang_check_leaflist(lys_module *module,lys_node_leaflist *leaflist,int options,
                       unres_schema *unres)

{
  int iVar1;
  unres_schema *unres_local;
  int options_local;
  lys_node_leaflist *leaflist_local;
  lys_module *module_local;
  int i;
  int j;
  
  iVar1 = yang_fill_type(module,&leaflist->type,(yang_type *)(leaflist->type).der,leaflist,unres);
  if (iVar1 == 0) {
    iVar1 = yang_check_iffeatures(module,(void *)0x0,leaflist,LEAF_LIST_KEYWORD,unres);
    if (iVar1 == 0) {
      iVar1 = unres_schema_add_node
                        (module,unres,&leaflist->type,UNRES_TYPE_DER,(lys_node *)leaflist);
      if (iVar1 == -1) {
        yang_type_free(module->ctx,&leaflist->type);
      }
      else {
        for (i = 0; i < (int)(uint)leaflist->dflt_size; i = i + 1) {
          j = i;
          if ((leaflist->flags & 1) != 0) {
            while (j = j + 1, j < (int)(uint)leaflist->dflt_size) {
              if (leaflist->dflt[i] == leaflist->dflt[j]) {
                ly_vlog(module->ctx,LYE_INARG,LY_VLOG_LYS,leaflist,leaflist->dflt[i],"default");
                ly_vlog(module->ctx,LYE_SPEC,LY_VLOG_LYS,leaflist,"Duplicated default value \"%s\"."
                        ,leaflist->dflt[i]);
                return 1;
              }
            }
          }
          if ((((module->ctx->models).flags & 2U) == 0) &&
             (iVar1 = unres_schema_add_node
                                (module,unres,&leaflist->type,UNRES_TYPE_DFLT,
                                 (lys_node *)(leaflist->dflt + i)), iVar1 == -1)) {
            return 1;
          }
        }
        if (((leaflist->when == (lys_when *)0x0) ||
            (iVar1 = yang_check_ext_instance
                               (module,&leaflist->when->ext,(uint)leaflist->when->ext_size,
                                leaflist->when,unres), iVar1 == 0)) &&
           (iVar1 = yang_check_must(module,leaflist->must,(uint)leaflist->must_size,unres),
           iVar1 == 0)) {
          if ((((module->ctx->models).flags & 2U) != 0) ||
             ((leaflist->when == (lys_when *)0x0 && (leaflist->must_size == '\0')))) {
            return 0;
          }
          if ((options & 4U) == 0) {
            iVar1 = unres_schema_add_node(module,unres,leaflist,UNRES_XPATH,(lys_node *)0x0);
            if (iVar1 != -1) {
              return 0;
            }
          }
          else {
            iVar1 = lyxp_node_check_syntax((lys_node *)leaflist);
            if (iVar1 == 0) {
              return 0;
            }
          }
        }
      }
    }
    else {
      yang_type_free(module->ctx,&leaflist->type);
    }
  }
  else {
    yang_type_free(module->ctx,&leaflist->type);
  }
  return 1;
}



int yang_check_list(lys_module *module,lys_node_list *list,lys_node **child,int options,
                   unres_schema *unres)

{
  int iVar1;
  unres_schema *unres_local;
  int options_local;
  lys_node **child_local;
  lys_node_list *list_local;
  lys_module *module_local;
  lys_node *node;
  
  iVar1 = yang_check_typedef(module,(lys_node *)list,unres);
  if ((iVar1 == 0) &&
     (iVar1 = yang_check_iffeatures(module,(void *)0x0,list,LIST_KEYWORD,unres), iVar1 == 0)) {
    node = (lys_node *)list;
    if ((list->flags & 2) != 0) {
      list->flags = list->flags & 0x7f;
    }
    for (; (node != (lys_node *)0x0 && ((node->nodetype & 0x12800) == LYS_UNKNOWN));
        node = node->parent) {
    }
    if (((node == (lys_node *)0x0) && ((list->flags & 1) != 0)) &&
       (list->keys == (lys_node_leaf **)0x0)) {
      ly_vlog(module->ctx,LYE_MISSCHILDSTMT,LY_VLOG_LYS,list,&DAT_00225888,&DAT_0022498f);
    }
    else {
      iVar1 = yang_check_nodes(module,(lys_node *)list,*child,options,unres);
      if (iVar1 == 0) {
        *child = (lys_node *)0x0;
        if ((((list->keys == (lys_node_leaf **)0x0) ||
             (iVar1 = yang_read_key(module,list,unres), iVar1 == 0)) &&
            ((iVar1 = yang_read_unique(module,list,unres), iVar1 == 0 &&
             ((list->when == (lys_when *)0x0 ||
              (iVar1 = yang_check_ext_instance
                                 (module,&list->when->ext,(uint)list->when->ext_size,list->when,
                                  unres), iVar1 == 0)))))) &&
           (iVar1 = yang_check_must(module,list->must,(uint)list->must_size,unres), iVar1 == 0)) {
          if ((((module->ctx->models).flags & 2U) != 0) ||
             ((list->when == (lys_when *)0x0 && (list->must_size == '\0')))) {
            return 0;
          }
          if ((options & 4U) == 0) {
            iVar1 = unres_schema_add_node(module,unres,list,UNRES_XPATH,(lys_node *)0x0);
            if (iVar1 != -1) {
              return 0;
            }
          }
          else {
            iVar1 = lyxp_node_check_syntax((lys_node *)list);
            if (iVar1 == 0) {
              return 0;
            }
          }
        }
      }
      else {
        *child = (lys_node *)0x0;
      }
    }
  }
  return 1;
}



int yang_check_choice(lys_module *module,lys_node_choice *choice,lys_node **child,int options,
                     unres_schema *unres)

{
  lys_node *str;
  int iVar1;
  unres_schema *unres_local;
  int options_local;
  lys_node **child_local;
  lys_node_choice *choice_local;
  lys_module *module_local;
  char *value;
  
  iVar1 = yang_check_iffeatures(module,(void *)0x0,choice,CHOICE_KEYWORD,unres);
  if (iVar1 == 0) {
    iVar1 = yang_check_nodes(module,(lys_node *)choice,*child,options,unres);
    if (iVar1 == 0) {
      *child = (lys_node *)0x0;
      if (choice->dflt != (lys_node *)0x0) {
        str = choice->dflt;
        choice->dflt = (lys_node *)0x0;
        iVar1 = unres_schema_add_str(module,unres,choice,UNRES_CHOICE_DFLT,(char *)str);
        if (iVar1 == -1) {
          free(str);
          return 1;
        }
        free(str);
      }
      if ((choice->when == (lys_when *)0x0) ||
         (iVar1 = yang_check_ext_instance
                            (module,&choice->when->ext,(uint)choice->when->ext_size,choice->when,
                             unres), iVar1 == 0)) {
        if ((((module->ctx->models).flags & 2U) != 0) || (choice->when == (lys_when *)0x0)) {
          return 0;
        }
        if ((options & 4U) == 0) {
          iVar1 = unres_schema_add_node(module,unres,choice,UNRES_XPATH,(lys_node *)0x0);
          if (iVar1 != -1) {
            return 0;
          }
        }
        else {
          iVar1 = lyxp_node_check_syntax((lys_node *)choice);
          if (iVar1 == 0) {
            return 0;
          }
        }
      }
    }
    else {
      *child = (lys_node *)0x0;
      free(choice->dflt);
      choice->dflt = (lys_node *)0x0;
    }
  }
  else {
    free(choice->dflt);
    choice->dflt = (lys_node *)0x0;
  }
  return 1;
}



int yang_check_rpc_action
              (lys_module *module,lys_node_rpc_action *rpc,lys_node **child,int options,
              unres_schema *unres)

{
  long lVar1;
  int iVar2;
  char *pcVar3;
  unres_schema *unres_local;
  int options_local;
  lys_node **child_local;
  lys_node_rpc_action *rpc_local;
  lys_module *module_local;
  lys_node *node;
  
  if (rpc->nodetype == LYS_ACTION) {
    for (node = rpc->parent; node != (lys_node *)0x0; node = lys_parent(node)) {
      if (((node->nodetype & 0x4180) != LYS_UNKNOWN) ||
         ((node->nodetype == LYS_LIST &&
          (lVar1._0_2_ = node[1].flags, lVar1._2_1_ = node[1].ext_size,
          lVar1._3_1_ = node[1].iffeature_size, lVar1._4_1_ = node[1].padding[0],
          lVar1._5_1_ = node[1].padding[1], lVar1._6_1_ = node[1].padding[2],
          lVar1._7_1_ = node[1].padding[3], lVar1 == 0)))) {
        pcVar3 = strnodetype(node->nodetype);
        ly_vlog(module->ctx,LYE_INPAR,LY_VLOG_LYS,rpc->parent,pcVar3,"action");
        return 1;
      }
    }
  }
  iVar2 = yang_check_typedef(module,(lys_node *)rpc,unres);
  if ((iVar2 == 0) &&
     (iVar2 = yang_check_iffeatures(module,(void *)0x0,rpc,RPC_KEYWORD,unres), iVar2 == 0)) {
    iVar2 = yang_check_nodes(module,(lys_node *)rpc,*child,options | 2,unres);
    if (iVar2 == 0) {
      *child = (lys_node *)0x0;
      return 0;
    }
    *child = (lys_node *)0x0;
  }
  return 1;
}



int yang_check_notif(lys_module *module,lys_node_notif *notif,lys_node **child,int options,
                    unres_schema *unres)

{
  int iVar1;
  unres_schema *unres_local;
  int options_local;
  lys_node **child_local;
  lys_node_notif *notif_local;
  lys_module *module_local;
  
  iVar1 = yang_check_typedef(module,(lys_node *)notif,unres);
  if ((iVar1 == 0) &&
     (iVar1 = yang_check_iffeatures(module,(void *)0x0,notif,NOTIFICATION_KEYWORD,unres), iVar1 == 0
     )) {
    iVar1 = yang_check_nodes(module,(lys_node *)notif,*child,options | 2,unres);
    if (iVar1 == 0) {
      *child = (lys_node *)0x0;
      iVar1 = yang_check_must(module,notif->must,(uint)notif->must_size,unres);
      if (iVar1 == 0) {
        if ((((module->ctx->models).flags & 2U) != 0) || (notif->must_size == '\0')) {
          return 0;
        }
        if ((options & 4U) == 0) {
          iVar1 = unres_schema_add_node(module,unres,notif,UNRES_XPATH,(lys_node *)0x0);
          if (iVar1 != -1) {
            return 0;
          }
        }
        else {
          iVar1 = lyxp_node_check_syntax((lys_node *)notif);
          if (iVar1 == 0) {
            return 0;
          }
        }
      }
    }
    else {
      *child = (lys_node *)0x0;
    }
  }
  return 1;
}



int yang_check_augment(lys_module *module,lys_node_augment *augment,int options,unres_schema *unres)

{
  lys_node *nodes;
  int iVar1;
  unres_schema *unres_local;
  int options_local;
  lys_node_augment *augment_local;
  lys_module *module_local;
  lys_node *child;
  
  nodes = augment->child;
  augment->child = (lys_node *)0x0;
  iVar1 = yang_check_iffeatures(module,(void *)0x0,augment,AUGMENT_KEYWORD,unres);
  if (iVar1 == 0) {
    iVar1 = yang_check_nodes(module,(lys_node *)augment,nodes,options,unres);
    if (((iVar1 == 0) &&
        (iVar1 = yang_check_ext_instance(module,&augment->ext,(uint)augment->ext_size,augment,unres)
        , iVar1 == 0)) &&
       ((augment->when == (lys_when *)0x0 ||
        (iVar1 = yang_check_ext_instance
                           (module,&augment->when->ext,(uint)augment->when->ext_size,augment->when,
                            unres), iVar1 == 0)))) {
      if ((((module->ctx->models).flags & 2U) != 0) || (augment->when == (lys_when *)0x0)) {
        return 0;
      }
      if ((options & 4U) == 0) {
        iVar1 = unres_schema_add_node(module,unres,augment,UNRES_XPATH,(lys_node *)0x0);
        if (iVar1 != -1) {
          return 0;
        }
      }
      else {
        iVar1 = lyxp_node_check_syntax((lys_node *)augment);
        if (iVar1 == 0) {
          return 0;
        }
      }
    }
  }
  else {
    yang_free_nodes(module->ctx,nodes);
  }
  return 1;
}



int yang_check_uses(lys_module *module,lys_node_uses *uses,int options,unres_schema *unres)

{
  byte bVar1;
  int iVar2;
  unres_schema *unres_local;
  int options_local;
  lys_node_uses *uses_local;
  lys_module *module_local;
  uint i;
  uint size;
  
  bVar1 = uses->augment_size;
  uses->augment_size = '\0';
  iVar2 = yang_check_iffeatures(module,(void *)0x0,uses,USES_KEYWORD,unres);
  if (iVar2 == 0) {
    for (i = 0; i < uses->refine_size; i = i + 1) {
      iVar2 = yang_check_iffeatures(module,uses->refine + i,uses,REFINE_KEYWORD,unres);
      if (((iVar2 != 0) ||
          (iVar2 = yang_check_must(module,uses->refine[i].must,(uint)uses->refine[i].must_size,unres
                                  ), iVar2 != 0)) ||
         (iVar2 = yang_check_ext_instance
                            (module,&uses->refine[i].ext,(uint)uses->refine[i].ext_size,
                             uses->refine + i,unres), iVar2 != 0)) goto LAB_0019a66e;
    }
    for (i = 0; i < bVar1; i = i + 1) {
      uses->augment_size = uses->augment_size + '\x01';
      iVar2 = yang_check_augment(module,uses->augment + i,options,unres);
      if (iVar2 != 0) goto LAB_0019a66e;
    }
    iVar2 = unres_schema_add_node(module,unres,uses,UNRES_USES,(lys_node *)0x0);
    if ((iVar2 != -1) &&
       ((uses->when == (lys_when *)0x0 ||
        (iVar2 = yang_check_ext_instance
                           (module,&uses->when->ext,(uint)uses->when->ext_size,uses->when,unres),
        iVar2 == 0)))) {
      if ((((module->ctx->models).flags & 2U) != 0) || (uses->when == (lys_when *)0x0)) {
        return 0;
      }
      if ((options & 4U) == 0) {
        iVar2 = unres_schema_add_node(module,unres,uses,UNRES_XPATH,(lys_node *)0x0);
        if (iVar2 != -1) {
          return 0;
        }
      }
      else {
        iVar2 = lyxp_node_check_syntax((lys_node *)uses);
        if (iVar2 == 0) {
          return 0;
        }
      }
    }
  }
LAB_0019a66e:
  for (i = (uint)uses->augment_size; i < bVar1; i = i + 1) {
    yang_free_augment(module->ctx,uses->augment + i);
  }
  return 1;
}



int yang_check_anydata(lys_module *module,lys_node_anydata *anydata,lys_node **child,int options,
                      unres_schema *unres)

{
  int iVar1;
  unres_schema *unres_local;
  int options_local;
  lys_node **child_local;
  lys_node_anydata *anydata_local;
  lys_module *module_local;
  
  iVar1 = yang_check_iffeatures(module,(void *)0x0,anydata,ANYDATA_KEYWORD,unres);
  if (iVar1 == 0) {
    iVar1 = yang_check_nodes(module,(lys_node *)anydata,*child,options,unres);
    if (iVar1 == 0) {
      *child = (lys_node *)0x0;
      if (((anydata->when == (lys_when *)0x0) ||
          (iVar1 = yang_check_ext_instance
                             (module,&anydata->when->ext,(uint)anydata->when->ext_size,anydata->when
                              ,unres), iVar1 == 0)) &&
         (iVar1 = yang_check_must(module,anydata->must,(uint)anydata->must_size,unres), iVar1 == 0))
      {
        if ((((module->ctx->models).flags & 2U) != 0) ||
           ((anydata->when == (lys_when *)0x0 && (anydata->must_size == '\0')))) {
          return 0;
        }
        if ((options & 4U) == 0) {
          iVar1 = unres_schema_add_node(module,unres,anydata,UNRES_XPATH,(lys_node *)0x0);
          if (iVar1 != -1) {
            return 0;
          }
        }
        else {
          iVar1 = lyxp_node_check_syntax((lys_node *)anydata);
          if (iVar1 == 0) {
            return 0;
          }
        }
      }
    }
    else {
      *child = (lys_node *)0x0;
    }
  }
  return 1;
}



int yang_check_nodes(lys_module *module,lys_node *parent,lys_node *nodes,int options,
                    unres_schema *unres)

{
  LYS_NODE LVar1;
  long lVar2;
  int iVar3;
  lys_module *module_00;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  int options_local;
  lys_node *nodes_local;
  lys_node *parent_local;
  lys_module *module_local;
  int i;
  lys_node *child;
  lys_node *node;
  lys_node *sibling;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  node = nodes;
  do {
    if (node == (lys_node *)0x0) {
      iVar3 = 0;
LAB_0019b059:
      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return iVar3;
    }
    sibling = node->next;
    child = node->child;
    node->next = (lys_node *)0x0;
    node->child = (lys_node *)0x0;
    node->parent = (lys_node *)0x0;
    node->prev = node;
    module_00 = module;
    if ((module->field_0x40 & 1) != 0) {
      module_00 = (lys_module *)module->data;
    }
    iVar3 = lys_node_addchild(parent,module_00,node,0);
    if ((iVar3 != 0) || (iVar3 = check_status_flag(node,parent), iVar3 != 0)) {
      lys_node_unlink(node);
      yang_free_nodes(module->ctx,node);
      goto LAB_0019b028;
    }
    if (parent != node->parent) {
      if (parent != node->parent->parent) {
                    // WARNING: Subroutine does not return
        __assert_fail("node->parent->parent == parent",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
                      ,0x109d,"yang_check_nodes");
      }
      if ((node->parent->nodetype != LYS_CASE) || ((node->parent->flags & 0x40) == 0)) {
                    // WARNING: Subroutine does not return
        __assert_fail("(node->parent->nodetype == LYS_CASE) && (node->parent->flags & LYS_IMPLICIT)"
                      ,
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
                      ,0x109e,"yang_check_nodes");
      }
      store_config_flag(node->parent,options);
    }
    store_config_flag(node,options);
    iVar3 = yang_check_ext_instance(module,&node->ext,(uint)node->ext_size,node,unres);
    if (iVar3 != 0) goto LAB_0019b028;
    for (i = 0; i < (int)(uint)node->ext_size; i = i + 1) {
      if (((node->ext[i]->flags & 8) != 0) &&
         (node->flags = node->flags | 0x2000, (node->ext[i]->flags & 0x10) != 0)) {
        node->flags = node->flags | 0x4000;
        break;
      }
    }
    LVar1 = node->nodetype;
    if (LVar1 == LYS_ANYDATA) {
switchD_0019aba2_caseD_20:
      iVar3 = yang_check_anydata(module,(lys_node_anydata *)node,&child,options,unres);
joined_r0x0019ae60:
      if (iVar3 == 0) goto LAB_0019affb;
      goto LAB_0019b028;
    }
    if (LYS_ANYDATA < LVar1) goto switchD_0019aba2_caseD_3;
    if (LVar1 == LYS_ACTION) {
LAB_0019ae40:
      iVar3 = yang_check_rpc_action(module,(lys_node_rpc_action *)node,&child,options,unres);
      goto joined_r0x0019ae60;
    }
    if (LYS_ACTION < LVar1) goto switchD_0019aba2_caseD_3;
    if (LVar1 == LYS_USES) {
      iVar3 = yang_check_uses(module,(lys_node_uses *)node,options,unres);
      if (iVar3 == 0) goto LAB_0019affb;
      child = (lys_node *)0x0;
      goto LAB_0019b028;
    }
    if (LYS_USES < LVar1) goto switchD_0019aba2_caseD_3;
    if (LVar1 == LYS_GROUPING) {
      iVar3 = yang_check_typedef(module,node,unres);
      if ((iVar3 == 0) &&
         (iVar3 = yang_check_iffeatures(module,(void *)0x0,node,GROUPING_KEYWORD,unres), iVar3 == 0)
         ) {
        iVar3 = yang_check_nodes(module,node,child,options | 4,unres);
        if (iVar3 == 0) goto LAB_0019affb;
        child = (lys_node *)0x0;
      }
      goto LAB_0019b028;
    }
    if (LYS_GROUPING < LVar1) goto switchD_0019aba2_caseD_3;
    if (LVar1 == LYS_OUTPUT) {
LAB_0019ae6b:
      iVar3 = yang_check_typedef(module,node,unres);
      if (iVar3 == 0) {
        iVar3 = yang_check_nodes(module,node,child,options,unres);
        if (iVar3 == 0) {
          if (node->padding[1] == '\0') goto LAB_0019affb;
          iVar3 = yang_check_must(module,(lys_restr *)node[1].name,(uint)node->padding[1],unres);
          if (iVar3 == 0) {
            if ((((module->ctx->models).flags & 2U) == 0) && ((options & 4U) != 0)) {
              iVar3 = lyxp_node_check_syntax(node);
              goto joined_r0x0019af1d;
            }
            iVar3 = unres_schema_add_node(module,unres,node,UNRES_XPATH,(lys_node *)0x0);
joined_r0x0019af46:
            if (iVar3 != -1) goto LAB_0019affb;
          }
        }
        else {
          child = (lys_node *)0x0;
        }
      }
      goto LAB_0019b028;
    }
    if (LYS_OUTPUT < LVar1) goto switchD_0019aba2_caseD_3;
    if (LVar1 == LYS_INPUT) goto LAB_0019ae6b;
    if (LYS_INPUT < LVar1) goto switchD_0019aba2_caseD_3;
    if (LVar1 == LYS_RPC) goto LAB_0019ae40;
    if (LYS_RPC < LVar1) goto switchD_0019aba2_caseD_3;
    if (LVar1 == LYS_NOTIF) {
      iVar3 = yang_check_notif(module,(lys_node_notif *)node,&child,options,unres);
      goto joined_r0x0019ae60;
    }
    if (LYS_NOTIF < LVar1) goto switchD_0019aba2_caseD_3;
    if (LYS_ANYXML < LVar1) {
      if (LVar1 != LYS_CASE) goto switchD_0019aba2_caseD_3;
      iVar3 = yang_check_iffeatures(module,(void *)0x0,node,CASE_KEYWORD,unres);
      if (iVar3 == 0) {
        iVar3 = yang_check_nodes(module,node,child,options,unres);
        if (iVar3 == 0) {
          lVar2._0_1_ = node->hash[0];
          lVar2._1_1_ = node->hash[1];
          lVar2._2_1_ = node->hash[2];
          lVar2._3_1_ = node->hash[3];
          lVar2._4_4_ = *(undefined4 *)&node->field_0x6c;
          if (lVar2 == 0) goto LAB_0019affb;
          iVar3 = yang_check_ext_instance
                            (module,(lys_ext_instance ***)(*(long *)node->hash + 0x18),
                             (uint)*(byte *)(*(long *)node->hash + 0x20),*(void **)node->hash,unres)
          ;
          if (iVar3 != 0) goto LAB_0019b028;
          if ((((module->ctx->models).flags & 2U) == 0) && ((options & 4U) != 0)) {
            iVar3 = lyxp_node_check_syntax(node);
            goto joined_r0x0019af1d;
          }
          iVar3 = unres_schema_add_node(module,unres,node,UNRES_XPATH,(lys_node *)0x0);
          goto joined_r0x0019af46;
        }
        child = (lys_node *)0x0;
      }
      goto LAB_0019b028;
    }
    if ((LVar1 == LYS_UNKNOWN) || (false)) {
switchD_0019aba2_caseD_3:
      ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
             ,0x1121);
      goto LAB_0019b028;
    }
    switch(LVar1) {
    case LYS_CONTAINER:
      iVar3 = yang_check_container(module,(lys_node_container *)node,&child,options,unres);
      break;
    case LYS_CHOICE:
      iVar3 = yang_check_choice(module,(lys_node_choice *)node,&child,options,unres);
      break;
    default:
      goto switchD_0019aba2_caseD_3;
    case LYS_LEAF:
      iVar3 = yang_check_leaf(module,(lys_node_leaf *)node,options,unres);
      if (iVar3 != 0) {
        child = (lys_node *)0x0;
        goto LAB_0019b028;
      }
      goto LAB_0019affb;
    case LYS_LEAFLIST:
      iVar3 = yang_check_leaflist(module,(lys_node_leaflist *)node,options,unres);
      if (iVar3 != 0) {
        child = (lys_node *)0x0;
        goto LAB_0019b028;
      }
      goto LAB_0019affb;
    case LYS_LIST:
      iVar3 = yang_check_list(module,(lys_node_list *)node,&child,options,unres);
      break;
    case LYS_ANYXML:
      goto switchD_0019aba2_caseD_20;
    }
joined_r0x0019af1d:
    if (iVar3 != 0) {
LAB_0019b028:
      yang_free_nodes(module->ctx,sibling);
      yang_free_nodes(module->ctx,child);
      iVar3 = 1;
      goto LAB_0019b059;
    }
LAB_0019affb:
    node = sibling;
  } while( true );
}



int yang_check_deviate(lys_module *module,unres_schema *unres,lys_deviate *deviate,
                      lys_node *dev_target,ly_set *dflt_check)

{
  lys_tpdf *parent;
  int iVar1;
  ly_set *dflt_check_local;
  lys_node *dev_target_local;
  lys_deviate *deviate_local;
  unres_schema *unres_local;
  lys_module *module_local;
  int i;
  int j;
  lys_type *type;
  lys_node_leaflist *llist;
  lys_tpdf *tmp_parent;
  
  iVar1 = yang_check_ext_instance(module,&deviate->ext,(uint)deviate->ext_size,deviate,unres);
  if (((iVar1 == 0) &&
      ((deviate->must_size == '\0' ||
       (iVar1 = yang_check_deviate_must(module,unres,deviate,dev_target), iVar1 == 0)))) &&
     ((deviate->unique == (lys_unique *)0x0 ||
      (iVar1 = yang_check_deviate_unique(module,deviate,dev_target), iVar1 == 0)))) {
    if (deviate->dflt_size != '\0') {
      iVar1 = yang_read_deviate_default(module,deviate,dev_target,dflt_check);
      if (iVar1 != 0) goto LAB_0019b484;
      if ((dev_target->nodetype == LYS_LEAFLIST) && (deviate->mod == LY_DEVIATE_DEL)) {
        i = 0;
        for (j = 0; j < (int)(uint)dev_target->padding[2]; j = j + 1) {
          *(undefined8 *)((dev_target[1].prev)->padding + (long)i * 8 + -0x1c) =
               *(undefined8 *)((dev_target[1].prev)->padding + (long)j * 8 + -0x1c);
          if (*(long *)((dev_target[1].prev)->padding + (long)i * 8 + -0x1c) != 0) {
            i = i + 1;
          }
        }
        dev_target->padding[2] = (char)i + '\x01';
      }
    }
    if ((((deviate->max_set == '\0') ||
         (iVar1 = yang_read_deviate_minmax(deviate,dev_target,deviate->max,1), iVar1 == 0)) &&
        ((deviate->min_set == '\0' ||
         (iVar1 = yang_read_deviate_minmax(deviate,dev_target,deviate->min,0), iVar1 == 0)))) &&
       ((deviate->units == (char *)0x0 ||
        (iVar1 = yang_read_deviate_units(module->ctx,deviate,dev_target), iVar1 == 0)))) {
      if ((deviate->flags & 3) != 0) {
        dev_target->flags = dev_target->flags & 0xfffc;
        dev_target->flags = deviate->flags & 3 | dev_target->flags;
      }
      if (((deviate->flags & 0xc0) == 0) ||
         (iVar1 = yang_check_deviate_mandatory(deviate,dev_target), iVar1 == 0)) {
        if (deviate->type == (lys_type *)0x0) {
          return 0;
        }
        if ((dev_target->nodetype == LYS_LEAF) || (dev_target->nodetype == LYS_LEAFLIST)) {
          type = (lys_type *)&dev_target[1].ref;
          parent = (lys_tpdf *)dev_target[1].iffeature;
          lys_type_free(module->ctx,type,(_func_void_lys_node_ptr_void_ptr *)0x0);
          memcpy(type,deviate->type,0x40);
          free(deviate->type);
          deviate->type = type;
          deviate->type->parent = parent;
          iVar1 = yang_fill_type(module,type,(yang_type *)dev_target[1].ext,parent,unres);
          if ((iVar1 == 0) &&
             (iVar1 = unres_schema_add_node(module,unres,deviate->type,UNRES_TYPE_DER,dev_target),
             iVar1 != -1)) {
            return 0;
          }
        }
        else {
          ly_vlog(module->ctx,LYE_INSTMT,LY_VLOG_NONE,(void *)0x0,&DAT_00224b85);
          ly_vlog(module->ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                  "Target node does not allow \"type\" property.");
        }
      }
    }
  }
LAB_0019b484:
  if (deviate->type != (lys_type *)0x0) {
    yang_type_free(module->ctx,deviate->type);
    deviate->type = (lys_type *)0x0;
  }
  return 1;
}



int yang_check_deviation(lys_module *module,unres_schema *unres,lys_deviation *dev)

{
  long lVar1;
  lys_module *plVar2;
  int iVar3;
  LYS_NODE LVar4;
  lys_module *plVar5;
  char *pcVar6;
  lys_node *plVar7;
  long in_FS_OFFSET;
  lys_deviation *dev_local;
  unres_schema *unres_local;
  lys_module *module_local;
  int rc;
  uint i;
  uint u;
  ly_set *set;
  lys_node *parent;
  ly_set *dflt_check;
  char *value;
  char *target_name;
  lys_node *dev_target;
  lys_node_inout *inout;
  lys_module *mod;
  lys_node_leaflist *llist;
  lys_node_leaf *leaf;
  unres_schema tmp_unres;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  dev_target = (lys_node *)0x0;
  dflt_check = ly_set_new();
  iVar3 = resolve_schema_nodeid(dev->target_name,(lys_node *)0x0,module,&set,0,1);
  if (iVar3 == -1) {
    ly_vlog(module->ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,dev->target_name,"deviation");
    ly_set_free(set);
    i = 0;
LAB_0019bedb:
    for (; i < dev->deviate_size; i = i + 1) {
      if (dev->deviate[i].type != (lys_type *)0x0) {
        yang_type_free(module->ctx,dev->deviate[i].type);
        free(dev->deviate[i].type);
        dev->deviate[i].type = (lys_type *)0x0;
      }
    }
  }
  else {
    dev_target = *(set->set).s;
    ly_set_free(set);
    plVar2 = dev_target->module;
    plVar5 = lys_main_module(module);
    if (plVar2 == plVar5) {
      ly_vlog(module->ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,dev->target_name,"deviation");
      ly_vlog(module->ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Deviating own module is not allowed.");
      i = 0;
      goto LAB_0019bedb;
    }
    if (dflt_check == (ly_set *)0x0) {
      ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_check_deviation")
      ;
      i = 0;
      goto LAB_0019bedb;
    }
    if (dev->deviate->mod != LY_DEVIATE_NO) {
      memset(&tmp_unres,0,0x28);
      plVar7 = lys_node_dup(dev_target->module,(lys_node *)0x0,dev_target,&tmp_unres,1);
      dev->orig_node = plVar7;
      if (tmp_unres.count != 0) {
        ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
               ,0x11e7);
        i = 0;
        goto LAB_0019bedb;
      }
LAB_0019ba19:
      iVar3 = yang_check_ext_instance(module,&dev->ext,(uint)dev->ext_size,dev,unres);
      if (iVar3 == 0) {
        for (i = 0; i < dev->deviate_size; i = i + 1) {
          iVar3 = yang_check_deviate(module,unres,dev->deviate + i,dev_target,dflt_check);
          if (iVar3 != 0) {
            yang_free_deviate(module->ctx,dev,i + 1);
            dev->deviate_size = (char)i + '\x01';
            goto LAB_0019bedb;
          }
        }
        for (u = 0; u < dflt_check->number; u = u + 1) {
          value = (char *)0x0;
          rc = 0;
          if ((dflt_check->set).s[u]->nodetype == LYS_LEAF) {
            leaf = (lys_node_leaf *)(dflt_check->set).s[u];
            target_name = leaf->name;
            value = leaf->dflt;
            rc = unres_schema_add_node
                           (module,unres,&leaf->type,UNRES_TYPE_DFLT,(lys_node *)&leaf->dflt);
          }
          else {
            llist = (lys_node_leaflist *)(dflt_check->set).s[u];
            target_name = llist->name;
            for (i = 0; i < llist->dflt_size; i = i + 1) {
              rc = unres_schema_add_node
                             (module,unres,&llist->type,UNRES_TYPE_DFLT,
                              (lys_node *)(llist->dflt + i));
              if (rc == -1) {
                value = llist->dflt[i];
                break;
              }
            }
          }
          if (rc == -1) {
            ly_vlog(module->ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,value,"default");
            ly_vlog(module->ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                    "The default value \"%s\" of the deviated node \"%s\"no longer matches its type."
                    ,target_name);
            goto LAB_0019bef8;
          }
        }
        ly_set_free(dflt_check);
        dflt_check = (ly_set *)0x0;
        for (parent = dev_target; parent != (lys_node *)0x0; parent = lys_parent(parent)) {
          mod = lys_node_module(parent);
          if (module != mod) {
            mod->field_0x40 = mod->field_0x40 & 0xcf | 0x10;
            parent->module->field_0x40 = parent->module->field_0x40 & 0xcf | 0x10;
            if ((mod->field_0x40 & 0x80) == 0) {
              mod->field_0x40 = mod->field_0x40 | 0x80;
              iVar3 = unres_schema_add_node
                                (mod,unres,(void *)0x0,UNRES_MOD_IMPLEMENT,(lys_node *)0x0);
              if (iVar3 == -1) goto LAB_0019bef8;
            }
          }
        }
        iVar3 = 0;
        goto LAB_0019bf09;
      }
      i = 0;
      goto LAB_0019bedb;
    }
    if (((dev_target->nodetype == LYS_LEAF) && (dev_target->parent != (lys_node *)0x0)) &&
       (dev_target->parent->nodetype == LYS_LIST)) {
      for (i = 0; i < dev_target->parent->padding[2]; i = i + 1) {
        if (dev_target == *(lys_node **)(*(long *)&dev_target->parent[1].flags + (ulong)i * 8)) {
          ly_vlog(module->ctx,LYE_INARG,LY_VLOG_NONE,(void *)0x0,"not-supported","deviation");
          ly_vlog(module->ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                  "\"not-supported\" deviation cannot remove a list key.");
          i = 0;
          goto LAB_0019bedb;
        }
      }
    }
    parent = dev_target->parent;
    lys_node_unlink(dev_target);
    if (parent == (lys_node *)0x0) {
LAB_0019b976:
      dev->orig_node = dev_target;
      goto LAB_0019ba19;
    }
    if ((parent->nodetype & 0x3000) != LYS_UNKNOWN) {
      dev_target->parent = parent;
      goto LAB_0019b976;
    }
    if ((parent->nodetype & 0x4100) == LYS_UNKNOWN) goto LAB_0019b976;
    inout = (lys_node_inout *)calloc(1,0x78);
    if (inout != (lys_node_inout *)0x0) {
      inout->nodetype = dev_target->nodetype;
      if (inout->nodetype == LYS_INPUT) {
        pcVar6 = "input";
      }
      else {
        pcVar6 = "output";
      }
      pcVar6 = lydict_insert(module->ctx,pcVar6,0);
      inout->name = pcVar6;
      inout->module = dev_target->module;
      inout->flags = 0x40;
      if ((parent->child == (lys_node *)0x0) || (parent->child->next != (lys_node *)0x0)) {
LAB_0019b90f:
                    // WARNING: Subroutine does not return
        __assert_fail("parent->child && !parent->child->next && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUTPUT : LYS_INPUT))"
                      ,
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
                      ,0x11d8,"yang_check_deviation");
      }
      if (inout->nodetype == LYS_INPUT) {
        LVar4 = LYS_OUTPUT;
      }
      else {
        LVar4 = LYS_INPUT;
      }
      if (LVar4 != parent->child->nodetype) goto LAB_0019b90f;
      parent->child->next = (lys_node *)inout;
      inout->prev = parent->child;
      parent->child->prev = (lys_node *)inout;
      inout->parent = parent;
      goto LAB_0019b976;
    }
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_check_deviation");
  }
LAB_0019bef8:
  ly_set_free(dflt_check);
  iVar3 = 1;
LAB_0019bf09:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int yang_check_sub_module(lys_module *module,unres_schema *unres,lys_node *node)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  bool bVar4;
  int iVar5;
  lys_node *node_local;
  unres_schema *unres_local;
  lys_module *module_local;
  uint i;
  uint erase_identities;
  uint erase_nodes;
  uint dev_size;
  uint aug_size;
  
  bVar3 = true;
  bVar4 = true;
  bVar1 = module->augment_size;
  module->augment_size = '\0';
  bVar2 = module->deviation_size;
  module->deviation_size = '\0';
  iVar5 = yang_check_typedef(module,(lys_node *)0x0,unres);
  if ((iVar5 == 0) &&
     (iVar5 = yang_check_ext_instance(module,&module->ext,(uint)module->ext_size,module,unres),
     iVar5 == 0)) {
    for (i = 0; i < module->rev_size; i = i + 1) {
      iVar5 = yang_check_ext_instance
                        (module,&module->rev[i].ext,(uint)module->rev[i].ext_size,module->rev + i,
                         unres);
      if (iVar5 != 0) goto LAB_0019c3a8;
    }
    for (i = 0; i < module->extensions_size; i = i + 1) {
      iVar5 = yang_check_ext_instance
                        (module,&module->extensions[i].ext,(uint)module->extensions[i].ext_size,
                         module->extensions + i,unres);
      if (iVar5 != 0) goto LAB_0019c3a8;
    }
    for (i = 0; i < module->features_size; i = i + 1) {
      iVar5 = yang_check_iffeatures(module,(void *)0x0,module->features + i,FEATURE_KEYWORD,unres);
      if (((iVar5 != 0) ||
          (iVar5 = yang_check_ext_instance
                             (module,&module->features[i].ext,(uint)module->features[i].ext_size,
                              module->features + i,unres), iVar5 != 0)) ||
         ((module->features[i].iffeature_size != '\0' &&
          (iVar5 = unres_schema_add_node
                             (module,unres,module->features + i,UNRES_FEATURE,(lys_node *)0x0),
          iVar5 == -1)))) goto LAB_0019c3a8;
    }
    bVar3 = false;
    iVar5 = yang_check_identities(module,unres);
    if (iVar5 == 0) {
      bVar4 = false;
      iVar5 = yang_check_nodes(module,(lys_node *)0x0,node,0,unres);
      if (iVar5 == 0) {
        for (i = 0; i < bVar2; i = i + 1) {
          module->deviation_size = module->deviation_size + '\x01';
          iVar5 = yang_check_deviation(module,unres,module->deviation + i);
          if (iVar5 != 0) goto LAB_0019c3a8;
        }
        i = 0;
        while( true ) {
          if (bVar1 <= i) {
            return 0;
          }
          module->augment_size = module->augment_size + '\x01';
          iVar5 = yang_check_augment(module,module->augment + i,0,unres);
          if ((iVar5 != 0) ||
             (iVar5 = unres_schema_add_node
                                (module,unres,module->augment + i,UNRES_AUGMENT,(lys_node *)0x0),
             iVar5 == -1)) break;
          i = i + 1;
        }
      }
    }
  }
LAB_0019c3a8:
  if (bVar3) {
    yang_free_ident_base(module->ident,0,(uint)module->ident_size);
  }
  if (bVar4) {
    yang_free_nodes(module->ctx,node);
  }
  for (i = (uint)module->augment_size; i < bVar1; i = i + 1) {
    yang_free_augment(module->ctx,module->augment + i);
  }
  for (i = (uint)module->deviation_size; i < bVar2; i = i + 1) {
    yang_free_deviate(module->ctx,module->deviation + i,0);
    free(module->deviation[i].deviate);
    lydict_remove(module->ctx,module->deviation[i].target_name);
    lydict_remove(module->ctx,module->deviation[i].dsc);
    lydict_remove(module->ctx,module->deviation[i].ref);
  }
  return 1;
}



int yang_read_extcomplex_str
              (lys_module *module,lys_ext_instance_complex *ext,char *arg_name,char *parent_name,
              char **value,int parent_stmt,LY_STMT stmt)

{
  int iVar1;
  char ***pppcVar2;
  char *pcVar3;
  char **ppcVar4;
  long in_FS_OFFSET;
  int parent_stmt_local;
  char **value_local;
  char *parent_name_local;
  char *arg_name_local;
  lys_ext_instance_complex *ext_local;
  lys_module *module_local;
  int c;
  lyext_substmt *info;
  char **str;
  char ***p;
  void *reallocated;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  p = (char ***)0x0;
  c = 0;
  if ((stmt == LY_STMT_PREFIX) && (parent_stmt == 3)) {
    pppcVar2 = (char ***)lys_ext_complex_get_substmt(LY_STMT_BELONGSTO,ext,&info);
    if (info->cardinality < LY_STMT_CARD_SOME) {
      str = (char **)(pppcVar2 + 1);
    }
    else {
      c = 0;
      while ((*pppcVar2)[(long)c + 1] != (char *)0x0) {
        c = c + 1;
      }
      str = pppcVar2[1];
      p = pppcVar2;
    }
    ppcVar4 = str + c;
    pcVar3 = lydict_insert_zc(module->ctx,*value);
    *ppcVar4 = pcVar3;
    *value = (char *)0x0;
LAB_0019cb52:
    iVar1 = 0;
  }
  else {
    str = (char **)lys_ext_complex_get_substmt(stmt,ext,&info);
    if ((char ***)str == (char ***)0x0) {
      ly_vlog(module->ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,arg_name,parent_name);
    }
    else {
      if ((LY_STMT_CARD_MAND < info->cardinality) || ((char **)*str == (char **)0x0)) {
        if (LY_STMT_CARD_MAND < info->cardinality) {
          p = (char ***)str;
          if ((char **)*str == (char **)0x0) {
            ppcVar4 = (char **)calloc(2,8);
            *p = ppcVar4;
            if (*p == (char **)0x0) {
              ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "yang_read_extcomplex_str");
              goto LAB_0019cb59;
            }
            if (stmt == LY_STMT_BELONGSTO) {
              pppcVar2 = p + 1;
              ppcVar4 = (char **)calloc(2,8);
              *pppcVar2 = ppcVar4;
              if (p[1] == (char **)0x0) {
                ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                       "yang_read_extcomplex_str");
                goto LAB_0019cb59;
              }
            }
            else if (stmt == LY_STMT_ARGUMENT) {
              pppcVar2 = p + 1;
              ppcVar4 = (char **)calloc(2,1);
              *pppcVar2 = ppcVar4;
              if (p[1] == (char **)0x0) {
                ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                       "yang_read_extcomplex_str");
                goto LAB_0019cb59;
              }
              *(undefined *)p[1] = 2;
            }
          }
          else {
            for (c = 0; *(char **)((long)*str + (long)c * 8) != (char *)0x0; c = c + 1) {
            }
          }
          str = *p;
        }
        ppcVar4 = str + c;
        pcVar3 = lydict_insert_zc(module->ctx,*value);
        *ppcVar4 = pcVar3;
        *value = (char *)0x0;
        if (c != 0) {
          reallocated = realloc(*p,(long)(c + 2) * 8);
          if ((char **)reallocated == (char **)0x0) {
            ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "yang_read_extcomplex_str");
            lydict_remove(module->ctx,(*p)[c]);
            (*p)[c] = (char *)0x0;
            iVar1 = 1;
            goto LAB_0019cb78;
          }
          *p = (char **)reallocated;
          (*p)[(long)c + 1] = (char *)0x0;
          if (stmt == LY_STMT_BELONGSTO) {
            reallocated = realloc(p[1],(long)(c + 2) * 8);
            if ((char **)reallocated == (char **)0x0) {
              ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "yang_read_extcomplex_str");
              lydict_remove(module->ctx,p[1][c]);
              p[1][c] = (char *)0x0;
              iVar1 = 1;
              goto LAB_0019cb78;
            }
            p[1] = (char **)reallocated;
            p[1][(long)c + 1] = (char *)0x0;
          }
          else if (stmt == LY_STMT_ARGUMENT) {
            reallocated = realloc(p[1],(long)(c + 2));
            if ((char **)reallocated == (char **)0x0) {
              ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "yang_read_extcomplex_str");
              *(undefined *)((long)c + (long)p[1]) = 0;
              iVar1 = 1;
              goto LAB_0019cb78;
            }
            p[1] = (char **)reallocated;
            *(undefined *)((long)p[1] + (long)c + 1) = 0;
          }
        }
        goto LAB_0019cb52;
      }
      ly_vlog(module->ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,arg_name,parent_name);
    }
LAB_0019cb59:
    free(*value);
    *value = (char *)0x0;
    iVar1 = 1;
  }
LAB_0019cb78:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int yang_fill_ext_substm_index(lys_ext_instance_complex *ext,LY_STMT stmt,yytokentype keyword)

{
  int iVar1;
  long in_FS_OFFSET;
  yytokentype keyword_local;
  LY_STMT stmt_local;
  lys_ext_instance_complex *ext_local;
  int c;
  int decrement;
  lyext_substmt *info;
  char ***p;
  char **str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  decrement = 0;
  p = (char ***)0x0;
  if ((keyword == BELONGS_TO_KEYWORD) || (stmt == LY_STMT_BELONGSTO)) {
    stmt_local = LY_STMT_BELONGSTO;
    decrement = -1;
  }
  else if ((keyword == ARGUMENT_KEYWORD) || (stmt_local = stmt, stmt == LY_STMT_ARGUMENT)) {
    stmt_local = LY_STMT_ARGUMENT;
    decrement = -1;
  }
  str = (char **)lys_ext_complex_get_substmt(stmt_local,ext,&info);
  if ((((char ***)str == (char ***)0x0) || (info->cardinality < LY_STMT_CARD_SOME)) ||
     ((char **)*str == (char **)0x0)) {
    iVar1 = 0;
  }
  else {
    for (c = 0; *(char **)((long)*str + (long)c * 8) != (char *)0x0; c = c + 1) {
    }
    iVar1 = decrement + c;
    p = (char ***)str;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



void ** yang_getplace_for_extcomplex_struct
                  (lys_ext_instance_complex *ext,int *index,char *parent_name,char *node_name,
                  LY_STMT stmt)

{
  void ***pppvVar1;
  void **ppvVar2;
  long in_FS_OFFSET;
  LY_STMT stmt_local;
  char *node_name_local;
  char *parent_name_local;
  int *index_local;
  lys_ext_instance_complex *ext_local;
  int c;
  lyext_substmt *info;
  void **data;
  void ***p;
  ly_ctx *ctx;
  void *reallocated;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = ext->module->ctx;
  p = (void ***)0x0;
  pppvVar1 = (void ***)lys_ext_complex_get_substmt(stmt,ext,&info);
  data = pppvVar1;
  if (pppvVar1 == (void ***)0x0) {
    ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,node_name,parent_name);
    ppvVar2 = (void **)0x0;
  }
  else if ((info->cardinality < LY_STMT_CARD_SOME) && (*pppvVar1 != (void **)0x0)) {
    ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node_name,parent_name);
    ppvVar2 = (void **)0x0;
  }
  else {
    c = 0;
    if (LY_STMT_CARD_MAND < info->cardinality) {
      data = *pppvVar1;
      p = pppvVar1;
      if (data == (void **)0x0) {
        data = (void **)calloc(2,8);
        *p = data;
        if (data == (void **)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "yang_getplace_for_extcomplex_struct");
          ppvVar2 = (void **)0x0;
          goto LAB_0019cef3;
        }
      }
      else {
        c = 0;
        for (; *data != (void *)0x0; data = data + 1) {
          c = c + 1;
        }
      }
    }
    if (c != 0) {
      reallocated = realloc(*p,(long)(c + 2) * 8);
      if ((void **)reallocated == (void **)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "yang_getplace_for_extcomplex_struct");
        ppvVar2 = (void **)0x0;
        goto LAB_0019cef3;
      }
      *p = (void **)reallocated;
      data = *p;
      data[(long)c + 1] = (void *)0x0;
    }
    if (index == (int *)0x0) {
      ppvVar2 = data + c;
    }
    else {
      *index = c;
      ppvVar2 = data;
    }
  }
LAB_0019cef3:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return ppvVar2;
}



int yang_fill_extcomplex_flags
              (lys_ext_instance_complex *ext,char *parent_name,char *node_name,LY_STMT stmt,
              uint16_t value,uint16_t mask)

{
  int iVar1;
  long in_FS_OFFSET;
  uint16_t mask_local;
  uint16_t value_local;
  LY_STMT stmt_local;
  char *node_name_local;
  char *parent_name_local;
  lys_ext_instance_complex *ext_local;
  lyext_substmt *info;
  uint16_t *data;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  data = (uint16_t *)lys_ext_complex_get_substmt(stmt,ext,&info);
  if (data == (ushort *)0x0) {
    ly_vlog(ext->module->ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,node_name,parent_name);
    iVar1 = 1;
  }
  else if ((info->cardinality < LY_STMT_CARD_SOME) && ((*data & mask) != 0)) {
    ly_vlog(ext->module->ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node_name,parent_name);
    iVar1 = 1;
  }
  else {
    *data = *data | value;
    iVar1 = 0;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int yang_fill_extcomplex_uint8
              (lys_ext_instance_complex *ext,char *parent_name,char *node_name,LY_STMT stmt,
              uint8_t value)

{
  int iVar1;
  uint8_t *puVar2;
  char cVar3;
  long in_FS_OFFSET;
  uint8_t value_local;
  LY_STMT stmt_local;
  char *node_name_local;
  char *parent_name_local;
  lys_ext_instance_complex *ext_local;
  int i;
  lyext_substmt *info;
  uint8_t *val;
  uint8_t **pp;
  ly_ctx *ctx;
  uint8_t *reallocated;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = ext->module->ctx;
  pp = (uint8_t **)0x0;
  i = 0;
  val = (uint8_t *)lys_ext_complex_get_substmt(stmt,ext,&info);
  if ((uint8_t **)val == (uint8_t **)0x0) {
    ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,node_name,parent_name);
    iVar1 = 1;
  }
  else {
    if (stmt == LY_STMT_DIGITS) {
      if ((info->cardinality < LY_STMT_CARD_SOME) && (*val != '\0')) {
        ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node_name,parent_name);
        iVar1 = 1;
        goto LAB_0019d313;
      }
      if (LY_STMT_CARD_MAND < info->cardinality) {
        pp = (uint8_t **)val;
        if (*(uint8_t **)val == (uint8_t *)0x0) {
          puVar2 = (uint8_t *)calloc(2,1);
          *pp = puVar2;
          if (*pp == (uint8_t *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "yang_fill_extcomplex_uint8");
            iVar1 = 1;
            goto LAB_0019d313;
          }
        }
        else {
          for (i = 0; (*(uint8_t **)val)[i] != '\0'; i = i + 1) {
          }
        }
        val = *pp + i;
      }
      *val = value;
      if (i != 0) {
        reallocated = (uint8_t *)realloc(*pp,(long)(i + 2));
        if (reallocated == (uint8_t *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "yang_fill_extcomplex_uint8");
          iVar1 = 1;
          goto LAB_0019d313;
        }
        *pp = reallocated;
        (*pp)[(long)i + 1] = '\0';
      }
    }
    else {
      if (*val != '\0') {
        ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node_name,parent_name);
        iVar1 = 1;
        goto LAB_0019d313;
      }
      if (stmt == LY_STMT_REQINSTANCE) {
        if (value == '\x01') {
          cVar3 = '\x01';
        }
        else {
          cVar3 = '\x02';
        }
        *val = cVar3;
      }
      else {
        if (stmt != LY_STMT_MODIFIER) {
          ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/parser_yang.c"
                 ,0x139c);
          iVar1 = 1;
          goto LAB_0019d313;
        }
        *val = '\x01';
      }
    }
    iVar1 = 0;
  }
LAB_0019d313:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int yang_extcomplex_node
              (lys_ext_instance_complex *ext,char *parent_name,char *node_name,lys_node *node,
              LY_STMT stmt)

{
  lys_node *plVar1;
  int iVar2;
  LY_STMT LVar3;
  long in_FS_OFFSET;
  LY_STMT stmt_local;
  lys_node *node_local;
  char *node_name_local;
  char *parent_name_local;
  lys_ext_instance_complex *ext_local;
  lyext_substmt *info;
  lys_node *siter;
  lys_node **snode;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  snode = (lys_node **)lys_ext_complex_get_substmt(stmt,ext,&info);
  if (snode == (lys_node **)0x0) {
    ly_vlog(ext->module->ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,node_name,parent_name);
    iVar2 = 1;
  }
  else {
    plVar1 = node;
    if (info->cardinality < LY_STMT_CARD_SOME) {
      while (siter = plVar1, siter != (lys_node *)0x0) {
        LVar3 = lys_snode2stmt(siter->nodetype);
        if (stmt == LVar3) {
          ly_vlog(ext->module->ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,node_name,parent_name);
          iVar2 = 1;
          goto LAB_0019d431;
        }
        plVar1 = siter->next;
      }
    }
    iVar2 = 0;
  }
LAB_0019d431:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int yang_fill_extcomplex_module
              (ly_ctx *ctx,lys_ext_instance_complex *ext,char *parent_name,char **values,
              int implemented)

{
  lys_module **pplVar1;
  int iVar2;
  lys_module *plVar3;
  long in_FS_OFFSET;
  int implemented_local;
  char **values_local;
  char *parent_name_local;
  lys_ext_instance_complex *ext_local;
  ly_ctx *ctx_local;
  int c;
  int i;
  lyext_substmt *info;
  lys_module **modules;
  lys_module ***p;
  lys_module **pp;
  lys_module *reallocated;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (values == (char **)0x0) {
    iVar2 = 0;
  }
  else {
    modules = (lys_module **)lys_ext_complex_get_substmt(LY_STMT_MODULE,ext,&info);
    pp = modules;
    if (modules == (lys_module **)0x0) {
      ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_NONE,(void *)0x0,"module",parent_name);
      iVar2 = 1;
    }
    else {
      for (i = 0; values[i] != (char *)0x0; i = i + 1) {
        c = 0;
        if ((info->cardinality < LY_STMT_CARD_SOME) && (*modules != (lys_module *)0x0)) {
          ly_vlog(ctx,LYE_TOOMANY,LY_VLOG_NONE,(void *)0x0,"module",parent_name);
          iVar2 = 1;
          goto LAB_0019d726;
        }
        if (LY_STMT_CARD_MAND < info->cardinality) {
          p = (lys_module ***)pp;
          modules = (lys_module **)*pp;
          if ((lys_module *)modules == (lys_module *)0x0) {
            modules = (lys_module **)calloc(2,8);
            *p = modules;
            if (*p == (lys_module **)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "yang_fill_extcomplex_module");
              iVar2 = 1;
              goto LAB_0019d726;
            }
          }
          else {
            c = 0;
            for (; *modules != (lys_module *)0x0; modules = modules + 1) {
              c = c + 1;
            }
          }
        }
        if (c != 0) {
          reallocated = (lys_module *)realloc(*p,(long)(c + 2) * 8);
          if (reallocated == (lys_module *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "yang_fill_extcomplex_module");
            iVar2 = 1;
            goto LAB_0019d726;
          }
          *p = (lys_module **)reallocated;
          modules = *p;
          modules[(long)c + 1] = (lys_module *)0x0;
        }
        pplVar1 = modules + c;
        plVar3 = yang_read_module(ctx,values[i],0,(char *)0x0,implemented);
        *pplVar1 = plVar3;
        if (modules[c] == (lys_module *)0x0) {
          iVar2 = 1;
          goto LAB_0019d726;
        }
      }
      iVar2 = 0;
    }
  }
LAB_0019d726:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



lys_node_list * lys_is_key(lys_node_leaf *node,uint8_t *index)

{
  uint8_t *index_local;
  lys_node_leaf *node_local;
  uint8_t i;
  lys_node *parent;
  lys_node_list *list;
  
  ly_log_dbg(0x20,"%s","lys_is_key");
  if ((node != (lys_node_leaf *)0x0) && (parent = (lys_node *)node, node->nodetype == LYS_LEAF)) {
    do {
      parent = lys_parent(parent);
      if ((lys_node_list *)parent == (lys_node_list *)0x0) break;
    } while (((lys_node_list *)parent)->nodetype == LYS_USES);
    if (((lys_node_list *)parent != (lys_node_list *)0x0) &&
       (((lys_node_list *)parent)->nodetype == LYS_LIST)) {
      for (i = '\0'; i < ((lys_node_list *)parent)->keys_size; i = i + '\x01') {
        if (node == ((lys_node_list *)parent)->keys[i]) {
          if (index != (uint8_t *)0x0) {
            *index = i;
            return (lys_node_list *)parent;
          }
          return (lys_node_list *)parent;
        }
      }
    }
  }
  return (lys_node_list *)0x0;
}



lys_node * lys_is_disabled(lys_node *node,int recursive)

{
  int iVar1;
  int recursive_local;
  lys_node *node_local;
  int i;
  
  ly_log_dbg(0x20,"%s","lys_is_disabled");
  node_local = node;
  if (node != (lys_node *)0x0) {
    do {
      if ((node_local->nodetype != LYS_INPUT) && (node_local->nodetype != LYS_OUTPUT)) {
        for (i = 0; i < (int)(uint)node_local->iffeature_size; i = i + 1) {
          iVar1 = resolve_iffeature(node_local->iffeature + i);
          if (iVar1 == 0) {
            return node_local;
          }
        }
      }
      if (recursive == 0) {
        return (lys_node *)0x0;
      }
      if (node_local->nodetype == LYS_AUGMENT) {
        node_local = node_local->prev;
        if (node_local == (lys_node *)0x0) {
          return (lys_node *)0x0;
        }
      }
      else {
        if (node_local->nodetype == LYS_EXT) {
          return (lys_node *)0x0;
        }
        if (node_local->parent == (lys_node *)0x0) {
          return (lys_node *)0x0;
        }
        node_local = node_local->parent;
      }
    } while ((recursive != 2) ||
            ((node_local->nodetype & (LYS_CONTAINER|LYS_LEAF|LYS_LEAFLIST|LYS_LIST)) == LYS_UNKNOWN)
            );
  }
  return (lys_node *)0x0;
}



int lys_iffeature_value(lys_iffeature *iff)

{
  int iVar1;
  lys_iffeature *iff_local;
  
  iVar1 = resolve_iffeature(iff);
  return iVar1;
}



lys_type * lys_getnext_union_type(lys_type *last,lys_type *type)

{
  lys_type *plVar1;
  long in_FS_OFFSET;
  lys_type *type_local;
  lys_type *last_local;
  int found;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lys_getnext_union_type");
  found = 0;
  if ((type == (lys_type *)0x0) || (type->base != LY_TYPE_UNION)) {
    plVar1 = (lys_type *)0x0;
  }
  else {
    plVar1 = lyp_get_next_union_type(type,last,&found);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar1;
}



int lys_get_sibling(lys_node *siblings,char *mod_name,int mod_name_len,char *name,int nam_len,
                   LYS_NODE type,lys_node **ret)

{
  char *__s1;
  int iVar1;
  size_t sVar2;
  lys_node *plVar3;
  lys_module *plVar4;
  LYS_NODE type_local;
  char *name_local;
  int nam_len_local;
  int mod_name_len_local;
  char *mod_name_local;
  lys_node *siblings_local;
  lys_node *node;
  lys_node *parent;
  lys_module *mod;
  char *node_mod_name;
  
  mod = (lys_module *)0x0;
  if (((siblings == (lys_node *)0x0) || (mod_name == (char *)0x0)) || (name == (char *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("siblings && mod_name && name",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0xa0,"lys_get_sibling");
  }
  if ((type & 0x1800) != LYS_UNKNOWN) {
                    // WARNING: Subroutine does not return
    __assert_fail("!(type & (LYS_USES | LYS_GROUPING))",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0xa1,"lys_get_sibling");
  }
  mod_name_len_local = mod_name_len;
  if (mod_name_len == 0) {
    sVar2 = strlen(mod_name);
    mod_name_len_local = (int)sVar2;
  }
  nam_len_local = nam_len;
  siblings_local = siblings;
  if (nam_len == 0) {
    sVar2 = strlen(name);
    nam_len_local = (int)sVar2;
  }
  for (; (siblings_local != (lys_node *)0x0 && (siblings_local->nodetype == LYS_USES));
      siblings_local = siblings_local->child) {
  }
  if (siblings_local == (lys_node *)0x0) {
    iVar1 = 1;
  }
  else {
    if (siblings_local->nodetype == LYS_GROUPING) {
      for (node = siblings_local; (node->nodetype == LYS_GROUPING && (siblings_local != node->prev))
          ; node = node->prev) {
      }
      if (node->nodetype == LYS_GROUPING) {
        return 1;
      }
      siblings_local = node;
    }
    for (parent = lys_parent(siblings_local);
        (parent != (lys_node *)0x0 && (parent->nodetype == LYS_USES)); parent = lys_parent(parent))
    {
    }
    if (parent == (lys_node *)0x0) {
      for (node = siblings_local;
          (plVar3 = lys_parent(node), plVar3 != (lys_node *)0x0 && (node->nodetype == LYS_USES));
          node = lys_parent(node)) {
      }
      mod = lys_node_module(node);
    }
    node = (lys_node *)0x0;
    do {
      do {
        node = lys_getnext(node,parent,mod,0xb);
        if (node == (lys_node *)0x0) {
          return 1;
        }
      } while ((type != LYS_UNKNOWN) && ((node->nodetype & type) == LYS_UNKNOWN));
      plVar4 = lys_node_module(node);
      __s1 = plVar4->name;
    } while (((__s1 != mod_name) &&
             ((iVar1 = strncmp(__s1,mod_name,(long)mod_name_len_local), iVar1 != 0 ||
              (__s1[mod_name_len_local] != '\0')))) ||
            ((name != node->name &&
             ((iVar1 = strncmp(node->name,name,(long)nam_len_local), iVar1 != 0 ||
              (node->name[nam_len_local] != '\0'))))));
    if (ret != (lys_node **)0x0) {
      *ret = node;
    }
    iVar1 = 0;
  }
  return iVar1;
}



int lys_getnext_data(lys_module *mod,lys_node *parent,char *name,int nam_len,LYS_NODE type,
                    int getnext_opts,lys_node **ret)

{
  int iVar1;
  lys_module *plVar2;
  lys_module *plVar3;
  int getnext_opts_local;
  LYS_NODE type_local;
  int nam_len_local;
  char *name_local;
  lys_node *parent_local;
  lys_module *mod_local;
  lys_node *node;
  
  if (((mod != (lys_module *)0x0) || (parent != (lys_node *)0x0)) && (name != (char *)0x0)) {
    if ((type & 0x3e42) != LYS_UNKNOWN) {
                    // WARNING: Subroutine does not return
      __assert_fail("!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT))"
                    ,
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                    ,0xe9,"lys_getnext_data");
    }
    mod_local = mod;
    if (mod == (lys_module *)0x0) {
      mod_local = lys_node_module(parent);
    }
    node = (lys_node *)0x0;
    do {
      do {
        node = lys_getnext(node,parent,mod_local,getnext_opts);
        if (node == (lys_node *)0x0) {
          return 1;
        }
      } while ((type != LYS_UNKNOWN) && ((node->nodetype & type) == LYS_UNKNOWN));
      plVar2 = lys_node_module(node);
      plVar3 = lys_main_module(mod_local);
    } while ((plVar2 != plVar3) ||
            ((iVar1 = strncmp(node->name,name,(long)nam_len), iVar1 != 0 ||
             (node->name[nam_len] != '\0'))));
    if (ret != (lys_node **)0x0) {
      *ret = node;
    }
    return 0;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("(mod || parent) && name",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                ,0xe8,"lys_getnext_data");
}



lys_node * lys_getnext(lys_node *last,lys_node *parent,lys_module *module,int options)

{
  LYS_NODE LVar1;
  long lVar2;
  lys_node **pplVar3;
  lys_node *plVar4;
  int options_local;
  lys_module *module_local;
  lys_node *parent_local;
  lys_node *last_local;
  lys_node *next;
  lys_node *aug_parent;
  lys_node **snode;
  
  ly_log_dbg(0x20,"%s","lys_getnext");
  if ((((parent == (lys_node *)0x0) && (module == (lys_module *)0x0)) ||
      ((module != (lys_module *)0x0 && ((module->field_0x40 & 1) != 0)))) ||
     (((parent != (lys_node *)0x0 && (parent->nodetype == LYS_USES)) && ((options & 0x80U) == 0))))
  {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_getnext");
    return (lys_node *)0x0;
  }
  if (last == (lys_node *)0x0) {
    if (parent == (lys_node *)0x0) {
      if (((options & 0x100U) == 0) &&
         (((module->field_0x40 & 0x40) != 0 || ((module->field_0x40 & 0x80) == 0)))) {
        return (lys_node *)0x0;
      }
      last_local = module->data;
      next = last_local;
    }
    else {
      pplVar3 = lys_child(parent,LYS_UNKNOWN);
      if (((pplVar3 == (lys_node **)0x0) || (*pplVar3 == (lys_node *)0x0)) ||
         ((parent->nodetype == LYS_AUGMENT && (parent != (*pplVar3)->parent)))) {
        next = (lys_node *)0x0;
LAB_0019e39e:
        return next;
      }
      last_local = *pplVar3;
      next = last_local;
    }
  }
  else {
    last_local = last;
    if (((last->nodetype == LYS_USES) && ((options & 0x20U) != 0)) &&
       (last->child != (lys_node *)0x0)) {
      next = last->child;
    }
    else {
      next = last->next;
    }
  }
LAB_0019e005:
  do {
    if (((parent != (lys_node *)0x0) && (parent->nodetype == LYS_AUGMENT)) &&
       (next != (lys_node *)0x0)) {
      aug_parent = next->parent;
      do {
        for (; (aug_parent != (lys_node *)0x0 && (aug_parent->nodetype != LYS_AUGMENT));
            aug_parent = aug_parent->parent) {
        }
        if (aug_parent != (lys_node *)0x0) {
          if (aug_parent == parent) break;
          aug_parent = aug_parent->prev;
        }
      } while (aug_parent != (lys_node *)0x0);
      if (aug_parent == (lys_node *)0x0) {
        return (lys_node *)0x0;
      }
    }
    for (; (next != (lys_node *)0x0 && (next->nodetype == LYS_GROUPING)); next = next->next) {
      if ((options & 4U) != 0) {
        return next;
      }
    }
    if (next != (lys_node *)0x0) {
      last_local = next;
      if (((options & 0x100U) == 0) && (plVar4 = lys_is_disabled(next,0), plVar4 != (lys_node *)0x0)
         ) {
        next = next->next;
      }
      else {
        LVar1 = next->nodetype;
        if (LVar1 == LYS_ANYDATA) {
          return next;
        }
        if (LYS_ANYDATA < LVar1) {
          return (lys_node *)0x0;
        }
        if (LVar1 == LYS_ACTION) {
          return next;
        }
        if (LYS_ACTION < LVar1) {
          return (lys_node *)0x0;
        }
        if (LVar1 != LYS_USES) {
          if (LYS_USES < LVar1) {
            return (lys_node *)0x0;
          }
          if (LVar1 != LYS_OUTPUT) {
            if (LYS_OUTPUT < LVar1) {
              return (lys_node *)0x0;
            }
            if (LVar1 != LYS_INPUT) {
              if (LYS_INPUT < LVar1) {
                return (lys_node *)0x0;
              }
              if (LVar1 == LYS_RPC) {
                return next;
              }
              if (LYS_RPC < LVar1) {
                return (lys_node *)0x0;
              }
              if (LVar1 == LYS_NOTIF) {
                return next;
              }
              if (LYS_NOTIF < LVar1) {
                return (lys_node *)0x0;
              }
              if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
                if (LVar1 == LYS_UNKNOWN) {
                  return (lys_node *)0x0;
                }
                if (false) {
                  return (lys_node *)0x0;
                }
                switch(LVar1) {
                case LYS_CONTAINER:
                  lVar2._0_2_ = next[1].flags;
                  lVar2._2_1_ = next[1].ext_size;
                  lVar2._3_1_ = next[1].iffeature_size;
                  lVar2._4_1_ = next[1].padding[0];
                  lVar2._5_1_ = next[1].padding[1];
                  lVar2._6_1_ = next[1].padding[2];
                  lVar2._7_1_ = next[1].padding[3];
                  if (lVar2 != 0) {
                    return next;
                  }
                  if ((options & 0x40U) == 0) {
                    return next;
                  }
                  if (next->child == (lys_node *)0x0) {
                    next = next->next;
                  }
                  else {
                    next = next->child;
                  }
                  break;
                case LYS_CHOICE:
                  if ((options & 1U) != 0) {
                    return next;
                  }
                  if (next->child == (lys_node *)0x0) {
                    next = next->next;
                  }
                  else {
                    next = next->child;
                  }
                  break;
                default:
                  return (lys_node *)0x0;
                case LYS_LEAF:
                case LYS_LEAFLIST:
                case LYS_LIST:
                case LYS_ANYXML:
                  goto LAB_0019e39e;
                }
              }
              else {
                if (LVar1 != LYS_CASE) {
                  return (lys_node *)0x0;
                }
                if ((options & 2U) != 0) {
                  return next;
                }
                if (next->child == (lys_node *)0x0) {
                  next = next->next;
                }
                else {
                  next = next->child;
                }
              }
              goto LAB_0019e005;
            }
          }
          if ((options & 8U) != 0) {
            return next;
          }
          if (next->child == (lys_node *)0x0) {
            next = next->next;
          }
          else {
            next = next->child;
          }
          goto LAB_0019e005;
        }
        if ((options & 0x10U) != 0) {
          return next;
        }
        if (next->child == (lys_node *)0x0) {
          next = next->next;
        }
        else {
          next = next->child;
        }
      }
      goto LAB_0019e005;
    }
    if (((last_local == (lys_node *)0x0) || (parent == last_local->parent)) ||
       (plVar4 = lys_parent(last_local), parent == plVar4)) {
      return (lys_node *)0x0;
    }
    last_local = lys_parent(last_local);
    next = last_local->next;
  } while( true );
}



void lys_node_unlink(lys_node *node)

{
  LY_STMT stmt;
  lys_module *plVar1;
  lys_node *plVar2;
  lys_node *node_local;
  lys_node *parent;
  lys_node *first;
  lys_node **pp;
  lys_module *main_module;
  
  pp = (lys_node **)0x0;
  if (node != (lys_node *)0x0) {
    if ((node->module != (lys_module *)0x0) &&
       (plVar1 = lys_node_module(node), node == plVar1->data)) {
      plVar1->data = node->next;
    }
    parent = node->parent;
    if ((parent != (lys_node *)0x0) && (parent->nodetype == LYS_AUGMENT)) {
      if (node == parent->child) {
        if ((node->next == (lys_node *)0x0) || (parent != node->next->parent)) {
          plVar2 = (lys_node *)0x0;
        }
        else {
          plVar2 = node->next;
        }
        parent->child = plVar2;
      }
      if ((parent->flags & 1) == 0) {
        parent = parent->prev;
      }
      else {
        parent = (lys_node *)0x0;
      }
    }
    if (parent != (lys_node *)0x0) {
      if (parent->nodetype == LYS_EXT) {
        stmt = lys_snode2stmt(node->nodetype);
        pp = (lys_node **)
             lys_ext_complex_get_substmt
                       (stmt,(lys_ext_instance_complex *)parent,(lyext_substmt **)0x0);
        if (node == *pp) {
          *pp = node->next;
        }
      }
      else if (node == parent->child) {
        parent->child = node->next;
      }
      node->parent = (lys_node *)0x0;
    }
    if (node != node->prev) {
      if (node->next == (lys_node *)0x0) {
        first = node;
        if (parent == (lys_node *)0x0) {
          while (first->prev->next != (lys_node *)0x0) {
            first = first->prev;
          }
        }
        else if (parent->nodetype == LYS_EXT) {
          first = *pp;
        }
        else {
          first = parent->child;
        }
        first->prev = node->prev;
      }
      else {
        node->next->prev = node->prev;
      }
      if (node->prev->next != (lys_node *)0x0) {
        node->prev->next = node->next;
      }
      node->next = (lys_node *)0x0;
      node->prev = node;
    }
  }
  return;
}



lys_node_grp * lys_find_grouping_up(char *name,lys_node *start)

{
  int iVar1;
  lys_module *plVar2;
  lys_node *start_local;
  char *name_local;
  lys_node *par_iter;
  lys_node *iter;
  lys_node *stop;
  
  par_iter = start;
  do {
    if (par_iter == (lys_node *)0x0) {
      return (lys_node_grp *)0x0;
    }
    if (((par_iter->parent != (lys_node *)0x0) && (par_iter->parent->parent == (lys_node *)0x0)) &&
       (par_iter->parent->nodetype == LYS_AUGMENT)) {
      plVar2 = lys_main_module(par_iter->parent->module);
      par_iter = plVar2->data;
      if (par_iter == (lys_node *)0x0) {
        return (lys_node_grp *)0x0;
      }
    }
    if (par_iter->nodetype == LYS_EXT) {
      plVar2 = lys_main_module(par_iter->module);
      par_iter = plVar2->data;
      if (par_iter == (lys_node *)0x0) {
        return (lys_node_grp *)0x0;
      }
LAB_0019e6cc:
      stop = (lys_node *)0x0;
      for (iter = par_iter; iter != (lys_node *)0x0; iter = iter->prev) {
        if (stop == (lys_node *)0x0) {
          stop = par_iter;
        }
        else if (iter == stop) break;
        if ((iter->nodetype == LYS_GROUPING) && (iVar1 = strcmp(name,iter->name), iVar1 == 0)) {
          return (lys_node_grp *)iter;
        }
      }
    }
    else if ((par_iter->parent == (lys_node *)0x0) ||
            ((par_iter->parent->nodetype & 0x3042) == LYS_UNKNOWN)) goto LAB_0019e6cc;
    par_iter = par_iter->parent;
  } while( true );
}



lys_node_grp * lys_get_next_grouping(lys_node_grp *lastgrp,lys_node *root)

{
  lys_node *plVar1;
  lys_node *root_local;
  lys_node_grp *lastgrp_local;
  lys_node *last;
  lys_node *next;
  
  if (root == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("root",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x22b,"lys_get_next_grouping");
  }
  last = (lys_node *)lastgrp;
  if (lastgrp == (lys_node_grp *)0x0) {
    last = root;
  }
  while( true ) {
    if ((last->nodetype & 0xe13) == LYS_UNKNOWN) {
      next = (lys_node *)0x0;
    }
    else {
      next = last->child;
    }
    if (next == (lys_node *)0x0) {
      if (last == root) {
        return (lys_node_grp *)0x0;
      }
      next = last->next;
    }
    while (next == (lys_node *)0x0) {
      plVar1 = lys_parent(last);
      if (root == plVar1) {
        return (lys_node_grp *)0x0;
      }
      next = last->next;
      last = lys_parent(last);
    }
    if (next->nodetype == LYS_GROUPING) break;
    last = next;
  }
  return (lys_node_grp *)next;
}



int lys_check_id(lys_node *node,lys_node *parent,lys_module *module)

{
  LYS_NODE LVar1;
  char *pcVar2;
  bool bVar3;
  lys_module *plVar4;
  lys_node_grp *plVar5;
  char *pcVar6;
  lys_node **pplVar7;
  bool bVar8;
  lys_module *module_local;
  lys_node *parent_local;
  lys_node *node_local;
  int down;
  int up;
  lys_node *start;
  lys_node *stop;
  lys_node *iter;
  lys_node_grp *grp;
  
  if (node == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x25a,"lys_check_id");
  }
  if (parent == (lys_node *)0x0) {
    module_local = module;
    if (module == (lys_module *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("module",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                    ,0x25d,"lys_check_id");
    }
  }
  else {
    module_local = parent->module;
  }
  plVar4 = lys_main_module(module_local);
  LVar1 = node->nodetype;
  if (LVar1 != LYS_ANYDATA) {
    if (LYS_ANYDATA < LVar1) {
      return 0;
    }
    if (LVar1 == LYS_GROUPING) {
      if (parent == (lys_node *)0x0) {
        bVar3 = true;
        bVar8 = true;
        start = plVar4->data;
      }
      else {
        pplVar7 = lys_child(parent,LYS_GROUPING);
        start = *pplVar7;
        bVar8 = start != (lys_node *)0x0;
        if (!bVar8) {
          start = parent;
        }
        if (parent->nodetype == LYS_EXT) {
          bVar3 = false;
        }
        else {
          bVar3 = true;
        }
      }
      if ((bVar3) &&
         (plVar5 = lys_find_grouping_up(node->name,start), plVar5 != (lys_node_grp *)0x0)) {
        ly_vlog(plVar4->ctx,LYE_DUPID,LY_VLOG_LYS,node,"grouping",node->name);
        return 1;
      }
      if (!bVar8) {
        return 0;
      }
      iter = start;
      stop = (lys_node *)0x0;
      do {
        if (iter == (lys_node *)0x0) {
          return 0;
        }
        if (stop == (lys_node *)0x0) {
          stop = start;
        }
        else if (iter == stop) {
          return 0;
        }
        if ((iter->nodetype & 0xe13) != LYS_UNKNOWN) {
          grp = (lys_node_grp *)0x0;
          while (grp = lys_get_next_grouping(grp,iter), grp != (lys_node_grp *)0x0) {
            if (node->name == grp->name) {
              ly_vlog(plVar4->ctx,LYE_DUPID,LY_VLOG_LYS,node,"grouping",node->name);
              return 1;
            }
          }
        }
        iter = iter->prev;
      } while( true );
    }
    if (LYS_GROUPING < LVar1) {
      return 0;
    }
    if (LVar1 == LYS_CASE) {
      if (parent == (lys_node *)0x0) {
        start = plVar4->data;
      }
      else {
        pplVar7 = lys_child(parent,LYS_CASE);
        start = *pplVar7;
      }
      iter = start;
      while( true ) {
        if (iter == (lys_node *)0x0) {
          return 0;
        }
        if ((((iter->nodetype & 0x807d) != LYS_UNKNOWN) && (iter->module == node->module)) &&
           (iter->name == node->name)) break;
        iter = iter->next;
      }
      ly_vlog(plVar4->ctx,LYE_DUPID,LY_VLOG_LYS,node,&DAT_00226066,node->name);
      return 1;
    }
    if (LYS_CASE < LVar1) {
      return 0;
    }
    if (LVar1 != LYS_LIST) {
      if (LYS_LIST < LVar1) {
        return 0;
      }
      if (LVar1 != LYS_LEAFLIST) {
        if (LYS_LEAFLIST < LVar1) {
          return 0;
        }
        if (LVar1 < (LYS_CONTAINER|LYS_CHOICE)) {
          if (LVar1 == LYS_UNKNOWN) {
            return 0;
          }
        }
        else if (LVar1 != LYS_LEAF) {
          return 0;
        }
      }
    }
  }
  iter = parent;
  if (parent == (lys_node *)0x0) {
    stop = (lys_node *)0x0;
    iter = plVar4->data;
  }
  else {
    while ((iter != (lys_node *)0x0 && ((iter->nodetype & 0x3042) != LYS_UNKNOWN))) {
      if (iter->nodetype == LYS_AUGMENT) {
        if (iter->prev == (lys_node *)0x0) break;
        iter = iter->prev;
      }
      else {
        iter = iter->parent;
      }
    }
    if (iter == (lys_node *)0x0) {
      stop = (lys_node *)0x0;
      iter = plVar4->data;
    }
    else if (iter->nodetype == LYS_EXT) {
      stop = iter;
      iter = (lys_node *)lys_child(iter,node->nodetype);
      if (iter != (lys_node *)0x0) {
        iter = (lys_node *)iter->name;
      }
    }
    else {
      stop = iter;
      iter = iter->child;
    }
  }
  do {
    while( true ) {
      while( true ) {
        if (iter == (lys_node *)0x0) {
          return 0;
        }
        if ((iter->nodetype & 0x1040) == LYS_UNKNOWN) break;
        iter = iter->child;
      }
      if ((((iter->nodetype & (LYS_CONTAINER|LYS_CHOICE|LYS_LEAF|LYS_LEAFLIST|LYS_LIST|LYS_ANYDATA))
            != LYS_UNKNOWN) && (iter->module == node->module)) && (iter->name == node->name)) {
        pcVar2 = node->name;
        pcVar6 = strnodetype(node->nodetype);
        ly_vlog(plVar4->ctx,LYE_DUPID,LY_VLOG_LYS,node,pcVar6,pcVar2);
        return 1;
      }
      if (iter->nodetype != LYS_CHOICE) break;
      iter = iter->child;
    }
    if (iter->next == (lys_node *)0x0) {
      while (stop != iter->parent) {
        iter = lys_parent(iter);
        if (((iter != (lys_node *)0x0) && (iter->next != (lys_node *)0x0)) || (iter == stop))
        goto LAB_0019ed50;
      }
      iter = stop;
LAB_0019ed50:
      if (iter == stop) {
        return 0;
      }
    }
    iter = iter->next;
  } while( true );
}



int lys_node_addchild(lys_node *parent,lys_module *module,lys_node *child,int options)

{
  undefined8 uVar1;
  lys_node *plVar2;
  LY_STMT stmt;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  long in_FS_OFFSET;
  bool bVar6;
  int options_local;
  lys_node *child_local;
  lys_module *module_local;
  lys_node *parent_local;
  int type;
  int shortcase;
  lyext_substmt *info;
  lys_node *iter;
  lys_node *log_parent;
  ly_ctx *ctx;
  lys_node_augment *aug;
  void *p;
  lys_node_case *c;
  lys_node **pchild;
  lys_node_inout *in;
  lys_node_inout *out;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = child->module->ctx;
  bVar6 = false;
  info = (lyext_substmt *)0x0;
  if (child == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("child",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x30c,"lys_node_addchild");
  }
  if (parent == (lys_node *)0x0) {
    if (module == (lys_module *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("module",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                    ,0x328,"lys_node_addchild");
    }
    if ((child->nodetype & 0x600) != LYS_UNKNOWN) {
                    // WARNING: Subroutine does not return
      __assert_fail("!(child->nodetype & (LYS_INPUT | LYS_OUTPUT))",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                    ,0x329,"lys_node_addchild");
    }
    type = 0;
    log_parent = (lys_node *)0x0;
    module_local = module;
  }
  else {
    type = parent->nodetype;
    module_local = parent->module;
    log_parent = parent;
    if (type == LYS_USES) {
      while ((log_parent != (lys_node *)0x0 && (log_parent->nodetype == LYS_USES))) {
        if (log_parent->nodetype == LYS_AUGMENT) {
          aug = (lys_node_augment *)log_parent;
          if (log_parent->prev == (lys_node *)0x0) goto switchD_0019f126_caseD_3;
          log_parent = log_parent->prev;
        }
        else {
          log_parent = log_parent->parent;
        }
      }
      if (log_parent == (lys_node *)0x0) {
        type = 0;
      }
      else {
        type = log_parent->nodetype;
      }
    }
  }
  if (type == 0x10000) {
    stmt = lys_snode2stmt(child->nodetype);
    p = lys_ext_complex_get_substmt(stmt,(lys_ext_instance_complex *)log_parent,&info);
    if (p == (void *)0x0) {
      uVar1 = *(undefined8 *)log_parent->name;
      pcVar5 = strnodetype(child->nodetype);
      ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,log_parent,pcVar5,uVar1);
      iVar3 = 1;
      goto LAB_0019fc8e;
    }
  }
  else if (type < 0x10001) {
    if (type == 0x8020) {
switchD_0019f126_caseD_4:
      pcVar5 = strnodetype(log_parent->nodetype);
      pcVar4 = strnodetype(child->nodetype);
      ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,log_parent,pcVar4,pcVar5);
      pcVar5 = strnodetype(log_parent->nodetype);
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
              "The \"%s\" statement cannot have any data substatement.",pcVar5);
      iVar3 = 1;
      goto LAB_0019fc8e;
    }
    if (type < 0x8021) {
      if (type == 0x4000) {
LAB_0019f2f1:
        if ((child->nodetype & 0xe00) == LYS_UNKNOWN) {
          pcVar5 = strnodetype(child->nodetype);
          ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,log_parent,pcVar5,&DAT_002260ad);
          iVar3 = 1;
          goto LAB_0019fc8e;
        }
      }
      else if (type < 0x4001) {
        if (type == 0x2000) {
          if ((child->nodetype & 0xd0ff) == LYS_UNKNOWN) {
            pcVar5 = strnodetype(log_parent->nodetype);
            pcVar4 = strnodetype(child->nodetype);
            ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,log_parent,pcVar4,pcVar5);
            iVar3 = 1;
            goto LAB_0019fc8e;
          }
        }
        else if (type < 0x2001) {
          if (type == 0x1000) {
switchD_0019f126_caseD_1:
            if ((child->nodetype & 0xd8bf) == LYS_UNKNOWN) {
              pcVar5 = strnodetype(log_parent->nodetype);
              pcVar4 = strnodetype(child->nodetype);
              ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,log_parent,pcVar4,pcVar5);
              iVar3 = 1;
              goto LAB_0019fc8e;
            }
          }
          else if (type < 0x1001) {
            if (type == 0x800) goto switchD_0019f126_caseD_1;
            if (type < 0x801) {
              if (type == 0x400) {
LAB_0019f1a6:
                if ((child->nodetype & 0x983f) == LYS_UNKNOWN) {
                  pcVar5 = strnodetype(log_parent->nodetype);
                  pcVar4 = strnodetype(child->nodetype);
                  ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,log_parent,pcVar4,pcVar5);
                  iVar3 = 1;
                  goto LAB_0019fc8e;
                }
              }
              else if (type < 0x401) {
                if (type == 0x200) goto LAB_0019f1a6;
                if (type < 0x201) {
                  if (type == 0x100) goto LAB_0019f2f1;
                  if (type < 0x101) {
                    if (type == 0x80) goto LAB_0019f1a6;
                    if (type < 0x81) {
                      if (type < 0x21) {
                        if ((-1 < type) && (true)) {
                          switch(type) {
                          case 0:
                            if ((child->nodetype & 0xb9bf) == LYS_UNKNOWN) {
                              pcVar5 = strnodetype(child->nodetype);
                              ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,log_parent,pcVar5,
                                      "(sub)module");
                              iVar3 = 1;
                              goto LAB_0019fc8e;
                            }
                            break;
                          case 1:
                          case 0x10:
                            goto switchD_0019f126_caseD_1;
                          case 2:
                            if ((child->nodetype & 0x807f) == LYS_UNKNOWN) {
                              pcVar5 = strnodetype(child->nodetype);
                              ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,log_parent,pcVar5,"choice");
                              iVar3 = 1;
                              goto LAB_0019fc8e;
                            }
                            bVar6 = child->nodetype != LYS_CASE;
                            break;
                          case 4:
                          case 8:
                          case 0x20:
                            goto switchD_0019f126_caseD_4;
                          }
                        }
                      }
                      else if ((type == 0x40) && ((child->nodetype & 0x903f) == LYS_UNKNOWN)) {
                        pcVar5 = strnodetype(child->nodetype);
                        ly_vlog(ctx,LYE_INCHILDSTMT,LY_VLOG_LYS,log_parent,pcVar5,&DAT_00226066);
                        iVar3 = 1;
                        goto LAB_0019fc8e;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
switchD_0019f126_caseD_3:
  if ((((module_local->ctx->models).flags & 2U) == 0) &&
     (iVar3 = lys_check_id(child,parent,module_local), iVar3 != 0)) {
    iVar3 = 1;
  }
  else {
    if (child->parent != (lys_node *)0x0) {
      lys_node_unlink(child);
    }
    parent_local = parent;
    if (((child->nodetype & 0x600) == LYS_UNKNOWN) || (parent->nodetype == LYS_EXT)) {
      if (bVar6) {
        c = (lys_node_case *)calloc(1,0x70);
        if (c == (lys_node_case *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_node_addchild");
          iVar3 = 1;
          goto LAB_0019fc8e;
        }
        pcVar5 = lydict_insert(module_local->ctx,child->name,0);
        c->name = pcVar5;
        c->flags = 0x40;
        if ((options & 3U) == 0) {
          c->flags = parent->flags & 3 | c->flags;
        }
        c->module = module_local;
        c->nodetype = LYS_CASE;
        c->prev = (lys_node *)c;
        lys_node_addchild(parent,module_local,(lys_node *)c,options);
        parent_local = (lys_node *)c;
      }
      if (parent_local == (lys_node *)0x0) {
        if (module_local->data == (lys_node *)0x0) {
          module_local->data = child;
        }
        else {
          module_local->data->prev->next = child;
          child->prev = module_local->data->prev;
          module_local->data->prev = child;
        }
      }
      else {
        pchild = lys_child(parent_local,child->nodetype);
        if (pchild == (lys_node **)0x0) {
                    // WARNING: Subroutine does not return
          __assert_fail("pchild",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                        ,0x3c8,"lys_node_addchild");
        }
        child->parent = parent_local;
        if (*pchild == (lys_node *)0x0) {
          *pchild = child;
          iter = child;
        }
        else {
          iter = (*pchild)->prev;
          iter->next = child;
          child->prev = iter;
        }
        while (iter->next != (lys_node *)0x0) {
          iter = iter->next;
          iter->parent = parent_local;
        }
        (*pchild)->prev = iter;
      }
    }
    else {
      for (iter = parent->child; (iter != (lys_node *)0x0 && (iter->nodetype != child->nodetype));
          iter = iter->next) {
      }
      if (iter == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("iter",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                      ,0x393,"lys_node_addchild");
      }
      if (iter == parent->child) {
        parent->child = child;
      }
      else {
        iter->prev->next = child;
      }
      child->prev = iter->prev;
      child->next = iter->next;
      if (iter->next == (lys_node *)0x0) {
        parent->child->prev = child;
      }
      else {
        iter->next->prev = child;
      }
      child->parent = parent;
      iter->next = (lys_node *)0x0;
      iter->prev = iter;
      iter->parent = (lys_node *)0x0;
      lys_node_free(iter,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
    }
    for (iter = parent_local;
        (iter != (lys_node *)0x0 && ((iter->nodetype & 0x12800) == LYS_UNKNOWN));
        iter = iter->parent) {
    }
    if ((parent_local != (lys_node *)0x0) && (plVar2 = child, iter == (lys_node *)0x0)) {
      while ((iter = plVar2, iter != (lys_node *)0x0 && ((iter->nodetype & 0x780) == LYS_UNKNOWN)))
      {
        plVar2 = iter->parent;
      }
      if (((iter == (lys_node *)0x0) && ((parent_local->flags & 2) != 0)) &&
         ((child->flags & 1) != 0)) {
        ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,child,&DAT_0022612f,"config");
        ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                "State nodes cannot have configuration nodes as children.");
        iVar3 = 1;
        goto LAB_0019fc8e;
      }
    }
    if (((child->nodetype & (LYS_CONTAINER|LYS_CHOICE|LYS_LEAF|LYS_LEAFLIST|LYS_LIST|LYS_ANYDATA))
         != LYS_UNKNOWN) && ((child->flags & 0x80) != 0)) {
      for (iter = parent_local; iter != (lys_node *)0x0; iter = lys_parent(iter)) {
        if ((iter->nodetype & (LYS_CONTAINER|LYS_LIST)) != LYS_UNKNOWN) {
          if ((iter->flags & 0x80) != 0) break;
          iter->flags = iter->flags | 0x80;
        }
      }
    }
    if (((child->nodetype & 0x4100) != LYS_UNKNOWN) && (child->child == (lys_node *)0x0)) {
      in = (lys_node_inout *)calloc(1,0x78);
      out = (lys_node_inout *)calloc(1,0x78);
      if ((in == (lys_node_inout *)0x0) || (out == (lys_node_inout *)0x0)) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_node_addchild");
        free(in);
        free(out);
        iVar3 = 1;
        goto LAB_0019fc8e;
      }
      in->nodetype = LYS_INPUT;
      pcVar5 = lydict_insert(child->module->ctx,"input",5);
      in->name = pcVar5;
      out->nodetype = LYS_OUTPUT;
      pcVar5 = lydict_insert(child->module->ctx,"output",6);
      out->name = pcVar5;
      out->module = child->module;
      in->module = out->module;
      out->parent = child;
      in->parent = out->parent;
      out->flags = 0x40;
      in->flags = out->flags;
      in->next = (lys_node *)out;
      in->prev = (lys_node *)out;
      out->prev = (lys_node *)in;
      child->child = (lys_node *)in;
    }
    iVar3 = 0;
  }
LAB_0019fc8e:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_module *
lys_parse_mem_(ly_ctx *ctx,char *data,LYS_INFORMAT format,char *revision,int internal,int implement)

{
  int iVar1;
  size_t sVar2;
  int implement_local;
  char *revision_local;
  int internal_local;
  LYS_INFORMAT format_local;
  char *data_local;
  ly_ctx *ctx_local;
  uint len;
  char *enlarged_data;
  lys_module *mod;
  
  enlarged_data = (char *)0x0;
  mod = (lys_module *)0x0;
  if ((ctx == (ly_ctx *)0x0) || (data == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_parse_mem_");
    mod = (lys_module *)0x0;
  }
  else {
    data_local = data;
    if ((internal == 0) && (format == LYS_IN_YANG)) {
      sVar2 = strlen(data);
      data_local = (char *)malloc((ulong)((int)sVar2 + 2));
      if (data_local == (char *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_parse_mem_");
        return (lys_module *)0x0;
      }
      memcpy(data_local,data,sVar2 & 0xffffffff);
      data_local[(int)sVar2 + 1] = '\0';
      data_local[sVar2 & 0xffffffff] = data_local[(int)sVar2 + 1];
      enlarged_data = data_local;
    }
    if (format == LYS_IN_YANG) {
      mod = yang_read_module(ctx,data_local,0,revision,implement);
    }
    else if (format == LYS_IN_YIN) {
      mod = yin_read_module(ctx,data_local,revision,implement);
    }
    else {
      ly_log(ctx,LY_LLERR,LY_EINVAL,"Invalid schema input format.");
    }
    free(enlarged_data);
    if (((mod != (lys_module *)0x0) && (iVar1 = ly_strequal_(mod->name,"ietf-netconf"), iVar1 != 0))
       && (iVar1 = lyp_add_ietf_netconf_annotations_config(mod), iVar1 != 0)) {
      lys_free(mod,(_func_void_lys_node_ptr_void_ptr *)0x0,1,1);
      mod = (lys_module *)0x0;
    }
  }
  return mod;
}



lys_module * lys_parse_mem(ly_ctx *ctx,char *data,LYS_INFORMAT format)

{
  lys_module *plVar1;
  LYS_INFORMAT format_local;
  char *data_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","lys_parse_mem");
  plVar1 = lys_parse_mem_(ctx,data,format,(char *)0x0,0,1);
  return plVar1;
}



lys_submodule *
lys_sub_parse_mem(lys_module *module,char *data,LYS_INFORMAT format,unres_schema *unres)

{
  size_t sVar1;
  lys_module *module_00;
  unres_schema *unres_local;
  LYS_INFORMAT format_local;
  char *data_local;
  lys_module *module_local;
  uint len;
  char *enlarged_data;
  lys_submodule *submod;
  
  enlarged_data = (char *)0x0;
  if (module == (lys_module *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("module",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x453,"lys_sub_parse_mem");
  }
  if (data != (char *)0x0) {
    data_local = data;
    if (format == LYS_IN_YANG) {
      sVar1 = strlen(data);
      data_local = (char *)malloc((ulong)((int)sVar1 + 2));
      if (data_local == (char *)0x0) {
        ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_sub_parse_mem");
        return (lys_submodule *)0x0;
      }
      memcpy(data_local,data,sVar1 & 0xffffffff);
      data_local[(int)sVar1 + 1] = '\0';
      data_local[sVar1 & 0xffffffff] = data_local[(int)sVar1 + 1];
      enlarged_data = data_local;
    }
    module_00 = lys_main_module(module);
    if (format == LYS_IN_YANG) {
      submod = yang_read_submodule(module_00,data_local,0,unres);
    }
    else {
      if (format != LYS_IN_YIN) {
                    // WARNING: Subroutine does not return
        __assert_fail("0",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                      ,0x46b,"lys_sub_parse_mem");
      }
      submod = yin_read_submodule(module_00,data_local,unres);
    }
    free(enlarged_data);
    return submod;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("data",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                ,0x454,"lys_sub_parse_mem");
}



lys_module * lys_parse_path(ly_ctx *ctx,char *path,LYS_INFORMAT format)

{
  long lVar1;
  int iVar2;
  lys_module *plVar3;
  int *piVar4;
  char *pcVar5;
  char *pcVar6;
  size_t __n;
  lys_revision *plVar7;
  long in_FS_OFFSET;
  LYS_INFORMAT format_local;
  char *path_local;
  ly_ctx *ctx_local;
  int fd;
  char *filename;
  lys_module *ret;
  char *rev;
  char *dot;
  size_t len;
  char rpath [4096];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lys_parse_path");
  if ((ctx == (ly_ctx *)0x0) || (path == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_parse_path");
    plVar3 = (lys_module *)0x0;
  }
  else {
    iVar2 = open(path,0);
    if (iVar2 == -1) {
      piVar4 = __errno_location();
      pcVar5 = strerror(*piVar4);
      ly_log(ctx,LY_LLERR,LY_ESYS,"Opening file \"%s\" failed (%s).",path,pcVar5);
      plVar3 = (lys_module *)0x0;
    }
    else {
      plVar3 = lys_parse_fd(ctx,iVar2,format);
      close(iVar2);
      if (plVar3 == (lys_module *)0x0) {
        plVar3 = (lys_module *)0x0;
      }
      else {
        pcVar5 = strrchr(path,0x2f);
        filename = path;
        if (pcVar5 != (char *)0x0) {
          filename = pcVar5 + 1;
        }
        pcVar5 = strchr(filename,0x40);
        pcVar6 = strrchr(filename,0x2e);
        __n = strlen(plVar3->name);
        iVar2 = strncmp(filename,plVar3->name,__n);
        if (((iVar2 != 0) || ((pcVar5 != (char *)0x0 && (pcVar5 != filename + __n)))) ||
           ((pcVar5 == (char *)0x0 && (pcVar6 != filename + __n)))) {
          ly_log(ctx,LY_LLWRN,LY_SUCCESS,"File name \"%s\" does not match module name \"%s\".",
                 filename,plVar3->name);
        }
        if (pcVar5 != (char *)0x0) {
          if (((plVar3->rev_size == '\0') || ((long)pcVar6 - (long)(pcVar5 + 1) != 10)) ||
             (iVar2 = strncmp(plVar3->rev->date,pcVar5 + 1,10), iVar2 != 0)) {
            if (plVar3->rev_size == '\0') {
              plVar7 = (lys_revision *)&DAT_00226288;
            }
            else {
              plVar7 = plVar3->rev;
            }
            ly_log(ctx,LY_LLWRN,LY_SUCCESS,"File name \"%s\" does not match module revision \"%s\"."
                   ,filename,plVar7);
          }
        }
        if (plVar3->filepath == (char *)0x0) {
          pcVar5 = realpath(path,rpath);
          if (pcVar5 == (char *)0x0) {
            pcVar5 = lydict_insert(ctx,path,0);
            plVar3->filepath = pcVar5;
          }
          else {
            pcVar5 = lydict_insert(ctx,rpath,0);
            plVar3->filepath = pcVar5;
          }
        }
      }
    }
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_module * lys_parse_fd(ly_ctx *ctx,int fd,LYS_INFORMAT format)

{
  lys_module *plVar1;
  LYS_INFORMAT format_local;
  int fd_local;
  ly_ctx *ctx_local;
  
  ly_log_dbg(0x20,"%s","lys_parse_fd");
  plVar1 = lys_parse_fd_(ctx,fd,format,(char *)0x0,1);
  return plVar1;
}



void lys_parse_set_filename(ly_ctx *ctx,char **filename,int fd)

{
  long lVar1;
  ssize_t sVar2;
  char *pcVar3;
  long in_FS_OFFSET;
  int fd_local;
  char **filename_local;
  ly_ctx *ctx_local;
  int len;
  char proc_path [32];
  char path [4096];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  sprintf(proc_path,"/proc/self/fd/%d",(ulong)(uint)fd);
  sVar2 = readlink(proc_path,path,0xfff);
  if (0 < (int)sVar2) {
    pcVar3 = lydict_insert(ctx,path,(long)(int)sVar2);
    *filename = pcVar3;
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



lys_module * lys_parse_fd_(ly_ctx *ctx,int fd,LYS_INFORMAT format,char *revision,int implement)

{
  int iVar1;
  lys_module *plVar2;
  long in_FS_OFFSET;
  int implement_local;
  char *revision_local;
  LYS_INFORMAT format_local;
  int fd_local;
  ly_ctx *ctx_local;
  size_t length;
  char *addr;
  lys_module *module;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((ctx == (ly_ctx *)0x0) || (fd < 0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_parse_fd_");
    plVar2 = (lys_module *)0x0;
  }
  else {
    iVar1 = lyp_mmap(ctx,fd,(ulong)(format == LYS_IN_YANG),&length,&addr);
    if (iVar1 == 0) {
      if (addr == (char *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EINVAL,"Empty schema file.");
        plVar2 = (lys_module *)0x0;
      }
      else {
        module = lys_parse_mem_(ctx,addr,format,revision,1,implement);
        lyp_munmap(addr,length);
        plVar2 = module;
        if ((module != (lys_module *)0x0) && (module->filepath == (char *)0x0)) {
          lys_parse_set_filename(ctx,&module->filepath,fd);
          plVar2 = module;
        }
      }
    }
    else {
      ly_log(ctx,LY_LLERR,LY_ESYS,"Mapping file descriptor into memory failed (%s()).",
             "lys_parse_fd_");
      plVar2 = (lys_module *)0x0;
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_submodule * lys_sub_parse_fd(lys_module *module,int fd,LYS_INFORMAT format,unres_schema *unres)

{
  int iVar1;
  lys_module *module_00;
  lys_submodule *plVar2;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  LYS_INFORMAT format_local;
  int fd_local;
  lys_module *module_local;
  size_t length;
  char *addr;
  lys_submodule *submodule;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (module == (lys_module *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("module",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x4f9,"lys_sub_parse_fd");
  }
  if (fd < 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("fd >= 0",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x4fa,"lys_sub_parse_fd");
  }
  iVar1 = lyp_mmap(module->ctx,fd,(ulong)(format == LYS_IN_YANG),&length,&addr);
  if (iVar1 == 0) {
    if (addr == (char *)0x0) {
      ly_log(module->ctx,LY_LLERR,LY_EINVAL,"Empty submodule schema file.");
      plVar2 = (lys_submodule *)0x0;
    }
    else {
      module_00 = lys_main_module(module);
      if (format == LYS_IN_YANG) {
        submodule = yang_read_submodule(module_00,addr,0,unres);
      }
      else {
        if (format != LYS_IN_YIN) {
          ly_log(module_00->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                 ,0x50f);
          plVar2 = (lys_submodule *)0x0;
          goto LAB_001a0926;
        }
        submodule = yin_read_submodule(module_00,addr,unres);
      }
      lyp_munmap(addr,length);
      plVar2 = submodule;
      if ((submodule != (lys_submodule *)0x0) && (submodule->filepath == (char *)0x0)) {
        lys_parse_set_filename(module_00->ctx,&submodule->filepath,fd);
        plVar2 = submodule;
      }
    }
  }
  else {
    ly_log(module->ctx,LY_LLERR,LY_ESYS,"Mapping file descriptor into memory failed (%s()).",
           "lys_sub_parse_fd");
    plVar2 = (lys_submodule *)0x0;
  }
LAB_001a0926:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lys_search_localfile
              (char **searchpaths,int cwd,char *name,char *revision,char **localfile,
              LYS_INFORMAT *format)

{
  long lVar1;
  bool bVar2;
  int iVar3;
  int *piVar4;
  char *pcVar5;
  size_t __n;
  long in_FS_OFFSET;
  LYS_INFORMAT *format_local;
  char **localfile_local;
  char *revision_local;
  char *name_local;
  int cwd_local;
  char **searchpaths_local;
  int i;
  int implicit_cwd;
  int ret;
  LYS_INFORMAT format_aux;
  LYS_INFORMAT match_format;
  uint u;
  char *wn;
  size_t match_len;
  char *wd;
  DIR *dir;
  char *match_name;
  ly_set *dirs;
  size_t len;
  size_t dir_len;
  dirent *file;
  size_t flen;
  stat st;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lys_search_localfile");
  match_len = 0;
  bVar2 = false;
  ret = 1;
  wn = (char *)0x0;
  dir = (DIR *)0x0;
  match_name = (char *)0x0;
  match_format = LYS_IN_UNKNOWN;
  if (localfile == (char **)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_search_localfile");
    ret = 1;
    goto LAB_001a1375;
  }
  dirs = ly_set_new();
  if (dirs == (ly_set *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_search_localfile")
    ;
    ret = 1;
    goto LAB_001a1375;
  }
  len = strlen(name);
  if (cwd == 0) {
LAB_001a0afe:
    if (searchpaths != (char **)0x0) {
      for (i = 0; searchpaths[i] != (char *)0x0; i = i + 1) {
        if ((bVar2) && (iVar3 = strcmp((char *)*(dirs->set).s,searchpaths[i]), iVar3 == 0)) {
          bVar2 = false;
        }
        else {
          wd = strdup(searchpaths[i]);
          if (wd == (char *)0x0) {
            ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "lys_search_localfile");
            goto LAB_001a12d2;
          }
          iVar3 = ly_set_add(dirs,wd,0);
          if (iVar3 == -1) goto LAB_001a12d2;
        }
      }
    }
    wd = (char *)0x0;
    while (dirs->number != 0) {
      free(wd);
      free(wn);
      wn = (char *)0x0;
      dirs->number = dirs->number - 1;
      wd = (char *)(dirs->set).s[dirs->number];
      (dirs->set).s[dirs->number] = (lys_node *)0x0;
      ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,"Searching for \"%s\" in %s.",name,wd);
      if (dir != (DIR *)0x0) {
        closedir((DIR *)dir);
      }
      dir = (DIR *)opendir(wd);
      dir_len = strlen(wd);
      if (dir == (DIR *)0x0) {
        piVar4 = __errno_location();
        pcVar5 = strerror(*piVar4);
        ly_log((ly_ctx *)0x0,LY_LLWRN,LY_SUCCESS,
               "Unable to open directory \"%s\" for searching (sub)modules (%s).",wd,pcVar5);
      }
      else {
LAB_001a1253:
        file = (dirent *)readdir((DIR *)dir);
        if (file != (dirent *)0x0) {
          iVar3 = strcmp(".",((dirent *)file)->d_name);
          if ((iVar3 != 0) && (iVar3 = strcmp("..",file->d_name), iVar3 != 0)) {
            free(wn);
            iVar3 = asprintf(&wn,"%s/%s",wd,file->d_name);
            if (iVar3 == -1) {
              ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "lys_search_localfile");
              goto LAB_001a12d2;
            }
            iVar3 = stat(wn,(stat *)&st);
            if (iVar3 == -1) {
              piVar4 = __errno_location();
              pcVar5 = strerror(*piVar4);
              ly_log((ly_ctx *)0x0,LY_LLWRN,LY_SUCCESS,
                     "Unable to get information about \"%s\" file in \"%s\" when searching for (sub)modules (%s)"
                     ,file->d_name,wd,pcVar5);
            }
            else if (((st.st_mode & 0xf000) != 0x4000) || ((dirs->number == 0 && (bVar2)))) {
              if ((((st.st_mode & 0xf000) == 0x8000) &&
                  (iVar3 = strncmp(name,file->d_name,len), iVar3 == 0)) &&
                 ((file->d_name[len] == '.' || (file->d_name[len] == '@')))) {
                flen = strlen(file->d_name);
                iVar3 = strcmp(file->d_name + (flen - 4),".yin");
                if (iVar3 == 0) {
                  format_aux = LYS_IN_YIN;
                }
                else {
                  iVar3 = strcmp(file->d_name + (flen - 5),".yang");
                  if (iVar3 != 0) goto LAB_001a1253;
                  format_aux = LYS_IN_YANG;
                }
                if (revision == (char *)0x0) {
                  if (match_name != (char *)0x0) {
                    if (((file->d_name[len] != '@') ||
                        (iVar3 = lyp_check_date((ly_ctx *)0x0,file->d_name + len + 1), iVar3 != 0))
                       || ((match_name[match_len] == '@' &&
                           (iVar3 = strncmp(match_name + match_len + 1,file->d_name + len + 1,10),
                           -1 < iVar3)))) goto LAB_001a1253;
                    free(match_name);
                  }
                  match_name = wn;
                  wn = (char *)0x0;
                  match_len = len + dir_len + 1;
                  match_format = format_aux;
                  goto LAB_001a1253;
                }
                if (file->d_name[len] == '@') {
                  __n = strlen(revision);
                  iVar3 = strncmp(revision,file->d_name + len + 1,__n);
                  if (iVar3 == 0) {
                    free(match_name);
                    match_name = wn;
                    wn = (char *)0x0;
                    match_len = len + dir_len + 1;
                    match_format = format_aux;
                    break;
                  }
                }
                else {
                  free(match_name);
                  match_name = wn;
                  wn = (char *)0x0;
                  match_len = len + dir_len + 1;
                  match_format = format_aux;
                }
              }
            }
            else {
              iVar3 = ly_set_add(dirs,wn,0);
              if (iVar3 == -1) goto LAB_001a12d2;
              wn = (char *)0x0;
            }
          }
          goto LAB_001a1253;
        }
      }
    }
    *localfile = match_name;
    match_name = (char *)0x0;
    if (format != (LYS_INFORMAT *)0x0) {
      *format = match_format;
    }
    ret = 0;
  }
  else {
    wd = get_current_dir_name();
    if (wd == (char *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
             "lys_search_localfile");
    }
    else {
      iVar3 = ly_set_add(dirs,wd,0);
      if (iVar3 != -1) {
        bVar2 = true;
        goto LAB_001a0afe;
      }
    }
  }
LAB_001a12d2:
  free(wn);
  free(wd);
  if (dir != (DIR *)0x0) {
    closedir((DIR *)dir);
  }
  free(match_name);
  for (u = 0; u < dirs->number; u = u + 1) {
    free((dirs->set).s[u]);
  }
  ly_set_free(dirs);
LAB_001a1375:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lys_ext_iter(lys_ext_instance **ext,uint8_t ext_size,uint8_t start,LYEXT_SUBSTMT substmt)

{
  LYEXT_SUBSTMT substmt_local;
  uint8_t start_local;
  uint8_t ext_size_local;
  lys_ext_instance **ext_local;
  uint u;
  
  u = (uint)start;
  while( true ) {
    if (ext_size <= u) {
      return -1;
    }
    if (substmt == (uint)ext[u]->insubstmt) break;
    u = u + 1;
  }
  return u;
}



int lys_ext_dup(ly_ctx *ctx,lys_module *mod,lys_ext_instance **orig,uint8_t size,void *parent,
               LYEXT_PAR parent_type,lys_ext_instance ***new,int shallow,unres_schema *unres)

{
  lys_ext_instance **pplVar1;
  int iVar2;
  lys_ext_instance *plVar3;
  char *pcVar4;
  lyxml_elem *plVar5;
  void *parent_local;
  LYEXT_PAR parent_type_local;
  uint8_t size_local;
  lys_ext_instance **orig_local;
  lys_module *mod_local;
  ly_ctx *ctx_local;
  uint8_t u;
  int i;
  lys_ext_instance **result;
  unres_ext *info_orig;
  unres_ext *info;
  size_t len;
  
  u = '\0';
  orig_local = orig;
  mod_local = mod;
  ctx_local = ctx;
  if (new == (lys_ext_instance ***)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("new",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x5fd,"lys_ext_dup");
  }
  if (size == '\0') {
    if (orig == (lys_ext_instance **)0x0) {
      *new = (lys_ext_instance **)0x0;
      iVar2 = 0;
    }
    else {
      ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
             ,0x601);
      iVar2 = 1;
    }
  }
  else {
    result = (lys_ext_instance **)calloc((ulong)size,8);
    *new = result;
    if (result == (lys_ext_instance **)0x0) {
      ly_log(ctx_local,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_ext_dup");
      iVar2 = 1;
    }
    else {
      for (u = '\0'; u < size; u = u + '\x01') {
        if (orig_local[u] == (lys_ext_instance *)0x0) {
          i = unres_schema_find(unres,-1,&orig_local,UNRES_EXT);
          if (i == -1) {
            ly_log(ctx_local,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                   ,0x63a);
LAB_001a1ad5:
            *new = (lys_ext_instance **)0x0;
            lys_extension_instances_free
                      (ctx_local,result,(uint)u,(_func_void_lys_node_ptr_void_ptr *)0x0);
            return 1;
          }
          info_orig = (unres_ext *)unres->str_snode[i];
          info = (unres_ext *)malloc(0x30);
          if (info == (unres_ext *)0x0) {
            ly_log(ctx_local,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_ext_dup");
            goto LAB_001a1ad5;
          }
          info->datatype = info_orig->datatype;
          if (info->datatype == LYS_IN_YIN) {
            plVar5 = lyxml_dup_elem(ctx_local,(info_orig->data).yin,(lyxml_elem *)0x0,1,0);
            (info->data).yin = plVar5;
          }
          info->parent = parent;
          info->mod = mod_local;
          info->parent_type = parent_type;
          info->ext_index = u;
          iVar2 = unres_schema_add_node(info->mod,unres,new,UNRES_EXT,(lys_node *)info);
          if (iVar2 == -1) goto LAB_001a1ad5;
        }
        else {
          if (orig_local[u]->ext_type == '\0') {
            pplVar1 = result + u;
            plVar3 = (lys_ext_instance *)malloc(0x40);
            *pplVar1 = plVar3;
            if (result[u] == (lys_ext_instance *)0x0) {
              ly_log(ctx_local,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_ext_dup");
              goto LAB_001a1ad5;
            }
          }
          else if (orig_local[u]->ext_type == '\x01') {
            len = (size_t)orig_local[u]->def->plugin[1].check_position;
            pplVar1 = result + u;
            plVar3 = (lys_ext_instance *)calloc(1,len);
            *pplVar1 = plVar3;
            if (result[u] == (lys_ext_instance *)0x0) {
              ly_log(ctx_local,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_ext_dup");
              goto LAB_001a1ad5;
            }
            result[u][1].def = *(lys_ext **)(orig_local[u]->def->plugin + 1);
            memcpy(result[u] + 1,orig_local[u] + 1,len - 0x40);
          }
          result[u]->def = orig_local[u]->def;
          result[u]->flags = 4;
          plVar3 = result[u];
          pcVar4 = lydict_insert(ctx_local,orig_local[u]->arg_value,0);
          plVar3->arg_value = pcVar4;
          result[u]->parent = parent;
          result[u]->parent_type = (uint8_t)parent_type;
          result[u]->insubstmt = orig_local[u]->insubstmt;
          result[u]->insubstmt_index = orig_local[u]->insubstmt_index;
          result[u]->ext_type = orig_local[u]->ext_type;
          result[u]->priv = (void *)0x0;
          result[u]->nodetype = LYS_EXT;
          result[u]->module = mod_local;
          result[u]->ext_size = orig_local[u]->ext_size;
          iVar2 = lys_ext_dup(ctx_local,mod_local,orig_local[u]->ext,orig_local[u]->ext_size,
                              result[u],LYEXT_PAR_EXTINST,&result[u]->ext,shallow,unres);
          if (iVar2 != 0) goto LAB_001a1ad5;
          if (shallow != 0) {
            result[u]->priv = orig_local[u]->priv;
          }
        }
      }
      iVar2 = 0;
    }
  }
  return iVar2;
}



lys_restr * lys_restr_dup(lys_module *mod,lys_restr *old,int size,int shallow,unres_schema *unres)

{
  int iVar1;
  lys_restr *plVar2;
  char *pcVar3;
  unres_schema *unres_local;
  int shallow_local;
  int size_local;
  lys_restr *old_local;
  lys_module *mod_local;
  int i;
  lys_restr *result;
  
  if (size == 0) {
    plVar2 = (lys_restr *)0x0;
  }
  else {
    plVar2 = (lys_restr *)calloc((long)size,0x38);
    if (plVar2 == (lys_restr *)0x0) {
      ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_restr_dup");
      plVar2 = (lys_restr *)0x0;
    }
    else {
      for (i = 0; i < size; i = i + 1) {
        iVar1 = unres_schema_find(unres,-1,&old[i].ext,UNRES_EXT);
        if (iVar1 == -1) {
          plVar2[i].ext_size = old[i].ext_size;
          lys_ext_dup(mod->ctx,mod,old[i].ext,old[i].ext_size,plVar2 + i,LYEXT_PAR_RESTR,
                      &plVar2[i].ext,shallow,unres);
        }
        pcVar3 = lydict_insert(mod->ctx,old[i].expr,0);
        plVar2[i].expr = pcVar3;
        pcVar3 = lydict_insert(mod->ctx,old[i].dsc,0);
        plVar2[i].dsc = pcVar3;
        pcVar3 = lydict_insert(mod->ctx,old[i].ref,0);
        plVar2[i].ref = pcVar3;
        pcVar3 = lydict_insert(mod->ctx,old[i].eapptag,0);
        plVar2[i].eapptag = pcVar3;
        pcVar3 = lydict_insert(mod->ctx,old[i].emsg,0);
        plVar2[i].emsg = pcVar3;
      }
    }
  }
  return plVar2;
}



void lys_restr_free(ly_ctx *ctx,lys_restr *restr,
                   _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_restr *restr_local;
  ly_ctx *ctx_local;
  
  if (ctx == (ly_ctx *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("ctx",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x677,"lys_restr_free");
  }
  if (restr != (lys_restr *)0x0) {
    lys_extension_instances_free(ctx,restr->ext,(uint)restr->ext_size,private_destructor);
    lydict_remove(ctx,restr->expr);
    lydict_remove(ctx,restr->dsc);
    lydict_remove(ctx,restr->ref);
    lydict_remove(ctx,restr->eapptag);
    lydict_remove(ctx,restr->emsg);
  }
  return;
}



void lys_iffeature_free(ly_ctx *ctx,lys_iffeature *iffeature,uint8_t iffeature_size,int shallow,
                       _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  int shallow_local;
  uint8_t iffeature_size_local;
  lys_iffeature *iffeature_local;
  ly_ctx *ctx_local;
  uint8_t i;
  
  ly_log_dbg(0x20,"%s","lys_iffeature_free");
  for (i = '\0'; i < iffeature_size; i = i + '\x01') {
    lys_extension_instances_free
              (ctx,iffeature[i].ext,(uint)iffeature[i].ext_size,private_destructor);
    if (shallow == 0) {
      free(iffeature[i].expr);
      free(iffeature[i].features);
    }
  }
  free(iffeature);
  return;
}


/*
Unable to decompile 'type_dup'
Cause: Exception while decompiling 001a206a: process: timeout

*/


yang_type *
lys_yang_type_dup(lys_module *module,lys_node *parent,yang_type *old,lys_type *type,int in_grp,
                 int shallow,unres_schema *unres)

{
  int iVar1;
  yang_type *__ptr;
  char *pcVar2;
  int shallow_local;
  int in_grp_local;
  lys_type *type_local;
  yang_type *old_local;
  lys_node *parent_local;
  lys_module *module_local;
  yang_type *new;
  
  __ptr = (yang_type *)calloc(1,0x18);
  if (__ptr == (yang_type *)0x0) {
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_yang_type_dup");
  }
  else {
    __ptr->flags = old->flags;
    __ptr->base = old->base;
    pcVar2 = lydict_insert(module->ctx,old->name,0);
    __ptr->name = pcVar2;
    __ptr->type = type;
    if (__ptr->name == (char *)0x0) {
      ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_yang_type_dup");
    }
    else {
      iVar1 = type_dup(module,parent,type,old->type,__ptr->base,in_grp,shallow,unres);
      if (iVar1 == 0) {
        return __ptr;
      }
      __ptr->type->base = __ptr->base;
      lys_type_free(module->ctx,__ptr->type,(_func_void_lys_node_ptr_void_ptr *)0x0);
      memset(&__ptr->type->info,0,0x20);
    }
    free(__ptr);
  }
  return (yang_type *)0x0;
}



int lys_copy_union_leafrefs
              (lys_module *mod,lys_node *parent,lys_type *type,lys_type *prev_new,
              unres_schema *unres)

{
  byte bVar1;
  long lVar2;
  int iVar3;
  lys_type_bit *plVar4;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  lys_type *prev_new_local;
  lys_type *type_local;
  lys_node *parent_local;
  lys_module *mod_local;
  uint8_t ext_size;
  uint i;
  uint top_type;
  lys_ext_instance **ext;
  void *reloc;
  lys_type new;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  prev_new_local = prev_new;
  if (prev_new == (lys_type *)0x0) {
    memset(&new,0,0x40);
    new.base = type->base;
    prev_new_local = &new;
    new.parent = (lys_tpdf *)parent;
  }
  if (type->der == (lys_tpdf *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("type->der",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x76f,"lys_copy_union_leafrefs");
  }
  if (type->der->module == (lys_module *)0x0) {
    if (type->base == LY_TYPE_UNION) {
      (prev_new_local->info).uni.has_ptr_type = (type->info).uni.has_ptr_type;
      (prev_new_local->info).bits.count = (type->info).bits.count;
      if ((prev_new_local->info).bits.count == 0) {
                    // WARNING: Subroutine does not return
        __assert_fail("prev_new->info.uni.count",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                      ,0x78e,"lys_copy_union_leafrefs");
      }
      plVar4 = (lys_type_bit *)calloc((ulong)(prev_new_local->info).bits.count,0x40);
      (prev_new_local->info).bits.bit = plVar4;
      if ((prev_new_local->info).bits.bit == (lys_type_bit *)0x0) {
        ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "lys_copy_union_leafrefs");
        iVar3 = -1;
        goto LAB_001a324f;
      }
      for (i = 0; i < (prev_new_local->info).bits.count; i = i + 1) {
        iVar3 = lys_copy_union_leafrefs
                          (mod,parent,(lys_type *)((ulong)i * 0x40 + (long)(type->info).bits.bit),
                           (lys_type *)((long)(prev_new_local->info).bits.bit + (ulong)i * 0x40),
                           unres);
        if (iVar3 != 0) {
          iVar3 = -1;
          goto LAB_001a324f;
        }
      }
      prev_new_local->der = type->der;
    }
    else {
      iVar3 = lys_type_dup(mod,parent,prev_new_local,type,0,0,unres);
      if (iVar3 != 0) {
        iVar3 = -1;
        goto LAB_001a324f;
      }
    }
  }
  else {
    bVar1 = type->ext_size;
    iVar3 = lys_ext_dup(mod->ctx,mod,type->ext,type->ext_size,prev_new_local,LYEXT_PAR_TYPE,&ext,0,
                        unres);
    if (iVar3 != 0) {
      iVar3 = -1;
      goto LAB_001a324f;
    }
    if (prev_new_local->ext == (lys_ext_instance **)0x0) {
      prev_new_local->ext = ext;
      prev_new_local->ext_size = bVar1;
    }
    else {
      reloc = realloc(prev_new_local->ext,
                      (long)(int)((uint)bVar1 + (uint)prev_new_local->ext_size) * 8);
      if ((lys_ext_instance **)reloc == (lys_ext_instance **)0x0) {
        ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "lys_copy_union_leafrefs");
        iVar3 = -1;
        goto LAB_001a324f;
      }
      prev_new_local->ext = (lys_ext_instance **)reloc;
      memcpy(prev_new_local->ext + prev_new_local->ext_size,ext,(ulong)bVar1 * 8);
      free(ext);
      prev_new_local->ext_size = prev_new_local->ext_size + bVar1;
    }
    iVar3 = lys_copy_union_leafrefs(mod,parent,&type->der->type,prev_new_local,unres);
    if (iVar3 != 0) {
      iVar3 = -1;
      goto LAB_001a324f;
    }
  }
  if (prev_new == (lys_type *)0x0) {
    memcpy(type,prev_new_local,0x40);
  }
  iVar3 = 0;
LAB_001a324f:
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void * lys_ext_instance_substmt(lys_ext_instance *ext)

{
  uint uVar1;
  lys_ext_instance *ext_local;
  
  ly_log_dbg(0x20,"%s","lys_ext_instance_substmt");
  if (ext == (lys_ext_instance *)0x0) {
    return (void *)0x0;
  }
  switch(ext->insubstmt) {
  case '\0':
  case '\x13':
  case '\x14':
    return (void *)0x0;
  case '\x01':
    if (ext->parent_type == '\n') {
      return *(void **)((long)ext->parent + 0x10);
    }
    break;
  case '\x02':
    if (ext->parent_type == '\x03') {
      return *(void **)((ulong)ext->insubstmt_index * 8 + *(long *)((long)ext->parent + 0x20));
    }
    if (ext->parent_type == '\t') {
      return *(void **)((ulong)ext->insubstmt_index * 8 + *(long *)((long)ext->parent + 0x38));
    }
    break;
  case '\x03':
    if ((ext->parent_type == '\0') && ((*(byte *)((long)ext->parent + 0x40) & 1) != 0)) {
      return *(void **)((long)ext->parent + 0xa8);
    }
    break;
  case '\x04':
    if (ext->parent_type == '\0') {
      return *(void **)((long)ext->parent + 0x30);
    }
    break;
  case '\x05':
    if (ext->parent_type == '\x01') {
      uVar1 = *(uint *)((long)ext->parent + 0x38);
      if (uVar1 == 8) {
LAB_001a3457:
        return *(void **)((ulong)ext->insubstmt_index * 8 + *(long *)((long)ext->parent + 200));
      }
      if (uVar1 < 9) {
        if (uVar1 == 2) {
          return *(void **)((long)ext->parent + 0x70);
        }
        if (uVar1 == 4) goto LAB_001a3457;
      }
    }
    else {
      if (ext->parent_type == '\x02') {
        return *(void **)((long)ext->parent + 0x78);
      }
      if (ext->parent_type == '\x0e') {
        return *(void **)((ulong)ext->insubstmt_index * 8 + *(long *)((long)ext->parent + 0x38));
      }
      if (ext->parent_type == '\f') {
        return (void *)((ulong)ext->insubstmt_index * 8 + *(long *)((long)ext->parent + 0x40));
      }
    }
    break;
  case '\x06':
    if (true) {
      switch(ext->parent_type) {
      case '\0':
        return *(void **)((long)ext->parent + 0x18);
      case '\x01':
        return *(void **)((long)ext->parent + 8);
      case '\x02':
        return *(void **)((long)ext->parent + 8);
      case '\x04':
        return *(void **)((long)ext->parent + 8);
      case '\x05':
        return *(void **)((long)ext->parent + 8);
      case '\x06':
        return *(void **)((long)ext->parent + 8);
      case '\a':
        return *(void **)((long)ext->parent + 8);
      case '\b':
        return *(void **)((long)ext->parent + 8);
      case '\t':
        return *(void **)((long)ext->parent + 8);
      case '\n':
        return *(void **)((long)ext->parent + 8);
      case '\f':
        return *(void **)((long)ext->parent + 8);
      case '\r':
        return *(void **)((long)ext->parent + 8);
      case '\x0f':
        return *(void **)((long)ext->parent + 0x28);
      case '\x10':
        return *(void **)((long)ext->parent + 0x20);
      case '\x11':
        return *(void **)((long)ext->parent + 0x18);
      }
    }
    break;
  case '\a':
    if (ext->parent_type == '\a') {
      return *(void **)((long)ext->parent + 0x18);
    }
    break;
  case '\b':
    if (ext->parent_type == '\a') {
      return *(void **)((long)ext->parent + 0x20);
    }
    break;
  case '\t':
    if ((ext->parent_type == '\x01') && (*(int *)((long)ext->parent + 0x38) == 0x10)) {
      return *(void **)((long)ext->parent + 0x88);
    }
    break;
  case '\n':
    if ((ext->parent_type == '\0') && ((*(byte *)((long)ext->parent + 0x40) & 1) == 0)) {
      return *(void **)((long)ext->parent + 0xb0);
    }
    break;
  case '\v':
    if (ext->parent_type == '\0') {
      return *(void **)((long)ext->parent + 0x28);
    }
    break;
  case '\f':
                    // WARNING: Load size is inaccurate
    if ((ext->parent_type == '\x03') && (*ext->parent == 9)) {
      return *(void **)((long)ext->parent + 0x20);
    }
    break;
  case '\r':
    if (ext->parent_type == '\0') {
      return *(void **)((long)ext->parent + 0x10);
    }
    if (ext->parent_type == '\x0f') {
      return *(void **)((long)ext->parent + 8);
    }
    break;
  case '\x0e':
    if ((ext->parent_type == '\x01') && (*(int *)((long)ext->parent + 0x38) == 1)) {
      return *(void **)((long)ext->parent + 0x88);
    }
    if (ext->parent_type == '\f') {
      return *(void **)((long)ext->parent + 0x48);
    }
    break;
  case '\x0f':
    if (true) {
      switch(ext->parent_type) {
      case '\0':
        return *(void **)((long)ext->parent + 0x20);
      case '\x01':
        return *(void **)((long)ext->parent + 0x10);
      case '\x02':
        return *(void **)((long)ext->parent + 0x10);
      case '\x04':
        return *(void **)((long)ext->parent + 0x10);
      case '\x05':
        return *(void **)((long)ext->parent + 0x10);
      case '\x06':
        return *(void **)((long)ext->parent + 0x10);
      case '\a':
        return *(void **)((long)ext->parent + 0x10);
      case '\b':
        return *(void **)((long)ext->parent + 0x10);
      case '\t':
        return *(void **)((long)ext->parent + 0x10);
      case '\n':
        return *(void **)((long)ext->parent + 0x10);
      case '\f':
        return *(void **)((long)ext->parent + 0x10);
      case '\r':
        return *(void **)((long)ext->parent + 0x10);
      case '\x0f':
        return *(void **)((long)ext->parent + 0x30);
      case '\x10':
        return *(void **)((long)ext->parent + 0x28);
      case '\x11':
        return *(void **)((long)ext->parent + 0x20);
      }
    }
    break;
  case '\x10':
    if (ext->parent_type == '\x0f') {
      return (void *)((long)ext->parent + 0x10);
    }
    if (ext->parent_type == '\x10') {
      return (void *)((long)ext->parent + 8);
    }
    break;
  case '\x11':
    if ((ext->parent_type == '\x01') && ((*(uint *)((long)ext->parent + 0x38) & 0xc) != 0)) {
      return *(void **)((long)ext->parent + 0xc0);
    }
    if (ext->parent_type == '\x02') {
      return *(void **)((long)ext->parent + 0x28);
    }
    if (ext->parent_type == '\x0e') {
      return *(void **)((long)ext->parent + 0x30);
    }
    break;
  case '\x12':
    if (ext->parent_type == '\x05') {
      return (void *)((long)ext->parent + 0x1c);
    }
    break;
  case '\x15':
    if (ext->parent_type == '\x03') {
                    // WARNING: Load size is inaccurate
      if (*ext->parent == 9) {
        return (void *)((long)ext->parent + 0x30);
      }
                    // WARNING: Load size is inaccurate
      if (*ext->parent == 8) {
        return (void *)((long)ext->parent + 0x20);
      }
    }
    break;
  case '\x16':
    if (ext->parent_type == '\n') {
      return (void *)((long)ext->parent + 0x18);
    }
    break;
  case '\x17':
  case '\x18':
    if (ext->parent_type == '\x01') {
      return (void *)((long)ext->parent + 0x18);
    }
    if (ext->parent_type == '\x0e') {
      return (void *)((long)ext->parent + 4);
    }
    if (ext->parent_type == '\f') {
      return (void *)((long)ext->parent + 0x18);
    }
    break;
  case '\x19':
    if ((ext->parent_type == '\x01') && ((*(uint *)((long)ext->parent + 0x38) & 0x18) != 0)) {
      return (void *)((long)ext->parent + 0x18);
    }
    break;
  case '\x1a':
    if ((ext->parent_type < 0xb) && ((1L << (ext->parent_type & 0x3f) & 0x676U) != 0)) {
      return (void *)((long)ext->parent + 0x18);
    }
    break;
  case '\x1b':
                    // WARNING: Load size is inaccurate
    if ((ext->parent_type == '\x03') && (*ext->parent == 4)) {
      return (void *)((long)ext->parent + 0x28);
    }
    break;
  case '\x1c':
    if (ext->parent_type == '\x01') {
      if (*(int *)((long)ext->parent + 0x38) == 0x10) {
        return (void *)((long)ext->parent + 0x9c);
      }
      if (*(int *)((long)ext->parent + 0x38) == 8) {
        return (void *)((long)ext->parent + 0xd4);
      }
    }
    else if (ext->parent_type == '\f') {
      return (void *)((long)ext->parent + 0x4c);
    }
    break;
  case '\x1d':
    if (ext->parent_type == '\x01') {
      if (*(int *)((long)ext->parent + 0x38) == 0x10) {
        return (void *)((long)ext->parent + 0x98);
      }
      if (*(int *)((long)ext->parent + 0x38) == 8) {
        return (void *)((long)ext->parent + 0xd0);
      }
    }
    else if (ext->parent_type == '\f') {
      return (void *)((long)ext->parent + 0x48);
    }
    break;
  case '\x1e':
    if (ext->parent_type == '\x04') {
      return (void *)((long)ext->parent + 0x1c);
    }
    break;
  case '\x1f':
    if (ext->parent_type == '\x0e') {
      return (void *)((ulong)ext->insubstmt_index * 0x10 + *(long *)((long)ext->parent + 0x20));
    }
    if ((ext->parent_type == '\x01') && (*(int *)((long)ext->parent + 0x38) == 0x10)) {
      return (void *)((ulong)ext->insubstmt_index * 0x10 + *(long *)((long)ext->parent + 0x90));
    }
  }
  ly_log(ext->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
         ,0x8c4);
  return (void *)0x0;
}



int lys_type_dup(lys_module *mod,lys_node *parent,lys_type *new,lys_type *old,int in_grp,int shallow
                ,unres_schema *unres)

{
  int iVar1;
  lys_tpdf *plVar2;
  int shallow_local;
  int in_grp_local;
  lys_type *old_local;
  lys_type *new_local;
  lys_node *parent_local;
  lys_module *mod_local;
  int i;
  
  new->base = old->base;
  new->der = old->der;
  new->parent = (lys_tpdf *)parent;
  new->ext_size = old->ext_size;
  iVar1 = lys_ext_dup(mod->ctx,mod,old->ext,old->ext_size,new,LYEXT_PAR_TYPE,&new->ext,shallow,unres
                     );
  if (iVar1 == 0) {
    iVar1 = unres_schema_find(unres,-1,old,UNRES_TYPE_DER);
    if (iVar1 == -1) {
      iVar1 = type_dup(mod,parent,new,old,new->base,in_grp,shallow,unres);
    }
    else {
      if (*(char *)&old->der->name < '\0') {
        plVar2 = (lys_tpdf *)
                 lys_yang_type_dup(mod,parent,(yang_type *)old->der,new,in_grp,shallow,unres);
        new->der = plVar2;
      }
      else {
        plVar2 = (lys_tpdf *)lyxml_dup_elem(mod->ctx,(lyxml_elem *)old->der,(lyxml_elem *)0x0,1,0);
        new->der = plVar2;
      }
      if ((new->der != (lys_tpdf *)0x0) &&
         (iVar1 = unres_schema_add_node(mod,unres,new,UNRES_TYPE_DER,parent), iVar1 != -1)) {
        return 0;
      }
      iVar1 = -1;
    }
  }
  else {
    iVar1 = -1;
  }
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void lys_type_free(ly_ctx *ctx,lys_type *type,_func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_type *type_local;
  ly_ctx *ctx_local;
  uint i;
  
  if (ctx != (ly_ctx *)0x0) {
    if (type != (lys_type *)0x0) {
      lys_extension_instances_free(ctx,type->ext,(uint)type->ext_size,private_destructor);
      if (true) {
        switch(type->base) {
        case LY_TYPE_BINARY:
          lys_restr_free(ctx,(type->info).dec64.range,private_destructor);
          free((type->info).bits.bit);
          break;
        case LY_TYPE_BITS:
          for (i = 0; i < (type->info).bits.count; i = i + 1) {
            lydict_remove(ctx,(type->info).bits.bit[i].name);
            lydict_remove(ctx,(type->info).bits.bit[i].dsc);
            lydict_remove(ctx,(type->info).bits.bit[i].ref);
            lys_iffeature_free(ctx,(type->info).bits.bit[i].iffeature,
                               (type->info).bits.bit[i].iffeature_size,0,private_destructor);
            lys_extension_instances_free
                      (ctx,(type->info).bits.bit[i].ext,(uint)(type->info).bits.bit[i].ext_size,
                       private_destructor);
          }
          free((type->info).bits.bit);
          break;
        case LY_TYPE_DEC64:
          lys_restr_free(ctx,(type->info).dec64.range,private_destructor);
          free((type->info).bits.bit);
          break;
        case LY_TYPE_ENUM:
          for (i = 0; i < (type->info).bits.count; i = i + 1) {
            lydict_remove(ctx,(type->info).bits.bit[i].name);
            lydict_remove(ctx,(type->info).bits.bit[i].dsc);
            lydict_remove(ctx,(type->info).bits.bit[i].ref);
            lys_iffeature_free(ctx,(type->info).bits.bit[i].iffeature,
                               (type->info).bits.bit[i].iffeature_size,0,private_destructor);
            lys_extension_instances_free
                      (ctx,(type->info).bits.bit[i].ext,(uint)(type->info).bits.bit[i].ext_size,
                       private_destructor);
          }
          free((type->info).bits.bit);
          break;
        case LY_TYPE_IDENT:
          free((type->info).bits.bit);
          break;
        case LY_TYPE_LEAFREF:
          lydict_remove(ctx,(type->info).lref.path);
          break;
        case LY_TYPE_STRING:
          lys_restr_free(ctx,(type->info).dec64.range,private_destructor);
          free((type->info).bits.bit);
          for (i = 0; i < (type->info).str.pat_count; i = i + 1) {
            lys_restr_free(ctx,(lys_restr *)
                               (((type->info).lref.target)->padding + (ulong)i * 0x38 + -0x1c),
                           private_destructor);
            if ((type->info).str.patterns_pcre != (void **)0x0) {
              (*_pcre_free)((type->info).str.patterns_pcre[i * 2]);
              pcre_free_study((type->info).str.patterns_pcre[i * 2 + 1]);
            }
          }
          free((type->info).lref.target);
          free((type->info).str.patterns_pcre);
          break;
        case LY_TYPE_UNION:
          for (i = 0; i < (type->info).bits.count; i = i + 1) {
            lys_type_free(ctx,(lys_type *)((long)(type->info).bits.bit + (ulong)i * 0x40),
                          private_destructor);
          }
          free((type->info).bits.bit);
          break;
        case LY_TYPE_INT8:
        case LY_TYPE_UINT8:
        case LY_TYPE_INT16:
        case LY_TYPE_UINT16:
        case LY_TYPE_INT32:
        case LY_TYPE_UINT32:
        case LY_TYPE_INT64:
        case LY_TYPE_UINT64:
          lys_restr_free(ctx,(type->info).dec64.range,private_destructor);
          free((type->info).bits.bit);
        }
      }
    }
    return;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("ctx",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                ,0x8f0,"lys_type_free");
}



void lys_tpdf_free(ly_ctx *ctx,lys_tpdf *tpdf,_func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_tpdf *tpdf_local;
  ly_ctx *ctx_local;
  
  if (ctx == (ly_ctx *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("ctx",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x952,"lys_tpdf_free");
  }
  if (tpdf != (lys_tpdf *)0x0) {
    lydict_remove(ctx,tpdf->name);
    lydict_remove(ctx,tpdf->dsc);
    lydict_remove(ctx,tpdf->ref);
    lys_type_free(ctx,&tpdf->type,private_destructor);
    lydict_remove(ctx,tpdf->units);
    lydict_remove(ctx,tpdf->dflt);
    lys_extension_instances_free(ctx,tpdf->ext,(uint)tpdf->ext_size,private_destructor);
  }
  return;
}



lys_when * lys_when_dup(lys_module *mod,lys_when *old,int shallow,unres_schema *unres)

{
  lys_when *parent;
  char *pcVar1;
  unres_schema *unres_local;
  int shallow_local;
  lys_when *old_local;
  lys_module *mod_local;
  lys_when *new;
  
  if (old == (lys_when *)0x0) {
    parent = (lys_when *)0x0;
  }
  else {
    parent = (lys_when *)calloc(1,0x28);
    if (parent == (lys_when *)0x0) {
      ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_when_dup");
      parent = (lys_when *)0x0;
    }
    else {
      pcVar1 = lydict_insert(mod->ctx,old->cond,0);
      parent->cond = pcVar1;
      pcVar1 = lydict_insert(mod->ctx,old->dsc,0);
      parent->dsc = pcVar1;
      pcVar1 = lydict_insert(mod->ctx,old->ref,0);
      parent->ref = pcVar1;
      parent->ext_size = old->ext_size;
      lys_ext_dup(mod->ctx,mod,old->ext,old->ext_size,parent,LYEXT_PAR_WHEN,&parent->ext,shallow,
                  unres);
    }
  }
  return parent;
}



void lys_when_free(ly_ctx *ctx,lys_when *w,_func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_when *w_local;
  ly_ctx *ctx_local;
  
  if (w != (lys_when *)0x0) {
    lys_extension_instances_free(ctx,w->ext,(uint)w->ext_size,private_destructor);
    lydict_remove(ctx,w->cond);
    lydict_remove(ctx,w->dsc);
    lydict_remove(ctx,w->ref);
    free(w);
  }
  return;
}



void lys_augment_free(ly_ctx *ctx,lys_node_augment *aug,
                     _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  lys_node *plVar1;
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_node_augment *aug_local;
  ly_ctx *ctx_local;
  lys_node *next;
  lys_node *sub;
  
  if ((aug->target == (lys_node *)0x0) || ((aug->flags & 1) != 0)) {
    sub = aug->child;
    while (sub != (lys_node *)0x0) {
      plVar1 = sub->next;
      lys_node_free(sub,private_destructor,0);
      sub = plVar1;
    }
  }
  lydict_remove(ctx,aug->target_name);
  lydict_remove(ctx,aug->dsc);
  lydict_remove(ctx,aug->ref);
  lys_iffeature_free(ctx,aug->iffeature,aug->iffeature_size,0,private_destructor);
  lys_extension_instances_free(ctx,aug->ext,(uint)aug->ext_size,private_destructor);
  lys_when_free(ctx,aug->when,private_destructor);
  return;
}



void lys_ident_free(ly_ctx *ctx,lys_ident *ident,
                   _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_ident *ident_local;
  ly_ctx *ctx_local;
  
  if (ctx == (ly_ctx *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("ctx",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x9a2,"lys_ident_free");
  }
  if (ident != (lys_ident *)0x0) {
    free(ident->base);
    ly_set_free(ident->der);
    lydict_remove(ctx,ident->name);
    lydict_remove(ctx,ident->dsc);
    lydict_remove(ctx,ident->ref);
    lys_iffeature_free(ctx,ident->iffeature,ident->iffeature_size,0,private_destructor);
    lys_extension_instances_free(ctx,ident->ext,(uint)ident->ext_size,private_destructor);
  }
  return;
}



void lys_grp_free(ly_ctx *ctx,lys_node_grp *grp,_func_void_lys_node_ptr_void_ptr *private_destructor
                 )

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_node_grp *grp_local;
  ly_ctx *ctx_local;
  int i;
  
  for (i = 0; i < (int)(uint)grp->tpdf_size; i = i + 1) {
    lys_tpdf_free(ctx,grp->tpdf + i,private_destructor);
  }
  free(grp->tpdf);
  return;
}



void lys_rpc_action_free(ly_ctx *ctx,lys_node_rpc_action *rpc_act,
                        _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_node_rpc_action *rpc_act_local;
  ly_ctx *ctx_local;
  int i;
  
  for (i = 0; i < (int)(uint)rpc_act->tpdf_size; i = i + 1) {
    lys_tpdf_free(ctx,rpc_act->tpdf + i,private_destructor);
  }
  free(rpc_act->tpdf);
  return;
}



void lys_inout_free(ly_ctx *ctx,lys_node_inout *io,
                   _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_node_inout *io_local;
  ly_ctx *ctx_local;
  int i;
  
  for (i = 0; i < (int)(uint)io->tpdf_size; i = i + 1) {
    lys_tpdf_free(ctx,io->tpdf + i,private_destructor);
  }
  free(io->tpdf);
  for (i = 0; i < (int)(uint)io->must_size; i = i + 1) {
    lys_restr_free(ctx,io->must + i,private_destructor);
  }
  free(io->must);
  return;
}



void lys_notif_free(ly_ctx *ctx,lys_node_notif *notif,
                   _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_node_notif *notif_local;
  ly_ctx *ctx_local;
  int i;
  
  for (i = 0; i < (int)(uint)notif->must_size; i = i + 1) {
    lys_restr_free(ctx,notif->must + i,private_destructor);
  }
  free(notif->must);
  for (i = 0; i < (int)(uint)notif->tpdf_size; i = i + 1) {
    lys_tpdf_free(ctx,notif->tpdf + i,private_destructor);
  }
  free(notif->tpdf);
  return;
}



void lys_anydata_free(ly_ctx *ctx,lys_node_anydata *anyxml,
                     _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_node_anydata *anyxml_local;
  ly_ctx *ctx_local;
  int i;
  
  for (i = 0; i < (int)(uint)anyxml->must_size; i = i + 1) {
    lys_restr_free(ctx,anyxml->must + i,private_destructor);
  }
  free(anyxml->must);
  lys_when_free(ctx,anyxml->when,private_destructor);
  return;
}



void lys_leaf_free(ly_ctx *ctx,lys_node_leaf *leaf,
                  _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_node_leaf *leaf_local;
  ly_ctx *ctx_local;
  int i;
  
  ly_set_free(leaf->backlinks);
  for (i = 0; i < (int)(uint)leaf->must_size; i = i + 1) {
    lys_restr_free(ctx,leaf->must + i,private_destructor);
  }
  free(leaf->must);
  lys_when_free(ctx,leaf->when,private_destructor);
  lys_type_free(ctx,&leaf->type,private_destructor);
  lydict_remove(ctx,leaf->units);
  lydict_remove(ctx,leaf->dflt);
  return;
}



void lys_leaflist_free(ly_ctx *ctx,lys_node_leaflist *llist,
                      _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_node_leaflist *llist_local;
  ly_ctx *ctx_local;
  int i;
  
  if (llist->backlinks != (ly_set *)0x0) {
    ly_set_free(llist->backlinks);
  }
  for (i = 0; i < (int)(uint)llist->must_size; i = i + 1) {
    lys_restr_free(ctx,llist->must + i,private_destructor);
  }
  free(llist->must);
  for (i = 0; i < (int)(uint)llist->dflt_size; i = i + 1) {
    lydict_remove(ctx,llist->dflt[i]);
  }
  free(llist->dflt);
  lys_when_free(ctx,llist->when,private_destructor);
  lys_type_free(ctx,&llist->type,private_destructor);
  lydict_remove(ctx,llist->units);
  return;
}



void lys_list_free(ly_ctx *ctx,lys_node_list *list,
                  _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_node_list *list_local;
  ly_ctx *ctx_local;
  int i;
  int j;
  
  lys_when_free(ctx,list->when,private_destructor);
  for (i = 0; i < (int)(uint)list->must_size; i = i + 1) {
    lys_restr_free(ctx,list->must + i,private_destructor);
  }
  free(list->must);
  for (i = 0; i < (int)(uint)list->tpdf_size; i = i + 1) {
    lys_tpdf_free(ctx,list->tpdf + i,private_destructor);
  }
  free(list->tpdf);
  free(list->keys);
  for (i = 0; i < (int)(uint)list->unique_size; i = i + 1) {
    for (j = 0; j < (int)(uint)list->unique[i].expr_size; j = j + 1) {
      lydict_remove(ctx,list->unique[i].expr[j]);
    }
    free(list->unique[i].expr);
  }
  free(list->unique);
  lydict_remove(ctx,list->keys_str);
  return;
}



void lys_container_free(ly_ctx *ctx,lys_node_container *cont,
                       _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_node_container *cont_local;
  ly_ctx *ctx_local;
  int i;
  
  lydict_remove(ctx,cont->presence);
  for (i = 0; i < (int)(uint)cont->tpdf_size; i = i + 1) {
    lys_tpdf_free(ctx,cont->tpdf + i,private_destructor);
  }
  free(cont->tpdf);
  for (i = 0; i < (int)(uint)cont->must_size; i = i + 1) {
    lys_restr_free(ctx,cont->must + i,private_destructor);
  }
  free(cont->must);
  lys_when_free(ctx,cont->when,private_destructor);
  return;
}



void lys_feature_free(ly_ctx *ctx,lys_feature *f,
                     _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_feature *f_local;
  ly_ctx *ctx_local;
  
  lydict_remove(ctx,f->name);
  lydict_remove(ctx,f->dsc);
  lydict_remove(ctx,f->ref);
  lys_iffeature_free(ctx,f->iffeature,f->iffeature_size,0,private_destructor);
  ly_set_free(f->depfeatures);
  lys_extension_instances_free(ctx,f->ext,(uint)f->ext_size,private_destructor);
  return;
}



void lys_extension_free(ly_ctx *ctx,lys_ext *e,_func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_ext *e_local;
  ly_ctx *ctx_local;
  
  lydict_remove(ctx,e->name);
  lydict_remove(ctx,e->dsc);
  lydict_remove(ctx,e->ref);
  lydict_remove(ctx,e->argument);
  lys_extension_instances_free(ctx,e->ext,(uint)e->ext_size,private_destructor);
  return;
}



void lys_deviation_free(lys_module *module,lys_deviation *dev,
                       _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  ly_ctx *ctx_00;
  lys_node *plVar1;
  lys_node *plVar2;
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_deviation *dev_local;
  lys_module *module_local;
  int j;
  int k;
  int i;
  lys_node *next;
  lys_node *elem;
  ly_ctx *ctx;
  
  ctx_00 = module->ctx;
  lydict_remove(ctx_00,dev->target_name);
  lydict_remove(ctx_00,dev->dsc);
  lydict_remove(ctx_00,dev->ref);
  lys_extension_instances_free(ctx_00,dev->ext,(uint)dev->ext_size,private_destructor);
  if (dev->deviate != (lys_deviate *)0x0) {
    if (dev->orig_node != (lys_node *)0x0) {
      if (dev->deviate->mod == LY_DEVIATE_NO) {
        next = dev->orig_node;
LAB_001a54cf:
        elem = next;
        if (next != (lys_node *)0x0) {
          next->module = module;
          if ((next->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
            next = next->child;
          }
          else {
            next = (lys_node *)0x0;
          }
          if (next == (lys_node *)0x0) {
            if (elem == dev->orig_node) goto LAB_001a54dd;
            next = elem->next;
          }
          while (next == (lys_node *)0x0) {
            if (elem->parent->nodetype == LYS_AUGMENT) {
              elem = elem->parent->prev;
            }
            else {
              elem = elem->parent;
            }
            plVar1 = lys_parent(elem);
            plVar2 = lys_parent(dev->orig_node);
            if (plVar1 == plVar2) break;
            next = elem->next;
          }
          goto LAB_001a54cf;
        }
LAB_001a54dd:
        lys_node_free(dev->orig_node,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
      }
      else {
        dev->orig_node->module = module;
        lys_node_free(dev->orig_node,(_func_void_lys_node_ptr_void_ptr *)0x0,1);
      }
    }
    for (i = 0; i < (int)(uint)dev->deviate_size; i = i + 1) {
      lys_extension_instances_free
                (ctx_00,dev->deviate[i].ext,(uint)dev->deviate[i].ext_size,private_destructor);
      for (j = 0; j < (int)(uint)dev->deviate[i].dflt_size; j = j + 1) {
        lydict_remove(ctx_00,dev->deviate[i].dflt[j]);
      }
      free(dev->deviate[i].dflt);
      lydict_remove(ctx_00,dev->deviate[i].units);
      if (dev->deviate[i].mod == LY_DEVIATE_DEL) {
        for (j = 0; j < (int)(uint)dev->deviate[i].must_size; j = j + 1) {
          lys_restr_free(ctx_00,dev->deviate[i].must + j,private_destructor);
        }
        free(dev->deviate[i].must);
        for (j = 0; j < (int)(uint)dev->deviate[i].unique_size; j = j + 1) {
          for (k = 0; k < (int)(uint)dev->deviate[i].unique[j].expr_size; k = k + 1) {
            lydict_remove(ctx_00,dev->deviate[i].unique[j].expr[k]);
          }
          free(dev->deviate[i].unique[j].expr);
        }
        free(dev->deviate[i].unique);
      }
    }
    free(dev->deviate);
  }
  return;
}



void lys_uses_free(ly_ctx *ctx,lys_node_uses *uses,
                  _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_node_uses *uses_local;
  ly_ctx *ctx_local;
  int i;
  int j;
  
  for (i = 0; i < (int)(uint)uses->refine_size; i = i + 1) {
    lydict_remove(ctx,uses->refine[i].target_name);
    lydict_remove(ctx,uses->refine[i].dsc);
    lydict_remove(ctx,uses->refine[i].ref);
    lys_iffeature_free(ctx,uses->refine[i].iffeature,uses->refine[i].iffeature_size,0,
                       private_destructor);
    for (j = 0; j < (int)(uint)uses->refine[i].must_size; j = j + 1) {
      lys_restr_free(ctx,uses->refine[i].must + j,private_destructor);
    }
    free(uses->refine[i].must);
    for (j = 0; j < (int)(uint)uses->refine[i].dflt_size; j = j + 1) {
      lydict_remove(ctx,uses->refine[i].dflt[j]);
    }
    free(uses->refine[i].dflt);
    lys_extension_instances_free
              (ctx,uses->refine[i].ext,(uint)uses->refine[i].ext_size,private_destructor);
    if ((uses->refine[i].target_type & 1) != 0) {
      lydict_remove(ctx,uses->refine[i].mod.presence);
    }
  }
  free(uses->refine);
  for (i = 0; i < (int)(uint)uses->augment_size; i = i + 1) {
    lys_augment_free(ctx,uses->augment + i,private_destructor);
  }
  free(uses->augment);
  lys_when_free(ctx,uses->when,private_destructor);
  return;
}



void lys_node_free(lys_node *node,_func_void_lys_node_ptr_void_ptr *private_destructor,int shallow)

{
  LYS_NODE LVar1;
  ly_ctx *ctx_00;
  lys_node *plVar2;
  int shallow_local;
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_node *node_local;
  lys_node *sub;
  lys_node *next;
  ly_ctx *ctx;
  
  if (node == (lys_node *)0x0) {
    return;
  }
  if (node->module == (lys_module *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node->module",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0xaea,"lys_node_free");
  }
  if (node->module->ctx == (ly_ctx *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node->module->ctx",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0xaeb,"lys_node_free");
  }
  ctx_00 = node->module->ctx;
  if ((node->priv != (void *)0x0) && (private_destructor != (_func_void_lys_node_ptr_void_ptr *)0x0)
     ) {
    (*private_destructor)(node,node->priv);
  }
  lydict_remove(ctx_00,node->name);
  if ((node->nodetype & 0x600) == LYS_UNKNOWN) {
    lys_iffeature_free(ctx_00,node->iffeature,node->iffeature_size,shallow,private_destructor);
    lydict_remove(ctx_00,node->dsc);
    lydict_remove(ctx_00,node->ref);
  }
  if ((shallow == 0) && ((node->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN)) {
    sub = node->child;
    while (sub != (lys_node *)0x0) {
      plVar2 = sub->next;
      lys_node_free(sub,private_destructor,0);
      sub = plVar2;
    }
  }
  lys_extension_instances_free(ctx_00,node->ext,(uint)node->ext_size,private_destructor);
  LVar1 = node->nodetype;
  if (LVar1 == LYS_EXT) {
switchD_001a5f5b_caseD_0:
    ly_log(ctx_00,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
           ,0xb32);
    goto switchD_001a5f5b_caseD_3;
  }
  if (LYS_EXT < LVar1) goto switchD_001a5f5b_caseD_3;
  if (LVar1 == LYS_ANYDATA) {
switchD_001a5f5b_caseD_20:
    lys_anydata_free(ctx_00,(lys_node_anydata *)node,private_destructor);
    goto switchD_001a5f5b_caseD_3;
  }
  if (LYS_ANYDATA < LVar1) goto switchD_001a5f5b_caseD_3;
  if (LVar1 == LYS_ACTION) {
LAB_001a606d:
    lys_rpc_action_free(ctx_00,(lys_node_rpc_action *)node,private_destructor);
  }
  else {
    if (((LYS_ACTION < LVar1) || (LVar1 == LYS_AUGMENT)) || (LYS_AUGMENT < LVar1))
    goto switchD_001a5f5b_caseD_3;
    if (LVar1 == LYS_USES) {
      lys_uses_free(ctx_00,(lys_node_uses *)node,private_destructor);
      goto switchD_001a5f5b_caseD_3;
    }
    if (LYS_USES < LVar1) goto switchD_001a5f5b_caseD_3;
    if (LVar1 == LYS_GROUPING) {
      lys_grp_free(ctx_00,(lys_node_grp *)node,private_destructor);
      goto switchD_001a5f5b_caseD_3;
    }
    if (LYS_GROUPING < LVar1) goto switchD_001a5f5b_caseD_3;
    if (LVar1 != LYS_OUTPUT) {
      if (LYS_OUTPUT < LVar1) goto switchD_001a5f5b_caseD_3;
      if (LVar1 != LYS_INPUT) {
        if (LYS_INPUT < LVar1) goto switchD_001a5f5b_caseD_3;
        if (LVar1 != LYS_RPC) {
          if (LYS_RPC < LVar1) goto switchD_001a5f5b_caseD_3;
          if (LVar1 == LYS_NOTIF) {
            lys_notif_free(ctx_00,(lys_node_notif *)node,private_destructor);
            goto switchD_001a5f5b_caseD_3;
          }
          if (LYS_NOTIF < LVar1) goto switchD_001a5f5b_caseD_3;
          if (LYS_ANYXML < LVar1) {
            if (LVar1 == LYS_CASE) {
              lys_when_free(ctx_00,*(lys_when **)node->hash,private_destructor);
            }
            goto switchD_001a5f5b_caseD_3;
          }
          if (false) goto switchD_001a5f5b_caseD_3;
          switch(LVar1) {
          case LYS_UNKNOWN:
            goto switchD_001a5f5b_caseD_0;
          case LYS_CONTAINER:
            lys_container_free(ctx_00,(lys_node_container *)node,private_destructor);
            break;
          case LYS_CHOICE:
            lys_when_free(ctx_00,*(lys_when **)node->hash,private_destructor);
            break;
          case LYS_LEAF:
            lys_leaf_free(ctx_00,(lys_node_leaf *)node,private_destructor);
            break;
          case LYS_LEAFLIST:
            lys_leaflist_free(ctx_00,(lys_node_leaflist *)node,private_destructor);
            break;
          case LYS_LIST:
            lys_list_free(ctx_00,(lys_node_list *)node,private_destructor);
            break;
          case LYS_ANYXML:
            goto switchD_001a5f5b_caseD_20;
          }
          goto switchD_001a5f5b_caseD_3;
        }
        goto LAB_001a606d;
      }
    }
    lys_inout_free(ctx_00,(lys_node_inout *)node,private_destructor);
  }
switchD_001a5f5b_caseD_3:
  lys_node_unlink(node);
  free(node);
  return;
}



lys_module * lys_implemented_module(lys_module *mod)

{
  ly_ctx *plVar1;
  lys_module *mod_local;
  int i;
  ly_ctx *ctx;
  
  ly_log_dbg(0x20,"%s","lys_implemented_module");
  if ((mod != (lys_module *)0x0) && ((mod->field_0x40 & 0x80) == 0)) {
    plVar1 = mod->ctx;
    for (i = 0; i < (plVar1->models).used; i = i + 1) {
      if ((((plVar1->models).list[i]->field_0x40 & 0x80) != 0) &&
         (mod->name == (plVar1->models).list[i]->name)) {
        return (plVar1->models).list[i];
      }
    }
  }
  return mod;
}



void module_free_common(lys_module *module,_func_void_lys_node_ptr_void_ptr *private_destructor)

{
  ly_ctx *ctx_00;
  lys_node *plVar1;
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_module *module_local;
  uint i;
  lys_node *next;
  lys_node *iter;
  ly_ctx *ctx;
  
  if (module->ctx == (ly_ctx *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("module->ctx",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0xb61,"module_free_common");
  }
  ctx_00 = module->ctx;
  for (i = 0; i < module->imp_size; i = i + 1) {
    lydict_remove(ctx_00,module->imp[i].prefix);
    lydict_remove(ctx_00,module->imp[i].dsc);
    lydict_remove(ctx_00,module->imp[i].ref);
    lys_extension_instances_free
              (ctx_00,module->imp[i].ext,(uint)module->imp[i].ext_size,private_destructor);
  }
  free(module->imp);
  if ((module->field_0x40 & 1) == 0) {
    iter = module->data;
    while (iter != (lys_node *)0x0) {
      plVar1 = iter->next;
      lys_node_free(iter,private_destructor,0);
      iter = plVar1;
    }
  }
  lydict_remove(ctx_00,module->dsc);
  lydict_remove(ctx_00,module->ref);
  lydict_remove(ctx_00,module->org);
  lydict_remove(ctx_00,module->contact);
  lydict_remove(ctx_00,module->filepath);
  for (i = 0; i < module->rev_size; i = i + 1) {
    lys_extension_instances_free
              (ctx_00,module->rev[i].ext,(uint)module->rev[i].ext_size,private_destructor);
    lydict_remove(ctx_00,module->rev[i].dsc);
    lydict_remove(ctx_00,module->rev[i].ref);
  }
  free(module->rev);
  for (i = 0; i < module->ident_size; i = i + 1) {
    lys_ident_free(ctx_00,module->ident + i,private_destructor);
  }
  module->ident_size = 0;
  free(module->ident);
  for (i = 0; i < module->tpdf_size; i = i + 1) {
    lys_tpdf_free(ctx_00,module->tpdf + i,private_destructor);
  }
  free(module->tpdf);
  lys_extension_instances_free(ctx_00,module->ext,(uint)module->ext_size,private_destructor);
  for (i = 0; i < module->augment_size; i = i + 1) {
    lys_augment_free(ctx_00,module->augment + i,private_destructor);
  }
  free(module->augment);
  for (i = 0; i < module->features_size; i = i + 1) {
    lys_feature_free(ctx_00,module->features + i,private_destructor);
  }
  free(module->features);
  for (i = 0; i < module->deviation_size; i = i + 1) {
    lys_deviation_free(module,module->deviation + i,private_destructor);
  }
  free(module->deviation);
  for (i = 0; i < module->extensions_size; i = i + 1) {
    lys_extension_free(ctx_00,module->extensions + i,private_destructor);
  }
  free(module->extensions);
  lydict_remove(ctx_00,module->name);
  lydict_remove(ctx_00,module->prefix);
  return;
}



void lys_submodule_free(lys_submodule *submodule,
                       _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_submodule *submodule_local;
  int i;
  
  if (submodule != (lys_submodule *)0x0) {
    module_free_common((lys_module *)submodule,private_destructor);
    for (i = 0; i < (int)(uint)submodule->inc_size; i = i + 1) {
      lydict_remove(submodule->ctx,submodule->inc[i].dsc);
      lydict_remove(submodule->ctx,submodule->inc[i].ref);
      lys_extension_instances_free
                (submodule->ctx,submodule->inc[i].ext,(uint)submodule->inc[i].ext_size,
                 private_destructor);
    }
    free(submodule->inc);
    free(submodule);
  }
  return;
}



int lys_ingrouping(lys_node *node)

{
  lys_node *node_local;
  lys_node *iter;
  
  iter = node;
  if (node == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0xbcc,"lys_ingrouping");
  }
  while ((iter != (lys_node *)0x0 && (iter->nodetype != LYS_GROUPING))) {
    if ((iter->parent == (lys_node *)0x0) ||
       ((iter->parent->nodetype != LYS_AUGMENT || (iter->parent->parent == (lys_node *)0x0)))) {
      iter = lys_parent(iter);
    }
    else {
      iter = iter->parent->parent;
    }
  }
  return (int)(iter != (lys_node *)0x0);
}



lys_node *
lys_node_dup_recursion
          (lys_module *module,lys_node *parent,lys_node *node,unres_schema *unres,int shallow,
          int finalize)

{
  lys_node **ret;
  LYS_NODE LVar1;
  int iVar2;
  char *pcVar3;
  lys_iffeature *plVar4;
  uint8_t *puVar5;
  lys_feature **pplVar6;
  lys_node *plVar7;
  lys_module *plVar8;
  lys_node_leaf **pplVar9;
  lys_unique *plVar10;
  char **ppcVar11;
  lys_restr *plVar12;
  lys_when *plVar13;
  long lVar14;
  long in_FS_OFFSET;
  int finalize_local;
  int shallow_local;
  unres_schema *unres_local;
  lys_node *node_local;
  lys_node *parent_local;
  lys_module *module_local;
  uint16_t flags;
  int_log_opts prev_ilo;
  uint size1;
  uint size2;
  int i;
  int j;
  uint size;
  int rc;
  lys_node_list *list_orig;
  lys_node *retval;
  lys_node *iter;
  lys_node *p;
  lys_node_container *cont;
  lys_node_choice *choice;
  lys_node_leaf *leaf;
  lys_node_leaflist *llist;
  lys_node_list *list;
  lys_node_anydata *any;
  lys_node_uses *uses;
  lys_node_case *cs;
  ly_ctx *ctx;
  lys_node_container *cont_orig;
  lys_node_choice *choice_orig;
  lys_node_leaf *leaf_orig;
  lys_node_leaflist *llist_orig;
  lys_node_anydata *any_orig;
  lys_node_uses *uses_orig;
  lys_node_rpc_action *rpc;
  lys_node_inout *io;
  lys_node_notif *ntf;
  lys_node_case *cs_orig;
  unres_list_uniq *unique_info;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  retval = (lys_node *)0x0;
  ctx = module->ctx;
  cont = (lys_node_container *)0x0;
  choice = (lys_node_choice *)0x0;
  leaf = (lys_node_leaf *)0x0;
  llist = (lys_node_leaflist *)0x0;
  list = (lys_node_list *)0x0;
  any = (lys_node_anydata *)0x0;
  uses = (lys_node_uses *)0x0;
  rpc = (lys_node_rpc_action *)0x0;
  io = (lys_node_inout *)0x0;
  ntf = (lys_node_notif *)0x0;
  cs = (lys_node_case *)0x0;
  LVar1 = node->nodetype;
  list_orig = (lys_node_list *)node;
  cont_orig = (lys_node_container *)node;
  choice_orig = (lys_node_choice *)node;
  leaf_orig = (lys_node_leaf *)node;
  llist_orig = (lys_node_leaflist *)node;
  any_orig = (lys_node_anydata *)node;
  uses_orig = (lys_node_uses *)node;
  cs_orig = (lys_node_case *)node;
  if (LVar1 == LYS_ANYDATA) {
switchD_001a6b9b_caseD_20:
    retval = (lys_node *)calloc(1,0x80);
    any = (lys_node_anydata *)retval;
    goto LAB_001a6d82;
  }
  if (LYS_ANYDATA < LVar1) goto switchD_001a6b9b_caseD_3;
  if (LVar1 == LYS_ACTION) {
LAB_001a6cee:
    retval = (lys_node *)calloc(1,0x78);
    rpc = (lys_node_rpc_action *)retval;
    goto LAB_001a6d82;
  }
  if (LYS_ACTION < LVar1) goto switchD_001a6b9b_caseD_3;
  if (LVar1 == LYS_USES) {
    retval = (lys_node *)calloc(1,0x88);
    uses = (lys_node_uses *)retval;
    goto LAB_001a6d82;
  }
  if (LYS_USES < LVar1) goto switchD_001a6b9b_caseD_3;
  if (LVar1 == LYS_OUTPUT) {
LAB_001a6d0e:
    retval = (lys_node *)calloc(1,0x78);
    io = (lys_node_inout *)retval;
    goto LAB_001a6d82;
  }
  if (LYS_OUTPUT < LVar1) goto switchD_001a6b9b_caseD_3;
  if (LVar1 == LYS_INPUT) goto LAB_001a6d0e;
  if (LYS_INPUT < LVar1) goto switchD_001a6b9b_caseD_3;
  if (LVar1 == LYS_RPC) goto LAB_001a6cee;
  if (LYS_RPC < LVar1) goto switchD_001a6b9b_caseD_3;
  if (LVar1 == LYS_NOTIF) {
    retval = (lys_node *)calloc(1,0x80);
    ntf = (lys_node_notif *)retval;
    goto LAB_001a6d82;
  }
  if (LVar1 < (LYS_CONTAINER|LYS_NOTIF)) {
    if (LYS_ANYXML < LVar1) {
      if (LVar1 == LYS_CASE) {
        retval = (lys_node *)calloc(1,0x70);
        cs = (lys_node_case *)retval;
        goto LAB_001a6d82;
      }
      goto switchD_001a6b9b_caseD_3;
    }
    if ((LVar1 == LYS_UNKNOWN) || (false)) goto switchD_001a6b9b_caseD_3;
    switch(LVar1) {
    case LYS_CONTAINER:
      retval = (lys_node *)calloc(1,0x90);
      cont = (lys_node_container *)retval;
      break;
    case LYS_CHOICE:
      retval = (lys_node *)calloc(1,0x78);
      choice = (lys_node_choice *)retval;
      break;
    default:
      goto switchD_001a6b9b_caseD_3;
    case LYS_LEAF:
      retval = (lys_node *)calloc(1,0xd0);
      leaf = (lys_node_leaf *)retval;
      break;
    case LYS_LEAFLIST:
      retval = (lys_node *)calloc(1,0xd8);
      llist = (lys_node_leaflist *)retval;
      break;
    case LYS_LIST:
      retval = (lys_node *)calloc(1,0xa8);
      list = (lys_node_list *)retval;
      break;
    case LYS_ANYXML:
      goto switchD_001a6b9b_caseD_20;
    }
LAB_001a6d82:
    if (retval == (lys_node *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_node_dup_recursion");
      plVar7 = (lys_node *)0x0;
      goto LAB_001a8771;
    }
    pcVar3 = lydict_insert(ctx,node->name,0);
    retval->name = pcVar3;
    pcVar3 = lydict_insert(ctx,node->dsc,0);
    retval->dsc = pcVar3;
    pcVar3 = lydict_insert(ctx,node->ref,0);
    retval->ref = pcVar3;
    retval->flags = node->flags;
    retval->module = module;
    retval->nodetype = node->nodetype;
    retval->prev = retval;
    iVar2 = unres_schema_find(unres,-1,&node->ext,UNRES_EXT);
    if (iVar2 == -1) {
      retval->ext_size = node->ext_size;
      iVar2 = lys_ext_dup(ctx,module,node->ext,node->ext_size,retval,LYEXT_PAR_NODE,&retval->ext,
                          shallow,unres);
      if (iVar2 == 0) goto LAB_001a6f2d;
    }
    else {
LAB_001a6f2d:
      if (node->iffeature_size != '\0') {
        retval->iffeature_size = node->iffeature_size;
        plVar4 = (lys_iffeature *)calloc((ulong)retval->iffeature_size,0x20);
        retval->iffeature = plVar4;
        if (retval->iffeature == (lys_iffeature *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_node_dup_recursion");
          goto LAB_001a8753;
        }
      }
      if (shallow == 0) {
        for (i = 0; plVar7 = parent, i < (int)(uint)node->iffeature_size; i = i + 1) {
          resolve_iffeature_getsizes(node->iffeature + i,&size1,&size2);
          if (size1 != 0) {
            size = (uint)((size1 & 3) != 0) + (size1 >> 2);
            plVar4 = retval->iffeature;
            lVar14 = (long)i;
            puVar5 = (uint8_t *)malloc((ulong)size);
            plVar4[lVar14].expr = puVar5;
            if (retval->iffeature[i].expr == (uint8_t *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "lys_node_dup_recursion");
              goto LAB_001a8753;
            }
            memcpy(retval->iffeature[i].expr,node->iffeature[i].expr,(ulong)size);
            plVar4 = retval->iffeature;
            lVar14 = (long)i;
            pplVar6 = (lys_feature **)calloc((ulong)size2,8);
            plVar4[lVar14].features = pplVar6;
            if (retval->iffeature[i].features == (lys_feature **)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "lys_node_dup_recursion");
              free(retval->iffeature[i].expr);
              goto LAB_001a8753;
            }
            for (j = 0; (uint)j < size2; j = j + 1) {
              rc = unres_schema_dup(module,unres,node->iffeature[i].features + j,UNRES_IFFEAT,
                                    retval->iffeature[i].features + j);
              if (rc == 1) {
                retval->iffeature[i].features[j] = node->iffeature[i].features[j];
              }
              else if (rc == -1) goto LAB_001a8753;
            }
          }
          retval->iffeature[i].ext_size = node->iffeature[i].ext_size;
          iVar2 = lys_ext_dup(ctx,module,node->iffeature[i].ext,node->iffeature[i].ext_size,
                              retval->iffeature + i,LYEXT_PAR_IFFEATURE,&retval->iffeature[i].ext,0,
                              unres);
          if (iVar2 != 0) goto LAB_001a8753;
        }
        do {
          p = plVar7;
          for (iter = p; (iter != (lys_node *)0x0 && (iter->nodetype == LYS_USES));
              iter = iter->parent) {
          }
        } while (((iter != (lys_node *)0x0) && (iter->nodetype == LYS_AUGMENT)) &&
                (p = iter->prev, plVar7 = p, p != (lys_node *)0x0));
        if (iter == (lys_node *)0x0) {
          flags = 1;
        }
        else {
          flags = iter->flags & 3;
        }
        if (finalize == 1) {
          if ((retval->flags & 4) == 0) {
            if (retval->nodetype != LYS_USES) {
              retval->flags = flags | retval->flags & 0xfffc;
            }
            if ((retval->flags & 0x38) < (parent->flags & 0x38)) {
              retval->flags = retval->flags & 0xffc7;
              retval->flags = parent->flags & 0x38 | retval->flags;
            }
          }
          else if (((flags & 2) != 0) && ((retval->flags & 1) != 0)) {
            ly_vlog(ctx,LYE_INARG,LY_VLOG_LYS,retval,&DAT_0022612f,"config");
            ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                    "State nodes cannot have configuration nodes as children.");
            goto LAB_001a8753;
          }
        }
        else if (finalize == 2) {
          retval->flags = retval->flags & 0xfffc;
          retval->flags = retval->flags & 0xfffb;
        }
        iVar2 = lys_node_addchild(parent,retval->module,retval,0);
        if (iVar2 == 0) {
          if ((node->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
            for (iter = node->child; iter != (lys_node *)0x0; iter = iter->next) {
              if (((iter->nodetype & LYS_GROUPING) == LYS_UNKNOWN) &&
                 (plVar7 = lys_node_dup_recursion(module,retval,iter,unres,0,finalize),
                 plVar7 == (lys_node *)0x0)) goto LAB_001a8753;
            }
          }
          if ((((finalize != 1) || (retval->nodetype != LYS_LIST)) || ((retval->flags & 1) == 0)) ||
             (node->padding[2] != '\0')) goto LAB_001a77c2;
          ly_vlog(ctx,LYE_MISSCHILDSTMT,LY_VLOG_LYS,retval,&DAT_002266bd,&DAT_002266b8);
        }
      }
      else {
        memcpy(retval->iffeature,node->iffeature,(ulong)retval->iffeature_size << 5);
LAB_001a77c2:
        LVar1 = node->nodetype;
        if (LVar1 == LYS_ANYDATA) {
switchD_001a789c_caseD_20:
          if (any_orig->must != (lys_restr *)0x0) {
            plVar12 = lys_restr_dup(module,any_orig->must,(uint)any_orig->must_size,shallow,unres);
            any->must = plVar12;
            if (any->must == (lys_restr *)0x0) goto LAB_001a8753;
            any->must_size = any_orig->must_size;
          }
          plVar7 = retval;
          if (any_orig->when == (lys_when *)0x0) goto LAB_001a8771;
          plVar13 = lys_when_dup(module,any_orig->when,shallow,unres);
          any->when = plVar13;
          plVar13 = any->when;
joined_r0x001a867e:
          plVar7 = retval;
          if (plVar13 != (lys_when *)0x0) goto LAB_001a8771;
        }
        else {
          if (LYS_ANYDATA < LVar1) goto switchD_001a789c_caseD_3;
          plVar7 = retval;
          if (LVar1 == LYS_ACTION) goto LAB_001a8771;
          if (LYS_ACTION < LVar1) goto switchD_001a789c_caseD_3;
          if (LVar1 == LYS_USES) {
            uses->grp = uses_orig->grp;
            if (uses_orig->when == (lys_when *)0x0) goto LAB_001a8771;
            plVar13 = lys_when_dup(module,uses_orig->when,shallow,unres);
            uses->when = plVar13;
            plVar13 = uses->when;
            goto joined_r0x001a867e;
          }
          if (LYS_USES < LVar1) goto switchD_001a789c_caseD_3;
          if (LVar1 == LYS_OUTPUT) goto LAB_001a8771;
          if (LYS_OUTPUT < LVar1) goto switchD_001a789c_caseD_3;
          if (LVar1 == LYS_INPUT) goto LAB_001a8771;
          if (LYS_INPUT < LVar1) goto switchD_001a789c_caseD_3;
          if (LVar1 == LYS_RPC) goto LAB_001a8771;
          if (LYS_RPC < LVar1) goto switchD_001a789c_caseD_3;
          if (LVar1 == LYS_NOTIF) goto LAB_001a8771;
          if (LVar1 < (LYS_CONTAINER|LYS_NOTIF)) {
            if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
              if ((LVar1 != LYS_UNKNOWN) && (true)) {
                switch(LVar1) {
                case LYS_CONTAINER:
                  if (cont_orig->when != (lys_when *)0x0) {
                    plVar13 = lys_when_dup(module,cont_orig->when,shallow,unres);
                    cont->when = plVar13;
                    if (cont->when == (lys_when *)0x0) break;
                  }
                  pcVar3 = lydict_insert(ctx,cont_orig->presence,0);
                  cont->presence = pcVar3;
                  plVar7 = retval;
                  if (cont_orig->must == (lys_restr *)0x0) goto LAB_001a8771;
                  plVar12 = lys_restr_dup(module,cont_orig->must,(uint)cont_orig->must_size,shallow,
                                          unres);
                  cont->must = plVar12;
                  if (cont->must != (lys_restr *)0x0) {
                    cont->must_size = cont_orig->must_size;
                    plVar7 = retval;
                    goto LAB_001a8771;
                  }
                  break;
                case LYS_CHOICE:
                  if (choice_orig->when != (lys_when *)0x0) {
                    plVar13 = lys_when_dup(module,choice_orig->when,shallow,unres);
                    choice->when = plVar13;
                    if (choice->when == (lys_when *)0x0) break;
                  }
                  if (shallow != 0) {
                    choice->dflt = choice_orig->dflt;
                    plVar7 = retval;
                    goto LAB_001a8771;
                  }
                  if (choice_orig->dflt == (lys_node *)0x0) {
                    unres_schema_dup(module,unres,choice_orig,UNRES_CHOICE_DFLT,choice);
                    plVar7 = retval;
                    goto LAB_001a8771;
                  }
                  ret = &choice->dflt;
                  pcVar3 = choice_orig->dflt->name;
                  plVar8 = lys_node_module(retval);
                  rc = lys_get_sibling(choice->child,plVar8->name,0,pcVar3,0,0x807d,ret);
                  plVar7 = retval;
                  if (rc == 0) goto LAB_001a8771;
                  if (rc == 1) {
                    ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                           ,0xcf6);
                  }
                  break;
                default:
                  goto switchD_001a789c_caseD_3;
                case LYS_LEAF:
                  iVar2 = lys_ingrouping(retval);
                  iVar2 = lys_type_dup(module,retval,&leaf->type,&leaf_orig->type,iVar2,shallow,
                                       unres);
                  if (iVar2 == 0) {
                    pcVar3 = lydict_insert(module->ctx,leaf_orig->units,0);
                    leaf->units = pcVar3;
                    if (leaf_orig->dflt != (char *)0x0) {
                      ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
                      pcVar3 = leaf_orig->dflt;
                      plVar8 = lys_main_module(leaf_orig->module);
                      pcVar3 = transform_schema2json(plVar8,pcVar3);
                      leaf->dflt = pcVar3;
                      ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
                      if (leaf->dflt == (char *)0x0) {
                        pcVar3 = lydict_insert(ctx,leaf_orig->dflt,0);
                        leaf->dflt = pcVar3;
                      }
                    }
                    if (leaf_orig->must != (lys_restr *)0x0) {
                      plVar12 = lys_restr_dup(module,leaf_orig->must,(uint)leaf_orig->must_size,
                                              shallow,unres);
                      leaf->must = plVar12;
                      if (leaf->must == (lys_restr *)0x0) break;
                      leaf->must_size = leaf_orig->must_size;
                    }
                    plVar7 = retval;
                    if (leaf_orig->when == (lys_when *)0x0) goto LAB_001a8771;
                    plVar13 = lys_when_dup(module,leaf_orig->when,shallow,unres);
                    leaf->when = plVar13;
                    plVar13 = leaf->when;
                    goto joined_r0x001a867e;
                  }
                  break;
                case LYS_LEAFLIST:
                  iVar2 = lys_ingrouping(retval);
                  iVar2 = lys_type_dup(module,retval,&llist->type,&llist_orig->type,iVar2,shallow,
                                       unres);
                  if (iVar2 == 0) {
                    pcVar3 = lydict_insert(module->ctx,llist_orig->units,0);
                    llist->units = pcVar3;
                    llist->min = llist_orig->min;
                    llist->max = llist_orig->max;
                    if (llist_orig->must != (lys_restr *)0x0) {
                      plVar12 = lys_restr_dup(module,llist_orig->must,(uint)llist_orig->must_size,
                                              shallow,unres);
                      llist->must = plVar12;
                      if (llist->must == (lys_restr *)0x0) break;
                      llist->must_size = llist_orig->must_size;
                    }
                    if (llist_orig->dflt != (char **)0x0) {
                      ppcVar11 = (char **)malloc((ulong)llist_orig->dflt_size << 3);
                      llist->dflt = ppcVar11;
                      if (llist->dflt == (char **)0x0) {
                        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                               "lys_node_dup_recursion");
                        break;
                      }
                      llist->dflt_size = llist_orig->dflt_size;
                      for (i = 0; i < (int)(uint)llist->dflt_size; i = i + 1) {
                        ppcVar11 = llist->dflt;
                        lVar14 = (long)i;
                        pcVar3 = lydict_insert(ctx,llist_orig->dflt[i],0);
                        ppcVar11[lVar14] = pcVar3;
                      }
                    }
                    plVar7 = retval;
                    if (llist_orig->when != (lys_when *)0x0) {
                      plVar13 = lys_when_dup(module,llist_orig->when,shallow,unres);
                      llist->when = plVar13;
                      plVar7 = retval;
                    }
                    goto LAB_001a8771;
                  }
                  break;
                case LYS_LIST:
                  list->min = list_orig->min;
                  list->max = list_orig->max;
                  if (list_orig->must != (lys_restr *)0x0) {
                    plVar12 = lys_restr_dup(module,list_orig->must,(uint)list_orig->must_size,
                                            shallow,unres);
                    list->must = plVar12;
                    if (list->must == (lys_restr *)0x0) break;
                    list->must_size = list_orig->must_size;
                  }
                  if (list_orig->keys_size != '\0') {
                    pplVar9 = (lys_node_leaf **)calloc((ulong)list_orig->keys_size,8);
                    list->keys = pplVar9;
                    if (list->keys == (lys_node_leaf **)0x0) {
                      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                             "lys_node_dup_recursion");
                      break;
                    }
                    pcVar3 = lydict_insert(ctx,list_orig->keys_str,0);
                    list->keys_str = pcVar3;
                    list->keys_size = list_orig->keys_size;
                    if (shallow == 0) {
                      iVar2 = unres_schema_add_node
                                        (module,unres,list,UNRES_LIST_KEYS,(lys_node *)0x0);
                      if (iVar2 == -1) break;
                    }
                    else {
                      memcpy(list->keys,list_orig->keys,(ulong)list_orig->keys_size * 8);
                    }
                  }
                  if (list_orig->unique != (lys_unique *)0x0) {
                    plVar10 = (lys_unique *)malloc((ulong)list_orig->unique_size << 4);
                    list->unique = plVar10;
                    if (list->unique == (lys_unique *)0x0) {
                      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                             "lys_node_dup_recursion");
                      break;
                    }
                    list->unique_size = list_orig->unique_size;
                    for (i = 0; i < (int)(uint)list->unique_size; i = i + 1) {
                      plVar10 = list->unique;
                      lVar14 = (long)i;
                      ppcVar11 = (char **)malloc((ulong)list_orig->unique[i].expr_size << 3);
                      plVar10[lVar14].expr = ppcVar11;
                      if (list->unique[i].expr == (char **)0x0) {
                        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                               "lys_node_dup_recursion");
                        goto LAB_001a8753;
                      }
                      list->unique[i].expr_size = list_orig->unique[i].expr_size;
                      for (j = 0; j < (int)(uint)list->unique[i].expr_size; j = j + 1) {
                        ppcVar11 = list->unique[i].expr;
                        lVar14 = (long)j;
                        pcVar3 = lydict_insert(ctx,list_orig->unique[i].expr[j],0);
                        ppcVar11[lVar14] = pcVar3;
                        unique_info = (unres_list_uniq *)malloc(0x18);
                        if (unique_info == (unres_list_uniq *)0x0) {
                          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                                 "lys_node_dup_recursion");
                          goto LAB_001a8753;
                        }
                        unique_info->list = (lys_node *)list;
                        unique_info->expr = list->unique[i].expr[j];
                        unique_info->trg_type = &list->unique[i].trg_type;
                        unres_schema_dup(module,unres,&list_orig,UNRES_LIST_UNIQ,unique_info);
                      }
                    }
                  }
                  plVar7 = retval;
                  if (list_orig->when == (lys_when *)0x0) goto LAB_001a8771;
                  plVar13 = lys_when_dup(module,list_orig->when,shallow,unres);
                  list->when = plVar13;
                  plVar13 = list->when;
                  goto joined_r0x001a867e;
                case LYS_ANYXML:
                  goto switchD_001a789c_caseD_20;
                }
                goto LAB_001a8753;
              }
            }
            else if (LVar1 == LYS_CASE) {
              if (cs_orig->when == (lys_when *)0x0) goto LAB_001a8771;
              plVar13 = lys_when_dup(module,cs_orig->when,shallow,unres);
              cs->when = plVar13;
              plVar13 = cs->when;
              goto joined_r0x001a867e;
            }
          }
switchD_001a789c_caseD_3:
          ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                 ,0xda2);
        }
      }
    }
  }
  else {
switchD_001a6b9b_caseD_3:
    ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
           ,0xc41);
  }
LAB_001a8753:
  lys_node_free(retval,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
  plVar7 = (lys_node *)0x0;
LAB_001a8771:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar7;
}



int lys_has_xpath(lys_node *node)

{
  LYS_NODE LVar1;
  long lVar2;
  long lVar3;
  long lVar4;
  lys_node *node_local;
  
  if (node == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0xdb0,"lys_has_xpath");
  }
  LVar1 = node->nodetype;
  if (LVar1 == LYS_ANYDATA) {
    if ((node[1].name != (char *)0x0) || (node->padding[3] != '\0')) {
      return 1;
    }
  }
  else if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
    if (LVar1 == LYS_AUGMENT) {
      if (node->next != (lys_node *)0x0) {
        return 1;
      }
    }
    else if (LVar1 < (LYS_CONTAINER|LYS_AUGMENT)) {
      if (LVar1 == LYS_USES) {
        lVar4._0_1_ = node->hash[0];
        lVar4._1_1_ = node->hash[1];
        lVar4._2_1_ = node->hash[2];
        lVar4._3_1_ = node->hash[3];
        lVar4._4_4_ = *(undefined4 *)&node->field_0x6c;
        if (lVar4 != 0) {
          return 1;
        }
      }
      else if (LVar1 < (LYS_CONTAINER|LYS_USES)) {
        if (LVar1 != LYS_OUTPUT) {
          if (LYS_OUTPUT < LVar1) {
            return 0;
          }
          if (LVar1 != LYS_INPUT) {
            if (LYS_INPUT < LVar1) {
              return 0;
            }
            if (LVar1 == LYS_NOTIF) {
              if (node->padding[1] == '\0') {
                return 0;
              }
              return 1;
            }
            if (LYS_NOTIF < LVar1) {
              return 0;
            }
            if (LVar1 < (LYS_CONTAINER|LYS_LIST)) {
              if (LVar1 == LYS_UNKNOWN) {
                return 0;
              }
              if (false) {
                return 0;
              }
              switch(LVar1) {
              case LYS_CONTAINER:
                goto switchD_001a8885_caseD_1;
              case LYS_CHOICE:
                lVar3._0_1_ = node->hash[0];
                lVar3._1_1_ = node->hash[1];
                lVar3._2_1_ = node->hash[2];
                lVar3._3_1_ = node->hash[3];
                lVar3._4_4_ = *(undefined4 *)&node->field_0x6c;
                if (lVar3 == 0) {
                  return 0;
                }
                return 1;
              default:
                return 0;
              case LYS_LEAF:
                if ((node[1].name == (char *)0x0) && (node->padding[3] == '\0')) {
                  return 0;
                }
                return 1;
              case LYS_LEAFLIST:
                if ((node[1].name == (char *)0x0) && (node->padding[3] == '\0')) {
                  return 0;
                }
                return 1;
              case LYS_LIST:
                if ((node[1].name == (char *)0x0) && (node->padding[0] == '\0')) {
                  return 0;
                }
                return 1;
              }
            }
            if (LVar1 != LYS_CASE) {
              return 0;
            }
            lVar2._0_1_ = node->hash[0];
            lVar2._1_1_ = node->hash[1];
            lVar2._2_1_ = node->hash[2];
            lVar2._3_1_ = node->hash[3];
            lVar2._4_4_ = *(undefined4 *)&node->field_0x6c;
            if (lVar2 == 0) {
              return 0;
            }
            return 1;
          }
        }
        if (node->padding[1] != '\0') {
          return 1;
        }
      }
    }
  }
  return 0;
switchD_001a8885_caseD_1:
  if ((node[1].name == (char *)0x0) && (node->padding[1] == '\0')) {
    return 0;
  }
  return 1;
}



int lys_type_is_local(lys_type *type)

{
  uint uVar1;
  lys_module *plVar2;
  lys_module *plVar3;
  lys_type *type_local;
  
  if (type->der->module == (lys_module *)0x0) {
    uVar1 = 1;
  }
  else {
    plVar2 = lys_main_module(type->der->module);
    plVar3 = lys_main_module(type->parent->module);
    uVar1 = (uint)(plVar2 == plVar3);
  }
  return uVar1;
}



lys_node *
lys_node_dup(lys_module *module,lys_node *parent,lys_node *node,unres_schema *unres,int shallow)

{
  int iVar1;
  lys_node *node_00;
  lys_node *plVar2;
  lys_node *plVar3;
  int shallow_local;
  unres_schema *unres_local;
  lys_node *node_local;
  lys_node *parent_local;
  lys_module *module_local;
  int finalize;
  lys_node *p;
  lys_node *iter;
  lys_node *next;
  lys_node *result;
  
  finalize = 0;
  p = parent;
  if (shallow == 0) {
    for (; (p != (lys_node *)0x0 && ((p->nodetype & 0x4f80) == LYS_UNKNOWN)); p = lys_parent(p)) {
    }
    if (p == (lys_node *)0x0) {
      finalize = 1;
    }
    else if (p->nodetype == LYS_GROUPING) {
      finalize = 0;
    }
    else {
      finalize = 2;
    }
  }
  node_00 = lys_node_dup_recursion(module,parent,node,unres,shallow,finalize);
  iter = node_00;
  if (finalize != 0) {
    while (iter != (lys_node *)0x0) {
      iVar1 = lys_has_xpath(iter);
      if ((iVar1 != 0) &&
         (iVar1 = unres_schema_add_node(module,unres,iter,UNRES_XPATH,(lys_node *)0x0), iVar1 == -1)
         ) {
        return (lys_node *)0x0;
      }
      if ((iter->nodetype & 0x882c) == LYS_UNKNOWN) {
        next = iter->child;
      }
      else {
        next = (lys_node *)0x0;
      }
      if (next == (lys_node *)0x0) {
        if (iter == node_00) {
          return node_00;
        }
        next = iter->next;
      }
      while (next == (lys_node *)0x0) {
        iter = lys_parent(iter);
        plVar2 = lys_parent(iter);
        plVar3 = lys_parent(node_00);
        if (plVar2 == plVar3) break;
        next = iter->next;
      }
      iter = next;
    }
  }
  return node_00;
}



void lys_node_switch(lys_node *node1,lys_node *node2)

{
  uint16_t *__src;
  lys_node *__src_00;
  LYS_NODE LVar1;
  long lVar2;
  uint8_t *puVar3;
  long lVar4;
  uint8_t *puVar5;
  uint8_t uVar6;
  uint8_t uVar7;
  uint8_t uVar8;
  undefined4 uVar9;
  size_t sVar10;
  uint8_t_0_ *puVar11;
  lys_node **pplVar12;
  long in_FS_OFFSET;
  lys_node *node2_local;
  lys_node *node1_local;
  size_t size;
  size_t mem_size;
  undefined8 local_38;
  uint8_t_0_ *mem;
  size_t offset;
  long local_20;
  
  node1_local = node1;
  node2_local = node2;
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  mem_size = 0x68;
  local_38 = 0x67;
  for (pplVar12 = &node2_local; pplVar12 != &node2_local;
      pplVar12 = (lys_node **)((long)pplVar12 + -0x1000)) {
    *(undefined8 *)((long)pplVar12 + -8) = *(undefined8 *)((long)pplVar12 + -8);
  }
  if (true) {
    *(undefined8 *)((long)pplVar12 + -8) = *(undefined8 *)((long)pplVar12 + -8);
  }
  if (((node1_local->module != node2_local->module) || (node1_local->name != node2_local->name)) ||
     (node1_local->nodetype != node2_local->nodetype)) {
                    // WARNING: Subroutine does not return
    mem = (undefined *)((long)pplVar12 + -0x70);
    *(undefined8 *)((long)pplVar12 + -0x78) = 0x1a8d57;
    __assert_fail("(node1->module == node2->module) && ly_strequal(node1->name, node2->name, 1) && (node1->nodetype == node2->nodetype)"
                  ,
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0xe47,"lys_node_switch");
  }
  offset = 0x18;
  size = 0x18;
  __src = &node1_local->flags;
  mem = (undefined *)((long)pplVar12 + -0x70);
  *(undefined8 *)((long)pplVar12 + -0x78) = 0x1a8d86;
  memcpy((undefined *)((long)pplVar12 + -0x70),__src,0x18);
  sVar10 = size;
  lVar2 = offset - 0x1c;
  puVar3 = node2_local->padding;
  lVar4 = offset - 0x1c;
  puVar5 = node1_local->padding;
  *(undefined8 *)((long)pplVar12 + -0x78) = 0x1a8dad;
  memcpy(puVar5 + lVar4,puVar3 + lVar2,sVar10);
  puVar11 = mem;
  sVar10 = size;
  lVar2 = offset - 0x1c;
  puVar3 = node2_local->padding;
  *(undefined8 *)((long)pplVar12 + -0x78) = 0x1a8dcc;
  memcpy(puVar3 + lVar2,puVar11,sVar10);
  puVar11 = mem;
  offset = 0x70;
  LVar1 = node1_local->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_001a8e95_caseD_20:
    size = 0x10;
  }
  else {
    if (LYS_ANYDATA < LVar1) goto switchD_001a8e95_caseD_3;
    if (LVar1 == LYS_ACTION) {
LAB_001a8f32:
      size = 8;
    }
    else {
      if (LYS_ACTION < LVar1) goto switchD_001a8e95_caseD_3;
      if (LVar1 != LYS_OUTPUT) {
        if (LYS_OUTPUT < LVar1) goto switchD_001a8e95_caseD_3;
        if (LVar1 != LYS_INPUT) {
          if (LYS_INPUT < LVar1) goto switchD_001a8e95_caseD_3;
          if (LVar1 != LYS_RPC) {
            if (LYS_RPC < LVar1) goto switchD_001a8e95_caseD_3;
            if (LVar1 == LYS_NOTIF) {
              size = 0x10;
            }
            else {
              if (LYS_NOTIF < LVar1) goto switchD_001a8e95_caseD_3;
              if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
                if ((LVar1 == LYS_UNKNOWN) || (false)) {
switchD_001a8e95_caseD_3:
                    // WARNING: Subroutine does not return
                  *(undefined8 *)((long)pplVar12 + -0x78) = 0x1a8f60;
                  __assert_fail("0",
                                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                                ,0xeab,"lys_node_switch");
                }
                switch(LVar1) {
                case LYS_CONTAINER:
                  size = 0x20;
                  break;
                case LYS_CHOICE:
                  size = 8;
                  break;
                default:
                  goto switchD_001a8e95_caseD_3;
                case LYS_LEAF:
                  size = 0x60;
                  break;
                case LYS_LEAFLIST:
                  size = 0x68;
                  break;
                case LYS_LIST:
                  size = 0x38;
                  break;
                case LYS_ANYXML:
                  goto switchD_001a8e95_caseD_20;
                }
              }
              else {
                if (LVar1 != LYS_CASE) goto switchD_001a8e95_caseD_3;
                size = 0;
              }
            }
            goto LAB_001a8f60;
          }
          goto LAB_001a8f32;
        }
      }
      size = 8;
    }
  }
LAB_001a8f60:
  sVar10 = size;
  if (mem_size < size) {
                    // WARNING: Subroutine does not return
    *(undefined8 *)((long)pplVar12 + -0x78) = 0x1a8f89;
    __assert_fail("size <= mem_size",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0xeaf,"lys_node_switch");
  }
  __src_00 = node1_local + 1;
  *(undefined8 *)((long)pplVar12 + -0x78) = 0x1a8fa8;
  memcpy(puVar11,__src_00,sVar10);
  sVar10 = size;
  lVar2 = offset - 0x1c;
  puVar3 = node2_local->padding;
  lVar4 = offset - 0x1c;
  puVar5 = node1_local->padding;
  *(undefined8 *)((long)pplVar12 + -0x78) = 0x1a8fcf;
  memcpy(puVar5 + lVar4,puVar3 + lVar2,sVar10);
  puVar11 = mem;
  sVar10 = size;
  lVar2 = offset - 0x1c;
  puVar3 = node2_local->padding;
  *(undefined8 *)((long)pplVar12 + -0x78) = 0x1a8fee;
  memcpy(puVar3 + lVar2,puVar11,sVar10);
  LVar1 = node1_local->nodetype;
  if (LVar1 == LYS_ACTION) {
LAB_001a911b:
    *(undefined2 *)(node1_local->padding + 2) = *(undefined2 *)(node2_local->padding + 2);
    node1_local[1].name = node2_local[1].name;
    *(undefined2 *)(node2_local->padding + 2) = 0;
    node2_local[1].name = (char *)0x0;
  }
  else {
    if (LYS_ACTION < LVar1) goto LAB_001a91e5;
    if (LVar1 != LYS_OUTPUT) {
      if (LYS_OUTPUT < LVar1) goto LAB_001a91e5;
      if (LVar1 != LYS_INPUT) {
        if (LYS_INPUT < LVar1) goto LAB_001a91e5;
        if (LVar1 != LYS_RPC) {
          if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
            if (LVar1 == LYS_NOTIF) {
              *(undefined2 *)(node1_local->padding + 2) = *(undefined2 *)(node2_local->padding + 2);
              node1_local[1].name = node2_local[1].name;
              *(undefined2 *)(node2_local->padding + 2) = 0;
              node2_local[1].name = (char *)0x0;
            }
            else if (LVar1 < (LYS_CONTAINER|LYS_NOTIF)) {
              if (LVar1 == LYS_LIST) {
                node1_local->padding[1] = node2_local->padding[1];
                node1_local[1].ref = node2_local[1].ref;
                node2_local->padding[1] = '\0';
                node2_local[1].ref = (char *)0x0;
              }
              else if (LVar1 < (LYS_CONTAINER|LYS_LIST)) {
                if (LVar1 != LYS_LEAFLIST) {
                  if (LYS_LEAFLIST < LVar1) goto LAB_001a91e5;
                  if (LVar1 == LYS_CONTAINER) {
                    *(undefined2 *)(node1_local->padding + 2) =
                         *(undefined2 *)(node2_local->padding + 2);
                    node1_local[1].ref = node2_local[1].ref;
                    *(undefined2 *)(node2_local->padding + 2) = 0;
                    node2_local[1].ref = (char *)0x0;
                    goto LAB_001a91e5;
                  }
                  if (LVar1 != LYS_LEAF) goto LAB_001a91e5;
                }
                node1_local[1].iffeature = (lys_iffeature *)node1_local;
                node2_local[1].iffeature = (lys_iffeature *)node2_local;
              }
            }
          }
          goto LAB_001a91e5;
        }
        goto LAB_001a911b;
      }
    }
    *(undefined2 *)(node1_local->padding + 2) = *(undefined2 *)(node2_local->padding + 2);
    uVar6 = node2_local->hash[1];
    uVar7 = node2_local->hash[2];
    uVar8 = node2_local->hash[3];
    uVar9 = *(undefined4 *)&node2_local->field_0x6c;
    node1_local->hash[0] = node2_local->hash[0];
    node1_local->hash[1] = uVar6;
    node1_local->hash[2] = uVar7;
    node1_local->hash[3] = uVar8;
    *(undefined4 *)&node1_local->field_0x6c = uVar9;
    *(undefined2 *)(node2_local->padding + 2) = 0;
    node2_local->hash[0] = '\0';
    node2_local->hash[1] = '\0';
    node2_local->hash[2] = '\0';
    node2_local->hash[3] = '\0';
    *(undefined4 *)&node2_local->field_0x6c = 0;
  }
LAB_001a91e5:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void lys_free(lys_module *module,_func_void_lys_node_ptr_void_ptr *private_destructor,int free_subs,
             int remove_from_ctx)

{
  ly_ctx *ctx_00;
  int remove_from_ctx_local;
  int free_subs_local;
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  lys_module *module_local;
  int i;
  ly_ctx *ctx;
  
  if (module != (lys_module *)0x0) {
    ctx_00 = module->ctx;
    if ((remove_from_ctx != 0) && ((ctx_00->models).used != 0)) {
      for (i = 0; i < (ctx_00->models).used; i = i + 1) {
        if (module == (ctx_00->models).list[i]) {
          (ctx_00->models).used = (ctx_00->models).used + -1;
          memmove((ctx_00->models).list + i,(ctx_00->models).list[(long)i + 1],
                  (long)((ctx_00->models).used - i) * 8);
          (ctx_00->models).list[(ctx_00->models).used] = (lys_module *)0x0;
          break;
        }
      }
    }
    module_free_common(module,private_destructor);
    for (i = 0; i < (int)(uint)module->inc_size; i = i + 1) {
      lydict_remove(ctx_00,module->inc[i].dsc);
      lydict_remove(ctx_00,module->inc[i].ref);
      lys_extension_instances_free
                (ctx_00,module->inc[i].ext,(uint)module->inc[i].ext_size,private_destructor);
      if (free_subs != 0) {
        lys_submodule_free(module->inc[i].submodule,private_destructor);
      }
    }
    free(module->inc);
    lydict_remove(ctx_00,module->ns);
    free(module);
  }
  return;
}



void lys_features_disable_recursive(lys_feature *f)

{
  lys_node *f_00;
  lys_feature *f_local;
  uint i;
  lys_feature *depf;
  
  f->flags = f->flags & 0xfeff;
  if (f->depfeatures != (ly_set *)0x0) {
    for (i = 0; i < f->depfeatures->number; i = i + 1) {
      f_00 = (f->depfeatures->set).s[i];
      if ((f_00->flags & 0x100) != 0) {
        lys_features_disable_recursive((lys_feature *)f_00);
      }
    }
  }
  return;
}



int lys_features_change(lys_module *module,char *name,int op)

{
  int iVar1;
  char *pcVar2;
  bool bVar3;
  int op_local;
  char *name_local;
  lys_module *module_local;
  uint8_t fsize;
  int all;
  int i;
  int j;
  int k;
  int progress;
  int faili;
  int failj;
  int failk;
  lys_feature *f;
  
  if (((module == (lys_module *)0x0) || (name == (char *)0x0)) || (*name == '\0')) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_features_change");
    iVar1 = 1;
  }
  else {
    iVar1 = strcmp(name,"*");
    bVar3 = iVar1 == 0;
    failk = 1;
    progress = 1;
    while ((progress != 0 && (failk != 0))) {
      progress = 0;
      failk = 0;
      for (i = -1; i < (int)(uint)module->inc_size; i = i + 1) {
        if (i == -1) {
          fsize = module->features_size;
          f = module->features;
        }
        else {
          fsize = (module->inc[i].submodule)->features_size;
          f = (module->inc[i].submodule)->features;
        }
        for (j = 0; j < (int)(uint)fsize; j = j + 1) {
          if ((bVar3) || (iVar1 = strcmp(f[j].name,name), iVar1 == 0)) {
            if (((op == 0) || ((f[j].flags & 0x100) == 0)) &&
               ((op != 0 || ((f[j].flags & 0x100) != 0)))) {
              if (op == 0) {
                lys_features_disable_recursive(f + j);
                progress = progress + 1;
              }
              else {
                for (k = 0; k < (int)(uint)f[j].iffeature_size; k = k + 1) {
                  iVar1 = resolve_iffeature(f[j].iffeature + k);
                  if (iVar1 == 0) {
                    if (!bVar3) {
                      ly_log(module->ctx,LY_LLERR,LY_EINVAL,
                             "Feature \"%s\" is disabled by its %d. if-feature condition.",f[j].name
                             ,(ulong)(k + 1));
                      return 1;
                    }
                    faili = i;
                    failj = j;
                    failk = k + 1;
                    break;
                  }
                }
                if (k == (uint)f[j].iffeature_size) {
                  f[j].flags = f[j].flags | 0x100;
                  progress = progress + 1;
                }
              }
              if (!bVar3) {
                return 0;
              }
            }
            else if (!bVar3) {
              return 0;
            }
          }
        }
      }
    }
    if (failk == 0) {
      if (bVar3) {
        iVar1 = 0;
      }
      else {
        iVar1 = 1;
      }
    }
    else {
      if (faili == -1) {
        pcVar2 = module->features[failj].name;
      }
      else {
        pcVar2 = (module->inc[faili].submodule)->features[failj].name;
      }
      ly_log(module->ctx,LY_LLERR,LY_EINVAL,
             "Feature \"%s\" is disabled by its %d. if-feature condition.",pcVar2,(ulong)(uint)failk
            );
      iVar1 = 1;
    }
  }
  return iVar1;
}



int lys_features_enable(lys_module *module,char *feature)

{
  int iVar1;
  char *feature_local;
  lys_module *module_local;
  
  ly_log_dbg(0x20,"%s","lys_features_enable");
  iVar1 = lys_features_change(module,feature,1);
  return iVar1;
}



int lys_features_disable(lys_module *module,char *feature)

{
  int iVar1;
  char *feature_local;
  lys_module *module_local;
  
  ly_log_dbg(0x20,"%s","lys_features_disable");
  iVar1 = lys_features_change(module,feature,0);
  return iVar1;
}



int lys_features_state(lys_module *module,char *feature)

{
  int iVar1;
  char *feature_local;
  lys_module *module_local;
  int i;
  int j;
  
  ly_log_dbg(0x20,"%s","lys_features_state");
  if ((module != (lys_module *)0x0) && (feature != (char *)0x0)) {
    for (i = 0; i < (int)(uint)module->features_size; i = i + 1) {
      iVar1 = strcmp(feature,module->features[i].name);
      if (iVar1 == 0) {
        if ((module->features[i].flags & 0x100) == 0) {
          return 0;
        }
        return 1;
      }
    }
    for (j = 0; j < (int)(uint)module->inc_size; j = j + 1) {
      for (i = 0; i < (int)(uint)(module->inc[j].submodule)->features_size; i = i + 1) {
        iVar1 = strcmp(feature,(module->inc[j].submodule)->features[i].name);
        if (iVar1 == 0) {
          if (((module->inc[j].submodule)->features[i].flags & 0x100) == 0) {
            return 0;
          }
          return 1;
        }
      }
    }
  }
  return -1;
}



char ** lys_features_list(lys_module *module,uint8_t **states)

{
  char **__ptr;
  uint8_t *puVar1;
  uint8_t **states_local;
  lys_module *module_local;
  int i;
  int j;
  uint count;
  char **result;
  
  ly_log_dbg(0x20,"%s","lys_features_list");
  if (module == (lys_module *)0x0) {
    __ptr = (char **)0x0;
  }
  else {
    count = (uint)module->features_size;
    for (i = 0; i < (int)(uint)module->inc_size; i = i + 1) {
      count = count + (module->inc[i].submodule)->features_size;
    }
    __ptr = (char **)malloc((ulong)(count + 1) << 3);
    if (__ptr == (char **)0x0) {
      ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_features_list");
      __ptr = (char **)0x0;
    }
    else {
      if (states != (uint8_t **)0x0) {
        puVar1 = (uint8_t *)malloc((ulong)(count + 1));
        *states = puVar1;
        if (*states == (uint8_t *)0x0) {
          ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_features_list"
                );
          free(__ptr);
          return (char **)0x0;
        }
      }
      count = 0;
      for (i = 0; i < (int)(uint)module->features_size; i = i + 1) {
        __ptr[count] = module->features[i].name;
        if (states != (uint8_t **)0x0) {
          if ((module->features[i].flags & 0x100) == 0) {
            (*states)[count] = '\0';
          }
          else {
            (*states)[count] = '\x01';
          }
        }
        count = count + 1;
      }
      for (j = 0; j < (int)(uint)module->inc_size; j = j + 1) {
        for (i = 0; i < (int)(uint)(module->inc[j].submodule)->features_size; i = i + 1) {
          __ptr[count] = (module->inc[j].submodule)->features[i].name;
          if (states != (uint8_t **)0x0) {
            if (((module->inc[j].submodule)->features[i].flags & 0x100) == 0) {
              (*states)[count] = '\0';
            }
            else {
              (*states)[count] = '\x01';
            }
          }
          count = count + 1;
        }
      }
      __ptr[count] = (char *)0x0;
    }
  }
  return __ptr;
}



lys_module * lys_node_module(lys_node *node)

{
  lys_module *plVar1;
  lys_node *node_local;
  
  ly_log_dbg(0x20,"%s","lys_node_module");
  if (node == (lys_node *)0x0) {
    plVar1 = (lys_module *)0x0;
  }
  else if ((node->module->field_0x40 & 1) == 0) {
    plVar1 = node->module;
  }
  else {
    plVar1 = (lys_module *)node->module->data;
  }
  return plVar1;
}



lys_module * lys_main_module(lys_module *module)

{
  lys_module *module_local;
  
  ly_log_dbg(0x20,"%s","lys_main_module");
  if (module == (lys_module *)0x0) {
    module = (lys_module *)0x0;
  }
  else if ((module->field_0x40 & 1) != 0) {
    module = (lys_module *)module->data;
  }
  return module;
}



lys_node * lys_parent(lys_node *node)

{
  lys_node *node_local;
  lys_node *parent;
  
  ly_log_dbg(0x20,"%s","lys_parent");
  if (node == (lys_node *)0x0) {
    parent = (lys_node *)0x0;
  }
  else {
    if (node->nodetype == LYS_EXT) {
      if (node->padding[1] != '\x01') {
        return (lys_node *)0x0;
      }
      parent = (lys_node *)node->dsc;
    }
    else {
      if (node->parent == (lys_node *)0x0) {
        return (lys_node *)0x0;
      }
      parent = node->parent;
    }
    if (parent->nodetype == LYS_AUGMENT) {
      parent = parent->prev;
    }
  }
  return parent;
}



lys_node ** lys_child(lys_node *node,LYS_NODE nodetype)

{
  LY_STMT stmt;
  lys_node **pplVar1;
  LYS_NODE nodetype_local;
  lys_node *node_local;
  void *pp;
  
  if (node != (lys_node *)0x0) {
    if (node->nodetype == LYS_EXT) {
      stmt = lys_snode2stmt(nodetype);
      pplVar1 = (lys_node **)
                lys_ext_complex_get_substmt
                          (stmt,(lys_ext_instance_complex *)node,(lyext_substmt **)0x0);
      if (pplVar1 == (lys_node **)0x0) {
        pplVar1 = (lys_node **)0x0;
      }
    }
    else if ((node->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
      pplVar1 = &node->child;
    }
    else {
      pplVar1 = (lys_node **)0x0;
    }
    return pplVar1;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("node",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                ,0x102f,"lys_child");
}



void * lys_set_private(lys_node *node,void *priv)

{
  void *pvVar1;
  void *priv_local;
  lys_node *node_local;
  void *prev;
  
  ly_log_dbg(0x20,"%s","lys_set_private");
  if (node == (lys_node *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_set_private");
    pvVar1 = (void *)0x0;
  }
  else {
    pvVar1 = node->priv;
    node->priv = priv;
  }
  return pvVar1;
}



int lys_leaf_add_leafref_target(lys_node_leaf *leafref_target,lys_node *leafref)

{
  ly_ctx *ctx_00;
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  ly_set *plVar4;
  lys_node *leafref_local;
  lys_node_leaf *leafref_target_local;
  lys_node_leaf *iter;
  ly_ctx *ctx;
  
  ctx_00 = leafref_target->module->ctx;
  if ((leafref_target->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
    ly_log(ctx_00,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
           ,0x1057);
    iVar1 = -1;
  }
  else {
    iter = leafref_target;
    if (((*(char *)&leafref[1].parent == -1) || ((leafref->flags & 1) == 0)) ||
       ((leafref_target->flags & 2) == 0)) {
      for (; (iter != (lys_node_leaf *)0x0 && ((iter->type).base == LY_TYPE_LEAFREF));
          iter = (iter->type).info.lref.target) {
        if (iter == (lys_node_leaf *)leafref) {
          ly_vlog(ctx_00,LYE_CIRC_LEAFREFS,LY_VLOG_LYS,leafref);
          return -1;
        }
      }
      if (leafref_target->backlinks == (ly_set *)0x0) {
        plVar4 = ly_set_new();
        leafref_target->backlinks = plVar4;
        if (leafref_target->backlinks == (ly_set *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "lys_leaf_add_leafref_target");
          return -1;
        }
      }
      ly_set_add(leafref_target->backlinks,leafref,0);
      iVar1 = 0;
    }
    else {
      pcVar2 = strnodetype(leafref_target->nodetype);
      pcVar3 = strnodetype(leafref->nodetype);
      ly_vlog(ctx_00,LYE_SPEC,LY_VLOG_LYS,leafref,
              "The leafref %s is config but refers to a non-config %s.",pcVar3,pcVar2);
      iVar1 = -1;
    }
  }
  return iVar1;
}



ly_set * lys_xpath_atomize(lys_node *ctx_node,lyxp_node_type ctx_node_type,char *expr,int options)

{
  long lVar1;
  int iVar2;
  ly_set *set_00;
  lys_module *module;
  long in_FS_OFFSET;
  char *expr_local;
  int options_local;
  lyxp_node_type ctx_node_type_local;
  lys_node *ctx_node_local;
  uint32_t i;
  lys_node *parent;
  ly_set *ret_set;
  lyxp_set set;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lys_xpath_atomize");
  if ((ctx_node == (lys_node *)0x0) || (expr == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_xpath_atomize");
    set_00 = (ly_set *)0x0;
  }
  else {
    ctx_node_local = ctx_node;
    if ((ctx_node_type == LYXP_NODE_ROOT) || (ctx_node_type == LYXP_NODE_ROOT_CONFIG)) {
      do {
        module = lys_node_module(ctx_node_local);
        ctx_node_local = lys_getnext((lys_node *)0x0,(lys_node *)0x0,module,0x100);
        if (ctx_node_type != LYXP_NODE_ROOT_CONFIG) break;
      } while ((ctx_node_local->flags & 2) != 0);
    }
    memset(&set,0,0x40);
    for (parent = ctx_node_local; (parent != (lys_node *)0x0 && (parent->nodetype != LYS_OUTPUT));
        parent = lys_parent(parent)) {
    }
    if (parent == (lys_node *)0x0) {
      if ((options & 1U) == 0) {
        if ((options & 2U) == 0) {
          options_local = options | 4;
        }
        else {
          options_local = options & 0xfffffffdU | 0x10;
        }
      }
      else {
        options_local = options & 0xfffffffeU | 8;
      }
    }
    else {
      options_local = options & 0xfffffffcU | 0x20;
    }
    iVar2 = lyxp_atomize(expr,ctx_node_local,ctx_node_type,&set,options_local,(lys_node **)0x0);
    if (iVar2 == 0) {
      set_00 = ly_set_new();
      for (i = 0; i < set.used; i = i + 1) {
        if ((set.val.nodes[i].type == LYXP_NODE_ELEM) &&
           (iVar2 = ly_set_add(set_00,set.val.nodes[i].node,1), iVar2 == -1)) {
          ly_set_free(set_00);
          free(set.val.nodes);
          set_00 = (ly_set *)0x0;
          goto LAB_001aa5b9;
        }
      }
      free(set.val.nodes);
    }
    else {
      free(set.val.nodes);
      ly_vlog(ctx_node_local->module->ctx,LYE_SPEC,LY_VLOG_LYS,ctx_node_local,
              "Resolving XPath expression \"%s\" failed.",expr);
      set_00 = (ly_set *)0x0;
    }
  }
LAB_001aa5b9:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return set_00;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ly_set * lys_node_xpath_atomize(lys_node *node,int options)

{
  long lVar1;
  int iVar2;
  ly_set *set_00;
  lys_node *plVar3;
  lys_node *plVar4;
  long in_FS_OFFSET;
  int options_local;
  lys_node *node_local;
  uint16_t i;
  lys_node *next;
  lys_node *elem;
  lys_node *parent;
  lys_node *tmp;
  ly_set *ret_set;
  lyxp_set set;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lys_node_xpath_atomize");
  parent = node;
  if (node == (lys_node *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_node_xpath_atomize");
    set_00 = (ly_set *)0x0;
  }
  else {
    for (; (parent != (lys_node *)0x0 && ((parent->nodetype & 0x680) == LYS_UNKNOWN));
        parent = lys_parent(parent)) {
    }
    if (parent == (lys_node *)0x0) {
      set_00 = (ly_set *)0x0;
    }
    else {
      set_00 = ly_set_new();
      elem = node;
      if (set_00 == (ly_set *)0x0) {
        set_00 = (ly_set *)0x0;
      }
      else {
        while (elem != (lys_node *)0x0) {
          if (((options & 2U) == 0) || ((elem->flags & 0x600) != 0)) {
            iVar2 = lyxp_node_atomize(elem,&set,0);
            if (iVar2 != 0) {
              ly_set_free(set_00);
              free(set.val.nodes);
              set_00 = (ly_set *)0x0;
              break;
            }
            for (i = 0; i < set.used; i = i + 1) {
              if (set.val.nodes[i].type == LYXP_NODE_ELEM) {
                if ((options & 2U) != 0) {
                  for (tmp = (lys_node *)set.val.nodes[i].node;
                      (tmp != (lys_node *)0x0 && (tmp != parent)); tmp = lys_parent(tmp)) {
                  }
                  if (tmp != (lys_node *)0x0) goto LAB_001aa806;
                }
                iVar2 = ly_set_add(set_00,set.val.nodes[i].node,0);
                if (iVar2 == -1) {
                  ly_set_free(set_00);
                  free(set.val.nodes);
                  set_00 = (ly_set *)0x0;
                  goto LAB_001aa92b;
                }
              }
LAB_001aa806:
            }
            free(set.val.nodes);
            if ((options & 1U) == 0) break;
          }
          if ((elem->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
            next = elem->child;
          }
          else {
            next = (lys_node *)0x0;
          }
          if (next == (lys_node *)0x0) {
            if (elem == node) break;
            next = elem->next;
          }
          while (next == (lys_node *)0x0) {
            if (elem->parent->nodetype == LYS_AUGMENT) {
              elem = elem->parent->prev;
            }
            else {
              elem = elem->parent;
            }
            plVar3 = lys_parent(elem);
            plVar4 = lys_parent(node);
            if (plVar3 == plVar4) break;
            next = elem->next;
          }
          elem = next;
        }
      }
    }
  }
LAB_001aa92b:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return set_00;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int apply_aug(lys_node_augment *augment,unres_schema *unres)

{
  lys_ext_instance *plVar1;
  int iVar2;
  char **item;
  lys_module *plVar3;
  lys_node *plVar4;
  lys_node *plVar5;
  unres_schema *unres_local;
  lys_node_augment *augment_local;
  uint u;
  int clear_config;
  lys_node *child;
  lys_node *parent;
  lys_type *type;
  lys_module *mod;
  lys_ext_instance *ext;
  uint8_t *v;
  
  if ((augment->target == (lys_node *)0x0) || ((augment->flags & 1) == 0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("augment->target && (augment->flags & LYS_NOTAPPLIED)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x1146,"apply_aug");
  }
  if (augment->child != (lys_node *)0x0) {
    for (parent = augment->target;
        (parent != (lys_node *)0x0 && ((parent->nodetype & 0x780) == LYS_UNKNOWN));
        parent = lys_parent(parent)) {
    }
    for (child = augment->child; child != (lys_node *)0x0; child = child->next) {
      iVar2 = inherit_config_flag(child,augment->target->flags & 3,(uint)(parent != (lys_node *)0x0)
                                 );
      if (iVar2 != 0) {
        return -1;
      }
    }
    for (u = 0; child = (lys_node *)augment, u < augment->target->ext_size; u = u + 1) {
      plVar1 = augment->target->ext[u];
      if (((plVar1 != (lys_ext_instance *)0x0) && (plVar1->def->plugin != (lyext_plugin *)0x0)) &&
         ((plVar1->def->plugin->flags & 1) != 0)) {
        plVar4 = (lys_node *)malloc(1);
        if (plVar4 == (lys_node *)0x0) {
          ly_log(augment->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "apply_aug");
          return -1;
        }
        *(char *)&plVar4->name = (char)u;
        plVar5 = augment->target;
        plVar3 = lys_main_module(augment->module);
        iVar2 = unres_schema_add_node(plVar3,unres,&plVar5->ext,UNRES_EXT_FINALIZE,plVar4);
        if (iVar2 == -1) {
          return -1;
        }
      }
    }
    while (child != (lys_node *)0x0) {
      if (((child->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) &&
         (item = &child[1].ref, *(int *)item == 9)) {
        if (*(long *)&child[1].nodetype == 0) {
          iVar2 = unres_schema_find(unres,-1,item,UNRES_TYPE_LEAFREF);
          if (-1 < iVar2) {
            plVar3 = lys_node_module(child);
            iVar2 = unres_schema_add_node(plVar3,unres,item,UNRES_TYPE_LEAFREF,child);
            if (iVar2 == -1) {
              return -1;
            }
          }
        }
        else {
          plVar3 = lys_node_module(*(lys_node **)&child[1].nodetype);
          if ((plVar3->field_0x40 & 0x80) == 0) {
            plVar3->field_0x40 = plVar3->field_0x40 | 0x80;
            iVar2 = unres_schema_add_node
                              (plVar3,unres,(void *)0x0,UNRES_MOD_IMPLEMENT,(lys_node *)0x0);
            if (iVar2 == -1) {
              return -1;
            }
          }
        }
      }
      if ((child->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
        parent = child->child;
      }
      else {
        parent = (lys_node *)0x0;
      }
      if (parent == (lys_node *)0x0) {
        if (child == (lys_node *)augment) break;
        parent = child->next;
      }
      while (parent == (lys_node *)0x0) {
        if (child->parent->nodetype == LYS_AUGMENT) {
          child = child->parent->prev;
        }
        else {
          child = child->parent;
        }
        plVar4 = lys_parent(child);
        plVar5 = lys_parent((lys_node *)augment);
        if (plVar4 == plVar5) break;
        parent = child->next;
      }
      child = parent;
    }
    if (augment->target->child == (lys_node *)0x0) {
      augment->target->child = augment->child;
    }
    else {
      plVar4 = augment->target->child->prev;
      plVar4->next = augment->child;
      augment->target->child->prev = augment->child->prev;
      augment->child->prev = plVar4;
    }
  }
  augment->flags = augment->flags & 0xfffe;
  return 0;
}



void remove_aug(lys_node_augment *augment)

{
  lys_node *plVar1;
  lys_node_augment *augment_local;
  lys_node *last;
  lys_node *elem;
  
  if (((augment->flags & 1) == 0) && (augment->target != (lys_node *)0x0)) {
    plVar1 = augment->child;
    last = plVar1;
    if (plVar1 != (lys_node *)0x0) {
      while (((last != (lys_node *)0x0 && (last->next != (lys_node *)0x0)) &&
             ((lys_node *)augment == last->next->parent))) {
        last = last->next;
      }
      if (plVar1 == augment->target->child) {
        augment->target->child = last->next;
      }
      if (plVar1->prev->next != (lys_node *)0x0) {
        plVar1->prev->next = last->next;
      }
      if (last->next == (lys_node *)0x0) {
        if (augment->target->child != (lys_node *)0x0) {
          augment->target->child->prev = plVar1->prev;
        }
      }
      else {
        last->next->prev = plVar1->prev;
      }
      plVar1->prev = last;
      last->next = (lys_node *)0x0;
    }
    augment->flags = augment->flags | 1;
  }
  return;
}



void lys_switch_deviation(lys_deviation *dev,lys_module *module,unres_schema *unres)

{
  lys_node *child;
  int iVar1;
  LYS_NODE LVar2;
  char *pcVar3;
  lys_module *plVar4;
  long in_FS_OFFSET;
  bool bVar5;
  unres_schema *unres_local;
  lys_module *module_local;
  lys_deviation *dev_local;
  int reapply;
  int ret;
  ly_set *set;
  lys_node *target;
  lys_node *parent;
  lys_node_inout *inout;
  char *parent_path;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  target = (lys_node *)0x0;
  if (dev->deviate != (lys_deviate *)0x0) {
    if (dev->deviate->mod == LY_DEVIATE_NO) {
      if (dev->orig_node == (lys_node *)0x0) {
        iVar1 = resolve_schema_nodeid(dev->target_name,(lys_node *)0x0,module,&set,0,1);
        if (iVar1 == -1) {
          ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                 ,0x1208);
          ly_set_free(set);
        }
        else {
          target = *(set->set).s;
          ly_set_free(set);
          parent = target->parent;
          lys_node_unlink(target);
          if (parent != (lys_node *)0x0) {
            if ((parent->nodetype & 0x3000) == LYS_UNKNOWN) {
              if ((parent->nodetype & 0x4100) != LYS_UNKNOWN) {
                inout = (lys_node_inout *)calloc(1,0x78);
                if (inout == (lys_node_inout *)0x0) {
                  ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                         "lys_switch_deviation");
                  goto LAB_001ab4f2;
                }
                inout->nodetype = target->nodetype;
                if (inout->nodetype == LYS_INPUT) {
                  pcVar3 = "input";
                }
                else {
                  pcVar3 = "output";
                }
                pcVar3 = lydict_insert(module->ctx,pcVar3,0);
                inout->name = pcVar3;
                inout->module = target->module;
                inout->flags = 0x40;
                if ((parent->child == (lys_node *)0x0) || (parent->child->next != (lys_node *)0x0))
                {
LAB_001ab3e0:
                    // WARNING: Subroutine does not return
                  __assert_fail("parent->child && !parent->child->next && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUTPUT : LYS_INPUT))"
                                ,
                                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                                ,0x1224,"lys_switch_deviation");
                }
                if (inout->nodetype == LYS_INPUT) {
                  LVar2 = LYS_OUTPUT;
                }
                else {
                  LVar2 = LYS_INPUT;
                }
                if (LVar2 != parent->child->nodetype) goto LAB_001ab3e0;
                parent->child->next = (lys_node *)inout;
                inout->prev = parent->child;
                parent->child->prev = (lys_node *)inout;
                inout->parent = parent;
              }
            }
            else {
              target->parent = parent;
            }
          }
          dev->orig_node = target;
        }
      }
      else {
        pcVar3 = strrchr(dev->target_name,0x2f);
        if (pcVar3 == dev->target_name) {
          child = dev->orig_node;
          plVar4 = lys_node_module(dev->orig_node);
          lys_node_addchild((lys_node *)0x0,plVar4,child,0);
        }
        else {
          parent = dev->orig_node->parent;
          if ((parent == (lys_node *)0x0) || (parent->nodetype != LYS_AUGMENT)) {
            if ((parent == (lys_node *)0x0) || (parent->nodetype != LYS_USES)) {
              pcVar3 = strrchr(dev->target_name,0x2f);
              parent_path = strndup(dev->target_name,(long)pcVar3 - (long)dev->target_name);
              iVar1 = resolve_schema_nodeid(parent_path,(lys_node *)0x0,module,&set,0,1);
              free(parent_path);
              if (iVar1 == -1) {
                ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                       "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                       ,0x11f5);
                ly_set_free(set);
                goto LAB_001ab4f2;
              }
              target = *(set->set).s;
              ly_set_free(set);
              lys_node_addchild(target,(lys_module *)0x0,dev->orig_node,0);
            }
            else {
              lys_node_addchild(parent,(lys_module *)0x0,dev->orig_node,0);
            }
          }
          else {
            dev->orig_node->parent = (lys_node *)0x0;
            bVar5 = (parent->flags & 1) == 0;
            if (bVar5) {
              remove_aug((lys_node_augment *)parent);
            }
            lys_node_addchild(parent,(lys_module *)0x0,dev->orig_node,0);
            if (bVar5) {
              plVar4 = lys_node_module(parent);
              if ((plVar4->field_0x40 & 0x80) == 0) {
                    // WARNING: Subroutine does not return
                __assert_fail("lys_node_module(parent)->implemented",
                              "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                              ,0x11e8,"lys_switch_deviation");
              }
              parent->flags = parent->flags | 1;
              apply_aug((lys_node_augment *)parent,unres);
            }
          }
        }
        dev->orig_node = (lys_node *)0x0;
      }
    }
    else {
      iVar1 = resolve_schema_nodeid(dev->target_name,(lys_node *)0x0,module,&set,0,1);
      if (iVar1 == -1) {
        ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
               ,0x1231);
        ly_set_free(set);
      }
      else {
        target = *(set->set).s;
        ly_set_free(set);
        lys_node_switch(target,dev->orig_node);
      }
    }
  }
LAB_001ab4f2:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void lys_enable_deviations(lys_module *module)

{
  lys_submodule *plVar1;
  size_t sVar2;
  long in_FS_OFFSET;
  lys_module *module_local;
  uint32_t i;
  uint32_t j;
  unres_schema *unres;
  lys_module *mod;
  char *ptr;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  i = 0;
  if ((module->field_0x40 & 0x30) != 0) {
    unres = (unres_schema *)calloc(1,0x28);
    if (unres == (unres_schema *)0x0) {
      ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_enable_deviations"
            );
    }
    else {
      while (mod = ly_ctx_get_module_iter(module->ctx,&i), mod != (lys_module *)0x0) {
        if (mod != module) {
          for (j = 0; j < mod->deviation_size; j = j + 1) {
            ptr = strstr(mod->deviation[j].target_name,module->name);
            if ((ptr != (char *)0x0) && (sVar2 = strlen(module->name), ptr[sVar2] == ':')) {
              lys_switch_deviation(mod->deviation + j,mod,unres);
            }
          }
        }
      }
      if ((module->field_0x40 & 0x30) != 0x20) {
                    // WARNING: Subroutine does not return
        __assert_fail("module->deviated == 2",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                      ,0x1257,"lys_enable_deviations");
      }
      module->field_0x40 = module->field_0x40 & 0xcf | 0x10;
      for (j = 0; j < module->inc_size; j = j + 1) {
        if (((module->inc[j].submodule)->field_0x40 & 0x30) != 0) {
          plVar1 = module->inc[j].submodule;
          plVar1->field_0x40 =
               plVar1->field_0x40 & 0xcf | (byte)(((byte)module->field_0x40 >> 4 & 3) << 4);
        }
      }
      if (unres->count != 0) {
        resolve_unres_schema(module,unres);
      }
      unres_schema_free(module,&unres,1);
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void lys_disable_deviations(lys_module *module)

{
  uint uVar1;
  lys_submodule *plVar2;
  size_t sVar3;
  long in_FS_OFFSET;
  lys_module *module_local;
  uint32_t i;
  uint32_t j;
  unres_schema *unres;
  lys_module *mod;
  char *ptr;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((module->field_0x40 & 0x30) != 0) {
    unres = (unres_schema *)calloc(1,0x28);
    if (unres == (unres_schema *)0x0) {
      ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
             "lys_disable_deviations");
    }
    else {
      i = (module->ctx->models).used;
      while (uVar1 = i - 1, i != 0) {
        mod = (module->ctx->models).list[uVar1];
        i = uVar1;
        if (mod != module) {
          j = (uint)mod->deviation_size;
          while (uVar1 = j - 1, j != 0) {
            ptr = strstr(mod->deviation[uVar1].target_name,module->name);
            j = uVar1;
            if ((ptr != (char *)0x0) && (sVar3 = strlen(module->name), ptr[sVar3] == ':')) {
              lys_switch_deviation(mod->deviation + uVar1,mod,unres);
            }
          }
        }
      }
      if ((module->field_0x40 & 0x30) != 0x10) {
                    // WARNING: Subroutine does not return
        __assert_fail("module->deviated == 1",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                      ,0x1284,"lys_disable_deviations");
      }
      module->field_0x40 = module->field_0x40 & 0xcf | 0x20;
      for (j = 0; j < module->inc_size; j = j + 1) {
        if (((module->inc[j].submodule)->field_0x40 & 0x30) != 0) {
          plVar2 = module->inc[j].submodule;
          plVar2->field_0x40 =
               plVar2->field_0x40 & 0xcf | (byte)(((byte)module->field_0x40 >> 4 & 3) << 4);
        }
      }
      if (unres->count != 0) {
        resolve_unres_schema(module,unres);
      }
      unres_schema_free(module,&unres,1);
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void apply_dev(lys_deviation *dev,lys_module *module,unres_schema *unres)

{
  lys_module *plVar1;
  unres_schema *unres_local;
  lys_module *module_local;
  lys_deviation *dev_local;
  
  lys_switch_deviation(dev,module,unres);
  if (dev->orig_node == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("dev->orig_node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x1299,"apply_dev");
  }
  plVar1 = lys_node_module(dev->orig_node);
  plVar1->field_0x40 = plVar1->field_0x40 & 0xcf | 0x10;
  plVar1 = dev->orig_node->module;
  plVar1->field_0x40 = plVar1->field_0x40 & 0xcf | 0x10;
  return;
}



void remove_dev(lys_deviation *dev,lys_module *module,unres_schema *unres)

{
  size_t sVar1;
  long in_FS_OFFSET;
  unres_schema *unres_local;
  lys_module *module_local;
  lys_deviation *dev_local;
  uint32_t idx;
  uint32_t j;
  lys_module *target_mod;
  lys_module *target_submod;
  lys_module *mod;
  char *ptr;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  idx = 0;
  if (dev->orig_node == (lys_node *)0x0) {
    ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
           ,0x12aa);
  }
  else {
    target_mod = lys_node_module(dev->orig_node);
    target_submod = dev->orig_node->module;
    lys_switch_deviation(dev,module,unres);
    do {
      do {
        mod = ly_ctx_get_module_iter(module->ctx,&idx);
        if (mod == (lys_module *)0x0) goto LAB_001abc3d;
      } while ((mod == module) || (mod == target_mod));
      j = 0;
      while ((j < mod->deviation_size &&
             ((ptr = strstr(mod->deviation[j].target_name,target_mod->name), ptr == (char *)0x0 ||
              (sVar1 = strlen(target_mod->name), ptr[sVar1] != ':'))))) {
        j = j + 1;
      }
    } while (mod->deviation_size <= j);
LAB_001abc3d:
    if (mod == (lys_module *)0x0) {
      target_mod->field_0x40 = target_mod->field_0x40 & 0xcf;
      target_submod->field_0x40 = target_submod->field_0x40 & 0xcf;
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void lys_sub_module_apply_devs_augs(lys_module *module)

{
  long in_FS_OFFSET;
  lys_module *module_local;
  uint8_t u;
  uint8_t v;
  unres_schema *unres;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((module->field_0x40 & 0x80) == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("module->implemented",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x12ce,"lys_sub_module_apply_devs_augs");
  }
  unres = (unres_schema *)calloc(1,0x28);
  if (unres == (unres_schema *)0x0) {
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
           "lys_sub_module_apply_devs_augs");
  }
  else {
    for (u = '\0'; u < module->deviation_size; u = u + '\x01') {
      apply_dev(module->deviation + u,module,unres);
    }
    for (u = '\0'; u < module->augment_size; u = u + '\x01') {
      apply_aug(module->augment + u,unres);
    }
    for (v = '\0'; v < module->inc_size; v = v + '\x01') {
      for (u = '\0'; u < (module->inc[v].submodule)->deviation_size; u = u + '\x01') {
        apply_dev((module->inc[v].submodule)->deviation + u,module,unres);
      }
      for (u = '\0'; u < (module->inc[v].submodule)->augment_size; u = u + '\x01') {
        apply_aug((module->inc[v].submodule)->augment + u,unres);
      }
    }
    if (unres->count != 0) {
      resolve_unres_schema(module,unres);
    }
    unres_schema_free(module,&unres,1);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void lys_sub_module_remove_devs_augs(lys_module *module)

{
  long in_FS_OFFSET;
  lys_module *module_local;
  uint8_t u;
  uint8_t v;
  uint8_t w;
  unres_schema *unres;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  unres = (unres_schema *)calloc(1,0x28);
  if (unres == (unres_schema *)0x0) {
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
           "lys_sub_module_remove_devs_augs");
  }
  else {
    for (u = '\0'; u < module->deviation_size; u = u + '\x01') {
      if (module->deviation[u].orig_node != (lys_node *)0x0) {
        remove_dev(module->deviation + u,module,unres);
      }
      for (v = '\0'; v < module->deviation[u].deviate_size; v = v + '\x01') {
        if (module->deviation[u].deviate[v].mod == LY_DEVIATE_ADD) {
          free(module->deviation[u].deviate[v].must);
        }
      }
    }
    for (u = '\0'; u < module->augment_size; u = u + '\x01') {
      remove_aug(module->augment + u);
    }
    v = '\0';
    while ((v < module->inc_size && (module->inc[v].submodule != (lys_submodule *)0x0))) {
      for (u = '\0'; u < (module->inc[v].submodule)->deviation_size; u = u + '\x01') {
        if ((module->inc[v].submodule)->deviation[u].orig_node != (lys_node *)0x0) {
          remove_dev((module->inc[v].submodule)->deviation + u,module,unres);
        }
        for (w = '\0'; w < (module->inc[v].submodule)->deviation[u].deviate_size; w = w + '\x01') {
          if ((module->inc[v].submodule)->deviation[u].deviate[w].mod == LY_DEVIATE_ADD) {
            free((module->inc[v].submodule)->deviation[u].deviate[w].must);
          }
        }
      }
      for (u = '\0'; u < (module->inc[v].submodule)->augment_size; u = u + '\x01') {
        remove_aug((module->inc[v].submodule)->augment + u);
      }
      v = v + '\x01';
    }
    if (unres->count != 0) {
      resolve_unres_schema(module,unres);
    }
    unres_schema_free(module,&unres,1);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int lys_make_implemented_r(lys_module *module,unres_schema *unres)

{
  ly_ctx *ctx_00;
  lys_submodule *plVar1;
  int iVar2;
  lys_module *plVar3;
  lys_node *plVar4;
  lys_node *plVar5;
  unres_schema *unres_local;
  lys_module *module_local;
  uint16_t i;
  uint16_t j;
  uint16_t k;
  lys_node *root;
  lys_node *next;
  lys_node *node;
  ly_ctx *ctx;
  lys_module *target_module;
  
  if ((module->field_0x40 & 0x80) == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("module->implemented",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                  ,0x132f,"lys_make_implemented_r");
  }
  ctx_00 = module->ctx;
  for (i = 0; (int)(uint)i < (ctx_00->models).used; i = i + 1) {
    if (((module != (ctx_00->models).list[i]) &&
        (iVar2 = strcmp(module->name,(ctx_00->models).list[i]->name), iVar2 == 0)) &&
       (((ctx_00->models).list[i]->field_0x40 & 0x80) != 0)) {
      ly_log(ctx_00,LY_LLERR,LY_EINVAL,"Module \"%s\" in another revision already implemented.",
             module->name);
      return 1;
    }
  }
  for (i = 0; i < module->augment_size; i = i + 1) {
    if (module->augment[i].target == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("module->augment[i].target",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                    ,0x1340,"lys_make_implemented_r");
    }
    plVar3 = lys_node_module(module->augment[i].target);
    if ((plVar3->field_0x40 & 0x80) == 0) {
      plVar3->field_0x40 = plVar3->field_0x40 | 0x80;
      iVar2 = unres_schema_add_node(plVar3,unres,(void *)0x0,UNRES_MOD_IMPLEMENT,(lys_node *)0x0);
      if (iVar2 == -1) {
        return -1;
      }
    }
    if (((module->augment[i].flags & 1) != 0) &&
       (iVar2 = apply_aug(module->augment + i,unres), iVar2 != 0)) {
      return -1;
    }
  }
  for (i = 0; i < module->ident_size; i = i + 1) {
    for (j = 0; j < module->ident[i].base_size; j = j + 1) {
      resolve_identity_backlink_update(module->ident + i,module->ident[i].base[j]);
    }
  }
  i = 0;
  while ((i < module->inc_size && (module->inc[i].submodule != (lys_submodule *)0x0))) {
    plVar1 = module->inc[i].submodule;
    plVar1->field_0x40 = plVar1->field_0x40 | 0x80;
    for (j = 0; j < (module->inc[i].submodule)->augment_size; j = j + 1) {
      if ((module->inc[i].submodule)->augment[j].target == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("module->inc[i].submodule->augment[j].target",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                      ,0x135d,"lys_make_implemented_r");
      }
      plVar3 = lys_node_module((module->inc[i].submodule)->augment[j].target);
      if ((plVar3->field_0x40 & 0x80) == 0) {
        plVar3->field_0x40 = plVar3->field_0x40 | 0x80;
        iVar2 = unres_schema_add_node(plVar3,unres,(void *)0x0,UNRES_MOD_IMPLEMENT,(lys_node *)0x0);
        if (iVar2 == -1) {
          return -1;
        }
      }
      if ((((module->inc[i].submodule)->augment[j].flags & 1) != 0) &&
         (iVar2 = apply_aug((module->inc[i].submodule)->augment + j,unres), iVar2 != 0)) {
        return -1;
      }
    }
    for (j = 0; j < (module->inc[i].submodule)->ident_size; j = j + 1) {
      for (k = 0; k < (module->inc[i].submodule)->ident[j].base_size; k = k + 1) {
        resolve_identity_backlink_update
                  ((module->inc[i].submodule)->ident + j,
                   (module->inc[i].submodule)->ident[j].base[k]);
      }
    }
    i = i + 1;
  }
  root = module->data;
  do {
    if (root == (lys_node *)0x0) {
      return 0;
    }
    node = root;
    while (node != (lys_node *)0x0) {
      if (node->nodetype == LYS_GROUPING) {
LAB_001acb89:
        if (node == root) break;
        next = node->next;
      }
      else {
        if ((((node->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) &&
            (*(int *)&node[1].ref == 9)) &&
           (iVar2 = unres_schema_add_node(module,unres,&node[1].ref,UNRES_TYPE_LEAFREF,node),
           iVar2 == -1)) {
          return -1;
        }
        next = node->child;
        if ((node->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) != LYS_UNKNOWN) {
          next = (lys_node *)0x0;
        }
        if (next == (lys_node *)0x0) goto LAB_001acb89;
      }
      while (next == (lys_node *)0x0) {
        node = lys_parent(node);
        plVar4 = lys_parent(node);
        plVar5 = lys_parent(root);
        if (plVar4 == plVar5) break;
        next = node->next;
      }
      node = next;
    }
    root = root->next;
  } while( true );
}



int lys_set_implemented(lys_module *module)

{
  int iVar1;
  lys_module *module_00;
  undefined *puVar2;
  lys_revision *plVar3;
  long in_FS_OFFSET;
  bool bVar4;
  lys_module *module_local;
  int disabled;
  unres_schema *unres;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lys_set_implemented");
  if (module == (lys_module *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_set_implemented");
    iVar1 = 1;
  }
  else {
    module_00 = lys_main_module(module);
    bVar4 = (module_00->field_0x40 & 0x40) != 0;
    if (bVar4) {
      lys_set_enabled(module_00);
    }
    if ((module_00->field_0x40 & 0x80) == 0) {
      unres = (unres_schema *)calloc(1,0x28);
      if (unres == (unres_schema *)0x0) {
        ly_log(module_00->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "lys_set_implemented");
        if (bVar4) {
          FUN_00109620(module_00);
        }
        iVar1 = 1;
      }
      else {
        module_00->field_0x40 = module_00->field_0x40 | 0x80;
        iVar1 = lys_make_implemented_r(module_00,unres);
        if ((iVar1 == 0) &&
           ((unres->count == 0 || (iVar1 = resolve_unres_schema(module_00,unres), iVar1 == 0)))) {
          unres_schema_free((lys_module *)0x0,&unres,0);
          if (module_00->rev_size == '\0') {
            plVar3 = (lys_revision *)&DAT_00226b6c;
          }
          else {
            plVar3 = module_00->rev;
          }
          if (module_00->rev_size == '\0') {
            puVar2 = &DAT_00226b6c;
          }
          else {
            puVar2 = &DAT_00226b6d;
          }
          ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,"Module \"%s%s%s\" now implemented.",
                 module_00->name,puVar2,plVar3);
          iVar1 = 0;
        }
        else {
          if (bVar4) {
            FUN_00109620(module_00);
          }
          module_00->field_0x40 = module_00->field_0x40 & 0x7f;
          unres_schema_free(module_00,&unres,1);
          iVar1 = 1;
        }
      }
    }
    else {
      iVar1 = 0;
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void lys_submodule_module_data_free(lys_submodule *submodule)

{
  lys_node *plVar1;
  lys_submodule *submodule_local;
  lys_node *next;
  lys_node *elem;
  
  plVar1 = submodule->belongsto->data;
  while (elem = plVar1, elem != (lys_node *)0x0) {
    plVar1 = elem->next;
    if ((lys_module *)submodule == elem->module) {
      lys_node_free(elem,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
    }
  }
  return;
}



char * lys_path(lys_node *node,int options)

{
  int iVar1;
  char *pcVar2;
  long in_FS_OFFSET;
  int options_local;
  lys_node *node_local;
  char *buf;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lys_path");
  buf = (char *)0x0;
  if (node == (lys_node *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_path");
    pcVar2 = (char *)0x0;
  }
  else {
    iVar1 = ly_vlog_build_path(LY_VLOG_LYS,node,&buf,(uint)((options & 1U) == 0),0);
    pcVar2 = buf;
    if (iVar1 != 0) {
      pcVar2 = (char *)0x0;
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return pcVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * lys_data_path(lys_node *node)

{
  long lVar1;
  int iVar2;
  ly_set *set_00;
  lys_module *plVar3;
  char *pcVar4;
  long in_FS_OFFSET;
  lys_node *node_local;
  int i;
  int used;
  char *result;
  char *separator;
  char *name;
  lys_module *prev_mod;
  ly_set *set;
  char buf [1024];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lys_data_path");
  result = (char *)0x0;
  if (node == (lys_node *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_data_path");
    result = (char *)0x0;
  }
  else {
    buf[0] = '\0';
    set_00 = ly_set_new();
    node_local = node;
    if (set_00 == (ly_set *)0x0) {
      ly_log(node->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lys_data_path");
    }
    else {
LAB_001ad0f8:
      if (node_local != (lys_node *)0x0) {
        ly_set_add(set_00,node_local,0);
        do {
          node_local = lys_parent(node_local);
          if (node_local == (lys_node *)0x0) break;
        } while ((node_local->nodetype & 0x1642) != LYS_UNKNOWN);
        goto LAB_001ad0f8;
      }
      prev_mod = (lys_module *)0x0;
      used = 0;
      i = set_00->number;
LAB_001ad281:
      i = i - 1;
      if (-1 < i) {
        node_local = (set_00->set).s[i];
        if (node_local->nodetype == LYS_EXT) goto code_r0x001ad165;
        name = node_local->name;
        separator = ":";
        goto LAB_001ad1ca;
      }
      result = strdup(buf);
      if (result == (char *)0x0) {
        ly_log(node_local->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "lys_data_path");
      }
    }
    ly_set_free(set_00);
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return result;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
code_r0x001ad165:
  iVar2 = strcmp(*(char **)node_local->name,"yang-data");
  if (iVar2 == 0) {
    name = node_local->ref;
    separator = ":#";
LAB_001ad1ca:
    plVar3 = lys_node_module(node_local);
    if (prev_mod == plVar3) {
      separator = "";
    }
    plVar3 = lys_node_module(node_local);
    if (prev_mod == plVar3) {
      pcVar4 = "";
    }
    else {
      plVar3 = lys_node_module(node_local);
      pcVar4 = plVar3->name;
    }
    iVar2 = sprintf(buf + used,"/%s%s%s",pcVar4,separator,name);
    used = used + iVar2;
    prev_mod = lys_node_module(node_local);
  }
  goto LAB_001ad281;
}



lys_node_augment *
lys_getnext_target_aug(lys_node_augment *last,lys_module *mod,lys_node *aug_target)

{
  lys_node_augment *plVar1;
  bool bVar2;
  lys_node *aug_target_local;
  lys_module *mod_local;
  lys_node_augment *last_local;
  int i;
  int j;
  int last_found;
  lys_node *child;
  lys_node_augment *aug;
  
  if ((mod != (lys_module *)0x0) && (aug_target != (lys_node *)0x0)) {
    bVar2 = last == (lys_node_augment *)0x0;
    for (i = 0; i < (int)(uint)mod->augment_size; i = i + 1) {
      if ((mod->augment[i].target != (lys_node *)0x0) && (aug_target == mod->augment[i].target)) {
        if (bVar2) {
          return mod->augment + i;
        }
        if (last == mod->augment + i) {
          bVar2 = true;
        }
      }
    }
    for (i = 0; i < (int)(uint)mod->inc_size; i = i + 1) {
      for (j = 0; j < (int)(uint)(mod->inc[i].submodule)->augment_size; j = j + 1) {
        if (((mod->inc[i].submodule)->augment[j].target != (lys_node *)0x0) &&
           (aug_target == (mod->inc[i].submodule)->augment[j].target)) {
          if (bVar2) {
            return (mod->inc[i].submodule)->augment + j;
          }
          if (last == (mod->inc[i].submodule)->augment + j) {
            bVar2 = true;
          }
        }
      }
    }
    child = aug_target->child;
    while( true ) {
      if (child == (lys_node *)0x0) {
        return (lys_node_augment *)0x0;
      }
      if ((child->nodetype == LYS_CHOICE) &&
         (plVar1 = lys_getnext_target_aug(last,mod,child), plVar1 != (lys_node_augment *)0x0))
      break;
      child = child->next;
    }
    return plVar1;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("mod && aug_target",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_schema.c"
                ,0x1440,"lys_getnext_target_aug");
}



ly_set * lys_find_path(lys_module *cur_module,lys_node *cur_node,char *path)

{
  int iVar1;
  long in_FS_OFFSET;
  char *path_local;
  lys_node *cur_node_local;
  lys_module *cur_module_local;
  int rc;
  ly_set *ret;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lys_find_path");
  if (((cur_module == (lys_module *)0x0) && (cur_node == (lys_node *)0x0)) || (path == (char *)0x0))
  {
    ret = (ly_set *)0x0;
  }
  else {
    iVar1 = resolve_schema_nodeid(path,cur_node,cur_module,&ret,1,1);
    if (iVar1 == -1) {
      ret = (ly_set *)0x0;
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void lys_extcomplex_free_str(ly_ctx *ctx,lys_ext_instance_complex *ext,LY_STMT stmt)

{
  char **ppcVar1;
  long in_FS_OFFSET;
  LY_STMT stmt_local;
  lys_ext_instance_complex *ext_local;
  ly_ctx *ctx_local;
  int c;
  lyext_substmt *info;
  char **str;
  char ***a;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  str = (char **)lys_ext_complex_get_substmt(stmt,ext,&info);
  if (((char ***)str != (char ***)0x0) && ((char **)*str != (char **)0x0)) {
    if (info->cardinality < LY_STMT_CARD_SOME) {
      lydict_remove(ctx,*str);
      if (stmt == LY_STMT_BELONGSTO) {
        lydict_remove(ctx,str[1]);
      }
    }
    else {
      ppcVar1 = (char **)*str;
      a = (char ***)str;
      for (c = 0; str = ppcVar1, str[c] != (char *)0x0; c = c + 1) {
        lydict_remove(ctx,str[c]);
        ppcVar1 = str;
      }
      free(*a);
      if (stmt == LY_STMT_BELONGSTO) {
        str = a[1];
        for (c = 0; str[c] != (char *)0x0; c = c + 1) {
          lydict_remove(ctx,str[c]);
        }
        free(a[1]);
      }
      else if (stmt == LY_STMT_ARGUMENT) {
        free(a[1]);
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void lys_extension_instances_free
               (ly_ctx *ctx,lys_ext_instance **e,uint size,
               _func_void_lys_node_ptr_void_ptr *private_destructor)

{
  lys_ext *plVar1;
  lys_node *plVar2;
  void **ppvVar3;
  undefined8 *puVar4;
  long *plVar5;
  _func_void_lys_node_ptr_void_ptr *private_destructor_local;
  uint size_local;
  lys_ext_instance **e_local;
  ly_ctx *ctx_local;
  uint k;
  uint j;
  uint i;
  void **pp;
  lys_node *siter;
  lys_node *snext;
  lyext_substmt *substmt;
  void **start;
  
  if ((size != 0) && (e != (lys_ext_instance **)0x0)) {
    for (i = 0; i < size; i = i + 1) {
      if (e[i] != (lys_ext_instance *)0x0) {
        if ((e[i]->flags & 1) == 0) {
          if ((e[i]->flags & 2) != 0) {
            free(e[i]->def);
            e[i]->def = (lys_ext *)0x0;
            yang_free_ext_data((yang_ext_substmt *)e[i]->parent);
          }
          if ((e[i]->priv != (void *)0x0) &&
             (private_destructor != (_func_void_lys_node_ptr_void_ptr *)0x0)) {
            (*private_destructor)((lys_node *)e[i],e[i]->priv);
          }
          lys_extension_instances_free(ctx,e[i]->ext,(uint)e[i]->ext_size,private_destructor);
          lydict_remove(ctx,e[i]->arg_value);
        }
        if ((((e[i]->def != (lys_ext *)0x0) && (e[i]->def->plugin != (lyext_plugin *)0x0)) &&
            (e[i]->def->plugin->type == LYEXT_COMPLEX)) && ((e[i]->flags & 4) == 0)) {
          plVar1 = e[i][1].def;
          j = 0;
          while (*(int *)(plVar1->padding + (ulong)j * 0x18 + -0x1b) != 0) {
            if (true) {
              switch(*(undefined4 *)(plVar1->padding + (ulong)j * 0x18 + -0x1b)) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
              case 0xb:
              case 0xc:
              case 0xd:
              case 0xe:
              case 0xf:
              case 0x10:
              case 0x11:
                lys_extcomplex_free_str
                          (ctx,(lys_ext_instance_complex *)e[i],
                           *(LY_STMT *)(plVar1->padding + (ulong)j * 0x18 + -0x1b));
                break;
              case 0x12:
              case 0x1c:
              case 0x1d:
              case 0x1e:
                plVar5 = (long *)((long)&e[i][1].parent +
                                 *(long *)(plVar1->padding + (ulong)j * 0x18 + -0x13));
                if ((1 < *(uint *)(plVar1->padding + (ulong)j * 0x18 + -0xb)) && (*plVar5 != 0)) {
                  k = 0;
                  while (*(long *)(*plVar5 + (ulong)k * 8) != 0) {
                    free(*(void **)(*plVar5 + (ulong)k * 8));
                    k = k + 1;
                  }
                }
                free((void *)*plVar5);
                break;
              case 0x1b:
                if (1 < *(uint *)(plVar1->padding + (ulong)j * 0x18 + -0xb)) {
                  free(*(void **)((long)&e[i][1].parent +
                                 *(long *)(plVar1->padding + (ulong)j * 0x18 + -0x13)));
                }
                break;
              case 0x1f:
                plVar5 = (long *)lys_ext_complex_get_substmt
                                           (LY_STMT_UNIQUE,(lys_ext_instance_complex *)e[i],
                                            (lyext_substmt **)0x0);
                if ((plVar5 != (long *)0x0) && (*plVar5 != 0)) {
                  if (*(uint *)(plVar1->padding + (ulong)j * 0x18 + -0xb) < 2) {
                    for (k = 0; k < *(byte *)(*plVar5 + 8); k = k + 1) {
                      lydict_remove(ctx,*(char **)(*(long *)*plVar5 + (ulong)k * 8));
                    }
                    free(*(void **)*plVar5);
                    free((void *)*plVar5);
                  }
                  else {
                    ppvVar3 = (void **)*plVar5;
                    for (pp = ppvVar3; *pp != (void *)0x0; pp = pp + 1) {
                      for (k = 0; k < *(byte *)((long)*pp + 8); k = k + 1) {
                    // WARNING: Load size is inaccurate
                        lydict_remove(ctx,*(char **)(**pp + (ulong)k * 8));
                      }
                    // WARNING: Load size is inaccurate
                      free(**pp);
                      free(*pp);
                    }
                    free(ppvVar3);
                  }
                }
                break;
              case 0x20:
                if (1 < *(uint *)(plVar1->padding + (ulong)j * 0x18 + -0xb)) {
                  free(*(void **)((long)&e[i][1].parent +
                                 *(long *)(plVar1->padding + (ulong)j * 0x18 + -0x13)));
                }
                break;
              case 0x21:
              case 0x22:
              case 0x23:
              case 0x24:
              case 0x25:
              case 0x26:
              case 0x27:
              case 0x28:
              case 0x29:
              case 0x2a:
              case 0x2b:
              case 0x2c:
              case 0x2d:
              case 0x2e:
              case 0x39:
                puVar4 = (undefined8 *)
                         ((long)&e[i][1].parent +
                         *(long *)(plVar1->padding + (ulong)j * 0x18 + -0x13));
                siter = (lys_node *)*puVar4;
                while (siter != (lys_node *)0x0) {
                  plVar2 = siter->next;
                  lys_node_free(siter,(_func_void_lys_node_ptr_void_ptr *)0x0,0);
                  siter = plVar2;
                }
                *puVar4 = 0;
                break;
              case 0x2f:
                plVar5 = (long *)lys_ext_complex_get_substmt
                                           (LY_STMT_TYPEDEF,(lys_ext_instance_complex *)e[i],
                                            (lyext_substmt **)0x0);
                if ((plVar5 != (long *)0x0) && (*plVar5 != 0)) {
                  if (*(uint *)(plVar1->padding + (ulong)j * 0x18 + -0xb) < 2) {
                    lys_tpdf_free(ctx,(lys_tpdf *)*plVar5,private_destructor);
                    free((void *)*plVar5);
                  }
                  else {
                    ppvVar3 = (void **)*plVar5;
                    for (pp = ppvVar3; *pp != (void *)0x0; pp = pp + 1) {
                      lys_tpdf_free(ctx,(lys_tpdf *)*pp,private_destructor);
                      free(*pp);
                    }
                    free(ppvVar3);
                  }
                }
                break;
              case 0x30:
                plVar5 = (long *)lys_ext_complex_get_substmt
                                           (LY_STMT_TYPE,(lys_ext_instance_complex *)e[i],
                                            (lyext_substmt **)0x0);
                if ((plVar5 != (long *)0x0) && (*plVar5 != 0)) {
                  if (*(uint *)(plVar1->padding + (ulong)j * 0x18 + -0xb) < 2) {
                    lys_type_free(ctx,(lys_type *)*plVar5,private_destructor);
                    free((void *)*plVar5);
                  }
                  else {
                    ppvVar3 = (void **)*plVar5;
                    for (pp = ppvVar3; *pp != (void *)0x0; pp = pp + 1) {
                      lys_type_free(ctx,(lys_type *)*pp,private_destructor);
                      free(*pp);
                    }
                    free(ppvVar3);
                  }
                }
                break;
              case 0x31:
                plVar5 = (long *)lys_ext_complex_get_substmt
                                           (LY_STMT_IFFEATURE,(lys_ext_instance_complex *)e[i],
                                            (lyext_substmt **)0x0);
                if ((plVar5 != (long *)0x0) && (*plVar5 != 0)) {
                  if (*(uint *)(plVar1->padding + (ulong)j * 0x18 + -0xb) < 2) {
                    lys_iffeature_free(ctx,(lys_iffeature *)*plVar5,'\x01',0,private_destructor);
                  }
                  else {
                    ppvVar3 = (void **)*plVar5;
                    for (pp = ppvVar3; *pp != (void *)0x0; pp = pp + 1) {
                      lys_iffeature_free(ctx,(lys_iffeature *)*pp,'\x01',0,private_destructor);
                    }
                    free(ppvVar3);
                  }
                }
                break;
              case 0x32:
              case 0x33:
              case 0x34:
              case 0x35:
                plVar5 = (long *)lys_ext_complex_get_substmt
                                           (*(LY_STMT *)(plVar1->padding + (ulong)j * 0x18 + -0x1b),
                                            (lys_ext_instance_complex *)e[i],(lyext_substmt **)0x0);
                if ((plVar5 != (long *)0x0) && (*plVar5 != 0)) {
                  if (*(uint *)(plVar1->padding + (ulong)j * 0x18 + -0xb) < 2) {
                    lys_restr_free(ctx,(lys_restr *)*plVar5,private_destructor);
                    free((void *)*plVar5);
                  }
                  else {
                    ppvVar3 = (void **)*plVar5;
                    for (pp = ppvVar3; *pp != (void *)0x0; pp = pp + 1) {
                      lys_restr_free(ctx,(lys_restr *)*pp,private_destructor);
                      free(*pp);
                    }
                    free(ppvVar3);
                  }
                }
                break;
              case 0x36:
                plVar5 = (long *)lys_ext_complex_get_substmt
                                           (LY_STMT_WHEN,(lys_ext_instance_complex *)e[i],
                                            (lyext_substmt **)0x0);
                if ((plVar5 != (long *)0x0) && (*plVar5 != 0)) {
                  if (*(uint *)(plVar1->padding + (ulong)j * 0x18 + -0xb) < 2) {
                    lys_when_free(ctx,(lys_when *)*plVar5,private_destructor);
                  }
                  else {
                    ppvVar3 = (void **)*plVar5;
                    for (pp = ppvVar3; *pp != (void *)0x0; pp = pp + 1) {
                      lys_when_free(ctx,(lys_when *)*pp,private_destructor);
                    }
                    free(ppvVar3);
                  }
                }
                break;
              case 0x37:
                plVar5 = (long *)lys_ext_complex_get_substmt
                                           (LY_STMT_REVISION,(lys_ext_instance_complex *)e[i],
                                            (lyext_substmt **)0x0);
                if ((plVar5 != (long *)0x0) && (*plVar5 != 0)) {
                  if (*(uint *)(plVar1->padding + (ulong)j * 0x18 + -0xb) < 2) {
                    lydict_remove(ctx,*(char **)(*plVar5 + 0x18));
                    lydict_remove(ctx,*(char **)(*plVar5 + 0x20));
                    lys_extension_instances_free
                              (ctx,*(lys_ext_instance ***)(*plVar5 + 0x10),
                               (uint)*(byte *)(*plVar5 + 0xb),private_destructor);
                    free((void *)*plVar5);
                  }
                  else {
                    ppvVar3 = (void **)*plVar5;
                    for (pp = ppvVar3; *pp != (void *)0x0; pp = pp + 1) {
                      lydict_remove(ctx,*(char **)((long)*pp + 0x18));
                      lydict_remove(ctx,*(char **)((long)*pp + 0x20));
                      lys_extension_instances_free
                                (ctx,*(lys_ext_instance ***)((long)*pp + 0x10),
                                 (uint)*(byte *)((long)*pp + 0xb),private_destructor);
                      free(*pp);
                    }
                    free(ppvVar3);
                  }
                }
              }
            }
            j = j + 1;
          }
        }
        free(e[i]);
      }
    }
    free(e);
  }
  return;
}



int lyd_anydata_equal(lyd_node *first,lyd_node *second)

{
  uint uVar1;
  char *pcVar2;
  long in_FS_OFFSET;
  lyd_node *second_local;
  lyd_node *first_local;
  char *str1;
  char *str2;
  lyd_node_anydata *anydata;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  str1 = (char *)0x0;
  str2 = (char *)0x0;
  if ((first->schema->nodetype & LYS_ANYDATA) == LYS_UNKNOWN) {
                    // WARNING: Subroutine does not return
    __assert_fail("first->schema->nodetype & LYS_ANYDATA",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x36,"lyd_anydata_equal");
  }
  if (first->schema->nodetype != second->schema->nodetype) {
                    // WARNING: Subroutine does not return
    __assert_fail("first->schema->nodetype == second->schema->nodetype",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x37,"lyd_anydata_equal");
  }
  anydata = (lyd_node_anydata *)first;
  if (first->ht == (hash_table *)0x0) {
    lyxml_print_mem(&str1,(lyxml_elem *)first->ht,0x10);
    pcVar2 = lydict_insert_zc(anydata->schema->module->ctx,str1);
    (anydata->value).str = pcVar2;
  }
  str1 = (anydata->value).str;
  anydata = (lyd_node_anydata *)second;
  if (second->ht == (hash_table *)0x0) {
    lyxml_print_mem(&str2,(lyxml_elem *)second->ht,0x10);
    pcVar2 = lydict_insert_zc(anydata->schema->module->ctx,str2);
    (anydata->value).str = pcVar2;
  }
  str2 = (anydata->value).str;
  if (first->schema->module->ctx == second->schema->module->ctx) {
    uVar1 = (uint)(str1 == str2);
  }
  else {
    uVar1 = ly_strequal_(str1,str2);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



int lyd_list_has_keys(lyd_node *list)

{
  lys_node *plVar1;
  int iVar2;
  lyd_node *list_local;
  int i;
  lyd_node *iter;
  lys_node_list *slist;
  
  if (list->schema->nodetype != LYS_LIST) {
                    // WARNING: Subroutine does not return
    __assert_fail("list->schema->nodetype == LYS_LIST",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x56,"lyd_list_has_keys");
  }
  plVar1 = list->schema;
  if (plVar1->padding[2] == '\0') {
    iVar2 = 1;
  }
  else {
    i = 0;
    iter = list->child;
    for (; (iter != (lyd_node *)0x0 && (i < (int)(uint)plVar1->padding[2])); i = i + 1) {
      if (iter->schema != *(lys_node **)(*(long *)&plVar1[1].flags + (long)i * 8)) {
        return 0;
      }
      iter = iter->next;
    }
    if (i < (int)(uint)plVar1->padding[2]) {
      iVar2 = 0;
    }
    else {
      iVar2 = 1;
    }
  }
  return iVar2;
}



int lyd_leaf_val_equal(lyd_node *node1,lyd_node *node2,int diff_ctx)

{
  uint uVar1;
  int diff_ctx_local;
  lyd_node *node2_local;
  lyd_node *node1_local;
  
  if ((node1->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
                    // WARNING: Subroutine does not return
    __assert_fail("node1->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x77,"lyd_leaf_val_equal");
  }
  if (node1->schema->nodetype != node2->schema->nodetype) {
                    // WARNING: Subroutine does not return
    __assert_fail("node1->schema->nodetype == node2->schema->nodetype",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x78,"lyd_leaf_val_equal");
  }
  if (diff_ctx == 0) {
    uVar1 = (uint)(node1->ht == node2->ht);
  }
  else {
    uVar1 = ly_strequal_((char *)node1->ht,(char *)node2->ht);
  }
  return uVar1;
}



int lyd_list_equal(lyd_node *node1,lyd_node *node2,int with_defaults)

{
  LYS_NODE LVar1;
  ly_ctx *ctx_00;
  char *pcVar2;
  uint diff_ctx_00;
  int iVar3;
  lys_module *plVar4;
  lys_node *plVar5;
  int with_defaults_local;
  lyd_node *node2_local;
  lyd_node *node1_local;
  int i;
  int diff_ctx;
  lyd_node *elem1;
  lyd_node *next1;
  lyd_node *elem2;
  lyd_node *next2;
  lys_node *elem1_sch;
  ly_ctx *ctx;
  
  ctx_00 = node2->schema->module->ctx;
  diff_ctx_00 = (uint)(node1->schema->module->ctx != node2->schema->module->ctx);
  LVar1 = node2->schema->nodetype;
  if (LVar1 == LYS_LEAFLIST) {
    iVar3 = lyd_leaf_val_equal(node1,node2,diff_ctx_00);
    if ((iVar3 != 0) && ((with_defaults == 0 || ((node1->field_0x9 & 1) == (node2->field_0x9 & 1))))
       ) {
      return 1;
    }
  }
  else {
    if (LVar1 != LYS_LIST) {
      ly_log(ctx_00,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
             ,0x113);
      return -1;
    }
    if (node1->schema->padding[2] == '\0') {
      if ((node1->child == (lyd_node *)0x0) && (node2->child == (lyd_node *)0x0)) {
        return 1;
      }
      elem2 = node2->child;
      elem1 = node1->child;
      while (((elem1 != (lyd_node *)0x0 && (elem2 != (lyd_node *)0x0)) &&
             (elem1->hash == elem2->hash))) {
        if (diff_ctx_00 == 0) {
          elem1_sch = elem1->schema;
        }
        else {
          elem1_sch = lyd_get_schema_inctx(elem1,ctx_00);
          if (elem1_sch == (lys_node *)0x0) {
            pcVar2 = elem1->schema->name;
            plVar4 = lyd_node_module(elem1);
            ly_log(ctx_00,LY_LLERR,LY_EINVAL,
                   "Target context does not contain a required schema node (%s:%s).",plVar4->name,
                   pcVar2);
            return -1;
          }
        }
        if (elem1_sch != elem2->schema) break;
        if (elem2->schema->nodetype == LYS_LIST) {
          iVar3 = lyd_list_has_keys(elem1);
          if ((iVar3 != 0) || (iVar3 = lyd_list_has_keys(elem2), iVar3 != 0)) goto LAB_001aedbb;
          next1 = (lyd_node *)0x0;
          next2 = (lyd_node *)0x0;
        }
        else {
          if ((elem2->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
            if (((elem2->schema->nodetype & LYS_ANYDATA) != LYS_UNKNOWN) &&
               (iVar3 = lyd_anydata_equal(elem1,elem2), iVar3 == 0)) break;
          }
          else {
            iVar3 = lyd_leaf_val_equal(elem1,elem2,diff_ctx_00);
            if ((iVar3 == 0) &&
               ((with_defaults == 0 || ((elem1->field_0x9 & 1) == (elem2->field_0x9 & 1))))) break;
          }
LAB_001aedbb:
          if ((elem2->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
            next1 = elem1->child;
            next2 = elem2->child;
          }
          else {
            next1 = (lyd_node *)0x0;
            next2 = (lyd_node *)0x0;
          }
        }
        if (next1 == (lyd_node *)0x0) {
          next1 = elem1->next;
        }
        if (next2 == (lyd_node *)0x0) {
          next2 = elem2->next;
        }
        while ((next1 == (lyd_node *)0x0 && (elem1 = elem1->parent, elem1 != node1))) {
          next1 = elem1->next;
        }
        while ((next2 == (lyd_node *)0x0 && (elem2 = elem2->parent, elem2 != node2))) {
          next2 = elem2->next;
        }
        elem2 = next2;
        elem1 = next1;
      }
      if ((elem1 == (lyd_node *)0x0) && (elem2 == (lyd_node *)0x0)) {
        return 1;
      }
    }
    else {
      elem1 = node1->child;
      elem2 = node2->child;
      elem1_sch = (lys_node *)0x0;
      for (i = 0; i < (int)(uint)node1->schema->padding[2]; i = i + 1) {
        if ((diff_ctx_00 != 0) && (elem1 != (lyd_node *)0x0)) {
          if (elem1_sch == (lys_node *)0x0) {
            elem1_sch = lyd_get_schema_inctx(elem1,ctx_00);
            if (elem1_sch == (lys_node *)0x0) {
              pcVar2 = elem1->schema->name;
              plVar4 = lyd_node_module(elem1);
              ly_log(ctx_00,LY_LLERR,LY_EINVAL,
                     "Target context does not contain a required schema node (%s:%s).",plVar4->name,
                     pcVar2);
              return -1;
            }
          }
          else {
            elem1_sch = elem1_sch->next;
          }
        }
        if ((elem1 == (lyd_node *)0x0) || (elem2 == (lyd_node *)0x0)) break;
        plVar5 = elem1_sch;
        if (elem1_sch == (lys_node *)0x0) {
          plVar5 = elem1->schema;
        }
        if ((plVar5 != elem2->schema) ||
           (iVar3 = lyd_leaf_val_equal(elem1,elem2,diff_ctx_00), iVar3 == 0)) break;
        elem1 = elem1->next;
        elem2 = elem2->next;
      }
      if (i == (uint)node1->schema->padding[2]) {
        return 1;
      }
    }
  }
  return 0;
}



// WARNING: Variable defined which should be unmapped: UNUSED_cb_data_local

int lyd_hash_table_val_equal(void *val1_p,void *val2_p,int mod,void *UNUSED_cb_data)

{
  LYS_NODE LVar1;
  lyd_node *node1;
  lyd_node *node2;
  int iVar2;
  void *UNUSED_cb_data_local;
  int mod_local;
  void *val2_p_local;
  void *val1_p_local;
  lyd_node *val1;
  lyd_node *val2;
  
                    // WARNING: Load size is inaccurate
  node1 = *val1_p;
                    // WARNING: Load size is inaccurate
  node2 = *val2_p;
  if (mod != 0) {
    if (node1 == node2) {
      return 1;
    }
    return 0;
  }
  if (node1->schema != node2->schema) {
    return 0;
  }
  LVar1 = node1->schema->nodetype;
  if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
    if ((LVar1 != LYS_UNKNOWN) && (true)) {
      switch(LVar1) {
      case LYS_CONTAINER:
      case LYS_LEAF:
      case LYS_ANYXML:
        goto LAB_001af014;
      case LYS_LEAFLIST:
      case LYS_LIST:
        iVar2 = lyd_list_equal(node1,node2,0);
        return iVar2;
      }
    }
  }
  else if (LVar1 == LYS_ANYDATA) {
LAB_001af014:
    return 1;
  }
  ly_log(node1->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
         ,0x13d,UNUSED_cb_data);
  return 0;
}



void lyd_hash_keyless_list_dfs(lyd_node *child,uint32_t *hash)

{
  LYS_NODE LVar1;
  int iVar2;
  uint32_t uVar3;
  uint32_t *hash_local;
  lyd_node *child_local;
  
  child_local = child;
  do {
    if (child_local == (lyd_node *)0x0) {
      return;
    }
    LVar1 = child_local->schema->nodetype;
    if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
      if ((LVar1 == LYS_UNKNOWN) || (false)) {
switchD_001af06f_caseD_2:
                    // WARNING: Subroutine does not return
        __assert_fail("0",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x156,"lyd_hash_keyless_list_dfs");
      }
      switch(LVar1) {
      case LYS_CONTAINER:
        lyd_hash_keyless_list_dfs(child_local->child,hash);
        break;
      default:
        goto switchD_001af06f_caseD_2;
      case LYS_LEAF:
      case LYS_LEAFLIST:
      case LYS_ANYXML:
        goto switchD_001af06f_caseD_4;
      case LYS_LIST:
        iVar2 = lyd_list_has_keys(child_local);
        if (iVar2 != 0) {
          lyd_hash_keyless_list_dfs(child_local->child,hash);
        }
      }
    }
    else {
      if (LVar1 != LYS_ANYDATA) goto switchD_001af06f_caseD_2;
switchD_001af06f_caseD_4:
      uVar3 = dict_hash_multi(*hash,(char *)&child_local->hash,4);
      *hash = uVar3;
    }
    child_local = child_local->next;
  } while( true );
}



int lyd_hash(lyd_node *node)

{
  int iVar1;
  uint32_t uVar2;
  lys_module *plVar3;
  size_t sVar4;
  lyd_node *node_local;
  int i;
  lyd_node *iter;
  
  if ((node->hash != 0) &&
     ((node->schema->nodetype != LYS_LIST || (node->schema->padding[2] != '\0')))) {
                    // WARNING: Subroutine does not return
    __assert_fail("!node->hash || ((node->schema->nodetype == LYS_LIST) && !((struct lys_node_list *)node->schema)->keys_size)"
                  ,
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x161,"lyd_hash");
  }
  if ((node->schema->nodetype == LYS_LIST) && (iVar1 = lyd_list_has_keys(node), iVar1 == 0)) {
    iVar1 = 1;
  }
  else {
    plVar3 = lyd_node_module(node);
    sVar4 = strlen(plVar3->name);
    plVar3 = lyd_node_module(node);
    uVar2 = dict_hash_multi(0,plVar3->name,sVar4);
    node->hash = uVar2;
    sVar4 = strlen(node->schema->name);
    uVar2 = dict_hash_multi(node->hash,node->schema->name,sVar4);
    node->hash = uVar2;
    if (node->schema->nodetype == LYS_LEAFLIST) {
      sVar4 = strlen((char *)node->ht);
      uVar2 = dict_hash_multi(node->hash,(char *)node->ht,sVar4);
      node->hash = uVar2;
    }
    else if (node->schema->nodetype == LYS_LIST) {
      if (node->schema->padding[2] == '\0') {
        lyd_hash_keyless_list_dfs(node->child,&node->hash);
      }
      else {
        i = 0;
        iter = node->child;
        for (; i < (int)(uint)node->schema->padding[2]; i = i + 1) {
          if (iter == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
            __assert_fail("iter",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                          ,0x16c,"lyd_hash");
          }
          sVar4 = strlen((char *)iter->ht);
          uVar2 = dict_hash_multi(node->hash,(char *)iter->ht,sVar4);
          node->hash = uVar2;
          iter = iter->next;
        }
      }
    }
    uVar2 = dict_hash_multi(node->hash,(char *)0x0,0);
    node->hash = uVar2;
    iVar1 = 0;
  }
  return iVar1;
}



void lyd_keyless_list_hash_change(lyd_node *parent)

{
  int iVar1;
  lyd_node *parent_local;
  int r;
  
  parent_local = parent;
  do {
    if ((parent_local == (lyd_node *)0x0) || ((parent_local->schema->flags & 1) != 0)) {
      return;
    }
    if (parent_local->schema->nodetype == LYS_LIST) {
      if ((parent_local->hash == 0) || (parent_local->schema->padding[2] != '\0')) {
        iVar1 = lyd_list_has_keys(parent_local);
        if (iVar1 == 0) {
          return;
        }
      }
      else {
        if (((parent_local->parent != (lyd_node *)0x0) &&
            (parent_local->parent->ht != (hash_table *)0x0)) &&
           (r = lyht_remove(parent_local->parent->ht,&parent_local,parent_local->hash), r != 0)) {
                    // WARNING: Subroutine does not return
          __assert_fail("!r",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                        ,0x187,"lyd_keyless_list_hash_change");
        }
        lyd_hash(parent_local);
        if (((parent_local->parent != (lyd_node *)0x0) &&
            (parent_local->parent->ht != (hash_table *)0x0)) &&
           (r = lyht_insert(parent_local->parent->ht,&parent_local,parent_local->hash,(void **)0x0),
           r != 0)) {
                    // WARNING: Subroutine does not return
          __assert_fail("!r",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                        ,399,"lyd_keyless_list_hash_change");
        }
      }
    }
    parent_local = parent_local->parent;
  } while( true );
}



void _lyd_insert_hash(lyd_node *node,int keyless_list_check)

{
  lyd_node *plVar1;
  int iVar2;
  lys_node_list *plVar3;
  hash_table *phVar4;
  long in_FS_OFFSET;
  int keyless_list_check_local;
  lyd_node *node_local;
  int i;
  lyd_node *iter;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  node_local = node;
  if ((node->parent != (lyd_node *)0x0) &&
     ((node->schema->nodetype != LYS_LIST || (iVar2 = lyd_list_has_keys(node), iVar2 != 0)))) {
    if ((node_local->schema->nodetype == LYS_LEAF) &&
       ((plVar3 = lys_is_key((lys_node_leaf *)node_local->schema,(uint8_t *)0x0),
        plVar3 != (lys_node_list *)0x0 && (iVar2 = lyd_hash(node_local->parent), iVar2 == 0)))) {
      _lyd_insert_hash(node_local->parent,0);
    }
    if (node_local->parent->ht == (hash_table *)0x0) {
      i = 0;
      for (iter = node_local->parent->child; iter != (lyd_node *)0x0; iter = iter->next) {
        if ((iter->schema->nodetype == LYS_LIST) && (iVar2 = lyd_list_has_keys(iter), iVar2 == 0)) {
          i = i + -1;
        }
        i = i + 1;
      }
      if (4 < i) {
                    // WARNING: Subroutine does not return
        __assert_fail("i <= LY_CACHE_HT_MIN_CHILDREN",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x1b4,"_lyd_insert_hash");
      }
      if (i == 4) {
        plVar1 = node_local->parent;
        phVar4 = lyht_new(1,8,lyd_hash_table_val_equal,(void *)0x0,1);
        plVar1->ht = phVar4;
        for (iter = node_local->parent->child; iter != (lyd_node *)0x0; iter = iter->next) {
          if (((iter->schema->nodetype != LYS_LIST) || (iVar2 = lyd_list_has_keys(iter), iVar2 != 0)
              ) && (iVar2 = lyht_insert(node_local->parent->ht,&iter,iter->hash,(void **)0x0),
                   iVar2 != 0)) {
                    // WARNING: Subroutine does not return
            __assert_fail("0",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                          ,0x1bf,"_lyd_insert_hash");
          }
        }
      }
    }
    else {
      iVar2 = lyht_insert(node_local->parent->ht,&node_local,node_local->hash,(void **)0x0);
      if (iVar2 != 0) {
                    // WARNING: Subroutine does not return
        __assert_fail("0",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x1c5,"_lyd_insert_hash");
      }
    }
    if (keyless_list_check != 0) {
      lyd_keyless_list_hash_change(node_local->parent);
    }
  }
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void lyd_insert_hash(lyd_node *node)

{
  lyd_node *node_local;
  
  _lyd_insert_hash(node,1);
  return;
}



void _lyd_unlink_hash(lyd_node *node,lyd_node *orig_parent,int keyless_list_check)

{
  int iVar1;
  lys_node_list *plVar2;
  int keyless_list_check_local;
  lyd_node *orig_parent_local;
  lyd_node *node_local;
  lyd_node *iter;
  
  node_local = node;
  if ((keyless_list_check != 0) && (orig_parent != (lyd_node *)0x0)) {
    for (iter = orig_parent->child; iter != (lyd_node *)0x0; iter = iter->next) {
      if (iter == node) {
                    // WARNING: Subroutine does not return
        __assert_fail("iter != node",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x1e1,"_lyd_unlink_hash");
      }
    }
  }
  if ((orig_parent != (lyd_node *)0x0) && (node->hash != 0)) {
    if ((node->schema->nodetype == LYS_LIST) && (iVar1 = lyd_list_has_keys(node), iVar1 == 0)) {
      return;
    }
    if (orig_parent->ht != (hash_table *)0x0) {
      iVar1 = lyht_remove(orig_parent->ht,&node_local,node_local->hash);
      if (iVar1 != 0) {
                    // WARNING: Subroutine does not return
        __assert_fail("0",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x1e9,"_lyd_unlink_hash");
      }
      if (orig_parent->ht->used < 4) {
        lyht_free(orig_parent->ht);
        orig_parent->ht = (hash_table *)0x0;
      }
    }
    plVar2 = lys_is_key((lys_node_leaf *)node_local->schema,(uint8_t *)0x0);
    if ((plVar2 != (lys_node_list *)0x0) && (orig_parent->hash != 0)) {
      if ((orig_parent->schema->nodetype != LYS_LIST) ||
         (iVar1 = lyd_list_has_keys(orig_parent), iVar1 != 0)) {
                    // WARNING: Subroutine does not return
        __assert_fail("(orig_parent->schema->nodetype == LYS_LIST) && !lyd_list_has_keys(orig_parent)"
                      ,
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x1f5,"_lyd_unlink_hash");
      }
      _lyd_unlink_hash(orig_parent,orig_parent->parent,0);
      orig_parent->hash = 0;
    }
    if (keyless_list_check != 0) {
      lyd_keyless_list_hash_change(orig_parent);
    }
  }
  return;
}



void lyd_unlink_hash(lyd_node *node,lyd_node *orig_parent)

{
  lyd_node *orig_parent_local;
  lyd_node *node_local;
  
  _lyd_unlink_hash(node,orig_parent,1);
  return;
}



int lyd_get_node_siblings(lyd_node *data,lys_node *schema,ly_set *set)

{
  uint uVar1;
  ly_set *set_local;
  lys_node *schema_local;
  lyd_node *data_local;
  lyd_node *iter;
  
  if ((set == (ly_set *)0x0) || (set->number != 0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("set && !set->number",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x213,"lyd_get_node_siblings");
  }
  if (schema == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("schema",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x214,"lyd_get_node_siblings");
  }
  if ((schema->nodetype & 0xc1bd) != LYS_UNKNOWN) {
    iter = data;
    if (data == (lyd_node *)0x0) {
      uVar1 = 0;
    }
    else {
      for (; iter != (lyd_node *)0x0; iter = iter->next) {
        if (schema == iter->schema) {
          ly_set_add(set,iter,1);
        }
      }
      uVar1 = set->number;
    }
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("schema->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC | LYS_ACTION)"
                ,
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                ,0x215,"lyd_get_node_siblings");
}



int lyd_is_when_false(lyd_node *root,lyd_node *last_parent,lys_node *schema,int options)

{
  int iVar1;
  lys_node *stop;
  long in_FS_OFFSET;
  int options_local;
  lys_node *schema_local;
  lyd_node *last_parent_local;
  lyd_node *root_local;
  int_log_opts prev_ilo;
  lyd_node *current;
  lyd_node *dummy;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (((options & 0x10000ffU) == 0) || ((options & 0x1000071U) != 0)) {
    if (last_parent == (lyd_node *)0x0) {
      stop = (lys_node *)0x0;
    }
    else {
      stop = last_parent->schema;
    }
    iVar1 = resolve_applies_when(schema,1,stop);
    if (iVar1 != 0) {
      schema_local = schema;
      if (schema->nodetype == LYS_CHOICE) {
        schema_local = lys_getnext((lys_node *)0x0,schema,(lys_module *)0x0,0x100);
      }
      dummy = lyd_new_dummy(root,last_parent,schema_local,(char *)0x0,0);
      if (dummy == (lyd_node *)0x0) {
        iVar1 = -1;
        goto LAB_001afc0d;
      }
      if ((dummy->parent == (lyd_node *)0x0) && (root != (lyd_node *)0x0)) {
        lyd_insert_before(root,dummy);
      }
      for (current = dummy; current != (lyd_node *)0x0; current = current->child) {
        ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
        resolve_when(current,0,(lys_when **)0x0);
        ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
        if (((byte)current->field_0x9 >> 1 & 1) != 0) {
          lyd_free(dummy);
          iVar1 = 1;
          goto LAB_001afc0d;
        }
        if ((current->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) != LYS_UNKNOWN) break;
      }
      lyd_free(dummy);
    }
  }
  iVar1 = 0;
LAB_001afc0d:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyd_check_mandatory_data
              (lyd_node *root,lyd_node *last_parent,ly_set *instances,lys_node *schema,int options)

{
  LYS_NODE LVar1;
  uint uVar2;
  ly_ctx *ctx_00;
  ushort uVar3;
  int iVar4;
  lys_node *plVar5;
  lys_module *plVar6;
  char *pcVar7;
  int options_local;
  lys_node *schema_local;
  ly_set *instances_local;
  lyd_node *last_parent_local;
  lyd_node *root_local;
  uint16_t status;
  uint32_t limit;
  ly_ctx *ctx;
  
  ctx_00 = schema->module->ctx;
  if (instances->number == 0) {
    uVar3 = schema->flags & 0x38;
    plVar5 = lys_is_disabled(schema,2);
    if ((plVar5 != (lys_node *)0x0) || ((uVar3 != 0 && (uVar3 != 8)))) {
      return 0;
    }
    if (((options & 0x2000U) != 0) || (((options & 0x10000ffU) != 0 && ((schema->flags & 2) != 0))))
    {
      return 0;
    }
    iVar4 = lyd_is_when_false(root,last_parent,schema,options);
    if (iVar4 != 0) {
      return 0;
    }
  }
  LVar1 = schema->nodetype;
  if (LVar1 == LYS_ANYDATA) {
LAB_001afd43:
    if (((schema->flags & 0x40) != 0) && (instances->number == 0)) {
      if (last_parent == (lyd_node *)0x0) {
        plVar6 = lys_node_module(schema);
        pcVar7 = plVar6->name;
      }
      else {
        pcVar7 = last_parent->schema->name;
      }
      ly_vlog(ctx_00,LYE_MISSELEM,LY_VLOG_LYD,last_parent,schema->name,pcVar7);
      return 1;
    }
    return 0;
  }
  if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
    if (LVar1 == LYS_ANYXML) goto LAB_001afd43;
    if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
      if (LVar1 == LYS_LIST) {
        if ((*(uint *)&schema[1].iffeature != 0) &&
           (instances->number < *(uint *)&schema[1].iffeature)) {
          ly_vlog(ctx_00,LYE_NOMIN,LY_VLOG_LYD,last_parent,schema->name);
          return 1;
        }
        uVar2 = *(uint *)((long)&schema[1].iffeature + 4);
        if (uVar2 == 0) {
          return 0;
        }
        if (instances->number <= uVar2) {
          return 0;
        }
        ly_vlog(ctx_00,LYE_NOMAX,LY_VLOG_LYD,(instances->set).s[uVar2],schema->name);
        return 1;
      }
      if (LVar1 < (LYS_CONTAINER|LYS_LIST)) {
        if (LVar1 == LYS_LEAF) goto LAB_001afd43;
        if (LVar1 == LYS_LEAFLIST) {
          if ((*(uint *)&schema[1].priv != 0) && (instances->number < *(uint *)&schema[1].priv)) {
            ly_vlog(ctx_00,LYE_NOMIN,LY_VLOG_LYD,last_parent,schema->name);
            return 1;
          }
          uVar2 = *(uint *)((long)&schema[1].priv + 4);
          if (uVar2 == 0) {
            return 0;
          }
          if (instances->number <= uVar2) {
            return 0;
          }
          ly_vlog(ctx_00,LYE_NOMAX,LY_VLOG_LYD,(instances->set).s[uVar2],schema->name);
          return 1;
        }
      }
    }
  }
                    // WARNING: Subroutine does not return
  __assert_fail("0",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                ,0x2a1,"lyd_check_mandatory_data");
}



// WARNING: Type propagation algorithm not settling

int lyd_check_mandatory_subtree
              (lyd_node *tree,lyd_node *subtree,lyd_node *last_parent,lys_node *schema,int toplevel,
              int options)

{
  LYS_NODE LVar1;
  long lVar2;
  int iVar3;
  lys_node *plVar4;
  lyd_node *last_parent_00;
  lyd_node *subtree_00;
  int options_local;
  int toplevel_local;
  lys_node *schema_local;
  lyd_node *last_parent_local;
  lyd_node *subtree_local;
  lyd_node *tree_local;
  uint u;
  int ret;
  lys_node *siter;
  lys_node *siter_prev;
  lyd_node *iter;
  ly_set *present;
  
  present = (ly_set *)0x0;
  ret = 1;
  if (schema == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("schema",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x2c5,"lyd_check_mandatory_subtree");
  }
  plVar4 = lys_is_disabled(schema,0);
  if (plVar4 != (lys_node *)0x0) {
    return 0;
  }
  if ((schema->nodetype & (LYS_CONTAINER|LYS_LEAF|LYS_LEAFLIST|LYS_LIST|LYS_ANYDATA)) != LYS_UNKNOWN
     ) {
    present = ly_set_new();
    if (present == (ly_set *)0x0) goto LAB_001b04e8;
    if (((toplevel != 0) && (tree != (lyd_node *)0x0)) ||
       ((toplevel == 0 && (subtree != (lyd_node *)0x0)))) {
      if (toplevel == 0) {
        lyd_get_node_siblings(subtree->child,schema,present);
      }
      else {
        lyd_get_node_siblings(tree,schema,present);
      }
    }
  }
  LVar1 = schema->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_001b0105_caseD_4:
    iVar3 = lyd_check_mandatory_data(tree,last_parent,present,schema,options);
    goto joined_r0x001b0136;
  }
  if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
    if (LVar1 == LYS_USES) {
LAB_001b0476:
      for (siter = schema->child; siter != (lys_node *)0x0; siter = siter->next) {
        iVar3 = lyd_check_mandatory_subtree(tree,subtree,last_parent,siter,toplevel,options);
        if (iVar3 != 0) goto LAB_001b04e8;
      }
    }
    else if (LVar1 < (LYS_CONTAINER|LYS_USES)) {
      if (LVar1 == LYS_OUTPUT) goto LAB_001b0476;
      if (LVar1 < (LYS_CONTAINER|LYS_OUTPUT)) {
        if (LVar1 == LYS_INPUT) goto LAB_001b0476;
        if (LVar1 < (LYS_CONTAINER|LYS_INPUT)) {
          if (LVar1 == LYS_NOTIF) {
            if ((options & 0x40U) != 0) goto LAB_001b0476;
          }
          else if (LVar1 < (LYS_CONTAINER|LYS_NOTIF)) {
            if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
              if ((LVar1 != LYS_UNKNOWN) && (true)) {
                switch(LVar1) {
                case LYS_CONTAINER:
                  if ((present->number != 0) ||
                     (lVar2._0_2_ = schema[1].flags, lVar2._2_1_ = schema[1].ext_size,
                     lVar2._3_1_ = schema[1].iffeature_size, lVar2._4_1_ = schema[1].padding[0],
                     lVar2._5_1_ = schema[1].padding[1], lVar2._6_1_ = schema[1].padding[2],
                     lVar2._7_1_ = schema[1].padding[3], lVar2 == 0)) {
                    for (siter = schema->child; siter != (lys_node *)0x0; siter = siter->next) {
                      last_parent_00 = last_parent;
                      if (present->number != 0) {
                        last_parent_00 = *(present->set).d;
                      }
                      if (present->number == 0) {
                        subtree_00 = (lyd_node *)0x0;
                      }
                      else {
                        subtree_00 = *(present->set).d;
                      }
                      iVar3 = lyd_check_mandatory_subtree
                                        (tree,subtree_00,last_parent_00,siter,0,options);
                      if (iVar3 != 0) goto LAB_001b04e8;
                    }
                  }
                  break;
                case LYS_CHOICE:
                  iter = (lyd_node *)0x0;
                  if (((toplevel != 0) && (tree != (lyd_node *)0x0)) ||
                     ((toplevel == 0 && (subtree != (lyd_node *)0x0)))) {
                    iter = tree;
                    if (toplevel == 0) {
                      iter = subtree->child;
                    }
                    for (; iter != (lyd_node *)0x0; iter = iter->next) {
                      siter = lys_parent(iter->schema);
                      siter_prev = iter->schema;
                      for (; ((siter != (lys_node *)0x0 &&
                              ((siter->nodetype & 0x1042) != LYS_UNKNOWN)) && (siter != schema));
                          siter = lys_parent(siter)) {
                        siter_prev = siter;
                      }
                      if (siter == schema) break;
                    }
                  }
                  if (iter == (lyd_node *)0x0) {
                    iVar3 = lyd_is_when_false(tree,last_parent,schema,options);
                    if (iVar3 == 0) {
                      if (schema[1].name != (char *)0x0) {
                        iVar3 = lyd_check_mandatory_subtree
                                          (tree,subtree,last_parent,(lys_node *)schema[1].name,
                                           toplevel,options);
                        goto joined_r0x001b0136;
                      }
                      if ((schema->flags & 0x40) != 0) {
                        ly_vlog(schema->module->ctx,LYE_NOMANDCHOICE,LY_VLOG_LYD,last_parent,
                                schema->name);
                        goto LAB_001b04e8;
                      }
                    }
                  }
                  else {
                    if ((siter == (lys_node *)0x0) || (siter_prev == (lys_node *)0x0)) {
                    // WARNING: Subroutine does not return
                      __assert_fail("siter && siter_prev",
                                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                                    ,0x32a,"lyd_check_mandatory_subtree");
                    }
                    iVar3 = lyd_check_mandatory_subtree
                                      (tree,subtree,last_parent,siter_prev,toplevel,options);
joined_r0x001b0136:
                    if (iVar3 != 0) goto LAB_001b04e8;
                  }
                  break;
                case LYS_LEAF:
                case LYS_LEAFLIST:
                case LYS_ANYXML:
                  goto switchD_001b0105_caseD_4;
                case LYS_LIST:
                  iVar3 = lyd_check_mandatory_data(tree,last_parent,present,schema,options);
                  if (iVar3 != 0) goto LAB_001b04e8;
                  for (u = 0; u < present->number; u = u + 1) {
                    for (siter = schema->child; siter != (lys_node *)0x0; siter = siter->next) {
                      iVar3 = lyd_check_mandatory_subtree
                                        (tree,(lyd_node *)(present->set).s[u],
                                         (lyd_node *)(present->set).s[u],siter,0,options);
                      if (iVar3 != 0) goto LAB_001b04e8;
                    }
                  }
                }
              }
            }
            else if (LVar1 == LYS_CASE) goto LAB_001b0476;
          }
        }
      }
    }
  }
  ret = 0;
LAB_001b04e8:
  ly_set_free(present);
  return ret;
}



int lyd_check_mandatory_tree
              (lyd_node *root,ly_ctx *ctx,lys_module **modules,int mod_count,int options)

{
  int iVar1;
  int options_local;
  int mod_count_local;
  lys_module **modules_local;
  ly_ctx *ctx_local;
  lyd_node *root_local;
  int i;
  lys_node *siter;
  
  if ((root == (lyd_node *)0x0) && (ctx == (ly_ctx *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("root || ctx",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x354,"lyd_check_mandatory_tree");
  }
  if ((options & 0x100U) != 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("!(options & LYD_OPT_ACT_NOTIF)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x355,"lyd_check_mandatory_tree");
  }
  if ((options & 0x200eU) != 0) {
    return 0;
  }
  ctx_local = ctx;
  if (ctx == (ly_ctx *)0x0) {
    ctx_local = root->schema->module->ctx;
  }
  if (((options & 0x10000ffU) == 0) || ((options & 1U) != 0)) {
    if ((options & 0x1000U) == 0) {
      if ((modules == (lys_module **)0x0) || (mod_count == 0)) {
        for (i = 0; i < (ctx_local->models).used; i = i + 1) {
          if (((((ctx_local->models).list[i]->field_0x40 & 0x80) != 0) &&
              (((ctx_local->models).list[i]->field_0x40 & 0x40) == 0)) &&
             (((options & 0x10000U) == 0 ||
              (iVar1 = strcmp((ctx_local->models).list[i]->name,"ietf-yang-library"), iVar1 != 0))))
          {
            for (siter = (ctx_local->models).list[i]->data; siter != (lys_node *)0x0;
                siter = siter->next) {
              if (((siter->nodetype & 0x180) == LYS_UNKNOWN) &&
                 (iVar1 = lyd_check_mandatory_subtree
                                    (root,(lyd_node *)0x0,(lyd_node *)0x0,siter,1,options),
                 iVar1 != 0)) {
                return 1;
              }
            }
          }
        }
      }
      else {
        for (i = 0; i < mod_count; i = i + 1) {
          for (siter = modules[i]->data; siter != (lys_node *)0x0; siter = siter->next) {
            if (((siter->nodetype & 0x180) == LYS_UNKNOWN) &&
               (iVar1 = lyd_check_mandatory_subtree
                                  (root,(lyd_node *)0x0,(lyd_node *)0x0,siter,1,options), iVar1 != 0
               )) {
              return 1;
            }
          }
        }
      }
    }
    else if ((root != (lyd_node *)0x0) &&
            (iVar1 = lyd_check_mandatory_subtree
                               (root,(lyd_node *)0x0,(lyd_node *)0x0,root->schema,1,options),
            iVar1 != 0)) {
      return 1;
    }
  }
  else if ((options & 0x40U) == 0) {
    if ((options & 0x30U) == 0) {
      if ((options & 0x1000000U) == 0) {
        ly_log(ctx_local,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
               ,0x39b);
        return 1;
      }
      if ((root != (lyd_node *)0x0) &&
         (iVar1 = lyd_check_mandatory_subtree
                            (root,(lyd_node *)0x0,(lyd_node *)0x0,root->schema,1,options),
         iVar1 != 0)) {
        return 1;
      }
    }
    else {
      if ((root == (lyd_node *)0x0) || ((root->schema->nodetype & 0x4100) == LYS_UNKNOWN)) {
        ly_log(ctx_local,LY_LLERR,LY_EINVAL,"Subtree is not a single RPC/action/reply.");
        return 1;
      }
      if ((options & 0x10U) == 0) {
        for (siter = root->schema->child;
            (siter != (lys_node *)0x0 && (siter->nodetype != LYS_OUTPUT)); siter = siter->next) {
        }
      }
      else {
        for (siter = root->schema->child;
            (siter != (lys_node *)0x0 && (siter->nodetype != LYS_INPUT)); siter = siter->next) {
        }
      }
      if ((siter != (lys_node *)0x0) &&
         (iVar1 = lyd_check_mandatory_subtree(root,root,root,siter,0,options), iVar1 != 0)) {
        return 1;
      }
    }
  }
  else {
    if ((root == (lyd_node *)0x0) || (root->schema->nodetype != LYS_NOTIF)) {
      ly_log(ctx_local,LY_LLERR,LY_EINVAL,"Subtree is not a single notification.");
      return 1;
    }
    if ((root->schema->child != (lys_node *)0x0) &&
       (iVar1 = lyd_check_mandatory_subtree(root,root,root,root->schema,0,options), iVar1 != 0)) {
      return 1;
    }
  }
  return 0;
}



lyd_node *
lyd_parse_(ly_ctx *ctx,lyd_node *rpc_act,char *data,LYD_FORMAT format,int options,
          lyd_node *data_tree,char *yang_data_name)

{
  int iVar1;
  LY_ERR *pLVar2;
  lyd_node *plVar3;
  long in_FS_OFFSET;
  char *yang_data_name_local;
  lyd_node *data_tree_local;
  int options_local;
  LYD_FORMAT format_local;
  char *data_local;
  lyd_node *rpc_act_local;
  ly_ctx *ctx_local;
  int xmlopt;
  lyxml_elem *xml;
  lyd_node *result;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  result = (lyd_node *)0x0;
  if ((ctx == (ly_ctx *)0x0) || (data == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_parse_");
    plVar3 = (lyd_node *)0x0;
  }
  else {
    xmlopt = (int)((options & 0x1000U) == 0);
    pLVar2 = ly_errno_glob_address();
    *pLVar2 = LY_SUCCESS;
    if (format == LYD_LYB) {
      result = lyd_parse_lyb(ctx,data,options,data_tree,yang_data_name,(int *)0x0);
    }
    else if (format < 4) {
      if (format == LYD_XML) {
        xml = lyxml_parse_mem(ctx,data,xmlopt);
        pLVar2 = ly_errno_glob_address();
        if (*pLVar2 == LY_SUCCESS) {
          if ((options & 0x20U) == 0) {
            if ((options & 0x50U) == 0) {
              if ((options & 0x1000000U) == 0) {
                result = lyd_parse_xml(ctx,&xml,options);
              }
              else {
                result = lyd_parse_xml(ctx,&xml,options,yang_data_name);
              }
            }
            else {
              result = lyd_parse_xml(ctx,&xml,options,data_tree);
            }
          }
          else {
            result = lyd_parse_xml(ctx,&xml,options,rpc_act,data_tree);
          }
          lyxml_free_withsiblings(ctx,xml);
        }
      }
      else if (format == LYD_JSON) {
        result = lyd_parse_json(ctx,data,options,rpc_act,data_tree,yang_data_name);
      }
    }
    pLVar2 = ly_errno_glob_address();
    if (*pLVar2 == LY_SUCCESS) {
      plVar3 = result;
      if (((options & 0x30U) != 0) &&
         (iVar1 = lyd_schema_sort(result,1), plVar3 = result, iVar1 != 0)) {
        lyd_free_withsiblings(result);
        plVar3 = (lyd_node *)0x0;
      }
    }
    else {
      lyd_free_withsiblings(result);
      plVar3 = (lyd_node *)0x0;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar3;
}



lyd_node * lyd_parse_data_(ly_ctx *ctx,char *data,LYD_FORMAT format,int options,__va_list_tag *ap)

{
  int iVar1;
  long *plVar2;
  undefined8 *puVar3;
  lyd_node *plVar4;
  __va_list_tag *ap_local;
  int options_local;
  LYD_FORMAT format_local;
  char *data_local;
  ly_ctx *ctx_local;
  lyd_node *rpc_act;
  lyd_node *data_tree;
  lyd_node *iter;
  char *yang_data_name;
  
  rpc_act = (lyd_node *)0x0;
  data_tree = (lyd_node *)0x0;
  yang_data_name = (char *)0x0;
  iVar1 = lyp_data_check_options(ctx,options,"lyd_parse_data_");
  if (iVar1 != 0) {
    return (lyd_node *)0x0;
  }
  if ((options & 0x20U) != 0) {
    if (ap->gp_offset < 0x30) {
      plVar2 = (long *)((ulong)ap->gp_offset + (long)ap->reg_save_area);
      ap->gp_offset = ap->gp_offset + 8;
    }
    else {
      plVar2 = (long *)ap->overflow_arg_area;
      ap->overflow_arg_area = plVar2 + 1;
    }
    rpc_act = (lyd_node *)*plVar2;
    if (((rpc_act == (lyd_node *)0x0) || (rpc_act->parent != (lyd_node *)0x0)) ||
       ((rpc_act->schema->nodetype & (LYS_CONTAINER|LYS_LIST|LYS_RPC)) == LYS_UNKNOWN)) {
      ly_log(ctx,LY_LLERR,LY_EINVAL,
             "%s: invalid variable parameter (const struct lyd_node *rpc_act).","lyd_parse_data_");
      return (lyd_node *)0x0;
    }
  }
  if ((options & 0x70U) != 0) {
    if (ap->gp_offset < 0x30) {
      plVar2 = (long *)((ulong)ap->gp_offset + (long)ap->reg_save_area);
      ap->gp_offset = ap->gp_offset + 8;
    }
    else {
      plVar2 = (long *)ap->overflow_arg_area;
      ap->overflow_arg_area = plVar2 + 1;
    }
    data_tree = (lyd_node *)*plVar2;
    if (data_tree != (lyd_node *)0x0) {
      iter = data_tree;
      if ((options & 0x8000U) != 0) {
        ly_log(ctx,LY_LLERR,LY_EINVAL,
               "%s: invalid parameter (variable arg const struct lyd_node *data_tree and LYD_OPT_NOEXTDEPS set)."
               ,"lyd_parse_data_");
        return (lyd_node *)0x0;
      }
      for (; iter != (lyd_node *)0x0; iter = iter->next) {
        if (iter->parent != (lyd_node *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EINVAL,
                 "%s: invalid variable parameter (const struct lyd_node *data_tree).",
                 "lyd_parse_data_");
          return (lyd_node *)0x0;
        }
      }
      while (data_tree->prev->next != (lyd_node *)0x0) {
        data_tree = data_tree->prev;
      }
      if ((options & 0x1000U) != 0) {
        ly_log(ctx,LY_LLERR,LY_EINVAL,
               "%s: invalid parameter (variable arg const struct lyd_node *data_tree with LYD_OPT_NOSIBLINGS)."
               ,"lyd_parse_data_");
        return (lyd_node *)0x0;
      }
    }
  }
  if ((options & 0x1000000U) != 0) {
    if (ap->gp_offset < 0x30) {
      puVar3 = (undefined8 *)((ulong)ap->gp_offset + (long)ap->reg_save_area);
      ap->gp_offset = ap->gp_offset + 8;
    }
    else {
      puVar3 = (undefined8 *)ap->overflow_arg_area;
      ap->overflow_arg_area = puVar3 + 1;
    }
    yang_data_name = (char *)*puVar3;
  }
  plVar4 = lyd_parse_(ctx,rpc_act,data,format,options,data_tree,yang_data_name);
  return plVar4;
}



lyd_node * lyd_parse_mem(ly_ctx *ctx,char *data,LYD_FORMAT format,int options,...)

{
  long lVar1;
  char in_AL;
  lyd_node *plVar2;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  int options_local;
  LYD_FORMAT format_local;
  char *data_local;
  ly_ctx *ctx_local;
  lyd_node *result;
  va_list ap;
  undefined local_b8 [32];
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  local_98 = in_R8;
  local_90 = in_R9;
  ly_log_dbg(0x20,"%s","lyd_parse_mem");
  ap[0].gp_offset = 0x20;
  ap[0].fp_offset = 0x30;
  ap[0].overflow_arg_area = &stack0x00000008;
  ap[0].reg_save_area = local_b8;
  plVar2 = lyd_parse_data_(ctx,data,format,options,ap);
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar2;
}



lyd_node * lyd_parse_fd_(ly_ctx *ctx,int fd,LYD_FORMAT format,int options,__va_list_tag *ap)

{
  int iVar1;
  lyd_node *plVar2;
  long in_FS_OFFSET;
  __va_list_tag *ap_local;
  int options_local;
  LYD_FORMAT format_local;
  int fd_local;
  ly_ctx *ctx_local;
  size_t length;
  char *data;
  lyd_node *ret;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((ctx == (ly_ctx *)0x0) || (fd == -1)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_parse_fd_");
    plVar2 = (lyd_node *)0x0;
  }
  else {
    iVar1 = lyp_mmap(ctx,fd,0,&length,&data);
    if (iVar1 == 0) {
      if (data == (char *)0x0) {
        plVar2 = (lyd_node *)0x0;
      }
      else {
        ret = lyd_parse_data_(ctx,data,format,options,ap);
        lyp_munmap(data,length);
        plVar2 = ret;
      }
    }
    else {
      ly_log(ctx,LY_LLERR,LY_ESYS,"Mapping file descriptor into memory failed (%s()).",
             "lyd_parse_fd_");
      plVar2 = (lyd_node *)0x0;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar2;
}



lyd_node * lyd_parse_fd(ly_ctx *ctx,int fd,LYD_FORMAT format,int options,...)

{
  long lVar1;
  char in_AL;
  lyd_node *plVar2;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  int options_local;
  LYD_FORMAT format_local;
  int fd_local;
  ly_ctx *ctx_local;
  lyd_node *ret;
  va_list ap;
  undefined local_b8 [32];
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  local_98 = in_R8;
  local_90 = in_R9;
  ly_log_dbg(0x20,"%s","lyd_parse_fd");
  ap[0].gp_offset = 0x20;
  ap[0].fp_offset = 0x30;
  ap[0].overflow_arg_area = &stack0x00000008;
  ap[0].reg_save_area = local_b8;
  plVar2 = lyd_parse_fd_(ctx,fd,format,options,ap);
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar2;
}



lyd_node * lyd_parse_path(ly_ctx *ctx,char *path,LYD_FORMAT format,int options,...)

{
  long lVar1;
  char in_AL;
  int fd_00;
  lyd_node *plVar2;
  int *piVar3;
  char *pcVar4;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  int options_local;
  LYD_FORMAT format_local;
  char *path_local;
  ly_ctx *ctx_local;
  int fd;
  lyd_node *ret;
  va_list ap;
  undefined local_b8 [32];
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  local_98 = in_R8;
  local_90 = in_R9;
  ly_log_dbg(0x20,"%s","lyd_parse_path");
  if ((ctx == (ly_ctx *)0x0) || (path == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_parse_path");
    plVar2 = (lyd_node *)0x0;
  }
  else {
    fd_00 = open(path,0);
    if (fd_00 == -1) {
      piVar3 = __errno_location();
      pcVar4 = strerror(*piVar3);
      ly_log(ctx,LY_LLERR,LY_ESYS,"Failed to open data file \"%s\" (%s).",path,pcVar4);
      plVar2 = (lyd_node *)0x0;
    }
    else {
      ap[0].gp_offset = 0x20;
      ap[0].fp_offset = 0x30;
      ap[0].overflow_arg_area = &stack0x00000008;
      ap[0].reg_save_area = local_b8;
      plVar2 = lyd_parse_fd_(ctx,fd_00,format,options,ap);
      close(fd_00);
    }
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar2;
}



lys_node * lyd_new_find_schema(lyd_node *parent,lys_module *module,int rpc_output)

{
  LYS_NODE LVar1;
  int rpc_output_local;
  lys_module *module_local;
  lyd_node *parent_local;
  lys_node *siblings;
  
  if (parent == (lyd_node *)0x0) {
    siblings = module->data;
  }
  else if (parent->schema == (lys_node *)0x0) {
    siblings = (lys_node *)0x0;
  }
  else {
    siblings = parent->schema->child;
    if (siblings != (lys_node *)0x0) {
      if (rpc_output == 0) {
        LVar1 = LYS_OUTPUT;
      }
      else {
        LVar1 = LYS_INPUT;
      }
      if (LVar1 == siblings->nodetype) {
        siblings = siblings->next;
      }
    }
    if (siblings != (lys_node *)0x0) {
      if (rpc_output == 0) {
        LVar1 = LYS_INPUT;
      }
      else {
        LVar1 = LYS_OUTPUT;
      }
      if (LVar1 == siblings->nodetype) {
        siblings = siblings->child;
      }
    }
  }
  return siblings;
}



lyd_node * _lyd_new(lyd_node *parent,lys_node *schema,int dflt)

{
  int iVar1;
  lyd_node *node;
  int dflt_local;
  lys_node *schema_local;
  lyd_node *parent_local;
  lyd_node *ret;
  
  node = (lyd_node *)calloc(1,0x48);
  if (node == (lyd_node *)0x0) {
    ly_log(schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","_lyd_new");
    node = (lyd_node *)0x0;
  }
  else {
    node->schema = schema;
    iVar1 = ly_new_node_validity(schema);
    node->validity = (uint8_t)iVar1;
    iVar1 = resolve_applies_when(schema,0,(lys_node *)0x0);
    if (iVar1 != 0) {
      node->field_0x9 = node->field_0x9 & 0xf1 | 8;
    }
    node->prev = node;
    node->field_0x9 = node->field_0x9 & 0xfe | (byte)dflt & 1;
    lyd_hash(node);
    if ((parent != (lyd_node *)0x0) && (iVar1 = lyd_insert(parent,node), iVar1 != 0)) {
      lyd_free(node);
      node = (lyd_node *)0x0;
    }
  }
  return node;
}



lyd_node * lyd_new(lyd_node *parent,lys_module *module,char *name)

{
  char *pcVar1;
  int iVar2;
  lyd_node *plVar3;
  size_t sVar4;
  lys_node *parent_00;
  lys_module *plVar5;
  long in_FS_OFFSET;
  char *name_local;
  lys_module *module_local;
  lyd_node *parent_local;
  lys_node *snode;
  lys_node *siblings;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_new");
  snode = (lys_node *)0x0;
  if (((parent == (lyd_node *)0x0) && (module == (lys_module *)0x0)) || (name == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new");
    plVar3 = (lyd_node *)0x0;
  }
  else {
    siblings = lyd_new_find_schema(parent,module,0);
    if (siblings == (lys_node *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new");
      plVar3 = (lyd_node *)0x0;
    }
    else {
      sVar4 = strlen(name);
      parent_00 = lys_parent(siblings);
      iVar2 = lys_getnext_data(module,parent_00,name,(int)sVar4,0x4191,0,&snode);
      if ((iVar2 == 0) && (snode != (lys_node *)0x0)) {
        plVar3 = _lyd_new(parent,snode,0);
      }
      else {
        pcVar1 = siblings->name;
        plVar5 = lys_node_module(siblings);
        ly_log(siblings->module->ctx,LY_LLERR,LY_EINVAL,
               "Failed to find \"%s\" as a sibling to \"%s:%s\".",name,plVar5->name,pcVar1);
        plVar3 = (lyd_node *)0x0;
      }
    }
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar3;
}



lyd_node * lyd_create_leaf(lys_node *schema,char *val_str,int dflt)

{
  int iVar1;
  lyd_node *node;
  hash_table *phVar2;
  int dflt_local;
  char *val_str_local;
  lys_node *schema_local;
  lyd_node_leaf_list *ret;
  
  node = (lyd_node *)calloc(1,0x50);
  if (node == (lyd_node *)0x0) {
    ly_log(schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_create_leaf"
          );
    node = (lyd_node *)0x0;
  }
  else {
    node->schema = schema;
    iVar1 = ly_new_node_validity(schema);
    node->validity = (uint8_t)iVar1;
    iVar1 = resolve_applies_when(schema,0,(lys_node *)0x0);
    if (iVar1 != 0) {
      node->field_0x9 = node->field_0x9 & 0xf1 | 8;
    }
    node->prev = node;
    *(undefined4 *)&node[1].schema = *(undefined4 *)&schema[1].ref;
    if (val_str == (char *)0x0) {
      val_str = "";
    }
    phVar2 = (hash_table *)lydict_insert(schema->module->ctx,val_str,0);
    node->ht = phVar2;
    node->field_0x9 = node->field_0x9 & 0xfe | (byte)dflt & 1;
    lyd_hash(node);
  }
  return node;
}



lyd_node * _lyd_new_leaf(lyd_node *parent,lys_node *schema,char *val_str,int dflt,int edit_leaf)

{
  int iVar1;
  lyd_node_leaf_list *leaf;
  lys_type *plVar2;
  int edit_leaf_local;
  int dflt_local;
  char *val_str_local;
  lys_node *schema_local;
  lyd_node *parent_local;
  lyd_node *ret;
  
  leaf = (lyd_node_leaf_list *)lyd_create_leaf(schema,val_str,dflt);
  if (leaf == (lyd_node_leaf_list *)0x0) {
    leaf = (lyd_node_leaf_list *)0x0;
  }
  else if ((parent == (lyd_node *)0x0) || (iVar1 = lyd_insert(parent,(lyd_node *)leaf), iVar1 == 0))
  {
    if ((edit_leaf == 0) || (*leaf->value_str != '\0')) {
      plVar2 = lyp_parse_value((lys_type *)&leaf->schema[1].ref,&leaf->value_str,(lyxml_elem *)0x0,
                               leaf,(lyd_attr *)0x0,(lys_module *)0x0,1,dflt,0);
      if (plVar2 == (lys_type *)0x0) {
        lyd_free((lyd_node *)leaf);
        leaf = (lyd_node_leaf_list *)0x0;
      }
      else if ((leaf->schema->nodetype == LYS_LEAF) &&
              (parent_local = parent, (leaf->schema->flags & 0x100) != 0)) {
        while ((parent_local != (lyd_node *)0x0 && (parent_local->schema->nodetype != LYS_LIST))) {
          parent_local = parent_local->parent;
        }
        if (parent_local == (lyd_node *)0x0) {
          ly_log(schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                 ,0x4f4);
        }
        else {
          parent_local->validity = parent_local->validity | 2;
        }
      }
    }
    else {
      leaf->value_type = LY_TYPE_UNKNOWN;
    }
  }
  else {
    lyd_free((lyd_node *)leaf);
    leaf = (lyd_node_leaf_list *)0x0;
  }
  return (lyd_node *)leaf;
}



lyd_node * lyd_new_leaf(lyd_node *parent,lys_module *module,char *name,char *val_str)

{
  char *pcVar1;
  int iVar2;
  lyd_node *plVar3;
  size_t sVar4;
  lys_node *parent_00;
  lys_module *plVar5;
  long in_FS_OFFSET;
  char *val_str_local;
  char *name_local;
  lys_module *module_local;
  lyd_node *parent_local;
  lys_node *snode;
  lys_node *siblings;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_new_leaf");
  snode = (lys_node *)0x0;
  if (((parent == (lyd_node *)0x0) && (module == (lys_module *)0x0)) || (name == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new_leaf");
    plVar3 = (lyd_node *)0x0;
  }
  else {
    siblings = lyd_new_find_schema(parent,module,0);
    if (siblings == (lys_node *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new_leaf");
      plVar3 = (lyd_node *)0x0;
    }
    else {
      sVar4 = strlen(name);
      parent_00 = lys_parent(siblings);
      iVar2 = lys_getnext_data(module,parent_00,name,(int)sVar4,LYS_LEAF|LYS_LEAFLIST,0,&snode);
      if ((iVar2 == 0) && (snode != (lys_node *)0x0)) {
        plVar3 = _lyd_new_leaf(parent,snode,val_str,0,0);
      }
      else {
        pcVar1 = siblings->name;
        plVar5 = lys_node_module(siblings);
        ly_log(siblings->module->ctx,LY_LLERR,LY_EINVAL,
               "Failed to find \"%s\" as a sibling to \"%s:%s\".",name,plVar5->name,pcVar1);
        plVar3 = (lyd_node *)0x0;
      }
    }
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar3;
}



void lyd_wd_update_parents(lyd_node *node)

{
  lys_node *plVar1;
  long lVar2;
  lyd_node *node_local;
  lyd_node *parent;
  lyd_node *iter;
  
  parent = node->parent;
  node_local = node;
  while( true ) {
    if ((((parent == (lyd_node *)0x0) || ((parent->field_0x9 & 1) != 0)) ||
        (parent->schema->nodetype != LYS_CONTAINER)) ||
       (plVar1 = parent->schema, lVar2._0_2_ = plVar1[1].flags, lVar2._2_1_ = plVar1[1].ext_size,
       lVar2._3_1_ = plVar1[1].iffeature_size, lVar2._4_1_ = plVar1[1].padding[0],
       lVar2._5_1_ = plVar1[1].padding[1], lVar2._6_1_ = plVar1[1].padding[2],
       lVar2._7_1_ = plVar1[1].padding[3], lVar2 != 0)) {
      return;
    }
    for (iter = node_local->prev; (iter != node_local && ((iter->field_0x9 & 1) != 0));
        iter = iter->prev) {
    }
    if (iter != node_local) break;
    if (node_local == node_local->prev) {
      return;
    }
    node_local = node_local->parent;
    node_local->field_0x9 = node_local->field_0x9 | 1;
    parent = node_local->parent;
  }
  return;
}



void check_leaf_list_backlinks(lyd_node *node)

{
  lys_node *plVar1;
  lys_node *leaf;
  bool bVar2;
  ly_set *set_00;
  lyd_node *node_local;
  uint32_t i;
  uint32_t j;
  int validity_changed;
  lyd_node *iter;
  lyd_node *next;
  ly_set *set;
  ly_set *data;
  lyd_node_leaf_list *leaf_list;
  
  bVar2 = false;
  iter = node;
  while (iter != (lyd_node *)0x0) {
    if (((iter->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) &&
       (iter->schema->child != (lys_node *)0x0)) {
      plVar1 = iter->schema->child;
      for (i = 0; i < *(uint *)((long)&plVar1->name + 4); i = i + 1) {
        set_00 = lyd_find_instance(iter,*(lys_node **)(plVar1->dsc + (ulong)i * 8));
        if (set_00 == (ly_set *)0x0) {
          ly_log(node->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                 ,0x557);
          return;
        }
        for (j = 0; j < set_00->number; j = j + 1) {
          leaf = (set_00->set).s[j];
          *(byte *)&leaf->dsc = *(byte *)&leaf->dsc | 8;
          bVar2 = true;
          if (*(LY_DATA_TYPE *)&leaf->child == LY_TYPE_LEAFREF) {
            lyp_parse_value((lys_type *)&((lys_node *)leaf->name)[1].ref,(char **)&leaf->nodetype,
                            (lyxml_elem *)0x0,(lyd_node_leaf_list *)leaf,(lyd_attr *)0x0,
                            (lys_module *)0x0,1,(uint)(*(byte *)((long)&leaf->dsc + 1) & 1),0);
          }
        }
        ly_set_free(set_00);
      }
    }
    if ((iter->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
      next = iter->child;
    }
    else {
      next = (lyd_node *)0x0;
    }
    if (next == (lyd_node *)0x0) {
      if (iter == node) break;
      next = iter->next;
    }
    while ((next == (lyd_node *)0x0 && (iter = iter->parent, iter->parent != node->parent))) {
      next = iter->next;
    }
    iter = next;
  }
  if ((bVar2) && (node->parent != (lyd_node *)0x0)) {
    node->parent->validity = node->parent->validity | 4;
  }
  return;
}



int lyd_change_leaf(lyd_node_leaf_list *leaf,char *val_str)

{
  char *__s1;
  bool bVar1;
  int iVar2;
  int iVar3;
  char *pcVar4;
  lys_type *plVar5;
  char *val_str_local;
  lyd_node_leaf_list *leaf_local;
  int val_change;
  int dflt_change;
  lyd_node *parent;
  char *backup;
  
  ly_log_dbg(0x20,"%s","lyd_change_leaf");
  if ((leaf == (lyd_node_leaf_list *)0x0) || (leaf->schema->nodetype != LYS_LEAF)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_change_leaf");
    iVar2 = -1;
  }
  else {
    __s1 = leaf->value_str;
    if (val_str == (char *)0x0) {
      val_str = "";
    }
    pcVar4 = lydict_insert(leaf->schema->module->ctx,val_str,0);
    leaf->value_str = pcVar4;
    plVar5 = lyp_parse_value((lys_type *)&leaf->schema[1].ref,&leaf->value_str,(lyxml_elem *)0x0,
                             leaf,(lyd_attr *)0x0,(lys_module *)0x0,1,0,0);
    if (plVar5 == (lys_type *)0x0) {
      lydict_remove(leaf->schema->module->ctx,__s1);
      iVar2 = -1;
    }
    else {
      iVar2 = strcmp(__s1,leaf->value_str);
      lydict_remove(leaf->schema->module->ctx,__s1);
      parent = (lyd_node *)leaf;
      if ((leaf->field_0x9 & 1) == 0) {
        bVar1 = false;
      }
      else {
        for (; parent != (lyd_node *)0x0; parent = parent->parent) {
          parent->field_0x9 = parent->field_0x9 & 0xfe;
        }
        bVar1 = true;
      }
      if (iVar2 != 0) {
        iVar3 = ly_new_node_validity(leaf->schema);
        leaf->validity = (uint8_t)iVar3;
        check_leaf_list_backlinks((lyd_node *)leaf);
        if ((leaf->schema->flags & 0x100) != 0) {
          parent = leaf->parent;
          while ((parent != (lyd_node *)0x0 && (parent->schema->nodetype != LYS_LIST))) {
            parent = parent->parent;
          }
          if (parent != (lyd_node *)0x0) {
            parent->validity = parent->validity | 2;
          }
        }
      }
      if ((iVar2 != 0) || (bVar1)) {
        iVar2 = 0;
      }
      else {
        iVar2 = 1;
      }
    }
  }
  return iVar2;
}



lyd_node *
lyd_create_anydata(lyd_node *parent,lys_node *schema,void *value,LYD_ANYDATA_VALUETYPE value_type)

{
  int iVar1;
  lyd_node *node;
  hash_table *phVar2;
  LYD_ANYDATA_VALUETYPE value_type_local;
  void *value_local;
  lys_node *schema_local;
  lyd_node *parent_local;
  int len;
  lyd_node *iter;
  lyd_node_anydata *ret;
  
  node = (lyd_node *)calloc(1,0x40);
  if (node == (lyd_node *)0x0) {
    ly_log(schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
           "lyd_create_anydata");
    return (lyd_node *)0x0;
  }
  node->schema = schema;
  iVar1 = ly_new_node_validity(schema);
  node->validity = (uint8_t)iVar1;
  iVar1 = resolve_applies_when(schema,0,(lys_node *)0x0);
  if (iVar1 != 0) {
    node->field_0x9 = node->field_0x9 & 0xf1 | 8;
  }
  node->prev = node;
  value_type_local = value_type;
  if (true) {
    switch(value_type) {
    case LYD_ANYDATA_CONSTSTRING:
    case LYD_ANYDATA_JSON:
    case LYD_ANYDATA_SXML:
      phVar2 = (hash_table *)lydict_insert(schema->module->ctx,(char *)value,0);
      node->ht = phVar2;
      break;
    case LYD_ANYDATA_STRING:
    case LYD_ANYDATA_JSOND:
    case LYD_ANYDATA_SXMLD:
      phVar2 = (hash_table *)lydict_insert_zc(schema->module->ctx,(char *)value);
      node->ht = phVar2;
      value_type_local = value_type & 0xfffffffe;
      break;
    case LYD_ANYDATA_XML:
      node->ht = (hash_table *)value;
      break;
    case LYD_ANYDATA_DATATREE:
      node->ht = (hash_table *)value;
      break;
    case LYD_ANYDATA_LYB:
      iVar1 = lyd_lyb_data_length((char *)value);
      if (iVar1 == -1) {
        ly_log(schema->module->ctx,LY_LLERR,LY_EINVAL,"Invalid LYB data.");
        return (lyd_node *)0x0;
      }
      phVar2 = (hash_table *)malloc((long)iVar1);
      node->ht = phVar2;
      if (node->ht == (hash_table *)0x0) {
        ly_log(schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "lyd_create_anydata");
        free(node);
        return (lyd_node *)0x0;
      }
      memcpy(node->ht,value,(long)iVar1);
      break;
    case LYD_ANYDATA_LYBD:
      node->ht = (hash_table *)value;
      value_type_local = value_type & 0xfffffffe;
    }
  }
  *(LYD_ANYDATA_VALUETYPE *)&node->field_0x34 = value_type_local;
  lyd_hash(node);
  if (parent != (lyd_node *)0x0) {
    iVar1 = lyd_insert(parent,node);
    iter = parent;
    if (iVar1 == 0) {
      for (; (iter != (lyd_node *)0x0 && ((iter->field_0x9 & 1) != 0)); iter = iter->parent) {
        iter->field_0x9 = iter->field_0x9 & 0xfe;
      }
    }
    else {
      lyd_free(node);
      node = (lyd_node *)0x0;
    }
  }
  return node;
}



lyd_node *
lyd_new_anydata(lyd_node *parent,lys_module *module,char *name,void *value,
               LYD_ANYDATA_VALUETYPE value_type)

{
  char *pcVar1;
  int iVar2;
  lyd_node *plVar3;
  size_t sVar4;
  lys_node *parent_00;
  lys_module *plVar5;
  long in_FS_OFFSET;
  LYD_ANYDATA_VALUETYPE value_type_local;
  void *value_local;
  char *name_local;
  lys_module *module_local;
  lyd_node *parent_local;
  lys_node *snode;
  lys_node *siblings;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_new_anydata");
  if (((parent == (lyd_node *)0x0) && (module == (lys_module *)0x0)) || (name == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new_anydata");
    plVar3 = (lyd_node *)0x0;
  }
  else {
    siblings = lyd_new_find_schema(parent,module,0);
    if (siblings == (lys_node *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new_anydata");
      plVar3 = (lyd_node *)0x0;
    }
    else {
      sVar4 = strlen(name);
      parent_00 = lys_parent(siblings);
      iVar2 = lys_getnext_data(module,parent_00,name,(int)sVar4,LYS_ANYDATA,0,&snode);
      if ((iVar2 == 0) && (snode != (lys_node *)0x0)) {
        plVar3 = lyd_create_anydata(parent,snode,value,value_type);
      }
      else {
        pcVar1 = siblings->name;
        plVar5 = lys_node_module(siblings);
        ly_log(siblings->module->ctx,LY_LLERR,LY_EINVAL,
               "Failed to find \"%s\" as a sibling to \"%s:%s\".",name,plVar5->name,pcVar1);
        plVar3 = (lyd_node *)0x0;
      }
    }
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar3;
}



lyd_node * lyd_new_yangdata(lys_module *module,char *name_template,char *name)

{
  int iVar1;
  lyd_node *plVar2;
  size_t sVar3;
  long in_FS_OFFSET;
  char *name_local;
  char *name_template_local;
  lys_module *module_local;
  lys_node *snode;
  lys_node *schema;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_new_yangdata");
  schema = (lys_node *)0x0;
  if (((module == (lys_module *)0x0) || (name_template == (char *)0x0)) || (name == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new_yangdata");
    plVar2 = (lyd_node *)0x0;
  }
  else {
    sVar3 = strlen(name_template);
    schema = lyp_get_yang_data_template(module,name_template,(int)sVar3);
    if (schema == (lys_node *)0x0) {
      ly_log(module->ctx,LY_LLERR,LY_EINVAL,"Failed to find yang-data template \"%s\".",
             name_template);
      plVar2 = (lyd_node *)0x0;
    }
    else {
      sVar3 = strlen(name);
      iVar1 = lys_getnext_data(module,schema,name,(int)sVar3,LYS_CONTAINER,0,&snode);
      if ((iVar1 == 0) && (snode != (lys_node *)0x0)) {
        plVar2 = _lyd_new((lyd_node *)0x0,snode,0);
      }
      else {
        ly_log(module->ctx,LY_LLERR,LY_EINVAL,
               "Failed to find \"%s\" as a container child of \"%s:%s\".",name,module->name,
               schema->name);
        plVar2 = (lyd_node *)0x0;
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar2;
}



lyd_node * lyd_new_output(lyd_node *parent,lys_module *module,char *name)

{
  char *pcVar1;
  int iVar2;
  lyd_node *plVar3;
  size_t sVar4;
  lys_node *parent_00;
  lys_module *plVar5;
  long in_FS_OFFSET;
  char *name_local;
  lys_module *module_local;
  lyd_node *parent_local;
  lys_node *snode;
  lys_node *siblings;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_new_output");
  snode = (lys_node *)0x0;
  if (((parent == (lyd_node *)0x0) && (module == (lys_module *)0x0)) || (name == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new_output");
    plVar3 = (lyd_node *)0x0;
  }
  else {
    siblings = lyd_new_find_schema(parent,module,1);
    if (siblings == (lys_node *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new_output");
      plVar3 = (lyd_node *)0x0;
    }
    else {
      sVar4 = strlen(name);
      parent_00 = lys_parent(siblings);
      iVar2 = lys_getnext_data(module,parent_00,name,(int)sVar4,0x4191,0,&snode);
      if ((iVar2 == 0) && (snode != (lys_node *)0x0)) {
        plVar3 = _lyd_new(parent,snode,0);
      }
      else {
        pcVar1 = siblings->name;
        plVar5 = lys_node_module(siblings);
        ly_log(siblings->module->ctx,LY_LLERR,LY_EINVAL,
               "Failed to find \"%s\" as a sibling to \"%s:%s\".",name,plVar5->name,pcVar1);
        plVar3 = (lyd_node *)0x0;
      }
    }
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar3;
}



lyd_node * lyd_new_output_leaf(lyd_node *parent,lys_module *module,char *name,char *val_str)

{
  char *pcVar1;
  int iVar2;
  lyd_node *plVar3;
  size_t sVar4;
  lys_node *parent_00;
  lys_module *plVar5;
  long in_FS_OFFSET;
  char *val_str_local;
  char *name_local;
  lys_module *module_local;
  lyd_node *parent_local;
  lys_node *snode;
  lys_node *siblings;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_new_output_leaf");
  snode = (lys_node *)0x0;
  if (((parent == (lyd_node *)0x0) && (module == (lys_module *)0x0)) || (name == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new_output_leaf");
    plVar3 = (lyd_node *)0x0;
  }
  else {
    siblings = lyd_new_find_schema(parent,module,1);
    if (siblings == (lys_node *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new_output_leaf");
      plVar3 = (lyd_node *)0x0;
    }
    else {
      sVar4 = strlen(name);
      parent_00 = lys_parent(siblings);
      iVar2 = lys_getnext_data(module,parent_00,name,(int)sVar4,LYS_LEAF|LYS_LEAFLIST,0,&snode);
      if ((iVar2 == 0) && (snode != (lys_node *)0x0)) {
        plVar3 = _lyd_new_leaf(parent,snode,val_str,0,0);
      }
      else {
        pcVar1 = siblings->name;
        plVar5 = lys_node_module(siblings);
        ly_log(siblings->module->ctx,LY_LLERR,LY_EINVAL,
               "Failed to find \"%s\" as a sibling to \"%s:%s\".",name,plVar5->name,pcVar1);
        plVar3 = (lyd_node *)0x0;
      }
    }
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar3;
}



lyd_node *
lyd_new_output_anydata
          (lyd_node *parent,lys_module *module,char *name,void *value,
          LYD_ANYDATA_VALUETYPE value_type)

{
  char *pcVar1;
  int iVar2;
  lyd_node *plVar3;
  size_t sVar4;
  lys_node *parent_00;
  lys_module *plVar5;
  long in_FS_OFFSET;
  LYD_ANYDATA_VALUETYPE value_type_local;
  void *value_local;
  char *name_local;
  lys_module *module_local;
  lyd_node *parent_local;
  lys_node *snode;
  lys_node *siblings;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_new_output_anydata");
  if (((parent == (lyd_node *)0x0) && (module == (lys_module *)0x0)) || (name == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new_output_anydata");
    plVar3 = (lyd_node *)0x0;
  }
  else {
    siblings = lyd_new_find_schema(parent,module,1);
    if (siblings == (lys_node *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new_output_anydata");
      plVar3 = (lyd_node *)0x0;
    }
    else {
      sVar4 = strlen(name);
      parent_00 = lys_parent(siblings);
      iVar2 = lys_getnext_data(module,parent_00,name,(int)sVar4,LYS_ANYDATA,0,&snode);
      if ((iVar2 == 0) && (snode != (lys_node *)0x0)) {
        plVar3 = lyd_create_anydata(parent,snode,value,value_type);
      }
      else {
        pcVar1 = siblings->name;
        plVar5 = lys_node_module(siblings);
        ly_log(siblings->module->ctx,LY_LLERR,LY_EINVAL,
               "Failed to find \"%s\" as a sibling to \"%s:%s\".",name,plVar5->name,pcVar1);
        plVar3 = (lyd_node *)0x0;
      }
    }
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar3;
}



char * lyd_make_canonical(lys_node *schema,char *val_str,int val_str_len)

{
  char *pcVar1;
  lyd_node_leaf_list *leaf;
  lys_type *plVar2;
  int val_str_len_local;
  char *val_str_local;
  lys_node *schema_local;
  char *str;
  lyd_node *node;
  
  if ((schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) {
    pcVar1 = strndup(val_str,(long)val_str_len);
    if (pcVar1 == (char *)0x0) {
      ly_log(schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
             "lyd_make_canonical");
      pcVar1 = (char *)0x0;
    }
    else {
      leaf = (lyd_node_leaf_list *)lyd_create_leaf(schema,pcVar1,0);
      free(pcVar1);
      if (leaf == (lyd_node_leaf_list *)0x0) {
        pcVar1 = (char *)0x0;
      }
      else {
        plVar2 = lyp_parse_value((lys_type *)&leaf->schema[1].ref,&leaf->value_str,(lyxml_elem *)0x0
                                 ,leaf,(lyd_attr *)0x0,(lys_module *)0x0,1,0,0);
        if (plVar2 == (lys_type *)0x0) {
          lyd_free((lyd_node *)leaf);
          pcVar1 = (char *)0x0;
        }
        else {
          pcVar1 = strdup(leaf->value_str);
          lyd_free((lyd_node *)leaf);
          if (pcVar1 == (char *)0x0) {
            ly_log(schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "lyd_make_canonical");
            pcVar1 = (char *)0x0;
          }
        }
      }
    }
    return pcVar1;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("schema->nodetype & (LYS_LEAF | LYS_LEAFLIST)",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                ,0x67d,"lyd_make_canonical");
}



int lyd_new_path_list_predicate(lyd_node *list,char *list_name,char *predicate,int *parsed)

{
  char *__s2;
  int iVar1;
  ushort **ppuVar2;
  lys_module *plVar3;
  lys_module *plVar4;
  lyd_node *plVar5;
  size_t __n;
  long in_FS_OFFSET;
  int *parsed_local;
  char *predicate_local;
  char *list_name_local;
  lyd_node *list_local;
  int mod_name_len;
  int nam_len;
  int val_len;
  int has_predicate;
  int r;
  int i;
  char *mod_name;
  char *name;
  char *value;
  lys_node_list *slist;
  lys_node *key;
  char *key_val;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  slist = (lys_node_list *)list->schema;
  r = parse_schema_json_predicate
                (predicate,&mod_name,&mod_name_len,&name,&nam_len,&value,&val_len,&has_predicate);
  if (0 < r) {
    iVar1 = strncmp(name,".",(long)nam_len);
    if (iVar1 != 0) {
      ppuVar2 = __ctype_b_loc();
      if (((*ppuVar2)[*name] & 0x800) == 0) {
        if (slist->keys_size == '\0') {
          iVar1 = 0;
        }
        else {
          i = 0;
          predicate_local = predicate;
          do {
            key = (lys_node *)slist->keys[i];
            *parsed = *parsed + r;
            predicate_local = predicate_local + r;
            if (value == (char *)0x0) {
LAB_001b3332:
              ly_vlog(slist->module->ctx,LYE_PATH_INKEY,LY_VLOG_NONE,(void *)0x0,name);
              iVar1 = -1;
              goto LAB_001b3448;
            }
            if (mod_name == (char *)0x0) {
              plVar3 = lys_node_module(key);
              plVar4 = lys_node_module((lys_node *)slist);
              if (plVar3 != plVar4) goto LAB_001b3332;
            }
            __s2 = mod_name;
            if (mod_name != (char *)0x0) {
              __n = (size_t)mod_name_len;
              plVar3 = lys_node_module(key);
              iVar1 = strncmp(plVar3->name,__s2,__n);
              if (iVar1 == 0) {
                plVar3 = lys_node_module(key);
                if (plVar3->name[mod_name_len] == '\0') goto LAB_001b32fc;
              }
              goto LAB_001b3332;
            }
LAB_001b32fc:
            iVar1 = strncmp(key->name,name,(long)nam_len);
            if ((iVar1 != 0) || (key->name[nam_len] != '\0')) goto LAB_001b3332;
            key_val = (char *)malloc((long)(val_len + 1));
            if (key_val == (char *)0x0) {
              ly_log(slist->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "lyd_new_path_list_predicate");
              iVar1 = -1;
              goto LAB_001b3448;
            }
            strncpy(key_val,value,(long)val_len);
            key_val[val_len] = '\0';
            plVar5 = _lyd_new_leaf(list,key,key_val,0,0);
            if (plVar5 == (lyd_node *)0x0) {
              free(key_val);
              iVar1 = -1;
              goto LAB_001b3448;
            }
            free(key_val);
            i = i + 1;
            if ((int)(uint)slist->keys_size <= i) {
              iVar1 = 0;
              goto LAB_001b3448;
            }
            if (has_predicate == 0) {
              ly_vlog(slist->module->ctx,LYE_PATH_MISSKEY,LY_VLOG_NONE,(void *)0x0,list_name);
              iVar1 = -1;
              goto LAB_001b3448;
            }
            r = parse_schema_json_predicate
                          (predicate_local,&mod_name,&mod_name_len,&name,&nam_len,&value,&val_len,
                           &has_predicate);
            if (r < 1) break;
            iVar1 = strncmp(name,".",(long)nam_len);
          } while (iVar1 != 0);
          ly_vlog(slist->module->ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,
                  (ulong)(uint)(int)predicate_local[-r],predicate_local + -r);
          iVar1 = -1;
        }
      }
      else {
        *parsed = *parsed + r;
        iVar1 = 0;
      }
      goto LAB_001b3448;
    }
  }
  ly_vlog(slist->module->ctx,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,
          (ulong)(uint)(int)predicate[-r],predicate + -r);
  iVar1 = -1;
LAB_001b3448:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



lyd_node * lyd_new_path_update(lyd_node *node,void *value,LYD_ANYDATA_VALUETYPE value_type,int dflt)

{
  LYS_NODE LVar1;
  ly_ctx *ctx_00;
  int iVar2;
  hash_table *phVar3;
  int dflt_local;
  LYD_ANYDATA_VALUETYPE value_type_local;
  void *value_local;
  lyd_node *node_local;
  int len;
  ly_ctx *ctx;
  lyd_node_anydata *any;
  
  ctx_00 = node->schema->module->ctx;
  LVar1 = node->schema->nodetype;
  if (LVar1 == LYS_ANYDATA) {
LAB_001b3550:
    if ((*(uint *)&node->field_0x34 < 2) && (value_type < LYD_ANYDATA_JSON)) {
      iVar2 = ly_strequal_((char *)node->ht,(char *)value);
      if (iVar2 != 0) {
        return (lyd_node *)0x0;
      }
    }
    else if ((value_type == *(LYD_ANYDATA_VALUETYPE *)&node->field_0x34) &&
            ((hash_table *)value == node->ht)) {
      return (lyd_node *)0x0;
    }
    if (true) {
      switch(*(undefined4 *)&node->field_0x34) {
      case 0:
      case 2:
      case 4:
        lydict_remove(ctx_00,(char *)node->ht);
        break;
      case 1:
      case 3:
      case 5:
      case 0x21:
                    // WARNING: Subroutine does not return
        __assert_fail("0",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x72d,"lyd_new_path_update");
      case 8:
        lyxml_free_withsiblings(ctx_00,(lyxml_elem *)node->ht);
        break;
      case 0x10:
        lyd_free_withsiblings((lyd_node *)node->ht);
        break;
      case 0x20:
        free(node->ht);
      }
    }
    if (true) {
      switch(value_type) {
      case LYD_ANYDATA_CONSTSTRING:
      case LYD_ANYDATA_JSON:
      case LYD_ANYDATA_SXML:
        phVar3 = (hash_table *)lydict_insert(ctx_00,(char *)value,0);
        node->ht = phVar3;
        break;
      case LYD_ANYDATA_STRING:
      case LYD_ANYDATA_JSOND:
      case LYD_ANYDATA_SXMLD:
        phVar3 = (hash_table *)lydict_insert_zc(ctx_00,(char *)value);
        node->ht = phVar3;
        break;
      case LYD_ANYDATA_XML:
        node->ht = (hash_table *)value;
        break;
      case LYD_ANYDATA_DATATREE:
        node->ht = (hash_table *)value;
        break;
      case LYD_ANYDATA_LYB:
        iVar2 = lyd_lyb_data_length((char *)value);
        if (iVar2 == -1) {
          ly_log(ctx_00,LY_LLERR,LY_EINVAL,"Invalid LYB data.");
          node = (lyd_node *)0x0;
        }
        else {
          phVar3 = (hash_table *)malloc((long)iVar2);
          node->ht = phVar3;
          if (node->ht == (hash_table *)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_new_path_update")
            ;
            node = (lyd_node *)0x0;
          }
          else {
            memcpy(node->ht,value,(long)iVar2);
          }
        }
        break;
      case LYD_ANYDATA_LYBD:
        node->ht = (hash_table *)value;
      }
    }
  }
  else {
    if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
      if (LVar1 == LYS_LEAF) {
        if (LYD_ANYDATA_STRING < value_type) {
          ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new_path_update")
          ;
          return (lyd_node *)0x0;
        }
        iVar2 = lyd_change_leaf((lyd_node_leaf_list *)node,(char *)value);
        if (iVar2 == 0) {
          if (dflt == 0) {
            return node;
          }
          node->field_0x9 = node->field_0x9 | 1;
          return node;
        }
        if (dflt != 0) {
          node->field_0x9 = node->field_0x9 | 1;
          return node;
        }
      }
      else if (LVar1 == LYS_ANYXML) goto LAB_001b3550;
    }
    node = (lyd_node *)0x0;
  }
  return node;
}



lyd_node *
lyd_new_path(lyd_node *data_tree,ly_ctx *ctx,char *path,void *value,LYD_ANYDATA_VALUETYPE value_type
            ,int options)

{
  int iVar1;
  lyd_node *plVar2;
  lys_module *plVar3;
  char *pcVar4;
  LYS_NODE LVar5;
  long in_FS_OFFSET;
  int options_local;
  LYD_ANYDATA_VALUETYPE value_type_local;
  void *value_local;
  char *path_local;
  ly_ctx *ctx_local;
  lyd_node *data_tree_local;
  int parsed;
  int mod_name_len;
  int nam_len;
  int val_name_len;
  int val_len;
  int is_relative;
  int has_predicate;
  int i;
  int first_iter;
  int edit_leaf;
  int backup_mod_name_len;
  int yang_data_name_len;
  int backup_is_relative;
  int r;
  char *mod_name;
  char *name;
  char *val_name;
  char *val;
  char *str;
  char *id;
  char *backup_mod_name;
  char *yang_data_name;
  lyd_node *ret;
  lyd_node *node;
  lyd_node *parent;
  lys_node *schild;
  lys_node *sparent;
  lys_node *tmp;
  lys_module *module;
  lys_module *prev_mod;
  char *node_mod_name;
  lys_node_list *slist;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_new_path");
  backup_mod_name = (char *)0x0;
  yang_data_name = (char *)0x0;
  ret = (lyd_node *)0x0;
  parent = (lyd_node *)0x0;
  parsed = 0;
  is_relative = -1;
  first_iter = 1;
  if (((path == (char *)0x0) || ((data_tree == (lyd_node *)0x0 && (ctx == (ly_ctx *)0x0)))) ||
     ((data_tree == (lyd_node *)0x0 && (*path != '/')))) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_new_path");
    plVar2 = (lyd_node *)0x0;
  }
  else {
    ctx_local = ctx;
    if (ctx == (ly_ctx *)0x0) {
      ctx_local = data_tree->schema->module->ctx;
    }
    id = path;
    if (data_tree != (lyd_node *)0x0) {
      plVar2 = data_tree;
      if (*path == '/') {
        while ((node = plVar2, parsed == 0 && (node != (lyd_node *)0x0))) {
          pcVar4 = (char *)value;
          if (LYD_ANYDATA_STRING < value_type) {
            pcVar4 = (char *)0x0;
          }
          parent = resolve_partial_json_data_nodeid(id,pcVar4,node,options,&parsed);
          plVar2 = node->next;
        }
        if (parsed == 0) {
          for (node = data_tree->prev; (parsed == 0 && (node->next != (lyd_node *)0x0));
              node = node->prev) {
            pcVar4 = (char *)value;
            if (LYD_ANYDATA_STRING < value_type) {
              pcVar4 = (char *)0x0;
            }
            parent = resolve_partial_json_data_nodeid(id,pcVar4,node,options,&parsed);
          }
        }
      }
      else {
        pcVar4 = (char *)value;
        if (LYD_ANYDATA_STRING < value_type) {
          pcVar4 = (char *)0x0;
        }
        parent = resolve_partial_json_data_nodeid(path,pcVar4,data_tree,options,&parsed);
      }
      if (parsed == -1) {
        plVar2 = (lyd_node *)0x0;
        goto LAB_001b4b87;
      }
      if (parsed != 0) {
        if (parent == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
          __assert_fail("parent",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                        ,0x78f,"lyd_new_path");
        }
        is_relative = 1;
        id = id + parsed;
        if (*id == '\0') {
          if (((options & 1U) == 0) && (((parent->field_0x9 & 1) == 0 || ((options & 8U) != 0)))) {
            ly_vlog(ctx_local,LYE_PATH_EXISTS,LY_VLOG_STR,path);
            plVar2 = (lyd_node *)0x0;
          }
          else if (((parent->field_0x9 & 1) == 0) || ((options & 8U) == 0)) {
            plVar2 = lyd_new_path_update(parent,value,value_type,options & 8);
          }
          else {
            plVar2 = (lyd_node *)0x0;
          }
          goto LAB_001b4b87;
        }
      }
    }
    backup_is_relative = is_relative;
    r = parse_schema_nodeid(id,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,(int *)0x0,
                            (int *)0x0,1);
    if (r < 1) {
      ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[-r],id + -r);
      plVar2 = (lyd_node *)0x0;
    }
    else {
      if (*name == '#') {
        if (is_relative != 0) {
          ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,0x23,name);
          plVar2 = (lyd_node *)0x0;
          goto LAB_001b4b87;
        }
        yang_data_name = name + 1;
        yang_data_name_len = nam_len + -1;
        backup_mod_name = mod_name;
        backup_mod_name_len = mod_name_len;
        id = id + r;
      }
      else {
        is_relative = backup_is_relative;
      }
      r = parse_schema_nodeid(id,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,&has_predicate,
                              (int *)0x0,0);
      if (r < 1) {
        ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[-r],id + -r)
        ;
        plVar2 = (lyd_node *)0x0;
      }
      else {
        id = id + r;
        if (backup_mod_name != (char *)0x0) {
          mod_name = backup_mod_name;
          mod_name_len = backup_mod_name_len;
        }
        value_type_local = value_type;
        value_local = value;
        data_tree_local = data_tree;
        if (is_relative == 0) {
          if (parent != (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
            __assert_fail("!parent",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                          ,0x7d4,"lyd_new_path");
          }
          if (mod_name == (char *)0x0) {
            str = strndup(path,(size_t)(name + ((long)nam_len - (long)path)));
            ly_vlog(ctx_local,LYE_PATH_MISSMOD,LY_VLOG_STR,str);
            free(str);
            plVar2 = (lyd_node *)0x0;
            goto LAB_001b4b87;
          }
          module = ly_ctx_nget_module(ctx_local,mod_name,(long)mod_name_len,(char *)0x0,1);
          if (module == (lys_module *)0x0) {
            str = strndup(path,(size_t)(mod_name + ((long)mod_name_len - (long)path)));
            ly_vlog(ctx_local,LYE_PATH_INMOD,LY_VLOG_STR,str);
            free(str);
            plVar2 = (lyd_node *)0x0;
            goto LAB_001b4b87;
          }
          mod_name = (char *)0x0;
          mod_name_len = 0;
          sparent = (lys_node *)0x0;
          prev_mod = module;
          if ((yang_data_name != (char *)0x0) &&
             (sparent = lyp_get_yang_data_template(module,yang_data_name,yang_data_name_len),
             sparent == (lys_node *)0x0)) {
            str = strndup(path,(size_t)(yang_data_name + ((long)yang_data_name_len - (long)path)));
            ly_vlog(ctx_local,LYE_PATH_INNODE,LY_VLOG_STR,str);
            free(str);
            plVar2 = (lyd_node *)0x0;
            goto LAB_001b4b87;
          }
        }
        else {
          if (data_tree == (lyd_node *)0x0) {
            ly_log(ctx_local,LY_LLERR,LY_EINVAL,
                   "%s: provided relative path (%s) without context node.","lyd_new_path",path);
            plVar2 = (lyd_node *)0x0;
            goto LAB_001b4b87;
          }
          if (parent == (lyd_node *)0x0) {
            parent = data_tree;
          }
          sparent = parent->schema;
          module = lys_node_module(sparent);
          prev_mod = module;
        }
LAB_001b402c:
        schild = (lys_node *)0x0;
LAB_001b4176:
        do {
          schild = lys_getnext(schild,sparent,module,0);
          if (schild == (lys_node *)0x0) goto LAB_001b41a1;
        } while ((schild->nodetype & 0xc1bd) == LYS_UNKNOWN);
        if (mod_name == (char *)0x0) {
          plVar3 = lys_node_module(schild);
          if (prev_mod != plVar3) goto LAB_001b4176;
        }
        else {
          plVar3 = lys_node_module(schild);
          node_mod_name = plVar3->name;
          iVar1 = strncmp(node_mod_name,mod_name,(long)mod_name_len);
          if ((iVar1 != 0) || (node_mod_name[mod_name_len] != '\0')) goto LAB_001b4176;
        }
        iVar1 = strncmp(schild->name,name,(long)nam_len);
        if ((iVar1 != 0) || (schild->name[nam_len] != '\0')) goto LAB_001b4176;
        for (tmp = lys_parent(schild); (tmp != (lys_node *)0x0 && (tmp->nodetype == LYS_USES));
            tmp = lys_parent(tmp)) {
        }
        if (tmp == (lys_node *)0x0) goto LAB_001b41a1;
        if ((options & 4U) == 0) {
          if (tmp->nodetype != LYS_OUTPUT) goto LAB_001b41a1;
          goto LAB_001b4176;
        }
        if (tmp->nodetype == LYS_INPUT) goto LAB_001b4176;
LAB_001b41a1:
        if (schild == (lys_node *)0x0) {
          str = strndup(path,(size_t)(name + ((long)nam_len - (long)path)));
          ly_vlog(ctx_local,LYE_PATH_INNODE,LY_VLOG_STR,str);
          free(str);
          lyd_free(ret);
          plVar2 = (lyd_node *)0x0;
          goto LAB_001b4b87;
        }
        LVar5 = schild->nodetype;
        if (LVar5 == LYS_ANYDATA) {
switchD_001b4298_caseD_20:
          if (*id != '\0') {
            ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)*id,id);
            lyd_free(ret);
            plVar2 = (lyd_node *)0x0;
            goto LAB_001b4b87;
          }
          if ((value_type_local < LYD_ANYDATA_JSON) && (value_local == (void *)0x0)) {
            value_type_local = LYD_ANYDATA_CONSTSTRING;
            value_local = &DAT_00227b5d;
          }
          plVar2 = parent;
          if (is_relative == 0) {
            plVar2 = (lyd_node *)0x0;
          }
          node = lyd_create_anydata(plVar2,schild,value_local,value_type_local);
        }
        else {
          if (LVar5 < (LYS_CONTAINER|LYS_ANYDATA)) {
            if (LVar5 == LYS_ACTION) {
switchD_001b4298_caseD_1:
              if ((options & 2U) == 0) {
                plVar2 = parent;
                if (is_relative == 0) {
                  plVar2 = (lyd_node *)0x0;
                }
                node = _lyd_new(plVar2,schild,options >> 3 & 1);
                goto LAB_001b4700;
              }
              str = strndup(path,(size_t)(name + ((long)nam_len - (long)path)));
              ly_vlog(ctx_local,LYE_PATH_MISSPAR,LY_VLOG_STR,str);
              free(str);
              lyd_free(ret);
              plVar2 = (lyd_node *)0x0;
              goto LAB_001b4b87;
            }
            if (LVar5 < (LYS_CONTAINER|LYS_ACTION)) {
              if (LVar5 == LYS_RPC) goto switchD_001b4298_caseD_1;
              if (LVar5 < (LYS_CONTAINER|LYS_RPC)) {
                if (LVar5 < (LYS_CONTAINER|LYS_ANYXML)) {
                  if ((LVar5 != LYS_UNKNOWN) && (true)) {
                    switch(LVar5) {
                    case LYS_CONTAINER:
                    case LYS_LIST:
                      goto switchD_001b4298_caseD_1;
                    case LYS_LEAF:
                    case LYS_LEAFLIST:
                      str = (char *)0x0;
                      if (has_predicate != 0) {
                        r = parse_schema_json_predicate
                                      (id,(char **)0x0,(int *)0x0,&val_name,&val_name_len,&val,
                                       &val_len,&has_predicate);
                        if (r < 1) {
                          ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,
                                  (ulong)(uint)(int)id[-r],id + -r);
                          lyd_free(ret);
                          plVar2 = (lyd_node *)0x0;
                          goto LAB_001b4b87;
                        }
                        id = id + r;
                        if ((*val_name != '.') || (val_name_len != 1)) {
                          ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,
                                  (ulong)(uint)(int)*val_name,val_name);
                          lyd_free(ret);
                          plVar2 = (lyd_node *)0x0;
                          goto LAB_001b4b87;
                        }
                        str = strndup(val,(long)val_len);
                        if (str == (char *)0x0) {
                          ly_log(ctx_local,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                                 "lyd_new_path");
                          lyd_free(ret);
                          plVar2 = (lyd_node *)0x0;
                          goto LAB_001b4b87;
                        }
                      }
                      if (*id == '\0') {
                        if (((options & 0x20U) == 0) || (schild->nodetype != LYS_LEAF)) {
                          edit_leaf = 0;
                        }
                        else {
                          edit_leaf = 1;
                        }
                        pcVar4 = (char *)value_local;
                        if (str != (char *)0x0) {
                          pcVar4 = str;
                        }
                        plVar2 = parent;
                        if (is_relative == 0) {
                          plVar2 = (lyd_node *)0x0;
                        }
                        node = _lyd_new_leaf(plVar2,schild,pcVar4,options >> 3 & 1,edit_leaf);
                        free(str);
                        goto LAB_001b4700;
                      }
                      ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,
                              (ulong)(uint)(int)*id,id);
                      free(str);
                      lyd_free(ret);
                      plVar2 = (lyd_node *)0x0;
                      goto LAB_001b4b87;
                    case LYS_ANYXML:
                      goto switchD_001b4298_caseD_20;
                    }
                  }
                }
                else if (LVar5 == LYS_NOTIF) goto switchD_001b4298_caseD_1;
              }
            }
          }
          ly_log(ctx_local,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                 ,0x86b);
          node = (lyd_node *)0x0;
        }
LAB_001b4700:
        if (node == (lyd_node *)0x0) {
          str = strndup(path,(long)id - (long)path);
          if (is_relative == 0) {
            ly_vlog(ctx_local,LYE_SPEC,LY_VLOG_STR,str,"Failed to create node \"%s\".",schild->name)
            ;
          }
          else {
            ly_vlog(ctx_local,LYE_SPEC,LY_VLOG_STR,str,
                    "Failed to create node \"%s\" as a child of \"%s\".",schild->name,
                    parent->schema->name);
          }
          free(str);
          lyd_free(ret);
          plVar2 = (lyd_node *)0x0;
          goto LAB_001b4b87;
        }
        if (is_relative == 0) {
          if (data_tree_local != (lyd_node *)0x0) {
            for (; data_tree_local->next != (lyd_node *)0x0; data_tree_local = data_tree_local->next
                ) {
            }
            iVar1 = lyd_insert_after(data_tree_local,node);
            if (iVar1 != 0) {
              lyd_free(ret);
              plVar2 = (lyd_node *)0x0;
              goto LAB_001b4b87;
            }
          }
          is_relative = 1;
        }
        if (first_iter != 0) {
          sparent = node->schema;
          do {
            sparent = lys_parent(sparent);
            if (sparent == (lys_node *)0x0) break;
            if ((options & 4U) == 0) {
              LVar5 = LYS_INPUT;
            }
            else {
              LVar5 = LYS_OUTPUT;
            }
          } while (LVar5 != sparent->nodetype);
          if ((sparent != (lys_node *)0x0) && (iVar1 = lyd_schema_sort(node,0), iVar1 != 0)) {
            lyd_free(ret);
            plVar2 = (lyd_node *)0x0;
            goto LAB_001b4b87;
          }
          ret = node;
          first_iter = 0;
        }
        parsed = 0;
        if (((schild->nodetype == LYS_LIST) && (has_predicate != 0)) &&
           (iVar1 = lyd_new_path_list_predicate(node,name,id,&parsed), iVar1 != 0)) {
          lyd_free(ret);
          plVar2 = (lyd_node *)0x0;
          goto LAB_001b4b87;
        }
        id = id + parsed;
        if (*id == '\0') {
          plVar2 = ret;
          if ((options & 0x10U) != 0) {
            plVar2 = node;
          }
          goto LAB_001b4b87;
        }
        parent = node;
        sparent = schild;
        prev_mod = lys_node_module(schild);
        r = parse_schema_nodeid(id,&mod_name,&mod_name_len,&name,&nam_len,&is_relative,
                                &has_predicate,(int *)0x0,0);
        if (0 < r) {
          id = id + r;
          if ((schild->nodetype == LYS_LIST) && (mod_name == (char *)0x0)) {
            slist = (lys_node_list *)schild;
            for (i = 0; i < (int)(uint)slist->keys_size; i = i + 1) {
              iVar1 = strncmp(slist->keys[i]->name,name,(long)nam_len);
              if ((iVar1 == 0) && (slist->keys[i]->name[nam_len] == '\0')) {
                plVar2 = ret;
                if (*id != '\0') {
                  ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)*id,
                          id);
                  lyd_free(ret);
                  plVar2 = (lyd_node *)0x0;
                }
                goto LAB_001b4b87;
              }
            }
          }
          goto LAB_001b402c;
        }
        ly_vlog(ctx_local,LYE_PATH_INCHAR,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)(int)id[-r],id + -r)
        ;
        lyd_free(ret);
        plVar2 = (lyd_node *)0x0;
      }
    }
  }
LAB_001b4b87:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



uint lyd_list_pos(lyd_node *node)

{
  lyd_node *node_local;
  uint pos;
  lys_node *schema;
  
  ly_log_dbg(0x20,"%s","lyd_list_pos");
  if ((node == (lyd_node *)0x0) ||
     ((node->schema->nodetype != LYS_LIST && (node->schema->nodetype != LYS_LEAFLIST)))) {
    pos = 0;
  }
  else {
    pos = 0;
    node_local = node;
    do {
      if (node->schema == node_local->schema) {
        pos = pos + 1;
      }
      node_local = node_local->prev;
    } while (node_local->next != (lyd_node *)0x0);
  }
  return pos;
}



lyd_node * lyd_new_dummy(lyd_node *root,lyd_node *parent,lys_node *schema,char *value,int dflt)

{
  LYS_NODE LVar1;
  int iVar2;
  ly_set *set;
  int dflt_local;
  char *value_local;
  lys_node *schema_local;
  lyd_node *parent_local;
  lyd_node *root_local;
  uint index;
  lys_node *siter;
  lyd_node *iter;
  lyd_node *dummy;
  ly_set *spath;
  
  dummy = (lyd_node *)0x0;
  if (schema == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("schema",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x8ea,"lyd_new_dummy");
  }
  if ((schema->nodetype & 0xc1bd) == LYS_UNKNOWN) {
                    // WARNING: Subroutine does not return
    __assert_fail("schema->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC | LYS_ACTION)"
                  ,
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x8eb,"lyd_new_dummy");
  }
  set = ly_set_new();
  if (set == (ly_set *)0x0) {
    ly_log(schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_new_dummy");
    return (lyd_node *)0x0;
  }
  siter = schema;
  root_local = root;
  if ((parent == (lyd_node *)0x0) && (root != (lyd_node *)0x0)) {
    for (; root_local->parent != (lyd_node *)0x0; root_local = root_local->parent) {
    }
    while (root_local->prev->next != (lyd_node *)0x0) {
      root_local = root_local->prev;
    }
  }
  for (; (siter != (lys_node *)0x0 && ((parent == (lyd_node *)0x0 || (siter != parent->schema))));
      siter = lys_parent(siter)) {
    if ((siter->nodetype & 0xc1bd) != LYS_UNKNOWN) {
      ly_set_add(set,siter,1);
    }
  }
  if (set->number == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("spath->number > 0",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x908,"lyd_new_dummy");
  }
  index = set->number;
  parent_local = parent;
  if ((parent == (lyd_node *)0x0) &&
     (((set->set).s[index - 1]->nodetype & LYS_LEAFLIST) == LYS_UNKNOWN)) {
    for (iter = root_local; iter != (lyd_node *)0x0; iter = iter->next) {
      if (iter->schema == (set->set).s[index - 1]) {
        parent_local = iter;
        index = index - 1;
        break;
      }
    }
  }
  iter = parent_local;
  do {
    if (((iter == (lyd_node *)0x0) || (index == 0)) ||
       (((set->set).s[index - 1]->nodetype & LYS_LEAFLIST) != LYS_UNKNOWN)) break;
    for (iter = parent_local->child; iter != (lyd_node *)0x0; iter = iter->next) {
      if (iter->schema == (set->set).s[index - 1]) {
        index = index - 1;
        parent_local = iter;
        break;
      }
    }
  } while( true );
LAB_001b50db:
  if (index == 0) {
    ly_set_free(set);
    return dummy;
  }
  LVar1 = (set->set).s[index - 1]->nodetype;
  if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
    if ((LVar1 == LYS_UNKNOWN) || (false)) goto LAB_001b50f8;
    switch(LVar1) {
    case LYS_CONTAINER:
    case LYS_LIST:
      iter = _lyd_new(parent_local,(set->set).s[index - 1],dflt);
      break;
    default:
      goto LAB_001b50f8;
    case LYS_LEAF:
    case LYS_LEAFLIST:
      if (value == (char *)0x0) {
        iter = lyd_create_leaf((set->set).s[index - 1],(char *)0x0,dflt);
        if (((iter != (lyd_node *)0x0) && (parent_local != (lyd_node *)0x0)) &&
           (iVar2 = lyd_insert(parent_local,iter), iVar2 != 0)) {
          lyd_free(iter);
          goto LAB_001b50f8;
        }
      }
      else {
        iter = _lyd_new_leaf(parent_local,(set->set).s[index - 1],value,dflt,0);
      }
      break;
    case LYS_ANYXML:
      goto switchD_001b4f4a_caseD_20;
    }
  }
  else {
    if (LVar1 != LYS_ANYDATA) goto LAB_001b50f8;
switchD_001b4f4a_caseD_20:
    iter = lyd_create_anydata(parent_local,(set->set).s[index - 1],&DAT_00227b5d,
                              LYD_ANYDATA_CONSTSTRING);
  }
  if (iter == (lyd_node *)0x0) {
    ly_log(schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
           ,0x93d);
LAB_001b50f8:
    ly_set_free(set);
    lyd_free(dummy);
    return (lyd_node *)0x0;
  }
  iter->validity = 0x80;
  if (dummy == (lyd_node *)0x0) {
    dummy = iter;
  }
  parent_local = iter;
  index = index - 1;
  goto LAB_001b50db;
}



lys_node * lys_get_schema_inctx(lys_node *schema,ly_ctx *ctx)

{
  int iVar1;
  long in_FS_OFFSET;
  ly_ctx *ctx_local;
  lys_node *schema_local;
  uint32_t idx;
  uint index;
  lys_node *iter;
  lys_module *mod;
  lys_module *trg_mod;
  lys_node *parent;
  lys_node *first_sibling;
  ly_set *parents;
  void **ptr;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  trg_mod = (lys_module *)0x0;
  first_sibling = (lys_node *)0x0;
  iter = (lys_node *)0x0;
  if ((ctx != (ly_ctx *)0x0) && (ctx != schema->module->ctx)) {
    parents = ly_set_new();
    for (parent = schema; parent != (lys_node *)0x0; parent = lys_parent(parent)) {
      if (parent->nodetype != LYS_USES) {
        ly_set_add(parents,parent,1);
      }
    }
    if (parents->number == 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("parents->number",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                    ,0x96f,"lys_get_schema_inctx");
    }
    index = parents->number - 1;
    parent = (parents->set).s[index];
    if (parent->nodetype == LYS_EXT) {
      ptr = (void **)lys_ext_complex_get_substmt
                               (LY_STMT_NODE,(lys_ext_instance_complex *)parent,
                                (lyext_substmt **)0x0);
      if (ptr == (void **)0x0) {
        ly_set_free(parents);
        schema = (lys_node *)0x0;
        goto LAB_001b546c;
      }
      first_sibling = (lys_node *)*ptr;
      index = index - 1;
      parent = (parents->set).s[index];
    }
    idx = 0;
    while (mod = ly_ctx_get_module_iter(ctx,&idx), mod != (lys_module *)0x0) {
      trg_mod = lys_node_module(parent);
      iVar1 = strcmp(mod->name,trg_mod->name);
      if ((iVar1 == 0) &&
         (((mod->rev_size == '\0' && (trg_mod->rev_size == '\0')) ||
          ((mod->rev_size != '\0' &&
           ((trg_mod->rev_size != '\0' &&
            (iVar1 = strcmp(mod->rev->date,trg_mod->rev->date), iVar1 == 0)))))))) break;
    }
    if ((mod == (lys_module *)0x0) &&
       ((trg_mod != (lys_module *)0x0 && (ctx->data_clb != (ly_module_data_clb)0x0)))) {
      ly_log_dbg(2,"Attempting to load \'%s\' into context using callback ...",trg_mod->name);
      mod = (*ctx->data_clb)(ctx,trg_mod->name,(char *)0x0,0,ctx->data_clb_data);
    }
    if (mod == (lys_module *)0x0) {
      ly_set_free(parents);
      schema = (lys_node *)0x0;
    }
    else {
      if (first_sibling == (lys_node *)0x0) {
        first_sibling = mod->data;
      }
      while ((lys_get_sibling(first_sibling,trg_mod->name,0,parent->name,0,parent->nodetype,&iter),
             iter != (lys_node *)0x0 && (index != 0))) {
        first_sibling = iter->child;
        index = index - 1;
        parent = (parents->set).s[index];
        iter = (lys_node *)0x0;
      }
      ly_set_free(parents);
      schema = iter;
    }
  }
LAB_001b546c:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return schema;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_node * lyd_get_schema_inctx(lyd_node *node,ly_ctx *ctx)

{
  lys_node *plVar1;
  ly_ctx *ctx_local;
  lyd_node *node_local;
  
  if (node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x9b5,"lyd_get_schema_inctx");
  }
  plVar1 = lys_get_schema_inctx(node->schema,ctx);
  return plVar1;
}



void lyd_merge_node_update(lyd_node *target,lyd_node *source)

{
  ly_ctx *ctx_00;
  int iVar1;
  hash_table *phVar2;
  lyd_node *plVar3;
  lyxml_elem *plVar4;
  lyd_node *source_local;
  lyd_node *target_local;
  int len;
  ly_ctx *ctx;
  lyd_node_anydata *trg_any;
  lyd_node_anydata *src_any;
  lyd_node_leaf_list *trg_leaf;
  lyd_node_leaf_list *src_leaf;
  
  if ((target->schema->nodetype & (LYS_LEAF|LYS_ANYDATA)) == LYS_UNKNOWN) {
                    // WARNING: Subroutine does not return
    __assert_fail("target->schema->nodetype & (LYS_LEAF | LYS_ANYDATA)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x9c3,"lyd_merge_node_update");
  }
  ctx_00 = target->schema->module->ctx;
  if (ctx_00 == source->schema->module->ctx) {
    if (target->schema->nodetype == LYS_LEAF) {
      lydict_remove(ctx_00,(char *)target->ht);
      phVar2 = (hash_table *)lydict_insert(ctx_00,(char *)source->ht,0);
      target->ht = phVar2;
      *(undefined4 *)&target[1].schema = *(undefined4 *)&source[1].schema;
      if (*(int *)&target[1].schema == 9) {
        target->validity = target->validity | 8;
        lyp_parse_value((lys_type *)&target->schema[1].ref,(char **)&target->ht,(lyxml_elem *)0x0,
                        (lyd_node_leaf_list *)target,(lyd_attr *)0x0,(lys_module *)0x0,1,
                        (uint)(source->field_0x9 & 1),0);
      }
      else {
        lyd_free_value((lyd_val)target->child,*(LY_DATA_TYPE *)&target[1].schema,
                       *(uint8_t *)((long)&target[1].schema + 4),(lys_type *)&target->schema[1].ref,
                       (char *)target->ht,(lyd_val *)0x0,(LY_DATA_TYPE *)0x0,(uint8_t *)0x0);
        target->child = source->child;
      }
      target->field_0x9 = target->field_0x9 & 0xfe | source->field_0x9 & 1;
      check_leaf_list_backlinks(target);
      return;
    }
    if (true) {
      switch(*(undefined4 *)&target->field_0x34) {
      case 0:
      case 2:
      case 4:
        lydict_remove(ctx_00,(char *)target->ht);
        break;
      case 1:
      case 3:
      case 5:
      case 0x21:
                    // WARNING: Subroutine does not return
        __assert_fail("0",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x9f3,"lyd_merge_node_update");
      case 8:
        lyxml_free_withsiblings(ctx_00,(lyxml_elem *)target->ht);
        break;
      case 0x10:
        lyd_free_withsiblings((lyd_node *)target->ht);
        break;
      case 0x20:
        free(target->ht);
      }
    }
    *(undefined4 *)&target->field_0x34 = *(undefined4 *)&source->field_0x34;
    target->ht = source->ht;
    *(undefined4 *)&source->field_0x34 = 0x10;
    source->ht = (hash_table *)0x0;
    return;
  }
  if (target->schema->nodetype != LYS_LEAF) {
    if (true) {
      switch(*(undefined4 *)&target->field_0x34) {
      case 0:
      case 2:
      case 4:
        lydict_remove(ctx_00,(char *)target->ht);
        break;
      case 1:
      case 3:
      case 5:
      case 0x21:
                    // WARNING: Subroutine does not return
        __assert_fail("0",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0xa44,"lyd_merge_node_update");
      case 8:
        lyxml_free_withsiblings(ctx_00,(lyxml_elem *)target->ht);
        break;
      case 0x10:
        lyd_free_withsiblings((lyd_node *)target->ht);
        break;
      case 0x20:
        free(target->ht);
      }
    }
    *(undefined4 *)&target->field_0x34 = *(undefined4 *)&source->field_0x34;
    if (source->ht == (hash_table *)0x0) {
      return;
    }
    if (false) {
      return;
    }
    switch(*(undefined4 *)&target->field_0x34) {
    case 0:
    case 2:
    case 4:
      phVar2 = (hash_table *)lydict_insert(ctx_00,(char *)source->ht,0);
      target->ht = phVar2;
      return;
    case 1:
    case 3:
    case 5:
    case 0x21:
                    // WARNING: Subroutine does not return
      __assert_fail("0",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                    ,0xa66,"lyd_merge_node_update");
    default:
      return;
    case 8:
      plVar4 = lyxml_dup_elem(ctx_00,(lyxml_elem *)source->ht,(lyxml_elem *)0x0,1,1);
      target->ht = (hash_table *)plVar4;
      return;
    case 0x10:
      plVar3 = lyd_dup_withsiblings_to_ctx((lyd_node *)source->ht,1,ctx_00);
      target->ht = (hash_table *)plVar3;
      return;
    case 0x20:
      goto switchD_001b5ad4_caseD_20;
    }
  }
  lydict_remove(ctx_00,(char *)target->ht);
  phVar2 = (hash_table *)lydict_insert(ctx_00,(char *)source->ht,0);
  target->ht = phVar2;
  lyd_free_value((lyd_val)target->child,*(LY_DATA_TYPE *)&target[1].schema,
                 *(uint8_t *)((long)&target[1].schema + 4),(lys_type *)&target->schema[1].ref,
                 (char *)target->ht,(lyd_val *)0x0,(LY_DATA_TYPE *)0x0,(uint8_t *)0x0);
  *(undefined4 *)&target[1].schema = *(undefined4 *)&source[1].schema;
  target->field_0x9 = target->field_0x9 & 0xfe | source->field_0x9 & 1;
  if (false) {
switchD_001b58a5_caseD_0:
    target->child = source->child;
  }
  else {
    switch(*(undefined4 *)&target[1].schema) {
    default:
      goto switchD_001b58a5_caseD_0;
    case 1:
    case 10:
      target->child = (lyd_node *)target->ht;
      break;
    case 2:
    case 6:
    case 7:
      lyp_parse_value((lys_type *)&target->schema[1].ref,(char **)&target->ht,(lyxml_elem *)0x0,
                      (lyd_node_leaf_list *)target,(lyd_attr *)0x0,(lys_module *)0x0,1,
                      (uint)(target->field_0x9 & 1),1);
      break;
    case 8:
      target->child = (lyd_node *)0x0;
      break;
    case 9:
      target->validity = target->validity | 8;
      lyp_parse_value((lys_type *)&target->schema[1].ref,(char **)&target->ht,(lyxml_elem *)0x0,
                      (lyd_node_leaf_list *)target,(lyd_attr *)0x0,(lys_module *)0x0,1,
                      (uint)(target->field_0x9 & 1),0);
      break;
    case 0xb:
      plVar3 = (lyd_node *)lydict_insert(ctx_00,(char *)source->child,0);
      target->child = plVar3;
    }
  }
  check_leaf_list_backlinks(target);
  return;
switchD_001b5ad4_caseD_20:
  iVar1 = lyd_lyb_data_length((char *)source->ht);
  if (iVar1 == -1) {
    ly_log(ctx_00,LY_LLERR,LY_EINVAL,"Invalid LYB data.");
    return;
  }
  phVar2 = (hash_table *)malloc((long)iVar1);
  target->ht = phVar2;
  if (target->ht == (hash_table *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_merge_node_update");
    return;
  }
  memcpy(target->ht,source->ht,(long)iVar1);
  return;
}



int lyd_merge_node_schema_equal(lyd_node *node1,lyd_node *node2)

{
  char *pcVar1;
  lys_node *plVar2;
  lys_module *plVar3;
  lyd_node *node2_local;
  lyd_node *node1_local;
  lys_node *sch1;
  
  if (node1->schema->module->ctx == node2->schema->module->ctx) {
    if (node1->schema != node2->schema) {
      return 0;
    }
  }
  else {
    plVar2 = lyd_get_schema_inctx(node1,node2->schema->module->ctx);
    if (plVar2 == (lys_node *)0x0) {
      pcVar1 = node1->schema->name;
      plVar3 = lyd_node_module(node1);
      ly_log(node2->schema->module->ctx,LY_LLERR,LY_EINVAL,
             "Target context does not contain a required schema node (%s:%s).",plVar3->name,pcVar1);
      return -1;
    }
    if (plVar2 != node2->schema) {
      return 0;
    }
  }
  return 1;
}



int lyd_merge_node_equal(lyd_node *node1,lyd_node *node2)

{
  LYS_NODE LVar1;
  int iVar2;
  lyd_node *node2_local;
  lyd_node *node1_local;
  int ret;
  
  LVar1 = node1->schema->nodetype;
  if (LVar1 == LYS_ANYDATA) {
LAB_001b5f35:
    return 1;
  }
  if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
    if (LVar1 == LYS_ACTION) {
      return 1;
    }
    if (LVar1 < (LYS_CONTAINER|LYS_ACTION)) {
      if (LVar1 == LYS_RPC) {
        return 1;
      }
      if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
        if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
          if ((LVar1 != LYS_UNKNOWN) && (true)) {
            switch(LVar1) {
            case LYS_CONTAINER:
            case LYS_LEAF:
            case LYS_ANYXML:
              goto LAB_001b5f35;
            case LYS_LEAFLIST:
              if ((char)node1->validity < '\0') {
                if ((node1->schema->flags & 2) == 0) {
                    // WARNING: Subroutine does not return
                  __assert_fail("node1->schema->flags & LYS_CONFIG_R",
                                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                                ,0xa9b,"lyd_merge_node_equal");
                }
                return 0;
              }
              iVar2 = lyd_list_equal(node1,node2,1);
              if (iVar2 == 1) {
                if ((node1->schema->flags & 2) != 0) {
                  node1->validity = node1->validity | 0x80;
                  return 2;
                }
                return 1;
              }
              return iVar2;
            case LYS_LIST:
              if ((char)node1->validity < '\0') {
                if (node1->schema->padding[2] != '\0') {
                    // WARNING: Subroutine does not return
                  __assert_fail("!((struct lys_node_list *)node1->schema)->keys_size",
                                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                                ,0xaa9,"lyd_merge_node_equal");
                }
                return 0;
              }
              iVar2 = lyd_list_equal(node1,node2,1);
              if (iVar2 == 1) {
                if (node1->schema->padding[2] == '\0') {
                  node1->validity = node1->validity | 0x80;
                  return 2;
                }
                return 1;
              }
              return iVar2;
            }
          }
        }
        else if (LVar1 == LYS_NOTIF) {
          return 1;
        }
      }
    }
  }
  ly_log(node2->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
         ,0xab8);
  return -1;
}



int lyd_merge_parent_children(lyd_node *target,lyd_node *source,int options)

{
  bool bVar1;
  int iVar2;
  long in_FS_OFFSET;
  int options_local;
  lyd_node *source_local;
  lyd_node *target_local;
  int ret;
  int clear_flag;
  lyd_node *src_elem;
  lyd_node *trg_child;
  lyd_node **trg_child_p;
  lyd_node *trg_parent;
  lyd_node *src;
  lyd_node *src_backup;
  lyd_node *src_elem_backup;
  lyd_node *src_next;
  lyd_node *trg_parent_backup;
  ly_ctx *ctx;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  bVar1 = false;
  ctx = target->schema->module->ctx;
  source_local = source;
  src = source;
  do {
    if (src == (lyd_node *)0x0) {
      lyd_free_withsiblings(source_local);
      if (bVar1) {
        iVar2 = 2;
      }
      else {
        iVar2 = 0;
      }
LAB_001b63fe:
      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return iVar2;
    }
    src_backup = src->next;
    src_next = src;
    trg_parent = target;
LAB_001b639b:
    do {
      src_elem = src_next;
      if (src_next == (lyd_node *)0x0) break;
      if (((src_next->field_0x9 & 1) == 0) || ((options & 0x100U) == 0)) {
        ret = 0;
        if (src_next->hash == 0) {
          lyd_hash(src_next);
        }
        if (trg_parent->ht == (hash_table *)0x0) {
          for (trg_child = trg_parent->child; trg_child != (lyd_node *)0x0;
              trg_child = trg_child->next) {
            ret = lyd_merge_node_schema_equal(trg_child,src_elem);
            if (ret == 1) {
              ret = lyd_merge_node_equal(trg_child,src_elem);
            }
            if (ret != 0) break;
          }
        }
        else {
          trg_child = (lyd_node *)0x0;
          iVar2 = lyht_find(trg_parent->ht,&src_elem,src_elem->hash,&trg_child_p);
          if (iVar2 == 0) {
            trg_child = *trg_child_p;
            ret = 1;
            if (((trg_child->schema->nodetype == LYS_LIST) &&
                (trg_child->schema->padding[2] == '\0')) ||
               ((trg_child->schema->nodetype == LYS_LEAFLIST &&
                ((trg_child->schema->flags & 2) != 0)))) {
              if ((trg_child->schema->flags & 2) == 0) {
                    // WARNING: Subroutine does not return
                __assert_fail("trg_child->schema->flags & LYS_CONFIG_R",
                              "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                              ,0xae6,"lyd_merge_parent_children");
              }
              while ((trg_child != (lyd_node *)0x0 && ((char)trg_child->validity < '\0'))) {
                iVar2 = lyht_find_next(trg_parent->ht,&trg_child,trg_child->hash,&trg_child_p);
                if (iVar2 == 0) {
                  trg_child = *trg_child_p;
                }
                else {
                  trg_child = (lyd_node *)0x0;
                }
              }
              if (trg_child == (lyd_node *)0x0) {
                ret = 0;
              }
              else {
                trg_child->validity = trg_child->validity | 0x80;
                ret = 2;
              }
            }
          }
        }
        if (ret < 1) {
          if (ret == -1) {
            lyd_free_withsiblings(source_local);
            iVar2 = 1;
            goto LAB_001b63fe;
          }
        }
        else if ((trg_child->schema->nodetype & (LYS_LEAF|LYS_ANYDATA)) == LYS_UNKNOWN) {
          if (ret == 2) {
            bVar1 = true;
          }
        }
        else {
          lyd_merge_node_update(trg_child,src_elem);
        }
        src_elem_backup = src_elem;
        trg_parent_backup = trg_parent;
        if ((((src_elem->schema->nodetype != LYS_CONTAINER) &&
             ((src_elem->schema->nodetype != LYS_LIST || (src_elem->schema->padding[2] == '\0'))))
            || (src_elem->child == (lyd_node *)0x0)) || (trg_child == (lyd_node *)0x0))
        goto LAB_001b625f;
        src_next = src_elem->child;
        trg_parent = trg_child;
LAB_001b62c7:
        while ((src_next == (lyd_node *)0x0 &&
               (src_elem = src_elem->parent, src_elem->parent != src->parent))) {
          src_next = src_elem->next;
          trg_parent = trg_parent->parent;
        }
        if (trg_child != (lyd_node *)0x0) goto LAB_001b639b;
      }
      else {
        if (src == src_next) break;
        trg_child = (lyd_node *)0x1;
LAB_001b625f:
        if (src != src_elem) {
          src_next = src_elem->next;
          goto LAB_001b62c7;
        }
        if (trg_child != (lyd_node *)0x0) break;
        src_next = (lyd_node *)0x0;
      }
      if (ctx == src_elem_backup->schema->module->ctx) {
        lyd_unlink(src_elem_backup);
      }
      else {
        src_elem_backup = lyd_dup_to_ctx(src_elem_backup,1,ctx);
      }
      if (source_local == src_elem) {
        source_local = source_local->next;
      }
      iVar2 = lyd_insert(trg_parent_backup,src_elem_backup);
      if (iVar2 != 0) {
        ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
               ,0xb4f);
        lyd_free_withsiblings(source_local);
        iVar2 = 1;
        goto LAB_001b63fe;
      }
    } while (src != src_elem);
    src = src_backup;
  } while( true );
}



int lyd_merge_siblings(lyd_node *target,lyd_node *source,int options)

{
  LYS_NODE LVar1;
  ly_ctx *ctx_00;
  lyd_node *plVar2;
  bool bVar3;
  int iVar4;
  int options_local;
  lyd_node *source_local;
  lyd_node *target_local;
  int ret;
  int clear_flag;
  lyd_node *trg;
  lyd_node *src;
  lyd_node *src_backup;
  lyd_node *ins;
  ly_ctx *ctx;
  
  bVar3 = false;
  ctx_00 = target->schema->module->ctx;
  target_local = target;
  while (source_local = source, plVar2 = source, target_local->prev->next != (lyd_node *)0x0) {
    target_local = target_local->prev;
  }
  do {
    src = plVar2;
    if (src == (lyd_node *)0x0) {
      lyd_free_withsiblings(source_local);
      if (bVar3) {
        iVar4 = 2;
      }
      else {
        iVar4 = 0;
      }
      return iVar4;
    }
    plVar2 = src->next;
    for (trg = target_local; trg != (lyd_node *)0x0; trg = trg->next) {
      ret = lyd_merge_node_schema_equal(trg,src);
      if (ret == 1) {
        ret = lyd_merge_node_equal(trg,src);
      }
      if (0 < ret) {
        if (ret == 2) {
          bVar3 = true;
        }
        LVar1 = trg->schema->nodetype;
        if (LVar1 == LYS_ANYDATA) {
switchD_001b6556_caseD_4:
          lyd_merge_node_update(trg,src);
          break;
        }
        if (LYS_ANYDATA < LVar1) goto switchD_001b6556_caseD_2;
        if (LVar1 != LYS_OUTPUT) {
          if (LYS_OUTPUT < LVar1) goto switchD_001b6556_caseD_2;
          if (LVar1 != LYS_INPUT) {
            if (LYS_INPUT < LVar1) goto switchD_001b6556_caseD_2;
            if (LVar1 != LYS_RPC) {
              if (LYS_RPC < LVar1) goto switchD_001b6556_caseD_2;
              if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
                if ((LVar1 == LYS_UNKNOWN) || (false)) {
switchD_001b6556_caseD_2:
                  ly_log(ctx_00,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                         ,0xb92);
                  lyd_free_withsiblings(source_local);
                  return 1;
                }
                switch(LVar1) {
                case LYS_CONTAINER:
                case LYS_LIST:
                  goto switchD_001b6556_caseD_1;
                default:
                  goto switchD_001b6556_caseD_2;
                case LYS_LEAF:
                case LYS_ANYXML:
                  goto switchD_001b6556_caseD_4;
                case LYS_LEAFLIST:
                  goto LAB_001b6640;
                }
              }
              if (LVar1 != LYS_NOTIF) goto switchD_001b6556_caseD_2;
            }
          }
        }
switchD_001b6556_caseD_1:
        iVar4 = lyd_merge_parent_children(trg,src->child,options);
        if (iVar4 == 2) {
          bVar3 = true;
        }
        else if (iVar4 != 0) {
          lyd_free_withsiblings(source_local);
          return 1;
        }
        break;
      }
      if (ret == -1) {
        lyd_free_withsiblings(source_local);
        return 1;
      }
    }
LAB_001b6640:
    if (trg == (lyd_node *)0x0) {
      if (ctx_00 == src->schema->module->ctx) {
        lyd_unlink(src);
        if (src == source_local) {
          source_local = plVar2;
        }
        ins = src;
      }
      else {
        ins = lyd_dup_to_ctx(src,1,ctx_00);
      }
      lyd_insert_after(target_local->prev,ins);
    }
  } while( true );
}



int lyd_merge_to_ctx(lyd_node **trg,lyd_node *src,int options,ly_ctx *ctx)

{
  bool bVar1;
  undefined8 uVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  lys_module *plVar6;
  lyd_node *plVar7;
  ly_ctx *ctx_local;
  int options_local;
  lyd_node *src_local;
  lyd_node **trg_local;
  int i;
  int src_depth;
  int depth;
  int first_iter;
  int ret;
  int dflt;
  lyd_node *node;
  lyd_node *node2;
  lyd_node *target;
  lyd_node *trg_merge_start;
  lyd_node *src_merge_start;
  lyd_node *iter;
  lys_node *src_snode;
  lys_node *sch;
  lys_node *parent;
  
  ly_log_dbg(0x20,"%s","lyd_merge_to_ctx");
  src_merge_start = (lyd_node *)0x0;
  sch = (lys_node *)0x0;
  dflt = 1;
  if (((trg == (lyd_node **)0x0) || (*trg == (lyd_node *)0x0)) || (src == (lyd_node *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_merge_to_ctx");
    return -1;
  }
  target = *trg;
  for (parent = lys_parent(target->schema);
      (parent != (lys_node *)0x0 && (parent->nodetype == LYS_USES)); parent = lys_parent(parent)) {
  }
  if ((parent != (lys_node *)0x0) &&
     (pcVar4 = lyp_get_yang_data_template_name(target), pcVar4 == (char *)0x0)) {
    ly_log(parent->module->ctx,LY_LLERR,LY_EINVAL,"Target not a top-level data tree.");
    return -1;
  }
  ctx_local = ctx;
  if ((ctx == (ly_ctx *)0x0) || (ctx == target->schema->module->ctx)) {
    if (src->schema->module->ctx == target->schema->module->ctx) {
      if (ctx == src->schema->module->ctx) {
        ctx_local = (ly_ctx *)0x0;
      }
    }
    else {
      ctx_local = target->schema->module->ctx;
    }
  }
  else {
    while (target->prev->next != (lyd_node *)0x0) {
      target = target->prev;
    }
    *trg = target;
    node = (lyd_node *)0x0;
    for (; target != (lyd_node *)0x0; target = target->next) {
      plVar7 = lyd_dup_to_ctx(target,1,ctx);
      if ((plVar7 == (lyd_node *)0x0) ||
         ((node != (lyd_node *)0x0 &&
          (iVar3 = lyd_insert_after(node->prev,plVar7), plVar7 = node, iVar3 != 0))))
      goto LAB_001b6fe6;
      node = plVar7;
    }
    target = node;
  }
  node = (lyd_node *)0x0;
  src_snode = src->schema;
  src_depth = 0;
  while ((src_snode = lys_parent(src_snode), src_snode != (lys_node *)0x0 &&
         (src_snode->nodetype != LYS_EXT))) {
    src_depth = src_depth + 1;
  }
  trg_merge_start = target;
  depth = 0;
  bVar1 = true;
  plVar7 = src_merge_start;
  if (src_depth != 0) {
    iter = src;
    if ((options & 0x1000U) == 0) {
      for (; iter != (lyd_node *)0x0; iter = iter->next) {
        if ((iter->field_0x9 & 1) == 0) {
          dflt = 0;
          break;
        }
      }
    }
    else {
      dflt = (int)(src->field_0x9 & 1);
    }
  }
  do {
    do {
      src_merge_start = plVar7;
      src_snode = src->schema;
      for (i = 0; i < src_depth - depth; i = i + 1) {
        src_snode = lys_parent(src_snode);
      }
      depth = depth + 1;
      plVar7 = src_merge_start;
    } while ((src_snode != src->schema) && ((src_snode->nodetype & 0x1042) != LYS_UNKNOWN));
    if (src_snode == src->schema) {
      iter = src;
      if ((options & 0x400U) != 0) goto LAB_001b6d0c;
      node = (lyd_node *)0x0;
      src_local = src;
      goto LAB_001b6e03;
    }
    if (src_snode->nodetype != LYS_CONTAINER) {
      pcVar4 = src_snode->name;
      pcVar5 = strnodetype(src_snode->nodetype);
      ly_log(ctx_local,LY_LLERR,LY_EINVAL,"Cannot create %s \"%s\" for the merge.",pcVar5,pcVar4);
      break;
    }
    if (src_merge_start == (lyd_node *)0x0) {
      if (bVar1) {
        node = trg_merge_start;
        bVar1 = false;
      }
      else {
        node = trg_merge_start->child;
      }
      for (; node != (lyd_node *)0x0; node = node->next) {
        if (ctx_local == (ly_ctx *)0x0) {
          sch = src_snode;
        }
        else {
          sch = lys_get_schema_inctx(src_snode,ctx_local);
          if (sch == (lys_node *)0x0) {
            pcVar4 = src_snode->name;
            plVar6 = lys_node_module(src_snode);
            ly_log(ctx_local,LY_LLERR,LY_EINVAL,
                   "Target context does not contain schema node for the data node being merged (%s:%s)."
                   ,plVar6->name,pcVar4);
            goto LAB_001b6fe6;
          }
        }
        if (sch == node->schema) {
          trg_merge_start = node;
          break;
        }
      }
      if ((options & 0x400U) == 0) {
        src_snode = sch;
      }
    }
    else if (((ctx_local != (ly_ctx *)0x0) && ((options & 0x400U) == 0)) &&
            (src_snode = lys_get_schema_inctx(src_snode,ctx_local), uVar2 = uRam0000000000000000,
            src_snode == (lys_node *)0x0)) {
      plVar6 = lys_node_module((lys_node *)0x0);
      ly_log(ctx_local,LY_LLERR,LY_EINVAL,
             "Target context does not contain schema node for the data node being merged (%s:%s).",
             plVar6->name,uVar2);
      break;
    }
  } while (((node != (lyd_node *)0x0) ||
           (plVar7 = _lyd_new((lyd_node *)0x0,src_snode,dflt), src_merge_start == (lyd_node *)0x0))
          || (iVar3 = lyd_insert(plVar7,src_merge_start), iVar3 == 0));
LAB_001b6fe6:
  if (target != *trg) {
    lyd_free_withsiblings(target);
  }
  lyd_free_withsiblings(src_merge_start);
  return -1;
LAB_001b6e03:
  if (src_local == (lyd_node *)0x0) goto LAB_001b6e11;
  plVar7 = lyd_dup_to_ctx(src_local,1,ctx_local);
  if (plVar7 == (lyd_node *)0x0) {
    lyd_free_withsiblings(node);
    goto LAB_001b6fe6;
  }
  if ((node != (lyd_node *)0x0) &&
     (iVar3 = lyd_insert_after(node->prev,plVar7), plVar7 = node, iVar3 != 0)) {
    lyd_free_withsiblings(node);
    goto LAB_001b6fe6;
  }
  node = plVar7;
  if ((options & 0x1000U) != 0) goto LAB_001b6e11;
  src_local = src_local->next;
  goto LAB_001b6e03;
LAB_001b6d0c:
  while ((iter != (lyd_node *)0x0 && (check_leaf_list_backlinks(iter), (options & 0x1000U) == 0))) {
    iter = iter->next;
  }
  node = src;
  if ((src != src->prev) && ((options & 0x1000U) != 0)) {
    plVar7 = src->prev;
    lyd_unlink(src);
    lyd_free_withsiblings(plVar7);
  }
LAB_001b6e11:
  if (src_merge_start == (lyd_node *)0x0) {
    src_merge_start = node;
  }
  else {
    for (node2 = src_merge_start; node2->child != (lyd_node *)0x0; node2 = node2->child) {
    }
    node2->child = node;
    for (; node != (lyd_node *)0x0; node = node->next) {
      node->parent = node2;
    }
  }
  if (bVar1) {
    ret = lyd_merge_siblings(trg_merge_start,src_merge_start,options);
  }
  else {
    ret = lyd_merge_parent_children(trg_merge_start,src_merge_start,options);
  }
  src_merge_start = (lyd_node *)0x0;
  if (ret == 2) {
    node = target;
    while (node != (lyd_node *)0x0) {
      node->validity = node->validity & 0x7f;
      if ((node->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
        node2 = node->child;
      }
      else {
        node2 = (lyd_node *)0x0;
      }
      if (node2 == (lyd_node *)0x0) {
        if (node == target) break;
        node2 = node->next;
      }
      while ((node2 == (lyd_node *)0x0 && (node = node->parent, node->parent != target->parent))) {
        node2 = node->next;
      }
      node = node2;
    }
    ret = 0;
  }
  else if (ret != 0) goto LAB_001b6fe6;
  if (target->schema->nodetype == LYS_RPC) {
    lyd_schema_sort(target,1);
  }
  if (target != *trg) {
    lyd_free_withsiblings(*trg);
    *trg = target;
  }
  return ret;
}



int lyd_merge(lyd_node *target,lyd_node *source,int options)

{
  int iVar1;
  int options_local;
  lyd_node *source_local;
  lyd_node *target_local;
  
  target_local = target;
  ly_log_dbg(0x20,"%s","lyd_merge");
  if ((target_local == (lyd_node *)0x0) || (source == (lyd_node *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_merge");
    iVar1 = -1;
  }
  else {
    iVar1 = lyd_merge_to_ctx(&target_local,source,options,target_local->schema->module->ctx);
  }
  return iVar1;
}



void lyd_free_diff(lyd_difflist *diff)

{
  lyd_difflist *diff_local;
  
  ly_log_dbg(0x20,"%s","lyd_free_diff");
  if (diff != (lyd_difflist *)0x0) {
    free(diff->type);
    free(diff->first);
    free(diff->second);
    free(diff);
  }
  return;
}



int lyd_difflist_add(lyd_difflist *diff,uint *size,uint index,LYD_DIFFTYPE type,lyd_node *first,
                    lyd_node *second)

{
  uint uVar1;
  ly_ctx *ctx_00;
  LYD_DIFFTYPE *pLVar2;
  lyd_node **pplVar3;
  lyd_node *second_local;
  lyd_node *first_local;
  LYD_DIFFTYPE type_local;
  uint index_local;
  uint *size_local;
  lyd_difflist *diff_local;
  ly_ctx *ctx;
  void *new;
  
  if (diff == (lyd_difflist *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("diff",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0xcdb,"lyd_difflist_add");
  }
  if ((size == (uint *)0x0) || (*size == 0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("size && *size",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0xcdc,"lyd_difflist_add");
  }
  if ((first == (lyd_node *)0x0) && (second == (lyd_node *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("first || second",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0xcdd,"lyd_difflist_add");
  }
  if (first == (lyd_node *)0x0) {
    if (second == (lyd_node *)0x0) {
      ctx_00 = (ly_ctx *)0x0;
    }
    else {
      ctx_00 = second->schema->module->ctx;
    }
  }
  else {
    ctx_00 = first->schema->module->ctx;
  }
  if (index + 1 == *size) {
    *size = *size + 0x10;
    pLVar2 = (LYD_DIFFTYPE *)realloc(diff->type,(ulong)*size * 4);
    if (pLVar2 == (LYD_DIFFTYPE *)0x0) {
      ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_difflist_add");
      return 1;
    }
    diff->type = pLVar2;
    pplVar3 = (lyd_node **)realloc(diff->first,(ulong)*size * 8);
    if (pplVar3 == (lyd_node **)0x0) {
      ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_difflist_add");
      return 1;
    }
    diff->first = pplVar3;
    pplVar3 = (lyd_node **)realloc(diff->second,(ulong)*size * 8);
    if (pplVar3 == (lyd_node **)0x0) {
      ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_difflist_add");
      return 1;
    }
    diff->second = pplVar3;
  }
  diff->type[index] = type;
  diff->first[index] = first;
  diff->second[index] = second;
  uVar1 = index + 1;
  diff->type[uVar1] = LYD_DIFF_END;
  diff->first[uVar1] = (lyd_node *)0x0;
  diff->second[uVar1] = (lyd_node *)0x0;
  return 0;
}



int diff_ordset_insert(lyd_node *node,ly_set *ordset)

{
  undefined8 *node_00;
  ly_set *ordset_local;
  lyd_node *node_local;
  uint i;
  diff_ordered *iter;
  diff_ordered *new_ordered;
  
  i = 0;
  while ((i < ordset->number &&
         (((lys_node *)(ordset->set).s[i]->name != node->schema ||
          ((lyd_node *)(ordset->set).s[i]->dsc != node->parent))))) {
    i = i + 1;
  }
  if (i == ordset->number) {
    node_00 = (undefined8 *)calloc(1,0x30);
    if (node_00 == (undefined8 *)0x0) {
      ly_log(node->schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
             "diff_ordset_insert");
      return 1;
    }
    *node_00 = node->schema;
    node_00[1] = node->parent;
    ly_set_add(ordset,node_00,1);
  }
  *(int *)&(ordset->set).s[i]->ref = *(int *)&(ordset->set).s[i]->ref + 1;
  return 0;
}



void diff_ordset_free(ly_set *set)

{
  lys_node *__ptr;
  ly_set *set_local;
  uint i;
  uint j;
  diff_ordered *ord;
  
  if (set != (ly_set *)0x0) {
    for (i = 0; i < set->number; i = i + 1) {
      __ptr = (set->set).s[i];
      for (j = 0; j < *(uint *)&__ptr->ref; j = j + 1) {
        free(*(void **)((ulong)j * 0x18 + *(long *)&__ptr->flags + 0x10));
      }
      free(*(void **)&__ptr->flags);
      free(__ptr);
    }
    ly_set_free(set);
  }
  return;
}



int lyd_diff_compare(lyd_node *first,lyd_node *second,int options)

{
  int iVar1;
  int options_local;
  lyd_node *second_local;
  lyd_node *first_local;
  int rc;
  
  if (((first->field_0x9 & 1) != 0) && ((options & 1U) == 0)) {
    return 1;
  }
  if ((first->schema->nodetype & (LYS_LEAFLIST|LYS_LIST)) != LYS_UNKNOWN) {
    if ((char)first->validity < '\0') {
      return 1;
    }
    iVar1 = lyd_list_equal(first,second,options & 1);
    if (iVar1 == -1) {
      return -1;
    }
    if (iVar1 == 0) {
      return 1;
    }
  }
  return 0;
}



int lyd_diff_match(lyd_node *first,lyd_node *second,lyd_difflist *diff,uint *size,uint *i,
                  ly_set *matchset,ly_set *ordset,int options)

{
  LYS_NODE LVar1;
  uint uVar2;
  int iVar3;
  ly_set *matchset_local;
  uint *i_local;
  uint *size_local;
  lyd_difflist *diff_local;
  lyd_node *second_local;
  lyd_node *first_local;
  
  LVar1 = first->schema->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_001b772b_caseD_20:
    iVar3 = lyd_anydata_equal(first,second);
    if (iVar3 == 0) {
      uVar2 = *i;
      *i = uVar2 + 1;
      iVar3 = lyd_difflist_add(diff,size,uVar2,LYD_DIFF_CHANGED,first,second);
      if (iVar3 != 0) {
        return -1;
      }
    }
LAB_001b78e8:
    if ((char)first->validity < '\0') {
                    // WARNING: Subroutine does not return
      __assert_fail("!(first->validity & LYD_VAL_INUSE)",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                    ,0xd97,"lyd_diff_match");
    }
    first->validity = first->validity | 0x80;
    iVar3 = 0;
  }
  else {
    if (LYS_ANYDATA < LVar1) goto switchD_001b772b_caseD_2;
    if (LVar1 == LYS_ACTION) goto switchD_001b772b_caseD_1;
    if (LYS_ACTION < LVar1) goto switchD_001b772b_caseD_2;
    if (LVar1 == LYS_RPC) goto switchD_001b772b_caseD_1;
    if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
      if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
        if ((LVar1 != LYS_UNKNOWN) && (true)) {
          switch(LVar1) {
          default:
            goto switchD_001b772b_caseD_2;
          case LYS_LEAF:
            iVar3 = lyd_leaf_val_equal(first,second,0);
            if ((iVar3 == 0) ||
               (((options & 1U) != 0 && ((first->field_0x9 & 1) != (second->field_0x9 & 1))))) {
              uVar2 = *i;
              *i = uVar2 + 1;
              iVar3 = lyd_difflist_add(diff,size,uVar2,LYD_DIFF_CHANGED,first,second);
              if (iVar3 != 0) {
                return -1;
              }
            }
            break;
          case LYS_LEAFLIST:
          case LYS_LIST:
            if ((first->schema->flags & 0x100) != 0) {
              diff_ordset_insert(first,ordset);
            }
          case LYS_CONTAINER:
switchD_001b772b_caseD_1:
            if ((char)second->validity < '\0') {
                    // WARNING: Subroutine does not return
              __assert_fail("!(second->validity & LYD_VAL_INUSE)",
                            "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                            ,0xd7a,"lyd_diff_match");
            }
            second->validity = second->validity | 0x80;
            ly_set_add(matchset,first,1);
            break;
          case LYS_ANYXML:
            goto switchD_001b772b_caseD_20;
          }
          goto LAB_001b78e8;
        }
      }
      else if (LVar1 == LYS_NOTIF) goto switchD_001b772b_caseD_1;
    }
switchD_001b772b_caseD_2:
    ly_log(first->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
           ,0xd92);
    iVar3 = -1;
  }
  return iVar3;
}



int lyd_diff_equivnode(lyd_node *first,lyd_node *second)

{
  int iVar1;
  lyd_node *second_local;
  lyd_node *first_local;
  lyd_node *iter1;
  lyd_node *iter2;
  
  iter1 = first;
  iter2 = second;
  while( true ) {
    if ((iter1 == (lyd_node *)0x0) || (iter2 == (lyd_node *)0x0)) {
      return (uint)(iter1 == iter2);
    }
    if (iter1->schema->module->ctx == iter2->schema->module->ctx) {
      if (iter1->schema != iter2->schema) {
        return 0;
      }
    }
    else {
      iVar1 = ly_strequal_(iter1->schema->name,iter2->schema->name);
      if (iVar1 == 0) {
        return 0;
      }
    }
    if ((iter1->schema->nodetype == LYS_LIST) && (iVar1 = lyd_list_equal(iter1,iter2,0), iVar1 != 1)
       ) break;
    iter1 = iter1->parent;
    iter2 = iter2->parent;
  }
  return 0;
}



int lyd_diff_move_preprocess(diff_ordered *ordered,lyd_node *first,lyd_node *second)

{
  uint uVar1;
  ly_ctx *ctx_00;
  int iVar2;
  uint uVar3;
  char *__ptr;
  diff_ordered_dist *pdVar4;
  uint uVar5;
  lyd_node *second_local;
  lyd_node *first_local;
  diff_ordered *ordered_local;
  uint pos;
  int abs_dist;
  lyd_node *iter;
  diff_ordered_dist *dist_iter;
  diff_ordered_dist *dist_last;
  ly_ctx *ctx;
  char *str;
  diff_ordered_dist *dist_aux;
  
  ctx_00 = first->schema->module->ctx;
  pos = 0;
  for (iter = first->prev; iter->next != (lyd_node *)0x0; iter = iter->prev) {
    if (((char)iter->validity < '\0') && (iter->schema == first->schema)) {
      pos = pos + 1;
    }
  }
  if (pos != ordered->count) {
    uVar1 = ordered->count;
    uVar3 = ordered->count;
    __ptr = lyd_path(first);
    ly_log_dbg(0x10,"detected moved element \"%s\" from %d to %d (distance %d)",__ptr,(ulong)pos,
               (ulong)uVar3,(ulong)(uVar1 - pos));
    free(__ptr);
  }
  pdVar4 = (diff_ordered_dist *)calloc(1,0x10);
  ordered->items[pos].dist = pdVar4;
  if (pdVar4 == (diff_ordered_dist *)0x0) {
    ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_diff_move_preprocess");
    iVar2 = 1;
  }
  else {
    (ordered->items[pos].dist)->dist = ordered->count - pos;
    uVar1 = (ordered->items[pos].dist)->dist;
    uVar3 = (int)uVar1 >> 0x1f;
    ordered->items[pos].first = first;
    ordered->items[pos].second = second;
    ordered->count = ordered->count + 1;
    dist_iter = ordered->dist;
    dist_last = (diff_ordered_dist *)0x0;
    for (; dist_iter != (diff_ordered_dist *)0x0; dist_iter = dist_iter->next) {
      uVar5 = dist_iter->dist >> 0x1f;
      if ((int)((dist_iter->dist ^ uVar5) - uVar5) <= (int)((uVar1 ^ uVar3) - uVar3)) {
        pdVar4->next = dist_iter;
        if (dist_last != (diff_ordered_dist *)0x0) {
          dist_last->next = pdVar4;
        }
        break;
      }
      if (dist_iter->next == ordered->dist) {
        pdVar4->next = ordered->dist;
        ordered->dist_last = pdVar4;
        break;
      }
      dist_last = dist_iter;
    }
    if (pdVar4->next == ordered->dist) {
      if (pdVar4 == ordered->dist_last) {
        if (ordered->dist == (diff_ordered_dist *)0x0) {
          pdVar4->next = pdVar4;
          ordered->dist_last = pdVar4;
          ordered->dist = ordered->dist_last;
        }
      }
      else {
        ordered->dist = pdVar4;
        if (pdVar4->next == (diff_ordered_dist *)0x0) {
          ordered->dist_last = pdVar4;
          pdVar4->next = pdVar4;
        }
        else {
          ordered->dist_last->next = pdVar4;
        }
      }
    }
    iVar2 = 0;
  }
  return iVar2;
}



lyd_difflist * lyd_diff_init_difflist(ly_ctx *ctx,uint *size)

{
  lyd_difflist *__ptr;
  LYD_DIFFTYPE *pLVar1;
  lyd_node **pplVar2;
  uint *size_local;
  ly_ctx *ctx_local;
  lyd_difflist *result;
  
  __ptr = (lyd_difflist *)malloc(0x18);
  if (__ptr == (lyd_difflist *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_diff_init_difflist");
    *size = 0;
    __ptr = (lyd_difflist *)0x0;
  }
  else {
    *size = 1;
    pLVar1 = (LYD_DIFFTYPE *)calloc((ulong)*size,4);
    __ptr->type = pLVar1;
    pplVar2 = (lyd_node **)calloc((ulong)*size,8);
    __ptr->first = pplVar2;
    pplVar2 = (lyd_node **)calloc((ulong)*size,8);
    __ptr->second = pplVar2;
    if (((__ptr->type == (LYD_DIFFTYPE *)0x0) || (__ptr->first == (lyd_node **)0x0)) ||
       (__ptr->second == (lyd_node **)0x0)) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_diff_init_difflist");
      free(__ptr->second);
      free(__ptr->first);
      free(__ptr->type);
      free(__ptr);
      *size = 0;
      __ptr = (lyd_difflist *)0x0;
    }
  }
  return __ptr;
}



lyd_difflist * lyd_diff(lyd_node *first,lyd_node *second,int options)

{
  ly_set **pplVar1;
  long lVar2;
  long lVar3;
  diff_ordered_dist *pdVar4;
  uint uVar5;
  matchlist_s *__ptr;
  int iVar6;
  ly_set *plVar7;
  diff_ordered_item *pdVar8;
  lyd_difflist *plVar9;
  lyd_node *plVar10;
  long in_FS_OFFSET;
  int options_local;
  lyd_node *second_local;
  lyd_node *first_local;
  uint size;
  uint size2;
  uint index;
  uint index2;
  uint i;
  uint j;
  uint k;
  int rc;
  lyd_node *elem2;
  lyd_node *iter;
  lyd_node *elem1;
  lyd_node *aux;
  lyd_node *parent;
  lyd_node *next1;
  lyd_node *next2;
  lyd_difflist *result;
  lyd_difflist *result2;
  matchlist_s *matchlist;
  ly_set *ordset;
  diff_ordered_dist *dist_iter;
  ly_ctx *ctx;
  diff_ordered *ordered;
  matchlist_s *mlaux;
  void *new;
  diff_ordered_dist *dist_aux;
  diff_ordered_item item_aux;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_diff");
  parent = (lyd_node *)0x0;
  result2 = (lyd_difflist *)0x0;
  index = 0;
  index2 = 0;
  matchlist = (matchlist_s *)0x0;
  ordset = (ly_set *)0x0;
  if (first == (lyd_node *)0x0) {
    if ((second == (lyd_node *)0x0) || (second->parent == (lyd_node *)0x0)) {
      result = lyd_diff_init_difflist((ly_ctx *)0x0,&size);
      for (iter = second; uVar5 = index, plVar9 = result, iter != (lyd_node *)0x0; iter = iter->next
          ) {
        if (((iter->field_0x9 & 1) == 0) || ((options & 1U) != 0)) {
          index = index + 1;
          iVar6 = lyd_difflist_add(result,&size,uVar5,LYD_DIFF_CREATED,(lyd_node *)0x0,iter);
          if (iVar6 != 0) goto LAB_001b98a8;
        }
        plVar9 = result;
        if ((options & 0x800U) != 0) break;
      }
    }
    else {
      ly_log(second->schema->module->ctx,LY_LLERR,LY_EINVAL,
             "%s: \"first\" parameter is NULL and \"second\" is not top level.","lyd_diff");
      plVar9 = (lyd_difflist *)0x0;
    }
    goto LAB_001b98d8;
  }
  if (second == (lyd_node *)0x0) {
    result = lyd_diff_init_difflist(first->schema->module->ctx,&size);
    for (iter = first; uVar5 = index, plVar9 = result, iter != (lyd_node *)0x0; iter = iter->next) {
      if (((iter->field_0x9 & 1) == 0) || ((options & 1U) != 0)) {
        index = index + 1;
        iVar6 = lyd_difflist_add(result,&size,uVar5,LYD_DIFF_DELETED,iter,(lyd_node *)0x0);
        if (iVar6 != 0) goto LAB_001b98a8;
      }
      plVar9 = result;
      if ((options & 0x800U) != 0) break;
    }
    goto LAB_001b98d8;
  }
  ctx = first->schema->module->ctx;
  if ((options & 0x800U) == 0) {
    first_local = first;
    if (first->parent == (lyd_node *)0x0) {
      while (first_local->prev->next != (lyd_node *)0x0) {
        first_local = first_local->prev;
      }
    }
    else {
      first_local = first->parent->child;
    }
    second_local = second;
    if (second->parent == (lyd_node *)0x0) {
      while (second_local->prev->next != (lyd_node *)0x0) {
        second_local = second_local->prev;
      }
    }
    else {
      second_local = second->parent->child;
    }
    if ((((first_local->parent != (lyd_node *)0x0) && (second_local->parent != (lyd_node *)0x0)) &&
        (first_local->parent->schema != second_local->parent->schema)) ||
       ((first_local->parent == (lyd_node *)0x0 && (first_local->parent != second_local->parent))))
    {
      ly_log(ctx,LY_LLERR,LY_EINVAL,"%s: incompatible trees with different parents.","lyd_diff");
      plVar9 = (lyd_difflist *)0x0;
      goto LAB_001b98d8;
    }
  }
  else {
    if (first->schema != second->schema) {
      ly_log(ctx,LY_LLERR,LY_EINVAL,
             "%s: incompatible trees to compare with LYD_OPT_NOSIBLINGS option.","lyd_diff");
      plVar9 = (lyd_difflist *)0x0;
      goto LAB_001b98d8;
    }
    first_local = first->child;
    second_local = second->child;
  }
  if (first_local == second_local) {
    ly_log(ctx,LY_LLERR,LY_EINVAL,"%s: comparing the same tree does not make sense.","lyd_diff");
    plVar9 = (lyd_difflist *)0x0;
    goto LAB_001b98d8;
  }
  result = lyd_diff_init_difflist(ctx,&size);
  if ((result != (lyd_difflist *)0x0) &&
     (result2 = lyd_diff_init_difflist(ctx,&size2), result2 != (lyd_difflist *)0x0)) {
    matchlist = (matchlist_s *)malloc(0x18);
    if (matchlist == (matchlist_s *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_diff");
    }
    else {
      matchlist->i = 0;
      plVar7 = ly_set_new();
      matchlist->match = plVar7;
      matchlist->prev = (matchlist_s *)0x0;
      ordset = ly_set_new();
      if (ordset != (ly_set *)0x0) {
        next1 = first_local;
        next2 = second_local;
LAB_001b9142:
        elem2 = next2;
        if (next2 != (lyd_node *)0x0) {
          elem1 = next1;
          if (((next2->field_0x9 & 1) == 0) || ((options & 1U) != 0)) {
            if ((next1 == (lyd_node *)0x0) ||
               ((next1->parent == (lyd_node *)0x0 || (next1->parent->ht == (hash_table *)0x0)))) {
              for (iter = next1; iter != (lyd_node *)0x0; iter = iter->next) {
                if (iter->schema == elem2->schema) {
                  rc = lyd_diff_compare(iter,elem2,options);
                  if (rc == -1) goto LAB_001b98a8;
                  if (rc == 0) break;
                }
              }
            }
            else {
              iter = (lyd_node *)0x0;
              iVar6 = lyht_find(next1->parent->ht,&elem2,next2->hash,&item_aux.first);
              if (iVar6 == 0) {
                iter = (lyd_node *)(item_aux.first)->schema;
                if (((*(undefined *)((long)&((lys_node *)iter)->dsc + 1) & 1) != 0) &&
                   ((options & 1U) == 0)) {
                  iter = (lyd_node *)0x0;
                }
                while ((iter != (lyd_node *)0x0 && ((char)iter->validity < '\0'))) {
                  if (((iter->schema->nodetype & (LYS_LEAFLIST|LYS_LIST)) == LYS_UNKNOWN) ||
                     ((iter->schema->flags & 2) == 0)) {
                    // WARNING: Subroutine does not return
                    __assert_fail("(iter->schema->nodetype & (LYS_LIST | LYS_LEAFLIST)) && (iter->schema->flags & LYS_CONFIG_R)"
                                  ,
                                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                                  ,0xec1,"lyd_diff");
                  }
                  iVar6 = lyht_find_next(elem1->parent->ht,&iter,iter->hash,&item_aux.first);
                  if (iVar6 == 0) {
                    iter = (lyd_node *)(item_aux.first)->schema;
                  }
                  else {
                    iter = (lyd_node *)0x0;
                  }
                }
              }
            }
            if ((iter != (lyd_node *)0x0) &&
               (iVar6 = lyd_diff_match(iter,elem2,result,&size,&index,matchlist->match,ordset,
                                       options), iVar6 != 0)) goto LAB_001b98a8;
            uVar5 = index2;
            if (iter == (lyd_node *)0x0) {
              plVar10 = parent;
              if (elem1 != (lyd_node *)0x0) {
                plVar10 = elem1->parent;
              }
              index2 = index2 + 1;
              iVar6 = lyd_difflist_add(result2,&size2,uVar5,LYD_DIFF_CREATED,plVar10,elem2);
              uVar5 = index2;
              if (iVar6 != 0) goto LAB_001b98a8;
              if ((elem1 != (lyd_node *)0x0) && ((elem2->schema->flags & 0x100) != 0)) {
                for (aux = elem2->prev;
                    (aux->next != (lyd_node *)0x0 && (aux->schema != elem2->schema));
                    aux = aux->prev) {
                }
                if (aux->next == (lyd_node *)0x0) {
                  aux = (lyd_node *)0x0;
                }
                index2 = index2 + 1;
                iVar6 = lyd_difflist_add(result2,&size2,uVar5,LYD_DIFF_MOVEDAFTER2,aux,elem2);
                if (iVar6 != 0) goto LAB_001b98a8;
              }
            }
          }
          next1 = elem1;
          next2 = elem2->next;
          if (next2 != (lyd_node *)0x0) goto LAB_001b9129;
          i = ordset->number;
          while ((i != 0 &&
                 (ordered = (diff_ordered *)(ordset->set).s[i - 1],
                 lVar3._0_2_ = ((lys_node *)ordered)->flags,
                 lVar3._2_1_ = ((lys_node *)ordered)->ext_size,
                 lVar3._3_1_ = ((lys_node *)ordered)->iffeature_size,
                 lVar3._4_1_ = ((lys_node *)ordered)->padding[0],
                 lVar3._5_1_ = ((lys_node *)ordered)->padding[1],
                 lVar3._6_1_ = ((lys_node *)ordered)->padding[2],
                 lVar3._7_1_ = ((lys_node *)ordered)->padding[3], lVar3 == 0))) {
            pdVar8 = (diff_ordered_item *)calloc((ulong)*(uint *)&((lys_node *)ordered)->ref,0x18);
            ordered->items = pdVar8;
            if (ordered->items == (diff_ordered_item *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_diff");
              goto LAB_001b98a8;
            }
            ordered->dist = (diff_ordered_dist *)0x0;
            ordered->count = 0;
            i = i - 1;
          }
          if (elem2->parent == second_local->parent) {
            elem2 = second_local;
          }
          else {
            elem2 = elem2->parent->child;
          }
          for (iter = elem2; iter != (lyd_node *)0x0; iter = iter->next) {
            if ((char)iter->validity < '\0') {
              if (matchlist->i == matchlist->match->number) {
                if (iter != elem2) {
                  ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                         ,0xf2e);
                  goto LAB_001b98a8;
                }
                iter = (lyd_node *)0x0;
                break;
              }
              iter->validity = iter->validity & 0x7f;
              if (((iter->schema->nodetype & (LYS_LEAFLIST|LYS_LIST)) != LYS_UNKNOWN) &&
                 ((iter->schema->flags & 0x100) != 0)) {
                for (j = ordset->number; j != 0; j = j - 1) {
                  ordered = (diff_ordered *)(ordset->set).s[j - 1];
                  if (((lys_node *)((lys_node *)ordered)->name == iter->schema) &&
                     (iVar6 = lyd_diff_equivnode((lyd_node *)((lys_node *)ordered)->dsc,iter->parent
                                                ), iVar6 != 0)) {
                    lyd_diff_move_preprocess
                              (ordered,(lyd_node *)(matchlist->match->set).s[matchlist->i],iter);
                    break;
                  }
                }
              }
              if (((iter->schema->nodetype == LYS_CONTAINER) ||
                  ((iter->schema->nodetype == LYS_LIST && (iter->schema->padding[2] != '\0')))) &&
                 (iter->child != (lyd_node *)0x0)) goto LAB_001b8b8a;
              matchlist->i = matchlist->i + 1;
            }
          }
          goto LAB_001b8cc7;
        }
LAB_001b9152:
        ly_set_free(matchlist->match);
        free(matchlist);
        matchlist = (matchlist_s *)0x0;
        next1 = first_local;
        while (elem1 = next1, uVar5 = index, next1 != (lyd_node *)0x0) {
          if ((char)next1->validity < '\0') {
            next1->validity = next1->validity & 0x7f;
LAB_001b921a:
            if (((next1->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) &&
               ((next1->schema->nodetype != LYS_LIST || (next1->schema->padding[2] != '\0')))) {
              next1 = next1->child;
            }
            else {
              next1 = (lyd_node *)0x0;
            }
            if (next1 == (lyd_node *)0x0) goto LAB_001b9277;
          }
          else {
            if (((next1->field_0x9 & 1) != 0) && ((options & 1U) == 0)) goto LAB_001b921a;
            index = index + 1;
            iVar6 = lyd_difflist_add(result,&size,uVar5,LYD_DIFF_DELETED,next1,(lyd_node *)0x0);
            if (iVar6 != 0) goto LAB_001b98a8;
LAB_001b9277:
            next1 = elem1->next;
          }
          while ((next1 == (lyd_node *)0x0 && (elem1 = elem1->parent, elem1 != first_local->parent))
                ) {
            next1 = elem1->next;
          }
        }
        for (i = 0; i < ordset->number; i = i + 1) {
          ordered = (diff_ordered *)(ordset->set).s[i];
          if (*(int *)(((lys_node *)ordered)->ext + 1) != 0) {
            dist_iter = (diff_ordered_dist *)((lys_node *)ordered)->ext;
            while( true ) {
              pdVar4 = dist_iter;
              dist_aux = dist_iter;
              while (dist_iter->dist == 0) {
                dist_iter = dist_iter->next;
                if (dist_iter == pdVar4) goto LAB_001b95ed;
              }
              k = 0;
              while ((k < ordered->count && (dist_iter != ordered->items[k].dist))) {
                k = k + 1;
              }
              memcpy(&item_aux,ordered->items + k,0x18);
              if (dist_iter->dist < 1) {
                while (dist_iter->dist != 0) {
                  memcpy(ordered->items + k,ordered->items + (k - 1),0x18);
                  pdVar4 = ordered->items[k].dist;
                  pdVar4->dist = pdVar4->dist + -1;
                  dist_iter->dist = dist_iter->dist + 1;
                  k = k - 1;
                }
              }
              else {
                while (dist_iter->dist != 0) {
                  memcpy(ordered->items + k,ordered->items + (k + 1),0x18);
                  pdVar4 = ordered->items[k].dist;
                  pdVar4->dist = pdVar4->dist + 1;
                  dist_iter->dist = dist_iter->dist + -1;
                  k = k + 1;
                }
              }
              memcpy(ordered->items + k,&item_aux,0x18);
              uVar5 = index;
              if (k == 0) {
                plVar10 = (lyd_node *)0x0;
              }
              else {
                plVar10 = ordered->items[k - 1].first;
              }
              index = index + 1;
              iVar6 = lyd_difflist_add(result,&size,uVar5,LYD_DIFF_MOVEDAFTER1,item_aux.first,
                                       plVar10);
              if (iVar6 != 0) break;
              dist_iter = dist_iter->next;
            }
            goto LAB_001b98a8;
          }
LAB_001b95ed:
        }
        diff_ordset_free(ordset);
        ordset = (ly_set *)0x0;
        if (index2 != 0) {
          if (size <= index2 + index + 1) {
            size = index2 + index + 1;
            new = realloc(result->type,(ulong)size * 4);
            if ((LYD_DIFFTYPE *)new == (LYD_DIFFTYPE *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_diff");
            }
            else {
              result->type = (LYD_DIFFTYPE *)new;
              new = realloc(result->first,(ulong)size * 8);
              if ((lyd_node **)new == (lyd_node **)0x0) {
                ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_diff");
              }
              else {
                result->first = (lyd_node **)new;
                new = realloc(result->second,(ulong)size * 8);
                if ((lyd_node **)new != (lyd_node **)0x0) {
                  result->second = (lyd_node **)new;
                  goto LAB_001b9794;
                }
                ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_diff");
              }
            }
            goto LAB_001b98a8;
          }
LAB_001b9794:
          memcpy(result->type + index,result2->type,(ulong)(index2 + 1) * 4);
          memcpy(result->first + index,result2->first,(ulong)(index2 + 1) * 8);
          memcpy(result->second + index,result2->second,(ulong)(index2 + 1) * 8);
        }
        lyd_free_diff(result2);
        plVar9 = result;
        goto LAB_001b98d8;
      }
    }
  }
LAB_001b98a8:
  while (matchlist != (matchlist_s *)0x0) {
    mlaux = matchlist;
    pplVar1 = &matchlist->match;
    matchlist = matchlist->prev;
    ly_set_free(*pplVar1);
    free(mlaux);
  }
  diff_ordset_free(ordset);
  lyd_free_diff(result);
  lyd_free_diff(result2);
  plVar9 = (lyd_difflist *)0x0;
LAB_001b98d8:
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar9;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_001b8b8a:
  while ((matchlist->i < matchlist->match->number &&
         ((lys_node *)(matchlist->match->set).s[matchlist->i]->name != iter->schema))) {
    matchlist->i = matchlist->i + 1;
  }
  if (matchlist->i == matchlist->match->number) {
    ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
           ,0xf48);
    goto LAB_001b98a8;
  }
  next1 = (lyd_node *)(matchlist->match->set).s[matchlist->i]->parent;
  if ((lys_node *)next1 == (lys_node *)0x0) {
    parent = (lyd_node *)(matchlist->match->set).s[matchlist->i];
  }
  matchlist->i = matchlist->i + 1;
  next2 = iter->child;
LAB_001b8cc7:
  if (iter == (lyd_node *)0x0) {
    if (second_local == elem2) goto LAB_001b9152;
  }
  else {
    mlaux = (matchlist_s *)malloc(0x18);
    if (mlaux == (matchlist_s *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_diff");
      goto LAB_001b98a8;
    }
    mlaux->i = 0;
    plVar7 = ly_set_new();
    mlaux->match = plVar7;
    mlaux->prev = matchlist;
    matchlist = mlaux;
  }
LAB_001b9129:
  if (next2 == (lyd_node *)0x0) {
    ly_set_clean(matchlist->match);
    matchlist->i = 0;
    mlaux = matchlist->prev;
    for (iter = elem2->parent->next; iter != (lyd_node *)0x0; iter = iter->next) {
      if ((char)iter->validity < '\0') {
        if (mlaux->i == mlaux->match->number) {
          if (elem2->parent->next != iter) {
            ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                   ,0xf7d);
            goto LAB_001b98a8;
          }
          iter = (lyd_node *)0x0;
          break;
        }
        iter->validity = iter->validity & 0x7f;
        if (((iter->schema->nodetype & (LYS_LEAFLIST|LYS_LIST)) != LYS_UNKNOWN) &&
           ((iter->schema->flags & 0x100) != 0)) {
          for (j = ordset->number; j != 0; j = j - 1) {
            ordered = (diff_ordered *)(ordset->set).s[j - 1];
            if (((lys_node *)((lys_node *)ordered)->name == iter->schema) &&
               (iVar6 = lyd_diff_equivnode((lyd_node *)((lys_node *)ordered)->dsc,iter->parent),
               iVar6 != 0)) {
              lyd_diff_move_preprocess(ordered,(lyd_node *)(mlaux->match->set).s[mlaux->i],iter);
              break;
            }
          }
        }
        if (((iter->schema->nodetype == LYS_CONTAINER) ||
            ((iter->schema->nodetype == LYS_LIST && (iter->schema->padding[2] != '\0')))) &&
           (iter->child != (lyd_node *)0x0)) goto LAB_001b8f93;
        mlaux->i = mlaux->i + 1;
      }
    }
    goto LAB_001b90d0;
  }
  goto LAB_001b9142;
LAB_001b8f93:
  while ((mlaux->i < mlaux->match->number &&
         ((lys_node *)(mlaux->match->set).s[mlaux->i]->name != iter->schema))) {
    mlaux->i = mlaux->i + 1;
  }
  if (mlaux->i == mlaux->match->number) {
    ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
           ,0xf97);
    goto LAB_001b98a8;
  }
  next1 = (lyd_node *)(mlaux->match->set).s[mlaux->i]->parent;
  if ((lys_node *)next1 == (lys_node *)0x0) {
    parent = (lyd_node *)(mlaux->match->set).s[mlaux->i];
  }
  mlaux->i = mlaux->i + 1;
  next2 = iter->child;
LAB_001b90d0:
  if (iter != (lyd_node *)0x0) goto LAB_001b9129;
  elem2 = elem2->parent;
  ly_set_free(matchlist->match);
  __ptr = matchlist;
  mlaux = matchlist;
  matchlist = matchlist->prev;
  free(__ptr);
  if (matchlist->prev == (matchlist_s *)0x0) goto LAB_001b9142;
  goto LAB_001b9129;
}



void lyd_insert_setinvalid(lyd_node *node)

{
  int iVar1;
  lyd_node *node_local;
  lyd_node *next;
  lyd_node *elem;
  lyd_node *parent_list;
  
  if (node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x1066,"lyd_insert_setinvalid");
  }
  iVar1 = ly_new_node_validity(node->schema);
  node->validity = (uint8_t)iVar1;
  parent_list = node->parent;
  while ((parent_list != (lyd_node *)0x0 && (parent_list->schema->nodetype != LYS_LIST))) {
    parent_list = parent_list->parent;
  }
  if ((parent_list != (lyd_node *)0x0) && (elem = node, (parent_list->validity & 2) == 0)) {
    while (elem != (lyd_node *)0x0) {
      if (elem->schema->nodetype == LYS_LIST) {
LAB_001b9a23:
        next = elem->next;
        if ((next == (lyd_node *)0x0) && (elem == node)) break;
      }
      else {
        if ((elem->schema->nodetype == LYS_LEAF) && ((elem->schema->flags & 0x100) != 0)) {
          parent_list->validity = parent_list->validity | 2;
          break;
        }
        if ((elem->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) != LYS_UNKNOWN) {
          if (elem != node) goto LAB_001b9a23;
          break;
        }
        next = elem->child;
        if (next == (lyd_node *)0x0) goto LAB_001b9a23;
      }
      while ((next == (lyd_node *)0x0 && (elem = elem->parent, elem->parent != node->parent))) {
        next = elem->parent->next;
      }
      elem = next;
    }
  }
  if (node->parent != (lyd_node *)0x0) {
    if (((node->schema->nodetype & LYS_LEAFLIST) == LYS_UNKNOWN) ||
       (*(int *)((long)&node->schema[1].priv + 4) == 0)) {
      if (((node->schema->nodetype & LYS_LIST) == LYS_UNKNOWN) ||
         (*(int *)((long)&node->schema[1].iffeature + 4) == 0)) {
        for (next = node->parent; next != (lyd_node *)0x0; next = next->parent) {
          if (((next->schema->flags & 0x2000) != 0) && ((next->schema->flags & 0x4000) != 0)) {
            next->validity = next->validity | 4;
          }
        }
      }
      else {
        node->parent->validity = node->parent->validity | 4;
      }
    }
    else {
      node->parent->validity = node->parent->validity | 4;
    }
  }
  return;
}



void lyd_replace(lyd_node *orig,lyd_node *repl)

{
  lyd_node *repl_local;
  lyd_node *orig_local;
  lyd_node *iter;
  lyd_node *last;
  
  if (repl != (lyd_node *)0x0) {
    last = repl;
    if ((repl->parent == (lyd_node *)0x0) && (repl->prev->next == (lyd_node *)0x0)) {
      for (; last->next != (lyd_node *)0x0; last = last->next) {
        last->parent = orig->parent;
      }
    }
    else {
      repl->next = (lyd_node *)0x0;
      repl->prev = repl;
    }
    if ((orig->parent != (lyd_node *)0x0) && (orig == orig->parent->child)) {
      orig->parent->child = repl;
    }
    if (orig != orig->prev) {
      if (orig->prev->next != (lyd_node *)0x0) {
        orig->prev->next = repl;
      }
      repl->prev = orig->prev;
      orig->prev = orig;
      if (orig->next == (lyd_node *)0x0) {
        iter = repl;
        if (repl->parent == (lyd_node *)0x0) {
          for (; orig != iter->prev; iter = iter->prev) {
          }
          iter->prev = last;
        }
        else {
          repl->parent->child->prev = last;
        }
      }
      else {
        orig->next->prev = last;
        last->next = orig->next;
        orig->next = (lyd_node *)0x0;
      }
    }
  }
  lyd_free(orig);
  return;
}



int lyd_insert_common(lyd_node *parent,lyd_node **sibling,lyd_node *node,int invalidate)

{
  lys_node *plVar1;
  long lVar2;
  lyd_node *plVar3;
  int iVar4;
  char *pcVar5;
  lys_node_list *plVar6;
  lys_module *module;
  char *pcVar7;
  long in_FS_OFFSET;
  int invalidate_local;
  lyd_node *node_local;
  lyd_node **sibling_local;
  lyd_node *parent_local;
  uint8_t pos;
  int invalid;
  int isrpc;
  int clrdflt;
  int i;
  int stype;
  lyd_node *start;
  lys_node *par1;
  lys_node *par2;
  lys_node *siter;
  lyd_node *iter;
  lyd_node *ins;
  lyd_node *next1;
  lyd_node *next2;
  ly_set *llists;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  invalid = 0;
  isrpc = 0;
  clrdflt = 0;
  llists = (ly_set *)0x0;
  stype = 0x600;
  if ((parent == (lyd_node *)0x0) && (sibling == (lyd_node **)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("parent || sibling",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x10fe,"lyd_insert_common");
  }
  if (parent == (lyd_node *)0x0) {
    start = *sibling;
    while (start->prev->next != (lyd_node *)0x0) {
      start = start->prev;
    }
  }
  else {
    start = parent->child;
  }
  if (start == (lyd_node *)0x0) {
    if (parent == (lyd_node *)0x0) {
      if ((node->parent != (lyd_node *)0x0) || (node->prev->next != (lyd_node *)0x0)) {
        lyd_unlink_internal(node,1);
      }
      *sibling = node;
      iVar4 = 0;
      goto LAB_001ba69a;
    }
    par1 = parent->schema;
    if ((par1->nodetype & 0x4100) != LYS_UNKNOWN) {
      stype = 0x4100;
    }
  }
  else if ((parent == (lyd_node *)0x0) || ((parent->schema->nodetype & 0x4100) == LYS_UNKNOWN)) {
    for (par1 = lys_parent(start->schema);
        (par1 != (lys_node *)0x0 && ((par1->nodetype & 0x691) == LYS_UNKNOWN));
        par1 = lys_parent(par1)) {
    }
  }
  else {
    par1 = parent->schema;
    stype = 0x4100;
  }
  for (par2 = lys_parent(node->schema);
      (par2 != (lys_node *)0x0 &&
      ((par2->nodetype & (stype | (LYS_CONTAINER|LYS_LIST|LYS_NOTIF))) == LYS_UNKNOWN));
      par2 = lys_parent(par2)) {
  }
  if (par1 == par2) {
    if ((invalidate != 0) &&
       (((isrpc = lyp_is_rpc_action(node->schema), parent == (lyd_node *)0x0 ||
         (parent != node->parent)) || (invalid = isrpc, isrpc != 0)))) {
      invalid = isrpc + 1;
    }
    if ((node->parent != (lyd_node *)0x0) || (node->prev->next != (lyd_node *)0x0)) {
      lyd_unlink_internal(node,invalid);
    }
    llists = ly_set_new();
    ins = node;
    while (ins != (lyd_node *)0x0) {
      next1 = ins->next;
      if ((invalid == 1) &&
         (iVar4 = lyv_multicases(ins,(lys_node *)0x0,&start,1,(lyd_node *)0x0), iVar4 != 0)) {
        ly_set_free(llists);
        iVar4 = 1;
        goto LAB_001ba69a;
      }
      ins->prev = ins;
      ins->next = (lyd_node *)0x0;
      iter = (lyd_node *)0x0;
      if ((ins->field_0x9 & 1) == 0) {
        clrdflt = 1;
      }
      if ((((ins->field_0x9 & 1) == 0) && (ins->schema->nodetype == LYS_LEAF)) &&
         (plVar6 = lys_is_key((lys_node_leaf *)ins->schema,&pos), plVar6 != (lys_node_list *)0x0)) {
        i = 0;
        iter = parent->child;
        while (((iter != (lyd_node *)0x0 && (i < (int)(uint)pos)) &&
               (iter->schema->nodetype == LYS_LEAF))) {
          i = i + 1;
          iter = iter->next;
        }
        if (iter != (lyd_node *)0x0) {
          if (iter == parent->child) {
            parent->child = ins;
          }
          if (iter->prev->next != (lyd_node *)0x0) {
            iter->prev->next = ins;
          }
          ins->prev = iter->prev;
          iter->prev = ins;
          ins->next = iter;
          if (parent->child != start) {
            start = parent->child;
          }
        }
      }
      else if (ins->schema->nodetype == LYS_LEAFLIST) {
        i = llists->number;
        iVar4 = ly_set_add(llists,ins->schema,0);
        if ((i != iVar4) || ((ins->field_0x9 & 1) != 0)) {
          iter = start;
          while (iter != (lyd_node *)0x0) {
            next2 = iter->next;
            if ((iter->schema == ins->schema) &&
               ((((ins->field_0x9 & 1) != 0 &&
                 (((iter->field_0x9 & 1) == 0 ||
                  (((iter->schema->flags & 1) != 0 &&
                   (iVar4 = strcmp((char *)iter->ht,(char *)ins->ht), iVar4 == 0)))))) ||
                (((ins->field_0x9 & 1) == 0 && ((iter->field_0x9 & 1) != 0)))))) {
              if (iter == start) {
                start = next2;
              }
              lyd_free(iter);
            }
            iter = next2;
          }
        }
      }
      else if ((ins->schema->nodetype == LYS_LEAF) ||
              ((ins->schema->nodetype == LYS_CONTAINER &&
               (plVar1 = ins->schema, lVar2._0_2_ = plVar1[1].flags,
               lVar2._2_1_ = plVar1[1].ext_size, lVar2._3_1_ = plVar1[1].iffeature_size,
               lVar2._4_1_ = plVar1[1].padding[0], lVar2._5_1_ = plVar1[1].padding[1],
               lVar2._6_1_ = plVar1[1].padding[2], lVar2._7_1_ = plVar1[1].padding[3], lVar2 == 0)))
              ) {
        for (iter = start; iter != (lyd_node *)0x0; iter = iter->next) {
          if (iter->schema == ins->schema) {
            if (((ins->field_0x9 & 1) == 0) && ((iter->field_0x9 & 1) == 0)) {
              iter = (lyd_node *)0x0;
            }
            else {
              lyd_replace(iter,ins);
            }
            break;
          }
        }
      }
      if (iter == (lyd_node *)0x0) {
        if (start == (lyd_node *)0x0) {
          start = ins;
          if (parent != (lyd_node *)0x0) {
            parent->child = ins;
          }
        }
        else if (isrpc == 0) {
          start->prev->next = ins;
          ins->prev = start->prev;
          start->prev = ins;
        }
        else {
          for (par1 = ins->schema->parent; (par1->nodetype & 0x600) == LYS_UNKNOWN;
              par1 = lys_parent(par1)) {
          }
          siter = (lys_node *)0x0;
          iter = start;
LAB_001ba52b:
          if (iter == (lyd_node *)0x0) goto LAB_001ba539;
          do {
            module = lys_node_module(par1);
            siter = lys_getnext(siter,par1,module,0);
            if ((siter == (lys_node *)0x0) || (siter == iter->schema)) break;
          } while (siter != ins->schema);
          if (siter != ins->schema) {
            iter = iter->next;
            goto LAB_001ba52b;
          }
          if (((siter->nodetype & (LYS_LEAFLIST|LYS_LIST)) == LYS_UNKNOWN) ||
             (siter != iter->schema)) goto LAB_001ba4be;
          for (; (iter != (lyd_node *)0x0 && (siter == iter->schema)); iter = iter->next) {
          }
          if (iter != (lyd_node *)0x0) {
LAB_001ba4be:
            if (iter == start) {
              start = ins;
              if (parent != (lyd_node *)0x0) {
                parent->child = ins;
              }
            }
            else {
              iter->prev->next = ins;
            }
            ins->prev = iter->prev;
            iter->prev = ins;
            ins->next = iter;
          }
LAB_001ba539:
          if (iter == (lyd_node *)0x0) {
            start->prev->next = ins;
            ins->prev = start->prev;
            start->prev = ins;
          }
        }
      }
      lyd_unlink_hash(ins,ins->parent);
      ins->parent = parent;
      lyd_insert_hash(ins);
      if (invalidate != 0) {
        check_leaf_list_backlinks(ins);
      }
      if (invalid != 0) {
        lyd_insert_setinvalid(ins);
      }
      ins = next1;
    }
    ly_set_free(llists);
    plVar3 = parent;
    if (clrdflt != 0) {
      while ((iter = plVar3, iter != (lyd_node *)0x0 && ((iter->field_0x9 & 1) != 0))) {
        iter->field_0x9 = iter->field_0x9 & 0xfe;
        plVar3 = iter->parent;
      }
    }
    if (sibling != (lyd_node **)0x0) {
      *sibling = start;
    }
    iVar4 = 0;
  }
  else {
    if (par2 == (lys_node *)0x0) {
      pcVar7 = "<top-lvl>";
    }
    else {
      pcVar7 = par2->name;
    }
    if (par1 == (lys_node *)0x0) {
      pcVar5 = "<top-lvl>";
    }
    else {
      pcVar5 = par1->name;
    }
    ly_log(parent->schema->module->ctx,LY_LLERR,LY_EINVAL,
           "Cannot insert, different parents (\"%s\" and \"%s\").",pcVar5,pcVar7);
    iVar4 = 1;
  }
LAB_001ba69a:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar4;
}



int lyd_insert(lyd_node *parent,lyd_node *node)

{
  int iVar1;
  lyd_node *node_local;
  lyd_node *parent_local;
  
  ly_log_dbg(0x20,"%s","lyd_insert");
  if (((node == (lyd_node *)0x0) || (parent == (lyd_node *)0x0)) ||
     ((parent->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) != LYS_UNKNOWN)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_insert");
    iVar1 = 1;
  }
  else {
    iVar1 = lyd_insert_common(parent,(lyd_node **)0x0,node,1);
  }
  return iVar1;
}



int lyd_insert_sibling(lyd_node **sibling,lyd_node *node)

{
  int iVar1;
  lyd_node *parent;
  lyd_node *node_local;
  lyd_node **sibling_local;
  
  ly_log_dbg(0x20,"%s","lyd_insert_sibling");
  if ((sibling == (lyd_node **)0x0) || (node == (lyd_node *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_insert_sibling");
    iVar1 = 1;
  }
  else {
    if (*sibling == (lyd_node *)0x0) {
      parent = (lyd_node *)0x0;
    }
    else {
      parent = (*sibling)->parent;
    }
    iVar1 = lyd_insert_common(parent,sibling,node,1);
  }
  return iVar1;
}



int lyd_insert_nextto(lyd_node *sibling,lyd_node *node,int before,int invalidate)

{
  lys_node *plVar1;
  long lVar2;
  lyd_node *plVar3;
  int iVar4;
  char *pcVar5;
  char *pcVar6;
  long in_FS_OFFSET;
  int invalidate_local;
  int before_local;
  lyd_node *node_local;
  lyd_node *sibling_local;
  int invalid;
  lyd_node *start;
  lys_node *par1;
  lys_node *par2;
  lyd_node *iter;
  lyd_node *ins;
  lyd_node *next1;
  lyd_node *next2;
  lyd_node *last;
  lyd_node *orig_parent;
  lyd_node *orig_prev;
  lyd_node *orig_next;
  ly_ctx *ctx;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  start = (lyd_node *)0x0;
  orig_parent = (lyd_node *)0x0;
  orig_prev = (lyd_node *)0x0;
  orig_next = (lyd_node *)0x0;
  invalid = 0;
  if (sibling == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("sibling",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x1210,"lyd_insert_nextto");
  }
  if (node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x1211,"lyd_insert_nextto");
  }
  ctx = sibling->schema->module->ctx;
  if (sibling == node) {
    iVar4 = 0;
  }
  else {
    for (par1 = lys_parent(sibling->schema);
        (par1 != (lys_node *)0x0 && ((par1->nodetype & 0x4691) == LYS_UNKNOWN));
        par1 = lys_parent(par1)) {
    }
    for (par2 = lys_parent(node->schema);
        (par2 != (lys_node *)0x0 && ((par2->nodetype & 0x4691) == LYS_UNKNOWN));
        par2 = lys_parent(par2)) {
    }
    if (par1 == par2) {
      if ((invalidate != 0) &&
         (((node->parent != sibling->parent ||
           (invalid = lyp_is_rpc_action(node->schema), invalid != 0)) ||
          (node->parent == (lyd_node *)0x0)))) {
        if ((node->parent == (lyd_node *)0x0) && (invalid == 0)) {
          for (iter = node->prev; (iter != node && (iter != sibling)); iter = iter->prev) {
          }
          if (iter == node) {
            invalid = 1;
          }
        }
        else {
          invalid = invalid + 1;
        }
      }
      if (((invalid == 0) || (node->parent != (lyd_node *)0x0)) ||
         (node->prev->next != (lyd_node *)0x0)) {
        orig_parent = node->parent;
        if (node != node->prev) {
          orig_prev = node->prev;
        }
        orig_next = node->next;
        lyd_unlink_internal(node,invalid);
      }
      start = sibling;
      if (sibling->parent == (lyd_node *)0x0) {
        while (start->prev->next != (lyd_node *)0x0) {
          start = start->prev;
        }
      }
      else {
        start = sibling->parent->child;
      }
      plVar3 = node;
      if (invalid == 0) {
        node->parent = sibling->parent;
        last = node;
      }
      else {
        while (ins = plVar3, ins != (lyd_node *)0x0) {
          next1 = ins->next;
          lyd_insert_setinvalid(ins);
          if ((invalid == 1) &&
             (iVar4 = lyv_multicases(ins,(lys_node *)0x0,&start,1,sibling), iVar4 == 2)) {
            pcVar6 = ly_errpath(ctx);
            ly_vlog(ctx,LYE_SPEC,LY_VLOG_LYD,sibling,
                    "Insert request refers node (%s) that is going to be auto-deleted.",pcVar6);
LAB_001bb053:
            if (orig_prev == (lyd_node *)0x0) {
              if (orig_next == (lyd_node *)0x0) {
                if (orig_parent != (lyd_node *)0x0) {
                  orig_parent->child = node;
                  node->parent = orig_parent;
                }
              }
              else {
                lyd_insert_before(orig_next,node);
              }
            }
            else {
              lyd_insert_after(orig_prev,node);
            }
            iVar4 = 1;
            goto LAB_001bb0bb;
          }
          if (ins->schema->nodetype == LYS_LEAFLIST) {
            iter = start;
            while (iter != (lyd_node *)0x0) {
              next2 = iter->next;
              if ((iter->schema == ins->schema) &&
                 ((((ins->field_0x9 & 1) != 0 &&
                   (((iter->field_0x9 & 1) == 0 ||
                    (((iter->schema->flags & 1) != 0 &&
                     (iVar4 = strcmp((char *)iter->ht,(char *)ins->ht), iVar4 == 0)))))) ||
                  (((ins->field_0x9 & 1) == 0 && ((iter->field_0x9 & 1) != 0)))))) {
                if (iter == sibling) {
                  str = lyd_path(sibling);
                  ly_log(ctx,LY_LLERR,LY_EINVAL,
                         "Insert request refers node (%s) that is going to be auto-deleted.",str);
                  free(str);
                  goto LAB_001bb053;
                }
                if (iter == start) {
                  start = next2;
                }
                lyd_free(iter);
              }
              iter = next2;
            }
          }
          else if ((ins->schema->nodetype == LYS_LEAF) ||
                  ((ins->schema->nodetype == LYS_CONTAINER &&
                   (plVar1 = ins->schema, lVar2._0_2_ = plVar1[1].flags,
                   lVar2._2_1_ = plVar1[1].ext_size, lVar2._3_1_ = plVar1[1].iffeature_size,
                   lVar2._4_1_ = plVar1[1].padding[0], lVar2._5_1_ = plVar1[1].padding[1],
                   lVar2._6_1_ = plVar1[1].padding[2], lVar2._7_1_ = plVar1[1].padding[3],
                   lVar2 == 0)))) {
            for (iter = start; iter != (lyd_node *)0x0; iter = iter->next) {
              if (iter->schema == ins->schema) {
                if (((iter->field_0x9 & 1) != 0) || ((ins->field_0x9 & 1) != 0)) {
                  if (iter == sibling) {
                    str = lyd_path(sibling);
                    ly_log(ctx,LY_LLERR,LY_EINVAL,
                           "Insert request refers node (%s) that is going to be auto-deleted.",str);
                    free(str);
                    goto LAB_001bb053;
                  }
                  if (iter == start) {
                    start = iter->next;
                  }
                  lyd_free(iter);
                }
                break;
              }
            }
          }
          ins->parent = sibling->parent;
          last = ins;
          ins = next1;
          plVar3 = ins;
        }
      }
      if (before == 0) {
        if (sibling->next == (lyd_node *)0x0) {
          start->prev = last;
        }
        else {
          last->next = sibling->next;
          sibling->next->prev = last;
        }
        sibling->next = node;
        node->prev = sibling;
      }
      else {
        if (sibling->prev->next == (lyd_node *)0x0) {
          if (sibling->parent != (lyd_node *)0x0) {
            sibling->parent->child = node;
          }
        }
        else {
          sibling->prev->next = node;
        }
        node->prev = sibling->prev;
        sibling->prev = last;
        last->next = sibling;
      }
      lyd_insert_hash(node);
      for (iter = node; iter != last; iter = iter->next) {
        lyd_unlink_hash(iter,iter->parent);
        lyd_insert_hash(iter);
      }
      plVar3 = node;
      if (invalidate != 0) {
        while ((next1 = plVar3, next1 != (lyd_node *)0x0 &&
               (check_leaf_list_backlinks(next1), next1 != last))) {
          plVar3 = next1->next;
        }
      }
      iVar4 = 0;
    }
    else {
      if (par2 == (lys_node *)0x0) {
        pcVar6 = "<top-lvl>";
      }
      else {
        pcVar6 = par2->name;
      }
      if (par1 == (lys_node *)0x0) {
        pcVar5 = "<top-lvl>";
      }
      else {
        pcVar5 = par1->name;
      }
      ly_log(ctx,LY_LLERR,LY_EINVAL,"Cannot insert, different parents (\"%s\" and \"%s\").",pcVar5,
             pcVar6);
      iVar4 = 1;
    }
  }
LAB_001bb0bb:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar4;
}



int lyd_insert_before(lyd_node *sibling,lyd_node *node)

{
  int iVar1;
  lyd_node *node_local;
  lyd_node *sibling_local;
  
  ly_log_dbg(0x20,"%s","lyd_insert_before");
  if ((node == (lyd_node *)0x0) || (sibling == (lyd_node *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_insert_before");
    iVar1 = 1;
  }
  else {
    iVar1 = lyd_insert_nextto(sibling,node,1,1);
  }
  return iVar1;
}



int lyd_insert_after(lyd_node *sibling,lyd_node *node)

{
  int iVar1;
  lyd_node *node_local;
  lyd_node *sibling_local;
  
  ly_log_dbg(0x20,"%s","lyd_insert_after");
  if ((node == (lyd_node *)0x0) || (sibling == (lyd_node *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_insert_after");
    iVar1 = 1;
  }
  else {
    iVar1 = lyd_insert_nextto(sibling,node,0,1);
  }
  return iVar1;
}



uint32_t lys_module_pos(lys_module *module)

{
  lys_module *module_local;
  int i;
  uint32_t pos;
  
  pos = 1;
  i = 0;
  while( true ) {
    if ((module->ctx->models).used <= i) {
      ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
             ,0x12f8);
      return 0;
    }
    if (module == (module->ctx->models).list[i]) break;
    pos = pos + 1;
    i = i + 1;
  }
  return pos;
}



int lys_module_node_pos_r(lys_node *first_sibling,lys_node *target,uint32_t *pos)

{
  lys_module *module;
  lys_node *parent;
  uint32_t *pos_local;
  lys_node *target_local;
  lys_node *first_sibling_local;
  lys_node *next;
  
  next = (lys_node *)0x0;
  do {
    module = lys_node_module(first_sibling);
    parent = lys_parent(first_sibling);
    next = lys_getnext(next,parent,module,0x100);
    if (next == (lys_node *)0x0) {
      ly_log(first_sibling->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
             ,0x1309);
      return 1;
    }
    *pos = *pos + 1;
  } while (target != next);
  return 0;
}



int lyd_node_pos_cmp(void *item1,void *item2)

{
  uint32_t uVar1;
  uint32_t uVar2;
  int iVar3;
  lys_module *plVar4;
  lys_module *plVar5;
  void *item2_local;
  void *item1_local;
  uint32_t mpos1;
  uint32_t mpos2;
  lyd_node_pos *np1;
  lyd_node_pos *np2;
  
                    // WARNING: Load size is inaccurate
  plVar4 = lys_node_module((lys_node *)**item1);
                    // WARNING: Load size is inaccurate
  plVar5 = lys_node_module((lys_node *)**item2);
  if (plVar4 == plVar5) {
    if (*(uint *)((long)item2 + 8) < *(uint *)((long)item1 + 8)) {
      iVar3 = 1;
    }
    else if (*(uint *)((long)item1 + 8) < *(uint *)((long)item2 + 8)) {
      iVar3 = -1;
    }
    else {
      iVar3 = 0;
    }
  }
  else {
                    // WARNING: Load size is inaccurate
    plVar4 = lys_node_module((lys_node *)**item1);
    uVar1 = lys_module_pos(plVar4);
                    // WARNING: Load size is inaccurate
    plVar4 = lys_node_module((lys_node *)**item2);
    uVar2 = lys_module_pos(plVar4);
    if (uVar2 < uVar1) {
      iVar3 = 1;
    }
    else {
      iVar3 = -1;
    }
  }
  return iVar3;
}



int lyd_schema_sort(lyd_node *sibling,int recursive)

{
  int iVar1;
  long *__ptr;
  lys_module *plVar2;
  lys_module *plVar3;
  lys_node *plVar4;
  int recursive_local;
  lyd_node *sibling_local;
  uint32_t len;
  uint32_t i;
  lyd_node *node;
  lys_node *first_ssibling;
  lyd_node_pos *array;
  
  ly_log_dbg(0x20,"%s","lyd_schema_sort");
  first_ssibling = (lys_node *)0x0;
  if (sibling == (lyd_node *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_schema_sort");
    iVar1 = -1;
  }
  else {
    sibling_local = sibling;
    if (sibling != sibling->prev) {
      sibling_local = lyd_first_sibling(sibling);
      len = 0;
      for (node = sibling_local; node != (lyd_node *)0x0; node = node->next) {
        len = len + 1;
      }
      __ptr = (long *)malloc((ulong)len << 4);
      if (__ptr == (long *)0x0) {
        ly_log(sibling_local->schema->module->ctx,LY_LLERR,LY_EMEM,
               "Memory allocation failed (%s()).","lyd_schema_sort");
        return -1;
      }
      node = sibling_local;
      for (i = 0; i < len; i = i + 1) {
        *(undefined4 *)(__ptr + (ulong)i * 2 + 1) = 0;
        if (first_ssibling == (lys_node *)0x0) {
LAB_001bb583:
          first_ssibling = node->schema;
          while ((plVar4 = lys_parent(first_ssibling), plVar4 != (lys_node *)0x0 &&
                 (plVar4 = lys_parent(first_ssibling), (plVar4->nodetype & 0x1042) != LYS_UNKNOWN)))
          {
            first_ssibling = lys_parent(first_ssibling);
          }
          plVar4 = lys_parent(first_ssibling);
          if (plVar4 == (lys_node *)0x0) {
            while (first_ssibling->prev->next != (lys_node *)0x0) {
              first_ssibling = first_ssibling->prev;
            }
          }
          else {
            plVar4 = lys_parent(first_ssibling);
            first_ssibling = plVar4->child;
          }
        }
        else {
          plVar2 = lyd_node_module(node);
          plVar3 = lys_node_module(first_ssibling);
          if (plVar2 != plVar3) goto LAB_001bb583;
        }
        iVar1 = lys_module_node_pos_r
                          (first_ssibling,node->schema,(uint32_t *)(__ptr + (ulong)i * 2 + 1));
        if (iVar1 != 0) {
          free(__ptr);
          return -1;
        }
        __ptr[(ulong)i * 2] = (long)node;
        node = node->next;
      }
      qsort(__ptr,(ulong)len,0x10,lyd_node_pos_cmp);
      for (i = 0; i < len; i = i + 1) {
        if ((i == 0) && (sibling_local = (lyd_node *)*__ptr, *(long *)(*__ptr + 0x28) != 0)) {
          *(long *)(*(long *)(*__ptr + 0x28) + 0x40) = *__ptr;
        }
        if (i == 0) {
          *(long *)(*__ptr + 0x20) = __ptr[(ulong)(len - 1) * 2];
        }
        else {
          *(long *)(__ptr[(ulong)i * 2] + 0x20) = __ptr[(ulong)(i - 1) * 2];
        }
        if (i < len - 1) {
          *(long *)(__ptr[(ulong)i * 2] + 0x18) = __ptr[(ulong)(i + 1) * 2];
        }
        else {
          *(undefined8 *)(__ptr[(ulong)i * 2] + 0x18) = 0;
        }
      }
      free(__ptr);
    }
    if (recursive != 0) {
      for (node = sibling_local; node != (lyd_node *)0x0; node = node->next) {
        if ((((node->schema->nodetype & 0x4191) != LYS_UNKNOWN) && (node->child != (lyd_node *)0x0))
           && (iVar1 = lyd_schema_sort(node->child,recursive), iVar1 != 0)) {
          return -1;
        }
      }
    }
    iVar1 = 0;
  }
  return iVar1;
}



int _lyd_validate(lyd_node **node,lyd_node *data_tree,ly_ctx *ctx,lys_module **modules,int mod_count
                 ,lyd_difflist **diff,int options)

{
  lys_node *plVar1;
  long lVar2;
  lyd_node **pplVar3;
  int iVar4;
  unres_data *unres_00;
  lyd_difflist *plVar5;
  char *pcVar6;
  ly_ctx *ctx_00;
  lys_module *plVar7;
  lyd_node *plVar8;
  lyd_difflist **diff_local;
  int mod_count_local;
  lys_module **modules_local;
  ly_ctx *ctx_local;
  lyd_node *data_tree_local;
  lyd_node **node_local;
  int ret;
  uint i;
  lyd_node *root;
  lyd_node *next1;
  lyd_node *next2;
  lyd_node *iter;
  lyd_node *act_notif;
  unres_data *unres;
  lys_module *yanglib_mod;
  
  act_notif = (lyd_node *)0x0;
  ret = 1;
  unres_00 = (unres_data *)calloc(1,0x28);
  if (unres_00 == (unres_data *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","_lyd_validate");
    return 1;
  }
  if (diff != (lyd_difflist **)0x0) {
    unres_00->store_diff = 1;
    plVar5 = lyd_diff_init_difflist(ctx,&unres_00->diff_size);
    unres_00->diff = plVar5;
  }
  if ((((options & 0x30U) != 0) && (*node != (lyd_node *)0x0)) &&
     ((*node)->schema->nodetype != LYS_RPC)) {
    options = options | 0x100;
  }
  if ((((options & 0xc0U) != 0) && (*node != (lyd_node *)0x0)) &&
     ((*node)->schema->nodetype != LYS_NOTIF)) {
    options = options | 0x100;
  }
  plVar8 = *node;
LAB_001bbc03:
  do {
    root = plVar8;
    if (root == (lyd_node *)0x0) break;
    plVar8 = root->next;
    if (modules != (lys_module **)0x0) {
      for (i = 0; (i < (uint)mod_count && (plVar7 = lyd_node_module(root), plVar7 != modules[i]));
          i = i + 1) {
      }
      if (i == mod_count) goto LAB_001bbc03;
    }
    iter = root;
    while (iter != (lyd_node *)0x0) {
      if ((iter->parent != (lyd_node *)0x0) && ((iter->schema->nodetype & 0x4080) != LYS_UNKNOWN)) {
        if (((options & 0x100U) == 0) || (act_notif != (lyd_node *)0x0)) {
          ly_vlog(ctx,LYE_INELEM,LY_VLOG_LYD,iter,iter->schema->name);
          if ((options & 0x10U) == 0) {
            pcVar6 = "notification";
          }
          else {
            pcVar6 = "action";
          }
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,"Unexpected %s node \"%s\".",pcVar6,
                  iter->schema->name);
          goto LAB_001bc02d;
        }
        act_notif = iter;
      }
      iVar4 = lyv_data_context(iter,options,unres_00);
      if ((iVar4 != 0) || (iVar4 = lyv_data_content(iter,options,unres_00), iVar4 != 0))
      goto LAB_001bc02d;
      if ((((iter->field_0x9 & 1) == 0) &&
          (((iter->schema->nodetype == LYS_CONTAINER && (iter->child == (lyd_node *)0x0)) &&
           (plVar1 = iter->schema, lVar2._0_2_ = plVar1[1].flags, lVar2._2_1_ = plVar1[1].ext_size,
           lVar2._3_1_ = plVar1[1].iffeature_size, lVar2._4_1_ = plVar1[1].padding[0],
           lVar2._5_1_ = plVar1[1].padding[1], lVar2._6_1_ = plVar1[1].padding[2],
           lVar2._7_1_ = plVar1[1].padding[3], lVar2 == 0)))) && (iter->attr == (lyd_attr *)0x0)) {
        iter->field_0x9 = iter->field_0x9 | 1;
      }
      if ((iter->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
        next2 = iter->child;
      }
      else {
        next2 = (lyd_node *)0x0;
      }
      if (next2 == (lyd_node *)0x0) {
        if (iter == root) break;
        next2 = iter->next;
      }
      while ((next2 == (lyd_node *)0x0 && (iter = iter->parent, iter->parent != root->parent))) {
        next2 = iter->next;
      }
      iter = next2;
    }
  } while ((options & 0x1000U) == 0);
  if ((options & 0x100U) != 0) {
    if (act_notif == (lyd_node *)0x0) {
      if ((options & 0x10U) == 0) {
        pcVar6 = "notification";
      }
      else {
        pcVar6 = "action";
      }
      ly_vlog(ctx,LYE_MISSELEM,LY_VLOG_LYD,*node,pcVar6,(*node)->schema->name);
      goto LAB_001bc02d;
    }
    options = options & 0xfffffeff;
  }
  if (*node != (lyd_node *)0x0) {
    ctx_00 = ctx;
    if (ctx == (ly_ctx *)0x0) {
      ctx_00 = (*node)->schema->module->ctx;
    }
    plVar7 = ly_ctx_get_module(ctx_00,"ietf-yang-library",(char *)0x0,1);
    for (root = *node; root != (lyd_node *)0x0; root = root->next) {
      if ((((options & 0x20000U) != 0) && (plVar7 != (lys_module *)0x0)) &&
         (plVar7 == root->schema->module)) {
        options = options & 0xfffdffff;
      }
      if (((root->schema->nodetype & (LYS_LEAFLIST|LYS_LIST)) != LYS_UNKNOWN) &&
         ((root->validity & 1) != 0)) {
        if ((options & 0x2000U) == 0) {
          iVar4 = lyv_data_dup(root,*node);
          if (iVar4 != 0) goto LAB_001bc02d;
        }
        else {
          root->validity = root->validity & 0xfe;
        }
      }
    }
  }
  if ((options & 0x20000U) != 0) {
    if (*node == (lyd_node *)0x0) {
      plVar8 = ly_ctx_info(ctx);
      *node = plVar8;
    }
    else {
      plVar8 = ly_ctx_info(ctx);
      iVar4 = lyd_merge(*node,plVar8,0x500);
      if (iVar4 != 0) {
        ly_log(ctx,LY_LLERR,LY_EINT,"Adding ietf-yang-library data failed.");
        goto LAB_001bc02d;
      }
    }
  }
  iVar4 = lyd_defaults_add_unres(node,options,ctx,modules,mod_count,data_tree,act_notif,unres_00,1);
  if (iVar4 == 0) {
    if (act_notif == (lyd_node *)0x0) {
      iVar4 = lyd_check_mandatory_tree(*node,ctx,modules,mod_count,options);
    }
    else {
      iVar4 = lyd_check_mandatory_tree(act_notif,ctx,modules,mod_count,options);
    }
    if ((iVar4 == 0) &&
       ((((options & 0x30U) == 0 || (*node == (lyd_node *)0x0)) ||
        (iVar4 = lyd_schema_sort(*node,1), iVar4 == 0)))) {
      if (diff != (lyd_difflist **)0x0) {
        if (unres_00->store_diff == 0) {
                    // WARNING: Subroutine does not return
          __assert_fail("unres->store_diff",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                        ,0x141a,"_lyd_validate");
        }
        for (i = 0; i < unres_00->diff_idx; i = i + 1) {
          if (unres_00->diff->type[i] == LYD_DIFF_CREATED) {
            if (unres_00->diff->second[i]->parent != (lyd_node *)0x0) {
              pplVar3 = unres_00->diff->first;
              plVar8 = (lyd_node *)lyd_path(unres_00->diff->second[i]->parent);
              pplVar3[i] = plVar8;
            }
            pplVar3 = unres_00->diff->second;
            plVar8 = lyd_dup(unres_00->diff->second[i],1);
            pplVar3[i] = plVar8;
          }
        }
        *diff = unres_00->diff;
        unres_00->diff = (lyd_difflist *)0x0;
        unres_00->diff_idx = 0;
      }
      ret = 0;
    }
  }
LAB_001bc02d:
  if (unres_00 != (unres_data *)0x0) {
    free(unres_00->node);
    free(unres_00->type);
    for (i = 0; i < unres_00->diff_idx; i = i + 1) {
      if (unres_00->diff->type[i] == LYD_DIFF_DELETED) {
        lyd_free_withsiblings(unres_00->diff->first[i]);
        free(unres_00->diff->second[i]);
      }
    }
    lyd_free_diff(unres_00->diff);
    free(unres_00);
  }
  return ret;
}



int lyd_validate(lyd_node **node,int options,void *var_arg,...)

{
  long lVar1;
  char in_AL;
  int iVar2;
  long *plVar3;
  long in_RCX;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  void *var_arg_local;
  int options_local;
  lyd_node **node_local;
  lyd_node *iter;
  lyd_node *data_tree;
  lyd_difflist **diff;
  ly_ctx *ctx;
  va_list ap;
  long local_a0;
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  local_a0 = in_RCX;
  local_98 = in_R8;
  local_90 = in_R9;
  ly_log_dbg(0x20,"%s","lyd_validate");
  diff = (lyd_difflist **)0x0;
  ctx = (ly_ctx *)0x0;
  if (node == (lyd_node **)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_validate");
    iVar2 = 1;
  }
  else {
    iVar2 = lyp_data_check_options((ly_ctx *)0x0,options,"lyd_validate");
    if (iVar2 == 0) {
      data_tree = *node;
      if ((((options & 0x10000ffU) == 0) || ((options & 0xfU) != 0)) && (*node == (lyd_node *)0x0))
      {
        if (var_arg == (void *)0x0) {
          ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,
                 "%s: invalid variable parameter (struct ly_ctx *ctx).","lyd_validate");
          iVar2 = 1;
          goto LAB_001bc611;
        }
        options_local = options & 0xffffefff;
        ctx = (ly_ctx *)var_arg;
      }
      else {
        options_local = options;
        if ((options & 0x70U) == 0) {
          if ((((options & 0x1000000U) != 0) && (*node != (lyd_node *)0x0)) &&
             (((*node)->prev->next != (lyd_node *)0x0 || ((*node)->next != (lyd_node *)0x0)))) {
            ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,
                   "%s: invalid variable parameter (struct lyd_node *node).","lyd_validate");
            iVar2 = 1;
            goto LAB_001bc611;
          }
        }
        else {
          if ((options & 0x1000U) != 0) {
            ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,
                   "%s: invalid parameter (variable arg const struct lyd_node *data_tree with LYD_OPT_NOSIBLINGS)."
                   ,"lyd_validate");
            iVar2 = 1;
            goto LAB_001bc611;
          }
          if (*node == (lyd_node *)0x0) {
            ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_validate");
            iVar2 = 1;
            goto LAB_001bc611;
          }
          data_tree = (lyd_node *)var_arg;
          if (var_arg != (void *)0x0) {
            iter = (lyd_node *)var_arg;
            if ((options & 0x8000U) != 0) {
              ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,
                     "%s: invalid parameter (variable arg const struct lyd_node *data_tree and LYD_OPT_NOEXTDEPS set)."
                     ,"lyd_validate");
              iVar2 = 1;
              goto LAB_001bc611;
            }
            for (; iter != (lyd_node *)0x0; iter = iter->next) {
              if (iter->parent != (lyd_node *)0x0) {
                ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,
                       "%s: invalid variable parameter (const struct lyd_node *data_tree).",
                       "lyd_validate");
                iVar2 = 1;
                goto LAB_001bc611;
              }
            }
            while (data_tree->prev->next != (lyd_node *)0x0) {
              data_tree = data_tree->prev;
            }
          }
        }
      }
      if ((options_local & 0x40000U) != 0) {
        plVar3 = (long *)&stack0x00000008;
        if (true) {
          plVar3 = &local_a0;
        }
        diff = (lyd_difflist **)*plVar3;
        if (diff == (lyd_difflist **)0x0) {
          ly_log(ctx,LY_LLERR,LY_EINVAL,"%s: invalid variable parameter (struct lyd_difflist **).",
                 "lyd_validate");
          iVar2 = 1;
          goto LAB_001bc611;
        }
      }
      if (*node != (lyd_node *)0x0) {
        if (ctx == (ly_ctx *)0x0) {
          ctx = (*node)->schema->module->ctx;
        }
        if ((options_local & 0x1000U) == 0) {
          while ((*node)->prev->next != (lyd_node *)0x0) {
            *node = (*node)->prev;
          }
        }
      }
      iVar2 = _lyd_validate(node,data_tree,ctx,(lys_module **)0x0,0,diff,options_local);
    }
    else {
      iVar2 = 1;
    }
  }
LAB_001bc611:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyd_validate_modules(lyd_node **node,lys_module **modules,int mod_count,int options,...)

{
  long lVar1;
  ly_ctx *ctx_00;
  char in_AL;
  int iVar2;
  long *plVar3;
  long in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  int options_local;
  int mod_count_local;
  lys_module **modules_local;
  lyd_node **node_local;
  lyd_difflist **diff;
  ly_ctx *ctx;
  va_list ap;
  long local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  local_98 = in_R8;
  local_90 = in_R9;
  ly_log_dbg(0x20,"%s","lyd_validate_modules");
  diff = (lyd_difflist **)0x0;
  if (((node == (lyd_node **)0x0) || (modules == (lys_module **)0x0)) || (mod_count == 0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_validate_modules");
    iVar2 = 1;
  }
  else {
    ctx_00 = (*modules)->ctx;
    if ((*node != (lyd_node *)0x0) && ((options & 0x1000U) == 0)) {
      while ((*node)->prev->next != (lyd_node *)0x0) {
        *node = (*node)->prev;
      }
    }
    iVar2 = lyp_data_check_options(ctx_00,options,"lyd_validate_modules");
    if (iVar2 == 0) {
      if (((options & 0x10000ffU) == 0) || ((options & 0xfU) != 0)) {
        if ((options & 0x40000U) != 0) {
          plVar3 = (long *)&stack0x00000008;
          if (true) {
            plVar3 = &local_98;
          }
          diff = (lyd_difflist **)*plVar3;
          if (diff == (lyd_difflist **)0x0) {
            ly_log(ctx_00,LY_LLERR,LY_EINVAL,
                   "%s: invalid variable parameter (struct lyd_difflist **).","lyd_validate_modules"
                  );
            iVar2 = 1;
            goto LAB_001bc8f4;
          }
        }
        iVar2 = _lyd_validate(node,*node,ctx_00,modules,mod_count,diff,options);
      }
      else {
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"%s: options include a forbidden data type.",
               "lyd_validate_modules");
        iVar2 = 1;
      }
    }
    else {
      iVar2 = 1;
    }
  }
LAB_001bc8f4:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyd_validate_value(lys_node *node,char *value)

{
  long lVar1;
  lys_type *plVar2;
  long in_FS_OFFSET;
  char *value_local;
  lys_node *node_local;
  int ret;
  lys_node_leaf *sleaf;
  lyd_node_leaf_list leaf;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_validate_value");
  ret = 0;
  if ((node == (lys_node *)0x0) || ((node->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_validate_value");
    ret = 1;
  }
  else {
    value_local = value;
    if (value == (char *)0x0) {
      value_local = "";
    }
    memset(&leaf,0,0x50);
    leaf.value_str = lydict_insert(node->module->ctx,value_local,0);
    sleaf = (lys_node_leaf *)node;
    while( true ) {
      leaf.value_type = (sleaf->type).base;
      leaf.schema = node;
      if (leaf.value_type != LY_TYPE_LEAFREF) break;
      if ((sleaf->type).info.lref.target == (lys_node_leaf *)0x0) {
        ly_log(node->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
               ,0x14e7);
        ret = 1;
        goto LAB_001bcab7;
      }
      sleaf = (sleaf->type).info.lref.target;
    }
    plVar2 = lyp_parse_value(&sleaf->type,&leaf.value_str,(lyxml_elem *)0x0,&leaf,(lyd_attr *)0x0,
                             (lys_module *)0x0,0,0,0);
    if (plVar2 == (lys_type *)0x0) {
      ret = 1;
    }
LAB_001bcab7:
    lydict_remove(node->module->ctx,leaf.value_str);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return ret;
}



// WARNING: Variable defined which should be unmapped: ret

lyd_attr * lyd_dup_attr(ly_ctx *ctx,lyd_node *parent,lyd_attr *attr)

{
  lyd_attr *plVar1;
  char *pcVar2;
  undefined8 *puVar3;
  lyd_attr *attr_local;
  lyd_node *parent_local;
  ly_ctx *ctx_local;
  lyd_attr *ret;
  
  if (parent->attr == (lyd_attr *)0x0) {
    plVar1 = (lyd_attr *)malloc(0x38);
    parent->attr = plVar1;
    ret = parent->attr;
  }
  else {
    for (ret = parent->attr; ret->next != (lyd_attr *)0x0; ret = ret->next) {
    }
    plVar1 = (lyd_attr *)calloc(1,0x38);
    ret->next = plVar1;
    ret = ret->next;
  }
  if (ret == (lyd_attr *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_dup_attr");
    return (lyd_attr *)0x0;
  }
  ret->parent = parent;
  ret->next = (lyd_attr *)0x0;
  ret->annotation = attr->annotation;
  pcVar2 = lydict_insert(ctx,attr->name,0);
  ret->name = pcVar2;
  pcVar2 = lydict_insert(ctx,attr->value_str,0);
  ret->value_str = pcVar2;
  ret->value_type = attr->value_type;
  ret->value_flags = attr->value_flags;
  if (false) {
switchD_001bcc76_caseD_0:
    ret->value = attr->value;
  }
  else {
    switch(ret->value_type) {
    default:
      goto switchD_001bcc76_caseD_0;
    case LY_TYPE_BINARY:
    case LY_TYPE_STRING:
      ret->value = (lyd_val)ret->value_str;
      break;
    case LY_TYPE_BITS:
    case LY_TYPE_ENUM:
    case LY_TYPE_IDENT:
      puVar3 = (undefined8 *)
               lys_ext_complex_get_substmt(LY_STMT_TYPE,ret->annotation,(lyext_substmt **)0x0);
      lyp_parse_value((lys_type *)*puVar3,&ret->value_str,(lyxml_elem *)0x0,
                      (lyd_node_leaf_list *)0x0,ret,(lys_module *)0x0,1,0,0);
      break;
    case LY_TYPE_INST:
      (ret->value).binary = (char *)0x0;
      break;
    case LY_TYPE_LEAFREF:
      puVar3 = (undefined8 *)
               lys_ext_complex_get_substmt(LY_STMT_TYPE,ret->annotation,(lyext_substmt **)0x0);
      lyp_parse_value((lys_type *)*puVar3,&ret->value_str,(lyxml_elem *)0x0,
                      (lyd_node_leaf_list *)0x0,ret,(lys_module *)0x0,1,0,0);
      break;
    case LY_TYPE_UNION:
      pcVar2 = lydict_insert(ctx,(attr->value).binary,0);
      (ret->value).binary = pcVar2;
    }
  }
  return ret;
}



int lyd_unlink_internal(lyd_node *node,int permanent)

{
  int iVar1;
  int permanent_local;
  lyd_node *node_local;
  lyd_node *iter;
  
  if (node == (lyd_node *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_unlink_internal");
    iVar1 = 1;
  }
  else {
    if (permanent != 0) {
      check_leaf_list_backlinks(node);
    }
    if (node->prev->next != (lyd_node *)0x0) {
      node->prev->next = node->next;
    }
    if (node->next == (lyd_node *)0x0) {
      if (node->parent == (lyd_node *)0x0) {
        for (iter = node->prev; node != iter->prev; iter = iter->prev) {
        }
      }
      else {
        iter = node->parent->child;
      }
      iter->prev = node->prev;
    }
    else {
      node->next->prev = node->prev;
    }
    if (node->parent != (lyd_node *)0x0) {
      if (node == node->parent->child) {
        node->parent->child = node->next;
      }
      if (permanent != 2) {
        lyd_unlink_hash(node,node->parent);
      }
      node->parent = (lyd_node *)0x0;
    }
    node->next = (lyd_node *)0x0;
    node->prev = node;
    iVar1 = 0;
  }
  return iVar1;
}



int lyd_unlink(lyd_node *node)

{
  int iVar1;
  lyd_node *node_local;
  
  ly_log_dbg(0x20,"%s","lyd_unlink");
  iVar1 = lyd_unlink_internal(node,1);
  return iVar1;
}



int _lyd_dup_node_common(lyd_node *new_node,lyd_node *orig,ly_ctx *ctx,int options)

{
  int iVar1;
  int options_local;
  ly_ctx *ctx_local;
  lyd_node *orig_local;
  lyd_node *new_node_local;
  lyd_attr *attr;
  
  new_node->attr = (lyd_attr *)0x0;
  if ((options & 2U) == 0) {
    for (attr = orig->attr; attr != (lyd_attr *)0x0; attr = attr->next) {
      lyd_dup_attr(ctx,new_node,attr);
    }
  }
  new_node->next = (lyd_node *)0x0;
  new_node->prev = new_node;
  new_node->parent = (lyd_node *)0x0;
  iVar1 = ly_new_node_validity(new_node->schema);
  new_node->validity = (uint8_t)iVar1;
  new_node->field_0x9 = new_node->field_0x9 & 0xfe | orig->field_0x9 & 1;
  if ((options & 0x10U) == 0) {
    new_node->field_0x9 = new_node->field_0x9 & 0xf1 | ((byte)orig->field_0x9 >> 1 & 4) * '\x02';
  }
  else {
    new_node->field_0x9 = new_node->field_0x9 & 0xf1 | ((byte)orig->field_0x9 >> 1 & 7) * '\x02';
  }
  if ((new_node->schema->nodetype == LYS_LIST) && (iVar1 = lyd_list_has_keys(new_node), iVar1 == 0))
  {
    return 0;
  }
  new_node->hash = orig->hash;
  return 0;
}



lyd_node * _lyd_dup_node(lyd_node *node,lys_node *schema,ly_ctx *ctx,int options)

{
  LYS_NODE LVar1;
  int iVar2;
  char *pcVar3;
  lys_type *plVar4;
  lyd_node *plVar5;
  lyxml_elem *plVar6;
  hash_table *phVar7;
  int options_local;
  ly_ctx *ctx_local;
  lys_node *schema_local;
  lyd_node *node_local;
  int r;
  lyd_node *new_node;
  lyd_node_anydata *old_any;
  lyd_node_anydata *new_any;
  lyd_node_leaf_list *new_leaf;
  lys_node_leaf *sleaf;
  lys_type *type;
  
  new_node = (lyd_node *)0x0;
  LVar1 = node->schema->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_001bd13f_caseD_20:
    new_node = (lyd_node *)calloc(1,0x40);
    if (new_node == (lyd_node *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","_lyd_dup_node");
    }
    else {
      new_node->schema = schema;
      iVar2 = _lyd_dup_node_common(new_node,node,ctx,options);
      if (iVar2 == 0) {
        *(undefined4 *)&new_node->field_0x34 = *(undefined4 *)&node->field_0x34;
        if (node->ht == (hash_table *)0x0) {
          return new_node;
        }
        if (true) {
          switch(*(undefined4 *)&node->field_0x34) {
          case 0:
          case 2:
          case 4:
            phVar7 = (hash_table *)lydict_insert(ctx,(char *)node->ht,0);
            new_node->ht = phVar7;
            return new_node;
          case 1:
          case 3:
          case 5:
          case 0x21:
                    // WARNING: Subroutine does not return
            __assert_fail("0",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                          ,0x1619,"_lyd_dup_node");
          default:
            return new_node;
          case 8:
            plVar6 = lyxml_dup_elem(ctx,(lyxml_elem *)node->ht,(lyxml_elem *)0x0,1,1);
            new_node->ht = (hash_table *)plVar6;
            return new_node;
          case 0x10:
            plVar5 = lyd_dup_withsiblings_to_ctx((lyd_node *)node->ht,1,ctx);
            new_node->ht = (hash_table *)plVar5;
            return new_node;
          case 0x20:
            goto switchD_001bd52d_caseD_20;
          }
        }
        return new_node;
      }
    }
    goto LAB_001bd73f;
  }
  if (LYS_ANYDATA < LVar1) goto switchD_001bd13f_caseD_2;
  if (LVar1 == LYS_ACTION) {
switchD_001bd13f_caseD_1:
    new_node = (lyd_node *)calloc(1,0x48);
    if (new_node == (lyd_node *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","_lyd_dup_node");
    }
    else {
      new_node->schema = schema;
      iVar2 = _lyd_dup_node_common(new_node,node,ctx,options);
      if (iVar2 == 0) {
        return new_node;
      }
    }
    goto LAB_001bd73f;
  }
  if (LYS_ACTION < LVar1) goto switchD_001bd13f_caseD_2;
  if (LVar1 == LYS_RPC) goto switchD_001bd13f_caseD_1;
  if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
    if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
      if ((LVar1 != LYS_UNKNOWN) && (true)) {
        switch(LVar1) {
        case LYS_CONTAINER:
        case LYS_LIST:
          goto switchD_001bd13f_caseD_1;
        case LYS_LEAF:
        case LYS_LEAFLIST:
          new_node = (lyd_node *)calloc(1,0x50);
          if ((lyd_node_leaf_list *)new_node == (lyd_node_leaf_list *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","_lyd_dup_node");
            goto LAB_001bd73f;
          }
          ((lyd_node_leaf_list *)new_node)->schema = schema;
          pcVar3 = lydict_insert(ctx,(char *)node->ht,0);
          ((lyd_node_leaf_list *)new_node)->value_str = pcVar3;
          ((lyd_node_leaf_list *)new_node)->value_type = *(LY_DATA_TYPE *)&node[1].schema;
          ((lyd_node_leaf_list *)new_node)->value_flags = *(uint8_t *)((long)&node[1].schema + 4);
          iVar2 = _lyd_dup_node_common(new_node,node,ctx,options);
          if (iVar2 != 0) goto LAB_001bd73f;
          if (false) {
switchD_001bd248_caseD_0:
            ((lyd_node_leaf_list *)new_node)->value = (lyd_val)node->child;
          }
          else {
            switch(((lyd_node_leaf_list *)new_node)->value_type) {
            default:
              goto switchD_001bd248_caseD_0;
            case LY_TYPE_BINARY:
            case LY_TYPE_STRING:
              ((lyd_node_leaf_list *)new_node)->value =
                   (lyd_val)((lyd_node_leaf_list *)new_node)->value_str;
              break;
            case LY_TYPE_BITS:
            case LY_TYPE_ENUM:
            case LY_TYPE_IDENT:
              plVar4 = lyp_parse_value((lys_type *)&((lyd_node_leaf_list *)new_node)->schema[1].ref,
                                       &((lyd_node_leaf_list *)new_node)->value_str,
                                       (lyxml_elem *)0x0,(lyd_node_leaf_list *)new_node,
                                       (lyd_attr *)0x0,(lys_module *)0x0,1,
                                       (uint)(node->field_0x9 & 1),0);
              if (plVar4 == (lys_type *)0x0) goto LAB_001bd73f;
              break;
            case LY_TYPE_INST:
              (((lyd_node_leaf_list *)new_node)->value).binary = (char *)0x0;
              break;
            case LY_TYPE_LEAFREF:
              ((lyd_node_leaf_list *)new_node)->validity =
                   ((lyd_node_leaf_list *)new_node)->validity | 8;
              lyp_parse_value((lys_type *)&((lyd_node_leaf_list *)new_node)->schema[1].ref,
                              &((lyd_node_leaf_list *)new_node)->value_str,(lyxml_elem *)0x0,
                              (lyd_node_leaf_list *)new_node,(lyd_attr *)0x0,(lys_module *)0x0,1,
                              (uint)(node->field_0x9 & 1),0);
              break;
            case LY_TYPE_UNION:
              pcVar3 = lydict_insert(ctx,(char *)node->child,0);
              (((lyd_node_leaf_list *)new_node)->value).binary = pcVar3;
            }
          }
          if ((((lyd_node_leaf_list *)new_node)->value_flags & 2) == 0) {
            return (lyd_node *)(lyd_node_leaf_list *)new_node;
          }
          plVar4 = lyd_leaf_type((lyd_node_leaf_list *)new_node);
          if (((plVar4 == (lys_type *)0x0) || (plVar4->der == (lys_tpdf *)0x0)) ||
             (plVar4->der->module == (lys_module *)0x0)) {
            ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                   ,0x15df);
          }
          else {
            iVar2 = lytype_store(plVar4->der->module,plVar4->der->name,
                                 &((lyd_node_leaf_list *)new_node)->value_str,
                                 &((lyd_node_leaf_list *)new_node)->value);
            if (iVar2 != -1) {
              if (iVar2 == 0) {
                return (lyd_node *)(lyd_node_leaf_list *)new_node;
              }
              ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                     "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                     ,0x15e7);
            }
          }
          goto LAB_001bd73f;
        case LYS_ANYXML:
          goto switchD_001bd13f_caseD_20;
        }
      }
    }
    else if (LVar1 == LYS_NOTIF) goto switchD_001bd13f_caseD_1;
  }
switchD_001bd13f_caseD_2:
  ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
         ,0x162b);
LAB_001bd73f:
  lyd_free(new_node);
  return (lyd_node *)0x0;
switchD_001bd52d_caseD_20:
  iVar2 = lyd_lyb_data_length((char *)node->ht);
  if (iVar2 == -1) {
    ly_log(ctx,LY_LLERR,LY_EINVAL,"Invalid LYB data.");
  }
  else {
    phVar7 = (hash_table *)malloc((long)iVar2);
    new_node->ht = phVar7;
    if (new_node->ht != (hash_table *)0x0) {
      memcpy(new_node->ht,node->ht,(long)iVar2);
      return new_node;
    }
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","_lyd_dup_node");
  }
  goto LAB_001bd73f;
}



int lyd_dup_keys(lyd_node *new_list,lyd_node *old_list,lys_node *skip_key,ly_ctx *log_ctx,
                int options)

{
  lys_node *plVar1;
  int iVar2;
  lyd_node *node;
  int options_local;
  ly_ctx *log_ctx_local;
  lys_node *skip_key_local;
  lyd_node *old_list_local;
  lyd_node *new_list_local;
  uint16_t i;
  lyd_node *key;
  lys_node_list *slist;
  lyd_node *key_dup;
  
  if (new_list->schema->nodetype == LYS_LIST) {
    plVar1 = new_list->schema;
    key = old_list->child;
    for (i = 0; (key != (lyd_node *)0x0 && (i < plVar1->padding[2])); i = i + 1) {
      if (key->schema != *(lys_node **)(*(long *)&plVar1[1].flags + (ulong)i * 8)) {
        ly_vlog(log_ctx,LYE_PATH_INKEY,LY_VLOG_LYD,new_list,
                **(undefined8 **)(*(long *)&plVar1[1].flags + (ulong)i * 8));
        return -1;
      }
      if (skip_key != key->schema) {
        node = lyd_dup(key,options & 2);
        if (node == (lyd_node *)0x0) {
          ly_log(log_ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_dup_keys");
          return -1;
        }
        iVar2 = lyd_insert(new_list,node);
        if (iVar2 != 0) {
          lyd_free(node);
          return -1;
        }
      }
      key = key->next;
    }
    if ((key == (lyd_node *)0x0) && (i < plVar1->padding[2])) {
      ly_vlog(log_ctx,LYE_PATH_INKEY,LY_VLOG_LYD,new_list,
              **(undefined8 **)(*(long *)&plVar1[1].flags + (ulong)i * 8));
      iVar2 = -1;
    }
    else {
      iVar2 = 0;
    }
  }
  else {
    iVar2 = 0;
  }
  return iVar2;
}



lyd_node * lyd_dup_to_ctx(lyd_node *node,int options,ly_ctx *ctx)

{
  LYS_NODE type;
  char *pcVar1;
  int iVar2;
  lys_module *plVar3;
  size_t sVar4;
  lys_node_list *plVar5;
  lyd_node *plVar6;
  long in_FS_OFFSET;
  ly_ctx *ctx_local;
  int options_local;
  lyd_node *node_local;
  lys_node *schema;
  lyd_node *next;
  lyd_node *elem;
  lyd_node *ret;
  lyd_node *parent;
  lyd_node *new_node;
  ly_ctx *log_ctx;
  lys_module *trg_mod;
  char *yang_data_name;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_dup_to_ctx");
  new_node = (lyd_node *)0x0;
  if (node == (lyd_node *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_dup_to_ctx");
    plVar6 = (lyd_node *)0x0;
  }
  else {
    options_local = options;
    if (((options & 1U) != 0) && ((options & 8U) != 0)) {
      options_local = options & 0xfffffff7;
    }
    log_ctx = ctx;
    if (ctx == (ly_ctx *)0x0) {
      log_ctx = node->schema->module->ctx;
    }
    ctx_local = ctx;
    if (ctx == node->schema->module->ctx) {
      ctx_local = (ly_ctx *)0x0;
    }
    ret = (lyd_node *)0x0;
    parent = (lyd_node *)0x0;
    elem = node;
    while (new_node = (lyd_node *)0x0, next = elem, elem != (lyd_node *)0x0) {
      if (ctx_local == (ly_ctx *)0x0) {
        schema = elem->schema;
      }
      else {
        schema = (lys_node *)0x0;
        if (parent == (lyd_node *)0x0) {
          schema = lyd_get_schema_inctx(elem,ctx_local);
        }
        else {
          plVar3 = lyd_node_module(elem);
          sVar4 = strlen(plVar3->name);
          plVar3 = lyd_node_module(elem);
          trg_mod = lyp_get_module(parent->schema->module,(char *)0x0,0,plVar3->name,(int)sVar4,1);
          if (trg_mod == (lys_module *)0x0) {
            plVar3 = lyd_node_module(elem);
            ly_log(log_ctx,LY_LLERR,LY_EINVAL,
                   "Target context does not contain model for the data node being duplicated (%s).",
                   plVar3->name);
            goto LAB_001bdedd;
          }
          type = elem->schema->nodetype;
          sVar4 = strlen(elem->schema->name);
          lys_getnext_data(trg_mod,parent->schema,elem->schema->name,(int)sVar4,type,0,&schema);
        }
        if (schema == (lys_node *)0x0) {
          yang_data_name = lyp_get_yang_data_template_name(elem);
          if (yang_data_name == (char *)0x0) {
            pcVar1 = elem->schema->name;
            plVar3 = lyd_node_module(elem);
            ly_log(log_ctx,LY_LLERR,LY_EINVAL,
                   "Target context does not contain schema node for the data node being duplicated (%s:%s)."
                   ,plVar3->name,pcVar1);
          }
          else {
            pcVar1 = elem->schema->name;
            plVar3 = lyd_node_module(elem);
            ly_log(log_ctx,LY_LLERR,LY_EINVAL,
                   "Target context does not contain schema node for the data node being duplicated (%s:#%s/%s)."
                   ,plVar3->name,yang_data_name,pcVar1);
          }
          goto LAB_001bdedd;
        }
      }
      new_node = _lyd_dup_node(elem,schema,log_ctx,options_local);
      if ((new_node == (lyd_node *)0x0) ||
         ((parent != (lyd_node *)0x0 && (iVar2 = lyd_insert(parent,new_node), iVar2 != 0))))
      goto LAB_001bdedd;
      if (ret == (lyd_node *)0x0) {
        ret = new_node;
      }
      if ((options_local & 9U) == 0) break;
      if ((options_local & 8U) != 0) {
        iVar2 = lyd_dup_keys(new_node,elem,(lys_node *)0x0,log_ctx,options_local);
        if (iVar2 != 0) goto LAB_001bdedd;
        break;
      }
      if ((elem->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
        next = elem->child;
      }
      else {
        next = (lyd_node *)0x0;
      }
      if (next == (lyd_node *)0x0) {
        if (elem->parent == node->parent) break;
        next = elem->next;
      }
      else {
        parent = new_node;
      }
      new_node = (lyd_node *)0x0;
      while ((next == (lyd_node *)0x0 && (elem = elem->parent, elem->parent != node->parent))) {
        if (parent == (lyd_node *)0x0) {
          ly_log(log_ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                 ,0x16d6);
          goto LAB_001bdedd;
        }
        parent = parent->parent;
        next = elem->next;
      }
      elem = next;
    }
    plVar6 = ret;
    if ((options_local & 4U) != 0) {
      parent = ret;
      plVar5 = lys_is_key((lys_node_leaf *)ret->schema,(uint8_t *)0x0);
      if (plVar5 == (lys_node_list *)0x0) {
        schema = (lys_node *)0x0;
      }
      else {
        schema = ret->schema;
      }
      elem = node->parent;
      while( true ) {
        plVar6 = ret;
        if (elem == (lyd_node *)0x0) goto LAB_001bdeee;
        new_node = lyd_dup(elem,options_local & 2);
        if (new_node == (lyd_node *)0x0) break;
        iVar2 = lyd_dup_keys(new_node,elem,schema,log_ctx,options_local);
        if (iVar2 != 0) goto LAB_001bdedd;
        iVar2 = lyd_insert(new_node,parent);
        if (iVar2 != 0) {
          ret = parent;
          goto LAB_001bdedd;
        }
        parent = new_node;
        elem = elem->parent;
      }
      ly_log(log_ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_dup_to_ctx");
LAB_001bdedd:
      lyd_free(ret);
      plVar6 = (lyd_node *)0x0;
    }
  }
LAB_001bdeee:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lyd_node * lyd_dup(lyd_node *node,int options)

{
  lyd_node *plVar1;
  int options_local;
  lyd_node *node_local;
  
  ly_log_dbg(0x20,"%s","lyd_dup");
  plVar1 = lyd_dup_to_ctx(node,options,(ly_ctx *)0x0);
  return plVar1;
}



lyd_node * lyd_dup_withsiblings_r(lyd_node *first,lyd_node *parent_dup,int options,ly_ctx *ctx)

{
  int iVar1;
  lyd_node *list;
  lyd_node *plVar2;
  ly_ctx *ctx_local;
  int options_local;
  lyd_node *parent_dup_local;
  lyd_node *first_local;
  lyd_node *first_dup;
  lyd_node *prev_dup;
  lyd_node *next;
  lyd_node *last_dup;
  
  first_dup = (lyd_node *)0x0;
  prev_dup = (lyd_node *)0x0;
  next = first;
  if (first == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("first",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x170f,"lyd_dup_withsiblings_r");
  }
  while( true ) {
    if (next == (lyd_node *)0x0) {
      if (prev_dup->next == (lyd_node *)0x0) {
        first_dup->prev = prev_dup;
        return first_dup;
      }
                    // WARNING: Subroutine does not return
      __assert_fail("!prev_dup->next",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                    ,0x173e,"lyd_dup_withsiblings_r");
    }
    list = _lyd_dup_node(next,next->schema,ctx,options);
    if (list == (lyd_node *)0x0) break;
    list->validity = next->validity;
    list->field_0x9 = list->field_0x9 & 0xf1 | ((byte)next->field_0x9 >> 1 & 7) * '\x02';
    list->parent = parent_dup;
    if (first_dup == (lyd_node *)0x0) {
      first_dup = list;
      if (parent_dup != (lyd_node *)0x0) {
        parent_dup->child = list;
      }
    }
    else {
      if (prev_dup == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("prev_dup",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x1724,"lyd_dup_withsiblings_r");
      }
      prev_dup->next = list;
      list->prev = prev_dup;
    }
    if ((list->schema->nodetype != LYS_LIST) || (iVar1 = lyd_list_has_keys(list), iVar1 != 0)) {
      list->hash = next->hash;
    }
    lyd_insert_hash(list);
    if ((((next->schema->nodetype & 0x4191) != LYS_UNKNOWN) && (next->child != (lyd_node *)0x0)) &&
       (plVar2 = lyd_dup_withsiblings_r(next->child,list,options,ctx), plVar2 == (lyd_node *)0x0))
    break;
    next = next->next;
    prev_dup = list;
  }
  if (first_dup != (lyd_node *)0x0) {
    first_dup->parent = (lyd_node *)0x0;
    lyd_free_withsiblings(first_dup);
  }
  return (lyd_node *)0x0;
}



lyd_node * lyd_dup_withsiblings_to_ctx(lyd_node *node,int options,ly_ctx *ctx)

{
  int iVar1;
  lyd_node *node_00;
  lyd_node *node_01;
  ly_ctx *ctx_local;
  int options_local;
  lyd_node *node_local;
  lyd_node *iter;
  lyd_node *ret;
  lyd_node *ret_iter;
  lyd_node *tmp;
  
  node_local = node;
  if (node == (lyd_node *)0x0) {
    node_00 = (lyd_node *)0x0;
  }
  else {
    while (node_local->prev->next != (lyd_node *)0x0) {
      node_local = node_local->prev;
    }
    if (node_local->parent == (lyd_node *)0x0) {
      node_00 = lyd_dup_withsiblings_r(node_local,(lyd_node *)0x0,options,ctx);
    }
    else {
      node_00 = lyd_dup_to_ctx(node_local,options,ctx);
      if (node_00 == (lyd_node *)0x0) {
        node_00 = (lyd_node *)0x0;
      }
      else {
        ret_iter = node_00;
        for (iter = node_local->next; iter != (lyd_node *)0x0; iter = iter->next) {
          node_01 = lyd_dup_to_ctx(iter,options,ctx);
          if (node_01 == (lyd_node *)0x0) {
            lyd_free_withsiblings(node_00);
            return (lyd_node *)0x0;
          }
          iVar1 = lyd_insert_after(ret_iter,node_01);
          if (iVar1 != 0) {
            lyd_free_withsiblings(node_00);
            return (lyd_node *)0x0;
          }
          ret_iter = ret_iter->next;
          if (ret_iter != node_01) {
                    // WARNING: Subroutine does not return
            __assert_fail("ret_iter == tmp",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                          ,5999,"lyd_dup_withsiblings_to_ctx");
          }
        }
      }
    }
  }
  return node_00;
}



lyd_node * lyd_dup_withsiblings(lyd_node *node,int options)

{
  lyd_node *plVar1;
  lys_module *plVar2;
  int options_local;
  lyd_node *node_local;
  
  ly_log_dbg(0x20,"%s","lyd_dup_withsiblings");
  if (node == (lyd_node *)0x0) {
    plVar1 = (lyd_node *)0x0;
  }
  else {
    plVar2 = lyd_node_module(node);
    plVar1 = lyd_dup_withsiblings_to_ctx(node,options,plVar2->ctx);
  }
  return plVar1;
}



void lyd_free_attr(ly_ctx *ctx,lyd_node *parent,lyd_attr *attr,int recursive)

{
  lyd_attr *plVar1;
  undefined8 *puVar2;
  int recursive_local;
  lyd_attr *attr_local;
  lyd_node *parent_local;
  ly_ctx *ctx_local;
  lyd_attr *iter;
  lys_type **type;
  
  ly_log_dbg(0x20,"%s","lyd_free_attr");
  if ((ctx != (ly_ctx *)0x0) && (attr != (lyd_attr *)0x0)) {
    if (parent != (lyd_node *)0x0) {
      if (attr == parent->attr) {
        if (recursive == 0) {
          parent->attr = attr->next;
        }
        else {
          parent->attr = (lyd_attr *)0x0;
        }
      }
      else {
        for (iter = parent->attr; attr != iter->next; iter = iter->next) {
        }
        if (iter->next != (lyd_attr *)0x0) {
          if (recursive == 0) {
            iter->next = attr->next;
          }
          else {
            iter->next = (lyd_attr *)0x0;
          }
        }
      }
    }
    iter = attr;
    if (recursive == 0) {
      attr->next = (lyd_attr *)0x0;
    }
    while (iter != (lyd_attr *)0x0) {
      plVar1 = iter->next;
      lydict_remove(ctx,iter->name);
      puVar2 = (undefined8 *)
               lys_ext_complex_get_substmt(LY_STMT_TYPE,iter->annotation,(lyext_substmt **)0x0);
      if (puVar2 == (undefined8 *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("type",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x17ae,"lyd_free_attr");
      }
      lyd_free_value(iter->value,iter->value_type,iter->value_flags,(lys_type *)*puVar2,
                     iter->value_str,(lyd_val *)0x0,(LY_DATA_TYPE *)0x0,(uint8_t *)0x0);
      lydict_remove(ctx,iter->value_str);
      free(iter);
      iter = plVar1;
    }
  }
  return;
}



lyd_node * lyd_attr_parent(lyd_node *root,lyd_attr *attr)

{
  lyd_attr *attr_local;
  lyd_node *root_local;
  lyd_node *elem;
  lyd_node *next;
  lyd_attr *node_attr;
  
  elem = root;
  do {
    if (elem == (lyd_node *)0x0) {
      return (lyd_node *)0x0;
    }
    for (node_attr = elem->attr; node_attr != (lyd_attr *)0x0; node_attr = node_attr->next) {
      if (node_attr == attr) {
        return elem;
      }
    }
    if ((elem->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
      next = elem->child;
    }
    else {
      next = (lyd_node *)0x0;
    }
    if (next == (lyd_node *)0x0) {
      if (elem == root) {
        return (lyd_node *)0x0;
      }
      next = elem->next;
    }
    while ((next == (lyd_node *)0x0 && (elem = elem->parent, elem->parent != root->parent))) {
      next = elem->next;
    }
    elem = next;
  } while( true );
}



lyd_attr * lyd_insert_attr(lyd_node *parent,lys_module *mod,char *name,char *value)

{
  ly_ctx *ctx_00;
  int iVar1;
  char *pcVar2;
  char *name_00;
  lyd_attr *attr;
  undefined8 *puVar3;
  lys_type *plVar4;
  char *value_local;
  char *name_local;
  lys_module *mod_local;
  lyd_node *parent_local;
  int pos;
  int i;
  lyd_attr *iter;
  lys_module *module;
  ly_ctx *ctx;
  char *p;
  char *aux;
  lyd_attr *a;
  
  ly_log_dbg(0x20,"%s","lyd_insert_attr");
  if (((parent == (lyd_node *)0x0) || (name == (char *)0x0)) || (value == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_insert_attr");
    return (lyd_attr *)0x0;
  }
  ctx_00 = parent->schema->module->ctx;
  pcVar2 = strchr(name,0x3a);
  if (pcVar2 == (char *)0x0) {
    name_local = name;
    module = mod;
    if (mod == (lys_module *)0x0) {
      if (((false) ||
          ((iVar1 = strcmp(name,"type"), iVar1 != 0 && (iVar1 = strcmp(name,"select"), iVar1 != 0)))
          ) || (iVar1 = strcmp(parent->schema->name,"filter"), iVar1 != 0)) {
        module = lyd_node_module(parent);
      }
      else {
        module = ly_ctx_get_module(ctx_00,"ietf-netconf",(char *)0x0,1);
        if (module == (lys_module *)0x0) {
          ly_log(ctx_00,LY_LLERR,LY_EINVAL,
                 "Attribute prefix does not match any implemented schema in the context.");
          return (lyd_attr *)0x0;
        }
      }
    }
  }
  else {
    name_00 = strndup(name,(long)pcVar2 - (long)name);
    if (name_00 == (char *)0x0) {
      ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_insert_attr");
      return (lyd_attr *)0x0;
    }
    module = ly_ctx_get_module(ctx_00,name_00,(char *)0x0,1);
    free(name_00);
    name_local = pcVar2 + 1;
    if (module == (lys_module *)0x0) {
      ly_log(ctx_00,LY_LLERR,LY_EINVAL,
             "Attribute prefix does not match any implemented schema in the context.");
      return (lyd_attr *)0x0;
    }
  }
  pos = -1;
  while( true ) {
    if (pos + 1U < (uint)module->ext_size) {
      iVar1 = lys_ext_instance_presence
                        ((*(ctx_00->models).list)->extensions,module->ext + (long)pos + 1,
                         (module->ext_size - (char)pos) + 0xff);
      if (iVar1 == -1) {
        pos = -1;
      }
      else {
        pos = iVar1 + pos + 1;
      }
    }
    else {
      pos = -1;
    }
    if (pos == -1) break;
    iVar1 = ly_strequal_(module->ext[pos]->arg_value,name_local);
    if (iVar1 != 0) {
      attr = (lyd_attr *)calloc(1,0x38);
      if (attr == (lyd_attr *)0x0) {
        ly_log(ctx_00,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyd_insert_attr");
        attr = (lyd_attr *)0x0;
      }
      else {
        attr->parent = parent;
        attr->next = (lyd_attr *)0x0;
        attr->annotation = (lys_ext_instance_complex *)module->ext[pos];
        pcVar2 = lydict_insert(ctx_00,name_local,0);
        attr->name = pcVar2;
        pcVar2 = lydict_insert(ctx_00,value,0);
        attr->value_str = pcVar2;
        puVar3 = (undefined8 *)
                 lys_ext_complex_get_substmt(LY_STMT_TYPE,attr->annotation,(lyext_substmt **)0x0);
        plVar4 = lyp_parse_value((lys_type *)*puVar3,&attr->value_str,(lyxml_elem *)0x0,
                                 (lyd_node_leaf_list *)0x0,attr,(lys_module *)0x0,1,0,0);
        if (plVar4 == (lys_type *)0x0) {
          lyd_free_attr(ctx_00,(lyd_node *)0x0,attr,0);
          attr = (lyd_attr *)0x0;
        }
        else if (parent->attr == (lyd_attr *)0x0) {
          parent->attr = attr;
        }
        else {
          for (iter = parent->attr; iter->next != (lyd_attr *)0x0; iter = iter->next) {
          }
          iter->next = attr;
        }
      }
      return attr;
    }
  }
  ly_log(ctx_00,LY_LLERR,LY_EINVAL,"Attribute does not match any annotation instance definition.");
  return (lyd_attr *)0x0;
}



void lyd_free_value(lyd_val value,LY_DATA_TYPE value_type,uint8_t value_flags,lys_type *type,
                   char *value_str,lyd_val *old_val,LY_DATA_TYPE *old_val_type,
                   uint8_t *old_val_flags)

{
  lyd_val *old_val_local;
  char *value_str_local;
  lys_type *type_local;
  uint8_t value_flags_local;
  LY_DATA_TYPE value_type_local;
  lyd_val value_local;
  
  if (old_val == (lyd_val *)0x0) {
    if ((value_flags & 2) == 0) {
      if (value_type != LY_TYPE_UNION) {
        if (LY_TYPE_UNION < value_type) {
          return;
        }
        if (value_type == LY_TYPE_BITS) {
          if (value.binary == (char *)0x0) {
            return;
          }
          free(value.ptr);
          return;
        }
        if (value_type != LY_TYPE_INST) {
          return;
        }
        if ((value_flags & 1) == 0) {
          return;
        }
      }
      lydict_remove(type->parent->module->ctx,value.binary);
    }
    else {
      lytype_free(type,value,value_str);
    }
  }
  else {
    *old_val = value;
    *old_val_type = value_type;
    *old_val_flags = value_flags;
  }
  return;
}



void _lyd_free_node(lyd_node *node)

{
  LYS_NODE LVar1;
  lyd_node *node_local;
  lyd_node_leaf_list *leaf;
  
  if (node == (lyd_node *)0x0) {
    return;
  }
  LVar1 = node->schema->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_001bec62_caseD_20:
    if (true) {
      switch(*(undefined4 *)&node->field_0x34) {
      case 0:
      case 2:
      case 4:
        lydict_remove(node->schema->module->ctx,(char *)node->ht);
        break;
      case 1:
      case 3:
      case 5:
      case 0x21:
                    // WARNING: Subroutine does not return
        __assert_fail("0",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x186c,"_lyd_free_node");
      case 8:
        lyxml_free_withsiblings(node->schema->module->ctx,(lyxml_elem *)node->ht);
        break;
      case 0x10:
        lyd_free_withsiblings((lyd_node *)node->ht);
        break;
      case 0x20:
        free(node->ht);
      }
    }
  }
  else {
    if (LYS_ANYDATA < LVar1) goto switchD_001bec62_caseD_2;
    if (LVar1 != LYS_ACTION) {
      if (LYS_ACTION < LVar1) goto switchD_001bec62_caseD_2;
      if (LVar1 != LYS_RPC) {
        if (LYS_RPC < LVar1) goto switchD_001bec62_caseD_2;
        if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
          if ((LVar1 == LYS_UNKNOWN) || (false)) {
switchD_001bec62_caseD_2:
                    // WARNING: Subroutine does not return
            __assert_fail("0",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                          ,0x1878,"_lyd_free_node");
          }
          switch(LVar1) {
          case LYS_CONTAINER:
          case LYS_LIST:
            goto switchD_001bec62_caseD_1;
          default:
            goto switchD_001bec62_caseD_2;
          case LYS_LEAF:
          case LYS_LEAFLIST:
            lyd_free_value((lyd_val)node->child,*(LY_DATA_TYPE *)&node[1].schema,
                           *(uint8_t *)((long)&node[1].schema + 4),(lys_type *)&node->schema[1].ref,
                           (char *)node->ht,(lyd_val *)0x0,(LY_DATA_TYPE *)0x0,(uint8_t *)0x0);
            lydict_remove(node->schema->module->ctx,(char *)node->ht);
            goto LAB_001bedda;
          case LYS_ANYXML:
            goto switchD_001bec62_caseD_20;
          }
        }
        if (LVar1 != LYS_NOTIF) goto switchD_001bec62_caseD_2;
      }
    }
switchD_001bec62_caseD_1:
    lyht_free(node->ht);
  }
LAB_001bedda:
  lyd_free_attr(node->schema->module->ctx,node,node->attr,1);
  free(node);
  return;
}



void lyd_free_internal_r(lyd_node *node,int top)

{
  lyd_node *plVar1;
  int permanent;
  int top_local;
  lyd_node *node_local;
  lyd_node *next;
  lyd_node *iter;
  
  if (node != (lyd_node *)0x0) {
    if (top == 0) {
      permanent = 2;
    }
    else {
      permanent = 1;
    }
    lyd_unlink_internal(node,permanent);
    if ((node->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
      iter = node->child;
      while (iter != (lyd_node *)0x0) {
        plVar1 = iter->next;
        lyd_free_internal_r(iter,0);
        iter = plVar1;
      }
    }
    _lyd_free_node(node);
  }
  return;
}



void lyd_free(lyd_node *node)

{
  lyd_node *node_local;
  
  ly_log_dbg(0x20,"%s","lyd_free");
  lyd_free_internal_r(node,1);
  return;
}



void lyd_free_withsiblings_r(lyd_node *first)

{
  lyd_node *plVar1;
  lyd_node *first_local;
  lyd_node *next;
  lyd_node *node;
  
  node = first;
  while (node != (lyd_node *)0x0) {
    plVar1 = node->next;
    if ((node->schema->nodetype & 0x4191) != LYS_UNKNOWN) {
      lyd_free_withsiblings_r(node->child);
    }
    _lyd_free_node(node);
    node = plVar1;
  }
  return;
}



void lyd_free_withsiblings(lyd_node *node)

{
  lyd_node *plVar1;
  lyd_node *node_local;
  lyd_node *iter;
  lyd_node *aux;
  
  ly_log_dbg(0x20,"%s","lyd_free_withsiblings");
  if (node != (lyd_node *)0x0) {
    node_local = node;
    if (node->parent == (lyd_node *)0x0) {
      while (node_local->prev->next != (lyd_node *)0x0) {
        node_local = node_local->prev;
      }
      lyd_free_withsiblings_r(node_local);
    }
    else {
      iter = node->prev;
      while (plVar1 = node, iter->next != (lyd_node *)0x0) {
        plVar1 = iter->prev;
        lyd_free(iter);
        iter = plVar1;
      }
      while (iter = plVar1, iter != (lyd_node *)0x0) {
        plVar1 = iter->next;
        lyd_free(iter);
      }
    }
  }
  return;
}



int lyd_get_unique_default(char *unique_expr,lyd_node *list,char **dflt)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  char **dflt_local;
  lyd_node *list_local;
  char *unique_expr_local;
  int_log_opts prev_ilo;
  uint i;
  lys_node *parent;
  lyd_node *node;
  lys_tpdf *tpdf;
  lyd_node *last;
  ly_ctx *ctx;
  lys_node_leaf *sleaf;
  ly_set *s;
  ly_set *r;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = list->schema->module->ctx;
  sleaf = (lys_node_leaf *)0x0;
  if (((unique_expr == (char *)0x0) || (list == (lyd_node *)0x0)) || (dflt == (char **)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("unique_expr && list && dflt",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x18dd,"lyd_get_unique_default");
  }
  *dflt = (char *)0x0;
  iVar2 = resolve_descendant_schema_nodeid(unique_expr,list->schema->child,4,1,&parent);
  if ((iVar2 == 0) && (parent != (lys_node *)0x0)) {
    sleaf = (lys_node_leaf *)parent;
    if (parent[1].prev == (lys_node *)0x0) {
      if ((parent->flags & 0x40) == 0) {
        tpdf = (lys_tpdf *)parent[1].ext;
        while ((tpdf != (lys_tpdf *)0x0 && (*dflt == (char *)0x0))) {
          *dflt = tpdf->dflt;
          tpdf = (tpdf->type).der;
        }
      }
    }
    else {
      *dflt = (char *)parent[1].prev;
    }
    if (*dflt == (char *)0x0) {
      iVar2 = 0;
    }
    else {
      s = ly_set_new();
      for (parent = lys_parent((lys_node *)sleaf); list->schema != parent;
          parent = lys_parent(parent)) {
        if ((parent->nodetype & 0x1043) == LYS_UNKNOWN) {
          ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                 ,0x18fa);
          ly_set_free(s);
          iVar2 = -1;
          goto LAB_001bf4c1;
        }
        ly_set_add(s,parent,1);
      }
      ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
      last = list;
      for (i = 0; i < s->number; i = i + 1) {
        parent = (s->set).s[i];
        if (parent->nodetype == LYS_CONTAINER) {
          if (last != (lyd_node *)0x0) {
            r = lyd_find_path(last,parent->name);
            if ((r == (ly_set *)0x0) || (1 < r->number)) {
              ly_set_free(r);
              *dflt = (char *)0x0;
              break;
            }
            if (r->number == 0) {
              last = (lyd_node *)0x0;
            }
            else {
              last = *(r->set).d;
            }
            ly_set_free(r);
          }
          lVar1._0_2_ = parent[1].flags;
          lVar1._2_1_ = parent[1].ext_size;
          lVar1._3_1_ = parent[1].iffeature_size;
          lVar1._4_1_ = parent[1].padding[0];
          lVar1._5_1_ = parent[1].padding[1];
          lVar1._6_1_ = parent[1].padding[2];
          lVar1._7_1_ = parent[1].padding[3];
          if (lVar1 != 0) {
            *dflt = (char *)0x0;
            break;
          }
        }
        else if ((parent->nodetype == LYS_CHOICE) && (last != (lyd_node *)0x0)) {
          if (i + 1 == s->number) {
            parent = (lys_node *)sleaf;
          }
          else {
            if ((((s->set).s[i + 1]->nodetype == LYS_CASE) && (i + 2 < s->number)) &&
               ((s->set).s[i + 2]->nodetype == LYS_CHOICE)) {
              i = i + 1;
              goto LAB_001bf482;
            }
            parent = (s->set).s[i + 1];
          }
          node = last->child;
          iVar2 = lyv_multicases((lyd_node *)0x0,parent,&node,0,(lyd_node *)0x0);
          if (iVar2 != 0) {
            *dflt = (char *)0x0;
            break;
          }
        }
LAB_001bf482:
      }
      ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
      ly_set_free(s);
      iVar2 = 0;
    }
  }
  else {
    ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
           ,0x18e2);
    iVar2 = -1;
  }
LAB_001bf4c1:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * lyd_path(lyd_node *node)

{
  int iVar1;
  char *pcVar2;
  long in_FS_OFFSET;
  lyd_node *node_local;
  char *buf;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_path");
  buf = (char *)0x0;
  if (node == (lyd_node *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_path");
    pcVar2 = (char *)0x0;
  }
  else {
    iVar1 = ly_vlog_build_path(LY_VLOG_LYD,node,&buf,0,0);
    pcVar2 = buf;
    if (iVar1 != 0) {
      pcVar2 = (char *)0x0;
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return pcVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyd_build_relative_data_path(lys_module *module,lyd_node *node,char *schema_id,char *buf)

{
  int iVar1;
  undefined *puVar2;
  long in_FS_OFFSET;
  char *buf_local;
  char *schema_id_local;
  lyd_node *node_local;
  lys_module *module_local;
  int mod_name_len;
  int name_len;
  int is_relative;
  int len;
  int r;
  char *mod_name;
  char *name;
  lys_node *snode;
  lys_node *schema;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  len = 0;
  is_relative = -1;
  if ((schema_id == (char *)0x0) || (buf == (char *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("schema_id && buf",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x195d,"lyd_build_relative_data_path");
  }
  schema = node->schema;
  schema_id_local = schema_id;
  do {
    iVar1 = len;
    if (*schema_id_local == '\0') {
LAB_001bf7c2:
      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
        return iVar1;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    r = parse_schema_nodeid(schema_id_local,&mod_name,&mod_name_len,&name,&name_len,&is_relative,
                            (int *)0x0,(int *)0x0,0);
    if (r < 1) {
      ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
             ,0x1962);
      iVar1 = -1;
      goto LAB_001bf7c2;
    }
    schema_id_local = schema_id_local + r;
    snode = (lys_node *)0x0;
    while (snode = lys_getnext(snode,schema,(lys_module *)0x0,0x103), snode != (lys_node *)0x0) {
      r = schema_nodeid_siblingcheck(snode,module,mod_name,mod_name_len,name,name_len);
      if (r == 0) {
        schema = snode;
        break;
      }
      if (r != 1) {
        iVar1 = -1;
        goto LAB_001bf7c2;
      }
    }
    if ((snode == (lys_node *)0x0) || ((*schema_id_local == '\0' && (snode->nodetype != LYS_LEAF))))
    {
      ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
             ,0x1975);
      iVar1 = -1;
      goto LAB_001bf7c2;
    }
    if ((snode->nodetype & (LYS_CHOICE|LYS_CASE)) == LYS_UNKNOWN) {
      if (len == 0) {
        puVar2 = &DAT_00227b5d;
      }
      else {
        puVar2 = &DAT_00228cb9;
      }
      iVar1 = sprintf(buf + len,"%s%s",puVar2,snode->name);
      len = len + iVar1;
    }
  } while( true );
}



ly_set * lyd_find_path(lyd_node *ctx_node,char *path)

{
  long lVar1;
  int iVar2;
  lys_module *plVar3;
  ly_set *plVar4;
  long in_FS_OFFSET;
  char *path_local;
  lyd_node *ctx_node_local;
  int mod_name_len;
  int name_len;
  int is_relative;
  uint32_t i;
  char *mod_name;
  char *name;
  ly_set *set;
  char *node_mod_name;
  char *yang_xpath;
  lyxp_set xp_set;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_find_path");
  is_relative = -1;
  if ((ctx_node == (lyd_node *)0x0) || (path == (char *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_find_path");
    plVar4 = (ly_set *)0x0;
  }
  else {
    iVar2 = parse_schema_nodeid(path,&mod_name,&mod_name_len,&name,&name_len,&is_relative,(int *)0x0
                                ,(int *)0x0,1);
    path_local = path;
    if ((0 < iVar2) && ((*name == '#' && (is_relative == 0)))) {
      plVar3 = lyd_node_module(ctx_node);
      node_mod_name = plVar3->name;
      iVar2 = strncmp(mod_name,node_mod_name,(long)mod_name_len);
      if ((iVar2 != 0) || (node_mod_name[mod_name_len] != '\0')) {
        plVar4 = (ly_set *)0x0;
        goto LAB_001bfaca;
      }
      path_local = name + name_len;
    }
    plVar3 = lyd_node_module(ctx_node);
    yang_xpath = transform_json2xpath(plVar3,path_local);
    if (yang_xpath == (char *)0x0) {
      plVar4 = (ly_set *)0x0;
    }
    else {
      memset(&xp_set,0,0x40);
      plVar3 = lyd_node_module(ctx_node);
      iVar2 = lyxp_eval(yang_xpath,ctx_node,LYXP_NODE_ELEM,plVar3,&xp_set,0);
      if (iVar2 == 0) {
        free(yang_xpath);
        set = ly_set_new();
        if (set == (ly_set *)0x0) {
          ly_log(ctx_node->schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "lyd_find_path");
          plVar4 = (ly_set *)0x0;
        }
        else {
          if (xp_set.type == LYXP_SET_NODE_SET) {
            for (i = 0; i < xp_set.used; i = i + 1) {
              if (xp_set.val.nodes[i].type == LYXP_NODE_ELEM) {
                iVar2 = ly_set_add(set,xp_set.val.nodes[i].node,1);
                if (iVar2 < 0) {
                  ly_set_free(set);
                  set = (ly_set *)0x0;
                  break;
                }
              }
            }
          }
          lyxp_set_cast(&xp_set,LYXP_SET_EMPTY,ctx_node,(lys_module *)0x0,0);
          plVar4 = set;
        }
      }
      else {
        free(yang_xpath);
        plVar4 = (ly_set *)0x0;
      }
    }
  }
LAB_001bfaca:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar4;
}



ly_set * lyd_find_instance(lyd_node *data,lys_node *schema)

{
  uint uVar1;
  ly_set *set;
  ly_set *set_00;
  lys_node *schema_local;
  lyd_node *data_local;
  uint i;
  uint j;
  ly_set *ret;
  lys_node *siter;
  lyd_node *iter;
  ly_set *spath;
  ly_set *ret_aux;
  
  ly_log_dbg(0x20,"%s","lyd_find_instance");
  if (((data == (lyd_node *)0x0) || (schema == (lys_node *)0x0)) ||
     ((schema->nodetype & 0xc1bd) == LYS_UNKNOWN)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_find_instance");
  }
  else {
    ret = ly_set_new();
    set = ly_set_new();
    if ((ret == (ly_set *)0x0) || (data_local = data, set == (ly_set *)0x0)) {
      ly_log(schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
             "lyd_find_instance");
    }
    else {
      for (; data_local->parent != (lyd_node *)0x0; data_local = data_local->parent) {
      }
      while (siter = schema, data_local->prev->next != (lyd_node *)0x0) {
        data_local = data_local->prev;
      }
      while (siter != (lys_node *)0x0) {
        if (siter->nodetype == LYS_AUGMENT) {
          siter = siter->prev;
        }
        else {
          if ((siter->nodetype & 0xc1bd) != LYS_UNKNOWN) {
            ly_set_add(set,siter,1);
          }
          siter = siter->parent;
        }
      }
      if (set->number != 0) {
        for (iter = data_local; iter != (lyd_node *)0x0; iter = iter->next) {
          if (iter->schema == (set->set).s[set->number - 1]) {
            ly_set_add(ret,iter,1);
          }
        }
        uVar1 = set->number;
        while( true ) {
          i = uVar1 - 1;
          if ((i == 0) || (ret->number == 0)) {
            ly_set_free(set);
            return ret;
          }
          set_00 = ly_set_new();
          if (set_00 == (ly_set *)0x0) break;
          for (j = 0; j < ret->number; j = j + 1) {
            for (iter = (lyd_node *)(ret->set).s[j]->parent; iter != (lyd_node *)0x0;
                iter = iter->next) {
              if (iter->schema == (set->set).s[uVar1 - 2]) {
                ly_set_add(set_00,iter,1);
              }
            }
          }
          ly_set_free(ret);
          ret = set_00;
          uVar1 = i;
        }
        ly_log(schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "lyd_find_instance");
      }
    }
    ly_set_free(ret);
    ly_set_free(set);
  }
  return (ly_set *)0x0;
}



lyd_node * lyd_first_sibling(lyd_node *node)

{
  lyd_node *node_local;
  lyd_node *start;
  
  ly_log_dbg(0x20,"%s","lyd_first_sibling");
  if (node == (lyd_node *)0x0) {
    start = (lyd_node *)0x0;
  }
  else {
    start = node;
    if (node->parent == (lyd_node *)0x0) {
      while (start->prev->next != (lyd_node *)0x0) {
        start = start->prev;
      }
    }
    else {
      start = node->parent->child;
    }
  }
  return start;
}



// WARNING: Unknown calling convention

ly_set * ly_set_new(void)

{
  ly_set *plVar1;
  ly_set *new;
  
  ly_log_dbg(0x20,"%s","ly_set_new");
  plVar1 = (ly_set *)calloc(1,0x10);
  if (plVar1 == (ly_set *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_set_new");
    plVar1 = (ly_set *)0x0;
  }
  return plVar1;
}



void ly_set_free(ly_set *set)

{
  ly_set *set_local;
  
  ly_log_dbg(0x20,"%s","ly_set_free");
  if (set != (ly_set *)0x0) {
    free((set->set).s);
    free(set);
  }
  return;
}



int ly_set_contains(ly_set *set,void *node)

{
  void *node_local;
  ly_set *set_local;
  uint i;
  
  ly_log_dbg(0x20,"%s","ly_set_contains");
  if (set != (ly_set *)0x0) {
    for (i = 0; i < set->number; i = i + 1) {
      if ((lys_node *)node == (set->set).s[i]) {
        return i;
      }
    }
  }
  return -1;
}



ly_set * ly_set_dup(ly_set *set)

{
  ly_set *__ptr;
  lys_node **pplVar1;
  ly_set *set_local;
  ly_set *new;
  
  ly_log_dbg(0x20,"%s","ly_set_dup");
  if (set == (ly_set *)0x0) {
    __ptr = (ly_set *)0x0;
  }
  else {
    __ptr = (ly_set *)malloc(0x10);
    if (__ptr == (ly_set *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_set_dup");
      __ptr = (ly_set *)0x0;
    }
    else {
      __ptr->number = set->number;
      __ptr->size = set->size;
      pplVar1 = (lys_node **)malloc((ulong)__ptr->size << 3);
      (__ptr->set).s = pplVar1;
      if ((__ptr->set).s == (lys_node **)0x0) {
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_set_dup");
        free(__ptr);
        __ptr = (ly_set *)0x0;
      }
      else {
        memcpy((__ptr->set).s,(set->set).s,(ulong)__ptr->size * 8);
      }
    }
  }
  return __ptr;
}



int ly_set_add(ly_set *set,void *node,int options)

{
  uint uVar1;
  int iVar2;
  lys_node **pplVar3;
  int options_local;
  void *node_local;
  ly_set *set_local;
  uint i;
  void **new;
  
  ly_log_dbg(0x20,"%s","ly_set_add");
  if (set == (ly_set *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_set_add");
    iVar2 = -1;
  }
  else {
    if ((options & 1U) == 0) {
      for (i = 0; i < set->number; i = i + 1) {
        if ((lys_node *)node == (set->set).s[i]) {
          return i;
        }
      }
    }
    if (set->size == set->number) {
      pplVar3 = (lys_node **)realloc((set->set).s,(ulong)(set->size + 8) * 8);
      if (pplVar3 == (lys_node **)0x0) {
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_set_add");
        return -1;
      }
      set->size = set->size + 8;
      (set->set).s = pplVar3;
    }
    uVar1 = set->number;
    set->number = uVar1 + 1;
    (set->set).s[uVar1] = (lys_node *)node;
    iVar2 = set->number - 1;
  }
  return iVar2;
}



int ly_set_merge(ly_set *trg,ly_set *src,int options)

{
  int iVar1;
  uint uVar2;
  lys_node **pplVar3;
  int options_local;
  ly_set *src_local;
  ly_set *trg_local;
  uint i;
  uint ret;
  void **new;
  
  ly_log_dbg(0x20,"%s","ly_set_merge");
  if (trg == (ly_set *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_set_merge");
    uVar2 = 0xffffffff;
  }
  else if (src == (ly_set *)0x0) {
    uVar2 = 0;
  }
  else {
    if ((options & 1U) == 0) {
      i = 0;
      while (i < src->number) {
        iVar1 = ly_set_contains(trg,(src->set).s[i]);
        if (iVar1 < 0) {
          i = i + 1;
        }
        else {
          ly_set_rm_index(src,i);
        }
      }
    }
    if (trg->size < src->number + trg->number) {
      pplVar3 = (lys_node **)realloc((trg->set).s,(ulong)(src->number + trg->number) * 8);
      if (pplVar3 == (lys_node **)0x0) {
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_set_merge");
        return -1;
      }
      trg->size = trg->number + src->number;
      (trg->set).s = pplVar3;
    }
    memcpy((trg->set).s + trg->number,(src->set).s,(ulong)src->number * 8);
    uVar2 = src->number;
    trg->number = trg->number + uVar2;
    ly_set_free(src);
  }
  return uVar2;
}



int ly_set_rm_index(ly_set *set,uint index)

{
  int iVar1;
  uint index_local;
  ly_set *set_local;
  
  ly_log_dbg(0x20,"%s","ly_set_rm_index");
  if ((set == (ly_set *)0x0) || (set->number < index + 1)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_set_rm_index");
    iVar1 = 1;
  }
  else {
    if (index == set->number - 1) {
      (set->set).s[index] = (lys_node *)0x0;
    }
    else {
      (set->set).s[index] = (set->set).s[set->number - 1];
      (set->set).s[set->number - 1] = (lys_node *)0x0;
    }
    set->number = set->number - 1;
    iVar1 = 0;
  }
  return iVar1;
}



int ly_set_rm(ly_set *set,void *node)

{
  int iVar1;
  void *node_local;
  ly_set *set_local;
  uint i;
  
  ly_log_dbg(0x20,"%s","ly_set_rm");
  if ((set == (ly_set *)0x0) || (node == (void *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_set_rm");
    iVar1 = 1;
  }
  else {
    for (i = 0; (i < set->number && ((lys_node *)node != (set->set).s[i])); i = i + 1) {
    }
    if (i == set->number) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","ly_set_rm");
      iVar1 = 1;
    }
    else {
      iVar1 = ly_set_rm_index(set,i);
    }
  }
  return iVar1;
}



int ly_set_clean(ly_set *set)

{
  ly_set *set_local;
  
  ly_log_dbg(0x20,"%s","ly_set_clean");
  if (set != (ly_set *)0x0) {
    set->number = 0;
  }
  return (int)(set == (ly_set *)0x0);
}



int lyd_wd_default(lyd_node_leaf_list *node)

{
  char **ppcVar1;
  lys_node *plVar2;
  int iVar3;
  lyd_node_leaf_list *node_local;
  uint8_t dflts_size;
  uint8_t c;
  uint8_t i;
  lyd_node *iter;
  lys_tpdf *tpdf;
  char *dflt;
  char **dflts;
  lys_node_leaflist *llist;
  lys_node_leaf *leaf;
  
  ly_log_dbg(0x20,"%s","lyd_wd_default");
  dflt = (char *)0x0;
  dflts = (char **)0x0;
  dflts_size = '\0';
  if ((node == (lyd_node_leaf_list *)0x0) ||
     ((node->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN)) {
    iVar3 = 0;
  }
  else if ((node->field_0x9 & 1) == 0) {
    if (node->schema->nodetype == LYS_LEAF) {
      plVar2 = node->schema;
      if (plVar2[1].prev == (lys_node *)0x0) {
        if ((plVar2->flags & 0x40) == 0) {
          tpdf = (lys_tpdf *)plVar2[1].ext;
          while ((tpdf != (lys_tpdf *)0x0 && (dflt == (char *)0x0))) {
            ppcVar1 = &tpdf->dflt;
            tpdf = (tpdf->type).der;
            dflt = *ppcVar1;
          }
        }
      }
      else {
        dflt = (char *)plVar2[1].prev;
      }
      if (dflt == (char *)0x0) {
        return 0;
      }
      if (dflt != node->value_str) {
        return 0;
      }
    }
    else {
      if (((byte)node->schema->module->field_0x40 >> 1 & 7) < 2) {
        return 0;
      }
      plVar2 = node->schema;
      if (plVar2->padding[2] == '\0') {
        if (*(int *)&plVar2[1].priv == 0) {
          tpdf = (lys_tpdf *)plVar2[1].ext;
          while( true ) {
            if ((tpdf == (lys_tpdf *)0x0) || (false)) goto LAB_001c0894;
            if (tpdf->dflt != (char *)0x0) break;
            tpdf = (tpdf->type).der;
          }
          dflts = &tpdf->dflt;
          dflts_size = '\x01';
        }
      }
      else {
        dflts_size = plVar2->padding[2];
        dflts = &(plVar2[1].prev)->name;
      }
LAB_001c0894:
      if (dflts_size == '\0') {
        return 0;
      }
      iter = (lyd_node *)node;
      if (node->parent == (lyd_node *)0x0) {
        while (iter->prev->next != (lyd_node *)0x0) {
          iter = iter->prev;
        }
      }
      else {
        iter = node->parent->child;
      }
      c = '\0';
      for (; iter != (lyd_node *)0x0; iter = iter->next) {
        if (iter->schema == node->schema) {
          if (c == dflts_size) {
            return 0;
          }
          if ((plVar2->flags & 0x100) == 0) {
            for (i = '\0'; (i < dflts_size && ((hash_table *)dflts[i] != iter->ht)); i = i + '\x01')
            {
            }
            if (i == dflts_size) {
              return 0;
            }
          }
          else if ((hash_table *)dflts[c] != iter->ht) {
            return 0;
          }
          c = c + '\x01';
        }
      }
      if (c != dflts_size) {
        return 0;
      }
    }
    iVar3 = 1;
  }
  else {
    iVar3 = 1;
  }
  return iVar3;
}



int unres_data_diff_new(unres_data *unres,lyd_node *subtree,lyd_node *parent,int created)

{
  uint uVar1;
  int iVar2;
  lys_module *plVar3;
  int created_local;
  lyd_node *parent_local;
  lyd_node *subtree_local;
  unres_data *unres_local;
  char *parent_xpath;
  
  parent_xpath = (char *)0x0;
  if (created == 0) {
    if ((parent != (lyd_node *)0x0) &&
       (parent_xpath = lyd_path(parent), parent_xpath == (char *)0x0)) {
      plVar3 = lyd_node_module(subtree);
      ly_log(plVar3->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","unres_data_diff_new");
      return -1;
    }
    uVar1 = unres->diff_idx;
    unres->diff_idx = uVar1 + 1;
    iVar2 = lyd_difflist_add(unres->diff,&unres->diff_size,uVar1,LYD_DIFF_DELETED,subtree,
                             (lyd_node *)parent_xpath);
  }
  else {
    uVar1 = unres->diff_idx;
    unres->diff_idx = uVar1 + 1;
    iVar2 = lyd_difflist_add(unres->diff,&unres->diff_size,uVar1,LYD_DIFF_CREATED,(lyd_node *)0x0,
                             subtree);
  }
  return iVar2;
}



void unres_data_diff_rem(unres_data *unres,uint idx)

{
  uint idx_local;
  unres_data *unres_local;
  
  if (unres->diff->type[idx] == LYD_DIFF_DELETED) {
    lyd_free_withsiblings(unres->diff->first[idx]);
    free(unres->diff->second[idx]);
  }
  if (idx < unres->diff_idx - 1) {
    unres->diff->type[idx] = unres->diff->type[unres->diff_idx - 1];
    unres->diff->first[idx] = unres->diff->first[unres->diff_idx - 1];
    unres->diff->second[idx] = unres->diff->second[unres->diff_idx - 1];
  }
  if (unres->diff->type[unres->diff_idx] != LYD_DIFF_END) {
                    // WARNING: Subroutine does not return
    __assert_fail("unres->diff->type[unres->diff_idx] == LYD_DIFF_END",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x1b94,"unres_data_diff_rem");
  }
  unres->diff->type[unres->diff_idx - 1] = unres->diff->type[unres->diff_idx];
  unres->diff_idx = unres->diff_idx - 1;
  return;
}



void lyd_free_val_diff(lyd_difflist *diff)

{
  lyd_difflist *diff_local;
  uint32_t i;
  
  ly_log_dbg(0x20,"%s","lyd_free_val_diff");
  if (diff != (lyd_difflist *)0x0) {
    for (i = 0; diff->type[i] != LYD_DIFF_END; i = i + 1) {
      if (diff->type[i] == LYD_DIFF_DELETED) {
        lyd_free_withsiblings(diff->first[i]);
        free(diff->second[i]);
      }
      else if (diff->type[i] == LYD_DIFF_CREATED) {
        free(diff->first[i]);
        lyd_free_withsiblings(diff->second[i]);
      }
    }
    lyd_free_diff(diff);
  }
  return;
}



int lyd_wd_add_leaf(lyd_node **tree,lyd_node *last_parent,lys_node_leaf *leaf,unres_data *unres,
                   int check_when_must)

{
  char **ppcVar1;
  int iVar2;
  uint uVar3;
  lyd_node *subtree;
  int check_when_must_local;
  unres_data *unres_local;
  lys_node_leaf *leaf_local;
  lyd_node *last_parent_local;
  lyd_node **tree_local;
  int ret;
  lyd_node *current;
  lys_tpdf *tpdf;
  char *dflt;
  lyd_node *dummy;
  
  dflt = (char *)0x0;
  if (leaf->dflt == (char *)0x0) {
    if ((leaf->flags & 0x40) == 0) {
      tpdf = (leaf->type).der;
      while ((tpdf != (lys_tpdf *)0x0 && (dflt == (char *)0x0))) {
        ppcVar1 = &tpdf->dflt;
        tpdf = (tpdf->type).der;
        dflt = *ppcVar1;
      }
    }
  }
  else {
    dflt = leaf->dflt;
  }
  if (dflt == (char *)0x0) {
    return 0;
  }
  subtree = lyd_new_dummy(*tree,last_parent,(lys_node *)leaf,dflt,1);
  if (((subtree == (lyd_node *)0x0) ||
      ((unres->store_diff != 0 &&
       (iVar2 = unres_data_diff_new(unres,subtree,(lyd_node *)0x0,1), iVar2 != 0)))) ||
     ((current = subtree, subtree->parent == (lyd_node *)0x0 &&
      ((*tree != (lyd_node *)0x0 && (iVar2 = lyd_insert_sibling(tree,subtree), iVar2 != 0)))))) {
LAB_001c106e:
    lyd_free(subtree);
    iVar2 = 1;
  }
  else {
    while( true ) {
      if ((check_when_must != 0) &&
         (((((byte)current->field_0x9 >> 1 & 4) != 0 &&
           (iVar2 = unres_data_add(unres,current,UNRES_WHEN), iVar2 == -1)) ||
          ((check_when_must == 2 &&
           (((uVar3 = resolve_applies_must(current), (uVar3 & 1) != 0 &&
             (iVar2 = unres_data_add(unres,current,UNRES_MUST), iVar2 == -1)) ||
            (((uVar3 & 2) != 0 &&
             (iVar2 = unres_data_add(unres,current,UNRES_MUST_INOUT), iVar2 == -1))))))))))
      goto LAB_001c106e;
      current->validity = current->validity & 0x7f;
      if (leaf == (lys_node_leaf *)current->schema) break;
      current = current->child;
    }
    lyd_wd_update_parents(subtree);
    if (*(int *)&current[1].schema == 9) {
      iVar2 = unres_data_add(unres,current,UNRES_LEAFREF);
joined_r0x001c103b:
      if (iVar2 != 0) goto LAB_001c106e;
    }
    else if (*(int *)&current[1].schema == 8) {
      iVar2 = unres_data_add(unres,current,UNRES_INSTID);
      goto joined_r0x001c103b;
    }
    if (*tree == (lyd_node *)0x0) {
      *tree = subtree;
    }
    iVar2 = 0;
  }
  return iVar2;
}



int lyd_wd_add_leaflist(lyd_node **tree,lyd_node *last_parent,lys_node_leaflist *llist,
                       unres_data *unres,int check_when_must)

{
  lyd_node *plVar1;
  uint uVar2;
  int iVar3;
  int check_when_must_local;
  unres_data *unres_local;
  lys_node_leaflist *llist_local;
  lyd_node *last_parent_local;
  lyd_node **tree_local;
  uint8_t dflt_size;
  int i;
  int ret;
  lyd_node *current;
  lyd_node *first;
  lys_tpdf *tpdf;
  char **dflt;
  lyd_node *dummy;
  
  first = (lyd_node *)0x0;
  dflt = (char **)0x0;
  dflt_size = '\0';
  if (1 < ((byte)llist->module->field_0x40 >> 1 & 7)) {
    if (llist->dflt_size == '\0') {
      if (llist->min == 0) {
        tpdf = (llist->type).der;
        while( true ) {
          if ((tpdf == (lys_tpdf *)0x0) || (false)) goto LAB_001c1154;
          if (tpdf->dflt != (char *)0x0) break;
          tpdf = (tpdf->type).der;
        }
        dflt = &tpdf->dflt;
        dflt_size = '\x01';
      }
    }
    else {
      dflt_size = llist->dflt_size;
      dflt = llist->dflt;
    }
LAB_001c1154:
    if (dflt_size != '\0') {
      for (i = 0; i < (int)(uint)dflt_size; i = i + 1) {
        current = lyd_new_dummy(*tree,last_parent,(lys_node *)llist,dflt[i],1);
        if ((current == (lyd_node *)0x0) ||
           ((unres->store_diff != 0 &&
            (iVar3 = unres_data_diff_new(unres,current,(lyd_node *)0x0,1), iVar3 != 0))))
        goto LAB_001c13ef;
        plVar1 = current;
        if ((first != (lyd_node *)0x0) && (plVar1 = first, current->parent == (lyd_node *)0x0)) {
          first->prev->next = current;
          current->prev = first->prev;
          first->prev = current;
        }
        while( true ) {
          first = plVar1;
          if ((check_when_must != 0) &&
             (((((byte)current->field_0x9 >> 1 & 4) != 0 &&
               (iVar3 = unres_data_add(unres,current,UNRES_WHEN), iVar3 == -1)) ||
              ((check_when_must == 2 &&
               (((uVar2 = resolve_applies_must(current), (uVar2 & 1) != 0 &&
                 (iVar3 = unres_data_add(unres,current,UNRES_MUST), iVar3 == -1)) ||
                (((uVar2 & 2) != 0 &&
                 (iVar3 = unres_data_add(unres,current,UNRES_MUST_INOUT), iVar3 == -1))))))))))
          goto LAB_001c13ef;
          current->validity = current->validity & 0x7f;
          if (llist == (lys_node_leaflist *)current->schema) break;
          current = current->child;
          plVar1 = first;
        }
        if (*(int *)&current[1].schema == 9) {
          iVar3 = unres_data_add(unres,current,UNRES_LEAFREF);
joined_r0x001c1365:
          if (iVar3 != 0) goto LAB_001c13ef;
        }
        else if (*(int *)&current[1].schema == 8) {
          iVar3 = unres_data_add(unres,current,UNRES_INSTID);
          goto joined_r0x001c1365;
        }
      }
      if (((first == (lyd_node *)0x0) || (first->parent != (lyd_node *)0x0)) ||
         (*tree == (lyd_node *)0x0)) {
        if (*tree == (lyd_node *)0x0) {
          *tree = first;
        }
      }
      else {
        iVar3 = lyd_insert_sibling(tree,first);
        if (iVar3 != 0) {
LAB_001c13ef:
          lyd_free_withsiblings(first);
          return 1;
        }
      }
      lyd_wd_update_parents(first);
    }
  }
  return 0;
}



void lyd_wd_leaflist_cleanup(ly_set *set,unres_data *unres)

{
  unres_data *unres_local;
  ly_set *set_local;
  uint i;
  
  if (set != (ly_set *)0x0) {
    i = 0;
    while ((i < set->number && ((*(byte *)((long)&(set->set).s[i]->dsc + 1) & 1) != 0))) {
      i = i + 1;
    }
    if (i < set->number) {
      for (i = 0; i < set->number; i = i + 1) {
        if ((*(byte *)((long)&(set->set).s[i]->dsc + 1) & 1) != 0) {
          if (unres->store_diff == 0) {
            lyd_free((lyd_node *)(set->set).s[i]);
          }
          else {
            unres_data_diff_new(unres,(lyd_node *)(set->set).s[i],
                                (lyd_node *)(set->set).s[i]->iffeature,0);
            lyd_unlink((lyd_node *)(set->set).s[i]);
          }
        }
      }
    }
    return;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("set",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                ,0x1c89,"lyd_wd_leaflist_cleanup");
}



// WARNING: Type propagation algorithm not settling

int lyd_wd_add_subtree(lyd_node **root,lyd_node *last_parent,lyd_node *subroot,lys_node *schema,
                      int toplevel,int options,unres_data *unres)

{
  LYS_NODE LVar1;
  long lVar2;
  long lVar3;
  bool bVar4;
  int iVar5;
  uint uVar6;
  lys_node *plVar7;
  int options_local;
  int toplevel_local;
  lys_node *schema_local;
  lyd_node *subroot_local;
  lyd_node *last_parent_local;
  lyd_node **root_local;
  int i;
  int check_when_must;
  int storing_diff;
  ly_set *present;
  lys_node *siter;
  lys_node *siter_prev;
  lyd_node *iter;
  
  present = (ly_set *)0x0;
  bVar4 = false;
  if (root == (lyd_node **)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("root",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x1cbb,"lyd_wd_add_subtree");
  }
  if (((options & 0x10000ffU) != 0) && ((schema->flags & 2) != 0)) {
    return 0;
  }
  if ((options & 0x8eU) == 0) {
    if ((options & 0x2000U) == 0) {
      check_when_must = 2;
    }
    else {
      check_when_must = 1;
    }
  }
  else {
    check_when_must = 0;
  }
  if ((toplevel == 0) ||
     ((schema->nodetype & (LYS_CONTAINER|LYS_LEAF|LYS_LEAFLIST|LYS_LIST)) == LYS_UNKNOWN)) {
    if (subroot == (lyd_node *)0x0) {
      for (siter = schema->parent;
          (siter != (lys_node *)0x0 && ((siter->nodetype & (LYS_CHOICE|LYS_USES)) != LYS_UNKNOWN));
          siter = siter->parent) {
        plVar7 = lys_is_disabled(siter,0);
        if (plVar7 != (lys_node *)0x0) {
          return 0;
        }
      }
      if (((siter != (lys_node *)0x0) && (siter->nodetype == LYS_AUGMENT)) &&
         (plVar7 = lys_is_disabled(siter,0), plVar7 != (lys_node *)0x0)) {
        return 0;
      }
      plVar7 = lys_is_disabled(schema,0);
      if (plVar7 != (lys_node *)0x0) {
        return 0;
      }
    }
    LVar1 = schema->nodetype;
    subroot_local = subroot;
    last_parent_local = last_parent;
    if (LVar1 == LYS_USES) goto LAB_001c1a62;
    if (LYS_USES < LVar1) goto LAB_001c1f9b;
    if (LVar1 == LYS_OUTPUT) goto LAB_001c1a62;
    if (LYS_OUTPUT < LVar1) goto LAB_001c1f9b;
    if (LVar1 == LYS_INPUT) goto LAB_001c1a62;
    if (LYS_INPUT < LVar1) goto LAB_001c1f9b;
    if (LVar1 == LYS_NOTIF) goto LAB_001c1a62;
    if (LVar1 < (LYS_CONTAINER|LYS_NOTIF)) {
      if (LVar1 < (LYS_CONTAINER|LYS_LIST)) {
        if ((LVar1 != LYS_UNKNOWN) && (true)) {
          switch(LVar1) {
          case LYS_CONTAINER:
switchD_001c18ad_caseD_1:
            if (subroot == (lyd_node *)0x0) {
              lVar2._0_2_ = schema[1].flags;
              lVar2._2_1_ = schema[1].ext_size;
              lVar2._3_1_ = schema[1].iffeature_size;
              lVar2._4_1_ = schema[1].padding[0];
              lVar2._5_1_ = schema[1].padding[1];
              lVar2._6_1_ = schema[1].padding[2];
              lVar2._7_1_ = schema[1].padding[3];
              if (lVar2 != 0) break;
              subroot_local = _lyd_new(last_parent,schema,1);
              subroot_local->validity = subroot_local->validity & 0xfb;
              if (unres->store_diff != 0) {
                iVar5 = unres_data_diff_new(unres,subroot_local,(lyd_node *)0x0,1);
                if (iVar5 != 0) goto LAB_001c1fcd;
                bVar4 = true;
                unres->store_diff = 0;
              }
              if (last_parent == (lyd_node *)0x0) {
                if (*root == (lyd_node *)0x0) {
                  *root = subroot_local;
                }
                else {
                  lyd_insert_common((*root)->parent,root,subroot_local,0);
                }
              }
              last_parent_local = subroot_local;
              if ((check_when_must != 0) &&
                 (((((byte)subroot_local->field_0x9 >> 1 & 4) != 0 &&
                   (iVar5 = unres_data_add(unres,subroot_local,UNRES_WHEN), iVar5 == -1)) ||
                  ((check_when_must == 2 &&
                   (((uVar6 = resolve_applies_must(subroot_local), (uVar6 & 1) != 0 &&
                     (iVar5 = unres_data_add(unres,subroot_local,UNRES_MUST), iVar5 == -1)) ||
                    (((uVar6 & 2) != 0 &&
                     (iVar5 = unres_data_add(unres,subroot_local,UNRES_MUST_INOUT), iVar5 == -1)))))
                   ))))) goto LAB_001c1fcd;
            }
            else {
              lVar3._0_2_ = schema[1].flags;
              lVar3._2_1_ = schema[1].ext_size;
              lVar3._3_1_ = schema[1].iffeature_size;
              lVar3._4_1_ = schema[1].padding[0];
              lVar3._5_1_ = schema[1].padding[1];
              lVar3._6_1_ = schema[1].padding[2];
              lVar3._7_1_ = schema[1].padding[3];
              if (lVar3 == 0) {
                subroot->field_0x9 = subroot->field_0x9 | 1;
              }
            }
LAB_001c1a62:
            present = ly_set_new();
            if (present == (ly_set *)0x0) goto LAB_001c1fcd;
            for (siter = schema->child; siter != (lys_node *)0x0; siter = siter->next) {
              if ((siter->nodetype & (LYS_CHOICE|LYS_USES)) == LYS_UNKNOWN) {
                if ((siter->nodetype & (LYS_CONTAINER|LYS_LEAF|LYS_LEAFLIST|LYS_LIST|LYS_ANYDATA))
                    != LYS_UNKNOWN) {
                  if ((subroot_local == (lyd_node *)0x0) ||
                     (iVar5 = lyd_get_node_siblings(subroot_local->child,siter,present), iVar5 == 0)
                     ) {
                    iVar5 = lyd_wd_add_subtree(root,last_parent_local,(lyd_node *)0x0,siter,toplevel
                                               ,options,unres);
                    goto joined_r0x001c1c8b;
                  }
                  if ((siter->nodetype & LYS_LEAFLIST) == LYS_UNKNOWN) {
                    if (siter->nodetype != LYS_LEAF) {
                      for (i = 0; i < (int)present->number; i = i + 1) {
                        iVar5 = lyd_wd_add_subtree(root,(lyd_node *)(present->set).s[i],
                                                   (lyd_node *)(present->set).s[i],siter,toplevel,
                                                   options,unres);
                        if (iVar5 != 0) goto LAB_001c1fcd;
                      }
                    }
                  }
                  else {
                    lyd_wd_leaflist_cleanup(present,unres);
                  }
                  if ((subroot_local->field_0x9 & 1) != 0) {
                    i = 0;
LAB_001c1c39:
                    if (i < (int)present->number) {
                      if ((*(byte *)((long)&(present->set).s[i]->dsc + 1) & 1) != 0)
                      goto LAB_001c1c35;
                      for (iter = subroot_local;
                          (iter != (lyd_node *)0x0 && ((iter->field_0x9 & 1) != 0));
                          iter = iter->parent) {
                        iter->field_0x9 = iter->field_0x9 & 0xfe;
                      }
                    }
                  }
                  ly_set_clean(present);
                }
              }
              else {
                iVar5 = lyd_wd_add_subtree(root,last_parent_local,subroot_local,siter,toplevel,
                                           options,unres);
joined_r0x001c1c8b:
                if (iVar5 != 0) goto LAB_001c1fcd;
              }
            }
            if (bVar4) {
              unres->store_diff = 1;
            }
            break;
          case LYS_CHOICE:
            iter = (lyd_node *)0x0;
            if (((toplevel != 0) && (*root != (lyd_node *)0x0)) ||
               ((toplevel == 0 && (subroot != (lyd_node *)0x0)))) {
              if (toplevel == 0) {
                iter = subroot->child;
              }
              else {
                iter = *root;
              }
              for (; iter != (lyd_node *)0x0; iter = iter->next) {
                siter = lys_parent(iter->schema);
                siter_prev = iter->schema;
                for (; ((siter != (lys_node *)0x0 && ((siter->nodetype & 0x1042) != LYS_UNKNOWN)) &&
                       (siter != schema)); siter = lys_parent(siter)) {
                  siter_prev = siter;
                }
                if (siter == schema) break;
              }
            }
            if (iter == (lyd_node *)0x0) {
              if (schema[1].name == (char *)0x0) break;
              iVar5 = lyd_wd_add_subtree(root,last_parent,subroot,(lys_node *)schema[1].name,
                                         toplevel,options,unres);
            }
            else {
              if ((siter == (lys_node *)0x0) || (siter_prev == (lys_node *)0x0)) {
                    // WARNING: Subroutine does not return
                __assert_fail("siter && siter_prev",
                              "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                              ,0x1dc0,"lyd_wd_add_subtree");
              }
              iVar5 = lyd_wd_add_subtree(root,last_parent,subroot,siter_prev,toplevel,options,unres)
              ;
            }
joined_r0x001c1dfd:
            if (iVar5 != 0) goto LAB_001c1fcd;
            break;
          case LYS_LEAF:
          case LYS_LEAFLIST:
            if (subroot != (lyd_node *)0x0) {
              present = ly_set_new();
              if (present == (ly_set *)0x0) goto LAB_001c1fcd;
              lyd_get_node_siblings(subroot->child,schema,present);
              if (present->number != 0) {
                if ((subroot->field_0x9 & 1) != 0) {
                  for (i = 0; i < (int)present->number; i = i + 1) {
                    iter = subroot;
                    if ((*(byte *)((long)&(present->set).s[i]->dsc + 1) & 1) == 0)
                    goto LAB_001c1d6e;
                  }
                }
                break;
              }
            }
            if (schema->nodetype != LYS_LEAF) {
              iVar5 = lyd_wd_add_leaflist(root,last_parent,(lys_node_leaflist *)schema,unres,
                                          check_when_must);
              goto joined_r0x001c1dfd;
            }
            iVar5 = lyd_wd_add_leaf(root,last_parent,(lys_node_leaf *)schema,unres,check_when_must);
            if (iVar5 != 0) {
              return 1;
            }
            break;
          case LYS_LIST:
            if (subroot != (lyd_node *)0x0) goto switchD_001c18ad_caseD_1;
          }
        }
      }
      else if (LVar1 == LYS_CASE) goto LAB_001c1a62;
    }
LAB_001c1f9b:
    ly_set_free(present);
    iVar5 = 0;
  }
  else {
    present = ly_set_new();
    if (present != (ly_set *)0x0) {
      if ((*root != (lyd_node *)0x0) &&
         (iVar5 = lyd_get_node_siblings(*root,schema,present), iVar5 != 0)) {
        for (i = 0; i < (int)present->number; i = i + 1) {
          if ((schema->nodetype & LYS_LEAFLIST) == LYS_UNKNOWN) {
            if ((schema->nodetype != LYS_LEAF) &&
               (iVar5 = lyd_wd_add_subtree(root,(lyd_node *)(present->set).s[i],
                                           (lyd_node *)(present->set).s[i],schema,0,options,unres),
               iVar5 != 0)) goto LAB_001c1fcd;
          }
          else {
            lyd_wd_leaflist_cleanup(present,unres);
          }
        }
LAB_001c1751:
        ly_set_free(present);
        return 0;
      }
      iVar5 = lyd_wd_add_subtree(root,last_parent,(lyd_node *)0x0,schema,0,options,unres);
      if (iVar5 == 0) goto LAB_001c1751;
    }
LAB_001c1fcd:
    ly_set_free(present);
    iVar5 = 1;
  }
  return iVar5;
LAB_001c1d6e:
  for (; (iter != (lyd_node *)0x0 && ((iter->field_0x9 & 1) != 0)); iter = iter->parent) {
    iter->field_0x9 = iter->field_0x9 & 0xfe;
  }
  goto LAB_001c1f9b;
LAB_001c1c35:
  i = i + 1;
  goto LAB_001c1c39;
}



int lyd_wd_add(lyd_node **root,ly_ctx *ctx,lys_module **modules,int mod_count,unres_data *unres,
              int options)

{
  int iVar1;
  unres_data *unres_local;
  int options_local;
  int mod_count_local;
  lys_module **modules_local;
  ly_ctx *ctx_local;
  lyd_node **root_local;
  int i;
  lys_node *siter;
  
  if ((root == (lyd_node **)0x0) || ((options & 0x100U) != 0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("root && !(options & LYD_OPT_ACT_NOTIF)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x1de3,"lyd_wd_add");
  }
  if ((*root == (lyd_node *)0x0) && (ctx == (ly_ctx *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("*root || ctx",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x1de4,"lyd_wd_add");
  }
  if (((options & 0x1000U) != 0) && (*root == (lyd_node *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("!(options & LYD_OPT_NOSIBLINGS) || *root",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x1de5,"lyd_wd_add");
  }
  if ((options & 0xeU) != 0) {
    return 0;
  }
  ctx_local = ctx;
  if (ctx == (ly_ctx *)0x0) {
    ctx_local = (*root)->schema->module->ctx;
  }
  if (((options & 0x10000ffU) == 0) || ((options & 1U) != 0)) {
    if ((options & 0x1000U) == 0) {
      if ((modules == (lys_module **)0x0) || (mod_count == 0)) {
        for (i = 0; i < (ctx_local->models).used; i = i + 1) {
          if ((((ctx_local->models).list[i]->field_0x40 & 0x80) != 0) &&
             (((ctx_local->models).list[i]->field_0x40 & 0x40) == 0)) {
            for (siter = (ctx_local->models).list[i]->data; siter != (lys_node *)0x0;
                siter = siter->next) {
              if (((siter->nodetype & 0x903f) != LYS_UNKNOWN) &&
                 (iVar1 = lyd_wd_add_subtree(root,(lyd_node *)0x0,(lyd_node *)0x0,siter,1,options,
                                             unres), iVar1 != 0)) {
                return 1;
              }
            }
          }
        }
      }
      else {
        for (i = 0; i < mod_count; i = i + 1) {
          for (siter = modules[i]->data; siter != (lys_node *)0x0; siter = siter->next) {
            if (((siter->nodetype & 0x903f) != LYS_UNKNOWN) &&
               (iVar1 = lyd_wd_add_subtree(root,(lyd_node *)0x0,(lyd_node *)0x0,siter,1,options,
                                           unres), iVar1 != 0)) {
              return 1;
            }
          }
        }
      }
    }
    else {
      iVar1 = lyd_wd_add_subtree(root,(lyd_node *)0x0,(lyd_node *)0x0,(*root)->schema,1,options,
                                 unres);
      if (iVar1 != 0) {
        return 1;
      }
    }
  }
  else if ((options & 0x40U) == 0) {
    if ((options & 0x30U) == 0) {
      if ((options & 0x1000000U) == 0) {
        ly_log(ctx_local,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
               ,0x1e2e);
        return 1;
      }
      iVar1 = lyd_wd_add_subtree(root,(lyd_node *)0x0,(lyd_node *)0x0,(*root)->schema,1,options,
                                 unres);
      if (iVar1 != 0) {
        return 1;
      }
    }
    else {
      if ((*root == (lyd_node *)0x0) || (((*root)->schema->nodetype & 0x4100) == LYS_UNKNOWN)) {
        ly_log(ctx_local,LY_LLERR,LY_EINVAL,"Subtree is not a single RPC/action/reply.");
        return 1;
      }
      if ((options & 0x10U) == 0) {
        for (siter = (*root)->schema->child;
            (siter != (lys_node *)0x0 && (siter->nodetype != LYS_OUTPUT)); siter = siter->next) {
        }
      }
      else {
        for (siter = (*root)->schema->child;
            (siter != (lys_node *)0x0 && (siter->nodetype != LYS_INPUT)); siter = siter->next) {
        }
      }
      if ((siter != (lys_node *)0x0) &&
         (iVar1 = lyd_wd_add_subtree(root,*root,*root,siter,0,options,unres), iVar1 != 0)) {
        return 1;
      }
    }
  }
  else {
    if ((*root == (lyd_node *)0x0) || ((*root)->schema->nodetype != LYS_NOTIF)) {
      ly_log(ctx_local,LY_LLERR,LY_EINVAL,"Subtree is not a single notification.");
      return 1;
    }
    iVar1 = lyd_wd_add_subtree(root,*root,*root,(*root)->schema,0,options,unres);
    if (iVar1 != 0) {
      return 1;
    }
  }
  return 0;
}



int lyd_defaults_add_unres
              (lyd_node **root,int options,ly_ctx *ctx,lys_module **modules,int mod_count,
              lyd_node *data_tree,lyd_node *act_notif,unres_data *unres,int wd)

{
  lyd_node *plVar1;
  int iVar2;
  lyd_node **root_00;
  lyd_node *data_tree_local;
  lys_module **modules_local;
  ly_ctx *ctx_local;
  int mod_count_local;
  int options_local;
  lyd_node **root_local;
  int ret;
  lyd_node *msg_sibling;
  lyd_node *msg_parent;
  lyd_node *data_tree_sibling;
  lyd_node *data_tree_parent;
  lys_node *msg_op;
  ly_set *set;
  
  msg_sibling = (lyd_node *)0x0;
  msg_parent = (lyd_node *)0x0;
  msg_op = (lys_node *)0x0;
  ret = 1;
  if (((root == (lyd_node **)0x0) ||
      (((*root == (lyd_node *)0x0 && (ctx == (ly_ctx *)0x0)) || (unres == (unres_data *)0x0)))) ||
     ((options & 0x100U) != 0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("root && (*root || ctx) && unres && !(options & LYD_OPT_ACT_NOTIF)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                  ,0x1e3f,"lyd_defaults_add_unres");
  }
  ctx_local = ctx;
  if (ctx == (ly_ctx *)0x0) {
    ctx_local = (*root)->schema->module->ctx;
  }
  if (((options & 0x1000U) != 0) && (*root == (lyd_node *)0x0)) {
    ly_log(ctx_local,LY_LLERR,LY_EINVAL,
           "Cannot add default values for one module (LYD_OPT_NOSIBLINGS) without any data.");
    return 1;
  }
  options_local = options;
  if ((options & 0x70U) == 0) {
    if ((*root != (lyd_node *)0x0) && ((*root)->parent != (lyd_node *)0x0)) {
      options_local = options | 0x1000;
    }
  }
  else {
    if (*root == (lyd_node *)0x0) {
      ly_log(ctx_local,LY_LLERR,LY_EINVAL,
             "Cannot add default values to RPC, RPC reply, and notification without at least the empty container."
            );
      return 1;
    }
    if ((((options & 0x10U) != 0) && (act_notif == (lyd_node *)0x0)) &&
       ((*root)->schema->nodetype != LYS_RPC)) {
      ly_log(ctx_local,LY_LLERR,LY_EINVAL,"Not valid RPC/action data.");
      return 1;
    }
    if ((((options & 0x20U) != 0) && (act_notif == (lyd_node *)0x0)) &&
       ((*root)->schema->nodetype != LYS_RPC)) {
      ly_log(ctx_local,LY_LLERR,LY_EINVAL,"Not valid reply data.");
      return 1;
    }
    if ((((options & 0x40U) != 0) && (act_notif == (lyd_node *)0x0)) &&
       ((*root)->schema->nodetype != LYS_NOTIF)) {
      ly_log(ctx_local,LY_LLERR,LY_EINVAL,"Not valid notification data.");
      return 1;
    }
    if (act_notif == (lyd_node *)0x0) {
      msg_op = (*root)->schema;
    }
    else {
      msg_op = act_notif->schema;
    }
  }
  if (wd != 0) {
    root_00 = root;
    if (act_notif != (lyd_node *)0x0) {
      root_00 = &act_notif;
    }
    iVar2 = lyd_wd_add(root_00,ctx_local,modules,mod_count,unres,options_local);
    if (iVar2 != 0) {
      return 1;
    }
  }
  if ((unres == (unres_data *)0x0) || (unres->count == 0)) {
    return 0;
  }
  if (*root == (lyd_node *)0x0) {
    ly_log(ctx_local,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
           ,0x1e6d);
    return 1;
  }
  if ((data_tree != (lyd_node *)0x0) && ((options_local & 0x70U) != 0)) {
    msg_parent = (lyd_node *)0x0;
    msg_sibling = *root;
    if (act_notif == (lyd_node *)0x0) {
      data_tree_parent = (lyd_node *)0x0;
      data_tree_sibling = data_tree;
    }
    else {
      data_tree_parent = (lyd_node *)0x0;
      plVar1 = data_tree;
      do {
        do {
          data_tree_sibling = plVar1;
          if (data_tree_sibling == (lyd_node *)0x0) goto LAB_001c2a70;
          while ((data_tree_sibling != (lyd_node *)0x0 &&
                 ((data_tree_sibling->schema != msg_sibling->schema ||
                  ((msg_sibling->schema->nodetype == LYS_LIST &&
                   (iVar2 = lyd_list_equal(data_tree_sibling,msg_sibling,0), iVar2 == 0))))))) {
            data_tree_sibling = data_tree_sibling->next;
          }
          plVar1 = data_tree_sibling;
        } while (data_tree_sibling == (lyd_node *)0x0);
        data_tree_parent = data_tree_sibling;
        msg_parent = msg_sibling;
        if (msg_sibling->child == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
          __assert_fail("msg_sibling->child",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                        ,0x1e8e,"lyd_defaults_add_unres");
        }
        msg_sibling = msg_sibling->child;
        while (msg_sibling->schema->nodetype == LYS_LEAF) {
          if (msg_sibling->next == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
            __assert_fail("msg_sibling->next",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                          ,0x1e92,"lyd_defaults_add_unres");
          }
          msg_sibling = msg_sibling->next;
        }
        plVar1 = data_tree_sibling->child;
      } while ((msg_sibling->schema->nodetype & 0x4080) == LYS_UNKNOWN);
      if (act_notif->parent == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("act_notif->parent",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x1e96,"lyd_defaults_add_unres");
      }
      if (act_notif->parent->schema != data_tree_sibling->schema) {
                    // WARNING: Subroutine does not return
        __assert_fail("act_notif->parent->schema == data_tree_parent->schema",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x1e97,"lyd_defaults_add_unres");
      }
      data_tree_sibling = data_tree_sibling->child;
      if (msg_sibling != act_notif) {
                    // WARNING: Subroutine does not return
        __assert_fail("msg_sibling == act_notif",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x1e98,"lyd_defaults_add_unres");
      }
LAB_001c2a70:
      if (data_tree_parent == (lyd_node *)0x0) {
        data_tree_sibling = data_tree;
      }
    }
    lyd_unlink_internal(msg_sibling,0);
    if ((data_tree_parent == (lyd_node *)0x0) && (data_tree_sibling == (lyd_node *)0x0)) {
                    // WARNING: Subroutine does not return
      __assert_fail("data_tree_parent || data_tree_sibling",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                    ,0x1ead,"lyd_defaults_add_unres");
    }
    if (data_tree_parent == (lyd_node *)0x0) {
      if (data_tree_sibling->parent != (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("!data_tree_sibling->parent",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x1eb3,"lyd_defaults_add_unres");
      }
      iVar2 = lyd_insert_nextto(data_tree_sibling->prev,msg_sibling,0,0);
    }
    else {
      iVar2 = lyd_insert_common(data_tree_parent,(lyd_node **)0x0,msg_sibling,0);
    }
    if (iVar2 != 0) goto LAB_001c2cb5;
  }
  iVar2 = resolve_unres_data(ctx_local,unres,root,options_local);
  if ((iVar2 == 0) && (ret = 0, (options_local & 0x70U) != 0)) {
    set = (ly_set *)0x0;
    if (data_tree == (lyd_node *)0x0) {
      if ((*root != (lyd_node *)0x0) &&
         ((set = lyd_find_instance(*root,msg_op), set == (ly_set *)0x0 ||
          ((set->number != 0 && (set->number != 1)))))) {
                    // WARNING: Subroutine does not return
        __assert_fail("set && ((set->number == 0) || (set->number == 1))",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x1ec9,"lyd_defaults_add_unres");
      }
    }
    else {
      if (data_tree_parent != (lyd_node *)0x0) {
        data_tree_sibling = data_tree_parent;
      }
      set = lyd_find_instance(data_tree_sibling,msg_op);
      if ((set == (ly_set *)0x0) || ((set->number != 0 && (set->number != 1)))) {
                    // WARNING: Subroutine does not return
        __assert_fail("set && ((set->number == 0) || (set->number == 1))",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/tree_data.c"
                      ,0x1ec6,"lyd_defaults_add_unres");
      }
    }
    if ((set == (ly_set *)0x0) || (set->number == 0)) {
      ly_vlog(ctx_local,LYE_SPEC,LY_VLOG_LYS,msg_op,
              "Operation/notification not supported because of the current configuration.");
      ret = 1;
    }
    ly_set_free(set);
  }
LAB_001c2cb5:
  if (((data_tree != (lyd_node *)0x0) && ((options_local & 0x70U) != 0)) &&
     (lyd_unlink_internal(msg_sibling,0), msg_parent != (lyd_node *)0x0)) {
    lyd_insert_common(msg_parent,(lyd_node **)0x0,msg_sibling,0);
  }
  return ret;
}



lys_module * lyd_node_module(lyd_node *node)

{
  lys_module *plVar1;
  lyd_node *node_local;
  
  ly_log_dbg(0x20,"%s","lyd_node_module");
  if (node == (lyd_node *)0x0) {
    plVar1 = (lys_module *)0x0;
  }
  else if ((node->schema->module->field_0x40 & 1) == 0) {
    plVar1 = node->schema->module;
  }
  else {
    plVar1 = (lys_module *)node->schema->module->data;
  }
  return plVar1;
}



double lyd_dec64_to_double(lyd_node *node)

{
  double dVar1;
  lyd_node *node_local;
  
  ly_log_dbg(0x20,"%s","lyd_dec64_to_double");
  if (((node == (lyd_node *)0x0) ||
      ((node->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN)) ||
     (*(int *)&node->schema[1].ref != 4)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_dec64_to_double");
    dVar1 = 0.0;
  }
  else {
    dVar1 = atof((char *)node->ht);
  }
  return dVar1;
}



lys_type * lyd_leaf_type(lyd_node_leaf_list *leaf)

{
  int iVar1;
  lys_type *plVar2;
  long in_FS_OFFSET;
  lyd_node_leaf_list *leaf_local;
  lys_type *type;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ly_log_dbg(0x20,"%s","lyd_leaf_type");
  if ((leaf == (lyd_node_leaf_list *)0x0) ||
     ((leaf->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN)) {
    plVar2 = (lys_type *)0x0;
  }
  else {
    type = (lys_type *)&leaf->schema[1].ref;
    do {
      if (type->base == LY_TYPE_LEAFREF) {
        type = &((type->info).lref.target)->type;
      }
      else if (type->base == LY_TYPE_UNION) {
        if (((type->info).uni.has_ptr_type != 0) && (leaf->validity != '\0')) {
          ly_vlog(leaf->schema->module->ctx,LYE_SPEC,LY_VLOG_LYD,leaf,
                  "Unable to determine the type of value \"%s\" from union type \"%s\" prior to validation."
                  ,leaf->value_str,type->der->name);
          plVar2 = (lys_type *)0x0;
          break;
        }
        iVar1 = resolve_union(leaf,type,0,0,&type);
        if (iVar1 != 0) {
          plVar2 = (lys_type *)0x0;
          break;
        }
      }
      plVar2 = type;
    } while (type->base == LY_TYPE_LEAFREF);
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return plVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

char ** ly_get_loaded_plugins(void)

{
  ly_log_dbg(0x20,"%s","ly_get_loaded_plugins");
  return loaded_plugins;
}



// WARNING: Unknown calling convention

int ly_clean_plugins(void)

{
  uint u;
  int ret;
  
  ly_log_dbg(0x20,"%s","ly_clean_plugins");
  ret = 0;
  pthread_mutex_lock((pthread_mutex_t *)&plugins_lock);
  plugin_refs = plugin_refs - 1;
  if (plugin_refs == 0) {
    if ((ext_plugins_count != 0) || (type_plugins_count != 0)) {
      free(ext_plugins);
      ext_plugins = (lyext_plugin_list *)0x0;
      ext_plugins_count = 0;
      free(type_plugins);
      type_plugins = (lytype_plugin_list *)0x0;
      type_plugins_count = 0;
      for (u = 0; u < loaded_plugins_count; u = u + 1) {
        free(loaded_plugins[u]);
      }
      free(loaded_plugins);
      loaded_plugins = (char **)0x0;
      loaded_plugins_count = 0;
      for (u = 0; u < dlhandlers.number; u = u + 1) {
        dlclose(dlhandlers.set.s[u]);
      }
      free(dlhandlers.set.s);
      dlhandlers.set.s = (lys_node **)0x0;
      dlhandlers.size = 0;
      dlhandlers.number = 0;
    }
  }
  else {
    ret = 1;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&plugins_lock);
  return ret;
}



int lytype_load_plugin(void *dlhandler,char *file_name)

{
  int iVar1;
  lytype_plugin_list *plugin_00;
  long lVar2;
  uint *puVar3;
  ulong uVar4;
  char *file_name_local;
  void *dlhandler_local;
  lytype_plugin_list *plugin;
  char *str;
  int *version;
  
  plugin_00 = (lytype_plugin_list *)dlsym(dlhandler,file_name);
  lVar2 = dlerror();
  if (lVar2 == 0) {
    puVar3 = (uint *)dlsym(dlhandler,"lytype_api_version");
    lVar2 = dlerror();
    if ((lVar2 == 0) && (*puVar3 == 1)) {
      iVar1 = ly_register_types(plugin_00,file_name);
    }
    else {
      if (puVar3 == (uint *)0x0) {
        uVar4 = 0;
      }
      else {
        uVar4 = (ulong)*puVar3;
      }
      ly_log((ly_ctx *)0x0,LY_LLWRN,LY_SUCCESS,
             "Processing \"%s\" user type plugin failed, wrong API version - %d expected, %d found."
             ,file_name,1,uVar4);
      iVar1 = 1;
    }
  }
  else {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_ESYS,
           "Processing \"%s\" user type plugin failed, missing plugin list object (%s).",file_name,
           lVar2);
    iVar1 = 1;
  }
  return iVar1;
}



int ly_register_types(lytype_plugin_list *plugin,char *log_name)

{
  int iVar1;
  lytype_plugin_list *plVar2;
  undefined *puVar3;
  char *pcVar4;
  char *log_name_local;
  lytype_plugin_list *plugin_local;
  uint32_t u;
  uint32_t v;
  lytype_plugin_list *p;
  
  ly_log_dbg(0x20,"%s","ly_register_types");
  u = 0;
  do {
    if (plugin[u].name == (char *)0x0) {
      plVar2 = (lytype_plugin_list *)realloc(type_plugins,(ulong)(u + type_plugins_count) * 0x28);
      if (plVar2 == (lytype_plugin_list *)0x0) {
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_register_types"
              );
        iVar1 = -1;
      }
      else {
        for (; type_plugins = plVar2, u != 0; u = u - 1) {
          memcpy(type_plugins + type_plugins_count,plugin + (u - 1),0x28);
          type_plugins_count = type_plugins_count + 1;
          plVar2 = type_plugins;
        }
        iVar1 = 0;
      }
      return iVar1;
    }
    for (v = 0; v < type_plugins_count; v = v + 1) {
      iVar1 = strcmp(plugin[u].name,type_plugins[v].name);
      if (((iVar1 == 0) && (iVar1 = strcmp(plugin[u].module,type_plugins[v].module), iVar1 == 0)) &&
         ((plugin[u].revision == (char *)0x0 ||
          ((type_plugins[v].revision == (char *)0x0 ||
           (iVar1 = strcmp(plugin[u].revision,type_plugins[v].revision), iVar1 == 0)))))) {
        if (plugin[u].revision == (char *)0x0) {
          pcVar4 = "";
        }
        else {
          pcVar4 = plugin[u].revision;
        }
        if (plugin[u].revision == (char *)0x0) {
          puVar3 = &DAT_00229bdc;
        }
        else {
          puVar3 = &DAT_00229bdd;
        }
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_ESYS,
               "Processing \"%s\" extension plugin failed,implementation collision for extension %s from module %s%s%s."
               ,log_name,plugin[u].name,plugin[u].module,puVar3,pcVar4);
        return 1;
      }
    }
    u = u + 1;
  } while( true );
}



int lyext_load_plugin(void *dlhandler,char *file_name)

{
  int iVar1;
  lyext_plugin_list *plugin_00;
  long lVar2;
  uint *puVar3;
  ulong uVar4;
  char *file_name_local;
  void *dlhandler_local;
  lyext_plugin_list *plugin;
  char *str;
  int *version;
  
  plugin_00 = (lyext_plugin_list *)dlsym(dlhandler,file_name);
  lVar2 = dlerror();
  if (lVar2 == 0) {
    puVar3 = (uint *)dlsym(dlhandler,"lyext_api_version");
    lVar2 = dlerror();
    if ((lVar2 == 0) && (*puVar3 == 1)) {
      iVar1 = ly_register_exts(plugin_00,file_name);
    }
    else {
      if (puVar3 == (uint *)0x0) {
        uVar4 = 0;
      }
      else {
        uVar4 = (ulong)*puVar3;
      }
      ly_log((ly_ctx *)0x0,LY_LLWRN,LY_SUCCESS,
             "Processing \"%s\" extension plugin failed, wrong API version - %d expected, %d found."
             ,file_name,1,uVar4);
      iVar1 = 1;
    }
  }
  else {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_ESYS,
           "Processing \"%s\" extension plugin failed, missing plugin list object (%s).",file_name,
           lVar2);
    iVar1 = 1;
  }
  return iVar1;
}



int ly_register_exts(lyext_plugin_list *plugin,char *log_name)

{
  lyext_plugin *plVar1;
  long lVar2;
  int iVar3;
  char *pcVar4;
  lyext_plugin_list *plVar5;
  undefined *puVar6;
  char *log_name_local;
  lyext_plugin_list *plugin_local;
  uint32_t u;
  uint32_t v;
  lyext_plugin_list *p;
  lyext_plugin_complex *pluginc;
  
  ly_log_dbg(0x20,"%s","ly_register_exts");
  u = 0;
  do {
    if (plugin[u].name == (char *)0x0) {
      plVar5 = (lyext_plugin_list *)realloc(ext_plugins,(ulong)(u + ext_plugins_count) << 5);
      if (plVar5 == (lyext_plugin_list *)0x0) {
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_register_exts")
        ;
        iVar3 = -1;
      }
      else {
        for (; ext_plugins = plVar5, u != 0; u = u - 1) {
          memcpy(ext_plugins + ext_plugins_count,plugin + (u - 1),0x20);
          ext_plugins_count = ext_plugins_count + 1;
          plVar5 = ext_plugins;
        }
        iVar3 = 0;
      }
      return iVar3;
    }
    for (v = 0; v < ext_plugins_count; v = v + 1) {
      iVar3 = strcmp(plugin[u].name,ext_plugins[v].name);
      if (((iVar3 == 0) && (iVar3 = strcmp(plugin[u].module,ext_plugins[v].module), iVar3 == 0)) &&
         ((plugin[u].revision == (char *)0x0 ||
          ((ext_plugins[v].revision == (char *)0x0 ||
           (iVar3 = strcmp(plugin[u].revision,ext_plugins[v].revision), iVar3 == 0)))))) {
        if (plugin[u].revision == (char *)0x0) {
          pcVar4 = "";
        }
        else {
          pcVar4 = plugin[u].revision;
        }
        if (plugin[u].revision == (char *)0x0) {
          puVar6 = &DAT_00229bdc;
        }
        else {
          puVar6 = &DAT_00229bdd;
        }
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_ESYS,
               "Processing \"%s\" extension plugin failed,implementation collision for extension %s from module %s%s%s."
               ,log_name,plugin[u].name,plugin[u].module,puVar6,pcVar4);
        return 1;
      }
    }
    if (((plugin[u].plugin)->type == LYEXT_COMPLEX) &&
       (plVar1 = plugin[u].plugin, lVar2._0_4_ = plVar1[1].type, lVar2._4_2_ = plVar1[1].flags,
       lVar2._6_2_ = *(undefined2 *)&plVar1[1].field_0x6, lVar2 != 0)) {
      plVar1 = plugin[u].plugin;
      v = 0;
      while (*(int *)((ulong)v * 0x18 + *(long *)(plVar1 + 1)) != 0) {
        if (((0x37 < *(int *)((ulong)v * 0x18 + *(long *)(plVar1 + 1))) ||
            (*(int *)((ulong)v * 0x18 + *(long *)(plVar1 + 1)) == 0x13)) ||
           (*(int *)((ulong)v * 0x18 + *(long *)(plVar1 + 1)) == 0x16)) {
          ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,
                 "Extension plugin \"%s\" (extension %s) allows not supported extension substatement (%s)"
                 ,log_name,plugin[u].name,
                 *(undefined8 *)
                  (ly_stmt_str + (long)*(int *)((ulong)v * 0x18 + *(long *)(plVar1 + 1)) * 8));
          return 1;
        }
        if (((1 < *(uint *)((ulong)v * 0x18 + *(long *)(plVar1 + 1) + 0x10)) &&
            (0x13 < *(int *)((ulong)v * 0x18 + *(long *)(plVar1 + 1)))) &&
           (*(int *)((ulong)v * 0x18 + *(long *)(plVar1 + 1)) < 0x1b)) {
          ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,
                 "Extension plugin \"%s\" (extension %s) allows multiple instances on \"%s\" substatement, which is not supported."
                 ,log_name,plugin[u].name,
                 *(undefined8 *)
                  (ly_stmt_str + (long)*(int *)((ulong)v * 0x18 + *(long *)(plVar1 + 1)) * 8));
          return 1;
        }
        v = v + 1;
      }
    }
    u = u + 1;
  } while( true );
}



void ly_add_loaded_plugin(char *name)

{
  char *name_local;
  
  loaded_plugins = (char **)ly_realloc(loaded_plugins,(long)(int)(loaded_plugins_count + 2) * 8);
  if (loaded_plugins == (char **)0x0) {
    free(name);
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_add_loaded_plugin")
    ;
  }
  else {
    loaded_plugins_count = loaded_plugins_count + 1;
    loaded_plugins[(ulong)loaded_plugins_count - 1] = name;
    loaded_plugins[loaded_plugins_count] = (char *)0x0;
  }
  return;
}



void ly_load_plugins_dir(DIR *dir,char *dir_path,int ext_or_type)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int ext_or_type_local;
  char *dir_path_local;
  DIR *dir_local;
  int ret;
  char *str;
  dirent *file;
  size_t len;
  void *dlhandler;
  char *name;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  do {
    while( true ) {
      while( true ) {
        do {
          file = (dirent *)readdir((DIR *)dir);
          if (file == (dirent *)0x0) goto LAB_001c3ffd;
          len = strlen(((dirent *)file)->d_name);
        } while ((len < 4) || (iVar1 = strcmp(file->d_name + (len - 3),".so"), iVar1 != 0));
        iVar1 = asprintf(&str,"%s/%s",dir_path,file->d_name);
        if (iVar1 == -1) {
          ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "ly_load_plugins_dir");
          goto LAB_001c3ffd;
        }
        dlhandler = (void *)dlopen(str,2);
        if (dlhandler != (void *)0x0) break;
        uVar2 = dlerror();
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_ESYS,"Loading \"%s\" as a plugin failed (%s).",str,uVar2);
        free(str);
      }
      iVar1 = ly_set_contains(&dlhandlers,dlhandler);
      if (iVar1 == -1) break;
      ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,"Plugin \"%s\" already loaded.",str);
      free(str);
      dlclose(dlhandler);
    }
    dlerror();
    name = strndup(file->d_name,len - 3);
    if (name == (char *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_load_plugins_dir"
            );
      dlclose(dlhandler);
      free(str);
      break;
    }
    if (ext_or_type == 0) {
      ret = lytype_load_plugin(dlhandler,name);
    }
    else {
      ret = lyext_load_plugin(dlhandler,name);
    }
    if (ret == 0) {
      ly_log((ly_ctx *)0x0,LY_LLVRB,LY_SUCCESS,"Plugin \"%s\" successfully loaded.",str);
      ly_add_loaded_plugin(name);
      ly_set_add(&dlhandlers,dlhandler,1);
    }
    else {
      free(name);
      dlclose(dlhandler);
    }
    free(str);
  } while (ret != -1);
LAB_001c3ffd:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ly_load_plugins(void)

{
  DIR *pDVar1;
  int *piVar2;
  char *pcVar3;
  char *pluginsdir;
  DIR *dir;
  
  ly_log_dbg(0x20,"%s","ly_load_plugins");
  pthread_mutex_lock((pthread_mutex_t *)&plugins_lock);
  plugin_refs = plugin_refs + 1;
  pluginsdir = getenv("LIBYANG_EXTENSIONS_PLUGINS_DIR");
  if (pluginsdir == (char *)0x0) {
    pluginsdir = "/usr/local/lib/libyang/extensions";
  }
  pDVar1 = opendir(pluginsdir);
  if (pDVar1 == (DIR *)0x0) {
    piVar2 = __errno_location();
    pcVar3 = strerror(*piVar2);
    ly_log((ly_ctx *)0x0,LY_LLWRN,LY_SUCCESS,
           "Failed to open libyang extensions plugins directory \"%s\" (%s).",pluginsdir,pcVar3);
  }
  else {
    ly_load_plugins_dir((DIR *)pDVar1,pluginsdir,1);
    closedir(pDVar1);
  }
  pluginsdir = getenv("LIBYANG_USER_TYPES_PLUGINS_DIR");
  if (pluginsdir == (char *)0x0) {
    pluginsdir = "/usr/local/lib/libyang/user_types";
  }
  pDVar1 = opendir(pluginsdir);
  if (pDVar1 == (DIR *)0x0) {
    piVar2 = __errno_location();
    pcVar3 = strerror(*piVar2);
    ly_log((ly_ctx *)0x0,LY_LLWRN,LY_SUCCESS,
           "Failed to open libyang user types plugins directory \"%s\" (%s).",pluginsdir,pcVar3);
  }
  else {
    ly_load_plugins_dir((DIR *)pDVar1,pluginsdir,0);
    closedir(pDVar1);
  }
  pthread_mutex_unlock((pthread_mutex_t *)&plugins_lock);
  return;
}



lyext_plugin * ext_get_plugin(char *name,char *module,char *revision)

{
  int iVar1;
  char *revision_local;
  char *module_local;
  char *name_local;
  uint16_t u;
  
  if (name == (char *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("name",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/plugins.c"
                  ,0x1c8,"ext_get_plugin");
  }
  if (module != (char *)0x0) {
    u = 0;
    while( true ) {
      if (ext_plugins_count <= u) {
        return (lyext_plugin *)0x0;
      }
      iVar1 = strcmp(name,ext_plugins[u].name);
      if (((iVar1 == 0) && (iVar1 = strcmp(module,ext_plugins[u].module), iVar1 == 0)) &&
         ((ext_plugins[u].revision == (char *)0x0 ||
          (iVar1 = strcmp(revision,ext_plugins[u].revision), iVar1 == 0)))) break;
      u = u + 1;
    }
    return ext_plugins[u].plugin;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("module",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/plugins.c"
                ,0x1c9,"ext_get_plugin");
}



int lys_ext_instance_presence(lys_ext *def,lys_ext_instance **ext,uint8_t ext_size)

{
  char *s2;
  int iVar1;
  lys_module *plVar2;
  uint8_t ext_size_local;
  lys_ext_instance **ext_local;
  lys_ext *def_local;
  uint8_t index;
  
  ly_log_dbg(0x20,"%s","lys_ext_instance_presence");
  if ((def == (lys_ext *)0x0) || ((ext_size != '\0' && (ext == (lys_ext_instance **)0x0)))) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_ext_instance_presence")
    ;
  }
  else {
    for (index = '\0'; index < ext_size; index = index + '\x01') {
      if (ext[index]->module->ctx == def->module->ctx) {
        if (def == ext[index]->def) {
          return (uint)index;
        }
      }
      else {
        iVar1 = ly_strequal_(ext[index]->def->name,def->name);
        if (iVar1 != 0) {
          plVar2 = lys_main_module(def->module);
          s2 = plVar2->name;
          plVar2 = lys_main_module(ext[index]->def->module);
          iVar1 = ly_strequal_(plVar2->name,s2);
          if (iVar1 != 0) {
            return (uint)index;
          }
        }
      }
    }
  }
  return -1;
}



void * lys_ext_complex_get_substmt(LY_STMT stmt,lys_ext_instance_complex *ext,lyext_substmt **info)

{
  char *pcVar1;
  lyext_substmt **info_local;
  lys_ext_instance_complex *ext_local;
  LY_STMT stmt_local;
  int i;
  
  ly_log_dbg(0x20,"%s","lys_ext_complex_get_substmt");
  if ((((ext == (lys_ext_instance_complex *)0x0) || (ext->def == (lys_ext *)0x0)) ||
      (ext->def->plugin == (lyext_plugin *)0x0)) || (ext->def->plugin->type != LYEXT_COMPLEX)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).",
           "lys_ext_complex_get_substmt");
    pcVar1 = (char *)0x0;
  }
  else if (ext->substmt == (lyext_substmt *)0x0) {
    if (info != (lyext_substmt **)0x0) {
      *info = (lyext_substmt *)0x0;
    }
    pcVar1 = (char *)0x0;
  }
  else {
    i = 0;
    while (ext->substmt[i].stmt != LY_STMT_UNKNOWN) {
      if (stmt == LY_STMT_NODE) {
        if ((LY_STMT_MODULE < ext->substmt[i].stmt) && (ext->substmt[i].stmt < LY_STMT_TYPEDEF)) {
          if (info != (lyext_substmt **)0x0) {
            *info = ext->substmt + i;
          }
          break;
        }
      }
      else if (stmt == ext->substmt[i].stmt) {
        if (info != (lyext_substmt **)0x0) {
          *info = ext->substmt + i;
        }
        break;
      }
      i = i + 1;
    }
    if (ext->substmt[i].stmt == LY_STMT_UNKNOWN) {
      pcVar1 = (char *)0x0;
    }
    else {
      pcVar1 = ext->content + ext->substmt[i].offset;
    }
  }
  return pcVar1;
}



LY_STMT lys_snode2stmt(LYS_NODE nodetype)

{
  LYS_NODE nodetype_local;
  
  if (nodetype != LYS_ANYDATA) {
    if (nodetype < (LYS_CONTAINER|LYS_ANYDATA)) {
      if (nodetype == LYS_ACTION) {
        return LY_STMT_ACTION;
      }
      if (nodetype < (LYS_CONTAINER|LYS_ACTION)) {
        if (nodetype == LYS_AUGMENT) {
          return LY_STMT_AUGMENT;
        }
        if (nodetype < (LYS_CONTAINER|LYS_AUGMENT)) {
          if (nodetype == LYS_USES) {
            return LY_STMT_USES;
          }
          if (nodetype < (LYS_CONTAINER|LYS_USES)) {
            if (nodetype == LYS_GROUPING) {
              return LY_STMT_GROUPING;
            }
            if (nodetype < (LYS_CONTAINER|LYS_GROUPING)) {
              if (nodetype == LYS_OUTPUT) {
                return LY_STMT_OUTPUT;
              }
              if (nodetype < (LYS_CONTAINER|LYS_OUTPUT)) {
                if (nodetype == LYS_INPUT) {
                  return LY_STMT_INPUT;
                }
                if (nodetype < (LYS_CONTAINER|LYS_INPUT)) {
                  if (nodetype == LYS_RPC) {
                    return LY_STMT_RPC;
                  }
                  if (nodetype < (LYS_CONTAINER|LYS_RPC)) {
                    if (nodetype == LYS_NOTIF) {
                      return LY_STMT_NOTIFICATION;
                    }
                    if (nodetype < (LYS_CONTAINER|LYS_NOTIF)) {
                      if (nodetype < (LYS_CONTAINER|LYS_ANYXML)) {
                        if ((nodetype != LYS_UNKNOWN) && (true)) {
                          switch(nodetype) {
                          case LYS_CONTAINER:
                            return LY_STMT_CONTAINER;
                          case LYS_CHOICE:
                            return LY_STMT_CHOICE;
                          case LYS_LEAF:
                            return LY_STMT_LEAF;
                          case LYS_LEAFLIST:
                            return LY_STMT_LEAFLIST;
                          case LYS_LIST:
                            return LY_STMT_LIST;
                          case LYS_ANYXML:
                            goto LAB_001c484a;
                          }
                        }
                      }
                      else if (nodetype == LYS_CASE) {
                        return LY_STMT_CASE;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return LY_STMT_NODE;
  }
LAB_001c484a:
  return LY_STMT_ANYDATA;
}



lytype_plugin_list * lytype_find(char *module,char *revision,char *type_name)

{
  int iVar1;
  char *type_name_local;
  char *revision_local;
  char *module_local;
  uint16_t u;
  
  u = 0;
  while( true ) {
    if (type_plugins_count <= u) {
      return (lytype_plugin_list *)0x0;
    }
    iVar1 = ly_strequal_(module,type_plugins[u].module);
    if (((iVar1 != 0) &&
        (((revision == (char *)0x0 && (type_plugins[u].revision == (char *)0x0)) ||
         ((revision != (char *)0x0 &&
          (iVar1 = ly_strequal_(revision,type_plugins[u].revision), iVar1 != 0)))))) &&
       (iVar1 = ly_strequal_(type_name,type_plugins[u].name), iVar1 != 0)) break;
    u = u + 1;
  }
  return type_plugins + u;
}



int lytype_store(lys_module *mod,char *type_name,char **value_str,lyd_val *value)

{
  int iVar1;
  lys_revision *revision;
  long in_FS_OFFSET;
  lyd_val *value_local;
  char **value_str_local;
  char *type_name_local;
  lys_module *mod_local;
  char *err_msg;
  lytype_plugin_list *p;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  err_msg = (char *)0x0;
  if ((((mod == (lys_module *)0x0) || (type_name == (char *)0x0)) || (value_str == (char **)0x0)) ||
     (value == (lyd_val *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("mod && type_name && value_str && value",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/plugins.c"
                  ,0x262,"lytype_store");
  }
  if (mod->rev_size == '\0') {
    revision = (lys_revision *)0x0;
  }
  else {
    revision = mod->rev;
  }
  p = lytype_find(mod->name,revision->date,type_name);
  if (p == (lytype_plugin_list *)0x0) {
    iVar1 = 1;
  }
  else {
    iVar1 = (*p->store_clb)(mod->ctx,type_name,value_str,value,&err_msg);
    if (iVar1 == 0) {
      iVar1 = 0;
    }
    else {
      if (err_msg == (char *)0x0) {
        iVar1 = asprintf(&err_msg,"Failed to store value \"%s\" of user type \"%s\".",*value_str,
                         type_name);
        if (iVar1 == -1) {
          ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lytype_store");
          iVar1 = -1;
          goto LAB_001c4b07;
        }
      }
      ly_log(mod->ctx,LY_LLERR,LY_EPLUGIN,err_msg);
      free(err_msg);
      iVar1 = -1;
    }
  }
LAB_001c4b07:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



void lytype_free(lys_type *type,lyd_val value,char *value_str)

{
  long lVar1;
  lys_module *plVar2;
  lytype_plugin_list *plVar3;
  lys_revision *revision;
  long in_FS_OFFSET;
  char *value_str_local;
  lyd_val value_local;
  lys_type *type_local;
  lys_module *mod;
  lytype_plugin_list *p;
  lyd_node_leaf_list leaf;
  lys_node_leaf sleaf;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  memset(&sleaf,0,0xd0);
  memset(&leaf,0,0x50);
  for (type_local = type; type_local->base == LY_TYPE_LEAFREF;
      type_local = &((type_local->info).lref.target)->type) {
  }
  if (type_local->base == LY_TYPE_UNION) {
    sleaf.module = type_local->parent->module;
    sleaf.name = "fake-leaf";
    sleaf.type.base = type_local->base;
    sleaf.type.value_flags = type_local->value_flags;
    sleaf.type.ext_size = type_local->ext_size;
    sleaf.type._6_2_ = *(undefined2 *)&type_local->field_0x6;
    sleaf.type.ext = type_local->ext;
    sleaf.type.der = type_local->der;
    sleaf.type.parent = type_local->parent;
    sleaf.type.info.binary.length = (lys_type_info_binary)(type_local->info).binary.length;
    sleaf.type.info.lref.target = (type_local->info).lref.target;
    sleaf.type.info.str.patterns_pcre = (type_local->info).str.patterns_pcre;
    sleaf.type.info.dec64.div = (type_local->info).dec64.div;
    sleaf.nodetype = LYS_LEAF;
    leaf.schema = (lys_node *)&sleaf;
    leaf.value_str = value_str;
    leaf.value = value;
    type_local = lyd_leaf_type(&leaf);
    if (type_local == (lys_type *)0x0) {
      ly_log((sleaf.module)->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/plugins.c"
             ,0x296);
      goto LAB_001c4dcc;
    }
  }
  plVar2 = type_local->der->module;
  if (plVar2 == (lys_module *)0x0) {
    ly_log(type_local->parent->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/plugins.c"
           ,0x29d);
  }
  else {
    if (plVar2->rev_size == '\0') {
      revision = (lys_revision *)0x0;
    }
    else {
      revision = plVar2->rev;
    }
    plVar3 = lytype_find(plVar2->name,revision->date,type_local->der->name);
    if (plVar3 == (lytype_plugin_list *)0x0) {
      ly_log(plVar2->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/plugins.c"
             ,0x2a3);
    }
    else if (plVar3->free_clb != (_func_void_void_ptr *)0x0) {
      (*plVar3->free_clb)(value.binary);
    }
  }
LAB_001c4dcc:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int nscmp(lyd_node *node1,lyd_node *node2)

{
  lys_module *plVar1;
  lys_module *plVar2;
  lyd_node *node2_local;
  lyd_node *node1_local;
  
  plVar1 = lys_node_module(node1->schema);
  plVar2 = lys_node_module(node2->schema);
  return (int)(plVar1 != plVar2);
}



int ly_print(lyout *out,char *format,...)

{
  LYOUT_TYPE LVar1;
  long lVar2;
  char in_AL;
  int iVar3;
  ssize_t sVar4;
  int *piVar5;
  undefined8 in_RCX;
  undefined8 in_RDX;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  char *format_local;
  lyout *out_local;
  int count;
  char *msg;
  char *aux;
  va_list ap;
  undefined local_b8 [16];
  undefined8 local_a8;
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  count = 0;
  msg = (char *)0x0;
  ap[0].gp_offset = 0x10;
  ap[0].fp_offset = 0x30;
  ap[0].overflow_arg_area = &stack0x00000008;
  ap[0].reg_save_area = local_b8;
  LVar1 = out->type;
  local_a8 = in_RDX;
  local_a0 = in_RCX;
  local_98 = in_R8;
  local_90 = in_R9;
  if (LVar1 == LYOUT_CALLBACK) {
    iVar3 = vasprintf(&msg,format,ap);
    sVar4 = (*(out->method).clb.f)((void *)(out->method).mem.len,msg,(long)iVar3);
    count = (int)sVar4;
    if (-1 < count) {
      piVar5 = __errno_location();
      *piVar5 = 0;
    }
    free(msg);
  }
  else if (LVar1 < 4) {
    if (LVar1 == LYOUT_MEMORY) {
      count = vasprintf(&msg,format,ap);
      if ((out->method).mem.size < (ulong)((long)(out->method).clb.arg + (long)count + 1)) {
        aux = (char *)ly_realloc((out->method).f,(long)(out->method).clb.arg + (long)count + 1);
        if (aux == (char *)0x0) {
          (out->method).f = (FILE *)0x0;
          (out->method).mem.len = 0;
          (out->method).mem.size = 0;
          ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_print");
          count = -1;
          goto LAB_001c51ad;
        }
        (out->method).mem.buf = aux;
        (out->method).mem.size = (long)(out->method).clb.arg + (long)count + 1;
      }
      memcpy((void *)((long)&((out->method).f)->_flags + (long)(out->method).clb.arg),msg,
             (long)count);
      (out->method).clb.arg = (void *)((long)(out->method).clb.arg + (long)count);
      *(undefined *)((long)&((out->method).f)->_flags + (long)(out->method).clb.arg) = 0;
      free(msg);
    }
    else if (LVar1 < LYOUT_CALLBACK) {
      if (LVar1 == LYOUT_FD) {
        count = vdprintf((out->method).fd,format,ap);
      }
      else if (LVar1 == LYOUT_STREAM) {
        count = vfprintf((FILE *)(out->method).f,format,ap);
      }
    }
  }
LAB_001c51ad:
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return count;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void ly_print_flush(lyout *out)

{
  LYOUT_TYPE LVar1;
  lyout *out_local;
  
  LVar1 = out->type;
  if ((((LVar1 < 4) && (LVar1 < LYOUT_MEMORY)) && (LVar1 != LYOUT_FD)) && (LVar1 == LYOUT_STREAM)) {
    fflush((FILE *)(out->method).f);
  }
  return;
}



int ly_write(lyout *out,char *buf,size_t count)

{
  LYOUT_TYPE LVar1;
  int iVar2;
  char *pcVar3;
  FILE *pFVar4;
  ssize_t sVar5;
  size_t sVar6;
  ssize_t sVar7;
  size_t count_local;
  char *buf_local;
  lyout *out_local;
  
  iVar2 = (int)count;
  if (out->hole_count == 0) {
    LVar1 = out->type;
    if (LVar1 == LYOUT_CALLBACK) {
      sVar7 = (*(out->method).clb.f)((void *)(out->method).mem.len,buf,count);
      iVar2 = (int)sVar7;
    }
    else {
      if (LVar1 < 4) {
        if (LVar1 == LYOUT_MEMORY) {
          if ((out->method).mem.size < (long)(out->method).clb.arg + count + 1) {
            pFVar4 = (FILE *)ly_realloc((out->method).f,(long)(out->method).clb.arg + count + 1);
            (out->method).f = pFVar4;
            if ((out->method).f == (FILE *)0x0) {
              (out->method).mem.len = 0;
              (out->method).mem.size = 0;
              ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_write");
              return -1;
            }
            (out->method).mem.size = (long)(out->method).clb.arg + count + 1;
          }
          memcpy((void *)((long)&((out->method).f)->_flags + (long)(out->method).clb.arg),buf,count)
          ;
          (out->method).clb.arg = (void *)((long)(out->method).clb.arg + count);
          *(undefined *)((long)&((out->method).f)->_flags + (long)(out->method).clb.arg) = 0;
          return iVar2;
        }
        if (LVar1 < LYOUT_CALLBACK) {
          if (LVar1 == LYOUT_FD) {
            sVar5 = write((out->method).fd,buf,count);
            return (int)sVar5;
          }
          if (LVar1 == LYOUT_STREAM) {
            sVar6 = fwrite(buf,1,count,(FILE *)(out->method).f);
            return (int)sVar6;
          }
        }
      }
      iVar2 = 0;
    }
  }
  else {
    if (out->buf_size < out->buf_len + count) {
      pcVar3 = (char *)ly_realloc(out->buffered,out->buf_len + count);
      out->buffered = pcVar3;
      if (out->buffered == (char *)0x0) {
        out->buf_len = 0;
        out->buf_size = 0;
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_write");
        return -1;
      }
      out->buf_size = out->buf_len + count;
    }
    memcpy(out->buffered + out->buf_len,buf,count);
    out->buf_len = out->buf_len + count;
  }
  return iVar2;
}



int ly_write_skip(lyout *out,size_t count,size_t *position)

{
  LYOUT_TYPE LVar1;
  FILE *pFVar2;
  char *pcVar3;
  size_t *position_local;
  size_t count_local;
  lyout *out_local;
  
  LVar1 = out->type;
  if (LVar1 != LYOUT_CALLBACK) {
    if (LYOUT_CALLBACK < LVar1) goto LAB_001c56fb;
    if (LYOUT_STREAM < LVar1) {
      if (LVar1 == LYOUT_MEMORY) {
        if ((out->method).mem.size < (long)(out->method).clb.arg + count) {
          pFVar2 = (FILE *)ly_realloc((out->method).f,(long)(out->method).clb.arg + count);
          (out->method).f = pFVar2;
          if ((out->method).f == (FILE *)0x0) {
            (out->method).mem.len = 0;
            (out->method).mem.size = 0;
            ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_write_skip"
                  );
            return -1;
          }
          (out->method).mem.size = (long)(out->method).clb.arg + count;
        }
        *position = (out->method).mem.len;
        (out->method).clb.arg = (void *)((long)(out->method).clb.arg + count);
      }
      goto LAB_001c56fb;
    }
  }
  if (out->buf_size < out->buf_len + count) {
    pcVar3 = (char *)ly_realloc(out->buffered,out->buf_len + count);
    out->buffered = pcVar3;
    if (out->buffered == (char *)0x0) {
      out->buf_len = 0;
      out->buf_size = 0;
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","ly_write_skip");
      return -1;
    }
    out->buf_size = out->buf_len + count;
  }
  *position = out->buf_len;
  out->buf_len = out->buf_len + count;
  out->hole_count = out->hole_count + 1;
LAB_001c56fb:
  return (int)count;
}



int ly_write_skipped(lyout *out,size_t position,char *buf,size_t count)

{
  LYOUT_TYPE LVar1;
  int iVar2;
  size_t count_local;
  char *buf_local;
  size_t position_local;
  lyout *out_local;
  
  LVar1 = out->type;
  count_local = count;
  if (LVar1 != LYOUT_CALLBACK) {
    if (LYOUT_CALLBACK < LVar1) goto LAB_001c5829;
    if (LYOUT_STREAM < LVar1) {
      if (LVar1 == LYOUT_MEMORY) {
        memcpy((void *)((long)&((out->method).f)->_flags + position),buf,count);
      }
      goto LAB_001c5829;
    }
  }
  if (out->buf_len < count + position) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer.c"
           ,0x110);
    return -1;
  }
  memcpy(out->buffered + position,buf,count);
  out->hole_count = out->hole_count - 1;
  if (out->hole_count == 0) {
    iVar2 = ly_write(out,out->buffered,out->buf_len);
    count_local = (size_t)iVar2;
    out->buf_len = 0;
  }
LAB_001c5829:
  return (int)count_local;
}



int write_iff(lyout *out,lys_module *module,lys_iffeature *expr,int prefix_kind,int *index_e,
             int *index_f)

{
  byte bVar1;
  uint8_t uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  lys_module *plVar6;
  lys_module *plVar7;
  char *pcVar8;
  undefined *puVar9;
  lys_revision *plVar10;
  int *index_f_local;
  int *index_e_local;
  int prefix_kind_local;
  lys_iffeature *expr_local;
  lys_module *module_local;
  lyout *out_local;
  uint8_t op;
  int count;
  int brackets_flag;
  lys_module *mod;
  
  count = 0;
  brackets_flag = *index_e;
  bVar1 = iff_getop(expr->expr,*index_e);
  *index_e = *index_e + 1;
  if (bVar1 == 3) {
    plVar6 = lys_main_module(expr->features[*index_f]->module);
    plVar7 = lys_main_module(module);
    if (plVar6 != plVar7) {
      if (prefix_kind == 0) {
        plVar6 = lys_main_module(expr->features[*index_f]->module);
        pcVar8 = transform_module_name2import_prefix(module,plVar6->name);
        count = ly_print(out,"%s:",pcVar8);
      }
      else if (prefix_kind == 1) {
        plVar6 = lys_main_module(expr->features[*index_f]->module);
        count = ly_print(out,"%s:",plVar6->name);
      }
      else if (prefix_kind == 2) {
        plVar6 = lys_main_module(expr->features[*index_f]->module);
        count = ly_print(out,"%s:",plVar6->prefix);
      }
      else if (prefix_kind == 3) {
        plVar6 = lys_main_module(expr->features[*index_f]->module);
        if (plVar6->rev_size == '\0') {
          plVar10 = (lys_revision *)&DAT_0022a475;
        }
        else {
          plVar10 = plVar6->rev;
        }
        if (plVar6->rev_size == '\0') {
          puVar9 = &DAT_0022a475;
        }
        else {
          puVar9 = &DAT_0022a476;
        }
        count = ly_print(out,"%s%s%s:",plVar6->name,puVar9,plVar10);
      }
    }
    iVar3 = ly_print(out,expr->features[*index_f]->name);
    count = count + iVar3;
    *index_f = *index_f + 1;
  }
  else if (bVar1 < 4) {
    if (bVar1 != 2) {
      if (2 < bVar1) {
        return 0;
      }
      if (bVar1 == 0) {
        iVar3 = ly_print(out,"not ");
        iVar4 = write_iff(out,module,expr,prefix_kind,index_e,index_f);
        return iVar3 + iVar4;
      }
      if (bVar1 != 1) {
        return 0;
      }
      if ((brackets_flag != 0) &&
         ((*index_e < 2 || (uVar2 = iff_getop(expr->expr,*index_e + -2), uVar2 != '\0')))) {
        brackets_flag = 0;
      }
    }
    if (brackets_flag != 0) {
      count = ly_print(out,"(");
    }
    iVar3 = write_iff(out,module,expr,prefix_kind,index_e,index_f);
    if (bVar1 == 2) {
      puVar9 = &DAT_0022a487;
    }
    else {
      puVar9 = &DAT_0022a48a;
    }
    iVar4 = ly_print(out," %s ",puVar9);
    iVar5 = write_iff(out,module,expr,prefix_kind,index_e,index_f);
    count = count + iVar3 + iVar4 + iVar5;
    if (brackets_flag != 0) {
      iVar3 = ly_print(out,")");
      count = count + iVar3;
    }
  }
  return count;
}



int ly_print_iffeature(lyout *out,lys_module *module,lys_iffeature *expr,int prefix_kind)

{
  int iVar1;
  long in_FS_OFFSET;
  int prefix_kind_local;
  lys_iffeature *expr_local;
  lys_module *module_local;
  lyout *out_local;
  int index_e;
  int index_f;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  index_e = 0;
  index_f = 0;
  if (expr->expr == (uint8_t *)0x0) {
    iVar1 = 0;
  }
  else {
    iVar1 = write_iff(out,module,expr,prefix_kind,&index_e,&index_f);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int lys_print_(lyout *out,lys_module *module,LYS_OUTFORMAT format,char *target_node,int line_length,
              int options)

{
  int options_local;
  char *target_node_local;
  int line_length_local;
  LYS_OUTFORMAT format_local;
  lys_module *module_local;
  lyout *out_local;
  int ret;
  
  if (false) {
switchD_001c5d06_caseD_0:
    ly_log(module->ctx,LY_LLERR,LY_EINVAL,"Unknown output format.");
    ret = 1;
  }
  else {
    switch(format) {
    default:
      goto switchD_001c5d06_caseD_0;
    case LYS_OUT_YANG:
      lys_disable_deviations(module);
      ret = yang_print_model(out,module);
      lys_enable_deviations(module);
      break;
    case LYS_OUT_YIN:
      lys_disable_deviations(module);
      ret = yin_print_model(out,module);
      lys_enable_deviations(module);
      break;
    case LYS_OUT_TREE:
      ret = tree_print_model(out,module,target_node,line_length,options);
      break;
    case LYS_OUT_INFO:
      ret = info_print_model(out,module,target_node);
      break;
    case LYS_OUT_JSON:
      ret = jsons_print_model(out,module,target_node);
    }
  }
  return ret;
}



int lys_print_file(FILE *f,lys_module *module,LYS_OUTFORMAT format,char *target_node,int line_length
                  ,int options)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  int options_local;
  char *target_node_local;
  int line_length_local;
  LYS_OUTFORMAT format_local;
  lys_module *module_local;
  FILE *f_local;
  lyout out;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if ((f == (FILE *)0x0) || (module == (lys_module *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_print_file");
    iVar2 = 1;
  }
  else {
    memset(&out,0,0x40);
    out.type = LYOUT_STREAM;
    out.method.f = f;
    iVar2 = lys_print_(&out,module,format,target_node,line_length,options);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lys_print_path(char *path,lys_module *module,LYS_OUTFORMAT format,char *target_node,
                  int line_length,int options)

{
  int iVar1;
  FILE *__stream;
  int *piVar2;
  char *pcVar3;
  int options_local;
  char *target_node_local;
  int line_length_local;
  LYS_OUTFORMAT format_local;
  lys_module *module_local;
  char *path_local;
  int ret;
  FILE *f;
  
  if ((path == (char *)0x0) || (module == (lys_module *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_print_path");
    iVar1 = 1;
  }
  else {
    __stream = fopen(path,"w");
    if (__stream == (FILE *)0x0) {
      piVar2 = __errno_location();
      pcVar3 = strerror(*piVar2);
      ly_log(module->ctx,LY_LLERR,LY_ESYS,"Failed to open file \"%s\" (%s).",path,pcVar3);
      iVar1 = 1;
    }
    else {
      iVar1 = lys_print_file((FILE *)__stream,module,format,target_node,line_length,options);
      fclose(__stream);
    }
  }
  return iVar1;
}



int lys_print_fd(int fd,lys_module *module,LYS_OUTFORMAT format,char *target_node,int line_length,
                int options)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  int options_local;
  int line_length_local;
  char *target_node_local;
  lys_module *module_local;
  LYS_OUTFORMAT format_local;
  int fd_local;
  lyout out;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if ((fd < 0) || (module == (lys_module *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_print_fd");
    iVar2 = 1;
  }
  else {
    memset(&out,0,0x40);
    out.type = LYOUT_FD;
    out.method.fd = fd;
    iVar2 = lys_print_(&out,module,format,target_node,line_length,options);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lys_print_mem(char **strp,lys_module *module,LYS_OUTFORMAT format,char *target_node,
                 int line_length,int options)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  int options_local;
  char *target_node_local;
  int line_length_local;
  LYS_OUTFORMAT format_local;
  lys_module *module_local;
  char **strp_local;
  int r;
  lyout out;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if ((strp == (char **)0x0) || (module == (lys_module *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_print_mem");
    iVar2 = 1;
  }
  else {
    memset(&out,0,0x40);
    out.type = LYOUT_MEMORY;
    iVar2 = lys_print_(&out,module,format,target_node,line_length,options);
    *strp = (char *)out.method.f;
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lys_print_clb(_func_ssize_t_void_ptr_void_ptr_size_t *writeclb,void *arg,lys_module *module,
                 LYS_OUTFORMAT format,char *target_node,int line_length,int options)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  char *target_node_local;
  int line_length_local;
  LYS_OUTFORMAT format_local;
  lys_module *module_local;
  void *arg_local;
  _func_ssize_t_void_ptr_void_ptr_size_t *writeclb_local;
  lyout out;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if ((writeclb == (_func_ssize_t_void_ptr_void_ptr_size_t *)0x0) || (module == (lys_module *)0x0))
  {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lys_print_clb");
    iVar2 = 1;
  }
  else {
    memset(&out,0,0x40);
    out.type = LYOUT_CALLBACK;
    out.method.clb.f = writeclb;
    out.method.clb.arg = arg;
    iVar2 = lys_print_(&out,module,format,target_node,line_length,options);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lys_print_target(lyout *out,lys_module *module,char *target_schema_path,
                    _func_void_lyout_ptr_lys_tpdf_ptr_int_ptr *clb_print_typedef,
                    _func_void_lyout_ptr_lys_ident_ptr_int_ptr *clb_print_identity,
                    _func_void_lyout_ptr_lys_feature_ptr_int_ptr *clb_print_feature,
                    _func_void_lyout_ptr_lys_type_ptr_int_ptr *clb_print_type,
                    _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_grouping,
                    _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_container,
                    _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_choice,
                    _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_leaf,
                    _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_leaflist,
                    _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_list,
                    _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_anydata,
                    _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_case,
                    _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_notif,
                    _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_rpc,
                    _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_action,
                    _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_input,
                    _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_output)

{
  LYS_NODE LVar1;
  int iVar2;
  char *pcVar3;
  long in_FS_OFFSET;
  _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_output_local;
  _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_input_local;
  _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_action_local;
  _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_rpc_local;
  _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_notif_local;
  _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_case_local;
  _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_anydata_local;
  _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_list_local;
  _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_leaflist_local;
  _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_leaf_local;
  _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_choice_local;
  _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_container_local;
  _func_void_lyout_ptr_lys_node_ptr_int_ptr *clb_print_grouping_local;
  _func_void_lyout_ptr_lys_type_ptr_int_ptr *clb_print_type_local;
  _func_void_lyout_ptr_lys_feature_ptr_int_ptr *clb_print_feature_local;
  _func_void_lyout_ptr_lys_ident_ptr_int_ptr *clb_print_identity_local;
  _func_void_lyout_ptr_lys_tpdf_ptr_int_ptr *clb_print_typedef_local;
  char *target_schema_path_local;
  lys_module *module_local;
  lyout *out_local;
  uint8_t tpdf_size;
  int f;
  int rc;
  int i;
  lys_node *target;
  char *spec_target;
  lys_tpdf *tpdf;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  f = 1;
  spec_target = (char *)0x0;
  target = (lys_node *)0x0;
  tpdf = (lys_tpdf *)0x0;
  tpdf_size = '\0';
  if ((*target_schema_path == '/') || (iVar2 = strncmp(target_schema_path,"type/",5), iVar2 == 0)) {
    pcVar3 = target_schema_path;
    if (*target_schema_path != '/') {
      pcVar3 = target_schema_path + 4;
    }
    rc = resolve_absolute_schema_nodeid(pcVar3,module,0xc7ff,&target);
    if ((rc != 0) || (target == (lys_node *)0x0)) {
      if (*target_schema_path != '/') {
        target_schema_path = target_schema_path + 4;
      }
      ly_log(module->ctx,LY_LLERR,LY_EINVAL,"Target %s could not be resolved.",target_schema_path);
      iVar2 = 1;
      goto LAB_001c6cf9;
    }
  }
  else {
    iVar2 = strncmp(target_schema_path,"grouping/",9);
    if (iVar2 != 0) {
      iVar2 = strncmp(target_schema_path,"typedef/",8);
      if (iVar2 != 0) {
        iVar2 = strncmp(target_schema_path,"identity/",9);
        if (iVar2 == 0) {
          i = 0;
          while ((i < (int)(uint)module->ident_size &&
                 (iVar2 = strcmp(module->ident[i].name,target_schema_path + 9), iVar2 != 0))) {
            i = i + 1;
          }
          if (i == (uint)module->ident_size) {
            ly_print(out,"Identity %s not found.\n",target_schema_path + 9);
            iVar2 = 1;
          }
          else {
            (*clb_print_identity)(out,module->ident + i,&f);
            iVar2 = 0;
          }
        }
        else {
          iVar2 = strncmp(target_schema_path,"feature/",8);
          if (iVar2 == 0) {
            i = 0;
            while ((i < (int)(uint)module->features_size &&
                   (iVar2 = strcmp(module->features[i].name,target_schema_path + 8), iVar2 != 0))) {
              i = i + 1;
            }
            if (i == (uint)module->features_size) {
              ly_print(out,"Feature %s not found.\n",target_schema_path + 8);
              iVar2 = 1;
            }
            else {
              (*clb_print_feature)(out,module->features + i,&f);
              iVar2 = 0;
            }
          }
          else {
            ly_print(out,"Target could not be resolved.\n");
            iVar2 = 1;
          }
        }
        goto LAB_001c6cf9;
      }
      pcVar3 = strrchr(target_schema_path + 8,0x2f);
      if (pcVar3 == (char *)0x0) {
        spec_target = target_schema_path + 8;
        tpdf = module->tpdf;
        tpdf_size = (uint8_t)module->tpdf_size;
      }
      else {
        *pcVar3 = '\0';
        spec_target = pcVar3 + 1;
        rc = resolve_absolute_schema_nodeid(target_schema_path + 7,module,0x4191,&target);
        if ((rc != 0) || (iVar2 = 0, target == (lys_node *)0x0)) {
          iVar2 = resolve_absolute_schema_nodeid(target_schema_path + 7,module,0x800,&target);
        }
        rc = iVar2;
        if ((rc == 0) && (target != (lys_node *)0x0)) {
          LVar1 = target->nodetype;
          if (LVar1 != LYS_ACTION) {
            if (LVar1 < (LYS_CONTAINER|LYS_ACTION)) {
              if (LVar1 == LYS_GROUPING) {
                tpdf = *(lys_tpdf **)target->hash;
                tpdf_size = (uint8_t)*(undefined2 *)(target->padding + 2);
                goto LAB_001c66a2;
              }
              if (LVar1 < (LYS_CONTAINER|LYS_GROUPING)) {
                if (LVar1 == LYS_RPC) goto LAB_001c660e;
                if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
                  if (LVar1 == LYS_NOTIF) {
                    tpdf = (lys_tpdf *)target[1].name;
                    tpdf_size = (uint8_t)*(undefined2 *)(target->padding + 2);
                  }
                  else {
                    if (LYS_NOTIF < LVar1) goto LAB_001c6640;
                    if (LVar1 == LYS_CONTAINER) {
                      tpdf = (lys_tpdf *)target[1].ref;
                      tpdf_size = (uint8_t)*(undefined2 *)(target->padding + 2);
                    }
                    else {
                      if (LVar1 != LYS_LIST) goto LAB_001c6640;
                      tpdf = (lys_tpdf *)target[1].ref;
                      tpdf_size = target->padding[1];
                    }
                  }
                  goto LAB_001c66a2;
                }
              }
            }
LAB_001c6640:
            ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer.c"
                   ,0x248);
            iVar2 = 1;
            goto LAB_001c6cf9;
          }
LAB_001c660e:
          tpdf = (lys_tpdf *)target[1].name;
          tpdf_size = (uint8_t)*(undefined2 *)(target->padding + 2);
        }
      }
LAB_001c66a2:
      for (i = 0; i < (int)(uint)tpdf_size; i = i + 1) {
        iVar2 = strcmp(tpdf[i].name,spec_target);
        if (iVar2 == 0) {
          (*clb_print_typedef)(out,tpdf + i,&f);
          break;
        }
      }
      spec_target = spec_target + -1;
      *spec_target = '/';
      if (i == (uint)tpdf_size) {
        ly_print(out,"Typedef %s not found.\n",target_schema_path);
        iVar2 = 1;
      }
      else {
        iVar2 = 0;
      }
      goto LAB_001c6cf9;
    }
    spec_target = strchr(target_schema_path + 9,0x2f);
    if (spec_target != (char *)0x0) {
      *spec_target = '\0';
      spec_target = spec_target + 1;
    }
    rc = resolve_absolute_schema_nodeid(target_schema_path + 8,module,0x800,&target);
    if ((rc != 0) || (target == (lys_node *)0x0)) {
      ly_print(out,"Grouping %s not found.\n",target_schema_path + 8);
      iVar2 = 1;
      goto LAB_001c6cf9;
    }
  }
  iVar2 = strncmp(target_schema_path,"type/",5);
  if (iVar2 == 0) {
    if ((target->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
      ly_log(module->ctx,LY_LLERR,LY_EINVAL,"Target is not a leaf or a leaf-list.");
      iVar2 = 1;
    }
    else {
      (*clb_print_type)(out,(lys_type *)&target[1].ref,&f);
      iVar2 = 0;
    }
    goto LAB_001c6cf9;
  }
  iVar2 = strncmp(target_schema_path,"grouping/",9);
  if ((iVar2 == 0) && (spec_target == (char *)0x0)) {
    (*clb_print_grouping)(out,target,&f);
    iVar2 = 0;
    goto LAB_001c6cf9;
  }
  if (spec_target != (char *)0x0) {
    rc = resolve_descendant_schema_nodeid(spec_target,target->child,0x807f,0,&target);
    if ((rc != 0) || (target == (lys_node *)0x0)) {
      ly_print(out,"Grouping %s child \"%s\" not found.\n",target_schema_path + 9,spec_target);
      iVar2 = 1;
      goto LAB_001c6cf9;
    }
    spec_target = spec_target + -1;
    *spec_target = '/';
  }
  LVar1 = target->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_001c6b3c_caseD_20:
    (*clb_print_anydata)(out,target,&f);
    goto LAB_001c6cf4;
  }
  if (LYS_ANYDATA < LVar1) goto switchD_001c6b3c_caseD_3;
  if (LVar1 == LYS_ACTION) {
    (*clb_print_action)(out,target,&f);
    goto LAB_001c6cf4;
  }
  if (LYS_ACTION < LVar1) goto switchD_001c6b3c_caseD_3;
  if (LVar1 == LYS_OUTPUT) {
    (*clb_print_output)(out,target,&f);
    goto LAB_001c6cf4;
  }
  if (LYS_OUTPUT < LVar1) goto switchD_001c6b3c_caseD_3;
  if (LVar1 == LYS_INPUT) {
    (*clb_print_input)(out,target,&f);
    goto LAB_001c6cf4;
  }
  if (LYS_INPUT < LVar1) goto switchD_001c6b3c_caseD_3;
  if (LVar1 == LYS_RPC) {
    (*clb_print_rpc)(out,target,&f);
    goto LAB_001c6cf4;
  }
  if (LYS_RPC < LVar1) goto switchD_001c6b3c_caseD_3;
  if (LVar1 == LYS_NOTIF) {
    (*clb_print_notif)(out,target,&f);
    goto LAB_001c6cf4;
  }
  if (LVar1 < (LYS_CONTAINER|LYS_NOTIF)) {
    if (LYS_ANYXML < LVar1) {
      if (LVar1 == LYS_CASE) {
        (*clb_print_case)(out,target,&f);
        goto LAB_001c6cf4;
      }
      goto switchD_001c6b3c_caseD_3;
    }
    if ((LVar1 == LYS_UNKNOWN) || (false)) goto switchD_001c6b3c_caseD_3;
    switch(LVar1) {
    case LYS_CONTAINER:
      (*clb_print_container)(out,target,&f);
      break;
    case LYS_CHOICE:
      (*clb_print_choice)(out,target,&f);
      break;
    default:
      goto switchD_001c6b3c_caseD_3;
    case LYS_LEAF:
      (*clb_print_leaf)(out,target,&f);
      break;
    case LYS_LEAFLIST:
      (*clb_print_leaflist)(out,target,&f);
      break;
    case LYS_LIST:
      (*clb_print_list)(out,target,&f);
      break;
    case LYS_ANYXML:
      goto switchD_001c6b3c_caseD_20;
    }
  }
  else {
switchD_001c6b3c_caseD_3:
    pcVar3 = strnodetype(target->nodetype);
    ly_print(out,"Nodetype %s not supported.\n",pcVar3);
  }
LAB_001c6cf4:
  iVar2 = 0;
LAB_001c6cf9:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyd_print_(lyout *out,lyd_node *root,LYD_FORMAT format,int options)

{
  int iVar1;
  int options_local;
  LYD_FORMAT format_local;
  lyd_node *root_local;
  lyout *out_local;
  
  if (format == LYD_LYB) {
    iVar1 = lyb_print_data(out,root,options);
    return iVar1;
  }
  if (format < 4) {
    if (format == LYD_XML) {
      iVar1 = xml_print_data(out,root,options);
      return iVar1;
    }
    if (format == LYD_JSON) {
      iVar1 = json_print_data(out,root,options);
      return iVar1;
    }
  }
  ly_log(root->schema->module->ctx,LY_LLERR,LY_EINVAL,"Unknown output format.");
  return 1;
}



int lyd_print_file(FILE *f,lyd_node *root,LYD_FORMAT format,int options)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  int options_local;
  LYD_FORMAT format_local;
  lyd_node *root_local;
  FILE *f_local;
  int r;
  lyout out;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (f == (FILE *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_print_file");
    iVar2 = 1;
  }
  else {
    memset(&out,0,0x40);
    out.type = LYOUT_STREAM;
    out.method.f = f;
    iVar2 = lyd_print_(&out,root,format,options);
    free(out.buffered);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lyd_print_path(char *path,lyd_node *root,LYD_FORMAT format,int options)

{
  int iVar1;
  FILE *__stream;
  int options_local;
  LYD_FORMAT format_local;
  lyd_node *root_local;
  char *path_local;
  int ret;
  FILE *f;
  
  if (path == (char *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_print_path");
    iVar1 = 1;
  }
  else {
    __stream = fopen(path,"w");
    if (__stream == (FILE *)0x0) {
      ly_log(root->schema->module->ctx,LY_LLERR,LY_EINVAL,"Cannot open file \"%s\" for writing.",
             path);
      iVar1 = 1;
    }
    else {
      iVar1 = lyd_print_file((FILE *)__stream,root,format,options);
      fclose(__stream);
    }
  }
  return iVar1;
}



int lyd_print_fd(int fd,lyd_node *root,LYD_FORMAT format,int options)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  int options_local;
  lyd_node *root_local;
  LYD_FORMAT format_local;
  int fd_local;
  int r;
  lyout out;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (fd < 0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_print_fd");
    iVar2 = 1;
  }
  else {
    memset(&out,0,0x40);
    out.type = LYOUT_FD;
    out.method.fd = fd;
    iVar2 = lyd_print_(&out,root,format,options);
    free(out.buffered);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lyd_print_mem(char **strp,lyd_node *root,LYD_FORMAT format,int options)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  int options_local;
  LYD_FORMAT format_local;
  lyd_node *root_local;
  char **strp_local;
  int r;
  lyout out;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (strp == (char **)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_print_mem");
    iVar2 = 1;
  }
  else {
    memset(&out,0,0x40);
    out.type = LYOUT_MEMORY;
    iVar2 = lyd_print_(&out,root,format,options);
    *strp = (char *)out.method.f;
    free(out.buffered);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lyd_print_clb(_func_ssize_t_void_ptr_void_ptr_size_t *writeclb,void *arg,lyd_node *root,
                 LYD_FORMAT format,int options)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  int options_local;
  LYD_FORMAT format_local;
  lyd_node *root_local;
  void *arg_local;
  _func_ssize_t_void_ptr_void_ptr_size_t *writeclb_local;
  int r;
  lyout out;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (writeclb == (_func_ssize_t_void_ptr_void_ptr_size_t *)0x0) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyd_print_clb");
    iVar2 = 1;
  }
  else {
    memset(&out,0,0x40);
    out.type = LYOUT_CALLBACK;
    out.method.clb.f = writeclb;
    out.method.clb.arg = arg;
    iVar2 = lyd_print_(&out,root,format,options);
    free(out.buffered);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lyd_wd_toprint(lyd_node *node,int options)

{
  LYS_NODE LVar1;
  lys_node *plVar2;
  long lVar3;
  long lVar4;
  bool bVar5;
  int iVar6;
  int options_local;
  lyd_node *node_local;
  int flag;
  lyd_node *next;
  lyd_node *subroot;
  lyd_node *elem;
  
  bVar5 = false;
  if ((options & 0x10U) == 0) {
    elem = node;
    if ((((node->field_0x9 & 1) == 0) || ((options & 0xf0U) != 0)) ||
       ((node->schema->flags & 2) != 0)) {
      if ((((node->field_0x9 & 1) != 0) && (node->schema->nodetype == LYS_CONTAINER)) &&
         ((options & 4U) == 0)) {
        while (elem != (lyd_node *)0x0) {
          if (elem->schema->nodetype != LYS_CONTAINER) {
            bVar5 = true;
            break;
          }
          if ((elem->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
            next = elem->child;
          }
          else {
            next = (lyd_node *)0x0;
          }
          if (next == (lyd_node *)0x0) {
            if (elem == node) break;
            next = elem->next;
          }
          while ((next == (lyd_node *)0x0 && (elem = elem->parent, elem->parent != node->parent))) {
            next = elem->next;
          }
          elem = next;
        }
        if (!bVar5) {
          return 0;
        }
      }
    }
    else {
      while (elem != (lyd_node *)0x0) {
        if ((elem->schema->flags & 2) != 0) {
          bVar5 = true;
          break;
        }
        if ((elem->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
          next = elem->child;
        }
        else {
          next = (lyd_node *)0x0;
        }
        if (next == (lyd_node *)0x0) {
          if (elem == node) break;
          next = elem->next;
        }
        while ((next == (lyd_node *)0x0 && (elem = elem->parent, elem->parent != node->parent))) {
          next = elem->next;
        }
        elem = next;
      }
      if (!bVar5) {
        return 0;
      }
    }
  }
  else {
    if ((node->field_0x9 & 1) != 0) {
      return 0;
    }
    if ((node->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
      if (((node->schema->nodetype & LYS_CONTAINER) != LYS_UNKNOWN) &&
         (plVar2 = node->schema, lVar3._0_2_ = plVar2[1].flags, lVar3._2_1_ = plVar2[1].ext_size,
         lVar3._3_1_ = plVar2[1].iffeature_size, lVar3._4_1_ = plVar2[1].padding[0],
         lVar3._5_1_ = plVar2[1].padding[1], lVar3._6_1_ = plVar2[1].padding[2],
         lVar3._7_1_ = plVar2[1].padding[3], lVar3 == 0)) {
        subroot = node->child;
        while ((subroot != (lyd_node *)0x0 && (!bVar5))) {
          elem = subroot;
          while (elem != (lyd_node *)0x0) {
            if ((elem->field_0x9 & 1) == 0) {
              LVar1 = elem->schema->nodetype;
              if (LVar1 == LYS_ANYDATA) {
switchD_001c72cf_caseD_10:
                bVar5 = true;
              }
              else if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
                if (LVar1 == LYS_ACTION) goto switchD_001c72cf_caseD_10;
                if (LVar1 < (LYS_CONTAINER|LYS_ACTION)) {
                  if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
                    if ((LVar1 != LYS_UNKNOWN) && (true)) {
                      switch(LVar1) {
                      case LYS_CONTAINER:
                        plVar2 = elem->schema;
                        lVar4._0_2_ = plVar2[1].flags;
                        lVar4._2_1_ = plVar2[1].ext_size;
                        lVar4._3_1_ = plVar2[1].iffeature_size;
                        lVar4._4_1_ = plVar2[1].padding[0];
                        lVar4._5_1_ = plVar2[1].padding[1];
                        lVar4._6_1_ = plVar2[1].padding[2];
                        lVar4._7_1_ = plVar2[1].padding[3];
                        if (lVar4 != 0) {
                          bVar5 = true;
                        }
                        break;
                      case LYS_LEAF:
                      case LYS_LEAFLIST:
                        iVar6 = lyd_wd_default((lyd_node_leaf_list *)elem);
                        if (iVar6 == 0) {
                          bVar5 = true;
                        }
                        break;
                      case LYS_LIST:
                      case LYS_ANYXML:
                        goto switchD_001c72cf_caseD_10;
                      }
                    }
                  }
                  else if (LVar1 == LYS_NOTIF) goto switchD_001c72cf_caseD_10;
                }
              }
              if (bVar5) break;
              if ((elem->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
                next = elem->child;
              }
              else {
                next = (lyd_node *)0x0;
              }
              if (next == (lyd_node *)0x0) goto LAB_001c735d;
            }
            else {
LAB_001c735d:
              if (elem == subroot) break;
              next = elem->next;
            }
            while ((next == (lyd_node *)0x0 &&
                   (elem = elem->parent, elem->parent != subroot->parent))) {
              next = elem->next;
            }
            elem = next;
          }
          subroot = subroot->next;
        }
        if (!bVar5) {
          return 0;
        }
      }
    }
    else {
      iVar6 = lyd_wd_default((lyd_node_leaf_list *)node);
      if (iVar6 != 0) {
        return 0;
      }
    }
  }
  return 1;
}



int lyd_toprint(lyd_node *node,int options)

{
  lys_node *plVar1;
  int iVar2;
  lys_module *plVar3;
  int options_local;
  lyd_node *node_local;
  lys_node *sparent;
  lyd_node *first;
  lys_node *scase;
  
  iVar2 = lyd_wd_toprint(node,options);
  if (iVar2 == 0) {
    for (sparent = lys_parent(node->schema);
        (plVar1 = sparent, sparent != (lys_node *)0x0 && (sparent->nodetype == LYS_USES));
        sparent = lys_parent(sparent)) {
    }
    if ((sparent == (lys_node *)0x0) || (sparent->nodetype != LYS_CASE)) {
      iVar2 = 0;
    }
    else {
      for (sparent = lys_parent(sparent);
          (sparent != (lys_node *)0x0 && (sparent->nodetype == LYS_USES));
          sparent = lys_parent(sparent)) {
      }
      if ((sparent == (lys_node *)0x0) || (sparent->nodetype != LYS_CHOICE)) {
        plVar3 = lyd_node_module(node);
        ly_log(plVar3->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer.c"
               ,0x3d4);
        iVar2 = 0;
      }
      else if (plVar1 == (lys_node *)sparent[1].name) {
        iVar2 = 0;
      }
      else {
        first = node->prev;
        while (first->prev->next != (lyd_node *)0x0) {
          first = first->prev;
        }
        for (; first != (lyd_node *)0x0; first = first->next) {
          if (first != node) {
            for (sparent = lys_parent(first->schema);
                (sparent != (lys_node *)0x0 && (sparent->nodetype == LYS_USES));
                sparent = lys_parent(sparent)) {
            }
            if ((sparent == plVar1) && (iVar2 = lyd_wd_toprint(first,options), iVar2 != 0)) {
              return 0;
            }
          }
        }
        iVar2 = 1;
      }
    }
  }
  else {
    iVar2 = 1;
  }
  return iVar2;
}



void lyxp_expr_free(lyxp_expr *expr)

{
  lyxp_expr *expr_local;
  uint16_t i;
  
  if (expr != (lyxp_expr *)0x0) {
    free(expr->expr);
    free(expr->tokens);
    free(expr->expr_pos);
    free(expr->tok_len);
    if (expr->repeat != (lyxp_expr_type **)0x0) {
      for (i = 0; i < expr->used; i = i + 1) {
        free(expr->repeat[i]);
      }
    }
    free(expr->repeat);
    free(expr);
  }
  return;
}



char * print_set_type(lyxp_set *set)

{
  char *pcVar1;
  lyxp_set *set_local;
  
  switch(set->type) {
  case LYXP_SET_EMPTY:
    pcVar1 = "empty";
    break;
  case LYXP_SET_NODE_SET:
    pcVar1 = "node set";
    break;
  case LYXP_SET_SNODE_SET:
    pcVar1 = "schema node set";
    break;
  case LYXP_SET_BOOLEAN:
    pcVar1 = "boolean";
    break;
  case LYXP_SET_NUMBER:
    pcVar1 = "number";
    break;
  case LYXP_SET_STRING:
    pcVar1 = "string";
    break;
  default:
    pcVar1 = (char *)0x0;
  }
  return pcVar1;
}



char * print_token(lyxp_token tok)

{
  char *pcVar1;
  lyxp_token tok_local;
  
  if (false) {
switchD_001c797a_caseD_0:
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
           ,0x95);
    pcVar1 = "";
  }
  else {
    switch(tok) {
    default:
      goto switchD_001c797a_caseD_0;
    case LYXP_TOKEN_PAR1:
      pcVar1 = "(";
      break;
    case LYXP_TOKEN_PAR2:
      pcVar1 = ")";
      break;
    case LYXP_TOKEN_BRACK1:
      pcVar1 = "[";
      break;
    case LYXP_TOKEN_BRACK2:
      pcVar1 = "]";
      break;
    case LYXP_TOKEN_DOT:
      pcVar1 = ".";
      break;
    case LYXP_TOKEN_DDOT:
      pcVar1 = "..";
      break;
    case LYXP_TOKEN_AT:
      pcVar1 = "@";
      break;
    case LYXP_TOKEN_COMMA:
      pcVar1 = ",";
      break;
    case LYXP_TOKEN_NAMETEST:
      pcVar1 = "NameTest";
      break;
    case LYXP_TOKEN_NODETYPE:
      pcVar1 = "NodeType";
      break;
    case LYXP_TOKEN_FUNCNAME:
      pcVar1 = "FunctionName";
      break;
    case LYXP_TOKEN_OPERATOR_LOG:
      pcVar1 = "Operator(Logic)";
      break;
    case LYXP_TOKEN_OPERATOR_COMP:
      pcVar1 = "Operator(Comparison)";
      break;
    case LYXP_TOKEN_OPERATOR_MATH:
      pcVar1 = "Operator(Math)";
      break;
    case LYXP_TOKEN_OPERATOR_UNI:
      pcVar1 = "Operator(Union)";
      break;
    case LYXP_TOKEN_OPERATOR_PATH:
      pcVar1 = "Operator(Path)";
      break;
    case LYXP_TOKEN_LITERAL:
      pcVar1 = "Literal";
      break;
    case LYXP_TOKEN_NUMBER:
      pcVar1 = "Number";
    }
  }
  return pcVar1;
}



void print_expr_struct_debug(lyxp_expr *exp)

{
  char cVar1;
  ushort uVar2;
  ushort uVar3;
  lyxp_expr_type lVar4;
  long lVar5;
  char *pcVar6;
  size_t sVar7;
  ulong uVar8;
  char *pcVar9;
  long in_FS_OFFSET;
  byte bVar10;
  lyxp_expr *exp_local;
  uint16_t i;
  uint16_t j;
  char tmp [128];
  
  bVar10 = 0;
  lVar5 = *(long *)(in_FS_OFFSET + 0x28);
  if ((exp != (lyxp_expr *)0x0) && (2 < ly_log_level)) {
    ly_log_dbg(8,"expression \"%s\":",exp->expr);
    for (i = 0; i < exp->used; i = i + 1) {
      pcVar9 = exp->expr;
      uVar2 = exp->expr_pos[i];
      uVar3 = exp->tok_len[i];
      pcVar6 = print_token(exp->tokens[i]);
      sprintf(tmp,"\ttoken %s, in expression \"%.*s\"",pcVar6,(ulong)uVar3,pcVar9 + uVar2);
      if (exp->repeat[i] != (lyxp_expr_type *)0x0) {
        lVar4 = *exp->repeat[i];
        sVar7 = strlen(tmp);
        sprintf(tmp + sVar7," (repeat %d",(ulong)lVar4);
        for (j = 1; exp->repeat[i][j] != LYXP_EXPR_NONE; j = j + 1) {
          lVar4 = exp->repeat[i][j];
          sVar7 = strlen(tmp);
          sprintf(tmp + sVar7,", %d",(ulong)lVar4);
        }
        uVar8 = 0xffffffffffffffff;
        pcVar9 = tmp;
        do {
          if (uVar8 == 0) break;
          uVar8 = uVar8 - 1;
          cVar1 = *pcVar9;
          pcVar9 = pcVar9 + (ulong)bVar10 * -2 + 1;
        } while (cVar1 != '\0');
        (tmp + (~uVar8 - 1))[0] = ')';
        (tmp + (~uVar8 - 1))[1] = '\0';
      }
      ly_log_dbg(8,tmp);
    }
  }
  if (lVar5 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void print_set_debug(lyxp_set *set)

{
  lyxp_node_type lVar1;
  int iVar2;
  char *pcVar3;
  long in_FS_OFFSET;
  lyxp_set *set_local;
  uint32_t i;
  char *str_num;
  lyxp_set_snode *sitem;
  lyxp_set_node *item;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (2 < ly_log_level) {
    switch(set->type) {
    case LYXP_SET_EMPTY:
      ly_log_dbg(8,"set EMPTY");
      break;
    case LYXP_SET_NODE_SET:
      ly_log_dbg(8,"set NODE SET:");
      for (i = 0; i < set->used; i = i + 1) {
        item = (set->val).nodes + i;
        switch(item->type) {
        case LYXP_NODE_ROOT:
          ly_log_dbg(8,"\t%d (pos %u): ROOT",(ulong)(i + 1),(ulong)item->pos);
          break;
        case LYXP_NODE_ROOT_CONFIG:
          ly_log_dbg(8,"\t%d (pos %u): ROOT CONFIG",(ulong)(i + 1),(ulong)item->pos);
          break;
        case LYXP_NODE_ELEM:
          if ((item->node->schema->nodetype == LYS_LIST) &&
             (item->node->child->schema->nodetype == LYS_LEAF)) {
            ly_log_dbg(8,"\t%d (pos %u): ELEM %s (1st child val: %s)",(ulong)(i + 1),
                       (ulong)item->pos,item->node->schema->name,item->node->child->ht);
          }
          else if (item->node->schema->nodetype == LYS_LEAFLIST) {
            ly_log_dbg(8,"\t%d (pos %u): ELEM %s (val: %s)",(ulong)(i + 1),(ulong)item->pos,
                       item->node->schema->name,item->node->ht);
          }
          else {
            ly_log_dbg(8,"\t%d (pos %u): ELEM %s",(ulong)(i + 1),(ulong)item->pos,
                       item->node->schema->name);
          }
          break;
        case LYXP_NODE_TEXT:
          if ((item->node->schema->nodetype & LYS_ANYDATA) == LYS_UNKNOWN) {
            ly_log_dbg(8,"\t%d (pos %u): TEXT %s",(ulong)(i + 1),(ulong)item->pos,item->node->ht);
          }
          else {
            if (item->node->schema->nodetype == LYS_ANYXML) {
              pcVar3 = "anyxml";
            }
            else {
              pcVar3 = "anydata";
            }
            ly_log_dbg(8,"\t%d (pos %u): TEXT <%s>",(ulong)(i + 1),(ulong)item->pos,pcVar3);
          }
          break;
        case LYXP_NODE_ATTR:
          ly_log_dbg(8,"\t%d (pos %u): ATTR %s = %s",(ulong)(i + 1),(ulong)item->pos,
                     ((set->val).nodes[i].node)->next,((set->val).nodes[i].node)->parent);
          break;
        default:
          ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                 ,0xf4);
        }
      }
      break;
    case LYXP_SET_SNODE_SET:
      ly_log_dbg(8,"set SNODE SET:");
      for (i = 0; i < set->used; i = i + 1) {
        sitem = (lyxp_set_snode *)((set->val).nodes + i);
        lVar1 = ((lyxp_set_node *)sitem)->type;
        if (lVar1 == LYXP_NODE_ELEM) {
          ly_log_dbg(8,"\t%d (%u): ELEM %s",(ulong)(i + 1),(ulong)((lyxp_set_node *)sitem)->pos,
                     ((lyxp_set_node *)sitem)->node->schema);
        }
        else if (lVar1 < LYXP_NODE_TEXT) {
          if (lVar1 == LYXP_NODE_ROOT) {
            ly_log_dbg(8,"\t%d (%u): ROOT",(ulong)(i + 1),(ulong)((lyxp_set_node *)sitem)->pos);
          }
          else {
            if (lVar1 != LYXP_NODE_ROOT_CONFIG) goto LAB_001c816c;
            ly_log_dbg(8,"\t%d (%u): ROOT CONFIG",(ulong)(i + 1),
                       (ulong)((lyxp_set_node *)sitem)->pos);
          }
        }
        else {
LAB_001c816c:
          ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                 ,0x10a);
        }
      }
      break;
    case LYXP_SET_BOOLEAN:
      ly_log_dbg(8,"set BOOLEAN");
      if ((set->val).bool == 0) {
        pcVar3 = "false";
      }
      else {
        pcVar3 = "true";
      }
      ly_log_dbg(8,"\t%s",pcVar3);
      break;
    case LYXP_SET_NUMBER:
      ly_log_dbg(8,"set NUMBER");
      if (NAN((set->val).num)) {
        str_num = strdup("NaN");
      }
      else if (((true) && ((longdouble)0 == (set->val).num)) ||
              ((true && ((longdouble)0 == (set->val).num)))) {
        str_num = strdup("0");
      }
      else if ((ABS((set->val).num) <= _DAT_0022ccf0) || ((set->val).num < (longdouble)0)) {
        if ((ABS((set->val).num) <= _DAT_0022ccf0) || ((longdouble)0 <= (set->val).num)) {
          if ((false) || ((set->val).num != (longdouble)(long)ROUND((set->val).num))) {
            iVar2 = asprintf(&str_num,"%03.1Lf");
            if (iVar2 == -1) {
              str_num = (char *)0x0;
            }
          }
          else {
            iVar2 = asprintf(&str_num,"%lld",(long)ROUND((set->val).num));
            if (iVar2 == -1) {
              str_num = (char *)0x0;
            }
          }
        }
        else {
          str_num = strdup("-Infinity");
        }
      }
      else {
        str_num = strdup("Infinity");
      }
      if (str_num == (char *)0x0) {
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","print_set_debug");
      }
      else {
        ly_log_dbg(8,"\t%s",str_num);
        free(str_num);
      }
      break;
    case LYXP_SET_STRING:
      ly_log_dbg(8,"set STRING");
      ly_log_dbg(8,"\t%s",(set->val).nodes);
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int cast_string_realloc(ly_ctx *ctx,uint16_t needed,char **str,uint16_t *used,uint16_t *size)

{
  char *pcVar1;
  uint16_t *size_local;
  uint16_t *used_local;
  char **str_local;
  uint16_t needed_local;
  ly_ctx *ctx_local;
  
  if ((int)((uint)*size - (uint)*used) < (int)(uint)needed) {
    do {
      if ((int)(0xffff - (uint)*size) < 0x10) {
        ly_log(ctx,LY_LLERR,LY_EINVAL,"XPath string length limit (%u) reached.",0xffff);
        return -1;
      }
      *size = *size + 0x10;
    } while ((int)((uint)*size - (uint)*used) < (int)(uint)needed);
    pcVar1 = (char *)ly_realloc(*str,(ulong)*size);
    *str = pcVar1;
    if (*str == (char *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","cast_string_realloc");
      return -1;
    }
  }
  return 0;
}



int cast_string_recursive
              (lyd_node *node,lys_module *param_2,int fake_cont,lyxp_node_type root_type,
              uint16_t indent,char **str,uint16_t *used,uint16_t *size)

{
  ushort uVar1;
  uint16_t uVar2;
  LYS_NODE LVar3;
  char *pcVar4;
  int iVar5;
  size_t sVar6;
  long in_FS_OFFSET;
  uint16_t *size_local;
  uint16_t *used_local;
  char **str_local;
  uint16_t indent_local;
  lyxp_node_type root_type_local;
  int fake_cont_local;
  lys_module *local_mod_local;
  lyd_node *node_local;
  char *buf;
  char *ptr;
  char *line;
  char *value_str;
  lyd_node *child;
  lyd_node_anydata *any;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if ((root_type == LYXP_NODE_ROOT_CONFIG) && ((node->schema->flags & 2) != 0)) {
    iVar5 = 0;
    goto LAB_001c8cf9;
  }
  indent_local = indent;
  if (fake_cont != 0) {
    iVar5 = cast_string_realloc(param_2->ctx,1,str,used,size);
    if (iVar5 != 0) {
      iVar5 = -1;
      goto LAB_001c8cf9;
    }
    pcVar4 = *str;
    uVar1 = *used;
    (pcVar4 + ((ulong)uVar1 - 1))[0] = '\n';
    (pcVar4 + ((ulong)uVar1 - 1))[1] = '\0';
    *used = *used + 1;
    indent_local = indent + 1;
  }
  LVar3 = node->schema->nodetype;
  if (LVar3 != LYS_ANYDATA) {
    if (LYS_ANYDATA < LVar3) {
switchD_001c86ed_caseD_2:
      ly_log(param_2->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
             ,0x1df);
      iVar5 = -1;
      goto LAB_001c8cf9;
    }
    if (LVar3 != LYS_RPC) {
      if (LVar3 < (LYS_CONTAINER|LYS_RPC)) {
        if (LVar3 < (LYS_CONTAINER|LYS_ANYXML)) {
          if ((LVar3 != LYS_UNKNOWN) && (true)) {
            switch(LVar3) {
            case LYS_CONTAINER:
            case LYS_LIST:
              goto switchD_001c86ed_caseD_1;
            case LYS_LEAF:
            case LYS_LEAFLIST:
              value_str = (char *)node->ht;
              if ((hash_table *)value_str == (hash_table *)0x0) {
                value_str = "";
              }
              sVar6 = strlen(value_str);
              iVar5 = cast_string_realloc(param_2->ctx,(short)sVar6 + indent_local * 2 + 1,str,used,
                                          size);
              if (iVar5 != 0) {
                iVar5 = -1;
                goto LAB_001c8cf9;
              }
              memset(*str + ((ulong)*used - 1),0x20,(long)(int)((uint)indent_local * 2));
              *used = indent_local * 2 + *used;
              if (*used == 1) {
                sprintf(*str + ((ulong)*used - 1),"%s",value_str);
                uVar2 = *used;
                sVar6 = strlen(value_str);
                *used = uVar2 + (short)sVar6;
              }
              else {
                sprintf(*str + ((ulong)*used - 1),"%s\n",value_str);
                uVar2 = *used;
                sVar6 = strlen(value_str);
                *used = (short)sVar6 + uVar2 + 1;
              }
              goto LAB_001c8c8a;
            case LYS_ANYXML:
              goto switchD_001c86ed_caseD_20;
            }
          }
        }
        else if (LVar3 == LYS_NOTIF) goto switchD_001c86ed_caseD_1;
      }
      goto switchD_001c86ed_caseD_2;
    }
switchD_001c86ed_caseD_1:
    iVar5 = cast_string_realloc(param_2->ctx,1,str,used,size);
    if (iVar5 != 0) {
      iVar5 = -1;
      goto LAB_001c8cf9;
    }
    pcVar4 = *str;
    uVar1 = *used;
    (pcVar4 + ((ulong)uVar1 - 1))[0] = '\n';
    (pcVar4 + ((ulong)uVar1 - 1))[1] = '\0';
    *used = *used + 1;
    for (child = node->child; child != (lyd_node *)0x0; child = child->next) {
      iVar5 = cast_string_recursive(child,param_2,0,root_type,indent_local + 1,str,used,size);
      if (iVar5 != 0) {
        iVar5 = -1;
        goto LAB_001c8cf9;
      }
    }
    goto LAB_001c8c8a;
  }
switchD_001c86ed_caseD_20:
  any = (lyd_node_anydata *)node;
  if (node->ht == (hash_table *)0x0) {
    buf = strdup("");
    if (buf == (char *)0x0) {
      ly_log(param_2->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
             "cast_string_recursive");
      iVar5 = -1;
      goto LAB_001c8cf9;
    }
    goto switchD_001c89cd_caseD_6;
  }
  if (false) goto switchD_001c89cd_caseD_6;
  switch(*(undefined4 *)&node->field_0x34) {
  case 0:
  case 2:
  case 4:
    buf = strdup((char *)node->ht);
    if (buf == (char *)0x0) {
      ly_log(param_2->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
             "cast_string_recursive");
      iVar5 = -1;
      goto LAB_001c8cf9;
    }
    break;
  case 1:
  case 3:
  case 5:
  case 0x21:
    ly_log(param_2->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
           ,0x1c6);
    iVar5 = -1;
    goto LAB_001c8cf9;
  case 8:
    iVar5 = lyxml_print_mem(&buf,(lyxml_elem *)node->ht,0x10);
    if (iVar5 == 0) {
      iVar5 = -1;
      goto LAB_001c8cf9;
    }
    break;
  case 0x10:
    iVar5 = lyd_print_mem(&buf,(lyd_node *)node->ht,LYD_XML,1);
    if (iVar5 != 0) {
      iVar5 = -1;
      goto LAB_001c8cf9;
    }
    break;
  case 0x20:
    ly_log(param_2->ctx,LY_LLERR,LY_EINVAL,"Cannot convert LYB anydata into string.");
    iVar5 = -1;
    goto LAB_001c8cf9;
  }
switchD_001c89cd_caseD_6:
  line = strtok_r(buf,"\n",&ptr);
  do {
    sVar6 = strlen(line);
    iVar5 = cast_string_realloc(param_2->ctx,(short)sVar6 + indent_local * 2 + 1,str,used,size);
    if (iVar5 != 0) {
      free(buf);
      iVar5 = -1;
      goto LAB_001c8cf9;
    }
    memset(*str + ((ulong)*used - 1),0x20,(long)(int)((uint)indent_local * 2));
    *used = indent_local * 2 + *used;
    strcpy(*str + ((ulong)*used - 1),line);
    uVar2 = *used;
    sVar6 = strlen(line);
    *used = uVar2 + (short)sVar6;
    pcVar4 = *str;
    uVar1 = *used;
    (pcVar4 + ((ulong)uVar1 - 1))[0] = '\n';
    (pcVar4 + ((ulong)uVar1 - 1))[1] = '\0';
    *used = *used + 1;
    line = strtok_r((char *)0x0,"\n",&ptr);
  } while (line != (char *)0x0);
  free(buf);
LAB_001c8c8a:
  if (fake_cont != 0) {
    iVar5 = cast_string_realloc(param_2->ctx,1,str,used,size);
    if (iVar5 != 0) {
      iVar5 = -1;
      goto LAB_001c8cf9;
    }
    pcVar4 = *str;
    uVar1 = *used;
    (pcVar4 + ((ulong)uVar1 - 1))[0] = '\n';
    (pcVar4 + ((ulong)uVar1 - 1))[1] = '\0';
    *used = *used + 1;
  }
  iVar5 = 0;
LAB_001c8cf9:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar5;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * cast_string_elem(lyd_node *node,lys_module *param_2,int fake_cont,lyxp_node_type root_type)

{
  int iVar1;
  char *pcVar2;
  long in_FS_OFFSET;
  lyxp_node_type root_type_local;
  int fake_cont_local;
  lys_module *local_mod_local;
  lyd_node *node_local;
  uint16_t used;
  uint16_t size;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  str = (char *)malloc(0x40);
  if (str == (char *)0x0) {
    ly_log(param_2->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","cast_string_elem");
    pcVar2 = (char *)0x0;
  }
  else {
    *str = '\0';
    used = 1;
    size = 0x40;
    iVar1 = cast_string_recursive(node,param_2,fake_cont,root_type,0,&str,&used,&size);
    if (iVar1 == 0) {
      pcVar2 = str;
      if ((used < size) &&
         (pcVar2 = (char *)ly_realloc(str,(ulong)used), str = pcVar2, pcVar2 == (char *)0x0)) {
        free((void *)0x0);
        ly_log(param_2->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","cast_string_elem");
        pcVar2 = (char *)0x0;
      }
    }
    else {
      free(str);
      pcVar2 = (char *)0x0;
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return pcVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * cast_node_set_to_string(lyxp_set *set,lyd_node *cur_node,lys_module *param_3,int options)

{
  lyxp_node_type lVar1;
  char *pcVar2;
  long in_FS_OFFSET;
  int options_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  lyxp_set *set_local;
  lyxp_node_type root_type;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((((set->val).nodes)->type == LYXP_NODE_ATTR) ||
     (-1 < (char)((set->val).nodes)->node->validity)) {
    moveto_get_root(cur_node,options,&root_type);
    lVar1 = ((set->val).nodes)->type;
    if (lVar1 == LYXP_NODE_ATTR) {
      str = strdup(((set->val).attrs)->attr->value_str);
      pcVar2 = str;
      if (str == (char *)0x0) {
        ly_log(param_3->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "cast_node_set_to_string");
        pcVar2 = str;
      }
    }
    else {
      if (lVar1 < LYXP_NODE_NONE) {
        if (lVar1 < LYXP_NODE_ELEM) {
          pcVar2 = cast_string_elem(((set->val).nodes)->node,param_3,1,root_type);
          goto LAB_001c901d;
        }
        if (lVar1 + ~LYXP_NODE_ROOT_CONFIG < 2) {
          pcVar2 = cast_string_elem(((set->val).nodes)->node,param_3,0,root_type);
          goto LAB_001c901d;
        }
      }
      ly_log(param_3->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
             ,0x239);
      pcVar2 = (char *)0x0;
    }
  }
  else {
    ly_vlog(param_3->ctx,LYE_XPATH_DUMMY,LY_VLOG_LYD,((set->val).nodes)->node,
            ((set->val).nodes)->node->schema->name);
    pcVar2 = (char *)0x0;
  }
LAB_001c901d:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return pcVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

longdouble * cast_string_to_number(longdouble *__return_storage_ptr__,char *str)

{
  int *piVar1;
  long in_FS_OFFSET;
  longdouble in_ST0;
  char *str_local;
  char *ptr;
  longdouble num;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  piVar1 = __errno_location();
  *piVar1 = 0;
  strtold((char *)__return_storage_ptr__,&ptr);
  num = in_ST0;
  piVar1 = __errno_location();
  if ((*piVar1 != 0) || (*ptr != '\0')) {
    num = _DAT_0022cd00;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (longdouble *)0x0;
}



int set_values_equal_cb(void *val1_p,void *val2_p,int UNUSED_mod,void *UNUSED_cb_data)

{
  int iVar1;
  void *UNUSED_cb_data_local;
  int UNUSED_mod_local;
  void *val2_p_local;
  void *val1_p_local;
  lyxp_set_hash_node *val1;
  lyxp_set_hash_node *val2;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  if ((*val1_p == *val2_p) && (*(int *)((long)val1_p + 8) == *(int *)((long)val2_p + 8))) {
    iVar1 = 1;
  }
  else {
    iVar1 = 0;
  }
  return iVar1;
}



void set_insert_node_hash(lyxp_set *set,lyd_node *node,lyxp_node_type type)

{
  long lVar1;
  uint32_t uVar2;
  int iVar3;
  hash_table *phVar4;
  long in_FS_OFFSET;
  lyxp_node_type type_local;
  lyd_node *node_local;
  lyxp_set *set_local;
  uint32_t i;
  uint32_t hash;
  int r;
  lyxp_set_hash_node hnode;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if ((set->ht == (hash_table *)0x0) && (3 < set->used)) {
    phVar4 = lyht_new(1,0xc,set_values_equal_cb,(void *)0x0,1);
    set->ht = phVar4;
    for (i = 0; i < set->used; i = i + 1) {
      hnode.node = (set->val).nodes[i].node;
      hnode.type = (set->val).nodes[i].type;
      uVar2 = dict_hash_multi(0,(char *)&hnode,8);
      uVar2 = dict_hash_multi(uVar2,(char *)&hnode.type,4);
      uVar2 = dict_hash_multi(uVar2,(char *)0x0,0);
      iVar3 = lyht_insert(set->ht,&hnode,uVar2,(void **)0x0);
      if (iVar3 != 0) {
                    // WARNING: Subroutine does not return
        __assert_fail("!r",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x27a,"set_insert_node_hash");
      }
    }
  }
  else if (set->ht != (hash_table *)0x0) {
    if (node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("node",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x27e,"set_insert_node_hash");
    }
    hnode.node = node;
    hnode.type = type;
    uVar2 = dict_hash_multi(0,(char *)&hnode,8);
    uVar2 = dict_hash_multi(uVar2,(char *)&hnode.type,4);
    uVar2 = dict_hash_multi(uVar2,(char *)0x0,0);
    iVar3 = lyht_insert(set->ht,&hnode,uVar2,(void **)0x0);
    if (iVar3 != 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("!r",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x289,"set_insert_node_hash");
    }
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void set_remove_node_hash(lyxp_set *set,lyd_node *node,lyxp_node_type type)

{
  long lVar1;
  uint32_t uVar2;
  int iVar3;
  long in_FS_OFFSET;
  lyxp_node_type type_local;
  lyd_node *node_local;
  lyxp_set *set_local;
  uint32_t hash;
  int r;
  lyxp_set_hash_node hnode;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (set->ht != (hash_table *)0x0) {
    hnode.node = node;
    hnode.type = type;
    uVar2 = dict_hash_multi(0,(char *)&hnode,8);
    uVar2 = dict_hash_multi(uVar2,(char *)&hnode.type,4);
    uVar2 = dict_hash_multi(uVar2,(char *)0x0,0);
    iVar3 = lyht_remove(set->ht,&hnode,uVar2);
    if (iVar3 != 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("!r",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x29e,"set_remove_node_hash");
    }
    if (set->ht->used == 0) {
      lyht_free(set->ht);
      set->ht = (hash_table *)0x0;
    }
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int set_dup_node_hash_check(lyxp_set *set,lyd_node *node,lyxp_node_type type,int skip_idx)

{
  long lVar1;
  uint32_t uVar2;
  int iVar3;
  long in_FS_OFFSET;
  int skip_idx_local;
  lyxp_node_type type_local;
  lyd_node *node_local;
  lyxp_set *set_local;
  uint32_t hash;
  lyxp_set_hash_node *match_p;
  lyxp_set_hash_node hnode;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  hnode.node = node;
  hnode.type = type;
  uVar2 = dict_hash_multi(0,(char *)&hnode,8);
  uVar2 = dict_hash_multi(uVar2,(char *)&hnode.type,4);
  uVar2 = dict_hash_multi(uVar2,(char *)0x0,0);
  iVar3 = lyht_find(set->ht,&hnode,uVar2,&match_p);
  if (iVar3 == 0) {
    if (((-1 < skip_idx) && ((set->val).nodes[skip_idx].node == match_p->node)) &&
       ((set->val).nodes[skip_idx].type == match_p->type)) {
      hnode.node = match_p->node;
      hnode.type = match_p->type;
      iVar3 = lyht_find_next(set->ht,&hnode,uVar2,&match_p);
      if (iVar3 != 0) {
        iVar3 = 0;
        goto LAB_001c9597;
      }
    }
    iVar3 = 1;
  }
  else {
    iVar3 = 0;
  }
LAB_001c9597:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar3;
}



void set_free_content(lyxp_set *set)

{
  lyxp_set *set_local;
  
  if (set != (lyxp_set *)0x0) {
    if (set->type == LYXP_SET_NODE_SET) {
      free((set->val).nodes);
      lyht_free(set->ht);
      set->ht = (hash_table *)0x0;
    }
    else if (set->type == LYXP_SET_SNODE_SET) {
      free((set->val).nodes);
    }
    else if (set->type == LYXP_SET_STRING) {
      free((set->val).nodes);
    }
    set->type = LYXP_SET_EMPTY;
  }
  return;
}



void lyxp_set_free(lyxp_set *set)

{
  lyxp_set *set_local;
  
  if (set != (lyxp_set *)0x0) {
    set_free_content(set);
    free(set);
  }
  return;
}



lyxp_set * set_copy(lyxp_set *set)

{
  int iVar1;
  lyxp_set *set_00;
  lyxp_set_node *plVar2;
  hash_table *phVar3;
  char *pcVar4;
  lyxp_set *set_local;
  uint16_t i;
  lyxp_set *ret;
  
  if (set == (lyxp_set *)0x0) {
    set_00 = (lyxp_set *)0x0;
  }
  else {
    set_00 = (lyxp_set *)malloc(0x40);
    if (set_00 == (lyxp_set *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","set_copy");
      set_00 = (lyxp_set *)0x0;
    }
    else if (set->type == LYXP_SET_SNODE_SET) {
      memset(set_00,0,0x40);
      set_00->type = set->type;
      for (i = 0; (uint)i < set->used; i = i + 1) {
        if (((set->val).nodes[i].pos == 1) &&
           (iVar1 = set_snode_insert_node
                              (set_00,(lys_node *)(set->val).nodes[i].node,(set->val).nodes[i].type)
           , iVar1 != 0)) {
          lyxp_set_free(set_00);
          return (lyxp_set *)0x0;
        }
      }
    }
    else if (set->type == LYXP_SET_NODE_SET) {
      set_00->type = set->type;
      plVar2 = (lyxp_set_node *)malloc((ulong)set->used << 4);
      (set_00->val).nodes = plVar2;
      if ((set_00->val).nodes == (lyxp_set_node *)0x0) {
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","set_copy");
        free(set_00);
        set_00 = (lyxp_set *)0x0;
      }
      else {
        memcpy((set_00->val).nodes,(set->val).nodes,(ulong)set->used << 4);
        set_00->size = set->used;
        set_00->used = set_00->size;
        set_00->ctx_pos = set->ctx_pos;
        set_00->ctx_size = set->ctx_size;
        phVar3 = lyht_dup(set->ht);
        set_00->ht = phVar3;
      }
    }
    else {
      memcpy(set_00,set,0x40);
      if (set->type == LYXP_SET_STRING) {
        pcVar4 = strdup((set->val).str);
        (set_00->val).str = pcVar4;
        if ((set_00->val).nodes == (lyxp_set_node *)0x0) {
          ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","set_copy");
          free(set_00);
          set_00 = (lyxp_set *)0x0;
        }
      }
    }
  }
  return set_00;
}



void set_fill_string(lyxp_set *set,char *string,uint16_t str_len)

{
  char *pcVar1;
  uint16_t str_len_local;
  char *string_local;
  lyxp_set *set_local;
  
  set_free_content(set);
  set->type = LYXP_SET_STRING;
  string_local = string;
  if ((str_len == 0) && (*string != '\0')) {
    string_local = "";
  }
  pcVar1 = strndup(string_local,(ulong)str_len);
  (set->val).str = pcVar1;
  return;
}



void set_fill_number(lyxp_set *set,longdouble number)

{
  lyxp_set *set_local;
  
  set_free_content(set);
  set->type = LYXP_SET_NUMBER;
  (set->val).num = number;
  return;
}



void set_fill_boolean(lyxp_set *set,int boolean)

{
  int boolean_local;
  lyxp_set *set_local;
  
  set_free_content(set);
  set->type = LYXP_SET_BOOLEAN;
  (set->val).bool = boolean;
  return;
}



void set_fill_set(lyxp_set *trg,lyxp_set *src)

{
  lyxp_set_node *plVar1;
  size_t sVar2;
  hash_table *phVar3;
  lyxp_set *src_local;
  lyxp_set *trg_local;
  
  if ((trg != (lyxp_set *)0x0) && (src != (lyxp_set *)0x0)) {
    if (src->type == LYXP_SET_SNODE_SET) {
      trg->type = LYXP_SET_SNODE_SET;
      trg->used = src->used;
      trg->size = src->used;
      plVar1 = (lyxp_set_node *)ly_realloc((trg->val).nodes,(ulong)trg->size << 4);
      (trg->val).nodes = plVar1;
      if ((trg->val).nodes == (lyxp_set_node *)0x0) {
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","set_fill_set");
        memset(trg,0,0x40);
      }
      else {
        memcpy((trg->val).nodes,(src->val).nodes,(ulong)src->used << 4);
      }
    }
    else if (src->type == LYXP_SET_BOOLEAN) {
      set_fill_boolean(trg,(src->val).bool);
    }
    else if (src->type == LYXP_SET_NUMBER) {
      set_fill_number(trg,(src->val).num);
    }
    else if (src->type == LYXP_SET_STRING) {
      sVar2 = strlen((src->val).str);
      set_fill_string(trg,(src->val).str,(uint16_t)sVar2);
    }
    else {
      if (trg->type == LYXP_SET_NODE_SET) {
        free((trg->val).nodes);
      }
      else if (trg->type == LYXP_SET_STRING) {
        free((trg->val).nodes);
      }
      if (src->type == LYXP_SET_EMPTY) {
        trg->type = LYXP_SET_EMPTY;
      }
      else {
        if (src->type != LYXP_SET_NODE_SET) {
                    // WARNING: Subroutine does not return
          __assert_fail("src->type == LYXP_SET_NODE_SET",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                        ,0x378,"set_fill_set");
        }
        trg->type = LYXP_SET_NODE_SET;
        trg->used = src->used;
        trg->size = src->used;
        trg->ctx_pos = src->ctx_pos;
        trg->ctx_size = src->ctx_size;
        plVar1 = (lyxp_set_node *)malloc((ulong)trg->used << 4);
        (trg->val).nodes = plVar1;
        if ((trg->val).nodes == (lyxp_set_node *)0x0) {
          ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","set_fill_set");
          memset(trg,0,0x40);
        }
        else {
          memcpy((trg->val).nodes,(src->val).nodes,(ulong)src->used << 4);
          phVar3 = lyht_dup(src->ht);
          trg->ht = phVar3;
        }
      }
    }
  }
  return;
}



void set_snode_clear_ctx(lyxp_set *set)

{
  lyxp_set *set_local;
  uint32_t i;
  
  for (i = 0; i < set->used; i = i + 1) {
    if ((set->val).nodes[i].pos == 1) {
      (set->val).nodes[i].pos = 0;
    }
  }
  return;
}



void set_remove_node(lyxp_set *set,uint32_t idx)

{
  uint32_t idx_local;
  lyxp_set *set_local;
  
  if ((set != (lyxp_set *)0x0) && (set->type == LYXP_SET_NODE_SET)) {
    if (set->used <= idx) {
                    // WARNING: Subroutine does not return
      __assert_fail("idx < set->used",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x3a3,"set_remove_node");
    }
    set_remove_node_hash(set,(set->val).nodes[idx].node,(set->val).nodes[idx].type);
    set->used = set->used - 1;
    if (set->used == 0) {
      set_free_content(set);
      memset(set,0,0x40);
    }
    else {
      memmove((set->val).nodes + idx,(set->val).nodes + (idx + 1),(ulong)(set->used - idx) << 4);
    }
    return;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("set && (set->type == LYXP_SET_NODE_SET)",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                ,0x3a2,"set_remove_node");
}



void set_remove_none_nodes(lyxp_set *set)

{
  ushort uVar1;
  ushort uVar2;
  lyxp_set *set_local;
  uint16_t i;
  uint16_t end;
  uint16_t orig_used;
  int32_t start;
  
  if ((set == (lyxp_set *)0x0) || (set->type != LYXP_SET_NODE_SET)) {
                    // WARNING: Subroutine does not return
    __assert_fail("set && (set->type == LYXP_SET_NODE_SET)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x3c1,"set_remove_none_nodes");
  }
  uVar2 = (ushort)set->used;
  set->used = 0;
  i = 0;
  do {
    if (uVar2 <= i) {
      if (set->used == 0) {
        set_free_content(set);
        memset(set,0,0x40);
      }
      return;
    }
    start = -1;
    uVar1 = i;
    do {
      i = uVar1;
      if (((set->val).nodes[i].type == LYXP_NODE_NONE) || (start != -1)) {
        if ((-1 < start) && ((set->val).nodes[i].type == LYXP_NODE_NONE)) {
          end = i;
          break;
        }
      }
      else {
        start = (int32_t)i;
      }
      uVar1 = i + 1;
      if (uVar1 == uVar2) {
        end = uVar1;
      }
    } while (uVar1 < uVar2);
    i = i + 1;
    if (-1 < start) {
      if (set->used != start) {
        memmove((set->val).nodes + set->used,(set->val).nodes + start,
                (long)(int)((uint)end - start) << 4);
      }
      set->used = set->used + ((uint)end - start);
    }
  } while( true );
}



int set_dup_node_check(lyxp_set *set,lyd_node *node,lyxp_node_type node_type,int skip_idx)

{
  int iVar1;
  int skip_idx_local;
  lyxp_node_type node_type_local;
  lyd_node *node_local;
  lyxp_set *set_local;
  uint32_t i;
  
  if (set->ht == (hash_table *)0x0) {
    for (i = 0; i < set->used; i = i + 1) {
      if ((((skip_idx < 0) || (i != skip_idx)) && (node == (set->val).nodes[i].node)) &&
         (node_type == (set->val).nodes[i].type)) {
        return 1;
      }
    }
    iVar1 = 0;
  }
  else {
    iVar1 = set_dup_node_hash_check(set,node,node_type,skip_idx);
  }
  return iVar1;
}



int set_snode_dup_node_check(lyxp_set *set,lys_node *node,lyxp_node_type node_type,int skip_idx)

{
  int skip_idx_local;
  lyxp_node_type node_type_local;
  lys_node *node_local;
  lyxp_set *set_local;
  uint32_t i;
  
  i = 0;
  while( true ) {
    if (set->used <= i) {
      return -1;
    }
    if ((((skip_idx < 0) || (i != skip_idx)) && (node == (lys_node *)(set->val).nodes[i].node)) &&
       (node_type == (set->val).nodes[i].type)) break;
    i = i + 1;
  }
  return i;
}



void set_snode_merge(lyxp_set *set1,lyxp_set *set2)

{
  uint uVar1;
  lyxp_node_type lVar2;
  uint32_t uVar3;
  lyxp_set_node *plVar4;
  lyxp_set_node *plVar5;
  lyxp_set *set2_local;
  lyxp_set *set1_local;
  uint32_t i;
  uint32_t j;
  uint32_t orig_used;
  
  if (((set1->type == LYXP_SET_SNODE_SET) || (set1->type == LYXP_SET_EMPTY)) &&
     ((set2->type == LYXP_SET_SNODE_SET || (set2->type == LYXP_SET_EMPTY)))) {
    if (set2->type != LYXP_SET_EMPTY) {
      if (set1->type == LYXP_SET_EMPTY) {
        memcpy(set1,set2,0x40);
      }
      else {
        if (set1->size < set1->used + set2->used) {
          set1->size = set1->used + set2->used;
          plVar4 = (lyxp_set_node *)ly_realloc((set1->val).nodes,(ulong)set1->size << 4);
          (set1->val).nodes = plVar4;
          if ((set1->val).nodes == (lyxp_set_node *)0x0) {
            ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "set_snode_merge");
            return;
          }
        }
        uVar1 = set1->used;
        for (i = 0; i < set2->used; i = i + 1) {
          j = 0;
          while ((j < uVar1 && ((set1->val).nodes[j].node != (set2->val).nodes[i].node))) {
            j = j + 1;
          }
          if (j == uVar1) {
            plVar5 = (set2->val).nodes + i;
            plVar4 = (set1->val).nodes + set1->used;
            lVar2 = plVar5->type;
            uVar3 = plVar5->pos;
            plVar4->node = plVar5->node;
            plVar4->type = lVar2;
            plVar4->pos = uVar3;
            set1->used = set1->used + 1;
          }
        }
        free((set2->val).nodes);
        memset(set2,0,0x40);
      }
    }
    return;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("((set1->type == LYXP_SET_SNODE_SET) || (set1->type == LYXP_SET_EMPTY)) && ((set2->type == LYXP_SET_SNODE_SET) || (set2->type == LYXP_SET_EMPTY))"
                ,
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                ,0x41e,"set_snode_merge");
}



void set_insert_node(lyxp_set *set,lyd_node *node,uint32_t pos,lyxp_node_type node_type,uint32_t idx
                    )

{
  lyxp_set_node *plVar1;
  uint32_t idx_local;
  lyxp_node_type node_type_local;
  uint32_t pos_local;
  lyd_node *node_local;
  lyxp_set *set_local;
  
  if ((set == (lyxp_set *)0x0) ||
     ((set->type != LYXP_SET_NODE_SET && (set->type != LYXP_SET_EMPTY)))) {
                    // WARNING: Subroutine does not return
    __assert_fail("set && ((set->type == LYXP_SET_NODE_SET) || (set->type == LYXP_SET_EMPTY))",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x450,"set_insert_node");
  }
  idx_local = idx;
  if (set->type == LYXP_SET_EMPTY) {
    if (idx != 0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
             ,0x456);
      idx_local = 0;
    }
    plVar1 = (lyxp_set_node *)malloc(0x20);
    (set->val).nodes = plVar1;
    if ((set->val).nodes == (lyxp_set_node *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","set_insert_node");
      return;
    }
    set->type = LYXP_SET_NODE_SET;
    set->used = 0;
    set->size = 2;
    set->ctx_pos = 1;
    set->ctx_size = 1;
    set->ht = (hash_table *)0x0;
  }
  else {
    if (set->used == set->size) {
      plVar1 = (lyxp_set_node *)ly_realloc((set->val).nodes,(ulong)(set->size + 2) << 4);
      (set->val).nodes = plVar1;
      if ((set->val).nodes == (lyxp_set_node *)0x0) {
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","set_insert_node");
        return;
      }
      set->size = set->size + 2;
    }
    if (set->used < idx) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
             ,0x46e);
      idx_local = set->used;
    }
    if (idx_local < set->used) {
      memmove((set->val).nodes + (idx_local + 1),(set->val).nodes + idx_local,
              (ulong)(set->used - idx_local) << 4);
    }
  }
  (set->val).nodes[idx_local].node = node;
  (set->val).nodes[idx_local].type = node_type;
  (set->val).nodes[idx_local].pos = pos;
  set->used = set->used + 1;
  set_insert_node_hash(set,node,node_type);
  return;
}



int set_snode_insert_node(lyxp_set *set,lys_node *node,lyxp_node_type node_type)

{
  uint32_t uVar1;
  lyxp_set_node *plVar2;
  lyxp_node_type node_type_local;
  lys_node *node_local;
  lyxp_set *set_local;
  int ret;
  
  if (set->type != LYXP_SET_SNODE_SET) {
                    // WARNING: Subroutine does not return
    __assert_fail("set->type == LYXP_SET_SNODE_SET",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x488,"set_snode_insert_node");
  }
  uVar1 = set_snode_dup_node_check(set,node,node_type,-1);
  if ((int)uVar1 < 0) {
    if (set->used == set->size) {
      plVar2 = (lyxp_set_node *)ly_realloc((set->val).nodes,(ulong)(set->size + 2) << 4);
      (set->val).nodes = plVar2;
      if ((set->val).nodes == (lyxp_set_node *)0x0) {
        ly_log(node->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "set_snode_insert_node");
        return -1;
      }
      set->size = set->size + 2;
    }
    uVar1 = set->used;
    (set->val).nodes[(int)uVar1].node = (lyd_node *)node;
    (set->val).nodes[(int)uVar1].type = node_type;
    (set->val).nodes[(int)uVar1].pos = 1;
    set->used = set->used + 1;
  }
  else {
    (set->val).nodes[(int)uVar1].pos = 1;
  }
  return uVar1;
}



void set_replace_node(lyxp_set *set,lyd_node *node,uint32_t pos,lyxp_node_type node_type,
                     uint32_t idx)

{
  uint32_t idx_local;
  lyxp_node_type node_type_local;
  uint32_t pos_local;
  lyd_node *node_local;
  lyxp_set *set_local;
  
  if ((set != (lyxp_set *)0x0) && (idx < set->used)) {
    set_remove_node_hash(set,(set->val).nodes[idx].node,(set->val).nodes[idx].type);
    (set->val).nodes[idx].node = node;
    (set->val).nodes[idx].type = node_type;
    (set->val).nodes[idx].pos = pos;
    set_insert_node_hash(set,(set->val).nodes[idx].node,(set->val).nodes[idx].type);
    return;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("set && (idx < set->used)",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                ,0x4aa,"set_replace_node");
}



uint32_t set_snode_new_in_ctx(lyxp_set *set)

{
  lyxp_set *set_local;
  uint32_t ret_ctx;
  uint32_t i;
  
  if (set->type != LYXP_SET_SNODE_SET) {
                    // WARNING: Subroutine does not return
    __assert_fail("set->type == LYXP_SET_SNODE_SET",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x4bc,"set_snode_new_in_ctx");
  }
  ret_ctx = 3;
  do {
    i = 0;
    while( true ) {
      if (set->used <= i) {
        for (i = 0; i < set->used; i = i + 1) {
          if ((set->val).nodes[i].pos == 1) {
            (set->val).nodes[i].pos = ret_ctx;
          }
        }
        return ret_ctx;
      }
      if (ret_ctx <= (set->val).nodes[i].pos) break;
      i = i + 1;
    }
    ret_ctx = (set->val).nodes[i].pos + 1;
  } while( true );
}



uint32_t get_node_pos(lyd_node *node,lyxp_node_type node_type,lyd_node *root,
                     lyxp_node_type root_type,lyd_node **prev,uint32_t *prev_pos)

{
  uint32_t *prev_pos_local;
  lyd_node **prev_local;
  lyd_node *root_local;
  lyxp_node_type root_type_local;
  lyxp_node_type node_type_local;
  lyd_node *node_local;
  uint32_t pos;
  lyd_node *next;
  lyd_node *elem;
  lyd_node *top_sibling;
  
  pos = 1;
  if (((prev == (lyd_node **)0x0) || (prev_pos == (uint32_t *)0x0)) ||
     (root->prev->next != (lyd_node *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("prev && prev_pos && !root->prev->next",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x4e3,"get_node_pos");
  }
  if ((node_type == LYXP_NODE_ROOT) || (node_type == LYXP_NODE_ROOT_CONFIG)) {
    return 0;
  }
  top_sibling = root;
  if (*prev == (lyd_node *)0x0) goto LAB_001cab96;
  pos = *prev_pos;
  elem = *prev;
  for (top_sibling = elem; top_sibling->parent != (lyd_node *)0x0; top_sibling = top_sibling->parent
      ) {
  }
  do {
    if ((root_type == LYXP_NODE_ROOT_CONFIG) && ((elem->schema->flags & 2) != 0)) {
LAB_001cab0d:
      if (elem != top_sibling) {
        next = elem->next;
LAB_001cab66:
        while ((next == (lyd_node *)0x0 && (elem->parent != top_sibling->parent))) {
          elem = elem->parent;
          next = elem->next;
        }
        elem = next;
        goto LAB_001cab75;
      }
      elem = (lyd_node *)0x0;
    }
    else if (elem != node) {
      pos = pos + 1;
      if ((elem->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
        next = elem->child;
      }
      else {
        next = (lyd_node *)0x0;
      }
      if (next == (lyd_node *)0x0) goto LAB_001cab0d;
      goto LAB_001cab66;
    }
    do {
      if (elem != (lyd_node *)0x0) {
LAB_001caba4:
        if (elem != (lyd_node *)0x0) {
          *prev = node;
          *prev_pos = pos;
          return pos;
        }
        if (*prev == (lyd_node *)0x0) {
          ly_log(node->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                 ,0x527);
          return 0;
        }
        *prev = (lyd_node *)0x0;
        *prev_pos = 0;
        pos = 1;
        elem = root;
        top_sibling = root;
        break;
      }
      top_sibling = top_sibling->next;
LAB_001cab96:
      if (top_sibling == (lyd_node *)0x0) goto LAB_001caba4;
      elem = top_sibling;
LAB_001cab75:
    } while (elem == (lyd_node *)0x0);
  } while( true );
}



int set_assign_pos(lyxp_set *set,lyd_node *root,lyxp_node_type root_type)

{
  lyxp_node_type lVar1;
  lyxp_set_node *plVar2;
  uint32_t uVar3;
  int iVar4;
  ulong uVar5;
  long in_FS_OFFSET;
  lyxp_node_type root_type_local;
  lyd_node *root_local;
  lyxp_set *set_local;
  uint32_t tmp_pos;
  uint32_t i;
  lyd_node *prev;
  lyd_node *tmp_node;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  prev = (lyd_node *)0x0;
  tmp_pos = 0;
  i = 0;
  do {
    if (set->used <= i) {
      iVar4 = 0;
LAB_001cade2:
      if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
        return iVar4;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    if ((set->val).nodes[i].pos == 0) {
      tmp_node = (lyd_node *)0x0;
      lVar1 = (set->val).nodes[i].type;
      if (lVar1 < LYXP_NODE_ATTR) {
        if (LYXP_NODE_ROOT_CONFIG < lVar1) {
LAB_001cad57:
          if (tmp_node == (lyd_node *)0x0) {
            tmp_node = (set->val).nodes[i].node;
          }
          plVar2 = (set->val).nodes;
          uVar5 = (ulong)i;
          uVar3 = get_node_pos(tmp_node,(set->val).nodes[i].type,root,root_type,&prev,&tmp_pos);
          plVar2[uVar5].pos = uVar3;
        }
      }
      else if (lVar1 == LYXP_NODE_ATTR) {
        tmp_node = lyd_attr_parent(root,(lyd_attr *)(set->val).nodes[i].node);
        if (tmp_node != (lyd_node *)0x0) goto LAB_001cad57;
        ly_log(root->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
               ,0x557);
        iVar4 = -1;
        goto LAB_001cade2;
      }
    }
    i = i + 1;
  } while( true );
}



uint16_t get_attr_pos(lyd_attr *attr,lyd_node *parent)

{
  lyd_node *parent_local;
  lyd_attr *attr_local;
  uint16_t pos;
  lyd_attr *attr2;
  
  pos = 0;
  for (attr2 = parent->attr; (attr2 != (lyd_attr *)0x0 && (attr2 != attr)); attr2 = attr2->next) {
    pos = pos + 1;
  }
  if (attr2 == (lyd_attr *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("attr2",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x57e,"get_attr_pos");
  }
  return pos;
}



int set_sort_compare(lyxp_set_node *item1,lyxp_set_node *item2,lyd_node *root)

{
  uint16_t uVar1;
  int iVar2;
  lyd_node *plVar3;
  lyd_node *root_local;
  lyxp_set_node *item2_local;
  lyxp_set_node *item1_local;
  uint32_t attr_pos1;
  uint32_t attr_pos2;
  lyd_node *tmp_node;
  
  attr_pos1 = 0;
  attr_pos2 = 0;
  if (item1->pos < item2->pos) {
    iVar2 = -1;
  }
  else if (item2->pos < item1->pos) {
    iVar2 = 1;
  }
  else if ((item1->node == item2->node) && (item1->type != item2->type)) {
    if (item1->type == LYXP_NODE_ELEM) {
      if (item2->type != LYXP_NODE_TEXT) {
                    // WARNING: Subroutine does not return
        __assert_fail("item2->type == LYXP_NODE_TEXT",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x5a2,"set_sort_compare");
      }
      iVar2 = -1;
    }
    else {
      if ((item1->type != LYXP_NODE_TEXT) || (item2->type != LYXP_NODE_ELEM)) {
                    // WARNING: Subroutine does not return
        __assert_fail("(item1->type == LYXP_NODE_TEXT) && (item2->type == LYXP_NODE_ELEM)",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x5a5,"set_sort_compare");
      }
      iVar2 = 1;
    }
  }
  else {
    if (item1->type == LYXP_NODE_ATTR) {
      plVar3 = lyd_attr_parent(root,(lyd_attr *)item1->node);
      if (plVar3 == (lyd_node *)0x0) {
        ly_log(root->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
               ,0x5ae);
        return -1;
      }
      uVar1 = get_attr_pos((lyd_attr *)item1->node,plVar3);
      attr_pos1 = (uint32_t)uVar1;
    }
    if (item2->type == LYXP_NODE_ATTR) {
      plVar3 = lyd_attr_parent(root,(lyd_attr *)item2->node);
      if (plVar3 == (lyd_node *)0x0) {
        ly_log(root->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
               ,0x5b6);
        return -1;
      }
      uVar1 = get_attr_pos((lyd_attr *)item2->node,plVar3);
      attr_pos2 = (uint32_t)uVar1;
    }
    if (item1->node == item2->node) {
      if ((item1->type != item2->type) ||
         ((item1->type == LYXP_NODE_ATTR && (attr_pos1 != attr_pos2)))) {
                    // WARNING: Subroutine does not return
        __assert_fail("(item1->type == item2->type) && ((item1->type != LYXP_NODE_ATTR) || (attr_pos1 == attr_pos2))"
                      ,
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x5bf,"set_sort_compare");
      }
      iVar2 = 0;
    }
    else if (item1->type == LYXP_NODE_ELEM) {
      if (item2->type == LYXP_NODE_ELEM) {
                    // WARNING: Subroutine does not return
        __assert_fail("item2->type != LYXP_NODE_ELEM",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x5c6,"set_sort_compare");
      }
      iVar2 = -1;
    }
    else if ((((item1->type == LYXP_NODE_TEXT) &&
              ((item2->type == LYXP_NODE_ELEM || (item2->type == LYXP_NODE_ATTR)))) ||
             ((item1->type == LYXP_NODE_ATTR && (item2->type == LYXP_NODE_ELEM)))) ||
            (((item1->type == LYXP_NODE_ATTR && (item2->type == LYXP_NODE_ATTR)) &&
             (attr_pos2 < attr_pos1)))) {
      iVar2 = 1;
    }
    else {
      iVar2 = -1;
    }
  }
  return iVar2;
}



int set_comp_cast(lyxp_set *trg,lyxp_set *src,lyxp_set_type type,lyd_node *cur_node,
                 lys_module *param_5,uint32_t src_idx,int options)

{
  int iVar1;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint32_t src_idx_local;
  lyxp_set_type type_local;
  lyxp_set *src_local;
  lyxp_set *trg_local;
  
  if (src->type != LYXP_SET_NODE_SET) {
                    // WARNING: Subroutine does not return
    __assert_fail("src->type == LYXP_SET_NODE_SET",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x5dd,"set_comp_cast");
  }
  memset(trg,0,0x40);
  set_insert_node(trg,(src->val).nodes[src_idx].node,(src->val).nodes[src_idx].pos,
                  (src->val).nodes[src_idx].type,0);
  iVar1 = lyxp_set_cast(trg,type,cur_node,param_5,options);
  if (iVar1 == 0) {
    iVar1 = 0;
  }
  else {
    set_free_content(trg);
    iVar1 = -1;
  }
  return iVar1;
}



int set_sort(lyxp_set *set,lyd_node *cur_node,int options)

{
  long lVar1;
  lyd_node *plVar2;
  lyxp_node_type lVar3;
  lyxp_node_type lVar4;
  uint32_t uVar5;
  int iVar6;
  uint32_t uVar7;
  lyxp_set_node *plVar8;
  lyxp_set_node *plVar9;
  long in_FS_OFFSET;
  int options_local;
  lyd_node *cur_node_local;
  lyxp_set *set_local;
  lyxp_node_type root_type;
  uint32_t i;
  uint32_t j;
  int ret;
  int cmp;
  int inverted;
  int change;
  lyd_node *root;
  uint64_t hash;
  lyxp_set_hash_node hnode;
  lyxp_set_node item;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  if ((set->type == LYXP_SET_NODE_SET) && (set->used != 1)) {
    root = moveto_get_root(cur_node,options,&root_type);
    iVar6 = set_assign_pos(set,root,root_type);
    if (iVar6 == 0) {
      ly_log_dbg(8,"SORT BEGIN");
      print_set_debug(set);
      for (i = 0; i < set->used; i = i + 1) {
        inverted = 0;
        change = 0;
        for (j = 1; j < set->used - i; j = j + 1) {
          if (inverted == 0) {
            cmp = set_sort_compare((set->val).nodes + (j - 1),(set->val).nodes + j,root);
          }
          else {
            cmp = set_sort_compare((set->val).nodes + j,(set->val).nodes + (j - 1),root);
          }
          if (((inverted == 0) || (-1 < cmp)) && ((inverted != 0 || (cmp < 1)))) {
            inverted = (int)(inverted == 0);
          }
          else {
            change = 1;
            plVar8 = (set->val).nodes + (j - 1);
            lVar4 = plVar8->type;
            uVar5 = plVar8->pos;
            plVar2 = plVar8->node;
            plVar9 = (set->val).nodes + j;
            plVar8 = (set->val).nodes + (j - 1);
            lVar3 = plVar9->type;
            uVar7 = plVar9->pos;
            plVar8->node = plVar9->node;
            plVar8->type = lVar3;
            plVar8->pos = uVar7;
            plVar8 = (set->val).nodes + j;
            plVar8->node = plVar2;
            plVar8->type = lVar4;
            plVar8->pos = uVar5;
          }
        }
        ret = ret + 1;
        if (change == 0) break;
      }
      ly_log_dbg(8,"SORT END %d",(ulong)(uint)ret);
      print_set_debug(set);
      if (3 < set->used) {
        if (set->ht == (hash_table *)0x0) {
                    // WARNING: Subroutine does not return
          __assert_fail("set->ht",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                        ,0x63a,"set_sort");
        }
        for (i = 0; i < set->used; i = i + 1) {
          hnode.node = (set->val).nodes[i].node;
          hnode.type = (set->val).nodes[i].type;
          uVar7 = dict_hash_multi(0,(char *)&hnode,8);
          hash = (uint64_t)uVar7;
          uVar7 = dict_hash_multi(uVar7,(char *)&hnode.type,4);
          hash = (uint64_t)uVar7;
          uVar7 = dict_hash_multi(uVar7,(char *)0x0,0);
          hash = (uint64_t)uVar7;
          iVar6 = lyht_find(set->ht,&hnode,uVar7,(void **)0x0);
          if (iVar6 != 0) {
                    // WARNING: Subroutine does not return
            __assert_fail("!lyht_find(set->ht, &hnode, hash, NULL)",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                          ,0x643,"set_sort");
          }
        }
      }
      iVar6 = ret + -1;
    }
    else {
      iVar6 = -1;
    }
  }
  else {
    iVar6 = 0;
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int set_sorted_dup_node_clean(lyxp_set *set)

{
  lyxp_set *set_local;
  uint32_t i;
  int ret;
  
  i = 0;
  ret = 0;
  if (1 < set->used) {
    while (i < set->used - 1) {
      if (((set->val).nodes[i].node == (set->val).nodes[i + 1].node) &&
         ((set->val).nodes[i].type == (set->val).nodes[i + 1].type)) {
        set_remove_node(set,i + 1);
        ret = 1;
      }
      else {
        i = i + 1;
      }
    }
  }
  return ret;
}



int set_sorted_merge(lyxp_set *trg,lyxp_set *src,lyd_node *cur_node,int options)

{
  int iVar1;
  lyxp_set_node *plVar2;
  ulong uVar3;
  ulong uVar4;
  long in_FS_OFFSET;
  int options_local;
  lyd_node *cur_node_local;
  lyxp_set *src_local;
  lyxp_set *trg_local;
  lyxp_node_type root_type;
  uint32_t i;
  uint32_t j;
  uint32_t count;
  uint32_t dup_count;
  uint32_t k;
  int cmp;
  lyd_node *root;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (((trg->type == LYXP_SET_NODE_SET) || (trg->type == LYXP_SET_EMPTY)) &&
     ((src->type == LYXP_SET_NODE_SET || (src->type == LYXP_SET_EMPTY)))) {
    if (src->type == LYXP_SET_EMPTY) {
      iVar1 = 0;
    }
    else if (trg->type == LYXP_SET_EMPTY) {
      set_fill_set(trg,src);
      lyxp_set_cast(src,LYXP_SET_EMPTY,cur_node,(lys_module *)0x0,options);
      iVar1 = 0;
    }
    else {
      root = moveto_get_root(cur_node,options,&root_type);
      iVar1 = set_assign_pos(trg,root,root_type);
      if (iVar1 == 0) {
        iVar1 = set_assign_pos(src,root,root_type);
        if (iVar1 == 0) {
          ly_log_dbg(8,"MERGE target");
          print_set_debug(trg);
          ly_log_dbg(8,"MERGE source");
          print_set_debug(src);
          if (trg->size - trg->used < src->used) {
            trg->size = trg->used + src->used;
            plVar2 = (lyxp_set_node *)ly_realloc((trg->val).nodes,(ulong)trg->size << 4);
            (trg->val).nodes = plVar2;
            if ((trg->val).nodes == (lyxp_set_node *)0x0) {
              ly_log(cur_node->schema->module->ctx,LY_LLERR,LY_EMEM,
                     "Memory allocation failed (%s()).","set_sorted_merge");
              iVar1 = -1;
              goto LAB_001cbbd0;
            }
          }
          i = 0;
          j = 0;
          count = 0;
          dup_count = 0;
          do {
            cmp = set_sort_compare((src->val).nodes + i,(trg->val).nodes + j,root);
            if (cmp == 0) {
              if (count == 0) {
                i = i + 1;
                j = j + 1;
              }
              else {
                count = count + 1;
                dup_count = dup_count + 1;
                i = i + 1;
                j = j + 1;
              }
            }
            else if (cmp < 0) {
              count = count + 1;
              uVar4 = (ulong)i;
              uVar3 = (ulong)i;
              i = i + 1;
              set_insert_node_hash(trg,(src->val).nodes[uVar3].node,(src->val).nodes[uVar4].type);
            }
            else {
              if (count != 0) goto LAB_001cb9fb;
              j = j + 1;
            }
            for (; (src->used <= i || (trg->used <= j)); j = j + iVar1) {
              if ((src->used <= i) && (count == 0)) {
                if ((trg->ht == (hash_table *)0x0) && (3 < trg->used)) {
                  set_insert_node_hash(trg,(lyd_node *)0x0,LYXP_NODE_ROOT);
                }
                ly_log_dbg(8,"MERGE result");
                print_set_debug(trg);
                lyxp_set_cast(src,LYXP_SET_EMPTY,cur_node,(lys_module *)0x0,options);
                iVar1 = 0;
                goto LAB_001cbbd0;
              }
              for (k = i; k < src->used; k = k + 1) {
                set_insert_node_hash(trg,(src->val).nodes[k].node,(src->val).nodes[k].type);
              }
              count = count + (src->used - i);
              i = src->used;
LAB_001cb9fb:
              memmove((trg->val).nodes + (j + (count - dup_count)),(trg->val).nodes + j,
                      (ulong)(trg->used - j) << 4);
              memcpy((trg->val).nodes + (j - dup_count),(src->val).nodes + (i - count),
                     (ulong)count << 4);
              trg->used = trg->used + (count - dup_count);
              iVar1 = count - dup_count;
              count = 0;
              dup_count = 0;
            }
          } while( true );
        }
      }
      iVar1 = -1;
    }
  }
  else {
    iVar1 = -1;
  }
LAB_001cbbd0:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int set_canonize(lyxp_set *set,lyxp_set *set2)

{
  lyxp_set_type lVar1;
  int iVar2;
  size_t sVar3;
  long in_FS_OFFSET;
  longdouble in_ST0;
  lyxp_set *set2_local;
  lyxp_set *set_local;
  int_log_opts prev_ilo;
  char *num_str;
  char *ptr;
  lys_node *schema;
  char *val_can;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (set2->type != LYXP_SET_NODE_SET) {
                    // WARNING: Subroutine does not return
    __assert_fail("set2->type == LYXP_SET_NODE_SET",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x703,"set_canonize");
  }
  if ((((set2->val).nodes)->type != LYXP_NODE_ELEM) ||
     ((((set2->val).nodes)->node->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN)) {
    iVar2 = 0;
    goto LAB_001cbecd;
  }
  schema = ((set2->val).nodes)->node->schema;
  lVar1 = set->type;
  if (lVar1 == LYXP_SET_STRING) {
    ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
    sVar3 = strlen((set->val).str);
    val_can = lyd_make_canonical(schema,(set->val).str,(int)sVar3);
    ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
    if (val_can != (char *)0x0) {
      free((set->val).nodes);
      (set->val).str = val_can;
    }
  }
  else {
    if (LYXP_SET_STRING < lVar1) {
LAB_001cbe84:
      ly_log(schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
             ,0x734);
      iVar2 = -1;
      goto LAB_001cbecd;
    }
    if (lVar1 != LYXP_SET_BOOLEAN) {
      if (lVar1 != LYXP_SET_NUMBER) goto LAB_001cbe84;
      iVar2 = asprintf(&num_str,"%Lf");
      if (iVar2 == -1) {
        ly_log(schema->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "set_canonize");
        iVar2 = -1;
        goto LAB_001cbecd;
      }
      ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
      sVar3 = strlen(num_str);
      val_can = lyd_make_canonical(schema,num_str,(int)sVar3);
      ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
      free(num_str);
      if (val_can != (char *)0x0) {
        strtold(val_can,&ptr);
        (set->val).num = in_ST0;
        if (*ptr != '\0') {
          free(val_can);
          ly_log(schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                 ,0x720);
          iVar2 = -1;
          goto LAB_001cbecd;
        }
        free(val_can);
      }
    }
  }
  iVar2 = 0;
LAB_001cbecd:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int exp_add_token(lyxp_expr *exp,lyxp_token token,uint16_t expr_pos,uint16_t tok_len)

{
  ushort uVar1;
  lyxp_token *plVar2;
  uint16_t *puVar3;
  uint16_t tok_len_local;
  uint16_t expr_pos_local;
  lyxp_token token_local;
  lyxp_expr *exp_local;
  uint32_t prev;
  
  if (exp->used == exp->size) {
    uVar1 = exp->size;
    exp->size = exp->size + 5;
    if (exp->size < uVar1) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
             ,0x758);
      return -1;
    }
    plVar2 = (lyxp_token *)ly_realloc(exp->tokens,(ulong)exp->size * 4);
    exp->tokens = plVar2;
    if (exp->tokens == (lyxp_token *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","exp_add_token");
      return -1;
    }
    puVar3 = (uint16_t *)ly_realloc(exp->expr_pos,(ulong)exp->size * 2);
    exp->expr_pos = puVar3;
    if (exp->expr_pos == (uint16_t *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","exp_add_token");
      return -1;
    }
    puVar3 = (uint16_t *)ly_realloc(exp->tok_len,(ulong)exp->size * 2);
    exp->tok_len = puVar3;
    if (exp->tok_len == (uint16_t *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","exp_add_token");
      return -1;
    }
  }
  exp->tokens[exp->used] = token;
  exp->expr_pos[exp->used] = expr_pos;
  exp->tok_len[exp->used] = tok_len;
  exp->used = exp->used + 1;
  return 0;
}



int exp_check_token(ly_ctx *ctx,lyxp_expr *exp,uint16_t exp_idx,lyxp_token want_tok,int strict)

{
  ushort uVar1;
  char *pcVar2;
  int iVar3;
  char *pcVar4;
  int strict_local;
  lyxp_token want_tok_local;
  uint16_t exp_idx_local;
  lyxp_expr *exp_local;
  ly_ctx *ctx_local;
  
  if (exp_idx == exp->used) {
    if (strict != 0) {
      ly_vlog(ctx,LYE_XPATH_EOF,LY_VLOG_NONE,(void *)0x0);
    }
    iVar3 = -1;
  }
  else if ((want_tok == LYXP_TOKEN_NONE) || (want_tok == exp->tokens[exp_idx])) {
    iVar3 = 0;
  }
  else {
    if (strict != 0) {
      pcVar2 = exp->expr;
      uVar1 = exp->expr_pos[exp_idx];
      pcVar4 = print_token(exp->tokens[exp_idx]);
      ly_vlog(ctx,LYE_XPATH_INTOK,LY_VLOG_NONE,(void *)0x0,pcVar4,pcVar2 + uVar1);
    }
    iVar3 = -1;
  }
  return iVar3;
}



void exp_repeat_push(lyxp_expr *exp,uint16_t exp_idx,uint16_t repeat_op_idx)

{
  lyxp_expr_type **pplVar1;
  lyxp_expr_type *plVar2;
  uint16_t repeat_op_idx_local;
  uint16_t exp_idx_local;
  lyxp_expr *exp_local;
  uint16_t i;
  
  if (exp->repeat[exp_idx] == (lyxp_expr_type *)0x0) {
    pplVar1 = exp->repeat;
    plVar2 = (lyxp_expr_type *)calloc(2,4);
    pplVar1[exp_idx] = plVar2;
    if (exp->repeat[exp_idx] == (lyxp_expr_type *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","exp_repeat_push");
    }
    else {
      *exp->repeat[exp_idx] = (uint)repeat_op_idx;
    }
  }
  else {
    for (i = 0; exp->repeat[exp_idx][i] != LYXP_EXPR_NONE; i = i + 1) {
    }
    pplVar1 = exp->repeat;
    plVar2 = (lyxp_expr_type *)realloc(exp->repeat[exp_idx],(long)(int)(i + 2) * 4);
    pplVar1[exp_idx] = plVar2;
    if (exp->repeat[exp_idx] == (lyxp_expr_type *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","exp_repeat_push");
    }
    else {
      exp->repeat[exp_idx][i] = (uint)repeat_op_idx;
      exp->repeat[exp_idx][(ulong)i + 1] = LYXP_EXPR_NONE;
    }
  }
  return;
}



int reparse_predicate(ly_ctx *ctx,lyxp_expr *exp,uint16_t *exp_idx)

{
  int iVar1;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  ly_ctx *ctx_local;
  
  iVar1 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_BRACK1,1);
  if (iVar1 == 0) {
    *exp_idx = *exp_idx + 1;
    iVar1 = reparse_or_expr(ctx,exp,exp_idx);
    if (iVar1 == 0) {
      iVar1 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_BRACK2,1);
      if (iVar1 == 0) {
        *exp_idx = *exp_idx + 1;
        iVar1 = 0;
      }
      else {
        iVar1 = -1;
      }
    }
    else {
      iVar1 = -1;
    }
  }
  else {
    iVar1 = -1;
  }
  return iVar1;
}



int reparse_relative_location_path(ly_ctx *ctx,lyxp_expr *exp,uint16_t *exp_idx)

{
  ushort uVar1;
  char *pcVar2;
  int iVar3;
  char *pcVar4;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  ly_ctx *ctx_local;
  
  iVar3 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_NONE,1);
  do {
    if (iVar3 != 0) {
      return -1;
    }
    if (false) {
switchD_001cc5b3_caseD_8:
      pcVar2 = exp->expr;
      uVar1 = exp->expr_pos[*exp_idx];
      pcVar4 = print_token(exp->tokens[*exp_idx]);
      ly_vlog(ctx,LYE_XPATH_INTOK,LY_VLOG_NONE,(void *)0x0,pcVar4,pcVar2 + uVar1);
      return -1;
    }
    switch(exp->tokens[*exp_idx]) {
    case LYXP_TOKEN_DOT:
      *exp_idx = *exp_idx + 1;
      break;
    case LYXP_TOKEN_DDOT:
      *exp_idx = *exp_idx + 1;
      break;
    case LYXP_TOKEN_AT:
      *exp_idx = *exp_idx + 1;
      iVar3 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_NONE,1);
      if (iVar3 != 0) {
        return -1;
      }
      if ((exp->tokens[*exp_idx] != LYXP_TOKEN_NAMETEST) &&
         (exp->tokens[*exp_idx] != LYXP_TOKEN_NODETYPE)) {
        pcVar2 = exp->expr;
        uVar1 = exp->expr_pos[*exp_idx];
        pcVar4 = print_token(exp->tokens[*exp_idx]);
        ly_vlog(ctx,LYE_XPATH_INTOK,LY_VLOG_NONE,(void *)0x0,pcVar4,pcVar2 + uVar1);
        return -1;
      }
    case LYXP_TOKEN_NAMETEST:
      *exp_idx = *exp_idx + 1;
      goto LAB_001cc7bc;
    default:
      goto switchD_001cc5b3_caseD_8;
    case LYXP_TOKEN_NODETYPE:
      *exp_idx = *exp_idx + 1;
      iVar3 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_PAR1,1);
      if (iVar3 != 0) {
        return -1;
      }
      *exp_idx = *exp_idx + 1;
      iVar3 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_PAR2,1);
      if (iVar3 != 0) {
        return -1;
      }
      *exp_idx = *exp_idx + 1;
LAB_001cc7bc:
      while ((*exp_idx < exp->used && (exp->tokens[*exp_idx] == LYXP_TOKEN_BRACK1))) {
        iVar3 = reparse_predicate(ctx,exp,exp_idx);
        if (iVar3 != 0) {
          return -1;
        }
      }
    }
    if ((exp->used <= *exp_idx) || (exp->tokens[*exp_idx] != LYXP_TOKEN_OPERATOR_PATH)) {
      return 0;
    }
    *exp_idx = *exp_idx + 1;
    iVar3 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_NONE,1);
  } while( true );
}



int reparse_absolute_location_path(ly_ctx *ctx,lyxp_expr *exp,uint16_t *exp_idx)

{
  lyxp_token lVar1;
  int iVar2;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  ly_ctx *ctx_local;
  
  iVar2 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_OPERATOR_PATH,1);
  if (iVar2 != 0) {
    return -1;
  }
  if (exp->tok_len[*exp_idx] == 1) {
    *exp_idx = *exp_idx + 1;
    iVar2 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_NONE,0);
    if (iVar2 != 0) {
      return 0;
    }
    lVar1 = exp->tokens[*exp_idx];
    if (lVar1 < LYXP_TOKEN_COMMA) {
      if (lVar1 < LYXP_TOKEN_DOT) {
        return 0;
      }
    }
    else if (1 < lVar1 + ~LYXP_TOKEN_COMMA) {
      return 0;
    }
    iVar2 = reparse_relative_location_path(ctx,exp,exp_idx);
    if (iVar2 != 0) {
      return -1;
    }
  }
  else {
    *exp_idx = *exp_idx + 1;
    iVar2 = reparse_relative_location_path(ctx,exp,exp_idx);
    if (iVar2 != 0) {
      return -1;
    }
  }
  return 0;
}



int reparse_function_call(ly_ctx *ctx,lyxp_expr *exp,uint16_t *exp_idx)

{
  ushort uVar1;
  int iVar2;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  ly_ctx *ctx_local;
  uint16_t func_exp_idx;
  int min_arg_count;
  int max_arg_count;
  int arg_count;
  
  min_arg_count = -1;
  iVar2 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_FUNCNAME,1);
  if (iVar2 == 0) {
    uVar1 = *exp_idx;
    if (true) {
      switch(exp->tok_len[*exp_idx]) {
      case 3:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"not",3);
        if (iVar2 == 0) {
          min_arg_count = 1;
          max_arg_count = 1;
        }
        else {
          iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"sum",3);
          if (iVar2 == 0) {
            min_arg_count = 1;
            max_arg_count = 1;
          }
        }
        break;
      case 4:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"lang",4);
        if (iVar2 == 0) {
          min_arg_count = 1;
          max_arg_count = 1;
        }
        else {
          iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"last",4);
          if (iVar2 == 0) {
            min_arg_count = 0;
            max_arg_count = 0;
          }
          else {
            iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"name",4);
            if (iVar2 == 0) {
              min_arg_count = 0;
              max_arg_count = 1;
            }
            else {
              iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"true",4);
              if (iVar2 == 0) {
                min_arg_count = 0;
                max_arg_count = 0;
              }
            }
          }
        }
        break;
      case 5:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"count",5);
        if (iVar2 == 0) {
          min_arg_count = 1;
          max_arg_count = 1;
        }
        else {
          iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"false",5);
          if (iVar2 == 0) {
            min_arg_count = 0;
            max_arg_count = 0;
          }
          else {
            iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"floor",5);
            if (iVar2 == 0) {
              min_arg_count = 1;
              max_arg_count = 1;
            }
            else {
              iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"round",5);
              if (iVar2 == 0) {
                min_arg_count = 1;
                max_arg_count = 1;
              }
              else {
                iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"deref",5);
                if (iVar2 == 0) {
                  min_arg_count = 1;
                  max_arg_count = 1;
                }
              }
            }
          }
        }
        break;
      case 6:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"concat",6);
        if (iVar2 == 0) {
          min_arg_count = 2;
          max_arg_count = 0x7fffffff;
        }
        else {
          iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"number",6);
          if (iVar2 == 0) {
            min_arg_count = 0;
            max_arg_count = 1;
          }
          else {
            iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"string",6);
            if (iVar2 == 0) {
              min_arg_count = 0;
              max_arg_count = 1;
            }
          }
        }
        break;
      case 7:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"boolean",7);
        if (iVar2 == 0) {
          min_arg_count = 1;
          max_arg_count = 1;
        }
        else {
          iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"ceiling",7);
          if (iVar2 == 0) {
            min_arg_count = 1;
            max_arg_count = 1;
          }
          else {
            iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"current",7);
            if (iVar2 == 0) {
              min_arg_count = 0;
              max_arg_count = 0;
            }
          }
        }
        break;
      case 8:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"contains",8);
        if (iVar2 == 0) {
          min_arg_count = 2;
          max_arg_count = 2;
        }
        else {
          iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"position",8);
          if (iVar2 == 0) {
            min_arg_count = 0;
            max_arg_count = 0;
          }
          else {
            iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"re-match",8);
            if (iVar2 == 0) {
              min_arg_count = 2;
              max_arg_count = 2;
            }
          }
        }
        break;
      case 9:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"substring",9);
        if (iVar2 == 0) {
          min_arg_count = 2;
          max_arg_count = 3;
        }
        else {
          iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"translate",9);
          if (iVar2 == 0) {
            min_arg_count = 3;
            max_arg_count = 3;
          }
        }
        break;
      case 10:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"local-name",10);
        if (iVar2 == 0) {
          min_arg_count = 0;
          max_arg_count = 1;
        }
        else {
          iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"enum-value",10);
          if (iVar2 == 0) {
            min_arg_count = 1;
            max_arg_count = 1;
          }
          else {
            iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"bit-is-set",10);
            if (iVar2 == 0) {
              min_arg_count = 2;
              max_arg_count = 2;
            }
          }
        }
        break;
      case 0xb:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"starts-with",0xb);
        if (iVar2 == 0) {
          min_arg_count = 2;
          max_arg_count = 2;
        }
        break;
      case 0xc:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"derived-from",0xc);
        if (iVar2 == 0) {
          min_arg_count = 2;
          max_arg_count = 2;
        }
        break;
      case 0xd:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"namespace-uri",0xd);
        if (iVar2 == 0) {
          min_arg_count = 0;
          max_arg_count = 1;
        }
        else {
          iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"string-length",0xd);
          if (iVar2 == 0) {
            min_arg_count = 0;
            max_arg_count = 1;
          }
        }
        break;
      case 0xf:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"normalize-space",0xf);
        if (iVar2 == 0) {
          min_arg_count = 0;
          max_arg_count = 1;
        }
        else {
          iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"substring-after",0xf);
          if (iVar2 == 0) {
            min_arg_count = 2;
            max_arg_count = 2;
          }
        }
        break;
      case 0x10:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"substring-before",0x10);
        if (iVar2 == 0) {
          min_arg_count = 2;
          max_arg_count = 2;
        }
        break;
      case 0x14:
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"derived-from-or-self",0x14);
        if (iVar2 == 0) {
          min_arg_count = 2;
          max_arg_count = 2;
        }
      }
    }
    if (min_arg_count == -1) {
      ly_vlog(ctx,LYE_XPATH_INFUNC,LY_VLOG_NONE,(void *)0x0,(ulong)exp->tok_len[*exp_idx],
              exp->expr + exp->expr_pos[*exp_idx]);
    }
    else {
      *exp_idx = *exp_idx + 1;
      iVar2 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_PAR1,1);
      if (iVar2 == 0) {
        *exp_idx = *exp_idx + 1;
        arg_count = 0;
        iVar2 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_NONE,1);
        if (iVar2 == 0) {
          if (exp->tokens[*exp_idx] != LYXP_TOKEN_PAR2) {
            arg_count = 1;
            iVar2 = reparse_or_expr(ctx,exp,exp_idx);
            if (iVar2 != 0) {
              return -1;
            }
          }
          do {
            if ((exp->used <= *exp_idx) || (exp->tokens[*exp_idx] != LYXP_TOKEN_COMMA)) {
              iVar2 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_PAR2,1);
              if (iVar2 != 0) {
                return -1;
              }
              *exp_idx = *exp_idx + 1;
              if ((min_arg_count <= arg_count) && (arg_count <= max_arg_count)) {
                return 0;
              }
              ly_vlog(ctx,LYE_XPATH_INARGCOUNT,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)arg_count,
                      (ulong)exp->tok_len[uVar1],exp->expr + exp->expr_pos[uVar1]);
              return -1;
            }
            *exp_idx = *exp_idx + 1;
            arg_count = arg_count + 1;
            iVar2 = reparse_or_expr(ctx,exp,exp_idx);
          } while (iVar2 == 0);
        }
      }
    }
  }
  return -1;
}



int reparse_path_expr(ly_ctx *ctx,lyxp_expr *exp,uint16_t *exp_idx)

{
  ushort uVar1;
  char *pcVar2;
  int iVar3;
  char *pcVar4;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  ly_ctx *ctx_local;
  
  iVar3 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_NONE,1);
  if (iVar3 != 0) {
    return -1;
  }
  if (true) {
    switch(exp->tokens[*exp_idx]) {
    default:
      goto switchD_001cd8e7_caseD_0;
    case LYXP_TOKEN_PAR1:
      *exp_idx = *exp_idx + 1;
      iVar3 = reparse_or_expr(ctx,exp,exp_idx);
      if (iVar3 != 0) {
        return -1;
      }
      iVar3 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_PAR2,1);
      if (iVar3 != 0) {
        return -1;
      }
      *exp_idx = *exp_idx + 1;
      break;
    case LYXP_TOKEN_DOT:
    case LYXP_TOKEN_DDOT:
    case LYXP_TOKEN_AT:
    case LYXP_TOKEN_NAMETEST:
    case LYXP_TOKEN_NODETYPE:
      iVar3 = reparse_relative_location_path(ctx,exp,exp_idx);
      if (iVar3 == 0) {
        return 0;
      }
      return -1;
    case LYXP_TOKEN_FUNCNAME:
      iVar3 = reparse_function_call(ctx,exp,exp_idx);
      if (iVar3 != 0) {
        return -1;
      }
      break;
    case LYXP_TOKEN_OPERATOR_PATH:
      iVar3 = reparse_absolute_location_path(ctx,exp,exp_idx);
      if (iVar3 == 0) {
        return 0;
      }
      return -1;
    case LYXP_TOKEN_LITERAL:
      *exp_idx = *exp_idx + 1;
      break;
    case LYXP_TOKEN_NUMBER:
      *exp_idx = *exp_idx + 1;
    }
    while ((*exp_idx < exp->used && (exp->tokens[*exp_idx] == LYXP_TOKEN_BRACK1))) {
      iVar3 = reparse_predicate(ctx,exp,exp_idx);
      if (iVar3 != 0) {
        return -1;
      }
    }
    if ((*exp_idx < exp->used) && (exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_PATH)) {
      *exp_idx = *exp_idx + 1;
      iVar3 = reparse_relative_location_path(ctx,exp,exp_idx);
      if (iVar3 != 0) {
        return -1;
      }
    }
    return 0;
  }
switchD_001cd8e7_caseD_0:
  pcVar2 = exp->expr;
  uVar1 = exp->expr_pos[*exp_idx];
  pcVar4 = print_token(exp->tokens[*exp_idx]);
  ly_vlog(ctx,LYE_XPATH_INTOK,LY_VLOG_NONE,(void *)0x0,pcVar4,pcVar2 + uVar1);
  return -1;
}



int reparse_unary_expr(ly_ctx *ctx,lyxp_expr *exp,uint16_t *exp_idx)

{
  uint16_t uVar1;
  int iVar2;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  ly_ctx *ctx_local;
  uint16_t prev_exp;
  
  uVar1 = *exp_idx;
  while ((iVar2 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_OPERATOR_MATH,0), iVar2 == 0 &&
         (exp->expr[exp->expr_pos[*exp_idx]] == '-'))) {
    exp_repeat_push(exp,uVar1,7);
    *exp_idx = *exp_idx + 1;
  }
  uVar1 = *exp_idx;
  iVar2 = reparse_path_expr(ctx,exp,exp_idx);
  while( true ) {
    if (iVar2 != 0) {
      return -1;
    }
    iVar2 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_OPERATOR_UNI,0);
    if (iVar2 != 0) break;
    exp_repeat_push(exp,uVar1,8);
    *exp_idx = *exp_idx + 1;
    iVar2 = reparse_path_expr(ctx,exp,exp_idx);
  }
  return 0;
}



int reparse_additive_expr(ly_ctx *ctx,lyxp_expr *exp,uint16_t *exp_idx)

{
  uint16_t exp_idx_00;
  uint16_t exp_idx_01;
  int iVar1;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  ly_ctx *ctx_local;
  uint16_t prev_add_exp;
  uint16_t prev_mul_exp;
  
  exp_idx_00 = *exp_idx;
  while( true ) {
    exp_idx_01 = *exp_idx;
    iVar1 = reparse_unary_expr(ctx,exp,exp_idx);
    if (iVar1 != 0) {
      return -1;
    }
    while ((iVar1 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_OPERATOR_MATH,0), iVar1 == 0 &&
           ((exp->expr[exp->expr_pos[*exp_idx]] == '*' || (exp->tok_len[*exp_idx] == 3))))) {
      exp_repeat_push(exp,exp_idx_01,6);
      *exp_idx = *exp_idx + 1;
      iVar1 = reparse_unary_expr(ctx,exp,exp_idx);
      if (iVar1 != 0) {
        return -1;
      }
    }
    iVar1 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_OPERATOR_MATH,0);
    if ((iVar1 != 0) ||
       ((exp->expr[exp->expr_pos[*exp_idx]] != '+' && (exp->expr[exp->expr_pos[*exp_idx]] != '-'))))
    break;
    exp_repeat_push(exp,exp_idx_00,5);
    *exp_idx = *exp_idx + 1;
  }
  return 0;
}



int reparse_equality_expr(ly_ctx *ctx,lyxp_expr *exp,uint16_t *exp_idx)

{
  uint16_t exp_idx_00;
  uint16_t exp_idx_01;
  int iVar1;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  ly_ctx *ctx_local;
  uint16_t prev_eq_exp;
  uint16_t prev_rel_exp;
  
  exp_idx_00 = *exp_idx;
  while( true ) {
    exp_idx_01 = *exp_idx;
    iVar1 = reparse_additive_expr(ctx,exp,exp_idx);
    if (iVar1 != 0) {
      return -1;
    }
    while ((iVar1 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_OPERATOR_COMP,0), iVar1 == 0 &&
           ((exp->expr[exp->expr_pos[*exp_idx]] == '<' ||
            (exp->expr[exp->expr_pos[*exp_idx]] == '>'))))) {
      exp_repeat_push(exp,exp_idx_01,4);
      *exp_idx = *exp_idx + 1;
      iVar1 = reparse_additive_expr(ctx,exp,exp_idx);
      if (iVar1 != 0) {
        return -1;
      }
    }
    iVar1 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_OPERATOR_COMP,0);
    if ((iVar1 != 0) ||
       ((exp->expr[exp->expr_pos[*exp_idx]] != '=' && (exp->expr[exp->expr_pos[*exp_idx]] != '!'))))
    break;
    exp_repeat_push(exp,exp_idx_00,3);
    *exp_idx = *exp_idx + 1;
  }
  return 0;
}



int reparse_or_expr(ly_ctx *ctx,lyxp_expr *exp,uint16_t *exp_idx)

{
  uint16_t exp_idx_00;
  uint16_t exp_idx_01;
  int iVar1;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  ly_ctx *ctx_local;
  uint16_t prev_or_exp;
  uint16_t prev_and_exp;
  
  exp_idx_00 = *exp_idx;
  while( true ) {
    exp_idx_01 = *exp_idx;
    iVar1 = reparse_equality_expr(ctx,exp,exp_idx);
    if (iVar1 != 0) {
      return -1;
    }
    while ((iVar1 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_OPERATOR_LOG,0), iVar1 == 0 &&
           (exp->tok_len[*exp_idx] == 3))) {
      exp_repeat_push(exp,exp_idx_01,2);
      *exp_idx = *exp_idx + 1;
      iVar1 = reparse_equality_expr(ctx,exp,exp_idx);
      if (iVar1 != 0) {
        return -1;
      }
    }
    iVar1 = exp_check_token(ctx,exp,*exp_idx,LYXP_TOKEN_OPERATOR_LOG,0);
    if ((iVar1 != 0) || (exp->tok_len[*exp_idx] != 2)) break;
    exp_repeat_push(exp,exp_idx_00,1);
    *exp_idx = *exp_idx + 1;
  }
  return 0;
}



uint16_t parse_ncname(ly_ctx *ctx,char *ncname)

{
  long in_FS_OFFSET;
  char *ncname_local;
  ly_ctx *ctx_local;
  uint16_t parsed;
  uint size;
  int uc;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  parsed = 0;
  uc = lyxml_getutf8(ctx,ncname,&size);
  if ((((((((uc < 0x61) || (0x7a < uc)) && (uc != 0x5f)) && ((uc < 0x41 || (0x5a < uc)))) &&
        (uc != 0x3a)) &&
       ((((uc < 0x370 || (0x1fff < uc)) || (uc == 0x37e)) &&
        ((((uc < 0xc0 || (0x2ff < uc)) || (uc == 0xd7)) || (uc == 0xf7)))))) &&
      ((((uc != 0x200c && (uc != 0x200d)) &&
        (((uc < 0x2070 || (0x218f < uc)) && ((uc < 0x2c00 || (0x2fef < uc)))))) &&
       (((uc < 0x3001 || (0xd7ff < uc)) &&
        ((((uc < 0xf900 || (0xfdcf < uc)) && ((uc < 0xfdf0 || (0xfffd < uc)))) &&
         ((uc < 0x10000 || (0xeffff < uc)))))))))) || (uc == 0x3a)) {
    parsed = 0;
  }
  else {
    do {
      parsed = parsed + (short)size;
      if ((ncname[parsed] == '\0') ||
         ((((((((((uc = lyxml_getutf8(ctx,ncname + parsed,&size), uc < 0x61 || (0x7a < uc)) &&
                 (uc != 0x5f)) && ((uc != 0x2d && ((uc < 0x41 || (0x5a < uc)))))) &&
               ((uc < 0x30 || (0x39 < uc)))) &&
              (((uc != 0x3a && (uc != 0x2e)) &&
               ((uc != 0xb7 && (((uc < 0x370 || (0x1fff < uc)) || (uc == 0x37e)))))))) &&
             (((uc < 0xc0 || (0x2ff < uc)) || ((uc == 0xd7 || (uc == 0xf7)))))) &&
            ((((uc != 0x200c && (uc != 0x200d)) && ((uc < 0x300 || (0x36f < uc)))) &&
             (((uc < 0x2070 || (0x218f < uc)) && ((uc < 0x2030f || (0x2040 < uc)))))))) &&
           (((((uc < 0x2c00 || (0x2fef < uc)) && ((uc < 0x3001 || (0xd7ff < uc)))) &&
             ((uc < 0xf900 || (0xfdcf < uc)))) && ((uc < 0xfdf0 || (0xfffd < uc)))))) &&
          ((uc < 0x10000 || (0xeffff < uc)))))) break;
    } while (uc != 0x3a);
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return parsed;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lyxp_expr * lyxp_parse_expr(ly_ctx *ctx,char *expr)

{
  ushort uVar1;
  bool bVar2;
  uint16_t uVar3;
  int iVar4;
  size_t sVar5;
  lyxp_expr *exp;
  char *pcVar6;
  lyxp_token *plVar7;
  uint16_t *puVar8;
  ushort **ppuVar9;
  lyxp_expr_type **pplVar10;
  char *expr_local;
  ly_ctx *ctx_local;
  uint16_t parsed;
  uint16_t tok_len;
  uint16_t ncname_len;
  lyxp_token tok_type;
  int prev_function_check;
  lyxp_expr *ret;
  
  parsed = 0;
  bVar2 = false;
  sVar5 = strlen(expr);
  if (sVar5 < 0x10000) {
    exp = (lyxp_expr *)calloc(1,0x30);
    if (exp == (lyxp_expr *)0x0) {
      ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxp_parse_expr");
    }
    else {
      pcVar6 = strdup(expr);
      exp->expr = pcVar6;
      if (exp->expr == (char *)0x0) {
        ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxp_parse_expr");
      }
      else {
        exp->used = 0;
        exp->size = 10;
        plVar7 = (lyxp_token *)malloc((ulong)exp->size << 2);
        exp->tokens = plVar7;
        if (exp->tokens == (lyxp_token *)0x0) {
          ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxp_parse_expr");
        }
        else {
          puVar8 = (uint16_t *)malloc((ulong)exp->size * 2);
          exp->expr_pos = puVar8;
          if (exp->expr_pos == (uint16_t *)0x0) {
            ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxp_parse_expr");
          }
          else {
            puVar8 = (uint16_t *)malloc((ulong)exp->size * 2);
            exp->tok_len = puVar8;
            if (exp->tok_len == (uint16_t *)0x0) {
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxp_parse_expr");
            }
            else {
              for (; (((expr[parsed] == ' ' || (expr[parsed] == '\t')) || (expr[parsed] == '\n')) ||
                     (expr[parsed] == '\r')); parsed = parsed + 1) {
              }
              do {
                if (expr[parsed] == '(') {
                  tok_len = 1;
                  tok_type = LYXP_TOKEN_PAR1;
                  if (((bVar2) && (exp->used != 0)) &&
                     (exp->tokens[(ulong)exp->used - 1] == LYXP_TOKEN_NAMETEST)) {
                    if (((exp->tok_len[(ulong)exp->used - 1] == 4) &&
                        ((iVar4 = strncmp(expr + exp->expr_pos[(ulong)exp->used - 1],"node",4),
                         iVar4 == 0 ||
                         (iVar4 = strncmp(expr + exp->expr_pos[(ulong)exp->used - 1],"text",4),
                         iVar4 == 0)))) ||
                       ((exp->tok_len[(ulong)exp->used - 1] == 7 &&
                        (iVar4 = strncmp(expr + exp->expr_pos[(ulong)exp->used - 1],"comment",7),
                        iVar4 == 0)))) {
                      exp->tokens[(ulong)exp->used - 1] = LYXP_TOKEN_NODETYPE;
                    }
                    else {
                      exp->tokens[(ulong)exp->used - 1] = LYXP_TOKEN_FUNCNAME;
                    }
                    bVar2 = false;
                  }
                }
                else if (expr[parsed] == ')') {
                  tok_len = 1;
                  tok_type = LYXP_TOKEN_PAR2;
                }
                else if (expr[parsed] == '[') {
                  tok_len = 1;
                  tok_type = LYXP_TOKEN_BRACK1;
                }
                else if (expr[parsed] == ']') {
                  tok_len = 1;
                  tok_type = LYXP_TOKEN_BRACK2;
                }
                else {
                  iVar4 = strncmp(expr + parsed,"..",2);
                  if (iVar4 == 0) {
                    tok_len = 2;
                    tok_type = LYXP_TOKEN_DDOT;
                  }
                  else if ((expr[parsed] == '.') &&
                          (ppuVar9 = __ctype_b_loc(),
                          ((*ppuVar9)[expr[(ulong)parsed + 1]] & 0x800) == 0)) {
                    tok_len = 1;
                    tok_type = LYXP_TOKEN_DOT;
                  }
                  else if (expr[parsed] == '@') {
                    tok_len = 1;
                    tok_type = LYXP_TOKEN_AT;
                  }
                  else if (expr[parsed] == ',') {
                    tok_len = 1;
                    tok_type = LYXP_TOKEN_COMMA;
                  }
                  else if (expr[parsed] == '\'') {
                    tok_len = 1;
                    while ((expr[(int)((uint)tok_len + (uint)parsed)] != '\0' &&
                           (expr[(int)((uint)tok_len + (uint)parsed)] != '\''))) {
                      tok_len = tok_len + 1;
                    }
                    if (expr[(int)((uint)tok_len + (uint)parsed)] == '\0') {
                      ly_vlog(ctx,LYE_XPATH_NOEND,LY_VLOG_NONE,(void *)0x0,
                              (ulong)(uint)(int)expr[parsed],expr + parsed);
                      goto LAB_001cf42e;
                    }
                    tok_len = tok_len + 1;
                    tok_type = LYXP_TOKEN_LITERAL;
                  }
                  else if (expr[parsed] == '\"') {
                    tok_len = 1;
                    while ((expr[(int)((uint)tok_len + (uint)parsed)] != '\0' &&
                           (expr[(int)((uint)tok_len + (uint)parsed)] != '\"'))) {
                      tok_len = tok_len + 1;
                    }
                    if (expr[(int)((uint)tok_len + (uint)parsed)] == '\0') {
                      ly_vlog(ctx,LYE_XPATH_NOEND,LY_VLOG_NONE,(void *)0x0,
                              (ulong)(uint)(int)expr[parsed],expr + parsed);
                      goto LAB_001cf42e;
                    }
                    tok_len = tok_len + 1;
                    tok_type = LYXP_TOKEN_LITERAL;
                  }
                  else if ((expr[parsed] == '.') ||
                          (ppuVar9 = __ctype_b_loc(), ((*ppuVar9)[expr[parsed]] & 0x800) != 0)) {
                    tok_len = 0;
                    while (ppuVar9 = __ctype_b_loc(),
                          ((*ppuVar9)[expr[(int)((uint)tok_len + (uint)parsed)]] & 0x800) != 0) {
                      tok_len = tok_len + 1;
                    }
                    if (expr[(int)((uint)tok_len + (uint)parsed)] == '.') {
                      do {
                        tok_len = tok_len + 1;
                        ppuVar9 = __ctype_b_loc();
                      } while (((*ppuVar9)[expr[(int)((uint)tok_len + (uint)parsed)]] & 0x800) != 0)
                      ;
                    }
                    tok_type = LYXP_TOKEN_NUMBER;
                  }
                  else if (expr[parsed] == '/') {
                    iVar4 = strncmp(expr + parsed,"//",2);
                    if (iVar4 == 0) {
                      tok_len = 2;
                    }
                    else {
                      tok_len = 1;
                    }
                    tok_type = LYXP_TOKEN_OPERATOR_PATH;
                  }
                  else {
                    iVar4 = strncmp(expr + parsed,"!=",2);
                    if (((iVar4 == 0) || (iVar4 = strncmp(expr + parsed,"<=",2), iVar4 == 0)) ||
                       (iVar4 = strncmp(expr + parsed,">=",2), iVar4 == 0)) {
                      tok_len = 2;
                      tok_type = LYXP_TOKEN_OPERATOR_COMP;
                    }
                    else if (expr[parsed] == '|') {
                      tok_len = 1;
                      tok_type = LYXP_TOKEN_OPERATOR_UNI;
                    }
                    else if ((expr[parsed] == '+') || (expr[parsed] == '-')) {
                      tok_len = 1;
                      tok_type = LYXP_TOKEN_OPERATOR_MATH;
                    }
                    else if (((expr[parsed] == '=') || (expr[parsed] == '<')) ||
                            (expr[parsed] == '>')) {
                      tok_len = 1;
                      tok_type = LYXP_TOKEN_OPERATOR_COMP;
                    }
                    else if ((((((exp->used == 0) ||
                                (exp->tokens[(ulong)exp->used - 1] == LYXP_TOKEN_AT)) ||
                               (exp->tokens[(ulong)exp->used - 1] == LYXP_TOKEN_PAR1)) ||
                              ((exp->tokens[(ulong)exp->used - 1] == LYXP_TOKEN_BRACK1 ||
                               (exp->tokens[(ulong)exp->used - 1] == LYXP_TOKEN_COMMA)))) ||
                             (((exp->tokens[(ulong)exp->used - 1] == LYXP_TOKEN_OPERATOR_LOG ||
                               ((exp->tokens[(ulong)exp->used - 1] == LYXP_TOKEN_OPERATOR_COMP ||
                                (exp->tokens[(ulong)exp->used - 1] == LYXP_TOKEN_OPERATOR_MATH))))
                              || (exp->tokens[(ulong)exp->used - 1] == LYXP_TOKEN_OPERATOR_UNI))))
                            || (exp->tokens[(ulong)exp->used - 1] == LYXP_TOKEN_OPERATOR_PATH)) {
                      if (expr[parsed] == '*') {
                        tok_len = 1;
                        tok_type = LYXP_TOKEN_NAMETEST;
                      }
                      else {
                        tok_len = parse_ncname(ctx,expr + parsed);
                        if (tok_len == 0) {
                          ly_vlog(ctx,LYE_INCHAR,LY_VLOG_NONE,(void *)0x0,
                                  (ulong)(uint)(int)expr[parsed],expr + parsed);
                          goto LAB_001cf42e;
                        }
                        if (expr[(int)((uint)tok_len + (uint)parsed)] == ':') {
                          uVar1 = tok_len + 1;
                          if (expr[(int)((uint)uVar1 + (uint)parsed)] == '*') {
                            tok_len = tok_len + 2;
                          }
                          else {
                            uVar3 = parse_ncname(ctx,expr + (int)((uint)uVar1 + (uint)parsed));
                            if (uVar3 == 0) {
                              ly_vlog(ctx,LYE_INCHAR,LY_VLOG_NONE,(void *)0x0,
                                      (ulong)(uint)(int)expr[parsed],expr + parsed);
                              goto LAB_001cf42e;
                            }
                            tok_len = uVar1 + uVar3;
                          }
                          bVar2 = false;
                          tok_type = LYXP_TOKEN_NAMETEST;
                        }
                        else {
                          bVar2 = true;
                          tok_type = LYXP_TOKEN_NAMETEST;
                        }
                      }
                    }
                    else if (expr[parsed] == '*') {
                      tok_len = 1;
                      tok_type = LYXP_TOKEN_OPERATOR_MATH;
                    }
                    else {
                      iVar4 = strncmp(expr + parsed,"or",2);
                      if (iVar4 == 0) {
                        tok_len = 2;
                        tok_type = LYXP_TOKEN_OPERATOR_LOG;
                      }
                      else {
                        iVar4 = strncmp(expr + parsed,"and",3);
                        if (iVar4 == 0) {
                          tok_len = 3;
                          tok_type = LYXP_TOKEN_OPERATOR_LOG;
                        }
                        else {
                          iVar4 = strncmp(expr + parsed,"mod",3);
                          if ((iVar4 != 0) && (iVar4 = strncmp(expr + parsed,"div",3), iVar4 != 0))
                          {
                            ly_vlog(ctx,LYE_INCHAR,LY_VLOG_NONE,(void *)0x0,
                                    (ulong)(uint)(int)expr[parsed],expr + parsed);
                            if (bVar2) {
                              ly_vlog(ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                                      "Perhaps \"%.*s\" is supposed to be a function call.",
                                      (ulong)exp->tok_len[(ulong)exp->used - 1],
                                      exp->expr + exp->expr_pos[(ulong)exp->used - 1]);
                            }
                            goto LAB_001cf42e;
                          }
                          tok_len = 3;
                          tok_type = LYXP_TOKEN_OPERATOR_MATH;
                        }
                      }
                    }
                  }
                }
                iVar4 = exp_add_token(exp,tok_type,parsed,tok_len);
                if (iVar4 != 0) goto LAB_001cf42e;
                for (parsed = parsed + tok_len;
                    ((expr[parsed] == ' ' || (expr[parsed] == '\t')) ||
                    ((expr[parsed] == '\n' || (expr[parsed] == '\r')))); parsed = parsed + 1) {
                }
              } while (expr[parsed] != '\0');
              pplVar10 = (lyxp_expr_type **)calloc((ulong)exp->size,8);
              exp->repeat = pplVar10;
              if (exp->repeat != (lyxp_expr_type **)0x0) {
                return exp;
              }
              ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxp_parse_expr");
            }
          }
        }
      }
    }
LAB_001cf42e:
    lyxp_expr_free(exp);
  }
  else {
    ly_log(ctx,LY_LLERR,LY_EINVAL,"XPath expression cannot be longer than %ud characters.",0xffff);
  }
  return (lyxp_expr *)0x0;
}



lys_node * warn_get_snode_in_ctx(lyxp_set *set)

{
  lyxp_set *set_local;
  uint32_t i;
  
  if ((set != (lyxp_set *)0x0) && (set->type == LYXP_SET_SNODE_SET)) {
    i = set->used;
    do {
      i = i - 1;
      if ((set->val).nodes[i].pos == 1) {
        return (lys_node *)(set->val).nodes[i].node;
      }
    } while (i != 0);
  }
  return (lys_node *)0x0;
}



int warn_is_numeric_type(lys_type *type)

{
  LY_DATA_TYPE LVar1;
  int iVar2;
  long in_FS_OFFSET;
  lys_type *type_local;
  int found;
  int ret;
  lys_node *node;
  lys_type *t;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  t = (lys_type *)0x0;
  found = 0;
  LVar1 = type->base;
  if (LVar1 < LY_TYPE_UNKNOWN) {
    if (LY_TYPE_UNION < LVar1) {
LAB_001cf511:
      iVar2 = 1;
      goto LAB_001cf641;
    }
    if (LVar1 == LY_TYPE_UNION) {
      do {
        t = lyp_get_next_union_type(type,t,&found);
        if (t == (lys_type *)0x0) {
          iVar2 = 0;
          goto LAB_001cf641;
        }
        found = 0;
        ret = warn_is_numeric_type(t);
      } while (ret == 0);
      iVar2 = 1;
      goto LAB_001cf641;
    }
    if (LVar1 < LY_TYPE_INT8) {
      if (LVar1 == LY_TYPE_DEC64) goto LAB_001cf511;
      if (LVar1 == LY_TYPE_LEAFREF) {
        if ((type->info).lref.target == (lys_node_leaf *)0x0) {
          if ((lys_tpdf *)type != type->parent + 1) {
                    // WARNING: Subroutine does not return
            __assert_fail("&((struct lys_node_leaf *)type->parent)->type == type",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                          ,0xbad,"warn_is_numeric_type");
          }
          for (node = (lys_node *)type->parent;
              (node != (lys_node *)0x0 && (node->nodetype != LYS_GROUPING)); node = node->parent) {
          }
          if (node == (lys_node *)0x0) {
            ly_log(type->parent->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                   ,0xbb0);
          }
          iVar2 = 0;
        }
        else {
          iVar2 = warn_is_numeric_type(&((type->info).lref.target)->type);
        }
        goto LAB_001cf641;
      }
    }
  }
  iVar2 = 0;
LAB_001cf641:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int warn_is_string_type(lys_type *type)

{
  int iVar1;
  long in_FS_OFFSET;
  lys_type *type_local;
  int found;
  int ret;
  lys_type *t;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  t = (lys_type *)0x0;
  found = 0;
  if (false) {
switchD_001cf6b4_caseD_0:
    iVar1 = 0;
  }
  else {
    switch(type->base) {
    default:
      goto switchD_001cf6b4_caseD_0;
    case LY_TYPE_BITS:
    case LY_TYPE_ENUM:
    case LY_TYPE_IDENT:
    case LY_TYPE_INST:
    case LY_TYPE_STRING:
      iVar1 = 1;
      break;
    case LY_TYPE_LEAFREF:
      if ((type->info).lref.target == (lys_node_leaf *)0x0) {
        iVar1 = 0;
      }
      else {
        iVar1 = warn_is_string_type(&((type->info).lref.target)->type);
      }
      break;
    case LY_TYPE_UNION:
      do {
        t = lyp_get_next_union_type(type,t,&found);
        if (t == (lys_type *)0x0) {
          iVar1 = 0;
          goto LAB_001cf739;
        }
        found = 0;
        ret = warn_is_string_type(t);
      } while (ret == 0);
      iVar1 = 1;
    }
  }
LAB_001cf739:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int warn_is_specific_type(lys_type *type,LY_DATA_TYPE base)

{
  int iVar1;
  long in_FS_OFFSET;
  LY_DATA_TYPE base_local;
  lys_type *type_local;
  int found;
  int ret;
  lys_type *t;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  t = (lys_type *)0x0;
  found = 0;
  if (base == type->base) {
    iVar1 = 1;
  }
  else if (type->base == LY_TYPE_UNION) {
    do {
      t = lyp_get_next_union_type(type,t,&found);
      if (t == (lys_type *)0x0) {
        iVar1 = 0;
        goto LAB_001cf835;
      }
      found = 0;
      ret = warn_is_specific_type(t,base);
    } while (ret == 0);
    iVar1 = 1;
  }
  else if (type->base == LY_TYPE_LEAFREF) {
    if ((type->info).lref.target == (lys_node_leaf *)0x0) {
      iVar1 = 1;
    }
    else {
      iVar1 = warn_is_specific_type(&((type->info).lref.target)->type,base);
    }
  }
  else {
    iVar1 = 0;
  }
LAB_001cf835:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



lys_type * warn_is_equal_type_next_type(lys_type *type,lys_type *prev_type)

{
  long in_FS_OFFSET;
  lys_type *prev_type_local;
  lys_type *type_local;
  int found;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  found = 0;
  if (type->base == LY_TYPE_LEAFREF) {
    if ((type->info).lref.target != (lys_node_leaf *)0x0) {
      type = warn_is_equal_type_next_type(&((type->info).lref.target)->type,prev_type);
    }
  }
  else if (type->base == LY_TYPE_UNION) {
    type = lyp_get_next_union_type(type,prev_type,&found);
  }
  else if (prev_type != (lys_type *)0x0) {
    if (type != prev_type) {
                    // WARNING: Subroutine does not return
      __assert_fail("type == prev_type",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0xc16,"warn_is_equal_type_next_type");
    }
    type = (lys_type *)0x0;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return type;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int warn_is_equal_type(lys_type *type1,lys_type *type2)

{
  lys_type *type2_local;
  lys_type *type1_local;
  lys_type *t1;
  lys_type *t2;
  
  t1 = (lys_type *)0x0;
  do {
    t1 = warn_is_equal_type_next_type(type1,t1);
    if (t1 == (lys_type *)0x0) {
      return 0;
    }
    if (t1->base == LY_TYPE_LEAFREF) {
      return 1;
    }
    t2 = (lys_type *)0x0;
    while (t2 = warn_is_equal_type_next_type(type2,t2), t2 != (lys_type *)0x0) {
      if (t2->base == LY_TYPE_LEAFREF) {
        return 1;
      }
      if (t2->base == t1->base) {
        return 1;
      }
    }
  } while( true );
}



void warn_operands(ly_ctx *ctx,lyxp_set *set1,lyxp_set *set2,int numbers_only,char *expr,
                  uint16_t expr_pos)

{
  char *pcVar1;
  bool bVar2;
  bool bVar3;
  int iVar4;
  lys_node *plVar5;
  lys_node *plVar6;
  char *pcVar7;
  char *expr_local;
  uint16_t expr_pos_local;
  int numbers_only_local;
  lyxp_set *set2_local;
  lyxp_set *set1_local;
  ly_ctx *ctx_local;
  int leaves;
  int warning;
  lys_node_leaf *node1;
  lys_node_leaf *node2;
  
  bVar2 = true;
  bVar3 = false;
  plVar5 = warn_get_snode_in_ctx(set1);
  plVar6 = warn_get_snode_in_ctx(set2);
  if ((plVar5 == (lys_node *)0x0) && (plVar6 == (lys_node *)0x0)) {
    return;
  }
  if (plVar5 != (lys_node *)0x0) {
    if ((plVar5->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
      pcVar1 = plVar5->name;
      pcVar7 = strnodetype(plVar5->nodetype);
      ly_log(ctx,LY_LLWRN,LY_SUCCESS,"Node type %s \"%s\" used as operand.",pcVar7,pcVar1);
      bVar3 = true;
      bVar2 = false;
    }
    else if ((numbers_only != 0) &&
            (iVar4 = warn_is_numeric_type((lys_type *)&plVar5[1].ref), iVar4 == 0)) {
      ly_log(ctx,LY_LLWRN,LY_SUCCESS,
             "Node \"%s\" is not of a numeric type, but used where it was expected.",plVar5->name);
      bVar3 = true;
    }
  }
  if (plVar6 != (lys_node *)0x0) {
    if ((plVar6->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
      pcVar1 = plVar6->name;
      pcVar7 = strnodetype(plVar6->nodetype);
      ly_log(ctx,LY_LLWRN,LY_SUCCESS,"Node type %s \"%s\" used as operand.",pcVar7,pcVar1);
      bVar3 = true;
      bVar2 = false;
    }
    else if ((numbers_only != 0) &&
            (iVar4 = warn_is_numeric_type((lys_type *)&plVar6[1].ref), iVar4 == 0)) {
      ly_log(ctx,LY_LLWRN,LY_SUCCESS,
             "Node \"%s\" is not of a numeric type, but used where it was expected.",plVar6->name);
      bVar3 = true;
    }
  }
  if (((((plVar5 != (lys_node *)0x0) && (plVar6 != (lys_node *)0x0)) && (bVar2)) &&
      (numbers_only == 0)) &&
     ((((iVar4 = warn_is_numeric_type((lys_type *)&plVar5[1].ref), iVar4 != 0 &&
        (iVar4 = warn_is_numeric_type((lys_type *)&plVar6[1].ref), iVar4 == 0)) ||
       ((iVar4 = warn_is_numeric_type((lys_type *)&plVar5[1].ref), iVar4 == 0 &&
        (iVar4 = warn_is_numeric_type((lys_type *)&plVar6[1].ref), iVar4 != 0)))) ||
      (((iVar4 = warn_is_numeric_type((lys_type *)&plVar5[1].ref), iVar4 == 0 &&
        (iVar4 = warn_is_numeric_type((lys_type *)&plVar6[1].ref), iVar4 == 0)) &&
       (iVar4 = warn_is_equal_type((lys_type *)&plVar5[1].ref,(lys_type *)&plVar6[1].ref),
       iVar4 == 0)))))) {
    ly_log(ctx,LY_LLWRN,LY_SUCCESS,
           "Incompatible types of operands \"%s\" and \"%s\" for comparison.",plVar5->name,
           plVar6->name);
    bVar3 = true;
  }
  if (bVar3) {
    ly_log(ctx,LY_LLWRN,LY_SUCCESS,
           "Previous warning generated by XPath subexpression[%u] \"%.20s\".",(ulong)expr_pos,
           expr + expr_pos);
  }
  return;
}



void warn_equality_value(ly_ctx *ctx,lyxp_expr *exp,lyxp_set *set,uint16_t val_exp,
                        uint16_t equal_exp,uint16_t last_equal_exp)

{
  char *pcVar1;
  lys_module *plVar2;
  long in_FS_OFFSET;
  uint16_t last_equal_exp_local;
  uint16_t equal_exp_local;
  uint16_t val_exp_local;
  lyxp_set *set_local;
  lyxp_expr *exp_local;
  ly_ctx *ctx_local;
  int_log_opts prev_ilo;
  int ret;
  char *value;
  lys_node *snode;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  snode = warn_get_snode_in_ctx(set);
  if (((snode == (lys_node *)0x0) || ((snode->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN))
     || ((exp->tokens[val_exp] != LYXP_TOKEN_LITERAL && (exp->tokens[val_exp] != LYXP_TOKEN_NUMBER))
        )) goto LAB_001d00d5;
  if (exp->tokens[val_exp] == LYXP_TOKEN_LITERAL) {
    value = strndup(exp->expr + (ulong)exp->expr_pos[val_exp] + 1,
                    (long)(int)(exp->tok_len[val_exp] - 2));
  }
  else {
    value = strndup(exp->expr + exp->expr_pos[val_exp],(ulong)exp->tok_len[val_exp]);
  }
  if (value == (char *)0x0) {
    ly_log(ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","warn_equality_value");
    goto LAB_001d00d5;
  }
  if (*(int *)&snode[1].ref == 7) {
    pcVar1 = strchr(value,0x3a);
    if (pcVar1 == (char *)0x0) {
      ly_log(ctx,LY_LLWRN,LY_SUCCESS,
             "Identityref \"%s\" comparison with identity \"%s\" without prefix, consider adding a prefix or best using \"derived-from(-or-self)()\" functions."
             ,snode->name,value);
      ly_log(ctx,LY_LLWRN,LY_SUCCESS,
             "Previous warning generated by XPath subexpression[%u] \"%.*s\".",
             (ulong)exp->expr_pos[equal_exp],
             (ulong)(((uint)exp->expr_pos[last_equal_exp] - (uint)exp->expr_pos[equal_exp]) +
                    (uint)exp->tok_len[last_equal_exp]),exp->expr + exp->expr_pos[equal_exp]);
    }
  }
  if (*(int *)&snode[1].ref == 7) {
    plVar2 = lys_node_module(snode);
    if ((plVar2->field_0x40 & 0x80) != 0) goto LAB_001cffbb;
  }
  else {
LAB_001cffbb:
    ly_ilo_change((ly_ctx *)0x0,ILO_ERR2WRN,&prev_ilo,(ly_err_item **)0x0);
    ret = lyd_validate_value(snode,value);
    ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
    if (ret != 0) {
      ly_log(ctx,LY_LLWRN,LY_SUCCESS,
             "Previous warning generated by XPath subexpression[%u] \"%.*s\".",
             (ulong)exp->expr_pos[equal_exp],
             (ulong)(((uint)exp->expr_pos[last_equal_exp] - (uint)exp->expr_pos[equal_exp]) +
                    (uint)exp->tok_len[last_equal_exp]),exp->expr + exp->expr_pos[equal_exp]);
    }
  }
  free(value);
LAB_001d00d5:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int xpath_bit_is_set(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,
                    lys_module *param_4,lyxp_set *set,int options)

{
  LYS_NODE LVar1;
  lyd_node *plVar2;
  int iVar3;
  lys_node *plVar4;
  char *pcVar5;
  char *pcVar6;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  int i;
  int ret;
  int bits_count;
  lyd_node_leaf_list *leaf;
  lys_node_leaf *sleaf;
  
  ret = 0;
  if ((options & 0x3cU) != 0) {
    if (((*args)->type == LYXP_SET_SNODE_SET) &&
       (plVar4 = warn_get_snode_in_ctx(*args), plVar4 != (lys_node *)0x0)) {
      if ((plVar4->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar6 = plVar4->name;
        pcVar5 = strnodetype(plVar4->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
               "xpath_bit_is_set",pcVar5,pcVar6);
        ret = 1;
      }
      else {
        iVar3 = warn_is_specific_type((lys_type *)&plVar4[1].ref,LY_TYPE_BITS);
        if (iVar3 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #1 of %s is node \"%s\", not of type \"bits\".","xpath_bit_is_set",
                 plVar4->name);
          ret = 1;
        }
      }
    }
    else {
      ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s not a node-set as expected.",
             "xpath_bit_is_set");
      ret = 1;
    }
    if ((args[1]->type == LYXP_SET_SNODE_SET) &&
       (plVar4 = warn_get_snode_in_ctx(args[1]), plVar4 != (lys_node *)0x0)) {
      if ((plVar4->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar6 = plVar4->name;
        pcVar5 = strnodetype(plVar4->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #2 of %s is a %s node \"%s\".",
               "xpath_bit_is_set",pcVar5,pcVar6);
        ret = 1;
      }
      else {
        iVar3 = warn_is_string_type((lys_type *)&plVar4[1].ref);
        if (iVar3 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #2 of %s is node \"%s\", not of string-type.","xpath_bit_is_set",
                 plVar4->name);
          ret = 1;
        }
      }
    }
    set_snode_clear_ctx(set);
    return ret;
  }
  if (((*args)->type != LYXP_SET_NODE_SET) && ((*args)->type != LYXP_SET_EMPTY)) {
    pcVar6 = print_set_type(*args);
    ly_vlog(param_4->ctx,LYE_XPATH_INARGTYPE,LY_VLOG_NONE,(void *)0x0,1,pcVar6,
            "bit-is-set(node-set, string)");
    return -1;
  }
  iVar3 = lyxp_set_cast(args[1],LYXP_SET_STRING,cur_node,param_4,options);
  if (iVar3 != 0) {
    return -1;
  }
  set_fill_boolean(set,0);
  if ((((*args)->type == LYXP_SET_NODE_SET) &&
      (plVar2 = (((*args)->val).nodes)->node,
      (plVar2->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN)) &&
     (*(int *)&plVar2->schema[1].ref == 2)) {
    LVar1 = plVar2->schema[1].nodetype;
    for (i = 0; i < (int)LVar1; i = i + 1) {
      if (((&plVar2->child->schema)[i] != (lys_node *)0x0) &&
         (iVar3 = ly_strequal_((&plVar2->child->schema)[i]->name,(args[1]->val).str), iVar3 != 0)) {
        set_fill_boolean(set,1);
        return 0;
      }
    }
  }
  return 0;
}



int xpath_boolean(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4,
                 lyxp_set *set,int options)

{
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  
  if ((options & 0x3cU) == 0) {
    lyxp_set_cast(*args,LYXP_SET_BOOLEAN,cur_node,param_4,options);
    set_fill_set(set,*args);
  }
  else {
    set_snode_clear_ctx(set);
  }
  return 0;
}



int xpath_ceiling(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4,
                 lyxp_set *set,int options)

{
  char *pcVar1;
  int iVar2;
  lys_node *plVar3;
  char *pcVar4;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  int ret;
  lys_node_leaf *sleaf;
  
  ret = 0;
  if ((options & 0x3cU) == 0) {
    iVar2 = lyxp_set_cast(*args,LYXP_SET_NUMBER,cur_node,param_4,options);
    if (iVar2 == 0) {
      if ((false) || (((*args)->val).num != (longdouble)(long)ROUND(((*args)->val).num))) {
        set_fill_number(set,(longdouble)((long)ROUND(((*args)->val).num) + 1));
      }
      else {
        set_fill_number(set,((*args)->val).num);
      }
      ret = 0;
    }
    else {
      ret = -1;
    }
  }
  else {
    if (((*args)->type == LYXP_SET_SNODE_SET) &&
       (plVar3 = warn_get_snode_in_ctx(*args), plVar3 != (lys_node *)0x0)) {
      if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar1 = plVar3->name;
        pcVar4 = strnodetype(plVar3->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
               "xpath_ceiling",pcVar4,pcVar1);
        ret = 1;
      }
      else {
        iVar2 = warn_is_specific_type((lys_type *)&plVar3[1].ref,LY_TYPE_DEC64);
        if (iVar2 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #1 of %s is node \"%s\", not of type \"decimal64\".","xpath_ceiling",
                 plVar3->name);
          ret = 1;
        }
      }
    }
    else {
      ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s not a node-set as expected.",
             "xpath_ceiling");
      ret = 1;
    }
    set_snode_clear_ctx(set);
  }
  return ret;
}



int xpath_concat(lyxp_set **args,uint16_t arg_count,lyd_node *cur_node,lys_module *param_4,
                lyxp_set *set,int options)

{
  char *pcVar1;
  int iVar2;
  lys_node *plVar3;
  char *pcVar4;
  size_t sVar5;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t arg_count_local;
  lyxp_set **args_local;
  uint16_t i;
  int ret;
  char *str;
  size_t used;
  lys_node_leaf *sleaf;
  
  str = (char *)0x0;
  used = 1;
  ret = 0;
  if ((options & 0x3cU) == 0) {
    for (i = 0; i < arg_count; i = i + 1) {
      iVar2 = lyxp_set_cast(args[i],LYXP_SET_STRING,cur_node,param_4,options);
      if (iVar2 != 0) {
        free(str);
        return -1;
      }
      sVar5 = strlen((args[i]->val).str);
      str = (char *)ly_realloc(str,used + sVar5);
      if (str == (char *)0x0) {
        ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","xpath_concat");
        return -1;
      }
      strcpy(str + (used - 1),(args[i]->val).str);
      sVar5 = strlen((args[i]->val).str);
      used = used + sVar5;
    }
    lyxp_set_cast(set,LYXP_SET_EMPTY,cur_node,param_4,options);
    set->type = LYXP_SET_STRING;
    (set->val).str = str;
    ret = 0;
  }
  else {
    for (i = 0; i < arg_count; i = i + 1) {
      if ((args[i]->type == LYXP_SET_SNODE_SET) &&
         (plVar3 = warn_get_snode_in_ctx(args[i]), plVar3 != (lys_node *)0x0)) {
        if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
          pcVar1 = plVar3->name;
          pcVar4 = strnodetype(plVar3->nodetype);
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #%u of %s is a %s node \"%s\".",
                 (ulong)(i + 1),"xpath_concat",pcVar4,pcVar1);
          ret = 1;
        }
        else {
          iVar2 = warn_is_string_type((lys_type *)&plVar3[1].ref);
          if (iVar2 == 0) {
            ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                   "Argument #%u of %s is node \"%s\", not of string-type.",(ulong)(i + 1),
                   "xpath_concat",plVar3->name);
            ret = 1;
          }
        }
      }
    }
    set_snode_clear_ctx(set);
  }
  return ret;
}



int xpath_contains(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4,
                  lyxp_set *set,int options)

{
  int iVar1;
  lys_node *plVar2;
  char *pcVar3;
  char *pcVar4;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  int ret;
  lys_node_leaf *sleaf;
  
  ret = 0;
  if ((options & 0x3cU) == 0) {
    iVar1 = lyxp_set_cast(*args,LYXP_SET_STRING,cur_node,param_4,options);
    if (iVar1 == 0) {
      iVar1 = lyxp_set_cast(args[1],LYXP_SET_STRING,cur_node,param_4,options);
      if (iVar1 == 0) {
        pcVar4 = strstr(((*args)->val).str,(args[1]->val).str);
        if (pcVar4 == (char *)0x0) {
          set_fill_boolean(set,0);
        }
        else {
          set_fill_boolean(set,1);
        }
        ret = 0;
      }
      else {
        ret = -1;
      }
    }
    else {
      ret = -1;
    }
  }
  else {
    if ((*args)->type == LYXP_SET_SNODE_SET) {
      plVar2 = warn_get_snode_in_ctx(*args);
      if (plVar2 != (lys_node *)0x0) {
        if ((plVar2->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
          pcVar4 = plVar2->name;
          pcVar3 = strnodetype(plVar2->nodetype);
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
                 "xpath_contains",pcVar3,pcVar4);
          ret = 1;
        }
        else {
          iVar1 = warn_is_string_type((lys_type *)&plVar2[1].ref);
          if (iVar1 == 0) {
            ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                   "Argument #1 of %s is node \"%s\", not of string-type.","xpath_contains",
                   plVar2->name);
            ret = 1;
          }
        }
      }
    }
    if (args[1]->type == LYXP_SET_SNODE_SET) {
      plVar2 = warn_get_snode_in_ctx(args[1]);
      if (plVar2 != (lys_node *)0x0) {
        if ((plVar2->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
          pcVar4 = plVar2->name;
          pcVar3 = strnodetype(plVar2->nodetype);
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #2 of %s is a %s node \"%s\".",
                 "xpath_contains",pcVar3,pcVar4);
          ret = 1;
        }
        else {
          iVar1 = warn_is_string_type((lys_type *)&plVar2[1].ref);
          if (iVar1 == 0) {
            ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                   "Argument #2 of %s is node \"%s\", not of string-type.","xpath_contains",
                   plVar2->name);
            ret = 1;
          }
        }
      }
    }
    set_snode_clear_ctx(set);
  }
  return ret;
}



int xpath_count(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *UNUSED_cur_node,
               lys_module *param_4,lyxp_set *set,int options)

{
  lys_node *plVar1;
  char *pcVar2;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *UNUSED_cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  int ret;
  lys_node *snode;
  
  ret = 0;
  if ((options & 0x3cU) != 0) {
    if (((*args)->type != LYXP_SET_SNODE_SET) ||
       (plVar1 = warn_get_snode_in_ctx(*args), plVar1 == (lys_node *)0x0)) {
      ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s not a node-set as expected.",
             "xpath_count");
      ret = 1;
    }
    set_snode_clear_ctx(set);
    return ret;
  }
  if ((*args)->type == LYXP_SET_EMPTY) {
    set_fill_number(set,(longdouble)0);
    return 0;
  }
  if ((*args)->type != LYXP_SET_NODE_SET) {
    pcVar2 = print_set_type(*args);
    ly_vlog(param_4->ctx,LYE_XPATH_INARGTYPE,LY_VLOG_NONE,(void *)0x0,1,pcVar2,"count(node-set)");
    return -1;
  }
  set_fill_number(set,(longdouble)(*args)->used);
  return 0;
}



int xpath_current(lyxp_set **args,uint16_t arg_count,lyd_node *cur_node,lys_module *param_4,
                 lyxp_set *set,int options)

{
  int iVar1;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t arg_count_local;
  lyxp_set **args_local;
  
  if ((arg_count == 0) && (args == (lyxp_set **)0x0)) {
    if ((options & 0x3cU) == 0) {
      lyxp_set_cast(set,LYXP_SET_EMPTY,cur_node,param_4,options);
      set_insert_node(set,cur_node,0,LYXP_NODE_ELEM,0);
    }
    else {
      set_snode_clear_ctx(set);
      set_snode_insert_node(set,(lys_node *)cur_node,LYXP_NODE_ELEM);
    }
    iVar1 = 0;
  }
  else {
    ly_vlog(param_4->ctx,LYE_XPATH_INARGCOUNT,LY_VLOG_NONE,(void *)0x0,(ulong)arg_count,"current()")
    ;
    iVar1 = -1;
  }
  return iVar1;
}



int xpath_deref(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4,
               lyxp_set *set,int options)

{
  lyd_node *plVar1;
  lys_node *plVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  int ret;
  lys_node_leaf *sleaf;
  lyd_node_leaf_list *leaf;
  
  ret = 0;
  if ((options & 0x3cU) == 0) {
    if (((*args)->type == LYXP_SET_NODE_SET) || ((*args)->type == LYXP_SET_EMPTY)) {
      lyxp_set_cast(set,LYXP_SET_EMPTY,cur_node,param_4,options);
      if ((*args)->type != LYXP_SET_EMPTY) {
        plVar1 = (((*args)->val).nodes)->node;
        plVar2 = plVar1->schema;
        if (((plVar2->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) &&
           ((*(int *)&plVar2[1].ref == 9 || (*(int *)&plVar2[1].ref == 8)))) {
          if ((*(byte *)((long)&plVar1[1].schema + 4) & 1) != 0) {
            ly_vlog(param_4->ctx,LYE_SPEC,LY_VLOG_LYD,(((*args)->val).nodes)->node,
                    "Trying to dereference an unresolved leafref or instance-identifier.");
            return -1;
          }
          set_insert_node(set,plVar1->child,0,LYXP_NODE_ELEM,0);
        }
      }
      ret = 0;
    }
    else {
      pcVar5 = print_set_type(*args);
      ly_vlog(param_4->ctx,LYE_XPATH_INARGTYPE,LY_VLOG_NONE,(void *)0x0,1,pcVar5,"deref(node-set)");
      ret = -1;
    }
  }
  else {
    if (((*args)->type == LYXP_SET_SNODE_SET) &&
       (sleaf = (lys_node_leaf *)warn_get_snode_in_ctx(*args), sleaf != (lys_node_leaf *)0x0)) {
      if ((sleaf->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar5 = sleaf->name;
        pcVar4 = strnodetype(sleaf->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
               "xpath_deref",pcVar4,pcVar5);
        ret = 1;
      }
      else {
        iVar3 = warn_is_specific_type(&sleaf->type,LY_TYPE_LEAFREF);
        if ((iVar3 == 0) && (iVar3 = warn_is_specific_type(&sleaf->type,LY_TYPE_INST), iVar3 == 0))
        {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #1 of %s is node \"%s\", not of type \"leafref\" neither \"instance-identifier\"."
                 ,"xpath_deref",sleaf->name);
          ret = 1;
        }
      }
    }
    else {
      ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s not a node-set as expected.",
             "xpath_deref");
      ret = 1;
    }
    set_snode_clear_ctx(set);
    if ((ret == 0) && ((sleaf->type).base == LY_TYPE_LEAFREF)) {
      if ((sleaf->type).info.lref.target == (lys_node_leaf *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("sleaf->type.info.lref.target",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0xe2d,"xpath_deref");
      }
      set_snode_insert_node(set,(lys_node *)(sleaf->type).info.lref.target,LYXP_NODE_ELEM);
    }
  }
  return ret;
}



int xpath_derived_from_ident_cmp(lys_ident *ident,char *ident_str)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  size_t sVar4;
  char *ident_str_local;
  lys_ident *ident_local;
  int len;
  char *ptr;
  
  pcVar3 = strchr(ident_str,0x3a);
  ptr = ident_str;
  if (pcVar3 != (char *)0x0) {
    iVar1 = (int)pcVar3 - (int)ident_str;
    iVar2 = strncmp(ident->module->name,ident_str,(long)iVar1);
    if ((iVar2 != 0) || (ident->module->name[iVar1] != '\0')) {
      return 1;
    }
    ptr = pcVar3 + 1;
  }
  sVar4 = strlen(ptr);
  iVar1 = strncmp(ident->name,ptr,(long)(int)sVar4);
  if ((iVar1 == 0) && (ident->name[(int)sVar4] == '\0')) {
    iVar1 = 0;
  }
  else {
    iVar1 = 1;
  }
  return iVar1;
}



int xpath_derived_from(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,
                      lys_module *param_4,lyxp_set *set,int options)

{
  lyd_node *plVar1;
  int iVar2;
  lys_node *plVar3;
  char *pcVar4;
  char *pcVar5;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  uint16_t i;
  uint16_t j;
  int ret;
  lyd_val *val;
  lyd_node_leaf_list *leaf;
  lys_node_leaf *sleaf;
  
  ret = 0;
  if ((options & 0x3cU) == 0) {
    if (((*args)->type == LYXP_SET_NODE_SET) || ((*args)->type == LYXP_SET_EMPTY)) {
      iVar2 = lyxp_set_cast(args[1],LYXP_SET_STRING,cur_node,param_4,options);
      if (iVar2 == 0) {
        set_fill_boolean(set,0);
        if ((*args)->type != LYXP_SET_EMPTY) {
          for (i = 0; (uint)i < (*args)->used; i = i + 1) {
            val = (lyd_val *)0x0;
            if (((*args)->val).nodes[i].type == LYXP_NODE_ELEM) {
              plVar1 = ((*args)->val).nodes[i].node;
              plVar3 = plVar1->schema;
              if (((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) &&
                 (*(int *)&plVar3[1].ref == 7)) {
                val = (lyd_val *)&plVar1->child;
              }
            }
            else if ((((*args)->val).nodes[i].type == LYXP_NODE_ATTR) &&
                    ((((*args)->val).nodes[i].node)->hash == 7)) {
              val = (lyd_val *)&(((*args)->val).nodes[i].node)->parent;
            }
            if (val != (lyd_val *)0x0) {
              for (j = 0; j < val->ident->base_size; j = j + 1) {
                iVar2 = xpath_derived_from_ident_cmp(val->ident->base[j],(args[1]->val).str);
                if (iVar2 == 0) {
                  set_fill_boolean(set,1);
                  break;
                }
              }
              if (j < val->ident->base_size) break;
            }
          }
        }
        ret = 0;
      }
      else {
        ret = -1;
      }
    }
    else {
      pcVar5 = print_set_type(*args);
      ly_vlog(param_4->ctx,LYE_XPATH_INARGTYPE,LY_VLOG_NONE,(void *)0x0,1,pcVar5,
              "derived-from(node-set, string)");
      ret = -1;
    }
  }
  else {
    if (((*args)->type == LYXP_SET_SNODE_SET) &&
       (plVar3 = warn_get_snode_in_ctx(*args), plVar3 != (lys_node *)0x0)) {
      if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar5 = plVar3->name;
        pcVar4 = strnodetype(plVar3->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
               "xpath_derived_from",pcVar4,pcVar5);
        ret = 1;
      }
      else {
        iVar2 = warn_is_specific_type((lys_type *)&plVar3[1].ref,LY_TYPE_IDENT);
        if (iVar2 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #1 of %s is node \"%s\", not of type \"identityref\".",
                 "xpath_derived_from",plVar3->name);
          ret = 1;
        }
      }
    }
    else {
      ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s not a node-set as expected.",
             "xpath_derived_from");
      ret = 1;
    }
    if ((args[1]->type == LYXP_SET_SNODE_SET) &&
       (plVar3 = warn_get_snode_in_ctx(args[1]), plVar3 != (lys_node *)0x0)) {
      if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar5 = plVar3->name;
        pcVar4 = strnodetype(plVar3->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #2 of %s is a %s node \"%s\".",
               "xpath_derived_from",pcVar4,pcVar5);
        ret = 1;
      }
      else {
        iVar2 = warn_is_string_type((lys_type *)&plVar3[1].ref);
        if (iVar2 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #2 of %s is node \"%s\", not of string-type.","xpath_derived_from",
                 plVar3->name);
          ret = 1;
        }
      }
    }
    set_snode_clear_ctx(set);
  }
  return ret;
}



int xpath_derived_from_or_self
              (lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4,
              lyxp_set *set,int options)

{
  lyd_node *plVar1;
  int iVar2;
  lys_node *plVar3;
  char *pcVar4;
  char *pcVar5;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  uint16_t i;
  uint16_t j;
  int ret;
  lyd_val *val;
  lyd_node_leaf_list *leaf;
  lys_node_leaf *sleaf;
  
  ret = 0;
  if ((options & 0x3cU) == 0) {
    if (((*args)->type == LYXP_SET_NODE_SET) || ((*args)->type == LYXP_SET_EMPTY)) {
      iVar2 = lyxp_set_cast(args[1],LYXP_SET_STRING,cur_node,param_4,options);
      if (iVar2 == 0) {
        set_fill_boolean(set,0);
        if ((*args)->type != LYXP_SET_EMPTY) {
          for (i = 0; (uint)i < (*args)->used; i = i + 1) {
            val = (lyd_val *)0x0;
            if (((*args)->val).nodes[i].type == LYXP_NODE_ELEM) {
              plVar1 = ((*args)->val).nodes[i].node;
              plVar3 = plVar1->schema;
              if (((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) &&
                 (*(int *)&plVar3[1].ref == 7)) {
                val = (lyd_val *)&plVar1->child;
              }
            }
            else if ((((*args)->val).nodes[i].type == LYXP_NODE_ATTR) &&
                    ((((*args)->val).nodes[i].node)->hash == 7)) {
              val = (lyd_val *)&(((*args)->val).nodes[i].node)->parent;
            }
            if (val != (lyd_val *)0x0) {
              iVar2 = xpath_derived_from_ident_cmp(val->ident,(args[1]->val).str);
              if (iVar2 == 0) {
                set_fill_boolean(set,1);
                break;
              }
              for (j = 0; j < val->ident->base_size; j = j + 1) {
                iVar2 = xpath_derived_from_ident_cmp(val->ident->base[j],(args[1]->val).str);
                if (iVar2 == 0) {
                  set_fill_boolean(set,1);
                  break;
                }
              }
              if (j < val->ident->base_size) break;
            }
          }
        }
        ret = 0;
      }
      else {
        ret = -1;
      }
    }
    else {
      pcVar5 = print_set_type(*args);
      ly_vlog(param_4->ctx,LYE_XPATH_INARGTYPE,LY_VLOG_NONE,(void *)0x0,1,pcVar5,
              "derived-from-or-self(node-set, string)");
      ret = -1;
    }
  }
  else {
    if (((*args)->type == LYXP_SET_SNODE_SET) &&
       (plVar3 = warn_get_snode_in_ctx(*args), plVar3 != (lys_node *)0x0)) {
      if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar5 = plVar3->name;
        pcVar4 = strnodetype(plVar3->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
               "xpath_derived_from_or_self",pcVar4,pcVar5);
        ret = 1;
      }
      else {
        iVar2 = warn_is_specific_type((lys_type *)&plVar3[1].ref,LY_TYPE_IDENT);
        if (iVar2 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #1 of %s is node \"%s\", not of type \"identityref\".",
                 "xpath_derived_from_or_self",plVar3->name);
          ret = 1;
        }
      }
    }
    else {
      ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s not a node-set as expected.",
             "xpath_derived_from_or_self");
      ret = 1;
    }
    if ((args[1]->type == LYXP_SET_SNODE_SET) &&
       (plVar3 = warn_get_snode_in_ctx(args[1]), plVar3 != (lys_node *)0x0)) {
      if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar5 = plVar3->name;
        pcVar4 = strnodetype(plVar3->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #2 of %s is a %s node \"%s\".",
               "xpath_derived_from_or_self",pcVar4,pcVar5);
        ret = 1;
      }
      else {
        iVar2 = warn_is_string_type((lys_type *)&plVar3[1].ref);
        if (iVar2 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #2 of %s is node \"%s\", not of string-type.",
                 "xpath_derived_from_or_self",plVar3->name);
          ret = 1;
        }
      }
    }
    set_snode_clear_ctx(set);
  }
  return ret;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int xpath_enum_value(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *UNUSED_cur_node,
                    lys_module *param_4,lyxp_set *set,int options)

{
  lyd_node *plVar1;
  int iVar2;
  lys_node *plVar3;
  char *pcVar4;
  char *pcVar5;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *UNUSED_cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  int ret;
  lyd_node_leaf_list *leaf;
  lys_node_leaf *sleaf;
  
  ret = 0;
  if ((options & 0x3cU) != 0) {
    if (((*args)->type == LYXP_SET_SNODE_SET) &&
       (plVar3 = warn_get_snode_in_ctx(*args), plVar3 != (lys_node *)0x0)) {
      if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar5 = plVar3->name;
        pcVar4 = strnodetype(plVar3->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
               "xpath_enum_value",pcVar4,pcVar5);
        ret = 1;
      }
      else {
        iVar2 = warn_is_specific_type((lys_type *)&plVar3[1].ref,LY_TYPE_ENUM);
        if (iVar2 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #1 of %s is node \"%s\", not of type \"enumeration\".","xpath_enum_value"
                 ,plVar3->name);
          ret = 1;
        }
      }
    }
    else {
      ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s not a node-set as expected.",
             "xpath_enum_value");
      ret = 1;
    }
    set_snode_clear_ctx(set);
                    // WARNING: Read-only address (ram,0x0022cd00) is written
    return ret;
  }
  if (((*args)->type != LYXP_SET_NODE_SET) && ((*args)->type != LYXP_SET_EMPTY)) {
    pcVar5 = print_set_type(*args);
    ly_vlog(param_4->ctx,LYE_XPATH_INARGTYPE,LY_VLOG_NONE,(void *)0x0,1,pcVar5,
            "enum-value(node-set)");
    return -1;
  }
  set_fill_number(set,_DAT_0022cd00);
  if (((*args)->type == LYXP_SET_NODE_SET) &&
     ((plVar1 = (((*args)->val).nodes)->node,
      (plVar1->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN &&
      (*(int *)&plVar1->schema[1].ref == 6)))) {
    set_fill_number(set,(longdouble)*(int *)((long)&plVar1->child->next + 4));
  }
  return 0;
}



int xpath_false(lyxp_set **UNUSED_args,uint16_t UNUSED_arg_count,lyd_node *UNUSED_cur_node,
               lys_module *UNUSED_local_mod,lyxp_set *set,int options)

{
  lyxp_set *set_local;
  lys_module *UNUSED_local_mod_local;
  lyd_node *UNUSED_cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **UNUSED_args_local;
  
  if ((options & 0x3cU) == 0) {
    set_fill_boolean(set,0);
  }
  else {
    set_snode_clear_ctx(set);
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int xpath_floor(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4,
               lyxp_set *set,int options)

{
  int iVar1;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  
  iVar1 = lyxp_set_cast(*args,LYXP_SET_NUMBER,cur_node,param_4,options);
  if (iVar1 == 0) {
    if (ABS(((*args)->val).num) <= _DAT_0022ccf0) {
      set_fill_number(set,(longdouble)(long)ROUND(((*args)->val).num));
    }
    iVar1 = 0;
  }
  else {
    iVar1 = -1;
  }
  return iVar1;
}



int xpath_lang(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4,
              lyxp_set *set,int options)

{
  lyxp_node_type lVar1;
  int iVar2;
  int iVar3;
  lys_node *plVar4;
  char *pcVar5;
  char *pcVar6;
  lyd_node *root_00;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  int i;
  int ret;
  lyd_node *node;
  lyd_attr *attr;
  lyd_node *root;
  lys_node_leaf *sleaf;
  
  attr = (lyd_attr *)0x0;
  ret = 0;
  if ((options & 0x3cU) != 0) {
    if (((*args)->type == LYXP_SET_SNODE_SET) &&
       (plVar4 = warn_get_snode_in_ctx(*args), plVar4 != (lys_node *)0x0)) {
      if ((plVar4->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar6 = plVar4->name;
        pcVar5 = strnodetype(plVar4->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
               "xpath_lang",pcVar5,pcVar6);
        ret = 1;
      }
      else {
        iVar2 = warn_is_string_type((lys_type *)&plVar4[1].ref);
        if (iVar2 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #1 of %s is node \"%s\", not of string-type.","xpath_lang",plVar4->name);
          ret = 1;
        }
      }
    }
    set_snode_clear_ctx(set);
    return ret;
  }
  iVar2 = lyxp_set_cast(*args,LYXP_SET_STRING,cur_node,param_4,options);
  if (iVar2 != 0) {
    return -1;
  }
  if (set->type == LYXP_SET_EMPTY) {
    set_fill_boolean(set,0);
    return 0;
  }
  if (set->type != LYXP_SET_NODE_SET) {
    pcVar6 = print_set_type(set);
    ly_vlog(param_4->ctx,LYE_XPATH_INCTX,LY_VLOG_NONE,(void *)0x0,pcVar6,"lang(string)");
    return -1;
  }
  lVar1 = ((set->val).nodes)->type;
  if (lVar1 < LYXP_NODE_ATTR) {
    if (LYXP_NODE_ROOT_CONFIG < lVar1) {
      node = ((set->val).nodes)->node;
LAB_001d245d:
      for (; node != (lyd_node *)0x0; node = node->parent) {
        attr = node->attr;
        while ((attr != (lyd_attr *)0x0 &&
               (((attr->name == (char *)0x0 || (iVar2 = strcmp(attr->name,"lang"), iVar2 != 0)) ||
                (iVar2 = strcmp(attr->annotation->module->name,"xml"), iVar2 != 0))))) {
          attr = attr->next;
        }
        if (attr != (lyd_attr *)0x0) break;
      }
      if (attr == (lyd_attr *)0x0) {
        set_fill_boolean(set,0);
      }
      else {
        for (i = 0; *(char *)((long)&(((*args)->val).nodes)->node + (long)i) != '\0'; i = i + 1) {
          iVar2 = tolower((int)*(char *)((long)&(((*args)->val).nodes)->node + (long)i));
          iVar3 = tolower((int)attr->value_str[i]);
          if (iVar2 != iVar3) {
            set_fill_boolean(set,0);
            break;
          }
        }
        if (*(char *)((long)&(((*args)->val).nodes)->node + (long)i) == '\0') {
          if ((attr->value_str[i] == '\0') || (attr->value_str[i] == '-')) {
            set_fill_boolean(set,1);
          }
          else {
            set_fill_boolean(set,0);
          }
        }
      }
      return 0;
    }
  }
  else if (lVar1 == LYXP_NODE_ATTR) {
    root_00 = moveto_get_root(cur_node,options,(lyxp_node_type *)0x0);
    node = lyd_attr_parent(root_00,((set->val).attrs)->attr);
    goto LAB_001d245d;
  }
  set_fill_boolean(set,0);
  return 0;
}



int xpath_last(lyxp_set **UNUSED_args,uint16_t UNUSED_arg_count,lyd_node *UNUSED_cur_node,
              lys_module *param_4,lyxp_set *set,int options)

{
  int iVar1;
  char *pcVar2;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *UNUSED_cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **UNUSED_args_local;
  
  if ((options & 0x3cU) == 0) {
    if (set->type == LYXP_SET_EMPTY) {
      set_fill_number(set,(longdouble)0);
      iVar1 = 0;
    }
    else if (set->type == LYXP_SET_NODE_SET) {
      set_fill_number(set,(longdouble)set->ctx_size);
      iVar1 = 0;
    }
    else {
      pcVar2 = print_set_type(set);
      ly_vlog(param_4->ctx,LYE_XPATH_INCTX,LY_VLOG_NONE,(void *)0x0,pcVar2,"last()");
      iVar1 = -1;
    }
  }
  else {
    set_snode_clear_ctx(set);
    iVar1 = 0;
  }
  return iVar1;
}



int xpath_local_name(lyxp_set **args,uint16_t arg_count,lyd_node *cur_node,lys_module *param_4,
                    lyxp_set *set,int options)

{
  lyxp_node_type lVar1;
  int iVar2;
  char *pcVar3;
  size_t sVar4;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t arg_count_local;
  lyxp_set **args_local;
  lyxp_set_node *item;
  
  if ((options & 0x3cU) != 0) {
    set_snode_clear_ctx(set);
    return 0;
  }
  if (arg_count == 0) {
    if (set->type == LYXP_SET_EMPTY) {
      set_fill_string(set,"",0);
      return 0;
    }
    if (set->type != LYXP_SET_NODE_SET) {
      pcVar3 = print_set_type(set);
      ly_vlog(param_4->ctx,LYE_XPATH_INCTX,LY_VLOG_NONE,(void *)0x0,pcVar3,"local-name(node-set?)");
      return -1;
    }
    iVar2 = set_sort(set,cur_node,options);
    if (iVar2 != 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("!set_sort(set, cur_node, options)",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x103f,"xpath_local_name");
    }
    item = (set->val).nodes;
  }
  else {
    if ((*args)->type == LYXP_SET_EMPTY) {
      set_fill_string(set,"",0);
      return 0;
    }
    if ((*args)->type != LYXP_SET_NODE_SET) {
      pcVar3 = print_set_type(*args);
      ly_vlog(param_4->ctx,LYE_XPATH_INARGTYPE,LY_VLOG_NONE,(void *)0x0,1,pcVar3,
              "local-name(node-set?)");
      return -1;
    }
    iVar2 = set_sort(*args,cur_node,options);
    if (iVar2 != 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("!set_sort(args[0], cur_node, options)",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x1031,"xpath_local_name");
    }
    item = ((*args)->val).nodes;
  }
  lVar1 = item->type;
  if (lVar1 == LYXP_NODE_ATTR) {
    sVar4 = strlen((char *)item->node->next);
    set_fill_string(set,(char *)item->node->next,(uint16_t)sVar4);
LAB_001d2952:
    iVar2 = 0;
  }
  else {
    if (lVar1 < LYXP_NODE_NONE) {
      if (lVar1 == LYXP_NODE_TEXT) {
LAB_001d2894:
        set_fill_string(set,"",0);
        goto LAB_001d2952;
      }
      if (lVar1 < LYXP_NODE_ATTR) {
        if (lVar1 < LYXP_NODE_ELEM) goto LAB_001d2894;
        if (lVar1 == LYXP_NODE_ELEM) {
          sVar4 = strlen(item->node->schema->name);
          set_fill_string(set,item->node->schema->name,(uint16_t)sVar4);
          goto LAB_001d2952;
        }
      }
    }
    ly_log(param_4->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
           ,0x1051);
    iVar2 = -1;
  }
  return iVar2;
}



int xpath_name(lyxp_set **args,uint16_t arg_count,lyd_node *cur_node,lys_module *param_4,
              lyxp_set *set,int options)

{
  int iVar1;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t arg_count_local;
  lyxp_set **args_local;
  
  iVar1 = xpath_local_name(args,arg_count,cur_node,param_4,set,options);
  return iVar1;
}



int xpath_namespace_uri(lyxp_set **args,uint16_t arg_count,lyd_node *cur_node,lys_module *param_4,
                       lyxp_set *set,int options)

{
  lyxp_node_type lVar1;
  int iVar2;
  char *pcVar3;
  lys_module *plVar4;
  size_t sVar5;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t arg_count_local;
  lyxp_set **args_local;
  lyxp_set_node *item;
  lys_module *module;
  
  if ((options & 0x3cU) != 0) {
    set_snode_clear_ctx(set);
    return 0;
  }
  if (arg_count == 0) {
    if (set->type == LYXP_SET_EMPTY) {
      set_fill_string(set,"",0);
      return 0;
    }
    if (set->type != LYXP_SET_NODE_SET) {
      pcVar3 = print_set_type(set);
      ly_vlog(param_4->ctx,LYE_XPATH_INCTX,LY_VLOG_NONE,(void *)0x0,pcVar3,
              "namespace-uri(node-set?)");
      return -1;
    }
    iVar2 = set_sort(set,cur_node,options);
    if (iVar2 != 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("!set_sort(set, cur_node, options)",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x10a1,"xpath_namespace_uri");
    }
    item = (set->val).nodes;
  }
  else {
    if ((*args)->type == LYXP_SET_EMPTY) {
      set_fill_string(set,"",0);
      return 0;
    }
    if ((*args)->type != LYXP_SET_NODE_SET) {
      pcVar3 = print_set_type(*args);
      ly_vlog(param_4->ctx,LYE_XPATH_INARGTYPE,LY_VLOG_NONE,(void *)0x0,1,pcVar3,
              "namespace-uri(node-set?)");
      return -1;
    }
    iVar2 = set_sort(*args,cur_node,options);
    if (iVar2 != 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("!set_sort(args[0], cur_node, options)",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x1093,"xpath_namespace_uri");
    }
    item = ((*args)->val).nodes;
  }
  lVar1 = item->type;
  if (lVar1 == LYXP_NODE_ATTR) {
LAB_001d2bee:
    if (item->type == LYXP_NODE_ELEM) {
      module = item->node->schema->module;
    }
    else {
      module = *(lys_module **)&item->node->attr->value_type;
    }
    plVar4 = lys_main_module(module);
    sVar5 = strlen(plVar4->ns);
    set_fill_string(set,plVar4->ns,(uint16_t)sVar5);
LAB_001d2c9c:
    iVar2 = 0;
  }
  else {
    if (lVar1 < LYXP_NODE_NONE) {
      if (lVar1 == LYXP_NODE_TEXT) {
LAB_001d2bd1:
        set_fill_string(set,"",0);
        goto LAB_001d2c9c;
      }
      if (lVar1 < LYXP_NODE_ATTR) {
        if (lVar1 < LYXP_NODE_ELEM) goto LAB_001d2bd1;
        if (lVar1 == LYXP_NODE_ELEM) goto LAB_001d2bee;
      }
    }
    ly_log(param_4->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
           ,0x10b9);
    iVar2 = -1;
  }
  return iVar2;
}



int xpath_node(lyxp_set **UNUSED_args,uint16_t UNUSED_arg_count,lyd_node *cur_node,
              lys_module *param_4,lyxp_set *set,int options)

{
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **UNUSED_args_local;
  
  if ((options & 0x3cU) == 0) {
    if (set->type != LYXP_SET_NODE_SET) {
      lyxp_set_cast(set,LYXP_SET_EMPTY,cur_node,param_4,options);
    }
  }
  else {
    set_snode_clear_ctx(set);
  }
  return 0;
}



int xpath_normalize_space
              (lyxp_set **args,uint16_t arg_count,lyd_node *cur_node,lys_module *param_4,
              lyxp_set *set,int options)

{
  char *pcVar1;
  bool bVar2;
  bool bVar3;
  undefined uVar4;
  int iVar5;
  lys_node *plVar6;
  char *pcVar7;
  size_t __size;
  void *ptr;
  lyxp_set_node *plVar8;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t arg_count_local;
  lyxp_set **args_local;
  uint16_t i;
  uint16_t new_used;
  int have_spaces;
  int space_before;
  int ret;
  char *new;
  lys_node_leaf *sleaf;
  
  bVar3 = false;
  bVar2 = false;
  ret = 0;
  if ((options & 0x3cU) == 0) {
    if (arg_count != 0) {
      set_fill_set(set,*args);
    }
    iVar5 = lyxp_set_cast(set,LYXP_SET_STRING,cur_node,param_4,options);
    if (iVar5 == 0) {
      for (i = 0; *(char *)((long)&((set->val).nodes)->node + (ulong)i) != '\0'; i = i + 1) {
        if ((((*(char *)((long)&((set->val).nodes)->node + (ulong)i) == ' ') ||
             (*(char *)((long)&((set->val).nodes)->node + (ulong)i) == '\t')) ||
            (*(char *)((long)&((set->val).nodes)->node + (ulong)i) == '\n')) ||
           (*(char *)((long)&((set->val).nodes)->node + (ulong)i) == '\r')) {
          if (((i == 0) || (bVar2)) ||
             (*(char *)((long)&((set->val).nodes)->node + (ulong)i + 1) == '\0')) {
            bVar3 = true;
            break;
          }
          bVar2 = true;
        }
        else {
          bVar2 = false;
        }
      }
      if (bVar3) {
        __size = strlen((set->val).str);
        ptr = malloc(__size);
        if (ptr == (void *)0x0) {
          ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "xpath_normalize_space");
          return -1;
        }
        new_used = 0;
        bVar2 = false;
        for (i = 0; *(char *)((long)&((set->val).nodes)->node + (ulong)i) != '\0'; i = i + 1) {
          if (((*(char *)((long)&((set->val).nodes)->node + (ulong)i) == ' ') ||
              (*(char *)((long)&((set->val).nodes)->node + (ulong)i) == '\t')) ||
             ((*(char *)((long)&((set->val).nodes)->node + (ulong)i) == '\n' ||
              (*(char *)((long)&((set->val).nodes)->node + (ulong)i) == '\r')))) {
            if ((i != 0) && (!bVar2)) {
              bVar2 = true;
              goto LAB_001d306d;
            }
            bVar2 = true;
          }
          else {
            bVar2 = false;
LAB_001d306d:
            if (bVar2) {
              uVar4 = 0x20;
            }
            else {
              uVar4 = *(undefined *)((long)&((set->val).nodes)->node + (ulong)i);
            }
            *(undefined *)((long)ptr + (ulong)new_used) = uVar4;
            new_used = new_used + 1;
          }
        }
        if ((new_used != 0) &&
           ((((*(char *)((long)ptr + ((ulong)new_used - 1)) == ' ' ||
              (*(char *)((long)ptr + ((ulong)new_used - 1)) == '\t')) ||
             (*(char *)((long)ptr + ((ulong)new_used - 1)) == '\n')) ||
            (*(char *)((long)ptr + ((ulong)new_used - 1)) == '\r')))) {
          new_used = new_used - 1;
        }
        plVar8 = (lyxp_set_node *)ly_realloc(ptr,(long)(int)(new_used + 1));
        if (plVar8 == (lyxp_set_node *)0x0) {
          ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "xpath_normalize_space");
          return -1;
        }
        *(undefined *)((long)&plVar8->node + (ulong)new_used) = 0;
        free((set->val).nodes);
        (set->val).nodes = plVar8;
      }
      ret = 0;
    }
    else {
      ret = -1;
    }
  }
  else {
    if (((arg_count != 0) && ((*args)->type == LYXP_SET_SNODE_SET)) &&
       (plVar6 = warn_get_snode_in_ctx(*args), plVar6 != (lys_node *)0x0)) {
      if ((plVar6->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar1 = plVar6->name;
        pcVar7 = strnodetype(plVar6->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
               "xpath_normalize_space",pcVar7,pcVar1);
        ret = 1;
      }
      else {
        iVar5 = warn_is_string_type((lys_type *)&plVar6[1].ref);
        if (iVar5 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #1 of %s is node \"%s\", not of string-type.","xpath_normalize_space",
                 plVar6->name);
          ret = 1;
        }
      }
    }
    set_snode_clear_ctx(set);
  }
  return ret;
}



int xpath_not(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4,
             lyxp_set *set,int options)

{
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  
  if ((options & 0x3cU) == 0) {
    lyxp_set_cast(*args,LYXP_SET_BOOLEAN,cur_node,param_4,options);
    if (((*args)->val).bool == 0) {
      set_fill_boolean(set,1);
    }
    else {
      set_fill_boolean(set,0);
    }
  }
  else {
    set_snode_clear_ctx(set);
  }
  return 0;
}



int xpath_number(lyxp_set **args,uint16_t arg_count,lyd_node *cur_node,lys_module *param_4,
                lyxp_set *set,int options)

{
  int iVar1;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t arg_count_local;
  lyxp_set **args_local;
  
  if ((options & 0x3cU) == 0) {
    if (arg_count == 0) {
      iVar1 = lyxp_set_cast(set,LYXP_SET_NUMBER,cur_node,param_4,options);
      if (iVar1 != 0) {
        return -1;
      }
    }
    else {
      iVar1 = lyxp_set_cast(*args,LYXP_SET_NUMBER,cur_node,param_4,options);
      if (iVar1 != 0) {
        return -1;
      }
      set_fill_set(set,*args);
    }
  }
  else {
    set_snode_clear_ctx(set);
  }
  return 0;
}



int xpath_position(lyxp_set **UNUSED_args,uint16_t UNUSED_arg_count,lyd_node *UNUSED_cur_node,
                  lys_module *param_4,lyxp_set *set,int options)

{
  int iVar1;
  char *pcVar2;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *UNUSED_cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **UNUSED_args_local;
  
  if ((options & 0x3cU) == 0) {
    if (set->type == LYXP_SET_EMPTY) {
      set_fill_number(set,(longdouble)0);
      iVar1 = 0;
    }
    else if (set->type == LYXP_SET_NODE_SET) {
      set_fill_number(set,(longdouble)set->ctx_pos);
      iVar1 = 0;
    }
    else {
      pcVar2 = print_set_type(set);
      ly_vlog(param_4->ctx,LYE_XPATH_INCTX,LY_VLOG_NONE,(void *)0x0,pcVar2,"position()");
      iVar1 = -1;
    }
  }
  else {
    set_snode_clear_ctx(set);
    iVar1 = 0;
  }
  return iVar1;
}



int xpath_re_match(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4,
                  lyxp_set *set,int options)

{
  char *pcVar1;
  int iVar2;
  char *pcVar3;
  size_t sVar4;
  long in_FS_OFFSET;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  int ret;
  pcre *precomp;
  lys_node_leaf *sleaf;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  if ((options & 0x3cU) == 0) {
    iVar2 = lyxp_set_cast(*args,LYXP_SET_STRING,cur_node,param_4,options);
    if (iVar2 == 0) {
      iVar2 = lyxp_set_cast(args[1],LYXP_SET_STRING,cur_node,param_4,options);
      if (iVar2 == 0) {
        iVar2 = lyp_check_pattern(param_4->ctx,(args[1]->val).str,&precomp);
        if (iVar2 == 0) {
          sVar4 = strlen(((*args)->val).str);
          iVar2 = pcre_exec(precomp,0,((*args)->val).nodes,sVar4 & 0xffffffff,0,0,0,0);
          if (iVar2 == 0) {
            set_fill_boolean(set,1);
          }
          else {
            set_fill_boolean(set,0);
          }
          free(precomp);
          ret = 0;
        }
        else {
          ret = -1;
        }
      }
      else {
        ret = -1;
      }
    }
    else {
      ret = -1;
    }
  }
  else {
    if ((*args)->type == LYXP_SET_SNODE_SET) {
      sleaf = (lys_node_leaf *)warn_get_snode_in_ctx(*args);
      if (sleaf != (lys_node_leaf *)0x0) {
        if ((sleaf->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
          pcVar1 = sleaf->name;
          pcVar3 = strnodetype(sleaf->nodetype);
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
                 "xpath_re_match",pcVar3,pcVar1);
          ret = 1;
        }
        else {
          iVar2 = warn_is_string_type(&sleaf->type);
          if (iVar2 == 0) {
            ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                   "Argument #1 of %s is node \"%s\", not of string-type.","xpath_re_match",
                   sleaf->name);
            ret = 1;
          }
        }
      }
    }
    if (args[1]->type == LYXP_SET_SNODE_SET) {
      sleaf = (lys_node_leaf *)warn_get_snode_in_ctx(args[1]);
      if (sleaf != (lys_node_leaf *)0x0) {
        if ((sleaf->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
          pcVar1 = sleaf->name;
          pcVar3 = strnodetype(sleaf->nodetype);
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #2 of %s is a %s node \"%s\".",
                 "xpath_re_match",pcVar3,pcVar1);
          ret = 1;
        }
        else {
          iVar2 = warn_is_string_type(&sleaf->type);
          if (iVar2 == 0) {
            ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                   "Argument #2 of %s is node \"%s\", not of string-type.","xpath_re_match",
                   sleaf->name);
            ret = 1;
          }
        }
      }
    }
    set_snode_clear_ctx(set);
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return ret;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int xpath_round(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4,
               lyxp_set *set,int options)

{
  char *pcVar1;
  int iVar2;
  lys_node *plVar3;
  char *pcVar4;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  int ret;
  lys_node_leaf *sleaf;
  
  ret = 0;
  if ((options & 0x3cU) == 0) {
    iVar2 = lyxp_set_cast(*args,LYXP_SET_NUMBER,cur_node,param_4,options);
    if (iVar2 == 0) {
      if (((true) && ((longdouble)0 == ((*args)->val).num)) ||
         ((((*args)->val).num < (longdouble)0 && (_DAT_0022cd10 <= ((*args)->val).num)))) {
        set_fill_number(set,-(longdouble)0);
      }
      else {
        ((*args)->val).num = _DAT_0022cd20 + ((*args)->val).num;
        iVar2 = xpath_floor(args,1,cur_node,param_4,*args,options);
        if (iVar2 != 0) {
          return -1;
        }
        set_fill_number(set,((*args)->val).num);
      }
      ret = 0;
    }
    else {
      ret = -1;
    }
  }
  else {
    if (((*args)->type == LYXP_SET_SNODE_SET) &&
       (plVar3 = warn_get_snode_in_ctx(*args), plVar3 != (lys_node *)0x0)) {
      if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar1 = plVar3->name;
        pcVar4 = strnodetype(plVar3->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
               "xpath_round",pcVar4,pcVar1);
        ret = 1;
      }
      else {
        iVar2 = warn_is_specific_type((lys_type *)&plVar3[1].ref,LY_TYPE_DEC64);
        if (iVar2 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #1 of %s is node \"%s\", not of type \"decimal64\".","xpath_round",
                 plVar3->name);
          ret = 1;
        }
      }
    }
    else {
      ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s not a node-set as expected.",
             "xpath_round");
      ret = 1;
    }
    set_snode_clear_ctx(set);
  }
                    // WARNING: Read-only address (ram,0x0022cd10) is written
                    // WARNING: Read-only address (ram,0x0022cd20) is written
  return ret;
}



int xpath_starts_with(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,
                     lys_module *param_4,lyxp_set *set,int options)

{
  char *pcVar1;
  int iVar2;
  lys_node *plVar3;
  char *pcVar4;
  size_t __n;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  int ret;
  lys_node_leaf *sleaf;
  
  ret = 0;
  if ((options & 0x3cU) == 0) {
    iVar2 = lyxp_set_cast(*args,LYXP_SET_STRING,cur_node,param_4,options);
    if (iVar2 == 0) {
      iVar2 = lyxp_set_cast(args[1],LYXP_SET_STRING,cur_node,param_4,options);
      if (iVar2 == 0) {
        __n = strlen((args[1]->val).str);
        iVar2 = strncmp(((*args)->val).str,(args[1]->val).str,__n);
        if (iVar2 == 0) {
          set_fill_boolean(set,1);
        }
        else {
          set_fill_boolean(set,0);
        }
        ret = 0;
      }
      else {
        ret = -1;
      }
    }
    else {
      ret = -1;
    }
  }
  else {
    if ((*args)->type == LYXP_SET_SNODE_SET) {
      plVar3 = warn_get_snode_in_ctx(*args);
      if (plVar3 != (lys_node *)0x0) {
        if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
          pcVar1 = plVar3->name;
          pcVar4 = strnodetype(plVar3->nodetype);
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
                 "xpath_starts_with",pcVar4,pcVar1);
          ret = 1;
        }
        else {
          iVar2 = warn_is_string_type((lys_type *)&plVar3[1].ref);
          if (iVar2 == 0) {
            ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                   "Argument #1 of %s is node \"%s\", not of string-type.","xpath_starts_with",
                   plVar3->name);
            ret = 1;
          }
        }
      }
    }
    if (args[1]->type == LYXP_SET_SNODE_SET) {
      plVar3 = warn_get_snode_in_ctx(args[1]);
      if (plVar3 != (lys_node *)0x0) {
        if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
          pcVar1 = plVar3->name;
          pcVar4 = strnodetype(plVar3->nodetype);
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #2 of %s is a %s node \"%s\".",
                 "xpath_starts_with",pcVar4,pcVar1);
          ret = 1;
        }
        else {
          iVar2 = warn_is_string_type((lys_type *)&plVar3[1].ref);
          if (iVar2 == 0) {
            ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                   "Argument #2 of %s is node \"%s\", not of string-type.","xpath_starts_with",
                   plVar3->name);
            ret = 1;
          }
        }
      }
    }
    set_snode_clear_ctx(set);
  }
  return ret;
}



int xpath_string(lyxp_set **args,uint16_t arg_count,lyd_node *cur_node,lys_module *param_4,
                lyxp_set *set,int options)

{
  int iVar1;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t arg_count_local;
  lyxp_set **args_local;
  
  if ((options & 0x3cU) == 0) {
    if (arg_count == 0) {
      iVar1 = lyxp_set_cast(set,LYXP_SET_STRING,cur_node,param_4,options);
      if (iVar1 != 0) {
        return -1;
      }
    }
    else {
      iVar1 = lyxp_set_cast(*args,LYXP_SET_STRING,cur_node,param_4,options);
      if (iVar1 != 0) {
        return -1;
      }
      set_fill_set(set,*args);
    }
  }
  else {
    set_snode_clear_ctx(set);
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int xpath_string_length(lyxp_set **args,uint16_t arg_count,lyd_node *cur_node,lys_module *param_4,
                       lyxp_set *set,int options)

{
  char *pcVar1;
  int iVar2;
  lys_node *plVar3;
  char *pcVar4;
  size_t sVar5;
  longdouble lVar6;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t arg_count_local;
  lyxp_set **args_local;
  int ret;
  lys_node_leaf *sleaf;
  
  ret = 0;
  if ((options & 0x3cU) == 0) {
    if (arg_count == 0) {
      iVar2 = lyxp_set_cast(set,LYXP_SET_STRING,cur_node,param_4,options);
      if (iVar2 != 0) {
        return -1;
      }
      sVar5 = strlen((set->val).str);
      lVar6 = (longdouble)(long)sVar5;
      if ((long)sVar5 < 0) {
        lVar6 = _DAT_0022cd30 + lVar6;
      }
      set_fill_number(set,lVar6);
    }
    else {
      iVar2 = lyxp_set_cast(*args,LYXP_SET_STRING,cur_node,param_4,options);
      if (iVar2 != 0) {
        return -1;
      }
      sVar5 = strlen(((*args)->val).str);
      lVar6 = (longdouble)(long)sVar5;
      if ((long)sVar5 < 0) {
        lVar6 = _DAT_0022cd30 + lVar6;
      }
      set_fill_number(set,lVar6);
    }
    ret = 0;
  }
  else {
    if (((arg_count != 0) && ((*args)->type == LYXP_SET_SNODE_SET)) &&
       (plVar3 = warn_get_snode_in_ctx(*args), plVar3 != (lys_node *)0x0)) {
      if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar1 = plVar3->name;
        pcVar4 = strnodetype(plVar3->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
               "xpath_string_length",pcVar4,pcVar1);
        ret = 1;
      }
      else {
        iVar2 = warn_is_string_type((lys_type *)&plVar3[1].ref);
        if (iVar2 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #1 of %s is node \"%s\", not of string-type.","xpath_string_length",
                 plVar3->name);
          ret = 1;
        }
      }
    }
    if (((arg_count == 0) && (set->type == LYXP_SET_SNODE_SET)) &&
       (plVar3 = warn_get_snode_in_ctx(set), plVar3 != (lys_node *)0x0)) {
      if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar1 = plVar3->name;
        pcVar4 = strnodetype(plVar3->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #0 of %s is a %s node \"%s\".",
               "xpath_string_length",pcVar4,pcVar1);
        ret = 1;
      }
      else {
        iVar2 = warn_is_string_type((lys_type *)&plVar3[1].ref);
        if (iVar2 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #0 of %s is node \"%s\", not of string-type.","xpath_string_length",
                 plVar3->name);
          ret = 1;
        }
      }
    }
    set_snode_clear_ctx(set);
  }
                    // WARNING: Read-only address (ram,0x0022cd30) is written
  return ret;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int xpath_substring(lyxp_set **args,uint16_t arg_count,lyd_node *cur_node,lys_module *param_4,
                   lyxp_set *set,int options)

{
  char *pcVar1;
  int iVar2;
  lys_node *plVar3;
  char *pcVar4;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t arg_count_local;
  lyxp_set **args_local;
  uint16_t str_start;
  uint16_t str_len;
  uint16_t pos;
  int start;
  int len;
  int ret;
  lys_node_leaf *sleaf;
  
  ret = 0;
  if ((options & 0x3cU) == 0) {
    iVar2 = lyxp_set_cast(*args,LYXP_SET_STRING,cur_node,param_4,options);
    if (iVar2 == 0) {
      iVar2 = xpath_round(args + 1,1,cur_node,param_4,args[1],options);
      if (iVar2 == 0) {
        if (_DAT_0022ccf0 < ABS((args[1]->val).num)) {
          if ((ABS((args[1]->val).num) <= _DAT_0022ccf0) || ((longdouble)0 <= (args[1]->val).num)) {
            start = 0x7fffffff;
          }
          else {
            start = -0x80000000;
          }
        }
        else {
          start = (int)ROUND((args[1]->val).num - (longdouble)1);
        }
        if (arg_count == 3) {
          iVar2 = xpath_round(args + 2,1,cur_node,param_4,args[2],options);
          if (iVar2 != 0) {
            return -1;
          }
          if (_DAT_0022ccf0 < ABS((args[2]->val).num)) {
            if ((NAN((args[2]->val).num)) || ((args[2]->val).num < (longdouble)0)) {
              len = 0;
            }
            else {
              len = 0x7fffffff;
            }
          }
          else {
            len = (int)ROUND((args[2]->val).num);
          }
        }
        else {
          len = 0x7fffffff;
        }
        str_start = 0;
        str_len = 0;
        for (pos = 0; *(char *)((long)&(((*args)->val).nodes)->node + (ulong)pos) != '\0';
            pos = pos + 1) {
          if ((int)(uint)pos < start) {
            str_start = str_start + 1;
          }
          else {
            if (len + start <= (int)(uint)pos) break;
            str_len = str_len + 1;
          }
        }
        set_fill_string(set,(char *)((long)&(((*args)->val).nodes)->node + (ulong)str_start),str_len
                       );
        ret = 0;
      }
      else {
        ret = -1;
      }
    }
    else {
      ret = -1;
    }
  }
  else {
    if (((*args)->type == LYXP_SET_SNODE_SET) &&
       (plVar3 = warn_get_snode_in_ctx(*args), plVar3 != (lys_node *)0x0)) {
      if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar1 = plVar3->name;
        pcVar4 = strnodetype(plVar3->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
               "xpath_substring",pcVar4,pcVar1);
        ret = 1;
      }
      else {
        iVar2 = warn_is_string_type((lys_type *)&plVar3[1].ref);
        if (iVar2 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #1 of %s is node \"%s\", not of string-type.","xpath_substring",
                 plVar3->name);
          ret = 1;
        }
      }
    }
    if ((args[1]->type == LYXP_SET_SNODE_SET) &&
       (plVar3 = warn_get_snode_in_ctx(args[1]), plVar3 != (lys_node *)0x0)) {
      if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar1 = plVar3->name;
        pcVar4 = strnodetype(plVar3->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #2 of %s is a %s node \"%s\".",
               "xpath_substring",pcVar4,pcVar1);
        ret = 1;
      }
      else {
        iVar2 = warn_is_numeric_type((lys_type *)&plVar3[1].ref);
        if (iVar2 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #2 of %s is node \"%s\", not of numeric type.","xpath_substring",
                 plVar3->name);
          ret = 1;
        }
      }
    }
    if (((arg_count == 3) && (args[2]->type == LYXP_SET_SNODE_SET)) &&
       (plVar3 = warn_get_snode_in_ctx(args[2]), plVar3 != (lys_node *)0x0)) {
      if ((plVar3->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar1 = plVar3->name;
        pcVar4 = strnodetype(plVar3->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #3 of %s is a %s node \"%s\".",
               "xpath_substring",pcVar4,pcVar1);
        ret = 1;
      }
      else {
        iVar2 = warn_is_numeric_type((lys_type *)&plVar3[1].ref);
        if (iVar2 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #3 of %s is node \"%s\", not of numeric type.","xpath_substring",
                 plVar3->name);
          ret = 1;
        }
      }
    }
    set_snode_clear_ctx(set);
  }
                    // WARNING: Read-only address (ram,0x0022ccf0) is written
  return ret;
}



int xpath_substring_after
              (lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4,
              lyxp_set *set,int options)

{
  int iVar1;
  lys_node *plVar2;
  char *pcVar3;
  char *pcVar4;
  size_t sVar5;
  size_t sVar6;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  int ret;
  char *ptr;
  lys_node_leaf *sleaf;
  
  ret = 0;
  if ((options & 0x3cU) == 0) {
    iVar1 = lyxp_set_cast(*args,LYXP_SET_STRING,cur_node,param_4,options);
    if (iVar1 == 0) {
      iVar1 = lyxp_set_cast(args[1],LYXP_SET_STRING,cur_node,param_4,options);
      if (iVar1 == 0) {
        pcVar4 = strstr(((*args)->val).str,(args[1]->val).str);
        if (pcVar4 == (char *)0x0) {
          set_fill_string(set,"",0);
        }
        else {
          sVar5 = strlen((args[1]->val).str);
          sVar5 = strlen(pcVar4 + sVar5);
          sVar6 = strlen((args[1]->val).str);
          set_fill_string(set,pcVar4 + sVar6,(uint16_t)sVar5);
        }
        ret = 0;
      }
      else {
        ret = -1;
      }
    }
    else {
      ret = -1;
    }
  }
  else {
    if ((*args)->type == LYXP_SET_SNODE_SET) {
      plVar2 = warn_get_snode_in_ctx(*args);
      if (plVar2 != (lys_node *)0x0) {
        if ((plVar2->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
          pcVar4 = plVar2->name;
          pcVar3 = strnodetype(plVar2->nodetype);
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
                 "xpath_substring_after",pcVar3,pcVar4);
          ret = 1;
        }
        else {
          iVar1 = warn_is_string_type((lys_type *)&plVar2[1].ref);
          if (iVar1 == 0) {
            ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                   "Argument #1 of %s is node \"%s\", not of string-type.","xpath_substring_after",
                   plVar2->name);
            ret = 1;
          }
        }
      }
    }
    if (args[1]->type == LYXP_SET_SNODE_SET) {
      plVar2 = warn_get_snode_in_ctx(args[1]);
      if (plVar2 != (lys_node *)0x0) {
        if ((plVar2->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
          pcVar4 = plVar2->name;
          pcVar3 = strnodetype(plVar2->nodetype);
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #2 of %s is a %s node \"%s\".",
                 "xpath_substring_after",pcVar3,pcVar4);
          ret = 1;
        }
        else {
          iVar1 = warn_is_string_type((lys_type *)&plVar2[1].ref);
          if (iVar1 == 0) {
            ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                   "Argument #2 of %s is node \"%s\", not of string-type.","xpath_substring_after",
                   plVar2->name);
            ret = 1;
          }
        }
      }
    }
    set_snode_clear_ctx(set);
  }
  return ret;
}



int xpath_substring_before
              (lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4,
              lyxp_set *set,int options)

{
  int iVar1;
  lys_node *plVar2;
  char *pcVar3;
  char *pcVar4;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  int ret;
  char *ptr;
  lys_node_leaf *sleaf;
  
  ret = 0;
  if ((options & 0x3cU) == 0) {
    iVar1 = lyxp_set_cast(*args,LYXP_SET_STRING,cur_node,param_4,options);
    if (iVar1 == 0) {
      iVar1 = lyxp_set_cast(args[1],LYXP_SET_STRING,cur_node,param_4,options);
      if (iVar1 == 0) {
        pcVar4 = strstr(((*args)->val).str,(args[1]->val).str);
        if (pcVar4 == (char *)0x0) {
          set_fill_string(set,"",0);
        }
        else {
          set_fill_string(set,((*args)->val).str,(short)pcVar4 - (short)*(undefined8 *)&(*args)->val
                         );
        }
        ret = 0;
      }
      else {
        ret = -1;
      }
    }
    else {
      ret = -1;
    }
  }
  else {
    if ((*args)->type == LYXP_SET_SNODE_SET) {
      plVar2 = warn_get_snode_in_ctx(*args);
      if (plVar2 != (lys_node *)0x0) {
        if ((plVar2->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
          pcVar4 = plVar2->name;
          pcVar3 = strnodetype(plVar2->nodetype);
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
                 "xpath_substring_before",pcVar3,pcVar4);
          ret = 1;
        }
        else {
          iVar1 = warn_is_string_type((lys_type *)&plVar2[1].ref);
          if (iVar1 == 0) {
            ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                   "Argument #1 of %s is node \"%s\", not of string-type.","xpath_substring_before",
                   plVar2->name);
            ret = 1;
          }
        }
      }
    }
    if (args[1]->type == LYXP_SET_SNODE_SET) {
      plVar2 = warn_get_snode_in_ctx(args[1]);
      if (plVar2 != (lys_node *)0x0) {
        if ((plVar2->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
          pcVar4 = plVar2->name;
          pcVar3 = strnodetype(plVar2->nodetype);
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #2 of %s is a %s node \"%s\".",
                 "xpath_substring_before",pcVar3,pcVar4);
          ret = 1;
        }
        else {
          iVar1 = warn_is_string_type((lys_type *)&plVar2[1].ref);
          if (iVar1 == 0) {
            ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                   "Argument #2 of %s is node \"%s\", not of string-type.","xpath_substring_before",
                   plVar2->name);
            ret = 1;
          }
        }
      }
    }
    set_snode_clear_ctx(set);
  }
  return ret;
}



int xpath_sum(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4,
             lyxp_set *set,int options)

{
  long lVar1;
  lys_node *plVar2;
  lyxp_node_type lVar3;
  uint32_t uVar4;
  int iVar5;
  char *pcVar6;
  lyxp_set_node *plVar7;
  longdouble *__return_storage_ptr__;
  lyd_node *plVar8;
  long in_FS_OFFSET;
  longdouble in_ST0;
  longdouble in_ST1;
  longdouble in_ST2;
  longdouble in_ST3;
  longdouble in_ST4;
  longdouble in_ST5;
  longdouble in_ST6;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  uint16_t i;
  int ret;
  char *str;
  lys_node_leaf *sleaf;
  longdouble num;
  lyxp_set set_item;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  if ((options & 0x3cU) == 0) {
    set_fill_number(set,(longdouble)0);
    if ((*args)->type == LYXP_SET_EMPTY) {
      ret = 0;
    }
    else if ((*args)->type == LYXP_SET_NODE_SET) {
      set_item.type = LYXP_SET_NODE_SET;
      set_item.val.nodes = (lyxp_set_node *)malloc(0x10);
      if (set_item.val.nodes == (lyxp_set_node *)0x0) {
        ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","xpath_sum");
        ret = -1;
      }
      else {
        set_item.used = 1;
        set_item.size = 1;
        for (i = 0; (uint)i < (*args)->used; i = i + 1) {
          plVar7 = ((*args)->val).nodes + i;
          lVar3 = plVar7->type;
          uVar4 = plVar7->pos;
          (set_item.val.nodes)->node = plVar7->node;
          *(lyxp_node_type *)(set_item.val._0_8_ + 8) = lVar3;
          *(uint32_t *)(set_item.val._0_8_ + 0xc) = uVar4;
          plVar8 = cur_node;
          __return_storage_ptr__ =
               (longdouble *)cast_node_set_to_string(&set_item,cur_node,param_4,options);
          if (__return_storage_ptr__ == (longdouble *)0x0) {
            ret = -1;
            goto LAB_001d5052;
          }
          cast_string_to_number(__return_storage_ptr__,(char *)plVar8);
          free(__return_storage_ptr__);
          (set->val).num = in_ST0 + (set->val).num;
          in_ST0 = in_ST1;
          in_ST1 = in_ST2;
          in_ST2 = in_ST3;
          in_ST3 = in_ST4;
          in_ST4 = in_ST5;
          in_ST5 = in_ST6;
        }
        free(set_item.val.nodes);
        ret = 0;
      }
    }
    else {
      pcVar6 = print_set_type(*args);
      ly_vlog(param_4->ctx,LYE_XPATH_INARGTYPE,LY_VLOG_NONE,(void *)0x0,1,pcVar6,"sum(node-set)");
      ret = -1;
    }
  }
  else {
    if ((*args)->type == LYXP_SET_SNODE_SET) {
      for (i = 0; (uint)i < (*args)->used; i = i + 1) {
        if (((*args)->val).nodes[i].pos == 1) {
          plVar8 = ((*args)->val).nodes[i].node;
          if ((*(uint *)&plVar8->ht & 0xc) == 0) {
            plVar2 = plVar8->schema;
            pcVar6 = strnodetype(*(LYS_NODE *)&plVar8->ht);
            ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
                   "xpath_sum",pcVar6,plVar2);
            ret = 1;
          }
          else {
            iVar5 = warn_is_numeric_type((lys_type *)&plVar8[1].ht);
            if (iVar5 == 0) {
              ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                     "Argument #1 of %s is node \"%s\", not of numeric type.","xpath_sum",
                     plVar8->schema);
              ret = 1;
            }
          }
        }
      }
    }
    set_snode_clear_ctx(set);
  }
LAB_001d5052:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return ret;
}



int xpath_text(lyxp_set **UNUSED_args,uint16_t UNUSED_arg_count,lyd_node *UNUSED_cur_node,
              lys_module *param_4,lyxp_set *set,int options)

{
  lyxp_node_type lVar1;
  int iVar2;
  char *pcVar3;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *UNUSED_cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **UNUSED_args_local;
  uint32_t i;
  
  if ((options & 0x3cU) == 0) {
    if (set->type == LYXP_SET_EMPTY) {
      iVar2 = 0;
    }
    else {
      if (set->type == LYXP_SET_NODE_SET) {
        i = 0;
LAB_001d5282:
        do {
          if (set->used <= i) {
            return 0;
          }
          lVar1 = (set->val).nodes[i].type;
          if (LYXP_NODE_ATTR < lVar1) {
LAB_001d5249:
            ly_log(param_4->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                   ,0x1417);
            return -1;
          }
          if ((LYXP_NODE_ELEM < lVar1) || (lVar1 < LYXP_NODE_ELEM)) {
LAB_001d5236:
            set_remove_node(set,i);
            goto LAB_001d5282;
          }
          if (lVar1 != LYXP_NODE_ELEM) goto LAB_001d5249;
          if ((char)((set->val).nodes[i].node)->validity < '\0') {
            ly_vlog(param_4->ctx,LYE_XPATH_DUMMY,LY_VLOG_LYD,(set->val).nodes[i].node,
                    ((set->val).nodes[i].node)->schema->name);
            return -1;
          }
          if (((((set->val).nodes[i].node)->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) ==
               LYS_UNKNOWN) || (((set->val).nodes[i].node)->ht == (hash_table *)0x0))
          goto LAB_001d5236;
          (set->val).nodes[i].type = LYXP_NODE_TEXT;
          i = i + 1;
        } while( true );
      }
      pcVar3 = print_set_type(set);
      ly_vlog(param_4->ctx,LYE_XPATH_INCTX,LY_VLOG_NONE,(void *)0x0,pcVar3,"text()");
      iVar2 = -1;
    }
  }
  else {
    set_snode_clear_ctx(set);
    iVar2 = 0;
  }
  return iVar2;
}



int xpath_translate(lyxp_set **args,uint16_t UNUSED_arg_count,lyd_node *cur_node,lys_module *param_4
                   ,lyxp_set *set,int options)

{
  char *pcVar1;
  bool bVar2;
  bool bVar3;
  int iVar4;
  lys_node *plVar5;
  char *pcVar6;
  size_t sVar7;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **args_local;
  uint16_t i;
  uint16_t j;
  uint16_t new_used;
  int found;
  int have_removed;
  int ret;
  char *new;
  lys_node_leaf *sleaf;
  
  ret = 0;
  if ((options & 0x3cU) == 0) {
    iVar4 = lyxp_set_cast(*args,LYXP_SET_STRING,cur_node,param_4,options);
    if (iVar4 == 0) {
      iVar4 = lyxp_set_cast(args[1],LYXP_SET_STRING,cur_node,param_4,options);
      if (iVar4 == 0) {
        iVar4 = lyxp_set_cast(args[2],LYXP_SET_STRING,cur_node,param_4,options);
        if (iVar4 == 0) {
          sVar7 = strlen(((*args)->val).str);
          new = (char *)malloc(sVar7 + 1);
          if (new == (char *)0x0) {
            ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                   "xpath_translate");
            ret = -1;
          }
          else {
            new_used = 0;
            bVar3 = false;
            for (i = 0; *(char *)((long)&(((*args)->val).nodes)->node + (ulong)i) != '\0'; i = i + 1
                ) {
              bVar2 = false;
              for (j = 0; *(char *)((long)&((args[1]->val).nodes)->node + (ulong)j) != '\0';
                  j = j + 1) {
                if (*(char *)((long)&(((*args)->val).nodes)->node + (ulong)i) ==
                    *(char *)((long)&((args[1]->val).nodes)->node + (ulong)j)) {
                  sVar7 = strlen((args[2]->val).str);
                  if (j < sVar7) {
                    new[new_used] = *(char *)((long)&((args[2]->val).nodes)->node + (ulong)j);
                    new_used = new_used + 1;
                    bVar2 = true;
                  }
                  else {
                    bVar3 = true;
                    bVar2 = true;
                  }
                  break;
                }
              }
              if (!bVar2) {
                new[new_used] = *(char *)((long)&(((*args)->val).nodes)->node + (ulong)i);
                new_used = new_used + 1;
              }
            }
            if ((bVar3) &&
               (new = (char *)ly_realloc(new,(long)(int)(new_used + 1)), new == (char *)0x0)) {
              ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "xpath_translate");
              return -1;
            }
            new[new_used] = '\0';
            lyxp_set_cast(set,LYXP_SET_EMPTY,cur_node,param_4,options);
            set->type = LYXP_SET_STRING;
            (set->val).str = new;
            ret = 0;
          }
        }
        else {
          ret = -1;
        }
      }
      else {
        ret = -1;
      }
    }
    else {
      ret = -1;
    }
  }
  else {
    if (((*args)->type == LYXP_SET_SNODE_SET) &&
       (plVar5 = warn_get_snode_in_ctx(*args), plVar5 != (lys_node *)0x0)) {
      if ((plVar5->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar1 = plVar5->name;
        pcVar6 = strnodetype(plVar5->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #1 of %s is a %s node \"%s\".",
               "xpath_translate",pcVar6,pcVar1);
        ret = 1;
      }
      else {
        iVar4 = warn_is_string_type((lys_type *)&plVar5[1].ref);
        if (iVar4 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #1 of %s is node \"%s\", not of string-type.","xpath_translate",
                 plVar5->name);
          ret = 1;
        }
      }
    }
    if ((args[1]->type == LYXP_SET_SNODE_SET) &&
       (plVar5 = warn_get_snode_in_ctx(args[1]), plVar5 != (lys_node *)0x0)) {
      if ((plVar5->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar1 = plVar5->name;
        pcVar6 = strnodetype(plVar5->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #2 of %s is a %s node \"%s\".",
               "xpath_translate",pcVar6,pcVar1);
        ret = 1;
      }
      else {
        iVar4 = warn_is_string_type((lys_type *)&plVar5[1].ref);
        if (iVar4 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #2 of %s is node \"%s\", not of string-type.","xpath_translate",
                 plVar5->name);
          ret = 1;
        }
      }
    }
    if ((args[2]->type == LYXP_SET_SNODE_SET) &&
       (plVar5 = warn_get_snode_in_ctx(args[2]), plVar5 != (lys_node *)0x0)) {
      if ((plVar5->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
        pcVar1 = plVar5->name;
        pcVar6 = strnodetype(plVar5->nodetype);
        ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,"Argument #3 of %s is a %s node \"%s\".",
               "xpath_translate",pcVar6,pcVar1);
        ret = 1;
      }
      else {
        iVar4 = warn_is_string_type((lys_type *)&plVar5[1].ref);
        if (iVar4 == 0) {
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Argument #3 of %s is node \"%s\", not of string-type.","xpath_translate",
                 plVar5->name);
          ret = 1;
        }
      }
    }
    set_snode_clear_ctx(set);
  }
  return ret;
}



int xpath_true(lyxp_set **UNUSED_args,uint16_t UNUSED_arg_count,lyd_node *UNUSED_cur_node,
              lys_module *UNUSED_local_mod,lyxp_set *set,int options)

{
  lyxp_set *set_local;
  lys_module *UNUSED_local_mod_local;
  lyd_node *UNUSED_cur_node_local;
  int options_local;
  uint16_t UNUSED_arg_count_local;
  lyxp_set **UNUSED_args_local;
  
  if ((options & 0x3cU) == 0) {
    set_fill_boolean(set,1);
  }
  else {
    set_snode_clear_ctx(set);
  }
  return 0;
}



lys_module *
moveto_resolve_model
          (char *mod_name_ns,uint16_t mod_nam_ns_len,ly_ctx *ctx,lys_node *cur_snode,int is_name,
          int import_and_disabled_model)

{
  int iVar1;
  lys_module *plVar2;
  char *pcVar3;
  int import_and_disabled_model_local;
  lys_node *cur_snode_local;
  ly_ctx *ctx_local;
  int is_name_local;
  uint16_t mod_nam_ns_len_local;
  char *mod_name_ns_local;
  uint16_t i;
  lys_module *mod;
  lys_module *mainmod;
  char *str;
  
  if (cur_snode != (lys_node *)0x0) {
    if (((ctx->models).parsing_sub_modules_count == '\0') ||
       (cur_snode->module ==
        (ctx->models).parsing_sub_modules[(ulong)(ctx->models).parsing_sub_modules_count - 1])) {
      mod = cur_snode->module;
    }
    else {
      mod = (ctx->models).parsing_sub_modules[(ulong)(ctx->models).parsing_sub_modules_count - 1];
    }
    plVar2 = lys_main_module(mod);
    if (is_name == 0) {
      pcVar3 = plVar2->ns;
    }
    else {
      pcVar3 = plVar2->name;
    }
    iVar1 = strncmp(pcVar3,mod_name_ns,(ulong)mod_nam_ns_len);
    if ((iVar1 == 0) && (pcVar3[mod_nam_ns_len] == '\0')) {
      return plVar2;
    }
    for (i = 0; i < mod->imp_size; i = i + 1) {
      if (is_name == 0) {
        pcVar3 = (mod->imp[i].module)->ns;
      }
      else {
        pcVar3 = (mod->imp[i].module)->name;
      }
      iVar1 = strncmp(pcVar3,mod_name_ns,(ulong)mod_nam_ns_len);
      if ((iVar1 == 0) && (pcVar3[mod_nam_ns_len] == '\0')) {
        return mod->imp[i].module;
      }
    }
  }
  i = 0;
  do {
    if ((ctx->models).used <= (int)(uint)i) {
      return (lys_module *)0x0;
    }
    if ((import_and_disabled_model != 0) ||
       ((((ctx->models).list[i]->field_0x40 & 0x80) != 0 &&
        (((ctx->models).list[i]->field_0x40 & 0x40) == 0)))) {
      if (is_name == 0) {
        pcVar3 = (ctx->models).list[i]->ns;
      }
      else {
        pcVar3 = (ctx->models).list[i]->name;
      }
      iVar1 = strncmp(pcVar3,mod_name_ns,(ulong)mod_nam_ns_len);
      if ((iVar1 == 0) && (pcVar3[mod_nam_ns_len] == '\0')) {
        return (ctx->models).list[i];
      }
    }
    i = i + 1;
  } while( true );
}



lyd_node * moveto_get_root(lyd_node *cur_node,int options,lyxp_node_type *root_type)

{
  lyxp_node_type *root_type_local;
  int options_local;
  lyd_node *cur_node_local;
  lyd_node *root;
  
  if (cur_node == (lyd_node *)0x0) {
    root = (lyd_node *)0x0;
  }
  else {
    root = cur_node;
    if (options == 0) {
      for (; root->parent != (lyd_node *)0x0; root = root->parent) {
      }
      while (root->prev->next != (lyd_node *)0x0) {
        root = root->prev;
      }
      *root_type = LYXP_NODE_ROOT;
    }
    else {
      if ((cur_node->schema->flags & 1) == 0) {
        *root_type = LYXP_NODE_ROOT;
      }
      else {
        *root_type = LYXP_NODE_ROOT_CONFIG;
      }
      for (; root->parent != (lyd_node *)0x0; root = root->parent) {
      }
      while (root->prev->next != (lyd_node *)0x0) {
        root = root->prev;
      }
    }
  }
  return root;
}



lys_node * moveto_snode_get_root(lys_node *cur_node,int options,lyxp_node_type *root_type)

{
  lys_module *module;
  lys_node *plVar1;
  lyxp_node_type *root_type_local;
  int options_local;
  lys_node *cur_node_local;
  lys_node *root;
  
  if ((cur_node != (lys_node *)0x0) && (root_type != (lyxp_node_type *)0x0)) {
    if ((options & 4U) == 0) {
      if ((cur_node->flags & 1) == 0) {
        *root_type = LYXP_NODE_ROOT;
      }
      else {
        *root_type = LYXP_NODE_ROOT_CONFIG;
      }
    }
    else {
      *root_type = LYXP_NODE_ROOT;
    }
    module = lys_node_module(cur_node);
    plVar1 = lys_getnext((lys_node *)0x0,(lys_node *)0x0,module,0x100);
    return plVar1;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("cur_node && root_type",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                ,0x151b,"moveto_snode_get_root");
}



void moveto_root(lyxp_set *set,lyd_node *cur_node,int options)

{
  long in_FS_OFFSET;
  int options_local;
  lyd_node *cur_node_local;
  lyxp_set *set_local;
  lyxp_node_type root_type;
  lyd_node *root;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (set != (lyxp_set *)0x0) {
    root = moveto_get_root(cur_node,options,&root_type);
    lyxp_set_cast(set,LYXP_SET_EMPTY,cur_node,(lys_module *)0x0,options);
    if (root != (lyd_node *)0x0) {
      set_insert_node(set,root,0,root_type,0);
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void moveto_snode_root(lyxp_set *set,lys_node *cur_node,int options)

{
  long in_FS_OFFSET;
  int options_local;
  lys_node *cur_node_local;
  lyxp_set *set_local;
  lyxp_node_type root_type;
  lys_node *root;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (set != (lyxp_set *)0x0) {
    if (cur_node == (lys_node *)0x0) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
             ,0x1550);
    }
    else {
      root = moveto_snode_get_root(cur_node,options,&root_type);
      set_snode_clear_ctx(set);
      set_snode_insert_node(set,root,root_type);
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int moveto_node_check(lyd_node *node,lyxp_node_type root_type,char *node_name,lys_module *moveto_mod
                     ,int options)

{
  int iVar1;
  lys_module *plVar2;
  lys_module *moveto_mod_local;
  char *node_name_local;
  int options_local;
  lyxp_node_type root_type_local;
  lyd_node *node_local;
  
  if ((moveto_mod != (lys_module *)0x0) && (plVar2 = lyd_node_module(node), moveto_mod != plVar2)) {
    return -1;
  }
  if ((root_type == LYXP_NODE_ROOT_CONFIG) && ((node->schema->flags & 2) != 0)) {
    iVar1 = -1;
  }
  else {
    iVar1 = strcmp(node_name,"*");
    if ((iVar1 == 0) || (node_name == node->schema->name)) {
      if ((((options & 2U) == 0) || (((byte)node->field_0x9 >> 1 & 4) == 0)) ||
         (((byte)node->field_0x9 >> 1 & 3) != 0)) {
        iVar1 = 0;
      }
      else {
        iVar1 = 1;
      }
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



int moveto_snode_check(lys_node *node,lyxp_node_type root_type,char *node_name,
                      lys_module *moveto_mod,int options)

{
  int iVar1;
  lys_module *plVar2;
  lys_module *moveto_mod_local;
  char *node_name_local;
  int options_local;
  lyxp_node_type root_type_local;
  lys_node *node_local;
  lys_node *parent;
  
  for (parent = lys_parent(node); (parent != (lys_node *)0x0 && (parent->nodetype == LYS_USES));
      parent = lys_parent(parent)) {
  }
  if ((options & 0x20U) == 0) {
    if ((parent != (lys_node *)0x0) && (parent->nodetype == LYS_OUTPUT)) {
      return -1;
    }
  }
  else if ((parent != (lys_node *)0x0) && (parent->nodetype == LYS_INPUT)) {
    return -1;
  }
  iVar1 = strcmp(node_name,"*");
  if ((iVar1 != 0) && (plVar2 = lys_node_module(node), moveto_mod != plVar2)) {
    return -1;
  }
  if ((root_type == LYXP_NODE_ROOT_CONFIG) && ((node->flags & 2) != 0)) {
    iVar1 = -1;
  }
  else {
    iVar1 = strcmp(node_name,"*");
    if ((iVar1 == 0) || (node_name == node->name)) {
      iVar1 = 0;
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



int moveto_node(lyxp_set *set,lyd_node *cur_node,char *qname,uint16_t qname_len,int options)

{
  int iVar1;
  char *pcVar2;
  long in_FS_OFFSET;
  int options_local;
  uint16_t qname_len_local;
  char *qname_local;
  lyd_node *cur_node_local;
  lyxp_set *set_local;
  lyxp_node_type root_type;
  uint32_t i;
  int replaced;
  int pref_len;
  int ret;
  lys_module *moveto_mod;
  lyd_node *sub;
  char *name_dict;
  ly_ctx *ctx;
  char *ptr;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  name_dict = (char *)0x0;
  if ((set == (lyxp_set *)0x0) || (set->type == LYXP_SET_EMPTY)) {
    iVar1 = 0;
  }
  else {
    if (cur_node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_fail("cur_node",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x15c0,"moveto_node");
    }
    ctx = cur_node->schema->module->ctx;
    if (set->type == LYXP_SET_NODE_SET) {
      moveto_get_root(cur_node,options,&root_type);
      ptr = strnchr(qname,0x3a,(uint)qname_len);
      if (ptr == (char *)0x0) {
        qname_len_local = qname_len;
        qname_local = qname;
        if ((*qname == '*') && (qname_len == 1)) {
          moveto_mod = (lys_module *)0x0;
        }
        else {
          moveto_mod = lyd_node_module(cur_node);
        }
      }
      else {
        pref_len = (int)ptr - (int)qname;
        moveto_mod = moveto_resolve_model(qname,(uint16_t)pref_len,ctx,(lys_node *)0x0,1,0);
        if (moveto_mod == (lys_module *)0x0) {
          ly_vlog(ctx,LYE_XPATH_INMOD,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)pref_len,qname);
          iVar1 = -1;
          goto LAB_001d6514;
        }
        qname_local = qname + (long)pref_len + 1;
        qname_len_local = (qname_len - (short)pref_len) - 1;
      }
      name_dict = lydict_insert(ctx,qname_local,(ulong)qname_len_local);
      i = 0;
      while (i < set->used) {
        replaced = 0;
        if (((set->val).nodes[i].type == LYXP_NODE_ROOT_CONFIG) ||
           ((set->val).nodes[i].type == LYXP_NODE_ROOT)) {
          for (sub = (set->val).nodes[i].node; sub != (lyd_node *)0x0; sub = sub->next) {
            ret = moveto_node_check(sub,root_type,name_dict,moveto_mod,options);
            if (ret == 0) {
              if (replaced == 0) {
                set_replace_node(set,sub,0,LYXP_NODE_ELEM,i);
                replaced = 1;
              }
              else {
                set_insert_node(set,sub,0,LYXP_NODE_ELEM,i);
              }
              i = i + 1;
            }
            else if (ret == 1) {
              lydict_remove(ctx,name_dict);
              iVar1 = 1;
              goto LAB_001d6514;
            }
          }
        }
        else if ((-1 < (char)((set->val).nodes[i].node)->validity) &&
                ((((set->val).nodes[i].node)->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)
                 ) == LYS_UNKNOWN)) {
          for (sub = ((set->val).nodes[i].node)->child; sub != (lyd_node *)0x0; sub = sub->next) {
            ret = moveto_node_check(sub,root_type,name_dict,moveto_mod,options);
            if (ret == 0) {
              if (replaced == 0) {
                set_replace_node(set,sub,0,LYXP_NODE_ELEM,i);
                replaced = 1;
              }
              else {
                set_insert_node(set,sub,0,LYXP_NODE_ELEM,i);
              }
              i = i + 1;
            }
            else if (ret == 1) {
              lydict_remove(ctx,name_dict);
              iVar1 = 1;
              goto LAB_001d6514;
            }
          }
        }
        if (replaced == 0) {
          set_remove_node(set,i);
        }
      }
      lydict_remove(ctx,name_dict);
      iVar1 = 0;
    }
    else {
      pcVar2 = print_set_type(set);
      ly_vlog(ctx,LYE_XPATH_INOP_1,LY_VLOG_NONE,(void *)0x0,"path operator",pcVar2);
      iVar1 = -1;
    }
  }
LAB_001d6514:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int moveto_snode(lyxp_set *set,lys_node *cur_node,char *qname,uint16_t qname_len,int options)

{
  int iVar1;
  char *pcVar2;
  lys_module *plVar3;
  lys_node *parent;
  long in_FS_OFFSET;
  int options_local;
  uint16_t qname_len_local;
  char *qname_local;
  lys_node *cur_node_local;
  lyxp_set *set_local;
  uint32_t mod_idx;
  lyxp_node_type root_type;
  int i;
  int temp_ctx;
  int pref_len;
  int orig_used;
  int idx;
  lys_module *moveto_mod;
  lys_module *tmp_mod;
  lys_node *sub;
  lys_node_augment *last_aug;
  char *name_dict;
  ly_ctx *ctx;
  char *ptr;
  lys_node *start_parent;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  temp_ctx = 0;
  name_dict = (char *)0x0;
  if ((set == (lyxp_set *)0x0) || (set->type == LYXP_SET_EMPTY)) {
    iVar1 = 0;
  }
  else {
    ctx = cur_node->module->ctx;
    if (set->type == LYXP_SET_SNODE_SET) {
      moveto_snode_get_root(cur_node,options,&root_type);
      ptr = strnchr(qname,0x3a,(uint)qname_len);
      if (ptr == (char *)0x0) {
        qname_len_local = qname_len;
        qname_local = qname;
        if ((*qname == '*') && (qname_len == 1)) {
          moveto_mod = (lys_module *)0x0;
        }
        else {
          moveto_mod = lys_node_module(cur_node);
        }
      }
      else {
        pref_len = (int)ptr - (int)qname;
        moveto_mod = moveto_resolve_model(qname,(uint16_t)pref_len,ctx,cur_node,1,1);
        if (moveto_mod == (lys_module *)0x0) {
          ly_vlog(ctx,LYE_XPATH_INMOD,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)pref_len,qname);
          iVar1 = -1;
          goto LAB_001d6ab8;
        }
        qname_local = qname + (long)pref_len + 1;
        qname_len_local = (qname_len - (short)pref_len) - 1;
      }
      name_dict = lydict_insert(ctx,qname_local,(ulong)qname_len_local);
      orig_used = set->used;
      for (i = 0; i < orig_used; i = i + 1) {
        if ((set->val).nodes[i].pos == 1) {
          (set->val).nodes[i].pos = 0;
          start_parent = (lys_node *)(set->val).nodes[i].node;
          if (((set->val).nodes[i].type == LYXP_NODE_ROOT_CONFIG) ||
             ((set->val).nodes[i].type == LYXP_NODE_ROOT)) {
            mod_idx = 0;
            while ((moveto_mod != (lys_module *)0x0 ||
                   (moveto_mod = ly_ctx_get_module_iter(ctx,&mod_idx),
                   moveto_mod != (lys_module *)0x0))) {
              sub = (lys_node *)0x0;
              while (sub = lys_getnext(sub,(lys_node *)0x0,moveto_mod,0x100), sub != (lys_node *)0x0
                    ) {
                iVar1 = moveto_snode_check(sub,root_type,name_dict,moveto_mod,options);
                if (((iVar1 == 0) &&
                    (idx = set_snode_insert_node(set,sub,LYXP_NODE_ELEM), idx < orig_used)) &&
                   (i < idx)) {
                  (set->val).nodes[idx].pos = 2;
                  temp_ctx = 1;
                }
              }
              sub = (lys_node *)0x0;
              if (mod_idx == 0) break;
              moveto_mod = (lys_module *)0x0;
            }
          }
          else if ((start_parent->nodetype & 0x802c) == 0) {
            last_aug = (lys_node_augment *)0x0;
            tmp_mod = (lys_module *)0x0;
            if ((moveto_mod == (lys_module *)0x0) || ((moveto_mod->field_0x40 & 0x80) != 0)) {
              if (moveto_mod != (lys_module *)0x0) goto LAB_001d6964;
              plVar3 = lys_node_module(cur_node);
              if ((plVar3->field_0x40 & 0x80) != 0) goto LAB_001d6964;
            }
            if (moveto_mod == (lys_module *)0x0) {
              tmp_mod = lys_node_module(cur_node);
            }
            else {
              tmp_mod = moveto_mod;
            }
            do {
              last_aug = lys_getnext_target_aug(last_aug,tmp_mod,start_parent);
LAB_001d6964:
              sub = (lys_node *)0x0;
              while( true ) {
                parent = start_parent;
                if (last_aug != (lys_node_augment *)0x0) {
                  parent = (lys_node *)last_aug;
                }
                sub = lys_getnext(sub,parent,(lys_module *)0x0,0x100);
                if (sub == (lys_node *)0x0) break;
                plVar3 = moveto_mod;
                if (moveto_mod == (lys_module *)0x0) {
                  plVar3 = lys_node_module(cur_node);
                }
                iVar1 = moveto_snode_check(sub,root_type,name_dict,plVar3,options);
                if (((iVar1 == 0) &&
                    (idx = set_snode_insert_node(set,sub,LYXP_NODE_ELEM), idx < orig_used)) &&
                   (i < idx)) {
                  (set->val).nodes[idx].pos = 2;
                  temp_ctx = 1;
                }
              }
              sub = (lys_node *)0x0;
            } while (last_aug != (lys_node_augment *)0x0);
          }
        }
      }
      lydict_remove(ctx,name_dict);
      if (temp_ctx != 0) {
        for (i = 0; i < orig_used; i = i + 1) {
          if ((set->val).nodes[i].pos == 2) {
            (set->val).nodes[i].pos = 1;
          }
        }
      }
      iVar1 = 0;
    }
    else {
      pcVar2 = print_set_type(set);
      ly_vlog(ctx,LYE_XPATH_INOP_1,LY_VLOG_NONE,(void *)0x0,"path operator",pcVar2);
      iVar1 = -1;
    }
  }
LAB_001d6ab8:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int moveto_node_alldesc(lyxp_set *set,lyd_node *cur_node,char *qname,uint16_t qname_len,int options)

{
  long lVar1;
  int iVar2;
  char *pcVar3;
  lys_module *plVar4;
  lys_module *plVar5;
  long in_FS_OFFSET;
  int options_local;
  uint16_t qname_len_local;
  char *qname_local;
  lyd_node *cur_node_local;
  lyxp_set *set_local;
  lyxp_node_type root_type;
  uint32_t i;
  int all;
  int match;
  int pref_len;
  int ret;
  lyd_node *next;
  lyd_node *elem;
  lys_module *moveto_mod;
  lyd_node *start;
  lyxp_set ret_set;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  all = 0;
  if ((set == (lyxp_set *)0x0) || (set->type == LYXP_SET_EMPTY)) {
    iVar2 = 0;
  }
  else if (set->type == LYXP_SET_NODE_SET) {
    moveto_get_root(cur_node,options,&root_type);
    pcVar3 = strnchr(qname,0x3a,(uint)qname_len);
    if ((pcVar3 == (char *)0x0) || (cur_node == (lyd_node *)0x0)) {
      moveto_mod = (lys_module *)0x0;
      qname_len_local = qname_len;
      qname_local = qname;
    }
    else {
      pcVar3 = strnchr(qname,0x3a,(uint)qname_len);
      pref_len = (int)pcVar3 - (int)qname;
      moveto_mod = moveto_resolve_model
                             (qname,(uint16_t)pref_len,cur_node->schema->module->ctx,(lys_node *)0x0
                              ,1,0);
      if (moveto_mod == (lys_module *)0x0) {
        ly_vlog(cur_node->schema->module->ctx,LYE_XPATH_INMOD,LY_VLOG_NONE,(void *)0x0,
                (ulong)(uint)pref_len,qname);
        iVar2 = -1;
        goto LAB_001d702d;
      }
      qname_local = qname + (long)pref_len + 1;
      qname_len_local = (qname_len - (short)pref_len) - 1;
    }
    iVar2 = moveto_node(set,cur_node,"*",1,options);
    ret = iVar2;
    if (iVar2 == 0) {
      if ((qname_len_local == 1) && (*qname_local == '*')) {
        all = 1;
      }
      memset(&ret_set,0,0x40);
      for (i = 0; i < set->used; i = i + 1) {
        next = (set->val).nodes[i].node;
        start = next;
        while (elem = next, next != (lyd_node *)0x0) {
          if ((((options & 2U) != 0) && (((byte)next->field_0x9 >> 1 & 4) != 0)) &&
             (((byte)next->field_0x9 >> 1 & 3) == 0)) {
            iVar2 = 1;
            goto LAB_001d702d;
          }
          if (((char)next->validity < '\0') ||
             ((root_type == LYXP_NODE_ROOT_CONFIG && ((next->schema->flags & 2) != 0)))) {
LAB_001d6f69:
            if (elem == start) break;
            next = elem->next;
          }
          else {
            match = 1;
            if (all == 0) {
              if ((moveto_mod == (lys_module *)0x0) ||
                 (plVar4 = lys_node_module(next->schema), moveto_mod == plVar4)) {
                if (moveto_mod == (lys_module *)0x0) {
                  plVar4 = lys_node_module(elem->schema);
                  plVar5 = lyd_node_module(cur_node);
                  if (plVar4 != plVar5) {
                    match = 0;
                  }
                }
              }
              else {
                match = 0;
              }
            }
            if (((match != 0) && (all == 0)) &&
               ((iVar2 = strncmp(elem->schema->name,qname_local,(ulong)qname_len_local), iVar2 != 0
                || (elem->schema->name[qname_len_local] != '\0')))) {
              match = 0;
            }
            if (match != 0) {
              set_insert_node(&ret_set,elem,0,LYXP_NODE_ELEM,ret_set.used);
              iVar2 = set_dup_node_check(set,elem,LYXP_NODE_ELEM,i);
              if (iVar2 != 0) goto LAB_001d6f69;
            }
            if ((elem->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
              next = elem->child;
            }
            else {
              next = (lyd_node *)0x0;
            }
            if (next == (lyd_node *)0x0) goto LAB_001d6f69;
          }
          while ((next == (lyd_node *)0x0 && (start != elem->parent))) {
            elem = elem->parent;
            next = elem->next;
          }
        }
      }
      ret_set.ctx_pos = set->ctx_pos;
      ret_set.ctx_size = set->ctx_size;
      set_free_content(set);
      memcpy(set,&ret_set,0x40);
      iVar2 = 0;
    }
  }
  else {
    pcVar3 = print_set_type(set);
    ly_vlog(cur_node->schema->module->ctx,LYE_XPATH_INOP_1,LY_VLOG_NONE,(void *)0x0,"path operator",
            pcVar3);
    iVar2 = -1;
  }
LAB_001d702d:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int moveto_snode_alldesc
              (lyxp_set *set,lys_node *cur_node,char *qname,uint16_t qname_len,int options)

{
  LYS_NODE LVar1;
  int iVar2;
  char *pcVar3;
  lys_module *plVar4;
  lys_module *plVar5;
  lys_node *plVar6;
  long in_FS_OFFSET;
  int options_local;
  uint16_t qname_len_local;
  char *qname_local;
  lys_node *cur_node_local;
  lyxp_set *set_local;
  lyxp_node_type root_type;
  int i;
  int all;
  int match;
  int pref_len;
  int orig_used;
  int idx;
  lys_node *next;
  lys_node *elem;
  lys_module *moveto_mod;
  ly_ctx *ctx;
  lys_node *start;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  all = 0;
  if ((set == (lyxp_set *)0x0) || (set->type == LYXP_SET_EMPTY)) {
    iVar2 = 0;
  }
  else {
    ctx = cur_node->module->ctx;
    if (set->type == LYXP_SET_SNODE_SET) {
      moveto_snode_get_root(cur_node,options,&root_type);
      pcVar3 = strnchr(qname,0x3a,(uint)qname_len);
      if (pcVar3 == (char *)0x0) {
        moveto_mod = (lys_module *)0x0;
        qname_len_local = qname_len;
        qname_local = qname;
      }
      else {
        pcVar3 = strnchr(qname,0x3a,(uint)qname_len);
        pref_len = (int)pcVar3 - (int)qname;
        moveto_mod = moveto_resolve_model(qname,(uint16_t)pref_len,ctx,cur_node,1,1);
        if (moveto_mod == (lys_module *)0x0) {
          ly_vlog(ctx,LYE_XPATH_INMOD,LY_VLOG_NONE,(void *)0x0,(ulong)(uint)pref_len,qname);
          iVar2 = -1;
          goto LAB_001d74f4;
        }
        qname_local = qname + (long)pref_len + 1;
        qname_len_local = (qname_len - (short)pref_len) - 1;
      }
      if ((qname_len_local == 1) && (*qname_local == '*')) {
        all = 1;
      }
      orig_used = set->used;
      for (i = 0; i < orig_used; i = i + 1) {
        if ((set->val).nodes[i].pos == 1) {
          (set->val).nodes[i].pos = 0;
          next = (lys_node *)(set->val).nodes[i].node;
          start = next;
          while (elem = next, next != (lys_node *)0x0) {
            if ((root_type == LYXP_NODE_ROOT_CONFIG) && ((next->flags & 2) != 0)) {
LAB_001d7476:
              if (elem == start) break;
              next = elem->next;
            }
            else {
              LVar1 = next->nodetype;
              if (LVar1 != LYS_USES) {
                if (LVar1 < (LYS_CONTAINER|LYS_USES)) {
                  if (LVar1 == LYS_GROUPING) goto LAB_001d7476;
                  if (LVar1 < (LYS_CONTAINER|LYS_GROUPING)) {
                    if (LVar1 == LYS_OUTPUT) {
joined_r0x001d730c:
                      if ((options & 0x20U) == 0) goto LAB_001d7476;
                      goto LAB_001d7445;
                    }
                    if (LVar1 < (LYS_CONTAINER|LYS_OUTPUT)) {
                      if (LVar1 == LYS_INPUT) goto joined_r0x001d730c;
                      if ((LVar1 < (LYS_CONTAINER|LYS_INPUT)) &&
                         ((LVar1 == LYS_CHOICE || (LVar1 == LYS_CASE)))) goto LAB_001d7445;
                    }
                  }
                }
                match = (int)(next != start);
                if ((match != 0) && (all == 0)) {
                  if ((moveto_mod == (lys_module *)0x0) ||
                     (plVar4 = lys_node_module(next), moveto_mod == plVar4)) {
                    if (moveto_mod == (lys_module *)0x0) {
                      plVar4 = lys_node_module(elem);
                      plVar5 = lys_node_module(cur_node);
                      if (plVar4 != plVar5) {
                        match = 0;
                      }
                    }
                  }
                  else {
                    match = 0;
                  }
                }
                if (((match != 0) && (all == 0)) &&
                   ((iVar2 = strncmp(elem->name,qname_local,(ulong)qname_len_local), iVar2 != 0 ||
                    (elem->name[qname_len_local] != '\0')))) {
                  match = 0;
                }
                if (match != 0) {
                  idx = set_snode_dup_node_check(set,elem,LYXP_NODE_ELEM,i);
                  if (idx < 0) {
                    set_snode_insert_node(set,elem,LYXP_NODE_ELEM);
                  }
                  else {
                    (set->val).nodes[idx].pos = 1;
                    if (i < idx) goto LAB_001d7476;
                  }
                }
              }
LAB_001d7445:
              next = elem->child;
              if ((elem->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) != LYS_UNKNOWN) {
                next = (lys_node *)0x0;
              }
              if (next == (lys_node *)0x0) goto LAB_001d7476;
            }
            while ((next == (lys_node *)0x0 && (plVar6 = lys_parent(elem), start != plVar6))) {
              elem = lys_parent(elem);
              next = elem->next;
            }
          }
        }
      }
      iVar2 = 0;
    }
    else {
      pcVar3 = print_set_type(set);
      ly_vlog(ctx,LYE_XPATH_INOP_1,LY_VLOG_NONE,(void *)0x0,"path operator",pcVar3);
      iVar2 = -1;
    }
  }
LAB_001d74f4:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



// WARNING: Variable defined which should be unmapped: UNUSED_options_local

int moveto_attr(lyxp_set *set,lyd_node *cur_node,char *qname,uint16_t qname_len,int UNUSED_options)

{
  bool bVar1;
  bool bVar2;
  uint uVar3;
  int iVar4;
  char *pcVar5;
  int UNUSED_options_local;
  uint16_t qname_len_local;
  char *qname_local;
  lyd_node *cur_node_local;
  lyxp_set *set_local;
  uint32_t i;
  int replaced;
  int all;
  int pref_len;
  lys_module *moveto_mod;
  lyd_attr *sub;
  
  bVar1 = false;
  if ((set == (lyxp_set *)0x0) || (set->type == LYXP_SET_EMPTY)) {
    iVar4 = 0;
  }
  else if (set->type == LYXP_SET_NODE_SET) {
    pcVar5 = strnchr(qname,0x3a,(uint)qname_len);
    if ((pcVar5 == (char *)0x0) || (cur_node == (lyd_node *)0x0)) {
      moveto_mod = (lys_module *)0x0;
      qname_len_local = qname_len;
      qname_local = qname;
    }
    else {
      pcVar5 = strnchr(qname,0x3a,(uint)qname_len);
      uVar3 = (int)pcVar5 - (int)qname;
      moveto_mod = moveto_resolve_model
                             (qname,(uint16_t)uVar3,cur_node->schema->module->ctx,(lys_node *)0x0,1,
                              0);
      if (moveto_mod == (lys_module *)0x0) {
        ly_vlog(cur_node->schema->module->ctx,LYE_XPATH_INMOD,LY_VLOG_NONE,(void *)0x0,(ulong)uVar3,
                qname,UNUSED_options);
        return -1;
      }
      qname_local = qname + (long)(int)uVar3 + 1;
      qname_len_local = (qname_len - (uint16_t)uVar3) - 1;
    }
    if ((qname_len_local == 1) && (*qname_local == '*')) {
      bVar1 = true;
    }
    i = 0;
    while (i < set->used) {
      bVar2 = false;
      if (((set->val).nodes[i].type == LYXP_NODE_ELEM) &&
         (-1 < (char)((set->val).nodes[i].node)->validity)) {
        for (sub = ((set->val).nodes[i].node)->attr; sub != (lyd_attr *)0x0; sub = sub->next) {
          if (((moveto_mod == (lys_module *)0x0) || (moveto_mod == sub->annotation->module)) &&
             ((bVar1 || ((iVar4 = strncmp(sub->name,qname_local,(ulong)qname_len_local), iVar4 == 0
                         && (sub->name[qname_len_local] == '\0')))))) {
            if (bVar2) {
              set_insert_node(set,(lyd_node *)sub,(set->val).nodes[i].pos,LYXP_NODE_ATTR,i + 1);
            }
            else {
              (set->val).nodes[i].node = (lyd_node *)sub;
              (set->val).nodes[i].type = LYXP_NODE_ATTR;
              bVar2 = true;
            }
            i = i + 1;
          }
        }
      }
      if (!bVar2) {
        set_remove_node(set,i);
      }
    }
    iVar4 = 0;
  }
  else {
    pcVar5 = print_set_type(set);
    ly_vlog(cur_node->schema->module->ctx,LYE_XPATH_INOP_1,LY_VLOG_NONE,(void *)0x0,"path operator",
            pcVar5,UNUSED_options);
    iVar4 = -1;
  }
  return iVar4;
}



int moveto_union(lyxp_set *set1,lyxp_set *set2,lyd_node *cur_node,int options)

{
  int iVar1;
  ly_ctx *ctx_00;
  char *pcVar2;
  char *pcVar3;
  int options_local;
  lyd_node *cur_node_local;
  lyxp_set *set2_local;
  lyxp_set *set1_local;
  ly_ctx *ctx;
  
  if ((options & 4U) == 0) {
    ctx_00 = cur_node->schema->module->ctx;
  }
  else {
    ctx_00 = (ly_ctx *)**(undefined8 **)&cur_node->hash;
  }
  if (((set1->type == LYXP_SET_NODE_SET) || (set1->type == LYXP_SET_EMPTY)) &&
     ((set2->type == LYXP_SET_NODE_SET || (set2->type == LYXP_SET_EMPTY)))) {
    if (set2->type == LYXP_SET_EMPTY) {
      iVar1 = 0;
    }
    else {
      if (set1->type != LYXP_SET_EMPTY) {
        iVar1 = set_sort(set1,cur_node,options);
        if ((iVar1 != 0) || (iVar1 = set_sort(set2,cur_node,options), iVar1 != 0)) {
                    // WARNING: Subroutine does not return
          __assert_fail("!set_sort(set1, cur_node, options) && !set_sort(set2, cur_node, options)",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                        ,0x182a,"moveto_union");
        }
        iVar1 = set_sorted_merge(set1,set2,cur_node,options);
        if (iVar1 != 0) {
          return -1;
        }
        iVar1 = set_sort(set1,cur_node,options);
        if (iVar1 == 0) {
          return 0;
        }
                    // WARNING: Subroutine does not return
        __assert_fail("!set_sort(set1, cur_node, options)",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x1832,"moveto_union");
      }
      memcpy(set1,set2,0x40);
      set2->type = LYXP_SET_EMPTY;
      iVar1 = 0;
    }
  }
  else {
    pcVar2 = print_set_type(set2);
    pcVar3 = print_set_type(set1);
    ly_vlog(ctx_00,LYE_XPATH_INOP_2,LY_VLOG_NONE,(void *)0x0,"union",pcVar3,pcVar2);
    iVar1 = -1;
  }
  return iVar1;
}



int moveto_attr_alldesc(lyxp_set *set,lyd_node *cur_node,char *qname,uint16_t qname_len,int options)

{
  bool bVar1;
  bool bVar2;
  uint uVar3;
  int iVar4;
  char *pcVar5;
  lyxp_set *set_00;
  int options_local;
  uint16_t qname_len_local;
  char *qname_local;
  lyd_node *cur_node_local;
  lyxp_set *set_local;
  uint32_t i;
  int replaced;
  int all;
  int pref_len;
  int ret;
  lyd_attr *sub;
  lys_module *moveto_mod;
  lyxp_set *set_all_desc;
  
  bVar1 = false;
  if ((set == (lyxp_set *)0x0) || (set->type == LYXP_SET_EMPTY)) {
    iVar4 = 0;
  }
  else if (set->type == LYXP_SET_NODE_SET) {
    pcVar5 = strnchr(qname,0x3a,(uint)qname_len);
    if (pcVar5 == (char *)0x0) {
      moveto_mod = (lys_module *)0x0;
      qname_len_local = qname_len;
      qname_local = qname;
    }
    else {
      pcVar5 = strnchr(qname,0x3a,(uint)qname_len);
      uVar3 = (int)pcVar5 - (int)qname;
      moveto_mod = moveto_resolve_model
                             (qname,(uint16_t)uVar3,cur_node->schema->module->ctx,(lys_node *)0x0,1,
                              0);
      if (moveto_mod == (lys_module *)0x0) {
        ly_vlog(cur_node->schema->module->ctx,LYE_XPATH_INMOD,LY_VLOG_NONE,(void *)0x0,(ulong)uVar3,
                qname);
        return -1;
      }
      qname_local = qname + (long)(int)uVar3 + 1;
      qname_len_local = (qname_len - (uint16_t)uVar3) - 1;
    }
    set_00 = set_copy(set);
    iVar4 = moveto_node_alldesc(set_00,cur_node,"*",1,options);
    if (iVar4 == 0) {
      iVar4 = moveto_union(set,set_00,cur_node,options);
      if (iVar4 == 0) {
        lyxp_set_free(set_00);
        if ((qname_len_local == 1) && (*qname_local == '*')) {
          bVar1 = true;
        }
        i = 0;
        while (i < set->used) {
          bVar2 = false;
          if ((set->val).nodes[i].type == LYXP_NODE_ELEM) {
            for (sub = ((set->val).nodes[i].node)->attr; sub != (lyd_attr *)0x0; sub = sub->next) {
              if (((moveto_mod == (lys_module *)0x0) || (moveto_mod == sub->annotation->module)) &&
                 ((bVar1 || ((iVar4 = strncmp(sub->name,qname_local,(ulong)qname_len_local),
                             iVar4 == 0 && (sub->name[qname_len_local] == '\0')))))) {
                if (bVar2) {
                  set_insert_node(set,(lyd_node *)sub,(set->val).nodes[i].pos,LYXP_NODE_ATTR,i + 1);
                }
                else {
                  (set->val).nodes[i].node = (lyd_node *)sub;
                  (set->val).nodes[i].type = LYXP_NODE_ATTR;
                  bVar2 = true;
                }
                i = i + 1;
              }
            }
          }
          if (!bVar2) {
            set_remove_node(set,i);
          }
        }
        iVar4 = 0;
      }
      else {
        lyxp_set_free(set_00);
        iVar4 = -1;
      }
    }
    else {
      lyxp_set_free(set_00);
    }
  }
  else {
    pcVar5 = print_set_type(set);
    ly_vlog(cur_node->schema->module->ctx,LYE_XPATH_INOP_1,LY_VLOG_NONE,(void *)0x0,"path operator",
            pcVar5);
    iVar4 = -1;
  }
  return iVar4;
}



int moveto_self_add_children_r
              (lyd_node *parent,uint32_t parent_pos,lyxp_node_type parent_type,lyxp_set *to_set,
              lyxp_set *dup_check_set,lyxp_node_type root_type,int options)

{
  int iVar1;
  lys_module *plVar2;
  lyxp_node_type root_type_local;
  lyxp_set *dup_check_set_local;
  lyxp_set *to_set_local;
  lyxp_node_type parent_type_local;
  uint32_t parent_pos_local;
  lyd_node *parent_local;
  int ret;
  lyd_node *sub;
  
  if (parent_type < LYXP_NODE_ELEM) {
    iVar1 = set_dup_node_check(dup_check_set,parent,LYXP_NODE_ELEM,-1);
    if ((((iVar1 == 0) &&
         (set_insert_node(to_set,parent,0,LYXP_NODE_ELEM,to_set->used),
         (parent->schema->nodetype & LYS_ANYDATA) == LYS_UNKNOWN)) && (-1 < (char)parent->validity))
       && (iVar1 = moveto_self_add_children_r
                             (parent,0,LYXP_NODE_ELEM,to_set,dup_check_set,root_type,options),
          iVar1 != 0)) {
      return iVar1;
    }
  }
  else {
    if (parent_type != LYXP_NODE_ELEM) {
      plVar2 = lyd_node_module(parent);
      ly_log(plVar2->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
             ,0x18e1);
      return -1;
    }
    if ((parent->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) == LYS_UNKNOWN) {
      for (sub = parent->child; sub != (lyd_node *)0x0; sub = sub->next) {
        if ((root_type != LYXP_NODE_ROOT_CONFIG) || ((sub->schema->flags & 2) == 0)) {
          if (((options & 2U) != 0) &&
             ((((byte)sub->field_0x9 >> 1 & 4) != 0 && (((byte)sub->field_0x9 >> 1 & 3) == 0)))) {
            return 1;
          }
          iVar1 = set_dup_node_check(dup_check_set,sub,LYXP_NODE_ELEM,-1);
          if ((((iVar1 == 0) &&
               (set_insert_node(to_set,sub,0,LYXP_NODE_ELEM,to_set->used),
               (sub->schema->nodetype & LYS_ANYDATA) == LYS_UNKNOWN)) && (-1 < (char)sub->validity))
             && (iVar1 = moveto_self_add_children_r
                                   (sub,0,LYXP_NODE_ELEM,to_set,dup_check_set,root_type,options),
                iVar1 != 0)) {
            return iVar1;
          }
        }
      }
    }
    else if ((parent->ht != (hash_table *)0x0) &&
            (iVar1 = set_dup_node_check(dup_check_set,parent,LYXP_NODE_TEXT,-1), iVar1 == 0)) {
      set_insert_node(to_set,parent,parent_pos,LYXP_NODE_TEXT,to_set->used);
    }
  }
  return 0;
}



int moveto_self(lyxp_set *set,lyd_node *cur_node,int all_desc,int options)

{
  long lVar1;
  int iVar2;
  char *pcVar3;
  long in_FS_OFFSET;
  int options_local;
  int all_desc_local;
  lyd_node *cur_node_local;
  lyxp_set *set_local;
  lyxp_node_type root_type;
  uint32_t i;
  int ret;
  lyxp_set ret_set;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if ((set == (lyxp_set *)0x0) || (set->type == LYXP_SET_EMPTY)) {
    iVar2 = 0;
  }
  else if (set->type == LYXP_SET_NODE_SET) {
    if (all_desc == 0) {
      iVar2 = 0;
    }
    else {
      moveto_get_root(cur_node,options,&root_type);
      memset(&ret_set,0,0x40);
      for (i = 0; i < set->used; i = i + 1) {
        set_insert_node(&ret_set,(set->val).nodes[i].node,(set->val).nodes[i].pos,
                        (set->val).nodes[i].type,ret_set.used);
        if (((((set->val).nodes[i].type != LYXP_NODE_TEXT) &&
             ((set->val).nodes[i].type != LYXP_NODE_ATTR)) &&
            ((((set->val).nodes[i].node)->schema->nodetype & LYS_ANYDATA) == LYS_UNKNOWN)) &&
           ((-1 < (char)((set->val).nodes[i].node)->validity &&
            (ret = moveto_self_add_children_r
                             ((set->val).nodes[i].node,(set->val).nodes[i].pos,
                              (set->val).nodes[i].type,&ret_set,set,root_type,options), ret != 0))))
        {
          set_free_content(&ret_set);
          iVar2 = ret;
          goto LAB_001d8308;
        }
      }
      ret_set.ctx_pos = set->ctx_pos;
      ret_set.ctx_size = set->ctx_size;
      set_free_content(set);
      memcpy(set,&ret_set,0x40);
      iVar2 = 0;
    }
  }
  else {
    pcVar3 = print_set_type(set);
    ly_vlog(cur_node->schema->module->ctx,LYE_XPATH_INOP_1,LY_VLOG_NONE,(void *)0x0,"path operator",
            pcVar3);
    iVar2 = -1;
  }
LAB_001d8308:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int moveto_snode_self(lyxp_set *set,lys_node *cur_node,int all_desc,int options)

{
  int iVar1;
  char *pcVar2;
  lys_node *plVar3;
  long in_FS_OFFSET;
  int options_local;
  int all_desc_local;
  lys_node *cur_node_local;
  lyxp_set *set_local;
  lyxp_node_type root_type;
  uint32_t i;
  lys_node *sub;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((set == (lyxp_set *)0x0) || (set->type == LYXP_SET_EMPTY)) {
    iVar1 = 0;
  }
  else if (set->type == LYXP_SET_SNODE_SET) {
    if (all_desc == 0) {
      iVar1 = 0;
    }
    else {
      moveto_snode_get_root(cur_node,options,&root_type);
      for (i = 0; i < set->used; i = i + 1) {
        if (((set->val).nodes[i].pos == 1) &&
           ((*(uint *)&((set->val).nodes[i].node)->ht & 0x11) != 0)) {
          sub = (lys_node *)0x0;
LAB_001d84a1:
          while (sub = lys_getnext(sub,(lys_node *)(set->val).nodes[i].node,(lys_module *)0x0,0x100)
                , sub != (lys_node *)0x0) {
            if ((options & 0x20U) == 0) goto LAB_001d8455;
            plVar3 = lys_parent(sub);
            if (plVar3->nodetype != LYS_INPUT) goto LAB_001d846d;
          }
          sub = (lys_node *)0x0;
        }
      }
      iVar1 = 0;
    }
  }
  else {
    pcVar2 = print_set_type(set);
    ly_vlog(cur_node->module->ctx,LYE_XPATH_INOP_1,LY_VLOG_NONE,(void *)0x0,"path operator",pcVar2);
    iVar1 = -1;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_001d8455:
  plVar3 = lys_parent(sub);
  if (plVar3->nodetype != LYS_OUTPUT) {
LAB_001d846d:
    if ((root_type != LYXP_NODE_ROOT_CONFIG) || ((sub->flags & 2) == 0)) {
      set_snode_insert_node(set,sub,LYXP_NODE_ELEM);
    }
  }
  goto LAB_001d84a1;
}



int moveto_parent(lyxp_set *set,lyd_node *cur_node,int all_desc,int options)

{
  lyd_node *plVar1;
  int iVar2;
  char *pcVar3;
  long in_FS_OFFSET;
  int options_local;
  int all_desc_local;
  lyd_node *cur_node_local;
  lyxp_set *set_local;
  lyxp_node_type root_type;
  uint32_t i;
  lyxp_node_type new_type;
  int ret;
  lyd_node *node;
  lyd_node *new_node;
  ly_ctx *ctx;
  lyd_node *root;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ctx = cur_node->schema->module->ctx;
  if ((set == (lyxp_set *)0x0) || (set->type == LYXP_SET_EMPTY)) {
    iVar2 = 0;
  }
  else if (set->type == LYXP_SET_NODE_SET) {
    if ((all_desc == 0) || (iVar2 = moveto_self(set,cur_node,1,options), ret = iVar2, iVar2 == 0)) {
      root = moveto_get_root(cur_node,options,&root_type);
      i = 0;
      while (i < set->used) {
        node = (set->val).nodes[i].node;
        if ((set->val).nodes[i].type == LYXP_NODE_ELEM) {
          plVar1 = node->parent;
LAB_001d870a:
          new_node = plVar1;
          if (((((options & 2U) != 0) && (new_node != (lyd_node *)0x0)) &&
              (((byte)new_node->field_0x9 >> 1 & 4) != 0)) &&
             (((byte)new_node->field_0x9 >> 1 & 3) == 0)) {
            iVar2 = 1;
            goto LAB_001d891c;
          }
          if (root == node) {
            if ((options == 0) || ((cur_node->schema->flags & 1) == 0)) {
              new_type = LYXP_NODE_ROOT;
            }
            else {
              new_type = LYXP_NODE_ROOT_CONFIG;
            }
            new_node = node;
          }
          else if (new_node == (lyd_node *)0x0) {
            if ((options == 0) || ((cur_node->schema->flags & 1) == 0)) {
              new_type = LYXP_NODE_ROOT;
            }
            else {
              new_type = LYXP_NODE_ROOT_CONFIG;
            }
            while (node->prev->next != (lyd_node *)0x0) {
              node = node->prev;
            }
            if (node != root) {
              ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                     "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                     ,0x19ba);
            }
            new_node = root;
          }
          else {
            new_type = LYXP_NODE_ELEM;
          }
          if ((new_type != LYXP_NODE_ELEM) && ((new_type != root_type || (new_node != root)))) {
                    // WARNING: Subroutine does not return
            __assert_fail("(new_type == LYXP_NODE_ELEM) || ((new_type == root_type) && (new_node == root))"
                          ,
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                          ,0x19c4,"moveto_parent");
          }
          iVar2 = set_dup_node_check(set,new_node,new_type,-1);
          if (iVar2 == 0) {
            set_replace_node(set,new_node,0,new_type,i);
            i = i + 1;
          }
          else {
            set_remove_node(set,i);
          }
        }
        else {
          plVar1 = node;
          if ((set->val).nodes[i].type == LYXP_NODE_TEXT) goto LAB_001d870a;
          if ((set->val).nodes[i].type == LYXP_NODE_ATTR) {
            new_node = lyd_attr_parent(root,(lyd_attr *)(set->val).nodes[i].node);
            plVar1 = new_node;
            if (new_node != (lyd_node *)0x0) goto LAB_001d870a;
            ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                   "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                   ,0x1999);
            iVar2 = -1;
            goto LAB_001d891c;
          }
          set_remove_node(set,i);
        }
      }
      iVar2 = set_sort(set,cur_node,options);
      if ((iVar2 != 0) || (iVar2 = set_sorted_dup_node_clean(set), iVar2 != 0)) {
                    // WARNING: Subroutine does not return
        __assert_fail("!set_sort(set, cur_node, options) && !set_sorted_dup_node_clean(set)",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x19ce,"moveto_parent");
      }
      iVar2 = 0;
    }
  }
  else {
    pcVar3 = print_set_type(set);
    ly_vlog(ctx,LYE_XPATH_INOP_1,LY_VLOG_NONE,(void *)0x0,"path operator",pcVar3);
    iVar2 = -1;
  }
LAB_001d891c:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int moveto_snode_parent(lyxp_set *set,lys_node *cur_node,int all_desc,int options)

{
  int iVar1;
  char *pcVar2;
  lys_module *module;
  long in_FS_OFFSET;
  int options_local;
  int all_desc_local;
  lys_node *cur_node_local;
  lyxp_set *set_local;
  lyxp_node_type root_type;
  int i;
  int temp_ctx;
  lyxp_node_type new_type;
  int idx;
  int orig_used;
  lys_node *new_node;
  lys_node *root;
  lys_node *node;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  temp_ctx = 0;
  if ((set == (lyxp_set *)0x0) || (set->type == LYXP_SET_EMPTY)) {
    iVar1 = 0;
  }
  else if (set->type == LYXP_SET_SNODE_SET) {
    if ((all_desc == 0) ||
       (iVar1 = moveto_snode_self(set,cur_node,1,options), idx = iVar1, iVar1 == 0)) {
      root = moveto_snode_get_root(cur_node,options,&root_type);
      orig_used = set->used;
      for (i = 0; i < orig_used; i = i + 1) {
        if ((set->val).nodes[i].pos == 1) {
          (set->val).nodes[i].pos = 0;
          node = (lys_node *)(set->val).nodes[i].node;
          if ((set->val).nodes[i].type == LYXP_NODE_ELEM) {
            for (new_node = lys_parent(node);
                (new_node != (lys_node *)0x0 && ((new_node->nodetype & 0x1642) != LYS_UNKNOWN));
                new_node = lys_parent(new_node)) {
            }
            if (root == node) {
              if (((options & 0x18U) == 0) || ((cur_node->flags & 1) == 0)) {
                new_type = LYXP_NODE_ROOT;
              }
              else {
                new_type = LYXP_NODE_ROOT_CONFIG;
              }
              new_node = node;
            }
            else if (new_node == (lys_node *)0x0) {
              if (((options & 0x18U) == 0) || ((cur_node->flags & 1) == 0)) {
                new_type = LYXP_NODE_ROOT;
              }
              else {
                new_type = LYXP_NODE_ROOT_CONFIG;
              }
              module = lys_node_module(node);
              node = lys_getnext((lys_node *)0x0,(lys_node *)0x0,module,0x100);
              if (node != root) {
                ly_log(cur_node->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                       "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                       ,0x1a13);
              }
              new_node = root;
            }
            else {
              new_type = LYXP_NODE_ELEM;
            }
            if ((new_type != LYXP_NODE_ELEM) && ((new_type != root_type || (new_node != root)))) {
                    // WARNING: Subroutine does not return
              __assert_fail("(new_type == LYXP_NODE_ELEM) || ((new_type == root_type) && (new_node == root))"
                            ,
                            "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                            ,0x1a1d,"moveto_snode_parent");
            }
            idx = set_snode_insert_node(set,new_node,new_type);
            if ((idx < orig_used) && (i < idx)) {
              (set->val).nodes[idx].pos = 2;
              temp_ctx = 1;
            }
          }
        }
      }
      if (temp_ctx != 0) {
        for (i = 0; i < orig_used; i = i + 1) {
          if ((set->val).nodes[i].pos == 2) {
            (set->val).nodes[i].pos = 1;
          }
        }
      }
      iVar1 = 0;
    }
  }
  else {
    pcVar2 = print_set_type(set);
    ly_vlog(cur_node->module->ctx,LYE_XPATH_INOP_1,LY_VLOG_NONE,(void *)0x0,"path operator",pcVar2);
    iVar1 = -1;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int moveto_op_comp(lyxp_set *set1,lyxp_set *set2,char *op,lyd_node *cur_node,lys_module *param_5,
                  int options)

{
  long lVar1;
  int iVar2;
  uint32_t uVar3;
  long in_FS_OFFSET;
  int options_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  char *op_local;
  lyxp_set *set2_local;
  lyxp_set *set1_local;
  int result;
  int64_t i;
  lyxp_set iter1;
  lyxp_set iter2;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iter1.type = LYXP_SET_EMPTY;
  if ((set1->type == LYXP_SET_EMPTY) || (set2->type == LYXP_SET_EMPTY)) {
    set_fill_boolean(set1,0);
    iVar2 = 0;
    goto LAB_001d96be;
  }
  if ((set1->type == LYXP_SET_NODE_SET) || (set2->type == LYXP_SET_NODE_SET)) {
    if (set1->type == LYXP_SET_NODE_SET) {
      if ((set2->type != LYXP_SET_NODE_SET) && (iVar2 = set_canonize(set2,set1), iVar2 != 0)) {
        iVar2 = -1;
        goto LAB_001d96be;
      }
      for (i = 0; i < (long)(ulong)set1->used; i = i + 1) {
        uVar3 = (uint32_t)i;
        if (set2->type == LYXP_SET_BOOLEAN) {
          iVar2 = set_comp_cast(&iter1,set1,LYXP_SET_BOOLEAN,cur_node,param_5,uVar3,options);
          if (iVar2 != 0) {
            iVar2 = -1;
            goto LAB_001d96be;
          }
        }
        else if (set2->type == LYXP_SET_NUMBER) {
          iVar2 = set_comp_cast(&iter1,set1,LYXP_SET_NUMBER,cur_node,param_5,uVar3,options);
          if (iVar2 != 0) {
            iVar2 = -1;
            goto LAB_001d96be;
          }
        }
        else {
          iVar2 = set_comp_cast(&iter1,set1,LYXP_SET_STRING,cur_node,param_5,uVar3,options);
          if (iVar2 != 0) {
            iVar2 = -1;
            goto LAB_001d96be;
          }
        }
        iVar2 = moveto_op_comp(&iter1,set2,op,cur_node,param_5,options);
        if (iVar2 != 0) {
          set_free_content(&iter1);
          iVar2 = -1;
          goto LAB_001d96be;
        }
        if (iter1.val.bool != 0) {
          set_fill_boolean(set1,1);
          iVar2 = 0;
          goto LAB_001d96be;
        }
      }
    }
    else {
      iVar2 = set_canonize(set1,set2);
      if (iVar2 != 0) {
        iVar2 = -1;
        goto LAB_001d96be;
      }
      for (i = 0; i < (long)(ulong)set2->used; i = i + 1) {
        uVar3 = (uint32_t)i;
        if (set1->type == LYXP_SET_BOOLEAN) {
          iVar2 = set_comp_cast(&iter2,set2,LYXP_SET_BOOLEAN,cur_node,param_5,uVar3,options);
          if (iVar2 != 0) {
            iVar2 = -1;
            goto LAB_001d96be;
          }
        }
        else if (set1->type == LYXP_SET_NUMBER) {
          iVar2 = set_comp_cast(&iter2,set2,LYXP_SET_NUMBER,cur_node,param_5,uVar3,options);
          if (iVar2 != 0) {
            iVar2 = -1;
            goto LAB_001d96be;
          }
        }
        else {
          iVar2 = set_comp_cast(&iter2,set2,LYXP_SET_STRING,cur_node,param_5,uVar3,options);
          if (iVar2 != 0) {
            iVar2 = -1;
            goto LAB_001d96be;
          }
        }
        set_fill_set(&iter1,set1);
        iVar2 = moveto_op_comp(&iter1,&iter2,op,cur_node,param_5,options);
        if (iVar2 != 0) {
          set_free_content(&iter1);
          set_free_content(&iter2);
          iVar2 = -1;
          goto LAB_001d96be;
        }
        set_free_content(&iter2);
        if (iter1.val.bool != 0) {
          set_fill_boolean(set1,1);
          iVar2 = 0;
          goto LAB_001d96be;
        }
      }
    }
    set_fill_boolean(set1,0);
    iVar2 = 0;
    goto LAB_001d96be;
  }
  if ((*op == '=') || (*op == '!')) {
    if ((set1->type == LYXP_SET_BOOLEAN) || (set2->type == LYXP_SET_BOOLEAN)) {
      lyxp_set_cast(set1,LYXP_SET_BOOLEAN,cur_node,param_5,options);
      lyxp_set_cast(set2,LYXP_SET_BOOLEAN,cur_node,param_5,options);
    }
    else if ((set1->type == LYXP_SET_NUMBER) || (set2->type == LYXP_SET_NUMBER)) {
      iVar2 = lyxp_set_cast(set1,LYXP_SET_NUMBER,cur_node,param_5,options);
      if (iVar2 != 0) {
        iVar2 = -1;
        goto LAB_001d96be;
      }
      iVar2 = lyxp_set_cast(set2,LYXP_SET_NUMBER,cur_node,param_5,options);
      if (iVar2 != 0) {
        iVar2 = -1;
        goto LAB_001d96be;
      }
    }
  }
  else {
    iVar2 = lyxp_set_cast(set1,LYXP_SET_NUMBER,cur_node,param_5,options);
    if (iVar2 != 0) {
      iVar2 = -1;
      goto LAB_001d96be;
    }
    iVar2 = lyxp_set_cast(set2,LYXP_SET_NUMBER,cur_node,param_5,options);
    if (iVar2 != 0) {
      iVar2 = -1;
      goto LAB_001d96be;
    }
  }
  if (set1->type != set2->type) {
                    // WARNING: Subroutine does not return
    __assert_fail("set1->type == set2->type",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x1ad6,"moveto_op_comp");
  }
  if (*op == '=') {
    if (set1->type == LYXP_SET_BOOLEAN) {
      result = (int)((set1->val).bool == (set2->val).bool);
    }
    else if (set1->type == LYXP_SET_NUMBER) {
      result = (int)((set2->val).num == (set1->val).num);
    }
    else {
      if (set1->type != LYXP_SET_STRING) {
                    // WARNING: Subroutine does not return
        __assert_fail("set1->type == LYXP_SET_STRING",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x1adf,"moveto_op_comp");
      }
      result = ly_strequal_((set1->val).str,(set2->val).str);
    }
  }
  else if (*op == '!') {
    if (set1->type == LYXP_SET_BOOLEAN) {
      result = (int)((set1->val).bool != (set2->val).bool);
    }
    else if (set1->type == LYXP_SET_NUMBER) {
      result = (int)((set2->val).num != (set1->val).num);
    }
    else {
      if (set1->type != LYXP_SET_STRING) {
                    // WARNING: Subroutine does not return
        __assert_fail("set1->type == LYXP_SET_STRING",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x1ae8,"moveto_op_comp");
      }
      iVar2 = ly_strequal_((set1->val).str,(set2->val).str);
      result = (int)(iVar2 == 0);
    }
  }
  else {
    if (set1->type != LYXP_SET_NUMBER) {
                    // WARNING: Subroutine does not return
      __assert_fail("set1->type == LYXP_SET_NUMBER",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x1aec,"moveto_op_comp");
    }
    if (*op == '<') {
      if (op[1] == '=') {
        result = (int)((set1->val).num <= (set2->val).num);
      }
      else {
        result = (int)((set1->val).num < (set2->val).num);
      }
    }
    else if (op[1] == '=') {
      result = (int)((set2->val).num <= (set1->val).num);
    }
    else {
      result = (int)((set2->val).num < (set1->val).num);
    }
  }
  if (result == 0) {
    set_fill_boolean(set1,0);
  }
  else {
    set_fill_boolean(set1,1);
  }
  iVar2 = 0;
LAB_001d96be:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int moveto_op_math(lyxp_set *set1,lyxp_set *set2,char *op,lyd_node *cur_node,lys_module *param_5,
                  int options)

{
  char cVar1;
  int iVar2;
  ly_ctx *ctx;
  int options_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  char *op_local;
  lyxp_set *set2_local;
  lyxp_set *set1_local;
  
  if ((set2 == (lyxp_set *)0x0) && (*op == '-')) {
    iVar2 = lyxp_set_cast(set1,LYXP_SET_NUMBER,cur_node,param_5,options);
    if (iVar2 != 0) {
      return -1;
    }
    (set1->val).num = -(set1->val).num;
    lyxp_set_free((lyxp_set *)0x0);
    return 0;
  }
  if ((set1 == (lyxp_set *)0x0) || (set2 == (lyxp_set *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("set1 && set2",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x1b1f,"moveto_op_math");
  }
  iVar2 = lyxp_set_cast(set1,LYXP_SET_NUMBER,cur_node,param_5,options);
  if (iVar2 != 0) {
    return -1;
  }
  iVar2 = lyxp_set_cast(set2,LYXP_SET_NUMBER,cur_node,param_5,options);
  if (iVar2 != 0) {
    return -1;
  }
  cVar1 = *op;
  if (cVar1 == 'm') {
    (set1->val).num = (longdouble)((long)ROUND((set1->val).num) % (long)ROUND((set2->val).num));
  }
  else {
    if ('m' < cVar1) {
LAB_001d98e5:
      if (param_5 == (lys_module *)0x0) {
        ctx = (ly_ctx *)0x0;
      }
      else {
        ctx = param_5->ctx;
      }
      ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
             ,0x1b43);
      return -1;
    }
    if (cVar1 == 'd') {
      (set1->val).num = (set1->val).num / (set2->val).num;
    }
    else {
      if ('d' < cVar1) goto LAB_001d98e5;
      if (cVar1 == '-') {
        (set1->val).num = (set1->val).num - (set2->val).num;
      }
      else {
        if ('-' < cVar1) goto LAB_001d98e5;
        if (cVar1 == '*') {
          (set1->val).num = (set2->val).num * (set1->val).num;
        }
        else {
          if (cVar1 != '+') goto LAB_001d98e5;
          (set1->val).num = (set2->val).num + (set1->val).num;
        }
      }
    }
  }
  return 0;
}



void eval_literal(lyxp_expr *exp,uint16_t *exp_idx,lyxp_set *set)

{
  ushort uVar1;
  char *pcVar2;
  char *pcVar3;
  lyxp_set *set_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  
  if (set != (lyxp_set *)0x0) {
    if (exp->tok_len[*exp_idx] == 2) {
      set_fill_string(set,"",0);
    }
    else {
      set_fill_string(set,exp->expr + (ulong)exp->expr_pos[*exp_idx] + 1,exp->tok_len[*exp_idx] - 2)
      ;
    }
  }
  uVar1 = exp->expr_pos[*exp_idx];
  pcVar2 = print_token(exp->tokens[*exp_idx]);
  if (set == (lyxp_set *)0x0) {
    pcVar3 = "skipped";
  }
  else {
    pcVar3 = "parsed";
  }
  ly_log_dbg(8,"%-27s %s %s[%u]","eval_literal",pcVar3,pcVar2,(ulong)uVar1);
  *exp_idx = *exp_idx + 1;
  return;
}



int eval_node_test(lyxp_expr *exp,uint16_t *exp_idx,lyd_node *cur_node,lys_module *param_4,
                  int attr_axis,int all_desc,lyxp_set *set,int options)

{
  ushort uVar1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  ly_ctx *ctx;
  int all_desc_local;
  int attr_axis_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  int i;
  int rc;
  char *path;
  
  rc = 0;
  if (exp->tokens[*exp_idx] == LYXP_TOKEN_NAMETEST) {
    if (attr_axis == 0) {
      if (all_desc == 0) {
        if ((set == (lyxp_set *)0x0) || ((options & 0x3cU) == 0)) {
          rc = moveto_node(set,cur_node,exp->expr + exp->expr_pos[*exp_idx],exp->tok_len[*exp_idx],
                           options);
        }
        else {
          rc = moveto_snode(set,(lys_node *)cur_node,exp->expr + exp->expr_pos[*exp_idx],
                            exp->tok_len[*exp_idx],options);
        }
      }
      else if ((set == (lyxp_set *)0x0) || ((options & 0x3cU) == 0)) {
        rc = moveto_node_alldesc(set,cur_node,exp->expr + exp->expr_pos[*exp_idx],
                                 exp->tok_len[*exp_idx],options);
      }
      else {
        rc = moveto_snode_alldesc
                       (set,(lys_node *)cur_node,exp->expr + exp->expr_pos[*exp_idx],
                        exp->tok_len[*exp_idx],options);
      }
      if (((rc == 0) && (set != (lyxp_set *)0x0)) && ((options & 0x3cU) != 0)) {
        i = set->used;
        do {
          i = i - 1;
          if (i < 0) break;
        } while ((set->val).nodes[i].pos == 0);
        if (i == -1) {
          pcVar3 = lys_path((lys_node *)cur_node,1);
          ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                 "Schema node \"%.*s\" not found (%.*s) with context node \"%s\".",
                 (ulong)exp->tok_len[*exp_idx],exp->expr + exp->expr_pos[*exp_idx],
                 (ulong)((uint)exp->expr_pos[*exp_idx] + (uint)exp->tok_len[*exp_idx]),exp->expr,
                 pcVar3);
          free(pcVar3);
        }
      }
    }
    else if ((set == (lyxp_set *)0x0) || ((options & 0x3cU) == 0)) {
      if (all_desc == 0) {
        rc = moveto_attr(set,cur_node,exp->expr + exp->expr_pos[*exp_idx],exp->tok_len[*exp_idx],
                         options);
      }
      else {
        rc = moveto_attr_alldesc(set,cur_node,exp->expr + exp->expr_pos[*exp_idx],
                                 exp->tok_len[*exp_idx],options);
      }
    }
    else {
      set_snode_clear_ctx(set);
    }
    if (rc != 0) {
      return rc;
    }
    uVar1 = exp->expr_pos[*exp_idx];
    pcVar3 = print_token(exp->tokens[*exp_idx]);
    if (set == (lyxp_set *)0x0) {
      pcVar4 = "skipped";
    }
    else {
      pcVar4 = "parsed";
    }
    ly_log_dbg(8,"%-27s %s %s[%u]","eval_node_test",pcVar4,pcVar3,(ulong)uVar1);
    *exp_idx = *exp_idx + 1;
  }
  else {
    if (exp->tokens[*exp_idx] != LYXP_TOKEN_NODETYPE) {
      if (param_4 == (lys_module *)0x0) {
        ctx = (ly_ctx *)0x0;
      }
      else {
        ctx = param_4->ctx;
      }
      ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
             ,0x1bdd);
      return -1;
    }
    if (set != (lyxp_set *)0x0) {
      if (exp->tok_len[*exp_idx] != 4) {
                    // WARNING: Subroutine does not return
        __assert_fail("exp->tok_len[*exp_idx] == 4",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x1bb9,"eval_node_test");
      }
      if (set->type == LYXP_SET_SNODE_SET) {
        set_snode_clear_ctx(set);
        set = (lyxp_set *)0x0;
      }
      else {
        iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"node",4);
        if (iVar2 == 0) {
          iVar2 = xpath_node((lyxp_set **)0x0,0,cur_node,param_4,set,options);
          if (iVar2 != 0) {
            return -1;
          }
        }
        else {
          iVar2 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"text",4);
          if (iVar2 != 0) {
                    // WARNING: Subroutine does not return
            __assert_fail("!strncmp(&exp->expr[exp->expr_pos[*exp_idx]], \"text\", 4)",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                          ,0x1bc4,"eval_node_test");
          }
          iVar2 = xpath_text((lyxp_set **)0x0,0,cur_node,param_4,set,options);
          if (iVar2 != 0) {
            return -1;
          }
        }
      }
    }
    uVar1 = exp->expr_pos[*exp_idx];
    pcVar3 = print_token(exp->tokens[*exp_idx]);
    if (set == (lyxp_set *)0x0) {
      pcVar4 = "skipped";
    }
    else {
      pcVar4 = "parsed";
    }
    ly_log_dbg(8,"%-27s %s %s[%u]","eval_node_test",pcVar4,pcVar3,(ulong)uVar1);
    *exp_idx = *exp_idx + 1;
    if (exp->tokens[*exp_idx] != LYXP_TOKEN_PAR1) {
                    // WARNING: Subroutine does not return
      __assert_fail("exp->tokens[*exp_idx] == LYXP_TOKEN_PAR1",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x1bd0,"eval_node_test");
    }
    uVar1 = exp->expr_pos[*exp_idx];
    pcVar3 = print_token(exp->tokens[*exp_idx]);
    if (set == (lyxp_set *)0x0) {
      pcVar4 = "skipped";
    }
    else {
      pcVar4 = "parsed";
    }
    ly_log_dbg(8,"%-27s %s %s[%u]","eval_node_test",pcVar4,pcVar3,(ulong)uVar1);
    *exp_idx = *exp_idx + 1;
    if (exp->tokens[*exp_idx] != LYXP_TOKEN_PAR2) {
                    // WARNING: Subroutine does not return
      __assert_fail("exp->tokens[*exp_idx] == LYXP_TOKEN_PAR2",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x1bd6,"eval_node_test");
    }
    uVar1 = exp->expr_pos[*exp_idx];
    pcVar3 = print_token(exp->tokens[*exp_idx]);
    if (set == (lyxp_set *)0x0) {
      pcVar4 = "skipped";
    }
    else {
      pcVar4 = "parsed";
    }
    ly_log_dbg(8,"%-27s %s %s[%u]","eval_node_test",pcVar4,pcVar3,(ulong)uVar1);
    *exp_idx = *exp_idx + 1;
  }
  return 0;
}



int eval_predicate(lyxp_expr *exp,uint16_t *exp_idx,lyd_node *cur_node,lys_module *param_4,
                  lyxp_set *set,int options,int parent_pos_pred)

{
  ushort uVar1;
  uint16_t uVar2;
  long lVar3;
  int iVar4;
  uint32_t uVar5;
  char *pcVar6;
  char *pcVar7;
  long in_FS_OFFSET;
  int options_local;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  uint16_t i;
  uint16_t orig_exp;
  uint32_t orig_pos;
  int ret;
  uint32_t pred_in_ctx;
  uint32_t orig_size;
  lyd_node *orig_parent;
  lyxp_set set2;
  
  lVar3 = *(long *)(in_FS_OFFSET + 0x28);
  uVar1 = exp->expr_pos[*exp_idx];
  pcVar6 = print_token(exp->tokens[*exp_idx]);
  if (set == (lyxp_set *)0x0) {
    pcVar7 = "skipped";
  }
  else {
    pcVar7 = "parsed";
  }
  ly_log_dbg(8,"%-27s %s %s[%u]","eval_predicate",pcVar7,pcVar6,(ulong)uVar1);
  *exp_idx = *exp_idx + 1;
  if (set == (lyxp_set *)0x0) {
LAB_001da49e:
    iVar4 = eval_expr_select(exp,exp_idx,LYXP_EXPR_NONE,cur_node,param_4,(lyxp_set *)0x0,options);
    if ((iVar4 == -1) || (iVar4 == 1)) goto LAB_001dac38;
  }
  else if (set->type == LYXP_SET_NODE_SET) {
    iVar4 = set_sort(set,cur_node,options);
    if (iVar4 != 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("!set_sort(set, cur_node, options)",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x1c08,"eval_predicate");
    }
    if (set->used == 0) goto LAB_001da49e;
    uVar2 = *exp_idx;
    orig_pos = 0;
    uVar5 = set->used;
    orig_parent = (lyd_node *)0x0;
    for (i = 0; (uint)i < set->used; i = i + 1) {
      memset(&set2,0,0x40);
      set_insert_node(&set2,(set->val).nodes[i].node,(set->val).nodes[i].pos,
                      (set->val).nodes[i].type,0);
      if ((parent_pos_pred == 0) || (orig_parent == ((set->val).nodes[i].node)->parent)) {
        orig_pos = orig_pos + 1;
      }
      else {
        orig_parent = ((set->val).nodes[i].node)->parent;
        orig_pos = 1;
      }
      set2.ctx_pos = orig_pos;
      *exp_idx = uVar2;
      set2.ctx_size = uVar5;
      iVar4 = eval_expr_select(exp,exp_idx,LYXP_EXPR_NONE,cur_node,param_4,&set2,options);
      if ((iVar4 == -1) || (iVar4 == 1)) {
        lyxp_set_cast(&set2,LYXP_SET_EMPTY,cur_node,param_4,options);
        goto LAB_001dac38;
      }
      if (set2.type == LYXP_SET_NUMBER) {
        if ((long)ROUND(set2.val.num) == (ulong)orig_pos) {
          set2.val.num = (longdouble)1;
        }
        else {
          set2.val.num = (longdouble)0;
        }
      }
      lyxp_set_cast(&set2,LYXP_SET_BOOLEAN,cur_node,param_4,options);
      if (set2.val.bool == 0) {
        set_remove_node_hash(set,(set->val).nodes[i].node,(set->val).nodes[i].type);
        (set->val).nodes[i].type = LYXP_NODE_NONE;
      }
    }
    set_remove_none_nodes(set);
  }
  else if (set->type == LYXP_SET_SNODE_SET) {
    i = 0;
    while (((uint)i < set->used && ((set->val).nodes[i].pos != 1))) {
      i = i + 1;
    }
    if ((uint)i == set->used) goto LAB_001da49e;
    uVar2 = *exp_idx;
    uVar5 = set_snode_new_in_ctx(set);
    for (i = 0; (uint)i < set->used; i = i + 1) {
      if (uVar5 == (set->val).nodes[i].pos) {
        (set->val).nodes[i].pos = 1;
        *exp_idx = uVar2;
        iVar4 = eval_expr_select(exp,exp_idx,LYXP_EXPR_NONE,cur_node,param_4,set,options);
        if ((iVar4 == -1) || (iVar4 == 1)) goto LAB_001dac38;
        (set->val).nodes[i].pos = uVar5;
      }
    }
    for (i = 0; (uint)i < set->used; i = i + 1) {
      if ((set->val).nodes[i].pos == 1) {
        (set->val).nodes[i].pos = 0;
      }
      else if (uVar5 == (set->val).nodes[i].pos) {
        (set->val).nodes[i].pos = 1;
      }
    }
  }
  else {
    set2.type = LYXP_SET_EMPTY;
    set_fill_set(&set2,set);
    iVar4 = eval_expr_select(exp,exp_idx,LYXP_EXPR_NONE,cur_node,param_4,&set2,options);
    if ((iVar4 == -1) || (iVar4 == 1)) {
      lyxp_set_cast(&set2,LYXP_SET_EMPTY,cur_node,param_4,options);
      goto LAB_001dac38;
    }
    lyxp_set_cast(&set2,LYXP_SET_BOOLEAN,cur_node,param_4,options);
    if (set2.val.bool == 0) {
      lyxp_set_cast(set,LYXP_SET_EMPTY,cur_node,param_4,options);
    }
    lyxp_set_cast(&set2,LYXP_SET_EMPTY,cur_node,param_4,options);
  }
  if (exp->tokens[*exp_idx] != LYXP_TOKEN_BRACK2) {
                    // WARNING: Subroutine does not return
    __assert_fail("exp->tokens[*exp_idx] == LYXP_TOKEN_BRACK2",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x1c7d,"eval_predicate");
  }
  uVar1 = exp->expr_pos[*exp_idx];
  pcVar6 = print_token(exp->tokens[*exp_idx]);
  if (set == (lyxp_set *)0x0) {
    pcVar7 = "skipped";
  }
  else {
    pcVar7 = "parsed";
  }
  ly_log_dbg(8,"%-27s %s %s[%u]","eval_predicate",pcVar7,pcVar6,(ulong)uVar1);
  *exp_idx = *exp_idx + 1;
  iVar4 = 0;
LAB_001dac38:
  if (lVar3 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int eval_relative_location_path
              (lyxp_expr *exp,uint16_t *exp_idx,lyd_node *cur_node,lys_module *param_4,int all_desc,
              lyxp_set *set,int options)

{
  ushort uVar1;
  lyxp_token lVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  ly_ctx *ctx;
  lyxp_set *set_local;
  int all_desc_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  int attr_axis;
  int ret;
  
  all_desc_local = all_desc;
  while( true ) {
    attr_axis = 0;
    lVar2 = exp->tokens[*exp_idx];
    if (LYXP_TOKEN_NODETYPE < lVar2) break;
    if (lVar2 < LYXP_TOKEN_NAMETEST) {
      if (lVar2 == LYXP_TOKEN_AT) {
        attr_axis = 1;
        uVar1 = exp->expr_pos[*exp_idx];
        pcVar4 = print_token(exp->tokens[*exp_idx]);
        if (set == (lyxp_set *)0x0) {
          pcVar5 = "skipped";
        }
        else {
          pcVar5 = "parsed";
        }
        ly_log_dbg(8,"%-27s %s %s[%u]","eval_relative_location_path",pcVar5,pcVar4,(ulong)uVar1);
        *exp_idx = *exp_idx + 1;
        goto LAB_001db03c;
      }
      if (LYXP_TOKEN_AT < lVar2) break;
      if (lVar2 == LYXP_TOKEN_DOT) {
        if ((set == (lyxp_set *)0x0) || ((options & 0x3cU) == 0)) {
          ret = moveto_self(set,cur_node,all_desc_local,options);
        }
        else {
          ret = moveto_snode_self(set,(lys_node *)cur_node,all_desc_local,options);
        }
        if (ret != 0) {
          return ret;
        }
        uVar1 = exp->expr_pos[*exp_idx];
        pcVar4 = print_token(exp->tokens[*exp_idx]);
        if (set == (lyxp_set *)0x0) {
          pcVar5 = "skipped";
        }
        else {
          pcVar5 = "parsed";
        }
        ly_log_dbg(8,"%-27s %s %s[%u]","eval_relative_location_path",pcVar5,pcVar4,(ulong)uVar1);
        *exp_idx = *exp_idx + 1;
      }
      else {
        if (lVar2 != LYXP_TOKEN_DDOT) break;
        if ((set == (lyxp_set *)0x0) || ((options & 0x3cU) == 0)) {
          ret = moveto_parent(set,cur_node,all_desc_local,options);
        }
        else {
          ret = moveto_snode_parent(set,(lys_node *)cur_node,all_desc_local,options);
        }
        if (ret != 0) {
          return ret;
        }
        uVar1 = exp->expr_pos[*exp_idx];
        pcVar4 = print_token(exp->tokens[*exp_idx]);
        if (set == (lyxp_set *)0x0) {
          pcVar5 = "skipped";
        }
        else {
          pcVar5 = "parsed";
        }
        ly_log_dbg(8,"%-27s %s %s[%u]","eval_relative_location_path",pcVar5,pcVar4,(ulong)uVar1);
        *exp_idx = *exp_idx + 1;
      }
    }
    else {
LAB_001db03c:
      iVar3 = eval_node_test(exp,exp_idx,cur_node,param_4,attr_axis,all_desc_local,set,options);
      while( true ) {
        if (iVar3 != 0) {
          return iVar3;
        }
        if ((exp->used <= *exp_idx) || (exp->tokens[*exp_idx] != LYXP_TOKEN_BRACK1)) break;
        iVar3 = eval_predicate(exp,exp_idx,cur_node,param_4,set,options,1);
      }
    }
    if ((exp->used <= *exp_idx) || (exp->tokens[*exp_idx] != LYXP_TOKEN_OPERATOR_PATH)) {
      return 0;
    }
    if (exp->tok_len[*exp_idx] == 1) {
      all_desc_local = 0;
    }
    else {
      if (exp->tok_len[*exp_idx] != 2) {
                    // WARNING: Subroutine does not return
        __assert_fail("exp->tok_len[*exp_idx] == 2",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x1ca0,"eval_relative_location_path");
      }
      all_desc_local = 1;
    }
    uVar1 = exp->expr_pos[*exp_idx];
    pcVar4 = print_token(exp->tokens[*exp_idx]);
    if (set == (lyxp_set *)0x0) {
      pcVar5 = "skipped";
    }
    else {
      pcVar5 = "parsed";
    }
    ly_log_dbg(8,"%-27s %s %s[%u]","eval_relative_location_path",pcVar5,pcVar4,(ulong)uVar1);
    *exp_idx = *exp_idx + 1;
  }
  if (param_4 == (lys_module *)0x0) {
    ctx = (ly_ctx *)0x0;
  }
  else {
    ctx = param_4->ctx;
  }
  ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
         ,0x1ce1);
  return -1;
}



int eval_absolute_location_path
              (lyxp_expr *exp,uint16_t *exp_idx,lyd_node *cur_node,lys_module *param_4,lyxp_set *set
              ,int options)

{
  ushort uVar1;
  lyxp_token lVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  int options_local;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  int all_desc;
  int ret;
  
  if (set != (lyxp_set *)0x0) {
    if ((options & 0x3cU) == 0) {
      moveto_root(set,cur_node,options);
    }
    else {
      moveto_snode_root(set,(lys_node *)cur_node,options);
    }
  }
  if (exp->tok_len[*exp_idx] == 1) {
    uVar1 = exp->expr_pos[*exp_idx];
    pcVar4 = print_token(exp->tokens[*exp_idx]);
    if (set == (lyxp_set *)0x0) {
      pcVar5 = "skipped";
    }
    else {
      pcVar5 = "parsed";
    }
    ly_log_dbg(8,"%-27s %s %s[%u]","eval_absolute_location_path",pcVar5,pcVar4,(ulong)uVar1);
    *exp_idx = *exp_idx + 1;
    iVar3 = exp_check_token(param_4->ctx,exp,*exp_idx,LYXP_TOKEN_NONE,0);
    if (iVar3 != 0) {
      return 0;
    }
    lVar2 = exp->tokens[*exp_idx];
    if (lVar2 < LYXP_TOKEN_COMMA) {
      if (lVar2 < LYXP_TOKEN_DOT) {
        return 0;
      }
    }
    else if (1 < lVar2 + ~LYXP_TOKEN_COMMA) {
      return 0;
    }
    iVar3 = eval_relative_location_path(exp,exp_idx,cur_node,param_4,0,set,options);
  }
  else {
    uVar1 = exp->expr_pos[*exp_idx];
    pcVar4 = print_token(exp->tokens[*exp_idx]);
    if (set == (lyxp_set *)0x0) {
      pcVar5 = "skipped";
    }
    else {
      pcVar5 = "parsed";
    }
    ly_log_dbg(8,"%-27s %s %s[%u]","eval_absolute_location_path",pcVar5,pcVar4,(ulong)uVar1);
    *exp_idx = *exp_idx + 1;
    iVar3 = eval_relative_location_path(exp,exp_idx,cur_node,param_4,1,set,options);
  }
  if (iVar3 == 0) {
    return 0;
  }
  return iVar3;
}



int eval_function_call(lyxp_expr *exp,uint16_t *exp_idx,lyd_node *cur_node,lys_module *param_4,
                      lyxp_set *set,int options)

{
  ushort uVar1;
  ushort uVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  lyxp_set *plVar6;
  lyxp_set **pplVar7;
  int options_local;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  uint16_t arg_count;
  uint16_t i;
  uint16_t func_exp;
  int rc;
  _func_int_lyxp_set_ptr_ptr_uint16_t_lyd_node_ptr_lys_module_ptr_lyxp_set_ptr_int *xpath_func;
  lyxp_set **args;
  lyxp_set **args_aux;
  
  rc = 1;
  xpath_func = (_func_int_lyxp_set_ptr_ptr_uint16_t_lyd_node_ptr_lys_module_ptr_lyxp_set_ptr_int *)
               0x0;
  arg_count = 0;
  uVar1 = *exp_idx;
  args = (lyxp_set **)0x0;
  if (set != (lyxp_set *)0x0) {
    if (true) {
      switch(exp->tok_len[*exp_idx]) {
      case 3:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"not",3);
        if (iVar3 == 0) {
          xpath_func = xpath_not;
        }
        else {
          iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"sum",3);
          if (iVar3 == 0) {
            xpath_func = xpath_sum;
          }
        }
        break;
      case 4:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"lang",4);
        if (iVar3 == 0) {
          xpath_func = xpath_lang;
        }
        else {
          iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"last",4);
          if (iVar3 == 0) {
            xpath_func = xpath_last;
          }
          else {
            iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"name",4);
            if (iVar3 == 0) {
              xpath_func = xpath_name;
            }
            else {
              iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"true",4);
              if (iVar3 == 0) {
                xpath_func = xpath_true;
              }
            }
          }
        }
        break;
      case 5:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"count",5);
        if (iVar3 == 0) {
          xpath_func = xpath_count;
        }
        else {
          iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"false",5);
          if (iVar3 == 0) {
            xpath_func = xpath_false;
          }
          else {
            iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"floor",5);
            if (iVar3 == 0) {
              xpath_func = xpath_floor;
            }
            else {
              iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"round",5);
              if (iVar3 == 0) {
                xpath_func = xpath_round;
              }
              else {
                iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"deref",5);
                if (iVar3 == 0) {
                  xpath_func = xpath_deref;
                }
              }
            }
          }
        }
        break;
      case 6:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"concat",6);
        if (iVar3 == 0) {
          xpath_func = xpath_concat;
        }
        else {
          iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"number",6);
          if (iVar3 == 0) {
            xpath_func = xpath_number;
          }
          else {
            iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"string",6);
            if (iVar3 == 0) {
              xpath_func = xpath_string;
            }
          }
        }
        break;
      case 7:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"boolean",7);
        if (iVar3 == 0) {
          xpath_func = xpath_boolean;
        }
        else {
          iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"ceiling",7);
          if (iVar3 == 0) {
            xpath_func = xpath_ceiling;
          }
          else {
            iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"current",7);
            if (iVar3 == 0) {
              xpath_func = xpath_current;
            }
          }
        }
        break;
      case 8:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"contains",8);
        if (iVar3 == 0) {
          xpath_func = xpath_contains;
        }
        else {
          iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"position",8);
          if (iVar3 == 0) {
            xpath_func = xpath_position;
          }
          else {
            iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"re-match",8);
            if (iVar3 == 0) {
              xpath_func = xpath_re_match;
            }
          }
        }
        break;
      case 9:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"substring",9);
        if (iVar3 == 0) {
          xpath_func = xpath_substring;
        }
        else {
          iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"translate",9);
          if (iVar3 == 0) {
            xpath_func = xpath_translate;
          }
        }
        break;
      case 10:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"local-name",10);
        if (iVar3 == 0) {
          xpath_func = xpath_local_name;
        }
        else {
          iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"enum-value",10);
          if (iVar3 == 0) {
            xpath_func = xpath_enum_value;
          }
          else {
            iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"bit-is-set",10);
            if (iVar3 == 0) {
              xpath_func = xpath_bit_is_set;
            }
          }
        }
        break;
      case 0xb:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"starts-with",0xb);
        if (iVar3 == 0) {
          xpath_func = xpath_starts_with;
        }
        break;
      case 0xc:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"derived-from",0xc);
        if (iVar3 == 0) {
          xpath_func = xpath_derived_from;
        }
        break;
      case 0xd:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"namespace-uri",0xd);
        if (iVar3 == 0) {
          xpath_func = xpath_namespace_uri;
        }
        else {
          iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"string-length",0xd);
          if (iVar3 == 0) {
            xpath_func = xpath_string_length;
          }
        }
        break;
      case 0xf:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"normalize-space",0xf);
        if (iVar3 == 0) {
          xpath_func = xpath_normalize_space;
        }
        else {
          iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"substring-after",0xf);
          if (iVar3 == 0) {
            xpath_func = xpath_substring_after;
          }
        }
        break;
      case 0x10:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"substring-before",0x10);
        if (iVar3 == 0) {
          xpath_func = xpath_substring_before;
        }
        break;
      case 0x14:
        iVar3 = strncmp(exp->expr + exp->expr_pos[*exp_idx],"derived-from-or-self",0x14);
        if (iVar3 == 0) {
          xpath_func = xpath_derived_from_or_self;
        }
      }
    }
    if (xpath_func ==
        (_func_int_lyxp_set_ptr_ptr_uint16_t_lyd_node_ptr_lys_module_ptr_lyxp_set_ptr_int *)0x0) {
      ly_vlog(param_4->ctx,LYE_XPATH_INTOK,LY_VLOG_NONE,(void *)0x0,"Unknown",
              exp->expr + exp->expr_pos[*exp_idx]);
      ly_vlog(param_4->ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Unknown XPath function \"%.*s\".",
              (ulong)exp->tok_len[*exp_idx],exp->expr + exp->expr_pos[*exp_idx]);
      return -1;
    }
  }
  uVar2 = exp->expr_pos[*exp_idx];
  pcVar4 = print_token(exp->tokens[*exp_idx]);
  if (set == (lyxp_set *)0x0) {
    pcVar5 = "skipped";
  }
  else {
    pcVar5 = "parsed";
  }
  ly_log_dbg(8,"%-27s %s %s[%u]","eval_function_call",pcVar5,pcVar4,(ulong)uVar2);
  *exp_idx = *exp_idx + 1;
  if (exp->tokens[*exp_idx] != LYXP_TOKEN_PAR1) {
                    // WARNING: Subroutine does not return
    __assert_fail("exp->tokens[*exp_idx] == LYXP_TOKEN_PAR1",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x1dc4,"eval_function_call");
  }
  uVar2 = exp->expr_pos[*exp_idx];
  pcVar4 = print_token(exp->tokens[*exp_idx]);
  if (set == (lyxp_set *)0x0) {
    pcVar5 = "skipped";
  }
  else {
    pcVar5 = "parsed";
  }
  ly_log_dbg(8,"%-27s %s %s[%u]","eval_function_call",pcVar5,pcVar4,(ulong)uVar2);
  *exp_idx = *exp_idx + 1;
  if (exp->tokens[*exp_idx] == LYXP_TOKEN_PAR2) {
    do {
      if ((exp->used <= *exp_idx) || (exp->tokens[*exp_idx] != LYXP_TOKEN_COMMA)) {
        if (exp->tokens[*exp_idx] != LYXP_TOKEN_PAR2) {
                    // WARNING: Subroutine does not return
          __assert_fail("exp->tokens[*exp_idx] == LYXP_TOKEN_PAR2",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                        ,0x1dfb,"eval_function_call");
        }
        uVar2 = exp->expr_pos[*exp_idx];
        pcVar4 = print_token(exp->tokens[*exp_idx]);
        if (set == (lyxp_set *)0x0) {
          pcVar5 = "skipped";
        }
        else {
          pcVar5 = "parsed";
        }
        ly_log_dbg(8,"%-27s %s %s[%u]","eval_function_call",pcVar5,pcVar4,(ulong)uVar2);
        *exp_idx = *exp_idx + 1;
        if (set == (lyxp_set *)0x0) {
          rc = 0;
        }
        else {
          rc = (*xpath_func)(args,arg_count,cur_node,param_4,set,options);
          if ((options & 0x3cU) != 0) {
            if (rc == 1) {
              ly_log(param_4->ctx,LY_LLWRN,LY_SUCCESS,
                     "Previous warning generated by XPath function \"%.*s\".",
                     (ulong)(((uint)exp->expr_pos[(ulong)*exp_idx - 1] - (uint)exp->expr_pos[uVar1])
                            + 1),exp->expr + exp->expr_pos[uVar1]);
              rc = 0;
            }
            for (i = 0; i < arg_count; i = i + 1) {
              set_snode_clear_ctx(args[i]);
              set_snode_merge(set,args[i]);
            }
          }
        }
        break;
      }
      uVar2 = exp->expr_pos[*exp_idx];
      pcVar4 = print_token(exp->tokens[*exp_idx]);
      if (set == (lyxp_set *)0x0) {
        pcVar5 = "skipped";
      }
      else {
        pcVar5 = "parsed";
      }
      ly_log_dbg(8,"%-27s %s %s[%u]","eval_function_call",pcVar5,pcVar4,(ulong)uVar2);
      *exp_idx = *exp_idx + 1;
      if (set == (lyxp_set *)0x0) {
        rc = eval_expr_select(exp,exp_idx,LYXP_EXPR_NONE,cur_node,param_4,(lyxp_set *)0x0,options);
      }
      else {
        uVar2 = arg_count + 1;
        pplVar7 = (lyxp_set **)realloc(args,(ulong)uVar2 * 8);
        if (pplVar7 == (lyxp_set **)0x0) {
          ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                 "eval_function_call");
          break;
        }
        plVar6 = set_copy(set);
        pplVar7[(ulong)uVar2 - 1] = plVar6;
        arg_count = uVar2;
        args = pplVar7;
        if (pplVar7[(ulong)uVar2 - 1] == (lyxp_set *)0x0) break;
        rc = eval_expr_select(exp,exp_idx,LYXP_EXPR_NONE,cur_node,param_4,pplVar7[(ulong)uVar2 - 1],
                              options);
      }
      if (rc == -1) break;
joined_r0x001dc307:
    } while (rc != 1);
    goto LAB_001dc769;
  }
  if (set == (lyxp_set *)0x0) {
    rc = eval_expr_select(exp,exp_idx,LYXP_EXPR_NONE,cur_node,param_4,(lyxp_set *)0x0,options);
  }
  else {
    args = (lyxp_set **)malloc(8);
    if (args == (lyxp_set **)0x0) {
      ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","eval_function_call");
      goto LAB_001dc769;
    }
    arg_count = 1;
    plVar6 = set_copy(set);
    *args = plVar6;
    if (*args == (lyxp_set *)0x0) goto LAB_001dc769;
    rc = eval_expr_select(exp,exp_idx,LYXP_EXPR_NONE,cur_node,param_4,*args,options);
  }
  if (rc != -1) goto joined_r0x001dc307;
LAB_001dc769:
  for (i = 0; i < arg_count; i = i + 1) {
    lyxp_set_free(args[i]);
  }
  free(args);
  return rc;
}



int eval_number(ly_ctx *ctx,lyxp_expr *exp,uint16_t *exp_idx,lyxp_set *set)

{
  ushort uVar1;
  int iVar2;
  int *piVar3;
  char *pcVar4;
  char *pcVar5;
  long in_FS_OFFSET;
  unkbyte10 in_ST0;
  lyxp_set *set_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  ly_ctx *ctx_local;
  char *endptr;
  longdouble num;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (set != (lyxp_set *)0x0) {
    piVar3 = __errno_location();
    *piVar3 = 0;
    strtold(exp->expr + exp->expr_pos[*exp_idx],&endptr);
    num._0_8_ = (undefined8)in_ST0;
    num._8_2_ = (undefined2)((unkuint10)in_ST0 >> 0x40);
    piVar3 = __errno_location();
    if (*piVar3 != 0) {
      ly_vlog(ctx,LYE_XPATH_INTOK,LY_VLOG_NONE,(void *)0x0,"Unknown",
              exp->expr + exp->expr_pos[*exp_idx]);
      piVar3 = __errno_location();
      pcVar4 = strerror(*piVar3);
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
              "Failed to convert \"%.*s\" into a long double (%s).",(ulong)exp->tok_len[*exp_idx],
              exp->expr + exp->expr_pos[*exp_idx],(short)pcVar4);
      iVar2 = -1;
      goto LAB_001dcb00;
    }
    if ((long)endptr - (long)(exp->expr + exp->expr_pos[*exp_idx]) != (ulong)exp->tok_len[*exp_idx])
    {
      ly_vlog(ctx,LYE_XPATH_INTOK,LY_VLOG_NONE,(void *)0x0,"Unknown",
              exp->expr + exp->expr_pos[*exp_idx]);
      ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,"Failed to convert \"%.*s\" into a long double."
              ,(ulong)exp->tok_len[*exp_idx],exp->expr + exp->expr_pos[*exp_idx]);
      iVar2 = -1;
      goto LAB_001dcb00;
    }
    set_fill_number(set,(longdouble)CONCAT28(num._8_2_,num._0_8_));
  }
  uVar1 = exp->expr_pos[*exp_idx];
  pcVar4 = print_token(exp->tokens[*exp_idx]);
  if (set == (lyxp_set *)0x0) {
    pcVar5 = "skipped";
  }
  else {
    pcVar5 = "parsed";
  }
  ly_log_dbg(8,"%-27s %s %s[%u]","eval_number",pcVar5,pcVar4,(ulong)uVar1);
  *exp_idx = *exp_idx + 1;
  iVar2 = 0;
LAB_001dcb00:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int eval_path_expr(lyxp_expr *exp,uint16_t *exp_idx,lyd_node *cur_node,lys_module *param_4,
                  lyxp_set *set,int options)

{
  ushort uVar1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  int options_local;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  int all_desc;
  int ret;
  int parent_pos_pred;
  
  if (false) {
switchD_001dcb82_caseD_0:
    pcVar4 = exp->expr;
    uVar1 = exp->expr_pos[*exp_idx];
    pcVar3 = print_token(exp->tokens[*exp_idx]);
    ly_vlog(param_4->ctx,LYE_XPATH_INTOK,LY_VLOG_NONE,(void *)0x0,pcVar3,pcVar4 + uVar1);
    return -1;
  }
  switch(exp->tokens[*exp_idx]) {
  default:
    goto switchD_001dcb82_caseD_0;
  case LYXP_TOKEN_PAR1:
    uVar1 = exp->expr_pos[*exp_idx];
    pcVar4 = print_token(exp->tokens[*exp_idx]);
    if (set == (lyxp_set *)0x0) {
      pcVar3 = "skipped";
    }
    else {
      pcVar3 = "parsed";
    }
    ly_log_dbg(8,"%-27s %s %s[%u]","eval_path_expr",pcVar3,pcVar4,(ulong)uVar1);
    *exp_idx = *exp_idx + 1;
    iVar2 = eval_expr_select(exp,exp_idx,LYXP_EXPR_NONE,cur_node,param_4,set,options);
    if (iVar2 == -1) {
      return -1;
    }
    if (iVar2 == 1) {
      return 1;
    }
    if (exp->tokens[*exp_idx] != LYXP_TOKEN_PAR2) {
                    // WARNING: Subroutine does not return
      __assert_fail("exp->tokens[*exp_idx] == LYXP_TOKEN_PAR2",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                    ,0x1e6e,"eval_path_expr");
    }
    uVar1 = exp->expr_pos[*exp_idx];
    pcVar4 = print_token(exp->tokens[*exp_idx]);
    if (set == (lyxp_set *)0x0) {
      pcVar3 = "skipped";
    }
    else {
      pcVar3 = "parsed";
    }
    ly_log_dbg(8,"%-27s %s %s[%u]","eval_path_expr",pcVar3,pcVar4,(ulong)uVar1);
    *exp_idx = *exp_idx + 1;
    parent_pos_pred = 0;
    break;
  case LYXP_TOKEN_DOT:
  case LYXP_TOKEN_DDOT:
  case LYXP_TOKEN_AT:
  case LYXP_TOKEN_NAMETEST:
  case LYXP_TOKEN_NODETYPE:
    iVar2 = eval_relative_location_path(exp,exp_idx,cur_node,param_4,0,set,options);
    goto joined_r0x001dce22;
  case LYXP_TOKEN_FUNCNAME:
    if (set == (lyxp_set *)0x0) {
      ret = eval_function_call(exp,exp_idx,cur_node,param_4,(lyxp_set *)0x0,options);
    }
    else {
      ret = eval_function_call(exp,exp_idx,cur_node,param_4,set,options);
    }
    if (ret != 0) {
      return ret;
    }
    parent_pos_pred = 1;
    break;
  case LYXP_TOKEN_OPERATOR_PATH:
    iVar2 = eval_absolute_location_path(exp,exp_idx,cur_node,param_4,set,options);
joined_r0x001dce22:
    if (iVar2 != 0) {
      return iVar2;
    }
    return 0;
  case LYXP_TOKEN_LITERAL:
    if ((set == (lyxp_set *)0x0) || ((options & 0x3cU) != 0)) {
      if (set != (lyxp_set *)0x0) {
        set_snode_clear_ctx(set);
      }
      eval_literal(exp,exp_idx,(lyxp_set *)0x0);
    }
    else {
      eval_literal(exp,exp_idx,set);
    }
    parent_pos_pred = 1;
    break;
  case LYXP_TOKEN_NUMBER:
    if ((set == (lyxp_set *)0x0) || ((options & 0x3cU) != 0)) {
      if (set != (lyxp_set *)0x0) {
        set_snode_clear_ctx(set);
      }
      ret = eval_number(param_4->ctx,exp,exp_idx,(lyxp_set *)0x0);
    }
    else {
      ret = eval_number(param_4->ctx,exp,exp_idx,set);
    }
    if (ret != 0) {
      return ret;
    }
    parent_pos_pred = 1;
  }
  while ((*exp_idx < exp->used && (exp->tokens[*exp_idx] == LYXP_TOKEN_BRACK1))) {
    iVar2 = eval_predicate(exp,exp_idx,cur_node,param_4,set,options,parent_pos_pred);
    if (iVar2 != 0) {
      return iVar2;
    }
  }
  if ((*exp_idx < exp->used) && (exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_PATH)) {
    if (exp->tok_len[*exp_idx] == 1) {
      all_desc = 0;
    }
    else {
      if (exp->tok_len[*exp_idx] != 2) {
                    // WARNING: Subroutine does not return
        __assert_fail("exp->tok_len[*exp_idx] == 2",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x1ecf,"eval_path_expr");
      }
      all_desc = 1;
    }
    uVar1 = exp->expr_pos[*exp_idx];
    pcVar4 = print_token(exp->tokens[*exp_idx]);
    if (set == (lyxp_set *)0x0) {
      pcVar3 = "skipped";
    }
    else {
      pcVar3 = "parsed";
    }
    ly_log_dbg(8,"%-27s %s %s[%u]","eval_path_expr",pcVar3,pcVar4,(ulong)uVar1);
    *exp_idx = *exp_idx + 1;
    iVar2 = eval_relative_location_path(exp,exp_idx,cur_node,param_4,all_desc,set,options);
    if (iVar2 != 0) {
      return iVar2;
    }
  }
  return 0;
}



int eval_union_expr(lyxp_expr *exp,uint16_t *exp_idx,uint16_t repeat,lyd_node *cur_node,
                   lys_module *param_5,lyxp_set *set,int options)

{
  ushort uVar1;
  long lVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  long in_FS_OFFSET;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t repeat_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  uint16_t i;
  int ret;
  lyxp_set orig_set;
  lyxp_set set2;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  if (repeat == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("repeat",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x1ef5,"eval_union_expr");
  }
  memset(&orig_set,0,0x40);
  memset(&set2,0,0x40);
  set_fill_set(&orig_set,set);
  ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_UNION,cur_node,param_5,set,options);
  if (ret == 0) {
    for (i = 0; i < repeat; i = i + 1) {
      if (exp->tokens[*exp_idx] != LYXP_TOKEN_OPERATOR_UNI) {
                    // WARNING: Subroutine does not return
        __assert_fail("exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_UNI",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x1f03,"eval_union_expr");
      }
      uVar1 = exp->expr_pos[*exp_idx];
      pcVar4 = print_token(exp->tokens[*exp_idx]);
      if (set == (lyxp_set *)0x0) {
        pcVar5 = "skipped";
      }
      else {
        pcVar5 = "parsed";
      }
      ly_log_dbg(8,"%-27s %s %s[%u]","eval_union_expr",pcVar5,pcVar4,(ulong)uVar1);
      *exp_idx = *exp_idx + 1;
      if (set == (lyxp_set *)0x0) {
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_UNION,cur_node,param_5,(lyxp_set *)0x0,options)
        ;
        if (ret != 0) break;
      }
      else {
        set_fill_set(&set2,&orig_set);
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_UNION,cur_node,param_5,&set2,options);
        if (ret != 0) break;
        if ((options & 0x3cU) == 0) {
          iVar3 = moveto_union(set,&set2,cur_node,options);
          if (iVar3 != 0) {
            ret = -1;
            break;
          }
        }
        else {
          set_snode_merge(set,&set2);
        }
      }
    }
  }
  lyxp_set_cast(&orig_set,LYXP_SET_EMPTY,cur_node,param_5,options);
  lyxp_set_cast(&set2,LYXP_SET_EMPTY,cur_node,param_5,options);
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int eval_unary_expr(lyxp_expr *exp,uint16_t *exp_idx,uint16_t repeat,lyd_node *cur_node,
                   lys_module *param_5,lyxp_set *set,int options)

{
  ushort uVar1;
  ushort uVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t repeat_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  uint16_t i;
  uint16_t this_op;
  int ret;
  
  if (repeat == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("repeat",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x1f39,"eval_unary_expr");
  }
  uVar1 = *exp_idx;
  i = 0;
  while( true ) {
    if (repeat <= i) {
      iVar3 = eval_expr_select(exp,exp_idx,LYXP_EXPR_UNARY,cur_node,param_5,set,options);
      if (iVar3 == 0) {
        if ((set != (lyxp_set *)0x0) && ((repeat & 1) != 0)) {
          if ((options & 0x3cU) == 0) {
            iVar3 = moveto_op_math(set,(lyxp_set *)0x0,exp->expr + exp->expr_pos[uVar1],cur_node,
                                   param_5,options);
            if (iVar3 != 0) {
              return -1;
            }
          }
          else {
            warn_operands(param_5->ctx,set,(lyxp_set *)0x0,1,exp->expr,exp->expr_pos[uVar1]);
          }
        }
        iVar3 = 0;
      }
      return iVar3;
    }
    iVar3 = exp_check_token(param_5->ctx,exp,*exp_idx,LYXP_TOKEN_OPERATOR_MATH,0);
    if ((iVar3 != 0) || (exp->expr[exp->expr_pos[*exp_idx]] != '-')) break;
    uVar2 = exp->expr_pos[*exp_idx];
    pcVar4 = print_token(exp->tokens[*exp_idx]);
    if (set == (lyxp_set *)0x0) {
      pcVar5 = "skipped";
    }
    else {
      pcVar5 = "parsed";
    }
    ly_log_dbg(8,"%-27s %s %s[%u]","eval_unary_expr",pcVar5,pcVar4,(ulong)uVar2);
    *exp_idx = *exp_idx + 1;
    i = i + 1;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("!exp_check_token(local_mod->ctx, exp, *exp_idx, LYXP_TOKEN_OPERATOR_MATH, 0) && (exp->expr[exp->expr_pos[*exp_idx]] == \'-\')"
                ,
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                ,0x1f3e,"eval_unary_expr");
}



int eval_multiplicative_expr
              (lyxp_expr *exp,uint16_t *exp_idx,uint16_t repeat,lyd_node *cur_node,
              lys_module *param_5,lyxp_set *set,int options)

{
  ushort uVar1;
  ushort uVar2;
  long lVar3;
  int iVar4;
  char *pcVar5;
  char *pcVar6;
  long in_FS_OFFSET;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t repeat_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  uint16_t i;
  uint16_t this_op;
  int ret;
  lyxp_set orig_set;
  lyxp_set set2;
  
  lVar3 = *(long *)(in_FS_OFFSET + 0x28);
  if (repeat == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("repeat",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x1f70,"eval_multiplicative_expr");
  }
  memset(&orig_set,0,0x40);
  memset(&set2,0,0x40);
  set_fill_set(&orig_set,set);
  ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_MULTIPLICATIVE,cur_node,param_5,set,options);
  if (ret == 0) {
    for (i = 0; i < repeat; i = i + 1) {
      uVar1 = *exp_idx;
      if (exp->tokens[*exp_idx] != LYXP_TOKEN_OPERATOR_MATH) {
                    // WARNING: Subroutine does not return
        __assert_fail("exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_MATH",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x1f80,"eval_multiplicative_expr");
      }
      uVar2 = exp->expr_pos[*exp_idx];
      pcVar5 = print_token(exp->tokens[*exp_idx]);
      if (set == (lyxp_set *)0x0) {
        pcVar6 = "skipped";
      }
      else {
        pcVar6 = "parsed";
      }
      ly_log_dbg(8,"%-27s %s %s[%u]","eval_multiplicative_expr",pcVar6,pcVar5,(ulong)uVar2);
      *exp_idx = *exp_idx + 1;
      if (set == (lyxp_set *)0x0) {
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_MULTIPLICATIVE,cur_node,param_5,(lyxp_set *)0x0
                               ,options);
        if (ret != 0) break;
      }
      else {
        set_fill_set(&set2,&orig_set);
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_MULTIPLICATIVE,cur_node,param_5,&set2,options);
        if (ret != 0) break;
        if ((options & 0x3cU) == 0) {
          iVar4 = moveto_op_math(set,&set2,exp->expr + exp->expr_pos[uVar1],cur_node,param_5,options
                                );
          if (iVar4 != 0) {
            ret = -1;
            break;
          }
        }
        else {
          warn_operands(param_5->ctx,set,&set2,1,exp->expr,exp->expr_pos[(ulong)uVar1 - 1]);
          set_snode_merge(set,&set2);
          set_snode_clear_ctx(set);
        }
      }
    }
  }
  lyxp_set_cast(&orig_set,LYXP_SET_EMPTY,cur_node,param_5,options);
  lyxp_set_cast(&set2,LYXP_SET_EMPTY,cur_node,param_5,options);
  if (lVar3 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int eval_additive_expr(lyxp_expr *exp,uint16_t *exp_idx,uint16_t repeat,lyd_node *cur_node,
                      lys_module *param_5,lyxp_set *set,int options)

{
  ushort uVar1;
  ushort uVar2;
  long lVar3;
  int iVar4;
  char *pcVar5;
  char *pcVar6;
  long in_FS_OFFSET;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t repeat_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  uint16_t i;
  uint16_t this_op;
  int ret;
  lyxp_set orig_set;
  lyxp_set set2;
  
  lVar3 = *(long *)(in_FS_OFFSET + 0x28);
  if (repeat == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("repeat",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x1fbe,"eval_additive_expr");
  }
  memset(&orig_set,0,0x40);
  memset(&set2,0,0x40);
  set_fill_set(&orig_set,set);
  ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_ADDITIVE,cur_node,param_5,set,options);
  if (ret == 0) {
    for (i = 0; i < repeat; i = i + 1) {
      uVar1 = *exp_idx;
      if (exp->tokens[*exp_idx] != LYXP_TOKEN_OPERATOR_MATH) {
                    // WARNING: Subroutine does not return
        __assert_fail("exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_MATH",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x1fce,"eval_additive_expr");
      }
      uVar2 = exp->expr_pos[*exp_idx];
      pcVar5 = print_token(exp->tokens[*exp_idx]);
      if (set == (lyxp_set *)0x0) {
        pcVar6 = "skipped";
      }
      else {
        pcVar6 = "parsed";
      }
      ly_log_dbg(8,"%-27s %s %s[%u]","eval_additive_expr",pcVar6,pcVar5,(ulong)uVar2);
      *exp_idx = *exp_idx + 1;
      if (set == (lyxp_set *)0x0) {
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_ADDITIVE,cur_node,param_5,(lyxp_set *)0x0,
                               options);
        iVar4 = ret;
joined_r0x001de006:
        if (iVar4 != 0) break;
      }
      else {
        set_fill_set(&set2,&orig_set);
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_ADDITIVE,cur_node,param_5,&set2,options);
        if (ret != 0) break;
        if ((options & 0x3cU) == 0) {
          iVar4 = moveto_op_math(set,&set2,exp->expr + exp->expr_pos[uVar1],cur_node,param_5,options
                                );
          goto joined_r0x001de006;
        }
        warn_operands(param_5->ctx,set,&set2,1,exp->expr,exp->expr_pos[(ulong)uVar1 - 1]);
        set_snode_merge(set,&set2);
        set_snode_clear_ctx(set);
      }
    }
  }
  lyxp_set_cast(&orig_set,LYXP_SET_EMPTY,cur_node,param_5,options);
  lyxp_set_cast(&set2,LYXP_SET_EMPTY,cur_node,param_5,options);
  if (lVar3 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return ret;
}



int eval_relational_expr
              (lyxp_expr *exp,uint16_t *exp_idx,uint16_t repeat,lyd_node *cur_node,
              lys_module *param_5,lyxp_set *set,int options)

{
  ushort uVar1;
  ushort uVar2;
  long lVar3;
  int iVar4;
  char *pcVar5;
  char *pcVar6;
  long in_FS_OFFSET;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t repeat_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  uint16_t i;
  uint16_t this_op;
  int ret;
  lyxp_set orig_set;
  lyxp_set set2;
  
  lVar3 = *(long *)(in_FS_OFFSET + 0x28);
  if (repeat == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("repeat",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x200d,"eval_relational_expr");
  }
  memset(&orig_set,0,0x40);
  memset(&set2,0,0x40);
  set_fill_set(&orig_set,set);
  ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_RELATIONAL,cur_node,param_5,set,options);
  if (ret == 0) {
    for (i = 0; i < repeat; i = i + 1) {
      uVar1 = *exp_idx;
      if (exp->tokens[*exp_idx] != LYXP_TOKEN_OPERATOR_COMP) {
                    // WARNING: Subroutine does not return
        __assert_fail("exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_COMP",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x201d,"eval_relational_expr");
      }
      uVar2 = exp->expr_pos[*exp_idx];
      pcVar5 = print_token(exp->tokens[*exp_idx]);
      if (set == (lyxp_set *)0x0) {
        pcVar6 = "skipped";
      }
      else {
        pcVar6 = "parsed";
      }
      ly_log_dbg(8,"%-27s %s %s[%u]","eval_relational_expr",pcVar6,pcVar5,(ulong)uVar2);
      *exp_idx = *exp_idx + 1;
      if (set == (lyxp_set *)0x0) {
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_RELATIONAL,cur_node,param_5,(lyxp_set *)0x0,
                               options);
        if (ret != 0) break;
      }
      else {
        set_fill_set(&set2,&orig_set);
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_RELATIONAL,cur_node,param_5,&set2,options);
        if (ret != 0) break;
        if ((options & 0x3cU) == 0) {
          iVar4 = moveto_op_comp(set,&set2,exp->expr + exp->expr_pos[uVar1],cur_node,param_5,options
                                );
          if (iVar4 != 0) {
            ret = -1;
            break;
          }
        }
        else {
          warn_operands(param_5->ctx,set,&set2,1,exp->expr,exp->expr_pos[(ulong)uVar1 - 1]);
          set_snode_merge(set,&set2);
          set_snode_clear_ctx(set);
        }
      }
    }
  }
  lyxp_set_cast(&orig_set,LYXP_SET_EMPTY,cur_node,param_5,options);
  lyxp_set_cast(&set2,LYXP_SET_EMPTY,cur_node,param_5,options);
  if (lVar3 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int eval_equality_expr(lyxp_expr *exp,uint16_t *exp_idx,uint16_t repeat,lyd_node *cur_node,
                      lys_module *param_5,lyxp_set *set,int options)

{
  ushort uVar1;
  ushort uVar2;
  long lVar3;
  int iVar4;
  char *pcVar5;
  char *pcVar6;
  long in_FS_OFFSET;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t repeat_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  uint16_t i;
  uint16_t this_op;
  int ret;
  lyxp_set orig_set;
  lyxp_set set2;
  
  lVar3 = *(long *)(in_FS_OFFSET + 0x28);
  if (repeat == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("repeat",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x205a,"eval_equality_expr");
  }
  memset(&orig_set,0,0x40);
  memset(&set2,0,0x40);
  set_fill_set(&orig_set,set);
  ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_EQUALITY,cur_node,param_5,set,options);
  if (ret == 0) {
    for (i = 0; i < repeat; i = i + 1) {
      uVar1 = *exp_idx;
      if (exp->tokens[*exp_idx] != LYXP_TOKEN_OPERATOR_COMP) {
                    // WARNING: Subroutine does not return
        __assert_fail("exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_COMP",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x206a,"eval_equality_expr");
      }
      uVar2 = exp->expr_pos[*exp_idx];
      pcVar5 = print_token(exp->tokens[*exp_idx]);
      if (set == (lyxp_set *)0x0) {
        pcVar6 = "skipped";
      }
      else {
        pcVar6 = "parsed";
      }
      ly_log_dbg(8,"%-27s %s %s[%u]","eval_equality_expr",pcVar6,pcVar5,(ulong)uVar2);
      *exp_idx = *exp_idx + 1;
      if (set == (lyxp_set *)0x0) {
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_EQUALITY,cur_node,param_5,(lyxp_set *)0x0,
                               options);
        if (ret != 0) goto LAB_001de9f9;
      }
      else {
        set_fill_set(&set2,&orig_set);
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_EQUALITY,cur_node,param_5,&set2,options);
        if (ret != 0) break;
        if ((options & 0x3cU) == 0) {
          iVar4 = moveto_op_comp(set,&set2,exp->expr + exp->expr_pos[uVar1],cur_node,param_5,options
                                );
          if (iVar4 != 0) {
            ret = -1;
            break;
          }
        }
        else {
          warn_operands(param_5->ctx,set,&set2,0,exp->expr,exp->expr_pos[(ulong)uVar1 - 1]);
          warn_equality_value(param_5->ctx,exp,set,*exp_idx - 1,uVar1 - 1,*exp_idx - 1);
          warn_equality_value(param_5->ctx,exp,&set2,uVar1 - 1,uVar1 - 1,*exp_idx - 1);
          set_snode_merge(set,&set2);
          set_snode_clear_ctx(set);
        }
      }
    }
  }
  lyxp_set_cast(&orig_set,LYXP_SET_EMPTY,cur_node,param_5,options);
  lyxp_set_cast(&set2,LYXP_SET_EMPTY,cur_node,param_5,options);
LAB_001de9f9:
  if (lVar3 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int eval_and_expr(lyxp_expr *exp,uint16_t *exp_idx,uint16_t repeat,lyd_node *cur_node,
                 lys_module *param_5,lyxp_set *set,int options)

{
  ushort uVar1;
  long lVar2;
  char *pcVar3;
  char *pcVar4;
  long in_FS_OFFSET;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t repeat_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  uint16_t i;
  int ret;
  lyxp_set orig_set;
  lyxp_set set2;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  if (repeat == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("repeat",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x20a7,"eval_and_expr");
  }
  memset(&orig_set,0,0x40);
  memset(&set2,0,0x40);
  set_fill_set(&orig_set,set);
  ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_AND,cur_node,param_5,set,options);
  if (ret == 0) {
    if ((set == (lyxp_set *)0x0) || ((options & 0x3cU) == 0)) {
      lyxp_set_cast(set,LYXP_SET_BOOLEAN,cur_node,param_5,options);
    }
    else {
      set_snode_clear_ctx(set);
    }
    for (i = 0; i < repeat; i = i + 1) {
      if (exp->tokens[*exp_idx] != LYXP_TOKEN_OPERATOR_LOG) {
                    // WARNING: Subroutine does not return
        __assert_fail("exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_LOG",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x20bc,"eval_and_expr");
      }
      uVar1 = exp->expr_pos[*exp_idx];
      pcVar3 = print_token(exp->tokens[*exp_idx]);
      if ((set == (lyxp_set *)0x0) || ((set->val).bool == 0)) {
        pcVar4 = "skipped";
      }
      else {
        pcVar4 = "parsed";
      }
      ly_log_dbg(8,"%-27s %s %s[%u]","eval_and_expr",pcVar4,pcVar3,(ulong)uVar1);
      *exp_idx = *exp_idx + 1;
      if ((set == (lyxp_set *)0x0) || ((set->type == LYXP_SET_BOOLEAN && ((set->val).bool == 0)))) {
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_AND,cur_node,param_5,(lyxp_set *)0x0,options);
        if (ret != 0) break;
      }
      else {
        set_fill_set(&set2,&orig_set);
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_AND,cur_node,param_5,&set2,options);
        if (ret != 0) break;
        if (set->type == LYXP_SET_SNODE_SET) {
          set_snode_clear_ctx(&set2);
          set_snode_merge(set,&set2);
        }
        else {
          lyxp_set_cast(&set2,LYXP_SET_BOOLEAN,cur_node,param_5,options);
          set_fill_set(set,&set2);
        }
      }
    }
  }
  lyxp_set_cast(&orig_set,LYXP_SET_EMPTY,cur_node,param_5,options);
  lyxp_set_cast(&set2,LYXP_SET_EMPTY,cur_node,param_5,options);
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int eval_or_expr(lyxp_expr *exp,uint16_t *exp_idx,uint16_t repeat,lyd_node *cur_node,
                lys_module *param_5,lyxp_set *set,int options)

{
  ushort uVar1;
  long lVar2;
  char *pcVar3;
  char *pcVar4;
  long in_FS_OFFSET;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  uint16_t repeat_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  uint16_t i;
  int ret;
  lyxp_set orig_set;
  lyxp_set set2;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  if (repeat == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("repeat",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x20f5,"eval_or_expr");
  }
  memset(&orig_set,0,0x40);
  memset(&set2,0,0x40);
  set_fill_set(&orig_set,set);
  ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_OR,cur_node,param_5,set,options);
  if (ret == 0) {
    if ((set == (lyxp_set *)0x0) || ((options & 0x3cU) == 0)) {
      lyxp_set_cast(set,LYXP_SET_BOOLEAN,cur_node,param_5,options);
    }
    else {
      set_snode_clear_ctx(set);
    }
    for (i = 0; i < repeat; i = i + 1) {
      if (exp->tokens[*exp_idx] != LYXP_TOKEN_OPERATOR_LOG) {
                    // WARNING: Subroutine does not return
        __assert_fail("exp->tokens[*exp_idx] == LYXP_TOKEN_OPERATOR_LOG",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                      ,0x210a,"eval_or_expr");
      }
      uVar1 = exp->expr_pos[*exp_idx];
      pcVar3 = print_token(exp->tokens[*exp_idx]);
      if ((set == (lyxp_set *)0x0) || ((set->val).bool != 0)) {
        pcVar4 = "skipped";
      }
      else {
        pcVar4 = "parsed";
      }
      ly_log_dbg(8,"%-27s %s %s[%u]","eval_or_expr",pcVar4,pcVar3,(ulong)uVar1);
      *exp_idx = *exp_idx + 1;
      if ((set == (lyxp_set *)0x0) || ((set->type == LYXP_SET_BOOLEAN && ((set->val).bool != 0)))) {
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_OR,cur_node,param_5,(lyxp_set *)0x0,options);
        if (ret != 0) break;
      }
      else {
        set_fill_set(&set2,&orig_set);
        ret = eval_expr_select(exp,exp_idx,LYXP_EXPR_OR,cur_node,param_5,&set2,options);
        if (ret != 0) break;
        if (set->type == LYXP_SET_SNODE_SET) {
          set_snode_clear_ctx(&set2);
          set_snode_merge(set,&set2);
        }
        else {
          lyxp_set_cast(&set2,LYXP_SET_BOOLEAN,cur_node,param_5,options);
          set_fill_set(set,&set2);
        }
      }
    }
  }
  lyxp_set_cast(&orig_set,LYXP_SET_EMPTY,cur_node,param_5,options);
  lyxp_set_cast(&set2,LYXP_SET_EMPTY,cur_node,param_5,options);
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int eval_expr_select(lyxp_expr *exp,uint16_t *exp_idx,lyxp_expr_type etype,lyd_node *cur_node,
                    lys_module *param_5,lyxp_set *set,int options)

{
  ly_ctx *ctx;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  lyxp_expr_type etype_local;
  uint16_t *exp_idx_local;
  lyxp_expr *exp_local;
  uint16_t i;
  uint16_t count;
  int ret;
  lyxp_expr_type next_etype;
  
  if (exp->repeat[*exp_idx] == (lyxp_expr_type *)0x0) {
    next_etype = LYXP_EXPR_NONE;
  }
  else {
    for (i = 0; etype < exp->repeat[*exp_idx][i]; i = i + 1) {
    }
    if (i == 0) {
      next_etype = LYXP_EXPR_NONE;
    }
    else {
      next_etype = exp->repeat[*exp_idx][(ulong)i - 1];
      count = 0;
      while ((i != 0 && (next_etype == exp->repeat[*exp_idx][(ulong)i - 1]))) {
        count = count + 1;
        i = i - 1;
      }
    }
  }
  switch(next_etype) {
  case LYXP_EXPR_NONE:
    ret = eval_path_expr(exp,exp_idx,cur_node,param_5,set,options);
    break;
  case LYXP_EXPR_OR:
    ret = eval_or_expr(exp,exp_idx,count,cur_node,param_5,set,options);
    break;
  case LYXP_EXPR_AND:
    ret = eval_and_expr(exp,exp_idx,count,cur_node,param_5,set,options);
    break;
  case LYXP_EXPR_EQUALITY:
    ret = eval_equality_expr(exp,exp_idx,count,cur_node,param_5,set,options);
    break;
  case LYXP_EXPR_RELATIONAL:
    ret = eval_relational_expr(exp,exp_idx,count,cur_node,param_5,set,options);
    break;
  case LYXP_EXPR_ADDITIVE:
    ret = eval_additive_expr(exp,exp_idx,count,cur_node,param_5,set,options);
    break;
  case LYXP_EXPR_MULTIPLICATIVE:
    ret = eval_multiplicative_expr(exp,exp_idx,count,cur_node,param_5,set,options);
    break;
  case LYXP_EXPR_UNARY:
    ret = eval_unary_expr(exp,exp_idx,count,cur_node,param_5,set,options);
    break;
  case LYXP_EXPR_UNION:
    ret = eval_union_expr(exp,exp_idx,count,cur_node,param_5,set,options);
    break;
  default:
    ret = -1;
    if (param_5 == (lys_module *)0x0) {
      ctx = (ly_ctx *)0x0;
    }
    else {
      ctx = param_5->ctx;
    }
    ly_log(ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
           ,0x2174);
  }
  return ret;
}



int lyxp_eval(char *expr,lyd_node *cur_node,lyxp_node_type cur_node_type,lys_module *param_4,
             lyxp_set *set,int options)

{
  int iVar1;
  long in_FS_OFFSET;
  lyxp_set *set_local;
  lys_module *local_mod_local;
  int options_local;
  lyxp_node_type cur_node_type_local;
  lyd_node *cur_node_local;
  char *expr_local;
  uint16_t exp_idx;
  int rc;
  ly_ctx *ctx;
  lyxp_expr *exp;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  exp_idx = 0;
  rc = -1;
  if (((expr == (char *)0x0) || (param_4 == (lys_module *)0x0)) || (set == (lyxp_set *)0x0)) {
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_EINVAL,"Invalid arguments (%s()).","lyxp_eval");
    iVar1 = 1;
  }
  else {
    ctx = param_4->ctx;
    exp = lyxp_parse_expr(ctx,expr);
    if (exp == (lyxp_expr *)0x0) {
      rc = -1;
    }
    else {
      rc = reparse_or_expr(ctx,exp,&exp_idx);
      if (rc == 0) {
        if (exp_idx < exp->used) {
          ly_vlog(ctx,LYE_XPATH_INTOK,LY_VLOG_NONE,(void *)0x0,"Unknown",
                  exp->expr + exp->expr_pos[exp_idx]);
          ly_vlog(ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                  "Unparsed characters \"%s\" left at the end of an XPath expression.",
                  exp->expr + exp->expr_pos[exp_idx]);
          rc = -1;
        }
        else {
          print_expr_struct_debug(exp);
          exp_idx = 0;
          memset(set,0,0x40);
          set->type = LYXP_SET_EMPTY;
          if (cur_node != (lyd_node *)0x0) {
            set_insert_node(set,cur_node,0,cur_node_type,0);
          }
          rc = eval_expr_select(exp,&exp_idx,LYXP_EXPR_NONE,cur_node,param_4,set,options);
          if (rc == 2) {
            rc = 0;
          }
          if ((rc == -1) && (cur_node != (lyd_node *)0x0)) {
            ly_vlog(ctx,LYE_PATH,LY_VLOG_LYD,cur_node);
            lyxp_set_cast(set,LYXP_SET_EMPTY,cur_node,param_4,options);
          }
        }
      }
    }
    lyxp_expr_free(exp);
    iVar1 = rc;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int lyxp_set_cast(lyxp_set *set,lyxp_set_type target,lyd_node *cur_node,lys_module *param_4,
                 int options)

{
  lyxp_set_type lVar1;
  int iVar2;
  char *pcVar3;
  ly_ctx *plVar4;
  undefined4 in_register_00000034;
  char *str_00;
  long in_FS_OFFSET;
  longdouble in_ST0;
  lys_module *local_mod_local;
  lyd_node *cur_node_local;
  int options_local;
  lyxp_set_type target_local;
  lyxp_set *set_local;
  char *str;
  longdouble num;
  long local_10;
  
  str_00 = (char *)CONCAT44(in_register_00000034,target);
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((set == (lyxp_set *)0x0) || (target == set->type)) {
    iVar2 = 0;
    goto LAB_001e014b;
  }
  if ((target == LYXP_SET_NODE_SET) ||
     ((set->type == LYXP_SET_SNODE_SET && (target != LYXP_SET_EMPTY)))) {
                    // WARNING: Subroutine does not return
    __assert_fail("(target != LYXP_SET_NODE_SET) && ((set->type != LYXP_SET_SNODE_SET) || (target == LYXP_SET_EMPTY))"
                  ,
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                  ,0x2221,"lyxp_set_cast");
  }
  if (set->type == LYXP_SET_SNODE_SET) {
    set_free_content(set);
    iVar2 = -1;
    goto LAB_001e014b;
  }
  if ((target == LYXP_SET_STRING) ||
     ((target == LYXP_SET_NUMBER &&
      ((set->type == LYXP_SET_NODE_SET || (set->type == LYXP_SET_EMPTY)))))) {
    lVar1 = set->type;
    if (lVar1 == LYXP_SET_NUMBER) {
      if (NAN((set->val).num)) {
        pcVar3 = strdup("NaN");
        (set->val).str = pcVar3;
        if ((set->val).nodes == (lyxp_set_node *)0x0) {
          ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxp_set_cast");
          iVar2 = -1;
          goto LAB_001e014b;
        }
      }
      else if (((true) && ((longdouble)0 == (set->val).num)) ||
              ((true && ((longdouble)0 == (set->val).num)))) {
        pcVar3 = strdup("0");
        (set->val).str = pcVar3;
        if ((set->val).nodes == (lyxp_set_node *)0x0) {
          ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxp_set_cast");
          iVar2 = -1;
          goto LAB_001e014b;
        }
      }
      else if ((ABS((set->val).num) <= _DAT_0022ccf0) || ((set->val).num < (longdouble)0)) {
        if ((ABS((set->val).num) <= _DAT_0022ccf0) || ((longdouble)0 <= (set->val).num)) {
          if ((false) || ((set->val).num != (longdouble)(long)ROUND((set->val).num))) {
            str_00 = "%03.1Lf";
            iVar2 = asprintf(&str,"%03.1Lf");
            if (iVar2 == -1) {
              ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "lyxp_set_cast");
              iVar2 = -1;
              goto LAB_001e014b;
            }
            (set->val).str = str;
          }
          else {
            str_00 = &DAT_0022abe0;
            iVar2 = asprintf(&str,"%lld",(long)ROUND((set->val).num));
            if (iVar2 == -1) {
              ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "lyxp_set_cast");
              iVar2 = -1;
              goto LAB_001e014b;
            }
            (set->val).str = str;
          }
        }
        else {
          pcVar3 = strdup("-Infinity");
          (set->val).str = pcVar3;
          if ((set->val).nodes == (lyxp_set_node *)0x0) {
            ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxp_set_cast")
            ;
            iVar2 = -1;
            goto LAB_001e014b;
          }
        }
      }
      else {
        pcVar3 = strdup("Infinity");
        (set->val).str = pcVar3;
        if ((set->val).nodes == (lyxp_set_node *)0x0) {
          ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxp_set_cast");
          iVar2 = -1;
          goto LAB_001e014b;
        }
      }
    }
    else {
      if (LYXP_SET_NUMBER < lVar1) {
LAB_001dfe8a:
        if (param_4 == (lys_module *)0x0) {
          plVar4 = (ly_ctx *)0x0;
        }
        else {
          plVar4 = param_4->ctx;
        }
        ly_log(plVar4,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
               ,0x2261);
        iVar2 = -1;
        goto LAB_001e014b;
      }
      if (lVar1 == LYXP_SET_BOOLEAN) {
        if ((set->val).bool == 0) {
          pcVar3 = strdup("false");
          (set->val).str = pcVar3;
        }
        else {
          pcVar3 = strdup("true");
          (set->val).str = pcVar3;
        }
        if ((set->val).nodes == (lyxp_set_node *)0x0) {
          ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxp_set_cast");
          iVar2 = -1;
          goto LAB_001e014b;
        }
      }
      else {
        if (LYXP_SET_BOOLEAN < lVar1) goto LAB_001dfe8a;
        if (lVar1 == LYXP_SET_EMPTY) {
          pcVar3 = strdup("");
          (set->val).str = pcVar3;
          if ((set->val).nodes == (lyxp_set_node *)0x0) {
            ly_log(param_4->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyxp_set_cast")
            ;
            iVar2 = -1;
            goto LAB_001e014b;
          }
        }
        else {
          if (lVar1 != LYXP_SET_NODE_SET) goto LAB_001dfe8a;
          if (set->used == 0) {
                    // WARNING: Subroutine does not return
            __assert_fail("set->used",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                          ,0x2250,"lyxp_set_cast");
          }
          iVar2 = set_sort(set,cur_node,options);
          if (iVar2 != 0) {
                    // WARNING: Subroutine does not return
            __assert_fail("!set_sort(set, cur_node, options)",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                          ,0x2253,"lyxp_set_cast");
          }
          str = cast_node_set_to_string(set,cur_node,param_4,options);
          if (str == (char *)0x0) {
            iVar2 = -1;
            goto LAB_001e014b;
          }
          set_free_content(set);
          (set->val).str = str;
          str_00 = (char *)cur_node;
        }
      }
    }
    set->type = LYXP_SET_STRING;
  }
  if (target == LYXP_SET_NUMBER) {
    if (set->type == LYXP_SET_BOOLEAN) {
      if ((set->val).bool == 0) {
        (set->val).num = (longdouble)0;
      }
      else {
        (set->val).num = (longdouble)1;
      }
    }
    else {
      if (set->type != LYXP_SET_STRING) {
        if (param_4 == (lys_module *)0x0) {
          plVar4 = (ly_ctx *)0x0;
        }
        else {
          plVar4 = param_4->ctx;
        }
        ly_log(plVar4,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
               ,0x2277);
        iVar2 = -1;
        goto LAB_001e014b;
      }
      cast_string_to_number((longdouble *)(set->val).nodes,str_00);
      num = in_ST0;
      set_free_content(set);
      (set->val).num = num;
    }
    set->type = LYXP_SET_NUMBER;
  }
  if (target == LYXP_SET_BOOLEAN) {
    lVar1 = set->type;
    if (lVar1 == LYXP_SET_STRING) {
      if (*(set->val).str == '\0') {
        set_free_content(set);
        (set->val).bool = 0;
      }
      else {
        set_free_content(set);
        (set->val).bool = 1;
      }
    }
    else {
      if (LYXP_SET_STRING < lVar1) {
LAB_001e00d9:
        if (param_4 == (lys_module *)0x0) {
          plVar4 = (ly_ctx *)0x0;
        }
        else {
          plVar4 = param_4->ctx;
        }
        ly_log(plVar4,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
               ,0x229a);
        iVar2 = -1;
        goto LAB_001e014b;
      }
      if (lVar1 == LYXP_SET_NUMBER) {
        if ((((true) && ((longdouble)0 == (set->val).num)) ||
            ((true && ((longdouble)0 == (set->val).num)))) || (NAN((set->val).num))) {
          (set->val).bool = 0;
        }
        else {
          (set->val).bool = 1;
        }
      }
      else {
        if (LYXP_SET_NUMBER < lVar1) goto LAB_001e00d9;
        if (lVar1 == LYXP_SET_EMPTY) {
          (set->val).bool = 0;
        }
        else {
          if (lVar1 != LYXP_SET_NODE_SET) goto LAB_001e00d9;
          set_free_content(set);
          if (set->used == 0) {
                    // WARNING: Subroutine does not return
            __assert_fail("set->used",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                          ,0x2293,"lyxp_set_cast");
          }
          (set->val).bool = 1;
        }
      }
    }
    set->type = LYXP_SET_BOOLEAN;
  }
  if (target == LYXP_SET_EMPTY) {
    set_free_content(set);
    set->type = LYXP_SET_EMPTY;
  }
  iVar2 = 0;
LAB_001e014b:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyxp_atomize(char *expr,lys_node *cur_snode,lyxp_node_type cur_snode_type,lyxp_set *set,
                int options,lys_node **ctx_snode)

{
  lyxp_node_type lVar1;
  lys_node *plVar2;
  lys_module *plVar3;
  long in_FS_OFFSET;
  lys_node **ctx_snode_local;
  lyxp_set *set_local;
  int options_local;
  lyxp_node_type cur_snode_type_local;
  lys_node *cur_snode_local;
  char *expr_local;
  uint16_t exp_idx;
  lyxp_node_type ctx_snode_type;
  int rc;
  lys_node *_ctx_snode;
  lyxp_expr *exp;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  exp_idx = 0;
  rc = -1;
  exp = lyxp_parse_expr(cur_snode->module->ctx,expr);
  if (exp == (lyxp_expr *)0x0) {
    rc = -1;
  }
  else {
    rc = reparse_or_expr(cur_snode->module->ctx,exp,&exp_idx);
    if (rc == 0) {
      if (exp_idx < exp->used) {
        ly_vlog(cur_snode->module->ctx,LYE_XPATH_INTOK,LY_VLOG_NONE,(void *)0x0,"Unknown",
                exp->expr + exp->expr_pos[exp_idx]);
        ly_vlog(cur_snode->module->ctx,LYE_SPEC,LY_VLOG_NONE,(void *)0x0,
                "Unparsed characters \"%s\" left at the end of an XPath expression.",
                exp->expr + exp->expr_pos[exp_idx]);
        rc = -1;
      }
      else {
        print_expr_struct_debug(exp);
        lVar1 = cur_snode_type;
        plVar2 = cur_snode;
        if ((options & 0x10U) != 0) {
          resolve_when_ctx_snode(cur_snode,&_ctx_snode,&ctx_snode_type);
          lVar1 = ctx_snode_type;
          plVar2 = _ctx_snode;
        }
        _ctx_snode = plVar2;
        ctx_snode_type = lVar1;
        if (ctx_snode != (lys_node **)0x0) {
          *ctx_snode = _ctx_snode;
        }
        exp_idx = 0;
        memset(set,0,0x40);
        set->type = LYXP_SET_SNODE_SET;
        set_snode_insert_node(set,_ctx_snode,ctx_snode_type);
        plVar3 = lys_node_module(_ctx_snode);
        rc = eval_expr_select(exp,&exp_idx,LYXP_EXPR_NONE,(lyd_node *)_ctx_snode,plVar3,set,options)
        ;
        if (rc == 2) {
          rc = 0;
        }
      }
    }
  }
  lyxp_expr_free(exp);
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return rc;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyxp_node_atomize(lys_node *node,lyxp_set *set,int set_ext_dep_flags)

{
  uint16_t uVar1;
  LYS_NODE LVar2;
  long lVar3;
  char *pcVar4;
  int iVar5;
  lys_node *plVar6;
  lys_module *plVar7;
  lys_module *plVar8;
  long in_FS_OFFSET;
  int set_ext_dep_flags_local;
  lyxp_set *set_local;
  lys_node *node_local;
  uint8_t must_size;
  uint32_t i;
  uint32_t j;
  int opts;
  int ret;
  lys_node *ctx_snode;
  lys_node *parent;
  lys_node *elem;
  lys_when *when;
  lys_restr *must;
  char *path;
  lyxp_set tmp_set;
  
  lVar3 = *(long *)(in_FS_OFFSET + 0x28);
  ctx_snode = (lys_node *)0x0;
  must_size = '\0';
  ret = 0;
  when = (lys_when *)0x0;
  must = (lys_restr *)0x0;
  path = (char *)0x0;
  memset(&tmp_set,0,0x40);
  memset(set,0,0x40);
  opts = 0;
  for (parent = node; (parent != (lys_node *)0x0 && (parent->nodetype != LYS_OUTPUT));
      parent = lys_parent(parent)) {
  }
  if (parent != (lys_node *)0x0) {
    opts = 0x20;
  }
  LVar2 = node->nodetype;
  if (LVar2 == LYS_ANYDATA) {
switchD_001e0591_caseD_20:
    when = (lys_when *)node[1].name;
    must = (lys_restr *)node[1].dsc;
    must_size = node->padding[3];
  }
  else if (LVar2 < (LYS_CONTAINER|LYS_ANYDATA)) {
    if (LVar2 == LYS_AUGMENT) {
      when = (lys_when *)node->next;
    }
    else if (LVar2 < (LYS_CONTAINER|LYS_AUGMENT)) {
      if (LVar2 == LYS_USES) {
        when = *(lys_when **)node->hash;
      }
      else if (LVar2 < (LYS_CONTAINER|LYS_USES)) {
        if (LVar2 == LYS_OUTPUT) {
LAB_001e0702:
          must = (lys_restr *)node[1].name;
          must_size = node->padding[1];
        }
        else if (LVar2 < (LYS_CONTAINER|LYS_OUTPUT)) {
          if (LVar2 == LYS_INPUT) goto LAB_001e0702;
          if (LVar2 < (LYS_CONTAINER|LYS_INPUT)) {
            if (LVar2 == LYS_NOTIF) {
              must = (lys_restr *)node[1].dsc;
              must_size = node->padding[1];
            }
            else if (LVar2 < (LYS_CONTAINER|LYS_NOTIF)) {
              if (LVar2 < (LYS_CONTAINER|LYS_ANYXML)) {
                if ((LVar2 != LYS_UNKNOWN) && (true)) {
                  switch(LVar2) {
                  case LYS_CONTAINER:
                    when = (lys_when *)node[1].name;
                    must = (lys_restr *)node[1].dsc;
                    must_size = node->padding[1];
                    break;
                  case LYS_CHOICE:
                    when = *(lys_when **)node->hash;
                    break;
                  case LYS_LEAF:
                    when = (lys_when *)node[1].name;
                    must = (lys_restr *)node[1].dsc;
                    must_size = node->padding[3];
                    break;
                  case LYS_LEAFLIST:
                    when = (lys_when *)node[1].name;
                    must = (lys_restr *)node[1].dsc;
                    must_size = node->padding[3];
                    break;
                  case LYS_LIST:
                    when = (lys_when *)node[1].name;
                    must = (lys_restr *)node[1].dsc;
                    must_size = node->padding[0];
                    break;
                  case LYS_ANYXML:
                    goto switchD_001e0591_caseD_20;
                  }
                }
              }
              else if (LVar2 == LYS_CASE) {
                when = *(lys_when **)node->hash;
              }
            }
          }
        }
      }
    }
  }
  plVar6 = node;
  if (set_ext_dep_flags != 0) {
    while ((parent = plVar6, parent != (lys_node *)0x0 &&
           ((parent->nodetype & 0x4180) == LYS_UNKNOWN))) {
      plVar6 = lys_parent(parent);
    }
  }
  if (when != (lys_when *)0x0) {
    iVar5 = lyxp_atomize(when->cond,node,LYXP_NODE_ELEM,&tmp_set,opts | 0x10,&ctx_snode);
    if (iVar5 != 0) {
      free(tmp_set.val.nodes);
      if (ctx_snode == (lys_node *)0x0) {
        ly_vlog(node->module->ctx,LYE_SPEC,LY_VLOG_LYS,node,"Invalid when condition \"%s\".",
                when->cond);
      }
      else {
        path = lys_path(ctx_snode,1);
        ly_vlog(node->module->ctx,LYE_SPEC,LY_VLOG_LYS,node,
                "Invalid when condition \"%s\" with context node \"%s\".",when->cond,path);
      }
      ret = -1;
      goto LAB_001e0fe0;
    }
    if (set_ext_dep_flags != 0) {
      for (j = 0; j < tmp_set.used; j = j + 1) {
        if (tmp_set.val.nodes[j].type == LYXP_NODE_ELEM) {
          plVar6 = (tmp_set.val.nodes[j].node)->schema;
          plVar7 = lys_node_module((lys_node *)tmp_set.val.nodes[j].node);
          uVar1 = *(uint16_t *)&(tmp_set.val.nodes[j].node)->next;
          pcVar4 = node->name;
          plVar8 = lys_node_module(node);
          iVar5 = lyp_check_status(node->flags,plVar8,pcVar4,uVar1,plVar7,(char *)plVar6,node);
          if (iVar5 != 0) {
            ret = -1;
            goto LAB_001e0fe0;
          }
          if (parent != (lys_node *)0x0) {
            for (elem = (lys_node *)tmp_set.val.nodes[j].node;
                (elem != (lys_node *)0x0 && (elem != parent)); elem = lys_parent(elem)) {
            }
            if (elem == (lys_node *)0x0) {
              if ((*(ushort *)&(tmp_set.val.nodes[j].node)->next & 1) == 0) {
                if ((*(ushort *)&(tmp_set.val.nodes[j].node)->next & 2) == 0) {
                    // WARNING: Subroutine does not return
                  __assert_fail("tmp_set.val.snodes[j].snode->flags & LYS_CONFIG_R",
                                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                                ,0x2355,"lyxp_node_atomize");
                }
                when->flags = when->flags | 0x400;
                node->flags = node->flags | 0x400;
              }
              else {
                when->flags = when->flags | 0x200;
                node->flags = node->flags | 0x200;
              }
            }
          }
        }
      }
    }
    set_snode_merge(set,&tmp_set);
    memset(&tmp_set,0,0x40);
  }
  for (i = 0; i < must_size; i = i + 1) {
    iVar5 = lyxp_atomize(must[i].expr,node,LYXP_NODE_ELEM,&tmp_set,opts | 8,&ctx_snode);
    if (iVar5 != 0) {
      free(tmp_set.val.nodes);
      if (ctx_snode == (lys_node *)0x0) {
        ly_vlog(node->module->ctx,LYE_SPEC,LY_VLOG_LYS,node,"Invalid must restriction \"%s\".",
                must[i].expr);
      }
      else {
        path = lys_path(ctx_snode,1);
        ly_vlog(node->module->ctx,LYE_SPEC,LY_VLOG_LYS,node,
                "Invalid must restriction \"%s\" with context node \"%s\".",must[i].expr,path);
      }
      ret = -1;
      break;
    }
    if (set_ext_dep_flags != 0) {
      for (j = 0; j < tmp_set.used; j = j + 1) {
        if (tmp_set.val.nodes[j].type == LYXP_NODE_ELEM) {
          plVar6 = (tmp_set.val.nodes[j].node)->schema;
          plVar7 = lys_node_module((lys_node *)tmp_set.val.nodes[j].node);
          uVar1 = *(uint16_t *)&(tmp_set.val.nodes[j].node)->next;
          pcVar4 = node->name;
          plVar8 = lys_node_module(node);
          iVar5 = lyp_check_status(node->flags,plVar8,pcVar4,uVar1,plVar7,(char *)plVar6,node);
          if (iVar5 != 0) {
            ret = -1;
            goto LAB_001e0fe0;
          }
          if (parent != (lys_node *)0x0) {
            for (elem = (lys_node *)tmp_set.val.nodes[j].node;
                (elem != (lys_node *)0x0 && (elem != parent)); elem = lys_parent(elem)) {
            }
            if (elem == (lys_node *)0x0) {
              if ((*(ushort *)&(tmp_set.val.nodes[j].node)->next & 1) == 0) {
                if ((*(ushort *)&(tmp_set.val.nodes[j].node)->next & 2) == 0) {
                  for (elem = (lys_node *)tmp_set.val.nodes[j].node;
                      (elem != (lys_node *)0x0 && (elem->nodetype != LYS_AUGMENT));
                      elem = elem->parent) {
                  }
                  if ((elem == (lys_node *)0x0) ||
                     (plVar7 = lys_node_module(elem), (plVar7->field_0x40 & 0x80) != 0)) {
                    // WARNING: Subroutine does not return
                    __assert_fail("elem && !lys_node_module(elem)->implemented",
                                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/xpath.c"
                                  ,0x238c,"lyxp_node_atomize");
                  }
                }
                else {
                  must[i].flags = must[i].flags | 0x400;
                  node->flags = node->flags | 0x400;
                }
              }
              else {
                must[i].flags = must[i].flags | 0x200;
                node->flags = node->flags | 0x200;
              }
            }
          }
        }
      }
    }
    set_snode_merge(set,&tmp_set);
    memset(&tmp_set,0,0x40);
  }
LAB_001e0fe0:
  if (ret != 0) {
    free((set->val).nodes);
    memset(set,0,0x40);
  }
  free(path);
  if (lVar3 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyxp_node_check_syntax(lys_node *node)

{
  ushort uVar1;
  LYS_NODE LVar2;
  char *pcVar3;
  int iVar4;
  char *pcVar5;
  long in_FS_OFFSET;
  lys_node *node_local;
  uint8_t must_size;
  uint16_t exp_idx;
  uint32_t i;
  lys_when *when;
  lys_restr *must;
  lyxp_expr *expr;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  must_size = '\0';
  when = (lys_when *)0x0;
  must = (lys_restr *)0x0;
  LVar2 = node->nodetype;
  if (LVar2 == LYS_ANYDATA) {
switchD_001e113d_caseD_20:
    when = (lys_when *)node[1].name;
    must = (lys_restr *)node[1].dsc;
    must_size = node->padding[3];
  }
  else if (LVar2 < (LYS_CONTAINER|LYS_ANYDATA)) {
    if (LVar2 == LYS_AUGMENT) {
      when = (lys_when *)node->next;
    }
    else if (LVar2 < (LYS_CONTAINER|LYS_AUGMENT)) {
      if (LVar2 == LYS_USES) {
        when = *(lys_when **)node->hash;
      }
      else if (LVar2 < (LYS_CONTAINER|LYS_USES)) {
        if (LVar2 == LYS_OUTPUT) {
LAB_001e124b:
          must = (lys_restr *)node[1].name;
          must_size = node->padding[1];
        }
        else if (LVar2 < (LYS_CONTAINER|LYS_OUTPUT)) {
          if (LVar2 == LYS_INPUT) goto LAB_001e124b;
          if (LVar2 < (LYS_CONTAINER|LYS_INPUT)) {
            if (LVar2 == LYS_NOTIF) {
              must = (lys_restr *)node[1].dsc;
              must_size = node->padding[1];
            }
            else if (LVar2 < (LYS_CONTAINER|LYS_NOTIF)) {
              if (LVar2 < (LYS_CONTAINER|LYS_ANYXML)) {
                if ((LVar2 != LYS_UNKNOWN) && (true)) {
                  switch(LVar2) {
                  case LYS_CONTAINER:
                    when = (lys_when *)node[1].name;
                    must = (lys_restr *)node[1].dsc;
                    must_size = node->padding[1];
                    break;
                  case LYS_CHOICE:
                    when = *(lys_when **)node->hash;
                    break;
                  case LYS_LEAF:
                    when = (lys_when *)node[1].name;
                    must = (lys_restr *)node[1].dsc;
                    must_size = node->padding[3];
                    break;
                  case LYS_LEAFLIST:
                    when = (lys_when *)node[1].name;
                    must = (lys_restr *)node[1].dsc;
                    must_size = node->padding[3];
                    break;
                  case LYS_LIST:
                    when = (lys_when *)node[1].name;
                    must = (lys_restr *)node[1].dsc;
                    must_size = node->padding[0];
                    break;
                  case LYS_ANYXML:
                    goto switchD_001e113d_caseD_20;
                  }
                }
              }
              else if (LVar2 == LYS_CASE) {
                when = *(lys_when **)node->hash;
              }
            }
          }
        }
      }
    }
  }
  if (when != (lys_when *)0x0) {
    expr = lyxp_parse_expr(node->module->ctx,when->cond);
    if (expr == (lyxp_expr *)0x0) {
      iVar4 = -1;
      goto LAB_001e14fa;
    }
    exp_idx = 0;
    iVar4 = reparse_or_expr(node->module->ctx,expr,&exp_idx);
    if (iVar4 != 0) {
      lyxp_expr_free(expr);
      iVar4 = -1;
      goto LAB_001e14fa;
    }
    if (expr->used != exp_idx) {
      pcVar3 = expr->expr;
      uVar1 = expr->expr_pos[exp_idx];
      pcVar5 = print_token(expr->tokens[exp_idx]);
      ly_vlog(node->module->ctx,LYE_XPATH_INTOK,LY_VLOG_NONE,(void *)0x0,pcVar5,pcVar3 + uVar1);
      lyxp_expr_free(expr);
      iVar4 = -1;
      goto LAB_001e14fa;
    }
    lyxp_expr_free(expr);
  }
  for (i = 0; i < must_size; i = i + 1) {
    expr = lyxp_parse_expr(node->module->ctx,must[i].expr);
    if (expr == (lyxp_expr *)0x0) {
      iVar4 = -1;
      goto LAB_001e14fa;
    }
    exp_idx = 0;
    iVar4 = reparse_or_expr(node->module->ctx,expr,&exp_idx);
    if (iVar4 != 0) {
      lyxp_expr_free(expr);
      iVar4 = -1;
      goto LAB_001e14fa;
    }
    if (expr->used != exp_idx) {
      pcVar3 = expr->expr;
      uVar1 = expr->expr_pos[exp_idx];
      pcVar5 = print_token(expr->tokens[exp_idx]);
      ly_vlog(node->module->ctx,LYE_XPATH_INTOK,LY_VLOG_NONE,(void *)0x0,pcVar5,pcVar3 + uVar1);
      lyxp_expr_free(expr);
      iVar4 = -1;
      goto LAB_001e14fa;
    }
    lyxp_expr_free(expr);
  }
  iVar4 = 0;
LAB_001e14fa:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void yang_encode(lyout *out,char *text,int len)

{
  char cVar1;
  size_t sVar2;
  int len_local;
  char *text_local;
  lyout *out_local;
  char special;
  int i;
  int start_len;
  char *start;
  
  special = '\0';
  if (len != 0) {
    len_local = len;
    if (len < 0) {
      sVar2 = strlen(text);
      len_local = (int)sVar2;
    }
    start_len = 0;
    start = text;
    for (i = 0; i < len_local; i = i + 1) {
      cVar1 = text[i];
      if (cVar1 == '\\') goto LAB_001e1598;
      if (cVar1 < ']') {
        if (cVar1 < '\v') {
          if (cVar1 < '\t') goto LAB_001e15ad;
        }
        else if (cVar1 != '\"') goto LAB_001e15ad;
LAB_001e1598:
        special = text[i];
      }
      else {
LAB_001e15ad:
        start_len = start_len + 1;
      }
      if (special != '\0') {
        ly_write(out,start,(long)start_len);
        if (special == '\\') {
          ly_write(out,"\\\\",2);
        }
        else if (special < ']') {
          if (special == '\"') {
            ly_write(out,"\\\"",2);
          }
          else if (special < '#') {
            if (special == '\t') {
              ly_write(out,"\\t",2);
            }
            else if (special == '\n') {
              ly_write(out,"\\n",2);
            }
          }
        }
        start = start + (long)start_len + 1;
        start_len = 0;
        special = '\0';
      }
    }
    ly_write(out,start,(long)start_len);
  }
  return;
}



void yang_print_open(lyout *out,int *flag)

{
  int *flag_local;
  lyout *out_local;
  
  if ((flag != (int *)0x0) && (*flag == 0)) {
    *flag = 1;
    ly_print(out," {\n");
  }
  return;
}



void yang_print_close(lyout *out,int level,int flag)

{
  int flag_local;
  int level_local;
  lyout *out_local;
  
  if (flag == 0) {
    ly_print(out,";\n");
  }
  else {
    ly_print(out,"%*s}\n",(ulong)(uint)(level * 2),&DAT_0022cd50);
  }
  return;
}



void yang_print_text(lyout *out,int level,char *name,char *text,int singleline,int closed)

{
  char *pcVar1;
  size_t sVar2;
  int closed_local;
  char *text_local;
  char *name_local;
  int singleline_local;
  int level_local;
  lyout *out_local;
  char *t;
  char *s;
  
  t = text;
  if (singleline == 0) {
    ly_print(out,"%*s%s\n",(ulong)(uint)(level * 2),&DAT_0022cd50,name);
    level_local = level + 1;
    ly_print(out,"%*s\"",(ulong)(uint)(level_local * 2),&DAT_0022cd50);
  }
  else {
    ly_print(out,"%*s%s \"",(ulong)(uint)(level * 2),&DAT_0022cd50,name);
    level_local = level;
  }
  while (pcVar1 = strchr(t,10), pcVar1 != (char *)0x0) {
    yang_encode(out,t,(int)pcVar1 - (int)t);
    ly_print(out,"\n");
    t = pcVar1 + 1;
    if (*t != '\n') {
      ly_print(out,"%*s ",(ulong)(uint)(level_local * 2),&DAT_0022cd50);
    }
  }
  sVar2 = strlen(t);
  yang_encode(out,t,(int)sVar2);
  if (closed == 0) {
    ly_print(out,"\"");
  }
  else {
    ly_print(out,"\";\n");
  }
  return;
}



void yang_print_substmt(lyout *out,int level,LYEXT_SUBSTMT substmt,uint8_t substmt_index,char *text,
                       lys_module *module,lys_ext_instance **ext,uint ext_size)

{
  undefined *puVar1;
  lys_module *module_local;
  char *text_local;
  uint8_t substmt_index_local;
  LYEXT_SUBSTMT substmt_local;
  int level_local;
  lyout *out_local;
  int i;
  
  i = -1;
  if (text != (char *)0x0) {
    do {
      i = lys_ext_iter(ext,(uint8_t)ext_size,(char)i + '\x01',substmt);
      if (i == -1) break;
    } while (substmt_index != ext[i]->insubstmt_index);
    if ((*(uint *)(ext_substmt_info + (long)substmt * 0x18 + 0x10) & 2) == 0) {
      yang_print_text(out,level,*(char **)(ext_substmt_info + (long)substmt * 0x18),text,
                      (uint)((*(uint *)(ext_substmt_info + (long)substmt * 0x18 + 0x10) & 1) == 0),
                      (uint)(i == -1));
    }
    else {
      if (i == -1) {
        puVar1 = &DAT_0022cd57;
      }
      else {
        puVar1 = &DAT_0022cd50;
      }
      ly_print(out,"%*s%s %s%s",(ulong)(uint)(level * 2),&DAT_0022cd50,
               *(undefined8 *)(ext_substmt_info + (long)substmt * 0x18),text,puVar1);
    }
    if (i != -1) {
      ly_print(out," {\n");
      do {
        yang_print_extension_instances(out,level + 1,module,substmt,substmt_index,ext + i,1);
        do {
          i = lys_ext_iter(ext,(uint8_t)ext_size,(char)i + '\x01',substmt);
          if (i == -1) break;
        } while (substmt_index != ext[i]->insubstmt_index);
      } while (i != -1);
      ly_print(out,"%*s}\n",(ulong)(uint)(level * 2),&DAT_0022cd50);
    }
  }
  return;
}



void yang_print_iffeature(lyout *out,int level,lys_module *module,lys_iffeature *iffeature)

{
  lys_iffeature *iffeature_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  
  ly_print(out,"%*sif-feature \"",(ulong)(uint)(level * 2),&DAT_0022cd50);
  ly_print_iffeature(out,module,iffeature,0);
  if (iffeature->ext_size == '\0') {
    ly_print(out,"\";\n");
  }
  else {
    ly_print(out,"\" {\n");
    yang_print_extension_instances
              (out,level + 1,module,LYEXT_SUBSTMT_SELF,'\0',iffeature->ext,(uint)iffeature->ext_size
              );
    ly_print(out,"%*s}\n",(ulong)(uint)(level * 2),&DAT_0022cd50);
  }
  return;
}



void yang_print_snode_common
               (lyout *out,int level,lys_node *node,lys_module *module,int *flag,int mask)

{
  int iVar1;
  lys_node *plVar2;
  int *flag_local;
  lys_module *module_local;
  lys_node *node_local;
  int mask_local;
  int level_local;
  lyout *out_local;
  int i;
  char *status;
  
  status = (char *)0x0;
  if (((mask & 1U) != 0) && (node->ext_size != '\0')) {
    yang_print_open(out,flag);
    yang_print_extension_instances
              (out,level,module,LYEXT_SUBSTMT_SELF,'\0',node->ext,(uint)node->ext_size);
  }
  if ((mask & 2U) != 0) {
    for (i = 0; i < (int)(uint)node->iffeature_size; i = i + 1) {
      yang_print_open(out,flag);
      yang_print_iffeature(out,level,module,node->iffeature + i);
    }
  }
  if ((mask & 4U) != 0) {
    iVar1 = lys_ext_iter(node->ext,node->ext_size,'\0',LYEXT_SUBSTMT_CONFIG);
    plVar2 = lys_parent(node);
    if (plVar2 == (lys_node *)0x0) {
      if ((node->flags & 2) == 0) {
        if (iVar1 != -1) {
          yang_print_open(out,flag);
          yang_print_substmt(out,level,LYEXT_SUBSTMT_CONFIG,'\0',"true",module,node->ext,
                             (uint)node->ext_size);
        }
      }
      else {
        yang_print_open(out,flag);
        yang_print_substmt(out,level,LYEXT_SUBSTMT_CONFIG,'\0',"false",module,node->ext,
                           (uint)node->ext_size);
      }
    }
    else if (((node->flags & 4) != 0) || (iVar1 != -1)) {
      if ((node->flags & 1) == 0) {
        if ((node->flags & 2) != 0) {
          yang_print_open(out,flag);
          yang_print_substmt(out,level,LYEXT_SUBSTMT_CONFIG,'\0',"false",module,node->ext,
                             (uint)node->ext_size);
        }
      }
      else {
        yang_print_open(out,flag);
        yang_print_substmt(out,level,LYEXT_SUBSTMT_CONFIG,'\0',"true",module,node->ext,
                           (uint)node->ext_size);
      }
    }
  }
  if (((mask & 8U) != 0) && ((node->nodetype & (LYS_CHOICE|LYS_LEAF|LYS_ANYDATA)) != LYS_UNKNOWN)) {
    if ((node->flags & 0x40) == 0) {
      if ((node->flags & 0x80) != 0) {
        yang_print_open(out,flag);
        yang_print_substmt(out,level,LYEXT_SUBSTMT_MANDATORY,'\0',"false",module,node->ext,
                           (uint)node->ext_size);
      }
    }
    else {
      yang_print_open(out,flag);
      yang_print_substmt(out,level,LYEXT_SUBSTMT_MANDATORY,'\0',"true",module,node->ext,
                         (uint)node->ext_size);
    }
  }
  if ((mask & 0x10U) != 0) {
    if ((node->flags & 8) == 0) {
      if ((node->flags & 0x10) == 0) {
        if ((node->flags & 0x20) != 0) {
          yang_print_open(out,flag);
          status = "obsolete";
        }
      }
      else {
        yang_print_open(out,flag);
        status = "deprecated";
      }
    }
    else {
      yang_print_open(out,flag);
      status = "current";
    }
    yang_print_substmt(out,level,LYEXT_SUBSTMT_STATUS,'\0',status,module,node->ext,
                       (uint)node->ext_size);
  }
  if (((mask & 0x20U) != 0) && (node->dsc != (char *)0x0)) {
    yang_print_open(out,flag);
    yang_print_substmt(out,level,LYEXT_SUBSTMT_DESCRIPTION,'\0',node->dsc,module,node->ext,
                       (uint)node->ext_size);
  }
  if (((mask & 0x40U) != 0) && (node->ref != (char *)0x0)) {
    yang_print_open(out,flag);
    yang_print_substmt(out,level,LYEXT_SUBSTMT_REFERENCE,'\0',node->ref,module,node->ext,
                       (uint)node->ext_size);
  }
  return;
}



void yang_print_feature(lyout *out,int level,lys_feature *feat)

{
  long in_FS_OFFSET;
  lys_feature *feat_local;
  int level_local;
  lyout *out_local;
  int flag;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  ly_print(out,"%*sfeature %s",(ulong)(uint)(level * 2),&DAT_0022cd50,feat->name);
  yang_print_snode_common(out,level + 1,(lys_node *)feat,feat->module,&flag,0x73);
  yang_print_close(out,level,flag);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_extension(lyout *out,int level,lys_ext *ext)

{
  int level_00;
  int iVar1;
  char *text;
  long in_FS_OFFSET;
  lys_ext *ext_local;
  int level_local;
  lyout *out_local;
  int flag;
  int flag2;
  int i;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  flag2 = 0;
  ly_print(out,"%*sextension %s",(ulong)(uint)(level * 2),&DAT_0022cd50,ext->name);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,(lys_node *)ext,ext->module,&flag,1);
  if (ext->argument == (char *)0x0) goto LAB_001e24f1;
  yang_print_open(out,&flag);
  ly_print(out,"%*sargument %s",(ulong)(uint)(level_00 * 2),&DAT_0022cd50,ext->argument);
  i = -1;
  while( true ) {
    i = lys_ext_iter(ext->ext,ext->ext_size,(char)i + '\x01',LYEXT_SUBSTMT_ARGUMENT);
    if (i == -1) break;
    yang_print_open(out,&flag2);
    yang_print_extension_instances
              (out,level + 2,ext->module,LYEXT_SUBSTMT_ARGUMENT,'\0',ext->ext + i,1);
  }
  if ((ext->flags & 1) == 0) {
    iVar1 = lys_ext_iter(ext->ext,ext->ext_size,'\0',LYEXT_SUBSTMT_YINELEM);
    if (iVar1 != -1) goto LAB_001e2468;
  }
  else {
LAB_001e2468:
    yang_print_open(out,&flag2);
    if ((ext->flags & 1) == 0) {
      text = "false";
    }
    else {
      text = "true";
    }
    yang_print_substmt(out,level + 2,LYEXT_SUBSTMT_YINELEM,'\0',text,ext->module,ext->ext,
                       (uint)ext->ext_size);
  }
  yang_print_close(out,level_00,flag2);
LAB_001e24f1:
  yang_print_snode_common(out,level_00,(lys_node *)ext,ext->module,&flag,0x70);
  yang_print_close(out,level,flag);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_restr(lyout *out,int level,lys_module *module,lys_restr *restr,char *name,
                     char *value)

{
  int level_00;
  long in_FS_OFFSET;
  char *value_local;
  char *name_local;
  lys_restr *restr_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  int flag;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  ly_print(out,"%*s%s \"",(ulong)(uint)(level * 2),&DAT_0022cd50,name);
  yang_encode(out,value,-1);
  ly_print(out,"\"");
  level_00 = level + 1;
  if (restr->ext_size != '\0') {
    yang_print_open(out,&flag);
    yang_print_extension_instances
              (out,level_00,module,LYEXT_SUBSTMT_SELF,'\0',restr->ext,(uint)restr->ext_size);
  }
  if (*restr->expr == '\x15') {
    yang_print_open(out,&flag);
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_MODIFIER,'\0',"invert-match",module,restr->ext,
                       (uint)restr->ext_size);
  }
  if (restr->emsg != (char *)0x0) {
    yang_print_open(out,&flag);
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_ERRMSG,'\0',restr->emsg,module,restr->ext,
                       (uint)restr->ext_size);
  }
  if (restr->eapptag != (char *)0x0) {
    yang_print_open(out,&flag);
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_ERRTAG,'\0',restr->eapptag,module,restr->ext,
                       (uint)restr->ext_size);
  }
  if (restr->dsc != (char *)0x0) {
    yang_print_open(out,&flag);
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_DESCRIPTION,'\0',restr->dsc,module,restr->ext,
                       (uint)restr->ext_size);
  }
  if (restr->ref != (char *)0x0) {
    yang_print_open(out,&flag);
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_REFERENCE,'\0',restr->ref,module,restr->ext,
                       (uint)restr->ext_size);
  }
  yang_print_close(out,level,flag);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_when(lyout *out,int level,lys_module *module,lys_when *when)

{
  int level_00;
  long in_FS_OFFSET;
  lys_when *when_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  int flag;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  str = transform_json2schema(module,when->cond);
  if (str == (char *)0x0) {
    ly_print(out,"(!error!)");
  }
  else {
    ly_print(out,"%*swhen \"",(ulong)(uint)(level * 2),&DAT_0022cd50);
    yang_encode(out,str,-1);
    ly_print(out,"\"");
    lydict_remove(module->ctx,str);
    level_00 = level + 1;
    if (when->ext_size != '\0') {
      yang_print_open(out,&flag);
      yang_print_extension_instances
                (out,level_00,module,LYEXT_SUBSTMT_SELF,'\0',when->ext,(uint)when->ext_size);
    }
    if (when->dsc != (char *)0x0) {
      yang_print_open(out,&flag);
      yang_print_substmt(out,level_00,LYEXT_SUBSTMT_DESCRIPTION,'\0',when->dsc,module,when->ext,
                         (uint)when->ext_size);
    }
    if (when->ref != (char *)0x0) {
      yang_print_open(out,&flag);
      yang_print_substmt(out,level_00,LYEXT_SUBSTMT_REFERENCE,'\0',when->ref,module,when->ext,
                         (uint)when->ext_size);
    }
    yang_print_close(out,level,flag);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_unsigned(lyout *out,int level,LYEXT_SUBSTMT substmt,uint8_t substmt_index,
                        lys_module *module,lys_ext_instance **ext,uint ext_size,uint attr_value)

{
  int iVar1;
  long in_FS_OFFSET;
  lys_ext_instance **ext_local;
  lys_module *module_local;
  uint8_t substmt_index_local;
  LYEXT_SUBSTMT substmt_local;
  int level_local;
  lyout *out_local;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = asprintf(&str,"%u",(ulong)attr_value);
  if (iVar1 == -1) {
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_print_unsigned");
  }
  else {
    yang_print_substmt(out,level,substmt,substmt_index,str,module,ext,ext_size);
    free(str);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_signed(lyout *out,int level,LYEXT_SUBSTMT substmt,uint8_t substmt_index,
                      lys_module *module,lys_ext_instance **ext,uint ext_size,int attr_value)

{
  int iVar1;
  long in_FS_OFFSET;
  lys_ext_instance **ext_local;
  lys_module *module_local;
  uint8_t substmt_index_local;
  LYEXT_SUBSTMT substmt_local;
  int level_local;
  lyout *out_local;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = asprintf(&str,"%d",(ulong)(uint)attr_value);
  if (iVar1 == -1) {
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yang_print_signed");
  }
  else {
    yang_print_substmt(out,level,substmt,substmt_index,str,module,ext,ext_size);
    free(str);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}


/*
Unable to decompile 'yang_print_type'
Cause: Exception while decompiling 001e2c23: process: timeout

*/


void yang_print_must(lyout *out,int level,lys_module *module,lys_restr *must)

{
  char *value;
  lys_restr *must_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  char *str;
  
  value = transform_json2schema(module,must->expr);
  if (value == (char *)0x0) {
    ly_print(out,"(!error!)");
  }
  else {
    yang_print_restr(out,level,module,must,"must",value);
    lydict_remove(module->ctx,value);
  }
  return;
}



void yang_print_unique(lyout *out,int level,lys_module *module,lys_unique *uniq)

{
  char *value;
  undefined *puVar1;
  lys_unique *uniq_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  int i;
  char *str;
  
  ly_print(out,"%*sunique \"",(ulong)(uint)(level * 2),&DAT_0022cd50);
  for (i = 0; i < (int)(uint)uniq->expr_size; i = i + 1) {
    value = transform_json2schema(module,uniq->expr[i]);
    if (i + 1 < (int)(uint)uniq->expr_size) {
      puVar1 = &DAT_0022cef1;
    }
    else {
      puVar1 = &DAT_0022cd50;
    }
    ly_print(out,"%s%s",value,puVar1);
    lydict_remove(module->ctx,value);
  }
  ly_print(out,"\"");
  return;
}



void yang_print_refine(lyout *out,int level,lys_module *module,lys_refine *refine)

{
  int level_00;
  long in_FS_OFFSET;
  lys_refine *refine_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  int flag;
  int i;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  str = transform_json2schema(module,refine->target_name);
  ly_print(out,"%*srefine \"%s\"",(ulong)(uint)(level * 2),&DAT_0022cd50,str);
  lydict_remove(module->ctx,str);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,(lys_node *)refine,module,&flag,3);
  for (i = 0; i < (int)(uint)refine->must_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_must(out,level_00,module,refine->must + i);
  }
  if (refine->target_type == 1) {
    yang_print_open(out,&flag);
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_PRESENCE,'\0',(refine->mod).presence,module,
                       refine->ext,(uint)refine->ext_size);
  }
  for (i = 0; i < (int)(uint)refine->dflt_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_DEFAULT,(uint8_t)i,refine->dflt[i],module,
                       refine->ext,(uint)refine->ext_size);
  }
  if ((refine->flags & 1) == 0) {
    if ((refine->flags & 2) != 0) {
      yang_print_open(out,&flag);
      yang_print_substmt(out,level_00,LYEXT_SUBSTMT_CONFIG,'\0',"false",module,refine->ext,
                         (uint)refine->ext_size);
    }
  }
  else {
    yang_print_open(out,&flag);
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_CONFIG,'\0',"true",module,refine->ext,
                       (uint)refine->ext_size);
  }
  if ((refine->flags & 0x40) == 0) {
    if ((refine->flags & 0x80) != 0) {
      yang_print_open(out,&flag);
      yang_print_substmt(out,level_00,LYEXT_SUBSTMT_MANDATORY,'\0',"false",module,refine->ext,
                         (uint)refine->ext_size);
    }
  }
  else {
    yang_print_open(out,&flag);
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_MANDATORY,'\0',"true",module,refine->ext,
                       (uint)refine->ext_size);
  }
  if ((refine->target_type & 0x18) != 0) {
    if ((refine->flags & 0x10) != 0) {
      yang_print_open(out,&flag);
      yang_print_unsigned(out,level_00,LYEXT_SUBSTMT_MIN,'\0',module,refine->ext,
                          (uint)refine->ext_size,(refine->mod).list.min);
    }
    if ((refine->flags & 8) != 0) {
      yang_print_open(out,&flag);
      if ((refine->mod).list.max == 0) {
        yang_print_substmt(out,level_00,LYEXT_SUBSTMT_MAX,'\0',"unbounded",module,refine->ext,
                           (uint)refine->ext_size);
      }
      else {
        yang_print_unsigned(out,level_00,LYEXT_SUBSTMT_MAX,'\0',module,refine->ext,
                            (uint)refine->ext_size,(refine->mod).list.max);
      }
    }
  }
  yang_print_snode_common(out,level_00,(lys_node *)refine,module,&flag,0x60);
  yang_print_close(out,level,flag);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_deviation(lyout *out,int level,lys_module *module,lys_deviation *deviation)

{
  int level_00;
  int level_01;
  char *value;
  lys_deviation *deviation_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  int i;
  int j;
  int p;
  char *str;
  
  value = transform_json2schema(module,deviation->target_name);
  ly_print(out,"%*sdeviation \"%s\" {\n",(ulong)(uint)(level * 2),&DAT_0022cd50,value);
  lydict_remove(module->ctx,value);
  level_00 = level + 1;
  if (deviation->ext_size != '\0') {
    yang_print_extension_instances
              (out,level_00,module,LYEXT_SUBSTMT_SELF,'\0',deviation->ext,(uint)deviation->ext_size)
    ;
  }
  yang_print_substmt(out,level_00,LYEXT_SUBSTMT_DESCRIPTION,'\0',deviation->dsc,module,
                     deviation->ext,(uint)deviation->ext_size);
  yang_print_substmt(out,level_00,LYEXT_SUBSTMT_REFERENCE,'\0',deviation->ref,module,deviation->ext,
                     (uint)deviation->ext_size);
  i = 0;
  do {
    if ((int)(uint)deviation->deviate_size <= i) {
      ly_print(out,"%*s}\n",(ulong)(uint)(level * 2),&DAT_0022cd50);
      return;
    }
    ly_print(out,"%*sdeviate ",(ulong)(uint)(level_00 * 2),&DAT_0022cd50);
    if (deviation->deviate[i].mod == LY_DEVIATE_NO) {
      if (deviation->deviate[i].ext_size != '\0') {
        ly_print(out,"not-supported {\n");
        goto LAB_001e41ec;
      }
      ly_print(out,"not-supported;\n");
    }
    else {
      if (deviation->deviate[i].mod == LY_DEVIATE_ADD) {
        ly_print(out,"add {\n");
      }
      else if (deviation->deviate[i].mod == LY_DEVIATE_RPL) {
        ly_print(out,"replace {\n");
      }
      else if (deviation->deviate[i].mod == LY_DEVIATE_DEL) {
        ly_print(out,"delete {\n");
      }
LAB_001e41ec:
      level_01 = level + 2;
      if (deviation->deviate[i].ext_size != '\0') {
        yang_print_extension_instances
                  (out,level_01,module,LYEXT_SUBSTMT_SELF,'\0',deviation->deviate[i].ext,
                   (uint)deviation->deviate[i].ext_size);
      }
      if (deviation->deviate[i].type != (lys_type *)0x0) {
        yang_print_type(out,level_01,module,deviation->deviate[i].type);
      }
      yang_print_substmt(out,level_01,LYEXT_SUBSTMT_UNITS,'\0',deviation->deviate[i].units,module,
                         deviation->deviate[i].ext,(uint)deviation->deviate[i].ext_size);
      for (j = 0; j < (int)(uint)deviation->deviate[i].must_size; j = j + 1) {
        yang_print_must(out,level_01,module,deviation->deviate[i].must + j);
      }
      for (j = 0; j < (int)(uint)deviation->deviate[i].unique_size; j = j + 1) {
        yang_print_unique(out,level_01,module,deviation->deviate[i].unique + j);
        p = -1;
        do {
          p = lys_ext_iter(deviation->deviate[i].ext,deviation->deviate[i].ext_size,(char)p + '\x01'
                           ,LYEXT_SUBSTMT_UNIQUE);
          if (p == -1) break;
        } while (j != (uint)deviation->deviate[i].ext[p]->insubstmt_index);
        if (p == -1) {
          ly_print(out,";\n");
        }
        else {
          ly_print(out," {\n");
          do {
            yang_print_extension_instances
                      (out,level + 3,module,LYEXT_SUBSTMT_UNIQUE,(uint8_t)j,
                       deviation->deviate[i].ext + p,1);
            do {
              p = lys_ext_iter(deviation->deviate[i].ext,deviation->deviate[i].ext_size,
                               (char)p + '\x01',LYEXT_SUBSTMT_UNIQUE);
              if (p == -1) break;
            } while (j != (uint)deviation->deviate[i].ext[p]->insubstmt_index);
          } while (p != -1);
          ly_print(out,"%*s}\n",(ulong)(uint)(level_01 * 2),&DAT_0022cd50);
        }
      }
      for (j = 0; j < (int)(uint)deviation->deviate[i].dflt_size; j = j + 1) {
        yang_print_substmt(out,level_01,LYEXT_SUBSTMT_DEFAULT,(uint8_t)j,
                           deviation->deviate[i].dflt[j],module,deviation->deviate[i].ext,
                           (uint)deviation->deviate[i].ext_size);
      }
      if ((deviation->deviate[i].flags & 1) == 0) {
        if ((deviation->deviate[i].flags & 2) != 0) {
          yang_print_substmt(out,level_01,LYEXT_SUBSTMT_CONFIG,'\0',"false",module,
                             deviation->deviate->ext,(uint)deviation->deviate[i].ext_size);
        }
      }
      else {
        yang_print_substmt(out,level_01,LYEXT_SUBSTMT_CONFIG,'\0',"true",module,
                           deviation->deviate->ext,(uint)deviation->deviate[i].ext_size);
      }
      if ((deviation->deviate[i].flags & 0x40) == 0) {
        if ((char)deviation->deviate[i].flags < '\0') {
          yang_print_substmt(out,level_01,LYEXT_SUBSTMT_MANDATORY,'\0',"false",module,
                             deviation->deviate[i].ext,(uint)deviation->deviate[i].ext_size);
        }
      }
      else {
        yang_print_substmt(out,level_01,LYEXT_SUBSTMT_MANDATORY,'\0',"true",module,
                           deviation->deviate[i].ext,(uint)deviation->deviate[i].ext_size);
      }
      if (deviation->deviate[i].min_set != '\0') {
        yang_print_unsigned(out,level_01,LYEXT_SUBSTMT_MIN,'\0',module,deviation->deviate[i].ext,
                            (uint)deviation->deviate[i].ext_size,deviation->deviate[i].min);
      }
      if (deviation->deviate[i].max_set != '\0') {
        if (deviation->deviate[i].max == 0) {
          yang_print_substmt(out,level_01,LYEXT_SUBSTMT_MAX,'\0',"unbounded",module,
                             deviation->deviate[i].ext,(uint)deviation->deviate[i].ext_size);
        }
        else {
          yang_print_unsigned(out,level_01,LYEXT_SUBSTMT_MAX,'\0',module,deviation->deviate[i].ext,
                              (uint)deviation->deviate[i].ext_size,deviation->deviate[i].max);
        }
      }
      ly_print(out,"%*s}\n",(ulong)(uint)(level_00 * 2),&DAT_0022cd50);
    }
    i = i + 1;
  } while( true );
}



void yang_print_augment(lyout *out,int level,lys_node_augment *augment)

{
  int level_00;
  char *value;
  lys_node_augment *augment_local;
  int level_local;
  lyout *out_local;
  lys_node *sub;
  char *str;
  
  value = transform_json2schema(augment->module,augment->target_name);
  ly_print(out,"%*saugment \"%s\" {\n",(ulong)(uint)(level * 2),&DAT_0022cd50,value);
  lydict_remove(augment->module->ctx,value);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,(lys_node *)augment,augment->module,(int *)0x0,1);
  if (augment->when != (lys_when *)0x0) {
    yang_print_when(out,level_00,augment->module,augment->when);
  }
  yang_print_snode_common(out,level_00,(lys_node *)augment,augment->module,(int *)0x0,0x72);
  for (sub = augment->child; sub != (lys_node *)0x0; sub = sub->next) {
    if ((lys_node *)augment == sub->parent) {
      yang_print_snode(out,level_00,sub,0xd0ff);
    }
  }
  ly_print(out,"%*s}\n",(ulong)(uint)(level * 2),&DAT_0022cd50);
  return;
}



void yang_print_typedef(lyout *out,int level,lys_module *module,lys_tpdf *tpdf)

{
  int level_00;
  int iVar1;
  char *pcVar2;
  lys_tpdf *tpdf_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  char *dflt;
  
  ly_print(out,"%*stypedef %s {\n",(ulong)(uint)(level * 2),&DAT_0022cd50,tpdf->name);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,(lys_node *)tpdf,module,(int *)0x0,1);
  yang_print_type(out,level_00,module,&tpdf->type);
  if (tpdf->units != (char *)0x0) {
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_UNITS,'\0',tpdf->units,module,tpdf->ext,
                       (uint)tpdf->ext_size);
  }
  if (tpdf->dflt != (char *)0x0) {
    if ((tpdf->flags & 0x1000) == 0) {
      dflt = tpdf->dflt;
    }
    else {
      pcVar2 = strchr(tpdf->dflt,0x3a);
      if (pcVar2 == (char *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("strchr(tpdf->dflt, \':\')",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_yang.c"
                      ,0x380,"yang_print_typedef");
      }
      pcVar2 = strchr(tpdf->dflt,0x3a);
      iVar1 = strncmp(tpdf->dflt,module->name,(long)pcVar2 - (long)tpdf->dflt);
      if (iVar1 == 0) {
        pcVar2 = strchr(tpdf->dflt,0x3a);
        dflt = lydict_insert(module->ctx,pcVar2 + 1,0);
      }
      else {
        dflt = transform_json2schema(module,tpdf->dflt);
      }
    }
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_DEFAULT,'\0',dflt,module,tpdf->ext,
                       (uint)tpdf->ext_size);
    if ((tpdf->flags & 0x1000) != 0) {
      lydict_remove(module->ctx,dflt);
    }
  }
  yang_print_snode_common(out,level_00,(lys_node *)tpdf,module,(int *)0x0,0x70);
  ly_print(out,"%*s}\n",(ulong)(uint)(level * 2),&DAT_0022cd50);
  return;
}



void yang_print_identity(lyout *out,int level,lys_ident *ident)

{
  int level_00;
  char *pcVar1;
  int iVar2;
  lys_module *plVar3;
  char *pcVar4;
  long in_FS_OFFSET;
  lys_ident *ident_local;
  int level_local;
  lyout *out_local;
  int flag;
  int i;
  char *str;
  lys_module *mod;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  ly_print(out,"%*sidentity %s",(ulong)(uint)(level * 2),&DAT_0022cd50,ident->name);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,(lys_node *)ident,ident->module,&flag,3);
  i = 0;
  do {
    if ((int)(uint)ident->base_size <= i) {
      yang_print_snode_common(out,level_00,(lys_node *)ident,ident->module,&flag,0x70);
      yang_print_close(out,level,flag);
LAB_001e5301:
      if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return;
    }
    yang_print_open(out,&flag);
    mod = lys_main_module(ident->base[i]->module);
    plVar3 = lys_main_module(ident->module);
    if (mod == plVar3) {
      yang_print_substmt(out,level_00,LYEXT_SUBSTMT_BASE,(uint8_t)i,ident->base[i]->name,
                         ident->module,ident->ext,(uint)ident->ext_size);
    }
    else {
      pcVar1 = ident->base[i]->name;
      pcVar4 = transform_module_name2import_prefix(ident->module,mod->name);
      iVar2 = asprintf(&str,"%s:%s",pcVar4,pcVar1);
      if (iVar2 == -1) {
        ly_log(ident->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "yang_print_identity");
        goto LAB_001e5301;
      }
      yang_print_substmt(out,level_00,LYEXT_SUBSTMT_BASE,(uint8_t)i,str,ident->module,ident->ext,
                         (uint)ident->ext_size);
      free(str);
    }
    i = i + 1;
  } while( true );
}



void yang_print_container(lyout *out,int level,lys_node *node)

{
  int level_00;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int flag;
  int i;
  lys_node *sub;
  lys_node_container *cont;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  cont = (lys_node_container *)node;
  ly_print(out,"%*scontainer %s",(ulong)(uint)(level * 2),&DAT_0022cd50,node->name);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,node,node->module,&flag,1);
  if (cont->when != (lys_when *)0x0) {
    yang_print_open(out,&flag);
    yang_print_when(out,level_00,node->module,cont->when);
  }
  for (i = 0; i < (int)(uint)cont->iffeature_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_iffeature(out,level_00,node->module,cont->iffeature + i);
  }
  for (i = 0; i < (int)(uint)cont->must_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_must(out,level_00,node->module,cont->must + i);
  }
  if (cont->presence != (char *)0x0) {
    yang_print_open(out,&flag);
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_PRESENCE,'\0',cont->presence,node->module,
                       node->ext,(uint)node->ext_size);
  }
  yang_print_snode_common(out,level_00,node,node->module,&flag,0x74);
  for (i = 0; i < (int)(uint)cont->tpdf_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_typedef(out,level_00,node->module,cont->tpdf + i);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yang_print_open(out,&flag);
      yang_print_snode(out,level_00,sub,0x800);
    }
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yang_print_open(out,&flag);
      yang_print_snode(out,level_00,sub,0x903f);
    }
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yang_print_open(out,&flag);
      yang_print_snode(out,level_00,sub,0x4000);
    }
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yang_print_open(out,&flag);
      yang_print_snode(out,level_00,sub,0x80);
    }
  }
  yang_print_close(out,level,flag);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_case(lyout *out,int level,lys_node *node)

{
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int flag;
  lys_node *sub;
  lys_node_case *cas;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  cas = (lys_node_case *)node;
  if ((node->flags & 0x40) == 0) {
    ly_print(out,"%*scase %s",(ulong)(uint)(level * 2),&DAT_0022cd50,node->name);
    level_local = level + 1;
    yang_print_snode_common(out,level_local,node,node->module,&flag,1);
    if (cas->when != (lys_when *)0x0) {
      yang_print_open(out,&flag);
      yang_print_when(out,level_local,node->module,cas->when);
    }
    yang_print_snode_common(out,level_local,node,node->module,&flag,0x72);
  }
  else {
    flag = 1;
    level_local = level;
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yang_print_open(out,&flag);
      yang_print_snode(out,level_local,sub,0x903f);
    }
  }
  if ((node->flags & 0x40) == 0) {
    yang_print_close(out,level_local + -1,flag);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_choice(lyout *out,int level,lys_node *node)

{
  int level_00;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int flag;
  int i;
  lys_node *sub;
  lys_node_choice *choice;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  choice = (lys_node_choice *)node;
  ly_print(out,"%*schoice %s",(ulong)(uint)(level * 2),&DAT_0022cd50,node->name);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,node,node->module,&flag,1);
  if (choice->when != (lys_when *)0x0) {
    yang_print_open(out,&flag);
    yang_print_when(out,level_00,node->module,choice->when);
  }
  for (i = 0; i < (int)(uint)choice->iffeature_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_iffeature(out,level_00,node->module,choice->iffeature + i);
  }
  if (choice->dflt != (lys_node *)0x0) {
    yang_print_open(out,&flag);
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_DEFAULT,'\0',choice->dflt->name,node->module,
                       node->ext,(uint)node->ext_size);
  }
  yang_print_snode_common(out,level_00,node,node->module,&flag,0x7c);
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yang_print_open(out,&flag);
      yang_print_snode(out,level_00,sub,0x807f);
    }
  }
  yang_print_close(out,level,flag);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_leaf(lyout *out,int level,lys_node *node)

{
  int level_00;
  lys_node *plVar1;
  int iVar2;
  char *pcVar3;
  lys_module *plVar4;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int i;
  char *dflt;
  lys_node_leaf *leaf;
  
  ly_print(out,"%*sleaf %s {\n",(ulong)(uint)(level * 2),&DAT_0022cd50,node->name);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,node,node->module,(int *)0x0,1);
  if (node[1].name != (char *)0x0) {
    yang_print_when(out,level_00,node->module,(lys_when *)node[1].name);
  }
  for (i = 0; i < (int)(uint)node->iffeature_size; i = i + 1) {
    yang_print_iffeature(out,level_00,node->module,node->iffeature + i);
  }
  yang_print_type(out,level_00,node->module,(lys_type *)&node[1].ref);
  yang_print_substmt(out,level_00,LYEXT_SUBSTMT_UNITS,'\0',(char *)node[1].next,node->module,
                     node->ext,(uint)node->ext_size);
  for (i = 0; i < (int)(uint)node->padding[3]; i = i + 1) {
    yang_print_must(out,level_00,node->module,(lys_restr *)(node[1].dsc + (long)i * 0x38));
  }
  if (node[1].prev != (lys_node *)0x0) {
    if ((node->flags & 0x1000) == 0) {
      dflt = (char *)node[1].prev;
    }
    else {
      pcVar3 = strchr((char *)node[1].prev,0x3a);
      if (pcVar3 == (char *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("strchr(leaf->dflt, \':\')",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_yang.c"
                      ,0x470,"yang_print_leaf");
      }
      pcVar3 = strchr((char *)node[1].prev,0x3a);
      plVar1 = node[1].prev;
      plVar4 = lys_node_module(node);
      iVar2 = strncmp((char *)node[1].prev,plVar4->name,(long)pcVar3 - (long)plVar1);
      if (iVar2 == 0) {
        pcVar3 = strchr((char *)node[1].prev,0x3a);
        dflt = lydict_insert(node->module->ctx,pcVar3 + 1,0);
      }
      else {
        dflt = transform_json2schema(node->module,(char *)node[1].prev);
      }
    }
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_DEFAULT,'\0',dflt,node->module,node->ext,
                       (uint)node->ext_size);
    if ((node->flags & 0x1000) != 0) {
      lydict_remove(node->module->ctx,dflt);
    }
  }
  yang_print_snode_common(out,level_00,node,node->module,(int *)0x0,0x7c);
  ly_print(out,"%*s}\n",(ulong)(uint)(level * 2),&DAT_0022cd50);
  return;
}



void yang_print_anydata(lyout *out,int level,lys_node *node)

{
  int iVar1;
  lys_node *plVar2;
  char *pcVar3;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int flag;
  int i;
  lys_node_anydata *any;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  any = (lys_node_anydata *)node;
  plVar2 = lys_parent(node);
  if (plVar2 == (lys_node *)0x0) {
    iVar1 = strcmp(node->name,"config");
    if (iVar1 == 0) {
      iVar1 = strcmp(node->module->name,"ietf-netconf");
      if (iVar1 == 0) goto LAB_001e612c;
    }
  }
  if (any->nodetype == LYS_ANYXML) {
    pcVar3 = "anyxml";
  }
  else {
    pcVar3 = "anydata";
  }
  ly_print(out,"%*s%s %s",(ulong)(uint)(level * 2),&DAT_0022cd50,pcVar3,any->name);
  iVar1 = level + 1;
  yang_print_snode_common(out,iVar1,node,node->module,&flag,1);
  if (any->when != (lys_when *)0x0) {
    yang_print_open(out,&flag);
    yang_print_when(out,iVar1,node->module,any->when);
  }
  for (i = 0; i < (int)(uint)any->iffeature_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_iffeature(out,iVar1,node->module,any->iffeature + i);
  }
  for (i = 0; i < (int)(uint)any->must_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_must(out,iVar1,node->module,any->must + i);
  }
  yang_print_snode_common(out,iVar1,node,node->module,&flag,0x7c);
  yang_print_close(out,level,flag);
LAB_001e612c:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_leaflist(lyout *out,int level,lys_node *node)

{
  int level_00;
  long lVar1;
  int iVar2;
  char *pcVar3;
  lys_module *plVar4;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int i;
  char *dflt;
  lys_node_leaflist *llist;
  
  ly_print(out,"%*sleaf-list %s {\n",(ulong)(uint)(level * 2),&DAT_0022cd50,node->name);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,node,node->module,(int *)0x0,1);
  if (node[1].name != (char *)0x0) {
    yang_print_when(out,level_00,node->module,(lys_when *)node[1].name);
  }
  for (i = 0; i < (int)(uint)node->iffeature_size; i = i + 1) {
    yang_print_iffeature(out,level_00,node->module,node->iffeature + i);
  }
  yang_print_type(out,level_00,node->module,(lys_type *)&node[1].ref);
  yang_print_substmt(out,level_00,LYEXT_SUBSTMT_UNITS,'\0',(char *)node[1].next,node->module,
                     node->ext,(uint)node->ext_size);
  for (i = 0; i < (int)(uint)node->padding[3]; i = i + 1) {
    yang_print_must(out,level_00,node->module,(lys_restr *)(node[1].dsc + (long)i * 0x38));
  }
  i = 0;
  do {
    if ((int)(uint)node->padding[2] <= i) {
      yang_print_snode_common(out,level_00,node,node->module,(int *)0x0,4);
      if (*(int *)&node[1].priv != 0) {
        yang_print_unsigned(out,level_00,LYEXT_SUBSTMT_MIN,'\0',node->module,node->ext,
                            (uint)node->ext_size,*(uint *)&node[1].priv);
      }
      if (*(int *)((long)&node[1].priv + 4) != 0) {
        yang_print_unsigned(out,level_00,LYEXT_SUBSTMT_MAX,'\0',node->module,node->ext,
                            (uint)node->ext_size,*(uint *)((long)&node[1].priv + 4));
      }
      if ((node->flags & 0x100) == 0) {
        iVar2 = lys_ext_iter(node->ext,node->ext_size,'\0',LYEXT_SUBSTMT_ORDEREDBY);
        if (iVar2 != -1) {
          yang_print_substmt(out,level_00,LYEXT_SUBSTMT_ORDEREDBY,'\0',"system",node->module,
                             node->ext,(uint)node->ext_size);
        }
      }
      else {
        yang_print_substmt(out,level_00,LYEXT_SUBSTMT_ORDEREDBY,'\0',"user",node->module,node->ext,
                           (uint)node->ext_size);
      }
      yang_print_snode_common(out,level_00,node,node->module,(int *)0x0,0x70);
      ly_print(out,"%*s}\n",(ulong)(uint)(level * 2),&DAT_0022cd50);
      return;
    }
    if ((node->flags & 0x1000) == 0) {
      dflt = *(char **)((node[1].prev)->padding + (long)i * 8 + -0x1c);
    }
    else {
      pcVar3 = strchr(*(char **)((node[1].prev)->padding + (long)i * 8 + -0x1c),0x3a);
      if (pcVar3 == (char *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("strchr(llist->dflt[i], \':\')",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_yang.c"
                      ,0x4bf,"yang_print_leaflist");
      }
      pcVar3 = strchr(*(char **)((node[1].prev)->padding + (long)i * 8 + -0x1c),0x3a);
      lVar1 = *(long *)((node[1].prev)->padding + (long)i * 8 + -0x1c);
      plVar4 = lys_node_module(node);
      iVar2 = strncmp(*(char **)((node[1].prev)->padding + (long)i * 8 + -0x1c),plVar4->name,
                      (long)pcVar3 - lVar1);
      if (iVar2 == 0) {
        pcVar3 = strchr(*(char **)((node[1].prev)->padding + (long)i * 8 + -0x1c),0x3a);
        dflt = lydict_insert(node->module->ctx,pcVar3 + 1,0);
      }
      else {
        dflt = transform_json2schema
                         (node->module,*(char **)((node[1].prev)->padding + (long)i * 8 + -0x1c));
      }
    }
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_DEFAULT,(uint8_t)i,dflt,node->module,node->ext,
                       (uint)node->ext_size);
    if ((node->flags & 0x1000) != 0) {
      lydict_remove(node->module->ctx,dflt);
    }
    i = i + 1;
  } while( true );
}



void yang_print_list(lyout *out,int level,lys_node *node)

{
  int level_00;
  int iVar1;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int flag;
  int i;
  int p;
  lys_node *sub;
  lys_node_list *list;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  list = (lys_node_list *)node;
  ly_print(out,"%*slist %s",(ulong)(uint)(level * 2),&DAT_0022cd50,node->name);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,node,node->module,&flag,1);
  if (list->when != (lys_when *)0x0) {
    yang_print_open(out,&flag);
    yang_print_when(out,level_00,list->module,list->when);
  }
  for (i = 0; i < (int)(uint)list->iffeature_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_iffeature(out,level_00,node->module,list->iffeature + i);
  }
  for (i = 0; i < (int)(uint)list->must_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_must(out,level_00,list->module,list->must + i);
  }
  if (list->keys_size != '\0') {
    yang_print_open(out,&flag);
    yang_print_substmt(out,level_00,LYEXT_SUBSTMT_KEY,'\0',list->keys_str,node->module,node->ext,
                       (uint)node->ext_size);
  }
  i = 0;
  do {
    if ((int)(uint)list->unique_size <= i) {
      yang_print_snode_common(out,level_00,node,node->module,&flag,4);
      if (list->min != 0) {
        yang_print_open(out,&flag);
        yang_print_unsigned(out,level_00,LYEXT_SUBSTMT_MIN,'\0',node->module,node->ext,
                            (uint)node->ext_size,list->min);
      }
      if (list->max != 0) {
        yang_print_open(out,&flag);
        yang_print_unsigned(out,level_00,LYEXT_SUBSTMT_MAX,'\0',node->module,node->ext,
                            (uint)node->ext_size,list->max);
      }
      if ((list->flags & 0x100) == 0) {
        iVar1 = lys_ext_iter(node->ext,node->ext_size,'\0',LYEXT_SUBSTMT_ORDEREDBY);
        if (iVar1 != -1) {
          yang_print_open(out,&flag);
          yang_print_substmt(out,level_00,LYEXT_SUBSTMT_ORDEREDBY,'\0',"system",node->module,
                             node->ext,(uint)node->ext_size);
        }
      }
      else {
        yang_print_open(out,&flag);
        yang_print_substmt(out,level_00,LYEXT_SUBSTMT_ORDEREDBY,'\0',"user",node->module,node->ext,
                           (uint)node->ext_size);
      }
      yang_print_snode_common(out,level_00,node,node->module,&flag,0x70);
      for (i = 0; i < (int)(uint)list->tpdf_size; i = i + 1) {
        yang_print_open(out,&flag);
        yang_print_typedef(out,level_00,list->module,list->tpdf + i);
      }
      for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
        if (node == sub->parent) {
          yang_print_open(out,&flag);
          yang_print_snode(out,level_00,sub,0x800);
        }
      }
      for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
        if (node == sub->parent) {
          yang_print_open(out,&flag);
          yang_print_snode(out,level_00,sub,0x903f);
        }
      }
      for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
        if (node == sub->parent) {
          yang_print_open(out,&flag);
          yang_print_snode(out,level_00,sub,0x4000);
        }
      }
      for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
        if (node == sub->parent) {
          yang_print_open(out,&flag);
          yang_print_snode(out,level_00,sub,0x80);
        }
      }
      yang_print_close(out,level,flag);
      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return;
    }
    yang_print_open(out,&flag);
    yang_print_unique(out,level_00,node->module,list->unique + i);
    p = -1;
    do {
      p = lys_ext_iter(list->ext,list->ext_size,(char)p + '\x01',LYEXT_SUBSTMT_UNIQUE);
      if (p == -1) break;
    } while (i != (uint)list->ext[p]->insubstmt_index);
    if (p == -1) {
      ly_print(out,";\n");
    }
    else {
      ly_print(out," {\n");
      do {
        yang_print_extension_instances
                  (out,level + 2,list->module,LYEXT_SUBSTMT_UNIQUE,(uint8_t)i,list->ext + p,1);
        do {
          p = lys_ext_iter(list->ext,list->ext_size,(char)p + '\x01',LYEXT_SUBSTMT_UNIQUE);
          if (p == -1) break;
        } while (i != (uint)list->ext[p]->insubstmt_index);
      } while (p != -1);
      ly_print(out,"%*s}\n",(ulong)(uint)(level_00 * 2),&DAT_0022cd50);
    }
    i = i + 1;
  } while( true );
}



void yang_print_grouping(lyout *out,int level,lys_node *node)

{
  int level_00;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int flag;
  int i;
  lys_node *sub;
  lys_node_grp *grp;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  grp = (lys_node_grp *)node;
  ly_print(out,"%*sgrouping %s",(ulong)(uint)(level * 2),&DAT_0022cd50,node->name);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,node,node->module,&flag,0x71);
  for (i = 0; i < (int)(uint)grp->tpdf_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_typedef(out,level_00,node->module,grp->tpdf + i);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    yang_print_open(out,&flag);
    yang_print_snode(out,level_00,sub,0x800);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    yang_print_open(out,&flag);
    yang_print_snode(out,level_00,sub,0x903f);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    yang_print_open(out,&flag);
    yang_print_snode(out,level_00,sub,0x4000);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    yang_print_open(out,&flag);
    yang_print_snode(out,level_00,sub,0x80);
  }
  yang_print_close(out,level,flag);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_uses(lyout *out,int level,lys_node *node)

{
  int level_00;
  lys_module *plVar1;
  char *pcVar2;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int flag;
  int i;
  lys_node_uses *uses;
  lys_module *mod;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  uses = (lys_node_uses *)node;
  ly_print(out,"%*suses ",(ulong)(uint)(level * 2),&DAT_0022cd50);
  if (node->child != (lys_node *)0x0) {
    mod = lys_node_module(node->child);
    plVar1 = lys_node_module(node);
    if (mod != plVar1) {
      pcVar2 = transform_module_name2import_prefix(node->module,mod->name);
      ly_print(out,"%s:",pcVar2);
    }
  }
  ly_print(out,"%s",uses->name);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,node,node->module,&flag,1);
  if (uses->when != (lys_when *)0x0) {
    yang_print_open(out,&flag);
    yang_print_when(out,level_00,node->module,uses->when);
  }
  yang_print_snode_common(out,level_00,node,node->module,&flag,0x72);
  for (i = 0; i < (int)(uint)uses->refine_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_refine(out,level_00,node->module,uses->refine + i);
  }
  for (i = 0; i < (int)(uint)uses->augment_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_augment(out,level_00,uses->augment + i);
  }
  yang_print_close(out,level,flag);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_input_output(lyout *out,int level,lys_node *node)

{
  int level_00;
  char *pcVar1;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int i;
  lys_node *sub;
  lys_node_inout *inout;
  
  if (node->nodetype == LYS_INPUT) {
    pcVar1 = "input";
  }
  else {
    pcVar1 = "output";
  }
  ly_print(out,"%*s%s {\n",(ulong)(uint)(level * 2),&DAT_0022cd50,pcVar1);
  level_00 = level + 1;
  if (node->ext_size != '\0') {
    yang_print_extension_instances
              (out,level_00,node->module,LYEXT_SUBSTMT_SELF,'\0',node->ext,(uint)node->ext_size);
  }
  for (i = 0; i < (int)(uint)node->padding[1]; i = i + 1) {
    yang_print_must(out,level_00,node->module,(lys_restr *)(node[1].name + (long)i * 0x38));
  }
  for (i = 0; i < (int)(uint)*(ushort *)(node->padding + 2); i = i + 1) {
    yang_print_typedef(out,level_00,node->module,(lys_tpdf *)(*(long *)node->hash + (long)i * 0x80))
    ;
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yang_print_snode(out,level_00,sub,0x800);
    }
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yang_print_snode(out,level_00,sub,0x903f);
    }
  }
  ly_print(out,"%*s}\n",(ulong)(uint)(level * 2),&DAT_0022cd50);
  return;
}



void yang_print_rpc_action(lyout *out,int level,lys_node *node)

{
  int level_00;
  char *pcVar1;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int flag;
  int i;
  lys_node *sub;
  lys_node_rpc_action *rpc;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  if (node->nodetype == LYS_RPC) {
    pcVar1 = "rpc";
  }
  else {
    pcVar1 = "action";
  }
  rpc = (lys_node_rpc_action *)node;
  ly_print(out,"%*s%s %s",(ulong)(uint)(level * 2),&DAT_0022cd50,pcVar1,node->name);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,node,node->module,&flag,0x73);
  for (i = 0; i < (int)(uint)rpc->tpdf_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_typedef(out,level_00,node->module,rpc->tpdf + i);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if ((node == sub->parent) &&
       (((sub->nodetype & 0x600) == LYS_UNKNOWN || ((sub->flags & 0x40) == 0)))) {
      yang_print_open(out,&flag);
      yang_print_snode(out,level_00,sub,0xe00);
    }
  }
  yang_print_close(out,level,flag);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_notif(lyout *out,int level,lys_node *node)

{
  int level_00;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int flag;
  int i;
  lys_node *sub;
  lys_node_notif *notif;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  notif = (lys_node_notif *)node;
  ly_print(out,"%*snotification %s",(ulong)(uint)(level * 2),&DAT_0022cd50,node->name);
  level_00 = level + 1;
  yang_print_snode_common(out,level_00,node,node->module,&flag,3);
  for (i = 0; i < (int)(uint)notif->must_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_must(out,level_00,node->module,notif->must + i);
  }
  yang_print_snode_common(out,level_00,node,node->module,&flag,0x70);
  for (i = 0; i < (int)(uint)notif->tpdf_size; i = i + 1) {
    yang_print_open(out,&flag);
    yang_print_typedef(out,level_00,node->module,notif->tpdf + i);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yang_print_open(out,&flag);
      yang_print_snode(out,level_00,sub,0x800);
    }
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yang_print_open(out,&flag);
      yang_print_snode(out,level_00,sub,0x903f);
    }
  }
  yang_print_close(out,level,flag);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_snode(lyout *out,int level,lys_node *node,int mask)

{
  LYS_NODE LVar1;
  lys_node *node_local;
  int mask_local;
  int level_local;
  lyout *out_local;
  
  if ((mask & node->nodetype) != LYS_UNKNOWN) {
    if (((node->nodetype & 0x600) != LYS_UNKNOWN) && ((node->flags & 0x40) != 0)) {
      return;
    }
    if (((node->parent == (lys_node *)0x0) ||
        ((node->parent->nodetype == LYS_AUGMENT && (node != node->parent->child)))) ||
       ((node->parent->nodetype != LYS_AUGMENT && (node->prev->next != (lys_node *)0x0)))) {
      ly_print(out,"\n");
    }
  }
  LVar1 = mask & node->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_001e7b85_caseD_20:
    yang_print_anydata(out,level,node);
    return;
  }
  if (LYS_ANYDATA < LVar1) {
    return;
  }
  if (LVar1 == LYS_ACTION) {
LAB_001e7c77:
    yang_print_rpc_action(out,level,node);
  }
  else {
    if (LYS_ACTION < LVar1) {
      return;
    }
    if (LVar1 == LYS_USES) {
      yang_print_uses(out,level,node);
      return;
    }
    if (LYS_USES < LVar1) {
      return;
    }
    if (LVar1 == LYS_GROUPING) {
      yang_print_grouping(out,level,node);
      return;
    }
    if (LYS_GROUPING < LVar1) {
      return;
    }
    if (LVar1 != LYS_OUTPUT) {
      if (LYS_OUTPUT < LVar1) {
        return;
      }
      if (LVar1 != LYS_INPUT) {
        if (LYS_INPUT < LVar1) {
          return;
        }
        if (LVar1 != LYS_RPC) {
          if (LYS_RPC < LVar1) {
            return;
          }
          if (LVar1 == LYS_NOTIF) {
            yang_print_notif(out,level,node);
            return;
          }
          if (LYS_NOTIF < LVar1) {
            return;
          }
          if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
            if (LVar1 == LYS_UNKNOWN) {
              return;
            }
            if (true) {
              switch(LVar1) {
              case LYS_CONTAINER:
                yang_print_container(out,level,node);
                return;
              case LYS_CHOICE:
                yang_print_choice(out,level,node);
                return;
              default:
                return;
              case LYS_LEAF:
                yang_print_leaf(out,level,node);
                return;
              case LYS_LEAFLIST:
                yang_print_leaflist(out,level,node);
                return;
              case LYS_LIST:
                yang_print_list(out,level,node);
                return;
              case LYS_ANYXML:
                goto switchD_001e7b85_caseD_20;
              }
            }
            return;
          }
          if (LVar1 != LYS_CASE) {
            return;
          }
          yang_print_case(out,level,node);
          return;
        }
        goto LAB_001e7c77;
      }
    }
    yang_print_input_output(out,level,node);
  }
  return;
}



void yang_print_revision(lyout *out,int level,lys_module *module,lys_revision *rev)

{
  lys_revision *rev_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  
  if (((rev->dsc == (char *)0x0) && (rev->ref == (char *)0x0)) && (rev->ext_size == '\0')) {
    ly_print(out,"%*srevision %s;\n",(ulong)(uint)(level * 2),&DAT_0022cd50,rev);
  }
  else {
    ly_print(out,"%*srevision %s {\n",(ulong)(uint)(level * 2),&DAT_0022cd50,rev);
    yang_print_extension_instances
              (out,level + 1,module,LYEXT_SUBSTMT_SELF,'\0',rev->ext,(uint)rev->ext_size);
    yang_print_substmt(out,level + 1,LYEXT_SUBSTMT_DESCRIPTION,'\0',rev->dsc,module,rev->ext,
                       (uint)rev->ext_size);
    yang_print_substmt(out,level + 1,LYEXT_SUBSTMT_REFERENCE,'\0',rev->ref,module,rev->ext,
                       (uint)rev->ext_size);
    ly_print(out,"%*s}\n",(ulong)(uint)(level * 2),&DAT_0022cd50);
  }
  return;
}



int yang_print_model_(lyout *out,int level,lys_module *module)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  lys_module *plVar4;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  uint i;
  int p;
  lys_node *node;
  
  if ((module->field_0x40 & 1) == 0) {
    if ((module->field_0x40 & 0x30) == 0x10) {
      pcVar3 = " // DEVIATED";
    }
    else {
      pcVar3 = "";
    }
    ly_print(out,"%*smodule %s {%s\n",(ulong)(uint)(level * 2),&DAT_0022cd50,module->name,pcVar3);
    iVar1 = level + 1;
    if ((module->field_0x40 & 0xe) != 0) {
      if ((module->field_0x40 & 0xe) == 4) {
        pcVar3 = "1.1";
      }
      else {
        pcVar3 = "1";
      }
      yang_print_substmt(out,iVar1,LYEXT_SUBSTMT_VERSION,'\0',pcVar3,module,module->ext,
                         (uint)module->ext_size);
    }
    yang_print_substmt(out,iVar1,LYEXT_SUBSTMT_NAMESPACE,'\0',module->ns,module,module->ext,
                       (uint)module->ext_size);
    yang_print_substmt(out,iVar1,LYEXT_SUBSTMT_PREFIX,'\0',module->prefix,module,module->ext,
                       (uint)module->ext_size);
    goto LAB_001e81e8;
  }
  if ((module->field_0x40 & 0x30) == 0x10) {
    pcVar3 = " // DEVIATED";
  }
  else {
    pcVar3 = "";
  }
  ly_print(out,"%*ssubmodule %s {%s\n",(ulong)(uint)(level * 2),&DAT_0022cd50,module->name,pcVar3);
  iVar1 = level + 1;
  if ((module->field_0x40 & 0xe) == 0) {
    iVar2 = lys_ext_iter(module->ext,module->ext_size,'\0',LYEXT_SUBSTMT_VERSION);
    if (iVar2 != -1) goto LAB_001e7f10;
  }
  else {
LAB_001e7f10:
    if ((module->field_0x40 & 0xe) == 4) {
      pcVar3 = "1.1";
    }
    else {
      pcVar3 = "1";
    }
    yang_print_substmt(out,iVar1,LYEXT_SUBSTMT_VERSION,'\0',pcVar3,module,module->ext,
                       (uint)module->ext_size);
  }
  ly_print(out,"%*sbelongs-to %s {\n",(ulong)(uint)(iVar1 * 2),&DAT_0022cd50,module->data->dsc);
  p = -1;
  while( true ) {
    p = lys_ext_iter(module->ext,module->ext_size,(char)p + '\x01',LYEXT_SUBSTMT_BELONGSTO);
    if (p == -1) break;
    yang_print_extension_instances
              (out,level + 2,module,LYEXT_SUBSTMT_BELONGSTO,'\0',module->ext + p,1);
  }
  yang_print_substmt(out,level + 2,LYEXT_SUBSTMT_PREFIX,'\0',module->prefix,module,module->ext,
                     (uint)module->ext_size);
  ly_print(out,"%*s}\n",(ulong)(uint)(iVar1 * 2),&DAT_0022cd50);
LAB_001e81e8:
  level_local = level + 1;
  for (i = 0; i < module->imp_size; i = i + 1) {
    ly_print(out,"\n%*simport %s {\n",(ulong)(uint)(level_local * 2),&DAT_0022cd50,
             (module->imp[i].module)->name);
    iVar1 = level + 2;
    yang_print_extension_instances
              (out,iVar1,module,LYEXT_SUBSTMT_SELF,'\0',module->imp[i].ext,
               (uint)module->imp[i].ext_size);
    yang_print_substmt(out,iVar1,LYEXT_SUBSTMT_PREFIX,'\0',module->imp[i].prefix,module,
                       module->imp[i].ext,(uint)module->imp[i].ext_size);
    if (module->imp[i].rev[0] != '\0') {
      yang_print_substmt(out,iVar1,LYEXT_SUBSTMT_REVISIONDATE,'\0',module->imp[i].rev,module,
                         module->imp[i].ext,(uint)module->imp[i].ext_size);
    }
    yang_print_substmt(out,iVar1,LYEXT_SUBSTMT_DESCRIPTION,'\0',module->imp[i].dsc,module,
                       module->imp[i].ext,(uint)module->imp[i].ext_size);
    yang_print_substmt(out,iVar1,LYEXT_SUBSTMT_REFERENCE,'\0',module->imp[i].ref,module,
                       module->imp[i].ext,(uint)module->imp[i].ext_size);
    ly_print(out,"%*s}\n",(ulong)(uint)(level_local * 2),&DAT_0022cd50);
  }
  for (i = 0; i < module->inc_size; i = i + 1) {
    if ((((module->inc[i].rev[0] == '\0') && (module->inc[i].dsc == (char *)0x0)) &&
        (module->inc[i].ref == (char *)0x0)) && (module->inc[i].ext_size == '\0')) {
      ly_print(out,"\n%*sinclude \"%s\";\n",(ulong)(uint)(level_local * 2),&DAT_0022cd50,
               (module->inc[i].submodule)->name);
    }
    else {
      ly_print(out,"\n%*sinclude %s {\n",(ulong)(uint)(level_local * 2),&DAT_0022cd50,
               (module->inc[i].submodule)->name);
      iVar1 = level + 2;
      yang_print_extension_instances
                (out,iVar1,module,LYEXT_SUBSTMT_SELF,'\0',module->inc[i].ext,
                 (uint)module->inc[i].ext_size);
      if (module->inc[i].rev[0] != '\0') {
        yang_print_substmt(out,iVar1,LYEXT_SUBSTMT_REVISIONDATE,'\0',module->inc[i].rev,module,
                           module->inc[i].ext,(uint)module->inc[i].ext_size);
      }
      yang_print_substmt(out,iVar1,LYEXT_SUBSTMT_DESCRIPTION,'\0',module->inc[i].dsc,module,
                         module->inc[i].ext,(uint)module->inc[i].ext_size);
      yang_print_substmt(out,iVar1,LYEXT_SUBSTMT_REFERENCE,'\0',module->inc[i].ref,module,
                         module->inc[i].ext,(uint)module->inc[i].ext_size);
      ly_print(out,"%*s}\n",(ulong)(uint)(level_local * 2),&DAT_0022cd50);
    }
  }
  if (((module->org != (char *)0x0) || (module->contact != (char *)0x0)) ||
     ((module->dsc != (char *)0x0 || (module->ref != (char *)0x0)))) {
    ly_print(out,"\n");
  }
  yang_print_substmt(out,level_local,LYEXT_SUBSTMT_ORGANIZATION,'\0',module->org,module,module->ext,
                     (uint)module->ext_size);
  yang_print_substmt(out,level_local,LYEXT_SUBSTMT_CONTACT,'\0',module->contact,module,module->ext,
                     (uint)module->ext_size);
  yang_print_substmt(out,level_local,LYEXT_SUBSTMT_DESCRIPTION,'\0',module->dsc,module,module->ext,
                     (uint)module->ext_size);
  yang_print_substmt(out,level_local,LYEXT_SUBSTMT_REFERENCE,'\0',module->ref,module,module->ext,
                     (uint)module->ext_size);
  if (module->rev_size != '\0') {
    ly_print(out,"\n");
  }
  for (i = 0; i < module->rev_size; i = i + 1) {
    yang_print_revision(out,level_local,module,module->rev + i);
  }
  for (i = 0; i < module->extensions_size; i = i + 1) {
    ly_print(out,"\n");
    yang_print_extension(out,level_local,module->extensions + i);
  }
  if (module->ext_size != '\0') {
    ly_print(out,"\n");
    yang_print_extension_instances
              (out,level_local,module,LYEXT_SUBSTMT_SELF,'\0',module->ext,(uint)module->ext_size);
  }
  for (i = 0; i < module->features_size; i = i + 1) {
    ly_print(out,"\n");
    yang_print_feature(out,level_local,module->features + i);
  }
  for (i = 0; i < module->ident_size; i = i + 1) {
    ly_print(out,"\n");
    yang_print_identity(out,level_local,module->ident + i);
  }
  for (i = 0; i < module->tpdf_size; i = i + 1) {
    ly_print(out,"\n");
    yang_print_typedef(out,level_local,module,module->tpdf + i);
  }
  plVar4 = lys_main_module(module);
  for (node = plVar4->data; node != (lys_node *)0x0; node = node->next) {
    if (module == node->module) {
      yang_print_snode(out,level_local,node,0x800);
    }
  }
  plVar4 = lys_main_module(module);
  for (node = plVar4->data; node != (lys_node *)0x0; node = node->next) {
    if (module == node->module) {
      yang_print_snode(out,level_local,node,0x903f);
    }
  }
  for (i = 0; i < module->augment_size; i = i + 1) {
    ly_print(out,"\n");
    yang_print_augment(out,level_local,module->augment + i);
  }
  plVar4 = lys_main_module(module);
  for (node = plVar4->data; node != (lys_node *)0x0; node = node->next) {
    if (module == node->module) {
      yang_print_snode(out,level_local,node,0x4100);
    }
  }
  plVar4 = lys_main_module(module);
  for (node = plVar4->data; node != (lys_node *)0x0; node = node->next) {
    if (module == node->module) {
      yang_print_snode(out,level_local,node,0x80);
    }
  }
  for (i = 0; i < module->deviation_size; i = i + 1) {
    ly_print(out,"\n");
    yang_print_deviation(out,level_local,module,module->deviation + i);
  }
  ly_print(out,"%*s}\n",(ulong)(uint)(level * 2),&DAT_0022cd50);
  ly_print_flush(out);
  return 0;
}



int yang_print_model(lyout *out,lys_module *module)

{
  int iVar1;
  lys_module *module_local;
  lyout *out_local;
  
  iVar1 = yang_print_model_(out,0,module);
  return iVar1;
}



void yang_print_extcomplex_bool
               (lyout *out,int level,lys_module *module,lys_ext_instance_complex *ext,LY_STMT stmt,
               char *true_val,char *false_val,int *content)

{
  long in_FS_OFFSET;
  int *content_local;
  char *false_val_local;
  char *true_val_local;
  lys_ext_instance_complex *ext_local;
  lys_module *module_local;
  LY_STMT stmt_local;
  int level_local;
  lyout *out_local;
  lyext_substmt *info;
  uint8_t *val;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  val = (uint8_t *)lys_ext_complex_get_substmt(stmt,ext,&info);
  if ((val != (uint8_t *)0x0) && (*val != '\0')) {
    yang_print_open(out,content);
    if (*val == '\x01') {
      yang_print_substmt(out,level,stmt,'\0',true_val,module,ext->ext,(uint)ext->ext_size);
    }
    else if (*val == '\x02') {
      yang_print_substmt(out,level,stmt,'\0',false_val,module,ext->ext,(uint)ext->ext_size);
    }
    else {
      ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_yang.c"
             ,0x729);
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yang_print_extcomplex_str
               (lyout *out,int level,lys_module *module,lys_ext_instance_complex *ext,LY_STMT stmt,
               int *content)

{
  long in_FS_OFFSET;
  int *content_local;
  lys_ext_instance_complex *ext_local;
  lys_module *module_local;
  LY_STMT stmt_local;
  int level_local;
  lyout *out_local;
  int c;
  lyext_substmt *info;
  char **str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  str = (char **)lys_ext_complex_get_substmt(stmt,ext,&info);
  if ((str != (char **)0x0) && (*str != (char *)0x0)) {
    if (info->cardinality < LY_STMT_CARD_SOME) {
      yang_print_open(out,content);
      yang_print_substmt(out,level,stmt,'\0',*str,module,ext->ext,(uint)ext->ext_size);
    }
    else {
      str = (char **)*str;
      c = 0;
      for (; *str != (char *)0x0; str = str + 1) {
        yang_print_open(out,content);
        yang_print_substmt(out,level,stmt,(uint8_t)c,*str,module,ext->ext,(uint)ext->ext_size);
        c = c + 1;
      }
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void yang_print_extcomplex_flags
               (lyout *out,int level,lys_module *module,lys_ext_instance_complex *ext,LY_STMT stmt,
               char *val1_str,char *val2_str,uint16_t val1,uint16_t val2,int *content)

{
  int iVar1;
  ushort *puVar2;
  uint16_t val2_local;
  uint16_t val1_local;
  char *val1_str_local;
  lys_ext_instance_complex *ext_local;
  lys_module *module_local;
  LY_STMT stmt_local;
  int level_local;
  lyout *out_local;
  char *str;
  uint16_t *flags;
  
  puVar2 = (ushort *)lys_ext_complex_get_substmt(stmt,ext,(lyext_substmt **)0x0);
  if (puVar2 != (ushort *)0x0) {
    str = val1_str;
    if ((*puVar2 & val1) == 0) {
      if ((*puVar2 & val2) == 0) {
        iVar1 = lys_ext_iter(ext->ext,ext->ext_size,'\0',stmt);
        if (iVar1 == -1) {
          return;
        }
      }
      else {
        str = val2_str;
      }
    }
    yang_print_open(out,content);
    yang_print_substmt(out,level,stmt,'\0',str,module,ext->ext,(uint)ext->ext_size);
  }
  return;
}



void yang_print_extension_instances
               (lyout *out,int level,lys_module *module,LYEXT_SUBSTMT substmt,uint8_t substmt_index,
               lys_ext_instance **ext,uint count)

{
  int iVar1;
  int iVar2;
  LY_STMT LVar3;
  lys_module *plVar4;
  size_t sVar5;
  size_t sVar6;
  char *pcVar7;
  long in_FS_OFFSET;
  lys_ext_instance **ext_local;
  uint8_t substmt_index_local;
  lys_module *module_local;
  LYEXT_SUBSTMT substmt_local;
  int level_local;
  lyout *out_local;
  int content;
  int content2;
  uint u;
  uint x;
  int i;
  int j;
  int c;
  char *prefix;
  char *str;
  void **pp;
  lys_node *siter;
  lys_module *mod;
  char *ext_name;
  lyext_substmt *info;
  void *p;
  uint16_t *flags;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  prefix = (char *)0x0;
  u = 0;
  do {
    if (count <= u) {
      if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
        return;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    if (((((ext[u]->flags & 1) == 0) && (substmt == (uint)ext[u]->insubstmt)) &&
        (substmt_index == ext[u]->insubstmt_index)) &&
       ((ext[u]->def->module != *(module->ctx->models).list ||
        (((iVar1 = strcmp(ext[u]->arg_value,"operation"), iVar1 != 0 &&
          (iVar1 = strcmp(ext[u]->arg_value,"select"), iVar1 != 0)) &&
         (iVar1 = strcmp(ext[u]->arg_value,"type"), iVar1 != 0)))))) {
      mod = lys_main_module(ext[u]->def->module);
      plVar4 = lys_main_module(module);
      if (mod == plVar4) {
        prefix = module->prefix;
      }
      else {
        for (x = 0; x < module->imp_size; x = x + 1) {
          if (mod == module->imp[x].module) {
            prefix = module->imp[x].prefix;
            break;
          }
        }
      }
      if (ext[u]->arg_value == (char *)0x0) {
        ly_print(out,"%*s%s:%s",(ulong)(uint)(level * 2),&DAT_0022cd50,prefix,ext[u]->def->name);
      }
      else {
        sVar5 = strlen(prefix);
        sVar6 = strlen(ext[u]->def->name);
        ext_name = (char *)malloc(sVar6 + sVar5 + 2);
        sprintf(ext_name,"%s:%s",prefix,ext[u]->def->name);
        yang_print_text(out,level,ext_name,ext[u]->arg_value,1,0);
        free(ext_name);
      }
      content = 0;
      if (ext[u]->ext_size != '\0') {
        yang_print_open(out,&content);
        yang_print_extension_instances
                  (out,level + 1,module,LYEXT_SUBSTMT_SELF,'\0',ext[u]->ext,(uint)ext[u]->ext_size);
      }
      if (((ext[u]->ext_type != '\0') && (ext[u]->ext_type == '\x01')) &&
         (info = (lyext_substmt *)ext[u][1].def, (lys_ext *)info != (lys_ext *)0x0)) {
        iVar1 = level + 1;
        i = 0;
        while (info[i].stmt != LY_STMT_UNKNOWN) {
          if (true) {
            switch(info[i].stmt) {
            case LY_STMT_ARGUMENT:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_ARGUMENT,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                yang_print_open(out,&content);
                if (info->cardinality < LY_STMT_CARD_SOME) {
                  content2 = 0;
                  ly_print(out,"%*sargument %s",(ulong)(uint)(iVar1 * 2),&DAT_0022cd50,*pp);
                  j = -1;
                  while (j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                          LYEXT_SUBSTMT_ARGUMENT), j != -1) {
                    yang_print_open(out,&content2);
                    yang_print_extension_instances
                              (out,level + 2,module,LYEXT_SUBSTMT_ARGUMENT,'\0',ext[u]->ext + j,1);
                  }
                  if ((*(char *)(pp + 1) == '\x01') ||
                     (iVar2 = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,'\0',LYEXT_SUBSTMT_YINELEM),
                     iVar2 != -1)) {
                    yang_print_open(out,&content2);
                    if (*(char *)(pp + 1) == '\x01') {
                      pcVar7 = "true";
                    }
                    else {
                      pcVar7 = "false";
                    }
                    yang_print_substmt(out,level + 2,LYEXT_SUBSTMT_YINELEM,'\0',pcVar7,module,
                                       ext[u]->ext,(uint)ext[u]->ext_size);
                  }
                  yang_print_close(out,iVar1,content2);
                }
                else {
                  c = 0;
                  while (*(long *)((long)*pp + (long)c * 8) != 0) {
                    content2 = 0;
                    ly_print(out,"%*sargument %s",(ulong)(uint)(iVar1 * 2),&DAT_0022cd50,
                             *(undefined8 *)((long)*pp + (long)c * 8));
                    j = -1;
                    while (j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                            LYEXT_SUBSTMT_ARGUMENT), j != -1) {
                      if (c == (uint)ext[u]->ext[j]->insubstmt_index) {
                        yang_print_open(out,&content2);
                        yang_print_extension_instances
                                  (out,level + 2,module,LYEXT_SUBSTMT_ARGUMENT,(uint8_t)c,
                                   ext[u]->ext + j,1);
                      }
                    }
                    if (*(char *)((long)c + (long)pp[1]) == '\x01') {
                      yang_print_open(out,&content2);
                      if (*(char *)((long)c + (long)pp[1]) == '\x01') {
                        pcVar7 = "true";
                      }
                      else {
                        pcVar7 = "false";
                      }
                      yang_print_substmt(out,level + 2,LYEXT_SUBSTMT_YINELEM,(uint8_t)c,pcVar7,
                                         module,ext[u]->ext,(uint)ext[u]->ext_size);
                    }
                    else {
                      j = -1;
                      do {
                        j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                         LYEXT_SUBSTMT_YINELEM);
                        if (j == -1) goto LAB_001e9c93;
                      } while (c != (uint)ext[u]->ext[j]->insubstmt_index);
                      yang_print_open(out,&content2);
                      if (*(char *)((long)c + (long)pp[1]) == '\x01') {
                        pcVar7 = "true";
                      }
                      else {
                        pcVar7 = "false";
                      }
                      yang_print_substmt(out,level + 2,LYEXT_SUBSTMT_YINELEM,(uint8_t)c,pcVar7,
                                         module,ext[u]->ext + j,(uint)ext[u]->ext_size - j);
                    }
LAB_001e9c93:
                    yang_print_close(out,iVar1,content2);
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_BASE:
            case LY_STMT_CONTACT:
            case LY_STMT_DEFAULT:
            case LY_STMT_DESCRIPTION:
            case LY_STMT_ERRTAG:
            case LY_STMT_ERRMSG:
            case LY_STMT_KEY:
            case LY_STMT_NAMESPACE:
            case LY_STMT_ORGANIZATION:
            case LY_STMT_PATH:
            case LY_STMT_PREFIX:
            case LY_STMT_PRESENCE:
            case LY_STMT_REFERENCE:
            case LY_STMT_REVISIONDATE:
            case LY_STMT_UNITS:
              yang_print_extcomplex_str
                        (out,iVar1,module,(lys_ext_instance_complex *)ext[u],info[i].stmt,&content);
              break;
            case LY_STMT_BELONGSTO:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_BELONGSTO,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info->cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                  ly_print(out,"%*sbelongs-to %s {\n",(ulong)(uint)(iVar1 * 2),&DAT_0022cd50,*pp);
                  j = -1;
                  while (j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                          LYEXT_SUBSTMT_BELONGSTO), j != -1) {
                    yang_print_extension_instances
                              (out,level + 2,module,LYEXT_SUBSTMT_BELONGSTO,'\0',ext[u]->ext + j,1);
                  }
                  yang_print_substmt(out,level + 2,LYEXT_SUBSTMT_PREFIX,'\0',(char *)pp[1],module,
                                     ext[u]->ext,(uint)ext[u]->ext_size);
                  ly_print(out,"%*s}\n",(ulong)(uint)(iVar1 * 2),&DAT_0022cd50);
                }
                else {
                  c = 0;
                  while (*(long *)((long)*pp + (long)c * 8) != 0) {
                    yang_print_open(out,&content);
                    ly_print(out,"%*sbelongs-to %s {\n",(ulong)(uint)(iVar1 * 2),&DAT_0022cd50,
                             *(undefined8 *)((long)*pp + (long)c * 8));
                    j = -1;
                    while( true ) {
                      j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                       LYEXT_SUBSTMT_BELONGSTO);
                      if (j == -1) break;
                      yang_print_extension_instances
                                (out,level + 2,module,LYEXT_SUBSTMT_BELONGSTO,(uint8_t)c,
                                 ext[u]->ext + j,1);
                    }
                    yang_print_substmt(out,level + 2,LYEXT_SUBSTMT_PREFIX,(uint8_t)c,
                                       *(char **)((long)pp[1] + (long)c * 8),module,ext[u]->ext,
                                       (uint)ext[u]->ext_size);
                    ly_print(out,"%*s}\n",(ulong)(uint)(iVar1 * 2),&DAT_0022cd50);
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_VALUE:
              p = (void *)((long)&ext[u][1].parent + info[i].offset);
                    // WARNING: Load size is inaccurate
              if (((long *)p != (long *)0x0) && (*p != 0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                  yang_print_signed(out,iVar1,LYEXT_SUBSTMT_VALUE,'\0',module,ext[u]->ext,
                                    (uint)ext[u]->ext_size,**p);
                }
                else {
                  c = 0;
                    // WARNING: Load size is inaccurate
                  while (*(long *)(*p + (long)c * 8) != 0) {
                    yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                    yang_print_signed(out,iVar1,LYEXT_SUBSTMT_VALUE,(uint8_t)c,module,ext[u]->ext,
                                      (uint)ext[u]->ext_size,**(int **)(*p + (long)c * 8));
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_MODIFIER:
              yang_print_extcomplex_bool
                        (out,iVar1,module,(lys_ext_instance_complex *)ext[u],LY_STMT_MODIFIER,
                         "invert-match",(char *)0x0,&content);
              break;
            case LY_STMT_REQINSTANCE:
              yang_print_extcomplex_bool
                        (out,iVar1,module,(lys_ext_instance_complex *)ext[u],info[i].stmt,"true",
                         "false",&content);
              break;
            case LY_STMT_CONFIG:
              yang_print_extcomplex_flags
                        (out,iVar1,module,(lys_ext_instance_complex *)ext[u],LY_STMT_CONFIG,"true",
                         "false",5,6,&content);
              break;
            case LY_STMT_MANDATORY:
              yang_print_extcomplex_flags
                        (out,iVar1,module,(lys_ext_instance_complex *)ext[u],LY_STMT_MANDATORY,
                         "false","true",0x80,0x40,&content);
              break;
            case LY_STMT_ORDEREDBY:
              yang_print_extcomplex_flags
                        (out,iVar1,module,(lys_ext_instance_complex *)ext[u],LY_STMT_ORDEREDBY,
                         "system","user",0,0x100,&content);
              break;
            case LY_STMT_STATUS:
              flags = (uint16_t *)
                      lys_ext_complex_get_substmt
                                (LY_STMT_STATUS,(lys_ext_instance_complex *)ext[u],
                                 (lyext_substmt **)0x0);
              if ((flags != (ushort *)0x0) && (*flags != 0)) {
                if ((*flags & 8) == 0) {
                  if ((*flags & 0x10) == 0) {
                    if ((*flags & 0x20) == 0) break;
                    yang_print_open(out,&content);
                    str = "obsolete";
                  }
                  else {
                    yang_print_open(out,&content);
                    str = "deprecated";
                  }
                }
                else {
                  yang_print_open(out,&content);
                  str = "current";
                }
                yang_print_substmt(out,iVar1,LYEXT_SUBSTMT_STATUS,'\0',str,module,ext[u]->ext,
                                   (uint)ext[u]->ext_size);
              }
              break;
            case LY_STMT_DIGITS:
              p = (void *)((long)&ext[u][1].parent + info[i].offset);
              if ((long *)p != (long *)0x0) {
                    // WARNING: Load size is inaccurate
                if ((info->cardinality < LY_STMT_CARD_SOME) || (*p == 0)) {
                    // WARNING: Load size is inaccurate
                  if (*p != '\0') {
                    yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                    yang_print_unsigned(out,iVar1,LYEXT_SUBSTMT_DIGITS,'\0',module,ext[u]->ext,
                                        (uint)ext[u]->ext_size,(uint)*p);
                  }
                }
                else {
                    // WARNING: Load size is inaccurate
                  for (c = 0; *(char *)((long)c + *p) != '\0'; c = c + 1) {
                    yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                    yang_print_unsigned(out,iVar1,LYEXT_SUBSTMT_DIGITS,(uint8_t)c,module,ext[u]->ext
                                        ,(uint)ext[u]->ext_size,(uint)*(byte *)((long)c + *p));
                  }
                }
              }
              break;
            case LY_STMT_MAX:
              p = (void *)((long)&ext[u][1].parent + info[i].offset);
                    // WARNING: Load size is inaccurate
              if (((long *)p != (long *)0x0) && (*p != 0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                  yang_print_unsigned(out,iVar1,LYEXT_SUBSTMT_MAX,'\0',module,ext[u]->ext,
                                      (uint)ext[u]->ext_size,**p);
                }
                else {
                  c = 0;
                    // WARNING: Load size is inaccurate
                  while (*(long *)(*p + (long)c * 8) != 0) {
                    yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                    yang_print_unsigned(out,iVar1,LYEXT_SUBSTMT_MAX,(uint8_t)c,module,ext[u]->ext,
                                        (uint)ext[u]->ext_size,**(uint **)(*p + (long)c * 8));
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_MIN:
              p = (void *)((long)&ext[u][1].parent + info[i].offset);
                    // WARNING: Load size is inaccurate
              if (((long *)p != (long *)0x0) && (*p != 0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                  yang_print_unsigned(out,iVar1,LYEXT_SUBSTMT_MIN,'\0',module,ext[u]->ext,
                                      (uint)ext[u]->ext_size,**p);
                }
                else {
                  c = 0;
                    // WARNING: Load size is inaccurate
                  while (*(long *)(*p + (long)c * 8) != 0) {
                    yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                    yang_print_unsigned(out,iVar1,LYEXT_SUBSTMT_MIN,(uint8_t)c,module,ext[u]->ext,
                                        (uint)ext[u]->ext_size,**(uint **)(*p + (long)c * 8));
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_POSITION:
              p = (void *)((long)&ext[u][1].parent + info[i].offset);
                    // WARNING: Load size is inaccurate
              if (((long *)p != (long *)0x0) && (*p != 0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                  yang_print_unsigned(out,iVar1,LYEXT_SUBSTMT_POSITION,'\0',module,ext[u]->ext,
                                      (uint)ext[u]->ext_size,**p);
                }
                else {
                  c = 0;
                    // WARNING: Load size is inaccurate
                  while (*(long *)(*p + (long)c * 8) != 0) {
                    yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                    yang_print_unsigned(out,iVar1,LYEXT_SUBSTMT_POSITION,(uint8_t)c,module,
                                        ext[u]->ext,(uint)ext[u]->ext_size,
                                        **(uint **)(*p + (long)c * 8));
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_UNIQUE:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_UNIQUE,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                  yang_print_unique(out,iVar1,module,(lys_unique *)*pp);
                  j = -1;
                  content2 = 0;
                  while (j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                          LYEXT_SUBSTMT_UNIQUE), j != -1) {
                    yang_print_open(out,&content2);
                    yang_print_extension_instances
                              (out,level + 2,module,LYEXT_SUBSTMT_UNIQUE,'\0',ext[u]->ext + j,1);
                  }
                  yang_print_close(out,iVar1,content2);
                }
                else {
                  pp = (void **)*pp;
                  c = 0;
                  for (; *pp != (void *)0x0; pp = pp + 1) {
                    yang_print_open(out,&content);
                    yang_print_unique(out,iVar1,module,(lys_unique *)*pp);
                    j = -1;
                    content2 = 0;
                    do {
                      j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                       LYEXT_SUBSTMT_UNIQUE);
                      if (j == -1) break;
                    } while (c != (uint)ext[u]->ext[j]->insubstmt_index);
                    if (j != -1) {
                      yang_print_open(out,&content2);
                      do {
                        yang_print_extension_instances
                                  (out,level + 2,module,LYEXT_SUBSTMT_UNIQUE,(uint8_t)c,
                                   ext[u]->ext + j,1);
                        do {
                          j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                           LYEXT_SUBSTMT_UNIQUE);
                          if (j == -1) break;
                        } while (c != (uint)ext[u]->ext[j]->insubstmt_index);
                      } while (j != -1);
                    }
                    yang_print_close(out,iVar1,content2);
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_MODULE:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_MODULE,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                  yang_print_model_(out,iVar1,(lys_module *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yang_print_open(out,&content);
                    yang_print_model_(out,iVar1,(lys_module *)*pp);
                  }
                }
              }
              break;
            case LY_STMT_ACTION:
            case LY_STMT_ANYDATA:
            case LY_STMT_ANYXML:
            case LY_STMT_CASE:
            case LY_STMT_CHOICE:
            case LY_STMT_CONTAINER:
            case LY_STMT_GROUPING:
            case LY_STMT_INPUT:
            case LY_STMT_LEAF:
            case LY_STMT_LEAFLIST:
            case LY_STMT_LIST:
            case LY_STMT_NOTIFICATION:
            case LY_STMT_OUTPUT:
            case LY_STMT_USES:
              pp = (void **)lys_ext_complex_get_substmt
                                      (info[i].stmt,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                for (siter = (lys_node *)*pp; siter != (lys_node *)0x0; siter = siter->next) {
                  LVar3 = lys_snode2stmt(siter->nodetype);
                  if (LVar3 == info[i].stmt) {
                    yang_print_open(out,&content);
                    yang_print_snode(out,iVar1,siter,0xffff);
                  }
                }
              }
              break;
            case LY_STMT_TYPEDEF:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_TYPEDEF,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                  yang_print_typedef(out,iVar1,module,(lys_tpdf *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yang_print_open(out,&content);
                    yang_print_typedef(out,iVar1,module,(lys_tpdf *)*pp);
                  }
                }
              }
              break;
            case LY_STMT_TYPE:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_TYPE,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                  yang_print_type(out,iVar1,module,(lys_type *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yang_print_open(out,&content);
                    yang_print_type(out,iVar1,module,(lys_type *)*pp);
                  }
                }
              }
              break;
            case LY_STMT_IFFEATURE:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_IFFEATURE,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                  yang_print_iffeature(out,iVar1,module,(lys_iffeature *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yang_print_open(out,&content);
                    yang_print_iffeature(out,iVar1,module,(lys_iffeature *)*pp);
                  }
                }
              }
              break;
            case LY_STMT_LENGTH:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_LENGTH,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                  yang_print_restr(out,iVar1,module,(lys_restr *)*pp,"length",**pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                    yang_print_restr(out,iVar1,module,(lys_restr *)*pp,"length",**pp);
                  }
                }
              }
              break;
            case LY_STMT_MUST:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_MUST,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                  yang_print_must(out,iVar1,module,(lys_restr *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yang_print_open(out,&content);
                    yang_print_must(out,iVar1,module,(lys_restr *)*pp);
                  }
                }
              }
              break;
            case LY_STMT_PATTERN:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_PATTERN,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                  yang_print_restr(out,iVar1,module,(lys_restr *)*pp,"pattern",(char *)(**pp + 1));
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                    yang_print_restr(out,iVar1,module,(lys_restr *)*pp,"pattern",(char *)(**pp + 1))
                    ;
                  }
                }
              }
              break;
            case LY_STMT_RANGE:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_RANGE,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                  yang_print_restr(out,iVar1,module,(lys_restr *)*pp,"range",**pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yang_print_open(out,&content);
                    // WARNING: Load size is inaccurate
                    yang_print_restr(out,iVar1,module,(lys_restr *)*pp,"range",**pp);
                  }
                }
              }
              break;
            case LY_STMT_WHEN:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_WHEN,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                  yang_print_when(out,iVar1,module,(lys_when *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yang_print_open(out,&content);
                    yang_print_when(out,iVar1,module,(lys_when *)*pp);
                  }
                }
              }
              break;
            case LY_STMT_REVISION:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_REVISION,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yang_print_open(out,&content);
                  yang_print_revision(out,iVar1,module,(lys_revision *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yang_print_open(out,&content);
                    yang_print_revision(out,iVar1,module,(lys_revision *)*pp);
                  }
                }
              }
            }
          }
          i = i + 1;
        }
      }
      yang_print_close(out,level,content);
    }
    u = u + 1;
  } while( true );
}



void yin_print_open(lyout *out,int level,char *elem_prefix,char *elem_name,char *attr_name,
                   char *attr_value,int endflag)

{
  undefined *puVar1;
  char *format;
  char *attr_value_local;
  char *attr_name_local;
  char *elem_name_local;
  char *elem_prefix_local;
  int level_local;
  lyout *out_local;
  
  if (elem_prefix == (char *)0x0) {
    ly_print(out,"%*s<%s",(ulong)(uint)(level * 2),&DAT_0022d460,elem_name);
  }
  else {
    ly_print(out,"%*s<%s:%s",(ulong)(uint)(level * 2),&DAT_0022d460,elem_prefix,elem_name);
  }
  if (attr_name == (char *)0x0) {
    if (endflag != 0) {
      if (endflag == -1) {
        format = "/>\n";
      }
      else {
        format = ">\n";
      }
      ly_print(out,format);
    }
  }
  else {
    ly_print(out," %s=\"",attr_name);
    lyxml_dump_text(out,attr_value,LYXML_DATA_ATTR);
    if (endflag == -1) {
      puVar1 = &DAT_0022d47b;
    }
    else if (endflag == 1) {
      puVar1 = &DAT_0022d478;
    }
    else {
      puVar1 = &DAT_0022d460;
    }
    ly_print(out,"\"%s",puVar1);
  }
  return;
}



void yin_print_close(lyout *out,int level,char *elem_prefix,char *elem_name,int endflag)

{
  char *elem_name_local;
  char *elem_prefix_local;
  int endflag_local;
  int level_local;
  lyout *out_local;
  
  if (endflag == 0) {
    ly_print(out,"/>\n");
  }
  else if (elem_prefix == (char *)0x0) {
    ly_print(out,"%*s</%s>\n",(ulong)(uint)(level * 2),&DAT_0022d460,elem_name);
  }
  else {
    ly_print(out,"%*s</%s:%s>\n",(ulong)(uint)(level * 2),&DAT_0022d460,elem_prefix,elem_name);
  }
  return;
}



void yin_print_close_parent(lyout *out,int *par_close_flag)

{
  int *par_close_flag_local;
  lyout *out_local;
  
  if ((par_close_flag != (int *)0x0) && (*par_close_flag == 0)) {
    *par_close_flag = 1;
    ly_print(out,">\n");
  }
  return;
}



void yin_print_arg(lyout *out,int level,char *arg,char *text)

{
  char *text_local;
  char *arg_local;
  int level_local;
  lyout *out_local;
  
  ly_print(out,"%*s<%s>",(ulong)(uint)(level * 2),&DAT_0022d460,arg);
  lyxml_dump_text(out,text,LYXML_DATA_ELEM);
  ly_print(out,"</%s>\n",arg);
  return;
}



void yin_print_substmt(lyout *out,int level,LYEXT_SUBSTMT substmt,uint8_t substmt_index,char *text,
                      lys_module *module,lys_ext_instance **ext,uint ext_size)

{
  long in_FS_OFFSET;
  lys_ext_instance **ext_local;
  lys_module *module_local;
  char *text_local;
  uint8_t substmt_index_local;
  LYEXT_SUBSTMT substmt_local;
  int level_local;
  lyout *out_local;
  int content;
  int i;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  if (text != (char *)0x0) {
    if ((*(uint *)(ext_substmt_info + (long)substmt * 0x18 + 0x10) & 1) == 0) {
      yin_print_open(out,level,(char *)0x0,*(char **)(ext_substmt_info + (long)substmt * 0x18),
                     *(char **)(ext_substmt_info + (long)substmt * 0x18 + 8),text,0);
    }
    else {
      content = 1;
      yin_print_open(out,level,(char *)0x0,*(char **)(ext_substmt_info + (long)substmt * 0x18),
                     (char *)0x0,(char *)0x0,1);
    }
    i = -1;
    do {
      i = lys_ext_iter(ext,(uint8_t)ext_size,(char)i + '\x01',substmt);
      if (i == -1) break;
    } while (substmt_index != ext[i]->insubstmt_index);
    if (i != -1) {
      yin_print_close_parent(out,&content);
      do {
        yin_print_extension_instances(out,level + 1,module,substmt,substmt_index,ext + i,1);
        do {
          i = lys_ext_iter(ext,(uint8_t)ext_size,(char)i + '\x01',substmt);
          if (i == -1) break;
        } while (substmt_index != ext[i]->insubstmt_index);
      } while (i != -1);
    }
    if ((*(uint *)(ext_substmt_info + (long)substmt * 0x18 + 0x10) & 1) != 0) {
      yin_print_arg(out,level + 1,*(char **)(ext_substmt_info + (long)substmt * 0x18 + 8),text);
    }
    yin_print_close(out,level,(char *)0x0,*(char **)(ext_substmt_info + (long)substmt * 0x18),
                    content);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_iffeature(lyout *out,int level,lys_module *module,lys_iffeature *iffeature)

{
  lys_iffeature *iffeature_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  
  ly_print(out,"%*s<if-feature name=\"",(ulong)(uint)(level * 2),&DAT_0022d460);
  ly_print_iffeature(out,module,iffeature,0);
  if (iffeature->ext_size == '\0') {
    ly_print(out,"\"/>\n");
  }
  else {
    ly_print(out,"\">\n");
    yin_print_extension_instances
              (out,level + 1,module,LYEXT_SUBSTMT_SELF,'\0',iffeature->ext,(uint)iffeature->ext_size
              );
    ly_print(out,"%*s</if-feature>\n",(ulong)(uint)(level * 2),&DAT_0022d460);
  }
  return;
}



void yin_print_snode_common
               (lyout *out,int level,lys_node *node,lys_module *module,int *par_close_flag,int mask)

{
  int iVar1;
  lys_node *plVar2;
  int *par_close_flag_local;
  lys_module *module_local;
  lys_node *node_local;
  int mask_local;
  int level_local;
  lyout *out_local;
  int i;
  char *status;
  
  status = (char *)0x0;
  if (((mask & 1U) != 0) && (node->ext_size != '\0')) {
    yin_print_close_parent(out,par_close_flag);
    yin_print_extension_instances
              (out,level,module,LYEXT_SUBSTMT_SELF,'\0',node->ext,(uint)node->ext_size);
  }
  if ((mask & 2U) != 0) {
    for (i = 0; i < (int)(uint)node->iffeature_size; i = i + 1) {
      yin_print_close_parent(out,par_close_flag);
      yin_print_iffeature(out,level,module,node->iffeature + i);
    }
  }
  if ((mask & 4U) != 0) {
    iVar1 = lys_ext_iter(node->ext,node->ext_size,'\0',LYEXT_SUBSTMT_CONFIG);
    plVar2 = lys_parent(node);
    if (plVar2 == (lys_node *)0x0) {
      if ((node->flags & 2) == 0) {
        if (iVar1 != -1) {
          yin_print_close_parent(out,par_close_flag);
          yin_print_substmt(out,level,LYEXT_SUBSTMT_CONFIG,'\0',"true",module,node->ext,
                            (uint)node->ext_size);
        }
      }
      else {
        yin_print_close_parent(out,par_close_flag);
        yin_print_substmt(out,level,LYEXT_SUBSTMT_CONFIG,'\0',"false",module,node->ext,
                          (uint)node->ext_size);
      }
    }
    else if (((node->flags & 4) != 0) || (iVar1 != -1)) {
      if ((node->flags & 1) == 0) {
        if ((node->flags & 2) != 0) {
          yin_print_close_parent(out,par_close_flag);
          yin_print_substmt(out,level,LYEXT_SUBSTMT_CONFIG,'\0',"false",module,node->ext,
                            (uint)node->ext_size);
        }
      }
      else {
        yin_print_close_parent(out,par_close_flag);
        yin_print_substmt(out,level,LYEXT_SUBSTMT_CONFIG,'\0',"true",module,node->ext,
                          (uint)node->ext_size);
      }
    }
  }
  if (((mask & 8U) != 0) && ((node->nodetype & (LYS_CHOICE|LYS_LEAF|LYS_ANYDATA)) != LYS_UNKNOWN)) {
    if ((node->flags & 0x40) == 0) {
      if ((node->flags & 0x80) != 0) {
        yin_print_close_parent(out,par_close_flag);
        yin_print_substmt(out,level,LYEXT_SUBSTMT_MANDATORY,'\0',"false",module,node->ext,
                          (uint)node->ext_size);
      }
    }
    else {
      yin_print_close_parent(out,par_close_flag);
      yin_print_substmt(out,level,LYEXT_SUBSTMT_MANDATORY,'\0',"true",module,node->ext,
                        (uint)node->ext_size);
    }
  }
  if ((mask & 0x10U) != 0) {
    if ((node->flags & 8) == 0) {
      if ((node->flags & 0x10) == 0) {
        if ((node->flags & 0x20) != 0) {
          yin_print_close_parent(out,par_close_flag);
          status = "obsolete";
        }
      }
      else {
        yin_print_close_parent(out,par_close_flag);
        status = "deprecated";
      }
    }
    else {
      yin_print_close_parent(out,par_close_flag);
      status = "current";
    }
    yin_print_substmt(out,level,LYEXT_SUBSTMT_STATUS,'\0',status,module,node->ext,
                      (uint)node->ext_size);
  }
  if (((mask & 0x20U) != 0) && (node->dsc != (char *)0x0)) {
    yin_print_close_parent(out,par_close_flag);
    yin_print_substmt(out,level,LYEXT_SUBSTMT_DESCRIPTION,'\0',node->dsc,module,node->ext,
                      (uint)node->ext_size);
  }
  if (((mask & 0x40U) != 0) && (node->ref != (char *)0x0)) {
    yin_print_close_parent(out,par_close_flag);
    yin_print_substmt(out,level,LYEXT_SUBSTMT_REFERENCE,'\0',node->ref,module,node->ext,
                      (uint)node->ext_size);
  }
  return;
}



void yin_print_extension(lyout *out,int level,lys_ext *ext)

{
  int level_00;
  int iVar1;
  char *text;
  long in_FS_OFFSET;
  lys_ext *ext_local;
  int level_local;
  lyout *out_local;
  int close;
  int close2;
  int i;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  close = 0;
  close2 = 0;
  yin_print_open(out,level,(char *)0x0,"extension","name",ext->name,0);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,(lys_node *)ext,ext->module,&close,1);
  if (ext->argument == (char *)0x0) goto LAB_001ecee5;
  yin_print_close_parent(out,&close);
  yin_print_open(out,level_00,(char *)0x0,"argument","name",ext->argument,close2);
  i = -1;
  while( true ) {
    i = lys_ext_iter(ext->ext,ext->ext_size,(char)i + '\x01',LYEXT_SUBSTMT_ARGUMENT);
    if (i == -1) break;
    yin_print_close_parent(out,&close2);
    yin_print_extension_instances
              (out,level + 2,ext->module,LYEXT_SUBSTMT_ARGUMENT,'\0',ext->ext + i,1);
  }
  if ((ext->flags & 1) == 0) {
    iVar1 = lys_ext_iter(ext->ext,ext->ext_size,'\0',LYEXT_SUBSTMT_YINELEM);
    if (iVar1 != -1) goto LAB_001ece4f;
  }
  else {
LAB_001ece4f:
    yin_print_close_parent(out,&close2);
    if ((ext->flags & 1) == 0) {
      text = "false";
    }
    else {
      text = "true";
    }
    yin_print_substmt(out,level + 2,LYEXT_SUBSTMT_YINELEM,'\0',text,ext->module,ext->ext,
                      (uint)ext->ext_size);
  }
  yin_print_close(out,level_00,(char *)0x0,"argument",close2);
LAB_001ecee5:
  yin_print_snode_common(out,level_00,(lys_node *)ext,ext->module,&close,0x70);
  yin_print_close(out,level,(char *)0x0,"extension",close);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_restr(lyout *out,int level,lys_module *module,lys_restr *restr,int *flag)

{
  int *flag_local;
  lys_restr *restr_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  
  if (restr->ext_size != '\0') {
    yin_print_close_parent(out,flag);
    yin_print_extension_instances
              (out,level,module,LYEXT_SUBSTMT_SELF,'\0',restr->ext,(uint)restr->ext_size);
  }
  if (*restr->expr == '\x15') {
    yin_print_close_parent(out,flag);
    yin_print_substmt(out,level,LYEXT_SUBSTMT_MODIFIER,'\0',"invert-match",module,restr->ext,
                      (uint)restr->ext_size);
  }
  if (restr->emsg != (char *)0x0) {
    yin_print_close_parent(out,flag);
    yin_print_substmt(out,level,LYEXT_SUBSTMT_ERRMSG,'\0',restr->emsg,module,restr->ext,
                      (uint)restr->ext_size);
  }
  if (restr->eapptag != (char *)0x0) {
    yin_print_close_parent(out,flag);
    yin_print_substmt(out,level,LYEXT_SUBSTMT_ERRTAG,'\0',restr->eapptag,module,restr->ext,
                      (uint)restr->ext_size);
  }
  if (restr->dsc != (char *)0x0) {
    yin_print_close_parent(out,flag);
    yin_print_substmt(out,level,LYEXT_SUBSTMT_DESCRIPTION,'\0',restr->dsc,module,restr->ext,
                      (uint)restr->ext_size);
  }
  if (restr->ref != (char *)0x0) {
    yin_print_close_parent(out,flag);
    yin_print_substmt(out,level,LYEXT_SUBSTMT_REFERENCE,'\0',restr->ref,module,restr->ext,
                      (uint)restr->ext_size);
  }
  return;
}



void yin_print_typerestr(lyout *out,int level,lys_module *module,lys_restr *restr,char *elem_name)

{
  char *attr_value;
  long in_FS_OFFSET;
  char *elem_name_local;
  lys_restr *restr_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  int content;
  int pattern;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  pattern = 0;
  if ((*restr->expr == '\x06') || (*restr->expr == '\x15')) {
    pattern = 1;
  }
  if (pattern == 0) {
    attr_value = restr->expr;
  }
  else {
    attr_value = restr->expr + 1;
  }
  yin_print_open(out,level,(char *)0x0,elem_name,"value",attr_value,0);
  yin_print_restr(out,level + 1,module,restr,&content);
  yin_print_close(out,level,(char *)0x0,elem_name,content);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_feature(lyout *out,int level,lys_feature *feat)

{
  long in_FS_OFFSET;
  lys_feature *feat_local;
  int level_local;
  lyout *out_local;
  int close;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  close = 0;
  yin_print_open(out,level,(char *)0x0,"feature","name",feat->name,0);
  yin_print_snode_common(out,level + 1,(lys_node *)feat,feat->module,&close,0x73);
  yin_print_close(out,level,(char *)0x0,"feature",close);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_when(lyout *out,int level,lys_module *module,lys_when *when)

{
  int level_00;
  long in_FS_OFFSET;
  lys_when *when_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  int flag;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  flag = 0;
  str = transform_json2schema(module,when->cond);
  if (str == (char *)0x0) {
    ly_print(out,"(!error!)");
  }
  else {
    ly_print(out,"%*s<when condition=\"",(ulong)(uint)(level * 2),&DAT_0022d460);
    lyxml_dump_text(out,str,LYXML_DATA_ATTR);
    ly_print(out,"\"");
    lydict_remove(module->ctx,str);
    level_00 = level + 1;
    if (when->ext_size != '\0') {
      yin_print_close_parent(out,&flag);
      yin_print_extension_instances
                (out,level_00,module,LYEXT_SUBSTMT_SELF,'\0',when->ext,(uint)when->ext_size);
    }
    if (when->dsc != (char *)0x0) {
      yin_print_close_parent(out,&flag);
      yin_print_substmt(out,level_00,LYEXT_SUBSTMT_DESCRIPTION,'\0',when->dsc,module,when->ext,
                        (uint)when->ext_size);
    }
    if (when->ref != (char *)0x0) {
      yin_print_close_parent(out,&flag);
      yin_print_substmt(out,level_00,LYEXT_SUBSTMT_REFERENCE,'\0',when->ref,module,when->ext,
                        (uint)when->ext_size);
    }
    yin_print_close(out,level,(char *)0x0,"when",flag);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_unsigned(lyout *out,int level,LYEXT_SUBSTMT substmt,uint8_t substmt_index,
                       lys_module *module,lys_ext_instance **ext,uint ext_size,uint attr_value)

{
  int iVar1;
  long in_FS_OFFSET;
  lys_ext_instance **ext_local;
  lys_module *module_local;
  uint8_t substmt_index_local;
  LYEXT_SUBSTMT substmt_local;
  int level_local;
  lyout *out_local;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = asprintf(&str,"%u",(ulong)attr_value);
  if (iVar1 == -1) {
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yin_print_unsigned");
  }
  else {
    yin_print_substmt(out,level,substmt,substmt_index,str,module,ext,ext_size);
    free(str);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_signed(lyout *out,int level,LYEXT_SUBSTMT substmt,uint8_t substmt_index,
                     lys_module *module,lys_ext_instance **ext,uint ext_size,int attr_value)

{
  int iVar1;
  long in_FS_OFFSET;
  lys_ext_instance **ext_local;
  lys_module *module_local;
  uint8_t substmt_index_local;
  LYEXT_SUBSTMT substmt_local;
  int level_local;
  lyout *out_local;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = asprintf(&str,"%d",(ulong)(uint)attr_value);
  if (iVar1 == -1) {
    ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yin_print_signed");
  }
  else {
    yin_print_substmt(out,level,substmt,substmt_index,str,module,ext,ext_size);
    free(str);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}


/*
Unable to decompile 'yin_print_type'
Cause: Exception while decompiling 001ed755: process: timeout

*/


void yin_print_must(lyout *out,int level,lys_module *module,lys_restr *must)

{
  long in_FS_OFFSET;
  lys_restr *must_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  int content;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  str = transform_json2schema(module,must->expr);
  if (str == (char *)0x0) {
    ly_print(out,"(!error!)");
  }
  else {
    ly_print(out,"%*s<must condition=\"",(ulong)(uint)(level * 2),&DAT_0022d460);
    lyxml_dump_text(out,str,LYXML_DATA_ATTR);
    ly_print(out,"\"");
    lydict_remove(module->ctx,str);
    yin_print_restr(out,level + 1,module,must,&content);
    yin_print_close(out,level,(char *)0x0,"must",content);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_unique(lyout *out,int level,lys_module *module,lys_unique *uniq)

{
  char *value;
  undefined *puVar1;
  lys_unique *uniq_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  int i;
  char *str;
  
  ly_print(out,"%*s<unique tag=\"",(ulong)(uint)(level * 2),&DAT_0022d460);
  for (i = 0; i < (int)(uint)uniq->expr_size; i = i + 1) {
    value = transform_json2schema(module,uniq->expr[i]);
    if (i + 1 < (int)(uint)uniq->expr_size) {
      puVar1 = &DAT_0022d647;
    }
    else {
      puVar1 = &DAT_0022d460;
    }
    ly_print(out,"%s%s",value,puVar1);
    lydict_remove(module->ctx,value);
  }
  ly_print(out,"\"");
  return;
}



void yin_print_refine(lyout *out,int level,lys_module *module,lys_refine *refine)

{
  int level_00;
  long in_FS_OFFSET;
  lys_refine *refine_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  int content;
  int i;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  str = transform_json2xml(module,refine->target_name,0,(char ***)0x0,(char ***)0x0,(uint32_t *)0x0)
  ;
  yin_print_open(out,level,(char *)0x0,"refine","target-node",str,content);
  lydict_remove(module->ctx,str);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,(lys_node *)refine,module,&content,3);
  for (i = 0; i < (int)(uint)refine->must_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_must(out,level_00,module,refine->must + i);
  }
  if ((refine->target_type == 1) && ((refine->mod).presence != (char *)0x0)) {
    yin_print_close_parent(out,&content);
    yin_print_substmt(out,level_00,LYEXT_SUBSTMT_PRESENCE,'\0',(refine->mod).presence,module,
                      refine->ext,(uint)refine->ext_size);
  }
  for (i = 0; i < (int)(uint)refine->dflt_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_substmt(out,level_00,LYEXT_SUBSTMT_DEFAULT,(uint8_t)i,refine->dflt[i],module,
                      refine->ext,(uint)refine->ext_size);
  }
  if ((refine->flags & 1) == 0) {
    if ((refine->flags & 2) != 0) {
      yin_print_close_parent(out,&content);
      yin_print_substmt(out,level_00,LYEXT_SUBSTMT_CONFIG,'\0',"false",module,refine->ext,
                        (uint)refine->ext_size);
    }
  }
  else {
    yin_print_close_parent(out,&content);
    yin_print_substmt(out,level_00,LYEXT_SUBSTMT_CONFIG,'\0',"true",module,refine->ext,
                      (uint)refine->ext_size);
  }
  if ((refine->flags & 0x40) == 0) {
    if ((refine->flags & 0x80) != 0) {
      yin_print_close_parent(out,&content);
      yin_print_substmt(out,level_00,LYEXT_SUBSTMT_MANDATORY,'\0',"false",module,refine->ext,
                        (uint)refine->ext_size);
    }
  }
  else {
    yin_print_close_parent(out,&content);
    yin_print_substmt(out,level_00,LYEXT_SUBSTMT_MANDATORY,'\0',"true",module,refine->ext,
                      (uint)refine->ext_size);
  }
  if ((refine->target_type & 0x18) != 0) {
    if ((refine->flags & 0x10) != 0) {
      yin_print_close_parent(out,&content);
      yin_print_unsigned(out,level_00,LYEXT_SUBSTMT_MIN,'\0',module,refine->ext,
                         (uint)refine->ext_size,(refine->mod).list.min);
    }
    if ((refine->flags & 8) != 0) {
      yin_print_close_parent(out,&content);
      if ((refine->mod).list.max == 0) {
        yin_print_substmt(out,level_00,LYEXT_SUBSTMT_MAX,'\0',"unbounded",module,refine->ext,
                          (uint)refine->ext_size);
      }
      else {
        yin_print_unsigned(out,level_00,LYEXT_SUBSTMT_MAX,'\0',module,refine->ext,
                           (uint)refine->ext_size,(refine->mod).list.max);
      }
    }
  }
  yin_print_snode_common(out,level_00,(lys_node *)refine,module,&content,0x60);
  yin_print_close(out,level,(char *)0x0,"refine",content);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_deviation(lyout *out,int level,lys_module *module,lys_deviation *deviation)

{
  int level_00;
  int level_01;
  long in_FS_OFFSET;
  lys_deviation *deviation_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  int content;
  int i;
  int j;
  int p;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  str = transform_json2schema(module,deviation->target_name);
  yin_print_open(out,level,(char *)0x0,"deviation","target-node",str,1);
  lydict_remove(module->ctx,str);
  level_00 = level + 1;
  if (deviation->ext_size != '\0') {
    yin_print_extension_instances
              (out,level_00,module,LYEXT_SUBSTMT_SELF,'\0',deviation->ext,(uint)deviation->ext_size)
    ;
  }
  yin_print_substmt(out,level_00,LYEXT_SUBSTMT_DESCRIPTION,'\0',deviation->dsc,module,deviation->ext
                    ,(uint)deviation->ext_size);
  yin_print_substmt(out,level_00,LYEXT_SUBSTMT_REFERENCE,'\0',deviation->ref,module,deviation->ext,
                    (uint)deviation->ext_size);
  i = 0;
  do {
    if ((int)(uint)deviation->deviate_size <= i) {
      yin_print_close(out,level,(char *)0x0,"deviation",1);
      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return;
    }
    ly_print(out,"%*s<deviate value=",(ulong)(uint)(level_00 * 2),&DAT_0022d460);
    if (deviation->deviate[i].mod == LY_DEVIATE_NO) {
      if (deviation->deviate[i].ext_size != '\0') {
        ly_print(out,"\"not-supported\">\n");
        goto LAB_001eedf4;
      }
      ly_print(out,"\"not-supported\"/>\n");
    }
    else {
      if (deviation->deviate[i].mod == LY_DEVIATE_ADD) {
        ly_print(out,"\"add\">\n");
      }
      else if (deviation->deviate[i].mod == LY_DEVIATE_RPL) {
        ly_print(out,"\"replace\">\n");
      }
      else if (deviation->deviate[i].mod == LY_DEVIATE_DEL) {
        ly_print(out,"\"delete\">\n");
      }
LAB_001eedf4:
      level_01 = level + 2;
      if (deviation->deviate[i].ext_size != '\0') {
        yin_print_extension_instances
                  (out,level_01,module,LYEXT_SUBSTMT_SELF,'\0',deviation->deviate[i].ext,
                   (uint)deviation->deviate[i].ext_size);
      }
      if (deviation->deviate[i].type != (lys_type *)0x0) {
        yin_print_type(out,level_01,module,deviation->deviate[i].type);
      }
      yin_print_substmt(out,level_01,LYEXT_SUBSTMT_UNITS,'\0',deviation->deviate[i].units,module,
                        deviation->deviate[i].ext,(uint)deviation->deviate[i].ext_size);
      for (j = 0; j < (int)(uint)deviation->deviate[i].must_size; j = j + 1) {
        yin_print_must(out,level_01,module,deviation->deviate[i].must + j);
      }
      for (j = 0; j < (int)(uint)deviation->deviate[i].unique_size; j = j + 1) {
        yin_print_unique(out,level_01,module,deviation->deviate[i].unique + j);
        content = 0;
        p = -1;
        do {
          p = lys_ext_iter(deviation->deviate[i].ext,deviation->deviate[i].ext_size,(char)p + '\x01'
                           ,LYEXT_SUBSTMT_UNIQUE);
          if (p == -1) break;
        } while (j != (uint)deviation->deviate[i].ext[p]->insubstmt_index);
        if (p != -1) {
          yin_print_close_parent(out,&content);
          do {
            yin_print_extension_instances
                      (out,level + 3,module,LYEXT_SUBSTMT_UNIQUE,(uint8_t)j,
                       deviation->deviate[i].ext + p,1);
            do {
              p = lys_ext_iter(deviation->deviate[i].ext,deviation->deviate[i].ext_size,
                               (char)p + '\x01',LYEXT_SUBSTMT_UNIQUE);
              if (p == -1) break;
            } while (j != (uint)deviation->deviate[i].ext[p]->insubstmt_index);
          } while (p != -1);
        }
        yin_print_close(out,level_01,(char *)0x0,"unique",content);
      }
      for (j = 0; j < (int)(uint)deviation->deviate[i].dflt_size; j = j + 1) {
        yin_print_substmt(out,level_01,LYEXT_SUBSTMT_DEFAULT,(uint8_t)j,
                          deviation->deviate[i].dflt[j],module,deviation->deviate[i].ext,
                          (uint)deviation->deviate[i].ext_size);
      }
      if ((deviation->deviate[i].flags & 1) == 0) {
        if ((deviation->deviate[i].flags & 2) != 0) {
          yin_print_substmt(out,level_01,LYEXT_SUBSTMT_CONFIG,'\0',"false",module,
                            deviation->deviate->ext,(uint)deviation->deviate[i].ext_size);
        }
      }
      else {
        yin_print_substmt(out,level_01,LYEXT_SUBSTMT_CONFIG,'\0',"true",module,
                          deviation->deviate->ext,(uint)deviation->deviate[i].ext_size);
      }
      if ((deviation->deviate[i].flags & 0x40) == 0) {
        if ((char)deviation->deviate[i].flags < '\0') {
          yin_print_substmt(out,level_01,LYEXT_SUBSTMT_MANDATORY,'\0',"false",module,
                            deviation->deviate[i].ext,(uint)deviation->deviate[i].ext_size);
        }
      }
      else {
        yin_print_substmt(out,level_01,LYEXT_SUBSTMT_MANDATORY,'\0',"true",module,
                          deviation->deviate[i].ext,(uint)deviation->deviate[i].ext_size);
      }
      if (deviation->deviate[i].min_set != '\0') {
        yin_print_unsigned(out,level_01,LYEXT_SUBSTMT_MIN,'\0',module,deviation->deviate[i].ext,
                           (uint)deviation->deviate[i].ext_size,deviation->deviate[i].min);
      }
      if (deviation->deviate[i].max_set != '\0') {
        if (deviation->deviate[i].max == 0) {
          yin_print_substmt(out,level_01,LYEXT_SUBSTMT_MAX,'\0',"unbounded",module,
                            deviation->deviate[i].ext,(uint)deviation->deviate[i].ext_size);
        }
        else {
          yin_print_unsigned(out,level_01,LYEXT_SUBSTMT_MAX,'\0',module,deviation->deviate[i].ext,
                             (uint)deviation->deviate[i].ext_size,deviation->deviate[i].max);
        }
      }
      yin_print_close(out,level_00,(char *)0x0,"deviate",1);
    }
    i = i + 1;
  } while( true );
}



void yin_print_augment(lyout *out,int level,lys_module *module,lys_node_augment *augment)

{
  int level_00;
  char *attr_value;
  lys_node_augment *augment_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  lys_node *sub;
  char *str;
  
  attr_value = transform_json2schema(module,augment->target_name);
  yin_print_open(out,level,(char *)0x0,"augment","target-node",attr_value,1);
  lydict_remove(module->ctx,attr_value);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,(lys_node *)augment,augment->module,(int *)0x0,1);
  if (augment->when != (lys_when *)0x0) {
    yin_print_when(out,level_00,module,augment->when);
  }
  yin_print_snode_common(out,level_00,(lys_node *)augment,augment->module,(int *)0x0,0x72);
  for (sub = augment->child; sub != (lys_node *)0x0; sub = sub->next) {
    if ((lys_node *)augment == sub->parent) {
      yin_print_snode(out,level_00,sub,0xd0ff);
    }
  }
  yin_print_close(out,level,(char *)0x0,"augment",1);
  return;
}



void yin_print_typedef(lyout *out,int level,lys_module *module,lys_tpdf *tpdf)

{
  int level_00;
  int iVar1;
  char *pcVar2;
  lys_tpdf *tpdf_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  char *dflt;
  
  yin_print_open(out,level,(char *)0x0,"typedef","name",tpdf->name,1);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,(lys_node *)tpdf,module,(int *)0x0,1);
  yin_print_type(out,level_00,module,&tpdf->type);
  if (tpdf->units != (char *)0x0) {
    yin_print_substmt(out,level_00,LYEXT_SUBSTMT_UNITS,'\0',tpdf->units,module,tpdf->ext,
                      (uint)tpdf->ext_size);
  }
  if (tpdf->dflt != (char *)0x0) {
    if ((tpdf->flags & 0x1000) == 0) {
      dflt = tpdf->dflt;
    }
    else {
      pcVar2 = strchr(tpdf->dflt,0x3a);
      if (pcVar2 == (char *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("strchr(tpdf->dflt, \':\')",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_yin.c"
                      ,0x36b,"yin_print_typedef");
      }
      pcVar2 = strchr(tpdf->dflt,0x3a);
      iVar1 = strncmp(tpdf->dflt,module->name,(long)pcVar2 - (long)tpdf->dflt);
      if (iVar1 == 0) {
        pcVar2 = strchr(tpdf->dflt,0x3a);
        dflt = lydict_insert(module->ctx,pcVar2 + 1,0);
      }
      else {
        dflt = transform_json2schema(module,tpdf->dflt);
      }
    }
    yin_print_substmt(out,level_00,LYEXT_SUBSTMT_DEFAULT,'\0',dflt,module,tpdf->ext,
                      (uint)tpdf->ext_size);
    if ((tpdf->flags & 0x1000) != 0) {
      lydict_remove(module->ctx,dflt);
    }
  }
  yin_print_snode_common(out,level_00,(lys_node *)tpdf,module,(int *)0x0,0x70);
  yin_print_close(out,level,(char *)0x0,"typedef",1);
  return;
}



void yin_print_identity(lyout *out,int level,lys_ident *ident)

{
  int level_00;
  char *pcVar1;
  int iVar2;
  lys_module *plVar3;
  char *pcVar4;
  long in_FS_OFFSET;
  lys_ident *ident_local;
  int level_local;
  lyout *out_local;
  int content;
  int i;
  char *str;
  lys_module *mod;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  yin_print_open(out,level,(char *)0x0,"identity","name",ident->name,0);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,(lys_node *)ident,ident->module,&content,3);
  for (i = 0; i < (int)(uint)ident->base_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    mod = lys_main_module(ident->base[i]->module);
    plVar3 = lys_main_module(ident->module);
    if (mod == plVar3) {
      yin_print_substmt(out,level_00,LYEXT_SUBSTMT_BASE,(uint8_t)i,ident->base[i]->name,
                        ident->module,ident->ext,(uint)ident->ext_size);
    }
    else {
      pcVar1 = ident->base[i]->name;
      pcVar4 = transform_module_name2import_prefix(ident->module,mod->name);
      iVar2 = asprintf(&str,"%s:%s",pcVar4,pcVar1);
      if (iVar2 == -1) {
        ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","yin_print_identity");
      }
      else {
        yin_print_substmt(out,level_00,LYEXT_SUBSTMT_BASE,(uint8_t)i,str,ident->module,ident->ext,
                          (uint)ident->ext_size);
        free(str);
      }
    }
  }
  yin_print_snode_common(out,level_00,(lys_node *)ident,ident->module,&content,0x70);
  yin_print_close(out,level,(char *)0x0,"identity",content);
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_container(lyout *out,int level,lys_node *node)

{
  int level_00;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int content;
  int i;
  lys_node *sub;
  lys_node_container *cont;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  cont = (lys_node_container *)node;
  yin_print_open(out,level,(char *)0x0,"container","name",node->name,0);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,node,node->module,&content,1);
  if (cont->when != (lys_when *)0x0) {
    yin_print_close_parent(out,&content);
    yin_print_when(out,level_00,node->module,cont->when);
  }
  for (i = 0; i < (int)(uint)cont->iffeature_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_iffeature(out,level_00,node->module,cont->iffeature + i);
  }
  for (i = 0; i < (int)(uint)cont->must_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_must(out,level_00,node->module,cont->must + i);
  }
  if (cont->presence != (char *)0x0) {
    yin_print_close_parent(out,&content);
    yin_print_substmt(out,level_00,LYEXT_SUBSTMT_PRESENCE,'\0',cont->presence,node->module,node->ext
                      ,(uint)node->ext_size);
  }
  yin_print_snode_common(out,level_00,node,node->module,&content,0x74);
  for (i = 0; i < (int)(uint)cont->tpdf_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_typedef(out,level_00,node->module,cont->tpdf + i);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yin_print_close_parent(out,&content);
      yin_print_snode(out,level_00,sub,0x800);
    }
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yin_print_close_parent(out,&content);
      yin_print_snode(out,level_00,sub,0x903f);
    }
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yin_print_close_parent(out,&content);
      yin_print_snode(out,level_00,sub,0x4000);
    }
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yin_print_close_parent(out,&content);
      yin_print_snode(out,level_00,sub,0x80);
    }
  }
  yin_print_close(out,level,(char *)0x0,"container",content);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_case(lyout *out,int level,lys_node *node)

{
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int content;
  lys_node *sub;
  lys_node_case *cas;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  cas = (lys_node_case *)node;
  if ((node->flags & 0x40) == 0) {
    yin_print_open(out,level,(char *)0x0,"case","name",node->name,0);
    level_local = level + 1;
    yin_print_snode_common(out,level_local,node,node->module,&content,1);
    if (cas->when != (lys_when *)0x0) {
      yin_print_close_parent(out,&content);
      yin_print_when(out,level_local,node->module,cas->when);
    }
    yin_print_snode_common(out,level_local,node,node->module,&content,0x72);
  }
  else {
    content = 1;
    level_local = level;
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yin_print_close_parent(out,&content);
      yin_print_snode(out,level_local,sub,0x903f);
    }
  }
  if ((node->flags & 0x40) == 0) {
    yin_print_close(out,level_local + -1,(char *)0x0,"case",content);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_choice(lyout *out,int level,lys_node *node)

{
  int level_00;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int content;
  int i;
  lys_node *sub;
  lys_node_choice *choice;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  choice = (lys_node_choice *)node;
  yin_print_open(out,level,(char *)0x0,"choice","name",node->name,0);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,node,node->module,&content,1);
  if (choice->when != (lys_when *)0x0) {
    yin_print_close_parent(out,&content);
    yin_print_when(out,level_00,node->module,choice->when);
  }
  for (i = 0; i < (int)(uint)choice->iffeature_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_iffeature(out,level_00,node->module,choice->iffeature + i);
  }
  if (choice->dflt != (lys_node *)0x0) {
    yin_print_close_parent(out,&content);
    yin_print_substmt(out,level_00,LYEXT_SUBSTMT_DEFAULT,'\0',choice->dflt->name,node->module,
                      node->ext,(uint)node->ext_size);
  }
  yin_print_snode_common(out,level_00,node,node->module,&content,0x7c);
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yin_print_close_parent(out,&content);
      yin_print_snode(out,level_00,sub,0x807f);
    }
  }
  yin_print_close(out,level,(char *)0x0,"choice",content);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_leaf(lyout *out,int level,lys_node *node)

{
  int level_00;
  lys_node *plVar1;
  int iVar2;
  char *pcVar3;
  lys_module *plVar4;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int i;
  char *dflt;
  lys_node_leaf *leaf;
  
  yin_print_open(out,level,(char *)0x0,"leaf","name",node->name,1);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,node,node->module,(int *)0x0,1);
  if (node[1].name != (char *)0x0) {
    yin_print_when(out,level_00,node->module,(lys_when *)node[1].name);
  }
  for (i = 0; i < (int)(uint)node->iffeature_size; i = i + 1) {
    yin_print_iffeature(out,level_00,node->module,node->iffeature + i);
  }
  yin_print_type(out,level_00,node->module,(lys_type *)&node[1].ref);
  yin_print_substmt(out,level_00,LYEXT_SUBSTMT_UNITS,'\0',(char *)node[1].next,node->module,
                    node->ext,(uint)node->ext_size);
  for (i = 0; i < (int)(uint)node->padding[3]; i = i + 1) {
    yin_print_must(out,level_00,node->module,(lys_restr *)(node[1].dsc + (long)i * 0x38));
  }
  if (node[1].prev != (lys_node *)0x0) {
    if ((node->flags & 0x1000) == 0) {
      dflt = (char *)node[1].prev;
    }
    else {
      pcVar3 = strchr((char *)node[1].prev,0x3a);
      if (pcVar3 == (char *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("strchr(leaf->dflt, \':\')",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_yin.c"
                      ,0x45f,"yin_print_leaf");
      }
      pcVar3 = strchr((char *)node[1].prev,0x3a);
      plVar1 = node[1].prev;
      plVar4 = lys_node_module(node);
      iVar2 = strncmp((char *)node[1].prev,plVar4->name,(long)pcVar3 - (long)plVar1);
      if (iVar2 == 0) {
        pcVar3 = strchr((char *)node[1].prev,0x3a);
        dflt = lydict_insert(node->module->ctx,pcVar3 + 1,0);
      }
      else {
        dflt = transform_json2schema(node->module,(char *)node[1].prev);
      }
    }
    yin_print_substmt(out,level_00,LYEXT_SUBSTMT_DEFAULT,'\0',dflt,node->module,node->ext,
                      (uint)node->ext_size);
    if ((node->flags & 0x1000) != 0) {
      lydict_remove(node->module->ctx,dflt);
    }
  }
  yin_print_snode_common(out,level_00,node,node->module,(int *)0x0,0x7c);
  yin_print_close(out,level,(char *)0x0,"leaf",1);
  return;
}



void yin_print_anydata(lyout *out,int level,lys_node *node)

{
  int iVar1;
  lys_node *plVar2;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int content;
  int i;
  lys_node_anydata *any;
  char *name;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  any = (lys_node_anydata *)node;
  plVar2 = lys_parent(node);
  if (plVar2 == (lys_node *)0x0) {
    iVar1 = strcmp(node->name,"config");
    if (iVar1 == 0) {
      iVar1 = strcmp(node->module->name,"ietf-netconf");
      if (iVar1 == 0) goto LAB_001f0d92;
    }
  }
  if (any->nodetype == LYS_ANYXML) {
    name = "anyxml";
  }
  else {
    name = "anydata";
  }
  yin_print_open(out,level,(char *)0x0,name,"name",any->name,content);
  iVar1 = level + 1;
  yin_print_snode_common(out,iVar1,node,node->module,&content,1);
  if (any->when != (lys_when *)0x0) {
    yin_print_close_parent(out,&content);
    yin_print_when(out,iVar1,node->module,any->when);
  }
  for (i = 0; i < (int)(uint)any->iffeature_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_iffeature(out,iVar1,node->module,any->iffeature + i);
  }
  for (i = 0; i < (int)(uint)any->must_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_must(out,iVar1,node->module,any->must + i);
  }
  yin_print_snode_common(out,iVar1,node,node->module,&content,0x7c);
  yin_print_close(out,level,(char *)0x0,name,content);
LAB_001f0d92:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_leaflist(lyout *out,int level,lys_node *node)

{
  int level_00;
  long lVar1;
  int iVar2;
  char *pcVar3;
  lys_module *plVar4;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int i;
  char *dflt;
  lys_node_leaflist *llist;
  
  yin_print_open(out,level,(char *)0x0,"leaf-list","name",node->name,1);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,node,node->module,(int *)0x0,1);
  if (node[1].name != (char *)0x0) {
    yin_print_when(out,level_00,node->module,(lys_when *)node[1].name);
  }
  for (i = 0; i < (int)(uint)node->iffeature_size; i = i + 1) {
    yin_print_iffeature(out,level_00,node->module,node->iffeature + i);
  }
  yin_print_type(out,level_00,node->module,(lys_type *)&node[1].ref);
  yin_print_substmt(out,level_00,LYEXT_SUBSTMT_UNITS,'\0',(char *)node[1].next,node->module,
                    node->ext,(uint)node->ext_size);
  for (i = 0; i < (int)(uint)node->padding[3]; i = i + 1) {
    yin_print_must(out,level_00,node->module,(lys_restr *)(node[1].dsc + (long)i * 0x38));
  }
  i = 0;
  do {
    if ((int)(uint)node->padding[2] <= i) {
      yin_print_snode_common(out,level_00,node,node->module,(int *)0x0,4);
      if (*(int *)&node[1].priv != 0) {
        yin_print_unsigned(out,level_00,LYEXT_SUBSTMT_MIN,'\0',node->module,node->ext,
                           (uint)node->ext_size,*(uint *)&node[1].priv);
      }
      if (*(int *)((long)&node[1].priv + 4) != 0) {
        yin_print_unsigned(out,level_00,LYEXT_SUBSTMT_MAX,'\0',node->module,node->ext,
                           (uint)node->ext_size,*(uint *)((long)&node[1].priv + 4));
      }
      if ((node->flags & 0x100) == 0) {
        iVar2 = lys_ext_iter(node->ext,node->ext_size,'\0',LYEXT_SUBSTMT_ORDEREDBY);
        if (iVar2 != -1) {
          yin_print_substmt(out,level_00,LYEXT_SUBSTMT_ORDEREDBY,'\0',"system",node->module,
                            node->ext,(uint)node->ext_size);
        }
      }
      else {
        yin_print_substmt(out,level_00,LYEXT_SUBSTMT_ORDEREDBY,'\0',"user",node->module,node->ext,
                          (uint)node->ext_size);
      }
      yin_print_snode_common(out,level_00,node,node->module,(int *)0x0,0x70);
      yin_print_close(out,level,(char *)0x0,"leaf-list",1);
      return;
    }
    if ((node->flags & 0x1000) == 0) {
      dflt = *(char **)((node[1].prev)->padding + (long)i * 8 + -0x1c);
    }
    else {
      pcVar3 = strchr(*(char **)((node[1].prev)->padding + (long)i * 8 + -0x1c),0x3a);
      if (pcVar3 == (char *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("strchr(llist->dflt[i], \':\')",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_yin.c"
                      ,0x4b3,"yin_print_leaflist");
      }
      pcVar3 = strchr(*(char **)((node[1].prev)->padding + (long)i * 8 + -0x1c),0x3a);
      lVar1 = *(long *)((node[1].prev)->padding + (long)i * 8 + -0x1c);
      plVar4 = lys_node_module(node);
      iVar2 = strncmp(*(char **)((node[1].prev)->padding + (long)i * 8 + -0x1c),plVar4->name,
                      (long)pcVar3 - lVar1);
      if (iVar2 == 0) {
        pcVar3 = strchr(*(char **)((node[1].prev)->padding + (long)i * 8 + -0x1c),0x3a);
        dflt = lydict_insert(node->module->ctx,pcVar3 + 1,0);
      }
      else {
        dflt = transform_json2schema
                         (node->module,*(char **)((node[1].prev)->padding + (long)i * 8 + -0x1c));
      }
    }
    yin_print_substmt(out,level_00,LYEXT_SUBSTMT_DEFAULT,(uint8_t)i,dflt,node->module,node->ext,
                      (uint)node->ext_size);
    if ((node->flags & 0x1000) != 0) {
      lydict_remove(node->module->ctx,dflt);
    }
    i = i + 1;
  } while( true );
}



void yin_print_list(lyout *out,int level,lys_node *node)

{
  int level_00;
  int iVar1;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int content;
  int content2;
  int i;
  int p;
  lys_node *sub;
  lys_node_list *list;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  list = (lys_node_list *)node;
  yin_print_open(out,level,(char *)0x0,"list","name",node->name,0);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,node,node->module,&content,1);
  if (list->when != (lys_when *)0x0) {
    yin_print_close_parent(out,&content);
    yin_print_when(out,level_00,list->module,list->when);
  }
  for (i = 0; i < (int)(uint)list->iffeature_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_iffeature(out,level_00,node->module,list->iffeature + i);
  }
  for (i = 0; i < (int)(uint)list->must_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_must(out,level_00,list->module,list->must + i);
  }
  if (list->keys_size != '\0') {
    yin_print_close_parent(out,&content);
    yin_print_substmt(out,level_00,LYEXT_SUBSTMT_KEY,'\0',list->keys_str,node->module,node->ext,
                      (uint)node->ext_size);
  }
  i = 0;
  do {
    if ((int)(uint)list->unique_size <= i) {
      yin_print_snode_common(out,level_00,node,node->module,&content,4);
      if (list->min != 0) {
        yin_print_close_parent(out,&content);
        yin_print_unsigned(out,level_00,LYEXT_SUBSTMT_MIN,'\0',node->module,node->ext,
                           (uint)node->ext_size,list->min);
      }
      if (list->max != 0) {
        yin_print_close_parent(out,&content);
        yin_print_unsigned(out,level_00,LYEXT_SUBSTMT_MAX,'\0',node->module,node->ext,
                           (uint)node->ext_size,list->max);
      }
      if ((list->flags & 0x100) == 0) {
        iVar1 = lys_ext_iter(node->ext,node->ext_size,'\0',LYEXT_SUBSTMT_ORDEREDBY);
        if (iVar1 != -1) {
          yin_print_close_parent(out,&content);
          yin_print_substmt(out,level_00,LYEXT_SUBSTMT_ORDEREDBY,'\0',"system",node->module,
                            node->ext,(uint)node->ext_size);
        }
      }
      else {
        yin_print_close_parent(out,&content);
        yin_print_substmt(out,level_00,LYEXT_SUBSTMT_ORDEREDBY,'\0',"user",node->module,node->ext,
                          (uint)node->ext_size);
      }
      yin_print_snode_common(out,level_00,node,node->module,&content,0x70);
      for (i = 0; i < (int)(uint)list->tpdf_size; i = i + 1) {
        yin_print_close_parent(out,&content);
        yin_print_typedef(out,level_00,list->module,list->tpdf + i);
      }
      for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
        if (node == sub->parent) {
          yin_print_close_parent(out,&content);
          yin_print_snode(out,level_00,sub,0x800);
        }
      }
      for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
        if (node == sub->parent) {
          yin_print_close_parent(out,&content);
          yin_print_snode(out,level_00,sub,0x903f);
        }
      }
      for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
        if (node == sub->parent) {
          yin_print_close_parent(out,&content);
          yin_print_snode(out,level_00,sub,0x4000);
        }
      }
      for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
        if (node == sub->parent) {
          yin_print_close_parent(out,&content);
          yin_print_snode(out,level_00,sub,0x80);
        }
      }
      yin_print_close(out,level,(char *)0x0,"list",content);
      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return;
    }
    yin_print_close_parent(out,&content);
    yin_print_unique(out,level_00,node->module,list->unique + i);
    content2 = 0;
    p = -1;
    do {
      p = lys_ext_iter(list->ext,list->ext_size,(char)p + '\x01',LYEXT_SUBSTMT_UNIQUE);
      if (p == -1) break;
    } while (i != (uint)list->ext[p]->insubstmt_index);
    if (p != -1) {
      yin_print_close_parent(out,&content2);
      do {
        yin_print_extension_instances
                  (out,level + 2,list->module,LYEXT_SUBSTMT_UNIQUE,(uint8_t)i,list->ext + p,1);
        do {
          p = lys_ext_iter(list->ext,list->ext_size,(char)p + '\x01',LYEXT_SUBSTMT_UNIQUE);
          if (p == -1) break;
        } while (i != (uint)list->ext[p]->insubstmt_index);
      } while (p != -1);
    }
    yin_print_close(out,level_00,(char *)0x0,"unique",content2);
    i = i + 1;
  } while( true );
}



void yin_print_grouping(lyout *out,int level,lys_node *node)

{
  int level_00;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int content;
  int i;
  lys_node *sub;
  lys_node_grp *grp;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  grp = (lys_node_grp *)node;
  yin_print_open(out,level,(char *)0x0,"grouping","name",node->name,0);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,node,node->module,&content,0x71);
  for (i = 0; i < (int)(uint)grp->tpdf_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_typedef(out,level_00,node->module,grp->tpdf + i);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    yin_print_close_parent(out,&content);
    yin_print_snode(out,level_00,sub,0x800);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    yin_print_close_parent(out,&content);
    yin_print_snode(out,level_00,sub,0x903f);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    yin_print_close_parent(out,&content);
    yin_print_snode(out,level_00,sub,0x4000);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    yin_print_close_parent(out,&content);
    yin_print_snode(out,level_00,sub,0x80);
  }
  yin_print_close(out,level,(char *)0x0,"grouping",content);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_uses(lyout *out,int level,lys_node *node)

{
  int level_00;
  lys_module *plVar1;
  char *pcVar2;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int content;
  int i;
  lys_node_uses *uses;
  lys_module *mod;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  uses = (lys_node_uses *)node;
  ly_print(out,"%*s<uses name=\"",(ulong)(uint)(level * 2),&DAT_0022d460);
  if (node->child != (lys_node *)0x0) {
    mod = lys_node_module(node->child);
    plVar1 = lys_node_module(node);
    if (mod != plVar1) {
      pcVar2 = transform_module_name2import_prefix(node->module,mod->name);
      ly_print(out,"%s:",pcVar2);
    }
  }
  ly_print(out,"%s\"",uses->name);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,node,node->module,&content,1);
  if (uses->when != (lys_when *)0x0) {
    yin_print_close_parent(out,&content);
    yin_print_when(out,level_00,node->module,uses->when);
  }
  yin_print_snode_common(out,level_00,node,node->module,&content,0x72);
  for (i = 0; i < (int)(uint)uses->refine_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_refine(out,level_00,node->module,uses->refine + i);
  }
  for (i = 0; i < (int)(uint)uses->augment_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_augment(out,level_00,node->module,uses->augment + i);
  }
  yin_print_close(out,level,(char *)0x0,"uses",content);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_input_output(lyout *out,int level,lys_node *node)

{
  int level_00;
  char *pcVar1;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int i;
  lys_node *sub;
  lys_node_inout *inout;
  
  if (node->nodetype == LYS_INPUT) {
    pcVar1 = "input";
  }
  else {
    pcVar1 = "output";
  }
  yin_print_open(out,level,(char *)0x0,pcVar1,(char *)0x0,(char *)0x0,1);
  level_00 = level + 1;
  if (node->ext_size != '\0') {
    yin_print_extension_instances
              (out,level_00,node->module,LYEXT_SUBSTMT_SELF,'\0',node->ext,(uint)node->ext_size);
  }
  for (i = 0; i < (int)(uint)node->padding[1]; i = i + 1) {
    yin_print_must(out,level_00,node->module,(lys_restr *)(node[1].name + (long)i * 0x38));
  }
  for (i = 0; i < (int)(uint)*(ushort *)(node->padding + 2); i = i + 1) {
    yin_print_typedef(out,level_00,node->module,(lys_tpdf *)(*(long *)node->hash + (long)i * 0x80));
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yin_print_snode(out,level_00,sub,0x800);
    }
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yin_print_snode(out,level_00,sub,0x903f);
    }
  }
  if (node->nodetype == LYS_INPUT) {
    pcVar1 = "input";
  }
  else {
    pcVar1 = "output";
  }
  yin_print_close(out,level,(char *)0x0,pcVar1,1);
  return;
}



void yin_print_rpc_action(lyout *out,int level,lys_node *node)

{
  int level_00;
  char *pcVar1;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int content;
  int i;
  lys_node *sub;
  lys_node_rpc_action *rpc;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  if (node->nodetype == LYS_RPC) {
    pcVar1 = "rpc";
  }
  else {
    pcVar1 = "action";
  }
  rpc = (lys_node_rpc_action *)node;
  yin_print_open(out,level,(char *)0x0,pcVar1,"name",node->name,0);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,node,node->module,&content,0x73);
  for (i = 0; i < (int)(uint)rpc->tpdf_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_typedef(out,level_00,node->module,rpc->tpdf + i);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if ((node == sub->parent) &&
       (((sub->nodetype & 0x600) == LYS_UNKNOWN || ((sub->flags & 0x40) == 0)))) {
      yin_print_close_parent(out,&content);
      yin_print_snode(out,level_00,sub,0xe00);
    }
  }
  if (node->nodetype == LYS_RPC) {
    pcVar1 = "rpc";
  }
  else {
    pcVar1 = "action";
  }
  yin_print_close(out,level,(char *)0x0,pcVar1,content);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_notif(lyout *out,int level,lys_node *node)

{
  int level_00;
  long in_FS_OFFSET;
  lys_node *node_local;
  int level_local;
  lyout *out_local;
  int content;
  int i;
  lys_node *sub;
  lys_node_notif *notif;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  content = 0;
  notif = (lys_node_notif *)node;
  yin_print_open(out,level,(char *)0x0,"notification","name",node->name,0);
  level_00 = level + 1;
  yin_print_snode_common(out,level_00,node,node->module,&content,3);
  for (i = 0; i < (int)(uint)notif->must_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_must(out,level_00,node->module,notif->must + i);
  }
  yin_print_snode_common(out,level_00,node,node->module,&content,0x70);
  for (i = 0; i < (int)(uint)notif->tpdf_size; i = i + 1) {
    yin_print_close_parent(out,&content);
    yin_print_typedef(out,level_00,node->module,notif->tpdf + i);
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yin_print_close_parent(out,&content);
      yin_print_snode(out,level_00,sub,0x800);
    }
  }
  for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
    if (node == sub->parent) {
      yin_print_close_parent(out,&content);
      yin_print_snode(out,level_00,sub,0x903f);
    }
  }
  yin_print_close(out,level,(char *)0x0,"notification",content);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_snode(lyout *out,int level,lys_node *node,int mask)

{
  LYS_NODE LVar1;
  lys_node *node_local;
  int mask_local;
  int level_local;
  lyout *out_local;
  
  LVar1 = mask & node->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_001f27c0_caseD_20:
    yin_print_anydata(out,level,node);
    return;
  }
  if (LYS_ANYDATA < LVar1) {
    return;
  }
  if (LVar1 == LYS_ACTION) {
LAB_001f28b2:
    yin_print_rpc_action(out,level,node);
  }
  else {
    if (LYS_ACTION < LVar1) {
      return;
    }
    if (LVar1 == LYS_USES) {
      yin_print_uses(out,level,node);
      return;
    }
    if (LYS_USES < LVar1) {
      return;
    }
    if (LVar1 == LYS_GROUPING) {
      yin_print_grouping(out,level,node);
      return;
    }
    if (LYS_GROUPING < LVar1) {
      return;
    }
    if (LVar1 != LYS_OUTPUT) {
      if (LYS_OUTPUT < LVar1) {
        return;
      }
      if (LVar1 != LYS_INPUT) {
        if (LYS_INPUT < LVar1) {
          return;
        }
        if (LVar1 != LYS_RPC) {
          if (LYS_RPC < LVar1) {
            return;
          }
          if (LVar1 == LYS_NOTIF) {
            yin_print_notif(out,level,node);
            return;
          }
          if (LYS_NOTIF < LVar1) {
            return;
          }
          if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
            if (LVar1 == LYS_UNKNOWN) {
              return;
            }
            if (true) {
              switch(LVar1) {
              case LYS_CONTAINER:
                yin_print_container(out,level,node);
                return;
              case LYS_CHOICE:
                yin_print_choice(out,level,node);
                return;
              default:
                return;
              case LYS_LEAF:
                yin_print_leaf(out,level,node);
                return;
              case LYS_LEAFLIST:
                yin_print_leaflist(out,level,node);
                return;
              case LYS_LIST:
                yin_print_list(out,level,node);
                return;
              case LYS_ANYXML:
                goto switchD_001f27c0_caseD_20;
              }
            }
            return;
          }
          if (LVar1 != LYS_CASE) {
            return;
          }
          yin_print_case(out,level,node);
          return;
        }
        goto LAB_001f28b2;
      }
    }
    yin_print_input_output(out,level,node);
  }
  return;
}



void yin_print_revision(lyout *out,int level,lys_module *module,lys_revision *rev)

{
  int level_00;
  lys_revision *rev_local;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  
  if (((rev->dsc == (char *)0x0) && (rev->ref == (char *)0x0)) && (rev->ext_size == '\0')) {
    yin_print_open(out,level,(char *)0x0,"revision","date",rev->date,-1);
  }
  else {
    yin_print_open(out,level,(char *)0x0,"revision","date",rev->date,1);
    level_00 = level + 1;
    yin_print_extension_instances
              (out,level_00,module,LYEXT_SUBSTMT_SELF,'\0',rev->ext,(uint)rev->ext_size);
    yin_print_substmt(out,level_00,LYEXT_SUBSTMT_DESCRIPTION,'\0',rev->dsc,module,rev->ext,
                      (uint)rev->ext_size);
    yin_print_substmt(out,level_00,LYEXT_SUBSTMT_REFERENCE,'\0',rev->ref,module,rev->ext,
                      (uint)rev->ext_size);
    yin_print_close(out,level,(char *)0x0,"revision",1);
  }
  return;
}



void yin_print_xmlns(lyout *out,lys_module *module)

{
  lys_module *module_local;
  lyout *out_local;
  uint i;
  uint lvl;
  
  if ((module->field_0x40 & 1) == 0) {
    lvl = 8;
  }
  else {
    lvl = 0xb;
  }
  ly_print(out,"%*sxmlns=\"%s\"",(ulong)lvl,&DAT_0022d460,"urn:ietf:params:xml:ns:yang:yin:1");
  if ((module->field_0x40 & 1) == 0) {
    ly_print(out,"\n%*sxmlns:%s=\"%s\"",(ulong)lvl,&DAT_0022d460,module->prefix,module->ns);
  }
  else {
    ly_print(out,"\n%*sxmlns:%s=\"%s\"",(ulong)lvl,&DAT_0022d460,module->prefix,
             module->data[1].parent);
  }
  for (i = 0; i < module->imp_size; i = i + 1) {
    ly_print(out,"\n%*sxmlns:%s=\"%s\"",(ulong)lvl,&DAT_0022d460,module->imp[i].prefix,
             (module->imp[i].module)->ns);
  }
  return;
}



int yin_print_model_(lyout *out,int level,lys_module *module)

{
  int iVar1;
  char *pcVar2;
  lys_module *plVar3;
  lys_module *module_local;
  int level_local;
  lyout *out_local;
  uint i;
  int p;
  lys_node *node;
  
  if ((module->field_0x40 & 0x30) == 0x10) {
    ly_print(out,"<!-- DEVIATED -->\n");
  }
  if ((module->field_0x40 & 1) == 0) {
    ly_print(out,"%*s<module name=\"%s\"\n",(ulong)(uint)(level * 2),&DAT_0022d460,module->name);
    yin_print_xmlns(out,module);
    ly_print(out,">\n");
    iVar1 = level + 1;
    if ((module->field_0x40 & 0xe) != 0) {
      if ((module->field_0x40 & 0xe) == 4) {
        pcVar2 = "1.1";
      }
      else {
        pcVar2 = "1";
      }
      yin_print_substmt(out,iVar1,LYEXT_SUBSTMT_VERSION,'\0',pcVar2,module,module->ext,
                        (uint)module->ext_size);
    }
    yin_print_substmt(out,iVar1,LYEXT_SUBSTMT_NAMESPACE,'\0',module->ns,module,module->ext,
                      (uint)module->ext_size);
    yin_print_substmt(out,iVar1,LYEXT_SUBSTMT_PREFIX,'\0',module->prefix,module,module->ext,
                      (uint)module->ext_size);
  }
  else {
    ly_print(out,"%*s<submodule name=\"%s\"\n",(ulong)(uint)(level * 2),&DAT_0022d460,module->name);
    yin_print_xmlns(out,module);
    ly_print(out,">\n");
    iVar1 = level + 1;
    if ((module->field_0x40 & 0xe) != 0) {
      if ((module->field_0x40 & 0xe) == 4) {
        pcVar2 = "1.1";
      }
      else {
        pcVar2 = "1";
      }
      yin_print_substmt(out,iVar1,LYEXT_SUBSTMT_VERSION,'\0',pcVar2,module,module->ext,
                        (uint)module->ext_size);
    }
    yin_print_open(out,iVar1,(char *)0x0,"belongs-to","module",module->data->dsc,1);
    p = -1;
    while( true ) {
      p = lys_ext_iter(module->ext,module->ext_size,(char)p + '\x01',LYEXT_SUBSTMT_BELONGSTO);
      if (p == -1) break;
      yin_print_extension_instances
                (out,level + 2,module,LYEXT_SUBSTMT_BELONGSTO,'\0',module->ext + p,1);
    }
    yin_print_substmt(out,level + 2,LYEXT_SUBSTMT_PREFIX,'\0',module->prefix,module,module->ext,
                      (uint)module->ext_size);
    yin_print_close(out,iVar1,(char *)0x0,"belongs-to",1);
  }
  level_local = level + 1;
  for (i = 0; i < module->imp_size; i = i + 1) {
    yin_print_open(out,level_local,(char *)0x0,"import","module",(module->imp[i].module)->name,1);
    iVar1 = level + 2;
    yin_print_extension_instances
              (out,iVar1,module,LYEXT_SUBSTMT_SELF,'\0',module->imp[i].ext,
               (uint)module->imp[i].ext_size);
    yin_print_substmt(out,iVar1,LYEXT_SUBSTMT_PREFIX,'\0',module->imp[i].prefix,module,
                      module->imp[i].ext,(uint)module->imp[i].ext_size);
    if (module->imp[i].rev[0] != '\0') {
      yin_print_substmt(out,iVar1,LYEXT_SUBSTMT_REVISIONDATE,'\0',module->imp[i].rev,module,
                        module->imp[i].ext,(uint)module->imp[i].ext_size);
    }
    yin_print_substmt(out,iVar1,LYEXT_SUBSTMT_DESCRIPTION,'\0',module->imp[i].dsc,module,
                      module->imp[i].ext,(uint)module->imp[i].ext_size);
    yin_print_substmt(out,iVar1,LYEXT_SUBSTMT_REFERENCE,'\0',module->imp[i].ref,module,
                      module->imp[i].ext,(uint)module->imp[i].ext_size);
    yin_print_close(out,level_local,(char *)0x0,"import",1);
  }
  for (i = 0; i < module->inc_size; i = i + 1) {
    if ((((module->inc[i].rev[0] == '\0') && (module->inc[i].dsc == (char *)0x0)) &&
        (module->inc[i].ref == (char *)0x0)) && (module->inc[i].ext_size == '\0')) {
      yin_print_open(out,level_local,(char *)0x0,"include","module",(module->inc[i].submodule)->name
                     ,-1);
    }
    else {
      yin_print_open(out,level_local,(char *)0x0,"include","module",(module->inc[i].submodule)->name
                     ,1);
      iVar1 = level + 2;
      yin_print_extension_instances
                (out,iVar1,module,LYEXT_SUBSTMT_SELF,'\0',module->inc[i].ext,
                 (uint)module->inc[i].ext_size);
      if (module->inc[i].rev[0] != '\0') {
        yin_print_substmt(out,iVar1,LYEXT_SUBSTMT_REVISIONDATE,'\0',module->inc[i].rev,module,
                          module->inc[i].ext,(uint)module->inc[i].ext_size);
      }
      yin_print_substmt(out,iVar1,LYEXT_SUBSTMT_DESCRIPTION,'\0',module->inc[i].dsc,module,
                        module->inc[i].ext,(uint)module->inc[i].ext_size);
      yin_print_substmt(out,iVar1,LYEXT_SUBSTMT_REFERENCE,'\0',module->inc[i].ref,module,
                        module->inc[i].ext,(uint)module->inc[i].ext_size);
      yin_print_close(out,level_local,(char *)0x0,"include",1);
    }
  }
  yin_print_substmt(out,level_local,LYEXT_SUBSTMT_ORGANIZATION,'\0',module->org,module,module->ext,
                    (uint)module->ext_size);
  yin_print_substmt(out,level_local,LYEXT_SUBSTMT_CONTACT,'\0',module->contact,module,module->ext,
                    (uint)module->ext_size);
  yin_print_substmt(out,level_local,LYEXT_SUBSTMT_DESCRIPTION,'\0',module->dsc,module,module->ext,
                    (uint)module->ext_size);
  yin_print_substmt(out,level_local,LYEXT_SUBSTMT_REFERENCE,'\0',module->ref,module,module->ext,
                    (uint)module->ext_size);
  for (i = 0; i < module->rev_size; i = i + 1) {
    yin_print_revision(out,level_local,module,module->rev + i);
  }
  for (i = 0; i < module->extensions_size; i = i + 1) {
    yin_print_extension(out,level_local,module->extensions + i);
  }
  if (module->ext_size != '\0') {
    yin_print_extension_instances
              (out,level_local,module,LYEXT_SUBSTMT_SELF,'\0',module->ext,(uint)module->ext_size);
  }
  for (i = 0; i < module->features_size; i = i + 1) {
    yin_print_feature(out,level_local,module->features + i);
  }
  for (i = 0; i < module->ident_size; i = i + 1) {
    yin_print_identity(out,level_local,module->ident + i);
  }
  for (i = 0; i < module->tpdf_size; i = i + 1) {
    yin_print_typedef(out,level_local,module,module->tpdf + i);
  }
  plVar3 = lys_main_module(module);
  for (node = plVar3->data; node != (lys_node *)0x0; node = node->next) {
    if (module == node->module) {
      yin_print_snode(out,level_local,node,0x800);
    }
  }
  plVar3 = lys_main_module(module);
  for (node = plVar3->data; node != (lys_node *)0x0; node = node->next) {
    if (module == node->module) {
      yin_print_snode(out,level_local,node,0x903f);
    }
  }
  for (i = 0; i < module->augment_size; i = i + 1) {
    yin_print_augment(out,level_local,module,module->augment + i);
  }
  plVar3 = lys_main_module(module);
  for (node = plVar3->data; node != (lys_node *)0x0; node = node->next) {
    if (module == node->module) {
      yin_print_snode(out,level_local,node,0x4100);
    }
  }
  plVar3 = lys_main_module(module);
  for (node = plVar3->data; node != (lys_node *)0x0; node = node->next) {
    if (module == node->module) {
      yin_print_snode(out,level_local,node,0x80);
    }
  }
  for (i = 0; i < module->deviation_size; i = i + 1) {
    yin_print_deviation(out,level_local,module,module->deviation + i);
  }
  if ((module->field_0x40 & 1) == 0) {
    ly_print(out,"%*s</module>\n",(ulong)(uint)(level * 2),&DAT_0022d460);
  }
  else {
    ly_print(out,"%*s</submodule>\n",(ulong)(uint)(level * 2),&DAT_0022d460);
  }
  ly_print_flush(out);
  return 0;
}



int yin_print_model(lyout *out,lys_module *module)

{
  int iVar1;
  lys_module *module_local;
  lyout *out_local;
  int level;
  
  ly_print(out,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
  iVar1 = yin_print_model_(out,0,module);
  return iVar1;
}



void yin_print_extcomplex_bool
               (lyout *out,int level,lys_module *module,lys_ext_instance_complex *ext,LY_STMT stmt,
               char *true_val,char *false_val,int *content)

{
  long in_FS_OFFSET;
  int *content_local;
  char *false_val_local;
  char *true_val_local;
  lys_ext_instance_complex *ext_local;
  lys_module *module_local;
  LY_STMT stmt_local;
  int level_local;
  lyout *out_local;
  lyext_substmt *info;
  uint8_t *val;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  val = (uint8_t *)lys_ext_complex_get_substmt(stmt,ext,&info);
  if ((val != (uint8_t *)0x0) && (*val != '\0')) {
    yin_print_close_parent(out,content);
    if (*val == '\x01') {
      yin_print_substmt(out,level,stmt,'\0',true_val,module,ext->ext,(uint)ext->ext_size);
    }
    else if (*val == '\x02') {
      yin_print_substmt(out,level,stmt,'\0',false_val,module,ext->ext,(uint)ext->ext_size);
    }
    else {
      ly_log(module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_yin.c"
             ,0x731);
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void yin_print_extcomplex_str
               (lyout *out,int level,lys_module *module,lys_ext_instance_complex *ext,LY_STMT stmt,
               int *content)

{
  long in_FS_OFFSET;
  int *content_local;
  lys_ext_instance_complex *ext_local;
  lys_module *module_local;
  LY_STMT stmt_local;
  int level_local;
  lyout *out_local;
  int c;
  lyext_substmt *info;
  char **str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  str = (char **)lys_ext_complex_get_substmt(stmt,ext,&info);
  if ((str != (char **)0x0) && (*str != (char *)0x0)) {
    if (info->cardinality < LY_STMT_CARD_SOME) {
      yin_print_close_parent(out,content);
      yin_print_substmt(out,level,stmt,'\0',*str,module,ext->ext,(uint)ext->ext_size);
    }
    else {
      str = (char **)*str;
      c = 0;
      for (; *str != (char *)0x0; str = str + 1) {
        yin_print_close_parent(out,content);
        yin_print_substmt(out,level,stmt,(uint8_t)c,*str,module,ext->ext,(uint)ext->ext_size);
        c = c + 1;
      }
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void yin_print_extcomplex_flags
               (lyout *out,int level,lys_module *module,lys_ext_instance_complex *ext,LY_STMT stmt,
               char *val1_str,char *val2_str,uint16_t val1,uint16_t val2,int *content)

{
  int iVar1;
  ushort *puVar2;
  uint16_t val2_local;
  uint16_t val1_local;
  char *val1_str_local;
  lys_ext_instance_complex *ext_local;
  lys_module *module_local;
  LY_STMT stmt_local;
  int level_local;
  lyout *out_local;
  char *str;
  uint16_t *flags;
  
  puVar2 = (ushort *)lys_ext_complex_get_substmt(stmt,ext,(lyext_substmt **)0x0);
  if (puVar2 != (ushort *)0x0) {
    str = val1_str;
    if ((*puVar2 & val1) == 0) {
      if ((*puVar2 & val2) == 0) {
        iVar1 = lys_ext_iter(ext->ext,ext->ext_size,'\0',stmt);
        if (iVar1 == -1) {
          return;
        }
      }
      else {
        str = val2_str;
      }
    }
    yin_print_close_parent(out,content);
    yin_print_substmt(out,level,stmt,'\0',str,module,ext->ext,(uint)ext->ext_size);
  }
  return;
}



void yin_print_extension_instances
               (lyout *out,int level,lys_module *module,LYEXT_SUBSTMT substmt,uint8_t substmt_index,
               lys_ext_instance **ext,uint count)

{
  int iVar1;
  int iVar2;
  LY_STMT LVar3;
  lys_module *plVar4;
  char *pcVar5;
  long in_FS_OFFSET;
  lys_ext_instance **ext_local;
  uint8_t substmt_index_local;
  lys_module *module_local;
  LYEXT_SUBSTMT substmt_local;
  int level_local;
  lyout *out_local;
  int content;
  int content2;
  uint u;
  uint x;
  int i;
  int j;
  int c;
  char *prefix;
  char *str;
  void **pp;
  lys_node *siter;
  lys_module *mod;
  lyext_substmt *info;
  void *p;
  uint16_t *flags;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  prefix = (char *)0x0;
  u = 0;
  do {
    if (count <= u) {
      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
        return;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    if (((((ext[u]->flags & 1) == 0) && (substmt == (uint)ext[u]->insubstmt)) &&
        (substmt_index == ext[u]->insubstmt_index)) &&
       ((ext[u]->def->module != *(module->ctx->models).list ||
        (((iVar1 = strcmp(ext[u]->arg_value,"operation"), iVar1 != 0 &&
          (iVar1 = strcmp(ext[u]->arg_value,"select"), iVar1 != 0)) &&
         (iVar1 = strcmp(ext[u]->arg_value,"type"), iVar1 != 0)))))) {
      mod = lys_main_module(ext[u]->def->module);
      plVar4 = lys_main_module(module);
      if (mod == plVar4) {
        prefix = module->prefix;
      }
      else {
        for (x = 0; x < module->imp_size; x = x + 1) {
          if (mod == module->imp[x].module) {
            prefix = module->imp[x].prefix;
            break;
          }
        }
      }
      if (prefix == (char *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("prefix",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_yin.c"
                      ,0x7c5,"yin_print_extension_instances");
      }
      content = 0;
      if (ext[u]->arg_value == (char *)0x0) {
        yin_print_open(out,level,prefix,ext[u]->def->name,(char *)0x0,(char *)0x0,0);
      }
      else if ((ext[u]->def->flags & 1) == 0) {
        yin_print_open(out,level,prefix,ext[u]->def->name,ext[u]->def->argument,ext[u]->arg_value,0)
        ;
      }
      else {
        content = 1;
        yin_print_open(out,level,prefix,ext[u]->def->name,(char *)0x0,(char *)0x0,1);
        ly_print(out,"%*s<%s:%s>",(ulong)(uint)((level + 1) * 2),&DAT_0022d460,prefix,
                 ext[u]->def->argument);
        lyxml_dump_text(out,ext[u]->arg_value,LYXML_DATA_ELEM);
        ly_print(out,"</%s:%s>\n",prefix,ext[u]->def->argument);
      }
      if (ext[u]->ext_size != '\0') {
        yin_print_close_parent(out,&content);
        yin_print_extension_instances
                  (out,level + 1,module,LYEXT_SUBSTMT_SELF,'\0',ext[u]->ext,(uint)ext[u]->ext_size);
      }
      if (((ext[u]->ext_type != '\0') && (ext[u]->ext_type == '\x01')) &&
         (info = (lyext_substmt *)ext[u][1].def, (lys_ext *)info != (lys_ext *)0x0)) {
        iVar1 = level + 1;
        i = 0;
        while (info[i].stmt != LY_STMT_UNKNOWN) {
          if (true) {
            switch(info[i].stmt) {
            case LY_STMT_ARGUMENT:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_ARGUMENT,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                yin_print_close_parent(out,&content);
                if (info->cardinality < LY_STMT_CARD_SOME) {
                  content2 = 0;
                  yin_print_open(out,iVar1,(char *)0x0,"argument","name",(char *)*pp,0);
                  j = -1;
                  while (j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                          LYEXT_SUBSTMT_ARGUMENT), j != -1) {
                    yin_print_close_parent(out,&content2);
                    yin_print_extension_instances
                              (out,level + 2,module,LYEXT_SUBSTMT_ARGUMENT,'\0',ext[u]->ext + j,1);
                  }
                  if ((*(char *)(pp + 1) == '\x01') ||
                     (iVar2 = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,'\0',LYEXT_SUBSTMT_YINELEM),
                     iVar2 != -1)) {
                    yin_print_close_parent(out,&content2);
                    if (*(char *)(pp + 1) == '\x01') {
                      pcVar5 = "true";
                    }
                    else {
                      pcVar5 = "false";
                    }
                    yin_print_substmt(out,level + 2,LYEXT_SUBSTMT_YINELEM,'\0',pcVar5,module,
                                      ext[u]->ext,(uint)ext[u]->ext_size);
                  }
                  yin_print_close(out,iVar1,(char *)0x0,"argument",content2);
                }
                else {
                  c = 0;
                  while (*(long *)((long)*pp + (long)c * 8) != 0) {
                    content2 = 0;
                    yin_print_open(out,iVar1,(char *)0x0,"argument","name",
                                   *(char **)((long)*pp + (long)c * 8),0);
                    j = -1;
                    while (j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                            LYEXT_SUBSTMT_ARGUMENT), j != -1) {
                      if (c == (uint)ext[u]->ext[j]->insubstmt_index) {
                        yin_print_close_parent(out,&content2);
                        yin_print_extension_instances
                                  (out,level + 2,module,LYEXT_SUBSTMT_ARGUMENT,(uint8_t)c,
                                   ext[u]->ext + j,1);
                      }
                    }
                    if (*(char *)((long)c + (long)pp[1]) == '\x01') {
                      yin_print_close_parent(out,&content2);
                      if (*(char *)((long)c + (long)pp[1]) == '\x01') {
                        pcVar5 = "true";
                      }
                      else {
                        pcVar5 = "false";
                      }
                      yin_print_substmt(out,level + 2,LYEXT_SUBSTMT_YINELEM,(uint8_t)c,pcVar5,module
                                        ,ext[u]->ext,(uint)ext[u]->ext_size);
                    }
                    else {
                      j = -1;
                      do {
                        j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                         LYEXT_SUBSTMT_YINELEM);
                        if (j == -1) goto LAB_001f4a7c;
                      } while (c != (uint)ext[u]->ext[j]->insubstmt_index);
                      yin_print_close_parent(out,&content2);
                      if (*(char *)((long)c + (long)pp[1]) == '\x01') {
                        pcVar5 = "true";
                      }
                      else {
                        pcVar5 = "false";
                      }
                      yin_print_substmt(out,level + 2,LYEXT_SUBSTMT_YINELEM,(uint8_t)c,pcVar5,module
                                        ,ext[u]->ext + j,(uint)ext[u]->ext_size - j);
                    }
LAB_001f4a7c:
                    yin_print_close(out,iVar1,(char *)0x0,"argument",content2);
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_BASE:
            case LY_STMT_CONTACT:
            case LY_STMT_DEFAULT:
            case LY_STMT_DESCRIPTION:
            case LY_STMT_ERRTAG:
            case LY_STMT_ERRMSG:
            case LY_STMT_KEY:
            case LY_STMT_NAMESPACE:
            case LY_STMT_ORGANIZATION:
            case LY_STMT_PATH:
            case LY_STMT_PREFIX:
            case LY_STMT_PRESENCE:
            case LY_STMT_REFERENCE:
            case LY_STMT_REVISIONDATE:
            case LY_STMT_UNITS:
              yin_print_extcomplex_str
                        (out,iVar1,module,(lys_ext_instance_complex *)ext[u],info[i].stmt,&content);
              break;
            case LY_STMT_BELONGSTO:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_BELONGSTO,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info->cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                  yin_print_open(out,iVar1,(char *)0x0,"belongs-to","module",(char *)*pp,1);
                  j = -1;
                  while (j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                          LYEXT_SUBSTMT_BELONGSTO), j != -1) {
                    yin_print_extension_instances
                              (out,level + 2,module,LYEXT_SUBSTMT_BELONGSTO,'\0',ext[u]->ext + j,1);
                  }
                  yin_print_substmt(out,level + 2,LYEXT_SUBSTMT_PREFIX,'\0',(char *)pp[1],module,
                                    ext[u]->ext,(uint)ext[u]->ext_size);
                  yin_print_close(out,iVar1,(char *)0x0,"belongs-to",1);
                }
                else {
                  c = 0;
                  while (*(long *)((long)*pp + (long)c * 8) != 0) {
                    yin_print_close_parent(out,&content);
                    yin_print_open(out,iVar1,(char *)0x0,"belongs-to","module",
                                   *(char **)((long)*pp + (long)c * 8),1);
                    j = -1;
                    while( true ) {
                      j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                       LYEXT_SUBSTMT_BELONGSTO);
                      if (j == -1) break;
                      yin_print_extension_instances
                                (out,level + 2,module,LYEXT_SUBSTMT_BELONGSTO,(uint8_t)c,
                                 ext[u]->ext + j,1);
                    }
                    yin_print_substmt(out,level + 2,LYEXT_SUBSTMT_PREFIX,(uint8_t)c,
                                      *(char **)((long)pp[1] + (long)c * 8),module,ext[u]->ext,
                                      (uint)ext[u]->ext_size);
                    yin_print_close(out,iVar1,(char *)0x0,"belongs-to",1);
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_VALUE:
              p = (void *)((long)&ext[u][1].parent + info[i].offset);
                    // WARNING: Load size is inaccurate
              if (((long *)p != (long *)0x0) && (*p != 0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                    // WARNING: Load size is inaccurate
                  yin_print_signed(out,iVar1,LYEXT_SUBSTMT_VALUE,'\0',module,ext[u]->ext,
                                   (uint)ext[u]->ext_size,**p);
                }
                else {
                  c = 0;
                    // WARNING: Load size is inaccurate
                  while (*(long *)(*p + (long)c * 8) != 0) {
                    yin_print_close_parent(out,&content);
                    // WARNING: Load size is inaccurate
                    yin_print_signed(out,iVar1,LYEXT_SUBSTMT_VALUE,(uint8_t)c,module,ext[u]->ext,
                                     (uint)ext[u]->ext_size,**(int **)(*p + (long)c * 8));
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_MODIFIER:
              yin_print_extcomplex_bool
                        (out,iVar1,module,(lys_ext_instance_complex *)ext[u],LY_STMT_MODIFIER,
                         "invert-match",(char *)0x0,&content);
              break;
            case LY_STMT_REQINSTANCE:
              yin_print_extcomplex_bool
                        (out,iVar1,module,(lys_ext_instance_complex *)ext[u],info[i].stmt,"true",
                         "false",&content);
              break;
            case LY_STMT_CONFIG:
              yin_print_extcomplex_flags
                        (out,iVar1,module,(lys_ext_instance_complex *)ext[u],LY_STMT_CONFIG,"true",
                         "false",5,6,&content);
              break;
            case LY_STMT_MANDATORY:
              yin_print_extcomplex_flags
                        (out,iVar1,module,(lys_ext_instance_complex *)ext[u],LY_STMT_MANDATORY,
                         "false","true",0x80,0x40,&content);
              break;
            case LY_STMT_ORDEREDBY:
              yin_print_extcomplex_flags
                        (out,iVar1,module,(lys_ext_instance_complex *)ext[u],LY_STMT_ORDEREDBY,
                         "system","user",0,0x100,&content);
              break;
            case LY_STMT_STATUS:
              flags = (uint16_t *)((long)&ext[u][1].parent + info[i].offset);
              if ((flags != (ushort *)0x0) && (*flags != 0)) {
                if ((*flags & 8) == 0) {
                  if ((*flags & 0x10) == 0) {
                    if ((*flags & 0x20) == 0) break;
                    yin_print_close_parent(out,&content);
                    str = "obsolete";
                  }
                  else {
                    yin_print_close_parent(out,&content);
                    str = "deprecated";
                  }
                }
                else {
                  yin_print_close_parent(out,&content);
                  str = "current";
                }
                yin_print_substmt(out,iVar1,LYEXT_SUBSTMT_STATUS,'\0',str,module,ext[u]->ext,
                                  (uint)ext[u]->ext_size);
              }
              break;
            case LY_STMT_DIGITS:
              p = (void *)((long)&ext[u][1].parent + info[i].offset);
              if ((long *)p != (long *)0x0) {
                    // WARNING: Load size is inaccurate
                if ((info->cardinality < LY_STMT_CARD_SOME) || (*p == 0)) {
                    // WARNING: Load size is inaccurate
                  if (*p != '\0') {
                    yin_print_close_parent(out,&content);
                    // WARNING: Load size is inaccurate
                    yin_print_unsigned(out,iVar1,LYEXT_SUBSTMT_DIGITS,'\0',module,ext[u]->ext,
                                       (uint)ext[u]->ext_size,(uint)*p);
                  }
                }
                else {
                    // WARNING: Load size is inaccurate
                  for (c = 0; *(char *)((long)c + *p) != '\0'; c = c + 1) {
                    yin_print_close_parent(out,&content);
                    // WARNING: Load size is inaccurate
                    yin_print_unsigned(out,iVar1,LYEXT_SUBSTMT_DIGITS,(uint8_t)c,module,ext[u]->ext,
                                       (uint)ext[u]->ext_size,(uint)*(byte *)((long)c + *p));
                  }
                }
              }
              break;
            case LY_STMT_MAX:
              p = (void *)((long)&ext[u][1].parent + info[i].offset);
                    // WARNING: Load size is inaccurate
              if (((long *)p != (long *)0x0) && (*p != 0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                    // WARNING: Load size is inaccurate
                  yin_print_unsigned(out,iVar1,LYEXT_SUBSTMT_MAX,'\0',module,ext[u]->ext,
                                     (uint)ext[u]->ext_size,**p);
                }
                else {
                  c = 0;
                    // WARNING: Load size is inaccurate
                  while (*(long *)(*p + (long)c * 8) != 0) {
                    yin_print_close_parent(out,&content);
                    // WARNING: Load size is inaccurate
                    yin_print_unsigned(out,iVar1,LYEXT_SUBSTMT_MAX,(uint8_t)c,module,ext[u]->ext,
                                       (uint)ext[u]->ext_size,**(uint **)(*p + (long)c * 8));
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_MIN:
              p = (void *)((long)&ext[u][1].parent + info[i].offset);
                    // WARNING: Load size is inaccurate
              if (((long *)p != (long *)0x0) && (*p != 0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                    // WARNING: Load size is inaccurate
                  yin_print_unsigned(out,iVar1,LYEXT_SUBSTMT_MIN,'\0',module,ext[u]->ext,
                                     (uint)ext[u]->ext_size,**p);
                }
                else {
                  c = 0;
                    // WARNING: Load size is inaccurate
                  while (*(long *)(*p + (long)c * 8) != 0) {
                    yin_print_close_parent(out,&content);
                    // WARNING: Load size is inaccurate
                    yin_print_unsigned(out,iVar1,LYEXT_SUBSTMT_MIN,(uint8_t)c,module,ext[u]->ext,
                                       (uint)ext[u]->ext_size,**(uint **)(*p + (long)c * 8));
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_POSITION:
              p = (void *)((long)&ext[u][1].parent + info[i].offset);
                    // WARNING: Load size is inaccurate
              if (((long *)p != (long *)0x0) && (*p != 0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                    // WARNING: Load size is inaccurate
                  yin_print_unsigned(out,iVar1,LYEXT_SUBSTMT_POSITION,'\0',module,ext[u]->ext,
                                     (uint)ext[u]->ext_size,**p);
                }
                else {
                  c = 0;
                    // WARNING: Load size is inaccurate
                  while (*(long *)(*p + (long)c * 8) != 0) {
                    yin_print_close_parent(out,&content);
                    // WARNING: Load size is inaccurate
                    yin_print_unsigned(out,iVar1,LYEXT_SUBSTMT_POSITION,(uint8_t)c,module,
                                       ext[u]->ext,(uint)ext[u]->ext_size,
                                       **(uint **)(*p + (long)c * 8));
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_UNIQUE:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_UNIQUE,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                  yin_print_unique(out,iVar1,module,(lys_unique *)*pp);
                  j = -1;
                  content2 = 0;
                  while (j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                          LYEXT_SUBSTMT_UNIQUE), j != -1) {
                    yin_print_close_parent(out,&content2);
                    yin_print_extension_instances
                              (out,level + 2,module,LYEXT_SUBSTMT_UNIQUE,'\0',ext[u]->ext + j,1);
                  }
                  yin_print_close(out,iVar1,(char *)0x0,"unique",content2);
                }
                else {
                  pp = (void **)*pp;
                  c = 0;
                  for (; *pp != (void *)0x0; pp = pp + 1) {
                    yin_print_close_parent(out,&content);
                    yin_print_unique(out,iVar1,module,(lys_unique *)*pp);
                    j = -1;
                    content2 = 0;
                    do {
                      j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                       LYEXT_SUBSTMT_UNIQUE);
                      if (j == -1) break;
                    } while (c != (uint)ext[u]->ext[j]->insubstmt_index);
                    if (j != -1) {
                      yin_print_close_parent(out,&content2);
                      do {
                        yin_print_extension_instances
                                  (out,level + 2,module,LYEXT_SUBSTMT_UNIQUE,(uint8_t)c,
                                   ext[u]->ext + j,1);
                        do {
                          j = lys_ext_iter(ext[u]->ext,ext[u]->ext_size,(char)j + '\x01',
                                           LYEXT_SUBSTMT_UNIQUE);
                          if (j == -1) break;
                        } while (c != (uint)ext[u]->ext[j]->insubstmt_index);
                      } while (j != -1);
                    }
                    yin_print_close(out,iVar1,(char *)0x0,"unique",content2);
                    c = c + 1;
                  }
                }
              }
              break;
            case LY_STMT_MODULE:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_MODULE,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                  yin_print_model_(out,iVar1,(lys_module *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yin_print_close_parent(out,&content);
                    yin_print_model_(out,iVar1,(lys_module *)*pp);
                  }
                }
              }
              break;
            case LY_STMT_ACTION:
            case LY_STMT_ANYDATA:
            case LY_STMT_ANYXML:
            case LY_STMT_CASE:
            case LY_STMT_CHOICE:
            case LY_STMT_CONTAINER:
            case LY_STMT_GROUPING:
            case LY_STMT_INPUT:
            case LY_STMT_LEAF:
            case LY_STMT_LEAFLIST:
            case LY_STMT_LIST:
            case LY_STMT_NOTIFICATION:
            case LY_STMT_OUTPUT:
            case LY_STMT_USES:
              pp = (void **)lys_ext_complex_get_substmt
                                      (info[i].stmt,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                for (siter = (lys_node *)*pp; siter != (lys_node *)0x0; siter = siter->next) {
                  LVar3 = lys_snode2stmt(siter->nodetype);
                  if (LVar3 == info[i].stmt) {
                    yin_print_close_parent(out,&content);
                    yin_print_snode(out,iVar1,siter,0xffff);
                  }
                }
              }
              break;
            case LY_STMT_TYPEDEF:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_TYPEDEF,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                  yin_print_typedef(out,iVar1,module,(lys_tpdf *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yin_print_close_parent(out,&content);
                    yin_print_typedef(out,iVar1,module,(lys_tpdf *)*pp);
                  }
                }
              }
              break;
            case LY_STMT_TYPE:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_TYPE,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                  yin_print_type(out,iVar1,module,(lys_type *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yin_print_close_parent(out,&content);
                    yin_print_type(out,iVar1,module,(lys_type *)*pp);
                  }
                }
              }
              break;
            case LY_STMT_IFFEATURE:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_IFFEATURE,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                  yin_print_iffeature(out,iVar1,module,(lys_iffeature *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yin_print_close_parent(out,&content);
                    yin_print_iffeature(out,iVar1,module,(lys_iffeature *)*pp);
                  }
                }
              }
              break;
            case LY_STMT_LENGTH:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_LENGTH,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                  yin_print_typerestr(out,iVar1,module,(lys_restr *)*pp,"length");
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yin_print_close_parent(out,&content);
                    yin_print_typerestr(out,iVar1,module,(lys_restr *)*pp,"length");
                  }
                }
              }
              break;
            case LY_STMT_MUST:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_MUST,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                  yin_print_must(out,iVar1,module,(lys_restr *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yin_print_close_parent(out,&content);
                    yin_print_must(out,iVar1,module,(lys_restr *)*pp);
                  }
                }
              }
              break;
            case LY_STMT_PATTERN:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_PATTERN,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                  yin_print_typerestr(out,iVar1,module,(lys_restr *)*pp,"pattern");
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yin_print_close_parent(out,&content);
                    yin_print_typerestr(out,iVar1,module,(lys_restr *)*pp,"pattern");
                  }
                }
              }
              break;
            case LY_STMT_RANGE:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_RANGE,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                  yin_print_typerestr(out,iVar1,module,(lys_restr *)*pp,"range");
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yin_print_close_parent(out,&content);
                    yin_print_typerestr(out,iVar1,module,(lys_restr *)*pp,"range");
                  }
                }
              }
              break;
            case LY_STMT_WHEN:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_WHEN,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                  yin_print_when(out,iVar1,module,(lys_when *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yin_print_close_parent(out,&content);
                    yin_print_when(out,iVar1,module,(lys_when *)*pp);
                  }
                }
              }
              break;
            case LY_STMT_REVISION:
              pp = (void **)lys_ext_complex_get_substmt
                                      (LY_STMT_REVISION,(lys_ext_instance_complex *)ext[u],
                                       (lyext_substmt **)0x0);
              if ((pp != (void **)0x0) && (*pp != (void *)0x0)) {
                if (info[i].cardinality < LY_STMT_CARD_SOME) {
                  yin_print_close_parent(out,&content);
                  yin_print_revision(out,iVar1,module,(lys_revision *)*pp);
                }
                else {
                  for (pp = (void **)*pp; *pp != (void *)0x0; pp = pp + 1) {
                    yin_print_close_parent(out,&content);
                    yin_print_revision(out,iVar1,module,(lys_revision *)*pp);
                  }
                }
              }
            }
          }
          i = i + 1;
        }
      }
      yin_print_close(out,level,prefix,ext[u]->def->name,content);
    }
    u = u + 1;
  } while( true );
}



char * jsons_nodetype_str(LYS_NODE value)

{
  LYS_NODE value_local;
  
  if (value == LYS_ANYDATA) {
    return "anydata";
  }
  if (value < (LYS_CONTAINER|LYS_ANYDATA)) {
    if (value == LYS_ACTION) {
      return "action";
    }
    if (value < (LYS_CONTAINER|LYS_ACTION)) {
      if (value == LYS_OUTPUT) {
        return "output";
      }
      if (value < (LYS_CONTAINER|LYS_OUTPUT)) {
        if (value == LYS_INPUT) {
          return "input";
        }
        if (value < (LYS_CONTAINER|LYS_INPUT)) {
          if (value == LYS_RPC) {
            return "rpc";
          }
          if (value < (LYS_CONTAINER|LYS_RPC)) {
            if (value == LYS_NOTIF) {
              return "notification";
            }
            if (value < (LYS_CONTAINER|LYS_NOTIF)) {
              if (value < (LYS_CONTAINER|LYS_ANYXML)) {
                if ((value != LYS_UNKNOWN) && (true)) {
                  switch(value) {
                  case LYS_CONTAINER:
                    return "container";
                  case LYS_CHOICE:
                    return "choice";
                  case LYS_LEAF:
                    return "leaf";
                  case LYS_LEAFLIST:
                    return "leaf-list";
                  case LYS_LIST:
                    return "list";
                  case LYS_ANYXML:
                    return "anyxml";
                  }
                }
              }
              else if (value == LYS_CASE) {
                return "case";
              }
            }
          }
        }
      }
    }
  }
  return (char *)0x0;
}



void jsons_print_text(lyout *out,char *label,char *arg,char *text,int closeit,int *first)

{
  undefined *puVar1;
  int *first_local;
  int closeit_local;
  char *text_local;
  char *arg_local;
  char *label_local;
  lyout *out_local;
  
  if (text != (char *)0x0) {
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"%s\":{\"%s\":",puVar1,label,arg);
    json_print_string(out,text);
    if (closeit != 0) {
      ly_print(out,"}");
    }
    if (first != (int *)0x0) {
      *first = 0;
    }
  }
  return;
}



void jsons_print_object(lyout *out,char *label,char *arg,char *val,int closeit,int *first)

{
  undefined *puVar1;
  undefined *puVar2;
  int *first_local;
  int closeit_local;
  char *val_local;
  char *arg_local;
  char *label_local;
  lyout *out_local;
  
  if (val != (char *)0x0) {
    if (closeit == 0) {
      puVar2 = &DAT_0022dce4;
    }
    else {
      puVar2 = &DAT_0022dcf5;
    }
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"%s\":{\"%s\":\"%s\"%s",puVar1,label,arg,val,puVar2);
    if (first != (int *)0x0) {
      *first = 0;
    }
  }
  return;
}



void jsons_print_status(lyout *out,uint16_t flags,int *first)

{
  int *first_local;
  uint16_t flags_local;
  lyout *out_local;
  char *str;
  
  if ((flags & 0x38) != 0) {
    if ((flags & 0x20) == 0) {
      if ((flags & 0x10) == 0) {
        str = "current";
      }
      else {
        str = "deprecated";
      }
    }
    else {
      str = "obsolete";
    }
    jsons_print_object(out,"status","value",str,1,first);
  }
  return;
}



void jsons_print_config(lyout *out,uint16_t flags,int *first)

{
  int *first_local;
  uint16_t flags_local;
  lyout *out_local;
  char *str;
  
  str = (char *)0x0;
  if ((flags & 3) != 0) {
    if ((flags & 2) == 0) {
      if ((flags & 1) != 0) {
        str = "true";
      }
    }
    else {
      str = "false";
    }
    jsons_print_object(out,"config","value",str,1,first);
  }
  return;
}



void jsons_print_mand(lyout *out,uint16_t flags,int *first)

{
  int *first_local;
  uint16_t flags_local;
  lyout *out_local;
  char *str;
  
  str = (char *)0x0;
  if ((flags & 0xc0) != 0) {
    if ((flags & 0x40) == 0) {
      if ((flags & 0x80) != 0) {
        str = "false";
      }
    }
    else {
      str = "true";
    }
    jsons_print_object(out,"mandatory","value",str,1,first);
  }
  return;
}



void jsons_print_ordering(lyout *out,uint16_t flags,int *first)

{
  int *first_local;
  uint16_t flags_local;
  lyout *out_local;
  
  if ((flags & 0x100) == 0) {
    jsons_print_object(out,"ordered-by","value","system",1,first);
  }
  else {
    jsons_print_object(out,"ordered-by","value","user",1,first);
  }
  return;
}



void jsons_print_iffeatures
               (lyout *out,lys_module *module,lys_iffeature *iff,uint8_t iff_size,int *first)

{
  undefined *puVar1;
  int *first_local;
  uint8_t iff_size_local;
  lys_iffeature *iff_local;
  lys_module *module_local;
  lyout *out_local;
  int i;
  
  if (iff_size != '\0') {
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"if-features\":[",puVar1);
    for (i = 0; i < (int)(uint)iff_size; i = i + 1) {
      if (i == 0) {
        puVar1 = &DAT_0022dce4;
      }
      else {
        puVar1 = &DAT_0022dce5;
      }
      ly_print(out,"%s\"",puVar1);
      ly_print_iffeature(out,module,iff + i,3);
      ly_print(out,"\"");
    }
    ly_print(out,"]");
    if (first != (int *)0x0) {
      *first = 0;
    }
  }
  return;
}



void jsons_print_when(lyout *out,lys_when *when,int *first)

{
  int *first_local;
  lys_when *when_local;
  lyout *out_local;
  
  if (when != (lys_when *)0x0) {
    jsons_print_text(out,"when","condition",when->cond,0,first);
    jsons_print_text(out,"description","text",when->dsc,1,(int *)0x0);
    jsons_print_text(out,"reference","text",when->ref,1,(int *)0x0);
    ly_print(out,"}");
  }
  return;
}



void jsons_print_typerestr(lyout *out,lys_restr *restr,char *label,int *first)

{
  bool bVar1;
  char *pcVar2;
  undefined *puVar3;
  int *first_local;
  char *label_local;
  lys_restr *restr_local;
  lyout *out_local;
  int pattern;
  
  bVar1 = false;
  if (restr != (lys_restr *)0x0) {
    if ((*restr->expr == '\x06') || (*restr->expr == '\x15')) {
      bVar1 = true;
    }
    if (label == (char *)0x0) {
      if ((first == (int *)0x0) || (*first == 0)) {
        puVar3 = &DAT_0022dce5;
      }
      else {
        puVar3 = &DAT_0022dce4;
      }
      ly_print(out,"%s{\"%s\":",puVar3,"value");
      if (bVar1) {
        pcVar2 = restr->expr + 1;
      }
      else {
        pcVar2 = restr->expr;
      }
      json_print_string(out,pcVar2);
    }
    else {
      if (bVar1) {
        pcVar2 = restr->expr + 1;
      }
      else {
        pcVar2 = restr->expr;
      }
      jsons_print_text(out,label,"value",pcVar2,0,first);
    }
    if ((bVar1) && (*restr->expr == '\x15')) {
      jsons_print_object(out,"modifier","value","invert-match",1,(int *)0x0);
    }
    jsons_print_text(out,"description","text",restr->dsc,1,(int *)0x0);
    jsons_print_text(out,"reference","text",restr->ref,1,(int *)0x0);
    jsons_print_object(out,"error-app-tag","value",restr->eapptag,1,(int *)0x0);
    jsons_print_text(out,"error-message","value",restr->emsg,1,(int *)0x0);
    ly_print(out,"}");
    if (first != (int *)0x0) {
      *first = 0;
    }
  }
  return;
}



void jsons_print_musts(lyout *out,lys_restr *must,uint8_t must_size,int *first)

{
  undefined *puVar1;
  long in_FS_OFFSET;
  int *first_local;
  uint8_t must_size_local;
  lys_restr *must_local;
  lyout *out_local;
  int f;
  int i;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (must_size != '\0') {
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"musts\":[",puVar1);
    f = 1;
    for (i = 0; i < (int)(uint)must_size; i = i + 1) {
      jsons_print_typerestr(out,must + i,(char *)0x0,&f);
    }
    ly_print(out,"]");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}


/*
Unable to decompile 'jsons_print_type_'
Cause: Exception while decompiling 001f7693: process: timeout

*/


void jsons_print_type(lyout *out,lys_type *type,int *first)

{
  int *first_local;
  lys_type *type_local;
  lyout *out_local;
  
  jsons_print_type_(out,type,1,first);
  return;
}



void jsons_print_typedef(lyout *out,lys_tpdf *tpdf,int *first)

{
  undefined *puVar1;
  long in_FS_OFFSET;
  int *first_local;
  lys_tpdf *tpdf_local;
  lyout *out_local;
  int f;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((first == (int *)0x0) || (*first == 0)) {
    puVar1 = &DAT_0022dce5;
  }
  else {
    puVar1 = &DAT_0022dce4;
  }
  ly_print(out,"%s\"%s\":{",puVar1,tpdf->name);
  f = 1;
  jsons_print_type(out,&tpdf->type,&f);
  jsons_print_text(out,"description","text",tpdf->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",tpdf->ref,1,(int *)0x0);
  jsons_print_status(out,tpdf->flags,(int *)0x0);
  jsons_print_object(out,"units","name",tpdf->units,1,(int *)0x0);
  jsons_print_object(out,"default","value",tpdf->dflt,1,(int *)0x0);
  ly_print(out,"}");
  if (first != (int *)0x0) {
    *first = 0;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void jsons_print_typedefs(lyout *out,lys_tpdf *tpdf,uint8_t tpdf_size,int *first)

{
  undefined *puVar1;
  int *first_local;
  uint8_t tpdf_size_local;
  lys_tpdf *tpdf_local;
  lyout *out_local;
  int i;
  
  if (tpdf_size != '\0') {
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"typedefs\":[",puVar1);
    for (i = 0; i < (int)(uint)tpdf_size; i = i + 1) {
      if (i == 0) {
        puVar1 = &DAT_0022dce4;
      }
      else {
        puVar1 = &DAT_0022dce5;
      }
      ly_print(out,"%s\"%s\"",puVar1,tpdf[i].name);
    }
    ly_print(out,"]");
    if (first != (int *)0x0) {
      *first = 0;
    }
  }
  return;
}



void jsons_print_min(lyout *out,uint32_t min,int *first)

{
  undefined *puVar1;
  int *first_local;
  uint32_t min_local;
  lyout *out_local;
  
  if ((first == (int *)0x0) || (*first == 0)) {
    puVar1 = &DAT_0022dce5;
  }
  else {
    puVar1 = &DAT_0022dce4;
  }
  ly_print(out,"%s\"min-elements\":{\"value\":%u}",puVar1,(ulong)min);
  return;
}



void jsons_print_max(lyout *out,uint32_t max,int *first)

{
  undefined *puVar1;
  int *first_local;
  uint32_t max_local;
  lyout *out_local;
  
  if ((first == (int *)0x0) || (*first == 0)) {
    puVar1 = &DAT_0022dce5;
  }
  else {
    puVar1 = &DAT_0022dce4;
  }
  ly_print(out,"%s\"max-elements\":{\"value\":%u}",puVar1,(ulong)max);
  return;
}



void jsons_print_uniques(lyout *out,lys_unique *unique,uint8_t unique_size,int *first)

{
  undefined *puVar1;
  int *first_local;
  uint8_t unique_size_local;
  lys_unique *unique_local;
  lyout *out_local;
  int i;
  int j;
  
  if (unique_size != '\0') {
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"uniques\":[",puVar1);
    for (i = 0; i < (int)(uint)unique_size; i = i + 1) {
      if (i == 0) {
        puVar1 = &DAT_0022dce4;
      }
      else {
        puVar1 = &DAT_0022dce5;
      }
      ly_print(out,"%s[",puVar1);
      for (j = 0; j < (int)(uint)unique[i].expr_size; j = j + 1) {
        if (j == 0) {
          puVar1 = &DAT_0022dce4;
        }
        else {
          puVar1 = &DAT_0022dce5;
        }
        ly_print(out,"%s\"%s\"",puVar1,unique[i].expr[j]);
      }
      ly_print(out,"]");
    }
    ly_print(out,"]");
    if (first != (int *)0x0) {
      *first = 0;
    }
  }
  return;
}



void jsons_print_defaults(lyout *out,char **dflts,uint8_t dflts_size,int *first)

{
  undefined *puVar1;
  int *first_local;
  uint8_t dflts_size_local;
  char **dflts_local;
  lyout *out_local;
  int i;
  
  if (dflts_size != '\0') {
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"defaults\":[",puVar1);
    for (i = 0; i < (int)(uint)dflts_size; i = i + 1) {
      if (i == 0) {
        puVar1 = &DAT_0022dce4;
      }
      else {
        puVar1 = &DAT_0022dce5;
      }
      ly_print(out,"%s\"%s\"",puVar1,dflts[i]);
    }
    ly_print(out,"]");
    if (first != (int *)0x0) {
      *first = 0;
    }
  }
  return;
}



void jsons_print_revisions(lyout *out,lys_revision *rev,uint8_t rev_size,int *first)

{
  undefined *puVar1;
  long in_FS_OFFSET;
  int *first_local;
  uint8_t rev_size_local;
  lys_revision *rev_local;
  lyout *out_local;
  int f;
  int i;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (rev_size != '\0') {
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"revision\":{",puVar1);
    for (i = 0; i < (int)(uint)rev_size; i = i + 1) {
      if (i == 0) {
        puVar1 = &DAT_0022dce4;
      }
      else {
        puVar1 = &DAT_0022dce5;
      }
      ly_print(out,"%s\"%s\":{",puVar1,rev + i);
      f = 1;
      jsons_print_text(out,"description","text",rev[i].dsc,1,&f);
      jsons_print_text(out,"reference","text",rev[i].ref,1,&f);
      ly_print(out,"}");
    }
    ly_print(out,"}");
    if (first != (int *)0x0) {
      *first = 0;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void jsons_print_imports_
               (lyout *out,lys_submodule *submodule,lys_import *imp,uint8_t imp_size,char **label)

{
  int iVar1;
  undefined *puVar2;
  undefined *puVar3;
  lys_revision *plVar4;
  long in_FS_OFFSET;
  char **label_local;
  uint8_t imp_size_local;
  lys_import *imp_local;
  lys_submodule *submodule_local;
  lyout *out_local;
  int f;
  int i;
  int j;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  j = 1;
  if ((imp_size != '\0') && (*label != (char *)0x0)) {
    ly_print(out,*label);
    free(*label);
    *label = (char *)0x0;
    j = 0;
  }
  i = 0;
  do {
    if ((int)(uint)imp_size <= i) {
LAB_001f8f0f:
      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return;
    }
    if (imp[i].rev[0] == '\0') {
      puVar3 = &DAT_0022dce4;
    }
    else {
      puVar3 = &DAT_0022df29;
    }
    if (j + i == 0) {
      puVar2 = &DAT_0022dce4;
    }
    else {
      puVar2 = &DAT_0022dce5;
    }
    ly_print(out,"%s\"%s%s%s\":{",puVar2,(imp[i].module)->name,puVar3,imp[i].rev);
    f = 1;
    jsons_print_object(out,"prefix","value",imp[i].prefix,1,&f);
    jsons_print_text(out,"description","text",imp[i].dsc,1,&f);
    jsons_print_text(out,"reference","text",imp[i].ref,1,&f);
    if (submodule != (lys_submodule *)0x0) {
      if (submodule->rev_size == '\0') {
        plVar4 = (lys_revision *)&DAT_0022dce4;
      }
      else {
        plVar4 = submodule->rev;
      }
      if (submodule->rev_size == '\0') {
        puVar3 = &DAT_0022dce4;
      }
      else {
        puVar3 = &DAT_0022df29;
      }
      ly_print(out,",\"from-submodule\":\"%s%s%s\"",submodule->name,puVar3,plVar4);
    }
    if ((imp[i].module)->rev_size == '\0') {
      plVar4 = (lys_revision *)&DAT_0022dce4;
    }
    else {
      plVar4 = (imp[i].module)->rev;
    }
    if ((imp[i].module)->rev_size == '\0') {
      puVar3 = &DAT_0022dce4;
    }
    else {
      puVar3 = &DAT_0022df29;
    }
    iVar1 = asprintf(&str,"%s%s%s",(imp[i].module)->name,puVar3,plVar4);
    if (iVar1 == -1) {
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
             "jsons_print_imports_");
      goto LAB_001f8f0f;
    }
    jsons_print_text(out,"resolves-to","module",str,1,&f);
    free(str);
    ly_print(out,"}");
    i = i + 1;
  } while( true );
}



void jsons_print_imports(lyout *out,lys_module *mod,int *first)

{
  int iVar1;
  undefined *puVar2;
  long in_FS_OFFSET;
  int *first_local;
  lys_module *mod_local;
  lyout *out_local;
  char *str;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((mod->imp_size != '\0') || (mod->inc_size != '\0')) {
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar2 = &DAT_0022dce5;
    }
    else {
      puVar2 = &DAT_0022dce4;
    }
    iVar1 = asprintf(&str,"%s\"import\":{",puVar2);
    if (iVar1 == -1) {
      ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","jsons_print_imports");
    }
    else {
      jsons_print_imports_(out,(lys_submodule *)0x0,mod->imp,mod->imp_size,&str);
      if (str == (char *)0x0) {
        ly_print(out,"}");
      }
      else {
        free(str);
      }
      if (first != (int *)0x0) {
        *first = 0;
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void jsons_print_includes(lyout *out,lys_include *inc,uint8_t inc_size,int *first)

{
  undefined *puVar1;
  undefined *puVar2;
  long in_FS_OFFSET;
  int *first_local;
  uint8_t inc_size_local;
  lys_include *inc_local;
  lyout *out_local;
  int f;
  int i;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (inc_size != '\0') {
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"include\":{",puVar1);
    for (i = 0; i < (int)(uint)inc_size; i = i + 1) {
      if (inc[i].rev[0] == '\0') {
        puVar1 = &DAT_0022dce4;
      }
      else {
        puVar1 = &DAT_0022df29;
      }
      if (i == 0) {
        puVar2 = &DAT_0022dce4;
      }
      else {
        puVar2 = &DAT_0022dce5;
      }
      ly_print(out,"%s\"%s%s%s\":{",puVar2,(inc[i].submodule)->name,puVar1,inc[i].rev);
      f = 1;
      jsons_print_text(out,"description","text",inc[i].dsc,1,&f);
      jsons_print_text(out,"reference","text",inc[i].ref,1,&f);
      ly_print(out,"}");
    }
    ly_print(out,"}");
    if (first != (int *)0x0) {
      *first = 0;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void jsons_print_augment(lyout *out,lys_node_augment *aug,uint8_t aug_size,int *first)

{
  undefined *puVar1;
  long in_FS_OFFSET;
  int *first_local;
  uint8_t aug_size_local;
  lys_node_augment *aug_local;
  lyout *out_local;
  int f;
  int i;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (aug_size != '\0') {
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"augment\":{",puVar1);
    for (i = 0; i < (int)(uint)aug_size; i = i + 1) {
      if (i == 0) {
        puVar1 = &DAT_0022dce4;
      }
      else {
        puVar1 = &DAT_0022dce5;
      }
      ly_print(out,"%s\"%s\":{",puVar1,aug[i].target_name);
      f = 1;
      jsons_print_text(out,"description","text",aug[i].dsc,1,&f);
      jsons_print_text(out,"reference","text",aug[i].ref,1,&f);
      jsons_print_status(out,aug[i].flags,&f);
      jsons_print_iffeatures(out,aug[i].module,aug[i].iffeature,aug[i].iffeature_size,&f);
      jsons_print_when(out,aug[i].when,&f);
      jsons_print_data(out,aug->module,aug->child,&f);
      jsons_print_actions(out,aug->child,&f);
      jsons_print_notifs(out,aug->child,&f);
      ly_print(out,"}");
    }
    ly_print(out,"}");
    if (first != (int *)0x0) {
      *first = 0;
      ly_print(out,"\n");
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void jsons_print_deviation(lyout *out,lys_deviation *dev,uint8_t dev_size,int *first)

{
  undefined *puVar1;
  long in_FS_OFFSET;
  int *first_local;
  uint8_t dev_size_local;
  lys_deviation *dev_local;
  lyout *out_local;
  int f;
  int f2;
  int i;
  int j;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (dev_size != '\0') {
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"deviations\":{",puVar1);
    for (i = 0; i < (int)(uint)dev_size; i = i + 1) {
      if (i == 0) {
        puVar1 = &DAT_0022dce4;
      }
      else {
        puVar1 = &DAT_0022dce5;
      }
      ly_print(out,"%s\"%s\":{",puVar1,dev[i].target_name);
      f = 1;
      jsons_print_text(out,"description","text",dev[i].dsc,1,&f);
      jsons_print_text(out,"reference","text",dev[i].ref,1,&f);
      if (dev[i].deviate_size != '\0') {
        if (f == 0) {
          puVar1 = &DAT_0022dce5;
        }
        else {
          puVar1 = &DAT_0022dce4;
        }
        ly_print(out,"%s\"deviates\":[",puVar1);
        f = 0;
        f2 = 1;
        for (j = 0; j < (int)(uint)dev[i].deviate_size; j = j + 1) {
          if (j == 0) {
            puVar1 = &DAT_0022dce5;
          }
          else {
            puVar1 = &DAT_0022dce4;
          }
          ly_print(out,"%s{",puVar1);
          jsons_print_config(out,(ushort)dev[i].deviate[j].flags,&f2);
          jsons_print_defaults(out,dev[i].deviate[j].dflt,dev[i].deviate[j].dflt_size,&f2);
          jsons_print_mand(out,(ushort)dev[i].deviate[j].flags,&f2);
          if (dev[i].deviate[j].min_set != '\0') {
            if (f2 == 0) {
              puVar1 = &DAT_0022dce5;
            }
            else {
              puVar1 = &DAT_0022dce4;
            }
            ly_print(out,"%s\"min-elements\":{\"value\":%u}",puVar1,(ulong)dev[i].deviate[j].min);
            f2 = 0;
          }
          if (dev[i].deviate[j].max_set != '\0') {
            if (f2 == 0) {
              puVar1 = &DAT_0022dce5;
            }
            else {
              puVar1 = &DAT_0022dce4;
            }
            ly_print(out,"%s\"max-elements\":{\"value\":%u}",puVar1,(ulong)dev[i].deviate[j].max);
            f2 = 0;
          }
          jsons_print_musts(out,dev[i].deviate[j].must,dev[i].deviate[j].must_size,&f2);
          jsons_print_type(out,dev[i].deviate[j].type,&f2);
          jsons_print_uniques(out,dev[i].deviate[j].unique,dev[i].deviate[j].unique_size,&f2);
          jsons_print_text(out,"units","name",dev[i].deviate[j].units,1,&f2);
          ly_print(out,"}");
        }
        ly_print(out,"]");
      }
      ly_print(out,"}");
    }
    ly_print(out,"}");
    if (first != (int *)0x0) {
      *first = 0;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void jsons_print_identity(lyout *out,lys_ident *ident,int *first)

{
  undefined *puVar1;
  undefined *puVar2;
  lys_revision *plVar3;
  long in_FS_OFFSET;
  int *first_local;
  lys_ident *ident_local;
  lyout *out_local;
  int f;
  int j;
  lys_module *mod;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  f = 1;
  if ((first == (int *)0x0) || (*first == 0)) {
    puVar1 = &DAT_0022dce5;
  }
  else {
    puVar1 = &DAT_0022dce4;
  }
  ly_print(out,"%s\"%s\":{",puVar1,ident->name);
  if (ident->base_size != '\0') {
    ly_print(out,"\"bases\":[");
    f = 0;
    for (j = 0; j < (int)(uint)ident->base_size; j = j + 1) {
      mod = ident->base[j]->module;
      if (mod->rev_size == '\0') {
        plVar3 = (lys_revision *)&DAT_0022dce4;
      }
      else {
        plVar3 = mod->rev;
      }
      if (mod->rev_size == '\0') {
        puVar1 = &DAT_0022dce4;
      }
      else {
        puVar1 = &DAT_0022df29;
      }
      if (j == 0) {
        puVar2 = &DAT_0022dce4;
      }
      else {
        puVar2 = &DAT_0022dce5;
      }
      ly_print(out,"%s\"%s%s%s:%s\"",puVar2,mod->name,puVar1,plVar3,ident->base[j]->name);
    }
    ly_print(out,"]");
  }
  jsons_print_text(out,"description","text",ident->dsc,1,&f);
  jsons_print_text(out,"reference","text",ident->ref,1,&f);
  jsons_print_status(out,ident->flags,&f);
  jsons_print_iffeatures(out,ident->module,ident->iffeature,ident->iffeature_size,&f);
  ly_print(out,"}");
  if (first != (int *)0x0) {
    *first = 0;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void jsons_print_identities(lyout *out,lys_ident *ident,uint16_t ident_size,int *first)

{
  undefined *puVar1;
  int *first_local;
  uint16_t ident_size_local;
  lys_ident *ident_local;
  lyout *out_local;
  int i;
  
  if (ident_size != 0) {
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"identities\":[",puVar1);
    for (i = 0; i < (int)(uint)ident_size; i = i + 1) {
      if (i == 0) {
        puVar1 = &DAT_0022dce4;
      }
      else {
        puVar1 = &DAT_0022dce5;
      }
      ly_print(out,"%s\"%s\"",puVar1,ident[i].name);
    }
    ly_print(out,"]");
    if (first != (int *)0x0) {
      *first = 0;
    }
  }
  return;
}



void jsons_print_feature(lyout *out,lys_feature *feat,int *first)

{
  undefined *puVar1;
  long in_FS_OFFSET;
  int *first_local;
  lys_feature *feat_local;
  lyout *out_local;
  int f;
  uint j;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  f = 1;
  if ((first == (int *)0x0) || (*first == 0)) {
    puVar1 = &DAT_0022dce5;
  }
  else {
    puVar1 = &DAT_0022dce4;
  }
  ly_print(out,"%s\"%s\":{",puVar1,feat->name);
  jsons_print_text(out,"description","text",feat->dsc,1,&f);
  jsons_print_text(out,"reference","text",feat->ref,1,&f);
  jsons_print_status(out,feat->flags,&f);
  jsons_print_iffeatures(out,feat->module,feat->iffeature,feat->iffeature_size,&f);
  if ((feat->depfeatures != (ly_set *)0x0) && (feat->depfeatures->number != 0)) {
    if (f == 0) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"depending-features\":[",puVar1);
    for (j = 0; j < feat->depfeatures->number; j = j + 1) {
      if (j == 0) {
        puVar1 = &DAT_0022dce4;
      }
      else {
        puVar1 = &DAT_0022dce5;
      }
      ly_print(out,"%s\"%s\"",puVar1,(feat->depfeatures->set).s[j]->name);
    }
    ly_print(out,"]");
  }
  ly_print(out,"}");
  if (first != (int *)0x0) {
    *first = 0;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void jsons_print_features(lyout *out,lys_feature *feat,uint8_t feat_size,int *first)

{
  undefined *puVar1;
  int *first_local;
  uint8_t feat_size_local;
  lys_feature *feat_local;
  lyout *out_local;
  int i;
  
  if (feat_size != '\0') {
    if ((first == (int *)0x0) || (*first == 0)) {
      puVar1 = &DAT_0022dce5;
    }
    else {
      puVar1 = &DAT_0022dce4;
    }
    ly_print(out,"%s\"features\":[",puVar1);
    for (i = 0; i < (int)(uint)feat_size; i = i + 1) {
      if (i == 0) {
        puVar1 = &DAT_0022dce4;
      }
      else {
        puVar1 = &DAT_0022dce5;
      }
      ly_print(out,"%s\"%s\"",puVar1,feat[i].name);
    }
    ly_print(out,"]");
    if (first != (int *)0x0) {
      *first = 0;
    }
  }
  return;
}



void jsons_print_data_(lyout *out,lys_module *mod,lys_node *data,int *first)

{
  lys_module *plVar1;
  lys_module *plVar2;
  char *pcVar3;
  char *pcVar4;
  int *first_local;
  lys_node *data_local;
  lys_module *mod_local;
  lyout *out_local;
  int mask;
  lys_node *node;
  
  for (node = data; node != (lys_node *)0x0; node = node->next) {
    if ((node->nodetype & 0x907f) != LYS_UNKNOWN) {
      if ((node->nodetype & LYS_USES) == LYS_UNKNOWN) {
        plVar1 = lys_main_module(mod);
        plVar2 = lys_main_module(node->module);
        if (plVar1 == plVar2) {
          pcVar3 = jsons_nodetype_str(node->nodetype);
          jsons_print_object(out,node->name,"nodetype",pcVar3,0,first);
          if ((node->module->field_0x40 & 1) != 0) {
            ly_print(out,",\"included-from\":\"%s\"",node->module->name);
          }
          ly_print(out,"}");
        }
        else {
          pcVar4 = jsons_nodetype_str(node->nodetype);
          pcVar3 = node->name;
          plVar1 = lys_main_module(node->module);
          ly_print(out,"\"%s:%s\":{\"nodetype\":\"%s\"}",plVar1->name,pcVar3,pcVar4);
          *first = 0;
        }
      }
      else {
        jsons_print_data_(out,mod,node->child,first);
      }
    }
  }
  return;
}



void jsons_print_data(lyout *out,lys_module *mod,lys_node *data,int *first)

{
  undefined *puVar1;
  long in_FS_OFFSET;
  int *first_local;
  lys_node *data_local;
  lys_module *mod_local;
  lyout *out_local;
  int f;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((first == (int *)0x0) || (*first == 0)) {
    puVar1 = &DAT_0022dce5;
  }
  else {
    puVar1 = &DAT_0022dce4;
  }
  ly_print(out,"%s\"data\":{",puVar1);
  f = 1;
  jsons_print_data_(out,mod,data,&f);
  ly_print(out,"}");
  if (first != (int *)0x0) {
    *first = 0;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void jsons_print_nodes_uses_
               (lyout *out,lys_node *data,char *label,int mask,int *top_first,int *first)

{
  undefined *puVar1;
  int *first_local;
  int *top_first_local;
  int mask_local;
  char *label_local;
  lys_node *data_local;
  lyout *out_local;
  lys_node *node;
  
  for (node = data; node != (lys_node *)0x0; node = node->next) {
    if ((mask & node->nodetype) != LYS_UNKNOWN) {
      if ((node->nodetype & LYS_USES) == LYS_UNKNOWN) {
        if (*first != 0) {
          if ((top_first == (int *)0x0) || (*top_first == 0)) {
            puVar1 = &DAT_0022dce5;
          }
          else {
            puVar1 = &DAT_0022dce4;
          }
          ly_print(out,"%s\"%s\":[",puVar1,label);
        }
        if (*first == 0) {
          puVar1 = &DAT_0022dce5;
        }
        else {
          puVar1 = &DAT_0022dce4;
        }
        ly_print(out,"%s\"%s\"",puVar1,node->name);
        *first = 0;
      }
      else {
        jsons_print_nodes_uses_(out,node->child,label,mask,top_first,first);
      }
    }
  }
  return;
}



void jsons_print_nodes_(lyout *out,lys_node *data,char *label,int mask,int *first)

{
  undefined *puVar1;
  long in_FS_OFFSET;
  int *first_local;
  int mask_local;
  char *label_local;
  lys_node *data_local;
  lyout *out_local;
  int f;
  lys_node *node;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  f = 1;
  for (node = data; node != (lys_node *)0x0; node = node->next) {
    if ((mask & node->nodetype) != LYS_UNKNOWN) {
      if ((node->nodetype & LYS_USES) == LYS_UNKNOWN) {
        if (f != 0) {
          if ((first == (int *)0x0) || (*first == 0)) {
            puVar1 = &DAT_0022dce5;
          }
          else {
            puVar1 = &DAT_0022dce4;
          }
          ly_print(out,"%s\"%s\":[",puVar1,label);
        }
        if (f == 0) {
          puVar1 = &DAT_0022dce5;
        }
        else {
          puVar1 = &DAT_0022dce4;
        }
        ly_print(out,"%s\"%s\"",puVar1,node->name);
        f = 0;
      }
      else {
        jsons_print_nodes_uses_(out,node->child,label,mask,first,&f);
      }
    }
  }
  if (f == 0) {
    ly_print(out,"]");
    if (first != (int *)0x0) {
      *first = 0;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void jsons_print_groupings(lyout *out,lys_node *data,int *first)

{
  int *first_local;
  lys_node *data_local;
  lyout *out_local;
  
  jsons_print_nodes_(out,data,"groupings",0x800,first);
  return;
}



void jsons_print_rpcs(lyout *out,lys_node *data,int *first)

{
  int *first_local;
  lys_node *data_local;
  lyout *out_local;
  
  jsons_print_nodes_(out,data,"rpcs",0x100,first);
  return;
}



void jsons_print_actions(lyout *out,lys_node *data,int *first)

{
  int *first_local;
  lys_node *data_local;
  lyout *out_local;
  
  jsons_print_nodes_(out,data,"actions",0x4000,first);
  return;
}



void jsons_print_notifs(lyout *out,lys_node *data,int *first)

{
  int *first_local;
  lys_node *data_local;
  lyout *out_local;
  
  jsons_print_nodes_(out,data,"notifications",0x80,first);
  return;
}



void jsons_print_module(lyout *out,lys_module *module)

{
  char *val;
  lys_module *module_local;
  lyout *out_local;
  
  ly_print(out,"{\"%s\":{",module->name);
  ly_print(out,"\"namespace\":\"%s\"",module->ns);
  ly_print(out,",\"prefix\":\"%s\"",module->prefix);
  jsons_print_text(out,"description","text",module->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",module->ref,1,(int *)0x0);
  jsons_print_text(out,"organization","text",module->org,1,(int *)0x0);
  jsons_print_text(out,"contact","text",module->contact,1,(int *)0x0);
  if ((module->field_0x40 & 0xe) == 4) {
    val = "1.1";
  }
  else {
    val = "1.0";
  }
  jsons_print_object(out,"yang-version","value",val,1,(int *)0x0);
  jsons_print_revisions(out,module->rev,module->rev_size,(int *)0x0);
  jsons_print_includes(out,module->inc,module->inc_size,(int *)0x0);
  jsons_print_imports(out,module,(int *)0x0);
  jsons_print_typedefs(out,module->tpdf,(uint8_t)module->tpdf_size,(int *)0x0);
  jsons_print_identities(out,module->ident,module->ident_size,(int *)0x0);
  jsons_print_features(out,module->features,module->features_size,(int *)0x0);
  jsons_print_augment(out,module->augment,module->augment_size,(int *)0x0);
  jsons_print_deviation(out,module->deviation,module->deviation_size,(int *)0x0);
  jsons_print_groupings(out,module->data,(int *)0x0);
  jsons_print_data(out,module,module->data,(int *)0x0);
  jsons_print_rpcs(out,module->data,(int *)0x0);
  jsons_print_notifs(out,module->data,(int *)0x0);
  ly_print(out,"}}");
  return;
}



void jsons_print_submodule(lyout *out,lys_submodule *module)

{
  char *val;
  lys_submodule *module_local;
  lyout *out_local;
  
  ly_print(out,"{\"%s\":{",module->name);
  ly_print(out,"\"belongs-to\":\"%s\"",module->belongsto->name);
  jsons_print_text(out,"description","text",module->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",module->ref,1,(int *)0x0);
  jsons_print_text(out,"organization","text",module->org,1,(int *)0x0);
  jsons_print_text(out,"contact","text",module->contact,1,(int *)0x0);
  if ((module->field_0x40 & 0xe) == 4) {
    val = "1.1";
  }
  else {
    val = "1.0";
  }
  jsons_print_object(out,"yang-version","value",val,1,(int *)0x0);
  jsons_print_revisions(out,module->rev,module->rev_size,(int *)0x0);
  jsons_print_includes(out,module->inc,module->inc_size,(int *)0x0);
  jsons_print_imports(out,(lys_module *)module,(int *)0x0);
  jsons_print_typedefs(out,module->tpdf,(uint8_t)module->tpdf_size,(int *)0x0);
  jsons_print_identities(out,module->ident,module->ident_size,(int *)0x0);
  jsons_print_features(out,module->features,module->features_size,(int *)0x0);
  jsons_print_augment(out,module->augment,module->augment_size,(int *)0x0);
  jsons_print_deviation(out,module->deviation,module->deviation_size,(int *)0x0);
  ly_print(out,"}}");
  return;
}



void jsons_print_container(lyout *out,lys_node *node,int *first)

{
  char *val;
  lys_module *plVar1;
  int *first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_container *cont;
  
  val = jsons_nodetype_str(node->nodetype);
  jsons_print_object(out,node->name,"nodetype",val,0,first);
  plVar1 = lys_main_module(node->module);
  ly_print(out,",\"module\":\"%s\"",plVar1->name);
  if ((node->module->field_0x40 & 1) != 0) {
    ly_print(out,",\"included-from\":\"%s\"",node->module->name);
  }
  jsons_print_text(out,"description","text",node->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",node->ref,1,(int *)0x0);
  jsons_print_config(out,node->flags,(int *)0x0);
  jsons_print_status(out,node->flags,(int *)0x0);
  jsons_print_text(out,"presence","value",*(char **)&node[1].flags,1,(int *)0x0);
  jsons_print_iffeatures(out,node->module,node->iffeature,node->iffeature_size,(int *)0x0);
  jsons_print_when(out,(lys_when *)node[1].name,(int *)0x0);
  jsons_print_musts(out,(lys_restr *)node[1].dsc,node->padding[1],(int *)0x0);
  jsons_print_typedefs
            (out,(lys_tpdf *)node[1].ref,(uint8_t)*(undefined2 *)(node->padding + 2),(int *)0x0);
  jsons_print_groupings(out,node->child,(int *)0x0);
  jsons_print_data(out,node->module,node->child,(int *)0x0);
  jsons_print_actions(out,node->child,(int *)0x0);
  jsons_print_notifs(out,node->child,(int *)0x0);
  ly_print(out,"}");
  return;
}



void jsons_print_choice(lyout *out,lys_node *node,int *first)

{
  char *val;
  lys_module *plVar1;
  int *first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_choice *choice;
  
  val = jsons_nodetype_str(node->nodetype);
  jsons_print_object(out,node->name,"nodetype",val,0,first);
  plVar1 = lys_main_module(node->module);
  ly_print(out,",\"module\":\"%s\"",plVar1->name);
  if ((node->module->field_0x40 & 1) != 0) {
    ly_print(out,",\"included-from\":\"%s\"",node->module->name);
  }
  jsons_print_text(out,"description","text",node->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",node->ref,1,(int *)0x0);
  jsons_print_config(out,node->flags,(int *)0x0);
  jsons_print_status(out,node->flags,(int *)0x0);
  jsons_print_mand(out,node->flags,(int *)0x0);
  if (node[1].name != (char *)0x0) {
    jsons_print_defaults(out,(char **)node[1].name,'\x01',(int *)0x0);
  }
  jsons_print_iffeatures(out,node->module,node->iffeature,node->iffeature_size,(int *)0x0);
  jsons_print_when(out,*(lys_when **)node->hash,(int *)0x0);
  jsons_print_data(out,node->module,node->child,(int *)0x0);
  ly_print(out,"}");
  return;
}



void jsons_print_leaf(lyout *out,lys_node *node,int *first)

{
  char *val;
  lys_module *plVar1;
  int *first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_leaf *leaf;
  
  val = jsons_nodetype_str(node->nodetype);
  jsons_print_object(out,node->name,"nodetype",val,0,first);
  plVar1 = lys_main_module(node->module);
  ly_print(out,",\"module\":\"%s\"",plVar1->name);
  if ((node->module->field_0x40 & 1) != 0) {
    ly_print(out,",\"included-from\":\"%s\"",node->module->name);
  }
  jsons_print_text(out,"description","text",node->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",node->ref,1,(int *)0x0);
  jsons_print_status(out,node->flags,(int *)0x0);
  jsons_print_config(out,node->flags,(int *)0x0);
  jsons_print_mand(out,node->flags,(int *)0x0);
  jsons_print_type(out,(lys_type *)&node[1].ref,(int *)0x0);
  jsons_print_text(out,"units","name",(char *)node[1].next,1,(int *)0x0);
  if (node[1].prev != (lys_node *)0x0) {
    jsons_print_defaults(out,(char **)&node[1].prev,'\x01',(int *)0x0);
  }
  jsons_print_iffeatures(out,node->module,node->iffeature,node->iffeature_size,(int *)0x0);
  jsons_print_when(out,(lys_when *)node[1].name,(int *)0x0);
  jsons_print_musts(out,(lys_restr *)node[1].dsc,node->padding[3],(int *)0x0);
  ly_print(out,"}");
  return;
}



void jsons_print_leaflist(lyout *out,lys_node *node,int *first)

{
  char *val;
  lys_module *plVar1;
  int *first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_leaflist *llist;
  
  val = jsons_nodetype_str(node->nodetype);
  jsons_print_object(out,node->name,"nodetype",val,0,first);
  plVar1 = lys_main_module(node->module);
  ly_print(out,",\"module\":\"%s\"",plVar1->name);
  if ((node->module->field_0x40 & 1) != 0) {
    ly_print(out,",\"included-from\":\"%s\"",node->module->name);
  }
  jsons_print_text(out,"description","text",node->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",node->ref,1,(int *)0x0);
  jsons_print_status(out,node->flags,(int *)0x0);
  jsons_print_config(out,node->flags,(int *)0x0);
  jsons_print_ordering(out,node->flags,(int *)0x0);
  jsons_print_type(out,(lys_type *)&node[1].ref,(int *)0x0);
  jsons_print_text(out,"units","name",(char *)node[1].next,1,(int *)0x0);
  jsons_print_defaults(out,&(node[1].prev)->name,node->padding[2],(int *)0x0);
  if (*(int *)&node[1].priv != 0) {
    jsons_print_min(out,*(uint32_t *)&node[1].priv,(int *)0x0);
  }
  if (*(int *)((long)&node[1].priv + 4) != 0) {
    jsons_print_max(out,*(uint32_t *)((long)&node[1].priv + 4),(int *)0x0);
  }
  jsons_print_iffeatures(out,node->module,node->iffeature,node->iffeature_size,(int *)0x0);
  jsons_print_when(out,(lys_when *)node[1].name,(int *)0x0);
  jsons_print_musts(out,(lys_restr *)node[1].dsc,node->padding[3],(int *)0x0);
  ly_print(out,"}");
  return;
}



void jsons_print_list(lyout *out,lys_node *node,int *first)

{
  char *val;
  lys_module *plVar1;
  undefined *puVar2;
  int *first_local;
  lys_node *node_local;
  lyout *out_local;
  uint8_t i;
  lys_node_list *list;
  
  val = jsons_nodetype_str(node->nodetype);
  jsons_print_object(out,node->name,"nodetype",val,0,first);
  plVar1 = lys_main_module(node->module);
  ly_print(out,",\"module\":\"%s\"",plVar1->name);
  if ((node->module->field_0x40 & 1) != 0) {
    ly_print(out,",\"included-from\":\"%s\"",node->module->name);
  }
  jsons_print_text(out,"description","text",node->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",node->ref,1,(int *)0x0);
  jsons_print_status(out,node->flags,(int *)0x0);
  jsons_print_config(out,node->flags,(int *)0x0);
  jsons_print_ordering(out,node->flags,(int *)0x0);
  if (*(int *)&node[1].iffeature != 0) {
    jsons_print_min(out,*(uint32_t *)&node[1].iffeature,(int *)0x0);
  }
  if (*(int *)((long)&node[1].iffeature + 4) != 0) {
    jsons_print_max(out,*(uint32_t *)((long)&node[1].iffeature + 4),(int *)0x0);
  }
  jsons_print_iffeatures(out,node->module,node->iffeature,node->iffeature_size,(int *)0x0);
  jsons_print_when(out,(lys_when *)node[1].name,(int *)0x0);
  jsons_print_musts(out,(lys_restr *)node[1].dsc,node->padding[0],(int *)0x0);
  ly_print(out,",\"keys\":[");
  for (i = '\0'; i < node->padding[2]; i = i + '\x01') {
    if (i == '\0') {
      puVar2 = &DAT_0022dce4;
    }
    else {
      puVar2 = &DAT_0022dce5;
    }
    ly_print(out,"%s\"%s\"",puVar2,**(undefined8 **)(*(long *)&node[1].flags + (ulong)i * 8));
  }
  ly_print(out,"]");
  jsons_print_uniques(out,(lys_unique *)node[1].ext,node->padding[3],(int *)0x0);
  jsons_print_typedefs(out,(lys_tpdf *)node[1].ref,node->padding[1],(int *)0x0);
  jsons_print_groupings(out,node->child,(int *)0x0);
  jsons_print_data(out,node->module,node->child,(int *)0x0);
  jsons_print_actions(out,node->child,(int *)0x0);
  jsons_print_notifs(out,node->child,(int *)0x0);
  ly_print(out,"}");
  return;
}



void jsons_print_anydata(lyout *out,lys_node *node,int *first)

{
  int iVar1;
  lys_node *plVar2;
  char *val;
  lys_module *plVar3;
  int *first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_anydata *any;
  
  plVar2 = lys_parent(node);
  if (((plVar2 == (lys_node *)0x0) && (iVar1 = strcmp(node->name,"config"), iVar1 == 0)) &&
     (iVar1 = strcmp(node->module->name,"ietf-netconf"), iVar1 == 0)) {
    return;
  }
  val = jsons_nodetype_str(node->nodetype);
  jsons_print_object(out,node->name,"nodetype",val,0,first);
  plVar3 = lys_main_module(node->module);
  ly_print(out,",\"module\":\"%s\"",plVar3->name);
  if ((node->module->field_0x40 & 1) != 0) {
    ly_print(out,",\"included-from\":\"%s\"",node->module->name);
  }
  jsons_print_text(out,"description","text",node->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",node->ref,1,(int *)0x0);
  jsons_print_config(out,node->flags,(int *)0x0);
  jsons_print_status(out,node->flags,(int *)0x0);
  jsons_print_mand(out,node->flags,(int *)0x0);
  jsons_print_iffeatures(out,node->module,node->iffeature,node->iffeature_size,(int *)0x0);
  jsons_print_when(out,(lys_when *)node[1].name,(int *)0x0);
  jsons_print_musts(out,(lys_restr *)node[1].dsc,node->padding[3],(int *)0x0);
  ly_print(out,"}");
  return;
}



void jsons_print_grouping(lyout *out,lys_node *node,int *first)

{
  lys_module *plVar1;
  int *first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_grp *group;
  
  plVar1 = lys_main_module(node->module);
  jsons_print_object(out,node->name,"module",plVar1->name,0,first);
  if ((node->module->field_0x40 & 1) != 0) {
    ly_print(out,",\"included-from\":\"%s\"",node->module->name);
  }
  jsons_print_text(out,"description","text",node->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",node->ref,1,(int *)0x0);
  jsons_print_status(out,node->flags,(int *)0x0);
  jsons_print_typedefs
            (out,*(lys_tpdf **)node->hash,(uint8_t)*(undefined2 *)(node->padding + 2),(int *)0x0);
  jsons_print_groupings(out,node->child,(int *)0x0);
  jsons_print_data(out,node->module,node->child,(int *)0x0);
  jsons_print_actions(out,node->child,(int *)0x0);
  jsons_print_notifs(out,node->child,(int *)0x0);
  ly_print(out,"}");
  return;
}



void jsons_print_case(lyout *out,lys_node *node,int *first)

{
  char *val;
  lys_module *plVar1;
  int *first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_case *cas;
  
  val = jsons_nodetype_str(node->nodetype);
  jsons_print_object(out,node->name,"nodetype",val,0,first);
  plVar1 = lys_main_module(node->module);
  ly_print(out,",\"module\":\"%s\"",plVar1->name);
  if ((node->module->field_0x40 & 1) != 0) {
    ly_print(out,",\"included-from\":\"%s\"",node->module->name);
  }
  jsons_print_text(out,"description","text",node->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",node->ref,1,(int *)0x0);
  jsons_print_config(out,node->flags,(int *)0x0);
  jsons_print_status(out,node->flags,(int *)0x0);
  jsons_print_iffeatures(out,node->module,node->iffeature,node->iffeature_size,(int *)0x0);
  jsons_print_when(out,*(lys_when **)node->hash,(int *)0x0);
  jsons_print_data(out,node->module,node->child,(int *)0x0);
  ly_print(out,"}");
  return;
}



void jsons_print_input(lyout *out,lys_node *node,int *first)

{
  lys_module *plVar1;
  int *first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_inout *input;
  
  plVar1 = lys_main_module(node->module);
  jsons_print_object(out,"input","module",plVar1->name,0,first);
  jsons_print_typedefs
            (out,*(lys_tpdf **)node->hash,(uint8_t)*(undefined2 *)(node->padding + 2),(int *)0x0);
  jsons_print_musts(out,(lys_restr *)node[1].name,node->padding[1],(int *)0x0);
  jsons_print_groupings(out,node->child,(int *)0x0);
  jsons_print_data(out,node->module,node->child,(int *)0x0);
  ly_print(out,"}");
  return;
}



void jsons_print_output(lyout *out,lys_node *node,int *first)

{
  lys_module *plVar1;
  int *first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_inout *output;
  
  plVar1 = lys_main_module(node->module);
  jsons_print_object(out,"output","module",plVar1->name,0,first);
  jsons_print_typedefs
            (out,*(lys_tpdf **)node->hash,(uint8_t)*(undefined2 *)(node->padding + 2),(int *)0x0);
  jsons_print_musts(out,(lys_restr *)node[1].name,node->padding[1],(int *)0x0);
  jsons_print_groupings(out,node->child,(int *)0x0);
  jsons_print_data(out,node->module,node->child,(int *)0x0);
  ly_print(out,"}");
  return;
}



void jsons_print_notif(lyout *out,lys_node *node,int *first)

{
  char *val;
  lys_module *plVar1;
  int *first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_notif *ntf;
  
  val = jsons_nodetype_str(node->nodetype);
  jsons_print_object(out,node->name,"nodetype",val,0,first);
  plVar1 = lys_main_module(node->module);
  ly_print(out,",\"module\":\"%s\"",plVar1->name);
  if ((node->module->field_0x40 & 1) != 0) {
    ly_print(out,",\"included-from\":\"%s\"",node->module->name);
  }
  jsons_print_text(out,"description","text",node->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",node->ref,1,(int *)0x0);
  jsons_print_status(out,node->flags,(int *)0x0);
  jsons_print_iffeatures(out,node->module,node->iffeature,node->iffeature_size,(int *)0x0);
  jsons_print_typedefs
            (out,(lys_tpdf *)node[1].name,(uint8_t)*(undefined2 *)(node->padding + 2),(int *)0x0);
  jsons_print_musts(out,(lys_restr *)node[1].dsc,node->padding[1],(int *)0x0);
  jsons_print_groupings(out,node->child,(int *)0x0);
  jsons_print_data(out,node->module,node->child,(int *)0x0);
  ly_print(out,"}");
  return;
}



void jsons_print_rpc(lyout *out,lys_node *node,int *first)

{
  char *val;
  lys_module *plVar1;
  int *first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node *child;
  lys_node_rpc_action *rpc;
  
  val = jsons_nodetype_str(node->nodetype);
  jsons_print_object(out,node->name,"nodetype",val,0,first);
  plVar1 = lys_main_module(node->module);
  ly_print(out,",\"module\":\"%s\"",plVar1->name);
  if ((node->module->field_0x40 & 1) != 0) {
    ly_print(out,",\"included-from\":\"%s\"",node->module->name);
  }
  jsons_print_text(out,"description","text",node->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",node->ref,1,(int *)0x0);
  jsons_print_status(out,node->flags,(int *)0x0);
  jsons_print_iffeatures(out,node->module,node->iffeature,node->iffeature_size,(int *)0x0);
  jsons_print_typedefs
            (out,(lys_tpdf *)node[1].name,(uint8_t)*(undefined2 *)(node->padding + 2),(int *)0x0);
  jsons_print_groupings(out,node->child,(int *)0x0);
  for (child = node->child; child != (lys_node *)0x0; child = child->next) {
    if ((child->nodetype & LYS_INPUT) != LYS_UNKNOWN) {
      jsons_print_input(out,child,(int *)0x0);
      break;
    }
  }
  child = node->child;
  do {
    if (child == (lys_node *)0x0) {
LAB_001fca12:
      ly_print(out,"}");
      return;
    }
    if ((child->nodetype & LYS_OUTPUT) != LYS_UNKNOWN) {
      jsons_print_output(out,child,(int *)0x0);
      goto LAB_001fca12;
    }
    child = child->next;
  } while( true );
}



void jsons_print_action(lyout *out,lys_node *node,int *first)

{
  char *val;
  lys_module *plVar1;
  int *first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node *child;
  lys_node_rpc_action *act;
  
  val = jsons_nodetype_str(node->nodetype);
  jsons_print_object(out,node->name,"nodetype",val,0,first);
  plVar1 = lys_main_module(node->module);
  ly_print(out,",\"module\":\"%s\"",plVar1->name);
  if ((node->module->field_0x40 & 1) != 0) {
    ly_print(out,",\"included-from\":\"%s\"",node->module->name);
  }
  jsons_print_text(out,"description","text",node->dsc,1,(int *)0x0);
  jsons_print_text(out,"reference","text",node->ref,1,(int *)0x0);
  jsons_print_status(out,node->flags,(int *)0x0);
  jsons_print_iffeatures(out,node->module,node->iffeature,node->iffeature_size,(int *)0x0);
  jsons_print_typedefs
            (out,(lys_tpdf *)node[1].name,(uint8_t)*(undefined2 *)(node->padding + 2),(int *)0x0);
  jsons_print_groupings(out,node->child,(int *)0x0);
  for (child = node->child; child != (lys_node *)0x0; child = child->next) {
    if ((child->nodetype & LYS_INPUT) != LYS_UNKNOWN) {
      jsons_print_input(out,child,(int *)0x0);
      break;
    }
  }
  child = node->child;
  do {
    if (child == (lys_node *)0x0) {
LAB_001fcc72:
      ly_print(out,"}");
      return;
    }
    if ((child->nodetype & LYS_OUTPUT) != LYS_UNKNOWN) {
      jsons_print_output(out,child,(int *)0x0);
      goto LAB_001fcc72;
    }
    child = child->next;
  } while( true );
}



int jsons_print_model(lyout *out,lys_module *module,char *target_schema_path)

{
  char *target_schema_path_local;
  lys_module *module_local;
  lyout *out_local;
  int rc;
  
  rc = 0;
  if (target_schema_path == (char *)0x0) {
    if ((module->field_0x40 & 1) == 0) {
      jsons_print_module(out,module);
    }
    else {
      jsons_print_submodule(out,(lys_submodule *)module);
    }
  }
  else {
    ly_print(out,"{");
    rc = lys_print_target(out,module,target_schema_path,jsons_print_typedef,jsons_print_identity,
                          jsons_print_feature,jsons_print_type,jsons_print_grouping,
                          jsons_print_container,jsons_print_choice,jsons_print_leaf,
                          jsons_print_leaflist,jsons_print_list,jsons_print_anydata,jsons_print_case
                          ,jsons_print_notif,jsons_print_rpc,jsons_print_action,jsons_print_input,
                          jsons_print_output);
    ly_print(out,"}");
  }
  ly_print_flush(out);
  return rc;
}



int modlist_add(mlist **mlist,lys_module *mod)

{
  mlist *pmVar1;
  lys_module *mod_local;
  mlist **mlist_local;
  mlist *iter;
  
  for (iter = *mlist; (iter != (mlist *)0x0 && (mod != iter->module)); iter = iter->next) {
  }
  if (iter == (mlist *)0x0) {
    pmVar1 = (mlist *)malloc(0x18);
    if (pmVar1 == (mlist *)0x0) {
      ly_log(mod->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","modlist_add");
      return 1;
    }
    pmVar1->next = *mlist;
    pmVar1->module = mod;
    pmVar1->printed = '\0';
    *mlist = pmVar1;
  }
  return 0;
}



void free_mlist(mlist **mlist)

{
  mlist *__ptr;
  mlist **mlist_local;
  mlist *miter;
  
  while (*mlist != (mlist *)0x0) {
    __ptr = *mlist;
    *mlist = __ptr->next;
    free(__ptr);
  }
  return;
}



void xml_print_ns(lyout *out,lyd_node *node,mlist **mlist,int options)

{
  LYS_NODE LVar1;
  int iVar2;
  lys_module *plVar3;
  int options_local;
  mlist **mlist_local;
  lyd_node *node_local;
  lyout *out_local;
  int r;
  lyd_node *cur;
  lyd_node *next;
  lyd_node *node2;
  lyd_attr *attr;
  mlist *miter;
  lys_module *wdmod;
  
  if (out == (lyout *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("out",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_xml.c"
                  ,0x54,"xml_print_ns");
  }
  if (node == (lyd_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("node",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_xml.c"
                  ,0x55,"xml_print_ns");
  }
  for (attr = node->attr; attr != (lyd_attr *)0x0; attr = attr->next) {
    iVar2 = strcmp(node->schema->name,"filter");
    if ((iVar2 != 0) ||
       ((iVar2 = strcmp(node->schema->module->name,"ietf-netconf"), iVar2 != 0 &&
        (iVar2 = strcmp(node->schema->module->name,"notifications"), iVar2 != 0)))) {
      plVar3 = lys_main_module(attr->annotation->module);
      iVar2 = modlist_add(mlist,plVar3);
      if (iVar2 != 0) goto LAB_001fd2f5;
    }
  }
  LVar1 = node->schema->nodetype;
  if (LVar1 != LYS_ACTION) {
    if (LYS_ACTION < LVar1) goto LAB_001fd2f5;
    if (LVar1 != LYS_RPC) {
      if (LYS_RPC < LVar1) goto LAB_001fd2f5;
      if (LVar1 != LYS_NOTIF) {
        if (LYS_NOTIF < LVar1) goto LAB_001fd2f5;
        if (LVar1 != LYS_LIST) {
          if (LYS_LIST < LVar1) goto LAB_001fd2f5;
          if (LVar1 != LYS_LEAFLIST) {
            if (LYS_LEAFLIST < LVar1) goto LAB_001fd2f5;
            if (LVar1 == LYS_CONTAINER) goto LAB_001fd0fc;
            if (LVar1 != LYS_LEAF) goto LAB_001fd2f5;
          }
          if ((((node->field_0x9 & 1) != 0) && ((options & 0xc0U) != 0)) &&
             (plVar3 = ly_ctx_get_module(node->schema->module->ctx,"ietf-netconf-with-defaults",
                                         (char *)0x0,1), plVar3 != (lys_module *)0x0)) {
            modlist_add(mlist,plVar3);
          }
          goto LAB_001fd2f5;
        }
      }
    }
  }
LAB_001fd0fc:
  if ((((options & 0xc0U) == 0) ||
      (plVar3 = ly_ctx_get_module(node->schema->module->ctx,"ietf-netconf-with-defaults",(char *)0x0
                                  ,1), plVar3 == (lys_module *)0x0)) ||
     (iVar2 = modlist_add(mlist,plVar3), iVar2 == 0)) {
    for (node2 = node->child; node2 != (lyd_node *)0x0; node2 = node2->next) {
      cur = node2;
      while (cur != (lyd_node *)0x0) {
        for (attr = cur->attr; attr != (lyd_attr *)0x0; attr = attr->next) {
          iVar2 = strcmp(cur->schema->name,"filter");
          if ((iVar2 != 0) ||
             ((iVar2 = strcmp(cur->schema->module->name,"ietf-netconf"), iVar2 != 0 &&
              (iVar2 = strcmp(cur->schema->module->name,"notifications"), iVar2 != 0)))) {
            plVar3 = lys_main_module(attr->annotation->module);
            iVar2 = modlist_add(mlist,plVar3);
            if (iVar2 != 0) goto LAB_001fd2f5;
          }
        }
        if ((cur->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
          next = cur->child;
        }
        else {
          next = (lyd_node *)0x0;
        }
        if (next == (lyd_node *)0x0) {
          if (cur == node2) break;
          next = cur->next;
        }
        while ((next == (lyd_node *)0x0 && (cur = cur->parent, cur->parent != node2->parent))) {
          next = cur->next;
        }
        cur = next;
      }
    }
  }
LAB_001fd2f5:
  for (miter = *mlist; miter != (mlist *)0x0; miter = miter->next) {
    if (miter->printed == '\0') {
      ly_print(out," xmlns:%s=\"%s\"",miter->module->prefix,miter->module->ns);
      miter->printed = '\x01';
    }
  }
  return;
}



int xml_print_attrs(lyout *out,lyd_node *node,int options)

{
  int iVar1;
  int *piVar2;
  char *pcVar3;
  long in_FS_OFFSET;
  int options_local;
  lyd_node *node_local;
  lyout *out_local;
  uint32_t ns_count;
  uint32_t i;
  int rpc_filter;
  char **prefs;
  char **nss;
  lyd_attr *attr;
  char *xml_expr;
  lys_module *wdmod;
  char *p;
  size_t len;
  char *mod_name;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  xml_expr = (char *)0x0;
  rpc_filter = 0;
  wdmod = (lys_module *)0x0;
  piVar2 = __errno_location();
  *piVar2 = 0;
  if (((node->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST)) != LYS_UNKNOWN) &&
     (((((node->field_0x9 & 1) != 0 && ((options & 0xc0U) != 0)) ||
       (((node->field_0x9 & 1) == 0 &&
        (((options & 0x40U) != 0 && (iVar1 = lyd_wd_default((lyd_node_leaf_list *)node), iVar1 != 0)
         ))))) &&
      (wdmod = ly_ctx_get_module(node->schema->module->ctx,"ietf-netconf-with-defaults",(char *)0x0,
                                 1), wdmod != (lys_module *)0x0)))) {
    ly_print(out," %s:default=\"true\"",wdmod->prefix);
  }
  iVar1 = strcmp(node->schema->name,"filter");
  if ((iVar1 == 0) &&
     ((iVar1 = strcmp(node->schema->module->name,"ietf-netconf"), iVar1 == 0 ||
      (iVar1 = strcmp(node->schema->module->name,"notifications"), iVar1 == 0)))) {
    rpc_filter = 1;
  }
  attr = node->attr;
  do {
    if (attr == (lyd_attr *)0x0) {
      piVar2 = __errno_location();
      if (*piVar2 == 0) {
        iVar1 = 0;
      }
      else {
        piVar2 = __errno_location();
        pcVar3 = strerror(*piVar2);
        ly_log(node->schema->module->ctx,LY_LLERR,LY_ESYS,"Print error (%s).",pcVar3);
        iVar1 = 1;
      }
LAB_001fd913:
      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
        return iVar1;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    if (rpc_filter == 0) {
      ly_print(out," %s:%s=\"",attr->annotation->module->prefix,attr->name);
    }
    else {
      iVar1 = strcmp(attr->name,"select");
      if (iVar1 == 0) {
        xml_expr = transform_json2xml(node->schema->module,attr->value_str,0,&prefs,&nss,&ns_count);
        if (xml_expr == (char *)0x0) {
          iVar1 = 1;
          goto LAB_001fd913;
        }
        for (i = 0; i < ns_count; i = i + 1) {
          ly_print(out," xmlns:%s=\"%s\"",prefs[i],nss[i]);
        }
        free(prefs);
        free(nss);
      }
      ly_print(out," %s=\"",attr->name);
    }
    if (false) {
switchD_001fd627_caseD_0:
      ly_log(node->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_xml.c"
             ,0x116);
      iVar1 = 1;
      goto LAB_001fd913;
    }
    switch(attr->value_type) {
    default:
      goto switchD_001fd627_caseD_0;
    case LY_TYPE_BINARY:
    case LY_TYPE_BITS:
    case LY_TYPE_BOOL:
    case LY_TYPE_DEC64:
    case LY_TYPE_ENUM:
    case LY_TYPE_STRING:
    case LY_TYPE_INT8:
    case LY_TYPE_UINT8:
    case LY_TYPE_INT16:
    case LY_TYPE_UINT16:
    case LY_TYPE_INT32:
    case LY_TYPE_UINT32:
    case LY_TYPE_INT64:
    case LY_TYPE_UINT64:
      if (attr->value_str != (char *)0x0) {
        pcVar3 = xml_expr;
        if (xml_expr == (char *)0x0) {
          pcVar3 = attr->value_str;
        }
        lyxml_dump_text(out,pcVar3,LYXML_DATA_ATTR);
      }
      break;
    case LY_TYPE_EMPTY:
      break;
    case LY_TYPE_IDENT:
      if (attr->value_str != (char *)0x0) {
        p = strchr(attr->value_str,0x3a);
        if (p == (char *)0x0) {
                    // WARNING: Subroutine does not return
          __assert_fail("p",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_xml.c"
                        ,0xf3,"xml_print_attrs");
        }
        len = (long)p - (long)attr->value_str;
        mod_name = attr->annotation->module->name;
        iVar1 = strncmp(attr->value_str,mod_name,len);
        if ((iVar1 != 0) || (mod_name[len] != '\0')) goto switchD_001fd627_caseD_8;
        p = p + 1;
        lyxml_dump_text(out,p,LYXML_DATA_ATTR);
      }
      break;
    case LY_TYPE_INST:
switchD_001fd627_caseD_8:
      xml_expr = transform_json2xml(node->schema->module,(char *)node->ht,1,&prefs,&nss,&ns_count);
      if (xml_expr == (char *)0x0) {
        iVar1 = 1;
        goto LAB_001fd913;
      }
      for (i = 0; i < ns_count; i = i + 1) {
        ly_print(out," xmlns:%s=\"%s\"",prefs[i],nss[i]);
      }
      free(prefs);
      free(nss);
      lyxml_dump_text(out,xml_expr,LYXML_DATA_ATTR);
      lydict_remove(node->schema->module->ctx,xml_expr);
    }
    ly_print(out,"\"");
    if (xml_expr != (char *)0x0) {
      lydict_remove(node->schema->module->ctx,xml_expr);
    }
    attr = attr->next;
  } while( true );
}



int xml_print_leaf(lyout *out,int level,lyd_node *node,int toplevel,int options)

{
  int iVar1;
  int *piVar2;
  lys_module *plVar3;
  char *pcVar4;
  ulong uVar5;
  long in_FS_OFFSET;
  int options_local;
  lyd_node *node_local;
  int toplevel_local;
  int level_local;
  lyout *out_local;
  uint32_t ns_count;
  int_log_opts prev_ilo;
  uint32_t i;
  LY_DATA_TYPE datatype;
  char **prefs;
  char **nss;
  mlist *mlist;
  lyd_node_leaf_list *iter;
  lys_tpdf *tpdf;
  lyd_node_leaf_list *leaf;
  char *ns;
  lys_type *type;
  char *xml_expr;
  char *p;
  size_t len;
  char *mod_name;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  mlist = (mlist *)0x0;
  leaf = (lyd_node_leaf_list *)node;
  piVar2 = __errno_location();
  *piVar2 = 0;
  if (((toplevel == 0) && (node->parent != (lyd_node *)0x0)) &&
     (iVar1 = nscmp(node,node->parent), iVar1 == 0)) {
    if (level == 0) {
      uVar5 = 0;
    }
    else {
      uVar5 = (ulong)(uint)((level + -1) * 2);
    }
    ly_print(out,"%*s<%s",uVar5,&DAT_0022e624,node->schema->name);
  }
  else {
    plVar3 = lyd_node_module(node);
    ns = plVar3->ns;
    if (level == 0) {
      uVar5 = 0;
    }
    else {
      uVar5 = (ulong)(uint)((level + -1) * 2);
    }
    ly_print(out,"%*s<%s xmlns=\"%s\"",uVar5,&DAT_0022e624,node->schema->name,ns);
  }
  if (toplevel != 0) {
    xml_print_ns(out,node,&mlist,options);
    free_mlist(&mlist);
  }
  iVar1 = xml_print_attrs(out,node,options);
  if (iVar1 == 0) {
    datatype = leaf->value_type;
    while (true) {
      switch(datatype) {
      default:
        goto switchD_001fdb16_caseD_0;
      case LY_TYPE_BINARY:
      case LY_TYPE_BITS:
      case LY_TYPE_BOOL:
      case LY_TYPE_DEC64:
      case LY_TYPE_ENUM:
      case LY_TYPE_UNION:
      case LY_TYPE_INT8:
      case LY_TYPE_UINT8:
      case LY_TYPE_INT16:
      case LY_TYPE_UINT16:
      case LY_TYPE_INT32:
      case LY_TYPE_UINT32:
      case LY_TYPE_INT64:
      case LY_TYPE_UINT64:
switchD_001fdb16_caseD_1:
        if ((leaf->value_str == (char *)0x0) || (*leaf->value_str == '\0')) {
          ly_print(out,"/>");
        }
        else {
          ly_print(out,">");
          lyxml_dump_text(out,leaf->value_str,LYXML_DATA_ELEM);
          ly_print(out,"</%s>",node->schema->name);
        }
        goto LAB_001fe000;
      case LY_TYPE_EMPTY:
      case LY_TYPE_UNKNOWN:
        ly_print(out,"/>");
        goto LAB_001fe000;
      case LY_TYPE_IDENT:
        if ((leaf->value_str == (char *)0x0) || (*leaf->value_str == '\0')) {
          ly_print(out,"/>");
          goto LAB_001fe000;
        }
        p = strchr(leaf->value_str,0x3a);
        if (p == (char *)0x0) {
                    // WARNING: Subroutine does not return
          __assert_fail("p",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_xml.c"
                        ,0x177,"xml_print_leaf");
        }
        len = (long)p - (long)leaf->value_str;
        mod_name = leaf->schema->module->name;
        iVar1 = strncmp(leaf->value_str,mod_name,len);
        if ((iVar1 == 0) && (mod_name[len] == '\0')) {
          ly_print(out,">");
          p = p + 1;
          lyxml_dump_text(out,p,LYXML_DATA_ELEM);
          ly_print(out,"</%s>",node->schema->name);
          goto LAB_001fe000;
        }
        datatype = LY_TYPE_INST;
        break;
      case LY_TYPE_INST:
        xml_expr = transform_json2xml(node->schema->module,(char *)node->ht,1,&prefs,&nss,&ns_count)
        ;
        if (xml_expr == (char *)0x0) {
          iVar1 = 1;
          goto LAB_001fe07e;
        }
        for (i = 0; i < ns_count; i = i + 1) {
          ly_print(out," xmlns:%s=\"%s\"",prefs[i],nss[i]);
        }
        free(prefs);
        free(nss);
        if (*xml_expr == '\0') {
          ly_print(out,"/>");
        }
        else {
          ly_print(out,">");
          lyxml_dump_text(out,xml_expr,LYXML_DATA_ELEM);
          ly_print(out,"</%s>",node->schema->name);
        }
        lydict_remove(node->schema->module->ctx,xml_expr);
LAB_001fe000:
        if (level != 0) {
          ly_print(out,"\n");
        }
        piVar2 = __errno_location();
        if (*piVar2 == 0) {
          iVar1 = 0;
        }
        else {
          piVar2 = __errno_location();
          pcVar4 = strerror(*piVar2);
          ly_log(node->schema->module->ctx,LY_LLERR,LY_ESYS,"Print error (%s).",pcVar4);
          iVar1 = 1;
        }
        goto LAB_001fe07e;
      case LY_TYPE_LEAFREF:
        for (iter = (lyd_node_leaf_list *)(leaf->value).enm;
            (iter != (lyd_node_leaf_list *)0x0 && (iter->value_type == LY_TYPE_LEAFREF));
            iter = (lyd_node_leaf_list *)(iter->value).enm) {
        }
        if (iter == (lyd_node_leaf_list *)0x0) {
          type = lyd_leaf_type(leaf);
          if (type == (lys_type *)0x0) {
            iVar1 = 1;
            goto LAB_001fe07e;
          }
          datatype = type->base;
        }
        else {
          datatype = iter->value_type;
        }
        break;
      case LY_TYPE_STRING:
        ly_ilo_change((ly_ctx *)0x0,ILO_IGNORE,&prev_ilo,(ly_err_item **)0x0);
        type = lyd_leaf_type(leaf);
        ly_ilo_restore((ly_ctx *)0x0,prev_ilo,(ly_err_item *)0x0,0);
        if (type == (lys_type *)0x0) goto switchD_001fdb16_caseD_1;
        tpdf = type->der;
        while ((tpdf->module != (lys_module *)0x0 &&
               ((iVar1 = strcmp(tpdf->name,"xpath1.0"), iVar1 != 0 ||
                (iVar1 = strcmp(tpdf->module->name,"ietf-yang-types"), iVar1 != 0))))) {
          tpdf = (tpdf->type).der;
        }
        if (tpdf->module == (lys_module *)0x0) goto switchD_001fdb16_caseD_1;
        datatype = LY_TYPE_INST;
      }
    }
switchD_001fdb16_caseD_0:
    ly_log(node->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_xml.c"
           ,0x1b6);
    iVar1 = 1;
  }
  else {
    iVar1 = 1;
  }
LAB_001fe07e:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int xml_print_container(lyout *out,int level,lyd_node *node,int toplevel,int options)

{
  int iVar1;
  int *piVar2;
  lys_module *plVar3;
  undefined *puVar4;
  char *pcVar5;
  ulong uVar6;
  long in_FS_OFFSET;
  int options_local;
  lyd_node *node_local;
  int toplevel_local;
  int level_local;
  lyout *out_local;
  mlist *mlist;
  lyd_node *child;
  char *ns;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  mlist = (mlist *)0x0;
  piVar2 = __errno_location();
  *piVar2 = 0;
  if ((toplevel == 0) && (node->parent != (lyd_node *)0x0)) {
    iVar1 = nscmp(node,node->parent);
    if (iVar1 == 0) {
      if (level == 0) {
        uVar6 = 0;
      }
      else {
        uVar6 = (ulong)(uint)((level + -1) * 2);
      }
      ly_print(out,"%*s<%s",uVar6,&DAT_0022e624,node->schema->name);
      goto LAB_001fe1a6;
    }
  }
  plVar3 = lyd_node_module(node);
  ns = plVar3->ns;
  if (level == 0) {
    uVar6 = 0;
  }
  else {
    uVar6 = (ulong)(uint)((level + -1) * 2);
  }
  ly_print(out,"%*s<%s xmlns=\"%s\"",uVar6,&DAT_0022e624,node->schema->name,ns);
LAB_001fe1a6:
  if (toplevel != 0) {
    xml_print_ns(out,node,&mlist,options);
    free_mlist(&mlist);
  }
  iVar1 = xml_print_attrs(out,node,options);
  if (iVar1 == 0) {
    if (node->child == (lyd_node *)0x0) {
      if (level == 0) {
        puVar4 = &DAT_0022e624;
      }
      else {
        puVar4 = &DAT_0022e662;
      }
      ly_print(out,"/>%s",puVar4);
    }
    else {
      if (level == 0) {
        puVar4 = &DAT_0022e624;
      }
      else {
        puVar4 = &DAT_0022e662;
      }
      ly_print(out,">%s",puVar4);
      for (child = node->child; child != (lyd_node *)0x0; child = child->next) {
        if (level == 0) {
          iVar1 = 0;
        }
        else {
          iVar1 = level + 1;
        }
        iVar1 = xml_print_node(out,iVar1,child,0,options);
        if (iVar1 != 0) {
          iVar1 = 1;
          goto LAB_001fe372;
        }
      }
      if (level == 0) {
        puVar4 = &DAT_0022e624;
      }
      else {
        puVar4 = &DAT_0022e662;
      }
      if (level == 0) {
        uVar6 = 0;
      }
      else {
        uVar6 = (ulong)(uint)((level + -1) * 2);
      }
      ly_print(out,"%*s</%s>%s",uVar6,&DAT_0022e624,node->schema->name,puVar4);
    }
    piVar2 = __errno_location();
    if (*piVar2 == 0) {
      iVar1 = 0;
    }
    else {
      piVar2 = __errno_location();
      pcVar5 = strerror(*piVar2);
      ly_log(node->schema->module->ctx,LY_LLERR,LY_ESYS,"Print error (%s).",pcVar5);
      iVar1 = 1;
    }
  }
  else {
    iVar1 = 1;
  }
LAB_001fe372:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int xml_print_list(lyout *out,int level,lyd_node *node,int is_list,int toplevel,int options)

{
  int iVar1;
  int *piVar2;
  lys_module *plVar3;
  undefined *puVar4;
  char *pcVar5;
  ulong uVar6;
  long in_FS_OFFSET;
  int options_local;
  int toplevel_local;
  lyd_node *node_local;
  int is_list_local;
  int level_local;
  lyout *out_local;
  mlist *mlist;
  lyd_node *child;
  char *ns;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  mlist = (mlist *)0x0;
  piVar2 = __errno_location();
  *piVar2 = 0;
  if (is_list == 0) {
    xml_print_leaf(out,level,node,toplevel,options);
  }
  else {
    if ((toplevel == 0) && (node->parent != (lyd_node *)0x0)) {
      iVar1 = nscmp(node,node->parent);
      if (iVar1 != 0) goto LAB_001fe404;
      if (level == 0) {
        uVar6 = 0;
      }
      else {
        uVar6 = (ulong)(uint)((level + -1) * 2);
      }
      ly_print(out,"%*s<%s",uVar6,&DAT_0022e624,node->schema->name);
    }
    else {
LAB_001fe404:
      plVar3 = lyd_node_module(node);
      ns = plVar3->ns;
      if (level == 0) {
        uVar6 = 0;
      }
      else {
        uVar6 = (ulong)(uint)((level + -1) * 2);
      }
      ly_print(out,"%*s<%s xmlns=\"%s\"",uVar6,&DAT_0022e624,node->schema->name,ns);
    }
    if (toplevel != 0) {
      xml_print_ns(out,node,&mlist,options);
      free_mlist(&mlist);
    }
    iVar1 = xml_print_attrs(out,node,options);
    if (iVar1 != 0) {
      iVar1 = 1;
      goto LAB_001fe692;
    }
    if (node->child == (lyd_node *)0x0) {
      if (level == 0) {
        puVar4 = &DAT_0022e624;
      }
      else {
        puVar4 = &DAT_0022e662;
      }
      ly_print(out,"/>%s",puVar4);
    }
    else {
      if (level == 0) {
        puVar4 = &DAT_0022e624;
      }
      else {
        puVar4 = &DAT_0022e662;
      }
      ly_print(out,">%s",puVar4);
      for (child = node->child; child != (lyd_node *)0x0; child = child->next) {
        if (level == 0) {
          iVar1 = 0;
        }
        else {
          iVar1 = level + 1;
        }
        iVar1 = xml_print_node(out,iVar1,child,0,options);
        if (iVar1 != 0) {
          iVar1 = 1;
          goto LAB_001fe692;
        }
      }
      if (level == 0) {
        puVar4 = &DAT_0022e624;
      }
      else {
        puVar4 = &DAT_0022e662;
      }
      if (level == 0) {
        uVar6 = 0;
      }
      else {
        uVar6 = (ulong)(uint)((level + -1) * 2);
      }
      ly_print(out,"%*s</%s>%s",uVar6,&DAT_0022e624,node->schema->name,puVar4);
    }
  }
  piVar2 = __errno_location();
  if (*piVar2 == 0) {
    iVar1 = 0;
  }
  else {
    piVar2 = __errno_location();
    pcVar5 = strerror(*piVar2);
    ly_log(node->schema->module->ctx,LY_LLERR,LY_ESYS,"Print error (%s).",pcVar5);
    iVar1 = 1;
  }
LAB_001fe692:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int xml_print_anydata(lyout *out,int level,lyd_node *node,int toplevel,int options)

{
  int iVar1;
  int *piVar2;
  lys_module *plVar3;
  undefined *puVar4;
  char *pcVar5;
  ulong uVar6;
  long in_FS_OFFSET;
  int options_local;
  lyd_node *node_local;
  int toplevel_local;
  int level_local;
  lyout *out_local;
  char *buf;
  mlist *mlist;
  lyd_node *iter;
  lyd_node_anydata *any;
  char *ns;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  mlist = (mlist *)0x0;
  any = (lyd_node_anydata *)node;
  piVar2 = __errno_location();
  *piVar2 = 0;
  if (((toplevel == 0) && (node->parent != (lyd_node *)0x0)) &&
     (iVar1 = nscmp(node,node->parent), iVar1 == 0)) {
    if (level == 0) {
      uVar6 = 0;
    }
    else {
      uVar6 = (ulong)(uint)((level + -1) * 2);
    }
    ly_print(out,"%*s<%s",uVar6,&DAT_0022e624,node->schema->name);
  }
  else {
    plVar3 = lyd_node_module(node);
    ns = plVar3->ns;
    if (level == 0) {
      uVar6 = 0;
    }
    else {
      uVar6 = (ulong)(uint)((level + -1) * 2);
    }
    ly_print(out,"%*s<%s xmlns=\"%s\"",uVar6,&DAT_0022e624,node->schema->name,ns);
  }
  if (toplevel != 0) {
    xml_print_ns(out,node,&mlist,options);
  }
  iVar1 = xml_print_attrs(out,node,options);
  if (iVar1 == 0) {
    if (((any->value).str == (char *)0x0) ||
       ((any->value_type == LYD_ANYDATA_CONSTSTRING && (*(any->value).str == '\0')))) {
      if (level == 0) {
        puVar4 = &DAT_0022e624;
      }
      else {
        puVar4 = &DAT_0022e662;
      }
      ly_print(out,"/>%s",puVar4);
    }
    else {
      if ((any->value_type == LYD_ANYDATA_LYB) &&
         (iter = lyd_parse_mem(node->schema->module->ctx,(any->value).str,LYD_LYB,0x2200),
         iter != (lyd_node *)0x0)) {
        free((any->value).str);
        any->value_type = LYD_ANYDATA_DATATREE;
        (any->value).tree = iter;
      }
      if (any->value_type == LYD_ANYDATA_DATATREE) {
        for (iter = (any->value).tree; iter != (lyd_node *)0x0; iter = iter->next) {
          xml_print_ns(out,iter,&mlist,options);
        }
      }
      ly_print(out,">");
      free_mlist(&mlist);
      if (true) {
        switch(any->value_type) {
        case LYD_ANYDATA_CONSTSTRING:
          lyxml_dump_text(out,(any->value).str,LYXML_DATA_ELEM);
          break;
        case LYD_ANYDATA_STRING:
        case LYD_ANYDATA_JSOND:
        case LYD_ANYDATA_SXMLD:
        case LYD_ANYDATA_LYBD:
                    // WARNING: Subroutine does not return
          __assert_fail("0",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_xml.c"
                        ,0x274,"xml_print_anydata");
        case LYD_ANYDATA_JSON:
        case LYD_ANYDATA_LYB:
          ly_log(node->schema->module->ctx,LY_LLWRN,LY_SUCCESS,
                 "Unable to print anydata content (type %d) as XML.",(ulong)any->value_type);
          break;
        case LYD_ANYDATA_SXML:
          ly_print(out,"%s",(any->value).str);
          break;
        case LYD_ANYDATA_XML:
          if (level == 0) {
            iVar1 = 0x10;
          }
          else {
            iVar1 = 0x32;
          }
          lyxml_print_mem(&buf,(any->value).xml,iVar1);
          if (level == 0) {
            puVar4 = &DAT_0022e624;
          }
          else {
            puVar4 = &DAT_0022e662;
          }
          ly_print(out,"%s%s",puVar4,buf);
          free(buf);
          break;
        case LYD_ANYDATA_DATATREE:
          if ((any->value).str != (char *)0x0) {
            if (level != 0) {
              ly_print(out,"\n");
            }
            for (iter = (any->value).tree; iter != (lyd_node *)0x0; iter = iter->next) {
              if (level == 0) {
                iVar1 = 0;
              }
              else {
                iVar1 = level + 1;
              }
              iVar1 = xml_print_node(out,iVar1,iter,0,options & 0xfffffefe);
              if (iVar1 != 0) {
                iVar1 = 1;
                goto LAB_001feb94;
              }
            }
          }
        }
      }
      if (level == 0) {
        puVar4 = &DAT_0022e624;
      }
      else {
        puVar4 = &DAT_0022e662;
      }
      ly_print(out,"</%s>%s",node->schema->name,puVar4);
    }
    piVar2 = __errno_location();
    if (*piVar2 == 0) {
      iVar1 = 0;
    }
    else {
      piVar2 = __errno_location();
      pcVar5 = strerror(*piVar2);
      ly_log(node->schema->module->ctx,LY_LLERR,LY_ESYS,"Print error (%s).",pcVar5);
      iVar1 = 1;
    }
  }
  else {
    iVar1 = 1;
  }
LAB_001feb94:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int xml_print_node(lyout *out,int level,lyd_node *node,int toplevel,int options)

{
  LYS_NODE LVar1;
  int iVar2;
  int options_local;
  lyd_node *node_local;
  int toplevel_local;
  int level_local;
  lyout *out_local;
  int ret;
  
  iVar2 = lyd_toprint(node,options);
  if (iVar2 == 0) {
    return 0;
  }
  LVar1 = node->schema->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_001fec68_caseD_20:
    iVar2 = xml_print_anydata(out,level,node,toplevel,options);
    return iVar2;
  }
  if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
    if (LVar1 == LYS_ACTION) {
switchD_001fec68_caseD_1:
      iVar2 = xml_print_container(out,level,node,toplevel,options);
      return iVar2;
    }
    if (LVar1 < (LYS_CONTAINER|LYS_ACTION)) {
      if (LVar1 == LYS_RPC) goto switchD_001fec68_caseD_1;
      if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
        if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
          if ((LVar1 != LYS_UNKNOWN) && (true)) {
            switch(LVar1) {
            case LYS_CONTAINER:
              goto switchD_001fec68_caseD_1;
            case LYS_LEAF:
              iVar2 = xml_print_leaf(out,level,node,toplevel,options);
              return iVar2;
            case LYS_LEAFLIST:
              iVar2 = xml_print_list(out,level,node,0,toplevel,options);
              return iVar2;
            case LYS_LIST:
              iVar2 = xml_print_list(out,level,node,1,toplevel,options);
              return iVar2;
            case LYS_ANYXML:
              goto switchD_001fec68_caseD_20;
            }
          }
        }
        else if (LVar1 == LYS_NOTIF) goto switchD_001fec68_caseD_1;
      }
    }
  }
  ly_log(node->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_xml.c"
         ,0x29e);
  return 1;
}



int xml_print_data(lyout *out,lyd_node *root,int options)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  undefined *puVar4;
  char *pcVar5;
  ulong uVar6;
  int options_local;
  lyd_node *root_local;
  lyout *out_local;
  int level;
  int action_input;
  lyd_node *node;
  lyd_node *next;
  lys_node *parent;
  
  parent = (lys_node *)0x0;
  bVar1 = false;
  piVar3 = __errno_location();
  *piVar3 = 0;
  if (root == (lyd_node *)0x0) {
    if ((out->type == LYOUT_MEMORY) || (out->type == LYOUT_CALLBACK)) {
      ly_print(out,"");
    }
  }
  else {
    level = options >> 1 & 1;
    root_local = root;
    if ((options & 0x100U) != 0) {
      node = root;
      if (root->schema->nodetype != LYS_RPC) {
        while ((node != (lyd_node *)0x0 && (node->schema->nodetype != LYS_ACTION))) {
          if ((node->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
            next = node->child;
          }
          else {
            next = (lyd_node *)0x0;
          }
          if (next == (lyd_node *)0x0) {
            if (node == root) break;
            next = node->next;
          }
          while ((next == (lyd_node *)0x0 && (node = node->parent, node->parent != root->parent))) {
            next = node->next;
          }
          node = next;
        }
      }
      if (node != (lyd_node *)0x0) {
        if (((node->schema->nodetype & 0x4191) != LYS_UNKNOWN) && (node->child != (lyd_node *)0x0))
        {
          for (parent = lys_parent(node->child->schema);
              (parent != (lys_node *)0x0 && (parent->nodetype == LYS_USES));
              parent = lys_parent(parent)) {
          }
        }
        if ((parent == (lys_node *)0x0) || (parent->nodetype != LYS_OUTPUT)) {
          if (node->schema->nodetype == LYS_ACTION) {
            bVar1 = true;
          }
        }
        else {
          root_local = node->child;
        }
      }
    }
    if (bVar1) {
      if (level == 0) {
        puVar4 = &DAT_0022e624;
        uVar6 = 0;
      }
      else {
        puVar4 = &DAT_0022e662;
        uVar6 = (ulong)((level - 1U) * 2);
      }
      ly_print(out,"%*s<action xmlns=\"%s\">%s",uVar6,&DAT_0022e624,"urn:ietf:params:xml:ns:yang:1",
               puVar4);
      if (level != 0) {
        level = level + 1;
      }
    }
    for (node = root_local; node != (lyd_node *)0x0; node = node->next) {
      iVar2 = xml_print_node(out,level,node,1,options);
      if (iVar2 != 0) {
        return 1;
      }
      if ((options & 1U) == 0) break;
    }
    if (bVar1) {
      if (level != 0) {
        level = level + -1;
      }
      if (level == 0) {
        puVar4 = &DAT_0022e624;
        uVar6 = 0;
      }
      else {
        puVar4 = &DAT_0022e662;
        uVar6 = (ulong)(uint)((level + -1) * 2);
      }
      ly_print(out,"%*s</action>%s",uVar6,&DAT_0022e624,puVar4);
    }
  }
  ly_print_flush(out);
  piVar3 = __errno_location();
  iVar2 = *piVar3;
  if (iVar2 != 0) {
    piVar3 = __errno_location();
    pcVar5 = strerror(*piVar3);
    ly_log((ly_ctx *)0x0,LY_LLERR,LY_ESYS,"Print error (%s).",pcVar5);
  }
  return (uint)(iVar2 != 0);
}



int tree_print_indent(lyout *out,int level,tp_opts *opts)

{
  int iVar1;
  tp_opts *opts_local;
  int level_local;
  lyout *out_local;
  int i;
  int ret;
  
  ret = 0;
  if (opts->base_indent != '\0') {
    ret = ly_print(out,"%*s",(ulong)opts->base_indent,&DAT_0022e8d0);
  }
  for (i = 0; i < level; i = i + 1) {
    if (((long)(1 << ((byte)i & 0x1f)) & opts->indent) == 0) {
      iVar1 = ly_print(out,"   ");
    }
    else {
      iVar1 = ly_print(out,"|  ");
    }
    ret = ret + iVar1;
  }
  return ret;
}



int tree_sibling_is_valid_child
              (lys_node *node,int including,lys_module *module,lys_node *aug_parent,
              LYS_NODE nodetype)

{
  int iVar1;
  lys_node *plVar2;
  lys_module *plVar3;
  lys_module *plVar4;
  lys_node *aug_parent_local;
  lys_module *module_local;
  LYS_NODE nodetype_local;
  int including_local;
  lys_node *node_local;
  lys_node *cur;
  lys_node *cur2;
  
  if ((aug_parent != (lys_node *)0x0) && (aug_parent->nodetype != LYS_AUGMENT)) {
                    // WARNING: Subroutine does not return
    __assert_fail("!aug_parent || (aug_parent->nodetype == LYS_AUGMENT)",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_tree.c"
                  ,0x4f,"tree_sibling_is_valid_child");
  }
  if (node == (lys_node *)0x0) {
    iVar1 = 0;
  }
  else {
    plVar2 = lys_parent(node);
    if (((plVar2 == (lys_node *)0x0) && (iVar1 = strcmp(node->name,"config"), iVar1 == 0)) &&
       (iVar1 = strcmp(node->module->name,"ietf-netconf"), iVar1 == 0)) {
      iVar1 = 0;
    }
    else {
      cur = node;
      if (including == 0) {
        cur = node->next;
      }
      for (; cur != (lys_node *)0x0; cur = cur->next) {
        if ((aug_parent != (lys_node *)0x0) && (aug_parent != cur->parent)) {
          return 0;
        }
        if ((module->field_0x40 & 1) == 0) {
LAB_001ff2e7:
          plVar2 = lys_is_disabled(cur,0);
          if (plVar2 == (lys_node *)0x0) {
            if ((cur->nodetype == LYS_USES) ||
               ((cur->nodetype == LYS_CASE && ((cur->flags & 0x40) != 0)))) {
              iVar1 = tree_sibling_is_valid_child(cur->child,1,module,(lys_node *)0x0,nodetype);
              if (iVar1 != 0) {
                return 1;
              }
            }
            else if (nodetype == LYS_GROUPING) {
              if (cur->nodetype == LYS_GROUPING) {
                return 0;
              }
            }
            else if (nodetype < (LYS_CONTAINER|LYS_GROUPING)) {
              if (nodetype == LYS_NOTIF) {
                if (cur->nodetype == LYS_NOTIF) {
                  return 1;
                }
              }
              else {
                if (nodetype != LYS_RPC) goto LAB_001ff3dd;
                if (cur->nodetype == LYS_RPC) {
                  return 1;
                }
              }
            }
            else {
LAB_001ff3dd:
              if ((cur->nodetype & 0xc07f) != LYS_UNKNOWN) {
                return 1;
              }
              if (((cur->nodetype & 0x600) != LYS_UNKNOWN) && (cur->child != (lys_node *)0x0)) {
                return 1;
              }
              if (cur->nodetype == LYS_NOTIF) {
                for (cur2 = lys_parent(cur);
                    (cur2 != (lys_node *)0x0 && (cur2->nodetype == LYS_USES));
                    cur2 = lys_parent(cur2)) {
                }
                if (cur2 != (lys_node *)0x0) {
                  return 1;
                }
              }
            }
          }
        }
        else {
          plVar3 = lys_main_module(module);
          plVar4 = lys_node_module(cur);
          if (plVar3 == plVar4) goto LAB_001ff2e7;
        }
      }
      plVar2 = lys_parent(node);
      if ((plVar2 == (lys_node *)0x0) || (plVar2 = lys_parent(node), plVar2->nodetype != LYS_USES))
      {
        iVar1 = 0;
      }
      else {
        plVar2 = lys_parent(node);
        iVar1 = tree_sibling_is_valid_child(plVar2,0,module,(lys_node *)0x0,nodetype);
      }
    }
  }
  return iVar1;
}



void tree_next_indent(int level,lys_node *node,lys_node *aug_parent,tp_opts *opts)

{
  bool bVar1;
  int iVar2;
  lys_node *plVar3;
  tp_opts *opts_local;
  lys_node *aug_parent_local;
  lys_node *node_local;
  int level_local;
  int next_is_case;
  int has_next;
  
  bVar1 = false;
  if (level < 0x41) {
    opts->indent = ~(1L << ((char)level - 1U & 0x3f)) & opts->indent;
    if (node->nodetype != LYS_CASE) {
      plVar3 = lys_parent(node);
      if (plVar3 != (lys_node *)0x0) {
        plVar3 = lys_parent(node);
        if (((plVar3->nodetype & (LYS_CHOICE|LYS_CASE)) != LYS_UNKNOWN) &&
           (node->next != (lys_node *)0x0)) {
          plVar3 = lys_parent(node->next);
          if (plVar3 != (lys_node *)0x0) {
            plVar3 = lys_parent(node->next);
            if (plVar3->nodetype == LYS_CHOICE) {
              bVar1 = true;
            }
          }
        }
      }
    }
    iVar2 = tree_sibling_is_valid_child(node,0,opts->module,aug_parent,node->nodetype);
    if ((iVar2 != 0) && (!bVar1)) {
      opts->indent = 1L << ((char)level - 1U & 0x3f) | opts->indent;
    }
  }
  else {
    ly_log(node->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_tree.c"
           ,0x9d);
  }
  return;
}



uint16_t tree_get_max_name_len(lys_node *sibling,lys_node *aug_parent,int type_mask,tp_opts *opts)

{
  LYS_NODE LVar1;
  uint uVar2;
  uint16_t uVar3;
  lys_module *plVar4;
  size_t sVar5;
  lys_module *plVar6;
  tp_opts *opts_local;
  int type_mask_local;
  lys_node *aug_parent_local;
  lys_node *sibling_local;
  uint max_name_len;
  uint name_len;
  lys_node *sub;
  lys_module *nodemod;
  
  max_name_len = 0;
  sub = sibling;
  do {
    if (sub == (lys_node *)0x0) {
      return (uint16_t)max_name_len;
    }
    if (((((opts->module->field_0x40 & 1) == 0) || (sub->module == opts->module)) &&
        ((aug_parent == (lys_node *)0x0 || (aug_parent == sub->parent)))) &&
       ((type_mask & sub->nodetype) != LYS_UNKNOWN)) {
      if ((sub->nodetype == LYS_USES) && ((opts->options & 4U) == 0)) {
        uVar3 = tree_get_max_name_len(sub->child,(lys_node *)0x0,type_mask,opts);
        uVar2 = (uint)uVar3;
      }
      else {
        plVar4 = lys_node_module(sub);
        sVar5 = strlen(sub->name);
        name_len = (uint)sVar5;
        plVar6 = lys_main_module(opts->module);
        if (plVar4 != plVar6) {
          if ((opts->options & 1U) == 0) {
            sVar5 = strlen(plVar4->name);
            name_len = name_len + 1 + (int)sVar5;
          }
          else {
            sVar5 = strlen(plVar4->prefix);
            name_len = name_len + 1 + (int)sVar5;
          }
        }
        LVar1 = sub->nodetype;
        if (LVar1 == LYS_ANYDATA) {
switchD_001ff7dc_caseD_1:
          uVar2 = name_len + 1;
        }
        else {
          uVar2 = name_len;
          if (LVar1 < (LYS_CONTAINER|LYS_ANYDATA)) {
            if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
              if ((LVar1 != LYS_UNKNOWN) && (true)) {
                switch(LVar1) {
                case LYS_CONTAINER:
                case LYS_LEAF:
                case LYS_LEAFLIST:
                case LYS_LIST:
                case LYS_ANYXML:
                  goto switchD_001ff7dc_caseD_1;
                case LYS_CHOICE:
                  uVar2 = name_len + 2;
                  if ((sub->flags & 0x40) == 0) {
                    uVar2 = name_len + 3;
                  }
                }
              }
            }
            else if (LVar1 == LYS_CASE) goto switchD_001ff7dc_caseD_1;
          }
        }
      }
      name_len = uVar2;
      if (max_name_len < name_len) {
        max_name_len = name_len;
      }
    }
    sub = sub->next;
  } while( true );
}



int tree_leaf_is_mandatory(lys_node *node)

{
  lys_node *node_local;
  uint16_t i;
  lys_node *parent;
  lys_node_list *list;
  
  for (parent = lys_parent(node); (parent != (lys_node *)0x0 && (parent->nodetype == LYS_USES));
      parent = lys_parent(parent)) {
  }
  if ((parent != (lys_node *)0x0) && (parent->nodetype == LYS_LIST)) {
    for (i = 0; i < parent->padding[2]; i = i + 1) {
      if (node == *(lys_node **)(*(long *)&parent[1].flags + (ulong)i * 8)) {
        return 1;
      }
    }
  }
  return 0;
}



int tree_print_wrap(lyout *out,int level,int line_printed,uint8_t indent,uint16_t len,tp_opts *opts)

{
  int iVar1;
  int iVar2;
  tp_opts *opts_local;
  uint16_t len_local;
  uint8_t indent_local;
  int line_printed_local;
  int level_local;
  lyout *out_local;
  
  if ((opts->line_length == 0) ||
     ((int)((uint)indent + line_printed + (uint)len) <= (int)(uint)opts->line_length)) {
    iVar1 = ly_print(out,"%*s",(ulong)indent,&DAT_0022ea4a);
    line_printed_local = line_printed + iVar1;
  }
  else {
    ly_print(out,"\n");
    iVar1 = tree_print_indent(out,level,opts);
    iVar2 = ly_print(out,"%*s",5,&DAT_0022ea4a);
    line_printed_local = iVar1 + iVar2;
  }
  return line_printed_local;
}



int tree_print_prefix(lyout *out,lys_node *node,tp_opts *opts)

{
  int iVar1;
  lys_module *plVar2;
  lys_module *plVar3;
  tp_opts *opts_local;
  lys_node *node_local;
  lyout *out_local;
  uint16_t ret;
  lys_module *nodemod;
  
  ret = 0;
  plVar2 = lys_node_module(node);
  plVar3 = lys_main_module(opts->module);
  if (plVar2 != plVar3) {
    if ((opts->options & 1U) == 0) {
      iVar1 = ly_print(out,"%s:",plVar2->name);
      ret = (uint16_t)iVar1;
    }
    else {
      iVar1 = ly_print(out,"%s:",plVar2->prefix);
      ret = (uint16_t)iVar1;
    }
  }
  return (int)ret;
}



int tree_print_type(lyout *out,lys_type *type,int options,char **out_str)

{
  lys_module *module;
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  char *pcVar4;
  size_t sVar5;
  char **out_str_local;
  int options_local;
  lys_type *type_local;
  lyout *out_local;
  int printed;
  lys_module *type_mod;
  char *tmp;
  char *str;
  
  module = type->parent->module;
  if ((type->base == LY_TYPE_LEAFREF) && (type->der->module == (lys_module *)0x0)) {
    if ((options & 8U) == 0) {
      if ((options & 1U) == 0) {
        if (out_str == (char **)0x0) {
          printed = ly_print(out,"-> %s",(type->info).bits.bit);
        }
        else {
          sVar3 = strlen((type->info).lref.path);
          printed = (int)sVar3 + 3;
          pcVar2 = (char *)malloc((long)((int)sVar3 + 4));
          if (pcVar2 == (char *)0x0) {
            ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","tree_print_type"
                  );
            printed = 0;
          }
          else {
            sprintf(pcVar2,"-> %s",(type->info).bits.bit);
            pcVar2 = lydict_insert_zc(module->ctx,pcVar2);
            *out_str = pcVar2;
          }
        }
      }
      else {
        pcVar2 = transform_json2schema(module,(type->info).lref.path);
        if (out_str == (char **)0x0) {
          printed = ly_print(out,"-> %s",pcVar2);
        }
        else {
          sVar3 = strlen(pcVar2);
          printed = (int)sVar3 + 3;
          pcVar4 = (char *)malloc((long)((int)sVar3 + 4));
          if (pcVar4 == (char *)0x0) {
            ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","tree_print_type"
                  );
            return 0;
          }
          sprintf(pcVar4,"-> %s",pcVar2);
          pcVar4 = lydict_insert_zc(module->ctx,pcVar4);
          *out_str = pcVar4;
        }
        lydict_remove(module->ctx,pcVar2);
      }
    }
    else if (out_str == (char **)0x0) {
      printed = ly_print(out,"leafref");
    }
    else {
      printed = 7;
      pcVar2 = lydict_insert(module->ctx,"leafref",7);
      *out_str = pcVar2;
    }
  }
  else {
    iVar1 = lys_type_is_local(type);
    if (iVar1 == 0) {
      if ((options & 1U) == 0) {
        if (out_str == (char **)0x0) {
          printed = ly_print(out,"%s:%s",type->der->module->name,type->der->name);
        }
        else {
          sVar3 = strlen(type->der->module->name);
          sVar5 = strlen(type->der->name);
          iVar1 = (int)sVar5 + (int)sVar3;
          printed = iVar1 + 1;
          pcVar2 = (char *)malloc((long)(iVar1 + 2));
          if (pcVar2 == (char *)0x0) {
            ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","tree_print_type"
                  );
            printed = 0;
          }
          else {
            sprintf(pcVar2,"%s:%s",type->der->module->name,type->der->name);
            pcVar2 = lydict_insert_zc(module->ctx,pcVar2);
            *out_str = pcVar2;
          }
        }
      }
      else {
        pcVar2 = transform_module_name2import_prefix(module,type->der->module->name);
        if (out_str == (char **)0x0) {
          printed = ly_print(out,"%s:%s",pcVar2,type->der->name);
        }
        else {
          sVar3 = strlen(pcVar2);
          sVar5 = strlen(type->der->name);
          iVar1 = (int)sVar5 + (int)sVar3;
          printed = iVar1 + 1;
          pcVar4 = (char *)malloc((long)(iVar1 + 2));
          if (pcVar4 == (char *)0x0) {
            ly_log(module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","tree_print_type"
                  );
            printed = 0;
          }
          else {
            sprintf(pcVar4,"%s:%s",pcVar2,type->der->name);
            pcVar2 = lydict_insert_zc(module->ctx,pcVar4);
            *out_str = pcVar2;
          }
        }
      }
    }
    else if (out_str == (char **)0x0) {
      printed = ly_print(out,"%s",type->der->name);
    }
    else {
      sVar3 = strlen(type->der->name);
      printed = (int)sVar3;
      pcVar2 = lydict_insert(module->ctx,type->der->name,(long)printed);
      *out_str = pcVar2;
    }
  }
  return printed;
}



int tree_print_config(lyout *out,lys_node *node,int spec_config)

{
  LYS_NODE LVar1;
  int iVar2;
  undefined *puVar3;
  int spec_config_local;
  lys_node *node_local;
  lyout *out_local;
  int ret;
  
  LVar1 = node->nodetype;
  if (LVar1 == LYS_ACTION) {
LAB_00200039:
    ret = ly_print(out,"-x ");
  }
  else {
    if (LVar1 < (LYS_CONTAINER|LYS_ACTION)) {
      if (LVar1 == LYS_USES) {
        iVar2 = ly_print(out,"-u ");
        return iVar2;
      }
      if (LVar1 < (LYS_CONTAINER|LYS_USES)) {
        if (LVar1 == LYS_RPC) goto LAB_00200039;
        if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
          if (LVar1 == LYS_CASE) {
            iVar2 = ly_print(out,":(");
            return iVar2;
          }
          if (LVar1 == LYS_NOTIF) {
            iVar2 = ly_print(out,"-n ");
            return iVar2;
          }
        }
      }
    }
    if (spec_config == 1) {
      ret = ly_print(out,"-w ");
    }
    else if (spec_config == 2) {
      ret = ly_print(out,"ro ");
    }
    else {
      if ((node->flags & 1) == 0) {
        if ((node->flags & 2) == 0) {
          puVar3 = &DAT_0022eaa2;
        }
        else {
          puVar3 = &DAT_0022ea9f;
        }
      }
      else {
        puVar3 = &DAT_0022eaa5;
      }
      ret = ly_print(out,"%s ",puVar3);
    }
    if (node->nodetype == LYS_CHOICE) {
      iVar2 = ly_print(out,"(");
      ret = ret + iVar2;
    }
  }
  return ret;
}



int tree_print_features(lyout *out,lys_iffeature *iff1,uint8_t iff1_size,lys_iffeature *iff2,
                       uint8_t iff2_size,tp_opts *opts,char **out_str)

{
  int iVar1;
  char *pcVar2;
  tp_opts *opts_local;
  lys_iffeature *iff2_local;
  uint8_t iff2_size_local;
  uint8_t iff1_size_local;
  lys_iffeature *iff1_local;
  lyout *out_local;
  int i;
  int printed;
  lyout *o;
  
  if ((iff1_size == '\0') && (iff2_size == '\0')) {
    iVar1 = 0;
  }
  else {
    o = out;
    if (out_str != (char **)0x0) {
      o = (lyout *)malloc(0x40);
      if (o == (lyout *)0x0) {
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
               "tree_print_features");
        return 0;
      }
      o->type = LYOUT_MEMORY;
      (o->method).f = (FILE *)0x0;
      (o->method).mem.len = 0;
      (o->method).mem.size = 0;
    }
    printed = ly_print(o,"{");
    for (i = 0; i < (int)(uint)iff1_size; i = i + 1) {
      if (0 < i) {
        iVar1 = ly_print(o,",");
        printed = printed + iVar1;
      }
      if ((opts->options & 1U) == 0) {
        iVar1 = 1;
      }
      else {
        iVar1 = 2;
      }
      iVar1 = ly_print_iffeature(o,opts->module,iff1 + i,iVar1);
      printed = printed + iVar1;
    }
    for (i = 0; i < (int)(uint)iff2_size; i = i + 1) {
      if (0 < i) {
        iVar1 = ly_print(o,",");
        printed = printed + iVar1;
      }
      if ((opts->options & 1U) == 0) {
        iVar1 = 1;
      }
      else {
        iVar1 = 2;
      }
      iVar1 = ly_print_iffeature(o,opts->module,iff2 + i,iVar1);
      printed = printed + iVar1;
    }
    iVar1 = ly_print(o,"}?");
    iVar1 = printed + iVar1;
    if (out_str != (char **)0x0) {
      pcVar2 = lydict_insert_zc(opts->module->ctx,(o->method).mem.buf);
      *out_str = pcVar2;
      free(o);
    }
  }
  return iVar1;
}



int tree_print_keys(lyout *out,lys_node_leaf **keys,uint8_t keys_size,tp_opts *opts,char **out_str)

{
  int iVar1;
  undefined *puVar2;
  char *pcVar3;
  char **out_str_local;
  tp_opts *opts_local;
  uint8_t keys_size_local;
  lys_node_leaf **keys_local;
  lyout *out_local;
  int i;
  int printed;
  lyout *o;
  
  if (keys_size == '\0') {
    printed = 0;
  }
  else {
    o = out;
    if (out_str != (char **)0x0) {
      o = (lyout *)malloc(0x40);
      if (o == (lyout *)0x0) {
        ly_log((ly_ctx *)0x0,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","tree_print_keys");
        return 0;
      }
      o->type = LYOUT_MEMORY;
      (o->method).f = (FILE *)0x0;
      (o->method).mem.len = 0;
      (o->method).mem.size = 0;
    }
    printed = ly_print(o,"[");
    for (i = 0; i < (int)(uint)keys_size; i = i + 1) {
      if (i + 1 < (int)(uint)keys_size) {
        puVar2 = &DAT_0022e8d0;
      }
      else {
        puVar2 = &DAT_0022eab7;
      }
      iVar1 = ly_print(o,"%s%s",keys[i]->name,puVar2);
      printed = printed + iVar1;
    }
    if (out_str != (char **)0x0) {
      pcVar3 = lydict_insert_zc(opts->module->ctx,(o->method).mem.buf);
      *out_str = pcVar3;
      free(o);
    }
  }
  return printed;
}



void tree_print_snode(lyout *out,int level,uint16_t max_name_len,lys_node *node,int mask,
                     lys_node *aug_parent,int subtree,tp_opts *opts)

{
  long lVar1;
  char cVar2;
  char cVar3;
  LYS_NODE LVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  lys_node *plVar10;
  undefined *puVar11;
  size_t sVar12;
  long in_FS_OFFSET;
  tp_opts *opts_local;
  lys_node *aug_parent_local;
  int mask_local;
  lys_node *node_local;
  uint16_t max_name_len_local;
  int level_local;
  lyout *out_local;
  uint8_t text_len;
  uint8_t text_indent;
  uint16_t max_child_len;
  int line_len;
  int node_len;
  int child_mask;
  char *text_str;
  lys_node *sub;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((node->parent == (lys_node *)0x0) || (node->parent->nodetype != LYS_AUGMENT)) {
    iVar5 = 0;
  }
  else {
    iVar5 = 1;
  }
  plVar10 = lys_is_disabled(node,iVar5);
  if (((plVar10 != (lys_node *)0x0) || ((mask & node->nodetype) == LYS_UNKNOWN)) ||
     ((((mask & node->nodetype & 0x640) != LYS_UNKNOWN && ((node->flags & 0x40) != 0)) &&
      ((node->nodetype != LYS_CASE ||
       (plVar10 = lys_is_disabled(node->child,0), plVar10 != (lys_node *)0x0))))))
  goto LAB_0020122a;
  LVar4 = mask & node->nodetype;
  level_local = level;
  if (LVar4 == LYS_USES) {
    if ((opts->options & 4U) != 0) goto LAB_00200697;
    goto LAB_00200f3c;
  }
  if (LVar4 < (LYS_CONTAINER|LYS_USES)) {
    if (LVar4 == LYS_ANYXML) {
      plVar10 = lys_parent(node);
      if (((plVar10 == (lys_node *)0x0) && (iVar5 = strcmp(node->name,"config"), iVar5 == 0)) &&
         (iVar5 = strcmp(node->module->name,"ietf-netconf"), iVar5 == 0)) goto LAB_0020122a;
    }
    else if (LVar4 == LYS_GROUPING) goto LAB_00200f3c;
  }
LAB_00200697:
  iVar5 = tree_print_indent(out,level,opts);
  if ((node->flags & 0x10) == 0) {
    if ((node->flags & 0x20) == 0) {
      puVar11 = &DAT_0022eac0;
    }
    else {
      puVar11 = &DAT_0022eabe;
    }
  }
  else {
    puVar11 = &DAT_0022eac2;
  }
  iVar6 = ly_print(out,"%s--",puVar11);
  iVar7 = tree_print_config(out,node,opts->spec_config);
  iVar8 = tree_print_prefix(out,node,opts);
  iVar9 = ly_print(out,node->name);
  node_len = iVar8 + iVar9;
  LVar4 = mask & node->nodetype;
  if (LVar4 == LYS_ANYDATA) {
switchD_002007b7_caseD_20:
    if ((node->flags & 0x40) == 0) {
      iVar8 = ly_print(out,"?");
      node_len = node_len + iVar8;
    }
  }
  else if (LVar4 < (LYS_CONTAINER|LYS_ANYDATA)) {
    if (LVar4 < (LYS_CONTAINER|LYS_ANYXML)) {
      if ((LVar4 != LYS_UNKNOWN) && (true)) {
        switch(LVar4) {
        case LYS_CONTAINER:
          lVar1._0_2_ = node[1].flags;
          lVar1._2_1_ = node[1].ext_size;
          lVar1._3_1_ = node[1].iffeature_size;
          lVar1._4_1_ = node[1].padding[0];
          lVar1._5_1_ = node[1].padding[1];
          lVar1._6_1_ = node[1].padding[2];
          lVar1._7_1_ = node[1].padding[3];
          if (lVar1 != 0) {
            iVar8 = ly_print(out,"!");
            node_len = node_len + iVar8;
          }
          break;
        case LYS_CHOICE:
          iVar8 = ly_print(out,")");
          node_len = node_len + iVar8;
          if ((node->flags & 0x40) == 0) {
            iVar8 = ly_print(out,"?");
            node_len = node_len + iVar8;
          }
          break;
        case LYS_LEAF:
          if (((node->flags & 0x40) == 0) && (iVar8 = tree_leaf_is_mandatory(node), iVar8 == 0)) {
            iVar8 = ly_print(out,"?");
            node_len = node_len + iVar8;
          }
          break;
        case LYS_LEAFLIST:
        case LYS_LIST:
          iVar8 = ly_print(out,"*");
          node_len = node_len + iVar8;
          break;
        case LYS_ANYXML:
          goto switchD_002007b7_caseD_20;
        }
      }
    }
    else if (LVar4 == LYS_CASE) {
      iVar8 = ly_print(out,")");
      node_len = node_len + iVar8;
    }
  }
  line_len = iVar5 + iVar6 + iVar7 + node_len;
  level_local = level + 1;
  if (subtree == 0) {
    tree_next_indent(level_local,node,aug_parent,opts);
  }
  LVar4 = mask & node->nodetype;
  cVar2 = (char)max_name_len;
  cVar3 = (char)node_len;
  if (LVar4 == LYS_ANYDATA) {
    if (max_name_len == 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("max_name_len",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_tree.c"
                    ,0x264,"tree_print_snode");
    }
    iVar5 = tree_print_wrap(out,level_local,line_len,(cVar2 - cVar3) + '\x03',7,opts);
    iVar6 = ly_print(out,"anydata");
    line_len = iVar5 + iVar6;
  }
  else if (LVar4 < (LYS_CONTAINER|LYS_ANYDATA)) {
    if (LVar4 == LYS_ANYXML) {
      if (max_name_len == 0) {
                    // WARNING: Subroutine does not return
        __assert_fail("max_name_len",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_tree.c"
                      ,0x26a,"tree_print_snode");
      }
      iVar5 = tree_print_wrap(out,level_local,line_len,(cVar2 - cVar3) + '\x03',6,opts);
      iVar6 = ly_print(out,"anyxml");
      line_len = iVar5 + iVar6;
    }
    else if (LVar4 < (LYS_CONTAINER|LYS_ANYXML)) {
      if (LVar4 == LYS_LIST) {
        iVar5 = tree_print_keys(out,*(lys_node_leaf ***)&node[1].flags,node->padding[2],opts,
                                &text_str);
        if ((byte)iVar5 != 0) {
          iVar5 = tree_print_wrap(out,level_local,line_len,'\x01',(ushort)(byte)iVar5,opts);
          iVar6 = ly_print(out,text_str);
          line_len = iVar5 + iVar6;
          lydict_remove(opts->module->ctx,text_str);
        }
      }
      else if ((LVar4 < (LYS_CONTAINER|LYS_LIST)) &&
              ((LVar4 == LYS_LEAF || (LVar4 == LYS_LEAFLIST)))) {
        if (max_name_len == 0) {
                    // WARNING: Subroutine does not return
          __assert_fail("max_name_len",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_tree.c"
                        ,0x25c,"tree_print_snode");
        }
        iVar5 = tree_print_type(out,(lys_type *)&node[1].ref,opts->options,&text_str);
        iVar5 = tree_print_wrap(out,level_local,line_len,(cVar2 - cVar3) + '\x03',
                                (ushort)(byte)iVar5,opts);
        iVar6 = ly_print(out,text_str);
        line_len = iVar5 + iVar6;
        lydict_remove(opts->module->ctx,text_str);
      }
    }
  }
  if ((opts->options & 1U) == 0) {
    LVar4 = mask & node->nodetype;
    if (LVar4 == LYS_CHOICE) {
      sub = (lys_node *)node[1].name;
      if (sub != (lys_node *)0x0) {
        sVar12 = strlen(sub->name);
        iVar5 = tree_print_wrap(out,level_local,line_len,'\x01',(short)sVar12 + 2,opts);
        iVar6 = ly_print(out,"<%s>",sub->name);
        line_len = iVar5 + iVar6;
      }
    }
    else if ((LVar4 == LYS_LEAF) &&
            (text_str = (char *)node[1].prev, (lys_node *)text_str != (lys_node *)0x0)) {
      sVar12 = strlen(text_str);
      iVar5 = tree_print_wrap(out,level_local,line_len,'\x01',(short)sVar12 + 2,opts);
      iVar6 = ly_print(out,"<%s>",text_str);
      line_len = iVar5 + iVar6;
    }
  }
  LVar4 = mask & node->nodetype;
  if (LVar4 == LYS_ANYDATA) {
switchD_00200d98_caseD_1:
    if ((node->parent == (lys_node *)0x0) || (node->parent->nodetype != LYS_AUGMENT)) {
      iVar5 = tree_print_features(out,node->iffeature,node->iffeature_size,(lys_iffeature *)0x0,'\0'
                                  ,opts,&text_str);
      text_len = (uint8_t)iVar5;
    }
    else {
      iVar5 = tree_print_features(out,node->iffeature,node->iffeature_size,node->parent->iffeature,
                                  node->parent->iffeature_size,opts,&text_str);
      text_len = (uint8_t)iVar5;
    }
    if (text_len != '\0') {
      tree_print_wrap(out,level_local,line_len,'\x01',(ushort)text_len,opts);
      ly_print(out,text_str);
      lydict_remove(opts->module->ctx,text_str);
    }
  }
  else if (LVar4 < (LYS_CONTAINER|LYS_ANYDATA)) {
    if (LVar4 == LYS_ACTION) goto switchD_00200d98_caseD_1;
    if (LVar4 < (LYS_CONTAINER|LYS_ACTION)) {
      if (LVar4 == LYS_USES) goto switchD_00200d98_caseD_1;
      if (LVar4 < (LYS_CONTAINER|LYS_USES)) {
        if (LVar4 == LYS_RPC) goto switchD_00200d98_caseD_1;
        if (LVar4 < (LYS_CONTAINER|LYS_RPC)) {
          if (LVar4 == LYS_NOTIF) goto switchD_00200d98_caseD_1;
          if (LVar4 < (LYS_CONTAINER|LYS_NOTIF)) {
            if (LVar4 < (LYS_CONTAINER|LYS_ANYXML)) {
              if ((LVar4 != LYS_UNKNOWN) && (true)) {
                switch(LVar4) {
                case LYS_CONTAINER:
                case LYS_CHOICE:
                case LYS_LEAF:
                case LYS_LEAFLIST:
                case LYS_LIST:
                case LYS_ANYXML:
                  goto switchD_00200d98_caseD_1;
                }
              }
            }
            else if (LVar4 == LYS_CASE) goto switchD_00200d98_caseD_1;
          }
        }
      }
    }
  }
  ly_print(out,"\n");
  if ((subtree == 1) || ((mask & node->nodetype) == LYS_USES)) goto LAB_0020122a;
  LVar4 = mask & node->nodetype;
  if (LVar4 == LYS_OUTPUT) {
LAB_00200f2b:
    opts->spec_config = 2;
  }
  else if (LVar4 < (LYS_CONTAINER|LYS_OUTPUT)) {
    if (LVar4 == LYS_NOTIF) goto LAB_00200f2b;
    if (LVar4 == LYS_INPUT) {
      opts->spec_config = 1;
    }
  }
LAB_00200f3c:
  LVar4 = mask & node->nodetype;
  if (LVar4 == LYS_ANYDATA) {
switchD_0020102a_caseD_4:
    child_mask = 0;
    max_child_len = 0;
  }
  else {
    if (LVar4 < (LYS_CONTAINER|LYS_ANYDATA)) {
      if (LVar4 == LYS_ACTION) {
LAB_00201049:
        child_mask = 0x600;
        max_child_len = 0;
        goto LAB_0020115a;
      }
      if (LVar4 < (LYS_CONTAINER|LYS_ACTION)) {
        if (LVar4 == LYS_USES) {
          child_mask = 0xd0bf;
          max_child_len = max_name_len;
          goto LAB_0020115a;
        }
        if (LVar4 < (LYS_CONTAINER|LYS_USES)) {
          if (LVar4 == LYS_GROUPING) {
switchD_0020102a_caseD_1:
            child_mask = 0xd0bf;
            max_child_len = tree_get_max_name_len(node->child,(lys_node *)0x0,0xd0bf,opts);
            goto LAB_0020115a;
          }
          if (LVar4 < (LYS_CONTAINER|LYS_GROUPING)) {
            if (LVar4 == LYS_OUTPUT) {
LAB_002010b3:
              child_mask = 0x903f;
              max_child_len = tree_get_max_name_len(node->child,(lys_node *)0x0,0x903f,opts);
              goto LAB_0020115a;
            }
            if (LVar4 < (LYS_CONTAINER|LYS_OUTPUT)) {
              if (LVar4 == LYS_INPUT) goto LAB_002010b3;
              if (LVar4 < (LYS_CONTAINER|LYS_INPUT)) {
                if (LVar4 == LYS_RPC) goto LAB_00201049;
                if (LVar4 < (LYS_CONTAINER|LYS_RPC)) {
                  if (LVar4 == LYS_NOTIF) {
LAB_00201087:
                    child_mask = 0x903f;
                    max_child_len = tree_get_max_name_len(node->child,(lys_node *)0x0,0x903f,opts);
                    goto LAB_0020115a;
                  }
                  if (LVar4 < (LYS_CONTAINER|LYS_NOTIF)) {
                    if (LVar4 < (LYS_CONTAINER|LYS_ANYXML)) {
                      if ((LVar4 != LYS_UNKNOWN) && (true)) {
                        switch(LVar4) {
                        case LYS_CONTAINER:
                        case LYS_LIST:
                          goto switchD_0020102a_caseD_1;
                        case LYS_CHOICE:
                          child_mask = 0x807d;
                          max_child_len =
                               tree_get_max_name_len(node->child,(lys_node *)0x0,0x807d,opts);
                          goto LAB_0020115a;
                        case LYS_LEAF:
                        case LYS_LEAFLIST:
                        case LYS_ANYXML:
                          goto switchD_0020102a_caseD_4;
                        }
                      }
                    }
                    else if (LVar4 == LYS_CASE) goto LAB_00201087;
                  }
                }
              }
            }
          }
        }
      }
    }
    child_mask = 0;
    max_child_len = 0;
    ly_log(node->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_tree.c"
           ,0x2f2);
  }
LAB_0020115a:
  if (child_mask != 0) {
    for (sub = node->child; sub != (lys_node *)0x0; sub = sub->next) {
      if ((((opts->module->field_0x40 & 1) == 0) || (node == sub->parent)) ||
         (sub->module == opts->module)) {
        tree_print_snode(out,level_local,max_child_len,sub,child_mask,(lys_node *)0x0,0,opts);
      }
    }
  }
  LVar4 = mask & node->nodetype;
  if ((LVar4 == LYS_OUTPUT) ||
     ((LVar4 < (LYS_CONTAINER|LYS_OUTPUT) && ((LVar4 == LYS_NOTIF || (LVar4 == LYS_INPUT)))))) {
    opts->spec_config = 0;
  }
LAB_0020122a:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void tree_print_subtree(lyout *out,lys_node *node,tp_opts *opts)

{
  lys_node *plVar1;
  tp_opts *opts_local;
  lys_node *node_local;
  lyout *out_local;
  uint depth;
  uint i;
  uint j;
  int level;
  lys_node *parent;
  
  level = 0;
  depth = 0;
  parent = node;
  while( true ) {
    plVar1 = lys_parent(parent);
    if (plVar1 == (lys_node *)0x0) break;
    plVar1 = lys_parent(parent);
    if (plVar1->nodetype != LYS_USES) {
      depth = depth + 1;
    }
    parent = lys_parent(parent);
  }
  if (parent->nodetype == LYS_RPC) {
    ly_print(out,"\n%*srpcs:\n",2,&DAT_0022ea4a);
    opts->base_indent = '\x04';
  }
  else if (parent->nodetype == LYS_NOTIF) {
    ly_print(out,"\n%*snotifications:\n",2,&DAT_0022ea4a);
    opts->base_indent = '\x04';
  }
  if (depth != 0) {
    i = depth;
    do {
      parent = node;
      for (j = 0; j < i; j = j + 1) {
        do {
          parent = lys_parent(parent);
        } while (parent->nodetype == LYS_USES);
      }
      tree_print_snode(out,level,0,parent,0x4791,(lys_node *)0x0,1,opts);
      level = level + 1;
      i = i - 1;
    } while (i != 0);
  }
  tree_print_snode(out,level,0,node,0xffff,(lys_node *)0x0,2,opts);
  return;
}



int tree_print_aug_target(lyout *out,int line_printed,uint8_t indent,char *path,tp_opts *opts)

{
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  undefined *puVar4;
  bool bVar5;
  tp_opts *opts_local;
  char *path_local;
  uint8_t indent_local;
  int line_printed_local;
  lyout *out_local;
  int printed;
  int is_last;
  int len;
  char *cur;
  char *next;
  
  printed = line_printed;
  cur = path;
  do {
    pcVar2 = strchr(cur + 1,0x2f);
    bVar5 = pcVar2 != (char *)0x0;
    if (bVar5) {
      len = (int)pcVar2 - (int)cur;
    }
    else {
      sVar3 = strlen(cur);
      len = (int)sVar3 + 1;
    }
    if (((opts->line_length != 0) && (cur != path)) &&
       ((int)(uint)opts->line_length < printed + len)) {
      iVar1 = ly_print(out,"\n%*s",(ulong)((uint)indent + line_printed),&DAT_0022ea4a);
      printed = iVar1 + -1;
    }
    if (bVar5) {
      puVar4 = &DAT_0022ea4a;
    }
    else {
      puVar4 = &DAT_0022eca4;
    }
    iVar1 = ly_print(out,"%.*s%s",(ulong)(uint)len,cur,puVar4);
    printed = printed + iVar1;
    cur = pcVar2;
  } while (bVar5);
  return printed;
}



int tree_print_model(lyout *out,lys_module *module,char *target_schema_path,int ll,int options)

{
  LYS_NODE LVar1;
  long lVar2;
  bool bVar3;
  uint16_t uVar4;
  int iVar5;
  ly_set *set_00;
  lys_module *plVar6;
  lys_node *plVar7;
  char *path;
  long in_FS_OFFSET;
  int options_local;
  int ll_local;
  char *target_schema_path_local;
  lys_module *module_local;
  lyout *out_local;
  uint16_t max_child_len;
  int have_rpcs;
  int have_notifs;
  int have_grps;
  int have_augs;
  int i;
  int mask;
  int printed;
  lys_node *node;
  lys_node *data;
  ly_set *set;
  char *str;
  lys_node *aug;
  tp_opts opts;
  
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  node = (lys_node *)0x0;
  have_rpcs = 0;
  have_notifs = 0;
  have_grps = 0;
  bVar3 = false;
  memset(&opts,0,0x28);
  opts.line_length = (uint16_t)ll;
  opts.module = module;
  opts.options = options;
  if (target_schema_path != (char *)0x0) {
    set_00 = lys_find_path(module,(lys_node *)0x0,target_schema_path);
    if (set_00 == (ly_set *)0x0) {
      iVar5 = 1;
      goto LAB_00201e0f;
    }
    if (set_00->number != 1) {
      ly_vlog(module->ctx,LYE_PATH_INNODE,LY_VLOG_NONE,(void *)0x0);
      if (set_00->number == 0) {
        ly_vlog(module->ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                "Schema path \"%s\" did not match any nodes.",target_schema_path);
      }
      else {
        ly_vlog(module->ctx,LYE_SPEC,LY_VLOG_PREV,(void *)0x0,
                "Schema path \"%s\" matched more nodes.",target_schema_path);
      }
      ly_set_free(set_00);
      iVar5 = 1;
      goto LAB_00201e0f;
    }
    node = *(set_00->set).s;
    ly_set_free(set_00);
  }
  if ((module->field_0x40 & 1) == 0) {
    ly_print(out,"module: %s\n",module->name);
    data = module->data;
  }
  else {
    ly_print(out,"submodule: %s",module->name);
    data = *(lys_node **)&module->data[1].nodetype;
    if ((options & 1U) == 0) {
      ly_print(out," (belongs-to %s)\n",module->data->dsc);
    }
    else {
      ly_print(out,"\n");
    }
  }
  if (target_schema_path == (char *)0x0) {
    opts.base_indent = '\x02';
    uVar4 = tree_get_max_name_len(data,(lys_node *)0x0,0x903f,&opts);
    for (node = data; node != (lys_node *)0x0; node = node->next) {
      if ((((opts.module)->field_0x40 & 1) == 0) || (node->module == opts.module)) {
        LVar1 = node->nodetype;
        if (LVar1 == LYS_GROUPING) {
          if (((options & 2U) != 0) && (plVar7 = lys_is_disabled(node,0), plVar7 == (lys_node *)0x0)
             ) {
            have_grps = have_grps + 1;
          }
        }
        else if (LVar1 < (LYS_CONTAINER|LYS_GROUPING)) {
          if (LVar1 == LYS_NOTIF) {
            plVar7 = lys_is_disabled(node,0);
            if (plVar7 == (lys_node *)0x0) {
              have_notifs = have_notifs + 1;
            }
          }
          else {
            if (LVar1 != LYS_RPC) goto LAB_002018b0;
            plVar7 = lys_is_disabled(node,0);
            if (plVar7 == (lys_node *)0x0) {
              have_rpcs = have_rpcs + 1;
            }
          }
        }
        else {
LAB_002018b0:
          tree_print_snode(out,0,uVar4,node,0x903f,(lys_node *)0x0,0,&opts);
        }
      }
    }
    opts.base_indent = '\x04';
    for (i = 0; i < (int)(uint)module->augment_size; i = i + 1) {
      if (((((module->field_0x40 & 1) == 0) || (module != (module->augment[i].target)->module)) &&
          (((module->field_0x40 & 1) != 0 ||
           (plVar6 = lys_node_module(module->augment[i].target), module != plVar6)))) &&
         (plVar7 = lys_is_disabled((lys_node *)(module->augment + i),0), plVar7 == (lys_node *)0x0))
      {
        if (!bVar3) {
          ly_print(out,"\n");
          bVar3 = true;
        }
        iVar5 = ly_print(out,"%*saugment ",2,&DAT_0022ea4a);
        if ((options & 1U) == 0) {
          tree_print_aug_target(out,iVar5,'\x02',module->augment[i].target_name,&opts);
        }
        else {
          path = transform_json2schema(module,module->augment[i].target_name);
          tree_print_aug_target(out,iVar5,'\x02',path,&opts);
          lydict_remove(module->ctx,path);
        }
        ly_print(out,"\n");
        plVar7 = (lys_node *)(module->augment + i);
        uVar4 = tree_get_max_name_len(plVar7->child,plVar7,0xd0ff,&opts);
        for (node = plVar7->child; node != (lys_node *)0x0; node = node->next) {
          if (plVar7 == node->parent) {
            tree_print_snode(out,0,uVar4,node,0xd0ff,plVar7,0,&opts);
          }
        }
      }
    }
    if (have_rpcs != 0) {
      ly_print(out,"\n%*srpcs:\n",2,&DAT_0022ea4a);
      for (node = data; node != (lys_node *)0x0; node = node->next) {
        tree_print_snode(out,0,0,node,0x100,(lys_node *)0x0,0,&opts);
      }
    }
    if (have_notifs != 0) {
      ly_print(out,"\n%*snotifications:\n",2,&DAT_0022ea4a);
      for (node = data; node != (lys_node *)0x0; node = node->next) {
        tree_print_snode(out,0,0,node,0x80,(lys_node *)0x0,0,&opts);
      }
    }
    if (((options & 2U) != 0) && (have_grps != 0)) {
      ly_print(out,"\n");
      for (node = data; node != (lys_node *)0x0; node = node->next) {
        if (node->nodetype == LYS_GROUPING) {
          ly_print(out,"%*sgrouping %s:\n",2,&DAT_0022ea4a,node->name);
          tree_print_snode(out,0,0,node,0x800,(lys_node *)0x0,0,&opts);
        }
      }
    }
    ly_print_flush(out);
    iVar5 = 0;
  }
  else {
    opts.base_indent = '\x02';
    tree_print_subtree(out,node,&opts);
    iVar5 = 0;
  }
LAB_00201e0f:
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar5;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void info_print_text(lyout *out,char *text,char *label)

{
  bool bVar1;
  char *pcVar2;
  char *label_local;
  char *text_local;
  lyout *out_local;
  int first;
  char *ptr1;
  char *ptr2;
  
  bVar1 = true;
  ly_print(out,"%-*s",0xb,label);
  ptr1 = text;
  if (text != (char *)0x0) {
    while (pcVar2 = strchr(ptr1,10), pcVar2 != (char *)0x0) {
      pcVar2 = pcVar2 + 1;
      if (bVar1) {
        ly_print(out,"%.*s",(ulong)(uint)((int)pcVar2 - (int)ptr1),ptr1);
        bVar1 = false;
        ptr1 = pcVar2;
      }
      else {
        ly_print(out,"%*s%.*s",0xb,&DAT_0022edd9,(ulong)(uint)((int)pcVar2 - (int)ptr1),ptr1);
        ptr1 = pcVar2;
      }
    }
    if (bVar1) {
      ly_print(out,"%s\n",ptr1);
      bVar1 = false;
    }
    else {
      ly_print(out,"%*s%s\n",0xb,&DAT_0022edd9,ptr1);
    }
  }
  if (bVar1) {
    ly_print(out,"\n");
  }
  return;
}



void info_print_snode(lyout *out,lys_node *parent,lys_node *node,char *label)

{
  size_t sVar1;
  char *pcVar2;
  lys_node *plVar3;
  char *label_local;
  lys_node *node_local;
  lys_node *parent_local;
  lyout *out_local;
  
  sVar1 = strlen(label);
  if (sVar1 < 10) {
    ly_print(out,"%-*s",0xb,label);
    if (node == (lys_node *)0x0) {
      ly_print(out,"\n");
    }
    else {
      if (node->name == (char *)0x0) {
        if (node->nodetype == LYS_INPUT) {
          pcVar2 = "input";
        }
        else {
          pcVar2 = "output";
        }
        ly_print(out,"%s\n",pcVar2);
      }
      else {
        pcVar2 = strnodetype(node->nodetype);
        ly_print(out,"%s \"",pcVar2);
        plVar3 = lys_parent(node);
        if (parent != plVar3) {
          ly_print(out,"%s:",node->module->prefix);
        }
        ly_print(out,"%s\"\n",node->name);
      }
      for (node_local = node->next; node_local != (lys_node *)0x0; node_local = node_local->next) {
        if (node_local->name == (char *)0x0) {
          if (node_local->nodetype == LYS_INPUT) {
            pcVar2 = "input";
          }
          else {
            pcVar2 = "output";
          }
          ly_print(out,"%*s%s\n",0xb,&DAT_0022edd9,pcVar2);
        }
        else {
          pcVar2 = strnodetype(node_local->nodetype);
          ly_print(out,"%*s%s \"",0xb,&DAT_0022edd9,pcVar2);
          plVar3 = lys_parent(node_local);
          if (parent != plVar3) {
            ly_print(out,"%s:",node_local->module->prefix);
          }
          ly_print(out,"%s\"\n",node_local->name);
        }
      }
    }
    return;
  }
                    // WARNING: Subroutine does not return
  __assert_fail("strlen(label) < INDENT_LEN-1",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_info.c"
                ,0x43,"info_print_snode");
}



void info_print_flags(lyout *out,uint16_t flags,uint16_t mask,int is_list)

{
  int is_list_local;
  uint16_t mask_local;
  uint16_t flags_local;
  lyout *out_local;
  
  if ((mask & 3) != 0) {
    ly_print(out,"%-*s",0xb,"Config: ");
    if ((flags & 2) == 0) {
      ly_print(out,"read-write\n");
    }
    else {
      ly_print(out,"read-only\n");
    }
  }
  if ((mask & 0x38) != 0) {
    ly_print(out,"%-*s",0xb,"Status: ");
    if ((flags & 0x10) == 0) {
      if ((flags & 0x20) == 0) {
        ly_print(out,"current\n");
      }
      else {
        ly_print(out,"obsolete\n");
      }
    }
    else {
      ly_print(out,"deprecated\n");
    }
  }
  if ((mask & 0xc0) != 0) {
    ly_print(out,"%-*s",0xb,"Mandatory: ");
    if ((flags & 0x40) == 0) {
      ly_print(out,"no\n");
    }
    else {
      ly_print(out,"yes\n");
    }
  }
  if ((is_list != 0) && ((mask & 0x100) != 0)) {
    ly_print(out,"%-*s",0xb,"Order: ");
    if ((flags & 0x100) == 0) {
      ly_print(out,"system-ordered\n");
    }
    else {
      ly_print(out,"user-ordered\n");
    }
  }
  if ((is_list == 0) && ((mask & 0x100) != 0)) {
    ly_print(out,"%-*s",0xb,"Enabled: ");
    if ((flags & 0x100) == 0) {
      ly_print(out,"no\n");
    }
    else {
      ly_print(out,"yes\n");
    }
  }
  return;
}



void info_print_if_feature
               (lyout *out,lys_module *module,lys_iffeature *iffeature,uint8_t iffeature_size)

{
  uint8_t iffeature_size_local;
  lys_iffeature *iffeature_local;
  lys_module *module_local;
  lyout *out_local;
  int i;
  
  ly_print(out,"%-*s",0xb,"If-feats: ");
  if (iffeature_size == '\0') {
    ly_print(out,"\n");
  }
  else {
    ly_print_iffeature(out,module,iffeature,1);
    ly_print(out,"\n");
    for (i = 1; i < (int)(uint)iffeature_size; i = i + 1) {
      ly_print(out,"%*s",0xb,&DAT_0022edd9);
      ly_print_iffeature(out,module,iffeature + i,1);
      ly_print(out,"\n");
    }
  }
  return;
}



void info_print_when(lyout *out,lys_when *when)

{
  lys_when *when_local;
  lyout *out_local;
  
  ly_print(out,"%-*s",0xb,"When: ");
  if (when == (lys_when *)0x0) {
    ly_print(out,"\n");
  }
  else {
    ly_print(out,"%s\n",when->cond);
  }
  return;
}



void info_print_must(lyout *out,lys_restr *must,uint8_t must_size)

{
  uint8_t must_size_local;
  lys_restr *must_local;
  lyout *out_local;
  int i;
  
  ly_print(out,"%-*s",0xb,"Must: ");
  if (must_size == '\0') {
    ly_print(out,"\n");
  }
  else {
    ly_print(out,"%s\n",must->expr);
    for (i = 1; i < (int)(uint)must_size; i = i + 1) {
      ly_print(out,"%*s%s\n",0xb,&DAT_0022edd9,must[i].expr);
    }
  }
  return;
}



void info_print_typedef(lyout *out,lys_tpdf *tpdf,uint8_t tpdf_size)

{
  uint8_t tpdf_size_local;
  lys_tpdf *tpdf_local;
  lyout *out_local;
  int i;
  
  ly_print(out,"%-*s",0xb,"Typedefs: ");
  if (tpdf_size == '\0') {
    ly_print(out,"\n");
  }
  else {
    ly_print(out,"%s\n",tpdf->name);
    for (i = 1; i < (int)(uint)tpdf_size; i = i + 1) {
      ly_print(out,"%*s%s",0xb,&DAT_0022edd9,tpdf[i].name);
    }
  }
  return;
}



void info_print_typedef_with_include(lyout *out,lys_module *mod)

{
  bool bVar1;
  lys_module *mod_local;
  lyout *out_local;
  int i;
  int j;
  int first;
  
  bVar1 = true;
  ly_print(out,"%-*s",0xb,"Typedefs: ");
  if (mod->tpdf_size != 0) {
    ly_print(out,"%s\n",mod->tpdf->name);
    bVar1 = false;
    for (i = 1; i < (int)(uint)mod->tpdf_size; i = i + 1) {
      ly_print(out,"%*s%s\n",0xb,&DAT_0022edd9,mod->tpdf[i].name);
    }
  }
  for (i = 0; i < (int)(uint)mod->inc_size; i = i + 1) {
    if ((mod->inc[i].submodule)->tpdf_size != 0) {
      if (bVar1) {
        ly_print(out,"%s (%s)\n",(mod->inc[i].submodule)->tpdf->name,(mod->inc[i].submodule)->name);
      }
      for (j = (int)bVar1; bVar1 = false, j < (int)(uint)(mod->inc[i].submodule)->tpdf_size;
          j = j + 1) {
        ly_print(out,"%*s%s (%s)\n",0xb,&DAT_0022edd9,(mod->inc[i].submodule)->tpdf[j].name,
                 (mod->inc[i].submodule)->name);
      }
    }
  }
  if (bVar1) {
    ly_print(out,"\n");
  }
  return;
}


/*
Unable to decompile 'info_print_type_detail_'
Cause: Exception while decompiling 00202a48: process: timeout

*/


void info_print_type_detail(lyout *out,lys_type *type,int *UNUSED_first)

{
  int *UNUSED_first_local;
  lys_type *type_local;
  lyout *out_local;
  
  info_print_type_detail_(out,type,0);
  return;
}



void info_print_list_constr(lyout *out,uint32_t min,uint32_t max)

{
  uint32_t max_local;
  uint32_t min_local;
  lyout *out_local;
  
  ly_print(out,"%-*s%u..",0xb,"Elements: ",(ulong)min);
  if (max == 0) {
    ly_print(out,"unbounded\n");
  }
  else {
    ly_print(out,"%u\n",(ulong)max);
  }
  return;
}



void info_print_unique(lyout *out,lys_unique *unique,uint8_t unique_size)

{
  uint8_t unique_size_local;
  lys_unique *unique_local;
  lyout *out_local;
  int i;
  int j;
  
  ly_print(out,"%-*s",0xb,"Unique: ");
  if (unique_size == '\0') {
    ly_print(out,"\n");
  }
  else {
    ly_print(out,"%s\n",*unique->expr);
    for (i = 0; i < (int)(uint)unique_size; i = i + 1) {
      for (j = (int)(i == 0); j < (int)(uint)unique[i].expr_size; j = j + 1) {
        ly_print(out,"%*s%s\n",0xb,&DAT_0022edd9,unique[i].expr[j]);
      }
    }
  }
  return;
}



void info_print_revision(lyout *out,lys_revision *rev,uint8_t rev_size)

{
  uint8_t rev_size_local;
  lys_revision *rev_local;
  lyout *out_local;
  int i;
  
  ly_print(out,"%-*s",0xb,"Revisions: ");
  if (rev_size == '\0') {
    ly_print(out,"\n");
  }
  else {
    ly_print(out,"%s\n",rev);
    for (i = 1; i < (int)(uint)rev_size; i = i + 1) {
      ly_print(out,"%*s%s\n",0xb,&DAT_0022edd9,rev + i);
    }
  }
  return;
}



void info_print_import_with_include(lyout *out,lys_module *mod)

{
  bool bVar1;
  lys_module *mod_local;
  lyout *out_local;
  int first;
  int i;
  int j;
  
  bVar1 = true;
  ly_print(out,"%-*s",0xb,"Imports: ");
  if (mod->imp_size != '\0') {
    ly_print(out,"%s:%s\n",mod->imp->prefix,mod->imp->module->name);
    bVar1 = false;
    for (i = 1; i < (int)(uint)mod->imp_size; i = i + 1) {
      ly_print(out,"%*s%s:%s\n",0xb,&DAT_0022edd9,mod->imp[i].prefix,(mod->imp[i].module)->name);
    }
  }
  for (j = 0; j < (int)(uint)mod->inc_size; j = j + 1) {
    if ((mod->inc[j].submodule)->imp_size != '\0') {
      if (bVar1) {
        ly_print(out,"%s:%s (%s)\n",(mod->inc[j].submodule)->imp->prefix,
                 (mod->inc[j].submodule)->imp->module->name,(mod->inc[j].submodule)->name);
      }
      for (i = (int)bVar1; bVar1 = false, i < (int)(uint)(mod->inc[j].submodule)->imp_size;
          i = i + 1) {
        ly_print(out,"%*s%s:%s (%s)\n",0xb,&DAT_0022edd9,(mod->inc[j].submodule)->imp[i].prefix,
                 ((mod->inc[j].submodule)->imp[i].module)->name,(mod->inc[j].submodule)->name);
      }
    }
  }
  if (bVar1) {
    ly_print(out,"\n");
  }
  return;
}



void info_print_include(lyout *out,lys_module *mod)

{
  bool bVar1;
  lys_module *mod_local;
  lyout *out_local;
  int first;
  int i;
  
  bVar1 = true;
  ly_print(out,"%-*s",0xb,"Includes: ");
  if (mod->inc_size != '\0') {
    ly_print(out,"%s\n",mod->inc->submodule->name);
    bVar1 = false;
    for (i = 1; i < (int)(uint)mod->inc_size; i = i + 1) {
      ly_print(out,"%*s%s\n",0xb,&DAT_0022edd9,(mod->inc[i].submodule)->name);
    }
  }
  if (bVar1) {
    ly_print(out,"\n");
  }
  return;
}



void info_print_augment(lyout *out,lys_module *mod)

{
  bool bVar1;
  lys_module *mod_local;
  lyout *out_local;
  int first;
  int i;
  
  bVar1 = true;
  ly_print(out,"%-*s",0xb,"Augments: ");
  if (mod->augment_size != '\0') {
    ly_print(out,"\"%s\"\n",mod->augment->target_name);
    bVar1 = false;
    for (i = 1; i < (int)(uint)mod->augment_size; i = i + 1) {
      ly_print(out,"%*s\"%s\"\n",0xb,&DAT_0022edd9,mod->augment[i].target_name);
    }
  }
  if (bVar1) {
    ly_print(out,"\n");
  }
  return;
}



void info_print_deviation(lyout *out,lys_module *mod)

{
  bool bVar1;
  lys_module *mod_local;
  lyout *out_local;
  int first;
  int i;
  
  bVar1 = true;
  ly_print(out,"%-*s",0xb,"Deviation: ");
  if (mod->deviation_size != '\0') {
    ly_print(out,"\"%s\"\n",mod->deviation->target_name);
    bVar1 = false;
    for (i = 1; i < (int)(uint)mod->deviation_size; i = i + 1) {
      ly_print(out,"%*s\"%s\"\n",0xb,&DAT_0022edd9,mod->deviation[i].target_name);
    }
  }
  if (bVar1) {
    ly_print(out,"\n");
  }
  return;
}



void info_print_ident_with_include(lyout *out,lys_module *mod)

{
  bool bVar1;
  lys_module *mod_local;
  lyout *out_local;
  int first;
  int i;
  int j;
  
  bVar1 = true;
  ly_print(out,"%-*s",0xb,"Idents: ");
  if (mod->ident_size != 0) {
    ly_print(out,"%s\n",mod->ident->name);
    bVar1 = false;
    for (i = 1; i < (int)(uint)mod->ident_size; i = i + 1) {
      ly_print(out,"%*s%s\n",0xb,&DAT_0022edd9,mod->ident[i].name);
    }
  }
  for (j = 0; j < (int)(uint)mod->inc_size; j = j + 1) {
    if ((mod->inc[j].submodule)->ident_size != 0) {
      if (bVar1) {
        ly_print(out,"%s (%s)\n",(mod->inc[j].submodule)->ident->name,(mod->inc[j].submodule)->name)
        ;
      }
      for (i = (int)bVar1; bVar1 = false, i < (int)(uint)(mod->inc[j].submodule)->ident_size;
          i = i + 1) {
        ly_print(out,"%*s%s (%s)\n",0xb,&DAT_0022edd9,(mod->inc[j].submodule)->ident[i].name,
                 (mod->inc[j].submodule)->name);
      }
    }
  }
  if (bVar1) {
    ly_print(out,"\n");
  }
  return;
}



void info_print_features_with_include(lyout *out,lys_module *mod)

{
  bool bVar1;
  lys_module *mod_local;
  lyout *out_local;
  int first;
  int i;
  int j;
  
  bVar1 = true;
  ly_print(out,"%-*s",0xb,"Features: ");
  if (mod->features_size != '\0') {
    ly_print(out,"%s\n",mod->features->name);
    bVar1 = false;
    for (i = 1; i < (int)(uint)mod->features_size; i = i + 1) {
      ly_print(out,"%*s%s\n",0xb,&DAT_0022edd9,mod->features[i].name);
    }
  }
  for (j = 0; j < (int)(uint)mod->inc_size; j = j + 1) {
    if ((mod->inc[j].submodule)->features_size != '\0') {
      if (bVar1) {
        ly_print(out,"%s (%s)\n",(mod->inc[j].submodule)->features->name,
                 (mod->inc[j].submodule)->name);
      }
      for (i = (int)bVar1; bVar1 = false, i < (int)(uint)(mod->inc[j].submodule)->features_size;
          i = i + 1) {
        ly_print(out,"%*s%s (%s)\n",0xb,&DAT_0022edd9,(mod->inc[j].submodule)->features[i].name,
                 (mod->inc[j].submodule)->name);
      }
    }
  }
  if (bVar1) {
    ly_print(out,"\n");
  }
  return;
}



void info_print_data_mainmod_with_include(lyout *out,lys_module *mod)

{
  char *pcVar1;
  bool bVar2;
  bool bVar3;
  int iVar4;
  lys_module *plVar5;
  lys_node *plVar6;
  char *pcVar7;
  undefined *puVar8;
  char *pcVar9;
  undefined *puVar10;
  lys_module *mod_local;
  lyout *out_local;
  int first;
  int from_include;
  lys_node *node;
  lys_module *mainmod;
  
  bVar2 = true;
  plVar5 = lys_main_module(mod);
  ly_print(out,"%-*s",0xb,"Data: ");
  if (plVar5->data != (lys_node *)0x0) {
    for (node = plVar5->data; node != (lys_node *)0x0; node = node->next) {
      if (mod == node->module) {
        bVar3 = false;
LAB_00204475:
        plVar6 = lys_parent(node);
        if (((plVar6 != (lys_node *)0x0) || (iVar4 = strcmp(node->name,"config"), iVar4 != 0)) ||
           (iVar4 = strcmp(node->module->name,"ietf-netconf"), iVar4 != 0)) {
          if (bVar2) {
            if (bVar3) {
              puVar8 = &DAT_0022f25e;
              pcVar9 = node->module->name;
              puVar10 = &DAT_0022f260;
            }
            else {
              puVar8 = &DAT_0022edd9;
              pcVar9 = "";
              puVar10 = &DAT_0022edd9;
            }
            pcVar1 = node->name;
            pcVar7 = strnodetype(node->nodetype);
            ly_print(out,"%s \"%s\"%s%s%s\n",pcVar7,pcVar1,puVar10,pcVar9,puVar8);
            bVar2 = false;
          }
          else {
            if (bVar3) {
              puVar8 = &DAT_0022f25e;
              pcVar9 = node->module->name;
              puVar10 = &DAT_0022f260;
            }
            else {
              puVar8 = &DAT_0022edd9;
              pcVar9 = "";
              puVar10 = &DAT_0022edd9;
            }
            pcVar1 = node->name;
            pcVar7 = strnodetype(node->nodetype);
            ly_print(out,"%*s%s \"%s\"%s%s%s\n",0xb,&DAT_0022edd9,pcVar7,pcVar1,puVar10,pcVar9,
                     puVar8);
          }
        }
      }
      else if (plVar5 == mod) {
        bVar3 = true;
        goto LAB_00204475;
      }
    }
  }
  if (bVar2) {
    ly_print(out,"\n");
  }
  return;
}



void info_print_typedef_detail(lyout *outf,lys_tpdf *tpdf,int *UNUSED_first)

{
  int *UNUSED_first_local;
  lys_tpdf *tpdf_local;
  lyout *outf_local;
  
  ly_print(outf,"%-*s%s\n",0xb,"Typedef: ",tpdf->name);
  ly_print(outf,"%-*s%s\n",0xb,"Module: ",tpdf->module->name);
  info_print_text(outf,tpdf->dsc,"Desc: ");
  info_print_text(outf,tpdf->ref,"Reference: ");
  info_print_flags(outf,tpdf->flags,0x38,0);
  info_print_type_detail_(outf,&tpdf->type,0);
  info_print_text(outf,tpdf->units,"Units: ");
  info_print_text(outf,tpdf->dflt,"Default: ");
  return;
}



void info_print_ident_detail(lyout *out,lys_ident *ident,int *UNUSED_first)

{
  undefined8 uVar1;
  int *UNUSED_first_local;
  lys_ident *ident_local;
  lyout *out_local;
  uint i;
  
  ly_print(out,"%-*s%s\n",0xb,"Identity: ",ident->name);
  ly_print(out,"%-*s%s\n",0xb,"Module: ",ident->module->name);
  info_print_text(out,ident->dsc,"Desc: ");
  info_print_text(out,ident->ref,"Reference: ");
  info_print_flags(out,ident->flags,0x38,0);
  ly_print(out,"%-*s",0xb,"Base: ");
  for (i = 0; i < ident->base_size; i = i + 1) {
    if (i == 0) {
      uVar1 = 0;
    }
    else {
      uVar1 = 0xb;
    }
    ly_print(out,"%*s%s\n",uVar1,&DAT_0022edd9,ident->base[i]->name);
  }
  if (i == 0) {
    ly_print(out,"\n");
  }
  ly_print(out,"%-*s",0xb,"Derived: ");
  if (ident->der != (ly_set *)0x0) {
    for (i = 0; i < ident->der->number; i = i + 1) {
      if (i == 0) {
        uVar1 = 0;
      }
      else {
        uVar1 = 0xb;
      }
      ly_print(out,"%*s%s\n",uVar1,&DAT_0022edd9,(ident->der->set).s[i]->name);
    }
    if (i == 0) {
      ly_print(out,"\n");
    }
  }
  return;
}



void info_print_feature_detail(lyout *out,lys_feature *feat,int *UNUSED_first)

{
  int *UNUSED_first_local;
  lys_feature *feat_local;
  lyout *out_local;
  
  ly_print(out,"%-*s%s\n",0xb,"Feature: ",feat->name);
  ly_print(out,"%-*s%s\n",0xb,"Module: ",feat->module->name);
  info_print_text(out,feat->dsc,"Desc: ");
  info_print_text(out,feat->ref,"Reference: ");
  info_print_flags(out,feat->flags,0x138,0);
  info_print_if_feature(out,feat->module,feat->iffeature,feat->iffeature_size);
  return;
}



void info_print_module(lyout *out,lys_module *module)

{
  undefined *puVar1;
  lys_module *module_local;
  lyout *out_local;
  
  ly_print(out,"%-*s%s\n",0xb,"Module: ",module->name);
  ly_print(out,"%-*s%s\n",0xb,"Namespace: ",module->ns);
  ly_print(out,"%-*s%s\n",0xb,"Prefix: ",module->prefix);
  info_print_text(out,module->dsc,"Desc: ");
  info_print_text(out,module->ref,"Reference: ");
  info_print_text(out,module->org,"Org: ");
  info_print_text(out,module->contact,"Contact: ");
  if ((module->field_0x40 & 0xe) == 4) {
    puVar1 = &DAT_0022f307;
  }
  else {
    puVar1 = &DAT_0022f30b;
  }
  ly_print(out,"%-*s%s\n",0xb,"YANG ver: ",puVar1);
  if ((module->field_0x40 & 0x30) == 0) {
    puVar1 = &DAT_0022f08a;
  }
  else {
    puVar1 = &DAT_0022f08d;
  }
  ly_print(out,"%-*s%s\n",0xb,"Deviated: ",puVar1);
  if ((module->field_0x40 & 0x80) == 0) {
    puVar1 = &DAT_0022f08a;
  }
  else {
    puVar1 = &DAT_0022f08d;
  }
  ly_print(out,"%-*s%s\n",0xb,"Implement: ",puVar1);
  info_print_text(out,module->filepath,"URI: file://");
  info_print_revision(out,module->rev,module->rev_size);
  info_print_include(out,module);
  info_print_import_with_include(out,module);
  info_print_typedef_with_include(out,module);
  info_print_ident_with_include(out,module);
  info_print_features_with_include(out,module);
  info_print_augment(out,module);
  info_print_deviation(out,module);
  info_print_data_mainmod_with_include(out,module);
  return;
}



void info_print_submodule(lyout *out,lys_submodule *module)

{
  undefined *puVar1;
  lys_submodule *module_local;
  lyout *out_local;
  
  ly_print(out,"%-*s%s\n",0xb,"Submodule: ",module->name);
  ly_print(out,"%-*s%s\n",0xb,"Parent: ",module->belongsto->name);
  ly_print(out,"%-*s%s\n",0xb,"Prefix: ",module->prefix);
  info_print_text(out,module->dsc,"Desc: ");
  info_print_text(out,module->ref,"Reference: ");
  info_print_text(out,module->org,"Org: ");
  info_print_text(out,module->contact,"Contact: ");
  if ((module->field_0x40 & 0xe) == 4) {
    puVar1 = &DAT_0022f307;
  }
  else {
    puVar1 = &DAT_0022f30b;
  }
  ly_print(out,"%-*s%s\n",0xb,"YANG ver: ",puVar1);
  if ((module->field_0x40 & 0x30) == 0) {
    puVar1 = &DAT_0022f08a;
  }
  else {
    puVar1 = &DAT_0022f08d;
  }
  ly_print(out,"%-*s%s\n",0xb,"Deviated: ",puVar1);
  if ((module->field_0x40 & 0x80) == 0) {
    puVar1 = &DAT_0022f08a;
  }
  else {
    puVar1 = &DAT_0022f08d;
  }
  ly_print(out,"%-*s%s\n",0xb,"Implement: ",puVar1);
  info_print_text(out,module->filepath,"URI: file://");
  info_print_revision(out,module->rev,module->rev_size);
  info_print_include(out,(lys_module *)module);
  info_print_import_with_include(out,(lys_module *)module);
  info_print_typedef_with_include(out,(lys_module *)module);
  info_print_ident_with_include(out,(lys_module *)module);
  info_print_features_with_include(out,(lys_module *)module);
  info_print_augment(out,(lys_module *)module);
  info_print_deviation(out,(lys_module *)module);
  info_print_data_mainmod_with_include(out,(lys_module *)module);
  return;
}



void info_print_container(lyout *out,lys_node *node,int *UNUSED_first)

{
  int *UNUSED_first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_container *cont;
  
  ly_print(out,"%-*s%s\n",0xb,"Container: ",node->name);
  ly_print(out,"%-*s%s\n",0xb,"Module: ",node->module->name);
  info_print_text(out,node->dsc,"Desc: ");
  info_print_text(out,node->ref,"Reference: ");
  info_print_flags(out,node->flags,0x3b,0);
  info_print_text(out,*(char **)&node[1].flags,"Presence: ");
  info_print_if_feature(out,node->module,node->iffeature,node->iffeature_size);
  info_print_when(out,(lys_when *)node[1].name);
  info_print_must(out,(lys_restr *)node[1].dsc,node->padding[1]);
  info_print_typedef(out,(lys_tpdf *)node[1].ref,(uint8_t)*(undefined2 *)(node->padding + 2));
  info_print_snode(out,node,node->child,"Children:");
  return;
}



void info_print_choice(lyout *out,lys_node *node,int *UNUSED_first)

{
  int *UNUSED_first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_choice *choice;
  
  ly_print(out,"%-*s%s\n",0xb,"Choice: ",node->name);
  ly_print(out,"%-*s%s\n",0xb,"Module: ",node->module->name);
  info_print_text(out,node->dsc,"Desc: ");
  info_print_text(out,node->ref,"Reference: ");
  info_print_flags(out,node->flags,0xfb,0);
  ly_print(out,"%-*s",0xb,"Default: ");
  if (node[1].name == (char *)0x0) {
    ly_print(out,"\n");
  }
  else {
    ly_print(out,"%s\n",*(undefined8 *)node[1].name);
  }
  info_print_if_feature(out,node->module,node->iffeature,node->iffeature_size);
  info_print_when(out,*(lys_when **)node->hash);
  info_print_snode(out,node,node->child,"Cases:");
  return;
}



void info_print_leaf(lyout *out,lys_node *node,int *UNUSED_first)

{
  int *UNUSED_first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_leaf *leaf;
  
  ly_print(out,"%-*s%s\n",0xb,"Leaf: ",node->name);
  ly_print(out,"%-*s%s\n",0xb,"Module: ",node->module->name);
  info_print_text(out,node->dsc,"Desc: ");
  info_print_text(out,node->ref,"Reference: ");
  info_print_flags(out,node->flags,0xfb,0);
  info_print_text(out,(char *)*node[1].ext,"Type: ");
  info_print_text(out,(char *)node[1].next,"Units: ");
  info_print_text(out,(char *)node[1].prev,"Default: ");
  info_print_if_feature(out,node->module,node->iffeature,node->iffeature_size);
  info_print_when(out,(lys_when *)node[1].name);
  info_print_must(out,(lys_restr *)node[1].dsc,node->padding[3]);
  return;
}



void info_print_leaflist(lyout *out,lys_node *node,int *UNUSED_first)

{
  int *UNUSED_first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_leaflist *llist;
  
  ly_print(out,"%-*s%s\n",0xb,"Leaflist: ",node->name);
  ly_print(out,"%-*s%s\n",0xb,"Module: ",node->module->name);
  info_print_text(out,node->dsc,"Desc: ");
  info_print_text(out,node->ref,"Reference: ");
  info_print_flags(out,node->flags,0x13b,1);
  info_print_text(out,(char *)*node[1].ext,"Type: ");
  info_print_text(out,(char *)node[1].next,"Units: ");
  info_print_list_constr(out,*(uint32_t *)&node[1].priv,*(uint32_t *)((long)&node[1].priv + 4));
  info_print_if_feature(out,node->module,node->iffeature,node->iffeature_size);
  info_print_when(out,(lys_when *)node[1].name);
  info_print_must(out,(lys_restr *)node[1].dsc,node->padding[3]);
  return;
}



void info_print_list(lyout *out,lys_node *node,int *UNUSED_first)

{
  int *UNUSED_first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_list *list;
  
  ly_print(out,"%-*s%s\n",0xb,"List: ",node->name);
  ly_print(out,"%-*s%s\n",0xb,"Module: ",node->module->name);
  info_print_text(out,node->dsc,"Desc: ");
  info_print_text(out,node->ref,"Reference: ");
  info_print_flags(out,node->flags,0x13b,1);
  info_print_list_constr
            (out,*(uint32_t *)&node[1].iffeature,*(uint32_t *)((long)&node[1].iffeature + 4));
  info_print_if_feature(out,node->module,node->iffeature,node->iffeature_size);
  info_print_when(out,(lys_when *)node[1].name);
  info_print_must(out,(lys_restr *)node[1].dsc,node->padding[0]);
  info_print_text(out,(char *)node[1].module,"Keys: ");
  info_print_unique(out,(lys_unique *)node[1].ext,node->padding[3]);
  info_print_typedef(out,(lys_tpdf *)node[1].ref,node->padding[1]);
  info_print_snode(out,node,node->child,"Children:");
  return;
}



void info_print_anydata(lyout *out,lys_node *node,int *UNUSED_first)

{
  char *pcVar1;
  int *UNUSED_first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_anydata *any;
  
  if (node->nodetype == LYS_ANYXML) {
    pcVar1 = "Anyxml";
  }
  else {
    pcVar1 = "Anydata";
  }
  ly_print(out,"%-*s%s\n",0xb,&DAT_0022f3ba,pcVar1,node->name);
  ly_print(out,"%-*s%s\n",0xb,"Module: ",node->module->name);
  info_print_text(out,node->dsc,"Desc: ");
  info_print_text(out,node->ref,"Reference: ");
  info_print_flags(out,node->flags,0xfb,0);
  info_print_if_feature(out,node->module,node->iffeature,node->iffeature_size);
  info_print_when(out,(lys_when *)node[1].name);
  info_print_must(out,(lys_restr *)node[1].dsc,node->padding[3]);
  return;
}



void info_print_grouping(lyout *out,lys_node *node,int *UNUSED_first)

{
  int *UNUSED_first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_grp *group;
  
  ly_print(out,"%-*s%s\n",0xb,"Grouping: ",node->name);
  ly_print(out,"%-*s%s\n",0xb,"Module: ",node->module->name);
  info_print_text(out,node->dsc,"Desc: ");
  info_print_text(out,node->ref,"Reference: ");
  info_print_flags(out,node->flags,0x38,0);
  info_print_typedef(out,*(lys_tpdf **)node->hash,(uint8_t)*(undefined2 *)(node->padding + 2));
  info_print_snode(out,node,node->child,"Children:");
  return;
}



void info_print_case(lyout *out,lys_node *node,int *UNUSED_first)

{
  int *UNUSED_first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_case *cas;
  
  ly_print(out,"%-*s%s\n",0xb,"Case: ",node->name);
  ly_print(out,"%-*s%s\n",0xb,"Module: ",node->module->name);
  info_print_text(out,node->dsc,"Desc: ");
  info_print_text(out,node->ref,"Reference: ");
  info_print_flags(out,node->flags,0x3b,0);
  info_print_if_feature(out,node->module,node->iffeature,node->iffeature_size);
  info_print_when(out,*(lys_when **)node->hash);
  info_print_snode(out,node,node->child,"Children:");
  return;
}



void info_print_input(lyout *out,lys_node *node,int *UNUSED_first)

{
  lys_node *plVar1;
  int *UNUSED_first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_inout *input;
  
  plVar1 = lys_parent(node);
  if (plVar1 != (lys_node *)0x0) {
    plVar1 = lys_parent(node);
    if (plVar1->nodetype == LYS_RPC) {
      plVar1 = lys_parent(node);
      ly_print(out,"%-*s%s\n",0xb,"Input of: ",plVar1->name);
      info_print_typedef(out,*(lys_tpdf **)node->hash,(uint8_t)*(undefined2 *)(node->padding + 2));
      info_print_must(out,(lys_restr *)node[1].name,node->padding[1]);
      info_print_snode(out,node,node->child,"Children:");
      return;
    }
  }
                    // WARNING: Subroutine does not return
  __assert_fail("lys_parent(node) && lys_parent(node)->nodetype == LYS_RPC",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_info.c"
                ,0x3b0,"info_print_input");
}



void info_print_output(lyout *out,lys_node *node,int *UNUSED_first)

{
  lys_node *plVar1;
  int *UNUSED_first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_inout *output;
  
  plVar1 = lys_parent(node);
  if (plVar1 != (lys_node *)0x0) {
    plVar1 = lys_parent(node);
    if (plVar1->nodetype == LYS_RPC) {
      plVar1 = lys_parent(node);
      ly_print(out,"%-*s%s\n",0xb,"Output of: ",plVar1->name);
      info_print_typedef(out,*(lys_tpdf **)node->hash,(uint8_t)*(undefined2 *)(node->padding + 2));
      info_print_must(out,(lys_restr *)node[1].name,node->padding[1]);
      info_print_snode(out,node,node->child,"Children:");
      return;
    }
  }
                    // WARNING: Subroutine does not return
  __assert_fail("lys_parent(node) && lys_parent(node)->nodetype == LYS_RPC",
                "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_info.c"
                ,0x3be,"info_print_output");
}



void info_print_notif(lyout *out,lys_node *node,int *UNUSED_first)

{
  int *UNUSED_first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_notif *ntf;
  
  ly_print(out,"%-*s%s\n",0xb,"Notif: ",node->name);
  ly_print(out,"%-*s%s\n",0xb,"Module: ",node->module->name);
  info_print_text(out,node->dsc,"Desc: ");
  info_print_text(out,node->ref,"Reference: ");
  info_print_flags(out,node->flags,0x38,0);
  info_print_if_feature(out,node->module,node->iffeature,node->iffeature_size);
  info_print_typedef(out,(lys_tpdf *)node[1].name,(uint8_t)*(undefined2 *)(node->padding + 2));
  info_print_must(out,(lys_restr *)node[1].dsc,node->padding[1]);
  info_print_snode(out,node,node->child,"Params:");
  return;
}



void info_print_rpc(lyout *out,lys_node *node,int *UNUSED_first)

{
  int *UNUSED_first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_rpc_action *rpc;
  
  ly_print(out,"%-*s%s\n",0xb,"RPC: ",node->name);
  ly_print(out,"%-*s%s\n",0xb,"Module: ",node->module->name);
  info_print_text(out,node->dsc,"Desc: ");
  info_print_text(out,node->ref,"Reference: ");
  info_print_flags(out,node->flags,0x38,0);
  info_print_if_feature(out,node->module,node->iffeature,node->iffeature_size);
  info_print_typedef(out,(lys_tpdf *)node[1].name,(uint8_t)*(undefined2 *)(node->padding + 2));
  info_print_snode(out,node,node->child,"Data:");
  return;
}



void info_print_action(lyout *out,lys_node *node,int *UNUSED_first)

{
  int *UNUSED_first_local;
  lys_node *node_local;
  lyout *out_local;
  lys_node_rpc_action *act;
  
  ly_print(out,"%-*s%s\n",0xb,"Action: ",node->name);
  ly_print(out,"%-*s%s\n",0xb,"Module: ",node->module->name);
  info_print_text(out,node->dsc,"Desc: ");
  info_print_text(out,node->ref,"Reference: ");
  info_print_flags(out,node->flags,0x38,0);
  info_print_if_feature(out,node->module,node->iffeature,node->iffeature_size);
  info_print_typedef(out,(lys_tpdf *)node[1].name,(uint8_t)*(undefined2 *)(node->padding + 2));
  info_print_snode(out,node,node->child,"Data:");
  return;
}



int info_print_model(lyout *out,lys_module *module,char *target_schema_path)

{
  char *target_schema_path_local;
  lys_module *module_local;
  lyout *out_local;
  int rc;
  
  rc = 0;
  if (target_schema_path == (char *)0x0) {
    if ((module->field_0x40 & 1) == 0) {
      info_print_module(out,module);
    }
    else {
      info_print_submodule(out,(lys_submodule *)module);
    }
  }
  else {
    rc = lys_print_target(out,module,target_schema_path,info_print_typedef_detail,
                          info_print_ident_detail,info_print_feature_detail,info_print_type_detail,
                          info_print_grouping,info_print_container,info_print_choice,info_print_leaf
                          ,info_print_leaflist,info_print_list,info_print_anydata,info_print_case,
                          info_print_notif,info_print_rpc,info_print_action,info_print_input,
                          info_print_output);
  }
  ly_print_flush(out);
  return rc;
}



int json_print_string(lyout *out,char *text)

{
  byte bVar1;
  int iVar2;
  char *text_local;
  lyout *out_local;
  uchar ascii;
  uint i;
  uint n;
  
  if (text == (char *)0x0) {
    iVar2 = 0;
  }
  else {
    ly_write(out,"\"",1);
    n = 0;
    for (i = 0; text[i] != '\0'; i = i + 1) {
      bVar1 = text[i];
      if (bVar1 < 0x20) {
        iVar2 = ly_print(out,"\\u%.4X",(ulong)bVar1);
        n = n + iVar2;
      }
      else if (bVar1 == 0x22) {
        iVar2 = ly_print(out,"\\\"");
        n = n + iVar2;
      }
      else if (bVar1 == 0x5c) {
        iVar2 = ly_print(out,"\\\\");
        n = n + iVar2;
      }
      else {
        ly_write(out,text + i,1);
        n = n + 1;
      }
    }
    ly_write(out,"\"",1);
    iVar2 = n + 2;
  }
  return iVar2;
}



int json_print_attrs(lyout *out,int level,lyd_node *node,lys_module *wdmod)

{
  int iVar1;
  int *piVar2;
  undefined *puVar3;
  lys_module *plVar4;
  lys_module *plVar5;
  char *pcVar6;
  undefined *puVar7;
  size_t __n;
  lys_module *wdmod_local;
  lyd_node *node_local;
  int level_local;
  lyout *out_local;
  lyd_attr *attr;
  char *p;
  size_t len;
  
  piVar2 = __errno_location();
  *piVar2 = 0;
  if (wdmod != (lys_module *)0x0) {
    ly_print(out,"%*s\"%s:default\":\"true\"",(ulong)(uint)(level * 2),&DAT_0022f4df,wdmod->name);
    if (level == 0) {
      puVar7 = &DAT_0022f4df;
    }
    else {
      puVar7 = &DAT_0022f4f7;
    }
    if (node->attr == (lyd_attr *)0x0) {
      puVar3 = &DAT_0022f4df;
    }
    else {
      puVar3 = &DAT_0022f4f9;
    }
    ly_print(out,"%s%s",puVar3,puVar7);
  }
  attr = node->attr;
  do {
    if (attr == (lyd_attr *)0x0) {
      piVar2 = __errno_location();
      iVar1 = *piVar2;
      if (iVar1 != 0) {
        piVar2 = __errno_location();
        pcVar6 = strerror(*piVar2);
        ly_log(node->schema->module->ctx,LY_LLERR,LY_ESYS,"Print error (%s).",pcVar6);
      }
      return (uint)(iVar1 != 0);
    }
    if (attr->annotation != (lys_ext_instance_complex *)0x0) {
      plVar4 = lys_main_module(attr->annotation->module);
      plVar5 = lys_main_module(node->schema->module);
      if (plVar4 == plVar5) {
        ly_print(out,"%*s\"%s\":",(ulong)(uint)(level * 2),&DAT_0022f4df,attr->name);
      }
      else {
        ly_print(out,"%*s\"%s:%s\":",(ulong)(uint)(level * 2),&DAT_0022f4df,
                 attr->annotation->module->name,attr->name);
      }
      if (false) {
switchD_0020666e_caseD_0:
        ly_log(node->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_json.c"
               ,0x84);
        return 1;
      }
      switch(attr->value_type) {
      default:
        goto switchD_0020666e_caseD_0;
      case LY_TYPE_BINARY:
      case LY_TYPE_BITS:
      case LY_TYPE_DEC64:
      case LY_TYPE_ENUM:
      case LY_TYPE_INST:
      case LY_TYPE_STRING:
      case LY_TYPE_INT64:
      case LY_TYPE_UINT64:
        json_print_string(out,attr->value_str);
        break;
      case LY_TYPE_BOOL:
      case LY_TYPE_INT8:
      case LY_TYPE_UINT8:
      case LY_TYPE_INT16:
      case LY_TYPE_UINT16:
      case LY_TYPE_INT32:
      case LY_TYPE_UINT32:
        if (*attr->value_str == '\0') {
          pcVar6 = "null";
        }
        else {
          pcVar6 = attr->value_str;
        }
        ly_print(out,"%s",pcVar6);
        break;
      case LY_TYPE_EMPTY:
        ly_print(out,"[null]");
        break;
      case LY_TYPE_IDENT:
        pcVar6 = strchr(attr->value_str,0x3a);
        if (pcVar6 == (char *)0x0) {
                    // WARNING: Subroutine does not return
          __assert_fail("p",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_json.c"
                        ,0x73,"json_print_attrs");
        }
        __n = (long)pcVar6 - (long)attr->value_str;
        iVar1 = strncmp(attr->value_str,attr->annotation->module->name,__n);
        if ((iVar1 == 0) && (attr->annotation->module->name[__n] == '\0')) {
          json_print_string(out,pcVar6 + 1);
        }
        else {
          json_print_string(out,attr->value_str);
        }
      }
      if (level == 0) {
        puVar7 = &DAT_0022f4df;
      }
      else {
        puVar7 = &DAT_0022f4f7;
      }
      if (attr->next == (lyd_attr *)0x0) {
        puVar3 = &DAT_0022f4df;
      }
      else {
        puVar3 = &DAT_0022f4f9;
      }
      ly_print(out,"%s%s",puVar3,puVar7);
    }
    attr = attr->next;
  } while( true );
}



int json_print_leaf(lyout *out,int level,lyd_node *node,int onlyvalue,int toplevel,int options)

{
  char *__s2;
  int iVar1;
  int *piVar2;
  lys_module *plVar3;
  undefined *puVar4;
  hash_table *phVar5;
  lys_type *plVar6;
  undefined *puVar7;
  char *pcVar8;
  size_t __n;
  undefined *puVar9;
  int options_local;
  int toplevel_local;
  lyd_node *node_local;
  int onlyvalue_local;
  int level_local;
  lyout *out_local;
  LY_DATA_TYPE datatype;
  lyd_node_leaf_list *iter;
  char *schema;
  lys_module *wdmod;
  lyd_node_leaf_list *leaf;
  lys_type *type;
  char *p;
  size_t len;
  char *mod_name;
  
  schema = (char *)0x0;
  wdmod = (lys_module *)0x0;
  piVar2 = __errno_location();
  *piVar2 = 0;
  if ((((node->field_0x9 & 1) != 0) && ((options & 0xc0U) != 0)) ||
     (((node->field_0x9 & 1) == 0 &&
      (((options & 0x40U) != 0 && (iVar1 = lyd_wd_default((lyd_node_leaf_list *)node), iVar1 != 0)))
      ))) {
    wdmod = ly_ctx_get_module(node->schema->module->ctx,"ietf-netconf-with-defaults",(char *)0x0,1);
  }
  if (onlyvalue == 0) {
    if (((toplevel == 0) && (node->parent != (lyd_node *)0x0)) &&
       (iVar1 = nscmp(node,node->parent), iVar1 == 0)) {
      if (level == 0) {
        puVar4 = &DAT_0022f4df;
      }
      else {
        puVar4 = &DAT_0022f63f;
      }
      ly_print(out,"%*s\"%s\":%s",(ulong)(uint)(level * 2),&DAT_0022f4df,node->schema->name,puVar4);
    }
    else {
      plVar3 = lys_node_module(node->schema);
      schema = plVar3->name;
      if (level == 0) {
        puVar4 = &DAT_0022f4df;
      }
      else {
        puVar4 = &DAT_0022f63f;
      }
      ly_print(out,"%*s\"%s:%s\":%s",(ulong)(uint)(level * 2),&DAT_0022f4df,schema,
               node->schema->name,puVar4);
    }
  }
  datatype = *(LY_DATA_TYPE *)&node[1].schema;
LAB_00206a6b:
  if (true) {
    switch(datatype) {
    default:
      goto switchD_00206a96_caseD_0;
    case LY_TYPE_BINARY:
    case LY_TYPE_BITS:
    case LY_TYPE_DEC64:
    case LY_TYPE_ENUM:
    case LY_TYPE_INST:
    case LY_TYPE_STRING:
    case LY_TYPE_UNION:
    case LY_TYPE_INT64:
    case LY_TYPE_UINT64:
      json_print_string(out,(char *)node->ht);
      break;
    case LY_TYPE_BOOL:
    case LY_TYPE_INT8:
    case LY_TYPE_UINT8:
    case LY_TYPE_INT16:
    case LY_TYPE_UINT16:
    case LY_TYPE_INT32:
    case LY_TYPE_UINT32:
      if (*(char *)&node->ht->used == '\0') {
        phVar5 = (hash_table *)&DAT_0022f515;
      }
      else {
        phVar5 = node->ht;
      }
      ly_print(out,"%s",phVar5);
      break;
    case LY_TYPE_EMPTY:
      ly_print(out,"[null]");
      break;
    case LY_TYPE_IDENT:
      pcVar8 = strchr((char *)node->ht,0x3a);
      if (pcVar8 == (char *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("p",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_json.c"
                      ,0xc6,"json_print_leaf");
      }
      __n = (long)pcVar8 - (long)node->ht;
      __s2 = node->schema->module->name;
      iVar1 = strncmp((char *)node->ht,__s2,__n);
      if ((iVar1 == 0) && (__s2[__n] == '\0')) {
        json_print_string(out,pcVar8 + 1);
      }
      else {
        json_print_string(out,(char *)node->ht);
      }
      break;
    case LY_TYPE_LEAFREF:
      goto switchD_00206a96_caseD_9;
    }
    if ((onlyvalue == 0) && ((node->attr != (lyd_attr *)0x0 || (wdmod != (lys_module *)0x0)))) {
      if (schema == (char *)0x0) {
        if (level == 0) {
          puVar4 = &DAT_0022f4df;
          puVar9 = &DAT_0022f4df;
        }
        else {
          puVar4 = &DAT_0022f4f7;
          puVar9 = &DAT_0022f63f;
        }
        if (level == 0) {
          puVar7 = &DAT_0022f4df;
        }
        else {
          puVar7 = &DAT_0022f4f7;
        }
        ly_print(out,",%s%*s\"@%s\":%s{%s",puVar7,(ulong)(uint)(level * 2),&DAT_0022f4df,
                 node->schema->name,puVar9,puVar4);
      }
      else {
        if (level == 0) {
          puVar4 = &DAT_0022f4df;
          puVar9 = &DAT_0022f4df;
        }
        else {
          puVar4 = &DAT_0022f4f7;
          puVar9 = &DAT_0022f63f;
        }
        if (level == 0) {
          puVar7 = &DAT_0022f4df;
        }
        else {
          puVar7 = &DAT_0022f4f7;
        }
        ly_print(out,",%s%*s\"@%s:%s\":%s{%s",puVar7,(ulong)(uint)(level * 2),&DAT_0022f4df,schema,
                 node->schema->name,puVar9,puVar4);
      }
      if (level == 0) {
        iVar1 = 0;
      }
      else {
        iVar1 = level + 1;
      }
      iVar1 = json_print_attrs(out,iVar1,node,wdmod);
      if (iVar1 != 0) {
        return 1;
      }
      ly_print(out,"%*s}",(ulong)(uint)(level * 2),&DAT_0022f4df);
    }
    piVar2 = __errno_location();
    if (*piVar2 != 0) {
      piVar2 = __errno_location();
      pcVar8 = strerror(*piVar2);
      ly_log(node->schema->module->ctx,LY_LLERR,LY_ESYS,"Print error (%s).",pcVar8);
      return 1;
    }
    return 0;
  }
switchD_00206a96_caseD_0:
  ly_log(node->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_json.c"
         ,0xe9);
  return 1;
switchD_00206a96_caseD_9:
  for (iter = (lyd_node_leaf_list *)node->child;
      (iter != (lyd_node_leaf_list *)0x0 && (iter->value_type == LY_TYPE_LEAFREF));
      iter = (lyd_node_leaf_list *)(iter->value).enm) {
  }
  if (iter == (lyd_node_leaf_list *)0x0) {
    plVar6 = lyd_leaf_type((lyd_node_leaf_list *)node);
    if (plVar6 == (lys_type *)0x0) {
      return 1;
    }
    datatype = plVar6->base;
  }
  else {
    datatype = iter->value_type;
  }
  goto LAB_00206a6b;
}



int json_print_container(lyout *out,int level,lyd_node *node,int toplevel,int options)

{
  int iVar1;
  int *piVar2;
  lys_module *plVar3;
  undefined *puVar4;
  char *pcVar5;
  undefined *puVar6;
  int options_local;
  lyd_node *node_local;
  int toplevel_local;
  int level_local;
  lyout *out_local;
  char *schema;
  
  piVar2 = __errno_location();
  *piVar2 = 0;
  if (((toplevel == 0) && (node->parent != (lyd_node *)0x0)) &&
     (iVar1 = nscmp(node,node->parent), iVar1 == 0)) {
    if (level == 0) {
      puVar6 = &DAT_0022f4df;
      puVar4 = &DAT_0022f4df;
    }
    else {
      puVar6 = &DAT_0022f4f7;
      puVar4 = &DAT_0022f63f;
    }
    ly_print(out,"%*s\"%s\":%s{%s",(ulong)(uint)(level * 2),&DAT_0022f4df,node->schema->name,puVar4,
             puVar6);
  }
  else {
    plVar3 = lys_node_module(node->schema);
    if (level == 0) {
      puVar6 = &DAT_0022f4df;
      puVar4 = &DAT_0022f4df;
    }
    else {
      puVar6 = &DAT_0022f4f7;
      puVar4 = &DAT_0022f63f;
    }
    ly_print(out,"%*s\"%s:%s\":%s{%s",(ulong)(uint)(level * 2),&DAT_0022f4df,plVar3->name,
             node->schema->name,puVar4,puVar6);
  }
  level_local = level;
  if (level != 0) {
    level_local = level + 1;
  }
  if (node->attr != (lyd_attr *)0x0) {
    if (level_local == 0) {
      puVar6 = &DAT_0022f4df;
      puVar4 = &DAT_0022f4df;
    }
    else {
      puVar6 = &DAT_0022f4f7;
      puVar4 = &DAT_0022f63f;
    }
    ly_print(out,"%*s\"@\":%s{%s",(ulong)(uint)(level_local * 2),&DAT_0022f4df,puVar4,puVar6);
    if (level_local == 0) {
      iVar1 = 0;
    }
    else {
      iVar1 = level_local + 1;
    }
    iVar1 = json_print_attrs(out,iVar1,node,(lys_module *)0x0);
    if (iVar1 != 0) {
      return 1;
    }
    ly_print(out,"%*s}",(ulong)(uint)(level_local * 2),&DAT_0022f4df);
    if (node->child != (lyd_node *)0x0) {
      if (level_local == 0) {
        puVar6 = &DAT_0022f4df;
      }
      else {
        puVar6 = &DAT_0022f4f7;
      }
      ly_print(out,",%s",puVar6);
    }
  }
  iVar1 = json_print_nodes(out,level_local,node->child,1,0,options);
  if (iVar1 == 0) {
    if (level_local != 0) {
      level_local = level_local + -1;
    }
    ly_print(out,"%*s}",(ulong)(uint)(level_local * 2),&DAT_0022f4df);
    piVar2 = __errno_location();
    if (*piVar2 == 0) {
      iVar1 = 0;
    }
    else {
      piVar2 = __errno_location();
      pcVar5 = strerror(*piVar2);
      ly_log(node->schema->module->ctx,LY_LLERR,LY_ESYS,"Print error (%s).",pcVar5);
      iVar1 = 1;
    }
  }
  else {
    iVar1 = 1;
  }
  return iVar1;
}



int json_print_leaf_list(lyout *out,int level,lyd_node *node,int is_list,int toplevel,int options)

{
  bool bVar1;
  bool bVar2;
  int iVar3;
  int *piVar4;
  lys_module *plVar5;
  undefined *puVar6;
  undefined *puVar7;
  undefined *puVar8;
  char *pcVar9;
  int options_local;
  int toplevel_local;
  lyd_node *node_local;
  int is_list_local;
  int level_local;
  lyout *out_local;
  int flag_empty;
  int flag_attrs;
  char *schema;
  lyd_node *list;
  
  schema = (char *)0x0;
  bVar1 = false;
  bVar2 = false;
  piVar4 = __errno_location();
  *piVar4 = 0;
  if ((is_list != 0) && (node->child == (lyd_node *)0x0)) {
    bVar1 = true;
  }
  if (((toplevel == 0) && (node->parent != (lyd_node *)0x0)) &&
     (iVar3 = nscmp(node,node->parent), iVar3 == 0)) {
    ly_print(out,"%*s\"%s\":",(ulong)(uint)(level * 2),&DAT_0022f4df,node->schema->name);
  }
  else {
    plVar5 = lys_node_module(node->schema);
    schema = plVar5->name;
    ly_print(out,"%*s\"%s:%s\":",(ulong)(uint)(level * 2),&DAT_0022f4df,schema,node->schema->name);
  }
  if (bVar1) {
    if (level == 0) {
      puVar6 = &DAT_0022f4df;
    }
    else {
      puVar6 = &DAT_0022f63f;
    }
    ly_print(out,"%snull",puVar6);
  }
  else {
    if (level == 0) {
      puVar6 = &DAT_0022f4df;
      puVar7 = &DAT_0022f4df;
    }
    else {
      puVar6 = &DAT_0022f4f7;
      puVar7 = &DAT_0022f63f;
    }
    ly_print(out,"%s[%s",puVar7,puVar6);
    level_local = level;
    list = node;
    if ((is_list == 0) && (level != 0)) {
      level_local = level + 1;
    }
    while (list != (lyd_node *)0x0) {
      if (is_list == 0) {
        ly_print(out,"%*s",(ulong)(uint)(level_local * 2),&DAT_0022f4df);
        iVar3 = json_print_leaf(out,level_local,list,1,toplevel,options);
        if (iVar3 != 0) {
          return 1;
        }
        if (list->attr != (lyd_attr *)0x0) {
          bVar2 = true;
        }
      }
      else {
        if (level_local != 0) {
          level_local = level_local + 1;
        }
        if (level_local == 0) {
          puVar6 = &DAT_0022f4df;
        }
        else {
          puVar6 = &DAT_0022f4f7;
        }
        ly_print(out,"%*s{%s",(ulong)(uint)(level_local * 2),&DAT_0022f4df,puVar6);
        if (level_local != 0) {
          level_local = level_local + 1;
        }
        if (list->attr != (lyd_attr *)0x0) {
          if (level_local == 0) {
            puVar6 = &DAT_0022f4df;
            puVar7 = &DAT_0022f4df;
          }
          else {
            puVar6 = &DAT_0022f4f7;
            puVar7 = &DAT_0022f63f;
          }
          ly_print(out,"%*s\"@\":%s{%s",(ulong)(uint)(level_local * 2),&DAT_0022f4df,puVar7,puVar6);
          if (level_local == 0) {
            iVar3 = 0;
          }
          else {
            iVar3 = level_local + 1;
          }
          iVar3 = json_print_attrs(out,iVar3,list,(lys_module *)0x0);
          if (iVar3 != 0) {
            return 1;
          }
          if (list->child == (lyd_node *)0x0) {
            ly_print(out,"%*s}",(ulong)(uint)(level_local * 2),&DAT_0022f4df);
          }
          else {
            if (level_local == 0) {
              puVar6 = &DAT_0022f4df;
            }
            else {
              puVar6 = &DAT_0022f4f7;
            }
            ly_print(out,"%*s},%s",(ulong)(uint)(level_local * 2),&DAT_0022f4df,puVar6);
          }
        }
        iVar3 = json_print_nodes(out,level_local,list->child,1,0,options);
        if (iVar3 != 0) {
          return 1;
        }
        if (level_local != 0) {
          level_local = level_local + -1;
        }
        ly_print(out,"%*s}",(ulong)(uint)(level_local * 2),&DAT_0022f4df);
        if (level_local != 0) {
          level_local = level_local + -1;
        }
      }
      if ((toplevel != 0) && ((options & 1U) == 0)) break;
      for (list = list->next; (list != (lyd_node *)0x0 && (list->schema != node->schema));
          list = list->next) {
      }
      if (list != (lyd_node *)0x0) {
        if (level_local == 0) {
          puVar6 = &DAT_0022f4df;
        }
        else {
          puVar6 = &DAT_0022f4f7;
        }
        ly_print(out,",%s",puVar6);
      }
    }
    if ((is_list == 0) && (level_local != 0)) {
      level_local = level_local + -1;
    }
    if (level_local == 0) {
      puVar6 = &DAT_0022f4df;
    }
    else {
      puVar6 = &DAT_0022f4f7;
    }
    ly_print(out,"%s%*s]",puVar6,(ulong)(uint)(level_local * 2),&DAT_0022f4df);
    if ((is_list == 0) && (bVar2)) {
      if (schema == (char *)0x0) {
        if (level_local == 0) {
          puVar6 = &DAT_0022f4df;
          puVar7 = &DAT_0022f4df;
        }
        else {
          puVar6 = &DAT_0022f4f7;
          puVar7 = &DAT_0022f63f;
        }
        if (level_local == 0) {
          puVar8 = &DAT_0022f4df;
        }
        else {
          puVar8 = &DAT_0022f4f7;
        }
        ly_print(out,",%s%*s\"@%s\":%s[%s",puVar8,(ulong)(uint)(level_local * 2),&DAT_0022f4df,
                 node->schema->name,puVar7,puVar6);
      }
      else {
        if (level_local == 0) {
          puVar6 = &DAT_0022f4df;
          puVar7 = &DAT_0022f4df;
        }
        else {
          puVar6 = &DAT_0022f4f7;
          puVar7 = &DAT_0022f63f;
        }
        if (level_local == 0) {
          puVar8 = &DAT_0022f4df;
        }
        else {
          puVar8 = &DAT_0022f4f7;
        }
        ly_print(out,",%s%*s\"@%s:%s\":%s[%s",puVar8,(ulong)(uint)(level_local * 2),&DAT_0022f4df,
                 schema,node->schema->name,puVar7,puVar6);
      }
      list = node;
      if (level_local != 0) {
        level_local = level_local + 1;
      }
      while (list != (lyd_node *)0x0) {
        if (list->attr == (lyd_attr *)0x0) {
          ly_print(out,"%*snull",(ulong)(uint)(level_local * 2),&DAT_0022f4df);
        }
        else {
          if (level_local == 0) {
            puVar6 = &DAT_0022f4df;
          }
          else {
            puVar6 = &DAT_0022f63f;
          }
          ly_print(out,"%*s{%s",(ulong)(uint)(level_local * 2),&DAT_0022f4df,puVar6);
          iVar3 = json_print_attrs(out,0,list,(lys_module *)0x0);
          if (iVar3 != 0) {
            return 1;
          }
          ly_print(out,"%*s}",(ulong)(uint)(level_local * 2),&DAT_0022f4df);
        }
        for (list = list->next; (list != (lyd_node *)0x0 && (list->schema != node->schema));
            list = list->next) {
        }
        if (list != (lyd_node *)0x0) {
          if (level_local == 0) {
            puVar6 = &DAT_0022f4df;
          }
          else {
            puVar6 = &DAT_0022f4f7;
          }
          ly_print(out,",%s",puVar6);
        }
      }
      if (level_local != 0) {
        level_local = level_local + -1;
      }
      if (level_local == 0) {
        puVar6 = &DAT_0022f4df;
      }
      else {
        puVar6 = &DAT_0022f4f7;
      }
      ly_print(out,"%s%*s]",puVar6,(ulong)(uint)(level_local * 2),&DAT_0022f4df);
    }
  }
  piVar4 = __errno_location();
  iVar3 = *piVar4;
  if (iVar3 != 0) {
    piVar4 = __errno_location();
    pcVar9 = strerror(*piVar4);
    ly_log(node->schema->module->ctx,LY_LLERR,LY_ESYS,"Print error (%s).",pcVar9);
  }
  return (uint)(iVar3 != 0);
}



int json_print_anydataxml(lyout *out,int level,lyd_node *node,int toplevel,int options)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  lys_module *plVar4;
  size_t sVar5;
  undefined *puVar6;
  char *pcVar7;
  undefined *puVar8;
  undefined *puVar9;
  long in_FS_OFFSET;
  int options_local;
  lyd_node *node_local;
  int toplevel_local;
  int level_local;
  lyout *out_local;
  int is_object;
  char *buf;
  char *schema;
  lyd_node_anydata *any;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  bVar1 = false;
  schema = (char *)0x0;
  any = (lyd_node_anydata *)node;
  piVar3 = __errno_location();
  *piVar3 = 0;
  if (((toplevel == 0) && (node->parent != (lyd_node *)0x0)) &&
     (iVar2 = nscmp(node,node->parent), iVar2 == 0)) {
    ly_print(out,"%*s\"%s\":",(ulong)(uint)(level * 2),&DAT_0022f4df,node->schema->name);
  }
  else {
    plVar4 = lys_node_module(node->schema);
    schema = plVar4->name;
    ly_print(out,"%*s\"%s:%s\":",(ulong)(uint)(level * 2),&DAT_0022f4df,schema,node->schema->name);
  }
  level_local = level;
  if (level != 0) {
    level_local = level + 1;
  }
  if (true) {
    switch(any->value_type) {
    case LYD_ANYDATA_CONSTSTRING:
    case LYD_ANYDATA_SXML:
      if (level_local != 0) {
        ly_print(out," ");
      }
      if ((any->value).str == (char *)0x0) {
        ly_print(out,"\"\"");
      }
      else {
        json_print_string(out,(any->value).str);
      }
      break;
    case LYD_ANYDATA_STRING:
    case LYD_ANYDATA_JSOND:
    case LYD_ANYDATA_SXMLD:
    case LYD_ANYDATA_LYB:
    case LYD_ANYDATA_LYBD:
      ly_log(node->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_json.c"
             ,0x1e9);
      iVar2 = 1;
      goto LAB_00207edf;
    case LYD_ANYDATA_JSON:
      if (level_local != 0) {
        ly_print(out,"\n");
      }
      if ((any->value).str != (char *)0x0) {
        ly_print(out,"%s",(any->value).str);
      }
      if ((level_local != 0) &&
         (((any->value).str == (char *)0x0 ||
          (pcVar7 = (any->value).str, sVar5 = strlen((any->value).str), pcVar7[sVar5 - 1] != '\n')))
         ) {
        ly_print(out,"\n");
      }
      break;
    case LYD_ANYDATA_XML:
      if (level_local == 0) {
        iVar2 = 0x10;
      }
      else {
        iVar2 = 0x32;
      }
      lyxml_print_mem(&buf,(any->value).xml,iVar2);
      if (level_local != 0) {
        ly_print(out," ");
      }
      json_print_string(out,buf);
      free(buf);
      break;
    case LYD_ANYDATA_DATATREE:
      bVar1 = true;
      if (level_local == 0) {
        puVar8 = &DAT_0022f4df;
        puVar9 = &DAT_0022f4df;
      }
      else {
        puVar8 = &DAT_0022f4f7;
        puVar9 = &DAT_0022f63f;
      }
      ly_print(out,"%s{%s",puVar9,puVar8);
      iVar2 = json_print_nodes(out,level_local,(any->value).tree,1,0,options & 0xfffffefeU | 1);
      if (iVar2 != 0) {
        iVar2 = 1;
        goto LAB_00207edf;
      }
    }
  }
  if (node->attr != (lyd_attr *)0x0) {
    if (schema == (char *)0x0) {
      if (level_local == 0) {
        puVar8 = &DAT_0022f4df;
        puVar9 = &DAT_0022f4df;
      }
      else {
        puVar8 = &DAT_0022f4f7;
        puVar9 = &DAT_0022f63f;
      }
      if (level_local == 0) {
        puVar6 = &DAT_0022f4df;
      }
      else {
        puVar6 = &DAT_0022f4f7;
      }
      ly_print(out,",%s%*s\"@%s\":%s{%s",puVar6,(ulong)(uint)(level_local * 2),&DAT_0022f4df,
               node->schema->name,puVar9,puVar8);
    }
    else {
      if (level_local == 0) {
        puVar8 = &DAT_0022f4df;
        puVar9 = &DAT_0022f4df;
      }
      else {
        puVar8 = &DAT_0022f4f7;
        puVar9 = &DAT_0022f63f;
      }
      if (level_local == 0) {
        puVar6 = &DAT_0022f4df;
      }
      else {
        puVar6 = &DAT_0022f4f7;
      }
      ly_print(out,",%s%*s\"@%s:%s\":%s{%s",puVar6,(ulong)(uint)(level_local * 2),&DAT_0022f4df,
               schema,node->schema->name,puVar9,puVar8);
    }
    if (level_local == 0) {
      iVar2 = 0;
    }
    else {
      iVar2 = level_local + 1;
    }
    iVar2 = json_print_attrs(out,iVar2,node,(lys_module *)0x0);
    if (iVar2 != 0) {
      iVar2 = 1;
      goto LAB_00207edf;
    }
    ly_print(out,"%*s}",(ulong)(uint)(level_local * 2),&DAT_0022f4df);
  }
  if (level_local != 0) {
    level_local = level_local + -1;
  }
  if (bVar1) {
    ly_print(out,"%*s}",(ulong)(uint)(level_local * 2),&DAT_0022f4df);
  }
  piVar3 = __errno_location();
  if (*piVar3 == 0) {
    iVar2 = 0;
  }
  else {
    piVar3 = __errno_location();
    pcVar7 = strerror(*piVar3);
    ly_log(node->schema->module->ctx,LY_LLERR,LY_ESYS,"Print error (%s).",pcVar7);
    iVar2 = 1;
  }
LAB_00207edf:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int json_print_nodes(lyout *out,int level,lyd_node *root,int withsiblings,int toplevel,int options)

{
  LYS_NODE LVar1;
  bool bVar2;
  int iVar3;
  int *piVar4;
  undefined *puVar5;
  char *pcVar6;
  ly_ctx *ctx;
  int options_local;
  int toplevel_local;
  lyd_node *root_local;
  int withsiblings_local;
  int level_local;
  lyout *out_local;
  int comma_flag;
  lyd_node *node;
  lyd_node *iter;
  
  bVar2 = false;
  piVar4 = __errno_location();
  *piVar4 = 0;
  for (node = root; node != (lyd_node *)0x0; node = node->next) {
    iVar3 = lyd_toprint(node,options);
    if (iVar3 != 0) {
      LVar1 = node->schema->nodetype;
      if (LVar1 == LYS_ANYDATA) {
switchD_00207fcd_caseD_20:
        if (bVar2) {
          if (level == 0) {
            puVar5 = &DAT_0022f4df;
          }
          else {
            puVar5 = &DAT_0022f4f7;
          }
          ly_print(out,",%s",puVar5);
        }
        iVar3 = json_print_anydataxml(out,level,node,toplevel,options);
        if (iVar3 != 0) {
          return 1;
        }
        goto LAB_00208246;
      }
      if (LYS_ANYDATA < LVar1) goto switchD_00207fcd_caseD_2;
      if (LVar1 == LYS_ACTION) {
switchD_00207fcd_caseD_1:
        if (bVar2) {
          if (level == 0) {
            puVar5 = &DAT_0022f4df;
          }
          else {
            puVar5 = &DAT_0022f4f7;
          }
          ly_print(out,",%s",puVar5);
        }
        iVar3 = json_print_container(out,level,node,toplevel,options);
        if (iVar3 != 0) {
          return 1;
        }
      }
      else {
        if (LYS_ACTION < LVar1) goto switchD_00207fcd_caseD_2;
        if (LVar1 == LYS_RPC) goto switchD_00207fcd_caseD_1;
        if (LYS_RPC < LVar1) goto switchD_00207fcd_caseD_2;
        if (LYS_ANYXML < LVar1) {
          if (LVar1 != LYS_NOTIF) goto switchD_00207fcd_caseD_2;
          goto switchD_00207fcd_caseD_1;
        }
        if ((LVar1 == LYS_UNKNOWN) || (false)) {
switchD_00207fcd_caseD_2:
          ly_log(node->schema->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_json.c"
                 ,0x24d);
          return 1;
        }
        switch(LVar1) {
        case LYS_CONTAINER:
          goto switchD_00207fcd_caseD_1;
        default:
          goto switchD_00207fcd_caseD_2;
        case LYS_LEAF:
          if (bVar2) {
            if (level == 0) {
              puVar5 = &DAT_0022f4df;
            }
            else {
              puVar5 = &DAT_0022f4f7;
            }
            ly_print(out,",%s",puVar5);
          }
          iVar3 = json_print_leaf(out,level,node,0,toplevel,options);
          if (iVar3 != 0) {
            return 1;
          }
          break;
        case LYS_LEAFLIST:
        case LYS_LIST:
          for (iter = node->prev;
              ((iter->next != (lyd_node *)0x0 && (node != root)) &&
              ((iter == node || (iter->schema != node->schema)))); iter = iter->prev) {
          }
          if ((iter->next == (lyd_node *)0x0) || (node == root)) {
            if (bVar2) {
              if (level == 0) {
                puVar5 = &DAT_0022f4df;
              }
              else {
                puVar5 = &DAT_0022f4f7;
              }
              ly_print(out,",%s",puVar5);
            }
            iVar3 = json_print_leaf_list
                              (out,level,node,(uint)(node->schema->nodetype == LYS_LIST),toplevel,
                               options);
            if (iVar3 != 0) {
              return 1;
            }
          }
          break;
        case LYS_ANYXML:
          goto switchD_00207fcd_caseD_20;
        }
      }
LAB_00208246:
      if (withsiblings == 0) break;
      bVar2 = true;
    }
  }
  if ((root != (lyd_node *)0x0) && (level != 0)) {
    ly_print(out,"\n");
  }
  piVar4 = __errno_location();
  if (*piVar4 == 0) {
    iVar3 = 0;
  }
  else {
    piVar4 = __errno_location();
    pcVar6 = strerror(*piVar4);
    if (root == (lyd_node *)0x0) {
      ctx = (ly_ctx *)0x0;
    }
    else {
      ctx = root->schema->module->ctx;
    }
    ly_log(ctx,LY_LLERR,LY_ESYS,"Print error (%s).",pcVar6);
    iVar3 = 1;
  }
  return iVar3;
}



int json_print_data(lyout *out,lyd_node *root,int options)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  undefined *puVar4;
  undefined *puVar5;
  char *pcVar6;
  int options_local;
  lyd_node *root_local;
  lyout *out_local;
  int level;
  int action_input;
  lyd_node *node;
  lyd_node *next;
  
  bVar1 = false;
  piVar3 = __errno_location();
  *piVar3 = 0;
  level = (int)((options & 2U) != 0);
  root_local = root;
  if ((options & 0x100U) != 0) {
    node = root;
    if (root->schema->nodetype != LYS_RPC) {
      while ((node != (lyd_node *)0x0 && (node->schema->nodetype != LYS_ACTION))) {
        if ((node->schema->nodetype & (LYS_LEAF|LYS_LEAFLIST|LYS_ANYDATA)) == LYS_UNKNOWN) {
          next = node->child;
        }
        else {
          next = (lyd_node *)0x0;
        }
        if (next == (lyd_node *)0x0) {
          if (node == root) break;
          next = node->next;
        }
        while ((next == (lyd_node *)0x0 && (node = node->parent, node->parent != root->parent))) {
          next = node->next;
        }
        node = next;
      }
    }
    if ((node != (lyd_node *)0x0) && ((node->schema->nodetype & 0x4100) != LYS_UNKNOWN)) {
      if ((node->child == (lyd_node *)0x0) || (node->child->schema->parent->nodetype != LYS_OUTPUT))
      {
        if (node->schema->nodetype == LYS_ACTION) {
          bVar1 = true;
        }
      }
      else {
        root_local = node->child;
      }
    }
  }
  if (level == 0) {
    puVar4 = &DAT_0022f4df;
  }
  else {
    puVar4 = &DAT_0022f4f7;
  }
  ly_print(out,"{%s",puVar4);
  if (bVar1) {
    if (level == 0) {
      puVar4 = &DAT_0022f4df;
      puVar5 = &DAT_0022f4df;
    }
    else {
      puVar4 = &DAT_0022f4f7;
      puVar5 = &DAT_0022f63f;
    }
    ly_print(out,"%*s\"yang:action\":%s{%s",(ulong)(uint)(level * 2),&DAT_0022f4df,puVar5,puVar4);
    if (level != 0) {
      level = level + 1;
    }
  }
  iVar2 = json_print_nodes(out,level,root_local,options & 1,1,options);
  if (iVar2 == 0) {
    if (bVar1) {
      if (level != 0) {
        level = level + -1;
      }
      if (level == 0) {
        puVar4 = &DAT_0022f4df;
      }
      else {
        puVar4 = &DAT_0022f4f7;
      }
      ly_print(out,"%*s}%s",(ulong)(uint)(level * 2),&DAT_0022f4df,puVar4);
    }
    if (level == 0) {
      puVar4 = &DAT_0022f4df;
    }
    else {
      puVar4 = &DAT_0022f4f7;
    }
    ly_print(out,"}%s",puVar4);
    ly_print_flush(out);
    piVar3 = __errno_location();
    if (*piVar3 == 0) {
      iVar2 = 0;
    }
    else {
      piVar3 = __errno_location();
      pcVar6 = strerror(*piVar3);
      ly_log((ly_ctx *)0x0,LY_LLERR,LY_ESYS,"Print error (%s).",pcVar6);
      iVar2 = 1;
    }
  }
  else {
    iVar2 = 1;
  }
  return iVar2;
}



__uint64_t __uint64_identity(__uint64_t __x)

{
  __uint64_t __x_local;
  
  return __x;
}



int lyb_hash_equal_cb(void *UNUSED_val1_p,void *UNUSED_val2_p,int UNUSED_mod,void *UNUSED_cb_data)

{
  void *UNUSED_cb_data_local;
  int UNUSED_mod_local;
  void *UNUSED_val2_p_local;
  void *UNUSED_val1_p_local;
  
  return 1;
}



int lyb_ptr_equal_cb(void *val1_p,void *val2_p,int UNUSED_mod,void *UNUSED_cb_data)

{
  void *UNUSED_cb_data_local;
  int UNUSED_mod_local;
  void *val2_p_local;
  void *val1_p_local;
  lys_node *val1;
  lys_node *val2;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  return (int)(*val1_p == *val2_p);
}



int lyb_hash_sequence_check(hash_table *ht,lys_node *sibling,int ht_col_id,int compare_col_id)

{
  byte bVar1;
  uint8_t uVar2;
  uint8_t uVar3;
  int iVar4;
  int iVar5;
  long in_FS_OFFSET;
  int compare_col_id_local;
  int ht_col_id_local;
  lys_node *sibling_local;
  hash_table *ht_local;
  int j;
  lys_node **col_node;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  sibling_local = sibling;
  ht_local = ht;
  bVar1 = lyb_hash(sibling,(uint8_t)ht_col_id);
  iVar4 = lyht_find(ht_local,&sibling_local,(uint)bVar1,&col_node);
  if (iVar4 == 0) {
    lyht_set_cb(ht_local,lyb_ptr_equal_cb);
    iVar4 = compare_col_id;
LAB_00208752:
    do {
      j = iVar4;
      if (-1 < j) {
        uVar2 = lyb_hash(sibling_local,(uint8_t)j);
        uVar3 = lyb_hash(*col_node,(uint8_t)j);
        if (uVar2 == uVar3) {
          iVar4 = j + -1;
          goto LAB_00208752;
        }
      }
      if (j == -1) {
        lyht_set_cb(ht_local,lyb_hash_equal_cb);
        iVar4 = 1;
        goto LAB_002087c9;
      }
      bVar1 = lyb_hash(*col_node,(uint8_t)ht_col_id);
      iVar5 = lyht_find_next(ht_local,col_node,(uint)bVar1,&col_node);
      iVar4 = compare_col_id;
    } while (iVar5 == 0);
    lyht_set_cb(ht_local,lyb_hash_equal_cb);
    iVar4 = 0;
  }
  else {
    iVar4 = 0;
  }
LAB_002087c9:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_check_augment_collision(hash_table *ht,lys_node *aug1,lys_node *aug2)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  long in_FS_OFFSET;
  lys_node *aug2_local;
  lys_node *aug1_local;
  hash_table *ht_local;
  uint8_t hash1;
  uint8_t hash2;
  int i;
  int coliding;
  lys_node *iter1;
  lys_node *iter2;
  values_equal_cb cb;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iter1 = (lys_node *)0x0;
  iter2 = (lys_node *)0x0;
  cb = (values_equal_cb)0x0;
  do {
    iter1 = lys_getnext(iter1,aug1,aug1->module,0);
    if (iter1 == (lys_node *)0x0) {
      iVar3 = 0;
LAB_00208a9f:
      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return iVar3;
    }
    iter2 = (lys_node *)0x0;
    while( true ) {
      iter2 = lys_getnext(iter2,aug2,aug2->module,0);
      if (iter2 == (lys_node *)0x0) break;
      coliding = 0;
      for (i = 0; i < 8; i = i + 1) {
        bVar1 = lyb_hash(iter1,(uint8_t)i);
        bVar2 = lyb_hash(iter2,(uint8_t)i);
        if ((bVar1 == 0) || (bVar2 == 0)) {
          ly_log(aug1->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                 "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
                 ,0x78);
          iVar3 = 0;
          goto LAB_00208a9f;
        }
        if (bVar1 == bVar2) {
          coliding = coliding + 1;
          cb = lyht_set_cb(ht,lyb_ptr_equal_cb);
          iVar3 = lyht_find(ht,&iter1,(uint)bVar1,(void **)0x0);
          if (iVar3 != 0) {
            iVar3 = lyht_find(ht,&iter2,(uint)bVar2,(void **)0x0);
            if (iVar3 != 0) {
              lyht_set_cb(ht,cb);
              goto LAB_002089ed;
            }
          }
          ly_log(aug1->module->ctx,LY_LLWRN,LY_SUCCESS,
                 "Augmentations from modules \"%s\" and \"%s\" have fatal hash collision.",
                 iter1->module->name,iter2->module->name);
          ly_log(aug1->module->ctx,LY_LLWRN,LY_SUCCESS,
                 "It will cause no errors if module \"%s\" is always loaded before \"%s\".",
                 iter1->module->name,iter2->module->name);
          lyht_set_cb(ht,cb);
          iVar3 = 1;
          goto LAB_00208a9f;
        }
LAB_002089ed:
      }
      if (coliding == 8) {
        ly_log(aug1->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
               ,0x89);
        iVar3 = 1;
        goto LAB_00208a9f;
      }
    }
  } while( true );
}



void lyb_check_augments(lys_node *parent,hash_table *ht)

{
  bool bVar1;
  int iVar2;
  lys_module *plVar3;
  lys_module *plVar4;
  lys_module *plVar5;
  lys_node **pplVar6;
  hash_table *ht_local;
  lys_node *parent_local;
  int augs_size;
  int augs_found;
  int i;
  int j;
  int found;
  lys_node *sibling;
  lys_node **augs;
  lys_module *mod;
  void *ret;
  
  sibling = (lys_node *)0x0;
  augs_size = 1;
  augs_found = 0;
  if (parent == (lys_node *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_fail("parent",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
                  ,0x99,"lyb_check_augments");
  }
  plVar3 = lys_node_module(parent);
  augs = (lys_node **)malloc(8);
  if (augs == (lys_node **)0x0) {
    ly_log(plVar3->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyb_check_augments");
  }
  else {
    while (sibling = lys_getnext(sibling,parent,(lys_module *)0x0,0), sibling != (lys_node *)0x0) {
      if ((sibling->parent->nodetype == LYS_AUGMENT) &&
         (plVar4 = lys_node_module(sibling->parent), plVar3 != plVar4)) {
        bVar1 = false;
        for (i = 0; i < augs_found; i = i + 1) {
          plVar4 = lys_node_module(augs[i]);
          plVar5 = lys_node_module(sibling);
          if (plVar4 == plVar5) {
            bVar1 = true;
            break;
          }
        }
        if (!bVar1) {
          pplVar6 = augs;
          if (augs_size == augs_found) {
            augs_size = augs_size << 1;
            pplVar6 = (lys_node **)realloc(augs,(long)augs_size * 8);
            if (pplVar6 == (lys_node **)0x0) {
              ly_log(plVar3->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
                     "lyb_check_augments");
              free(augs);
              return;
            }
          }
          augs = pplVar6;
          augs[augs_found] = sibling;
          augs_found = augs_found + 1;
        }
      }
    }
    for (i = 0; j = i, i < augs_found; i = i + 1) {
      while (j = j + 1, j < augs_found) {
        iVar2 = lyb_check_augment_collision(ht,augs[i]->parent,augs[j]->parent);
        if (iVar2 != 0) {
          free(augs);
          return;
        }
      }
    }
    free(augs);
  }
  return;
}



hash_table * lyb_hash_siblings(lys_node *sibling,lys_module **models,int mod_count)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  lys_module *plVar4;
  int mod_count_local;
  lys_module **models_local;
  lys_node *sibling_local;
  int i;
  int j;
  int aug_col;
  lys_node *parent;
  lys_module *aug_mod;
  hash_table *ht;
  lys_module *mod;
  
  aug_col = 0;
  aug_mod = (lys_module *)0x0;
  sibling_local = sibling;
  ht = lyht_new(1,8,lyb_hash_equal_cb,(void *)0x0,1);
  if (ht == (hash_table *)0x0) {
    ly_log(sibling_local->module->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).",
           "lyb_hash_siblings");
  }
  else {
    for (parent = lys_parent(sibling_local);
        (parent != (lys_node *)0x0 && ((parent->nodetype & 0x1042) != LYS_UNKNOWN));
        parent = lys_parent(parent)) {
    }
    mod = lys_node_module(sibling_local);
    sibling_local = (lys_node *)0x0;
    do {
      do {
        sibling_local = lys_getnext(sibling_local,parent,mod,0x100);
        if (sibling_local == (lys_node *)0x0) {
          if (aug_col != 0) {
            lyb_check_augments(parent,ht);
          }
          lyht_set_cb(ht,lyb_ptr_equal_cb);
          return ht;
        }
      } while ((models != (lys_module **)0x0) &&
              (iVar2 = lyb_has_schema_model(sibling_local,models,mod_count), iVar2 == 0));
      if ((sibling_local->parent != (lys_node *)0x0) &&
         ((sibling_local->parent->nodetype == LYS_AUGMENT &&
          (plVar4 = lys_node_module(sibling_local->parent), mod != plVar4)))) {
        if ((aug_mod != (lys_module *)0x0) &&
           (plVar4 = lys_node_module(sibling_local->parent), aug_mod != plVar4)) {
          aug_col = 1;
        }
        aug_mod = lys_node_module(sibling_local);
      }
      for (i = 0; iVar2 = i, i < 8; i = i + 1) {
        do {
          j = iVar2 + -1;
          if (j < 0) break;
          iVar3 = lyb_hash_sequence_check(ht,sibling_local,j,i);
          iVar2 = j;
        } while (iVar3 == 0);
        if (j < 0) {
          bVar1 = lyb_hash(sibling_local,(uint8_t)i);
          iVar2 = lyht_insert_with_resize_cb
                            (ht,&sibling_local,(uint)bVar1,lyb_ptr_equal_cb,(void **)0x0);
          if (iVar2 == 0) break;
          if ((i != 0) && (iVar2 = lyb_hash_sequence_check(ht,sibling_local,i,i), iVar2 == 0)) {
            lyht_set_cb(ht,lyb_ptr_equal_cb);
            bVar1 = lyb_hash(sibling_local,(uint8_t)i);
            iVar2 = lyht_insert(ht,&sibling_local,(uint)bVar1,(void **)0x0);
            if (iVar2 != 0) {
              lyht_set_cb(ht,lyb_hash_equal_cb);
              ly_log(sibling_local->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
                     "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
                     ,0x106);
              lyht_free(ht);
              return (hash_table *)0x0;
            }
            lyht_set_cb(ht,lyb_hash_equal_cb);
            break;
          }
        }
      }
    } while (i != 8);
    ly_log(sibling_local->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
           ,0x112);
    lyht_free(ht);
  }
  return (hash_table *)0x0;
}



uint8_t lyb_hash_find(hash_table *ht,lys_node *node)

{
  int iVar1;
  lys_node *node_local;
  hash_table *ht_local;
  uint8_t hash;
  uint32_t i;
  
  node_local = node;
  ht_local = ht;
  for (i = 0; i < 8; i = i + 1) {
    hash = lyb_hash(node_local,(uint8_t)i);
    if (hash == 0) {
      ly_log(node_local->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
             ,0x12d);
      return '\0';
    }
    iVar1 = lyht_find(ht_local,&node_local,(uint)hash,(void **)0x0);
    if (iVar1 == 0) break;
  }
  if (i == 8) {
    ly_log(node_local->module->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
           "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
           ,0x138);
    hash = '\0';
  }
  return hash;
}



int lyb_write(lyout *out,uint8_t *buf,size_t count,lyb_state *lybs)

{
  long lVar1;
  int iVar2;
  uint uVar3;
  ulong uVar4;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  size_t count_local;
  uint8_t *buf_local;
  lyout *out_local;
  int ret;
  int i;
  int full_chunk_i;
  size_t to_write;
  size_t r;
  uint8_t meta_buf [2];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  if ((out == (lyout *)0x0) || (count_local = count, buf_local = buf, lybs == (lyb_state *)0x0)) {
                    // WARNING: Subroutine does not return
    __assert_fail("out && lybs",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
                  ,0x147,"lyb_write");
  }
  do {
    do {
      to_write = count_local;
      full_chunk_i = -1;
      for (i = 0; i < lybs->used; i = i + 1) {
        if (0xfe < to_write + lybs->written[i]) {
          to_write = 0xff - lybs->written[i];
          full_chunk_i = i;
        }
      }
      if ((full_chunk_i == -1) && (count_local == 0)) goto LAB_0020952a;
      if (to_write != 0) {
        iVar2 = ly_write(out,(char *)buf_local,to_write);
        uVar4 = (ulong)iVar2;
        if (uVar4 < to_write) {
          ret = -1;
LAB_0020952a:
          if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
            return ret;
          }
                    // WARNING: Subroutine does not return
          __stack_chk_fail();
        }
        for (i = 0; i < lybs->used; i = i + 1) {
          lybs->written[i] = uVar4 + lybs->written[i];
          if (0xff < lybs->written[i]) {
                    // WARNING: Subroutine does not return
            __assert_fail("lybs->written[i] <= LYB_SIZE_MAX",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
                          ,0x164,"lyb_write");
          }
        }
        count_local = count_local - uVar4;
        buf_local = buf_local + uVar4;
        ret = ret + iVar2;
      }
    } while (full_chunk_i < 0);
    meta_buf[0] = (uint8_t)lybs->written[full_chunk_i];
    meta_buf[1] = lybs->inner_chunks[full_chunk_i];
    uVar3 = ly_write_skipped(out,lybs->position[full_chunk_i],(char *)meta_buf,2);
    if (uVar3 < 2) {
      ret = -1;
      goto LAB_0020952a;
    }
    lybs->written[full_chunk_i] = 0;
    lybs->inner_chunks[full_chunk_i] = '\0';
    uVar3 = ly_write_skip(out,2,lybs->position + full_chunk_i);
    if (uVar3 < 2) {
      ret = -1;
      goto LAB_0020952a;
    }
    ret = ret + uVar3;
    for (i = 0; i < full_chunk_i; i = i + 1) {
      if (lybs->inner_chunks[i] == 0xff) {
        ly_log(lybs->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
               "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
               ,0x186);
        ret = -1;
        goto LAB_0020952a;
      }
      lybs->inner_chunks[i] = lybs->inner_chunks[i] + '\x01';
    }
  } while( true );
}



int lyb_write_stop_subtree(lyout *out,lyb_state *lybs)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  lyout *out_local;
  int r;
  uint8_t meta_buf [2];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  meta_buf[0] = (uint8_t)lybs->written[(long)lybs->used + -1];
  meta_buf[1] = lybs->inner_chunks[(long)lybs->used + -1];
  iVar2 = ly_write_skipped(out,lybs->position[(long)lybs->used + -1],(char *)meta_buf,2);
  if (iVar2 < 2) {
    iVar2 = -1;
  }
  else {
    lybs->used = lybs->used + -1;
    iVar2 = 0;
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lyb_write_start_subtree(lyout *out,lyb_state *lybs)

{
  int iVar1;
  size_t *psVar2;
  uint8_t *puVar3;
  lyb_state *lybs_local;
  lyout *out_local;
  int i;
  
  if (lybs->used == lybs->size) {
    lybs->size = lybs->size + 4;
    psVar2 = (size_t *)ly_realloc(lybs->written,(long)lybs->size * 8);
    lybs->written = psVar2;
    psVar2 = (size_t *)ly_realloc(lybs->position,(long)lybs->size * 8);
    lybs->position = psVar2;
    puVar3 = (uint8_t *)ly_realloc(lybs->inner_chunks,(long)lybs->size);
    lybs->inner_chunks = puVar3;
    if (((lybs->written == (size_t *)0x0) || (lybs->position == (size_t *)0x0)) ||
       (lybs->inner_chunks == (uint8_t *)0x0)) {
      ly_log(lybs->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyb_write_start_subtree"
            );
      return -1;
    }
  }
  lybs->used = lybs->used + 1;
  lybs->written[(long)lybs->used + -1] = 0;
  lybs->inner_chunks[(long)lybs->used + -1] = '\0';
  i = 0;
  while( true ) {
    if (lybs->used + -1 <= i) {
      iVar1 = ly_write_skip(out,2,lybs->position + (long)lybs->used + -1);
      return iVar1;
    }
    if (lybs->inner_chunks[i] == 0xff) break;
    lybs->inner_chunks[i] = lybs->inner_chunks[i] + '\x01';
    i = i + 1;
  }
  ly_log(lybs->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
         "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
         ,0x1b8);
  return -1;
}



int lyb_write_number(uint64_t num,size_t bytes,lyout *out,lyb_state *lybs)

{
  int iVar1;
  lyb_state *lybs_local;
  lyout *out_local;
  size_t bytes_local;
  uint64_t num_local;
  
  num_local = num;
  num_local = __uint64_identity(num);
  iVar1 = lyb_write(out,(uint8_t *)&num_local,bytes,lybs);
  return iVar1;
}



int lyb_write_enum(uint32_t enum_idx,uint32_t count,lyout *out,lyb_state *lybs)

{
  int iVar1;
  lyb_state *lybs_local;
  lyout *out_local;
  uint32_t count_local;
  uint32_t enum_idx_local;
  size_t bytes;
  
  if (count <= enum_idx) {
                    // WARNING: Subroutine does not return
    __assert_fail("enum_idx < count",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
                  ,0x1cf,"lyb_write_enum");
  }
  if (count < 0x100) {
    bytes = 1;
  }
  else if (count < 0x10000) {
    bytes = 2;
  }
  else if (count < 0x1000000) {
    bytes = 3;
  }
  else {
    bytes = 4;
  }
  iVar1 = lyb_write_number((ulong)enum_idx,bytes,out,lybs);
  return iVar1;
}



int lyb_write_string(char *str,size_t str_len,int with_length,lyout *out,lyb_state *lybs)

{
  int iVar1;
  int iVar2;
  lyb_state *lybs_local;
  lyout *out_local;
  int with_length_local;
  size_t str_len_local;
  char *str_local;
  int ret;
  int r;
  
  ret = 0;
  str_len_local = str_len;
  if (str_len == 0) {
    str_len_local = strlen(str);
  }
  if (with_length != 0) {
    if (0xffff < str_len_local) {
      ly_log(lybs->ctx,LY_LLERR,LY_EINT,"Internal error (%s:%d).",
             "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
             ,0x1ea);
      return -1;
    }
    ret = lyb_write_number(str_len_local,2,out,lybs);
    if (ret < 0) {
      return -1;
    }
  }
  iVar1 = lyb_write(out,(uint8_t *)str,str_len_local,lybs);
  iVar2 = ret + iVar1;
  if (iVar1 < 0) {
    iVar2 = -1;
  }
  return iVar2;
}



int lyb_print_model(lyout *out,lys_module *mod,lyb_state *lybs)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  lyb_state *lybs_local;
  lys_module *mod_local;
  lyout *out_local;
  uint16_t revision;
  int ret;
  int r;
  
  iVar1 = lyb_write_string(mod->name,0,1,out,lybs);
  if (iVar1 < 0) {
    iVar1 = -1;
  }
  else {
    revision = 0;
    if (mod->rev_size != '\0') {
      iVar2 = atoi(mod->rev->date);
      iVar3 = atoi(mod->rev->date + 5);
      iVar4 = atoi(mod->rev->date + 8);
      revision = ((short)iVar2 + -2000) * 0x200 | (ushort)(iVar3 << 5) | (ushort)iVar4;
    }
    iVar2 = lyb_write_number((ulong)revision,2,out,lybs);
    iVar1 = iVar1 + iVar2;
    if (iVar2 < 0) {
      iVar1 = -1;
    }
  }
  return iVar1;
}



int is_added_model(lys_module **models,size_t mod_count,lys_module *mod)

{
  lys_module *mod_local;
  size_t mod_count_local;
  lys_module **models_local;
  size_t i;
  
  i = 0;
  while( true ) {
    if (mod_count <= i) {
      return 0;
    }
    if (mod == models[i]) break;
    i = i + 1;
  }
  return 1;
}



void add_model(lys_module ***models,size_t *mod_count,lys_module *mod)

{
  int iVar1;
  lys_module **pplVar2;
  lys_module *mod_local;
  size_t *mod_count_local;
  lys_module ***models_local;
  
  iVar1 = is_added_model(*models,*mod_count,mod);
  if (iVar1 == 0) {
    *mod_count = *mod_count + 1;
    pplVar2 = (lys_module **)ly_realloc(*models,*mod_count * 8);
    *models = pplVar2;
    (*models)[*mod_count - 1] = mod;
  }
  return;
}



int lyb_print_data_models(lyout *out,lyd_node *root,lyb_state *lybs)

{
  int iVar1;
  lys_module *plVar2;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  lyd_node *root_local;
  lyout *out_local;
  uint32_t idx;
  int ret;
  uint32_t i;
  uint32_t j;
  lys_module **models;
  size_t mod_count;
  lyd_node *node;
  lys_module *mod;
  lys_submodule *submod;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  models = (lys_module **)0x0;
  mod_count = 0;
  idx = 0;
  for (node = root; node != (lyd_node *)0x0; node = node->next) {
    mod = lyd_node_module(node);
    add_model(&models,&mod_count,mod);
  }
  if (root != (lyd_node *)0x0) {
    idx = ly_ctx_internal_modules_count(root->schema->module->ctx);
LAB_00209f72:
    mod = ly_ctx_get_module_iter(root->schema->module->ctx,&idx);
    if (mod != (lys_module *)0x0) {
      if ((mod->field_0x40 & 0x80) != 0) {
        for (i = 0; i < mod->deviation_size; i = i + 1) {
          if (mod->deviation[i].orig_node != (lys_node *)0x0) {
            plVar2 = lys_node_module(mod->deviation[i].orig_node);
            iVar1 = is_added_model(models,mod_count,plVar2);
            if (iVar1 != 0) {
              add_model(&models,&mod_count,mod);
              goto LAB_00209f72;
            }
          }
        }
        for (i = 0; i < mod->augment_size; i = i + 1) {
          plVar2 = lys_node_module(mod->augment[i].target);
          iVar1 = is_added_model(models,mod_count,plVar2);
          if (iVar1 != 0) {
            add_model(&models,&mod_count,mod);
            goto LAB_00209f72;
          }
        }
        for (j = 0; j < mod->inc_size; j = j + 1) {
          submod = mod->inc[j].submodule;
          for (i = 0; i < submod->deviation_size; i = i + 1) {
            if (submod->deviation[i].orig_node != (lys_node *)0x0) {
              plVar2 = lys_node_module(submod->deviation[i].orig_node);
              iVar1 = is_added_model(models,mod_count,plVar2);
              if (iVar1 != 0) {
                add_model(&models,&mod_count,mod);
                goto LAB_00209f72;
              }
            }
          }
          for (i = 0; i < submod->augment_size; i = i + 1) {
            plVar2 = lys_node_module(submod->augment[i].target);
            iVar1 = is_added_model(models,mod_count,plVar2);
            if (iVar1 != 0) {
              add_model(&models,&mod_count,mod);
              goto LAB_00209f72;
            }
          }
        }
      }
      goto LAB_00209f72;
    }
  }
  iVar1 = lyb_write_number(mod_count,2,out,lybs);
  ret = ret + iVar1;
  for (i = 0; i < mod_count; i = i + 1) {
    iVar1 = lyb_print_model(out,models[i],lybs);
    ret = ret + iVar1;
  }
  free(models);
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_print_magic_number(lyout *out)

{
  int iVar1;
  long in_FS_OFFSET;
  lyout *out_local;
  uint32_t magic_number;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  magic_number._0_1_ = 0x6c;
  magic_number._1_1_ = 0x79;
  magic_number._2_1_ = 0x62;
  iVar1 = ly_write(out,(char *)&magic_number,3);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int lyb_print_header(lyout *out)

{
  int iVar1;
  long in_FS_OFFSET;
  lyout *out_local;
  uint8_t byte;
  int ret;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  byte = '\0';
  iVar1 = ly_write(out,(char *)&byte,1);
  ret = ret + iVar1;
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return ret;
}



int lyb_print_anydata(lyd_node_anydata *anydata,lyout *out,lyb_state *lybs)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  lyout *out_local;
  lyd_node_anydata *anydata_local;
  int ret;
  int len;
  char *buf;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (anydata->value_type == LYD_ANYDATA_XML) {
    lyxml_print_mem(&buf,(anydata->value).xml,0x10);
    lyxml_free(anydata->schema->module->ctx,(anydata->value).xml);
    anydata->value_type = LYD_ANYDATA_CONSTSTRING;
    pcVar3 = lydict_insert_zc(anydata->schema->module->ctx,buf);
    (anydata->value).str = pcVar3;
  }
  else if (anydata->value_type == LYD_ANYDATA_DATATREE) {
    lyd_print_mem(&buf,(anydata->value).tree,LYD_LYB,1);
    lyd_free_withsiblings((anydata->value).tree);
    anydata->value_type = LYD_ANYDATA_LYB;
    (anydata->value).str = buf;
  }
  else if ((anydata->value_type & 1) != 0) {
    ly_log(lybs->ctx,LY_LLERR,LY_EINT,"Unsupported anydata value type to print.");
    iVar2 = -1;
    goto LAB_0020a2d0;
  }
  iVar1 = lyb_write(out,(uint8_t *)&anydata->value_type,4,lybs);
  if (anydata->value_type == LYD_ANYDATA_LYB) {
    iVar2 = lyd_lyb_data_length((anydata->value).str);
    if (-1 < iVar2) {
      iVar2 = lyb_write_string((anydata->value).str,(long)iVar2,0,out,lybs);
      iVar2 = iVar1 + iVar2;
    }
  }
  else {
    iVar2 = lyb_write_string((anydata->value).str,0,0,out,lybs);
    iVar2 = iVar1 + iVar2;
  }
LAB_0020a2d0:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_print_value(lys_type *type,char *value_str,lyd_val value,LY_DATA_TYPE value_type,
                   uint8_t value_flags,uint8_t dflt,lyout *out,lyb_state *lybs)

{
  LY_DATA_TYPE *pLVar1;
  int iVar2;
  int iVar3;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  lyout *out_local;
  uint8_t dflt_local;
  uint8_t value_flags_local;
  LY_DATA_TYPE value_type_local;
  lyd_val value_local;
  char *value_str_local;
  lys_type *type_local;
  uint8_t byte;
  int ret;
  LY_DATA_TYPE dtype;
  size_t count;
  size_t i;
  size_t bits_i;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  byte = '\0';
  if (dflt != '\0') {
    byte = 0x80;
  }
  if ((value_flags & 2) != 0) {
    byte = byte | 0x40;
  }
  if ((value_flags & 1) != 0) {
    byte = byte | 0x20;
  }
  type_local = type;
  if (value_type != (value_type & 0x1f)) {
                    // WARNING: Subroutine does not return
    __assert_fail("(value_type & 0x1f) == value_type",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
                  ,0x2e1,"lyb_print_value");
  }
  for (; type_local->base == LY_TYPE_LEAFREF; type_local = &((type_local->info).lref.target)->type)
  {
  }
  value_local = value;
  if (((value_flags & 2) == 0) && (value_type_local = value_type, type_local->base != LY_TYPE_UNION)
     ) {
    while (value_type_local == LY_TYPE_LEAFREF) {
      if ((value_flags & 1) != 0) {
                    // WARNING: Subroutine does not return
        __assert_fail("!(value_flags & LY_VALUE_UNRES)",
                      "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
                      ,0x2eb,"lyb_print_value");
      }
      pLVar1 = (LY_DATA_TYPE *)(value_local.dec64 + 0x48);
      value_local = (lyd_val)(value_local.ident)->der;
      value_type_local = *pLVar1;
    }
  }
  else {
    value_type_local = LY_TYPE_STRING;
  }
  byte = byte | (byte)value_type_local & 0x1f;
  iVar2 = lyb_write(out,&byte,1,lybs);
  ret = ret + iVar2;
  if ((value_flags & 2) == 0) {
    dtype = value_type_local;
  }
  else {
    dtype = LY_TYPE_STRING;
  }
  if (false) {
switchD_0020a492_caseD_0:
    iVar2 = 0;
  }
  else {
    switch(dtype) {
    default:
      goto switchD_0020a492_caseD_0;
    case LY_TYPE_BINARY:
    case LY_TYPE_IDENT:
    case LY_TYPE_INST:
    case LY_TYPE_STRING:
    case LY_TYPE_UNION:
    case LY_TYPE_UNKNOWN:
      iVar3 = lyb_write_string(value_str,0,0,out,lybs);
      iVar2 = ret + iVar3;
      ret = ret + iVar3;
      break;
    case LY_TYPE_BITS:
      for (; (type_local->info).bits.count == 0; type_local = &type_local->der->type) {
      }
      bits_i = 0;
      for (count = (size_t)((type_local->info).bits.count >> 3); count != 0; count = count - 1) {
        byte = '\0';
        for (i = 0; i < 8; i = i + 1) {
          if (*(long *)(value_local.binary + (i + bits_i) * 8) != 0) {
            byte = byte | (byte)(1 << ((byte)i & 0x1f));
          }
        }
        iVar2 = lyb_write(out,&byte,1,lybs);
        ret = ret + iVar2;
        bits_i = bits_i + 8;
      }
      iVar2 = ret;
      if (((type_local->info).bits.count & 7) != 0) {
        byte = '\0';
        for (i = 0; i < ((type_local->info).bits.count & 7); i = i + 1) {
          if (*(long *)(value_local.binary + (i + bits_i) * 8) != 0) {
            byte = byte | (byte)(1 << ((byte)i & 0x1f));
          }
        }
        iVar2 = lyb_write(out,&byte,1,lybs);
        iVar2 = ret + iVar2;
        ret = iVar2;
      }
      break;
    case LY_TYPE_BOOL:
      byte = value_local.bln != '\0';
      iVar3 = lyb_write(out,&byte,1,lybs);
      iVar2 = ret + iVar3;
      ret = ret + iVar3;
      break;
    case LY_TYPE_DEC64:
    case LY_TYPE_INT64:
    case LY_TYPE_UINT64:
      iVar3 = lyb_write_number(value_local.uint64,8,out,lybs);
      iVar2 = ret + iVar3;
      ret = ret + iVar3;
      break;
    case LY_TYPE_EMPTY:
      iVar2 = ret;
      break;
    case LY_TYPE_ENUM:
      for (; (type_local->info).bits.count == 0; type_local = &type_local->der->type) {
      }
      i = ((long)value_local.binary - (long)(type_local->info).bits.bit >> 4) * -0x5555555555555555;
      iVar3 = lyb_write_enum((uint32_t)i,(type_local->info).bits.count,out,lybs);
      iVar2 = ret + iVar3;
      ret = ret + iVar3;
      break;
    case LY_TYPE_INT8:
    case LY_TYPE_UINT8:
      iVar3 = lyb_write_number(value_local.uint64 & 0xff,1,out,lybs);
      iVar2 = ret + iVar3;
      ret = ret + iVar3;
      break;
    case LY_TYPE_INT16:
    case LY_TYPE_UINT16:
      iVar3 = lyb_write_number(value_local.uint64 & 0xffff,2,out,lybs);
      iVar2 = ret + iVar3;
      ret = ret + iVar3;
      break;
    case LY_TYPE_INT32:
    case LY_TYPE_UINT32:
      iVar3 = lyb_write_number(value_local.uint64 & 0xffffffff,4,out,lybs);
      iVar2 = ret + iVar3;
      ret = ret + iVar3;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int lyb_print_attributes(lyout *out,lyd_attr *attr,lyb_state *lybs)

{
  lyd_attr *plVar1;
  int iVar2;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  lyd_attr *attr_local;
  lyout *out_local;
  uint8_t count;
  int ret;
  int r;
  lyd_attr *iter;
  lys_type **type;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  count = '\0';
  for (iter = attr; iter != (lyd_attr *)0x0; iter = iter->next) {
    if (count == 0xff) {
      ly_log(lybs->ctx,LY_LLERR,LY_EINT,"Maximum supported number of data node attributes is %u.",
             0xff);
      iVar2 = -1;
      goto LAB_0020a9ad;
    }
    count = count + '\x01';
  }
  r = lyb_write(out,&count,1,lybs);
  ret = ret + r;
  plVar1 = attr;
  if (r < 0) {
    iVar2 = -1;
  }
  else {
    while (iter = plVar1, iVar2 = ret, iter != (lyd_attr *)0x0) {
      r = lyb_write_start_subtree(out,lybs);
      ret = ret + r;
      if (r < 0) {
        iVar2 = -1;
        break;
      }
      r = lyb_print_model(out,iter->annotation->module,lybs);
      ret = ret + r;
      if (r < 0) {
        iVar2 = -1;
        break;
      }
      r = lyb_write_string(iter->annotation->arg_value,0,1,out,lybs);
      ret = ret + r;
      if (r < 0) {
        iVar2 = -1;
        break;
      }
      type = (lys_type **)
             lys_ext_complex_get_substmt(LY_STMT_TYPE,iter->annotation,(lyext_substmt **)0x0);
      if ((type == (lys_type **)0x0) || (*type == (lys_type *)0x0)) {
        iVar2 = -1;
        break;
      }
      r = lyb_print_value(*type,iter->value_str,iter->value,iter->value_type,iter->value_flags,'\0',
                          out,lybs);
      ret = ret + r;
      if (r < 0) {
        iVar2 = -1;
        break;
      }
      r = lyb_write_stop_subtree(out,lybs);
      ret = ret + r;
      if (r < 0) {
        iVar2 = -1;
        break;
      }
      plVar1 = iter->next;
    }
  }
LAB_0020a9ad:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_print_schema_hash(lyout *out,lys_node *schema,hash_table **sibling_ht,lyb_state *lybs)

{
  int iVar1;
  lys_module *module;
  hash_table *phVar2;
  long in_FS_OFFSET;
  lyb_state *lybs_local;
  hash_table **sibling_ht_local;
  lys_node *schema_local;
  lyout *out_local;
  uint8_t hash;
  int r;
  int ret;
  uint32_t i;
  lys_node *parent;
  lys_node *first_sibling;
  void *mem;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  if (*sibling_ht == (hash_table *)0x0) {
    for (parent = lys_parent(schema);
        (parent != (lys_node *)0x0 && ((parent->nodetype & 0x1042) != LYS_UNKNOWN));
        parent = lys_parent(parent)) {
    }
    module = lys_node_module(schema);
    first_sibling = lys_getnext((lys_node *)0x0,parent,module,0);
    for (r = 0; r < lybs->sib_ht_count; r = r + 1) {
      if (first_sibling == lybs->sib_ht[r].first_sibling) {
        *sibling_ht = lybs->sib_ht[r].ht;
        break;
      }
    }
    if (*sibling_ht == (hash_table *)0x0) {
      phVar2 = lyb_hash_siblings(first_sibling,(lys_module **)0x0,0);
      *sibling_ht = phVar2;
      if (*sibling_ht == (hash_table *)0x0) {
        iVar1 = -1;
        goto LAB_0020ad18;
      }
      lybs->sib_ht_count = lybs->sib_ht_count + 1;
      mem = realloc(lybs->sib_ht,(long)lybs->sib_ht_count << 4);
      if ((anon_struct_16_2_515384b0 *)mem == (anon_struct_16_2_515384b0 *)0x0) {
        ly_log(lybs->ctx,LY_LLERR,LY_EMEM,"Memory allocation failed (%s()).","lyb_print_schema_hash"
              );
        iVar1 = -1;
        goto LAB_0020ad18;
      }
      lybs->sib_ht = (anon_struct_16_2_515384b0 *)mem;
      lybs->sib_ht[(long)lybs->sib_ht_count + -1].first_sibling = first_sibling;
      lybs->sib_ht[(long)lybs->sib_ht_count + -1].ht = *sibling_ht;
    }
  }
  hash = lyb_hash_find(*sibling_ht,schema);
  if (hash == '\0') {
    iVar1 = -1;
  }
  else {
    r = lyb_write(out,&hash,1,lybs);
    ret = ret + r;
    if (r < 0) {
      iVar1 = -1;
    }
    else {
      iVar1 = ret;
      if (-1 < (char)hash) {
        i = 0;
        while ((0x80 >> ((byte)i & 0x1f) & (uint)hash) == 0) {
          i = i + 1;
        }
        for (; iVar1 = ret, i != 0; i = i - 1) {
          hash = lyb_hash(schema,(char)i + 0xff);
          if (hash == 0) {
            iVar1 = -1;
            break;
          }
          if (((uint)hash & 0x80 >> ((char)i - 1U & 0x1f)) == 0) {
                    // WARNING: Subroutine does not return
            __assert_fail("hash & (LYB_HASH_COLLISION_ID >> (i - 1))",
                          "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-19334_Libyang/Libyang/src/printer_lyb.c"
                          ,0x3d3,"lyb_print_schema_hash");
          }
          r = lyb_write(out,&hash,1,lybs);
          ret = ret + r;
          if (r < 0) {
            iVar1 = -1;
            break;
          }
        }
      }
    }
  }
LAB_0020ad18:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_print_subtree(lyout *out,lyd_node *node,hash_table **sibling_ht,lyb_state *lybs,
                     int top_level)

{
  LYS_NODE LVar1;
  int iVar2;
  int iVar3;
  lys_module *mod;
  long in_FS_OFFSET;
  int top_level_local;
  lyb_state *lybs_local;
  hash_table **sibling_ht_local;
  lyd_node *node_local;
  lyout *out_local;
  int r;
  int ret;
  hash_table *child_ht;
  lyd_node_leaf_list *leaf;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  child_ht = (hash_table *)0x0;
  ret = lyb_write_start_subtree(out,lybs);
  if (ret < 0) {
    iVar2 = -1;
    goto LAB_0020b033;
  }
  if (top_level != 0) {
    mod = lyd_node_module(node);
    iVar2 = lyb_print_model(out,mod,lybs);
    ret = ret + iVar2;
    if (iVar2 < 0) {
      iVar2 = -1;
      goto LAB_0020b033;
    }
  }
  iVar2 = lyb_print_schema_hash(out,node->schema,sibling_ht,lybs);
  if (iVar2 < 0) {
    iVar2 = -1;
    goto LAB_0020b033;
  }
  iVar3 = lyb_print_attributes(out,node->attr,lybs);
  ret = ret + iVar2 + iVar3;
  if (iVar3 < 0) {
    iVar2 = -1;
    goto LAB_0020b033;
  }
  LVar1 = node->schema->nodetype;
  if (LVar1 == LYS_ANYDATA) {
switchD_0020aec3_caseD_20:
    iVar2 = lyb_print_anydata((lyd_node_anydata *)node,out,lybs);
    ret = ret + iVar2;
    if (iVar2 < 0) {
      iVar2 = -1;
      goto LAB_0020b033;
    }
    goto LAB_0020af8f;
  }
  if (LYS_ANYDATA < LVar1) goto switchD_0020aec3_caseD_2;
  if (LVar1 == LYS_ACTION) goto LAB_0020af8f;
  if (LYS_ACTION < LVar1) goto switchD_0020aec3_caseD_2;
  if (LVar1 == LYS_RPC) goto LAB_0020af8f;
  if (LVar1 < (LYS_CONTAINER|LYS_RPC)) {
    if (LVar1 < (LYS_CONTAINER|LYS_ANYXML)) {
      if ((LVar1 != LYS_UNKNOWN) && (true)) {
        switch(LVar1) {
        default:
          goto switchD_0020aec3_caseD_2;
        case LYS_LEAF:
        case LYS_LEAFLIST:
          leaf = (lyd_node_leaf_list *)node;
          iVar2 = lyb_print_value((lys_type *)&node->schema[1].ref,(char *)node->ht,
                                  (lyd_val)node->child,*(LY_DATA_TYPE *)&node[1].schema,
                                  *(uint8_t *)((long)&node[1].schema + 4),node->field_0x9 & 1,out,
                                  lybs);
          ret = ret + iVar2;
          if (iVar2 < 0) {
            iVar2 = -1;
            break;
          }
        case LYS_CONTAINER:
        case LYS_LIST:
LAB_0020af8f:
          r = 0;
          if ((node->schema->nodetype & 0x4191) != LYS_UNKNOWN) {
            for (node_local = node->child; node_local != (lyd_node *)0x0;
                node_local = node_local->next) {
              r = lyb_print_subtree(out,node_local,&child_ht,lybs,0);
              ret = ret + r;
              if (r < 0) break;
            }
          }
          if (r < 0) {
            iVar2 = -1;
          }
          else {
            iVar3 = lyb_write_stop_subtree(out,lybs);
            iVar2 = ret + iVar3;
            if (iVar3 < 0) {
              iVar2 = -1;
            }
          }
          break;
        case LYS_ANYXML:
          goto switchD_0020aec3_caseD_20;
        }
        goto LAB_0020b033;
      }
    }
    else if (LVar1 == LYS_NOTIF) goto LAB_0020af8f;
  }
switchD_0020aec3_caseD_2:
  iVar2 = -1;
LAB_0020b033:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int lyb_print_data(lyout *out,lyd_node *root,int options)

{
  long lVar1;
  int iVar2;
  lys_module *plVar3;
  long in_FS_OFFSET;
  int options_local;
  lyd_node *root_local;
  lyout *out_local;
  uint8_t zero;
  int r;
  int ret;
  int rc;
  hash_table *top_sibling_ht;
  lys_module *prev_mod;
  lys_node *parent;
  lyb_state lybs;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  ret = 0;
  rc = 0;
  zero = '\0';
  top_sibling_ht = (hash_table *)0x0;
  prev_mod = (lys_module *)0x0;
  memset(&lybs,0,0x48);
  if (root != (lyd_node *)0x0) {
    plVar3 = lyd_node_module(root);
    lybs.ctx = plVar3->ctx;
    for (parent = lys_parent(root->schema);
        (parent != (lys_node *)0x0 && (parent->nodetype == LYS_USES)); parent = lys_parent(parent))
    {
    }
    if ((parent != (lys_node *)0x0) && (parent->nodetype != LYS_EXT)) {
      ly_log(lybs.ctx,LY_LLERR,LY_EINVAL,"LYB printer supports only printing top-level nodes.");
      iVar2 = 1;
      goto LAB_0020b31e;
    }
  }
  r = lyb_print_magic_number(out);
  ret = ret + r;
  if (r < 0) {
    rc = 1;
  }
  else {
    r = lyb_print_header(out);
    ret = ret + r;
    if (r < 0) {
      rc = 1;
    }
    else {
      r = lyb_print_data_models(out,root,&lybs);
      ret = ret + r;
      root_local = root;
      if (r < 0) {
        rc = 1;
      }
      else {
        for (; root_local != (lyd_node *)0x0; root_local = root_local->next) {
          plVar3 = lyd_node_module(root_local);
          if (prev_mod != plVar3) {
            top_sibling_ht = (hash_table *)0x0;
            prev_mod = lyd_node_module(root_local);
          }
          r = lyb_print_subtree(out,root_local,&top_sibling_ht,&lybs,1);
          ret = ret + r;
          if (r < 0) {
            rc = 1;
            goto LAB_0020b2b9;
          }
          if ((options & 1U) == 0) break;
        }
        r = lyb_write(out,&zero,1,&lybs);
        ret = ret + r;
        if (r < 0) {
          rc = 1;
        }
      }
    }
  }
LAB_0020b2b9:
  free(lybs.written);
  free(lybs.position);
  free(lybs.inner_chunks);
  for (r = 0; r < lybs.sib_ht_count; r = r + 1) {
    lyht_free(lybs.sib_ht[r].ht);
  }
  free(lybs.sib_ht);
  iVar2 = rc;
LAB_0020b31e:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int stat(char *__file,stat *__buf)

{
  int iVar1;
  
  iVar1 = __xstat(1,__file,__buf);
  return iVar1;
}



int fstat(int __fd,stat *__buf)

{
  int iVar1;
  
  iVar1 = __fxstat(1,__fd,__buf);
  return iVar1;
}



void _fini(void)

{
  return;
}



typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned char    dwfenc;
typedef unsigned int    dword;
typedef long double    longdouble;
typedef long long    longlong;
typedef unsigned long    qword;
typedef int    sdword;
typedef long    sqword;
typedef short    sword;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long long    uint16;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined4;
typedef unsigned long    undefined5;
typedef unsigned long    undefined6;
typedef unsigned long    undefined7;
typedef unsigned long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef struct eh_frame_hdr eh_frame_hdr, *Peh_frame_hdr;

struct eh_frame_hdr {
    byte eh_frame_hdr_version; // Exception Handler Frame Header Version
    dwfenc eh_frame_pointer_encoding; // Exception Handler Frame Pointer Encoding
    dwfenc eh_frame_desc_entry_count_encoding; // Encoding of # of Exception Handler FDEs
    dwfenc eh_frame_table_encoding; // Exception Handler Table Encoding
};

typedef struct NoteGnuPropertyElement_4 NoteGnuPropertyElement_4, *PNoteGnuPropertyElement_4;

struct NoteGnuPropertyElement_4 {
    dword prType;
    dword prDatasz;
    byte data[4];
};

typedef struct fde_table_entry fde_table_entry, *Pfde_table_entry;

struct fde_table_entry {
    dword initial_loc; // Initial Location
    dword data_loc; // Data location
};

typedef ushort sa_family_t;

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef long __off64_t;

typedef ulong size_t;

struct _IO_FILE {
    int _flags;
    char *_IO_read_ptr;
    char *_IO_read_end;
    char *_IO_read_base;
    char *_IO_write_base;
    char *_IO_write_ptr;
    char *_IO_write_end;
    char *_IO_buf_base;
    char *_IO_buf_end;
    char *_IO_save_base;
    char *_IO_backup_base;
    char *_IO_save_end;
    struct _IO_marker *_markers;
    struct _IO_FILE *_chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t *_lock;
    __off64_t _offset;
    void *__pad1;
    void *__pad2;
    void *__pad3;
    void *__pad4;
    size_t __pad5;
    int _mode;
    char _unused2[20];
};

struct _IO_marker {
    struct _IO_marker *_next;
    struct _IO_FILE *_sbuf;
    int _pos;
};

typedef struct stat stat, *Pstat;

typedef ulong __dev_t;

typedef ulong __ino_t;

typedef ulong __nlink_t;

typedef uint __mode_t;

typedef uint __uid_t;

typedef uint __gid_t;

typedef long __blksize_t;

typedef long __blkcnt_t;

typedef struct timespec timespec, *Ptimespec;

typedef long __time_t;

struct timespec {
    __time_t tv_sec;
    long tv_nsec;
};

struct stat {
    __dev_t st_dev;
    __ino_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;
    __uid_t st_uid;
    __gid_t st_gid;
    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;
    __blksize_t st_blksize;
    __blkcnt_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    long __unused[3];
};

typedef struct utsname utsname, *Putsname;

struct utsname {
    char sysname[65];
    char nodename[65];
    char release[65];
    char version[65];
    char machine[65];
    char domainname[65];
};

typedef sdword INT32;

typedef char FT_String;

typedef ulong uLong;

typedef uint FT_UInt;

typedef dword FT_UInt32;

typedef long __syscall_slong_t;

typedef ulong FSID;

typedef uint uInt;

typedef int FT_Error;

typedef int Bool;

typedef long __ssize_t;

typedef uchar BufChar;

typedef sword INT16;

typedef dword CARD32;

typedef long __fd_mask;

typedef uchar char_type;

typedef ulong Mask;

typedef int BytesReadable_t;

typedef uchar __uint8_t;

typedef long __suseconds_t;

typedef uchar Byte;

typedef word __uint16_t;

typedef ulong Atom;

typedef word CARD16;

typedef int DrawDirection;

typedef long FT_Long;

typedef long FT_F26Dot6;

typedef char FT_Char;

typedef uchar FT_Byte;

typedef ulong FT_ULong;


// WARNING! conflicting data type names: /DWARF/__off64_t - /types.h/__off64_t

typedef sdword FT_Int32;

typedef long code_int;

typedef short FT_Short;

typedef int FT_Int;

typedef dword __uint32_t;

typedef long FT_Fixed;

typedef uchar CARD8;

typedef uint __socklen_t;

typedef ushort FT_UShort;

typedef ulong XID;

typedef long FT_Pos;

typedef uchar FT_Bool;

typedef struct _Sockettrans2dev _Sockettrans2dev, *P_Sockettrans2dev;

typedef struct _Sockettrans2dev Sockettrans2dev;

struct _Sockettrans2dev {
    char *transname;
    int family;
    int devcotsname;
    int devcltsname;
    int protocol;
};

typedef struct addrlist addrlist, *Paddrlist;

typedef struct addrinfo addrinfo, *Paddrinfo;

typedef __socklen_t socklen_t;

typedef struct sockaddr sockaddr, *Psockaddr;

struct addrlist {
    struct addrinfo *addr;
    struct addrinfo *firstaddr;
    char port[32];
    char host[64];
};

struct addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr *ai_addr;
    char *ai_canonname;
    struct addrinfo *ai_next;
};

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};

typedef struct _buffile _buffile, *P_buffile;

typedef struct _buffile *BufFilePtr;

struct _buffile {
    BufChar *bufp;
    int left;
    int eof;
    BufChar buffer[8192];
    int (*input)(BufFilePtr);
    int (*output)(int, BufFilePtr);
    int (*skip)(BufFilePtr, int);
    int (*close)(BufFilePtr, int);
    char *private;
};

typedef struct _fontProp _fontProp, *P_fontProp;

typedef struct _fontProp fontProp;

typedef enum scaleType {
    atom=0,
    truncate_atom=1,
    pixel_size=2,
    point_size=3,
    resolution_x=4,
    resolution_y=5,
    average_width=6,
    scaledX=7,
    scaledY=8,
    unscaled=9,
    fontname=10,
    raw_ascent=11,
    raw_descent=12,
    raw_pixelsize=13,
    raw_pointsize=14,
    raw_average_width=15,
    uncomputed=16
} scaleType;

struct _fontProp {
    char *name;
    Atom atom;
    enum scaleType type;
};

typedef struct _Xtransport _Xtransport, *P_Xtransport;

typedef struct _XtransConnInfo _XtransConnInfo, *P_XtransConnInfo;

typedef struct _XtransConnInfo *XtransConnInfo;

typedef struct iovec iovec, *Piovec;

typedef struct _XtransConnFd _XtransConnFd, *P_XtransConnFd;

struct _Xtransport {
    char *TransName;
    int flags;
    XtransConnInfo (*OpenCOTSClient)(struct _Xtransport *, char *, char *, char *);
    int (*SetOption)(XtransConnInfo, int, int);
    int (*Connect)(XtransConnInfo, char *, char *);
    int (*BytesReadable)(XtransConnInfo, BytesReadable_t *);
    int (*Read)(XtransConnInfo, char *, int);
    int (*Write)(XtransConnInfo, char *, int);
    int (*Readv)(XtransConnInfo, struct iovec *, int);
    int (*Writev)(XtransConnInfo, struct iovec *, int);
    int (*Disconnect)(XtransConnInfo);
    int (*Close)(XtransConnInfo);
    int (*CloseForCloning)(XtransConnInfo);
};

struct iovec {
    void *iov_base;
    size_t iov_len;
};

struct _XtransConnInfo {
    struct _Xtransport *transptr;
    int index;
    char *priv;
    int flags;
    int fd;
    char *port;
    int family;
    char *addr;
    int addrlen;
    char *peeraddr;
    int peeraddrlen;
    struct _XtransConnFd *recv_fds;
    struct _XtransConnFd *send_fds;
};

struct _XtransConnFd {
};

typedef struct _Xtransport Xtransport;

typedef struct _Xtransport_table _Xtransport_table, *P_Xtransport_table;

struct _Xtransport_table {
    Xtransport *transport;
    int transport_id;
};

typedef struct _Xtransport_table Xtransport_table;

typedef enum anon_enum_32 {
    IPPROTO_IP=0,
    _SC_ARG_MAX=0,
    IPPROTO_ICMP=1,
    _ISblank=1,
    _SC_CHILD_MAX=1,
    IPPROTO_IGMP=2,
    _IScntrl=2,
    _SC_CLK_TCK=2,
    _SC_NGROUPS_MAX=3,
    IPPROTO_IPIP=4,
    _ISpunct=4,
    _SC_OPEN_MAX=4,
    _SC_STREAM_MAX=5,
    IPPROTO_TCP=6,
    _SC_TZNAME_MAX=6,
    _SC_JOB_CONTROL=7,
    IPPROTO_EGP=8,
    _ISalnum=8,
    _SC_SAVED_IDS=8,
    _SC_REALTIME_SIGNALS=9,
    _SC_PRIORITY_SCHEDULING=10,
    _SC_TIMERS=11,
    IPPROTO_PUP=12,
    _SC_ASYNCHRONOUS_IO=12,
    _SC_PRIORITIZED_IO=13,
    _SC_SYNCHRONIZED_IO=14,
    _SC_FSYNC=15,
    _SC_MAPPED_FILES=16,
    IPPROTO_UDP=17,
    _SC_MEMLOCK=17,
    _SC_MEMLOCK_RANGE=18,
    _SC_MEMORY_PROTECTION=19,
    _SC_MESSAGE_PASSING=20,
    _SC_SEMAPHORES=21,
    IPPROTO_IDP=22,
    _SC_SHARED_MEMORY_OBJECTS=22,
    _SC_AIO_LISTIO_MAX=23,
    _SC_AIO_MAX=24,
    _SC_AIO_PRIO_DELTA_MAX=25,
    _SC_DELAYTIMER_MAX=26,
    _SC_MQ_OPEN_MAX=27,
    _SC_MQ_PRIO_MAX=28,
    IPPROTO_TP=29,
    _SC_VERSION=29,
    _SC_PAGESIZE=30,
    _SC_RTSIG_MAX=31,
    _SC_SEM_NSEMS_MAX=32,
    IPPROTO_DCCP=33,
    _SC_SEM_VALUE_MAX=33,
    _SC_SIGQUEUE_MAX=34,
    _SC_TIMER_MAX=35,
    _SC_BC_BASE_MAX=36,
    _SC_BC_DIM_MAX=37,
    _SC_BC_SCALE_MAX=38,
    _SC_BC_STRING_MAX=39,
    _SC_COLL_WEIGHTS_MAX=40,
    IPPROTO_IPV6=41,
    _SC_EQUIV_CLASS_MAX=41,
    _SC_EXPR_NEST_MAX=42,
    _SC_LINE_MAX=43,
    _SC_RE_DUP_MAX=44,
    _SC_CHARCLASS_NAME_MAX=45,
    IPPROTO_RSVP=46,
    _SC_2_VERSION=46,
    IPPROTO_GRE=47,
    _SC_2_C_BIND=47,
    _SC_2_C_DEV=48,
    _SC_2_FORT_DEV=49,
    IPPROTO_ESP=50,
    _SC_2_FORT_RUN=50,
    IPPROTO_AH=51,
    _SC_2_SW_DEV=51,
    _SC_2_LOCALEDEF=52,
    _SC_PII=53,
    _SC_PII_XTI=54,
    _SC_PII_SOCKET=55,
    _SC_PII_INTERNET=56,
    _SC_PII_OSI=57,
    _SC_POLL=58,
    _SC_SELECT=59,
    _SC_IOV_MAX=60,
    _SC_UIO_MAXIOV=60,
    _SC_PII_INTERNET_STREAM=61,
    _SC_PII_INTERNET_DGRAM=62,
    _SC_PII_OSI_COTS=63,
    _SC_PII_OSI_CLTS=64,
    _SC_PII_OSI_M=65,
    _SC_T_IOV_MAX=66,
    _SC_THREADS=67,
    _SC_THREAD_SAFE_FUNCTIONS=68,
    _SC_GETGR_R_SIZE_MAX=69,
    _SC_GETPW_R_SIZE_MAX=70,
    _SC_LOGIN_NAME_MAX=71,
    _SC_TTY_NAME_MAX=72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS=73,
    _SC_THREAD_KEYS_MAX=74,
    _SC_THREAD_STACK_MIN=75,
    _SC_THREAD_THREADS_MAX=76,
    _SC_THREAD_ATTR_STACKADDR=77,
    _SC_THREAD_ATTR_STACKSIZE=78,
    _SC_THREAD_PRIORITY_SCHEDULING=79,
    _SC_THREAD_PRIO_INHERIT=80,
    _SC_THREAD_PRIO_PROTECT=81,
    _SC_THREAD_PROCESS_SHARED=82,
    _SC_NPROCESSORS_CONF=83,
    _SC_NPROCESSORS_ONLN=84,
    _SC_PHYS_PAGES=85,
    _SC_AVPHYS_PAGES=86,
    _SC_ATEXIT_MAX=87,
    _SC_PASS_MAX=88,
    _SC_XOPEN_VERSION=89,
    _SC_XOPEN_XCU_VERSION=90,
    _SC_XOPEN_UNIX=91,
    IPPROTO_MTP=92,
    _SC_XOPEN_CRYPT=92,
    _SC_XOPEN_ENH_I18N=93,
    IPPROTO_BEETPH=94,
    _SC_XOPEN_SHM=94,
    _SC_2_CHAR_TERM=95,
    _SC_2_C_VERSION=96,
    _SC_2_UPE=97,
    IPPROTO_ENCAP=98,
    _SC_XOPEN_XPG2=98,
    _SC_XOPEN_XPG3=99,
    _SC_XOPEN_XPG4=100,
    _SC_CHAR_BIT=101,
    _SC_CHAR_MAX=102,
    IPPROTO_PIM=103,
    _SC_CHAR_MIN=103,
    _SC_INT_MAX=104,
    _SC_INT_MIN=105,
    _SC_LONG_BIT=106,
    _SC_WORD_BIT=107,
    IPPROTO_COMP=108,
    _SC_MB_LEN_MAX=108,
    _SC_NZERO=109,
    _SC_SSIZE_MAX=110,
    _SC_SCHAR_MAX=111,
    _SC_SCHAR_MIN=112,
    _SC_SHRT_MAX=113,
    _SC_SHRT_MIN=114,
    _SC_UCHAR_MAX=115,
    _SC_UINT_MAX=116,
    _SC_ULONG_MAX=117,
    _SC_USHRT_MAX=118,
    _SC_NL_ARGMAX=119,
    _SC_NL_LANGMAX=120,
    _SC_NL_MSGMAX=121,
    _SC_NL_NMAX=122,
    _SC_NL_SETMAX=123,
    _SC_NL_TEXTMAX=124,
    _SC_XBS5_ILP32_OFF32=125,
    _SC_XBS5_ILP32_OFFBIG=126,
    _SC_XBS5_LP64_OFF64=127,
    _SC_XBS5_LPBIG_OFFBIG=128,
    _SC_XOPEN_LEGACY=129,
    _SC_XOPEN_REALTIME=130,
    _SC_XOPEN_REALTIME_THREADS=131,
    IPPROTO_SCTP=132,
    _SC_ADVISORY_INFO=132,
    _SC_BARRIERS=133,
    _SC_BASE=134,
    _SC_C_LANG_SUPPORT=135,
    IPPROTO_UDPLITE=136,
    _SC_C_LANG_SUPPORT_R=136,
    IPPROTO_MPLS=137,
    _SC_CLOCK_SELECTION=137,
    _SC_CPUTIME=138,
    _SC_THREAD_CPUTIME=139,
    _SC_DEVICE_IO=140,
    _SC_DEVICE_SPECIFIC=141,
    _SC_DEVICE_SPECIFIC_R=142,
    _SC_FD_MGMT=143,
    _SC_FIFO=144,
    _SC_PIPE=145,
    _SC_FILE_ATTRIBUTES=146,
    _SC_FILE_LOCKING=147,
    _SC_FILE_SYSTEM=148,
    _SC_MONOTONIC_CLOCK=149,
    _SC_MULTI_PROCESS=150,
    _SC_SINGLE_PROCESS=151,
    _SC_NETWORKING=152,
    _SC_READER_WRITER_LOCKS=153,
    _SC_SPIN_LOCKS=154,
    _SC_REGEXP=155,
    _SC_REGEX_VERSION=156,
    _SC_SHELL=157,
    _SC_SIGNALS=158,
    _SC_SPAWN=159,
    _SC_SPORADIC_SERVER=160,
    _SC_THREAD_SPORADIC_SERVER=161,
    _SC_SYSTEM_DATABASE=162,
    _SC_SYSTEM_DATABASE_R=163,
    _SC_TIMEOUTS=164,
    _SC_TYPED_MEMORY_OBJECTS=165,
    _SC_USER_GROUPS=166,
    _SC_USER_GROUPS_R=167,
    _SC_2_PBS=168,
    _SC_2_PBS_ACCOUNTING=169,
    _SC_2_PBS_LOCATE=170,
    _SC_2_PBS_MESSAGE=171,
    _SC_2_PBS_TRACK=172,
    _SC_SYMLOOP_MAX=173,
    _SC_STREAMS=174,
    _SC_2_PBS_CHECKPOINT=175,
    _SC_V6_ILP32_OFF32=176,
    _SC_V6_ILP32_OFFBIG=177,
    _SC_V6_LP64_OFF64=178,
    _SC_V6_LPBIG_OFFBIG=179,
    _SC_HOST_NAME_MAX=180,
    _SC_TRACE=181,
    _SC_TRACE_EVENT_FILTER=182,
    _SC_TRACE_INHERIT=183,
    _SC_TRACE_LOG=184,
    _SC_LEVEL1_ICACHE_SIZE=185,
    _SC_LEVEL1_ICACHE_ASSOC=186,
    _SC_LEVEL1_ICACHE_LINESIZE=187,
    _SC_LEVEL1_DCACHE_SIZE=188,
    _SC_LEVEL1_DCACHE_ASSOC=189,
    _SC_LEVEL1_DCACHE_LINESIZE=190,
    _SC_LEVEL2_CACHE_SIZE=191,
    _SC_LEVEL2_CACHE_ASSOC=192,
    _SC_LEVEL2_CACHE_LINESIZE=193,
    _SC_LEVEL3_CACHE_SIZE=194,
    _SC_LEVEL3_CACHE_ASSOC=195,
    _SC_LEVEL3_CACHE_LINESIZE=196,
    _SC_LEVEL4_CACHE_SIZE=197,
    _SC_LEVEL4_CACHE_ASSOC=198,
    _SC_LEVEL4_CACHE_LINESIZE=199,
    _SC_IPV6=235,
    _SC_RAW_SOCKETS=236,
    _SC_V7_ILP32_OFF32=237,
    _SC_V7_ILP32_OFFBIG=238,
    _SC_V7_LP64_OFF64=239,
    _SC_V7_LPBIG_OFFBIG=240,
    _SC_SS_REPL_MAX=241,
    _SC_TRACE_EVENT_NAME_MAX=242,
    _SC_TRACE_NAME_MAX=243,
    _SC_TRACE_SYS_MAX=244,
    _SC_TRACE_USER_EVENT_MAX=245,
    _SC_XOPEN_STREAMS=246,
    _SC_THREAD_ROBUST_PRIO_INHERIT=247,
    _SC_THREAD_ROBUST_PRIO_PROTECT=248,
    IPPROTO_RAW=255,
    IPPROTO_MAX=256,
    _ISupper=256,
    _ISlower=512,
    _ISalpha=1024,
    _ISdigit=2048,
    _ISxdigit=4096,
    _ISspace=8192,
    _ISprint=16384,
    _ISgraph=32768
} anon_enum_32;

typedef __ssize_t ssize_t;

typedef struct __dirstream __dirstream, *P__dirstream;

typedef struct __dirstream DIR;

struct __dirstream {
};

typedef struct dirent dirent, *Pdirent;

struct dirent {
    __ino_t d_ino;
    __off_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
};

typedef struct FT_Glyph_Metrics_ FT_Glyph_Metrics_, *PFT_Glyph_Metrics_;

typedef struct FT_Glyph_Metrics_ FT_Glyph_Metrics;

struct FT_Glyph_Metrics_ {
    FT_Pos width;
    FT_Pos height;
    FT_Pos horiBearingX;
    FT_Pos horiBearingY;
    FT_Pos horiAdvance;
    FT_Pos vertBearingX;
    FT_Pos vertBearingY;
    FT_Pos vertAdvance;
};

typedef struct FT_CharMapRec_ FT_CharMapRec_, *PFT_CharMapRec_;

typedef struct FT_FaceRec_ FT_FaceRec_, *PFT_FaceRec_;

typedef struct FT_FaceRec_ *FT_Face;

typedef enum FT_Encoding_ {
    FT_ENCODING_NONE=0,
    FT_ENCODING_ADOBE_CUSTOM=1094992451,
    FT_ENCODING_ADOBE_EXPERT=1094992453,
    FT_ENCODING_ADOBE_STANDARD=1094995778,
    FT_ENCODING_APPLE_ROMAN=1634889070,
    FT_ENCODING_BIG5=1651074869,
    FT_ENCODING_MS_BIG5=1651074869,
    FT_ENCODING_GB2312=1734484000,
    FT_ENCODING_MS_GB2312=1734484000,
    FT_ENCODING_PRC=1734484000,
    FT_ENCODING_JOHAB=1785686113,
    FT_ENCODING_MS_JOHAB=1785686113,
    FT_ENCODING_ADOBE_LATIN_1=1818326065,
    FT_ENCODING_OLD_LATIN_2=1818326066,
    FT_ENCODING_MS_SJIS=1936353651,
    FT_ENCODING_SJIS=1936353651,
    FT_ENCODING_MS_SYMBOL=1937337698,
    FT_ENCODING_UNICODE=1970170211,
    FT_ENCODING_MS_WANSUNG=2002873971,
    FT_ENCODING_WANSUNG=2002873971
} FT_Encoding_;

typedef enum FT_Encoding_ FT_Encoding;

typedef struct FT_Bitmap_Size_ FT_Bitmap_Size_, *PFT_Bitmap_Size_;

typedef struct FT_Bitmap_Size_ FT_Bitmap_Size;

typedef struct FT_CharMapRec_ *FT_CharMap;

typedef struct FT_Generic_ FT_Generic_, *PFT_Generic_;

typedef struct FT_Generic_ FT_Generic;

typedef struct FT_BBox_ FT_BBox_, *PFT_BBox_;

typedef struct FT_BBox_ FT_BBox;

typedef struct FT_GlyphSlotRec_ FT_GlyphSlotRec_, *PFT_GlyphSlotRec_;

typedef struct FT_GlyphSlotRec_ *FT_GlyphSlot.conflict;

typedef struct FT_SizeRec_ FT_SizeRec_, *PFT_SizeRec_;

typedef struct FT_SizeRec_ *FT_Size;

typedef struct FT_DriverRec_ FT_DriverRec_, *PFT_DriverRec_;

typedef struct FT_DriverRec_ *FT_Driver;

typedef struct FT_MemoryRec_ FT_MemoryRec_, *PFT_MemoryRec_;

typedef struct FT_MemoryRec_ *FT_Memory.conflict;

typedef struct FT_StreamRec_ FT_StreamRec_, *PFT_StreamRec_;

typedef struct FT_StreamRec_ *FT_Stream.conflict;

typedef struct FT_ListRec_ FT_ListRec_, *PFT_ListRec_;

typedef struct FT_ListRec_ FT_ListRec;

typedef struct FT_Face_InternalRec_ FT_Face_InternalRec_, *PFT_Face_InternalRec_;

typedef struct FT_Face_InternalRec_ *FT_Face_Internal;

typedef void (*FT_Generic_Finalizer)(void *);

typedef struct FT_LibraryRec_ FT_LibraryRec_, *PFT_LibraryRec_;

typedef struct FT_LibraryRec_ *FT_Library;

typedef struct FT_GlyphSlotRec_ *FT_GlyphSlot;

typedef struct FT_Vector_ FT_Vector_, *PFT_Vector_;

typedef struct FT_Vector_ FT_Vector;

typedef enum FT_Glyph_Format_ {
    FT_GLYPH_FORMAT_NONE=0,
    FT_GLYPH_FORMAT_BITMAP=1651078259,
    FT_GLYPH_FORMAT_COMPOSITE=1668246896,
    FT_GLYPH_FORMAT_OUTLINE=1869968492,
    FT_GLYPH_FORMAT_PLOTTER=1886154612
} FT_Glyph_Format_;

typedef enum FT_Glyph_Format_ FT_Glyph_Format;

typedef struct FT_Bitmap_ FT_Bitmap_, *PFT_Bitmap_;

typedef struct FT_Bitmap_ FT_Bitmap;

typedef struct FT_Outline_ FT_Outline_, *PFT_Outline_;

typedef struct FT_Outline_ FT_Outline;

typedef struct FT_SubGlyphRec_ FT_SubGlyphRec_, *PFT_SubGlyphRec_;

typedef struct FT_SubGlyphRec_ *FT_SubGlyph;

typedef struct FT_Slot_InternalRec_ FT_Slot_InternalRec_, *PFT_Slot_InternalRec_;

typedef struct FT_Slot_InternalRec_ *FT_Slot_Internal;

typedef struct FT_Size_Metrics_ FT_Size_Metrics_, *PFT_Size_Metrics_;

typedef struct FT_Size_Metrics_ FT_Size_Metrics;

typedef struct FT_Size_InternalRec_ FT_Size_InternalRec_, *PFT_Size_InternalRec_;

typedef struct FT_Size_InternalRec_ *FT_Size_Internal;

typedef struct FT_MemoryRec_ *FT_Memory;

typedef void * (*FT_Alloc_Func)(FT_Memory, long);

typedef void (*FT_Free_Func)(FT_Memory, void *);

typedef void * (*FT_Realloc_Func)(FT_Memory, long, long, void *);

typedef union FT_StreamDesc_ FT_StreamDesc_, *PFT_StreamDesc_;

typedef union FT_StreamDesc_ FT_StreamDesc;

typedef struct FT_StreamRec_ *FT_Stream;

typedef ulong (*FT_Stream_IoFunc)(FT_Stream, ulong, uchar *, ulong);

typedef void (*FT_Stream_CloseFunc)(FT_Stream);

typedef struct FT_ListNodeRec_ FT_ListNodeRec_, *PFT_ListNodeRec_;

typedef struct FT_ListNodeRec_ *FT_ListNode.conflict;

typedef struct FT_ListNodeRec_ *FT_ListNode;

struct FT_BBox_ {
    FT_Pos xMin;
    FT_Pos yMin;
    FT_Pos xMax;
    FT_Pos yMax;
};

struct FT_Generic_ {
    void *data;
    FT_Generic_Finalizer finalizer;
};

struct FT_ListRec_ {
    FT_ListNode.conflict head;
    FT_ListNode.conflict tail;
};

struct FT_FaceRec_ {
    FT_Long num_faces;
    FT_Long face_index;
    FT_Long face_flags;
    FT_Long style_flags;
    FT_Long num_glyphs;
    FT_String *family_name;
    FT_String *style_name;
    FT_Int num_fixed_sizes;
    FT_Bitmap_Size *available_sizes;
    FT_Int num_charmaps;
    FT_CharMap *charmaps;
    FT_Generic generic;
    FT_BBox bbox;
    FT_UShort units_per_EM;
    FT_Short ascender;
    FT_Short descender;
    FT_Short height;
    FT_Short max_advance_width;
    FT_Short max_advance_height;
    FT_Short underline_position;
    FT_Short underline_thickness;
    FT_GlyphSlot.conflict glyph;
    FT_Size size;
    FT_CharMap charmap;
    FT_Driver driver;
    FT_Memory.conflict memory;
    FT_Stream.conflict stream;
    FT_ListRec sizes_list;
    FT_Generic autohint;
    void *extensions;
    FT_Face_Internal internal;
};

struct FT_SubGlyphRec_ {
};

struct FT_Bitmap_ {
    uint rows;
    uint width;
    int pitch;
    uchar *buffer;
    ushort num_grays;
    uchar pixel_mode;
    uchar palette_mode;
    void *palette;
};

union FT_StreamDesc_ {
    long value;
    void *pointer;
};

struct FT_Bitmap_Size_ {
    FT_Short height;
    FT_Short width;
    FT_Pos size;
    FT_Pos x_ppem;
    FT_Pos y_ppem;
};

struct FT_Slot_InternalRec_ {
};

struct FT_CharMapRec_ {
    FT_Face face;
    FT_Encoding encoding;
    FT_UShort platform_id;
    FT_UShort encoding_id;
};

struct FT_Size_InternalRec_ {
};

struct FT_DriverRec_ {
};

struct FT_Size_Metrics_ {
    FT_UShort x_ppem;
    FT_UShort y_ppem;
    FT_Fixed x_scale;
    FT_Fixed y_scale;
    FT_Pos ascender;
    FT_Pos descender;
    FT_Pos height;
    FT_Pos max_advance;
};

struct FT_StreamRec_ {
    uchar *base;
    ulong size;
    ulong pos;
    FT_StreamDesc descriptor;
    FT_StreamDesc pathname;
    FT_Stream_IoFunc read;
    FT_Stream_CloseFunc close;
    FT_Memory.conflict memory;
    uchar *cursor;
    uchar *limit;
};

struct FT_LibraryRec_ {
};

struct FT_Vector_ {
    FT_Pos x;
    FT_Pos y;
};

struct FT_ListNodeRec_ {
    FT_ListNode prev;
    FT_ListNode next;
    void *data;
};

struct FT_Outline_ {
    short n_contours;
    short n_points;
    FT_Vector *points;
    char *tags;
    short *contours;
    int flags;
};

struct FT_GlyphSlotRec_ {
    FT_Library library;
    FT_Face face;
    FT_GlyphSlot next;
    FT_UInt glyph_index;
    FT_Generic generic;
    FT_Glyph_Metrics metrics;
    FT_Fixed linearHoriAdvance;
    FT_Fixed linearVertAdvance;
    FT_Vector advance;
    FT_Glyph_Format format;
    FT_Bitmap bitmap;
    FT_Int bitmap_left;
    FT_Int bitmap_top;
    FT_Outline outline;
    FT_UInt num_subglyphs;
    FT_SubGlyph subglyphs;
    void *control_data;
    long control_len;
    FT_Pos lsb_delta;
    FT_Pos rsb_delta;
    void *other;
    FT_Slot_Internal internal;
};

struct FT_SizeRec_ {
    FT_Face face;
    FT_Generic generic;
    FT_Size_Metrics metrics;
    FT_Size_Internal internal;
};

struct FT_MemoryRec_ {
    void *user;
    FT_Alloc_Func alloc;
    FT_Free_Func free;
    FT_Realloc_Func realloc;
};

struct FT_Face_InternalRec_ {
};

typedef struct FT_FaceRec_ *FT_Face.conflict;

typedef enum FT_Render_Mode_ {
    FT_RENDER_MODE_NORMAL=0,
    FT_RENDER_MODE_LIGHT=1,
    FT_RENDER_MODE_MONO=2,
    FT_RENDER_MODE_LCD=3,
    FT_RENDER_MODE_LCD_V=4,
    FT_RENDER_MODE_MAX=5
} FT_Render_Mode_;

typedef struct _LFWIData.conflict _LFWIData.conflict, *P_LFWIData.conflict;

typedef void *pointer;

struct _LFWIData.conflict {
    pointer *privates;
    int current;
};

typedef struct _CatalogueRec _CatalogueRec, *P_CatalogueRec;

typedef struct _CatalogueRec *CataloguePtr;

typedef __time_t time_t;

typedef struct _FontPathElement _FontPathElement, *P_FontPathElement;

typedef struct _FontPathElement *FontPathElementPtr;

struct _FontPathElement {
    int name_length;
    char *name;
    int type;
    int refcount;
    void *private;
};

struct _CatalogueRec {
    time_t mtime;
    int fpeCount;
    int fpeAlloc;
    FontPathElementPtr *fpeList;
};

typedef struct _LFWIData.conflict *LFWIDataPtr.conflict;

typedef struct _AtomList _AtomList, *P_AtomList;

typedef struct _AtomList *AtomListPtr;

struct _AtomList {
    char *name;
    int len;
    int hash;
    Atom atom;
};

typedef CARD8 BOOL;

typedef CARD8 BYTE;

typedef struct SPropertyRecord SPropertyRecord, *PSPropertyRecord;

typedef enum ERecType {
    eRecTypeVoid=-1,
    eRecTypeInteger=0,
    eRecTypeDouble=1,
    eRecTypeBool=2,
    eRecTypeString=3
} ERecType;

struct SPropertyRecord {
    char *strRecordName;
    enum ERecType recordType;
};

typedef struct anon_struct_16_2_4c3f4b95 anon_struct_16_2_4c3f4b95, *Panon_struct_16_2_4c3f4b95;

typedef struct anon_struct_16_2_4c3f4b95 *SPropRecValContainer;

typedef union anon_union_8_4_c4d4a926_for_uValue anon_union_8_4_c4d4a926_for_uValue, *Panon_union_8_4_c4d4a926_for_uValue;

union anon_union_8_4_c4d4a926_for_uValue {
    int integerValue;
    double doubleValue;
    Bool boolValue;
    char *dynStringValue;
};

struct anon_struct_16_2_4c3f4b95 {
    struct SPropertyRecord *refRecordType;
    union anon_union_8_4_c4d4a926_for_uValue uValue;
};

typedef struct SPropRecValContainerEntityP SPropRecValContainerEntityP, *PSPropRecValContainerEntityP;

struct SPropRecValContainerEntityP {
    struct SPropertyRecord *refRecordType;
    union anon_union_8_4_c4d4a926_for_uValue uValue;
};

typedef struct SDynPropRecValList SDynPropRecValList, *PSDynPropRecValList;

typedef struct TagSPropRecValListNodeP TagSPropRecValListNodeP, *PTagSPropRecValListNodeP;

typedef struct TagSPropRecValListNodeP SPropRecValListNode;

struct SDynPropRecValList {
    SPropRecValListNode *headNode;
};

struct TagSPropRecValListNodeP {
    struct SPropRecValContainerEntityP containerE;
    struct TagSPropRecValListNodeP *nextNode;
};

typedef struct SDynPropRecValList SRefPropRecValList;

typedef struct __va_list_tag __va_list_tag, *P__va_list_tag;

struct __va_list_tag {
    uint gp_offset;
    uint fp_offset;
    void *overflow_arg_area;
    void *reg_save_area;
};

typedef struct __va_list_tag __builtin_va_list[1];

typedef __builtin_va_list __gnuc_va_list;

typedef struct _FTFont _FTFont, *P_FTFont;

typedef struct _FTInstance _FTInstance, *P_FTInstance;

typedef struct _FTInstance *FTInstancePtr;

typedef struct _FTMapping _FTMapping, *P_FTMapping;

typedef struct _FTMapping FTMappingRec;

typedef struct _FontInfo _FontInfo, *P_FontInfo;

typedef struct _FontInfo *FontInfoPtr;

typedef struct _CharInfo _CharInfo, *P_CharInfo;

typedef struct _CharInfo CharInfoRec;

typedef struct fsRange fsRange, *PfsRange;

typedef struct _FTFace _FTFace, *P_FTFace;

typedef struct _FTFace *FTFacePtr;

typedef struct _FTNormalisedTransformation _FTNormalisedTransformation, *P_FTNormalisedTransformation;

typedef struct _FTNormalisedTransformation FTNormalisedTransformationRec;

typedef struct xCharInfo xCharInfo, *PxCharInfo;

typedef struct FontBitmapFormatRec FontBitmapFormatRec, *PFontBitmapFormatRec;

typedef struct _CharInfo *CharInfoPtr;

typedef struct TTCapInfo TTCapInfo, *PTTCapInfo;

typedef struct _FontMap _FontMap, *P_FontMap;

typedef struct _FontProp _FontProp, *P_FontProp;

typedef struct _FontProp *FontPropPtr;

typedef struct FT_Matrix_ FT_Matrix_, *PFT_Matrix_;

typedef struct FT_Matrix_ FT_Matrix;

typedef struct _FontEnc _FontEnc, *P_FontEnc;

typedef struct _FontMap *FontMapPtr;

struct xCharInfo {
    INT16 leftSideBearing;
    INT16 rightSideBearing;
    INT16 characterWidth;
    INT16 ascent;
    INT16 descent;
    CARD16 attributes;
};

struct _CharInfo {
    struct xCharInfo metrics;
    char *bits;
};

struct TTCapInfo {
    long flags;
    double autoItalic;
    double scaleWidth;
    double scaleBBoxWidth;
    double scaleBBoxHeight;
    int doubleStrikeShift;
    int adjustBBoxWidthByPixel;
    int adjustLeftSideBearingByPixel;
    int adjustRightSideBearingByPixel;
    double scaleBitmap;
    int forceConstantSpacingBegin;
    int forceConstantSpacingEnd;
    int force_c_adjust_width_by_pixel;
    int force_c_adjust_lsb_by_pixel;
    int force_c_adjust_rsb_by_pixel;
    int force_c_representative_metrics_char_code;
    double force_c_scale_b_box_width;
    double force_c_scale_b_box_height;
    double force_c_scale_lsb;
    double force_c_scale_rsb;
    double vl_slant;
    int lsbShiftOfBitmapAutoItalic;
    int rsbShiftOfBitmapAutoItalic;
};

struct _FTFace {
    char *filename;
    FT_Face face;
    int bitmap;
    FT_UInt num_hmetrics;
    struct _FTInstance *instances;
    struct _FTInstance *active_instance;
    struct _FTFace *next;
};

struct FT_Matrix_ {
    FT_Fixed xx;
    FT_Fixed xy;
    FT_Fixed yx;
    FT_Fixed yy;
};

struct _FTNormalisedTransformation {
    double scale;
    int nonIdentity;
    FT_Matrix matrix;
    int xres;
    int yres;
};

struct FontBitmapFormatRec {
    int bit;
    int byte;
    int glyph;
    int scan;
};

struct _FTMapping {
    int named;
    FT_CharMap cmap;
    int base;
    struct _FontMap *mapping;
};

struct _FTFont {
    FTInstancePtr instance;
    FTMappingRec mapping;
    uint zero_idx;
    FontInfoPtr info;
    int nranges;
    CharInfoRec dummy_char;
    struct fsRange *ranges;
};

struct _FontInfo {
    ushort firstCol;
    ushort lastCol;
    ushort firstRow;
    ushort lastRow;
    ushort defaultCh;
    uint noOverlap:1;
    uint terminalFont:1;
    uint constantMetrics:1;
    uint constantWidth:1;
    uint inkInside:1;
    uint inkMetrics:1;
    uint allExist:1;
    uint drawDirection:2;
    uint cachable:1;
    uint anamorphic:1;
    short maxOverlap;
    short pad;
    struct xCharInfo maxbounds;
    struct xCharInfo minbounds;
    struct xCharInfo ink_maxbounds;
    struct xCharInfo ink_minbounds;
    short fontAscent;
    short fontDescent;
    int nprops;
    FontPropPtr props;
    char *isStringProp;
};

struct _FontProp {
    long name;
    long value;
};

struct _FTInstance {
    FTFacePtr face;
    FT_Size size;
    FTNormalisedTransformationRec transformation;
    FT_Int32 load_flags;
    FT_ULong strike_index;
    int spacing;
    double pixel_size;
    double pixel_width_unit_x;
    double pixel_width_unit_y;
    struct xCharInfo *charcellMetrics;
    int averageWidth;
    long rawAverageWidth;
    double advance;
    struct xCharInfo *forceConstantMetrics;
    struct FontBitmapFormatRec bmfmt;
    uint nglyphs;
    CharInfoPtr *glyphs;
    int **available;
    struct TTCapInfo ttcap;
    int refcount;
    struct _FTInstance *next;
};

struct fsRange {
    CARD8 min_char_high;
    CARD8 min_char_low;
    CARD8 max_char_high;
    CARD8 max_char_low;
};

struct _FontEnc {
    char *name;
    char **aliases;
    int size;
    int row_size;
    FontMapPtr mappings;
    struct _FontEnc *next;
    int first;
    int first_col;
};

struct _FontMap {
    int type;
    int pid;
    int eid;
    uint (*recode)(uint, void *);
    char * (*name)(uint, void *);
    void *client_data;
    struct _FontMap *next;
    struct _FontEnc *encoding;
};

typedef struct _FTFont *FTFontPtr;

typedef struct _FTNormalisedTransformation *FTNormalisedTransformationPtr;

typedef struct FontBitmapFormatRec *FontBitmapFormatPtr;

typedef struct FT_SfntName_ FT_SfntName_, *PFT_SfntName_;

typedef struct FT_SfntName_ FT_SfntName;

struct FT_SfntName_ {
    FT_UShort platform_id;
    FT_UShort encoding_id;
    FT_UShort language_id;
    FT_UShort name_id;
    FT_Byte *string;
    FT_UInt string_len;
};

typedef struct _BuiltinFile _BuiltinFile, *P_BuiltinFile;

typedef struct _BuiltinFile *BuiltinFilePtr;

struct _BuiltinFile {
    char *name;
    int len;
    char *bits;
};

typedef struct _BuiltinAlias _BuiltinAlias, *P_BuiltinAlias;

typedef struct _BuiltinAlias *BuiltinAliasPtr;

struct _BuiltinAlias {
    char *alias_name;
    char *font_name;
};

typedef struct _BuiltinAlias BuiltinAliasRec;

typedef struct _BuiltinDir _BuiltinDir, *P_BuiltinDir;

typedef struct _BuiltinDir BuiltinDirRec;

struct _BuiltinDir {
    char *file_name;
    char *font_name;
};

typedef struct _BuiltinFile BuiltinFileRec;

typedef struct _BuiltinDir *BuiltinDirPtr;

typedef struct fsPropInfo fsPropInfo, *PfsPropInfo;

struct fsPropInfo {
    CARD32 num_offsets;
    CARD32 data_len;
};

typedef struct fsOffset32 fsOffset32, *PfsOffset32;

struct fsOffset32 {
    CARD32 position;
    CARD32 length;
};

typedef struct fsReq fsReq, *PfsReq;

typedef struct fsReq fsNoopReq;

struct fsReq {
    CARD8 reqType;
    CARD8 data;
    CARD16 length;
};

typedef struct fsQueryXBitmaps8Req fsQueryXBitmaps8Req, *PfsQueryXBitmaps8Req;

typedef CARD32 fsBitmapFormat;

struct fsQueryXBitmaps8Req {
    CARD8 reqType;
    BOOL range;
    CARD16 length;
    CARD32 fid;
    fsBitmapFormat format;
    CARD32 num_ranges;
};

typedef struct fsQueryXExtents8Reply fsQueryXExtents8Reply, *PfsQueryXExtents8Reply;

typedef struct fsQueryXExtents8Reply fsQueryXExtents16Reply;

struct fsQueryXExtents8Reply {
    BYTE type;
    CARD8 pad0;
    CARD16 sequenceNumber;
    CARD32 length;
    CARD32 num_extents;
};

typedef struct fsConnClientPrefix fsConnClientPrefix, *PfsConnClientPrefix;

struct fsConnClientPrefix {
    BYTE byteOrder;
    CARD8 num_auths;
    CARD16 major_version;
    CARD16 minor_version;
    CARD16 auth_len;
};

typedef struct fsGenericReply fsGenericReply, *PfsGenericReply;

struct fsGenericReply {
    BYTE type;
    BYTE data1;
    CARD16 sequenceNumber;
    CARD32 length;
};

typedef struct fsResourceReq fsResourceReq, *PfsResourceReq;

typedef struct fsResourceReq fsCloseReq;

struct fsResourceReq {
    CARD8 reqType;
    BYTE pad;
    CARD16 length;
    CARD32 id;
};

typedef struct fsOpenBitmapFontReq fsOpenBitmapFontReq, *PfsOpenBitmapFontReq;

typedef CARD32 fsBitmapFormatMask;

struct fsOpenBitmapFontReq {
    CARD8 reqType;
    BYTE pad;
    CARD16 length;
    CARD32 fid;
    fsBitmapFormatMask format_mask;
    fsBitmapFormat format_hint;
};

typedef CARD32 fsTimestamp;

typedef struct fsListCataloguesReq fsListCataloguesReq, *PfsListCataloguesReq;

struct fsListCataloguesReq {
    CARD8 reqType;
    CARD8 data;
    CARD16 length;
    CARD32 maxNames;
    CARD16 nbytes;
    CARD16 pad2;
};

typedef struct fsResourceReq fsFreeACReq;

typedef struct fsConnSetup fsConnSetup, *PfsConnSetup;

struct fsConnSetup {
    CARD16 status;
    CARD16 major_version;
    CARD16 minor_version;
    CARD8 num_alternates;
    CARD8 auth_index;
    CARD16 alternate_len;
    CARD16 auth_len;
};

typedef struct fsResourceReq fsQueryXInfoReq;

typedef struct fsOpenBitmapFontReply fsOpenBitmapFontReply, *PfsOpenBitmapFontReply;

struct fsOpenBitmapFontReply {
    BYTE type;
    CARD8 otherid_valid;
    CARD16 sequenceNumber;
    CARD32 length;
    CARD32 otherid;
    BYTE cachable;
    BYTE pad1;
    CARD16 pad2;
};

typedef struct fsQueryXInfoReply fsQueryXInfoReply, *PfsQueryXInfoReply;

struct fsQueryXInfoReply {
    BYTE type;
    CARD8 pad0;
    CARD16 sequenceNumber;
    CARD32 length;
    CARD32 font_header_flags;
    CARD8 font_hdr_char_range_min_char_high;
    CARD8 font_hdr_char_range_min_char_low;
    CARD8 font_hdr_char_range_max_char_high;
    CARD8 font_hdr_char_range_max_char_low;
    CARD8 font_header_draw_direction;
    CARD8 font_header_pad;
    CARD8 font_header_default_char_high;
    CARD8 font_header_default_char_low;
    INT16 font_header_min_bounds_left;
    INT16 font_header_min_bounds_right;
    INT16 font_header_min_bounds_width;
    INT16 font_header_min_bounds_ascent;
    INT16 font_header_min_bounds_descent;
    CARD16 font_header_min_bounds_attributes;
    INT16 font_header_max_bounds_left;
    INT16 font_header_max_bounds_right;
    INT16 font_header_max_bounds_width;
    INT16 font_header_max_bounds_ascent;
    INT16 font_header_max_bounds_descent;
    CARD16 font_header_max_bounds_attributes;
    INT16 font_header_font_ascent;
    INT16 font_header_font_descent;
};

typedef struct fsQueryXBitmaps8Reply fsQueryXBitmaps8Reply, *PfsQueryXBitmaps8Reply;

struct fsQueryXBitmaps8Reply {
    BYTE type;
    CARD8 pad0;
    CARD16 sequenceNumber;
    CARD32 length;
    CARD32 replies_hint;
    CARD32 num_chars;
    CARD32 nbytes;
};

typedef struct fsListFontsWithXInfoReply fsListFontsWithXInfoReply, *PfsListFontsWithXInfoReply;

struct fsListFontsWithXInfoReply {
    BYTE type;
    CARD8 nameLength;
    CARD16 sequenceNumber;
    CARD32 length;
    CARD32 nReplies;
    CARD32 font_header_flags;
    CARD8 font_hdr_char_range_min_char_high;
    CARD8 font_hdr_char_range_min_char_low;
    CARD8 font_hdr_char_range_max_char_high;
    CARD8 font_hdr_char_range_max_char_low;
    CARD8 font_header_draw_direction;
    CARD8 font_header_pad;
    CARD8 font_header_default_char_high;
    CARD8 font_header_default_char_low;
    INT16 font_header_min_bounds_left;
    INT16 font_header_min_bounds_right;
    INT16 font_header_min_bounds_width;
    INT16 font_header_min_bounds_ascent;
    INT16 font_header_min_bounds_descent;
    CARD16 font_header_min_bounds_attributes;
    INT16 font_header_max_bounds_left;
    INT16 font_header_max_bounds_right;
    INT16 font_header_max_bounds_width;
    INT16 font_header_max_bounds_ascent;
    INT16 font_header_max_bounds_descent;
    CARD16 font_header_max_bounds_attributes;
    INT16 font_header_font_ascent;
    INT16 font_header_font_descent;
};

typedef struct fsQueryXExtents8Req fsQueryXExtents8Req, *PfsQueryXExtents8Req;

struct fsQueryXExtents8Req {
    CARD8 reqType;
    BOOL range;
    CARD16 length;
    CARD32 fid;
    CARD32 num_ranges;
};

typedef struct fsQueryXBitmaps8Reply fsQueryXBitmaps16Reply;

typedef struct fsError fsError, *PfsError;

struct fsError {
    BYTE type;
    BYTE request;
    CARD16 sequenceNumber;
    CARD32 length;
    fsTimestamp timestamp;
    CARD8 major_opcode;
    CARD8 minor_opcode;
    CARD16 pad;
};

typedef struct fsConnSetupAccept fsConnSetupAccept, *PfsConnSetupAccept;

struct fsConnSetupAccept {
    CARD32 length;
    CARD16 max_request_len;
    CARD16 vendor_len;
    CARD32 release_number;
};

typedef struct fsQueryXExtents8Req fsQueryXExtents16Req;

typedef struct fsListFontsReply fsListFontsReply, *PfsListFontsReply;

struct fsListFontsReply {
    BYTE type;
    BYTE pad1;
    CARD16 sequenceNumber;
    CARD32 length;
    CARD32 following;
    CARD32 nFonts;
};

typedef struct fsCreateACReq fsCreateACReq, *PfsCreateACReq;

struct fsCreateACReq {
    CARD8 reqType;
    BYTE num_auths;
    CARD16 length;
    CARD32 acid;
};

typedef struct fsSetCataloguesReq fsSetCataloguesReq, *PfsSetCataloguesReq;

struct fsSetCataloguesReq {
    CARD8 reqType;
    BYTE num_catalogues;
    CARD16 length;
};

typedef struct fsListFontsReq fsListFontsReq, *PfsListFontsReq;

typedef struct fsListFontsReq fsListFontsWithXInfoReq;

struct fsListFontsReq {
    CARD8 reqType;
    BYTE pad;
    CARD16 length;
    CARD32 maxNames;
    CARD16 nbytes;
    CARD16 pad2;
};

typedef struct fsPropOffset fsPropOffset, *PfsPropOffset;

struct fsPropOffset {
    struct fsOffset32 name;
    struct fsOffset32 value;
    CARD8 type;
    BYTE pad0;
    CARD16 pad1;
};

typedef struct fsXCharInfo fsXCharInfo, *PfsXCharInfo;

struct fsXCharInfo {
    INT16 left;
    INT16 right;
    INT16 width;
    INT16 ascent;
    INT16 descent;
    CARD16 attributes;
};

typedef struct fsResourceReq fsSetAuthorizationReq;

typedef struct fsQueryXBitmaps8Req fsQueryXBitmaps16Req;

typedef struct fsSetResolutionReq fsSetResolutionReq, *PfsSetResolutionReq;

struct fsSetResolutionReq {
    CARD8 reqType;
    BYTE num_resolutions;
    CARD16 length;
};

typedef struct anon_struct_16_2_de606a05 anon_struct_16_2_de606a05, *Panon_struct_16_2_de606a05;

struct anon_struct_16_2_de606a05 {
    char *capVariable;
    char *recordName;
};

typedef struct TagSPropRecValListNodeP SPropRecValListNodeP;

typedef BufFilePtr FontFilePtr;

typedef struct _fs_block_data _fs_block_data, *P_fs_block_data;

struct _fs_block_data {
    int type;
    pointer client;
    CARD16 sequenceNumber;
    pointer data;
    int errcode;
    struct _fs_block_data *depending;
    struct _fs_block_data *next;
};

typedef struct fs_clients_depending fs_clients_depending, *Pfs_clients_depending;

struct fs_clients_depending {
    pointer client;
    struct fs_clients_depending *next;
};

typedef struct fs_clients_depending *FSClientsDependingPtr;

typedef struct _fs_blocked_glyphs _fs_blocked_glyphs, *P_fs_blocked_glyphs;

typedef struct _Font _Font, *P_Font;

typedef enum FontEncoding {
    Linear8Bit=0,
    TwoD8Bit=1,
    Linear16Bit=2,
    TwoD16Bit=3
} FontEncoding;

typedef struct _Font *FontPtr;

typedef struct _FontInfo FontInfoRec;

struct _fs_blocked_glyphs {
    FontPtr pfont;
    int num_expected_ranges;
    struct fsRange *expected_ranges;
    FSClientsDependingPtr clients_depending;
};

struct _Font {
    int refcnt;
    FontInfoRec info;
    char bit;
    char byte;
    char glyph;
    char scan;
    fsBitmapFormat format;
    int (*get_glyphs)(FontPtr, ulong, uchar *, enum FontEncoding, ulong *, CharInfoPtr *);
    int (*get_metrics)(FontPtr, ulong, uchar *, enum FontEncoding, ulong *, struct xCharInfo **);
    void (*unload_font)(FontPtr);
    void (*unload_glyphs)(FontPtr);
    FontPathElementPtr fpe;
    void *svrPrivate;
    void *fontPrivate;
    void *fpePrivate;
    int maxPrivate;
    void **devPrivates;
};

typedef struct _fs_blocked_list _fs_blocked_list, *P_fs_blocked_list;

typedef struct _FontNames _FontNames, *P_FontNames;

typedef struct _FontNames *FontNamesPtr;

struct _FontNames {
    int nnames;
    int size;
    int *length;
    char **names;
};

struct _fs_blocked_list {
    FontNamesPtr names;
};

typedef struct _fs_blocked_list_info _fs_blocked_list_info, *P_fs_blocked_list_info;

struct _fs_blocked_list_info {
    int status;
    int namelen;
    FontInfoRec info;
    char name[256];
    int remaining;
};

typedef struct _fs_font _fs_font, *P_fs_font;

typedef struct _fs_font *FSFontPtr;

typedef struct _fs_glyph _fs_glyph, *P_fs_glyph;

typedef struct _fs_glyph *FSGlyphPtr;

struct _fs_font {
    CharInfoPtr pDefault;
    CharInfoPtr encoding;
    CharInfoPtr inkMetrics;
    FSGlyphPtr glyphs;
};

struct _fs_glyph {
    struct _fs_glyph *next;
};

typedef struct _fs_font_data _fs_font_data, *P_fs_font_data;

struct _fs_font_data {
    long fontid;
    int generation;
    ulong glyphs_to_get;
    int namelen;
    char *name;
    fsBitmapFormat format;
    fsBitmapFormatMask fmask;
};

typedef struct _fs_font_data FSFontDataRec;

typedef struct _fs_blocked_font _fs_blocked_font, *P_fs_blocked_font;

struct _fs_blocked_font {
    FontPtr pfont;
    long fontid;
    int state;
    int flags;
    Bool freeFont;
    CARD16 queryInfoSequence;
    CARD16 queryExtentsSequence;
    CARD16 queryBitmapsSequence;
    fsBitmapFormat format;
    FSClientsDependingPtr clients_depending;
};

typedef enum __socket_type {
    SOCK_STREAM=1,
    SOCK_DGRAM=2,
    SOCK_RAW=3,
    SOCK_RDM=4,
    SOCK_SEQPACKET=5,
    SOCK_DCCP=6,
    SOCK_PACKET=10,
    SOCK_NONBLOCK=2048,
    SOCK_CLOEXEC=524288
} __socket_type;

typedef __gnuc_va_list va_list;

typedef struct sockaddr_storage sockaddr_storage, *Psockaddr_storage;

struct sockaddr_storage {
    sa_family_t ss_family;
    char __ss_padding[118];
    ulong __ss_align;
};

typedef struct _PCFTable _PCFTable, *P_PCFTable;

struct _PCFTable {
    CARD32 type;
    CARD32 format;
    CARD32 size;
    CARD32 offset;
};

typedef struct _PCFTable *PCFTablePtr;

typedef struct _PCFTable PCFTableRec;

typedef void *voidpf;

typedef voidpf (*alloc_func)(voidpf, uInt, uInt);

typedef struct z_stream_s z_stream_s, *Pz_stream_s;

typedef struct z_stream_s z_stream;

typedef Byte Bytef;

typedef struct internal_state internal_state, *Pinternal_state;

typedef void (*free_func)(voidpf, voidpf);

struct internal_state {
};

struct z_stream_s {
    Bytef *next_in;
    uInt avail_in;
    uLong total_in;
    Bytef *next_out;
    uInt avail_out;
    uLong total_out;
    char *msg;
    struct internal_state *state;
    alloc_func zalloc;
    free_func zfree;
    voidpf opaque;
    int data_type;
    uLong adler;
    uLong reserved;
};

typedef struct PS_FontInfoRec_ PS_FontInfoRec_, *PPS_FontInfoRec_;

struct PS_FontInfoRec_ {
    FT_String *version;
    FT_String *notice;
    FT_String *full_name;
    FT_String *family_name;
    FT_String *weight;
    FT_Long italic_angle;
    FT_Bool is_fixed_pitch;
    FT_Short underline_position;
    FT_UShort underline_thickness;
};

typedef struct PS_FontInfoRec_ PS_FontInfoRec;

typedef struct _BitmapFileFunctions _BitmapFileFunctions, *P_BitmapFileFunctions;

typedef struct _BitmapFileFunctions BitmapFileFunctionsRec;

struct _BitmapFileFunctions {
    int (*ReadFont)(FontPtr, FontFilePtr, int, int, int, int);
    int (*ReadInfo)(FontInfoPtr, FontFilePtr);
};

typedef struct sockaddr_un sockaddr_un, *Psockaddr_un;

struct sockaddr_un {
    sa_family_t sun_family;
    char sun_path[108];
};

typedef struct _Client _Client, *P_Client;

typedef struct _Client *ClientPtr;

struct _Client {
};

typedef struct timeval timeval, *Ptimeval;

typedef struct timeval **OSTimePtr;

struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};

typedef void (*BlockHandlerProcPtr)(void *, OSTimePtr, void *);

typedef XID Font;

typedef struct BDFSTAT BDFSTAT, *PBDFSTAT;

typedef struct BDFSTAT bdfFileState;

struct BDFSTAT {
    int linenum;
    char *fileName;
    char fontName[1024];
    float pointSize;
    int resolution_x;
    int resolution_y;
    int digitCount;
    int digitWidths;
    int exHeight;
    FontPropPtr fontProp;
    FontPropPtr pointSizeProp;
    FontPropPtr resolutionXProp;
    FontPropPtr resolutionYProp;
    FontPropPtr resolutionProp;
    FontPropPtr xHeightProp;
    FontPropPtr weightProp;
    FontPropPtr quadWidthProp;
    BOOL haveFontAscent;
    BOOL haveFontDescent;
    BOOL haveDefaultCh;
};


// WARNING! conflicting data type names: /DWARF/struct_FILE.h/_IO_FILE - /stdio.h/_IO_FILE

typedef __uint16_t uint16_t;

typedef __uint32_t uint32_t;

typedef __uint8_t uint8_t;

typedef struct TT_OS2_ TT_OS2_, *PTT_OS2_;

struct TT_OS2_ {
    FT_UShort version;
    FT_Short xAvgCharWidth;
    FT_UShort usWeightClass;
    FT_UShort usWidthClass;
    FT_UShort fsType;
    FT_Short ySubscriptXSize;
    FT_Short ySubscriptYSize;
    FT_Short ySubscriptXOffset;
    FT_Short ySubscriptYOffset;
    FT_Short ySuperscriptXSize;
    FT_Short ySuperscriptYSize;
    FT_Short ySuperscriptXOffset;
    FT_Short ySuperscriptYOffset;
    FT_Short yStrikeoutSize;
    FT_Short yStrikeoutPosition;
    FT_Short sFamilyClass;
    FT_Byte panose[10];
    FT_ULong ulUnicodeRange1;
    FT_ULong ulUnicodeRange2;
    FT_ULong ulUnicodeRange3;
    FT_ULong ulUnicodeRange4;
    FT_Char achVendID[4];
    FT_UShort fsSelection;
    FT_UShort usFirstCharIndex;
    FT_UShort usLastCharIndex;
    FT_Short sTypoAscender;
    FT_Short sTypoDescender;
    FT_Short sTypoLineGap;
    FT_UShort usWinAscent;
    FT_UShort usWinDescent;
    FT_ULong ulCodePageRange1;
    FT_ULong ulCodePageRange2;
    FT_Short sxHeight;
    FT_Short sCapHeight;
    FT_UShort usDefaultChar;
    FT_UShort usBreakChar;
    FT_UShort usMaxContext;
    FT_UShort usLowerOpticalPointSize;
    FT_UShort usUpperOpticalPointSize;
};

typedef struct TT_MaxProfile_ TT_MaxProfile_, *PTT_MaxProfile_;

typedef struct TT_MaxProfile_ TT_MaxProfile;

struct TT_MaxProfile_ {
    FT_Fixed version;
    FT_UShort numGlyphs;
    FT_UShort maxPoints;
    FT_UShort maxContours;
    FT_UShort maxCompositePoints;
    FT_UShort maxCompositeContours;
    FT_UShort maxZones;
    FT_UShort maxTwilightPoints;
    FT_UShort maxStorage;
    FT_UShort maxFunctionDefs;
    FT_UShort maxInstructionDefs;
    FT_UShort maxStackElements;
    FT_UShort maxSizeOfInstructions;
    FT_UShort maxComponentElements;
    FT_UShort maxComponentDepth;
};

typedef enum FT_Sfnt_Tag_ {
    FT_SFNT_HEAD=0,
    FT_SFNT_MAXP=1,
    FT_SFNT_OS2=2,
    FT_SFNT_HHEA=3,
    FT_SFNT_VHEA=4,
    FT_SFNT_POST=5,
    FT_SFNT_PCLT=6,
    FT_SFNT_MAX=7
} FT_Sfnt_Tag_;

typedef struct TT_Postscript_ TT_Postscript_, *PTT_Postscript_;

typedef struct TT_Postscript_ TT_Postscript;

struct TT_Postscript_ {
    FT_Fixed FormatType;
    FT_Fixed italicAngle;
    FT_Short underlinePosition;
    FT_Short underlineThickness;
    FT_ULong isFixedPitch;
    FT_ULong minMemType42;
    FT_ULong maxMemType42;
    FT_ULong minMemType1;
    FT_ULong maxMemType1;
};

typedef struct TT_OS2_ TT_OS2;

typedef struct _FTMapping *FTMappingPtr;

typedef struct _fs_fpe_alternate _fs_fpe_alternate, *P_fs_fpe_alternate;

struct _fs_fpe_alternate {
    char *name;
    Bool subset;
};

typedef struct _fs_fpe_data _fs_fpe_data, *P_fs_fpe_data;

typedef struct _fs_fpe_data *FSFpePtr;

typedef struct _fs_fpe_alternate *FSFpeAltPtr;

typedef struct _fs_client_data _fs_client_data, *P_fs_client_data;

typedef struct _fs_client_data *FSClientPtr;

typedef struct _fs_buf _fs_buf, *P_fs_buf;

typedef struct _fs_buf FSBufRec;

typedef struct _fs_block_data *FSBlockDataPtr;

struct _fs_buf {
    char *buf;
    long size;
    long insert;
    long remove;
};

struct _fs_fpe_data {
    FSFpePtr next;
    int fs_fd;
    int fs_conn_state;
    int current_seq;
    char *servername;
    Bool has_catalogues;
    int generation;
    int numAlts;
    int alternate;
    int fsMajorVersion;
    FSFpeAltPtr alts;
    FSClientPtr clients;
    XID curacid;
    FSBufRec outBuf;
    FSBufRec inBuf;
    long inNeed;
    CARD32 blockState;
    CARD32 blockedReplyTime;
    CARD32 brokenWriteTime;
    CARD32 blockedConnectTime;
    CARD32 brokenConnectionTime;
    FSBlockDataPtr blockedRequests;
    struct _XtransConnInfo *trans_conn;
};

struct _fs_client_data {
    pointer client;
    struct _fs_client_data *next;
    XID acid;
    int auth_generation;
};

typedef struct _fs_buf *FSBufPtr;

typedef struct _BuiltinIO _BuiltinIO, *P_BuiltinIO;

typedef struct _BuiltinIO *BuiltinIOPtr;

struct _BuiltinIO {
    int offset;
    BuiltinFilePtr file;
};

typedef struct _compressedFILE _compressedFILE, *P_compressedFILE;

typedef struct _compressedFILE CompressedFile;

struct _compressedFILE {
    BufFilePtr file;
    char_type *stackp;
    code_int oldcode;
    char_type finchar;
    int block_compress;
    int maxbits;
    code_int maxcode;
    code_int maxmaxcode;
    code_int free_ent;
    int clear_flg;
    int n_bits;
    int offset;
    int size;
    char_type buf[16];
    char_type de_stack[65300];
    char_type *tab_suffix;
    ushort *tab_prefix;
};


// WARNING! conflicting data type names: /DWARF/stat.h/stat - /stat.h/stat

typedef struct sockaddr_storage Xtransaddr;

typedef struct _LFWIData _LFWIData, *P_LFWIData;

typedef struct _LFWIData *LFWIDataPtr;

struct _LFWIData {
    FontNamesPtr names;
    int current;
};


// WARNING! conflicting data type names: /DWARF/struct_timespec.h/timespec - /time.h/timespec

typedef enum state {
    Begin=0,
    Normal=1,
    Quoted=2,
    Comment=3
} state;

typedef struct sockaddr_dl sockaddr_dl, *Psockaddr_dl;

struct sockaddr_dl {
};

typedef struct sockaddr_ax25 sockaddr_ax25, *Psockaddr_ax25;

struct sockaddr_ax25 {
};

typedef struct sockaddr_at sockaddr_at, *Psockaddr_at;

struct sockaddr_at {
};

typedef struct sockaddr_x25 sockaddr_x25, *Psockaddr_x25;

struct sockaddr_x25 {
};

typedef struct sockaddr_eon sockaddr_eon, *Psockaddr_eon;

struct sockaddr_eon {
};

typedef struct sockaddr_ipx sockaddr_ipx, *Psockaddr_ipx;

struct sockaddr_ipx {
};

typedef struct _IO_wide_data _IO_wide_data, *P_IO_wide_data;

struct _IO_wide_data {
};


// WARNING! conflicting data type names: /DWARF/_UNCATEGORIZED_/_IO_marker - /libio.h/_IO_marker

typedef struct sockaddr_ns sockaddr_ns, *Psockaddr_ns;

struct sockaddr_ns {
};

typedef struct _IO_codecvt _IO_codecvt, *P_IO_codecvt;

struct _IO_codecvt {
};

typedef struct sockaddr_iso sockaddr_iso, *Psockaddr_iso;

struct sockaddr_iso {
};

typedef struct sockaddr_inarp sockaddr_inarp, *Psockaddr_inarp;

struct sockaddr_inarp {
};

typedef struct lconv lconv, *Plconv;

struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_p_cs_precedes;
    char int_p_sep_by_space;
    char int_n_cs_precedes;
    char int_n_sep_by_space;
    char int_p_sign_posn;
    char int_n_sign_posn;
};

typedef struct _BitmapFont _BitmapFont, *P_BitmapFont;

typedef struct _BitmapExtra _BitmapExtra, *P_BitmapExtra;

typedef struct _BitmapExtra *BitmapExtraPtr;

struct _BitmapExtra {
    Atom *glyphNames;
    int *sWidths;
    CARD32 bitmapsSizes[4];
    FontInfoRec info;
};

struct _BitmapFont {
    uint version_num;
    int num_chars;
    int num_tables;
    CharInfoPtr metrics;
    struct xCharInfo *ink_metrics;
    char *bitmaps;
    CharInfoPtr **encoding;
    CharInfoPtr pDefault;
    BitmapExtraPtr bitmapExtra;
};

typedef struct _BitmapFont *BitmapFontPtr;

typedef struct _FontScalableExtra _FontScalableExtra, *P_FontScalableExtra;

typedef struct _FontScalable _FontScalable, *P_FontScalable;

typedef struct _FontScalable FontScalableRec;

typedef struct _FontScaled _FontScaled, *P_FontScaled;

typedef struct _FontScaled *FontScaledPtr;

typedef struct _FontEntry _FontEntry, *P_FontEntry;

typedef struct _FontEntry *FontEntryPtr;

typedef struct _FontName _FontName, *P_FontName;

typedef struct _FontName FontNameRec;

typedef union _FontEntryParts _FontEntryParts, *P_FontEntryParts;

typedef struct _FontScalableEntry _FontScalableEntry, *P_FontScalableEntry;

typedef struct _FontScalableEntry FontScalableEntryRec;

typedef struct _FontBitmapEntry _FontBitmapEntry, *P_FontBitmapEntry;

typedef struct _FontBitmapEntry FontBitmapEntryRec;

typedef struct _FontAliasEntry _FontAliasEntry, *P_FontAliasEntry;

typedef struct _FontAliasEntry FontAliasEntryRec;

typedef struct _FontBCEntry _FontBCEntry, *P_FontBCEntry;

typedef struct _FontBCEntry FontBCEntryRec;

typedef struct _FontRenderer _FontRenderer, *P_FontRenderer;

typedef struct _FontEntry *FontEntryPtr.conflict;

typedef struct _FontScalable *FontScalablePtr;

typedef struct _FontName *FontNamePtr;

typedef struct _FontRenderer *FontRendererPtr;

typedef struct _FontScalableExtra *FontScalableExtraPtr;

struct _FontScalable {
    int values_supplied;
    double pixel_matrix[4];
    double point_matrix[4];
    int pixel;
    int point;
    int x;
    int y;
    int width;
    char *xlfdName;
    int nranges;
    struct fsRange *ranges;
};

struct _FontScalableExtra {
    FontScalableRec defaults;
    int numScaled;
    int sizeScaled;
    FontScaledPtr scaled;
    pointer private;
};

struct _FontAliasEntry {
    char *resolved;
};

struct _FontScalableEntry {
    FontRendererPtr renderer;
    char *fileName;
    FontScalableExtraPtr extra;
};

struct _FontBCEntry {
    FontScalableRec vals;
    FontEntryPtr entry;
};

struct _FontBitmapEntry {
    FontRendererPtr renderer;
    char *fileName;
    FontPtr pFont;
};

union _FontEntryParts {
    FontScalableEntryRec scalable;
    FontBitmapEntryRec bitmap;
    FontAliasEntryRec alias;
    FontBCEntryRec bc;
};

struct _FontRenderer {
    char *fileSuffix;
    int fileSuffixLen;
    int (*OpenBitmap)(FontPathElementPtr, FontPtr *, int, FontEntryPtr.conflict, char *, fsBitmapFormat, fsBitmapFormatMask, FontPtr);
    int (*OpenScalable)(FontPathElementPtr, FontPtr *, int, FontEntryPtr.conflict, char *, FontScalablePtr, fsBitmapFormat, fsBitmapFormatMask, FontPtr);
    int (*GetInfoBitmap)(FontPathElementPtr, FontInfoPtr, FontEntryPtr.conflict, char *);
    int (*GetInfoScalable)(FontPathElementPtr, FontInfoPtr, FontEntryPtr.conflict, FontNamePtr, char *, FontScalablePtr);
    int number;
    int capabilities;
};

struct _FontName {
    char *name;
    short length;
    short ndashes;
};

struct _FontEntry {
    FontNameRec name;
    int type;
    union _FontEntryParts u;
};

struct _FontScaled {
    FontScalableRec vals;
    FontEntryPtr bitmap;
    FontPtr pFont;
};

typedef struct _BitmapSources _BitmapSources, *P_BitmapSources;

typedef struct _BitmapSources BitmapSourcesRec;

struct _BitmapSources {
    FontPathElementPtr *fpe;
    int size;
    int count;
};

typedef struct _FontRenderer FontRendererRec;

typedef struct _FontTable _FontTable, *P_FontTable;

struct _FontTable {
    int used;
    int size;
    FontEntryPtr.conflict entries;
    Bool sorted;
};

typedef struct _FontRenderersElement _FontRenderersElement, *P_FontRenderersElement;

struct _FontRenderersElement {
    FontRendererPtr renderer;
    int priority;
};

typedef struct _FontEntry FontEntryRec;

typedef struct _FontDirectory _FontDirectory, *P_FontDirectory;

typedef struct _FontTable FontTableRec;

struct _FontDirectory {
    char *directory;
    ulong dir_mtime;
    ulong alias_mtime;
    FontTableRec scalable;
    FontTableRec nonScalable;
    char *attributes;
};

typedef struct _FontRenders _FontRenders, *P_FontRenders;

typedef struct _FontRenders FontRenderersRec;

struct _FontRenders {
    int number;
    struct _FontRenderersElement *renderers;
};

typedef struct _FontPatternCacheEntry _FontPatternCacheEntry, *P_FontPatternCacheEntry;

typedef struct _FontPatternCacheEntry *FontPatternCacheEntryPtr;

struct _FontPatternCacheEntry {
    struct _FontPatternCacheEntry *next;
    struct _FontPatternCacheEntry **prev;
    short patlen;
    char *pattern;
    int hash;
    FontPtr pFont;
};

typedef struct _FontPatternCacheEntry FontPatternCacheEntryRec;

typedef struct _FontPatternCache _FontPatternCache, *P_FontPatternCache;

struct _FontPatternCache {
    FontPatternCacheEntryPtr buckets[16];
    FontPatternCacheEntryRec entries[64];
    FontPatternCacheEntryPtr free;
};

typedef struct _snfFontInfo _snfFontInfo, *P_snfFontInfo;

typedef struct _snfCharInfo _snfCharInfo, *P_snfCharInfo;

typedef struct _snfCharInfo snfCharInfoRec;

struct _snfCharInfo {
    struct xCharInfo metrics;
    uint byteOffset:24;
    uint exists:1;
    uint pad:7;
};

struct _snfFontInfo {
    uint version1;
    uint allExist;
    uint drawDirection;
    uint noOverlap;
    uint constantMetrics;
    uint terminalFont;
    uint linear:1;
    uint constantWidth:1;
    uint inkInside:1;
    uint inkMetrics:1;
    uint padding:28;
    uint firstCol;
    uint lastCol;
    uint firstRow;
    uint lastRow;
    uint nProps;
    uint lenStrings;
    uint chDefault;
    int fontDescent;
    int fontAscent;
    snfCharInfoRec minbounds;
    snfCharInfoRec maxbounds;
    uint pixDepth;
    uint glyphSets;
    uint version2;
};

typedef struct _snfFontProp _snfFontProp, *P_snfFontProp;

struct _snfFontProp {
    CARD32 name;
    INT32 value;
    Bool indirect;
};

typedef struct _snfFontInfo *snfFontInfoPtr;

typedef struct _snfFontProp *snfFontPropPtr;

typedef struct _snfFontInfo snfFontInfoRec;

typedef FT_UInt32 FT_Tag;

typedef struct _FontResolution _FontResolution, *P_FontResolution;

typedef struct _FontResolution *FontResolutionPtr;

struct _FontResolution {
    ushort x_resolution;
    ushort y_resolution;
    ushort point_size;
};

typedef struct _FontPatternCache *FontPatternCachePtr;

typedef struct _fs_font_data *FSFontDataPtr;

typedef struct _fs_fpe_data *FSFpePtr.conflict;

typedef struct _fs_blocked_glyphs *FSBlockedGlyphPtr;

typedef struct _fs_blocked_list *FSBlockedListPtr;

typedef struct _fs_blocked_font *FSBlockedFontPtr;

typedef struct _fs_blocked_list_info *FSBlockedListInfoPtr;

typedef union conv_d conv_d, *Pconv_d;

union conv_d {
    double d;
    uchar b[8];
};

typedef struct _FontEnc *FontEncPtr;

typedef struct _IO_FILE FILE;

typedef struct in_addr in_addr, *Pin_addr;

typedef uint32_t in_addr_t;

struct in_addr {
    in_addr_t s_addr;
};

typedef uint16_t in_port_t;

typedef struct sockaddr_in sockaddr_in, *Psockaddr_in;

struct sockaddr_in {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;
    uchar sin_zero[8];
};

typedef struct in6_addr in6_addr, *Pin6_addr;

typedef union anon_union_16_3_a3f0114d_for___in6_u anon_union_16_3_a3f0114d_for___in6_u, *Panon_union_16_3_a3f0114d_for___in6_u;

union anon_union_16_3_a3f0114d_for___in6_u {
    uint8_t __u6_addr8[16];
    uint16_t __u6_addr16[8];
    uint32_t __u6_addr32[4];
};

struct in6_addr {
    union anon_union_16_3_a3f0114d_for___in6_u __in6_u;
};

typedef struct sockaddr_in6 sockaddr_in6, *Psockaddr_in6;

struct sockaddr_in6 {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
};

typedef struct _FontDirectory *FontDirectoryPtr;

typedef struct _FontScalableEntry *FontScalableEntryPtr;

typedef struct _FontTable *FontTablePtr;

typedef struct _FontBitmapEntry *FontBitmapEntryPtr;

typedef struct fd_set fd_set, *Pfd_set;

struct fd_set {
    __fd_mask fds_bits[16];
};

typedef struct _xzip_buf _xzip_buf, *P_xzip_buf;

typedef struct _xzip_buf xzip_buf;

struct _xzip_buf {
    z_stream z;
    int zstat;
    BufChar b[8192];
    BufChar b_in[8192];
    BufFilePtr f;
};

typedef Bool (*NameCheckFunc)(char *);

typedef struct _Font FontRec;

typedef int (*FreeFpeFunc)(FontPathElementPtr);

typedef int (*InitFpeFunc)(FontPathElementPtr);

typedef struct _ExtentInfo _ExtentInfo, *P_ExtentInfo;

typedef struct _ExtentInfo ExtentInfoRec;

struct _ExtentInfo {
    DrawDirection drawDirection;
    int fontAscent;
    int fontDescent;
    int overallAscent;
    int overallDescent;
    int overallWidth;
    int overallLeft;
    int overallRight;
};

typedef int (*WakeupFpeFunc)(FontPathElementPtr, ulong *);

typedef int (*OpenFontFunc)(void *, FontPathElementPtr, Mask, char *, int, fsBitmapFormat, fsBitmapFormatMask, XID, FontPtr *, char **, FontPtr);

typedef void (*SetPathFunc)(void);

typedef int (*NextLaFunc)(void *, FontPathElementPtr, char **, int *, char **, int *, void *);

typedef void (*ClientDiedFunc)(void *, FontPathElementPtr);

typedef int (*StartLaFunc)(void *, FontPathElementPtr, char *, int, int, void **);

typedef void (*CloseFontFunc)(FontPathElementPtr, FontPtr);

typedef int (*LoadGlyphsFunc)(void *, FontPtr, Bool, uint, int, uchar *);

typedef int (*StartLfwiFunc)(void *, FontPathElementPtr, char *, int, int, void **);

typedef int (*NextLfwiFunc)(void *, FontPathElementPtr, char **, int *, FontInfoPtr *, int *, void *);

typedef int (*ResetFpeFunc)(FontPathElementPtr);

typedef int (*ListFontsFunc)(void *, FontPathElementPtr, char *, int, int, FontNamesPtr);


// WARNING! conflicting data type names: /netdb.h/addrinfo - /DWARF/netdb.h/addrinfo


// WARNING! conflicting data type names: /stdio.h/FILE - /DWARF/FILE.h/FILE

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

struct evp_pkey_ctx_st {
};

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;


// WARNING! conflicting data type names: /dirent.h/__dirstream - /DWARF/_UNCATEGORIZED_/__dirstream


// WARNING! conflicting data type names: /dirent.h/DIR - /DWARF/dirent.h/DIR

typedef int (*__compar_fn_t)(void *, void *);

typedef enum Elf_ProgramHeaderType {
    PT_NULL=0,
    PT_LOAD=1,
    PT_DYNAMIC=2,
    PT_INTERP=3,
    PT_NOTE=4,
    PT_SHLIB=5,
    PT_PHDR=6,
    PT_TLS=7,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_STACK=1685382481,
    PT_GNU_RELRO=1685382482
} Elf_ProgramHeaderType;

typedef struct Elf64_Dyn Elf64_Dyn, *PElf64_Dyn;

typedef enum Elf64_DynTag {
    DT_NULL=0,
    DT_NEEDED=1,
    DT_PLTRELSZ=2,
    DT_PLTGOT=3,
    DT_HASH=4,
    DT_STRTAB=5,
    DT_SYMTAB=6,
    DT_RELA=7,
    DT_RELASZ=8,
    DT_RELAENT=9,
    DT_STRSZ=10,
    DT_SYMENT=11,
    DT_INIT=12,
    DT_FINI=13,
    DT_SONAME=14,
    DT_RPATH=15,
    DT_SYMBOLIC=16,
    DT_REL=17,
    DT_RELSZ=18,
    DT_RELENT=19,
    DT_PLTREL=20,
    DT_DEBUG=21,
    DT_TEXTREL=22,
    DT_JMPREL=23,
    DT_BIND_NOW=24,
    DT_INIT_ARRAY=25,
    DT_FINI_ARRAY=26,
    DT_INIT_ARRAYSZ=27,
    DT_FINI_ARRAYSZ=28,
    DT_RUNPATH=29,
    DT_FLAGS=30,
    DT_PREINIT_ARRAY=32,
    DT_PREINIT_ARRAYSZ=33,
    DT_RELRSZ=35,
    DT_RELR=36,
    DT_RELRENT=37,
    DT_ANDROID_REL=1610612751,
    DT_ANDROID_RELSZ=1610612752,
    DT_ANDROID_RELA=1610612753,
    DT_ANDROID_RELASZ=1610612754,
    DT_ANDROID_RELR=1879040000,
    DT_ANDROID_RELRSZ=1879040001,
    DT_ANDROID_RELRENT=1879040003,
    DT_GNU_PRELINKED=1879047669,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_CHECKSUM=1879047672,
    DT_PLTPADSZ=1879047673,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_FEATURE_1=1879047676,
    DT_POSFLAG_1=1879047677,
    DT_SYMINSZ=1879047678,
    DT_SYMINENT=1879047679,
    DT_GNU_XHASH=1879047924,
    DT_GNU_HASH=1879047925,
    DT_TLSDESC_PLT=1879047926,
    DT_TLSDESC_GOT=1879047927,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_LIBLIST=1879047929,
    DT_CONFIG=1879047930,
    DT_DEPAUDIT=1879047931,
    DT_AUDIT=1879047932,
    DT_PLTPAD=1879047933,
    DT_MOVETAB=1879047934,
    DT_SYMINFO=1879047935,
    DT_VERSYM=1879048176,
    DT_RELACOUNT=1879048185,
    DT_RELCOUNT=1879048186,
    DT_FLAGS_1=1879048187,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_AUXILIARY=2147483645,
    DT_FILTER=2147483647
} Elf64_DynTag;

struct Elf64_Dyn {
    enum Elf64_DynTag d_tag;
    qword d_val;
};

typedef struct Elf64_Sym Elf64_Sym, *PElf64_Sym;

struct Elf64_Sym {
    dword st_name;
    byte st_info;
    byte st_other;
    word st_shndx;
    qword st_value;
    qword st_size;
};

typedef struct Elf64_Shdr Elf64_Shdr, *PElf64_Shdr;

typedef enum Elf_SectionHeaderType {
    SHT_NULL=0,
    SHT_PROGBITS=1,
    SHT_SYMTAB=2,
    SHT_STRTAB=3,
    SHT_RELA=4,
    SHT_HASH=5,
    SHT_DYNAMIC=6,
    SHT_NOTE=7,
    SHT_NOBITS=8,
    SHT_REL=9,
    SHT_SHLIB=10,
    SHT_DYNSYM=11,
    SHT_INIT_ARRAY=14,
    SHT_FINI_ARRAY=15,
    SHT_PREINIT_ARRAY=16,
    SHT_GROUP=17,
    SHT_SYMTAB_SHNDX=18,
    SHT_ANDROID_REL=1610612737,
    SHT_ANDROID_RELA=1610612738,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_CHECKSUM=1879048184,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_syminfo=1879048188,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191
} Elf_SectionHeaderType;

struct Elf64_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType sh_type;
    qword sh_flags;
    qword sh_addr;
    qword sh_offset;
    qword sh_size;
    dword sh_link;
    dword sh_info;
    qword sh_addralign;
    qword sh_entsize;
};

typedef struct GnuBuildId GnuBuildId, *PGnuBuildId;

struct GnuBuildId {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
    byte hash[20];
};

typedef struct NoteGnuProperty_4 NoteGnuProperty_4, *PNoteGnuProperty_4;

struct NoteGnuProperty_4 {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
};

typedef struct Elf64_Ehdr Elf64_Ehdr, *PElf64_Ehdr;

struct Elf64_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_osabi;
    byte e_ident_abiversion;
    byte e_ident_pad[7];
    word e_type;
    word e_machine;
    dword e_version;
    qword e_entry;
    qword e_phoff;
    qword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};

typedef struct Elf64_Rela Elf64_Rela, *PElf64_Rela;

struct Elf64_Rela {
    qword r_offset; // location to apply the relocation action
    qword r_info; // the symbol table index and the type of relocation
    qword r_addend; // a constant addend used to compute the relocatable field value
};

typedef struct Elf64_Phdr Elf64_Phdr, *PElf64_Phdr;

struct Elf64_Phdr {
    enum Elf_ProgramHeaderType p_type;
    dword p_flags;
    qword p_offset;
    qword p_vaddr;
    qword p_paddr;
    qword p_filesz;
    qword p_memsz;
    qword p_align;
};




int _init(EVP_PKEY_CTX *ctx)

{
  int iVar1;
  
  iVar1 = 0x140228;
  if (true) {
    iVar1 = __gmon_start__();
  }
  return iVar1;
}



void FUN_00108020(void)

{
  (*(code *)(undefined *)0x0)();
  return;
}



int FontFileInitFPE(FontPathElementPtr fpe)

{
  int iVar1;
  Bool BVar2;
  long in_FS_OFFSET;
  FontDirectoryPtr p_Stack_28;
  long lStack_20;
  
  lStack_20 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = FontFileReadDirectory(fpe->name,&p_Stack_28);
  if (iVar1 == 0x55) {
    if ((p_Stack_28->nonScalable).used < 1) {
      fpe->private = p_Stack_28;
    }
    else {
      BVar2 = FontFileRegisterBitmapSource(fpe);
      if (BVar2 == 0) {
        iVar1 = 0x50;
        FontFileFreeFPE(fpe);
      }
      else {
        fpe->private = p_Stack_28;
      }
    }
  }
  if (lStack_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int FontFileFreeFPE(FontPathElementPtr fpe)

{
  FontFileUnregisterBitmapSource(fpe);
  FontFileFreeDir((FontDirectoryPtr)fpe->private);
  return 0x55;
}



int FontFileListNextFontOrAlias
              (pointer client,FontPathElementPtr fpe,char **namep,int *namelenp,char **resolvedp,
              int *resolvedlenp,pointer private)

{
  int iVar1;
  FontNamesPtr pFN;
  long lVar2;
  int iVar3;
  
                    // WARNING: Load size is inaccurate
  pFN = *private;
  iVar3 = *(int *)((long)private + 8);
  if (iVar3 == pFN->nnames) {
    FreeFontNames(pFN);
    free(private);
    return 0x53;
  }
  iVar1 = pFN->length[iVar3];
  *namep = pFN->names[iVar3];
  if (iVar1 < 0) {
    *namelenp = -iVar1;
                    // WARNING: Load size is inaccurate
    lVar2 = *(long *)(*private + 0x10);
    iVar3 = *(int *)((long)private + 8) + 1;
    *(int *)((long)private + 8) = iVar3;
    *resolvedp = *(char **)(lVar2 + (long)iVar3 * 8);
                    // WARNING: Load size is inaccurate
    *resolvedlenp = *(int *)(*(long *)(*private + 8) + (long)*(int *)((long)private + 8) * 4);
    iVar3 = 0x52;
  }
  else {
    *namelenp = iVar1;
    iVar3 = 0x55;
  }
  *(int *)((long)private + 8) = *(int *)((long)private + 8) + 1;
  return iVar3;
}



int FontFileListNextFontWithInfo
              (pointer client,FontPathElementPtr fpe,char **namep,int *namelenp,
              FontInfoPtr *pFontInfo,int *numFonts,pointer private)

{
  int iVar1;
  FontNamesPtr pFN;
  int iVar2;
  long in_FS_OFFSET;
  int iStack_3c;
  char *pcStack_38;
  char *pcStack_30;
  
  pcStack_30 = *(char **)(in_FS_OFFSET + 0x28);
                    // WARNING: Load size is inaccurate
  pFN = *private;
  iVar2 = *(int *)((long)private + 8);
  if (iVar2 == pFN->nnames) {
    FreeFontNames(pFN);
    free(private);
    iVar2 = 0x53;
  }
  else {
    pcStack_38 = pFN->names[iVar2];
    iStack_3c = pFN->length[iVar2];
    iVar2 = FontFileListOneFontWithInfo
                      (fpe,(FontPathElementPtr)&pcStack_38,(char **)&iStack_3c,(int *)pFontInfo,
                       pFontInfo);
    if (iVar2 == 0x53) {
      iVar2 = 0x50;
    }
    *namep = pcStack_38;
    *namelenp = iStack_3c;
                    // WARNING: Load size is inaccurate
    iVar1 = *(int *)((long)private + 8) + 1;
    *(int *)((long)private + 8) = iVar1;
    *numFonts = **private - iVar1;
  }
  if (pcStack_30 != *(char **)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



void FontFileCloseFont(FontPathElementPtr fpe,FontPtr pFont)

{
  FontEntryPtr entry;
  
  entry = (FontEntryPtr)pFont->fpePrivate;
  if (entry != (FontEntryPtr)0x0) {
    if (entry->type == 0) {
      FontFileRemoveScaledInstance(entry,pFont);
    }
    else if (entry->type == 2) {
      (entry->u).scalable.extra = (FontScalableExtraPtr)0x0;
    }
    pFont->fpePrivate = (void *)0x0;
  }
                    // WARNING: Could not recover jumptable at 0x0010d643. Too many branches
                    // WARNING: Treating indirect jump as call
  (*pFont->unload_font)(pFont);
  return;
}



int bitmapGetGlyphs(FontPtr pFont,ulong count,uchar *chars,FontEncoding charEncoding,
                   ulong *glyphCount,CharInfoPtr *glyphs)

{
  int iVar1;
  
  iVar1 = bitmapGetGlyphs(pFont,count,chars,charEncoding,glyphCount,glyphs);
  return iVar1;
}



int FontFileOpenFont(pointer client,FontPathElementPtr fpe,Mask flags,char *name,int namelen,
                    fsBitmapFormat format,fsBitmapFormatMask fmask,XID id,FontPtr *pFont,
                    char **aliasName,FontPtr non_cachable_font)

{
  fsBitmapFormatMask format_00;
  int iVar1;
  
  format_00 = fmask;
  if (0x3ff < namelen) {
    return 0x50;
  }
  fmask = (fsBitmapFormatMask)pFont;
  iVar1 = FontFileOpenFont(fpe,(FontPathElementPtr)flags,(Mask)name,(char *)(ulong)(uint)namelen,
                           format,format_00,fmask,(XID)aliasName,(FontPtr *)non_cachable_font,
                           aliasName,non_cachable_font);
  return iVar1;
}



int FontFileListFonts(pointer client,FontPathElementPtr fpe,char *pat,int len,int max,
                     FontNamesPtr names)

{
  int iVar1;
  int in_stack_00000008;
  
  iVar1 = _FontFileListFonts(&fpe->private,(FontPathElementPtr)pat,(char *)(ulong)(uint)len,max,
                             (int)names,(FontNamesPtr)0x0,in_stack_00000008);
  return iVar1;
}



void __cxa_finalize(void)

{
  __cxa_finalize();
  return;
}



void FT_Get_Sfnt_Name_Count(void)

{
  FT_Get_Sfnt_Name_Count();
  return;
}



void __strcat_chk(void)

{
  __strcat_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * inet_ntop(int __af,void *__cp,char *__buf,socklen_t __len)

{
  char *pcVar1;
  
  pcVar1 = inet_ntop(__af,__cp,__buf,__len);
  return pcVar1;
}



int add_range(fsRange *newrange,int *nranges,fsRange **range,Bool charset_subset)

{
  int iVar1;
  
  iVar1 = add_range(newrange,nranges,range,charset_subset);
  return iVar1;
}



Bool bitmapAddInkMetrics(FontPtr pFont)

{
  Bool BVar1;
  
  BVar1 = bitmapAddInkMetrics(pFont);
  return BVar1;
}



void __snprintf_chk(void)

{
  __snprintf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void free(void *__ptr)

{
  free(__ptr);
  return;
}



// WARNING: Unknown calling convention

int StoreFontClientFont(FontPtr pfont,Font id)

{
  int iVar1;
  
  iVar1 = StoreFontClientFont(pfont,id);
  return iVar1;
}



void FontCharInkMetrics(FontPtr pFont,CharInfoPtr pCI,xCharInfo *pInk)

{
  FontCharInkMetrics(pFont,pCI,pInk);
  return;
}



int BufFileClose(BufFilePtr f,int doClose)

{
  int iVar1;
  
  iVar1 = (*f->close)(f,doClose);
  free(f);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strcasecmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcasecmp(__s1,__s2);
  return iVar1;
}



void __vfprintf_chk(void)

{
  __vfprintf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}



int AddFontNamesName(FontNamesPtr names,char *name,int length)

{
  int iVar1;
  
  iVar1 = AddFontNamesName(names,name,length);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int unlink(char *__name)

{
  int iVar1;
  
  iVar1 = unlink(__name);
  return iVar1;
}



void FT_Get_Name_Index(void)

{
  FT_Get_Name_Index();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strncpy(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncpy(__dest,__src,__n);
  return pcVar1;
}



void FT_Load_Glyph(void)

{
  FT_Load_Glyph();
  return;
}



void _fs_connection_died(FSFpePtr conn)

{
  _fs_connection_died(conn);
  return;
}



Bool FontFileInitTable(FontTablePtr table,int size)

{
  FontEntryPtr_conflict p_Var1;
  
  if (0xd79435 < (uint)size) {
    return 0;
  }
  if (size == 0) {
    table->entries = (FontEntryPtr_conflict)0x0;
  }
  else {
    p_Var1 = (FontEntryPtr_conflict)malloc((long)size * 0x98);
    table->entries = p_Var1;
    if (p_Var1 == (FontEntryPtr_conflict)0x0) {
      return 0;
    }
  }
  table->used = 0;
  table->size = size;
  table->sorted = 0;
  return 1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}



void _fs_init_fontinfo(FSFpePtr_conflict conn,FontInfoPtr pfi)

{
  _fs_init_fontinfo(conn,pfi);
  return;
}



int _FontTransWrite(XtransConnInfo ciptr,char *buf,int size)

{
  int iVar1;
  
  iVar1 = _FontTransWrite(ciptr,buf,size);
  return iVar1;
}



BufFilePtr
BufFileCreate(char *private,_func_int_BufFilePtr *input,_func_int_int_BufFilePtr *output,
             _func_int_BufFilePtr_int *skip,_func_int_BufFilePtr_int *close)

{
  BufFilePtr p_Var1;
  
  p_Var1 = (BufFilePtr)malloc(0x2038);
  if (p_Var1 != (BufFilePtr)0x0) {
    p_Var1->private = private;
    p_Var1->bufp = p_Var1->buffer;
    p_Var1->input = input;
    p_Var1->output = output;
    p_Var1->skip = skip;
    p_Var1->left = 0;
    p_Var1->eof = 0;
    p_Var1->close = close;
  }
  return p_Var1;
}



// WARNING: Unknown calling convention

FontPtr CreateFontRec(void)

{
  FontPtr p_Var1;
  
  p_Var1 = CreateFontRec();
  return p_Var1;
}



void FT_Get_X11_Font_Format(void)

{
  FT_Get_X11_Font_Format();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcpy(__dest,__src);
  return pcVar1;
}



void FontCharReshape(FontPtr pFont,CharInfoPtr pSrc,CharInfoPtr pDst)

{
  FontCharReshape(pFont,pSrc,pDst);
  return;
}



void FT_Load_Sfnt_Table(void)

{
  FT_Load_Sfnt_Table();
  return;
}



void FT_Get_Postscript_Name(void)

{
  FT_Get_Postscript_Name();
  return;
}



void __isoc99_fscanf(void)

{
  __isoc99_fscanf();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void FontFileRegisterLocalFpeFunctions(void)

{
  RegisterFPEFunctions
            (FontFileNameCheck,FontFileInitFPE,FontFileFreeFPE,FontFileResetFPE,FontFileOpenFont,
             FontFileCloseFont,FontFileListFonts,FontFileStartListFontsWithInfo,
             FontFileListNextFontWithInfo,(WakeupFpeFunc)0x0,(ClientDiedFunc)0x0,(LoadGlyphsFunc)0x0
             ,FontFileStartListFontsAndAliases,FontFileListNextFontOrAlias,FontFileEmptyBitmapSource
            );
  return;
}



void bdfError(char *message,...)

{
  bdfError(message);
  return;
}



void inflate(void)

{
  inflate();
  return;
}



void FT_Set_Pixel_Sizes(void)

{
  FT_Set_Pixel_Sizes();
  return;
}



void FT_New_Size(void)

{
  FT_New_Size();
  return;
}



void FT_Done_Size(void)

{
  FT_Done_Size();
  return;
}



Bool FontFileRegisterBitmapSource(FontPathElementPtr fpe)

{
  FontPathElementPtr *pp_Var1;
  int iVar2;
  long lVar3;
  
  if (0 < FontFileBitmapSources.count) {
    pp_Var1 = FontFileBitmapSources.fpe;
    do {
      if (*pp_Var1 == fpe) {
        return 1;
      }
      pp_Var1 = pp_Var1 + 1;
    } while (pp_Var1 != FontFileBitmapSources.fpe + (ulong)(FontFileBitmapSources.count - 1) + 1);
  }
  pp_Var1 = FontFileBitmapSources.fpe;
  iVar2 = FontFileBitmapSources.size;
  if (FontFileBitmapSources.size == FontFileBitmapSources.count) {
    iVar2 = FontFileBitmapSources.count + 4;
    pp_Var1 = (FontPathElementPtr *)realloc(FontFileBitmapSources.fpe,(long)iVar2 << 3);
    if (pp_Var1 == (FontPathElementPtr *)0x0) {
      return 0;
    }
  }
  FontFileBitmapSources.size = iVar2;
  FontFileBitmapSources.fpe = pp_Var1;
  lVar3 = (long)FontFileBitmapSources.count;
  FontFileBitmapSources.count = FontFileBitmapSources.count + 1;
  FontFileBitmapSources.fpe[lVar3] = fpe;
  return 1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t writev(int __fd,iovec *__iovec,int __count)

{
  ssize_t sVar1;
  
  sVar1 = writev(__fd,__iovec,__count);
  return sVar1;
}



int FontFileReadDirectory(char *directory,FontDirectoryPtr *pdir)

{
  FontEntryPtr_conflict p_Var1;
  int iVar2;
  int iVar3;
  Bool BVar4;
  size_t sVar5;
  char *pcVar6;
  long lVar7;
  FILE *pFVar8;
  FontDirectoryPtr dir;
  undefined8 uVar9;
  uint *puVar10;
  uint *puVar11;
  FontRendererPtr p_Var12;
  FontEntryPtr p_Var13;
  int *piVar14;
  char cVar15;
  uint uVar16;
  uint uVar17;
  byte *pbVar18;
  long in_FS_OFFSET;
  bool bVar19;
  bool bVar20;
  byte bVar21;
  int iStack_2184;
  char *pcStack_2180;
  _FontName _Stack_2178;
  stat sStack_2168;
  stat sStack_20d8;
  char acStack_2048 [1024];
  char acStack_1c48 [1023];
  char acStack_1849 [1024];
  char cStack_1449;
  uint auStack_1448 [256];
  uint auStack_1048 [256];
  char acStack_c48 [1024];
  undefined auStack_848 [1024];
  char acStack_448 [1032];
  long lStack_40;
  
  bVar21 = 0;
  lStack_40 = *(long *)(in_FS_OFFSET + 0x28);
  sVar5 = strlen(directory);
  if (sVar5 + 0xb < 0x401) {
    pcVar6 = strchr(directory,0x3a);
    if (pcVar6 == (char *)0x0) {
      __memcpy_chk(auStack_1448,directory,sVar5 + 1,0x400);
    }
    else {
      __strncpy_chk(auStack_1448,directory,(long)pcVar6 - (long)directory,0x400);
      *(undefined *)((long)auStack_1448 + ((long)pcVar6 - (long)directory)) = 0;
    }
    pcVar6 = acStack_1849 + 1;
    lVar7 = __stpcpy_chk(pcVar6,auStack_1448,0x400);
    if (acStack_1849[lVar7 - (long)pcVar6] != '/') {
      __memcpy_chk(lVar7,&DAT_0013209c,2,(long)auStack_1448 - lVar7);
    }
    __strcat_chk(pcVar6,"fonts.dir",0x400);
    pFVar8 = fopen(pcVar6,"rt");
    if (pFVar8 == (FILE *)0x0) {
      piVar14 = __errno_location();
      if (*piVar14 == 2) {
        uVar9 = __strcpy_chk(auStack_848,auStack_1448,0x400);
        puVar11 = auStack_1448;
        do {
          puVar10 = puVar11;
          uVar16 = *puVar10 + 0xfefefeff & ~*puVar10;
          uVar17 = uVar16 & 0x80808080;
          puVar11 = puVar10 + 1;
        } while (uVar17 == 0);
        bVar19 = (uVar16 & 0x8080) == 0;
        if (bVar19) {
          uVar17 = uVar17 >> 0x10;
        }
        if (bVar19) {
          puVar11 = (uint *)((long)puVar10 + 6);
        }
        lVar7 = (long)puVar11 +
                ((-3 - (ulong)CARRY1((byte)uVar17,(byte)uVar17)) - (long)auStack_1448);
        dir = (FontDirectoryPtr)0x0;
        if (lVar7 + 0xdU < 0x401) goto LAB_0010b5cf;
      }
    }
    else {
      iVar2 = fileno(pFVar8);
      iVar2 = __fxstat(1,iVar2,&sStack_2168);
      if (((iVar2 == -1) || (iVar2 = __isoc99_fscanf(pFVar8,&DAT_001320ab,&iStack_2184), iVar2 != 1)
          ) || (dir = FontFileMakeDir(directory,iStack_2184), dir == (FontDirectoryPtr)0x0)) {
        fclose(pFVar8);
      }
      else {
        dir->dir_mtime = sStack_2168.st_mtim.tv_sec;
        if (FontFileReadDirectory::format[0] == '\0') {
          __sprintf_chk(FontFileReadDirectory::format,1,0x18,"%%%ds %%%d[^\n]\n",0x3ff,0x3ff);
        }
        while (iVar2 = __isoc99_fscanf(pFVar8,FontFileReadDirectory::format,acStack_2048,
                                       acStack_1c48), iVar2 != -1) {
          if (iVar2 != 2) {
            iVar2 = 0x56;
            FontFileFreeDir(dir);
            fclose(pFVar8);
            goto LAB_0010b506;
          }
          FontFileAddFontFile(dir,acStack_1c48,acStack_2048);
        }
        fclose(pFVar8);
        uVar9 = __strcpy_chk(auStack_848,auStack_1448,0x400);
        puVar11 = auStack_1448;
        do {
          puVar10 = puVar11;
          uVar16 = *puVar10 + 0xfefefeff & ~*puVar10;
          uVar17 = uVar16 & 0x80808080;
          puVar11 = puVar10 + 1;
        } while (uVar17 == 0);
        bVar19 = (uVar16 & 0x8080) == 0;
        if (bVar19) {
          uVar17 = uVar17 >> 0x10;
        }
        if (bVar19) {
          puVar11 = (uint *)((long)puVar10 + 6);
        }
        lVar7 = (long)puVar11 +
                ((-3 - (ulong)CARRY1((byte)uVar17,(byte)uVar17)) - (long)auStack_1448);
        if (0x400 < lVar7 + 0xdU) {
LAB_0010b4e7:
          iVar2 = 0x56;
          goto LAB_0010b80e;
        }
LAB_0010b5cf:
        if (*(char *)((long)auStack_1448 + lVar7 + -1) != '/') {
          uVar9 = __strcat_chk(uVar9,&DAT_0013209c,0x400);
        }
        pcVar6 = (char *)__strcat_chk(uVar9,"fonts.alias",0x400);
        pFVar8 = fopen(pcVar6,"rt");
        if (pFVar8 != (FILE *)0x0) {
          if ((dir == (FontDirectoryPtr)0x0) &&
             (dir = FontFileMakeDir((char *)auStack_1448,10), dir == (FontDirectoryPtr)0x0)) {
            iVar2 = 0x50;
            fclose(pFVar8);
            goto LAB_0010b506;
          }
          iVar2 = fileno(pFVar8);
          iVar2 = __fxstat(1,iVar2,&sStack_20d8);
          if (iVar2 != -1) {
            dir->alias_mtime = sStack_20d8.st_mtim.tv_sec;
LAB_0010b65d:
            do {
              iVar2 = lexAlias((FILE *)pFVar8,&pcStack_2180);
              pcVar6 = pcStack_2180;
              if (iVar2 == 2) {
                fclose(pFVar8);
                goto LAB_0010b8c8;
              }
              if (iVar2 == 3) {
LAB_0010b800:
                iVar2 = 0x50;
LAB_0010b806:
                fclose(pFVar8);
                goto LAB_0010b80e;
              }
            } while (iVar2 != 0);
            sVar5 = strlen(pcStack_2180);
            if (sVar5 < 0x400) {
              __memcpy_chk(auStack_1048,pcVar6,sVar5 + 1,0x400);
              iVar2 = lexAlias((FILE *)pFVar8,&pcStack_2180);
              if (iVar2 == 2) goto LAB_0010b954;
              if (2 < iVar2) {
                if (iVar2 == 3) goto code_r0x0010b8eb;
                goto LAB_0010b65d;
              }
              if (iVar2 == 0) {
                sVar5 = strlen(pcStack_2180);
                puVar11 = auStack_1048;
                if (0x3ff < sVar5) goto LAB_0010b954;
                do {
                  puVar10 = puVar11;
                  uVar16 = *puVar10 + 0xfefefeff & ~*puVar10;
                  uVar17 = uVar16 & 0x80808080;
                  puVar11 = puVar10 + 1;
                } while (uVar17 == 0);
                bVar19 = (uVar16 & 0x8080) == 0;
                if (bVar19) {
                  uVar17 = uVar17 >> 0x10;
                }
                if (bVar19) {
                  puVar11 = (uint *)((long)puVar10 + 6);
                }
                CopyISOLatin1Lowered
                          ((char *)auStack_1048,(char *)auStack_1048,
                           (((int)puVar11 + -3) - (uint)CARRY1((byte)uVar17,(byte)uVar17)) -
                           (int)auStack_1048);
                pcVar6 = pcStack_2180;
                sVar5 = strlen(pcStack_2180);
                CopyISOLatin1Lowered(acStack_c48,pcVar6,(int)sVar5);
                BVar4 = FontFileAddFontAlias(dir,(char *)auStack_1048,acStack_c48);
                if (BVar4 == 0) goto LAB_0010b800;
                goto LAB_0010b65d;
              }
              bVar19 = iVar2 == 0;
              bVar20 = iVar2 == 1;
              if (!bVar20) goto LAB_0010b65d;
              lVar7 = 0x13;
              puVar11 = auStack_1048;
              pbVar18 = (byte *)"FILE_NAMES_ALIASES";
              do {
                if (lVar7 == 0) break;
                lVar7 = lVar7 + -1;
                bVar19 = *(byte *)puVar11 < *pbVar18;
                bVar20 = *(byte *)puVar11 == *pbVar18;
                puVar11 = (uint *)((long)puVar11 + (ulong)bVar21 * -2 + 1);
                pbVar18 = pbVar18 + (ulong)bVar21 * -2 + 1;
              } while (bVar20);
              cVar15 = (!bVar19 && !bVar20) - bVar19;
              iVar2 = (int)cVar15;
              if (cVar15 == '\0') {
                if (0 < (dir->nonScalable).used) {
                  lVar7 = 0;
                  do {
                    p_Var1 = (dir->nonScalable).entries;
                    if (*(int *)((long)&p_Var1->type + lVar7) == 2) {
                      pcVar6 = *(char **)((long)&p_Var1->u + lVar7 + 8);
                      p_Var12 = FontFileMatchRenderer(pcVar6);
                      if (p_Var12 != (FontRendererPtr)0x0) {
                        sVar5 = strlen(pcVar6);
                        uVar17 = (int)sVar5 - p_Var12->fileSuffixLen;
                        if (uVar17 < 0x400) {
                          CopyISOLatin1Lowered(acStack_448,pcVar6,uVar17);
                          acStack_448[(int)uVar17] = '\0';
                          _Stack_2178.length = (short)uVar17;
                          _Stack_2178.name = acStack_448;
                          iVar3 = FontFileCountDashes(acStack_448,uVar17);
                          _Stack_2178.ndashes = (short)iVar3;
                          p_Var13 = FontFileFindNameInDir(&dir->nonScalable,&_Stack_2178);
                          if ((p_Var13 == (FontEntryPtr)0x0) &&
                             (BVar4 = FontFileAddFontAlias
                                                (dir,acStack_448,
                                                 *(char **)((long)&(((dir->nonScalable).entries)->
                                                                   name).name + lVar7)), BVar4 == 0)
                             ) goto LAB_0010b800;
                        }
                      }
                    }
                    iVar2 = iVar2 + 1;
                    lVar7 = lVar7 + 0x98;
                  } while (iVar2 < (dir->nonScalable).used);
                }
                goto LAB_0010b65d;
              }
            }
LAB_0010b954:
            iVar2 = 0x56;
            goto LAB_0010b806;
          }
          iVar2 = 0x56;
          fclose(pFVar8);
          goto LAB_0010b80e;
        }
        piVar14 = __errno_location();
        if (*piVar14 == 2) {
          if (dir != (FontDirectoryPtr)0x0) {
LAB_0010b8c8:
            iVar2 = 0x55;
            FontFileSortDir(dir);
            *pdir = dir;
            goto LAB_0010b506;
          }
        }
        else if (dir != (FontDirectoryPtr)0x0) goto LAB_0010b4e7;
      }
    }
  }
  iVar2 = 0x56;
  goto LAB_0010b506;
code_r0x0010b8eb:
  iVar2 = 0x50;
  fclose(pFVar8);
LAB_0010b80e:
  FontFileFreeDir(dir);
LAB_0010b506:
  if (lStack_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



BufFilePtr BufFileOpenWrite(int fd)

{
  BufFilePtr p_Var1;
  
  p_Var1 = BufFileCreate((char *)(long)fd,(_func_int_BufFilePtr *)0x0,BufFileRawFlush,
                         (_func_int_BufFilePtr_int *)0x0,BufFileFlush);
  p_Var1->left = 0x2000;
  p_Var1->bufp = p_Var1->buffer;
  return p_Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  qsort(__base,__nmemb,__size,__compar);
  return;
}



int FontFileStartListFonts
              (pointer client,FontPathElementPtr fpe,char *pat,int len,int max,pointer *privatep,
              int mark_aliases)

{
  int iVar1;
  undefined8 *__ptr;
  FontNamesPtr p_Var2;
  int in_stack_ffffffffffffffc8;
  
  __ptr = (undefined8 *)malloc(0x10);
  if (__ptr == (undefined8 *)0x0) {
    iVar1 = 0x50;
  }
  else {
    p_Var2 = MakeFontNamesRecord(0);
    *__ptr = p_Var2;
    if (p_Var2 == (FontNamesPtr)0x0) {
      iVar1 = 0x50;
      free(__ptr);
    }
    else {
      iVar1 = _FontFileListFonts(&fpe->private,(FontPathElementPtr)pat,(char *)(ulong)(uint)len,max,
                                 (int)p_Var2,(FontNamesPtr)(ulong)(uint)mark_aliases,
                                 in_stack_ffffffffffffffc8);
      if (iVar1 == 0x55) {
        *(undefined4 *)(__ptr + 1) = 0;
        *privatep = __ptr;
      }
      else {
        FreeFontNames((FontNamesPtr)*__ptr);
        free(__ptr);
      }
    }
  }
  return iVar1;
}



int _fs_wait_for_readable(FSFpePtr conn,int ms)

{
  int iVar1;
  
  iVar1 = _fs_wait_for_readable(conn,ms);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double strtod(char *__nptr,char **__endptr)

{
  double dVar1;
  
  dVar1 = strtod(__nptr,__endptr);
  return dVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int setsockopt(int __fd,int __level,int __optname,void *__optval,socklen_t __optlen)

{
  int iVar1;
  
  iVar1 = setsockopt(__fd,__level,__optname,__optval,__optlen);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

lconv * localeconv(void)

{
  lconv *plVar1;
  
  plVar1 = localeconv();
  return plVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t readlink(char *__path,char *__buf,size_t __len)

{
  ssize_t sVar1;
  
  sVar1 = readlink(__path,__buf,__len);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fcntl(int __fd,int __cmd,...)

{
  int iVar1;
  
  iVar1 = fcntl(__fd,__cmd);
  return iVar1;
}



Atom bdfForceMakeAtom(char *str,int *size)

{
  Atom AVar1;
  
  AVar1 = bdfForceMakeAtom(str,size);
  return AVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t write(int __fd,void *__buf,size_t __n)

{
  ssize_t sVar1;
  
  sVar1 = write(__fd,__buf,__n);
  return sVar1;
}



int FTGetEnglishName(FT_Face face,int nid,char *name_return,int name_len)

{
  int iVar1;
  
  iVar1 = FTGetEnglishName(face,nid,name_return,name_len);
  return iVar1;
}



int fs_load_all_glyphs(FontPtr pfont)

{
  int iVar1;
  
  iVar1 = fs_load_all_glyphs(pfont);
  return iVar1;
}



Bool FontFileAddFontAlias(FontDirectoryPtr dir,char *aliasName,char *fontName)

{
  int iVar1;
  Bool BVar2;
  size_t sVar3;
  FontEntryPtr p_Var4;
  long in_FS_OFFSET;
  _FontEntry _Stack_b8;
  long lStack_20;
  
  lStack_20 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = strcmp(aliasName,fontName);
  if (iVar1 != 0) {
    sVar3 = strlen(aliasName);
    _Stack_b8.name.length = (short)sVar3;
    CopyISOLatin1Lowered(aliasName,aliasName,(int)_Stack_b8.name.length);
    _Stack_b8.name.name = aliasName;
    iVar1 = FontFileCountDashes(aliasName,(int)_Stack_b8.name.length);
    _Stack_b8.type = 3;
    _Stack_b8.name.ndashes = (short)iVar1;
    _Stack_b8.u.scalable.renderer = (FontRendererPtr)strdup(fontName);
    if (_Stack_b8.u.scalable.renderer != (FontRendererPtr)0x0) {
      p_Var4 = FontFileAddEntry(&dir->nonScalable,&_Stack_b8);
      BVar2 = 1;
      if (p_Var4 != (FontEntryPtr)0x0) goto LAB_0010d17c;
      free(_Stack_b8.u.scalable.renderer);
    }
  }
  BVar2 = 0;
LAB_0010d17c:
  if (lStack_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar2;
}



XtransConnInfo _fs_connect(char *servername,int *err)

{
  XtransConnInfo p_Var1;
  
  p_Var1 = _fs_connect(servername,err);
  return p_Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getpeername(int __fd,sockaddr *__addr,socklen_t *__len)

{
  int iVar1;
  
  iVar1 = getpeername(__fd,__addr,__len);
  return iVar1;
}



FontEntryPtr FontFileAddEntry(FontTablePtr table,FontEntryPtr prototype)

{
  FontEntryPtr p_Var1;
  int iVar2;
  FontRendererPtr p_Var3;
  FontScalableExtraPtr p_Var4;
  undefined8 uVar5;
  short sVar6;
  short sVar7;
  undefined4 uVar8;
  char *__dest;
  FontEntryPtr_conflict __ptr;
  
  if (table->sorted == 0) {
    iVar2 = table->used;
    __ptr = table->entries;
    if (iVar2 == table->size) {
      __ptr = (FontEntryPtr_conflict)realloc(__ptr,(long)(iVar2 + 100) * 0x98);
      if (__ptr == (FontEntryPtr_conflict)0x0) {
        return (FontEntryPtr)0x0;
      }
      table->size = iVar2 + 100;
      iVar2 = table->used;
      table->entries = __ptr;
    }
    sVar6 = (prototype->name).length;
    sVar7 = (prototype->name).ndashes;
    uVar8 = *(undefined4 *)&(prototype->name).field_0xc;
    p_Var1 = __ptr + iVar2;
    (p_Var1->name).name = (prototype->name).name;
    (p_Var1->name).length = sVar6;
    (p_Var1->name).ndashes = sVar7;
    *(undefined4 *)&(p_Var1->name).field_0xc = uVar8;
    uVar8 = *(undefined4 *)&prototype->field_0x14;
    p_Var3 = (prototype->u).scalable.renderer;
    p_Var1->type = prototype->type;
    *(undefined4 *)&p_Var1->field_0x14 = uVar8;
    (p_Var1->u).scalable.renderer = p_Var3;
    p_Var4 = (prototype->u).scalable.extra;
    (p_Var1->u).scalable.fileName = (prototype->u).scalable.fileName;
    (p_Var1->u).scalable.extra = p_Var4;
    uVar5 = *(undefined8 *)((long)&prototype->u + 0x20);
    *(undefined8 *)((long)&p_Var1->u + 0x18) = *(undefined8 *)((long)&prototype->u + 0x18);
    *(undefined8 *)((long)&p_Var1->u + 0x20) = uVar5;
    uVar5 = *(undefined8 *)((long)&prototype->u + 0x30);
    *(undefined8 *)((long)&p_Var1->u + 0x28) = *(undefined8 *)((long)&prototype->u + 0x28);
    *(undefined8 *)((long)&p_Var1->u + 0x30) = uVar5;
    uVar5 = *(undefined8 *)((long)&prototype->u + 0x40);
    *(undefined8 *)((long)&p_Var1->u + 0x38) = *(undefined8 *)((long)&prototype->u + 0x38);
    *(undefined8 *)((long)&p_Var1->u + 0x40) = uVar5;
    uVar5 = *(undefined8 *)((long)&prototype->u + 0x50);
    *(undefined8 *)((long)&p_Var1->u + 0x48) = *(undefined8 *)((long)&prototype->u + 0x48);
    *(undefined8 *)((long)&p_Var1->u + 0x50) = uVar5;
    uVar5 = *(undefined8 *)((long)&prototype->u + 0x60);
    *(undefined8 *)((long)&p_Var1->u + 0x58) = *(undefined8 *)((long)&prototype->u + 0x58);
    *(undefined8 *)((long)&p_Var1->u + 0x60) = uVar5;
    uVar5 = *(undefined8 *)((long)&prototype->u + 0x70);
    *(undefined8 *)((long)&p_Var1->u + 0x68) = *(undefined8 *)((long)&prototype->u + 0x68);
    *(undefined8 *)((long)&p_Var1->u + 0x70) = uVar5;
    (p_Var1->u).bc.entry = (prototype->u).bc.entry;
    __dest = (char *)malloc((long)((prototype->name).length + 1));
    (p_Var1->name).name = __dest;
    if (__dest != (char *)0x0) {
      memcpy(__dest,(prototype->name).name,(long)(prototype->name).length);
      (p_Var1->name).name[(p_Var1->name).length] = '\0';
      table->used = table->used + 1;
      return p_Var1;
    }
  }
  return (FontEntryPtr)0x0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}



void FontFileSortDir(FontDirectoryPtr dir)

{
  FontFileSortTable(&dir->scalable);
  FontFileSortTable(&dir->nonScalable);
  FontFileSwitchStringsToBitmapPointers(dir);
  return;
}



int _FontTransClose(XtransConnInfo ciptr)

{
  int iVar1;
  
  iVar1 = _FontTransClose(ciptr);
  return iVar1;
}



void _fs_done_read(FSFpePtr conn,long size)

{
  _fs_done_read(conn,size);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

DIR * opendir(char *__name)

{
  DIR *pDVar1;
  
  pDVar1 = opendir(__name);
  return pDVar1;
}



void _fs_io_fini(FSFpePtr conn)

{
  _fs_io_fini(conn);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int shutdown(int __fd,int __how)

{
  int iVar1;
  
  iVar1 = shutdown(__fd,__how);
  return iVar1;
}



void FT_Done_Face(void)

{
  FT_Done_Face();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * stpcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = stpcpy(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention

void DeleteFontClientID(Font id)

{
  DeleteFontClientID(id);
  return;
}



int _fs_poll_connect(XtransConnInfo trans_conn,int timeout)

{
  int iVar1;
  
  iVar1 = _fs_poll_connect(trans_conn,timeout);
  return iVar1;
}



void QueryGlyphExtents(FontPtr pFont,CharInfoPtr *charinfo,ulong count,ExtentInfoRec *info)

{
  QueryGlyphExtents(pFont,charinfo,count,info);
  return;
}



Bool FontFileCompleteXLFD(FontScalablePtr vals,FontScalablePtr def)

{
  ushort uVar1;
  uint uVar2;
  Bool BVar3;
  FontResolutionPtr p_Var4;
  uint uVar5;
  uint uVar6;
  long in_FS_OFFSET;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  int iStack_24;
  long lStack_20;
  
  lStack_20 = *(long *)(in_FS_OFFSET + 0x28);
  p_Var4 = GetClientResolutions(&iStack_24);
  uVar5 = vals->values_supplied;
  if (((uVar5 & 3) == 0) || ((uVar5 & 0xc) == 0)) {
    uVar2 = vals->x;
    uVar6 = vals->y;
    if (iStack_24 == 0) {
LAB_0010f8d1:
      if ((int)uVar2 < 1) {
        uVar2 = def->x;
        vals->x = uVar2;
        if ((int)uVar6 < 1) goto LAB_0010f8df;
        if ((int)uVar2 < 1) goto LAB_0010f8f0;
      }
      else if ((int)uVar6 < 1) {
LAB_0010f8df:
        vals->y = def->y;
        goto LAB_0010f8e5;
      }
    }
    else {
      if ((int)uVar2 < 1) {
        uVar2 = (uint)p_Var4->x_resolution;
        vals->x = uVar2;
        if ((int)uVar6 < 1) goto LAB_0010f8ca;
        goto LAB_0010f8d1;
      }
      if ((int)uVar6 < 1) {
LAB_0010f8ca:
        uVar6 = (uint)p_Var4->y_resolution;
        vals->y = uVar6;
        goto LAB_0010f8d1;
      }
    }
LAB_0010f734:
    if ((uVar5 & 0xf) == 0) {
      if (iStack_24 == 0) {
        if ((*(byte *)&def->values_supplied & 0xc) == 0) goto LAB_0010f8f0;
        vals->point_matrix[0] = def->point_matrix[0];
        vals->point_matrix[1] = def->point_matrix[1];
        vals->point_matrix[2] = def->point_matrix[2];
        vals->point_matrix[3] = def->point_matrix[3];
        uVar5 = uVar5 & 0xfffffff3 | def->values_supplied & 0xcU;
        vals->values_supplied = uVar5;
      }
      else {
        uVar1 = p_Var4->point_size;
        vals->point_matrix[2] = 0.0;
        uVar5 = uVar5 & 0xfffffff3 | 4;
        vals->point_matrix[1] = 0.0;
        vals->values_supplied = uVar5;
        dVar13 = (double)uVar1 / 10.0;
        vals->point_matrix[3] = dVar13;
        vals->point_matrix[0] = dVar13;
      }
    }
    dVar13 = 1.0;
    if ((uVar5 & 3) == 1) {
      uVar5 = uVar5 | 3;
      dVar13 = (double)(int)uVar2 / (double)(int)uVar6;
      vals->values_supplied = uVar5;
      vals->pixel_matrix[0] = vals->pixel_matrix[0] * dVar13;
    }
    dVar8 = (double)(int)uVar2 / 72.27;
    dVar9 = (double)(int)uVar6 / 72.27;
    if ((uVar5 & 0xc) == 0) goto LAB_0010f950;
    dVar7 = vals->point_matrix[0];
    dVar11 = vals->point_matrix[1];
    dVar12 = vals->point_matrix[2];
    dVar10 = vals->point_matrix[3];
    while( true ) {
      dVar7 = dVar7 * dVar8;
      if (((uVar5 & 3) != 0) &&
         ((((dVar13 < ABS(vals->pixel_matrix[0] - dVar7) ||
            (1.0 < ABS(vals->pixel_matrix[1] - dVar11 * dVar9))) ||
           (1.0 < ABS(vals->pixel_matrix[2] - dVar12 * dVar8))) ||
          (1.0 < ABS(vals->pixel_matrix[3] - dVar10 * dVar9))))) goto LAB_0010f8f0;
      if ((uVar5 & 0xf) != 6) break;
LAB_0010f950:
      if ((ABS(dVar8) < 1e-20) || (ABS(dVar9) < 1e-20)) goto LAB_0010f8f0;
      dVar7 = vals->pixel_matrix[0];
      dVar12 = vals->pixel_matrix[2];
      dVar10 = vals->pixel_matrix[3];
      dVar11 = vals->pixel_matrix[1] / dVar9;
      uVar2 = (uint)((vals->values_supplied & 3U) == 2) * 4 + 4;
      uVar5 = vals->values_supplied & 0xfffffff3U | uVar2;
      vals->values_supplied = uVar5;
      vals->point_matrix[1] = dVar11;
      dVar12 = dVar12 / dVar8;
      vals->point_matrix[0] = dVar7 / dVar8;
      dVar10 = dVar10 / dVar9;
      vals->point_matrix[2] = dVar12;
      vals->point_matrix[3] = dVar10;
      if (uVar2 != 4) goto LAB_0010f9e4;
      dVar7 = (double)(int)((dVar7 / dVar8) * 10.0 + 0.5) / 10.0;
      dVar10 = (double)(int)(dVar10 * 10.0 + 0.5) / 10.0;
      vals->point_matrix[0] = dVar7;
      vals->point_matrix[3] = dVar10;
    }
    vals->pixel_matrix[0] = dVar7;
    vals->pixel_matrix[1] = dVar11 * dVar9;
    vals->pixel_matrix[2] = dVar12 * dVar8;
    vals->pixel_matrix[3] = dVar10 * dVar9;
    vals->values_supplied = uVar5 & 0xfffffffc | ((uVar5 & 0xc) != 8) + 2;
LAB_0010f9e4:
    dVar13 = xlfd_round_double(dVar7);
    vals->pixel_matrix[0] = dVar13;
    dVar13 = xlfd_round_double(vals->pixel_matrix[1]);
    vals->pixel_matrix[1] = dVar13;
    dVar13 = xlfd_round_double(vals->pixel_matrix[2]);
    vals->pixel_matrix[2] = dVar13;
    dVar13 = xlfd_round_double(vals->pixel_matrix[3]);
    vals->pixel_matrix[3] = dVar13;
    dVar13 = xlfd_round_double(vals->point_matrix[0]);
    vals->point_matrix[0] = dVar13;
    dVar13 = xlfd_round_double(vals->point_matrix[1]);
    vals->point_matrix[1] = dVar13;
    dVar13 = xlfd_round_double(vals->point_matrix[2]);
    vals->point_matrix[2] = dVar13;
    dVar13 = xlfd_round_double(vals->point_matrix[3]);
    vals->point_matrix[3] = dVar13;
    vals->point = (int)(dVar13 * 10.0);
    vals->pixel = (int)vals->pixel_matrix[3];
    BVar3 = 1;
  }
  else {
    if (vals->y < 1) {
      dVar13 = hypot(vals->pixel_matrix[1],vals->pixel_matrix[3]);
      dVar8 = hypot(vals->point_matrix[1],vals->point_matrix[3]);
      if (1e-20 <= dVar8) {
        uVar2 = vals->x;
        vals->y = (int)((dVar13 * 72.27) / dVar8 + 0.5);
        if ((int)uVar2 < 1) {
          uVar5 = vals->values_supplied;
          goto LAB_0010fb30;
        }
LAB_0010f8e9:
        uVar6 = vals->y;
        if (0 < (int)uVar6) goto LAB_0010f943;
      }
    }
    else {
      uVar2 = vals->x;
      if (0 < (int)uVar2) {
        uVar6 = vals->y;
LAB_0010f943:
        uVar5 = vals->values_supplied;
        goto LAB_0010f734;
      }
LAB_0010fb30:
      if ((uVar5 & 2) == 0) {
        uVar2 = vals->y;
        vals->x = uVar2;
      }
      else {
        dVar13 = hypot(vals->pixel_matrix[0],vals->pixel_matrix[2]);
        dVar8 = hypot(vals->point_matrix[0],vals->point_matrix[2]);
        if (dVar8 < 1e-20) goto LAB_0010f8f0;
        uVar2 = (uint)((dVar13 * 72.27) / dVar8 + 0.5);
        vals->x = uVar2;
      }
LAB_0010f8e5:
      if (0 < (int)uVar2) goto LAB_0010f8e9;
    }
LAB_0010f8f0:
    BVar3 = 0;
  }
  if (lStack_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar3;
}



// WARNING: Unknown calling convention

int RegisterFPEFunctions
              (NameCheckFunc name_func,InitFpeFunc init_func,FreeFpeFunc free_func,
              ResetFpeFunc reset_func,OpenFontFunc open_func,CloseFontFunc close_func,
              ListFontsFunc list_func,StartLfwiFunc start_lfwi_func,NextLfwiFunc next_lfwi_func,
              WakeupFpeFunc wakeup_func,ClientDiedFunc client_died,LoadGlyphsFunc load_glyphs,
              StartLaFunc start_list_alias_func,NextLaFunc next_list_alias_func,
              SetPathFunc set_path_func)

{
  int iVar1;
  
  iVar1 = RegisterFPEFunctions
                    (name_func,init_func,free_func,reset_func,open_func,close_func,list_func,
                     start_lfwi_func,next_lfwi_func,wakeup_func,client_died,load_glyphs,
                     start_list_alias_func,next_list_alias_func,set_path_func);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



int _fs_convert_lfwi_reply
              (FSFpePtr_conflict conn,FontInfoPtr pfi,fsListFontsWithXInfoReply *fsrep,
              fsPropInfo *pi,fsPropOffset *po,pointer pd)

{
  int iVar1;
  
  iVar1 = _fs_convert_lfwi_reply(conn,pfi,fsrep,pi,po,pd);
  return iVar1;
}



BufFilePtr BufFilePushCompressed(BufFilePtr f)

{
  int iVar1;
  byte *pbVar2;
  uint uVar3;
  char *private;
  char *pcVar4;
  BufFilePtr p_Var5;
  long lVar6;
  long lVar7;
  uint uVar8;
  
  iVar1 = f->left;
  f->left = iVar1 + -1;
  if (iVar1 == 0) {
    uVar3 = (*f->input)(f);
    f->eof = uVar3;
  }
  else {
    pbVar2 = f->bufp;
    f->bufp = pbVar2 + 1;
    uVar3 = (uint)*pbVar2;
  }
  if (uVar3 == 0x1f) {
    iVar1 = f->left;
    f->left = iVar1 + -1;
    if (iVar1 == 0) {
      uVar3 = (*f->input)(f);
      f->eof = uVar3;
    }
    else {
      pbVar2 = f->bufp;
      f->bufp = pbVar2 + 1;
      uVar3 = (uint)*pbVar2;
    }
    if (uVar3 == 0x9d) {
      iVar1 = f->left;
      f->left = iVar1 + -1;
      if (iVar1 == 0) {
        uVar3 = (*f->input)(f);
        f->eof = uVar3;
        if (uVar3 == 0xffffffff) {
          return (BufFilePtr)0x0;
        }
      }
      else {
        pbVar2 = f->bufp;
        f->bufp = pbVar2 + 1;
        uVar3 = (uint)*pbVar2;
      }
      uVar8 = uVar3 & 0x1f;
      if (uVar8 - 10 < 7) {
        lVar7 = (long)(1 << (sbyte)uVar8);
        private = (char *)malloc((ulong)(uint)(3 << (sbyte)uVar8) + 0xff88);
        if (private != (char *)0x0) {
          *(BufFilePtr *)private = f;
          lVar6 = 0xff;
          *(uint *)(private + 0x20) = uVar8;
          *(uint *)(private + 0x1c) = uVar3 & 0x80;
          *(long *)(private + 0x30) = lVar7;
          *(char **)(private + 0xff78) = private + 0xff88;
          pcVar4 = private + 0xff88 + lVar7;
          *(char **)(private + 0xff80) = pcVar4;
          private[0x44] = '\t';
          private[0x45] = '\0';
          private[0x46] = '\0';
          private[0x47] = '\0';
          private[0x28] = -1;
          private[0x29] = '\x01';
          private[0x2a] = '\0';
          private[0x2b] = '\0';
          private[0x2c] = '\0';
          private[0x2d] = '\0';
          private[0x2e] = '\0';
          private[0x2f] = '\0';
          while( true ) {
            (pcVar4 + lVar6 * 2)[0] = '\0';
            (pcVar4 + lVar6 * 2)[1] = '\0';
            *(char *)(*(long *)(private + 0xff78) + lVar6) = (char)lVar6;
            lVar6 = lVar6 + -1;
            if (lVar6 == -1) break;
            pcVar4 = *(char **)(private + 0xff80);
          }
          private[0x40] = '\0';
          private[0x41] = '\0';
          private[0x42] = '\0';
          private[0x43] = '\0';
          private[0x10] = -1;
          private[0x11] = -1;
          private[0x12] = -1;
          private[0x13] = -1;
          private[0x14] = -1;
          private[0x15] = -1;
          private[0x16] = -1;
          private[0x17] = -1;
          private[0x48] = '\0';
          private[0x49] = '\0';
          private[0x4a] = '\0';
          private[0x4b] = '\0';
          private[0x4c] = '\0';
          private[0x4d] = '\0';
          private[0x4e] = '\0';
          private[0x4f] = '\0';
          *(undefined (*) [16])(private + 0x50) = (undefined  [16])0x0;
          *(ulong *)(private + 0x38) = (ulong)(*(int *)(private + 0x1c) != 0) + 0x100;
          *(char **)(private + 8) = private + 0x60;
          p_Var5 = BufFileCreate(private,BufCompressedFill,(_func_int_int_BufFilePtr *)0x0,
                                 BufCompressedSkip,BufCompressedClose);
          return p_Var5;
        }
      }
    }
  }
  return (BufFilePtr)0x0;
}



int _fs_start_read(FSFpePtr conn,long size,char **buf)

{
  int iVar1;
  
  iVar1 = _fs_start_read(conn,size,buf);
  return iVar1;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



BufFilePtr BufFileOpenRead(int fd)

{
  BufFilePtr p_Var1;
  
  p_Var1 = BufFileCreate((char *)(long)fd,BufFileRawFill,(_func_int_int_BufFilePtr *)0x0,
                         BufFileRawSkip,BufFileRawClose);
  return p_Var1;
}



void DestroyFontRec(FontPtr pFont)

{
  DestroyFontRec(pFont);
  return;
}



void FontFileFreeEntry(FontEntryPtr entry)

{
  char *__ptr;
  FontScalableExtraPtr __ptr_00;
  void *__ptr_01;
  int iVar1;
  long lVar2;
  FontScaledPtr __ptr_02;
  
  __ptr = (entry->name).name;
  if (__ptr != (char *)0x0) {
    free(__ptr);
  }
  iVar1 = entry->type;
  (entry->name).name = (char *)0x0;
  if (iVar1 == 2) {
    free((entry->u).scalable.fileName);
    (entry->u).scalable.fileName = (char *)0x0;
    return;
  }
  if (iVar1 == 3) {
    free((entry->u).scalable.renderer);
    (entry->u).scalable.renderer = (FontRendererPtr)0x0;
    return;
  }
  if (iVar1 == 0) {
    free((entry->u).scalable.fileName);
    __ptr_00 = (entry->u).scalable.extra;
    __ptr_02 = __ptr_00->scaled;
    if (0 < __ptr_00->numScaled) {
      lVar2 = 0;
      iVar1 = 0;
      do {
        __ptr_01 = *(void **)((long)(__ptr_02->vals).point_matrix + lVar2 + 0x48);
        if (__ptr_01 != (void *)0x0) {
          free(__ptr_01);
          __ptr_02 = __ptr_00->scaled;
        }
        iVar1 = iVar1 + 1;
        lVar2 = lVar2 + 0x88;
      } while (iVar1 < __ptr_00->numScaled);
    }
    free(__ptr_02);
    free(__ptr_00);
    return;
  }
  return;
}



void FontEncIdentify(void)

{
  FontEncIdentify();
  return;
}



Bool FontFileMatchName(char *name,int length,FontNamePtr pat)

{
  int iVar1;
  FontEntryPtr p_Var2;
  long in_FS_OFFSET;
  _FontTable _Stack_c8;
  _FontEntry _Stack_a8;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  _Stack_c8.used = 1;
  _Stack_c8.size = 1;
  _Stack_c8.entries = &_Stack_a8;
  _Stack_a8.name.length = (short)length;
  _Stack_c8.sorted = 1;
  _Stack_a8.name.name = name;
  iVar1 = FontFileCountDashes(name,length);
  _Stack_a8.name.ndashes = (short)iVar1;
  p_Var2 = FontFileFindNameInDir(&_Stack_c8,pat);
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (Bool)(p_Var2 != (FontEntryPtr)0x0);
}



void _FontTransFreeConnInfo(XtransConnInfo ciptr)

{
  _FontTransFreeConnInfo(ciptr);
  return;
}



void FT_Activate_Size(void)

{
  FT_Activate_Size();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strchr(__s,__c);
  return pcVar1;
}



int _FontTransConnect(XtransConnInfo ciptr,char *address)

{
  int iVar1;
  
  iVar1 = _FontTransConnect(ciptr,address);
  return iVar1;
}



void __fdelt_chk(void)

{
  __fdelt_chk();
  return;
}



// WARNING: Unknown calling convention

int FTtoXReturnCode(int rc)

{
  int iVar1;
  
  iVar1 = FTtoXReturnCode(rc);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * gai_strerror(int __ecode)

{
  char *pcVar1;
  
  pcVar1 = gai_strerror(__ecode);
  return pcVar1;
}



FontDirectoryPtr FontFileMakeDir(char *dirName,int size)

{
  Bool BVar1;
  char *pcVar2;
  size_t sVar3;
  FontDirectoryPtr __ptr;
  char *pcVar4;
  size_t sVar5;
  size_t sVar6;
  FontDirectoryPtr p_Var7;
  bool bVar8;
  int iStack_40;
  
  pcVar2 = strchr(dirName,0x3a);
  if (pcVar2 == (char *)0x0) {
    sVar5 = strlen(dirName);
    sVar5 = (size_t)(int)sVar5;
    if (dirName[sVar5 - 1] == '/') {
      iStack_40 = 0;
      bVar8 = false;
      sVar3 = sVar5;
      sVar6 = sVar5;
    }
    else {
      iStack_40 = 0;
      bVar8 = true;
      sVar3 = sVar5 + 1;
      sVar6 = sVar5 + 1;
    }
  }
  else {
    sVar3 = strlen(pcVar2);
    sVar5 = (size_t)((int)pcVar2 - (int)dirName);
    iStack_40 = (int)sVar3;
    bVar8 = dirName[sVar5 - 1] != '/';
    sVar6 = bVar8 + sVar5;
    sVar3 = sVar6;
    if (iStack_40 != 0) {
      sVar3 = (long)(iStack_40 + 1) + sVar6;
    }
  }
  __ptr = (FontDirectoryPtr)malloc(sVar3 + 0x51);
  p_Var7 = __ptr;
  if (__ptr != (FontDirectoryPtr)0x0) {
    BVar1 = FontFileInitTable(&__ptr->scalable,0);
    if (BVar1 != 0) {
      BVar1 = FontFileInitTable(&__ptr->nonScalable,size);
      if (BVar1 != 0) {
        __ptr->dir_mtime = 0;
        pcVar4 = (char *)((long)&__ptr[1].directory + sVar6 + 1);
        __ptr->directory = (char *)(__ptr + 1);
        __ptr->alias_mtime = 0;
        if (iStack_40 == 0) {
          pcVar4 = (char *)0x0;
        }
        __ptr->attributes = pcVar4;
        pcVar4 = strncpy((char *)(__ptr + 1),dirName,sVar5);
        pcVar4[sVar5] = '\0';
        if (__ptr->attributes != (char *)0x0) {
          strcpy(__ptr->attributes,pcVar2);
        }
        if (!bVar8) {
          return __ptr;
        }
        pcVar2 = __ptr->directory;
        sVar5 = strlen(pcVar2);
        pcVar2 = pcVar2 + sVar5;
        pcVar2[0] = '/';
        pcVar2[1] = '\0';
        return __ptr;
      }
      FontFileFreeTable(&__ptr->scalable);
    }
    p_Var7 = (FontDirectoryPtr)0x0;
    free(__ptr);
  }
  return p_Var7;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strrchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strrchr(__s,__c);
  return pcVar1;
}



void FT_New_Face(void)

{
  FT_New_Face();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BuiltinRegisterFontFileFunctions(void)

{
  BuiltinRegisterFontFileFunctions();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int uname(utsname *__name)

{
  int iVar1;
  
  iVar1 = uname(__name);
  return iVar1;
}



// WARNING: Unknown calling convention

long _fs_pad_length(long len)

{
  long lVar1;
  
  lVar1 = _fs_pad_length(len);
  return lVar1;
}



int BuiltinReadDirectory(char *directory,FontDirectoryPtr *pdir)

{
  int iVar1;
  
  iVar1 = BuiltinReadDirectory(directory,pdir);
  return iVar1;
}



void FT_Init_FreeType(void)

{
  FT_Init_FreeType();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__off_t lseek(int __fd,__off_t __offset,int __whence)

{
  __off_t _Var1;
  
  _Var1 = lseek(__fd,__offset,__whence);
  return _Var1;
}



// WARNING: Unknown calling convention

int GetDefaultPointSize(void)

{
  int iVar1;
  
  iVar1 = GetDefaultPointSize();
  return iVar1;
}



void FontEncName(void)

{
  FontEncName();
  return;
}



uchar bdfHexByte(uchar *s)

{
  uchar uVar1;
  
  uVar1 = bdfHexByte(s);
  return uVar1;
}



int FontFileOpenBitmap(FontPathElementPtr fpe,FontPtr *pFont,int flags,FontEntryPtr entry,
                      fsBitmapFormat format,fsBitmapFormatMask fmask)

{
  int iVar1;
  
  iVar1 = FontFileOpenBitmapNCF(fpe,pFont,flags,entry,format,fmask,(FontPtr)0x0);
  return iVar1;
}



// WARNING: Unknown calling convention

void FontComputeInfoAccelerators(FontInfoPtr pFontInfo)

{
  FontComputeInfoAccelerators(pFontInfo);
  return;
}



// WARNING: Unknown calling convention

void FontDefaultFormat(int *bit,int *byte,int *glyph,int *scan)

{
  *bit = 1;
  *byte = 1;
  *glyph = 4;
  *scan = 1;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memset(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memset(__s,__c,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention

Bool SPropRecValList_new(SDynPropRecValList *pThisList)

{
  Bool BVar1;
  
  BVar1 = SPropRecValList_new(pThisList);
  return BVar1;
}



void FontEncRecode(void)

{
  FontEncRecode();
  return;
}



FontFilePtr BuiltinFileOpen(char *name)

{
  FontFilePtr p_Var1;
  
  p_Var1 = BuiltinFileOpen(name);
  return p_Var1;
}



int FontFileFindNamesInScalableDir
              (FontTablePtr table,FontNamePtr pat,int max,FontNamesPtr names,FontScalablePtr vals,
              int alias_behavior,int *newmax)

{
  FontRendererPtr __s;
  uint uVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  Bool BVar5;
  ulong uVar6;
  size_t sVar7;
  char *string;
  FontEntryPtr_conflict p_Var8;
  long in_FS_OFFSET;
  uint uStack_c4;
  int iStack_c0;
  undefined auStack_bc [124];
  long lStack_40;
  
  iVar2 = 0x55;
  lStack_40 = *(long *)(in_FS_OFFSET + 0x28);
  if (0 < max) {
    uVar1 = SetupWildMatch(table,(FontNamePtr)pat->name,(int *)(ulong)(ushort)pat->ndashes,
                           (int *)&uStack_c4,&iStack_c0,(FontNamePtr)auStack_bc);
    uVar6 = (ulong)uVar1;
    if ((int)uVar1 < 0) {
      uVar6 = (ulong)(int)uStack_c4;
      p_Var8 = table->entries + uVar6;
    }
    else {
      p_Var8 = table->entries + (int)uVar1;
      if ((alias_behavior == 0) || (p_Var8->type != 3)) {
        if (newmax != (int *)0x0) {
          *newmax = max + -1;
        }
        iVar2 = AddFontNamesName(names,(p_Var8->name).name,(int)(p_Var8->name).length);
        goto LAB_0010c86b;
      }
      iStack_c0 = uVar1 + 1;
      uStack_c4 = uVar1;
    }
    if ((int)uVar6 < iStack_c0) {
      do {
        iVar2 = (int)(p_Var8->name).ndashes;
        if ((int)auStack_bc._0_4_ <= iVar2) {
          string = (p_Var8->name).name;
          iVar2 = PatternMatch(pat->name,auStack_bc._0_4_,string,iVar2);
          if (0 < iVar2) {
            if (vals != (FontScalablePtr)0x0) {
              uVar1 = vals->values_supplied;
              if (p_Var8->type == 0) {
                uVar4 = ((p_Var8->u).scalable.renderer)->capabilities;
                if ((uVar1 & 3) != 2) goto LAB_0010c8ed;
LAB_0010c9aa:
                if ((uVar4 & 1) == 0) goto LAB_0010c94a;
              }
              else {
                uVar4 = -(uint)(p_Var8->type == 3);
                if ((uVar1 & 3) == 2) goto LAB_0010c9aa;
LAB_0010c8ed:
                if ((uVar1 & 0xc) == 8) goto LAB_0010c9aa;
              }
              if (((uVar1 & 0x40) != 0) && ((uVar4 & 2) == 0)) goto LAB_0010c94a;
            }
            if (((alias_behavior & 2U) != 0) && (p_Var8->type == 3)) {
              BVar5 = FontParseXLFDName(string,(FontScalablePtr)(auStack_bc + 4),0);
              if ((BVar5 != 0) && ((auStack_bc[4] & 0xf) == 0)) goto LAB_0010c94a;
              string = (p_Var8->name).name;
            }
            iVar3 = AddFontNamesName(names,string,(int)(p_Var8->name).length);
            iVar2 = iVar3;
            if (iVar3 != 0x55) goto LAB_0010c9be;
            if (((alias_behavior & 1U) != 0) && (p_Var8->type == 3)) {
              names->length[(long)names->nnames + -1] = -names->length[(long)names->nnames + -1];
              __s = (p_Var8->u).scalable.renderer;
              sVar7 = strlen((char *)__s);
              iVar2 = AddFontNamesName(names,(char *)__s,(int)sVar7);
              if (iVar2 != 0x55) goto LAB_0010c9be;
            }
            max = max + -1;
            iVar2 = iVar3;
            if (max == 0) goto LAB_0010c9be;
          }
        }
LAB_0010c94a:
        uVar1 = (int)uVar6 + 1;
        uVar6 = (ulong)uVar1;
        p_Var8 = p_Var8 + 1;
      } while ((int)uVar1 < iStack_c0);
    }
    iVar2 = 0x55;
LAB_0010c9be:
    if (newmax != (int *)0x0) {
      *newmax = max;
    }
  }
LAB_0010c86b:
  if (lStack_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ioctl(int __fd,ulong __request,...)

{
  int iVar1;
  
  iVar1 = ioctl(__fd,__request);
  return iVar1;
}



int FontFileMatchBitmapSource
              (FontPathElementPtr fpe,FontPtr *pFont,int flags,FontEntryPtr_conflict entry,
              FontNamePtr zeroPat,FontScalablePtr vals,fsBitmapFormat format,
              fsBitmapFormatMask fmask,Bool noSpecificSize)

{
  FontPtr p_Var1;
  int iVar2;
  FontEntryPtr p_Var3;
  FontScaledPtr p_Var4;
  long lVar5;
  
  if (0 < FontFileBitmapSources.count) {
    lVar5 = 0;
    do {
      if (((FontFileBitmapSources.fpe[lVar5] != fpe) &&
          (p_Var3 = FontFileFindNameInDir
                              ((FontTablePtr)
                               ((long)FontFileBitmapSources.fpe[lVar5]->private + 0x18),zeroPat),
          p_Var3 != (FontEntryPtr)0x0)) &&
         (p_Var4 = FontFileFindScaledInstance(p_Var3,vals,noSpecificSize),
         p_Var4 != (FontScaledPtr)0x0)) {
        p_Var1 = p_Var4->pFont;
        if (p_Var1 != (FontPtr)0x0) {
          *pFont = p_Var1;
          p_Var1->fpe = FontFileBitmapSources.fpe[lVar5];
          return 0x55;
        }
        p_Var3 = p_Var4->bitmap;
        if (p_Var3 == (FontEntryPtr)0x0) {
          return 0x53;
        }
        p_Var1 = (FontPtr)(p_Var3->u).scalable.extra;
        if (p_Var1 != (FontPtr)0x0) {
          *pFont = p_Var1;
          p_Var1->fpe = FontFileBitmapSources.fpe[lVar5];
          return 0x55;
        }
        iVar2 = FontFileOpenBitmap(FontFileBitmapSources.fpe[lVar5],pFont,flags,p_Var3,format,fmask)
        ;
        if (iVar2 == 0x55) {
          if (*pFont != (FontPtr)0x0) {
            (*pFont)->fpe = FontFileBitmapSources.fpe[lVar5];
            return 0x55;
          }
          return 0x55;
        }
        return iVar2;
      }
      lVar5 = lVar5 + 1;
    } while ((int)lVar5 < FontFileBitmapSources.count);
  }
  return 0x53;
}



double xlfd_round_double(double x)

{
  double dVar1;
  
  dVar1 = xlfd_round_double(x);
  return dVar1;
}



Bool FontFileRegisterRenderer(FontRendererPtr renderer)

{
  Bool BVar1;
  
  BVar1 = FontFilePriorityRegisterRenderer(renderer,0);
  return BVar1;
}



void FT_Get_PS_Font_Info(void)

{
  FT_Get_PS_Font_Info();
  return;
}



void FT_Set_Charmap(void)

{
  FT_Set_Charmap();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int close(int __fd)

{
  int iVar1;
  
  iVar1 = close(__fd);
  return iVar1;
}



FontPtr fs_create_font(FontPathElementPtr fpe,char *name,int namelen,fsBitmapFormat format,
                      fsBitmapFormatMask fmask)

{
  FontPtr p_Var1;
  
  p_Var1 = fs_create_font(fpe,name,namelen,format,fmask);
  return p_Var1;
}



Bool _fs_io_init(FSFpePtr conn)

{
  Bool BVar1;
  
  BVar1 = _fs_io_init(conn);
  return BVar1;
}



// WARNING: Unknown calling convention

int bitmapComputeWeight(FontPtr pFont)

{
  int iVar1;
  
  iVar1 = bitmapComputeWeight(pFont);
  return iVar1;
}



void FontEncFromXLFD(void)

{
  FontEncFromXLFD();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int closedir(DIR *__dirp)

{
  int iVar1;
  
  iVar1 = closedir(__dirp);
  return iVar1;
}



int _fs_write_pad(FSFpePtr conn,char *data,long len)

{
  int iVar1;
  
  iVar1 = _fs_write_pad(conn,data,len);
  return iVar1;
}



void FT_Outline_Get_BBox(void)

{
  FT_Outline_Get_BBox();
  return;
}



void FontEncFind(void)

{
  FontEncFind();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void fs_register_fpe_functions(void)

{
  fs_register_fpe_functions();
  return;
}



void FontFileSortTable(FontTablePtr table)

{
  if (table->sorted == 0) {
    qsort(table->entries,(long)table->used,0x98,FontFileNameCompare);
    table->sorted = 1;
    return;
  }
  return;
}



void FT_Select_Charmap(void)

{
  FT_Select_Charmap();
  return;
}



void FT_Get_Sfnt_Table(void)

{
  FT_Get_Sfnt_Table();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t read(int __fd,void *__buf,size_t __nbytes)

{
  ssize_t sVar1;
  
  sVar1 = read(__fd,__buf,__nbytes);
  return sVar1;
}



void FontFileFreeTable(FontTablePtr table)

{
  long lVar1;
  long lVar2;
  
  if (0 < table->used) {
    lVar1 = 0;
    do {
      lVar2 = lVar1 + 1;
      FontFileFreeEntry(table->entries + lVar1);
      lVar1 = lVar2;
    } while ((int)lVar2 < table->used);
  }
  free(table->entries);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int memcmp(void *__s1,void *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = memcmp(__s1,__s2,__n);
  return iVar1;
}



void _fs_unmark_block(FSFpePtr conn,CARD32 mask)

{
  _fs_unmark_block(conn,mask);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getsockopt(int __fd,int __level,int __optname,void *__optval,socklen_t *__optlen)

{
  int iVar1;
  
  iVar1 = getsockopt(__fd,__level,__optname,__optval,__optlen);
  return iVar1;
}



FontFilePtr FontFileOpen(char *name)

{
  char *pcVar1;
  int fd;
  uint uVar2;
  BufFilePtr f;
  size_t sVar3;
  BufFilePtr p_Var4;
  long lVar5;
  byte *pbVar6;
  byte *pbVar7;
  bool bVar8;
  bool bVar9;
  byte bVar10;
  
  bVar10 = 0;
  fd = open(name,0);
  p_Var4 = (BufFilePtr)0x0;
  if (-1 < fd) {
    f = BufFileOpenRead(fd);
    p_Var4 = f;
    if (f == (BufFilePtr)0x0) {
      close(fd);
    }
    else {
      sVar3 = strlen(name);
      uVar2 = (uint)sVar3;
      if (2 < (int)uVar2) {
        pcVar1 = name + (long)(int)uVar2 + -2;
        if (((*pcVar1 == '.') && (pcVar1[1] == 'Z')) && (pcVar1[2] == '\0')) {
          p_Var4 = BufFilePushCompressed(f);
        }
        else {
          bVar8 = uVar2 < 3;
          bVar9 = uVar2 == 3;
          if (bVar9) {
            return f;
          }
          lVar5 = 4;
          pbVar6 = (byte *)(name + (long)(int)uVar2 + -3);
          pbVar7 = &DAT_00133211;
          do {
            if (lVar5 == 0) break;
            lVar5 = lVar5 + -1;
            bVar8 = *pbVar6 < *pbVar7;
            bVar9 = *pbVar6 == *pbVar7;
            pbVar6 = pbVar6 + (ulong)bVar10 * -2 + 1;
            pbVar7 = pbVar7 + (ulong)bVar10 * -2 + 1;
          } while (bVar9);
          if ((!bVar8 && !bVar9) != bVar8) {
            return f;
          }
          p_Var4 = BufFilePushZIP(f);
        }
        if (p_Var4 == (BufFilePtr)0x0) {
          BufFileClose(f,1);
          p_Var4 = (BufFilePtr)0x0;
        }
      }
    }
  }
  return p_Var4;
}



int _fs_write(FSFpePtr conn,char *data,long len)

{
  int iVar1;
  
  iVar1 = _fs_write(conn,data,len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * calloc(size_t __nmemb,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = calloc(__nmemb,__size);
  return pvVar1;
}



// WARNING: Unknown calling convention

char * NameForAtom(Atom atom)

{
  char *pcVar1;
  
  pcVar1 = NameForAtom(atom);
  return pcVar1;
}



int pcfReadFont(FontPtr pFont,FontFilePtr file,int bit,int byte,int glyph,int scan)

{
  int iVar1;
  
  iVar1 = pcfReadFont(pFont,file,bit,byte,glyph,scan);
  return iVar1;
}



// WARNING: Unknown calling convention

Font GetNewFontClientID(void)

{
  Font FVar1;
  
  FVar1 = GetNewFontClientID();
  return FVar1;
}



FontScaledPtr FontFileFindScaledInstance(FontEntryPtr entry,FontScalablePtr vals,int noSpecificSize)

{
  fsRange *pfVar1;
  int iVar2;
  uint uVar3;
  FontScalableExtraPtr p_Var4;
  long lVar5;
  long lVar6;
  FontScaledPtr p_Var7;
  int iVar8;
  fsRange *pfVar9;
  double *pdVar10;
  fsRange *pfVar11;
  int iVar12;
  FontScaledPtr p_Var13;
  double dVar14;
  double dVar15;
  double dVar16;
  double dVar17;
  double dVar18;
  
  p_Var4 = (entry->u).scalable.extra;
  iVar2 = p_Var4->numScaled;
  if (noSpecificSize != 0) {
    p_Var13 = (FontScaledPtr)0x0;
    if (iVar2 != 0) {
      p_Var13 = p_Var4->scaled;
      dVar18 = (p_Var13->vals).point_matrix[0] - vals->point_matrix[0];
      dVar14 = (p_Var13->vals).point_matrix[1] - vals->point_matrix[1];
      dVar16 = (p_Var13->vals).point_matrix[3] - vals->point_matrix[3];
      dVar15 = (p_Var13->vals).point_matrix[2] - vals->point_matrix[2];
      dVar14 = dVar15 * dVar15 + dVar18 * dVar18 + dVar14 * dVar14 + dVar16 * dVar16;
      if (1 < iVar2) {
        pdVar10 = p_Var13[1].vals.point_matrix;
        iVar12 = 0;
        iVar8 = 1;
        do {
          if (((pdVar10[0xb] == 0.0) || ((*(byte *)((long)pdVar10[0xb] + 0x13) & 2) != 0)) &&
             (dVar15 = *pdVar10 - vals->point_matrix[0], dVar17 = pdVar10[3] - vals->point_matrix[3]
             , dVar16 = pdVar10[1] - vals->point_matrix[1],
             dVar18 = pdVar10[2] - vals->point_matrix[2],
             dVar15 = (double)(int)(dVar18 * dVar18 + dVar15 * dVar15 + dVar16 * dVar16 +
                                   dVar17 * dVar17), dVar15 < dVar14)) {
            dVar14 = dVar15;
            iVar12 = iVar8;
          }
          iVar8 = iVar8 + 1;
          pdVar10 = pdVar10 + 0x11;
        } while (iVar8 != iVar2);
        p_Var13 = p_Var13 + iVar12;
      }
      if ((p_Var13->pFont != (FontPtr)0x0) && (((p_Var13->pFont->info).field_0xb & 2) == 0)) {
        p_Var13 = (FontScaledPtr)0x0;
      }
    }
    return p_Var13;
  }
  if (0 < iVar2) {
    p_Var7 = p_Var4->scaled;
    p_Var13 = p_Var7 + (ulong)(iVar2 - 1) + 1;
    do {
      if (((((p_Var7->pFont == (FontPtr)0x0) || (((p_Var7->pFont->info).field_0xb & 2) != 0)) &&
           ((lVar5._0_4_ = vals->x, lVar5._4_4_ = vals->y, lVar6._0_4_ = (p_Var7->vals).x,
            lVar6._4_4_ = (p_Var7->vals).y, lVar6 == lVar5 &&
            ((iVar2 = (p_Var7->vals).width, iVar2 == vals->width || iVar2 == 0 ||
             (vals->width + 1U < 2)))))) &&
          ((uVar3 = vals->values_supplied, (uVar3 & 3) == 0 ||
           ((((((((p_Var7->vals).values_supplied ^ uVar3) & 3) == 0 && (true)) &&
              ((p_Var7->vals).pixel_matrix[0] == vals->pixel_matrix[0])) &&
             ((true && ((p_Var7->vals).pixel_matrix[1] == vals->pixel_matrix[1])))) &&
            (((true && (((p_Var7->vals).pixel_matrix[2] == vals->pixel_matrix[2] && (true)))) &&
             ((p_Var7->vals).pixel_matrix[3] == vals->pixel_matrix[3])))))))) &&
         (((uVar3 & 0xc) == 0 ||
          ((((((((uVar3 ^ (p_Var7->vals).values_supplied) & 0xc) == 0 && (true)) &&
              ((p_Var7->vals).point_matrix[0] == vals->point_matrix[0])) &&
             ((true && ((p_Var7->vals).point_matrix[1] == vals->point_matrix[1])))) &&
            ((true && (((p_Var7->vals).point_matrix[2] == vals->point_matrix[2] && (true)))))) &&
           ((p_Var7->vals).point_matrix[3] == vals->point_matrix[3])))))) {
        iVar2 = (p_Var7->vals).nranges;
        if (iVar2 == 0) {
          return p_Var7;
        }
        if (iVar2 == vals->nranges) {
          if (iVar2 < 1) {
            return p_Var7;
          }
          pfVar11 = (p_Var7->vals).ranges;
          pfVar9 = vals->ranges;
          pfVar1 = pfVar11 + (ulong)(iVar2 - 1) + 1;
          while ((((pfVar11->min_char_low == pfVar9->min_char_low &&
                   (pfVar11->min_char_high == pfVar9->min_char_high)) &&
                  (pfVar11->max_char_low == pfVar9->max_char_low)) &&
                 (pfVar11->max_char_high == pfVar9->max_char_high))) {
            pfVar11 = pfVar11 + 1;
            pfVar9 = pfVar9 + 1;
            if (pfVar1 == pfVar11) {
              return p_Var7;
            }
          }
        }
      }
      p_Var7 = p_Var7 + 1;
    } while (p_Var7 != p_Var13);
  }
  return (FontScaledPtr)0x0;
}



int _fs_flush(FSFpePtr conn)

{
  int iVar1;
  
  iVar1 = _fs_flush(conn);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}



// WARNING: Unknown calling convention

FontResolutionPtr GetClientResolutions(int *num)

{
  FontResolutionPtr p_Var1;
  
  p_Var1 = GetClientResolutions(num);
  return p_Var1;
}



void FT_MulFix(void)

{
  FT_MulFix();
  return;
}



void __memcpy_chk(void)

{
  __memcpy_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,__endptr,__base);
  return lVar1;
}



void EmptyFontPatternCache(FontPatternCachePtr cache)

{
  EmptyFontPatternCache(cache);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



uchar * bdfGetLine(FontFilePtr file,uchar *buf,int len)

{
  uchar *puVar1;
  
  puVar1 = bdfGetLine(file,buf,len);
  return puVar1;
}



void inflateEnd(void)

{
  inflateEnd();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int inet_pton(int __af,char *__cp,void *__buf)

{
  int iVar1;
  
  iVar1 = inet_pton(__af,__cp,__buf);
  return iVar1;
}



void TwoByteSwap(uchar *buf,int nbytes)

{
  TwoByteSwap(buf,nbytes);
  return;
}



Bool FontFileDirectoryChanged(FontDirectoryPtr dir)

{
  char *pcVar1;
  uint uVar2;
  int iVar3;
  size_t sVar4;
  int *piVar5;
  long in_FS_OFFSET;
  stat sStack_4d8;
  char acStack_448 [1032];
  long lStack_40;
  
  pcVar1 = dir->directory;
  lStack_40 = *(long *)(in_FS_OFFSET + 0x28);
  sVar4 = strlen(pcVar1);
  if (sVar4 + 10 < 0x401) {
    __memcpy_chk(acStack_448,pcVar1,sVar4,0x400);
    __memcpy_chk(acStack_448 + sVar4,"fonts.dir",10,0x400 - sVar4);
    iVar3 = __xstat(1,acStack_448,&sStack_4d8);
    if (iVar3 == -1) {
      piVar5 = __errno_location();
      if (*piVar5 == 2) {
        uVar2 = (uint)(dir->dir_mtime != 0);
        goto LAB_0010ba57;
      }
    }
    else if (dir->dir_mtime == sStack_4d8.st_mtim.tv_sec) {
      pcVar1 = dir->directory;
      sVar4 = strlen(pcVar1);
      if (0x400 < sVar4 + 0xc) goto LAB_0010ba55;
      __memcpy_chk(acStack_448,pcVar1,sVar4,0x400);
      __memcpy_chk(acStack_448 + sVar4,"fonts.alias",0xc,0x400 - sVar4);
      iVar3 = __xstat(1,acStack_448,&sStack_4d8);
      if (iVar3 != -1) {
        uVar2 = (uint)(dir->alias_mtime != sStack_4d8.st_mtim.tv_sec);
        goto LAB_0010ba57;
      }
      piVar5 = __errno_location();
      if (*piVar5 == 2) {
        uVar2 = (uint)(dir->alias_mtime != 0);
        goto LAB_0010ba57;
      }
    }
    uVar2 = 1;
  }
  else {
LAB_0010ba55:
    uVar2 = 0;
  }
LAB_0010ba57:
  if (lStack_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



int _FontTransGetHostname(char *buf,int maxlen)

{
  int iVar1;
  
  iVar1 = _FontTransGetHostname(buf,maxlen);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fileno(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fileno(__stream);
  return iVar1;
}



void __stpcpy_chk(void)

{
  __stpcpy_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int select(int __nfds,fd_set *__readfds,fd_set *__writefds,fd_set *__exceptfds,timeval *__timeout)

{
  int iVar1;
  
  iVar1 = select(__nfds,__readfds,__writefds,__exceptfds,__timeout);
  return iVar1;
}



void FT_Get_BDF_Charset_ID(void)

{
  FT_Get_BDF_Charset_ID();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __xstat(int __ver,char *__filename,stat *__stat_buf)

{
  int iVar1;
  
  iVar1 = __xstat(__ver,__filename,__stat_buf);
  return iVar1;
}



void FreeFontNames(FontNamesPtr pFN)

{
  FreeFontNames(pFN);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

dirent * readdir(DIR *__dirp)

{
  dirent *pdVar1;
  
  pdVar1 = readdir(__dirp);
  return pdVar1;
}



int fs_build_range(FontPtr pfont,Bool range_flag,uint count,int item_size,uchar *data,int *nranges,
                  fsRange **ranges)

{
  int iVar1;
  
  iVar1 = fs_build_range(pfont,range_flag,count,item_size,data,nranges,ranges);
  return iVar1;
}



// WARNING: Unknown calling convention

void bitmapComputeFontBounds(FontPtr pFont)

{
  bitmapComputeFontBounds(pFont);
  return;
}



// WARNING: Unknown calling convention

void _fs_convert_char_info(fsXCharInfo *src,xCharInfo *dst)

{
  _fs_convert_char_info(src,dst);
  return;
}



// WARNING: Unknown calling convention

int FontCouldBeTerminal(FontInfoPtr pFontInfo)

{
  int iVar1;
  
  iVar1 = FontCouldBeTerminal(pFontInfo);
  return iVar1;
}



int bdfReadFont(FontPtr pFont,FontFilePtr file,int bit,int byte,int glyph,int scan)

{
  int iVar1;
  
  iVar1 = bdfReadFont(pFont,file,bit,byte,glyph,scan);
  return iVar1;
}



FontEntryPtr FontFileFindNameInScalableDir(FontTablePtr table,FontNamePtr pat,FontScalablePtr vals)

{
  uint uVar1;
  FontEntryPtr_conflict p_Var2;
  int iVar3;
  uint uVar4;
  FontEntryPtr p_Var5;
  ulong uVar6;
  FontEntryPtr p_Var7;
  char *pat_00;
  long in_FS_OFFSET;
  int iStack_2c;
  int iStack_28;
  uint uStack_24;
  long lStack_20;
  
  lStack_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (table->entries != (FontEntryPtr_conflict)0x0) {
    iVar3 = SetupWildMatch(table,(FontNamePtr)pat->name,(int *)(ulong)(ushort)pat->ndashes,
                           &iStack_2c,&iStack_28,(FontNamePtr)&uStack_24);
    if (-1 < iVar3) {
      p_Var7 = table->entries + iVar3;
      goto LAB_0010c727;
    }
    if (iStack_2c < iStack_28) {
      p_Var2 = table->entries;
      uVar6 = (ulong)uStack_24;
      pat_00 = pat->name;
      p_Var5 = p_Var2 + iStack_2c;
      do {
        iVar3 = (int)(p_Var5->name).ndashes;
        if (((int)uVar6 <= iVar3) &&
           (p_Var7 = p_Var5, iVar3 = PatternMatch(pat_00,(int)uVar6,(p_Var5->name).name,iVar3),
           0 < iVar3)) {
          if (vals == (FontScalablePtr)0x0) goto LAB_0010c727;
          uVar1 = vals->values_supplied;
          if (p_Var5->type == 0) {
            uVar4 = ((p_Var5->u).scalable.renderer)->capabilities;
          }
          else {
            uVar4 = -(uint)(p_Var5->type == 3);
          }
          if (((((uVar1 & 3) != 2) && ((uVar1 & 0xc) != 8)) || ((uVar4 & 1) != 0)) &&
             (((uVar1 & 0x40) == 0 || ((uVar4 & 2) != 0)))) goto LAB_0010c727;
        }
        p_Var5 = p_Var5 + 1;
      } while (p_Var5 != p_Var2 + (long)iStack_2c + (ulong)(uint)((iStack_28 + -1) - iStack_2c) + 1)
      ;
    }
  }
  p_Var7 = (FontEntryPtr)0x0;
LAB_0010c727:
  if (lStack_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return p_Var7;
}



void pcfError(char *message,...)

{
  pcfError(message);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fflush(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fflush(__stream);
  return iVar1;
}



uint FTRemap(FT_Face_conflict face,FTMappingPtr tm,uint code)

{
  uint uVar1;
  int iVar2;
  long lVar3;
  
  if (tm->mapping == (_FontMap *)0x0) {
    if (code < 0x100) goto LAB_0011176a;
  }
  else {
    if (tm->named == 0) {
      iVar2 = FontEncRecode(code);
      code = iVar2 + tm->base;
LAB_0011176a:
      FT_Set_Charmap(face,tm->cmap);
      uVar1 = FT_Get_Char_Index(face,code);
      return uVar1;
    }
    lVar3 = FontEncName();
    if (lVar3 != 0) {
      uVar1 = FT_Get_Name_Index(face,lVar3);
      return uVar1;
    }
  }
  return 0;
}



int BufFileWrite(BufFilePtr f,char *b,int n)

{
  BufChar BVar1;
  BufChar *pBVar2;
  int iVar3;
  BufChar *pBVar4;
  BufChar *pBVar5;
  
  if (n != 0) {
    pBVar4 = (BufChar *)b;
    do {
      pBVar5 = pBVar4 + 1;
      iVar3 = f->left + -1;
      f->left = iVar3;
      if (iVar3 == 0) {
        iVar3 = (*f->output)((int)*pBVar4,f);
        if (iVar3 == -1) {
          return -1;
        }
      }
      else {
        pBVar2 = f->bufp;
        BVar1 = *pBVar4;
        f->bufp = pBVar2 + 1;
        *pBVar2 = BVar1;
      }
      pBVar4 = pBVar5;
    } while (pBVar5 != (BufChar *)(b + (ulong)(n - 1) + 1));
  }
  return n;
}



int FTPickMapping(char *xlfd,int length,char *filename,FT_Face_conflict face,FTMappingPtr tm)

{
  char *pcVar1;
  _FontMap **pp_Var2;
  FT_CharMap *ppFVar3;
  char cVar4;
  int iVar5;
  int iVar6;
  char *pcVar7;
  size_t sVar8;
  size_t sVar9;
  _FontMap *p_Var10;
  long lVar11;
  FT_CharMap pFVar12;
  FT_CharMap *ppFVar13;
  _FontMap *p_Var14;
  undefined4 in_register_00000034;
  byte bVar15;
  char *pcVar16;
  long in_FS_OFFSET;
  uint uStack_7c;
  char *pcStack_68;
  char *pcStack_60;
  char acStack_58 [24];
  long lStack_40;
  
  lStack_40 = *(long *)(in_FS_OFFSET + 0x28);
  if ((xlfd == (char *)0x0) ||
     (pcVar7 = (char *)FontEncFromXLFD(xlfd,CONCAT44(in_register_00000034,length)),
     pcVar7 == (char *)0x0)) {
    iVar5 = strcasecmp("iso8859-1","microsoft-symbol");
    pcVar7 = "iso8859-1";
    if (iVar5 != 0) {
      cVar4 = 'i';
      pcVar16 = pcVar7;
      goto LAB_001114a0;
    }
LAB_00111540:
    iVar5 = FT_Get_BDF_Charset_ID(face,&pcStack_68,&pcStack_60);
    if (iVar5 != 0) {
LAB_0011155a:
      iVar5 = FT_Select_Charmap(face,0x41444243);
      if (iVar5 == 0) {
LAB_00111410:
        tm->named = 0;
        pFVar12 = face->charmap;
        tm->base = 0;
        tm->mapping = (_FontMap *)0x0;
        tm->cmap = pFVar12;
        iVar5 = 0x55;
        goto LAB_0011143b;
      }
      uStack_7c = 1;
      bVar15 = 1;
LAB_0011157d:
      lVar11 = FontEncFind(pcVar7,filename);
      if (lVar11 == 0) {
        pcVar16 = pcVar7;
        if (bVar15 != 0) {
          lVar11 = FontEncFind("microsoft-symbol",filename);
        }
        goto joined_r0x001114db;
      }
      goto LAB_001114e1;
    }
    uStack_7c = 1;
LAB_00111347:
    sVar8 = strlen(pcStack_68);
    sVar9 = strlen(pcStack_60);
    if (0x12 < sVar9 + sVar8) goto LAB_00111410;
    __memcpy_chk(acStack_58,pcStack_68,sVar8,0x14);
    __memcpy_chk(acStack_58 + sVar8,&DAT_001321d3,1,0x14 - sVar8);
    __strcpy_chk(acStack_58 + sVar8 + 1,pcStack_60,0x13 - sVar8);
    ErrorF("%s %s\n",acStack_58,pcVar7);
    iVar5 = strcasecmp(acStack_58,"iso10646-1");
    if (iVar5 == 0) {
      bVar15 = (byte)uStack_7c & 1;
      goto LAB_0011157d;
    }
    iVar5 = strcasecmp(acStack_58,pcVar7);
    if (iVar5 == 0) goto LAB_00111410;
  }
  else {
    iVar5 = strcasecmp(pcVar7,"microsoft-symbol");
    if (iVar5 == 0) goto LAB_00111540;
    cVar4 = *pcVar7;
    pcVar16 = pcVar7;
    while (cVar4 != '-') {
LAB_001114a0:
      if (cVar4 == '\0') {
        uStack_7c = FT_Get_BDF_Charset_ID(face,&pcStack_68,&pcStack_60);
        pcVar7 = pcVar16;
        if (uStack_7c == 0) goto LAB_00111347;
        goto LAB_001114c2;
      }
      pcVar1 = pcVar7 + 1;
      pcVar7 = pcVar7 + 1;
      cVar4 = *pcVar1;
    }
    iVar5 = strcasecmp(pcVar7 + 1,"fontspecific");
    iVar6 = FT_Get_BDF_Charset_ID(face,&pcStack_68,&pcStack_60);
    pcVar7 = pcVar16;
    if (iVar6 == 0) {
      uStack_7c = (uint)(iVar5 == 0);
      goto LAB_00111347;
    }
    if (iVar5 == 0) goto LAB_0011155a;
LAB_001114c2:
    lVar11 = FontEncFind(pcVar16,filename);
    uStack_7c = 0;
joined_r0x001114db:
    if (lVar11 == 0) {
      ErrorF("FreeType: couldn\'t find encoding \'%s\' for \'%s\'\n",pcVar16,filename);
      iVar5 = 0x53;
      goto LAB_0011143b;
    }
LAB_001114e1:
    iVar5 = FT_Has_PS_Glyph_Names(face);
    p_Var14 = *(_FontMap **)(lVar11 + 0x18);
    if (iVar5 == 0) {
      if (p_Var14 != (_FontMap *)0x0) goto LAB_001115e9;
    }
    else {
      p_Var10 = p_Var14;
      if (p_Var14 != (_FontMap *)0x0) {
        do {
          if (p_Var10->type == 3) {
            tm->mapping = p_Var10;
            iVar5 = 0x55;
            tm->named = 1;
            tm->base = 0;
            goto LAB_0011143b;
          }
          pp_Var2 = &p_Var10->next;
          p_Var10 = *pp_Var2;
        } while (*pp_Var2 != (_FontMap *)0x0);
LAB_001115e9:
        iVar5 = face->num_charmaps;
        do {
          if (p_Var14->type == 1) {
            if (0 < iVar5) {
              ppFVar13 = face->charmaps;
              ppFVar3 = ppFVar13 + (ulong)(iVar5 - 1) + 1;
              do {
                pFVar12 = *ppFVar13;
                iVar6._0_2_ = pFVar12->platform_id;
                iVar6._2_2_ = pFVar12->encoding_id;
                if (iVar6 == 0x10003) goto LAB_0011163d;
                ppFVar13 = ppFVar13 + 1;
              } while (ppFVar3 != ppFVar13);
            }
          }
          else if ((p_Var14->type == 2) && (0 < iVar5)) {
            ppFVar13 = face->charmaps;
            ppFVar3 = ppFVar13 + (ulong)(iVar5 - 1) + 1;
            do {
              pFVar12 = *ppFVar13;
              if ((p_Var14->pid == (uint)pFVar12->platform_id) &&
                 (p_Var14->eid == (uint)pFVar12->encoding_id)) goto LAB_0011163d;
              ppFVar13 = ppFVar13 + 1;
            } while (ppFVar3 != ppFVar13);
          }
          p_Var14 = p_Var14->next;
        } while (p_Var14 != (_FontMap *)0x0);
      }
    }
  }
  iVar5 = 0x58;
LAB_0011143b:
  if (lStack_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar5;
LAB_0011163d:
  tm->cmap = pFVar12;
  tm->named = 0;
  if ((uStack_7c == 0) || (lVar11 = FT_Get_Sfnt_Table(face,2), lVar11 == 0)) {
    tm->base = 0;
  }
  else {
    tm->base = *(ushort *)(lVar11 + 0x56) - 0x20;
  }
  tm->mapping = p_Var14;
  iVar5 = 0x55;
  goto LAB_0011143b;
}



void __isoc99_sscanf(void)

{
  __isoc99_sscanf();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ungetc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = ungetc(__c,__stream);
  return iVar1;
}



int BitmapOpenScalable(FontPathElementPtr fpe,FontPtr *pFont,int flags,FontEntryPtr entry,
                      char *fileName,FontScalablePtr vals,fsBitmapFormat format,
                      fsBitmapFormatMask fmask,FontPtr non_cachable_font)

{
  int iVar1;
  
  iVar1 = BitmapOpenScalable(fpe,pFont,flags,entry,fileName,vals,format,fmask,non_cachable_font);
  return iVar1;
}



Bool SPropRecValList_add_by_font_cap(SDynPropRecValList *pThisList,char *strCapHead)

{
  Bool BVar1;
  
  BVar1 = SPropRecValList_add_by_font_cap(pThisList,strCapHead);
  return BVar1;
}



int BuiltinFileClose(FontFilePtr f,int unused)

{
  int iVar1;
  
  iVar1 = BuiltinFileClose(f,unused);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __fxstat(int __ver,int __fildes,stat *__stat_buf)

{
  int iVar1;
  
  iVar1 = __fxstat(__ver,__fildes,__stat_buf);
  return iVar1;
}



Atom MakeAtom(char *string,uint len,int makeit)

{
  Atom AVar1;
  
  AVar1 = MakeAtom(string,len,makeit);
  return AVar1;
}



void _fs_io_reinit(FSFpePtr conn)

{
  _fs_io_reinit(conn);
  return;
}



// WARNING: Unknown calling convention

ulong GetTimeInMillis(void)

{
  ulong uVar1;
  
  uVar1 = GetTimeInMillis();
  return uVar1;
}



// WARNING: Unknown calling convention

void bitmapComputeFontInkBounds(FontPtr pFont)

{
  bitmapComputeFontInkBounds(pFont);
  return;
}



Bool FontFilePriorityRegisterRenderer(FontRendererPtr renderer,int priority)

{
  char *__s2;
  ulong uVar1;
  int iVar2;
  _FontRenderersElement *p_Var3;
  int iVar4;
  _FontRenderersElement *p_Var5;
  size_t __size;
  Bool BVar6;
  int iVar7;
  
  p_Var3 = renderers.renderers;
  iVar4 = renderers.number;
  uVar1 = rendererGeneration;
  if (rendererGeneration == serverGeneration) {
    if (renderers.number < 1) {
      __size = 0x10;
      iVar2 = 1;
      iVar4 = 0;
    }
    else {
      iVar7 = 0;
      __s2 = renderer->fileSuffix;
      p_Var5 = renderers.renderers;
      do {
        iVar2 = strcasecmp(p_Var5->renderer->fileSuffix,__s2);
        if (iVar2 == 0) {
          if (priority <= p_Var5->priority) {
            if (p_Var5->priority != priority) {
              return 1;
            }
            if (uVar1 != 1) {
              return 1;
            }
            ErrorF("Warning: font renderer for \"%s\" already registered at priority %d\n",__s2,
                   (ulong)(uint)priority);
            return 1;
          }
          if (iVar7 < iVar4) goto LAB_00110793;
          iVar2 = iVar7 + 1;
          __size = (long)iVar2 << 4;
          iVar4 = iVar7;
          goto LAB_00110706;
        }
        iVar7 = iVar7 + 1;
        p_Var5 = p_Var5 + 1;
      } while (iVar4 != iVar7);
      iVar2 = iVar4 + 1;
      __size = (long)iVar2 << 4;
    }
  }
  else {
    rendererGeneration = serverGeneration;
    renderers.number = 0;
    if (renderers.renderers != (_FontRenderersElement *)0x0) {
      free(renderers.renderers);
    }
    p_Var3 = (_FontRenderersElement *)0x0;
    __size = 0x10;
    iVar2 = 1;
    renderers.renderers = (_FontRenderersElement *)0x0;
    iVar4 = 0;
  }
LAB_00110706:
  p_Var3 = (_FontRenderersElement *)realloc(p_Var3,__size);
  if (p_Var3 == (_FontRenderersElement *)0x0) {
    BVar6 = 0;
  }
  else {
    p_Var5 = p_Var3 + iVar4;
    iVar7 = iVar4;
    renderers.number = iVar2;
    renderers.renderers = p_Var3;
LAB_00110793:
    BVar6 = 1;
    renderer->number = iVar7;
    p_Var5->renderer = renderer;
    p_Var5->priority = priority;
  }
  return BVar6;
}



Bool FontFileAddScaledInstance
               (FontEntryPtr entry,FontScalablePtr vals,FontPtr pFont,char *bitmapName)

{
  int iVar1;
  FontScalableExtraPtr p_Var2;
  fsRange *pfVar3;
  double dVar4;
  undefined4 uVar5;
  int iVar6;
  FontScaledPtr p_Var7;
  
  p_Var2 = (entry->u).scalable.extra;
  iVar1 = p_Var2->numScaled;
  p_Var7 = p_Var2->scaled;
  if (iVar1 == p_Var2->sizeScaled) {
    p_Var7 = (FontScaledPtr)realloc(p_Var7,(long)(iVar1 + 4) * 0x88);
    if (p_Var7 == (FontScaledPtr)0x0) {
      return 0;
    }
    p_Var2->sizeScaled = iVar1 + 4;
    iVar1 = p_Var2->numScaled;
    p_Var2->scaled = p_Var7;
  }
  p_Var2->numScaled = iVar1 + 1;
  uVar5 = *(undefined4 *)&vals->field_0x4;
  dVar4 = vals->pixel_matrix[0];
  p_Var7 = p_Var7 + iVar1;
  (p_Var7->vals).values_supplied = vals->values_supplied;
  *(undefined4 *)&(p_Var7->vals).field_0x4 = uVar5;
  (p_Var7->vals).pixel_matrix[0] = dVar4;
  dVar4 = vals->pixel_matrix[2];
  (p_Var7->vals).pixel_matrix[1] = vals->pixel_matrix[1];
  (p_Var7->vals).pixel_matrix[2] = dVar4;
  dVar4 = vals->point_matrix[0];
  (p_Var7->vals).pixel_matrix[3] = vals->pixel_matrix[3];
  (p_Var7->vals).point_matrix[0] = dVar4;
  dVar4 = vals->point_matrix[2];
  (p_Var7->vals).point_matrix[1] = vals->point_matrix[1];
  (p_Var7->vals).point_matrix[2] = dVar4;
  iVar1 = vals->pixel;
  iVar6 = vals->point;
  (p_Var7->vals).point_matrix[3] = vals->point_matrix[3];
  (p_Var7->vals).pixel = iVar1;
  (p_Var7->vals).point = iVar6;
  iVar1 = vals->y;
  iVar6 = vals->width;
  uVar5 = *(undefined4 *)&vals->field_0x5c;
  (p_Var7->vals).x = vals->x;
  (p_Var7->vals).y = iVar1;
  (p_Var7->vals).width = iVar6;
  *(undefined4 *)&(p_Var7->vals).field_0x5c = uVar5;
  iVar1 = vals->nranges;
  uVar5 = *(undefined4 *)&vals->field_0x6c;
  (p_Var7->vals).xlfdName = vals->xlfdName;
  (p_Var7->vals).nranges = iVar1;
  *(undefined4 *)&(p_Var7->vals).field_0x6c = uVar5;
  pfVar3 = vals->ranges;
  p_Var7->pFont = pFont;
  (p_Var7->vals).ranges = pfVar3;
  p_Var7->bitmap = (FontEntryPtr)bitmapName;
  if (pFont != (FontPtr)0x0) {
    pFont->fpePrivate = entry;
  }
  return 1;
}



int FontFileClose(FontFilePtr f)

{
  int iVar1;
  
  iVar1 = BufFileClose(f,1);
  return iVar1;
}



void __strncpy_chk(void)

{
  __strncpy_chk();
  return;
}



void _fs_clean_aborted_loadglyphs(FontPtr pfont,int num_expected_ranges,fsRange *expected_ranges)

{
  _fs_clean_aborted_loadglyphs(pfont,num_expected_ranges,expected_ranges);
  return;
}



Atom bdfGetPropertyValue(char *s)

{
  Atom AVar1;
  
  AVar1 = bdfGetPropertyValue(s);
  return AVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * realloc(void *__ptr,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = realloc(__ptr,__size);
  return pvVar1;
}



void __strcpy_chk(void)

{
  __strcpy_chk();
  return;
}



// WARNING: Unknown calling convention

void _fs_mark_block(FSFpePtr conn,CARD32 mask)

{
  _fs_mark_block(conn,mask);
  return;
}



void FontFileFreeDir(FontDirectoryPtr dir)

{
  FontFileFreeTable(&dir->scalable);
  FontFileFreeTable(&dir->nonScalable);
  free(dir);
  return;
}



void __printf_chk(void)

{
  __printf_chk();
  return;
}



BufFilePtr BufFilePushZIP(BufFilePtr f)

{
  long *plVar1;
  byte *pbVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  char *private;
  BufFilePtr p_Var8;
  
  private = (char *)malloc(0x4080);
  if (private == (char *)0x0) {
    return (BufFilePtr)0x0;
  }
  private[0x40] = '\0';
  private[0x41] = '\0';
  private[0x42] = '\0';
  private[0x43] = '\0';
  private[0x44] = '\0';
  private[0x45] = '\0';
  private[0x46] = '\0';
  private[0x47] = '\0';
  private[0x48] = '\0';
  private[0x49] = '\0';
  private[0x4a] = '\0';
  private[0x4b] = '\0';
  private[0x4c] = '\0';
  private[0x4d] = '\0';
  private[0x4e] = '\0';
  private[0x4f] = '\0';
  private[0x50] = '\0';
  private[0x51] = '\0';
  private[0x52] = '\0';
  private[0x53] = '\0';
  private[0x54] = '\0';
  private[0x55] = '\0';
  private[0x56] = '\0';
  private[0x57] = '\0';
  *(BufFilePtr *)(private + 0x4078) = f;
  private[0] = '\0';
  private[1] = '\0';
  private[2] = '\0';
  private[3] = '\0';
  private[4] = '\0';
  private[5] = '\0';
  private[6] = '\0';
  private[7] = '\0';
  private[0x18] = '\0';
  private[0x19] = '\0';
  private[0x1a] = '\0';
  private[0x1b] = '\0';
  private[0x1c] = '\0';
  private[0x1d] = '\0';
  private[0x1e] = '\0';
  private[0x1f] = '\0';
  private[0x20] = '\0';
  private[0x21] = '\0';
  private[0x22] = '\0';
  private[0x23] = '\0';
  private[8] = '\0';
  private[9] = '\0';
  private[10] = '\0';
  private[0xb] = '\0';
  iVar3 = inflateInit2_(private,0xfffffff1,"1.2.11",0x70);
  *(int *)(private + 0x70) = iVar3;
  if (iVar3 == 0) {
    plVar1 = *(long **)(private + 0x4078);
    private[0x20] = '\0';
    private[0x21] = ' ';
    private[0x22] = '\0';
    private[0x23] = '\0';
    *(char **)(private + 0x18) = private + 0x2074;
    private[8] = '\0';
    private[9] = '\0';
    private[10] = '\0';
    private[0xb] = '\0';
    iVar3 = *(int *)(plVar1 + 1);
    *(int *)(plVar1 + 1) = iVar3 + -1;
    if (iVar3 == 0) {
      uVar4 = (*(code *)plVar1[0x402])(plVar1);
      *(uint *)((long)plVar1 + 0xc) = uVar4;
      if (uVar4 == 0xffffffff) goto LAB_001103d0;
    }
    else {
      pbVar2 = (byte *)*plVar1;
      *plVar1 = (long)(pbVar2 + 1);
      uVar4 = (uint)*pbVar2;
    }
    if (uVar4 == 0x1f) {
      iVar3 = *(int *)(plVar1 + 1);
      *(int *)(plVar1 + 1) = iVar3 + -1;
      if (iVar3 == 0) {
        uVar4 = (*(code *)plVar1[0x402])(plVar1);
        *(uint *)((long)plVar1 + 0xc) = uVar4;
        if (uVar4 == 0xffffffff) goto LAB_001103d0;
      }
      else {
        pbVar2 = (byte *)*plVar1;
        *plVar1 = (long)(pbVar2 + 1);
        uVar4 = (uint)*pbVar2;
      }
      if (uVar4 == 0x8b) {
        iVar3 = *(int *)(plVar1 + 1);
        *(int *)(plVar1 + 1) = iVar3 + -1;
        if (iVar3 == 0) {
          uVar4 = (*(code *)plVar1[0x402])(plVar1);
          *(uint *)((long)plVar1 + 0xc) = uVar4;
          if (uVar4 == 0xffffffff) goto LAB_001103d0;
        }
        else {
          pbVar2 = (byte *)*plVar1;
          *plVar1 = (long)(pbVar2 + 1);
          uVar4 = (uint)*pbVar2;
        }
        if (uVar4 == 8) {
          iVar3 = *(int *)(plVar1 + 1);
          *(int *)(plVar1 + 1) = iVar3 + -1;
          if (iVar3 == 0) {
            uVar4 = (*(code *)plVar1[0x402])(plVar1);
            *(uint *)((long)plVar1 + 0xc) = uVar4;
            if (uVar4 == 0xffffffff) goto LAB_001103d0;
          }
          else {
            pbVar2 = (byte *)*plVar1;
            *plVar1 = (long)(pbVar2 + 1);
            uVar4 = (uint)*pbVar2;
          }
          if ((uVar4 & 0xe0) == 0) {
            iVar3 = *(int *)(plVar1 + 1);
            iVar5 = iVar3 + -1;
            *(int *)(plVar1 + 1) = iVar5;
            if (iVar3 == 0) {
              iVar3 = (*(code *)plVar1[0x402])(plVar1);
              *(int *)((long)plVar1 + 0xc) = iVar3;
              if (iVar3 == -1) goto LAB_001103d0;
              iVar5 = *(int *)(plVar1 + 1);
            }
            else {
              *plVar1 = *plVar1 + 1;
            }
            iVar3 = iVar5 + -1;
            *(int *)(plVar1 + 1) = iVar3;
            if (iVar5 == 0) {
              iVar3 = (*(code *)plVar1[0x402])(plVar1);
              *(int *)((long)plVar1 + 0xc) = iVar3;
              if (iVar3 == -1) goto LAB_001103d0;
              iVar3 = *(int *)(plVar1 + 1);
            }
            else {
              *plVar1 = *plVar1 + 1;
            }
            iVar5 = iVar3 + -1;
            *(int *)(plVar1 + 1) = iVar5;
            if (iVar3 == 0) {
              iVar3 = (*(code *)plVar1[0x402])(plVar1);
              *(int *)((long)plVar1 + 0xc) = iVar3;
              if (iVar3 == -1) goto LAB_001103d0;
              iVar5 = *(int *)(plVar1 + 1);
            }
            else {
              *plVar1 = *plVar1 + 1;
            }
            iVar3 = iVar5 + -1;
            *(int *)(plVar1 + 1) = iVar3;
            if (iVar5 == 0) {
              iVar3 = (*(code *)plVar1[0x402])(plVar1);
              *(int *)((long)plVar1 + 0xc) = iVar3;
              if (iVar3 == -1) goto LAB_001103d0;
              iVar3 = *(int *)(plVar1 + 1);
            }
            else {
              *plVar1 = *plVar1 + 1;
            }
            iVar5 = iVar3 + -1;
            *(int *)(plVar1 + 1) = iVar5;
            if (iVar3 == 0) {
              iVar3 = (*(code *)plVar1[0x402])(plVar1);
              *(int *)((long)plVar1 + 0xc) = iVar3;
              if (iVar3 == -1) goto LAB_001103d0;
              iVar5 = *(int *)(plVar1 + 1);
            }
            else {
              *plVar1 = *plVar1 + 1;
            }
            *(int *)(plVar1 + 1) = iVar5 + -1;
            if (iVar5 == 0) {
              iVar3 = (*(code *)plVar1[0x402])(plVar1);
              *(int *)((long)plVar1 + 0xc) = iVar3;
              if (iVar3 == -1) goto LAB_001103d0;
            }
            else {
              *plVar1 = *plVar1 + 1;
            }
            if ((uVar4 & 4) != 0) {
              iVar5 = *(int *)(plVar1 + 1);
              iVar3 = iVar5 + -1;
              *(int *)(plVar1 + 1) = iVar3;
              if (iVar5 == 0) {
                uVar6 = (*(code *)plVar1[0x402])(plVar1);
                *(uint *)((long)plVar1 + 0xc) = uVar6;
                if (uVar6 == 0xffffffff) goto LAB_001103d0;
                iVar3 = *(int *)(plVar1 + 1);
              }
              else {
                pbVar2 = (byte *)*plVar1;
                *plVar1 = (long)(pbVar2 + 1);
                uVar6 = (uint)*pbVar2;
              }
              *(int *)(plVar1 + 1) = iVar3 + -1;
              if (iVar3 == 0) {
                uVar7 = (*(code *)plVar1[0x402])(plVar1);
                *(uint *)((long)plVar1 + 0xc) = uVar7;
                if (uVar7 == 0xffffffff) goto LAB_001103d0;
              }
              else {
                pbVar2 = (byte *)*plVar1;
                *plVar1 = (long)(pbVar2 + 1);
                uVar7 = (uint)*pbVar2;
              }
              iVar5 = uVar7 * 0x100 + uVar6;
              iVar3 = iVar5 + -1;
              if (-1 < iVar5) {
                do {
                  iVar5 = *(int *)(plVar1 + 1);
                  *(int *)(plVar1 + 1) = iVar5 + -1;
                  if (iVar5 == 0) {
                    iVar5 = (*(code *)plVar1[0x402])(plVar1);
                    *(int *)((long)plVar1 + 0xc) = iVar5;
                    if (iVar5 == -1) goto LAB_001103d0;
                  }
                  else {
                    *plVar1 = *plVar1 + 1;
                  }
                  iVar3 = iVar3 + -1;
                } while (iVar3 != -2);
              }
            }
            uVar6 = uVar4 & 8;
            do {
              while( true ) {
                if (uVar6 == 0) {
                  uVar6 = uVar4 & 0x10;
                  goto joined_r0x00110442;
                }
                iVar3 = *(int *)(plVar1 + 1);
                *(int *)(plVar1 + 1) = iVar3 + -1;
                if (iVar3 == 0) break;
                pbVar2 = (byte *)*plVar1;
                *plVar1 = (long)(pbVar2 + 1);
                uVar6 = (uint)*pbVar2;
              }
              uVar6 = (*(code *)plVar1[0x402])(plVar1);
              *(uint *)((long)plVar1 + 0xc) = uVar6;
            } while (uVar6 != 0xffffffff);
          }
        }
      }
    }
  }
  goto LAB_001103d0;
  while( true ) {
    uVar6 = (*(code *)plVar1[0x402])(plVar1);
    *(uint *)((long)plVar1 + 0xc) = uVar6;
    if (uVar6 == 0xffffffff) break;
joined_r0x00110442:
    if (uVar6 == 0) {
      if ((uVar4 & 2) != 0) {
        iVar3 = *(int *)(plVar1 + 1);
        iVar5 = iVar3 + -1;
        *(int *)(plVar1 + 1) = iVar5;
        if (iVar3 == 0) {
          iVar3 = (*(code *)plVar1[0x402])(plVar1);
          *(int *)((long)plVar1 + 0xc) = iVar3;
          if (iVar3 == -1) break;
          iVar5 = *(int *)(plVar1 + 1);
        }
        else {
          *plVar1 = *plVar1 + 1;
        }
        *(int *)(plVar1 + 1) = iVar5 + -1;
        if (iVar5 == 0) {
          iVar3 = (*(code *)plVar1[0x402])(plVar1);
          *(int *)((long)plVar1 + 0xc) = iVar3;
          if (iVar3 == -1) break;
        }
        else {
          *plVar1 = *plVar1 + 1;
        }
      }
      p_Var8 = BufFileCreate(private,BufZipFileFill,(_func_int_int_BufFilePtr *)0x0,BufZipFileSkip,
                             BufZipFileClose);
      return p_Var8;
    }
    iVar3 = *(int *)(plVar1 + 1);
    *(int *)(plVar1 + 1) = iVar3 + -1;
    if (iVar3 != 0) {
      pbVar2 = (byte *)*plVar1;
      *plVar1 = (long)(pbVar2 + 1);
      uVar6 = (uint)*pbVar2;
      goto joined_r0x00110442;
    }
  }
LAB_001103d0:
  free(private);
  return (BufFilePtr)0x0;
}



void FT_Get_Char_Index(void)

{
  FT_Get_Char_Index();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void CatalogueRegisterLocalFpeFunctions(void)

{
  RegisterFPEFunctions
            (CatalogueNameCheck,CatalogueInitFPE,CatalogueFreeFPE,CatalogueResetFPE,
             CatalogueOpenFont,CatalogueCloseFont,CatalogueListFonts,CatalogueStartListFontsWithInfo
             ,CatalogueListNextFontWithInfo,(WakeupFpeFunc)0x0,(ClientDiedFunc)0x0,
             (LoadGlyphsFunc)0x0,CatalogueStartListFontsAndAliases,CatalogueListNextFontOrAlias,
             FontFileEmptyBitmapSource);
  return;
}



void FontFileUnregisterBitmapSource(FontPathElementPtr fpe)

{
  long lVar1;
  ulong uVar2;
  uint uVar3;
  ulong uVar4;
  bool bVar5;
  
  if (0 < FontFileBitmapSources.count) {
    uVar3 = FontFileBitmapSources.count - 1;
    uVar2 = 0;
    do {
      uVar4 = uVar2 & 0xffffffff;
      if (FontFileBitmapSources.fpe[uVar2] == fpe) {
        FontFileBitmapSources.count = uVar3;
        if (uVar3 == 0) {
          FontFileBitmapSources.size = 0;
          free(FontFileBitmapSources.fpe);
          FontFileBitmapSources.fpe = (FontPathElementPtr *)0x0;
          return;
        }
        if ((int)uVar3 <= (int)uVar2) {
          return;
        }
        lVar1 = (long)(int)uVar2 * 8;
        do {
          uVar3 = (int)uVar4 + 1;
          uVar4 = (ulong)uVar3;
          *(undefined8 *)((long)FontFileBitmapSources.fpe + lVar1) =
               *(undefined8 *)((long)FontFileBitmapSources.fpe + lVar1 + 8);
          lVar1 = lVar1 + 8;
        } while ((int)uVar3 < FontFileBitmapSources.count);
        return;
      }
      bVar5 = uVar2 != uVar3;
      uVar2 = uVar2 + 1;
    } while (bVar5);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t readv(int __fd,iovec *__iovec,int __count)

{
  ssize_t sVar1;
  
  sVar1 = readv(__fd,__iovec,__count);
  return sVar1;
}



int RepadBitmap(char *pSrc,char *pDst,uint srcPad,uint dstPad,int width,int height)

{
  int iVar1;
  
  iVar1 = RepadBitmap(pSrc,pDst,srcPad,dstPad,width,height);
  return iVar1;
}



Bool SPropRecValList_search_record
               (SRefPropRecValList *pThisList,SPropRecValContainer *refRecValue,char *recordName)

{
  Bool BVar1;
  
  BVar1 = SPropRecValList_search_record(pThisList,refRecValue,recordName);
  return BVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memmove(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memmove(__dest,__src,__n);
  return pvVar1;
}



Bool FontParseXLFDName(char *fname,FontScalablePtr vals,int subst)

{
  Bool BVar1;
  
  BVar1 = FontParseXLFDName(fname,vals,subst);
  return BVar1;
}



// WARNING: Unknown calling convention

int client_auth_generation(ClientPtr client)

{
  int iVar1;
  
  iVar1 = client_auth_generation(client);
  return iVar1;
}



int _FontTransRead(XtransConnInfo ciptr,char *buf,int size)

{
  int iVar1;
  
  iVar1 = _FontTransRead(ciptr,buf,size);
  return iVar1;
}



XtransConnInfo _FontTransOpenCOTSClient(char *address)

{
  XtransConnInfo p_Var1;
  
  p_Var1 = _FontTransOpenCOTSClient(address);
  return p_Var1;
}



void FT_Render_Glyph(void)

{
  FT_Render_Glyph();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int open(char *__file,int __oflag,...)

{
  int iVar1;
  
  iVar1 = open(__file,__oflag);
  return iVar1;
}



int bdfIsInteger(char *str)

{
  int iVar1;
  
  iVar1 = bdfIsInteger(str);
  return iVar1;
}



int _FontTransSetOption(XtransConnInfo ciptr,int option,int arg)

{
  int iVar1;
  
  iVar1 = _FontTransSetOption(ciptr,option,arg);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * fopen(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen(__filename,__modes);
  return pFVar1;
}



void inflateInit2_(void)

{
  inflateInit2_();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BuiltinRegisterFpeFunctions(void)

{
  BuiltinRegisterFpeFunctions();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long sysconf(int __name)

{
  long lVar1;
  
  lVar1 = sysconf(__name);
  return lVar1;
}



void FT_Set_Transform(void)

{
  FT_Set_Transform();
  return;
}



void FT_Vector_Transform(void)

{
  FT_Vector_Transform();
  return;
}



FontNamesPtr MakeFontNamesRecord(uint size)

{
  FontNamesPtr p_Var1;
  
  p_Var1 = MakeFontNamesRecord(size);
  return p_Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getsockname(int __fd,sockaddr *__addr,socklen_t *__len)

{
  int iVar1;
  
  iVar1 = getsockname(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double sin(double __x)

{
  double dVar1;
  
  dVar1 = sin(__x);
  return dVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double floor(double __x)

{
  double dVar1;
  
  dVar1 = floor(__x);
  return dVar1;
}



// WARNING: Unknown calling convention

int init_fs_handlers(FontPathElementPtr fpe,BlockHandlerProcPtr block_handler)

{
  int iVar1;
  
  iVar1 = init_fs_handlers(fpe,block_handler);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcat(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcat(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int creat(char *__file,__mode_t __mode)

{
  int iVar1;
  
  iVar1 = creat(__file,__mode);
  return iVar1;
}



// WARNING: Unknown calling convention

Bool ClientSignal(ClientPtr client)

{
  Bool BVar1;
  
  BVar1 = ClientSignal(client);
  return BVar1;
}



// WARNING: Unknown calling convention

void remove_fs_handlers(FontPathElementPtr fpe,BlockHandlerProcPtr blockHandler,Bool all)

{
  remove_fs_handlers(fpe,blockHandler,all);
  return;
}



int BufFileRead(BufFilePtr f,char *b,int n)

{
  int iVar1;
  byte *pbVar2;
  uint uVar3;
  int iVar4;
  bool bVar5;
  
  iVar4 = n + -1;
  if (n != 0) {
    do {
      iVar1 = f->left;
      f->left = iVar1 + -1;
      if (iVar1 == 0) {
        uVar3 = (*f->input)(f);
        f->eof = uVar3;
        if (uVar3 == 0xffffffff) goto LAB_0010a877;
      }
      else {
        pbVar2 = f->bufp;
        f->bufp = pbVar2 + 1;
        uVar3 = (uint)*pbVar2;
      }
      *b = (char)uVar3;
      bVar5 = iVar4 != 0;
      b = b + 1;
      iVar4 = iVar4 + -1;
    } while (bVar5);
  }
  iVar4 = -1;
LAB_0010a877:
  return (n - iVar4) + -1;
}



int FontFileCountDashes(char *name,int namelen)

{
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  
  if (namelen == 0) {
    return 0;
  }
  iVar1 = 0;
  pcVar3 = name;
  do {
    pcVar2 = pcVar3 + 1;
    iVar1 = iVar1 + (uint)(*pcVar3 == '-');
    pcVar3 = pcVar2;
  } while (name + (ulong)(namelen - 1) + 1 != pcVar2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int connect(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = connect(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}



void __fprintf_chk(void)

{
  __fprintf_chk();
  return;
}



void FontFileSwitchStringsToBitmapPointers(FontDirectoryPtr dir)

{
  FontEntryPtr p_Var1;
  FontScalableExtraPtr p_Var2;
  FontEntryPtr p_Var3;
  FontEntryPtr *pp_Var4;
  int iVar5;
  int iVar6;
  FontScalableExtraPtr *pp_Var7;
  int iVar8;
  
  p_Var1 = (dir->nonScalable).entries;
  if ((dir->scalable).used < 1) {
    return;
  }
  pp_Var7 = &(((dir->scalable).entries)->u).scalable.extra;
  iVar8 = 0;
  do {
    p_Var2 = *pp_Var7;
    if (0 < p_Var2->numScaled) {
      pp_Var4 = &p_Var2->scaled->bitmap;
      iVar6 = 0;
      do {
        iVar5 = 0;
        p_Var3 = p_Var1;
        if (0 < (dir->nonScalable).used) {
          do {
            while ((FontEntryPtr)(p_Var3->name).name != *pp_Var4) {
              iVar5 = iVar5 + 1;
              p_Var3 = p_Var3 + 1;
              if ((dir->nonScalable).used <= iVar5) goto LAB_0010f577;
            }
            *pp_Var4 = p_Var3;
            iVar5 = iVar5 + 1;
            p_Var3 = p_Var3 + 1;
          } while (iVar5 < (dir->nonScalable).used);
        }
LAB_0010f577:
        iVar6 = iVar6 + 1;
        pp_Var4 = pp_Var4 + 0x11;
      } while (iVar6 < p_Var2->numScaled);
    }
    iVar8 = iVar8 + 1;
    pp_Var7 = pp_Var7 + 0x13;
    if ((dir->scalable).used <= iVar8) {
      return;
    }
  } while( true );
}



Bool FontFileAddFontFile(FontDirectoryPtr dir,char *fontName,char *fileName)

{
  bool bVar1;
  Bool BVar2;
  FontRendererPtr p_Var3;
  size_t sVar4;
  FontEntryPtr p_Var5;
  FontEntryPtr p_Var6;
  FontScalableExtraPtr p_Var7;
  FontResolutionPtr p_Var8;
  char *pcVar9;
  char *pcVar10;
  long lVar11;
  int iVar12;
  uint uVar13;
  FontScalablePtr p_Var14;
  FontScalableExtraPtr p_Var15;
  byte *pbVar16;
  byte *__s;
  long in_FS_OFFSET;
  bool bVar17;
  bool bVar18;
  byte bVar19;
  double dVar20;
  int iStack_1dc;
  _FontScalable _Stack_1d8;
  _FontScalable _Stack_158;
  _FontEntry _Stack_d8;
  long lStack_40;
  
  bVar19 = 0;
  lStack_40 = *(long *)(in_FS_OFFSET + 0x28);
  p_Var3 = FontFileMatchRenderer(fileName);
  if (p_Var3 != (FontRendererPtr)0x0) {
    sVar4 = strlen(fontName);
    _Stack_d8.name.length = (short)sVar4;
    if (_Stack_d8.name.length < 0x401) {
      iVar12 = (int)_Stack_d8.name.length;
    }
    else {
      iVar12 = 0x400;
      _Stack_d8.name.length = 0x400;
    }
    _Stack_d8.name.name = fontName;
    CopyISOLatin1Lowered(fontName,fontName,iVar12);
    iVar12 = FontFileCountDashes(_Stack_d8.name.name,(int)_Stack_d8.name.length);
    _Stack_d8.name.ndashes = (short)iVar12;
    _Stack_d8.name.name[_Stack_d8.name.length] = '\0';
    if ((((_Stack_d8.name.ndashes == 0xe) &&
         (BVar2 = FontParseXLFDName(_Stack_d8.name.name,&_Stack_1d8,0),
         iVar12 = _Stack_1d8.values_supplied, BVar2 != 0)) &&
        ((_Stack_1d8.values_supplied & 3U) != 2)) &&
       (((_Stack_1d8.values_supplied & 0xcU) != 8 && ((_Stack_1d8.values_supplied & 0x40U) == 0))))
    {
      if ((((_Stack_1d8.values_supplied & 3U) != 0) &&
          (((_Stack_1d8.values_supplied & 0xcU) != 0 &&
           (pcVar10 = dir->attributes, pcVar10 != (char *)0x0)))) && (*pcVar10 == ':')) {
        bVar1 = true;
        pcVar9 = pcVar10;
        while( true ) {
          __s = (byte *)(pcVar9 + 1);
          pcVar9 = strchr((char *)__s,0x3a);
          if (pcVar9 == (char *)0x0) break;
          uVar13 = (int)pcVar9 - (int)__s;
          bVar17 = uVar13 < 8;
          bVar18 = uVar13 == 8;
          if (bVar18) {
            lVar11 = 8;
            pbVar16 = (byte *)"unscaled";
            do {
              if (lVar11 == 0) break;
              lVar11 = lVar11 + -1;
              bVar17 = *__s < *pbVar16;
              bVar18 = *__s == *pbVar16;
              __s = __s + (ulong)bVar19 * -2 + 1;
              pbVar16 = pbVar16 + (ulong)bVar19 * -2 + 1;
            } while (bVar18);
            if ((!bVar17 && !bVar18) == bVar17) {
              bVar1 = false;
            }
          }
        }
        sVar4 = strlen(pcVar10);
        uVar13 = ((int)pcVar10 + (int)sVar4) - (int)__s;
        bVar17 = uVar13 < 8;
        bVar18 = uVar13 == 8;
        if (bVar18) {
          lVar11 = 8;
          pbVar16 = (byte *)"unscaled";
          do {
            if (lVar11 == 0) break;
            lVar11 = lVar11 + -1;
            bVar17 = *__s < *pbVar16;
            bVar18 = *__s == *pbVar16;
            __s = __s + (ulong)bVar19 * -2 + 1;
            pbVar16 = pbVar16 + (ulong)bVar19 * -2 + 1;
          } while (bVar18);
          if ((!bVar17 && !bVar18) == bVar17) goto LAB_0010cbd6;
        }
        if (!bVar1) goto LAB_0010cbd6;
      }
      if ((iVar12 & 0xfU) != 0) {
        BVar2 = 1;
        goto LAB_0010cbd9;
      }
      p_Var5 = (FontEntryPtr)0x0;
LAB_0010cd53:
      pcVar10 = strdup(fileName);
      _Stack_d8.u.scalable.fileName = pcVar10;
      if (pcVar10 != (char *)0x0) {
        p_Var7 = (FontScalableExtraPtr)malloc(0x90);
        if (p_Var7 == (FontScalableExtraPtr)0x0) {
          BVar2 = 0;
          free(pcVar10);
          goto LAB_0010cc38;
        }
        p_Var15 = p_Var7;
        for (lVar11 = 0xf; lVar11 != 0; lVar11 = lVar11 + -1) {
          *(undefined8 *)&p_Var15->defaults = 0;
          p_Var15 = (FontScalableExtraPtr)((long)p_Var15 + (ulong)bVar19 * -0x10 + 8);
        }
        if (((_Stack_1d8.values_supplied & 0xcU) == 4) &&
           (dVar20 = _Stack_1d8.point_matrix[3] * 10.0, iVar12 = GetDefaultPointSize(),
           (int)dVar20 == iVar12)) {
          *(ulong *)&p_Var7->defaults = CONCAT44(_Stack_1d8._4_4_,_Stack_1d8.values_supplied);
          (p_Var7->defaults).pixel_matrix[0] = _Stack_1d8.pixel_matrix[0];
          (p_Var7->defaults).pixel_matrix[1] = _Stack_1d8.pixel_matrix[1];
          (p_Var7->defaults).pixel_matrix[2] = _Stack_1d8.pixel_matrix[2];
          (p_Var7->defaults).pixel_matrix[3] = _Stack_1d8.pixel_matrix[3];
          (p_Var7->defaults).point_matrix[0] = _Stack_1d8.point_matrix[0];
          (p_Var7->defaults).ranges = _Stack_1d8.ranges;
          (p_Var7->defaults).point_matrix[1] = _Stack_1d8.point_matrix[1];
          (p_Var7->defaults).point_matrix[2] = _Stack_1d8.point_matrix[2];
          (p_Var7->defaults).point_matrix[3] = _Stack_1d8.point_matrix[3];
          *(undefined8 *)&(p_Var7->defaults).pixel = _Stack_1d8._72_8_;
          *(ulong *)&(p_Var7->defaults).x = CONCAT44(_Stack_1d8.y,_Stack_1d8.x);
          *(undefined8 *)&(p_Var7->defaults).width = _Stack_1d8._88_8_;
          (p_Var7->defaults).xlfdName = _Stack_1d8.xlfdName;
          *(undefined8 *)&(p_Var7->defaults).nranges = _Stack_1d8._104_8_;
        }
        else {
          iVar12 = GetDefaultPointSize();
          (p_Var7->defaults).point_matrix[2] = 0.0;
          (p_Var7->defaults).point_matrix[1] = 0.0;
          (p_Var7->defaults).values_supplied = 4;
          (p_Var7->defaults).width = -1;
          (p_Var7->defaults).point_matrix[3] = (double)iVar12 / 10.0;
          (p_Var7->defaults).point_matrix[0] = (double)iVar12 / 10.0;
          if ((_Stack_1d8.x < 1) || (_Stack_1d8.y < 1)) {
            p_Var8 = GetClientResolutions(&iStack_1dc);
            if ((p_Var8 == (FontResolutionPtr)0x0) || (iStack_1dc < 1)) {
              *(undefined8 *)&(p_Var7->defaults).x = 0x4b0000004b;
            }
            else {
              (p_Var7->defaults).x = (uint)p_Var8->x_resolution;
              (p_Var7->defaults).y = (uint)p_Var8->y_resolution;
            }
          }
          else {
            (p_Var7->defaults).x = _Stack_1d8.x;
            (p_Var7->defaults).y = _Stack_1d8.y;
          }
          FontFileCompleteXLFD((FontScalablePtr)p_Var7,(FontScalablePtr)p_Var7);
        }
        p_Var7->numScaled = 0;
        p_Var7->sizeScaled = 0;
        p_Var7->scaled = (FontScaledPtr)0x0;
        p_Var7->private = (pointer)0x0;
        _Stack_d8.type = 0;
        _Stack_d8.u.scalable.renderer = p_Var3;
        _Stack_d8.u.scalable.extra = p_Var7;
        p_Var6 = FontFileAddEntry(&dir->scalable,&_Stack_d8);
        if (p_Var6 == (FontEntryPtr)0x0) {
          free(p_Var7);
          goto LAB_0010cc88;
        }
        if (((_Stack_1d8.values_supplied & 0xfU) != 0) && (p_Var5 != (FontEntryPtr)0x0)) {
          FontFileCompleteXLFD(&_Stack_1d8,&_Stack_1d8);
          FontFileAddScaledInstance(p_Var6,&_Stack_1d8,(FontPtr)0x0,(p_Var5->name).name);
        }
LAB_0010cc32:
        BVar2 = 1;
        goto LAB_0010cc38;
      }
    }
    else {
LAB_0010cbd6:
      BVar2 = 0;
LAB_0010cbd9:
      _Stack_d8.type = 2;
      _Stack_d8.u.scalable.extra = (FontScalableExtraPtr)0x0;
      _Stack_d8.u.scalable.renderer = p_Var3;
      _Stack_d8.u.scalable.fileName = strdup(fileName);
      if (_Stack_d8.u.scalable.fileName != (char *)0x0) {
        p_Var5 = FontFileAddEntry(&dir->nonScalable,&_Stack_d8);
        if (p_Var5 != (FontEntryPtr)0x0) {
          if (BVar2 != 0) {
            if ((_Stack_1d8.values_supplied & 0xfU) != 0) {
              p_Var14 = &_Stack_158;
              for (lVar11 = 0xf; lVar11 != 0; lVar11 = lVar11 + -1) {
                *(undefined8 *)p_Var14 = 0;
                p_Var14 = (FontScalablePtr)((long)p_Var14 + (ulong)bVar19 * -0x10 + 8);
              }
              _Stack_158.values_supplied = 5;
              FontParseXLFDName(_Stack_d8.name.name,&_Stack_158,3);
              sVar4 = strlen(_Stack_d8.name.name);
              _Stack_d8.name.length = (short)sVar4;
              p_Var6 = FontFileFindNameInDir(&dir->scalable,&_Stack_d8.name);
              if (p_Var6 != (FontEntryPtr)0x0) {
                if (((_Stack_1d8.values_supplied & 0xcU) == 4) &&
                   (dVar20 = _Stack_1d8.point_matrix[3] * 10.0, iVar12 = GetDefaultPointSize(),
                   (int)dVar20 == iVar12)) {
                  p_Var7 = (p_Var6->u).scalable.extra;
                  *(ulong *)&p_Var7->defaults =
                       CONCAT44(_Stack_1d8._4_4_,_Stack_1d8.values_supplied);
                  (p_Var7->defaults).pixel_matrix[0] = _Stack_1d8.pixel_matrix[0];
                  (p_Var7->defaults).pixel_matrix[1] = _Stack_1d8.pixel_matrix[1];
                  (p_Var7->defaults).pixel_matrix[2] = _Stack_1d8.pixel_matrix[2];
                  (p_Var7->defaults).pixel_matrix[3] = _Stack_1d8.pixel_matrix[3];
                  (p_Var7->defaults).point_matrix[0] = _Stack_1d8.point_matrix[0];
                  (p_Var7->defaults).point_matrix[1] = _Stack_1d8.point_matrix[1];
                  (p_Var7->defaults).point_matrix[2] = _Stack_1d8.point_matrix[2];
                  (p_Var7->defaults).point_matrix[3] = _Stack_1d8.point_matrix[3];
                  (p_Var7->defaults).pixel = _Stack_1d8.pixel;
                  (p_Var7->defaults).point = _Stack_1d8.point;
                  (p_Var7->defaults).x = (int)CONCAT44(_Stack_1d8.y,_Stack_1d8.x);
                  (p_Var7->defaults).y = (int)(CONCAT44(_Stack_1d8.y,_Stack_1d8.x) >> 0x20);
                  (p_Var7->defaults).width = _Stack_1d8.width;
                  *(undefined4 *)&(p_Var7->defaults).field_0x5c = _Stack_1d8._92_4_;
                  (p_Var7->defaults).xlfdName = _Stack_1d8.xlfdName;
                  (p_Var7->defaults).nranges = _Stack_1d8.nranges;
                  *(undefined4 *)&(p_Var7->defaults).field_0x6c = _Stack_1d8._108_4_;
                  (p_Var7->defaults).ranges = _Stack_1d8.ranges;
                  free((p_Var6->u).scalable.fileName);
                  pcVar10 = strdup(fileName);
                  (p_Var6->u).scalable.fileName = pcVar10;
                  if (pcVar10 == (char *)0x0) goto LAB_0010cc95;
                }
                FontFileCompleteXLFD(&_Stack_1d8,&_Stack_1d8);
                FontFileAddScaledInstance(p_Var6,&_Stack_1d8,(FontPtr)0x0,(p_Var5->name).name);
                goto LAB_0010cc38;
              }
            }
            goto LAB_0010cd53;
          }
          goto LAB_0010cc32;
        }
LAB_0010cc88:
        free(_Stack_d8.u.scalable.fileName);
      }
    }
  }
LAB_0010cc95:
  BVar2 = 0;
LAB_0010cc38:
  if (lStack_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar2;
}



void FT_Has_PS_Glyph_Names(void)

{
  FT_Has_PS_Glyph_Names();
  return;
}



fsRange * FontParseRanges(char *name,int *nranges)

{
  fsRange *pfVar1;
  
  pfVar1 = FontParseRanges(name,nranges);
  return pfVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double hypot(double __x,double __y)

{
  double dVar1;
  
  dVar1 = hypot(__x,__y);
  return dVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BitmapRegisterFontFileFunctions(void)

{
  BitmapRegisterFontFileFunctions();
  return;
}



int CheckFSFormat(fsBitmapFormat format,fsBitmapFormatMask fmask,int *bit_order,int *byte_order,
                 int *scan,int *glyph,int *image)

{
  int iVar1;
  
  iVar1 = CheckFSFormat(format,fmask,bit_order,byte_order,scan,glyph,image);
  return iVar1;
}



void FT_Set_Char_Size(void)

{
  FT_Set_Char_Size();
  return;
}



// WARNING: Unknown calling convention

int _FontTransGetConnectionNumber(XtransConnInfo ciptr)

{
  int iVar1;
  
  iVar1 = _FontTransGetConnectionNumber(ciptr);
  return iVar1;
}



// WARNING: Unknown calling convention

FontPtr find_old_font(FSID id)

{
  FontPtr p_Var1;
  
  p_Var1 = find_old_font(id);
  return p_Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getaddrinfo(char *__name,char *__service,addrinfo *__req,addrinfo **__pai)

{
  int iVar1;
  
  iVar1 = getaddrinfo(__name,__service,__req,__pai);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strdup(char *__s)

{
  char *pcVar1;
  
  pcVar1 = strdup(__s);
  return pcVar1;
}



FontRendererPtr FontFileMatchRenderer(char *fileName)

{
  _FontRenderersElement *p_Var1;
  FontRendererPtr p_Var2;
  int iVar3;
  size_t sVar4;
  _FontRenderersElement *p_Var5;
  
  sVar4 = strlen(fileName);
  if (0 < renderers.number) {
    p_Var1 = renderers.renderers + (ulong)(renderers.number - 1) + 1;
    p_Var5 = renderers.renderers;
    do {
      p_Var2 = p_Var5->renderer;
      if ((p_Var2->fileSuffixLen <= (int)sVar4) &&
         (iVar3 = strcasecmp(fileName + ((long)(int)sVar4 - (long)p_Var2->fileSuffixLen),
                             p_Var2->fileSuffix), iVar3 == 0)) {
        return p_Var2;
      }
      p_Var5 = p_Var5 + 1;
    } while (p_Var1 != p_Var5);
  }
  return (FontRendererPtr)0x0;
}



int pcfReadFontInfo(FontInfoPtr pFontInfo,FontFilePtr file)

{
  int iVar1;
  
  iVar1 = pcfReadFontInfo(pFontInfo,file);
  return iVar1;
}



void FontFileRemoveScaledInstance(FontEntryPtr entry,FontPtr pFont)

{
  long lVar1;
  FontPtr p_Var2;
  void *__ptr;
  _func_void_FontPtr *p_Var3;
  undefined8 uVar4;
  undefined8 uVar5;
  undefined8 uVar6;
  undefined8 uVar7;
  undefined8 uVar8;
  undefined8 uVar9;
  undefined8 uVar10;
  undefined8 uVar11;
  undefined8 uVar12;
  undefined8 uVar13;
  undefined8 uVar14;
  undefined8 uVar15;
  undefined8 uVar16;
  undefined8 uVar17;
  undefined8 uVar18;
  int iVar19;
  int iVar20;
  
  p_Var2 = (entry->u).bitmap.pFont;
  if (0 < *(int *)&p_Var2->unload_font) {
    iVar20 = 0;
    do {
      while( true ) {
        lVar1 = (long)iVar20 * 0x88;
        if (*(FontPtr *)(p_Var2->unload_glyphs + lVar1 + 0x80) == pFont) break;
        iVar19 = *(int *)&p_Var2->unload_font;
LAB_0010f5d5:
        iVar20 = iVar20 + 1;
        if (iVar19 <= iVar20) {
          return;
        }
      }
      __ptr = *(void **)(p_Var2->unload_glyphs + lVar1 + 0x70);
      if (__ptr != (void *)0x0) {
        free(__ptr);
      }
      iVar19 = *(int *)&p_Var2->unload_font + -1;
      *(int *)&p_Var2->unload_font = iVar19;
      if (iVar19 <= iVar20) goto LAB_0010f5d5;
      do {
        iVar19 = iVar20;
        p_Var3 = p_Var2->unload_glyphs;
        iVar20 = iVar19 + 1;
        uVar4 = *(undefined8 *)(p_Var3 + lVar1 + 0x88 + 8);
        uVar5 = *(undefined8 *)(p_Var3 + lVar1 + 0x98);
        uVar6 = *(undefined8 *)(p_Var3 + lVar1 + 0x98 + 8);
        uVar7 = *(undefined8 *)(p_Var3 + lVar1 + 0xa8);
        uVar8 = *(undefined8 *)(p_Var3 + lVar1 + 0xa8 + 8);
        uVar9 = *(undefined8 *)(p_Var3 + lVar1 + 0xb8);
        uVar10 = *(undefined8 *)(p_Var3 + lVar1 + 0xb8 + 8);
        uVar11 = *(undefined8 *)(p_Var3 + lVar1 + 200);
        uVar12 = *(undefined8 *)(p_Var3 + lVar1 + 200 + 8);
        uVar13 = *(undefined8 *)(p_Var3 + lVar1 + 0xd8);
        uVar14 = *(undefined8 *)(p_Var3 + lVar1 + 0xd8 + 8);
        *(undefined8 *)(p_Var3 + lVar1) = *(undefined8 *)(p_Var3 + lVar1 + 0x88);
        *(undefined8 *)(p_Var3 + lVar1 + 8) = uVar4;
        uVar15 = *(undefined8 *)(p_Var3 + lVar1 + 0xe8);
        uVar16 = *(undefined8 *)(p_Var3 + lVar1 + 0xe8 + 8);
        uVar17 = *(undefined8 *)(p_Var3 + lVar1 + 0xf8);
        uVar18 = *(undefined8 *)(p_Var3 + lVar1 + 0xf8 + 8);
        *(undefined8 *)(p_Var3 + lVar1 + 0x10) = uVar5;
        *(undefined8 *)(p_Var3 + lVar1 + 0x10 + 8) = uVar6;
        uVar4 = *(undefined8 *)(p_Var3 + lVar1 + 0x108);
        *(undefined8 *)(p_Var3 + lVar1 + 0x20) = uVar7;
        *(undefined8 *)(p_Var3 + lVar1 + 0x20 + 8) = uVar8;
        *(undefined8 *)(p_Var3 + lVar1 + 0x30) = uVar9;
        *(undefined8 *)(p_Var3 + lVar1 + 0x30 + 8) = uVar10;
        *(undefined8 *)(p_Var3 + lVar1 + 0x80) = uVar4;
        *(undefined8 *)(p_Var3 + lVar1 + 0x40) = uVar11;
        *(undefined8 *)(p_Var3 + lVar1 + 0x40 + 8) = uVar12;
        *(undefined8 *)(p_Var3 + lVar1 + 0x50) = uVar13;
        *(undefined8 *)(p_Var3 + lVar1 + 0x50 + 8) = uVar14;
        *(undefined8 *)(p_Var3 + lVar1 + 0x60) = uVar15;
        *(undefined8 *)(p_Var3 + lVar1 + 0x60 + 8) = uVar16;
        *(undefined8 *)(p_Var3 + lVar1 + 0x70) = uVar17;
        *(undefined8 *)(p_Var3 + lVar1 + 0x70 + 8) = uVar18;
        lVar1 = lVar1 + 0x88;
      } while (iVar20 < *(int *)&p_Var2->unload_font);
      iVar20 = iVar19 + 2;
    } while (iVar20 < *(int *)&p_Var2->unload_font);
  }
  return;
}



void BitOrderInvert(uchar *buf,int nbytes)

{
  BitOrderInvert(buf,nbytes);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void FreeTypeRegisterFontFileFunctions(void)

{
  FontFileRegisterRenderer(renderers);
  FontFileRegisterRenderer(renderers + 1);
  FontFileRegisterRenderer(renderers + 2);
  FontFileRegisterRenderer(renderers + 3);
  FontFileRegisterRenderer(renderers + 4);
  FontFileRegisterRenderer(renderers + 5);
  FontFilePriorityRegisterRenderer(alt_renderers,-10);
  FontFilePriorityRegisterRenderer(alt_renderers + 1,-10);
  return;
}



// WARNING: Unknown calling convention

int set_font_authorizations(char **authorizations,int *authlen,ClientPtr client)

{
  int iVar1;
  
  iVar1 = set_font_authorizations(authorizations,authlen,client);
  return iVar1;
}



Bool bdfSpecialProperty(FontPtr pFont,FontPropPtr prop,char isString,bdfFileState *bdfState)

{
  Bool BVar1;
  
  BVar1 = bdfSpecialProperty(pFont,prop,isString,bdfState);
  return BVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getc(FILE *__stream)

{
  int iVar1;
  
  iVar1 = getc(__stream);
  return iVar1;
}



pointer fs_alloc_glyphs(FontPtr pFont,int size)

{
  pointer pvVar1;
  
  pvVar1 = fs_alloc_glyphs(pFont,size);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void FontFileRegisterFpeFunctions(void)

{
  BitmapRegisterFontFileFunctions();
  FreeTypeRegisterFontFileFunctions();
  FontFileRegisterLocalFpeFunctions();
  CatalogueRegisterLocalFpeFunctions();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strstr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strstr(__haystack,__needle);
  return pcVar1;
}



void bdfWarning(char *message,...)

{
  bdfWarning(message);
  return;
}



int _fs_convert_props(fsPropInfo *pi,fsPropOffset *po,pointer pd,FontInfoPtr pfi)

{
  int iVar1;
  
  iVar1 = _fs_convert_props(pi,po,pd,pfi);
  return iVar1;
}



void FT_Get_Sfnt_Name(void)

{
  FT_Get_Sfnt_Name();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int rand(void)

{
  int iVar1;
  
  iVar1 = rand();
  return iVar1;
}



void FourByteSwap(uchar *buf,int nbytes)

{
  FourByteSwap(buf,nbytes);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ushort ** __ctype_b_loc(void)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  return ppuVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void freeaddrinfo(addrinfo *__ai)

{
  freeaddrinfo(__ai);
  return;
}



// WARNING: Unknown calling convention

void ErrorF(char *f,...)

{
  ErrorF(f);
  return;
}



FontEntryPtr FontFileFindNameInDir(FontTablePtr table,FontNamePtr pat)

{
  FontEntryPtr p_Var1;
  
  p_Var1 = FontFileFindNameInScalableDir(table,pat,(FontScalablePtr)0x0);
  return p_Var1;
}



void __sprintf_chk(void)

{
  __sprintf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int socket(int __domain,int __type,int __protocol)

{
  int iVar1;
  
  iVar1 = socket(__domain,__type,__protocol);
  return iVar1;
}



void FUN_0010a1b0(FontInfoPtr param_1)

{
  _fs_free_props(param_1);
  return;
}



void processEntry bdfSpecialProperty_cold(void)

{
  FUN_0011cb13();
  return;
}



void deregister_tm_clones(void)

{
  if ((false) && (true)) {
    _ITM_deregisterTMCloneTable();
    return;
  }
  return;
}



void register_tm_clones(void)

{
  if ((false) && (true)) {
    _ITM_registerTMCloneTable();
    return;
  }
  return;
}



void __do_global_dtors_aux(void)

{
  if (completed_8061 == '\0') {
    if (true) {
      __cxa_finalize(__dso_handle);
    }
    deregister_tm_clones();
    completed_8061 = 1;
    return;
  }
  return;
}



void frame_dummy(void)

{
  register_tm_clones();
  return;
}



Bool FontFileRegisterBitmapSource(FontPathElementPtr fpe)

{
  FontPathElementPtr *pp_Var1;
  int iVar2;
  long lVar3;
  
  if (0 < FontFileBitmapSources.count) {
    pp_Var1 = FontFileBitmapSources.fpe;
    do {
      if (*pp_Var1 == fpe) {
        return 1;
      }
      pp_Var1 = pp_Var1 + 1;
    } while (pp_Var1 != FontFileBitmapSources.fpe + (ulong)(FontFileBitmapSources.count - 1) + 1);
  }
  pp_Var1 = FontFileBitmapSources.fpe;
  iVar2 = FontFileBitmapSources.size;
  if (FontFileBitmapSources.size == FontFileBitmapSources.count) {
    iVar2 = FontFileBitmapSources.count + 4;
    pp_Var1 = (FontPathElementPtr *)realloc(FontFileBitmapSources.fpe,(long)iVar2 << 3);
    if (pp_Var1 == (FontPathElementPtr *)0x0) {
      return 0;
    }
  }
  FontFileBitmapSources.size = iVar2;
  FontFileBitmapSources.fpe = pp_Var1;
  lVar3 = (long)FontFileBitmapSources.count;
  FontFileBitmapSources.count = FontFileBitmapSources.count + 1;
  FontFileBitmapSources.fpe[lVar3] = fpe;
  return 1;
}



void FontFileUnregisterBitmapSource(FontPathElementPtr fpe)

{
  long lVar1;
  ulong uVar2;
  uint uVar3;
  ulong uVar4;
  bool bVar5;
  
  if (0 < FontFileBitmapSources.count) {
    uVar3 = FontFileBitmapSources.count - 1;
    uVar2 = 0;
    do {
      uVar4 = uVar2 & 0xffffffff;
      if (FontFileBitmapSources.fpe[uVar2] == fpe) {
        FontFileBitmapSources.count = uVar3;
        if (uVar3 == 0) {
          FontFileBitmapSources.size = 0;
          free(FontFileBitmapSources.fpe);
          FontFileBitmapSources.fpe = (FontPathElementPtr *)0x0;
          return;
        }
        if ((int)uVar3 <= (int)uVar2) {
          return;
        }
        lVar1 = (long)(int)uVar2 * 8;
        do {
          uVar3 = (int)uVar4 + 1;
          uVar4 = (ulong)uVar3;
          *(undefined8 *)((long)FontFileBitmapSources.fpe + lVar1) =
               *(undefined8 *)((long)FontFileBitmapSources.fpe + lVar1 + 8);
          lVar1 = lVar1 + 8;
        } while ((int)uVar3 < FontFileBitmapSources.count);
        return;
      }
      bVar5 = uVar2 != uVar3;
      uVar2 = uVar2 + 1;
    } while (bVar5);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void FontFileEmptyBitmapSource(void)

{
  if (FontFileBitmapSources.count == 0) {
    return;
  }
  FontFileBitmapSources.size = 0;
  FontFileBitmapSources.count = 0;
  free(FontFileBitmapSources.fpe);
  FontFileBitmapSources.fpe = (FontPathElementPtr *)0x0;
  return;
}



int FontFileMatchBitmapSource
              (FontPathElementPtr fpe,FontPtr *pFont,int flags,FontEntryPtr_conflict entry,
              FontNamePtr zeroPat,FontScalablePtr vals,fsBitmapFormat format,
              fsBitmapFormatMask fmask,Bool noSpecificSize)

{
  FontPtr p_Var1;
  int iVar2;
  FontEntryPtr p_Var3;
  FontScaledPtr p_Var4;
  long lVar5;
  
  if (0 < FontFileBitmapSources.count) {
    lVar5 = 0;
    do {
      if (((FontFileBitmapSources.fpe[lVar5] != fpe) &&
          (p_Var3 = FontFileFindNameInDir
                              ((FontTablePtr)
                               ((long)FontFileBitmapSources.fpe[lVar5]->private + 0x18),zeroPat),
          p_Var3 != (FontEntryPtr)0x0)) &&
         (p_Var4 = FontFileFindScaledInstance(p_Var3,vals,noSpecificSize),
         p_Var4 != (FontScaledPtr)0x0)) {
        p_Var1 = p_Var4->pFont;
        if (p_Var1 != (FontPtr)0x0) {
          *pFont = p_Var1;
          p_Var1->fpe = FontFileBitmapSources.fpe[lVar5];
          return 0x55;
        }
        p_Var3 = p_Var4->bitmap;
        if (p_Var3 == (FontEntryPtr)0x0) {
          return 0x53;
        }
        p_Var1 = (FontPtr)(p_Var3->u).scalable.extra;
        if (p_Var1 != (FontPtr)0x0) {
          *pFont = p_Var1;
          p_Var1->fpe = FontFileBitmapSources.fpe[lVar5];
          return 0x55;
        }
        iVar2 = FontFileOpenBitmap(FontFileBitmapSources.fpe[lVar5],pFont,flags,p_Var3,format,fmask)
        ;
        if (iVar2 == 0x55) {
          if (*pFont != (FontPtr)0x0) {
            (*pFont)->fpe = FontFileBitmapSources.fpe[lVar5];
            return 0x55;
          }
          return 0x55;
        }
        return iVar2;
      }
      lVar5 = lVar5 + 1;
    } while ((int)lVar5 < FontFileBitmapSources.count);
  }
  return 0x53;
}



int BufFileRawClose(BufFilePtr f,int doClose)

{
  if (doClose == 0) {
    return 1;
  }
  close((int)f->private);
  return 1;
}



int BufFileRawFill(BufFilePtr f)

{
  ssize_t sVar1;
  
  sVar1 = read(*(int *)&f->private,f->buffer,0x2000);
  if (0 < (int)sVar1) {
    f->left = (int)sVar1 + -1;
    f->bufp = f->buffer + 1;
    return (int)f->buffer[0];
  }
  f->left = 0;
  return -1;
}



int BufFileRawSkip(BufFilePtr f,int count)

{
  __off_t _Var1;
  int *piVar2;
  ssize_t sVar3;
  int iVar4;
  int iVar5;
  
  iVar5 = f->left;
  if (count <= iVar5) {
    f->bufp = f->bufp + count;
    f->left = iVar5 - count;
    return count;
  }
  iVar5 = count - iVar5;
  _Var1 = lseek(*(int *)&f->private,(long)iVar5,1);
  if (_Var1 == -1) {
    piVar2 = __errno_location();
    if (*piVar2 != 0x1d) {
      return -1;
    }
    do {
      iVar4 = 0x2000;
      if (iVar5 < 0x2000) {
        iVar4 = iVar5;
      }
      sVar3 = read(*(int *)&f->private,f->buffer,(long)iVar4);
      if ((int)sVar3 < 1) {
        return -1;
      }
      iVar5 = iVar5 - (int)sVar3;
    } while (iVar5 != 0);
  }
  f->left = 0;
  return count;
}



int BufFileRawFlush(int c,BufFilePtr f)

{
  BufChar *__buf;
  BufChar *pBVar1;
  size_t sVar2;
  size_t __n;
  
  pBVar1 = f->bufp;
  if (c != -1) {
    f->bufp = pBVar1 + 1;
    *pBVar1 = (BufChar)c;
    pBVar1 = f->bufp;
  }
  __buf = f->buffer;
  f->left = 0x2000;
  f->bufp = __buf;
  __n = (size_t)((int)pBVar1 - (int)__buf);
  sVar2 = write((int)f->private,__buf,__n);
  if (sVar2 != __n) {
    c = -1;
  }
  return c;
}



int BufFileFlush(BufFilePtr f,int doClose)

{
  int iVar1;
  
  if (f->bufp != f->buffer) {
                    // WARNING: Could not recover jumptable at 0x0010a71c. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar1 = (*f->output)(-1,f);
    return iVar1;
  }
  return 0;
}



BufFilePtr
BufFileCreate(char *private,_func_int_BufFilePtr *input,_func_int_int_BufFilePtr *output,
             _func_int_BufFilePtr_int *skip,_func_int_BufFilePtr_int *close)

{
  BufFilePtr p_Var1;
  
  p_Var1 = (BufFilePtr)malloc(0x2038);
  if (p_Var1 != (BufFilePtr)0x0) {
    p_Var1->private = private;
    p_Var1->bufp = p_Var1->buffer;
    p_Var1->input = input;
    p_Var1->output = output;
    p_Var1->skip = skip;
    p_Var1->left = 0;
    p_Var1->eof = 0;
    p_Var1->close = close;
  }
  return p_Var1;
}



BufFilePtr BufFileOpenRead(int fd)

{
  BufFilePtr p_Var1;
  
  p_Var1 = BufFileCreate((char *)(long)fd,BufFileRawFill,(_func_int_int_BufFilePtr *)0x0,
                         BufFileRawSkip,BufFileRawClose);
  return p_Var1;
}



BufFilePtr BufFileOpenWrite(int fd)

{
  BufFilePtr p_Var1;
  
  p_Var1 = BufFileCreate((char *)(long)fd,(_func_int_BufFilePtr *)0x0,BufFileRawFlush,
                         (_func_int_BufFilePtr_int *)0x0,BufFileFlush);
  p_Var1->left = 0x2000;
  p_Var1->bufp = p_Var1->buffer;
  return p_Var1;
}



int BufFileRead(BufFilePtr f,char *b,int n)

{
  int iVar1;
  byte *pbVar2;
  uint uVar3;
  int iVar4;
  bool bVar5;
  
  iVar4 = n + -1;
  if (n != 0) {
    do {
      iVar1 = f->left;
      f->left = iVar1 + -1;
      if (iVar1 == 0) {
        uVar3 = (*f->input)(f);
        f->eof = uVar3;
        if (uVar3 == 0xffffffff) goto LAB_0010a877;
      }
      else {
        pbVar2 = f->bufp;
        f->bufp = pbVar2 + 1;
        uVar3 = (uint)*pbVar2;
      }
      *b = (char)uVar3;
      bVar5 = iVar4 != 0;
      b = b + 1;
      iVar4 = iVar4 + -1;
    } while (bVar5);
  }
  iVar4 = -1;
LAB_0010a877:
  return (n - iVar4) + -1;
}



int BufFileWrite(BufFilePtr f,char *b,int n)

{
  BufChar BVar1;
  BufChar *pBVar2;
  int iVar3;
  BufChar *pBVar4;
  BufChar *pBVar5;
  
  if (n != 0) {
    pBVar4 = (BufChar *)b;
    do {
      pBVar5 = pBVar4 + 1;
      iVar3 = f->left + -1;
      f->left = iVar3;
      if (iVar3 == 0) {
        iVar3 = (*f->output)((int)*pBVar4,f);
        if (iVar3 == -1) {
          return -1;
        }
      }
      else {
        pBVar2 = f->bufp;
        BVar1 = *pBVar4;
        f->bufp = pBVar2 + 1;
        *pBVar2 = BVar1;
      }
      pBVar4 = pBVar5;
    } while (pBVar5 != (BufChar *)(b + (ulong)(n - 1) + 1));
  }
  return n;
}



int BufFileClose(BufFilePtr f,int doClose)

{
  int iVar1;
  
  iVar1 = (*f->close)(f,doClose);
  free(f);
  return iVar1;
}



int BufCompressedFill(BufFilePtr f)

{
  BufChar *pBVar1;
  BufChar *pBVar2;
  _func_int_BufFilePtr **pp_Var3;
  char *pcVar4;
  long lVar5;
  byte *pbVar6;
  byte bVar7;
  uint uVar8;
  long lVar9;
  ulong uVar10;
  byte bVar11;
  int iVar12;
  char *pcVar13;
  char *pcVar14;
  int iVar15;
  long *plVar16;
  uint uVar17;
  ulong uVar18;
  int iVar19;
  byte *pbVar20;
  BufChar *pBVar21;
  BufChar *pBVar22;
  byte *local_70;
  ulong local_68;
  char local_49;
  
  pBVar1 = f->buffer;
  pp_Var3 = &f->input;
  pcVar4 = f->private;
  pcVar14 = *(char **)(pcVar4 + 8);
  local_49 = pcVar4[0x18];
  local_68 = *(ulong *)(pcVar4 + 0x10);
  pcVar13 = pcVar14;
  pBVar22 = pBVar1;
  if (pp_Var3 <= pBVar1) goto LAB_0010a9d2;
  do {
    pcVar13 = pcVar14;
    pBVar21 = pBVar22;
    if (pcVar4 + 0x60 < pcVar14) {
      do {
        pBVar2 = (BufChar *)(pcVar13 + -1);
        pcVar13 = pcVar13 + -1;
        pBVar22 = pBVar21 + 1;
        *pBVar21 = *pBVar2;
        if (pcVar13 <= pcVar4 + 0x60) break;
        pBVar21 = pBVar22;
      } while (pBVar22 < pp_Var3);
    }
LAB_0010a9d2:
    if (pp_Var3 == (_func_int_BufFilePtr **)pBVar22) {
      *(char **)(pcVar4 + 8) = pcVar13;
      *(ulong *)(pcVar4 + 0x10) = local_68;
      pcVar4[0x18] = local_49;
      goto LAB_0010abdd;
    }
    local_70 = (byte *)(pcVar4 + 0x50);
    lVar9 = *(long *)(pcVar4 + 0x38);
    lVar5 = *(long *)(pcVar4 + 0x28);
    pcVar14 = pcVar13;
    pbVar20 = local_70;
    if (*(int *)(pcVar4 + 0x40) < 1) {
      uVar8 = *(uint *)(pcVar4 + 0x48);
      iVar19 = *(int *)(pcVar4 + 0x44);
      if (*(int *)(pcVar4 + 0x4c) <= (int)uVar8) {
        if (lVar5 < lVar9) {
          iVar19 = iVar19 + 1;
          *(int *)(pcVar4 + 0x44) = iVar19;
          if (iVar19 == *(int *)(pcVar4 + 0x20)) goto LAB_0010ad30;
          goto LAB_0010aa16;
        }
LAB_0010aa31:
        plVar16 = *(long **)pcVar4;
        iVar12 = iVar19;
        if (0 < iVar19) goto LAB_0010aa74;
        break;
      }
      if (lVar5 < lVar9) goto LAB_0010aa04;
      iVar12 = uVar8 + iVar19;
      uVar17 = uVar8 & 7;
      iVar15 = 8 - uVar17;
      local_70 = local_70 + ((int)uVar8 >> 3);
    }
    else {
      if (lVar5 < lVar9) {
        iVar19 = *(int *)(pcVar4 + 0x44);
LAB_0010aa04:
        iVar19 = iVar19 + 1;
        *(int *)(pcVar4 + 0x44) = iVar19;
        if (iVar19 == *(int *)(pcVar4 + 0x20)) {
LAB_0010ad30:
          lVar9 = *(long *)(pcVar4 + 0x30);
        }
        else {
LAB_0010aa16:
          lVar9 = (long)((1 << ((byte)iVar19 & 0x1f)) + -1);
        }
        *(long *)(pcVar4 + 0x28) = lVar9;
        if (*(int *)(pcVar4 + 0x40) < 1) goto LAB_0010aa31;
      }
      plVar16 = *(long **)pcVar4;
      pcVar4[0x28] = -1;
      pcVar4[0x29] = '\x01';
      pcVar4[0x2a] = '\0';
      pcVar4[0x2b] = '\0';
      pcVar4[0x2c] = '\0';
      pcVar4[0x2d] = '\0';
      pcVar4[0x2e] = '\0';
      pcVar4[0x2f] = '\0';
      iVar12 = 9;
      pcVar4[0x40] = '\0';
      pcVar4[0x41] = '\0';
      pcVar4[0x42] = '\0';
      pcVar4[0x43] = '\0';
      pcVar4[0x44] = '\t';
      pcVar4[0x45] = '\0';
      pcVar4[0x46] = '\0';
      pcVar4[0x47] = '\0';
LAB_0010aa74:
      do {
        iVar19 = *(int *)(plVar16 + 1);
        *(int *)(plVar16 + 1) = iVar19 + -1;
        if (iVar19 == 0) {
          uVar8 = (*(code *)plVar16[0x402])(plVar16);
          *(uint *)((long)plVar16 + 0xc) = uVar8;
          if (uVar8 == 0xffffffff) break;
        }
        else {
          pbVar6 = (byte *)*plVar16;
          *plVar16 = (long)(pbVar6 + 1);
          uVar8 = (uint)*pbVar6;
        }
        *pbVar20 = (byte)uVar8;
        iVar12 = iVar12 + -1;
        pbVar20 = pbVar20 + 1;
      } while (iVar12 != 0);
      iVar19 = *(int *)(pcVar4 + 0x44);
      if (iVar19 == iVar12) break;
      pcVar4[0x48] = '\0';
      pcVar4[0x49] = '\0';
      pcVar4[0x4a] = '\0';
      pcVar4[0x4b] = '\0';
      uVar17 = 0;
      iVar15 = 8;
      *(int *)(pcVar4 + 0x4c) = iVar19 * 7 + iVar12 * -8 + 1;
      iVar12 = iVar19;
    }
    iVar19 = iVar19 - iVar15;
    bVar7 = local_70[1];
    uVar8 = (int)(uint)*local_70 >> (sbyte)uVar17;
    if (7 < iVar19) {
      iVar19 = iVar19 + -8;
      bVar11 = (byte)iVar15;
      iVar15 = 0x10 - uVar17;
      uVar8 = uVar8 | (uint)bVar7 << (bVar11 & 0x1f);
      bVar7 = local_70[2];
    }
    *(int *)(pcVar4 + 0x48) = iVar12;
    uVar18 = (ulong)(int)(uVar8 | (uint)(bVar7 & ""[iVar19]) << ((byte)iVar15 & 0x1f));
    if (uVar18 == 0x100) {
      if (*(int *)(pcVar4 + 0x1c) == 0) {
        lVar9 = *(long *)(pcVar4 + 0x38);
        if (0x100 < lVar9) {
          uVar10 = 0x100;
          goto LAB_0010ab38;
        }
        goto LAB_0010ac70;
      }
      lVar9 = 0x1fe;
      do {
        *(undefined2 *)(*(long *)(pcVar4 + 0xff80) + lVar9) = 0;
        lVar9 = lVar9 + -2;
      } while (lVar9 != -2);
      pcVar4[0x40] = '\x01';
      pcVar4[0x41] = '\0';
      pcVar4[0x42] = '\0';
      pcVar4[0x43] = '\0';
      pcVar4[0x38] = '\x01';
      pcVar4[0x39] = '\x01';
      pcVar4[0x3a] = '\0';
      pcVar4[0x3b] = '\0';
      pcVar4[0x3c] = '\0';
      pcVar4[0x3d] = '\0';
      pcVar4[0x3e] = '\0';
      pcVar4[0x3f] = '\0';
      local_68 = 0xffffffffffffffff;
      uVar18 = local_68;
    }
    else {
      lVar9 = *(long *)(pcVar4 + 0x38);
      uVar10 = uVar18;
      if (lVar9 <= (long)uVar18) {
LAB_0010ac70:
        if ((lVar9 < (long)uVar18) || (local_68 == 0xffffffffffffffff)) {
          return -1;
        }
        *pcVar13 = local_49;
        uVar10 = local_68;
        pcVar13 = pcVar13 + 1;
      }
      for (; 0xff < (long)uVar10;
          uVar10 = (ulong)*(ushort *)(*(long *)(pcVar4 + 0xff80) + uVar10 * 2)) {
LAB_0010ab38:
        *pcVar13 = *(char *)(*(long *)(pcVar4 + 0xff78) + uVar10);
        pcVar13 = pcVar13 + 1;
      }
      pcVar14 = pcVar13 + 1;
      local_49 = *(char *)(*(long *)(pcVar4 + 0xff78) + uVar10);
      *pcVar13 = local_49;
      lVar9 = *(long *)(pcVar4 + 0x38);
      if ((lVar9 < *(long *)(pcVar4 + 0x30)) && (local_68 != 0xffffffffffffffff)) {
        *(short *)(*(long *)(pcVar4 + 0xff80) + lVar9 * 2) = (short)local_68;
        *(char *)(*(long *)(pcVar4 + 0xff78) + lVar9) = local_49;
        *(long *)(pcVar4 + 0x38) = lVar9 + 1;
      }
    }
    local_68 = uVar18;
  } while (pBVar22 < pp_Var3);
  *(char **)(pcVar4 + 8) = pcVar14;
  *(ulong *)(pcVar4 + 0x10) = local_68;
  pcVar4[0x18] = local_49;
  if (pBVar1 == pBVar22) {
    f->left = 0;
    uVar8 = 0xffffffff;
  }
  else {
LAB_0010abdd:
    f->bufp = f->buffer + 1;
    f->left = ((int)pBVar22 - (int)pBVar1) + -1;
    uVar8 = (uint)f->buffer[0];
  }
  return uVar8;
}



int BufCompressedSkip(BufFilePtr f,int bytes)

{
  int iVar1;
  
  if (bytes == 0) {
    return 0;
  }
  do {
    iVar1 = f->left;
    f->left = iVar1 + -1;
    if (iVar1 == 0) {
      iVar1 = (*f->input)(f);
      f->eof = iVar1;
      if (iVar1 == -1) {
        return iVar1;
      }
    }
    else {
      f->bufp = f->bufp + 1;
    }
    bytes = bytes + -1;
  } while (bytes != 0);
  return 0;
}



int BufCompressedClose(BufFilePtr f,int doClose)

{
  BufFilePtr f_00;
  
  f_00 = *(BufFilePtr *)f->private;
  free(f->private);
  BufFileClose(f_00,doClose);
  return 1;
}



BufFilePtr BufFilePushCompressed(BufFilePtr f)

{
  int iVar1;
  byte *pbVar2;
  uint uVar3;
  char *private;
  char *pcVar4;
  BufFilePtr p_Var5;
  long lVar6;
  long lVar7;
  uint uVar8;
  
  iVar1 = f->left;
  f->left = iVar1 + -1;
  if (iVar1 == 0) {
    uVar3 = (*f->input)(f);
    f->eof = uVar3;
  }
  else {
    pbVar2 = f->bufp;
    f->bufp = pbVar2 + 1;
    uVar3 = (uint)*pbVar2;
  }
  if (uVar3 == 0x1f) {
    iVar1 = f->left;
    f->left = iVar1 + -1;
    if (iVar1 == 0) {
      uVar3 = (*f->input)(f);
      f->eof = uVar3;
    }
    else {
      pbVar2 = f->bufp;
      f->bufp = pbVar2 + 1;
      uVar3 = (uint)*pbVar2;
    }
    if (uVar3 == 0x9d) {
      iVar1 = f->left;
      f->left = iVar1 + -1;
      if (iVar1 == 0) {
        uVar3 = (*f->input)(f);
        f->eof = uVar3;
        if (uVar3 == 0xffffffff) {
          return (BufFilePtr)0x0;
        }
      }
      else {
        pbVar2 = f->bufp;
        f->bufp = pbVar2 + 1;
        uVar3 = (uint)*pbVar2;
      }
      uVar8 = uVar3 & 0x1f;
      if (uVar8 - 10 < 7) {
        lVar7 = (long)(1 << (sbyte)uVar8);
        private = (char *)malloc((ulong)(uint)(3 << (sbyte)uVar8) + 0xff88);
        if (private != (char *)0x0) {
          *(BufFilePtr *)private = f;
          lVar6 = 0xff;
          *(uint *)(private + 0x20) = uVar8;
          *(uint *)(private + 0x1c) = uVar3 & 0x80;
          *(long *)(private + 0x30) = lVar7;
          *(char **)(private + 0xff78) = private + 0xff88;
          pcVar4 = private + 0xff88 + lVar7;
          *(char **)(private + 0xff80) = pcVar4;
          private[0x44] = '\t';
          private[0x45] = '\0';
          private[0x46] = '\0';
          private[0x47] = '\0';
          private[0x28] = -1;
          private[0x29] = '\x01';
          private[0x2a] = '\0';
          private[0x2b] = '\0';
          private[0x2c] = '\0';
          private[0x2d] = '\0';
          private[0x2e] = '\0';
          private[0x2f] = '\0';
          while( true ) {
            (pcVar4 + lVar6 * 2)[0] = '\0';
            (pcVar4 + lVar6 * 2)[1] = '\0';
            *(char *)(*(long *)(private + 0xff78) + lVar6) = (char)lVar6;
            lVar6 = lVar6 + -1;
            if (lVar6 == -1) break;
            pcVar4 = *(char **)(private + 0xff80);
          }
          private[0x40] = '\0';
          private[0x41] = '\0';
          private[0x42] = '\0';
          private[0x43] = '\0';
          private[0x10] = -1;
          private[0x11] = -1;
          private[0x12] = -1;
          private[0x13] = -1;
          private[0x14] = -1;
          private[0x15] = -1;
          private[0x16] = -1;
          private[0x17] = -1;
          private[0x48] = '\0';
          private[0x49] = '\0';
          private[0x4a] = '\0';
          private[0x4b] = '\0';
          private[0x4c] = '\0';
          private[0x4d] = '\0';
          private[0x4e] = '\0';
          private[0x4f] = '\0';
          *(undefined (*) [16])(private + 0x50) = (undefined  [16])0x0;
          *(ulong *)(private + 0x38) = (ulong)(*(int *)(private + 0x1c) != 0) + 0x100;
          *(char **)(private + 8) = private + 0x60;
          p_Var5 = BufFileCreate(private,BufCompressedFill,(_func_int_int_BufFilePtr *)0x0,
                                 BufCompressedSkip,BufCompressedClose);
          return p_Var5;
        }
      }
    }
  }
  return (BufFilePtr)0x0;
}



// WARNING: Unknown calling convention

void FontDefaultFormat(int *bit,int *byte,int *glyph,int *scan)

{
  *bit = 1;
  *byte = 1;
  *glyph = 4;
  *scan = 1;
  return;
}



int lexAlias(FILE *file,char **lexToken)

{
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  int iVar4;
  size_t __size;
  byte bVar5;
  int iVar6;
  bool bVar7;
  
  iVar6 = 0;
  bVar5 = 0;
  iVar4 = 0;
  pcVar3 = lexAlias::tokenBuf;
LAB_0010b097:
  while( true ) {
    if (lexAlias::tokenSize == iVar4) {
      if (iVar4 == 0) {
        __size = 0x40;
        iVar1 = 0x40;
      }
      else {
        iVar1 = iVar4 * 2;
        __size = (size_t)iVar1;
      }
      pcVar2 = (char *)realloc(lexAlias::tokenBuf,__size);
      if (pcVar2 == (char *)0x0) {
        return 3;
      }
      pcVar3 = pcVar2 + iVar4;
      lexAlias::tokenSize = iVar1;
      lexAlias::tokenBuf = pcVar2;
    }
    iVar1 = getc((FILE *)file);
    pcVar2 = lexAlias::tokenBuf;
    if (0x22 < iVar1) break;
    if ((iVar1 < -1) || (false)) goto switchD_0010b0f8_caseD_0;
    switch(iVar1) {
    default:
      goto switchD_0010b0f8_caseD_0;
    case 9:
    case 0x20:
      charClass = 1;
      if (bVar5 == 1) {
        *pcVar3 = '\0';
        *lexToken = pcVar2;
        return 0;
      }
      if ((bVar5 != 3) && (bVar5 != 0)) goto LAB_0010b12f;
      break;
    case 10:
    case 0xd:
      charClass = 4;
      if ((bVar5 == 0) || (bVar5 == 3)) {
        *lexToken = (char *)0x0;
        return 1;
      }
      goto LAB_0010b251;
    case 0x21:
      charClass = 5;
      if (bVar5 == 0) {
        iVar6 = 3;
        bVar5 = 3;
      }
      else if (bVar5 != 3) {
        *pcVar3 = '!';
        iVar4 = iVar4 + 1;
        pcVar3 = pcVar3 + 1;
      }
      break;
    case 0x22:
      charClass = 0;
      if (bVar5 < 2) {
        iVar6 = 2;
        bVar5 = 2;
      }
      else {
        bVar7 = iVar6 != 2;
        bVar5 = bVar7 * '\x02' + 1;
        iVar6 = bVar7 + 1 + (uint)bVar7;
      }
      break;
    case -1:
      goto switchD_0010b0f8_caseD_ffffffff;
    }
  }
  if ((iVar1 == 0x5c) && (iVar1 = getc((FILE *)file), iVar1 == -1)) {
switchD_0010b0f8_caseD_ffffffff:
    charClass = 3;
    if ((bVar5 == 0) || (iVar1 = -1, bVar5 == 3)) {
      *lexToken = (char *)0x0;
      return 2;
    }
LAB_0010b251:
    pcVar2 = lexAlias::tokenBuf;
    *pcVar3 = '\0';
    *lexToken = pcVar2;
    ungetc(iVar1,(FILE *)file);
    return 0;
  }
switchD_0010b0f8_caseD_0:
  charClass = 2;
  if (bVar5 == 0) {
    iVar6 = 1;
    bVar5 = 1;
  }
  else if (bVar5 == 3) goto LAB_0010b097;
LAB_0010b12f:
  *pcVar3 = (char)iVar1;
  iVar4 = iVar4 + 1;
  pcVar3 = pcVar3 + 1;
  goto LAB_0010b097;
}



int FontFileReadDirectory(char *directory,FontDirectoryPtr *pdir)

{
  long lVar1;
  FontEntryPtr_conflict p_Var2;
  int iVar3;
  int iVar4;
  Bool BVar5;
  size_t sVar6;
  char *pcVar7;
  long lVar8;
  FILE *pFVar9;
  FontDirectoryPtr dir;
  undefined8 uVar10;
  uint *puVar11;
  uint *puVar12;
  FontRendererPtr p_Var13;
  FontEntryPtr p_Var14;
  int *piVar15;
  char cVar16;
  uint uVar17;
  uint uVar18;
  byte *pbVar19;
  long in_FS_OFFSET;
  bool bVar20;
  bool bVar21;
  byte bVar22;
  int num_fonts;
  char *lexToken;
  FontNameRec name;
  stat statb;
  stat statb_1;
  char file_name [1024];
  char font_name [1024];
  char dir_file [1024];
  char dir_path [1024];
  char alias [1024];
  char font_name_1 [1024];
  char alias_file [1024];
  char copy [1024];
  
  bVar22 = 0;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  sVar6 = strlen(directory);
  if (sVar6 + 0xb < 0x401) {
    pcVar7 = strchr(directory,0x3a);
    if (pcVar7 == (char *)0x0) {
      __memcpy_chk(dir_path,directory,sVar6 + 1,0x400);
    }
    else {
      __strncpy_chk(dir_path,directory,(long)pcVar7 - (long)directory,0x400);
      dir_path[(long)pcVar7 - (long)directory] = '\0';
    }
    lVar8 = __stpcpy_chk(dir_file,dir_path,0x400);
    if (font_name[(lVar8 - (long)dir_file) + 0x3ff] != '/') {
      __memcpy_chk(lVar8,&DAT_0013209c,2,dir_path + -lVar8);
    }
    __strcat_chk(dir_file,"fonts.dir",0x400);
    pFVar9 = fopen(dir_file,"rt");
    if (pFVar9 == (FILE *)0x0) {
      piVar15 = __errno_location();
      if (*piVar15 == 2) {
        uVar10 = __strcpy_chk(alias_file,dir_path,0x400);
        puVar12 = (uint *)dir_path;
        do {
          puVar11 = puVar12;
          uVar17 = *puVar11 + 0xfefefeff & ~*puVar11;
          uVar18 = uVar17 & 0x80808080;
          puVar12 = puVar11 + 1;
        } while (uVar18 == 0);
        bVar20 = (uVar17 & 0x8080) == 0;
        if (bVar20) {
          uVar18 = uVar18 >> 0x10;
        }
        if (bVar20) {
          puVar12 = (uint *)((long)puVar11 + 6);
        }
        lVar8 = (long)puVar12 + ((-3 - (ulong)CARRY1((byte)uVar18,(byte)uVar18)) - (long)dir_path);
        dir = (FontDirectoryPtr)0x0;
        if (lVar8 + 0xdU < 0x401) goto LAB_0010b5cf;
      }
    }
    else {
      iVar3 = fileno(pFVar9);
      iVar3 = __fxstat(1,iVar3,(stat *)&statb);
      if (((iVar3 == -1) || (iVar3 = __isoc99_fscanf(pFVar9,&DAT_001320ab,&num_fonts), iVar3 != 1))
         || (dir = FontFileMakeDir(directory,num_fonts), dir == (FontDirectoryPtr)0x0)) {
        fclose(pFVar9);
      }
      else {
        dir->dir_mtime = statb.st_mtim.tv_sec;
        if (FontFileReadDirectory::format[0] == '\0') {
          __sprintf_chk(FontFileReadDirectory::format,1,0x18,"%%%ds %%%d[^\n]\n",0x3ff,0x3ff);
        }
        while (iVar3 = __isoc99_fscanf(pFVar9,FontFileReadDirectory::format,file_name,font_name),
              iVar3 != -1) {
          if (iVar3 != 2) {
            iVar3 = 0x56;
            FontFileFreeDir(dir);
            fclose(pFVar9);
            goto LAB_0010b506;
          }
          FontFileAddFontFile(dir,font_name,file_name);
        }
        fclose(pFVar9);
        uVar10 = __strcpy_chk(alias_file,dir_path,0x400);
        puVar12 = (uint *)dir_path;
        do {
          puVar11 = puVar12;
          uVar17 = *puVar11 + 0xfefefeff & ~*puVar11;
          uVar18 = uVar17 & 0x80808080;
          puVar12 = puVar11 + 1;
        } while (uVar18 == 0);
        bVar20 = (uVar17 & 0x8080) == 0;
        if (bVar20) {
          uVar18 = uVar18 >> 0x10;
        }
        if (bVar20) {
          puVar12 = (uint *)((long)puVar11 + 6);
        }
        lVar8 = (long)puVar12 + ((-3 - (ulong)CARRY1((byte)uVar18,(byte)uVar18)) - (long)dir_path);
        if (0x400 < lVar8 + 0xdU) {
LAB_0010b4e7:
          iVar3 = 0x56;
          goto LAB_0010b80e;
        }
LAB_0010b5cf:
        if (dir_file[lVar8 + 0x3ff] != '/') {
          uVar10 = __strcat_chk(uVar10,&DAT_0013209c,0x400);
        }
        pcVar7 = (char *)__strcat_chk(uVar10,"fonts.alias",0x400);
        pFVar9 = fopen(pcVar7,"rt");
        if (pFVar9 != (FILE *)0x0) {
          if ((dir == (FontDirectoryPtr)0x0) &&
             (dir = FontFileMakeDir(dir_path,10), dir == (FontDirectoryPtr)0x0)) {
            iVar3 = 0x50;
            fclose(pFVar9);
            goto LAB_0010b506;
          }
          iVar3 = fileno(pFVar9);
          iVar3 = __fxstat(1,iVar3,(stat *)&statb_1);
          if (iVar3 != -1) {
            dir->alias_mtime = statb_1.st_mtim.tv_sec;
LAB_0010b65d:
            do {
              iVar3 = lexAlias((FILE *)pFVar9,&lexToken);
              pcVar7 = lexToken;
              if (iVar3 == 2) {
                fclose(pFVar9);
                goto LAB_0010b8c8;
              }
              if (iVar3 == 3) {
LAB_0010b800:
                iVar3 = 0x50;
LAB_0010b806:
                fclose(pFVar9);
                goto LAB_0010b80e;
              }
            } while (iVar3 != 0);
            sVar6 = strlen(lexToken);
            if (sVar6 < 0x400) {
              __memcpy_chk(alias,pcVar7,sVar6 + 1,0x400);
              iVar3 = lexAlias((FILE *)pFVar9,&lexToken);
              if (iVar3 == 2) goto LAB_0010b954;
              if (2 < iVar3) {
                if (iVar3 == 3) goto code_r0x0010b8eb;
                goto LAB_0010b65d;
              }
              if (iVar3 == 0) {
                sVar6 = strlen(lexToken);
                puVar12 = (uint *)alias;
                if (0x3ff < sVar6) goto LAB_0010b954;
                do {
                  puVar11 = puVar12;
                  uVar17 = *puVar11 + 0xfefefeff & ~*puVar11;
                  uVar18 = uVar17 & 0x80808080;
                  puVar12 = puVar11 + 1;
                } while (uVar18 == 0);
                bVar20 = (uVar17 & 0x8080) == 0;
                if (bVar20) {
                  uVar18 = uVar18 >> 0x10;
                }
                if (bVar20) {
                  puVar12 = (uint *)((long)puVar11 + 6);
                }
                CopyISOLatin1Lowered
                          (alias,alias,
                           (((int)puVar12 + -3) - (uint)CARRY1((byte)uVar18,(byte)uVar18)) -
                           (int)alias);
                pcVar7 = lexToken;
                sVar6 = strlen(lexToken);
                CopyISOLatin1Lowered(font_name_1,pcVar7,(int)sVar6);
                BVar5 = FontFileAddFontAlias(dir,alias,font_name_1);
                if (BVar5 == 0) goto LAB_0010b800;
                goto LAB_0010b65d;
              }
              bVar20 = iVar3 == 0;
              bVar21 = iVar3 == 1;
              if (!bVar21) goto LAB_0010b65d;
              lVar8 = 0x13;
              puVar12 = (uint *)alias;
              pbVar19 = (byte *)"FILE_NAMES_ALIASES";
              do {
                if (lVar8 == 0) break;
                lVar8 = lVar8 + -1;
                bVar20 = *(byte *)puVar12 < *pbVar19;
                bVar21 = *(byte *)puVar12 == *pbVar19;
                puVar12 = (uint *)((long)puVar12 + (ulong)bVar22 * -2 + 1);
                pbVar19 = pbVar19 + (ulong)bVar22 * -2 + 1;
              } while (bVar21);
              cVar16 = (!bVar20 && !bVar21) - bVar20;
              iVar3 = (int)cVar16;
              if (cVar16 == '\0') {
                if (0 < (dir->nonScalable).used) {
                  lVar8 = 0;
                  do {
                    p_Var2 = (dir->nonScalable).entries;
                    if (*(int *)((long)&p_Var2->type + lVar8) == 2) {
                      pcVar7 = *(char **)((long)&p_Var2->u + lVar8 + 8);
                      p_Var13 = FontFileMatchRenderer(pcVar7);
                      if (p_Var13 != (FontRendererPtr)0x0) {
                        sVar6 = strlen(pcVar7);
                        uVar18 = (int)sVar6 - p_Var13->fileSuffixLen;
                        if (uVar18 < 0x400) {
                          CopyISOLatin1Lowered(copy,pcVar7,uVar18);
                          copy[(int)uVar18] = '\0';
                          name.length = (short)uVar18;
                          name.name = copy;
                          iVar4 = FontFileCountDashes(copy,uVar18);
                          name.ndashes = (short)iVar4;
                          p_Var14 = FontFileFindNameInDir(&dir->nonScalable,&name);
                          if ((p_Var14 == (FontEntryPtr)0x0) &&
                             (BVar5 = FontFileAddFontAlias
                                                (dir,copy,*(char **)((long)&(((dir->nonScalable).
                                                                             entries)->name).name +
                                                                    lVar8)), BVar5 == 0))
                          goto LAB_0010b800;
                        }
                      }
                    }
                    iVar3 = iVar3 + 1;
                    lVar8 = lVar8 + 0x98;
                  } while (iVar3 < (dir->nonScalable).used);
                }
                goto LAB_0010b65d;
              }
            }
LAB_0010b954:
            iVar3 = 0x56;
            goto LAB_0010b806;
          }
          iVar3 = 0x56;
          fclose(pFVar9);
          goto LAB_0010b80e;
        }
        piVar15 = __errno_location();
        if (*piVar15 == 2) {
          if (dir != (FontDirectoryPtr)0x0) {
LAB_0010b8c8:
            iVar3 = 0x55;
            FontFileSortDir(dir);
            *pdir = dir;
            goto LAB_0010b506;
          }
        }
        else if (dir != (FontDirectoryPtr)0x0) goto LAB_0010b4e7;
      }
    }
  }
  iVar3 = 0x56;
  goto LAB_0010b506;
code_r0x0010b8eb:
  iVar3 = 0x50;
  fclose(pFVar9);
LAB_0010b80e:
  FontFileFreeDir(dir);
LAB_0010b506:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar3;
}



Bool FontFileDirectoryChanged(FontDirectoryPtr dir)

{
  char *pcVar1;
  long lVar2;
  uint uVar3;
  int iVar4;
  size_t sVar5;
  int *piVar6;
  long in_FS_OFFSET;
  stat statb;
  char dir_file [1024];
  
  pcVar1 = dir->directory;
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  sVar5 = strlen(pcVar1);
  if (sVar5 + 10 < 0x401) {
    __memcpy_chk(dir_file,pcVar1,sVar5,0x400);
    __memcpy_chk(dir_file + sVar5,"fonts.dir",10,0x400 - sVar5);
    iVar4 = __xstat(1,dir_file,(stat *)&statb);
    if (iVar4 == -1) {
      piVar6 = __errno_location();
      if (*piVar6 == 2) {
        uVar3 = (uint)(dir->dir_mtime != 0);
        goto LAB_0010ba57;
      }
    }
    else if (dir->dir_mtime == statb.st_mtim.tv_sec) {
      pcVar1 = dir->directory;
      sVar5 = strlen(pcVar1);
      if (0x400 < sVar5 + 0xc) goto LAB_0010ba55;
      __memcpy_chk(dir_file,pcVar1,sVar5,0x400);
      __memcpy_chk(dir_file + sVar5,"fonts.alias",0xc,0x400 - sVar5);
      iVar4 = __xstat(1,dir_file,(stat *)&statb);
      if (iVar4 != -1) {
        uVar3 = (uint)(dir->alias_mtime != statb.st_mtim.tv_sec);
        goto LAB_0010ba57;
      }
      piVar6 = __errno_location();
      if (*piVar6 == 2) {
        uVar3 = (uint)(dir->alias_mtime != 0);
        goto LAB_0010ba57;
      }
    }
    uVar3 = 1;
  }
  else {
LAB_0010ba55:
    uVar3 = 0;
  }
LAB_0010ba57:
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



FontFilePtr FontFileOpen(char *name)

{
  char *pcVar1;
  int fd;
  uint uVar2;
  BufFilePtr f;
  size_t sVar3;
  BufFilePtr p_Var4;
  long lVar5;
  byte *pbVar6;
  byte *pbVar7;
  bool bVar8;
  bool bVar9;
  byte bVar10;
  
  bVar10 = 0;
  fd = open(name,0);
  p_Var4 = (BufFilePtr)0x0;
  if (-1 < fd) {
    f = BufFileOpenRead(fd);
    p_Var4 = f;
    if (f == (BufFilePtr)0x0) {
      close(fd);
    }
    else {
      sVar3 = strlen(name);
      uVar2 = (uint)sVar3;
      if (2 < (int)uVar2) {
        pcVar1 = name + (long)(int)uVar2 + -2;
        if (((*pcVar1 == '.') && (pcVar1[1] == 'Z')) && (pcVar1[2] == '\0')) {
          p_Var4 = BufFilePushCompressed(f);
        }
        else {
          bVar8 = uVar2 < 3;
          bVar9 = uVar2 == 3;
          if (bVar9) {
            return f;
          }
          lVar5 = 4;
          pbVar6 = (byte *)(name + (long)(int)uVar2 + -3);
          pbVar7 = &DAT_00133211;
          do {
            if (lVar5 == 0) break;
            lVar5 = lVar5 + -1;
            bVar8 = *pbVar6 < *pbVar7;
            bVar9 = *pbVar6 == *pbVar7;
            pbVar6 = pbVar6 + (ulong)bVar10 * -2 + 1;
            pbVar7 = pbVar7 + (ulong)bVar10 * -2 + 1;
          } while (bVar9);
          if ((!bVar8 && !bVar9) != bVar8) {
            return f;
          }
          p_Var4 = BufFilePushZIP(f);
        }
        if (p_Var4 == (BufFilePtr)0x0) {
          BufFileClose(f,1);
          p_Var4 = (BufFilePtr)0x0;
        }
      }
    }
  }
  return p_Var4;
}



int FontFileClose(FontFilePtr f)

{
  int iVar1;
  
  iVar1 = BufFileClose(f,1);
  return iVar1;
}



FontFilePtr FontFileOpenWrite(char *name)

{
  int fd;
  BufFilePtr p_Var1;
  
  fd = creat(name,0x1b6);
  if (-1 < fd) {
    p_Var1 = BufFileOpenWrite(fd);
    return p_Var1;
  }
  return (FontFilePtr)0x0;
}



FontFilePtr FontFileOpenWriteFd(int fd)

{
  BufFilePtr p_Var1;
  
  p_Var1 = BufFileOpenWrite(fd);
  return p_Var1;
}



FontFilePtr FontFileOpenFd(int fd)

{
  BufFilePtr p_Var1;
  
  p_Var1 = BufFileOpenRead(fd);
  return p_Var1;
}



int strcmpn(char *s1,char *s2)

{
  byte *pbVar1;
  byte bVar2;
  byte bVar3;
  bool bVar4;
  long lVar5;
  
  bVar4 = false;
  while( true ) {
    bVar2 = *s1;
    bVar3 = *s2;
    if (bVar2 == 0) {
      return -(uint)(bVar3 != 0);
    }
    if (((byte)(bVar2 - 0x30) < 10) && ((byte)(bVar3 - 0x30) < 10)) {
      if (!bVar4) {
        lVar5 = 1;
        while (pbVar1 = (byte *)s2 + lVar5, (byte)(((byte *)s1)[lVar5] - 0x30) < 10) {
          lVar5 = lVar5 + 1;
          if (9 < (byte)(*pbVar1 - 0x30)) {
            return 1;
          }
        }
        if ((byte)(*pbVar1 - 0x30) < 10) {
          return -1;
        }
        bVar4 = true;
      }
    }
    else {
      bVar4 = false;
    }
    if (bVar2 < bVar3) {
      return -1;
    }
    if (bVar3 < bVar2) break;
    s1 = (char *)((byte *)s1 + 1);
    s2 = (char *)((byte *)s2 + 1);
  }
  return 1;
}



int FontFileNameCompare(void *a,void *b)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  iVar1 = strcmpn(*a,*b);
  return iVar1;
}



// DWARF original prototype: int SetupWildMatch(FontTablePtr table, FontNamePtr pat, int * leftp,
// int * rightp, int * privatep, FontNamePtr pat)

int SetupWildMatch(FontTablePtr table,FontNamePtr pat,int *leftp,int *rightp,int *privatep,
                  FontNamePtr pat_1)

{
  char cVar1;
  char **ppcVar2;
  int iVar3;
  int iVar4;
  char *name;
  FontNamePtr p_Var5;
  int iVar6;
  FontNamePtr p_Var7;
  int iVar8;
  FontNamePtr p_Var9;
  ulong uVar10;
  FontNamePtr p_Var11;
  int iVar12;
  
  cVar1 = *(char *)&pat->name;
  iVar6 = table->used;
  if (cVar1 != '\0') {
    ppcVar2 = &pat->name;
    p_Var11 = (FontNamePtr)0x0;
    p_Var9 = (FontNamePtr)0x0;
    p_Var7 = pat;
    do {
      p_Var5 = (FontNamePtr)((long)ppcVar2 + 1);
      if ((cVar1 == '*' || cVar1 == '?') && (p_Var9 == (FontNamePtr)0x0)) {
        p_Var9 = p_Var7;
      }
      if (((byte)(cVar1 - 0x30U) < 10) && (p_Var11 == (FontNamePtr)0x0)) {
        p_Var11 = p_Var7;
      }
      cVar1 = *(char *)&p_Var5->name;
      ppcVar2 = &p_Var5->name;
      p_Var7 = p_Var5;
    } while (cVar1 != '\0');
    if (p_Var9 != (FontNamePtr)0x0) {
      *(int *)&pat_1->name = (int)(short)leftp;
      if (table->sorted != 0) {
        if ((p_Var11 == (FontNamePtr)0x0) || (p_Var9 <= p_Var11)) {
          iVar8 = (int)p_Var9 - (int)pat;
        }
        else {
          iVar8 = (int)p_Var11 - (int)pat;
        }
        iVar3 = 0;
        while (iVar12 = iVar6, iVar3 < iVar12) {
          iVar6 = iVar12 + iVar3 >> 1;
          iVar4 = strncmp((char *)pat,table->entries[iVar6].name.name,(long)iVar8);
          if (iVar4 == 0) break;
          if (-1 < iVar4) {
            iVar3 = iVar6 + 1;
            iVar6 = iVar12;
          }
        }
        *rightp = iVar3;
        *privatep = iVar12;
        return -1;
      }
      goto LAB_0010be0d;
    }
  }
  *(undefined4 *)&pat_1->name = 0xffffffff;
  if (table->sorted != 0) {
    uVar10 = 0;
    while( true ) {
      iVar8 = iVar6;
      if (iVar8 <= (int)uVar10) {
        *rightp = 1;
        *privatep = 0;
        return -1;
      }
      iVar6 = iVar8 + (int)uVar10 >> 1;
      iVar3 = strcmpn((char *)pat,table->entries[iVar6].name.name);
      if (iVar3 == 0) break;
      if (-1 < iVar3) {
        uVar10 = (ulong)(iVar6 + 1);
        iVar6 = iVar8;
      }
    }
    return iVar6;
  }
LAB_0010be0d:
  *rightp = 0;
  *privatep = iVar6;
  return -1;
}



int PatternMatch(char *pat,int patdashes,char *string,int stringdashes)

{
  char cVar1;
  char cVar2;
  int iVar3;
  int iVar4;
  char *pcVar5;
  bool bVar6;
  
  pcVar5 = pat + 1;
  cVar2 = *pat;
  cVar1 = cVar2 + -0x2d;
  bVar6 = cVar2 == '-';
  if (bVar6) goto LAB_0010c01b;
  do {
    if (bVar6 || SBORROW1(cVar2,'-') != cVar1 < '\0') {
      if (cVar2 == '\0') {
        return (int)(*string == '\0');
      }
      if (cVar2 == '*') {
        cVar2 = *pcVar5;
        if (cVar2 == '\0') {
          return 1;
        }
        if (cVar2 == '-') {
          while( true ) {
            do {
              while( true ) {
                iVar3 = stringdashes;
                cVar2 = *string;
                string = string + 1;
                if (cVar2 == '-') break;
                stringdashes = iVar3;
                if (cVar2 == '\0') {
                  return 0;
                }
              }
              stringdashes = iVar3 + -1;
            } while (iVar3 < patdashes);
            iVar4 = PatternMatch(pat + 2,patdashes + -1,string,stringdashes);
            if (iVar4 != 0) break;
            if (iVar3 == patdashes) {
              return 0;
            }
          }
        }
        else {
LAB_0010bf90:
          do {
            cVar1 = *string;
            while (string = string + 1, cVar2 != cVar1) {
              if (cVar1 == '\0') {
                return 0;
              }
              if (cVar1 != '-') goto LAB_0010bf90;
              if (stringdashes < patdashes) {
                return 0;
              }
              stringdashes = stringdashes + -1;
              cVar1 = *string;
            }
          } while ((stringdashes < patdashes) ||
                  (iVar3 = PatternMatch(pat + 2,patdashes,string,stringdashes), iVar3 == 0));
        }
        return 1;
      }
LAB_0010c0a0:
      if (cVar2 != *string) {
        return 0;
      }
      string = string + 1;
      pat = pcVar5;
    }
    else {
      if (cVar2 != '?') goto LAB_0010c0a0;
      cVar2 = *string;
      string = string + 1;
      stringdashes = stringdashes - (uint)(cVar2 == '-');
      pat = pcVar5;
    }
    while( true ) {
      cVar2 = *pat;
      pcVar5 = pat + 1;
      cVar1 = cVar2 + -0x2d;
      bVar6 = cVar1 == '\0';
      if (!bVar6) break;
LAB_0010c01b:
      if (*string != '-') {
        return 0;
      }
      patdashes = patdashes + -1;
      stringdashes = stringdashes + -1;
      string = string + 1;
      pat = pcVar5;
    }
  } while( true );
}



Bool FontFileInitTable(FontTablePtr table,int size)

{
  FontEntryPtr_conflict p_Var1;
  
  if (0xd79435 < (uint)size) {
    return 0;
  }
  if (size == 0) {
    table->entries = (FontEntryPtr_conflict)0x0;
  }
  else {
    p_Var1 = (FontEntryPtr_conflict)malloc((long)size * 0x98);
    table->entries = p_Var1;
    if (p_Var1 == (FontEntryPtr_conflict)0x0) {
      return 0;
    }
  }
  table->used = 0;
  table->size = size;
  table->sorted = 0;
  return 1;
}



void FontFileFreeEntry(FontEntryPtr entry)

{
  char *__ptr;
  FontScalableExtraPtr __ptr_00;
  void *__ptr_01;
  int iVar1;
  long lVar2;
  FontScaledPtr __ptr_02;
  
  __ptr = (entry->name).name;
  if (__ptr != (char *)0x0) {
    free(__ptr);
  }
  iVar1 = entry->type;
  (entry->name).name = (char *)0x0;
  if (iVar1 == 2) {
    free((entry->u).scalable.fileName);
    (entry->u).scalable.fileName = (char *)0x0;
    return;
  }
  if (iVar1 == 3) {
    free((entry->u).scalable.renderer);
    (entry->u).scalable.renderer = (FontRendererPtr)0x0;
    return;
  }
  if (iVar1 != 0) {
    return;
  }
  free((entry->u).scalable.fileName);
  __ptr_00 = (entry->u).scalable.extra;
  __ptr_02 = __ptr_00->scaled;
  if (0 < __ptr_00->numScaled) {
    lVar2 = 0;
    iVar1 = 0;
    do {
      __ptr_01 = *(void **)((long)(__ptr_02->vals).point_matrix + lVar2 + 0x48);
      if (__ptr_01 != (void *)0x0) {
        free(__ptr_01);
        __ptr_02 = __ptr_00->scaled;
      }
      iVar1 = iVar1 + 1;
      lVar2 = lVar2 + 0x88;
    } while (iVar1 < __ptr_00->numScaled);
  }
  free(__ptr_02);
  free(__ptr_00);
  return;
}



void FontFileFreeTable(FontTablePtr table)

{
  long lVar1;
  long lVar2;
  
  if (0 < table->used) {
    lVar1 = 0;
    do {
      lVar2 = lVar1 + 1;
      FontFileFreeEntry(table->entries + lVar1);
      lVar1 = lVar2;
    } while ((int)lVar2 < table->used);
  }
  free(table->entries);
  return;
}



FontDirectoryPtr FontFileMakeDir(char *dirName,int size)

{
  Bool BVar1;
  char *pcVar2;
  size_t sVar3;
  FontDirectoryPtr __ptr;
  char *pcVar4;
  size_t sVar5;
  size_t sVar6;
  FontDirectoryPtr p_Var7;
  bool bVar8;
  int local_40;
  
  pcVar2 = strchr(dirName,0x3a);
  if (pcVar2 == (char *)0x0) {
    sVar5 = strlen(dirName);
    sVar5 = (size_t)(int)sVar5;
    if (dirName[sVar5 - 1] == '/') {
      local_40 = 0;
      bVar8 = false;
      sVar3 = sVar5;
      sVar6 = sVar5;
    }
    else {
      local_40 = 0;
      bVar8 = true;
      sVar3 = sVar5 + 1;
      sVar6 = sVar5 + 1;
    }
  }
  else {
    sVar3 = strlen(pcVar2);
    sVar5 = (size_t)((int)pcVar2 - (int)dirName);
    local_40 = (int)sVar3;
    bVar8 = dirName[sVar5 - 1] != '/';
    sVar6 = bVar8 + sVar5;
    sVar3 = sVar6;
    if (local_40 != 0) {
      sVar3 = (long)(local_40 + 1) + sVar6;
    }
  }
  __ptr = (FontDirectoryPtr)malloc(sVar3 + 0x51);
  p_Var7 = __ptr;
  if (__ptr != (FontDirectoryPtr)0x0) {
    BVar1 = FontFileInitTable(&__ptr->scalable,0);
    if (BVar1 != 0) {
      BVar1 = FontFileInitTable(&__ptr->nonScalable,size);
      if (BVar1 != 0) {
        __ptr->dir_mtime = 0;
        pcVar4 = (char *)((long)&__ptr[1].directory + sVar6 + 1);
        __ptr->directory = (char *)(__ptr + 1);
        __ptr->alias_mtime = 0;
        if (local_40 == 0) {
          pcVar4 = (char *)0x0;
        }
        __ptr->attributes = pcVar4;
        pcVar4 = strncpy((char *)(__ptr + 1),dirName,sVar5);
        pcVar4[sVar5] = '\0';
        if (__ptr->attributes != (char *)0x0) {
          strcpy(__ptr->attributes,pcVar2);
        }
        if (!bVar8) {
          return __ptr;
        }
        pcVar2 = __ptr->directory;
        sVar5 = strlen(pcVar2);
        pcVar2 = pcVar2 + sVar5;
        pcVar2[0] = '/';
        pcVar2[1] = '\0';
        return __ptr;
      }
      FontFileFreeTable(&__ptr->scalable);
    }
    p_Var7 = (FontDirectoryPtr)0x0;
    free(__ptr);
  }
  return p_Var7;
}



void FontFileFreeDir(FontDirectoryPtr dir)

{
  FontFileFreeTable(&dir->scalable);
  FontFileFreeTable(&dir->nonScalable);
  free(dir);
  return;
}



FontEntryPtr FontFileAddEntry(FontTablePtr table,FontEntryPtr prototype)

{
  FontEntryPtr p_Var1;
  int iVar2;
  FontRendererPtr p_Var3;
  FontScalableExtraPtr p_Var4;
  undefined8 uVar5;
  short sVar6;
  short sVar7;
  undefined4 uVar8;
  char *__dest;
  FontEntryPtr_conflict __ptr;
  
  if (table->sorted == 0) {
    iVar2 = table->used;
    __ptr = table->entries;
    if (iVar2 == table->size) {
      __ptr = (FontEntryPtr_conflict)realloc(__ptr,(long)(iVar2 + 100) * 0x98);
      if (__ptr == (FontEntryPtr_conflict)0x0) {
        return (FontEntryPtr)0x0;
      }
      table->size = iVar2 + 100;
      iVar2 = table->used;
      table->entries = __ptr;
    }
    sVar6 = (prototype->name).length;
    sVar7 = (prototype->name).ndashes;
    uVar8 = *(undefined4 *)&(prototype->name).field_0xc;
    p_Var1 = __ptr + iVar2;
    (p_Var1->name).name = (prototype->name).name;
    (p_Var1->name).length = sVar6;
    (p_Var1->name).ndashes = sVar7;
    *(undefined4 *)&(p_Var1->name).field_0xc = uVar8;
    uVar8 = *(undefined4 *)&prototype->field_0x14;
    p_Var3 = (prototype->u).scalable.renderer;
    p_Var1->type = prototype->type;
    *(undefined4 *)&p_Var1->field_0x14 = uVar8;
    (p_Var1->u).scalable.renderer = p_Var3;
    p_Var4 = (prototype->u).scalable.extra;
    (p_Var1->u).scalable.fileName = (prototype->u).scalable.fileName;
    (p_Var1->u).scalable.extra = p_Var4;
    uVar5 = *(undefined8 *)((long)&prototype->u + 0x20);
    *(undefined8 *)((long)&p_Var1->u + 0x18) = *(undefined8 *)((long)&prototype->u + 0x18);
    *(undefined8 *)((long)&p_Var1->u + 0x20) = uVar5;
    uVar5 = *(undefined8 *)((long)&prototype->u + 0x30);
    *(undefined8 *)((long)&p_Var1->u + 0x28) = *(undefined8 *)((long)&prototype->u + 0x28);
    *(undefined8 *)((long)&p_Var1->u + 0x30) = uVar5;
    uVar5 = *(undefined8 *)((long)&prototype->u + 0x40);
    *(undefined8 *)((long)&p_Var1->u + 0x38) = *(undefined8 *)((long)&prototype->u + 0x38);
    *(undefined8 *)((long)&p_Var1->u + 0x40) = uVar5;
    uVar5 = *(undefined8 *)((long)&prototype->u + 0x50);
    *(undefined8 *)((long)&p_Var1->u + 0x48) = *(undefined8 *)((long)&prototype->u + 0x48);
    *(undefined8 *)((long)&p_Var1->u + 0x50) = uVar5;
    uVar5 = *(undefined8 *)((long)&prototype->u + 0x60);
    *(undefined8 *)((long)&p_Var1->u + 0x58) = *(undefined8 *)((long)&prototype->u + 0x58);
    *(undefined8 *)((long)&p_Var1->u + 0x60) = uVar5;
    uVar5 = *(undefined8 *)((long)&prototype->u + 0x70);
    *(undefined8 *)((long)&p_Var1->u + 0x68) = *(undefined8 *)((long)&prototype->u + 0x68);
    *(undefined8 *)((long)&p_Var1->u + 0x70) = uVar5;
    (p_Var1->u).bc.entry = (prototype->u).bc.entry;
    __dest = (char *)malloc((long)((prototype->name).length + 1));
    (p_Var1->name).name = __dest;
    if (__dest != (char *)0x0) {
      memcpy(__dest,(prototype->name).name,(long)(prototype->name).length);
      (p_Var1->name).name[(p_Var1->name).length] = '\0';
      table->used = table->used + 1;
      return p_Var1;
    }
  }
  return (FontEntryPtr)0x0;
}



void FontFileSortTable(FontTablePtr table)

{
  if (table->sorted != 0) {
    return;
  }
  qsort(table->entries,(long)table->used,0x98,FontFileNameCompare);
  table->sorted = 1;
  return;
}



void FontFileSortDir(FontDirectoryPtr dir)

{
  FontFileSortTable(&dir->scalable);
  FontFileSortTable(&dir->nonScalable);
  FontFileSwitchStringsToBitmapPointers(dir);
  return;
}



int FontFileCountDashes(char *name,int namelen)

{
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  
  if (namelen != 0) {
    iVar1 = 0;
    pcVar3 = name;
    do {
      pcVar2 = pcVar3 + 1;
      iVar1 = iVar1 + (uint)(*pcVar3 == '-');
      pcVar3 = pcVar2;
    } while (name + (ulong)(namelen - 1) + 1 != pcVar2);
    return iVar1;
  }
  return 0;
}



char * FontFileSaveString(char *s)

{
  char *pcVar1;
  
  pcVar1 = strdup(s);
  return pcVar1;
}



FontEntryPtr FontFileFindNameInScalableDir(FontTablePtr table,FontNamePtr pat,FontScalablePtr vals)

{
  uint uVar1;
  FontEntryPtr_conflict p_Var2;
  int iVar3;
  uint uVar4;
  FontEntryPtr p_Var5;
  ulong uVar6;
  FontEntryPtr p_Var7;
  char *pat_00;
  long in_FS_OFFSET;
  int start;
  int stop;
  int private;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (table->entries != (FontEntryPtr_conflict)0x0) {
    iVar3 = SetupWildMatch(table,(FontNamePtr)pat->name,(int *)(ulong)(ushort)pat->ndashes,&start,
                           &stop,(FontNamePtr)&private);
    if (-1 < iVar3) {
      p_Var7 = table->entries + iVar3;
      goto LAB_0010c727;
    }
    if (start < stop) {
      p_Var2 = table->entries;
      uVar6 = (ulong)(uint)private;
      pat_00 = pat->name;
      p_Var5 = p_Var2 + start;
      do {
        iVar3 = (int)(p_Var5->name).ndashes;
        if ((int)uVar6 <= iVar3) {
          p_Var7 = p_Var5;
          iVar3 = PatternMatch(pat_00,(int)uVar6,(p_Var5->name).name,iVar3);
          if (0 < iVar3) {
            if (vals == (FontScalablePtr)0x0) goto LAB_0010c727;
            uVar1 = vals->values_supplied;
            if (p_Var5->type == 0) {
              uVar4 = ((p_Var5->u).scalable.renderer)->capabilities;
            }
            else {
              uVar4 = -(uint)(p_Var5->type == 3);
            }
            if (((((uVar1 & 3) != 2) && ((uVar1 & 0xc) != 8)) || ((uVar4 & 1) != 0)) &&
               (((uVar1 & 0x40) == 0 || ((uVar4 & 2) != 0)))) goto LAB_0010c727;
          }
        }
        p_Var5 = p_Var5 + 1;
      } while (p_Var5 != p_Var2 + (long)start + (ulong)(uint)((stop + -1) - start) + 1);
    }
  }
  p_Var7 = (FontEntryPtr)0x0;
LAB_0010c727:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return p_Var7;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



FontEntryPtr FontFileFindNameInDir(FontTablePtr table,FontNamePtr pat)

{
  FontEntryPtr p_Var1;
  
  p_Var1 = FontFileFindNameInScalableDir(table,pat,(FontScalablePtr)0x0);
  return p_Var1;
}



int FontFileFindNamesInScalableDir
              (FontTablePtr table,FontNamePtr pat,int max,FontNamesPtr names,FontScalablePtr vals,
              int alias_behavior,int *newmax)

{
  long lVar1;
  FontRendererPtr __s;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  Bool BVar6;
  ulong uVar7;
  size_t sVar8;
  char *string;
  FontEntryPtr_conflict p_Var9;
  long in_FS_OFFSET;
  int start;
  int stop;
  int private;
  FontScalableRec tmpvals;
  
  iVar3 = 0x55;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (0 < max) {
    uVar2 = SetupWildMatch(table,(FontNamePtr)pat->name,(int *)(ulong)(ushort)pat->ndashes,&start,
                           &stop,(FontNamePtr)&private);
    uVar7 = (ulong)uVar2;
    if ((int)uVar2 < 0) {
      uVar7 = (ulong)start;
      p_Var9 = table->entries + uVar7;
    }
    else {
      p_Var9 = table->entries + (int)uVar2;
      if ((alias_behavior == 0) || (p_Var9->type != 3)) {
        if (newmax != (int *)0x0) {
          *newmax = max + -1;
        }
        iVar3 = AddFontNamesName(names,(p_Var9->name).name,(int)(p_Var9->name).length);
        goto LAB_0010c86b;
      }
      stop = uVar2 + 1;
      start = uVar2;
    }
    if ((int)uVar7 < stop) {
      do {
        iVar3 = (int)(p_Var9->name).ndashes;
        if (private <= iVar3) {
          string = (p_Var9->name).name;
          iVar3 = PatternMatch(pat->name,private,string,iVar3);
          if (0 < iVar3) {
            if (vals != (FontScalablePtr)0x0) {
              uVar2 = vals->values_supplied;
              if (p_Var9->type == 0) {
                uVar5 = ((p_Var9->u).scalable.renderer)->capabilities;
                if ((uVar2 & 3) != 2) goto LAB_0010c8ed;
LAB_0010c9aa:
                if ((uVar5 & 1) == 0) goto LAB_0010c94a;
              }
              else {
                uVar5 = -(uint)(p_Var9->type == 3);
                if ((uVar2 & 3) == 2) goto LAB_0010c9aa;
LAB_0010c8ed:
                if ((uVar2 & 0xc) == 8) goto LAB_0010c9aa;
              }
              if (((uVar2 & 0x40) != 0) && ((uVar5 & 2) == 0)) goto LAB_0010c94a;
            }
            if (((alias_behavior & 2U) != 0) && (p_Var9->type == 3)) {
              BVar6 = FontParseXLFDName(string,&tmpvals,0);
              if ((BVar6 != 0) && (((byte)tmpvals.values_supplied & 0xf) == 0)) goto LAB_0010c94a;
              string = (p_Var9->name).name;
            }
            iVar4 = AddFontNamesName(names,string,(int)(p_Var9->name).length);
            iVar3 = iVar4;
            if (iVar4 != 0x55) goto LAB_0010c9be;
            if (((alias_behavior & 1U) != 0) && (p_Var9->type == 3)) {
              names->length[(long)names->nnames + -1] = -names->length[(long)names->nnames + -1];
              __s = (p_Var9->u).scalable.renderer;
              sVar8 = strlen((char *)__s);
              iVar3 = AddFontNamesName(names,(char *)__s,(int)sVar8);
              if (iVar3 != 0x55) goto LAB_0010c9be;
            }
            max = max + -1;
            iVar3 = iVar4;
            if (max == 0) goto LAB_0010c9be;
          }
        }
LAB_0010c94a:
        uVar2 = (int)uVar7 + 1;
        uVar7 = (ulong)uVar2;
        p_Var9 = p_Var9 + 1;
      } while ((int)uVar2 < stop);
    }
    iVar3 = 0x55;
LAB_0010c9be:
    if (newmax != (int *)0x0) {
      *newmax = max;
    }
  }
LAB_0010c86b:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar3;
}



int FontFileFindNamesInDir(FontTablePtr table,FontNamePtr pat,int max,FontNamesPtr names)

{
  int iVar1;
  
  iVar1 = FontFileFindNamesInScalableDir(table,pat,max,names,(FontScalablePtr)0x0,0,(int *)0x0);
  return iVar1;
}



Bool FontFileMatchName(char *name,int length,FontNamePtr pat)

{
  long lVar1;
  int iVar2;
  FontEntryPtr p_Var3;
  long in_FS_OFFSET;
  FontTableRec table;
  FontEntryRec entries [1];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  table.used = 1;
  table.size = 1;
  table.entries = entries;
  entries[0].name.length = (short)length;
  table.sorted = 1;
  entries[0].name.name = name;
  iVar2 = FontFileCountDashes(name,length);
  entries[0].name.ndashes = (short)iVar2;
  p_Var3 = FontFileFindNameInDir(&table,pat);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return (Bool)(p_Var3 != (FontEntryPtr)0x0);
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Bool FontFileAddFontFile(FontDirectoryPtr dir,char *fontName,char *fileName)

{
  long lVar1;
  bool bVar2;
  Bool BVar3;
  FontRendererPtr p_Var4;
  size_t sVar5;
  FontEntryPtr p_Var6;
  FontEntryPtr p_Var7;
  FontScalableExtraPtr p_Var8;
  FontResolutionPtr p_Var9;
  char *pcVar10;
  char *pcVar11;
  long lVar12;
  int iVar13;
  uint uVar14;
  FontScalablePtr p_Var15;
  FontScalableExtraPtr p_Var16;
  byte *pbVar17;
  byte *__s;
  long in_FS_OFFSET;
  bool bVar18;
  bool bVar19;
  byte bVar20;
  double dVar21;
  int num;
  FontScalableRec vals;
  FontScalableRec zeroVals;
  FontEntryRec entry;
  
  bVar20 = 0;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  p_Var4 = FontFileMatchRenderer(fileName);
  if (p_Var4 != (FontRendererPtr)0x0) {
    sVar5 = strlen(fontName);
    entry.name.length = (short)sVar5;
    if (entry.name.length < 0x401) {
      iVar13 = (int)entry.name.length;
    }
    else {
      iVar13 = 0x400;
      entry.name.length = 0x400;
    }
    entry.name.name = fontName;
    CopyISOLatin1Lowered(fontName,fontName,iVar13);
    iVar13 = FontFileCountDashes(entry.name.name,(int)entry.name.length);
    entry.name.ndashes = (short)iVar13;
    entry.name.name[entry.name.length] = '\0';
    if ((((entry.name.ndashes == 0xe) &&
         (BVar3 = FontParseXLFDName(entry.name.name,&vals,0), iVar13 = vals.values_supplied,
         BVar3 != 0)) && ((vals.values_supplied & 3U) != 2)) &&
       (((vals.values_supplied & 0xcU) != 8 && ((vals.values_supplied & 0x40U) == 0)))) {
      if ((((vals.values_supplied & 3U) != 0) &&
          (((vals.values_supplied & 0xcU) != 0 &&
           (pcVar11 = dir->attributes, pcVar11 != (char *)0x0)))) && (*pcVar11 == ':')) {
        bVar2 = true;
        pcVar10 = pcVar11;
        while( true ) {
          __s = (byte *)(pcVar10 + 1);
          pcVar10 = strchr((char *)__s,0x3a);
          if (pcVar10 == (char *)0x0) break;
          uVar14 = (int)pcVar10 - (int)__s;
          bVar18 = uVar14 < 8;
          bVar19 = uVar14 == 8;
          if (bVar19) {
            lVar12 = 8;
            pbVar17 = (byte *)"unscaled";
            do {
              if (lVar12 == 0) break;
              lVar12 = lVar12 + -1;
              bVar18 = *__s < *pbVar17;
              bVar19 = *__s == *pbVar17;
              __s = __s + (ulong)bVar20 * -2 + 1;
              pbVar17 = pbVar17 + (ulong)bVar20 * -2 + 1;
            } while (bVar19);
            if ((!bVar18 && !bVar19) == bVar18) {
              bVar2 = false;
            }
          }
        }
        sVar5 = strlen(pcVar11);
        uVar14 = ((int)pcVar11 + (int)sVar5) - (int)__s;
        bVar18 = uVar14 < 8;
        bVar19 = uVar14 == 8;
        if (bVar19) {
          lVar12 = 8;
          pbVar17 = (byte *)"unscaled";
          do {
            if (lVar12 == 0) break;
            lVar12 = lVar12 + -1;
            bVar18 = *__s < *pbVar17;
            bVar19 = *__s == *pbVar17;
            __s = __s + (ulong)bVar20 * -2 + 1;
            pbVar17 = pbVar17 + (ulong)bVar20 * -2 + 1;
          } while (bVar19);
          if ((!bVar18 && !bVar19) == bVar18) goto LAB_0010cbd6;
        }
        if (!bVar2) goto LAB_0010cbd6;
      }
      if ((iVar13 & 0xfU) != 0) {
        BVar3 = 1;
        goto LAB_0010cbd9;
      }
      p_Var6 = (FontEntryPtr)0x0;
LAB_0010cd53:
      pcVar11 = strdup(fileName);
      entry.u.scalable.fileName = pcVar11;
      if (pcVar11 != (char *)0x0) {
        p_Var8 = (FontScalableExtraPtr)malloc(0x90);
        if (p_Var8 == (FontScalableExtraPtr)0x0) {
          BVar3 = 0;
          free(pcVar11);
          goto LAB_0010cc38;
        }
        p_Var16 = p_Var8;
        for (lVar12 = 0xf; lVar12 != 0; lVar12 = lVar12 + -1) {
          *(undefined8 *)&p_Var16->defaults = 0;
          p_Var16 = (FontScalableExtraPtr)((long)p_Var16 + (ulong)bVar20 * -0x10 + 8);
        }
        if (((vals.values_supplied & 0xcU) == 4) &&
           (dVar21 = vals.point_matrix[3] * 10.0, iVar13 = GetDefaultPointSize(),
           (int)dVar21 == iVar13)) {
          *(ulong *)&p_Var8->defaults = CONCAT44(vals._4_4_,vals.values_supplied);
          (p_Var8->defaults).pixel_matrix[0] = vals.pixel_matrix[0];
          (p_Var8->defaults).pixel_matrix[1] = vals.pixel_matrix[1];
          (p_Var8->defaults).pixel_matrix[2] = vals.pixel_matrix[2];
          (p_Var8->defaults).pixel_matrix[3] = vals.pixel_matrix[3];
          (p_Var8->defaults).point_matrix[0] = vals.point_matrix[0];
          (p_Var8->defaults).ranges = vals.ranges;
          (p_Var8->defaults).point_matrix[1] = vals.point_matrix[1];
          (p_Var8->defaults).point_matrix[2] = vals.point_matrix[2];
          (p_Var8->defaults).point_matrix[3] = vals.point_matrix[3];
          *(undefined8 *)&(p_Var8->defaults).pixel = vals._72_8_;
          *(ulong *)&(p_Var8->defaults).x = CONCAT44(vals.y,vals.x);
          *(undefined8 *)&(p_Var8->defaults).width = vals._88_8_;
          (p_Var8->defaults).xlfdName = vals.xlfdName;
          *(undefined8 *)&(p_Var8->defaults).nranges = vals._104_8_;
        }
        else {
          iVar13 = GetDefaultPointSize();
          (p_Var8->defaults).point_matrix[2] = 0.0;
          (p_Var8->defaults).point_matrix[1] = 0.0;
          (p_Var8->defaults).values_supplied = 4;
          (p_Var8->defaults).width = -1;
          (p_Var8->defaults).point_matrix[3] = (double)iVar13 / 10.0;
          (p_Var8->defaults).point_matrix[0] = (double)iVar13 / 10.0;
          if ((vals.x < 1) || (vals.y < 1)) {
            p_Var9 = GetClientResolutions(&num);
            if ((p_Var9 == (FontResolutionPtr)0x0) || (num < 1)) {
              *(undefined8 *)&(p_Var8->defaults).x = 0x4b0000004b;
            }
            else {
              (p_Var8->defaults).x = (uint)p_Var9->x_resolution;
              (p_Var8->defaults).y = (uint)p_Var9->y_resolution;
            }
          }
          else {
            (p_Var8->defaults).x = vals.x;
            (p_Var8->defaults).y = vals.y;
          }
          FontFileCompleteXLFD((FontScalablePtr)p_Var8,(FontScalablePtr)p_Var8);
        }
        p_Var8->numScaled = 0;
        p_Var8->sizeScaled = 0;
        p_Var8->scaled = (FontScaledPtr)0x0;
        p_Var8->private = (pointer)0x0;
        entry.type = 0;
        entry.u.scalable.renderer = p_Var4;
        entry.u.scalable.extra = p_Var8;
        p_Var7 = FontFileAddEntry(&dir->scalable,&entry);
        if (p_Var7 == (FontEntryPtr)0x0) {
          free(p_Var8);
          goto LAB_0010cc88;
        }
        if (((vals.values_supplied & 0xfU) != 0) && (p_Var6 != (FontEntryPtr)0x0)) {
          FontFileCompleteXLFD(&vals,&vals);
          FontFileAddScaledInstance(p_Var7,&vals,(FontPtr)0x0,(p_Var6->name).name);
        }
LAB_0010cc32:
        BVar3 = 1;
        goto LAB_0010cc38;
      }
    }
    else {
LAB_0010cbd6:
      BVar3 = 0;
LAB_0010cbd9:
      entry.type = 2;
      entry.u.scalable.extra = (FontScalableExtraPtr)0x0;
      entry.u.scalable.renderer = p_Var4;
      entry.u.scalable.fileName = strdup(fileName);
      if (entry.u.scalable.fileName != (char *)0x0) {
        p_Var6 = FontFileAddEntry(&dir->nonScalable,&entry);
        if (p_Var6 != (FontEntryPtr)0x0) {
          if (BVar3 != 0) {
            if ((vals.values_supplied & 0xfU) != 0) {
              p_Var15 = &zeroVals;
              for (lVar12 = 0xf; lVar12 != 0; lVar12 = lVar12 + -1) {
                *(undefined8 *)p_Var15 = 0;
                p_Var15 = (FontScalablePtr)((long)p_Var15 + (ulong)bVar20 * -0x10 + 8);
              }
              zeroVals.values_supplied = 5;
              FontParseXLFDName(entry.name.name,&zeroVals,3);
              sVar5 = strlen(entry.name.name);
              entry.name.length = (short)sVar5;
              p_Var7 = FontFileFindNameInDir(&dir->scalable,&entry.name);
              if (p_Var7 != (FontEntryPtr)0x0) {
                if (((vals.values_supplied & 0xcU) == 4) &&
                   (dVar21 = vals.point_matrix[3] * 10.0, iVar13 = GetDefaultPointSize(),
                   (int)dVar21 == iVar13)) {
                  p_Var8 = (p_Var7->u).scalable.extra;
                  *(ulong *)&p_Var8->defaults = CONCAT44(vals._4_4_,vals.values_supplied);
                  (p_Var8->defaults).pixel_matrix[0] = vals.pixel_matrix[0];
                  (p_Var8->defaults).pixel_matrix[1] = vals.pixel_matrix[1];
                  (p_Var8->defaults).pixel_matrix[2] = vals.pixel_matrix[2];
                  (p_Var8->defaults).pixel_matrix[3] = vals.pixel_matrix[3];
                  (p_Var8->defaults).point_matrix[0] = vals.point_matrix[0];
                  (p_Var8->defaults).point_matrix[1] = vals.point_matrix[1];
                  (p_Var8->defaults).point_matrix[2] = vals.point_matrix[2];
                  (p_Var8->defaults).point_matrix[3] = vals.point_matrix[3];
                  (p_Var8->defaults).pixel = vals.pixel;
                  (p_Var8->defaults).point = vals.point;
                  (p_Var8->defaults).x = (int)CONCAT44(vals.y,vals.x);
                  (p_Var8->defaults).y = (int)(CONCAT44(vals.y,vals.x) >> 0x20);
                  (p_Var8->defaults).width = vals.width;
                  *(undefined4 *)&(p_Var8->defaults).field_0x5c = vals._92_4_;
                  (p_Var8->defaults).xlfdName = vals.xlfdName;
                  (p_Var8->defaults).nranges = vals.nranges;
                  *(undefined4 *)&(p_Var8->defaults).field_0x6c = vals._108_4_;
                  (p_Var8->defaults).ranges = vals.ranges;
                  free((p_Var7->u).scalable.fileName);
                  pcVar11 = strdup(fileName);
                  (p_Var7->u).scalable.fileName = pcVar11;
                  if (pcVar11 == (char *)0x0) goto LAB_0010cc95;
                }
                FontFileCompleteXLFD(&vals,&vals);
                FontFileAddScaledInstance(p_Var7,&vals,(FontPtr)0x0,(p_Var6->name).name);
                goto LAB_0010cc38;
              }
            }
            goto LAB_0010cd53;
          }
          goto LAB_0010cc32;
        }
LAB_0010cc88:
        free(entry.u.scalable.fileName);
      }
    }
  }
LAB_0010cc95:
  BVar3 = 0;
LAB_0010cc38:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar3;
}



Bool FontFileAddFontAlias(FontDirectoryPtr dir,char *aliasName,char *fontName)

{
  long lVar1;
  int iVar2;
  Bool BVar3;
  size_t sVar4;
  FontEntryPtr p_Var5;
  long in_FS_OFFSET;
  FontEntryRec entry;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar2 = strcmp(aliasName,fontName);
  if (iVar2 != 0) {
    sVar4 = strlen(aliasName);
    entry.name.length = (short)sVar4;
    CopyISOLatin1Lowered(aliasName,aliasName,(int)entry.name.length);
    entry.name.name = aliasName;
    iVar2 = FontFileCountDashes(aliasName,(int)entry.name.length);
    entry.type = 3;
    entry.name.ndashes = (short)iVar2;
    entry.u.scalable.renderer = (FontRendererPtr)strdup(fontName);
    if (entry.u.scalable.renderer != (FontRendererPtr)0x0) {
      p_Var5 = FontFileAddEntry(&dir->nonScalable,&entry);
      BVar3 = 1;
      if (p_Var5 != (FontEntryPtr)0x0) goto LAB_0010d17c;
      free(entry.u.scalable.renderer);
    }
  }
  BVar3 = 0;
LAB_0010d17c:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return BVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * font_encoding_from_xlfd(char *name,int length)

{
  char *pcVar1;
  
  pcVar1 = (char *)FontEncFromXLFD();
  return pcVar1;
}



FontEncPtr font_encoding_find(char *encoding_name,char *filename)

{
  FontEncPtr p_Var1;
  
  p_Var1 = (FontEncPtr)FontEncFind();
  return p_Var1;
}



uint font_encoding_recode(uint code,FontEncPtr encoding,FontMapPtr mapping)

{
  uint uVar1;
  undefined4 in_register_0000003c;
  
  if (mapping->encoding != encoding) {
    ErrorF("Inconsistent mapping/encoding\n");
    return 0;
  }
  uVar1 = FontEncRecode(CONCAT44(in_register_0000003c,code),mapping);
  return uVar1;
}



char * font_encoding_name(uint code,FontEncPtr encoding,FontMapPtr mapping)

{
  char *pcVar1;
  undefined4 in_register_0000003c;
  
  if (mapping->encoding == encoding) {
    pcVar1 = (char *)FontEncName(CONCAT44(in_register_0000003c,code),mapping);
    return pcVar1;
  }
  ErrorF("Inconsistent mapping/encoding\n");
  return (char *)0x0;
}



char ** identifyEncodingFile(char *filename)

{
  char **ppcVar1;
  
  ppcVar1 = (char **)FontEncIdentify();
  return ppcVar1;
}



// WARNING: Unknown calling convention

int FontFileNameCheck(char *name)

{
  return (int)(*name == '/');
}



int FontFileResetFPE(FontPathElementPtr fpe)

{
  FontDirectoryPtr dir;
  Bool BVar1;
  
  dir = (FontDirectoryPtr)fpe->private;
  BVar1 = FontFileDirectoryChanged(dir);
  if (BVar1 != 0) {
    return 0x59;
  }
  if ((0 < (dir->nonScalable).used) && (BVar1 = FontFileRegisterBitmapSource(fpe), BVar1 == 0)) {
    return 0x59;
  }
  return 0x55;
}



int FontFileFreeFPE(FontPathElementPtr fpe)

{
  FontFileUnregisterBitmapSource(fpe);
  FontFileFreeDir((FontDirectoryPtr)fpe->private);
  return 0x55;
}



int FontFileInitFPE(FontPathElementPtr fpe)

{
  int iVar1;
  Bool BVar2;
  long in_FS_OFFSET;
  FontDirectoryPtr dir;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = FontFileReadDirectory(fpe->name,&dir);
  if (iVar1 == 0x55) {
    if ((dir->nonScalable).used < 1) {
      fpe->private = dir;
    }
    else {
      BVar2 = FontFileRegisterBitmapSource(fpe);
      if (BVar2 == 0) {
        iVar1 = 0x50;
        FontFileFreeFPE(fpe);
      }
      else {
        fpe->private = dir;
      }
    }
  }
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int FontFileOpenBitmapNCF
              (FontPathElementPtr fpe,FontPtr *pFont,int flags,FontEntryPtr entry,
              fsBitmapFormat format,fsBitmapFormatMask fmask,FontPtr non_cachable_font)

{
  FontRendererPtr p_Var1;
  long lVar2;
  char *__s;
  FontPtr p_Var3;
  int iVar4;
  size_t sVar5;
  size_t sVar6;
  char *pcVar7;
  long in_FS_OFFSET;
  char fileName [2049];
  
  p_Var1 = (entry->u).scalable.renderer;
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  if (p_Var1->OpenBitmap ==
      (_func_int_FontPathElementPtr_FontPtr_ptr_int_FontEntryPtr_char_ptr_fsBitmapFormat_fsBitmapFormatMask_FontPtr
       *)0x0) {
    iVar4 = 0x53;
  }
  else {
                    // WARNING: Load size is inaccurate
    pcVar7 = *fpe->private;
    sVar5 = strlen(pcVar7);
    __s = (entry->u).scalable.fileName;
    sVar6 = strlen(__s);
    iVar4 = 0x53;
    if (sVar5 + sVar6 < 0x801) {
      pcVar7 = (char *)__memcpy_chk(fileName,pcVar7,sVar5,0x801);
      __strcpy_chk(pcVar7 + sVar5,__s,0x801 - sVar5);
      iVar4 = (*p_Var1->OpenBitmap)(fpe,pFont,flags,entry,pcVar7,format,fmask,non_cachable_font);
      if (iVar4 == 0x55) {
        p_Var3 = *pFont;
        (entry->u).bitmap.pFont = p_Var3;
        p_Var3->fpePrivate = entry;
      }
    }
  }
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int FontFileGetInfoBitmap(FontPathElementPtr fpe,FontInfoPtr pFontInfo,FontEntryPtr entry)

{
  FontRendererPtr p_Var1;
  long lVar2;
  char *__s;
  char *__s_00;
  int iVar3;
  size_t sVar4;
  size_t sVar5;
  long in_FS_OFFSET;
  char fileName [2049];
  
  p_Var1 = (entry->u).scalable.renderer;
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  if (p_Var1->GetInfoBitmap == (_func_int_FontPathElementPtr_FontInfoPtr_FontEntryPtr_char_ptr *)0x0
     ) {
    iVar3 = 0x53;
  }
  else {
                    // WARNING: Load size is inaccurate
    __s = *fpe->private;
    sVar4 = strlen(__s);
    __s_00 = (entry->u).scalable.fileName;
    sVar5 = strlen(__s_00);
    iVar3 = 0x53;
    if (sVar4 + sVar5 < 0x801) {
      __memcpy_chk(fileName,__s,sVar4,0x801);
      __strcpy_chk(fileName + sVar4,__s_00,0x801 - sVar4);
      iVar3 = (*p_Var1->GetInfoBitmap)(fpe,pFontInfo,entry,fileName);
    }
  }
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void FontFileCloseFont(FontPathElementPtr fpe,FontPtr pFont)

{
  FontEntryPtr entry;
  
  entry = (FontEntryPtr)pFont->fpePrivate;
  if (entry != (FontEntryPtr)0x0) {
    if (entry->type == 0) {
      FontFileRemoveScaledInstance(entry,pFont);
    }
    else if (entry->type == 2) {
      (entry->u).scalable.extra = (FontScalableExtraPtr)0x0;
    }
    pFont->fpePrivate = (void *)0x0;
  }
                    // WARNING: Could not recover jumptable at 0x0010d643. Too many branches
                    // WARNING: Treating indirect jump as call
  (*pFont->unload_font)(pFont);
  return;
}



int FontFileListNextFontOrAlias
              (pointer client,FontPathElementPtr fpe,char **namep,int *namelenp,char **resolvedp,
              int *resolvedlenp,pointer private)

{
  int iVar1;
  FontNamesPtr pFN;
  long lVar2;
  int iVar3;
  
                    // WARNING: Load size is inaccurate
  pFN = *private;
  iVar3 = *(int *)((long)private + 8);
  if (iVar3 != pFN->nnames) {
    iVar1 = pFN->length[iVar3];
    *namep = pFN->names[iVar3];
    if (iVar1 < 0) {
      *namelenp = -iVar1;
                    // WARNING: Load size is inaccurate
      lVar2 = *(long *)(*private + 0x10);
      iVar3 = *(int *)((long)private + 8) + 1;
      *(int *)((long)private + 8) = iVar3;
      *resolvedp = *(char **)(lVar2 + (long)iVar3 * 8);
                    // WARNING: Load size is inaccurate
      *resolvedlenp = *(int *)(*(long *)(*private + 8) + (long)*(int *)((long)private + 8) * 4);
      iVar3 = 0x52;
    }
    else {
      *namelenp = iVar1;
      iVar3 = 0x55;
    }
    *(int *)((long)private + 8) = *(int *)((long)private + 8) + 1;
    return iVar3;
  }
  FreeFontNames(pFN);
  free(private);
  return 0x53;
}



void CopyISOLatin1Lowered(char *dest,char *source,int length)

{
  char cVar1;
  ulong uVar2;
  
  if (0 < length) {
    uVar2 = 0;
    while( true ) {
      cVar1 = source[uVar2];
      if (((byte)(cVar1 + 0xbfU) < 0x1a) || ((byte)(cVar1 + 0x40U) < 0x17)) {
        dest[uVar2] = cVar1 + ' ';
      }
      else {
        if ((byte)(cVar1 + 0x28U) < 7) {
          cVar1 = cVar1 + ' ';
        }
        dest[uVar2] = cVar1;
      }
      if (uVar2 == length - 1) break;
      uVar2 = uVar2 + 1;
    }
    dest = dest + (ulong)(length - 1) + 1;
  }
  *dest = '\0';
  return;
}



int transfer_values_to_alias
              (char *entryname,int entrynamelength,char *resolvedname,char **aliasName,
              FontScalablePtr vals)

{
  double dVar1;
  double dVar2;
  double dVar3;
  long lVar4;
  int iVar5;
  Bool BVar6;
  size_t sVar7;
  double *pdVar8;
  char *dest;
  int iVar9;
  long in_FS_OFFSET;
  double dVar10;
  double dVar11;
  FontScalableRec tmpVals;
  FontScalableRec tmpVals2;
  char lowerName [1024];
  
  lVar4 = *(long *)(in_FS_OFFSET + 0x28);
  *aliasName = resolvedname;
  sVar7 = strlen(resolvedname);
  iVar9 = (int)sVar7;
  if ((iVar9 < 0x401) && (entrynamelength < 0x400)) {
    iVar5 = FontFileCountDashes(resolvedname,iVar9);
    if (iVar5 == 0xe) {
      dest = lowerName;
      tmpVals2.values_supplied = vals->values_supplied;
      tmpVals2._4_4_ = *(undefined4 *)&vals->field_0x4;
      tmpVals2.pixel_matrix[0] = vals->pixel_matrix[0];
      tmpVals2.ranges = vals->ranges;
      tmpVals2.pixel_matrix[1] = vals->pixel_matrix[1];
      tmpVals2.pixel_matrix[2] = vals->pixel_matrix[2];
      tmpVals2.pixel_matrix[3] = vals->pixel_matrix[3];
      tmpVals2.point_matrix[0] = vals->point_matrix[0];
      tmpVals2.point_matrix[1] = vals->point_matrix[1];
      tmpVals2.point_matrix[2] = vals->point_matrix[2];
      tmpVals2.point_matrix[3] = vals->point_matrix[3];
      tmpVals2.pixel = vals->pixel;
      tmpVals2.point = vals->point;
      tmpVals2.x = vals->x;
      tmpVals2.y = vals->y;
      tmpVals2.width = vals->width;
      tmpVals2._92_4_ = *(undefined4 *)&vals->field_0x5c;
      tmpVals2.xlfdName = vals->xlfdName;
      tmpVals2.nranges = vals->nranges;
      tmpVals2._108_4_ = *(undefined4 *)&vals->field_0x6c;
      CopyISOLatin1Lowered(dest,entryname,entrynamelength);
      lowerName[entrynamelength] = '\0';
      BVar6 = FontParseXLFDName(dest,&tmpVals,0);
      if ((BVar6 != 0) && (tmpVals.values_supplied == 0)) {
        BVar6 = FontParseXLFDName(*aliasName,&tmpVals,0);
        if (BVar6 != 0) {
          iVar9 = iVar9 + 1;
          if ((tmpVals.values_supplied & 0xfU) == 2) {
            pdVar8 = tmpVals.pixel_matrix;
LAB_0010d91f:
            BVar6 = FontFileCompleteXLFD(&tmpVals2,&tmpVals2);
            if (BVar6 == 0) {
              CopyISOLatin1Lowered(transfer_values_to_alias::aliasname,*aliasName,iVar9);
              iVar9 = 0;
              goto LAB_0010d7b3;
            }
            dVar1 = *pdVar8;
            dVar11 = pdVar8[1];
            dVar2 = pdVar8[2];
            dVar3 = pdVar8[3];
            dVar10 = tmpVals2.point_matrix[0] * dVar2;
            tmpVals2._0_8_ = tmpVals2._0_8_ & 0xfffffffffffffff0 | 10;
            tmpVals2.point_matrix[0] =
                 dVar1 * tmpVals2.point_matrix[0] + dVar11 * tmpVals2.point_matrix[2];
            tmpVals2.point_matrix[2] = dVar10 + tmpVals2.point_matrix[2] * dVar3;
            dVar10 = tmpVals2.point_matrix[1] * dVar2;
            tmpVals2.point_matrix[1] =
                 dVar1 * tmpVals2.point_matrix[1] + dVar11 * tmpVals2.point_matrix[3];
            tmpVals2.point_matrix[3] = dVar10 + tmpVals2.point_matrix[3] * dVar3;
            dVar10 = dVar11 * tmpVals2.pixel_matrix[3];
            dVar11 = dVar11 * tmpVals2.pixel_matrix[2];
            tmpVals2.pixel_matrix[2] =
                 tmpVals2.pixel_matrix[0] * dVar2 + tmpVals2.pixel_matrix[2] * dVar3;
            tmpVals2.pixel_matrix[3] =
                 dVar2 * tmpVals2.pixel_matrix[1] + dVar3 * tmpVals2.pixel_matrix[3];
            tmpVals2.pixel_matrix[0] = dVar1 * tmpVals2.pixel_matrix[0] + dVar11;
            tmpVals2.pixel_matrix[1] = dVar1 * tmpVals2.pixel_matrix[1] + dVar10;
            CopyISOLatin1Lowered(transfer_values_to_alias::aliasname,*aliasName,iVar9);
          }
          else {
            if ((tmpVals.values_supplied & 0xfU) == 8) {
              pdVar8 = tmpVals.point_matrix;
              goto LAB_0010d91f;
            }
            CopyISOLatin1Lowered(transfer_values_to_alias::aliasname,*aliasName,iVar9);
          }
          BVar6 = FontParseXLFDName(transfer_values_to_alias::aliasname,&tmpVals2,3);
          if (BVar6 != 0) {
            *aliasName = transfer_values_to_alias::aliasname;
          }
        }
      }
    }
  }
  iVar9 = 1;
LAB_0010d7b3:
  if (lVar4 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar9;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void _FontFileAddScalableNames
               (FontNamesPtr names,FontNamesPtr scaleNames,FontNamePtr nameptr,char *zeroChars,
               FontScalablePtr vals,fsRange *ranges,int nranges,int *max)

{
  long lVar1;
  char *pcVar2;
  Bool BVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  uint *fname;
  size_t sVar8;
  uint *puVar9;
  uint *puVar10;
  int iVar11;
  long in_FS_OFFSET;
  bool bVar12;
  char *aliasName;
  FontScalableRec zeroVals;
  FontScalableRec tmpVals;
  char nameChars [1024];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (0 < scaleNames->nnames) {
    iVar11 = 0;
    do {
      while( true ) {
        if (*max == 0) goto LAB_0010dec0;
        FontParseXLFDName(scaleNames->names[iVar11],&zeroVals,0);
        tmpVals.values_supplied = vals->values_supplied;
        tmpVals._4_4_ = *(undefined4 *)&vals->field_0x4;
        tmpVals.pixel_matrix[0] = vals->pixel_matrix[0];
        tmpVals.ranges = vals->ranges;
        tmpVals.pixel_matrix[1] = vals->pixel_matrix[1];
        tmpVals.pixel_matrix[2] = vals->pixel_matrix[2];
        tmpVals.pixel_matrix[3] = vals->pixel_matrix[3];
        tmpVals.point_matrix[0] = vals->point_matrix[0];
        tmpVals.point_matrix[1] = vals->point_matrix[1];
        tmpVals.point_matrix[2] = vals->point_matrix[2];
        tmpVals.point_matrix[3] = vals->point_matrix[3];
        tmpVals.pixel = vals->pixel;
        tmpVals.point = vals->point;
        tmpVals.x = vals->x;
        tmpVals.y = vals->y;
        tmpVals.width = vals->width;
        tmpVals._92_4_ = *(undefined4 *)&vals->field_0x5c;
        tmpVals.xlfdName = vals->xlfdName;
        tmpVals.nranges = vals->nranges;
        tmpVals._108_4_ = *(undefined4 *)&vals->field_0x6c;
        BVar3 = FontFileCompleteXLFD(&tmpVals,&zeroVals);
        iVar7 = iVar11 + 1;
        if (BVar3 != 0) break;
LAB_0010db34:
        iVar11 = iVar7;
        if (scaleNames->nnames <= iVar7) goto LAB_0010dec0;
      }
      *max = *max + -1;
      fname = (uint *)__strcpy_chk(nameChars,scaleNames->names[iVar11],0x400);
      iVar6 = vals->y;
      uVar5 = vals->values_supplied;
      if (((uVar5 & 0x13) == 0x10) && (iVar6 != 0)) {
        if ((uVar5 & 0x2c) != 0x20) {
LAB_0010dc9c:
          tmpVals.point_matrix[0] = vals->point_matrix[0];
          tmpVals.point_matrix[1] = vals->point_matrix[1];
          tmpVals.point_matrix[2] = vals->point_matrix[2];
          tmpVals.values_supplied = uVar5 & 0xc | tmpVals.values_supplied & 0xfffffff3U;
          tmpVals.point_matrix[3] = vals->point_matrix[3];
        }
      }
      else {
        tmpVals.pixel_matrix[0] = vals->pixel_matrix[0];
        tmpVals.pixel_matrix[1] = vals->pixel_matrix[1];
        tmpVals.pixel_matrix[2] = vals->pixel_matrix[2];
        tmpVals.values_supplied = tmpVals.values_supplied & 0xfffffffcU | uVar5 & 3;
        tmpVals.pixel_matrix[3] = vals->pixel_matrix[3];
        if (((uVar5 & 0x2c) != 0x20) || (iVar6 == 0)) goto LAB_0010dc9c;
      }
      if (vals->width < 1) {
        tmpVals._88_8_ = tmpVals._88_8_ & 0xffffffff00000000;
      }
      if (vals->x == 0) {
        tmpVals._80_8_ = tmpVals._80_8_ & 0xffffffff00000000;
      }
      if (iVar6 == 0) {
        tmpVals._80_8_ = tmpVals._80_8_ & 0xffffffff;
      }
      tmpVals.nranges = nranges;
      tmpVals.ranges = ranges;
      FontParseXLFDName((char *)fname,&tmpVals,3);
      puVar10 = fname;
      if (-1 < scaleNames->length[iVar11]) {
        do {
          puVar9 = puVar10;
          uVar4 = *puVar9 + 0xfefefeff & ~*puVar9;
          uVar5 = uVar4 & 0x80808080;
          puVar10 = puVar9 + 1;
        } while (uVar5 == 0);
        bVar12 = (uVar4 & 0x8080) == 0;
        if (bVar12) {
          uVar5 = uVar5 >> 0x10;
        }
        if (bVar12) {
          puVar10 = (uint *)((long)puVar9 + 6);
        }
        AddFontNamesName(names,(char *)fname,
                         (((int)puVar10 + -3) - (uint)CARRY1((byte)uVar5,(byte)uVar5)) - (int)fname)
        ;
        pcVar2 = scaleNames->names[iVar11];
        iVar6 = strcmp((char *)fname,pcVar2);
        if (((iVar6 != 0) &&
            (BVar3 = FontFileMatchName(pcVar2,scaleNames->length[iVar11],nameptr), BVar3 != 0)) &&
           (*max != 0)) {
          *max = *max + -1;
          AddFontNamesName(names,scaleNames->names[iVar11],scaleNames->length[iVar11]);
        }
        goto LAB_0010db34;
      }
      vals->ranges = ranges;
      vals->nranges = nranges;
      puVar10 = (uint *)zeroChars;
      do {
        puVar9 = puVar10;
        uVar4 = *puVar9 + 0xfefefeff & ~*puVar9;
        uVar5 = uVar4 & 0x80808080;
        puVar10 = puVar9 + 1;
      } while (uVar5 == 0);
      bVar12 = (uVar4 & 0x8080) == 0;
      if (bVar12) {
        uVar5 = uVar5 >> 0x10;
      }
      if (bVar12) {
        puVar10 = (uint *)((long)puVar9 + 6);
      }
      iVar7 = transfer_values_to_alias
                        (zeroChars,
                         (((int)puVar10 + -3) - (uint)CARRY1((byte)uVar5,(byte)uVar5)) -
                         (int)zeroChars,scaleNames->names[(long)iVar11 + 1],&aliasName,vals);
      puVar10 = fname;
      if (iVar7 != 0) {
        do {
          puVar9 = puVar10;
          uVar4 = *puVar9 + 0xfefefeff & ~*puVar9;
          uVar5 = uVar4 & 0x80808080;
          puVar10 = puVar9 + 1;
        } while (uVar5 == 0);
        bVar12 = (uVar4 & 0x8080) == 0;
        if (bVar12) {
          uVar5 = uVar5 >> 0x10;
        }
        if (bVar12) {
          puVar10 = (uint *)((long)puVar9 + 6);
        }
        AddFontNamesName(names,(char *)fname,
                         (((int)puVar10 + -3) - (uint)CARRY1((byte)uVar5,(byte)uVar5)) - (int)fname)
        ;
        pcVar2 = aliasName;
        names->length[(long)names->nnames + -1] = -names->length[(long)names->nnames + -1];
        sVar8 = strlen(aliasName);
        AddFontNamesName(names,pcVar2,(int)sVar8);
        pcVar2 = scaleNames->names[iVar11];
        iVar7 = strcmp((char *)fname,pcVar2);
        if (((iVar7 != 0) &&
            (BVar3 = FontFileMatchName(pcVar2,-scaleNames->length[iVar11],nameptr), BVar3 != 0)) &&
           (*max != 0)) {
          *max = *max + -1;
          AddFontNamesName(names,scaleNames->names[iVar11],-scaleNames->length[iVar11]);
          pcVar2 = aliasName;
          names->length[(long)names->nnames + -1] = -names->length[(long)names->nnames + -1];
          sVar8 = strlen(aliasName);
          AddFontNamesName(names,pcVar2,(int)sVar8);
        }
      }
      iVar11 = iVar11 + 2;
    } while (iVar11 < scaleNames->nnames);
  }
LAB_0010dec0:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int FontFileOpenFont(pointer client,FontPathElementPtr fpe,Mask flags,char *name,int namelen,
                    fsBitmapFormat format,fsBitmapFormatMask fmask,XID id,FontPtr *pFont,
                    char **aliasName,FontPtr non_cachable_font)

{
  long lVar1;
  undefined8 *puVar2;
  char *__s;
  FontRendererPtr p_Var3;
  _func_int_FontPathElementPtr_FontPtr_ptr_int_FontEntryPtr_char_ptr_FontScalablePtr_fsBitmapFormat_fsBitmapFormatMask_FontPtr
  *p_Var4;
  _func_int_FontPathElementPtr_FontPtr_ptr_int_FontEntryPtr_char_ptr_fsBitmapFormat_fsBitmapFormatMask_FontPtr
  *p_Var5;
  short sVar6;
  short sVar7;
  FontPtr *pFont_00;
  int iVar8;
  Bool BVar9;
  uint uVar10;
  uint uVar11;
  fsRange *__ptr;
  FontEntryPtr p_Var12;
  FontEntryPtr_conflict entry;
  size_t sVar13;
  size_t sVar14;
  FontPtr p_Var15;
  FontScaledPtr p_Var16;
  int length;
  long lVar17;
  uint *puVar18;
  uint *puVar19;
  FontScalablePtr p_Var20;
  char *dest;
  long in_FS_OFFSET;
  bool bVar21;
  byte bVar22;
  undefined4 in_stack_0000000c;
  int local_1100;
  int nranges;
  FontNameRec tmpName;
  FontScalableRec vals;
  char lowerName [1024];
  char origName [1024];
  char fileName [2049];
  
  bVar22 = 0;
  pFont_00 = (FontPtr *)CONCAT44(in_stack_0000000c,fmask);
  length = (int)name;
  sVar7 = (short)name;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  puVar2 = *(undefined8 **)((long)client + 0x18);
  CopyISOLatin1Lowered(lowerName,(char *)flags,length);
  lowerName[length] = '\0';
  __ptr = FontParseRanges(lowerName,&nranges);
  tmpName.name = lowerName;
  tmpName.length = sVar7;
  iVar8 = FontFileCountDashes(lowerName,length);
  tmpName.ndashes = (short)iVar8;
  BVar9 = FontParseXLFDName(lowerName,&vals,0);
  if (BVar9 == 0) {
    p_Var20 = &vals;
    for (lVar17 = 0xf; lVar17 != 0; lVar17 = lVar17 + -1) {
      *(undefined8 *)p_Var20 = 0;
      p_Var20 = (FontScalablePtr)((long)p_Var20 + (ulong)bVar22 * -0x10 + 8);
    }
  }
  p_Var12 = FontFileFindNameInDir((FontTablePtr)(puVar2 + 6),&tmpName);
  sVar6 = (short)lowerName;
  local_1100 = (int)fpe;
  if (p_Var12 != (FontEntryPtr)0x0) {
LAB_0010e15b:
    if (p_Var12->type != 2) {
      if (p_Var12->type == 3) {
        vals.nranges = nranges;
        vals.ranges = __ptr;
        transfer_values_to_alias
                  ((p_Var12->name).name,(int)(p_Var12->name).length,
                   (char *)(p_Var12->u).scalable.renderer,(char **)id,&vals);
        iVar8 = 0x52;
        goto LAB_0010e23c;
      }
      goto LAB_0010e170;
    }
    p_Var15 = (FontPtr)(p_Var12->u).scalable.extra;
    if (p_Var15 == (FontPtr)0x0) {
      iVar8 = FontFileOpenBitmapNCF
                        ((FontPathElementPtr)client,pFont_00,local_1100,p_Var12,namelen,format,
                         (FontPtr)pFont);
      if (iVar8 != 0x55) {
        if (iVar8 == 0x53) goto LAB_0010e170;
        goto LAB_0010e23c;
      }
      p_Var15 = *pFont_00;
      if (p_Var15 == (FontPtr)0x0) goto LAB_0010e23c;
LAB_0010e639:
      p_Var15->fpe = (FontPathElementPtr)client;
      goto LAB_0010e23c;
    }
LAB_0010e5b9:
    iVar8 = 0x55;
    *pFont_00 = p_Var15;
    p_Var15->fpe = (FontPathElementPtr)client;
    goto LAB_0010e23c;
  }
  if ((tmpName.ndashes == 0xe) &&
     (BVar9 = FontParseXLFDName(lowerName,&vals,2), puVar19 = (uint *)lowerName, BVar9 != 0)) {
    do {
      puVar18 = puVar19;
      uVar10 = *puVar18 + 0xfefefeff & ~*puVar18;
      uVar11 = uVar10 & 0x80808080;
      puVar19 = puVar18 + 1;
    } while (uVar11 == 0);
    bVar21 = (uVar10 & 0x8080) == 0;
    if (bVar21) {
      uVar11 = uVar11 >> 0x10;
    }
    if (bVar21) {
      puVar19 = (uint *)((long)puVar18 + 6);
    }
    tmpName.length = (((short)puVar19 + -3) - (ushort)CARRY1((byte)uVar11,(byte)uVar11)) - sVar6;
    p_Var12 = FontFileFindNameInDir((FontTablePtr)(puVar2 + 6),&tmpName);
    if (p_Var12 != (FontEntryPtr)0x0) goto LAB_0010e15b;
  }
LAB_0010e170:
  CopyISOLatin1Lowered(lowerName,(char *)flags,length);
  lowerName[length] = '\0';
  tmpName.name = lowerName;
  tmpName.length = sVar7;
  iVar8 = FontFileCountDashes(lowerName,length);
  tmpName.ndashes = (short)iVar8;
  BVar9 = FontParseXLFDName(lowerName,&vals,2);
  puVar19 = (uint *)lowerName;
  if (BVar9 == 0) {
LAB_0010e2d0:
    CopyISOLatin1Lowered(lowerName,(char *)flags,length);
    lowerName[length] = '\0';
    tmpName.name = lowerName;
    tmpName.length = sVar7;
    iVar8 = FontFileCountDashes(lowerName,length);
    tmpName.ndashes = (short)iVar8;
    entry = FontFileFindNameInScalableDir((FontTablePtr)(puVar2 + 3),&tmpName,&vals);
    if (entry != (FontEntryPtr)0x0) {
      __strcpy_chk(lowerName,(entry->name).name,0x400);
      tmpName.length = (entry->name).length;
      tmpName.ndashes = (entry->name).ndashes;
      iVar8 = entry->type;
      tmpName.name = lowerName;
      goto joined_r0x0010e360;
    }
LAB_0010e236:
    iVar8 = 0x53;
  }
  else {
    do {
      puVar18 = puVar19;
      uVar10 = *puVar18 + 0xfefefeff & ~*puVar18;
      uVar11 = uVar10 & 0x80808080;
      puVar19 = puVar18 + 1;
    } while (uVar11 == 0);
    bVar21 = (uVar10 & 0x8080) == 0;
    if (bVar21) {
      uVar11 = uVar11 >> 0x10;
    }
    if (bVar21) {
      puVar19 = (uint *)((long)puVar18 + 6);
    }
    tmpName.length = (((short)puVar19 + -3) - (ushort)CARRY1((byte)uVar11,(byte)uVar11)) - sVar6;
    entry = FontFileFindNameInScalableDir((FontTablePtr)(puVar2 + 3),&tmpName,&vals);
    if (entry == (FontEntryPtr)0x0) goto LAB_0010e2d0;
    iVar8 = entry->type;
joined_r0x0010e360:
    if ((iVar8 != 0) ||
       (BVar9 = FontFileCompleteXLFD(&vals,&((entry->u).scalable.extra)->defaults), BVar9 == 0))
    goto LAB_0010e236;
    if (((vals.values_supplied & 3U) == 2) ||
       ((((vals.values_supplied & 0xcU) == 8 || ((vals.values_supplied & 0xffffffb0U) != 0)) ||
        (p_Var16 = FontFileFindScaledInstance(entry,&vals,0), p_Var16 == (FontScaledPtr)0x0)))) {
      iVar8 = FontFileMatchBitmapSource
                        ((FontPathElementPtr)client,pFont_00,local_1100,entry,&tmpName,&vals,namelen
                         ,format,0);
      if (iVar8 == 0x55) {
LAB_0010e690:
        iVar8 = 0x55;
      }
      else {
        dest = origName;
        CopyISOLatin1Lowered(dest,(char *)flags,length);
        origName[length] = '\0';
        vals.nranges = nranges;
        __s = (char *)*puVar2;
        vals.xlfdName = dest;
        vals.ranges = __ptr;
        sVar13 = strlen(__s);
        sVar14 = strlen((entry->u).scalable.fileName);
        if (0x800 < sVar14 + sVar13) goto LAB_0010e236;
        __memcpy_chk(fileName,__s,sVar13 + 1,0x801);
        __strcpy_chk(fileName + sVar13,(entry->u).scalable.fileName,0x801 - sVar13);
        p_Var3 = (entry->u).scalable.renderer;
        p_Var4 = p_Var3->OpenScalable;
        if (p_Var4 == (_func_int_FontPathElementPtr_FontPtr_ptr_int_FontEntryPtr_char_ptr_FontScalablePtr_fsBitmapFormat_fsBitmapFormatMask_FontPtr
                       *)0x0) {
          p_Var5 = p_Var3->OpenBitmap;
          if (p_Var5 == (_func_int_FontPathElementPtr_FontPtr_ptr_int_FontEntryPtr_char_ptr_fsBitmapFormat_fsBitmapFormatMask_FontPtr
                         *)0x0) goto LAB_0010e23c;
          iVar8 = (*p_Var5)((FontPathElementPtr)client,pFont_00,local_1100,entry,fileName,namelen,
                            format,(FontPtr)pFont);
        }
        else {
          iVar8 = (*p_Var4)((FontPathElementPtr)client,pFont_00,local_1100,entry,fileName,&vals,
                            namelen,format,(FontPtr)pFont);
        }
        if (iVar8 == 0x55) {
          p_Var15 = *pFont_00;
          if (((p_Var15->info).firstCol <= (p_Var15->info).lastCol) &&
             ((p_Var15->info).firstRow <= (p_Var15->info).lastRow)) {
            BVar9 = FontFileAddScaledInstance(entry,&vals,p_Var15,(char *)0x0);
            if (BVar9 != 0) {
              (*pFont_00)->fpe = (FontPathElementPtr)client;
              goto LAB_0010e253;
            }
            (*pFont_00)->fpePrivate = (void *)0x0;
            p_Var15 = *pFont_00;
            goto LAB_0010e639;
          }
          (*p_Var15->unload_font)(p_Var15);
          iVar8 = 0x53;
        }
      }
    }
    else {
      p_Var15 = p_Var16->pFont;
      if (p_Var15 != (FontPtr)0x0) goto LAB_0010e5b9;
      p_Var12 = p_Var16->bitmap;
      if (p_Var12 == (FontEntryPtr)0x0) goto LAB_0010e236;
      p_Var15 = (FontPtr)(p_Var12->u).scalable.extra;
      if (p_Var15 == (FontPtr)0x0) {
        iVar8 = FontFileOpenBitmapNCF
                          ((FontPathElementPtr)client,pFont_00,local_1100,p_Var12,namelen,format,
                           (FontPtr)pFont);
        if (iVar8 == 0x55) {
          p_Var15 = *pFont_00;
          if (p_Var15 != (FontPtr)0x0) goto LAB_0010e639;
          goto LAB_0010e690;
        }
      }
      else {
        iVar8 = 0x55;
        *pFont_00 = p_Var15;
        p_Var15->fpe = (FontPathElementPtr)client;
      }
    }
  }
LAB_0010e23c:
  if (__ptr != (fsRange *)0x0) {
    free(__ptr);
  }
LAB_0010e253:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar8;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int FontFileOpenFont(pointer client,FontPathElementPtr fpe,Mask flags,char *name,int namelen,
                    fsBitmapFormat format,fsBitmapFormatMask fmask,XID id,FontPtr *pFont,
                    char **aliasName,FontPtr non_cachable_font)

{
  fsBitmapFormatMask format_00;
  int iVar1;
  
  format_00 = fmask;
  if (namelen < 0x400) {
    fmask = (fsBitmapFormatMask)pFont;
    iVar1 = FontFileOpenFont(fpe,(FontPathElementPtr)flags,(Mask)name,(char *)(ulong)(uint)namelen,
                             format,format_00,fmask,(XID)aliasName,(FontPtr *)non_cachable_font,
                             aliasName,non_cachable_font);
    return iVar1;
  }
  return 0x50;
}



int _FontFileListFonts(pointer client,FontPathElementPtr fpe,char *pat,int len,int max,
                      FontNamesPtr names,int mark_aliases)

{
  long lVar1;
  long lVar2;
  int iVar3;
  Bool BVar4;
  uint uVar5;
  uint uVar6;
  fsRange *ranges;
  FontNamesPtr p_Var7;
  uint *puVar8;
  uint *puVar9;
  int iVar10;
  undefined4 in_register_00000084;
  FontNamesPtr names_00;
  long in_FS_OFFSET;
  bool bVar11;
  int local_8fc [4];
  int nranges;
  FontNameRec lowerName;
  FontNameRec zeroName;
  FontScalableRec vals;
  char lowerChars [1024];
  char zeroChars [1024];
  
  names_00 = (FontNamesPtr)CONCAT44(in_register_00000084,max);
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar3 = (int)pat;
  local_8fc[0] = len;
  if (iVar3 < 0x400) {
                    // WARNING: Load size is inaccurate
    lVar2 = *client;
    CopyISOLatin1Lowered(lowerChars,(char *)fpe,iVar3);
    lowerName.length = (short)iVar3;
    lowerChars[iVar3] = '\0';
    lowerName.name = lowerChars;
    iVar3 = FontFileCountDashes(lowerChars,iVar3);
    lowerName.ndashes = (short)iVar3;
    __strcpy_chk(zeroChars,lowerChars,0x400);
    iVar10 = (int)names;
    if ((short)iVar3 == 0xe) {
      BVar4 = FontParseXLFDName(zeroChars,&vals,2);
      if (BVar4 != 0) {
        ranges = FontParseRanges(lowerChars,&nranges);
        iVar3 = FontFileFindNamesInScalableDir
                          ((FontTablePtr)(lVar2 + 0x30),&lowerName,local_8fc[0],names_00,
                           (FontScalablePtr)0x0,(iVar10 != 0) + 2,local_8fc);
        puVar9 = (uint *)zeroChars;
        do {
          puVar8 = puVar9;
          uVar5 = *puVar8 + 0xfefefeff & ~*puVar8;
          uVar6 = uVar5 & 0x80808080;
          puVar9 = puVar8 + 1;
        } while (uVar6 == 0);
        bVar11 = (uVar5 & 0x8080) == 0;
        if (bVar11) {
          uVar6 = uVar6 >> 0x10;
        }
        if (bVar11) {
          puVar9 = (uint *)((long)puVar8 + 6);
        }
        zeroName.length =
             (((short)puVar9 + -3) - (ushort)CARRY1((byte)uVar6,(byte)uVar6)) - (short)zeroChars;
        zeroName.ndashes = lowerName.ndashes;
        zeroName.name = zeroChars;
        p_Var7 = MakeFontNamesRecord(0);
        if (p_Var7 != (FontNamesPtr)0x0) {
          FontFileFindNamesInScalableDir
                    ((FontTablePtr)(lVar2 + 0x18),&zeroName,local_8fc[0],p_Var7,&vals,
                     (uint)(iVar10 != 0),(int *)0x0);
          _FontFileAddScalableNames
                    (names_00,p_Var7,&lowerName,zeroChars,&vals,ranges,nranges,local_8fc);
          FreeFontNames(p_Var7);
          p_Var7 = MakeFontNamesRecord(0);
          if (p_Var7 != (FontNamesPtr)0x0) {
            FontFileFindNamesInScalableDir
                      ((FontTablePtr)(lVar2 + 0x30),&zeroName,local_8fc[0],p_Var7,&vals,
                       (uint)(iVar10 != 0),(int *)0x0);
            _FontFileAddScalableNames
                      (names_00,p_Var7,&lowerName,zeroChars,&vals,ranges,nranges,local_8fc);
            FreeFontNames(p_Var7);
            if (ranges != (fsRange *)0x0) {
              free(ranges);
            }
            goto LAB_0010e8df;
          }
        }
        if (ranges != (fsRange *)0x0) {
          free(ranges);
        }
        goto LAB_0010eb38;
      }
    }
    iVar3 = FontFileFindNamesInScalableDir
                      ((FontTablePtr)(lVar2 + 0x30),&lowerName,local_8fc[0],names_00,
                       (FontScalablePtr)0x0,(uint)(iVar10 != 0),local_8fc);
    if (iVar3 == 0x55) {
      iVar3 = FontFileFindNamesInScalableDir
                        ((FontTablePtr)(lVar2 + 0x18),&lowerName,local_8fc[0],names_00,
                         (FontScalablePtr)0x0,(uint)(iVar10 != 0),(int *)0x0);
    }
  }
  else {
LAB_0010eb38:
    iVar3 = 0x50;
  }
LAB_0010e8df:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int FontFileListFonts(pointer client,FontPathElementPtr fpe,char *pat,int len,int max,
                     FontNamesPtr names)

{
  int iVar1;
  int in_stack_00000008;
  
  iVar1 = _FontFileListFonts(&fpe->private,(FontPathElementPtr)pat,(char *)(ulong)(uint)len,max,
                             (int)names,(FontNamesPtr)0x0,in_stack_00000008);
  return iVar1;
}



int FontFileListOneFontWithInfo
              (pointer client,FontPathElementPtr fpe,char **namep,int *namelenp,
              FontInfoPtr *pFontInfo)

{
  int length;
  long lVar1;
  char *source;
  undefined8 *puVar2;
  FontScalableExtraPtr p_Var3;
  char *__s;
  FontRendererPtr p_Var4;
  _func_int_FontPathElementPtr_FontInfoPtr_FontEntryPtr_FontNamePtr_char_ptr_FontScalablePtr *p_Var5
  ;
  _func_int_FontPathElementPtr_FontInfoPtr_FontEntryPtr_char_ptr *p_Var6;
  short sVar7;
  int iVar8;
  Bool BVar9;
  uint uVar10;
  uint uVar11;
  FontEntryPtr p_Var12;
  FontScaledPtr p_Var13;
  size_t sVar14;
  size_t sVar15;
  char *pcVar16;
  long lVar17;
  uint *puVar18;
  uint *puVar19;
  FontScalablePtr p_Var20;
  short sVar21;
  long in_FS_OFFSET;
  bool bVar22;
  byte bVar23;
  fsRange *local_1118;
  int nranges;
  FontNameRec tmpName;
  FontScalableRec vals;
  char lowerName [1024];
  char origName [1024];
  char fileName [2049];
  
  bVar23 = 0;
  iVar8 = 0x50;
  length = *(int *)namep;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (0x3ff < length) goto LAB_0010edbf;
  source = *(char **)fpe;
  puVar2 = *(undefined8 **)((long)client + 0x18);
  CopyISOLatin1Lowered(lowerName,source,length);
  lowerName[length] = '\0';
  local_1118 = FontParseRanges(lowerName,&nranges);
  sVar21 = (short)length;
  tmpName.name = lowerName;
  tmpName.length = sVar21;
  iVar8 = FontFileCountDashes(lowerName,length);
  tmpName.ndashes = (short)iVar8;
  BVar9 = FontParseXLFDName(lowerName,&vals,0);
  if (BVar9 == 0) {
    p_Var20 = &vals;
    for (lVar17 = 0xf; lVar17 != 0; lVar17 = lVar17 + -1) {
      *(undefined8 *)p_Var20 = 0;
      p_Var20 = (FontScalablePtr)((long)p_Var20 + (ulong)bVar23 * -0x10 + 8);
    }
  }
  p_Var12 = FontFileFindNameInDir((FontTablePtr)(puVar2 + 6),&tmpName);
  sVar7 = (short)lowerName;
  if (p_Var12 == (FontEntryPtr)0x0) {
    if ((tmpName.ndashes == 0xe) &&
       (BVar9 = FontParseXLFDName(lowerName,&vals,2), puVar19 = (uint *)lowerName, BVar9 != 0)) {
      do {
        puVar18 = puVar19;
        uVar10 = *puVar18 + 0xfefefeff & ~*puVar18;
        uVar11 = uVar10 & 0x80808080;
        puVar19 = puVar18 + 1;
      } while (uVar11 == 0);
      bVar22 = (uVar10 & 0x8080) == 0;
      if (bVar22) {
        uVar11 = uVar11 >> 0x10;
      }
      if (bVar22) {
        puVar19 = (uint *)((long)puVar18 + 6);
      }
      tmpName.length = (((short)puVar19 + -3) - (ushort)CARRY1((byte)uVar11,(byte)uVar11)) - sVar7;
      p_Var12 = FontFileFindNameInDir((FontTablePtr)(puVar2 + 6),&tmpName);
      if (p_Var12 != (FontEntryPtr)0x0) goto LAB_0010ec98;
    }
LAB_0010ecad:
    CopyISOLatin1Lowered(lowerName,source,length);
    lowerName[length] = '\0';
    tmpName.name = lowerName;
    tmpName.length = sVar21;
    iVar8 = FontFileCountDashes(lowerName,length);
    tmpName.ndashes = (short)iVar8;
    BVar9 = FontParseXLFDName(lowerName,&vals,2);
    puVar19 = (uint *)lowerName;
    if (BVar9 == 0) {
LAB_0010ee08:
      CopyISOLatin1Lowered(lowerName,source,length);
      lowerName[length] = '\0';
      tmpName.name = lowerName;
      tmpName.length = sVar21;
      iVar8 = FontFileCountDashes(lowerName,length);
      tmpName.ndashes = (short)iVar8;
      p_Var12 = FontFileFindNameInScalableDir((FontTablePtr)(puVar2 + 3),&tmpName,&vals);
      iVar8 = 0x53;
      if (p_Var12 == (FontEntryPtr)0x0) goto LAB_0010eda6;
      __strcpy_chk(lowerName,(p_Var12->name).name,0x400);
      tmpName.length = (p_Var12->name).length;
      tmpName.ndashes = (p_Var12->name).ndashes;
      tmpName.name = lowerName;
    }
    else {
      do {
        puVar18 = puVar19;
        uVar10 = *puVar18 + 0xfefefeff & ~*puVar18;
        uVar11 = uVar10 & 0x80808080;
        puVar19 = puVar18 + 1;
      } while (uVar11 == 0);
      bVar22 = (uVar10 & 0x8080) == 0;
      if (bVar22) {
        uVar11 = uVar11 >> 0x10;
      }
      if (bVar22) {
        puVar19 = (uint *)((long)puVar18 + 6);
      }
      tmpName.length = (((short)puVar19 + -3) - (ushort)CARRY1((byte)uVar11,(byte)uVar11)) - sVar7;
      p_Var12 = FontFileFindNameInScalableDir((FontTablePtr)(puVar2 + 3),&tmpName,&vals);
      if (p_Var12 == (FontEntryPtr)0x0) goto LAB_0010ee08;
    }
    iVar8 = 0x53;
    if (p_Var12->type == 0) {
      BVar9 = FontFileCompleteXLFD(&vals,&((p_Var12->u).scalable.extra)->defaults);
      iVar8 = 0x53;
      if (BVar9 != 0) {
        p_Var13 = FontFileFindScaledInstance(p_Var12,&vals,0);
        if (p_Var13 == (FontScaledPtr)0x0) {
          pcVar16 = origName;
          CopyISOLatin1Lowered(pcVar16,source,length);
          origName[length] = '\0';
          vals.nranges = nranges;
          __s = (char *)*puVar2;
          vals.xlfdName = pcVar16;
          vals.ranges = local_1118;
          sVar14 = strlen(__s);
          sVar15 = strlen((p_Var12->u).scalable.fileName);
          if (sVar15 + sVar14 < 0x801) {
            pcVar16 = (char *)__memcpy_chk(fileName,__s,sVar14 + 1,0x801);
            __strcpy_chk(pcVar16 + sVar14,(p_Var12->u).scalable.fileName,0x801 - sVar14);
            p_Var4 = (p_Var12->u).scalable.renderer;
            p_Var5 = p_Var4->GetInfoScalable;
            if (p_Var5 == (_func_int_FontPathElementPtr_FontInfoPtr_FontEntryPtr_FontNamePtr_char_ptr_FontScalablePtr
                           *)0x0) {
              p_Var6 = p_Var4->GetInfoBitmap;
              if (p_Var6 == (_func_int_FontPathElementPtr_FontInfoPtr_FontEntryPtr_char_ptr *)0x0)
              goto LAB_0010f0ac;
              iVar8 = (*p_Var6)((FontPathElementPtr)client,*(FontInfoPtr *)namelenp,p_Var12,pcVar16)
              ;
            }
            else {
              iVar8 = (*p_Var5)((FontPathElementPtr)client,*(FontInfoPtr *)namelenp,p_Var12,&tmpName
                                ,pcVar16,&vals);
            }
          }
          else {
LAB_0010f0ac:
            iVar8 = 0x53;
          }
          if (local_1118 != (fsRange *)0x0) {
            free(local_1118);
          }
          local_1118 = (fsRange *)0x0;
        }
        else {
          iVar8 = 0x53;
          if (p_Var13->pFont != (FontPtr)0x0) {
            iVar8 = 0x55;
            *(FontInfoRec **)namelenp = &p_Var13->pFont->info;
            goto LAB_0010edbf;
          }
          p_Var12 = p_Var13->bitmap;
          if (p_Var12 == (FontEntryPtr)0x0) goto LAB_0010ed8e;
          p_Var3 = (p_Var12->u).scalable.extra;
          if (p_Var3 != (FontScalableExtraPtr)0x0) {
            iVar8 = 0x55;
            *(double **)namelenp = (p_Var3->defaults).pixel_matrix;
            goto LAB_0010edbf;
          }
          iVar8 = FontFileGetInfoBitmap((FontPathElementPtr)client,*(FontInfoPtr *)namelenp,p_Var12)
          ;
        }
        if (iVar8 == 0x55) goto LAB_0010edbf;
      }
    }
LAB_0010ed8e:
    CopyISOLatin1Lowered(lowerName,source,length);
  }
  else {
LAB_0010ec98:
    if (p_Var12->type == 2) {
      p_Var3 = (p_Var12->u).scalable.extra;
      if (p_Var3 == (FontScalableExtraPtr)0x0) {
        iVar8 = FontFileGetInfoBitmap((FontPathElementPtr)client,*(FontInfoPtr *)namelenp,p_Var12);
        if (iVar8 == 0x53) goto LAB_0010ecad;
      }
      else {
        iVar8 = 0x55;
        *(double **)namelenp = (p_Var3->defaults).pixel_matrix;
      }
    }
    else {
      if (p_Var12->type != 3) goto LAB_0010ecad;
      vals.nranges = nranges;
      vals.ranges = local_1118;
      transfer_values_to_alias
                ((p_Var12->name).name,(int)(p_Var12->name).length,
                 (char *)(p_Var12->u).scalable.renderer,(char **)fpe,&vals);
      sVar14 = strlen(*(char **)fpe);
      iVar8 = 0x52;
      *(int *)namep = (int)sVar14;
    }
  }
LAB_0010eda6:
  if (local_1118 != (fsRange *)0x0) {
    free(local_1118);
  }
LAB_0010edbf:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar8;
}



int FontFileListNextFontWithInfo
              (pointer client,FontPathElementPtr fpe,char **namep,int *namelenp,
              FontInfoPtr *pFontInfo,int *numFonts,pointer private)

{
  int iVar1;
  FontNamesPtr pFN;
  int iVar2;
  long in_FS_OFFSET;
  int namelen;
  char *name;
  char *local_30;
  
  local_30 = *(char **)(in_FS_OFFSET + 0x28);
                    // WARNING: Load size is inaccurate
  pFN = *private;
  iVar2 = *(int *)((long)private + 8);
  if (iVar2 == pFN->nnames) {
    FreeFontNames(pFN);
    free(private);
    iVar2 = 0x53;
  }
  else {
    name = pFN->names[iVar2];
    namelen = pFN->length[iVar2];
    iVar2 = FontFileListOneFontWithInfo
                      (fpe,(FontPathElementPtr)&name,(char **)&namelen,(int *)pFontInfo,pFontInfo);
    if (iVar2 == 0x53) {
      iVar2 = 0x50;
    }
    *namep = name;
    *namelenp = namelen;
                    // WARNING: Load size is inaccurate
    iVar1 = *(int *)((long)private + 8) + 1;
    *(int *)((long)private + 8) = iVar1;
    *numFonts = **private - iVar1;
  }
  if (local_30 == *(char **)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int FontFileOpenBitmap(FontPathElementPtr fpe,FontPtr *pFont,int flags,FontEntryPtr entry,
                      fsBitmapFormat format,fsBitmapFormatMask fmask)

{
  int iVar1;
  
  iVar1 = FontFileOpenBitmapNCF(fpe,pFont,flags,entry,format,fmask,(FontPtr)0x0);
  return iVar1;
}



int FontFileStartListFonts
              (pointer client,FontPathElementPtr fpe,char *pat,int len,int max,pointer *privatep,
              int mark_aliases)

{
  int iVar1;
  undefined8 *__ptr;
  FontNamesPtr p_Var2;
  int in_stack_ffffffffffffffc8;
  
  __ptr = (undefined8 *)malloc(0x10);
  if (__ptr == (undefined8 *)0x0) {
    iVar1 = 0x50;
  }
  else {
    p_Var2 = MakeFontNamesRecord(0);
    *__ptr = p_Var2;
    if (p_Var2 == (FontNamesPtr)0x0) {
      iVar1 = 0x50;
      free(__ptr);
    }
    else {
      iVar1 = _FontFileListFonts(&fpe->private,(FontPathElementPtr)pat,(char *)(ulong)(uint)len,max,
                                 (int)p_Var2,(FontNamesPtr)(ulong)(uint)mark_aliases,
                                 in_stack_ffffffffffffffc8);
      if (iVar1 == 0x55) {
        *(undefined4 *)(__ptr + 1) = 0;
        *privatep = __ptr;
      }
      else {
        FreeFontNames((FontNamesPtr)*__ptr);
        free(__ptr);
      }
    }
  }
  return iVar1;
}



int FontFileStartListFontsWithInfo
              (pointer client,FontPathElementPtr fpe,char *pat,int len,int max,pointer *privatep)

{
  int iVar1;
  
  iVar1 = FontFileStartListFonts(client,fpe,pat,len,max,privatep,0);
  return iVar1;
}



int FontFileStartListFontsAndAliases
              (pointer client,FontPathElementPtr fpe,char *pat,int len,int max,pointer *privatep)

{
  int iVar1;
  
  iVar1 = FontFileStartListFonts(client,fpe,pat,len,max,privatep,1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void FontFileRegisterLocalFpeFunctions(void)

{
  RegisterFPEFunctions
            (FontFileNameCheck,FontFileInitFPE,FontFileFreeFPE,FontFileResetFPE,FontFileOpenFont,
             FontFileCloseFont,FontFileListFonts,FontFileStartListFontsWithInfo,
             FontFileListNextFontWithInfo,(WakeupFpeFunc)0x0,(ClientDiedFunc)0x0,(LoadGlyphsFunc)0x0
             ,FontFileStartListFontsAndAliases,FontFileListNextFontOrAlias,FontFileEmptyBitmapSource
            );
  return;
}



Bool FontFileAddScaledInstance
               (FontEntryPtr entry,FontScalablePtr vals,FontPtr pFont,char *bitmapName)

{
  int iVar1;
  FontScalableExtraPtr p_Var2;
  fsRange *pfVar3;
  double dVar4;
  undefined4 uVar5;
  int iVar6;
  FontScaledPtr p_Var7;
  
  p_Var2 = (entry->u).scalable.extra;
  iVar1 = p_Var2->numScaled;
  p_Var7 = p_Var2->scaled;
  if (iVar1 == p_Var2->sizeScaled) {
    p_Var7 = (FontScaledPtr)realloc(p_Var7,(long)(iVar1 + 4) * 0x88);
    if (p_Var7 == (FontScaledPtr)0x0) {
      return 0;
    }
    p_Var2->sizeScaled = iVar1 + 4;
    iVar1 = p_Var2->numScaled;
    p_Var2->scaled = p_Var7;
  }
  p_Var2->numScaled = iVar1 + 1;
  uVar5 = *(undefined4 *)&vals->field_0x4;
  dVar4 = vals->pixel_matrix[0];
  p_Var7 = p_Var7 + iVar1;
  (p_Var7->vals).values_supplied = vals->values_supplied;
  *(undefined4 *)&(p_Var7->vals).field_0x4 = uVar5;
  (p_Var7->vals).pixel_matrix[0] = dVar4;
  dVar4 = vals->pixel_matrix[2];
  (p_Var7->vals).pixel_matrix[1] = vals->pixel_matrix[1];
  (p_Var7->vals).pixel_matrix[2] = dVar4;
  dVar4 = vals->point_matrix[0];
  (p_Var7->vals).pixel_matrix[3] = vals->pixel_matrix[3];
  (p_Var7->vals).point_matrix[0] = dVar4;
  dVar4 = vals->point_matrix[2];
  (p_Var7->vals).point_matrix[1] = vals->point_matrix[1];
  (p_Var7->vals).point_matrix[2] = dVar4;
  iVar1 = vals->pixel;
  iVar6 = vals->point;
  (p_Var7->vals).point_matrix[3] = vals->point_matrix[3];
  (p_Var7->vals).pixel = iVar1;
  (p_Var7->vals).point = iVar6;
  iVar1 = vals->y;
  iVar6 = vals->width;
  uVar5 = *(undefined4 *)&vals->field_0x5c;
  (p_Var7->vals).x = vals->x;
  (p_Var7->vals).y = iVar1;
  (p_Var7->vals).width = iVar6;
  *(undefined4 *)&(p_Var7->vals).field_0x5c = uVar5;
  iVar1 = vals->nranges;
  uVar5 = *(undefined4 *)&vals->field_0x6c;
  (p_Var7->vals).xlfdName = vals->xlfdName;
  (p_Var7->vals).nranges = iVar1;
  *(undefined4 *)&(p_Var7->vals).field_0x6c = uVar5;
  pfVar3 = vals->ranges;
  p_Var7->pFont = pFont;
  (p_Var7->vals).ranges = pfVar3;
  p_Var7->bitmap = (FontEntryPtr)bitmapName;
  if (pFont != (FontPtr)0x0) {
    pFont->fpePrivate = entry;
  }
  return 1;
}



void FontFileSwitchStringsToBitmapPointers(FontDirectoryPtr dir)

{
  FontEntryPtr p_Var1;
  FontScalableExtraPtr p_Var2;
  FontEntryPtr p_Var3;
  FontEntryPtr *pp_Var4;
  int iVar5;
  int iVar6;
  FontScalableExtraPtr *pp_Var7;
  int iVar8;
  
  p_Var1 = (dir->nonScalable).entries;
  if ((dir->scalable).used < 1) {
    return;
  }
  pp_Var7 = &(((dir->scalable).entries)->u).scalable.extra;
  iVar8 = 0;
  do {
    p_Var2 = *pp_Var7;
    if (0 < p_Var2->numScaled) {
      pp_Var4 = &p_Var2->scaled->bitmap;
      iVar6 = 0;
      do {
        iVar5 = 0;
        p_Var3 = p_Var1;
        if (0 < (dir->nonScalable).used) {
          do {
            while ((FontEntryPtr)(p_Var3->name).name != *pp_Var4) {
              iVar5 = iVar5 + 1;
              p_Var3 = p_Var3 + 1;
              if ((dir->nonScalable).used <= iVar5) goto LAB_0010f577;
            }
            *pp_Var4 = p_Var3;
            iVar5 = iVar5 + 1;
            p_Var3 = p_Var3 + 1;
          } while (iVar5 < (dir->nonScalable).used);
        }
LAB_0010f577:
        iVar6 = iVar6 + 1;
        pp_Var4 = pp_Var4 + 0x11;
      } while (iVar6 < p_Var2->numScaled);
    }
    iVar8 = iVar8 + 1;
    pp_Var7 = pp_Var7 + 0x13;
    if ((dir->scalable).used <= iVar8) {
      return;
    }
  } while( true );
}



void FontFileRemoveScaledInstance(FontEntryPtr entry,FontPtr pFont)

{
  long lVar1;
  FontPtr p_Var2;
  void *__ptr;
  _func_void_FontPtr *p_Var3;
  undefined8 uVar4;
  undefined8 uVar5;
  undefined8 uVar6;
  undefined8 uVar7;
  undefined8 uVar8;
  undefined8 uVar9;
  undefined8 uVar10;
  undefined8 uVar11;
  undefined8 uVar12;
  undefined8 uVar13;
  undefined8 uVar14;
  undefined8 uVar15;
  undefined8 uVar16;
  undefined8 uVar17;
  undefined8 uVar18;
  int iVar19;
  int iVar20;
  
  p_Var2 = (entry->u).bitmap.pFont;
  if (0 < *(int *)&p_Var2->unload_font) {
    iVar20 = 0;
    do {
      while( true ) {
        lVar1 = (long)iVar20 * 0x88;
        if (*(FontPtr *)(p_Var2->unload_glyphs + lVar1 + 0x80) == pFont) break;
        iVar19 = *(int *)&p_Var2->unload_font;
LAB_0010f5d5:
        iVar20 = iVar20 + 1;
        if (iVar19 <= iVar20) {
          return;
        }
      }
      __ptr = *(void **)(p_Var2->unload_glyphs + lVar1 + 0x70);
      if (__ptr != (void *)0x0) {
        free(__ptr);
      }
      iVar19 = *(int *)&p_Var2->unload_font + -1;
      *(int *)&p_Var2->unload_font = iVar19;
      if (iVar19 <= iVar20) goto LAB_0010f5d5;
      do {
        iVar19 = iVar20;
        p_Var3 = p_Var2->unload_glyphs;
        iVar20 = iVar19 + 1;
        uVar4 = *(undefined8 *)(p_Var3 + lVar1 + 0x88 + 8);
        uVar5 = *(undefined8 *)(p_Var3 + lVar1 + 0x98);
        uVar6 = *(undefined8 *)(p_Var3 + lVar1 + 0x98 + 8);
        uVar7 = *(undefined8 *)(p_Var3 + lVar1 + 0xa8);
        uVar8 = *(undefined8 *)(p_Var3 + lVar1 + 0xa8 + 8);
        uVar9 = *(undefined8 *)(p_Var3 + lVar1 + 0xb8);
        uVar10 = *(undefined8 *)(p_Var3 + lVar1 + 0xb8 + 8);
        uVar11 = *(undefined8 *)(p_Var3 + lVar1 + 200);
        uVar12 = *(undefined8 *)(p_Var3 + lVar1 + 200 + 8);
        uVar13 = *(undefined8 *)(p_Var3 + lVar1 + 0xd8);
        uVar14 = *(undefined8 *)(p_Var3 + lVar1 + 0xd8 + 8);
        *(undefined8 *)(p_Var3 + lVar1) = *(undefined8 *)(p_Var3 + lVar1 + 0x88);
        *(undefined8 *)(p_Var3 + lVar1 + 8) = uVar4;
        uVar15 = *(undefined8 *)(p_Var3 + lVar1 + 0xe8);
        uVar16 = *(undefined8 *)(p_Var3 + lVar1 + 0xe8 + 8);
        uVar17 = *(undefined8 *)(p_Var3 + lVar1 + 0xf8);
        uVar18 = *(undefined8 *)(p_Var3 + lVar1 + 0xf8 + 8);
        *(undefined8 *)(p_Var3 + lVar1 + 0x10) = uVar5;
        *(undefined8 *)(p_Var3 + lVar1 + 0x10 + 8) = uVar6;
        uVar4 = *(undefined8 *)(p_Var3 + lVar1 + 0x108);
        *(undefined8 *)(p_Var3 + lVar1 + 0x20) = uVar7;
        *(undefined8 *)(p_Var3 + lVar1 + 0x20 + 8) = uVar8;
        *(undefined8 *)(p_Var3 + lVar1 + 0x30) = uVar9;
        *(undefined8 *)(p_Var3 + lVar1 + 0x30 + 8) = uVar10;
        *(undefined8 *)(p_Var3 + lVar1 + 0x80) = uVar4;
        *(undefined8 *)(p_Var3 + lVar1 + 0x40) = uVar11;
        *(undefined8 *)(p_Var3 + lVar1 + 0x40 + 8) = uVar12;
        *(undefined8 *)(p_Var3 + lVar1 + 0x50) = uVar13;
        *(undefined8 *)(p_Var3 + lVar1 + 0x50 + 8) = uVar14;
        *(undefined8 *)(p_Var3 + lVar1 + 0x60) = uVar15;
        *(undefined8 *)(p_Var3 + lVar1 + 0x60 + 8) = uVar16;
        *(undefined8 *)(p_Var3 + lVar1 + 0x70) = uVar17;
        *(undefined8 *)(p_Var3 + lVar1 + 0x70 + 8) = uVar18;
        lVar1 = lVar1 + 0x88;
      } while (iVar20 < *(int *)&p_Var2->unload_font);
      iVar20 = iVar19 + 2;
    } while (iVar20 < *(int *)&p_Var2->unload_font);
  }
  return;
}



Bool FontFileCompleteXLFD(FontScalablePtr vals,FontScalablePtr def)

{
  ushort uVar1;
  uint uVar2;
  Bool BVar3;
  FontResolutionPtr p_Var4;
  uint uVar5;
  uint uVar6;
  long in_FS_OFFSET;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  int num_res;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  p_Var4 = GetClientResolutions(&num_res);
  uVar5 = vals->values_supplied;
  if (((uVar5 & 3) == 0) || ((uVar5 & 0xc) == 0)) {
    uVar2 = vals->x;
    uVar6 = vals->y;
    if (num_res == 0) {
LAB_0010f8d1:
      if ((int)uVar2 < 1) {
        uVar2 = def->x;
        vals->x = uVar2;
        if ((int)uVar6 < 1) goto LAB_0010f8df;
        if ((int)uVar2 < 1) goto LAB_0010f8f0;
      }
      else if ((int)uVar6 < 1) {
LAB_0010f8df:
        vals->y = def->y;
        goto LAB_0010f8e5;
      }
    }
    else {
      if ((int)uVar2 < 1) {
        uVar2 = (uint)p_Var4->x_resolution;
        vals->x = uVar2;
        if ((int)uVar6 < 1) goto LAB_0010f8ca;
        goto LAB_0010f8d1;
      }
      if ((int)uVar6 < 1) {
LAB_0010f8ca:
        uVar6 = (uint)p_Var4->y_resolution;
        vals->y = uVar6;
        goto LAB_0010f8d1;
      }
    }
LAB_0010f734:
    if ((uVar5 & 0xf) == 0) {
      if (num_res == 0) {
        if ((*(byte *)&def->values_supplied & 0xc) == 0) goto LAB_0010f8f0;
        vals->point_matrix[0] = def->point_matrix[0];
        vals->point_matrix[1] = def->point_matrix[1];
        vals->point_matrix[2] = def->point_matrix[2];
        vals->point_matrix[3] = def->point_matrix[3];
        uVar5 = uVar5 & 0xfffffff3 | def->values_supplied & 0xcU;
        vals->values_supplied = uVar5;
      }
      else {
        uVar1 = p_Var4->point_size;
        vals->point_matrix[2] = 0.0;
        uVar5 = uVar5 & 0xfffffff3 | 4;
        vals->point_matrix[1] = 0.0;
        vals->values_supplied = uVar5;
        dVar13 = (double)uVar1 / 10.0;
        vals->point_matrix[3] = dVar13;
        vals->point_matrix[0] = dVar13;
      }
    }
    dVar13 = 1.0;
    if ((uVar5 & 3) == 1) {
      uVar5 = uVar5 | 3;
      dVar13 = (double)(int)uVar2 / (double)(int)uVar6;
      vals->values_supplied = uVar5;
      vals->pixel_matrix[0] = vals->pixel_matrix[0] * dVar13;
    }
    dVar8 = (double)(int)uVar2 / 72.27;
    dVar9 = (double)(int)uVar6 / 72.27;
    if ((uVar5 & 0xc) == 0) goto LAB_0010f950;
    dVar7 = vals->point_matrix[0];
    dVar11 = vals->point_matrix[1];
    dVar12 = vals->point_matrix[2];
    dVar10 = vals->point_matrix[3];
    while( true ) {
      dVar7 = dVar7 * dVar8;
      if (((uVar5 & 3) != 0) &&
         ((((dVar13 < ABS(vals->pixel_matrix[0] - dVar7) ||
            (1.0 < ABS(vals->pixel_matrix[1] - dVar11 * dVar9))) ||
           (1.0 < ABS(vals->pixel_matrix[2] - dVar12 * dVar8))) ||
          (1.0 < ABS(vals->pixel_matrix[3] - dVar10 * dVar9))))) goto LAB_0010f8f0;
      if ((uVar5 & 0xf) != 6) break;
LAB_0010f950:
      if ((ABS(dVar8) < 1e-20) || (ABS(dVar9) < 1e-20)) goto LAB_0010f8f0;
      dVar7 = vals->pixel_matrix[0];
      dVar12 = vals->pixel_matrix[2];
      dVar10 = vals->pixel_matrix[3];
      dVar11 = vals->pixel_matrix[1] / dVar9;
      uVar2 = (uint)((vals->values_supplied & 3U) == 2) * 4 + 4;
      uVar5 = vals->values_supplied & 0xfffffff3U | uVar2;
      vals->values_supplied = uVar5;
      vals->point_matrix[1] = dVar11;
      dVar12 = dVar12 / dVar8;
      vals->point_matrix[0] = dVar7 / dVar8;
      dVar10 = dVar10 / dVar9;
      vals->point_matrix[2] = dVar12;
      vals->point_matrix[3] = dVar10;
      if (uVar2 != 4) goto LAB_0010f9e4;
      dVar7 = (double)(int)((dVar7 / dVar8) * 10.0 + 0.5) / 10.0;
      dVar10 = (double)(int)(dVar10 * 10.0 + 0.5) / 10.0;
      vals->point_matrix[0] = dVar7;
      vals->point_matrix[3] = dVar10;
    }
    vals->pixel_matrix[0] = dVar7;
    vals->pixel_matrix[1] = dVar11 * dVar9;
    vals->pixel_matrix[2] = dVar12 * dVar8;
    vals->pixel_matrix[3] = dVar10 * dVar9;
    vals->values_supplied = uVar5 & 0xfffffffc | ((uVar5 & 0xc) != 8) + 2;
LAB_0010f9e4:
    dVar13 = xlfd_round_double(dVar7);
    vals->pixel_matrix[0] = dVar13;
    dVar13 = xlfd_round_double(vals->pixel_matrix[1]);
    vals->pixel_matrix[1] = dVar13;
    dVar13 = xlfd_round_double(vals->pixel_matrix[2]);
    vals->pixel_matrix[2] = dVar13;
    dVar13 = xlfd_round_double(vals->pixel_matrix[3]);
    vals->pixel_matrix[3] = dVar13;
    dVar13 = xlfd_round_double(vals->point_matrix[0]);
    vals->point_matrix[0] = dVar13;
    dVar13 = xlfd_round_double(vals->point_matrix[1]);
    vals->point_matrix[1] = dVar13;
    dVar13 = xlfd_round_double(vals->point_matrix[2]);
    vals->point_matrix[2] = dVar13;
    dVar13 = xlfd_round_double(vals->point_matrix[3]);
    vals->point_matrix[3] = dVar13;
    vals->point = (int)(dVar13 * 10.0);
    vals->pixel = (int)vals->pixel_matrix[3];
    BVar3 = 1;
  }
  else {
    if (vals->y < 1) {
      dVar13 = hypot(vals->pixel_matrix[1],vals->pixel_matrix[3]);
      dVar8 = hypot(vals->point_matrix[1],vals->point_matrix[3]);
      if (1e-20 <= dVar8) {
        uVar2 = vals->x;
        vals->y = (int)((dVar13 * 72.27) / dVar8 + 0.5);
        if ((int)uVar2 < 1) {
          uVar5 = vals->values_supplied;
          goto LAB_0010fb30;
        }
LAB_0010f8e9:
        uVar6 = vals->y;
        if (0 < (int)uVar6) goto LAB_0010f943;
      }
    }
    else {
      uVar2 = vals->x;
      if (0 < (int)uVar2) {
        uVar6 = vals->y;
LAB_0010f943:
        uVar5 = vals->values_supplied;
        goto LAB_0010f734;
      }
LAB_0010fb30:
      if ((uVar5 & 2) == 0) {
        uVar2 = vals->y;
        vals->x = uVar2;
      }
      else {
        dVar13 = hypot(vals->pixel_matrix[0],vals->pixel_matrix[2]);
        dVar8 = hypot(vals->point_matrix[0],vals->point_matrix[2]);
        if (dVar8 < 1e-20) goto LAB_0010f8f0;
        uVar2 = (uint)((dVar13 * 72.27) / dVar8 + 0.5);
        vals->x = uVar2;
      }
LAB_0010f8e5:
      if (0 < (int)uVar2) goto LAB_0010f8e9;
    }
LAB_0010f8f0:
    BVar3 = 0;
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar3;
}



FontScaledPtr FontFileFindScaledInstance(FontEntryPtr entry,FontScalablePtr vals,int noSpecificSize)

{
  fsRange *pfVar1;
  int iVar2;
  uint uVar3;
  FontScalableExtraPtr p_Var4;
  long lVar5;
  long lVar6;
  FontScaledPtr p_Var7;
  int iVar8;
  fsRange *pfVar9;
  double *pdVar10;
  fsRange *pfVar11;
  int iVar12;
  FontScaledPtr p_Var13;
  double dVar14;
  double dVar15;
  double dVar16;
  double dVar17;
  double dVar18;
  
  p_Var4 = (entry->u).scalable.extra;
  iVar2 = p_Var4->numScaled;
  if (noSpecificSize != 0) {
    p_Var13 = (FontScaledPtr)0x0;
    if (iVar2 != 0) {
      p_Var13 = p_Var4->scaled;
      dVar18 = (p_Var13->vals).point_matrix[0] - vals->point_matrix[0];
      dVar14 = (p_Var13->vals).point_matrix[1] - vals->point_matrix[1];
      dVar16 = (p_Var13->vals).point_matrix[3] - vals->point_matrix[3];
      dVar15 = (p_Var13->vals).point_matrix[2] - vals->point_matrix[2];
      dVar14 = dVar15 * dVar15 + dVar18 * dVar18 + dVar14 * dVar14 + dVar16 * dVar16;
      if (1 < iVar2) {
        pdVar10 = p_Var13[1].vals.point_matrix;
        iVar12 = 0;
        iVar8 = 1;
        do {
          if (((pdVar10[0xb] == 0.0) || ((*(byte *)((long)pdVar10[0xb] + 0x13) & 2) != 0)) &&
             (dVar15 = *pdVar10 - vals->point_matrix[0], dVar17 = pdVar10[3] - vals->point_matrix[3]
             , dVar16 = pdVar10[1] - vals->point_matrix[1],
             dVar18 = pdVar10[2] - vals->point_matrix[2],
             dVar15 = (double)(int)(dVar18 * dVar18 + dVar15 * dVar15 + dVar16 * dVar16 +
                                   dVar17 * dVar17), dVar15 < dVar14)) {
            dVar14 = dVar15;
            iVar12 = iVar8;
          }
          iVar8 = iVar8 + 1;
          pdVar10 = pdVar10 + 0x11;
        } while (iVar8 != iVar2);
        p_Var13 = p_Var13 + iVar12;
      }
      if ((p_Var13->pFont != (FontPtr)0x0) && (((p_Var13->pFont->info).field_0xb & 2) == 0)) {
        p_Var13 = (FontScaledPtr)0x0;
      }
    }
    return p_Var13;
  }
  if (0 < iVar2) {
    p_Var7 = p_Var4->scaled;
    p_Var13 = p_Var7 + (ulong)(iVar2 - 1) + 1;
    do {
      if (((((p_Var7->pFont == (FontPtr)0x0) || (((p_Var7->pFont->info).field_0xb & 2) != 0)) &&
           ((lVar5._0_4_ = vals->x, lVar5._4_4_ = vals->y, lVar6._0_4_ = (p_Var7->vals).x,
            lVar6._4_4_ = (p_Var7->vals).y, lVar6 == lVar5 &&
            ((iVar2 = (p_Var7->vals).width, iVar2 == vals->width || iVar2 == 0 ||
             (vals->width + 1U < 2)))))) &&
          ((uVar3 = vals->values_supplied, (uVar3 & 3) == 0 ||
           ((((((((p_Var7->vals).values_supplied ^ uVar3) & 3) == 0 && (true)) &&
              ((p_Var7->vals).pixel_matrix[0] == vals->pixel_matrix[0])) &&
             ((true && ((p_Var7->vals).pixel_matrix[1] == vals->pixel_matrix[1])))) &&
            (((true && (((p_Var7->vals).pixel_matrix[2] == vals->pixel_matrix[2] && (true)))) &&
             ((p_Var7->vals).pixel_matrix[3] == vals->pixel_matrix[3])))))))) &&
         (((uVar3 & 0xc) == 0 ||
          ((((((((uVar3 ^ (p_Var7->vals).values_supplied) & 0xc) == 0 && (true)) &&
              ((p_Var7->vals).point_matrix[0] == vals->point_matrix[0])) &&
             ((true && ((p_Var7->vals).point_matrix[1] == vals->point_matrix[1])))) &&
            ((true && (((p_Var7->vals).point_matrix[2] == vals->point_matrix[2] && (true)))))) &&
           ((p_Var7->vals).point_matrix[3] == vals->point_matrix[3])))))) {
        iVar2 = (p_Var7->vals).nranges;
        if (iVar2 == 0) {
          return p_Var7;
        }
        if (iVar2 == vals->nranges) {
          if (iVar2 < 1) {
            return p_Var7;
          }
          pfVar11 = (p_Var7->vals).ranges;
          pfVar9 = vals->ranges;
          pfVar1 = pfVar11 + (ulong)(iVar2 - 1) + 1;
          while ((((pfVar11->min_char_low == pfVar9->min_char_low &&
                   (pfVar11->min_char_high == pfVar9->min_char_high)) &&
                  (pfVar11->max_char_low == pfVar9->max_char_low)) &&
                 (pfVar11->max_char_high == pfVar9->max_char_high))) {
            pfVar11 = pfVar11 + 1;
            pfVar9 = pfVar9 + 1;
            if (pfVar1 == pfVar11) {
              return p_Var7;
            }
          }
        }
      }
      p_Var7 = p_Var7 + 1;
    } while (p_Var7 != p_Var13);
  }
  return (FontScaledPtr)0x0;
}



int BufZipFileSkip(BufFilePtr f,int c)

{
  int iVar1;
  int iVar2;
  
  iVar2 = c;
  if (c != 0) {
    do {
      iVar1 = f->left;
      f->left = iVar1 + -1;
      if (iVar1 == 0) {
        iVar1 = (*f->input)(f);
        f->eof = iVar1;
        if (iVar1 == -1) {
          return -1;
        }
      }
      else {
        f->bufp = f->bufp + 1;
      }
      iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
  }
  return c;
}



int BufZipFileClose(BufFilePtr f,int flag)

{
  char *__ptr;
  
  __ptr = f->private;
  inflateEnd(__ptr);
  BufFileClose(*(BufFilePtr *)(__ptr + 0x4078),flag);
  free(__ptr);
  return 1;
}



int BufZipFileFill(BufFilePtr f)

{
  long *plVar1;
  byte *pbVar2;
  long lVar3;
  int iVar4;
  uint uVar5;
  long lVar6;
  int iVar7;
  
  if (-1 < f->left) {
    f->left = f->left + -1;
    pbVar2 = f->bufp;
    f->bufp = pbVar2 + 1;
    return (uint)*pbVar2;
  }
  plVar1 = (long *)f->private;
  uVar5 = *(uint *)(plVar1 + 0xe);
  if (uVar5 != 0) {
    if ((int)uVar5 < 1) {
      if ((uVar5 & 0xfffffffd) != 0xfffffffd) {
        return -1;
      }
    }
    else if (uVar5 != 1) {
      return -1;
    }
    f->left = 0;
    return -1;
  }
  *(undefined4 *)(plVar1 + 4) = 0x2000;
  plVar1[3] = (long)plVar1 + 0x74;
  do {
    if (*(int *)(plVar1 + 1) == 0) {
      lVar6 = 0;
      do {
        iVar7 = (int)lVar6;
        iVar4 = *(int *)(plVar1[0x80f] + 8);
        *(int *)(plVar1[0x80f] + 8) = iVar4 + -1;
        if (iVar4 == 0) {
          lVar3 = plVar1[0x80f];
          uVar5 = (**(code **)(lVar3 + 0x2010))(lVar3);
          *(uint *)(lVar3 + 0xc) = uVar5;
          if (uVar5 == 0xffffffff) goto LAB_0011010a;
        }
        else {
          pbVar2 = *(byte **)plVar1[0x80f];
          *(byte **)plVar1[0x80f] = pbVar2 + 1;
          uVar5 = (uint)*pbVar2;
        }
        *(char *)((long)plVar1 + lVar6 + 0x2074) = (char)uVar5;
        lVar6 = lVar6 + 1;
      } while (lVar6 != 0x2000);
      iVar7 = 0x2000;
LAB_0011010a:
      *(int *)(plVar1 + 1) = *(int *)(plVar1 + 1) + iVar7;
      *plVar1 = (long)plVar1 + 0x2074;
    }
    iVar4 = inflate(plVar1,0);
    *(int *)(plVar1 + 0xe) = iVar4;
    if ((iVar4 != 0) || (*(int *)(plVar1 + 4) == 0)) {
      f->bufp = (BufChar *)((long)plVar1 + 0x74);
      iVar4 = -*(int *)(plVar1 + 4) + 0x2000;
      if (iVar4 < 0) {
        f->left = iVar4;
        return -1;
      }
      f->left = -*(int *)(plVar1 + 4) + 0x1fff;
      f->bufp = (BufChar *)((long)plVar1 + 0x75);
      return (uint)*(byte *)((long)plVar1 + 0x74);
    }
  } while( true );
}



BufFilePtr BufFilePushZIP(BufFilePtr f)

{
  long *plVar1;
  byte *pbVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  char *private;
  BufFilePtr p_Var8;
  
  private = (char *)malloc(0x4080);
  if (private == (char *)0x0) {
    return (BufFilePtr)0x0;
  }
  private[0x40] = '\0';
  private[0x41] = '\0';
  private[0x42] = '\0';
  private[0x43] = '\0';
  private[0x44] = '\0';
  private[0x45] = '\0';
  private[0x46] = '\0';
  private[0x47] = '\0';
  private[0x48] = '\0';
  private[0x49] = '\0';
  private[0x4a] = '\0';
  private[0x4b] = '\0';
  private[0x4c] = '\0';
  private[0x4d] = '\0';
  private[0x4e] = '\0';
  private[0x4f] = '\0';
  private[0x50] = '\0';
  private[0x51] = '\0';
  private[0x52] = '\0';
  private[0x53] = '\0';
  private[0x54] = '\0';
  private[0x55] = '\0';
  private[0x56] = '\0';
  private[0x57] = '\0';
  *(BufFilePtr *)(private + 0x4078) = f;
  private[0] = '\0';
  private[1] = '\0';
  private[2] = '\0';
  private[3] = '\0';
  private[4] = '\0';
  private[5] = '\0';
  private[6] = '\0';
  private[7] = '\0';
  private[0x18] = '\0';
  private[0x19] = '\0';
  private[0x1a] = '\0';
  private[0x1b] = '\0';
  private[0x1c] = '\0';
  private[0x1d] = '\0';
  private[0x1e] = '\0';
  private[0x1f] = '\0';
  private[0x20] = '\0';
  private[0x21] = '\0';
  private[0x22] = '\0';
  private[0x23] = '\0';
  private[8] = '\0';
  private[9] = '\0';
  private[10] = '\0';
  private[0xb] = '\0';
  iVar3 = inflateInit2_(private,0xfffffff1,"1.2.11",0x70);
  *(int *)(private + 0x70) = iVar3;
  if (iVar3 == 0) {
    plVar1 = *(long **)(private + 0x4078);
    private[0x20] = '\0';
    private[0x21] = ' ';
    private[0x22] = '\0';
    private[0x23] = '\0';
    *(char **)(private + 0x18) = private + 0x2074;
    private[8] = '\0';
    private[9] = '\0';
    private[10] = '\0';
    private[0xb] = '\0';
    iVar3 = *(int *)(plVar1 + 1);
    *(int *)(plVar1 + 1) = iVar3 + -1;
    if (iVar3 == 0) {
      uVar4 = (*(code *)plVar1[0x402])(plVar1);
      *(uint *)((long)plVar1 + 0xc) = uVar4;
      if (uVar4 == 0xffffffff) goto LAB_001103d0;
    }
    else {
      pbVar2 = (byte *)*plVar1;
      *plVar1 = (long)(pbVar2 + 1);
      uVar4 = (uint)*pbVar2;
    }
    if (uVar4 == 0x1f) {
      iVar3 = *(int *)(plVar1 + 1);
      *(int *)(plVar1 + 1) = iVar3 + -1;
      if (iVar3 == 0) {
        uVar4 = (*(code *)plVar1[0x402])(plVar1);
        *(uint *)((long)plVar1 + 0xc) = uVar4;
        if (uVar4 == 0xffffffff) goto LAB_001103d0;
      }
      else {
        pbVar2 = (byte *)*plVar1;
        *plVar1 = (long)(pbVar2 + 1);
        uVar4 = (uint)*pbVar2;
      }
      if (uVar4 == 0x8b) {
        iVar3 = *(int *)(plVar1 + 1);
        *(int *)(plVar1 + 1) = iVar3 + -1;
        if (iVar3 == 0) {
          uVar4 = (*(code *)plVar1[0x402])(plVar1);
          *(uint *)((long)plVar1 + 0xc) = uVar4;
          if (uVar4 == 0xffffffff) goto LAB_001103d0;
        }
        else {
          pbVar2 = (byte *)*plVar1;
          *plVar1 = (long)(pbVar2 + 1);
          uVar4 = (uint)*pbVar2;
        }
        if (uVar4 == 8) {
          iVar3 = *(int *)(plVar1 + 1);
          *(int *)(plVar1 + 1) = iVar3 + -1;
          if (iVar3 == 0) {
            uVar4 = (*(code *)plVar1[0x402])(plVar1);
            *(uint *)((long)plVar1 + 0xc) = uVar4;
            if (uVar4 == 0xffffffff) goto LAB_001103d0;
          }
          else {
            pbVar2 = (byte *)*plVar1;
            *plVar1 = (long)(pbVar2 + 1);
            uVar4 = (uint)*pbVar2;
          }
          if ((uVar4 & 0xe0) == 0) {
            iVar3 = *(int *)(plVar1 + 1);
            iVar5 = iVar3 + -1;
            *(int *)(plVar1 + 1) = iVar5;
            if (iVar3 == 0) {
              iVar3 = (*(code *)plVar1[0x402])(plVar1);
              *(int *)((long)plVar1 + 0xc) = iVar3;
              if (iVar3 == -1) goto LAB_001103d0;
              iVar5 = *(int *)(plVar1 + 1);
            }
            else {
              *plVar1 = *plVar1 + 1;
            }
            iVar3 = iVar5 + -1;
            *(int *)(plVar1 + 1) = iVar3;
            if (iVar5 == 0) {
              iVar3 = (*(code *)plVar1[0x402])(plVar1);
              *(int *)((long)plVar1 + 0xc) = iVar3;
              if (iVar3 == -1) goto LAB_001103d0;
              iVar3 = *(int *)(plVar1 + 1);
            }
            else {
              *plVar1 = *plVar1 + 1;
            }
            iVar5 = iVar3 + -1;
            *(int *)(plVar1 + 1) = iVar5;
            if (iVar3 == 0) {
              iVar3 = (*(code *)plVar1[0x402])(plVar1);
              *(int *)((long)plVar1 + 0xc) = iVar3;
              if (iVar3 == -1) goto LAB_001103d0;
              iVar5 = *(int *)(plVar1 + 1);
            }
            else {
              *plVar1 = *plVar1 + 1;
            }
            iVar3 = iVar5 + -1;
            *(int *)(plVar1 + 1) = iVar3;
            if (iVar5 == 0) {
              iVar3 = (*(code *)plVar1[0x402])(plVar1);
              *(int *)((long)plVar1 + 0xc) = iVar3;
              if (iVar3 == -1) goto LAB_001103d0;
              iVar3 = *(int *)(plVar1 + 1);
            }
            else {
              *plVar1 = *plVar1 + 1;
            }
            iVar5 = iVar3 + -1;
            *(int *)(plVar1 + 1) = iVar5;
            if (iVar3 == 0) {
              iVar3 = (*(code *)plVar1[0x402])(plVar1);
              *(int *)((long)plVar1 + 0xc) = iVar3;
              if (iVar3 == -1) goto LAB_001103d0;
              iVar5 = *(int *)(plVar1 + 1);
            }
            else {
              *plVar1 = *plVar1 + 1;
            }
            *(int *)(plVar1 + 1) = iVar5 + -1;
            if (iVar5 == 0) {
              iVar3 = (*(code *)plVar1[0x402])(plVar1);
              *(int *)((long)plVar1 + 0xc) = iVar3;
              if (iVar3 == -1) goto LAB_001103d0;
            }
            else {
              *plVar1 = *plVar1 + 1;
            }
            if ((uVar4 & 4) != 0) {
              iVar5 = *(int *)(plVar1 + 1);
              iVar3 = iVar5 + -1;
              *(int *)(plVar1 + 1) = iVar3;
              if (iVar5 == 0) {
                uVar6 = (*(code *)plVar1[0x402])(plVar1);
                *(uint *)((long)plVar1 + 0xc) = uVar6;
                if (uVar6 == 0xffffffff) goto LAB_001103d0;
                iVar3 = *(int *)(plVar1 + 1);
              }
              else {
                pbVar2 = (byte *)*plVar1;
                *plVar1 = (long)(pbVar2 + 1);
                uVar6 = (uint)*pbVar2;
              }
              *(int *)(plVar1 + 1) = iVar3 + -1;
              if (iVar3 == 0) {
                uVar7 = (*(code *)plVar1[0x402])(plVar1);
                *(uint *)((long)plVar1 + 0xc) = uVar7;
                if (uVar7 == 0xffffffff) goto LAB_001103d0;
              }
              else {
                pbVar2 = (byte *)*plVar1;
                *plVar1 = (long)(pbVar2 + 1);
                uVar7 = (uint)*pbVar2;
              }
              iVar5 = uVar7 * 0x100 + uVar6;
              iVar3 = iVar5 + -1;
              if (-1 < iVar5) {
                do {
                  iVar5 = *(int *)(plVar1 + 1);
                  *(int *)(plVar1 + 1) = iVar5 + -1;
                  if (iVar5 == 0) {
                    iVar5 = (*(code *)plVar1[0x402])(plVar1);
                    *(int *)((long)plVar1 + 0xc) = iVar5;
                    if (iVar5 == -1) goto LAB_001103d0;
                  }
                  else {
                    *plVar1 = *plVar1 + 1;
                  }
                  iVar3 = iVar3 + -1;
                } while (iVar3 != -2);
              }
            }
            uVar6 = uVar4 & 8;
            do {
              while( true ) {
                if (uVar6 == 0) {
                  uVar6 = uVar4 & 0x10;
                  goto joined_r0x00110442;
                }
                iVar3 = *(int *)(plVar1 + 1);
                *(int *)(plVar1 + 1) = iVar3 + -1;
                if (iVar3 == 0) break;
                pbVar2 = (byte *)*plVar1;
                *plVar1 = (long)(pbVar2 + 1);
                uVar6 = (uint)*pbVar2;
              }
              uVar6 = (*(code *)plVar1[0x402])(plVar1);
              *(uint *)((long)plVar1 + 0xc) = uVar6;
            } while (uVar6 != 0xffffffff);
          }
        }
      }
    }
  }
  goto LAB_001103d0;
  while( true ) {
    uVar6 = (*(code *)plVar1[0x402])(plVar1);
    *(uint *)((long)plVar1 + 0xc) = uVar6;
    if (uVar6 == 0xffffffff) break;
joined_r0x00110442:
    if (uVar6 == 0) {
      if ((uVar4 & 2) != 0) {
        iVar3 = *(int *)(plVar1 + 1);
        iVar5 = iVar3 + -1;
        *(int *)(plVar1 + 1) = iVar5;
        if (iVar3 == 0) {
          iVar3 = (*(code *)plVar1[0x402])(plVar1);
          *(int *)((long)plVar1 + 0xc) = iVar3;
          if (iVar3 == -1) break;
          iVar5 = *(int *)(plVar1 + 1);
        }
        else {
          *plVar1 = *plVar1 + 1;
        }
        *(int *)(plVar1 + 1) = iVar5 + -1;
        if (iVar5 == 0) {
          iVar3 = (*(code *)plVar1[0x402])(plVar1);
          *(int *)((long)plVar1 + 0xc) = iVar3;
          if (iVar3 == -1) break;
        }
        else {
          *plVar1 = *plVar1 + 1;
        }
      }
      p_Var8 = BufFileCreate(private,BufZipFileFill,(_func_int_int_BufFilePtr *)0x0,BufZipFileSkip,
                             BufZipFileClose);
      return p_Var8;
    }
    iVar3 = *(int *)(plVar1 + 1);
    *(int *)(plVar1 + 1) = iVar3 + -1;
    if (iVar3 != 0) {
      pbVar2 = (byte *)*plVar1;
      *plVar1 = (long)(pbVar2 + 1);
      uVar6 = (uint)*pbVar2;
      goto joined_r0x00110442;
    }
  }
LAB_001103d0:
  free(private);
  return (BufFilePtr)0x0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void FontFileRegisterFpeFunctions(void)

{
  BitmapRegisterFontFileFunctions();
  FreeTypeRegisterFontFileFunctions();
  FontFileRegisterLocalFpeFunctions();
  CatalogueRegisterLocalFpeFunctions();
  return;
}



Bool FontFilePriorityRegisterRenderer(FontRendererPtr renderer,int priority)

{
  char *__s2;
  ulong uVar1;
  int iVar2;
  _FontRenderersElement *p_Var3;
  int iVar4;
  _FontRenderersElement *p_Var5;
  size_t __size;
  Bool BVar6;
  int iVar7;
  
  p_Var3 = renderers.renderers;
  iVar4 = renderers.number;
  uVar1 = rendererGeneration;
  if (rendererGeneration == serverGeneration) {
    if (renderers.number < 1) {
      __size = 0x10;
      iVar2 = 1;
      iVar4 = 0;
    }
    else {
      iVar7 = 0;
      __s2 = renderer->fileSuffix;
      p_Var5 = renderers.renderers;
      do {
        iVar2 = strcasecmp(p_Var5->renderer->fileSuffix,__s2);
        if (iVar2 == 0) {
          if (priority <= p_Var5->priority) {
            if (p_Var5->priority != priority) {
              return 1;
            }
            if (uVar1 != 1) {
              return 1;
            }
            ErrorF("Warning: font renderer for \"%s\" already registered at priority %d\n",__s2,
                   (ulong)(uint)priority);
            return 1;
          }
          if (iVar7 < iVar4) goto LAB_00110793;
          iVar2 = iVar7 + 1;
          __size = (long)iVar2 << 4;
          iVar4 = iVar7;
          goto LAB_00110706;
        }
        iVar7 = iVar7 + 1;
        p_Var5 = p_Var5 + 1;
      } while (iVar4 != iVar7);
      iVar2 = iVar4 + 1;
      __size = (long)iVar2 << 4;
    }
  }
  else {
    rendererGeneration = serverGeneration;
    renderers.number = 0;
    if (renderers.renderers != (_FontRenderersElement *)0x0) {
      free(renderers.renderers);
    }
    p_Var3 = (_FontRenderersElement *)0x0;
    __size = 0x10;
    iVar2 = 1;
    renderers.renderers = (_FontRenderersElement *)0x0;
    iVar4 = 0;
  }
LAB_00110706:
  p_Var3 = (_FontRenderersElement *)realloc(p_Var3,__size);
  if (p_Var3 == (_FontRenderersElement *)0x0) {
    BVar6 = 0;
  }
  else {
    p_Var5 = p_Var3 + iVar4;
    iVar7 = iVar4;
    renderers.number = iVar2;
    renderers.renderers = p_Var3;
LAB_00110793:
    BVar6 = 1;
    renderer->number = iVar7;
    p_Var5->renderer = renderer;
    p_Var5->priority = priority;
  }
  return BVar6;
}



Bool FontFileRegisterRenderer(FontRendererPtr renderer)

{
  Bool BVar1;
  
  BVar1 = FontFilePriorityRegisterRenderer(renderer,0);
  return BVar1;
}



FontRendererPtr FontFileMatchRenderer(char *fileName)

{
  _FontRenderersElement *p_Var1;
  FontRendererPtr p_Var2;
  int iVar3;
  size_t sVar4;
  _FontRenderersElement *p_Var5;
  
  sVar4 = strlen(fileName);
  if (0 < renderers.number) {
    p_Var1 = renderers.renderers + (ulong)(renderers.number - 1) + 1;
    p_Var5 = renderers.renderers;
    do {
      p_Var2 = p_Var5->renderer;
      if ((p_Var2->fileSuffixLen <= (int)sVar4) &&
         (iVar3 = strcasecmp(fileName + ((long)(int)sVar4 - (long)p_Var2->fileSuffixLen),
                             p_Var2->fileSuffix), iVar3 == 0)) {
        return p_Var2;
      }
      p_Var5 = p_Var5 + 1;
    } while (p_Var1 != p_Var5);
  }
  return (FontRendererPtr)0x0;
}



// WARNING: Unknown calling convention

int CatalogueResetFPE(FontPathElementPtr fpe)

{
  return 0x59;
}



int CatalogueListNextFontOrAlias
              (pointer client,FontPathElementPtr fpe,char **namep,int *namelenp,char **resolvedp,
              int *resolvedlenp,pointer private)

{
  int iVar1;
  void *pvVar2;
  
  pvVar2 = fpe->private;
  iVar1 = *(int *)((long)private + 8);
  if (iVar1 != *(int *)((long)pvVar2 + 8)) {
    do {
                    // WARNING: Load size is inaccurate
      iVar1 = FontFileListNextFontOrAlias
                        (client,*(FontPathElementPtr *)
                                 (*(long *)((long)pvVar2 + 0x10) + (long)iVar1 * 8),namep,namelenp,
                         resolvedp,resolvedlenp,*(pointer *)(*private + (long)iVar1 * 8));
      if (iVar1 != 0x53) {
        return iVar1;
      }
      iVar1 = *(int *)((long)private + 8) + 1;
      *(int *)((long)private + 8) = iVar1;
      pvVar2 = fpe->private;
    } while (*(int *)((long)pvVar2 + 8) != iVar1);
  }
  free(private);
  return 0x53;
}



int ComparePriority(void *p1,void *p2)

{
  char *pcVar1;
  char *pcVar2;
  long lVar3;
  long lVar4;
  int iVar5;
  
                    // WARNING: Load size is inaccurate
  lVar3 = *(long *)(*p2 + 0x18);
                    // WARNING: Load size is inaccurate
  pcVar2 = *(char **)(*(long *)(*p1 + 0x18) + 0x48);
  if (pcVar2 == (char *)0x0) {
    pcVar2 = *(char **)(lVar3 + 0x48);
    pcVar1 = (char *)0x0;
    if (pcVar2 == (char *)0x0) {
      return 0;
    }
  }
  else {
    pcVar1 = strstr(pcVar2,"pri=");
    pcVar2 = *(char **)(lVar3 + 0x48);
    if (pcVar2 == (char *)0x0) {
      return -(uint)(pcVar1 != (char *)0x0);
    }
  }
  pcVar2 = strstr(pcVar2,"pri=");
  iVar5 = 0;
  if (pcVar2 != (char *)0x0 || pcVar1 != (char *)0x0) {
    if (pcVar1 == (char *)0x0) {
      iVar5 = 1;
    }
    else if (pcVar2 == (char *)0x0) {
      iVar5 = -1;
    }
    else {
      lVar3 = strtol(pcVar1 + 4,(char **)0x0,10);
      lVar4 = strtol(pcVar2 + 4,(char **)0x0,10);
      iVar5 = (int)lVar3 - (int)lVar4;
    }
  }
  return iVar5;
}



int CatalogueListNextFontWithInfo
              (pointer client,FontPathElementPtr fpe,char **namep,int *namelenp,
              FontInfoPtr *pFontInfo,int *numFonts,pointer private)

{
  int iVar1;
  void *pvVar2;
  
  pvVar2 = fpe->private;
  iVar1 = *(int *)((long)private + 8);
  if (iVar1 != *(int *)((long)pvVar2 + 8)) {
    do {
                    // WARNING: Load size is inaccurate
      iVar1 = FontFileListNextFontWithInfo
                        (client,*(FontPathElementPtr *)
                                 (*(long *)((long)pvVar2 + 0x10) + (long)iVar1 * 8),namep,namelenp,
                         pFontInfo,numFonts,*(pointer *)(*private + (long)iVar1 * 8));
      if (iVar1 != 0x53) {
        return iVar1;
      }
      iVar1 = *(int *)((long)private + 8) + 1;
      *(int *)((long)private + 8) = iVar1;
      pvVar2 = fpe->private;
    } while (*(int *)((long)pvVar2 + 8) != iVar1);
  }
  free(private);
  return 0x53;
}



void CatalogueCloseFont(FontPathElementPtr fpe,FontPtr pFont)

{
  FontFileCloseFont(fpe,pFont);
  return;
}



int CatalogueNameCheck(char *name)

{
  int iVar1;
  
  iVar1 = strncmp(name,"catalogue:",10);
  return (int)(iVar1 == 0);
}



void CatalogueUnrefFPEs(FontPathElementPtr fpe)

{
  int *piVar1;
  FontPathElementPtr fpe_00;
  long lVar2;
  
  if (0 < *(int *)&fpe->name) {
    lVar2 = 0;
    do {
      while( true ) {
        fpe_00 = *(FontPathElementPtr *)(*(long *)&fpe->type + lVar2 * 8);
        piVar1 = &fpe_00->refcount;
        *piVar1 = *piVar1 + -1;
        if (*piVar1 != 0) break;
        lVar2 = lVar2 + 1;
        FontFileFreeFPE(fpe_00);
        free(fpe_00->name);
        free(fpe_00);
        if (*(int *)&fpe->name <= (int)lVar2) goto LAB_00110ba6;
      }
      lVar2 = lVar2 + 1;
    } while ((int)lVar2 < *(int *)&fpe->name);
  }
LAB_00110ba6:
  *(undefined4 *)&fpe->name = 0;
  return;
}



int CatalogueRescan(FontPathElementPtr fpe,Bool forceScan)

{
  char *__filename;
  long *__ptr;
  long lVar1;
  int iVar2;
  DIR *__dirp;
  dirent *pdVar3;
  ssize_t sVar4;
  size_t sVar5;
  char *pcVar6;
  FontPathElementPtr fpe_00;
  void *pvVar7;
  int iVar8;
  long lVar9;
  long in_FS_OFFSET;
  stat statbuf;
  char link [1024];
  char dest [1024];
  
  __ptr = (long *)fpe->private;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  __filename = fpe->name + 10;
  iVar2 = __xstat(1,__filename,(stat *)&statbuf);
  iVar8 = 0x56;
  if (((-1 < iVar2) && ((statbuf.st_mode & 0xf000) == 0x4000)) &&
     ((forceScan != 0 || (iVar8 = 0x55, *__ptr < statbuf.st_mtim.tv_sec)))) {
    __dirp = opendir(__filename);
    if (__dirp == (DIR *)0x0) {
      free(__ptr);
      iVar8 = 0x56;
    }
    else {
      CatalogueUnrefFPEs((FontPathElementPtr)fpe->private);
LAB_00110c98:
      pdVar3 = readdir(__dirp);
      if (pdVar3 != (dirent *)0x0) {
        while( true ) {
          __snprintf_chk(link,0x400,1,0x400,"%s/%s",__filename,pdVar3->d_name);
          sVar4 = readlink(link,dest,0x3ff);
          iVar2 = (int)sVar4;
          if (iVar2 < 0) break;
          dest[iVar2] = '\0';
          if (dest[0] != '/') {
            sVar5 = strlen(__filename);
            lVar9 = (long)(int)sVar5;
            memmove(dest + lVar9 + 1,dest,0x3ff - lVar9);
            __memcpy_chk(dest,__filename,lVar9,0x400);
            dest[lVar9] = '/';
            iVar2 = iVar2 + 1 + (int)sVar5;
          }
          pcVar6 = strchr(link,0x3a);
          if (pcVar6 != (char *)0x0) {
            lVar9 = (long)iVar2;
            sVar5 = strlen(pcVar6);
            if (lVar9 + sVar5 < 0x400) {
              iVar2 = iVar2 + (int)sVar5;
              memcpy(dest + lVar9,pcVar6,sVar5);
            }
          }
          fpe_00 = (FontPathElementPtr)malloc(0x20);
          if (fpe_00 == (FontPathElementPtr)0x0) break;
          iVar8 = fpe->type;
          fpe_00->name_length = iVar2;
          fpe_00->type = iVar8;
          pcVar6 = (char *)malloc((long)(iVar2 + 1));
          fpe_00->name = pcVar6;
          if (pcVar6 != (char *)0x0) {
            pvVar7 = memcpy(pcVar6,dest,(long)iVar2);
            fpe_00->refcount = 1;
            *(undefined *)((long)pvVar7 + (long)iVar2) = 0;
            iVar2 = FontFileInitFPE(fpe_00);
            if (iVar2 == 0x55) {
              iVar8 = *(int *)(__ptr + 1);
              iVar2 = *(int *)((long)__ptr + 0xc);
              pvVar7 = (void *)__ptr[2];
              if (iVar2 <= iVar8) {
                if (iVar2 == 0) {
                  sVar5 = 0x80;
                  iVar2 = 0x10;
                }
                else {
                  iVar2 = iVar2 * 2;
                  sVar5 = (long)iVar2 << 3;
                }
                *(int *)((long)__ptr + 0xc) = iVar2;
                pvVar7 = realloc(pvVar7,sVar5);
                if (pvVar7 == (void *)0x0) {
                  FontFileFreeFPE(fpe_00);
                  free(fpe_00);
                  break;
                }
                __ptr[2] = (long)pvVar7;
                iVar8 = *(int *)(__ptr + 1);
              }
              *(int *)(__ptr + 1) = iVar8 + 1;
              *(FontPathElementPtr *)((long)pvVar7 + (long)iVar8 * 8) = fpe_00;
              break;
            }
            free(fpe_00->name);
          }
          free(fpe_00);
          pdVar3 = readdir(__dirp);
          if (pdVar3 == (dirent *)0x0) goto LAB_00110e1a;
        }
        goto LAB_00110c98;
      }
LAB_00110e1a:
      closedir(__dirp);
      qsort((void *)__ptr[2],(long)*(int *)(__ptr + 1),8,ComparePriority);
      iVar8 = 0x55;
      *__ptr = statbuf.st_mtim.tv_sec;
    }
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar8;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int CatalogueStartListFonts
              (pointer client,FontPathElementPtr fpe,char *pat,int len,int max,pointer *privatep,
              int mark_aliases)

{
  void *pvVar1;
  int iVar2;
  long *__ptr;
  long *plVar3;
  long lVar4;
  
  pvVar1 = fpe->private;
  CatalogueRescan(fpe,0);
  __ptr = (long *)malloc((long)*(int *)((long)pvVar1 + 8) * 8 + 0x10);
  if (__ptr == (long *)0x0) {
    iVar2 = 0x50;
  }
  else {
    plVar3 = __ptr + 2;
    *__ptr = (long)plVar3;
    if (0 < *(int *)((long)pvVar1 + 8)) {
      lVar4 = 0;
      while( true ) {
        iVar2 = FontFileStartListFonts
                          (client,*(FontPathElementPtr *)
                                   (*(long *)((long)pvVar1 + 0x10) + lVar4 * 8),pat,len,max,
                           (pointer *)((long)plVar3 + lVar4 * 8),mark_aliases);
        if (iVar2 != 0x55) {
          free(__ptr);
          return 0x50;
        }
        lVar4 = lVar4 + 1;
        if (*(int *)((long)pvVar1 + 8) <= (int)lVar4) break;
        plVar3 = (long *)*__ptr;
      }
    }
    *(undefined4 *)(__ptr + 1) = 0;
    *privatep = __ptr;
    iVar2 = 0x55;
  }
  return iVar2;
}



int CatalogueStartListFontsAndAliases
              (pointer client,FontPathElementPtr fpe,char *pat,int len,int max,pointer *privatep)

{
  int iVar1;
  
  iVar1 = CatalogueStartListFonts(client,fpe,pat,len,max,privatep,1);
  return iVar1;
}



int CatalogueStartListFontsWithInfo
              (pointer client,FontPathElementPtr fpe,char *pat,int len,int max,pointer *privatep)

{
  int iVar1;
  
  iVar1 = CatalogueStartListFonts(client,fpe,pat,len,max,privatep,0);
  return iVar1;
}



int CatalogueInitFPE(FontPathElementPtr fpe)

{
  int iVar1;
  undefined8 *puVar2;
  
  puVar2 = (undefined8 *)malloc(0x18);
  if (puVar2 != (undefined8 *)0x0) {
    fpe->private = puVar2;
    *puVar2 = 0;
    puVar2[1] = 0;
    puVar2[2] = 0;
    iVar1 = CatalogueRescan(fpe,1);
    return iVar1;
  }
  return 0x50;
}



int CatalogueListFonts(pointer client,FontPathElementPtr fpe,char *pat,int len,int max,
                      FontNamesPtr names)

{
  long lVar1;
  void *pvVar2;
  long lVar3;
  
  pvVar2 = fpe->private;
  CatalogueRescan(fpe,0);
  if (0 < *(int *)((long)pvVar2 + 8)) {
    lVar3 = 0;
    do {
      lVar1 = lVar3 * 8;
      lVar3 = lVar3 + 1;
      FontFileListFonts(client,*(FontPathElementPtr *)(*(long *)((long)pvVar2 + 0x10) + lVar1),pat,
                        len,max,names);
    } while ((int)lVar3 < *(int *)((long)pvVar2 + 8));
  }
  return 0x55;
}



int CatalogueOpenFont(pointer client,FontPathElementPtr fpe,Mask flags,char *name,int namelen,
                     fsBitmapFormat format,fsBitmapFormatMask fmask,XID id,FontPtr *pFont,
                     char **aliasName,FontPtr non_cachable_font)

{
  void *pvVar1;
  int iVar2;
  long lVar3;
  
  pvVar1 = fpe->private;
  CatalogueRescan(fpe,0);
  if (0 < *(int *)((long)pvVar1 + 8)) {
    lVar3 = 0;
    do {
      iVar2 = FontFileOpenFont(client,*(FontPathElementPtr *)
                                       (*(long *)((long)pvVar1 + 0x10) + lVar3 * 8),flags,name,
                               namelen,format,fmask,id,pFont,aliasName,non_cachable_font);
      if (iVar2 == 0x55) {
        return 0x55;
      }
      if (iVar2 == 0x52) {
        return 0x52;
      }
      lVar3 = lVar3 + 1;
    } while ((int)lVar3 < *(int *)((long)pvVar1 + 8));
  }
  return 0x53;
}



int CatalogueFreeFPE(FontPathElementPtr fpe)

{
  FontPathElementPtr fpe_00;
  int iVar1;
  
  iVar1 = strncmp(fpe->name,"catalogue:",10);
  if (iVar1 == 0) {
    fpe_00 = (FontPathElementPtr)fpe->private;
    CatalogueUnrefFPEs(fpe_00);
    free(*(void **)&fpe_00->type);
    free(fpe_00);
    return 0x55;
  }
  iVar1 = FontFileFreeFPE(fpe);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void CatalogueRegisterLocalFpeFunctions(void)

{
  RegisterFPEFunctions
            (CatalogueNameCheck,CatalogueInitFPE,CatalogueFreeFPE,CatalogueResetFPE,
             CatalogueOpenFont,CatalogueCloseFont,CatalogueListFonts,CatalogueStartListFontsWithInfo
             ,CatalogueListNextFontWithInfo,(WakeupFpeFunc)0x0,(ClientDiedFunc)0x0,
             (LoadGlyphsFunc)0x0,CatalogueStartListFontsAndAliases,CatalogueListNextFontOrAlias,
             FontFileEmptyBitmapSource);
  return;
}



int FTPickMapping(char *xlfd,int length,char *filename,FT_Face_conflict face,FTMappingPtr tm)

{
  char *pcVar1;
  _FontMap **pp_Var2;
  FT_CharMap *ppFVar3;
  long lVar4;
  char cVar5;
  int iVar6;
  int iVar7;
  char *pcVar8;
  size_t sVar9;
  size_t sVar10;
  _FontMap *p_Var11;
  long lVar12;
  FT_CharMap pFVar13;
  FT_CharMap *ppFVar14;
  _FontMap *p_Var15;
  undefined4 in_register_00000034;
  byte bVar16;
  char *pcVar17;
  long in_FS_OFFSET;
  uint local_7c;
  char *enc;
  char *reg;
  char buf [20];
  
  lVar4 = *(long *)(in_FS_OFFSET + 0x28);
  if ((xlfd == (char *)0x0) ||
     (pcVar8 = (char *)FontEncFromXLFD(xlfd,CONCAT44(in_register_00000034,length)),
     pcVar8 == (char *)0x0)) {
    iVar6 = strcasecmp("iso8859-1","microsoft-symbol");
    pcVar8 = "iso8859-1";
    if (iVar6 != 0) {
      cVar5 = 'i';
      pcVar17 = pcVar8;
      goto LAB_001114a0;
    }
LAB_00111540:
    iVar6 = FT_Get_BDF_Charset_ID(face,&enc,&reg);
    if (iVar6 != 0) {
LAB_0011155a:
      iVar6 = FT_Select_Charmap(face,0x41444243);
      if (iVar6 == 0) {
LAB_00111410:
        tm->named = 0;
        pFVar13 = face->charmap;
        tm->base = 0;
        tm->mapping = (_FontMap *)0x0;
        tm->cmap = pFVar13;
        iVar6 = 0x55;
        goto LAB_0011143b;
      }
      local_7c = 1;
      bVar16 = 1;
LAB_0011157d:
      lVar12 = FontEncFind(pcVar8,filename);
      if (lVar12 == 0) {
        pcVar17 = pcVar8;
        if (bVar16 != 0) {
          lVar12 = FontEncFind("microsoft-symbol",filename);
        }
        goto joined_r0x001114db;
      }
      goto LAB_001114e1;
    }
    local_7c = 1;
LAB_00111347:
    sVar9 = strlen(enc);
    sVar10 = strlen(reg);
    if (0x12 < sVar10 + sVar9) goto LAB_00111410;
    __memcpy_chk(buf,enc,sVar9,0x14);
    __memcpy_chk(buf + sVar9,&DAT_001321d3,1,0x14 - sVar9);
    __strcpy_chk(buf + sVar9 + 1,reg,0x13 - sVar9);
    ErrorF("%s %s\n",buf,pcVar8);
    iVar6 = strcasecmp(buf,"iso10646-1");
    if (iVar6 == 0) {
      bVar16 = (byte)local_7c & 1;
      goto LAB_0011157d;
    }
    iVar6 = strcasecmp(buf,pcVar8);
    if (iVar6 == 0) goto LAB_00111410;
  }
  else {
    iVar6 = strcasecmp(pcVar8,"microsoft-symbol");
    if (iVar6 == 0) goto LAB_00111540;
    cVar5 = *pcVar8;
    pcVar17 = pcVar8;
    while (cVar5 != '-') {
LAB_001114a0:
      if (cVar5 == '\0') {
        local_7c = FT_Get_BDF_Charset_ID(face,&enc,&reg);
        pcVar8 = pcVar17;
        if (local_7c == 0) goto LAB_00111347;
        goto LAB_001114c2;
      }
      pcVar1 = pcVar8 + 1;
      pcVar8 = pcVar8 + 1;
      cVar5 = *pcVar1;
    }
    iVar6 = strcasecmp(pcVar8 + 1,"fontspecific");
    iVar7 = FT_Get_BDF_Charset_ID(face,&enc,&reg);
    pcVar8 = pcVar17;
    if (iVar7 == 0) {
      local_7c = (uint)(iVar6 == 0);
      goto LAB_00111347;
    }
    if (iVar6 == 0) goto LAB_0011155a;
LAB_001114c2:
    lVar12 = FontEncFind(pcVar17,filename);
    local_7c = 0;
joined_r0x001114db:
    if (lVar12 == 0) {
      ErrorF("FreeType: couldn\'t find encoding \'%s\' for \'%s\'\n",pcVar17,filename);
      iVar6 = 0x53;
      goto LAB_0011143b;
    }
LAB_001114e1:
    iVar6 = FT_Has_PS_Glyph_Names(face);
    p_Var15 = *(_FontMap **)(lVar12 + 0x18);
    if (iVar6 == 0) {
      if (p_Var15 != (_FontMap *)0x0) goto LAB_001115e9;
    }
    else {
      p_Var11 = p_Var15;
      if (p_Var15 != (_FontMap *)0x0) {
        do {
          if (p_Var11->type == 3) {
            tm->mapping = p_Var11;
            iVar6 = 0x55;
            tm->named = 1;
            tm->base = 0;
            goto LAB_0011143b;
          }
          pp_Var2 = &p_Var11->next;
          p_Var11 = *pp_Var2;
        } while (*pp_Var2 != (_FontMap *)0x0);
LAB_001115e9:
        iVar6 = face->num_charmaps;
        do {
          if (p_Var15->type == 1) {
            if (0 < iVar6) {
              ppFVar14 = face->charmaps;
              ppFVar3 = ppFVar14 + (ulong)(iVar6 - 1) + 1;
              do {
                pFVar13 = *ppFVar14;
                iVar7._0_2_ = pFVar13->platform_id;
                iVar7._2_2_ = pFVar13->encoding_id;
                if (iVar7 == 0x10003) goto LAB_0011163d;
                ppFVar14 = ppFVar14 + 1;
              } while (ppFVar3 != ppFVar14);
            }
          }
          else if ((p_Var15->type == 2) && (0 < iVar6)) {
            ppFVar14 = face->charmaps;
            ppFVar3 = ppFVar14 + (ulong)(iVar6 - 1) + 1;
            do {
              pFVar13 = *ppFVar14;
              if ((p_Var15->pid == (uint)pFVar13->platform_id) &&
                 (p_Var15->eid == (uint)pFVar13->encoding_id)) goto LAB_0011163d;
              ppFVar14 = ppFVar14 + 1;
            } while (ppFVar3 != ppFVar14);
          }
          p_Var15 = p_Var15->next;
        } while (p_Var15 != (_FontMap *)0x0);
      }
    }
  }
  iVar6 = 0x58;
LAB_0011143b:
  if (lVar4 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar6;
LAB_0011163d:
  tm->cmap = pFVar13;
  tm->named = 0;
  if ((local_7c == 0) || (lVar12 = FT_Get_Sfnt_Table(face,2), lVar12 == 0)) {
    tm->base = 0;
  }
  else {
    tm->base = *(ushort *)(lVar12 + 0x56) - 0x20;
  }
  tm->mapping = p_Var15;
  iVar6 = 0x55;
  goto LAB_0011143b;
}



uint FTRemap(FT_Face_conflict face,FTMappingPtr tm,uint code)

{
  uint uVar1;
  int iVar2;
  long lVar3;
  
  if (tm->mapping == (_FontMap *)0x0) {
    if (code < 0x100) goto LAB_0011176a;
  }
  else {
    if (tm->named == 0) {
      iVar2 = FontEncRecode(code);
      code = iVar2 + tm->base;
LAB_0011176a:
      FT_Set_Charmap(face,tm->cmap);
      uVar1 = FT_Get_Char_Index(face,code);
      return uVar1;
    }
    lVar3 = FontEncName();
    if (lVar3 != 0) {
      uVar1 = FT_Get_Name_Index(face,lVar3);
      return uVar1;
    }
  }
  return 0;
}



FT_UShort sfnt_get_ushort(FT_Face face,FT_ULong table_tag,FT_ULong table_offset)

{
  long lVar1;
  FT_UShort FVar2;
  int iVar3;
  long in_FS_OFFSET;
  FT_ULong len;
  FT_Byte buff [2];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar3 = FT_Load_Sfnt_Table();
  FVar2 = 0;
  if (iVar3 == 0) {
    FVar2 = CONCAT11(buff[0],buff[1]);
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return FVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void restrict_code_range(ushort *refFirstCol,ushort *refFirstRow,ushort *refLastCol,
                        ushort *refLastRow,fsRange *ranges,int nRanges)

{
  fsRange *pfVar1;
  byte bVar2;
  byte bVar3;
  ushort uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  fsRange *r;
  uint uVar8;
  uint uVar9;
  
  if (nRanges < 1) {
    uVar9 = 0xffffffff;
    uVar8 = 0x100;
    uVar5 = 0xffffffff;
    uVar7 = 0x100;
  }
  else {
    uVar9 = 0xffffffff;
    uVar8 = 0x100;
    uVar5 = 0xffffffff;
    pfVar1 = ranges + (ulong)(nRanges - 1) + 1;
    uVar7 = 0x100;
    do {
      bVar2 = ranges->min_char_high;
      bVar3 = ranges->max_char_high;
      if (bVar2 == bVar3) {
        if (ranges->min_char_low < uVar7) {
          uVar7 = (uint)ranges->min_char_low;
        }
        if ((int)uVar5 < (int)(uint)ranges->max_char_low) {
          uVar5 = (uint)ranges->max_char_low;
        }
      }
      else {
        uVar7 = 0;
        uVar5 = 0xff;
      }
      if (bVar2 < uVar8) {
        uVar8 = (uint)bVar2;
      }
      if ((int)uVar9 < (int)(uint)bVar3) {
        uVar9 = (uint)bVar3;
      }
      ranges = ranges + 1;
    } while (pfVar1 != ranges);
  }
  uVar4 = *refLastCol;
  uVar6 = (uint)uVar4;
  if (uVar4 < uVar7) {
    *refFirstCol = uVar4;
LAB_001118c0:
    if ((int)uVar6 <= (int)uVar5) goto LAB_00111919;
LAB_001118c5:
    *refLastCol = uVar4;
  }
  else {
    uVar4 = *refFirstCol;
    uVar6 = (uint)uVar4;
    if (uVar7 <= uVar6) goto LAB_001118c0;
    uVar4 = (ushort)uVar7;
    *refFirstCol = uVar4;
    if ((int)uVar5 < (int)uVar7) goto LAB_001118c5;
LAB_00111919:
    if ((int)uVar5 < (int)(uint)*refLastCol) {
      *refLastCol = (ushort)uVar5;
      uVar4 = *refLastRow;
      goto joined_r0x0011192a;
    }
  }
  uVar4 = *refLastRow;
joined_r0x0011192a:
  if (uVar4 < uVar8) {
    *refFirstRow = uVar4;
    *refFirstCol = *refLastCol;
    uVar4 = *refFirstRow;
    uVar7 = (uint)uVar4;
  }
  else {
    uVar4 = *refFirstRow;
    uVar7 = (uint)uVar4;
    if (uVar7 < uVar8) {
      uVar4 = (ushort)uVar8;
      *refFirstRow = uVar4;
      uVar7 = uVar8;
    }
  }
  if ((int)uVar9 < (int)uVar7) {
    *refLastRow = uVar4;
    *refLastCol = *refFirstCol;
  }
  else if ((int)uVar9 < (int)(uint)*refLastRow) {
    *refLastRow = (ushort)uVar9;
    return;
  }
  return;
}



int restrict_code_range_by_str
              (int count,ushort *refFirstCol,ushort *refFirstRow,ushort *refLastCol,
              ushort *refLastRow,char *str)

{
  char cVar1;
  byte bVar2;
  char *pcVar3;
  ushort **ppuVar4;
  ulong uVar5;
  fsRange *pfVar6;
  fsRange *pfVar7;
  ushort *puVar8;
  ushort uVar9;
  ulong uVar10;
  long lVar11;
  ushort uVar12;
  long in_FS_OFFSET;
  int local_70;
  char *q;
  long local_40;
  
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  q = str;
  ppuVar4 = __ctype_b_loc();
  pfVar7 = (fsRange *)0x0;
  lVar11 = 0;
  do {
    local_70 = (int)lVar11;
    puVar8 = *ppuVar4;
    while ((cVar1 = *str, cVar1 == ',' ||
           ((*(byte *)((long)puVar8 + (long)cVar1 * 2 + 1) & 0x20) != 0))) {
      str = str + 1;
    }
    uVar10 = 0;
    if (cVar1 != '-') {
      uVar10 = strtol(str,&q,0);
      if ((q != str) && (uVar10 < 0x10000)) {
        uVar9 = (ushort)uVar10;
        cVar1 = *q;
        puVar8 = *ppuVar4;
        bVar2 = *(byte *)((long)puVar8 + (long)cVar1 * 2 + 1);
        str = q;
        while ((bVar2 & 0x20) != 0) {
          cVar1 = str[1];
          str = str + 1;
          bVar2 = *(byte *)((long)puVar8 + (long)cVar1 * 2 + 1);
        }
        uVar10 = uVar10 & 0xffffffff;
        if ((cVar1 == ',') || (cVar1 == '\0')) goto LAB_00111a59;
        if (cVar1 == '-') goto LAB_001119f4;
      }
LAB_00111b13:
      if (pfVar7 == (fsRange *)0x0) {
        local_70 = 0;
      }
      else {
        if (count == 0) {
          if (local_70 != 0) {
            restrict_code_range(refFirstCol,refFirstRow,refLastCol,refLastRow,pfVar7,local_70);
            local_70 = 0;
          }
        }
        else if (local_70 != 0) {
          *refFirstCol = (ushort)pfVar7->min_char_low;
          *refLastCol = (ushort)pfVar7->max_char_low;
          *refFirstRow = (ushort)pfVar7->min_char_high;
          *refLastRow = (ushort)pfVar7->max_char_high;
          local_70 = count;
        }
        free(pfVar7);
      }
      goto LAB_00111b6c;
    }
LAB_001119f4:
    bVar2 = *(byte *)((long)puVar8 + (long)str[1] * 2 + 1);
    pcVar3 = str;
    while (str = pcVar3 + 1, (bVar2 & 0x20) != 0) {
      bVar2 = *(byte *)((long)puVar8 + (long)pcVar3[2] * 2 + 1);
      pcVar3 = str;
    }
    uVar5 = strtol(str,&q,0);
    uVar12 = (ushort)uVar10;
    if (q == str) {
      if ((*str != ',') && (*str != '\0')) goto LAB_00111b13;
      uVar10 = 0xffff;
      uVar9 = uVar12;
    }
    else {
      if (0xffff < uVar5) goto LAB_00111b13;
      str = q;
      if ((0 < count) || (uVar9 = (ushort)uVar5, (int)uVar10 <= (int)uVar5)) {
        uVar10 = uVar5 & 0xffffffff;
        uVar9 = uVar12;
      }
    }
LAB_00111a59:
    pfVar6 = (fsRange *)realloc(pfVar7,(lVar11 + 1) * 4);
    if (pfVar6 == (fsRange *)0x0) {
      free(pfVar7);
      local_70 = 0;
LAB_00111b6c:
      if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return local_70;
    }
    pfVar7 = pfVar6 + lVar11;
    uVar12 = uVar9 << 8 | uVar9 >> 8;
    uVar9 = (ushort)uVar10 << 8 | (ushort)uVar10 >> 8;
    pfVar7->min_char_high = (char)uVar12;
    pfVar7->min_char_low = (char)(uVar12 >> 8);
    pfVar7->max_char_high = (char)uVar9;
    pfVar7->max_char_low = (char)(uVar9 >> 8);
    pfVar7 = pfVar6;
    lVar11 = lVar11 + 1;
  } while( true );
}



int FreeTypeSetUpFont(FontPathElementPtr fpe,FontPtr xf,FontInfoPtr info,fsBitmapFormat format,
                     fsBitmapFormatMask fmask,FontBitmapFormatPtr bmfmt)

{
  int iVar1;
  undefined8 uVar2;
  int iVar3;
  ulong uVar4;
  long in_FS_OFFSET;
  int image;
  long local_40;
  
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  FontDefaultFormat(&bmfmt->bit,&bmfmt->byte,&bmfmt->glyph,&bmfmt->scan);
  iVar3 = CheckFSFormat(format,fmask,&bmfmt->bit,&bmfmt->byte,&bmfmt->scan,&bmfmt->glyph,&image);
  if (iVar3 == 0x55) {
    if (xf != (FontPtr)0x0) {
      xf->refcnt = 0;
      xf->bit = (char)bmfmt->bit;
      xf->byte = (char)bmfmt->byte;
      xf->glyph = (char)bmfmt->glyph;
      iVar1 = bmfmt->scan;
      xf->get_metrics = FreeTypeGetMetrics;
      xf->get_glyphs = FreeTypeGetGlyphs;
      xf->scan = (char)iVar1;
      xf->format = format;
      xf->unload_font = FreeTypeUnloadXFont;
      xf->unload_glyphs = (_func_void_FontPtr *)0x0;
      xf->fpe = fpe;
      xf->svrPrivate = (void *)0x0;
      xf->fontPrivate = (void *)0x0;
      xf->fpePrivate = (void *)0x0;
    }
    uVar2._0_2_ = info->defaultCh;
    uVar2._2_2_ = *(undefined2 *)&info->field_0xa;
    uVar2._4_2_ = info->maxOverlap;
    uVar2._6_2_ = info->pad;
    uVar4 = (ulong)((uint)uVar2 & 0xf8000000) | 0x2300000;
    info->defaultCh = (short)uVar4;
    *(short *)&info->field_0xa = (short)(uVar4 >> 0x10);
    info->maxOverlap = (short)(uVar4 >> 0x20);
    info->pad = (short)(uVar4 >> 0x30);
  }
  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void FreeTypeFreeFace(FTFacePtr face)

{
  byte bVar1;
  FTFacePtr p_Var2;
  byte *pbVar3;
  uint uVar4;
  FTFacePtr p_Var5;
  
  pbVar3 = (byte *)face->filename;
  bVar1 = *pbVar3;
  if (bVar1 == 0) {
    uVar4 = 0;
  }
  else {
    uVar4 = 0;
    do {
      pbVar3 = pbVar3 + 1;
      uVar4 = (uVar4 << 5 | uVar4 >> 0x1b) + (uint)bVar1;
      bVar1 = *pbVar3;
    } while (bVar1 != 0);
    uVar4 = uVar4 & 0x1f;
  }
  p_Var2 = faceTable[(int)uVar4];
  if (face == faceTable[(int)uVar4]) {
    faceTable[(int)uVar4] = face->next;
  }
  else {
    do {
      p_Var5 = p_Var2;
      if (p_Var5 == (FTFacePtr)0x0) {
        ErrorF("FreeType: freeing unknown face\n");
        goto LAB_00111de0;
      }
      p_Var2 = p_Var5->next;
    } while (face != p_Var5->next);
    p_Var5->next = face->next;
  }
LAB_00111de0:
  FT_Done_Face(face->face);
  free(face->filename);
  free(face);
  return;
}



void FreeTypeFreeFont(FTFontPtr font)

{
  FTInstancePtr __ptr;
  char *__ptr_00;
  FTInstancePtr p_Var1;
  int iVar2;
  uint uVar3;
  FTInstancePtr p_Var4;
  long lVar5;
  long lVar6;
  CharInfoPtr __ptr_01;
  CharInfoPtr *__ptr_02;
  int **__ptr_03;
  long lVar7;
  
  __ptr = font->instance;
  if (__ptr != (FTInstancePtr)0x0) {
    if (__ptr == __ptr->face->active_instance) {
      __ptr->face->active_instance = (_FTInstance *)0x0;
    }
    iVar2 = __ptr->refcount + -1;
    __ptr->refcount = iVar2;
    if (iVar2 < 1) {
      p_Var1 = __ptr->face->instances;
      if (__ptr == p_Var1) {
        __ptr->face->instances = __ptr->next;
      }
      else {
        do {
          p_Var4 = p_Var1;
          if (p_Var4 == (FTInstancePtr)0x0) goto LAB_00111eb8;
          p_Var1 = p_Var4->next;
        } while (__ptr != p_Var4->next);
        p_Var4->next = __ptr->next;
      }
LAB_00111eb8:
      FT_Done_Size(__ptr->size);
      if (__ptr->face->instances == (_FTInstance *)0x0) {
        FreeTypeFreeFace(__ptr->face);
      }
      if (__ptr->charcellMetrics != (xCharInfo *)0x0) {
        free(__ptr->charcellMetrics);
      }
      if (__ptr->forceConstantMetrics != (xCharInfo *)0x0) {
        free(__ptr->forceConstantMetrics);
      }
      __ptr_02 = __ptr->glyphs;
      if (__ptr_02 != (CharInfoPtr *)0x0) {
        uVar3 = __ptr->nglyphs;
        for (lVar7 = 0; (-1 < (int)(uVar3 + 0xf) && ((int)lVar7 < (int)(uVar3 + 0xf) >> 4));
            lVar7 = lVar7 + 1) {
          __ptr_01 = __ptr_02[lVar7];
          if (__ptr_01 != (CharInfoPtr)0x0) {
            lVar5 = 0;
            do {
              while (*(int *)((long)__ptr->available[lVar7] + lVar5) == 3) {
                lVar6 = lVar5 + 4;
                free(*(void **)((long)&__ptr_01->bits + lVar5 * 6));
                __ptr_01 = __ptr->glyphs[lVar7];
                lVar5 = lVar6;
                if (lVar6 == 0x40) goto LAB_00111fee;
              }
              lVar5 = lVar5 + 4;
            } while (lVar5 != 0x40);
LAB_00111fee:
            free(__ptr_01);
            __ptr_02 = __ptr->glyphs;
            uVar3 = __ptr->nglyphs;
          }
        }
        free(__ptr_02);
      }
      __ptr_03 = __ptr->available;
      if (__ptr_03 != (int **)0x0) {
        uVar3 = __ptr->nglyphs;
        for (lVar7 = 0; (-1 < (int)(uVar3 + 0xf) && ((int)lVar7 < (int)(uVar3 + 0xf) >> 4));
            lVar7 = lVar7 + 1) {
          if (__ptr_03[lVar7] != (int *)0x0) {
            free(__ptr_03[lVar7]);
            __ptr_03 = __ptr->available;
            uVar3 = __ptr->nglyphs;
          }
        }
        free(__ptr_03);
      }
      free(__ptr);
    }
  }
  if (font->ranges != (fsRange *)0x0) {
    free(font->ranges);
  }
  __ptr_00 = (font->dummy_char).bits;
  if (__ptr_00 != (char *)0x0) {
    free(__ptr_00);
  }
  free(font);
  return;
}



// DWARF original prototype: int FreeTypeInstanceFindGlyph(uint idx_in, int flags, FTInstancePtr
// instance, CharInfoPtr * * glyphs, int * * * available, int * found, int * segmentP, int *
// offsetP, FTInstancePtr instance)

int FreeTypeInstanceFindGlyph
              (uint idx_in,int flags,FTInstancePtr instance,CharInfoPtr **glyphs,int ***available,
              int *found,int *segmentP,int *offsetP,FTInstancePtr instance_1)

{
  long *plVar1;
  uint uVar2;
  int **ppiVar3;
  int *piVar4;
  void *pvVar5;
  long lVar6;
  uint idx;
  int iVar7;
  int iVar8;
  
  uVar2 = *(uint *)&instance->face;
  if ((-1 < (int)glyphs) && ((flags & 8U) != 0)) {
    idx_in = (uVar2 >> 1) + idx_in;
  }
  if (uVar2 < idx_in) {
    *segmentP = 0;
    return 0x55;
  }
  pvVar5 = *(void **)found;
  if (pvVar5 == (void *)0x0) {
    if ((int)(uVar2 + 0xf) < 0) {
      iVar8 = ((int)(uVar2 + 0x1e) >> 4) + -1;
    }
    else {
      iVar8 = (int)(uVar2 + 0xf) >> 4;
    }
    pvVar5 = calloc((long)iVar8,8);
    *(void **)found = pvVar5;
    if (pvVar5 != (void *)0x0) goto LAB_00112090;
LAB_00112180:
    iVar8 = 0x50;
  }
  else {
LAB_00112090:
    if ((int)idx_in < 0) {
      iVar8 = ((int)(idx_in + 0xf) >> 4) + -1;
    }
    else {
      iVar8 = (int)idx_in >> 4;
    }
    lVar6 = (long)iVar8;
    plVar1 = (long *)((long)pvVar5 + lVar6 * 8);
    if (*plVar1 == 0) {
      pvVar5 = calloc(0x10,8);
      *plVar1 = (long)pvVar5;
      if (*(long *)(*(long *)found + lVar6 * 8) == 0) goto LAB_00112180;
    }
    if (*available == (int **)0x0) {
      iVar7 = *(int *)&instance->face + 0xf;
      if (iVar7 < 0) {
        iVar7 = (*(int *)&instance->face + 0x1e >> 4) + -1;
      }
      else {
        iVar7 = iVar7 >> 4;
      }
      ppiVar3 = (int **)calloc((long)iVar7,8);
      *available = ppiVar3;
      if (ppiVar3 == (int **)0x0) goto LAB_00112180;
      ppiVar3 = ppiVar3 + lVar6;
      piVar4 = *ppiVar3;
    }
    else {
      ppiVar3 = *available + lVar6;
      piVar4 = *ppiVar3;
    }
    if (piVar4 == (int *)0x0) {
      piVar4 = (int *)malloc(0x180);
      *ppiVar3 = piVar4;
      if ((*available)[lVar6] == (int *)0x0) goto LAB_00112180;
    }
    *segmentP = 1;
    *offsetP = iVar8;
    *(uint *)&instance_1->face = idx_in + iVar8 * -0x10;
    iVar8 = 0x55;
  }
  return iVar8;
}



int FreeTypeActivateInstance(FTInstancePtr instance)

{
  uint rc;
  int iVar1;
  FT_Matrix *pFVar2;
  
  if (instance->face->active_instance == instance) {
    return 0x55;
  }
  rc = FT_Activate_Size(instance->size);
  if (rc == 0) {
    pFVar2 = (FT_Matrix *)0x0;
    if ((instance->transformation).nonIdentity != 0) {
      pFVar2 = &(instance->transformation).matrix;
    }
    FT_Set_Transform(instance->face->face,pFVar2,0);
    instance->face->active_instance = instance;
    return 0x55;
  }
  instance->face->active_instance = (_FTInstance *)0x0;
  ErrorF("FreeType: couldn\'t activate instance: %d\n",(ulong)rc);
  iVar1 = FTtoXReturnCode(rc);
  return iVar1;
}



int FreeTypeLoadFont(FTFontPtr font,FontInfoPtr info,FTFacePtr face,char *FTFileName,
                    FontScalablePtr vals,FontEntryPtr entry,FontBitmapFormatPtr bmfmt,
                    FT_Int32 load_flags,TTCapInfo *tmp_ttcap,char *dynStrTTCapCodeRange,
                    int ttcap_spacing)

{
  double dVar1;
  int iVar2;
  int iVar3;
  long lVar4;
  _FontMap *p_Var5;
  _FontEnc *p_Var6;
  _FTInstance *p_Var7;
  long lVar8;
  long lVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  int iVar17;
  ushort uVar18;
  int iVar19;
  int iVar20;
  uint uVar21;
  int iVar22;
  long lVar23;
  FTInstancePtr instance;
  char *pcVar24;
  fsRange *__dest;
  ushort uVar25;
  long lVar26;
  FT_ULong FVar27;
  FT_Bitmap_Size *pFVar28;
  int iVar29;
  long lVar30;
  FT_Pos *pFVar31;
  long lVar32;
  ulong uVar33;
  ulong uVar34;
  ulong uVar35;
  char *xlfd;
  short sVar36;
  FT_Bitmap_Size *pFVar37;
  int iVar38;
  FT_Face pFVar39;
  long in_FS_OFFSET;
  bool bVar40;
  double dVar41;
  double dVar42;
  uint local_d8;
  int local_cc;
  long local_b8;
  long local_a8;
  long local_a0;
  long local_98;
  FTMappingRec *local_90;
  PS_FontInfoRec t1info_rec;
  
  lVar4 = *(long *)(in_FS_OFFSET + 0x28);
  iVar2 = vals->x;
  iVar3 = vals->y;
  lVar32._0_4_ = vals->x;
  lVar32._4_4_ = vals->y;
  dVar41 = hypot(vals->point_matrix[2],vals->point_matrix[3]);
  dVar42 = vals->point_matrix[3];
  dVar1 = vals->point_matrix[0];
  bVar40 = ABS(dVar1 - dVar42) < ABS(dVar1) * 0.001;
  if (bVar40) {
    local_b8 = (long)(((dVar1 + dVar42) * 0.5 * 65536.0) / dVar41);
    local_a0 = local_b8;
  }
  else {
    local_b8 = (long)(int)((dVar1 * 65536.0) / dVar41);
    local_a0 = (long)(int)((dVar42 * 65536.0) / dVar41);
  }
  local_d8 = (uint)!bVar40;
  if (ABS(vals->point_matrix[1]) < dVar41 * 0.001) {
    local_a8 = 0;
  }
  else {
    local_d8 = 1;
    local_a8 = (long)(int)((vals->point_matrix[1] * 65536.0) / dVar41);
  }
  if (ABS(vals->point_matrix[2]) < dVar41 * 0.001) {
    sVar36 = (entry->name).ndashes;
    pFVar39 = face->face;
    local_98 = 0;
    if (sVar36 == 0xe) goto LAB_00112b7d;
LAB_0011248c:
    if (ttcap_spacing == 0) {
LAB_001124b8:
      local_cc = 1;
      if ((*(byte *)&pFVar39->face_flags & 4) == 0) {
        iVar19 = FT_Get_PS_Font_Info();
        pFVar39 = face->face;
        sVar36 = (entry->name).ndashes;
        if (iVar19 == 0) {
          local_cc = 0;
          if (t1info_rec.is_fixed_pitch != '\0') {
            local_cc = 1;
          }
        }
        else {
          local_cc = 0;
        }
      }
      if (sVar36 == 0xe) {
        xlfd = (entry->name).name;
        uVar33 = (ulong)(uint)(int)(entry->name).length;
        goto LAB_00112c68;
      }
    }
    else if (ttcap_spacing == 99) {
      local_cc = 2;
    }
    else {
      if (ttcap_spacing != 0x6d) goto LAB_001124b8;
      local_cc = 1;
    }
    iVar19 = FTPickMapping((char *)0x0,0,FTFileName,pFVar39,&font->mapping);
  }
  else {
    sVar36 = (entry->name).ndashes;
    local_d8 = 1;
    pFVar39 = face->face;
    local_98 = (long)(int)((vals->point_matrix[2] * 65536.0) / dVar41);
    if (sVar36 != 0xe) goto LAB_0011248c;
LAB_00112b7d:
    uVar33 = (ulong)(entry->name).length;
    xlfd = (entry->name).name;
    if (xlfd <= xlfd + (uVar33 - 2)) {
      iVar19 = 0;
      pcVar24 = xlfd;
      do {
        if ((*pcVar24 == '-') && (iVar19 = iVar19 + 1, iVar19 == 0xb)) {
          if (pcVar24[1] == 'c') {
            if (pcVar24[2] == '-') {
              if (ttcap_spacing == 0) goto LAB_00113090;
              goto LAB_00112bdf;
            }
          }
          else if ((pcVar24[1] == 'm') && (pcVar24[2] == '-')) {
            if (ttcap_spacing != 0) goto LAB_00112bdf;
            goto LAB_00112bfb;
          }
          break;
        }
        pcVar24 = pcVar24 + 1;
      } while (pcVar24 <= xlfd + (uVar33 - 2));
    }
    if (ttcap_spacing == 0) goto LAB_001124b8;
LAB_00112bdf:
    if (ttcap_spacing == 99) {
LAB_00113090:
      local_cc = 2;
    }
    else {
      if (ttcap_spacing != 0x6d) goto LAB_001124b8;
LAB_00112bfb:
      local_cc = 1;
    }
LAB_00112c68:
    iVar19 = FTPickMapping(xlfd,(int)uVar33,FTFileName,pFVar39,&font->mapping);
  }
  if (iVar19 != 0x55) goto LAB_00112b30;
  local_90 = &font->mapping;
  iVar19 = vals->nranges;
  font->ranges = (fsRange *)0x0;
  font->nranges = iVar19;
  if (iVar19 == 0) {
LAB_0011254e:
    if (info == (FontInfoPtr)0x0) {
      font->info = (FontInfoPtr)0x0;
LAB_00112d58:
      font->zero_idx = 0;
    }
    else {
      p_Var5 = (font->mapping).mapping;
      if (p_Var5 == (_FontMap *)0x0) {
        lVar30 = 0xff;
        iVar19 = 0;
        info->firstRow = 0;
        info->lastRow = 0;
        info->firstCol = 0;
LAB_00112f40:
        uVar25 = (ushort)lVar30 & 0xff;
LAB_001125fc:
        info->lastCol = uVar25;
      }
      else {
        p_Var6 = p_Var5->encoding;
        iVar19 = p_Var6->first;
        if (p_Var6->row_size == 0) {
          iVar20 = p_Var6->size + -1;
          lVar30 = (long)iVar20;
          if (0xffff < iVar20) {
            lVar30 = 0xffff;
          }
          if (iVar19 == 0) {
            lVar26 = 0;
            uVar18 = 0;
            iVar19 = 0;
          }
          else {
            lVar26 = (long)iVar19;
            lVar23 = lVar26 + 0xff;
            if (-1 < lVar26) {
              lVar23 = lVar26;
            }
            uVar18 = (ushort)((ulong)lVar23 >> 8);
            iVar19 = -(uint)(lVar26 != 0);
          }
          info->firstRow = uVar18;
          lVar23 = lVar30 + 0xff;
          if (-1 < lVar30) {
            lVar23 = lVar30;
          }
          uVar25 = 0;
          uVar18 = (ushort)((ulong)lVar23 >> 8);
          info->lastRow = uVar18;
          iVar20._0_2_ = info->firstRow;
          iVar20._2_2_ = info->lastRow;
          if (iVar20 == 0) {
            uVar25 = (ushort)lVar26 & 0xff;
          }
          info->firstCol = uVar25;
          uVar25 = 0xff;
          if (uVar18 == 0) goto LAB_00112f40;
          goto LAB_001125fc;
        }
        info->firstRow = (ushort)iVar19;
        iVar19 = ((font->mapping).mapping)->encoding->size + -1;
        if (0xff < iVar19) {
          iVar19 = 0xff;
        }
        info->lastRow = (ushort)iVar19;
        info->firstCol = (ushort)((font->mapping).mapping)->encoding->first_col;
        iVar19 = ((font->mapping).mapping)->encoding->row_size + -1;
        if (0xff < iVar19) {
          iVar19 = 0xff;
        }
        info->lastCol = (ushort)iVar19;
        uVar33._0_2_ = info->firstCol;
        uVar33._2_2_ = info->lastCol;
        uVar33._4_2_ = info->firstRow;
        uVar33._6_2_ = info->lastRow;
        iVar19 = -(uint)((uVar33 & 0xffff0000ffff) != 0);
      }
      if (dynStrTTCapCodeRange != (char *)0x0) {
        restrict_code_range_by_str
                  (0,&info->firstCol,&info->firstRow,&info->lastCol,&info->lastRow,
                   dynStrTTCapCodeRange);
      }
      if (font->nranges != 0) {
        restrict_code_range(&info->firstCol,&info->firstRow,&info->lastCol,&info->lastRow,
                            font->ranges,font->nranges);
      }
      font->info = info;
      if (iVar19 == -1) goto LAB_00112d58;
      uVar21 = FTRemap(face->face,local_90,0);
      font->zero_idx = uVar21;
    }
    lVar30 = FT_Get_Sfnt_Table(face->face,5);
    uVar33 = tmp_ttcap->flags;
    if ((((uVar33 & 0x20) == 0) && (1 < (int)((info->lastRow + 1) - (uint)info->firstRow))) &&
       (lVar30 != 0)) {
      uVar33 = uVar33 | 0x10;
    }
    tmp_ttcap->flags = uVar33 & 0xffffffffffffffdf;
    if ((((face->bitmap == 0) && (local_cc != 2)) ||
        (tmp_ttcap->flags = uVar33 & 0xffffffffffffffcf, face->bitmap == 0)) &&
       ((*(byte *)&face->face->face_flags & 8) == 0)) {
      tmp_ttcap->flags = tmp_ttcap->flags & 0xffffffffffffffef;
    }
    if ((lVar30 != 0) && (*(long *)(lVar30 + 8) != 0)) {
      dVar42 = sin((((double)*(long *)(lVar30 + 8) * 0.0009765625) / 5760.0) * 1.5707963267948966);
      tmp_ttcap->vl_slant = -dVar42;
    }
    for (p_Var7 = face->instances; p_Var7 != (_FTInstance *)0x0; p_Var7 = p_Var7->next) {
      iVar19 = strcmp(p_Var7->face->filename,FTFileName);
      if ((((((iVar19 == 0) && (true)) && (dVar41 == (p_Var7->transformation).scale)) &&
           ((lVar30._0_4_ = (p_Var7->transformation).xres,
            lVar30._4_4_ = (p_Var7->transformation).yres, lVar30 == lVar32 &&
            ((p_Var7->transformation).nonIdentity == local_d8)))) &&
          ((local_d8 == 0 ||
           (((local_b8 == (p_Var7->transformation).matrix.xx &&
             ((p_Var7->transformation).matrix.yx == local_a8)) &&
            (((p_Var7->transformation).matrix.yy == local_a0 &&
             (local_98 == (p_Var7->transformation).matrix.xy)))))))) &&
         (((((((p_Var7->spacing == local_cc && (load_flags == p_Var7->load_flags)) &&
              ((p_Var7->bmfmt).bit == bmfmt->bit)) &&
             ((((p_Var7->bmfmt).byte == bmfmt->byte && ((p_Var7->bmfmt).glyph == bmfmt->glyph)) &&
              (true)))) && (((p_Var7->ttcap).autoItalic == tmp_ttcap->autoItalic && (true)))) &&
           ((((p_Var7->ttcap).scaleWidth == tmp_ttcap->scaleWidth &&
             (((true && ((p_Var7->ttcap).scaleBBoxWidth == tmp_ttcap->scaleBBoxWidth)) && (true))))
            && (((p_Var7->ttcap).scaleBBoxHeight == tmp_ttcap->scaleBBoxHeight &&
                (lVar26._0_4_ = tmp_ttcap->doubleStrikeShift,
                lVar26._4_4_ = tmp_ttcap->adjustBBoxWidthByPixel,
                lVar23._0_4_ = (p_Var7->ttcap).doubleStrikeShift,
                lVar23._4_4_ = (p_Var7->ttcap).adjustBBoxWidthByPixel, lVar23 == lVar26)))))) &&
          ((lVar8._0_4_ = tmp_ttcap->adjustLeftSideBearingByPixel,
           lVar8._4_4_ = tmp_ttcap->adjustRightSideBearingByPixel,
           lVar9._0_4_ = (p_Var7->ttcap).adjustLeftSideBearingByPixel,
           lVar9._4_4_ = (p_Var7->ttcap).adjustRightSideBearingByPixel, lVar9 == lVar8 &&
           ((((p_Var7->ttcap).flags == tmp_ttcap->flags && (true)) &&
            (((p_Var7->ttcap).scaleBitmap == tmp_ttcap->scaleBitmap &&
             (((p_Var7->ttcap).forceConstantSpacingEnd < 0 &&
              (tmp_ttcap->forceConstantSpacingEnd < 0)))))))))))) {
        p_Var7->refcount = p_Var7->refcount + 1;
        iVar19 = 0x55;
        font->instance = p_Var7;
        goto LAB_00112b30;
      }
    }
    instance = (FTInstancePtr)malloc(0x160);
    if (instance != (FTInstancePtr)0x0) {
      instance->face = face;
      instance->refcount = 1;
      instance->load_flags = load_flags;
      instance->pixel_size = 0.0;
      instance->spacing = local_cc;
      instance->pixel_width_unit_x = 0.0;
      (instance->transformation).nonIdentity = local_d8;
      instance->pixel_width_unit_y = 0.0;
      (instance->transformation).matrix.xx = local_b8;
      instance->charcellMetrics = (xCharInfo *)0x0;
      (instance->transformation).matrix.xy = local_98;
      instance->averageWidth = 0;
      (instance->transformation).matrix.yx = local_a8;
      instance->rawAverageWidth = 0;
      (instance->transformation).matrix.yy = local_a0;
      instance->forceConstantMetrics = (xCharInfo *)0x0;
      (instance->transformation).xres = iVar2;
      (instance->transformation).scale = dVar41;
      (instance->transformation).yres = iVar3;
      iVar19 = bmfmt->byte;
      iVar20 = bmfmt->glyph;
      iVar38 = bmfmt->scan;
      (instance->bmfmt).bit = bmfmt->bit;
      (instance->bmfmt).byte = iVar19;
      (instance->bmfmt).glyph = iVar20;
      (instance->bmfmt).scan = iVar38;
      instance->glyphs = (CharInfoPtr *)0x0;
      iVar19 = tmp_ttcap->forceConstantSpacingEnd;
      instance->available = (int **)0x0;
      pFVar39 = face->face;
      uVar21 = *(uint *)&pFVar39->num_glyphs;
      if (-1 < iVar19) {
        uVar21 = uVar21 * 2;
      }
      lVar32 = tmp_ttcap->flags;
      dVar42 = tmp_ttcap->autoItalic;
      dVar1 = tmp_ttcap->scaleWidth;
      dVar10 = tmp_ttcap->scaleBBoxWidth;
      instance->nglyphs = uVar21;
      dVar11 = tmp_ttcap->scaleBBoxHeight;
      iVar19 = tmp_ttcap->doubleStrikeShift;
      iVar20 = tmp_ttcap->adjustBBoxWidthByPixel;
      iVar16 = tmp_ttcap->lsbShiftOfBitmapAutoItalic;
      iVar17 = tmp_ttcap->rsbShiftOfBitmapAutoItalic;
      (instance->ttcap).flags = lVar32;
      (instance->ttcap).autoItalic = dVar42;
      iVar38 = tmp_ttcap->adjustLeftSideBearingByPixel;
      iVar22 = tmp_ttcap->adjustRightSideBearingByPixel;
      dVar12 = tmp_ttcap->scaleBitmap;
      (instance->ttcap).scaleWidth = dVar1;
      (instance->ttcap).scaleBBoxWidth = dVar10;
      iVar29 = tmp_ttcap->forceConstantSpacingBegin;
      iVar13 = tmp_ttcap->forceConstantSpacingEnd;
      iVar14 = tmp_ttcap->force_c_adjust_width_by_pixel;
      iVar15 = tmp_ttcap->force_c_adjust_lsb_by_pixel;
      (instance->ttcap).scaleBBoxHeight = dVar11;
      (instance->ttcap).doubleStrikeShift = iVar19;
      (instance->ttcap).adjustBBoxWidthByPixel = iVar20;
      iVar19 = tmp_ttcap->force_c_adjust_rsb_by_pixel;
      iVar20 = tmp_ttcap->force_c_representative_metrics_char_code;
      dVar42 = tmp_ttcap->force_c_scale_b_box_width;
      (instance->ttcap).adjustLeftSideBearingByPixel = iVar38;
      (instance->ttcap).adjustRightSideBearingByPixel = iVar22;
      (instance->ttcap).scaleBitmap = dVar12;
      dVar1 = tmp_ttcap->force_c_scale_b_box_height;
      dVar10 = tmp_ttcap->force_c_scale_lsb;
      (instance->ttcap).forceConstantSpacingBegin = iVar29;
      (instance->ttcap).forceConstantSpacingEnd = iVar13;
      (instance->ttcap).force_c_adjust_width_by_pixel = iVar14;
      (instance->ttcap).force_c_adjust_lsb_by_pixel = iVar15;
      dVar11 = tmp_ttcap->force_c_scale_rsb;
      dVar12 = tmp_ttcap->vl_slant;
      (instance->ttcap).lsbShiftOfBitmapAutoItalic = iVar16;
      (instance->ttcap).rsbShiftOfBitmapAutoItalic = iVar17;
      (instance->ttcap).force_c_adjust_rsb_by_pixel = iVar19;
      (instance->ttcap).force_c_representative_metrics_char_code = iVar20;
      (instance->ttcap).force_c_scale_b_box_width = dVar42;
      (instance->ttcap).force_c_scale_b_box_height = dVar1;
      (instance->ttcap).force_c_scale_lsb = dVar10;
      (instance->ttcap).force_c_scale_rsb = dVar11;
      (instance->ttcap).vl_slant = dVar12;
      uVar21 = FT_New_Size(pFVar39,&instance->size);
      if (uVar21 != 0) {
        ErrorF("FreeType: couldn\'t create size object: %d\n",(ulong)uVar21);
        free(instance);
        iVar19 = FTtoXReturnCode(uVar21);
        goto LAB_00112b30;
      }
      FreeTypeActivateInstance(instance);
      if (face->bitmap == 0) {
        lVar32 = (long)(int)(dVar41 * 64.0 + 0.5);
        iVar19 = FT_Set_Char_Size(instance->face->face,lVar32,lVar32,iVar2,iVar3);
LAB_00112a10:
        if (iVar19 == 0) {
          pFVar39 = face->face;
          if ((*(byte *)&pFVar39->face_flags & 8) != 0) {
            instance->strike_index = 0xffff;
            lVar26 = (long)(dVar41 * 64.0 + 0.5);
            lVar32 = iVar3 * lVar26 + 0x24;
            lVar30 = lVar32 >> 0x3f;
            uVar34 = ((lVar32 / 0x12 + lVar30 >> 2) - lVar30) + 0x20U & 0xffffffffffffffc0;
            uVar33 = (iVar2 * lVar26 + 0x24) / 0x48 + 0x20U & 0xffffffffffffffc0;
            if (((uVar33 == 0) || ((uVar35 = uVar33, uVar34 != 0 && (uVar35 = uVar34, uVar33 == 0)))
                ) && (uVar35 = uVar34, uVar34 != 0)) {
              uVar33 = uVar34;
            }
            if (pFVar39->num_fixed_sizes != 0) {
              pFVar31 = &pFVar39->available_sizes->x_ppem;
              FVar27 = 0;
              do {
                if (((*pFVar31 + 0x20U & 0xffffffffffffffc0) == uVar33) &&
                   ((pFVar31[1] + 0x20U & 0xffffffffffffffc0) == uVar35)) {
                  instance->strike_index = FVar27;
                  break;
                }
                pFVar31 = pFVar31 + 4;
                bVar40 = FVar27 != pFVar39->num_fixed_sizes - 1;
                FVar27 = FVar27 + 1;
              } while (bVar40);
            }
          }
          instance->next = instance->face->instances;
          instance->face->instances = instance;
          iVar19 = 0x55;
          font->instance = instance;
        }
        else {
          FT_Done_Size(instance->size);
          free(instance);
          iVar19 = FTtoXReturnCode(iVar19);
        }
      }
      else {
        if (local_d8 == 0) {
          iVar19 = face->face->num_fixed_sizes;
          if (0 < iVar19) {
            pFVar37 = face->face->available_sizes;
            lVar32 = -1;
            iVar38 = 100;
            iVar20 = 0;
            pFVar28 = pFVar37;
            do {
              iVar22 = (int)pFVar28->width - (int)(((double)iVar2 * dVar41) / 72.0 + 0.5);
              if (((iVar22 + 1U < 3) &&
                  (iVar29 = (int)pFVar28->height - (int)(((double)iVar3 * dVar41) / 72.0 + 0.5),
                  iVar29 + 1U < 3)) && (iVar22 = iVar29 * iVar29 + iVar22 * iVar22, iVar22 < iVar38)
                 ) {
                lVar32 = (long)iVar20;
                iVar38 = iVar22;
              }
              iVar20 = iVar20 + 1;
              pFVar28 = pFVar28 + 1;
            } while (iVar19 != iVar20);
            if ((int)lVar32 != -1) {
              pFVar37 = pFVar37 + lVar32;
              iVar19 = FT_Set_Pixel_Sizes(instance->face->face,(int)pFVar37->width,
                                          (int)pFVar37->height);
              goto LAB_00112a10;
            }
          }
        }
        free(instance);
        iVar19 = 0x53;
      }
      goto LAB_00112b30;
    }
  }
  else {
    __dest = (fsRange *)malloc((long)vals->nranges << 2);
    font->ranges = __dest;
    if (__dest != (fsRange *)0x0) {
      memcpy(__dest,vals->ranges,(long)vals->nranges << 2);
      goto LAB_0011254e;
    }
  }
  iVar19 = 0x50;
LAB_00112b30:
  if (lVar4 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar19;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int ft_get_index(uint code,FTFontPtr font,uint *idx)

{
  FontInfoPtr p_Var1;
  uint uVar2;
  
  p_Var1 = font->info;
  if ((p_Var1 != (FontInfoPtr)0x0) &&
     (((((code & 0xff) < (uint)p_Var1->firstCol || ((uint)p_Var1->lastCol < (code & 0xff))) ||
       (code >> 8 < (uint)p_Var1->firstRow)) || ((uint)p_Var1->lastRow < code >> 8)))) {
    *idx = font->zero_idx;
    return -1;
  }
  uVar2 = FTRemap(font->instance->face->face,&font->mapping,code);
  *idx = uVar2;
  return 0;
}



void FreeTypeUnloadXFont(FontPtr pFont)

{
  if (pFont == (FontPtr)0x0) {
    return;
  }
  if ((FTFontPtr)pFont->fontPrivate != (FTFontPtr)0x0) {
    FreeTypeFreeFont((FTFontPtr)pFont->fontPrivate);
  }
  if ((pFont->info).nprops < 1) {
    DestroyFontRec(pFont);
    return;
  }
  free((pFont->info).isStringProp);
  free((pFont->info).props);
  DestroyFontRec(pFont);
  return;
}



FT_Error FT_Do_SBit_Metrics(FT_Face ft_face,FT_Size ft_size,FT_ULong strike_index,
                           FT_UShort glyph_index,FT_Glyph_Metrics *metrics_return,
                           int *sbitchk_incomplete_but_exist)

{
  FT_Bitmap_Size *pFVar1;
  long lVar2;
  FT_GlyphSlot_conflict pFVar3;
  FT_Pos *pFVar4;
  FT_Pos FVar5;
  int iVar6;
  undefined6 in_register_0000000a;
  long lVar7;
  long lVar8;
  
  if (ft_size == (FT_Size)0xffff) {
    return -1;
  }
  pFVar1 = ft_face->available_sizes;
  if (pFVar1 != (FT_Bitmap_Size *)0x0) {
    pFVar4 = (FT_Pos *)CONCAT62(in_register_0000000a,glyph_index);
    lVar2 = pFVar1[(long)ft_size].y_ppem;
    lVar7 = lVar2 + 0x3f;
    if (-1 < lVar2) {
      lVar7 = lVar2;
    }
    lVar2 = pFVar1[(long)ft_size].x_ppem;
    lVar8 = lVar2 + 0x3f;
    if (-1 < lVar2) {
      lVar8 = lVar2;
    }
    iVar6 = FT_Set_Pixel_Sizes(ft_face,lVar8 >> 6,lVar7 >> 6);
    if (iVar6 == 0) {
      iVar6 = FT_Load_Glyph(ft_face,strike_index & 0xffff,0x4000);
      if (iVar6 == 0) {
        if (pFVar4 != (FT_Pos *)0x0) {
          pFVar3 = ft_face->glyph;
          FVar5 = (pFVar3->metrics).height;
          *pFVar4 = (pFVar3->metrics).width;
          pFVar4[1] = FVar5;
          FVar5 = (pFVar3->metrics).horiBearingY;
          pFVar4[2] = (pFVar3->metrics).horiBearingX;
          pFVar4[3] = FVar5;
          FVar5 = (pFVar3->metrics).vertBearingX;
          pFVar4[4] = (pFVar3->metrics).horiAdvance;
          pFVar4[5] = FVar5;
          FVar5 = (pFVar3->metrics).vertAdvance;
          pFVar4[6] = (pFVar3->metrics).vertBearingY;
          pFVar4[7] = FVar5;
        }
        return 0;
      }
    }
  }
  return -1;
}



int ft_get_very_lazy_bbox
              (FT_UInt index,FT_Face face,FT_Size size,FT_UInt num_hmetrics,double slant,
              FT_Matrix *matrix,FT_BBox *bbox,FT_Long *horiAdvance,FT_Long *vertAdvance)

{
  long lVar1;
  FT_UShort FVar2;
  FT_UShort FVar3;
  int iVar4;
  FT_Pos FVar5;
  long lVar6;
  FT_ULong FVar7;
  long lVar8;
  long in_FS_OFFSET;
  FT_Vector p0;
  FT_Vector p1;
  FT_Vector p2;
  FT_Vector p3;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if ((*(byte *)&face->face_flags & 8) == 0) {
    iVar4 = -1;
  }
  else {
    p3.x = 0;
    iVar4 = FT_Load_Sfnt_Table(face,0x686d7478,0,0,&p3);
    if ((num_hmetrics == 0) || (iVar4 != 0)) {
      lVar8 = 0;
      FVar2 = 0;
    }
    else if (index < num_hmetrics) {
      FVar2 = 0;
      lVar8 = 0;
      FVar7 = (ulong)index * 4;
      if (FVar7 + 4 <= (ulong)p3.x) {
        FVar2 = sfnt_get_ushort(face,0x686d7478,FVar7);
        FVar3 = sfnt_get_ushort(face,0x686d7478,FVar7 + 2);
        lVar8 = (long)(short)FVar3;
      }
    }
    else {
      lVar8 = 0;
      FVar2 = 0;
      FVar7 = (ulong)(num_hmetrics - 1) * 4;
      if (FVar7 + 4 <= (ulong)p3.x) {
        FVar2 = sfnt_get_ushort(face,0x686d7478,FVar7);
        FVar7 = FVar7 + ((index - num_hmetrics) * 2 + 4);
        if (FVar7 + 2 <= (ulong)p3.x) {
          FVar3 = sfnt_get_ushort(face,0x686d7478,FVar7);
          lVar8 = (long)(short)FVar3;
        }
      }
    }
    FVar5 = FT_MulFix(FVar2,(size->metrics).x_scale);
    *horiAdvance = FVar5;
    bbox->xMax = FVar5;
    FVar5 = FT_MulFix(lVar8,(size->metrics).x_scale);
    bbox->xMin = FVar5;
    FVar5 = FT_MulFix((face->bbox).yMin,(size->metrics).y_scale);
    bbox->yMin = FVar5;
    lVar8 = FT_MulFix((face->bbox).yMax,(size->metrics).y_scale);
    bbox->yMax = lVar8;
    if (slant <= 0.0) {
      if (slant < 0.0) {
        bbox->xMax = (long)((double)bbox->yMin * slant + (double)bbox->xMax);
        bbox->xMin = (long)((double)lVar8 * slant + (double)bbox->xMin);
      }
    }
    else {
      bbox->xMax = (long)((double)lVar8 * slant + (double)bbox->xMax);
      bbox->xMin = (long)((double)bbox->yMin * slant + (double)bbox->xMin);
    }
    *vertAdvance = -1;
    p0.x = bbox->xMin;
    p1.x = bbox->xMax;
    p0.y = bbox->yMin;
    p2.y = bbox->yMax;
    p1.y = p0.y;
    p2.x = p0.x;
    p3.x = p1.x;
    p3.y = p2.y;
    FT_Vector_Transform(&p0,matrix);
    FT_Vector_Transform(&p1,matrix);
    FT_Vector_Transform(&p2,matrix);
    FT_Vector_Transform(&p3,matrix);
    lVar8 = p2.x;
    if (p3.x <= p2.x) {
      lVar8 = p3.x;
    }
    if (p1.x < lVar8) {
      lVar8 = p1.x;
    }
    if (p0.x < lVar8) {
      lVar8 = p0.x;
    }
    lVar6 = p3.x;
    if (p3.x < p2.x) {
      lVar6 = p2.x;
    }
    bbox->xMin = lVar8;
    if (lVar6 < p1.x) {
      lVar6 = p1.x;
    }
    if (lVar6 < p0.x) {
      lVar6 = p0.x;
    }
    bbox->xMax = lVar6;
    lVar8 = p2.y;
    if (p3.y <= p2.y) {
      lVar8 = p3.y;
    }
    if (p1.y < lVar8) {
      lVar8 = p1.y;
    }
    if (p0.y < lVar8) {
      lVar8 = p0.y;
    }
    lVar6 = p3.y;
    if (p3.y < p2.y) {
      lVar6 = p2.y;
    }
    bbox->yMin = lVar8;
    if (lVar6 < p1.y) {
      lVar6 = p1.y;
    }
    if (lVar6 < p0.y) {
      lVar6 = p0.y;
    }
    bbox->yMax = lVar6;
    iVar4 = 0;
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int FreeTypeRasteriseGlyph(uint idx,int flags,CharInfoPtr tgp,FTInstancePtr instance,int hasMetrics)

{
  double *pdVar1;
  FTFacePtr p_Var2;
  long lVar3;
  uchar *puVar4;
  ulong uVar5;
  INT16 IVar6;
  sbyte sVar7;
  INT16 IVar8;
  int iVar9;
  int iVar10;
  FT_Error FVar11;
  xCharInfo *pxVar12;
  byte *pbVar13;
  long lVar14;
  byte *pbVar15;
  byte *pbVar16;
  byte *pbVar17;
  byte bVar18;
  CARD16 CVar19;
  int iVar20;
  short sVar21;
  int iVar22;
  uint uVar23;
  uint uVar24;
  int iVar25;
  uint uVar26;
  int iVar27;
  long lVar28;
  int iVar29;
  FT_GlyphSlot_conflict pFVar30;
  long lVar31;
  int iVar32;
  undefined4 in_register_00000084;
  FT_Glyph_Metrics *metrics_return;
  byte bVar33;
  int *in_R9;
  long lVar34;
  INT16 IVar35;
  FT_Glyph_Metrics *pFVar36;
  byte bVar37;
  int iVar38;
  FT_Glyph_Metrics *pFVar39;
  long in_FS_OFFSET;
  double dVar40;
  double dVar41;
  double dVar42;
  double dVar43;
  uint local_104;
  uint local_100;
  ulong local_f8;
  int local_e0;
  FT_Long outline_hori_advance;
  FT_Long outline_vert_advance;
  FT_BBox bbox;
  FT_Glyph_Metrics sbit_metrics;
  
  metrics_return = (FT_Glyph_Metrics *)CONCAT44(in_register_00000084,hasMetrics);
  p_Var2 = instance->face;
  lVar3 = *(long *)(in_FS_OFFSET + 0x28);
  FreeTypeActivateInstance(instance);
  if (tgp == (CharInfoPtr)0x0) {
LAB_00114340:
    iVar10 = 0x50;
    goto LAB_00113ba5;
  }
  if (hasMetrics == 0) {
    if ((instance->spacing == 2) || ((flags & 4U) != 0)) {
      pxVar12 = instance->charcellMetrics;
LAB_00113b75:
      IVar6 = pxVar12->rightSideBearing;
      IVar35 = pxVar12->characterWidth;
      IVar8 = pxVar12->ascent;
      pFVar39 = (FT_Glyph_Metrics *)0x0;
      (tgp->metrics).leftSideBearing = pxVar12->leftSideBearing;
      (tgp->metrics).rightSideBearing = IVar6;
      (tgp->metrics).characterWidth = IVar35;
      (tgp->metrics).ascent = IVar8;
      CVar19 = pxVar12->attributes;
      local_e0 = 0;
      (tgp->metrics).descent = pxVar12->descent;
      (tgp->metrics).attributes = CVar19;
      goto joined_r0x00113b94;
    }
    if ((flags & 8U) != 0) {
      pxVar12 = instance->forceConstantMetrics;
      goto LAB_00113b75;
    }
    if ((*(byte *)&instance->load_flags & 8) == 0) {
      pFVar36 = &sbit_metrics;
      FVar11 = FT_Do_SBit_Metrics(p_Var2->face,(FT_Size)instance->strike_index,(ulong)(idx & 0xffff)
                                  ,(FT_UShort)pFVar36,metrics_return,in_R9);
      if (FVar11 != 0) goto LAB_00113851;
      pFVar39 = (FT_Glyph_Metrics *)0x0;
LAB_001145a6:
      lVar31 = pFVar36->horiBearingX;
      dVar40 = (instance->ttcap).scaleBBoxWidth;
      lVar14 = lVar31 + pFVar36->width;
      lVar34 = lVar31 + 0x3f;
      if (-1 < lVar31) {
        lVar34 = lVar31;
      }
      lVar28 = lVar14 + 0x3f;
      if (-1 < lVar14) {
        lVar28 = lVar14;
      }
      sVar21 = (short)(lVar28 >> 6);
      dVar41 = (double)pFVar36->width + (double)lVar31 + (double)lVar31;
      dVar43 = (double)pFVar36->horiAdvance * dVar40 * 0.015625 + 0.5;
      if (ABS(dVar43) < 4503599627370496.0) {
        dVar43 = (double)((ulong)dVar43 & 0x8000000000000000 |
                         (ulong)((double)(long)dVar43 -
                                (double)(-(ulong)(dVar43 < (double)(long)dVar43) &
                                        0x3ff0000000000000)));
      }
      lVar14 = pFVar36->horiBearingY;
      iVar10 = (int)dVar43;
      lVar31 = lVar14 + 0x3f;
      if (-1 < lVar14) {
        lVar31 = lVar14;
      }
      IVar6 = (INT16)(lVar31 >> 6);
      lVar14 = pFVar36->height - lVar14;
      uVar5 = (instance->ttcap).flags;
      if (lVar14 < 0) {
        lVar14 = lVar14 + 0x3f;
      }
      IVar35 = (INT16)(lVar14 >> 6);
      iVar29 = iVar10;
      if ((uVar5 & 8) != 0) {
        iVar29 = iVar10 + (instance->ttcap).doubleStrikeShift;
      }
      iVar29 = iVar29 + (instance->ttcap).adjustBBoxWidthByPixel;
      metrics_return = (FT_Glyph_Metrics *)(ulong)((uint)uVar5 & 1);
      if ((uVar5 & 1) != 0) {
        sVar21 = (short)(instance->ttcap).doubleStrikeShift + sVar21;
      }
      uVar24 = (int)(lVar34 >> 6) + (instance->ttcap).adjustLeftSideBearingByPixel +
               (instance->ttcap).lsbShiftOfBitmapAutoItalic;
      sVar21 = (short)(instance->ttcap).adjustRightSideBearingByPixel + sVar21 +
               (short)(instance->ttcap).rsbShiftOfBitmapAutoItalic;
      dVar40 = ((double)(pFVar36->horiAdvance * 1000) * dVar40 * ((double)iVar29 / (double)iVar10) *
               0.015625) / instance->pixel_size;
      if (ABS(dVar40) < 4503599627370496.0) {
        dVar40 = (double)((ulong)dVar40 & 0x8000000000000000 |
                         (ulong)((double)(long)dVar40 -
                                (double)(-(ulong)(dVar40 < (double)(long)dVar40) &
                                        0x3ff0000000000000)));
      }
      CVar19 = (CARD16)(int)dVar40;
LAB_00113aaf:
      in_R9 = (int *)(ulong)uVar24;
      (tgp->metrics).attributes = CVar19;
      (tgp->metrics).leftSideBearing = (INT16)uVar24;
      (tgp->metrics).rightSideBearing = sVar21;
      (tgp->metrics).characterWidth = (INT16)iVar29;
      (tgp->metrics).ascent = IVar6;
      (tgp->metrics).descent = IVar35;
      if (instance->spacing != 0) {
        (tgp->metrics).characterWidth = instance->charcellMetrics->characterWidth;
      }
      local_e0 = 0;
      if ((*(byte *)((long)&(instance->ttcap).flags + 1) & 8) != 0) {
        dVar40 = (instance->advance * 0.5 - dVar41 * 0.5 * 0.015625) + 0.5;
        if (ABS(dVar40) < 4503599627370496.0) {
          dVar40 = (double)((ulong)((double)(long)dVar40 -
                                   (double)(-(ulong)(dVar40 < (double)(long)dVar40) &
                                           0x3ff0000000000000)) | (ulong)dVar40 & 0x8000000000000000
                           );
        }
        local_e0 = (int)dVar40;
        in_R9 = (int *)(ulong)(uVar24 + local_e0);
        (tgp->metrics).leftSideBearing = (INT16)(uVar24 + local_e0);
        (tgp->metrics).rightSideBearing = sVar21 + (short)local_e0;
      }
      goto joined_r0x00113b94;
    }
LAB_00113851:
    if (((*(byte *)&(instance->ttcap).flags & 0x10) != 0) &&
       (iVar10 = ft_get_very_lazy_bbox
                           (idx,p_Var2->face,instance->size,p_Var2->num_hmetrics,
                            (instance->ttcap).vl_slant,&(instance->transformation).matrix,&bbox,
                            &outline_hori_advance,&outline_vert_advance), iVar10 == 0)) {
      pFVar36 = (FT_Glyph_Metrics *)0x0;
LAB_001138d5:
      dVar41 = (double)(bbox.xMin + bbox.xMax);
      metrics_return = (FT_Glyph_Metrics *)(bbox.xMax + 0x20 >> 6);
      IVar35 = (INT16)(0x1f - bbox.yMin >> 6);
      uVar5 = (instance->ttcap).flags;
      sVar21 = (short)metrics_return;
      dVar40 = instance->pixel_width_unit_x;
      IVar6 = (INT16)(bbox.yMax + 0x20 >> 6);
      iVar10 = (instance->ttcap).adjustBBoxWidthByPixel;
      if ((false) || (dVar40 != 0.0)) {
        dVar43 = (instance->ttcap).scaleBBoxWidth;
        dVar42 = (double)outline_hori_advance * dVar43 * dVar40 * 0.015625 + 0.5;
        if (ABS(dVar42) < 4503599627370496.0) {
          dVar42 = (double)((ulong)((double)(long)dVar42 -
                                   (double)(-(ulong)(dVar42 < (double)(long)dVar42) &
                                           0x3ff0000000000000)) | (ulong)dVar42 & 0x8000000000000000
                           );
        }
        iVar29 = (int)dVar42;
        dVar42 = (double)iVar29;
        if ((uVar5 & 8) != 0) {
          iVar29 = iVar29 + (instance->ttcap).doubleStrikeShift;
        }
        iVar29 = iVar29 + iVar10;
        dVar40 = (double)(outline_hori_advance * 1000) * dVar43 * ((double)iVar29 / dVar42) * dVar40
                 * 0.015625;
        if (ABS(dVar40) < 4503599627370496.0) {
          dVar40 = (double)((ulong)dVar40 & 0x8000000000000000 |
                           (ulong)((double)(long)dVar40 -
                                  (double)(-(ulong)(dVar40 < (double)(long)dVar40) &
                                          0x3ff0000000000000)));
        }
        CVar19 = (CARD16)(int)dVar40;
      }
      else {
        dVar40 = (instance->ttcap).scaleBBoxHeight;
        dVar43 = (double)outline_vert_advance * dVar40 * instance->pixel_width_unit_y * 0.015625 +
                 0.5;
        if (ABS(dVar43) < 4503599627370496.0) {
          dVar43 = (double)((ulong)((double)(long)dVar43 -
                                   (double)(-(ulong)(dVar43 < (double)(long)dVar43) &
                                           0x3ff0000000000000)) | (ulong)dVar43 & 0x8000000000000000
                           );
        }
        iVar29 = (int)dVar43;
        if (iVar29 < 1) {
          iVar29 = (int)instance->charcellMetrics->characterWidth;
        }
        dVar43 = (double)iVar29;
        if ((uVar5 & 8) != 0) {
          iVar29 = iVar29 + (instance->ttcap).doubleStrikeShift;
        }
        iVar29 = iVar29 + iVar10;
        dVar40 = (double)(outline_vert_advance * 1000) * dVar40 * ((double)iVar29 / dVar43) *
                 instance->pixel_width_unit_y * 0.015625;
        if (ABS(dVar40) < 4503599627370496.0) {
          dVar40 = (double)((ulong)dVar40 & 0x8000000000000000 |
                           (ulong)((double)(long)dVar40 -
                                  (double)(-(ulong)(dVar40 < (double)(long)dVar40) &
                                          0x3ff0000000000000)));
        }
        CVar19 = (CARD16)(int)dVar40;
        if (CVar19 == 0) {
          CVar19 = instance->charcellMetrics->attributes;
        }
      }
      if ((uVar5 & 1) != 0) {
        sVar21 = (short)(instance->ttcap).doubleStrikeShift + sVar21;
      }
      sVar21 = sVar21 + (short)(instance->ttcap).adjustRightSideBearingByPixel;
      uVar24 = (int)(bbox.xMin + 0x20 >> 6) + (instance->ttcap).adjustLeftSideBearingByPixel;
      pFVar39 = pFVar36;
      goto LAB_00113aaf;
    }
    iVar10 = FT_Load_Glyph(instance->face->face,idx,instance->load_flags);
    if (iVar10 == 0) {
      pFVar30 = p_Var2->face->glyph;
      pFVar36 = &pFVar30->metrics;
      pFVar39 = pFVar36;
      if (pFVar30->format == FT_GLYPH_FORMAT_BITMAP) goto LAB_001145a6;
      iVar10 = FT_Outline_Get_BBox(&pFVar30->outline,&bbox);
      if (iVar10 == 0) {
        outline_hori_advance = (pFVar30->metrics).horiAdvance;
        outline_vert_advance = (pFVar30->metrics).vertAdvance;
        goto LAB_001138d5;
      }
    }
    goto LAB_00114330;
  }
  local_e0 = 0;
  pFVar39 = (FT_Glyph_Metrics *)0x0;
joined_r0x00113b94:
  if ((flags & 2U) == 0) {
    local_100 = 1;
    if (instance->spacing != 2) {
      local_100 = flags & 8;
      if ((flags & 8U) == 0) {
        if ((((*(byte *)&instance->load_flags & 8) != 0) ||
            (FVar11 = FT_Do_SBit_Metrics(p_Var2->face,(FT_Size)instance->strike_index,
                                         (ulong)(idx & 0xffff),0,metrics_return,in_R9), FVar11 != 0)
            ) && ((*(byte *)&(instance->ttcap).flags & 0x10) != 0)) {
          local_100 = (uint)((ulong)p_Var2->face->face_flags >> 3) & 1;
        }
      }
      else {
        local_100 = 1;
      }
    }
    if ((flags & 4U) == 0) {
      if (pFVar39 == (FT_Glyph_Metrics *)0x0) {
        iVar10 = FT_Load_Glyph(instance->face->face,idx,instance->load_flags);
        pFVar30 = p_Var2->face->glyph;
        pFVar39 = &pFVar30->metrics;
        if (iVar10 != 0) goto LAB_00114330;
      }
      else {
        pFVar30 = p_Var2->face->glyph;
      }
      if (pFVar30->format == FT_GLYPH_FORMAT_BITMAP) {
        local_104 = 0;
        if (((*(byte *)((long)&(instance->ttcap).flags + 1) & 8) != 0) && ((hasMetrics & 1U) != 0))
        {
          dVar40 = ((double)pFVar39->horiBearingX + (double)pFVar39->horiBearingX +
                   (double)pFVar39->width) * 0.5 * 0.015625;
          goto LAB_001137aa;
        }
        goto LAB_00113c58;
      }
      iVar10 = FT_Outline_Get_BBox(&pFVar30->outline,&bbox);
      if (iVar10 == 0) {
        bbox.yMin = bbox.yMin & 0xffffffffffffffc0;
        bbox.yMax = bbox.yMax + 0x3fU & 0xffffffffffffffc0;
        if ((int)(bbox.yMax - bbox.yMin >> 6) == 0) goto LAB_00113c21;
        iVar10 = FT_Render_Glyph(p_Var2->face->glyph,2);
        if (iVar10 != 0) goto LAB_00114330;
        if (((*(byte *)((long)&(instance->ttcap).flags + 1) & 8) == 0) || ((hasMetrics & 1U) == 0))
        {
          local_104 = 1;
          goto LAB_00113c58;
        }
        if (local_100 == 0) {
          iVar10 = FT_Outline_Get_BBox(&p_Var2->face->glyph->outline,&bbox);
          if (iVar10 != 0) goto LAB_00114330;
LAB_001147e2:
          local_104 = 1;
        }
        else {
          iVar10 = ft_get_very_lazy_bbox
                             (idx,p_Var2->face,instance->size,p_Var2->num_hmetrics,
                              (instance->ttcap).vl_slant,&(instance->transformation).matrix,&bbox,
                              &outline_hori_advance,&outline_vert_advance);
          local_104 = 0xffffffff;
          if (iVar10 == 0) goto LAB_001147e2;
        }
        dVar40 = (double)(bbox.xMin + bbox.xMax) * 0.5 * 0.015625;
        goto LAB_001137aa;
      }
LAB_00114330:
      iVar10 = FTtoXReturnCode(iVar10);
      goto LAB_00113ba5;
    }
LAB_00113c21:
    if (((*(byte *)((long)&(instance->ttcap).flags + 1) & 8) == 0) || ((hasMetrics & 1U) == 0)) {
      local_104 = 0xffffffff;
    }
    else {
      local_104 = 0xffffffff;
      dVar40 = 0.0;
LAB_001137aa:
      dVar40 = (instance->advance * 0.5 - dVar40) + 0.5;
      if (ABS(dVar40) < 4503599627370496.0) {
        dVar40 = (double)((ulong)dVar40 & 0x8000000000000000 |
                         (ulong)((double)(long)dVar40 -
                                (double)(-(ulong)(dVar40 < (double)(long)dVar40) &
                                        0x3ff0000000000000)));
      }
      local_e0 = (int)dVar40;
    }
LAB_00113c58:
    iVar38 = (int)(tgp->metrics).ascent;
    iVar22 = (int)(tgp->metrics).leftSideBearing;
    iVar10 = (instance->bmfmt).glyph;
    iVar20 = (tgp->metrics).descent + iVar38;
    iVar32 = (tgp->metrics).rightSideBearing - iVar22;
    iVar29 = 1;
    if (0 < iVar20) {
      iVar29 = iVar20;
    }
    iVar25 = 1;
    if (0 < iVar32) {
      iVar25 = iVar32;
    }
    uVar24 = iVar25 + -1 + iVar10 * 8 >> 3 & -iVar10;
    iVar25 = uVar24 * iVar29;
    pbVar13 = (byte *)calloc(1,(long)iVar25);
    if (pbVar13 == (byte *)0x0) goto LAB_00114340;
    tgp->bits = (char *)pbVar13;
    if (((local_104 == 0xffffffff) || (iVar32 < 1)) || (iVar20 < 1)) goto LAB_00113ba0;
    local_f8 = (instance->ttcap).flags;
    pFVar30 = p_Var2->face->glyph;
    iVar38 = iVar38 - pFVar30->bitmap_top;
    iVar22 = pFVar30->bitmap_left - iVar22;
    if ((local_f8 & 0x800) != 0) {
      iVar22 = local_e0 + iVar22;
    }
    if ((local_104 & local_100) == 0) {
      uVar26 = (uint)local_f8 & 1;
    }
    else {
      iVar10 = FT_Outline_Get_BBox(&pFVar30->outline,&bbox);
      if (iVar10 != 0) goto LAB_00114330;
      local_f8 = (instance->ttcap).flags;
      iVar10 = (int)(tgp->metrics).rightSideBearing;
      iVar20 = (int)(tgp->metrics).leftSideBearing;
      uVar26 = (uint)local_f8 & 1;
      if ((local_f8 & 1) != 0) {
        iVar10 = iVar10 - (instance->ttcap).doubleStrikeShift;
      }
      if ((local_f8 & 0x800) != 0) {
        iVar20 = iVar20 - local_e0;
        iVar10 = iVar10 - local_e0;
      }
      iVar32 = (int)(bbox.yMax + 0x20 >> 6);
      iVar9 = (int)(0x1f - bbox.yMin >> 6);
      if ((flags & 8U) == 0) {
        lVar14._0_4_ = (instance->ttcap).adjustLeftSideBearingByPixel;
        lVar14._4_4_ = (instance->ttcap).adjustRightSideBearingByPixel;
        if (lVar14 != 0) goto LAB_001142b8;
LAB_001144ff:
        iVar10 = iVar10 - (int)(bbox.xMax + 0x20 >> 6);
        iVar32 = (tgp->metrics).ascent - iVar32;
        iVar9 = (tgp->metrics).descent - iVar9;
        iVar20 = (int)(bbox.xMin + 0x20 >> 6) - iVar20;
        if ((iVar20 < 0) && (0 < iVar10)) {
          iVar22 = iVar22 + 1;
        }
        else if (iVar10 < 0) {
          iVar22 = iVar22 + -1 + (uint)(iVar20 < 1);
        }
      }
      else {
        if (((instance->ttcap).force_c_adjust_lsb_by_pixel == 0) &&
           ((instance->ttcap).force_c_adjust_rsb_by_pixel == 0)) goto LAB_001144ff;
LAB_001142b8:
        iVar32 = (tgp->metrics).ascent - iVar32;
        iVar9 = (tgp->metrics).descent - iVar9;
      }
      pFVar30 = p_Var2->face->glyph;
      if ((iVar32 < 0) && (0 < iVar9)) {
        iVar38 = iVar38 + 1;
      }
      else if (iVar9 < 0) {
        iVar38 = iVar38 + -1 + (uint)(iVar32 < 1);
      }
    }
    bVar37 = (byte)iVar22;
    if (iVar22 < 0) {
      iVar22 = (iVar22 + 7 >> 3) + -1;
      bVar37 = -bVar37 & 7;
      bVar18 = 8 - bVar37;
    }
    else {
      iVar22 = iVar22 >> 3;
      bVar18 = bVar37 & 7;
      bVar37 = 8 - (bVar37 & 7);
    }
    iVar10 = 0;
    if (-1 < iVar38) {
      iVar10 = iVar38;
    }
    if (iVar10 < iVar29) {
      iVar20 = iVar10 * uVar24;
      uVar23 = iVar10 - iVar38;
      do {
        while( true ) {
          if ((pFVar30->bitmap).rows <= uVar23) goto LAB_00113efa;
          iVar10 = 0;
          if (-1 < iVar22) {
            iVar10 = iVar22;
          }
          if (iVar10 < (int)uVar24) break;
LAB_00113dc0:
          uVar23 = uVar23 + 1;
          iVar20 = iVar20 + uVar24;
          if (iVar29 - iVar38 == uVar23) goto LAB_00113efa;
        }
        iVar32 = (pFVar30->bitmap).pitch;
        iVar9 = iVar10 - iVar22;
        iVar27 = uVar23 * iVar32;
        puVar4 = (pFVar30->bitmap).buffer;
        if ((0 < iVar9) && (iVar9 + -1 < iVar32)) {
          pbVar13[(long)iVar10 + (long)iVar20] =
               pbVar13[(long)iVar10 + (long)iVar20] |
               puVar4[(long)(iVar9 + -1) + (long)iVar27] << (bVar37 & 0x1f);
        }
        if ((iVar9 < 0) || ((pFVar30->bitmap).pitch <= iVar9)) goto LAB_00113dc0;
        pbVar13[(long)iVar10 + (long)iVar20] =
             pbVar13[(long)iVar10 + (long)iVar20] |
             (byte)((int)(uint)puVar4[(long)iVar9 + (long)iVar27] >> (bVar18 & 0x1f));
        if ((int)uVar24 <= iVar10 + 1) goto LAB_00113dc0;
        lVar14 = (long)(iVar9 + 1);
        pbVar16 = pbVar13 + (long)(iVar10 + 1) + (long)iVar20;
        do {
          bVar33 = puVar4[lVar14 + (long)iVar27 + -1] << (bVar37 & 0x1f) | *pbVar16;
          *pbVar16 = bVar33;
          if ((pFVar30->bitmap).pitch <= (int)lVar14) break;
          lVar31 = lVar14 + iVar27;
          lVar14 = lVar14 + 1;
          *pbVar16 = bVar33 | (byte)((int)(uint)puVar4[lVar31] >> (bVar18 & 0x1f));
          pbVar16 = pbVar16 + 1;
        } while ((long)iVar9 + 2 + (ulong)((uVar24 - 2) - iVar10) != lVar14);
        uVar23 = uVar23 + 1;
        iVar20 = iVar20 + uVar24;
      } while (iVar29 - iVar38 != uVar23);
    }
LAB_00113efa:
    if ((uVar26 != 0) && (iVar10 = (instance->ttcap).doubleStrikeShift, 0 < iVar10)) {
      iVar22 = 0;
      lVar14 = (ulong)(uVar24 - 1) + 1;
      do {
        if ((local_f8 & 2) == 0) {
          iVar20 = 0;
          pbVar16 = pbVar13;
          do {
            pbVar17 = pbVar16 + lVar14;
            lVar31 = 0;
            pbVar15 = pbVar16;
            if (0 < (int)uVar24) {
              do {
                bVar37 = *pbVar15;
                pbVar16 = pbVar15 + 1;
                *pbVar15 = bVar37 >> 1 | bVar37 | (byte)lVar31;
                pbVar15 = pbVar16;
                lVar31 = (ulong)bVar37 << 7;
              } while (pbVar16 != pbVar17);
            }
            iVar20 = iVar20 + 1;
          } while (iVar29 != iVar20);
        }
        else {
          iVar20 = 0;
          pbVar16 = pbVar13;
          do {
            if (0 < (int)uVar24) {
              bVar37 = *pbVar16;
              pbVar17 = pbVar16 + lVar14;
              iVar32 = 0;
              while( true ) {
                pbVar15 = pbVar16;
                iVar38 = (uint)bVar37 << 7;
                pbVar16 = pbVar15 + 1;
                bVar33 = ~bVar37;
                bVar37 = bVar37 | bVar37 >> 1;
                bVar18 = ~(bVar37 * '\x02' & bVar33) & (bVar37 | (byte)iVar32);
                *pbVar15 = bVar18;
                if (pbVar16 == pbVar17) break;
                bVar37 = *pbVar16;
                iVar32 = iVar38;
                if (((bVar33 & 1) != 0) && ((char)bVar37 < '\0')) {
                  *pbVar15 = bVar18 & 0xfe;
                }
              }
            }
            iVar20 = iVar20 + 1;
          } while (iVar29 != iVar20);
        }
        iVar22 = iVar22 + 1;
      } while (iVar22 != iVar10);
    }
    if ((local_104 == 0) &&
       (lVar31._0_4_ = (instance->ttcap).lsbShiftOfBitmapAutoItalic,
       lVar31._4_4_ = (instance->ttcap).rsbShiftOfBitmapAutoItalic, lVar31 != 0)) {
      iVar32 = (int)instance->charcellMetrics->ascent;
      iVar38 = iVar32 + instance->charcellMetrics->descent;
      iVar10 = (instance->ttcap).rsbShiftOfBitmapAutoItalic;
      iVar22 = (instance->ttcap).lsbShiftOfBitmapAutoItalic;
      iVar20 = iVar22 - iVar10;
      pdVar1 = &(instance->ttcap).autoItalic;
      if (0.0 < *pdVar1 || *pdVar1 == 0.0) {
        iVar20 = iVar10 - iVar22;
      }
      uVar26 = uVar24 - 1;
      iVar10 = ((iVar38 + -1) - (iVar32 - (tgp->metrics).ascent)) * iVar20;
      lVar14 = (long)(int)uVar24;
      iVar22 = uVar24 - ((int)pbVar13 + (int)(lVar14 + -1));
      uVar23 = 0;
      if ((int)uVar26 < 1) {
        uVar23 = uVar26;
      }
      iVar32 = 0;
      do {
        uVar5 = (long)iVar10 / (long)iVar38;
        iVar9 = (int)uVar5;
        if (iVar9 < 0) {
          if (((-iVar9 & 7U) != 0) && (0 < (int)uVar24)) {
            sVar7 = (sbyte)(-iVar9 & 7U);
            pbVar16 = pbVar13;
            while( true ) {
              bVar37 = *pbVar16 << sVar7;
              *pbVar16 = bVar37;
              if (pbVar13 + uVar26 == pbVar16) break;
              *pbVar16 = (byte)((int)(uint)pbVar16[1] >> (8U - sVar7 & 0x1f)) | bVar37;
              pbVar16 = pbVar16 + 1;
            }
          }
          if (0xe < 7U - iVar9) {
            pbVar16 = pbVar13;
            if (1 < (int)uVar24) {
              do {
                pbVar17 = pbVar16 + 1;
                *pbVar16 = pbVar16[1];
                pbVar16 = pbVar17;
              } while (pbVar13 + (ulong)(uVar24 - 2) + 1 != pbVar17);
              pbVar16 = pbVar13 + (int)uVar26;
            }
            *pbVar16 = 0;
          }
        }
        else {
          bVar37 = (byte)uVar5 & 7;
          if (((uVar5 & 7) != 0) && (0 < (int)uVar24)) {
            bVar18 = pbVar13[(int)uVar26];
            pbVar16 = pbVar13 + (int)uVar26;
            while( true ) {
              bVar33 = (byte)((int)(uint)bVar18 >> bVar37);
              *pbVar16 = bVar33;
              if (pbVar13 + ((lVar14 + -1) - (ulong)uVar26) == pbVar16) break;
              bVar18 = pbVar16[-1];
              if (uVar24 != iVar22 + -1 + (int)pbVar16) {
                *pbVar16 = bVar18 << (8 - bVar37 & 0x1f) | bVar33;
              }
              pbVar16 = pbVar16 + -1;
            }
          }
          if (0xe < iVar9 + 7U) {
            if (0 < (int)uVar26) {
              pbVar16 = pbVar13 + (int)uVar26;
              do {
                pbVar17 = pbVar16 + -1;
                *pbVar16 = pbVar16[-1];
                pbVar16 = pbVar17;
              } while (pbVar17 != pbVar13 + ((lVar14 + -2) - (ulong)(uVar24 - 2)));
            }
            pbVar13[(int)uVar23] = 0;
          }
        }
        iVar32 = iVar32 + 1;
        iVar10 = iVar10 - iVar20;
        pbVar13 = pbVar13 + lVar14;
        iVar22 = iVar22 - uVar24;
      } while (iVar29 != iVar32);
    }
    iVar10 = (instance->bmfmt).bit;
    if (iVar10 == 0) {
      BitOrderInvert((uchar *)tgp->bits,iVar25);
      iVar10 = (instance->bmfmt).bit;
    }
    if ((instance->bmfmt).byte != iVar10) {
      iVar10 = (instance->bmfmt).scan;
      if (iVar10 == 2) {
        TwoByteSwap((uchar *)tgp->bits,iVar25);
      }
      else if (iVar10 == 4) {
        FourByteSwap((uchar *)tgp->bits,iVar25);
        iVar10 = 0x55;
        goto LAB_00113ba5;
      }
    }
  }
LAB_00113ba0:
  iVar10 = 0x55;
LAB_00113ba5:
  if (lVar3 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar10;
}



int FreeTypeInstanceGetGlyphMetrics(uint idx,int flags,xCharInfo **metrics,FTInstancePtr instance)

{
  int iVar1;
  CharInfoPtr tgp;
  long in_FS_OFFSET;
  int found;
  int segment;
  int offset;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  if (instance->spacing == 2) {
    *metrics = instance->charcellMetrics;
    iVar1 = 0x55;
  }
  else if ((flags & 8U) == 0) {
    iVar1 = FreeTypeInstanceFindGlyph
                      (idx,flags,(FTInstancePtr)&instance->nglyphs,
                       (CharInfoPtr **)(ulong)(uint)(instance->ttcap).forceConstantSpacingEnd,
                       (int ***)&instance->glyphs,(int *)&instance->available,&found,&segment,
                       (FTInstancePtr)&offset);
    if (iVar1 == 0x55) {
      if (found != 0) {
        if (instance->available[segment][offset] != 1) {
          tgp = instance->glyphs[segment] + offset;
          if (instance->available[segment][offset] < 2) {
            iVar1 = FreeTypeRasteriseGlyph(idx,flags | 2,tgp,instance,0);
            if (iVar1 != 0x55) goto LAB_00114a88;
            instance->available[segment][offset] = 2;
            tgp = instance->glyphs[segment] + offset;
          }
          *metrics = &tgp->metrics;
          goto LAB_00114a88;
        }
      }
      *metrics = (xCharInfo *)0x0;
    }
  }
  else {
    *metrics = instance->forceConstantMetrics;
    iVar1 = 0x55;
  }
LAB_00114a88:
  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int FreeTypeFontGetGlyphMetrics(uint code,int flags,xCharInfo **metrics,FTFontPtr font)

{
  int iVar1;
  FTInstancePtr instance;
  uint idx_00;
  long in_FS_OFFSET;
  uint idx;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  idx = 0;
  iVar1 = ft_get_index(code,font,&idx);
  if (((iVar1 != 0) || (idx == 0)) || (idx == font->zero_idx)) {
    *metrics = (xCharInfo *)0x0;
    iVar1 = 0x55;
    goto LAB_00114c2d;
  }
  iVar1 = FreeTypeInstanceGetGlyphMetrics(idx,flags,metrics,font->instance);
  if ((iVar1 == 0x55) && (*metrics != (xCharInfo *)0x0)) {
LAB_00114c57:
    iVar1 = 0x55;
  }
  else {
    instance = font->instance;
    idx_00 = idx;
    if (font->zero_idx != idx) {
      iVar1 = FreeTypeInstanceGetGlyphMetrics(font->zero_idx,flags,metrics,instance);
      if ((iVar1 == 0x55) && (*metrics != (xCharInfo *)0x0)) goto LAB_00114c57;
      instance = font->instance;
      idx_00 = font->zero_idx;
    }
    iVar1 = FreeTypeInstanceGetGlyphMetrics(idx_00,flags | 4,metrics,instance);
  }
LAB_00114c2d:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int FreeTypeGetMetrics(FontPtr pFont,ulong count,uchar *chars,FontEncoding charEncoding,
                      ulong *metricCount,xCharInfo **metrics)

{
  ushort uVar1;
  FTFontPtr font;
  FTInstancePtr p_Var2;
  int iVar3;
  CharInfoRec *pCVar4;
  int flags;
  long lVar5;
  uint code;
  long in_FS_OFFSET;
  ulong local_58;
  xCharInfo *m;
  long local_40;
  
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  font = (FTFontPtr)pFont->fontPrivate;
  p_Var2 = font->instance;
  local_58 = count;
  if (count != 0) {
    code = 0;
    flags = 0;
    lVar5 = count - 1;
    do {
      if (charEncoding < Linear16Bit) {
        code = (uint)*chars;
        chars = (uchar *)((long)chars + 1);
      }
      else if (charEncoding + ~TwoD8Bit < 2) {
        uVar1 = *(ushort *)chars;
        chars = (uchar *)((long)chars + 2);
        iVar3 = (p_Var2->ttcap).forceConstantSpacingEnd;
        code = (uint)(ushort)(uVar1 << 8 | uVar1 >> 8);
        if ((*(byte *)((long)&(p_Var2->ttcap).flags + 1) & 4) == 0) {
          flags = 0;
          if ((int)code <= iVar3) {
            flags = (uint)((p_Var2->ttcap).forceConstantSpacingBegin <= (int)code) << 3;
          }
        }
        else {
          flags = 8;
          if (iVar3 < (int)code) {
            flags = (uint)((p_Var2->ttcap).forceConstantSpacingBegin <= (int)code) << 3;
          }
        }
      }
      iVar3 = FreeTypeFontGetGlyphMetrics(code,flags,&m,font);
      pCVar4 = &noSuchChar;
      if ((iVar3 == 0x55) && (pCVar4 = (CharInfoRec *)m, m == (xCharInfo *)0x0)) {
        pCVar4 = &noSuchChar;
      }
      lVar5 = lVar5 + -1;
      *metrics = &pCVar4->metrics;
      metrics = metrics + 1;
    } while (lVar5 != -1);
    local_58 = (long)(count << 3) >> 3;
  }
  *metricCount = local_58;
  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return 0x55;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int FreeTypeInstanceGetGlyph(uint idx,int flags,CharInfoPtr *g,FTInstancePtr instance)

{
  int iVar1;
  int iVar2;
  int iVar3;
  long in_FS_OFFSET;
  int found;
  int segment;
  int offset;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  iVar2 = FreeTypeInstanceFindGlyph
                    (idx,flags,(FTInstancePtr)&instance->nglyphs,
                     (CharInfoPtr **)(ulong)(uint)(instance->ttcap).forceConstantSpacingEnd,
                     (int ***)&instance->glyphs,(int *)&instance->available,&found,&segment,
                     (FTInstancePtr)&offset);
  iVar3 = iVar2;
  if (iVar2 != 0x55) goto LAB_00114f10;
  if (found != 0) {
    iVar1 = instance->available[segment][offset];
    if (iVar1 != 1) {
      if (iVar1 == 3) {
        *g = instance->glyphs[segment] + offset;
        goto LAB_00114f10;
      }
      iVar3 = FreeTypeRasteriseGlyph
                        (idx,flags | 1,instance->glyphs[segment] + offset,instance,(uint)(1 < iVar1)
                        );
      if (iVar3 != 0x55) {
        if (instance->available[segment][offset] < 2) goto LAB_00114f10;
        ErrorF("Warning: FreeTypeRasteriseGlyph() returns an error,\n");
        ErrorF("\tso the backend tries to set a white space.\n");
        iVar3 = FreeTypeRasteriseGlyph
                          (idx,flags | 5,instance->glyphs[segment] + offset,instance,
                           (uint)(1 < instance->available[segment][offset]));
        if (iVar3 != 0x55) goto LAB_00114f10;
      }
      instance->available[segment][offset] = 3;
      *g = instance->glyphs[segment] + offset;
      iVar3 = iVar2;
      goto LAB_00114f10;
    }
  }
  *g = (CharInfoPtr)0x0;
LAB_00114f10:
  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar3;
}



int FreeTypeGetGlyphs(FontPtr pFont,ulong count,uchar *chars,FontEncoding charEncoding,
                     ulong *glyphCount,CharInfoPtr *glyphs)

{
  ushort uVar1;
  FTFontPtr font;
  FTInstancePtr p_Var2;
  FontInfoPtr p_Var3;
  int iVar4;
  int iVar5;
  int iVar6;
  CharInfoPtr p_Var7;
  char *pcVar8;
  FTInstancePtr instance;
  CharInfoPtr *pp_Var9;
  ulong uVar10;
  uint code;
  uint idx_00;
  long lVar11;
  uint flags;
  long in_FS_OFFSET;
  uint idx;
  CharInfoPtr g;
  long local_40;
  
  font = (FTFontPtr)pFont->fontPrivate;
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  p_Var2 = font->instance;
  if (count == 0) {
    uVar10 = 0;
  }
  else {
    lVar11 = count - 1;
    flags = 0;
    code = 0;
    pp_Var9 = glyphs;
    do {
      if (charEncoding < Linear16Bit) {
        code = (uint)*chars;
        chars = (uchar *)((long)chars + 1);
      }
      else if (charEncoding + ~TwoD8Bit < 2) {
        uVar1 = *(ushort *)chars;
        chars = (uchar *)((long)chars + 2);
        iVar4 = (p_Var2->ttcap).forceConstantSpacingEnd;
        code = (uint)(ushort)(uVar1 << 8 | uVar1 >> 8);
        if ((*(byte *)((long)&(p_Var2->ttcap).flags + 1) & 4) == 0) {
          flags = 0;
          if ((int)code <= iVar4) {
            flags = (uint)((p_Var2->ttcap).forceConstantSpacingBegin <= (int)code) << 3;
          }
        }
        else {
          flags = 8;
          if (iVar4 < (int)code) {
            flags = (uint)((p_Var2->ttcap).forceConstantSpacingBegin <= (int)code) << 3;
          }
        }
      }
      idx = 0;
      iVar4 = ft_get_index(code,font,&idx);
      if (((iVar4 == 0) && (idx != 0)) && (idx != font->zero_idx)) {
        iVar4 = FreeTypeInstanceGetGlyph(idx,flags,&g,font->instance);
        if ((iVar4 != 0x55) || (p_Var7 = g, g == (CharInfoPtr)0x0)) {
          instance = font->instance;
          idx_00 = idx;
          if (font->zero_idx != idx) {
            iVar4 = FreeTypeInstanceGetGlyph(font->zero_idx,flags,&g,instance);
            if ((iVar4 == 0x55) && (p_Var7 = g, g != (CharInfoPtr)0x0)) goto LAB_00115139;
            instance = font->instance;
            idx_00 = font->zero_idx;
          }
          iVar4 = FreeTypeInstanceGetGlyph(idx_00,flags | 4,&g,instance);
          if ((iVar4 != 0x55) || (p_Var7 = g, g == (CharInfoPtr)0x0)) {
            if ((font->dummy_char).bits == (char *)0x0) goto LAB_001151c4;
            goto LAB_00115135;
          }
        }
LAB_00115139:
        *pp_Var9 = p_Var7;
        pp_Var9 = pp_Var9 + 1;
      }
      else {
        g = (CharInfoPtr)0x0;
        if ((font->dummy_char).bits != (char *)0x0) {
LAB_00115135:
          p_Var7 = &font->dummy_char;
          goto LAB_00115139;
        }
LAB_001151c4:
        p_Var3 = font->info;
        iVar4 = (font->instance->bmfmt).glyph;
        iVar5 = (int)(p_Var3->maxbounds).rightSideBearing - (int)(p_Var3->maxbounds).leftSideBearing
        ;
        if (iVar5 < 1) {
          iVar5 = 1;
        }
        iVar6 = (int)(p_Var3->maxbounds).ascent + (int)(p_Var3->maxbounds).descent;
        if (iVar6 < 1) {
          iVar6 = 1;
        }
        pcVar8 = (char *)calloc(1,(long)((iVar5 + -1 + iVar4 * 8 >> 3 & -iVar4) * iVar6));
        if (pcVar8 != (char *)0x0) {
          (font->dummy_char).bits = pcVar8;
          goto LAB_00115135;
        }
      }
      lVar11 = lVar11 + -1;
    } while (lVar11 != -1);
    uVar10 = (long)pp_Var9 - (long)glyphs >> 3;
  }
  *glyphCount = uVar10;
  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0x55;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FreeTypeLoadXFont(char *fileName,FontScalablePtr vals,FontPtr xf,FontInfoPtr info,
                     FontBitmapFormatPtr bmfmt,FontEntryPtr entry)

{
  char *pcVar1;
  double dVar2;
  char cVar3;
  byte bVar4;
  short sVar5;
  ushort uVar6;
  long lVar7;
  FTInstancePtr p_Var8;
  FTFacePtr p_Var9;
  FT_Size pFVar10;
  xCharInfo **ppxVar11;
  short sVar12;
  CARD16 CVar13;
  INT16 IVar14;
  FT_UShort FVar15;
  short sVar16;
  short sVar17;
  short sVar18;
  ushort uVar19;
  Bool BVar20;
  int iVar21;
  int iVar22;
  int iVar23;
  int iVar24;
  uint uVar25;
  FTFontPtr font;
  char *pcVar26;
  size_t sVar27;
  long lVar28;
  uint *puVar29;
  xCharInfo *pxVar30;
  xCharInfo *pxVar31;
  xCharInfo *pxVar32;
  FTFacePtr p_Var33;
  char *pcVar34;
  xCharInfo **ppxVar35;
  xCharInfo **ppxVar36;
  FontPropPtr __ptr;
  Atom AVar37;
  xCharInfo *pxVar38;
  long lVar39;
  short sVar40;
  int iVar44;
  long lVar41;
  short sVar42;
  short sVar43;
  int iVar45;
  int iVar46;
  byte *pbVar47;
  uint *puVar48;
  xCharInfo **ppxVar49;
  short sVar50;
  uint uVar51;
  uint uVar52;
  char *pcVar53;
  CARD16 CVar54;
  uint uVar55;
  uint *puVar56;
  long lVar57;
  long lVar58;
  INT16 IVar59;
  ulong uVar60;
  INT16 *pIVar61;
  short sVar62;
  int iVar63;
  uint code;
  FT_Face pFVar64;
  short sVar65;
  int iVar66;
  CARD16 CVar67;
  short sVar68;
  INT16 IVar69;
  FTFacePtr face;
  long in_FS_OFFSET;
  bool bVar70;
  bool bVar71;
  bool bVar72;
  double dVar73;
  double dVar74;
  double dVar75;
  double dVar76;
  double dVar77;
  double dVar78;
  double dVar79;
  double dVar80;
  double dVar81;
  double dVar82;
  double dVar83;
  double dVar84;
  double dVar85;
  double dVar86;
  double dVar87;
  double dVar88;
  double dVar89;
  uint *local_640;
  int local_618;
  int local_600;
  char *local_5f8;
  long local_5f0;
  double local_5e8;
  int local_5d8;
  int local_5d0;
  double local_5c8;
  short local_5c0;
  CARD16 local_5b8;
  uint local_5a8;
  CARD16 local_5a0;
  short local_58c;
  long local_578;
  long local_570;
  int local_568;
  int local_564;
  long local_558;
  ushort first_col_1;
  ushort first_col;
  ushort last_col;
  ushort first_row;
  SDynPropRecValList listPropRecVal;
  CharInfoPtr tmpglyph;
  xCharInfo *tmpchar;
  TTCapInfo tmp_ttcap;
  char val [1024];
  
  lVar7 = *(long *)(in_FS_OFFSET + 0x28);
  font = (FTFontPtr)calloc(1,0x60);
  if (font == (FTFontPtr)0x0) {
    iVar22 = 0x50;
    goto LAB_00115676;
  }
  iVar22 = vals->pixel;
  BVar20 = SPropRecValList_new(&listPropRecVal);
  if (BVar20 == 0) {
    pcVar26 = strrchr(fileName,0x2f);
    pcVar34 = pcVar26 + 1;
    if (pcVar26 == (char *)0x0) {
      pcVar34 = fileName;
    }
    pcVar26 = strrchr(pcVar34,0x3a);
    if (pcVar26 != (char *)0x0) {
      sVar27 = strlen(fileName);
      iVar44 = (int)pcVar34 - (int)fileName;
      local_640 = (uint *)malloc((long)((((int)sVar27 + (int)fileName) - (int)pcVar26) + iVar44));
      if (local_640 == (uint *)0x0) goto LAB_001156d8;
      if (0 < iVar44) {
        memcpy(local_640,fileName,(long)iVar44);
      }
      strcpy((char *)((long)local_640 + (long)iVar44),pcVar26 + 1);
      BVar20 = SPropRecValList_add_by_font_cap(&listPropRecVal,pcVar34);
      if (BVar20 == 0) goto LAB_001153ff;
      iVar22 = 0x56;
      free(local_640);
      goto LAB_001156bc;
    }
    local_640 = (uint *)strdup(fileName);
    if (local_640 == (uint *)0x0) goto LAB_001156d8;
LAB_001153ff:
    tmp_ttcap.flags = 0;
    tmp_ttcap.scaleWidth = 1.0;
    tmp_ttcap.scaleBBoxWidth = 1.0;
    tmp_ttcap.scaleBBoxHeight = 1.0;
    tmp_ttcap.force_c_adjust_rsb_by_pixel = 0;
    tmp_ttcap.force_c_representative_metrics_char_code = -2;
    tmp_ttcap.autoItalic = 0.0;
    tmp_ttcap.doubleStrikeShift = 1;
    tmp_ttcap.adjustBBoxWidthByPixel = 0;
    tmp_ttcap.adjustLeftSideBearingByPixel = 0;
    tmp_ttcap.adjustRightSideBearingByPixel = 0;
    tmp_ttcap.scaleBitmap = 0.0;
    tmp_ttcap.forceConstantSpacingBegin = -1;
    tmp_ttcap.forceConstantSpacingEnd = -1;
    tmp_ttcap.force_c_adjust_width_by_pixel = 0;
    tmp_ttcap.force_c_adjust_lsb_by_pixel = 0;
    tmp_ttcap.force_c_scale_b_box_width = 1.0;
    tmp_ttcap.force_c_scale_b_box_height = 1.0;
    tmp_ttcap.force_c_scale_lsb = 0.0;
    tmp_ttcap.force_c_scale_rsb = 1.0;
    tmp_ttcap.vl_slant = 0.0;
    tmp_ttcap.lsbShiftOfBitmapAutoItalic = 0;
    tmp_ttcap.rsbShiftOfBitmapAutoItalic = 0;
    BVar20 = SPropRecValList_search_record
                       (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,"FaceNumber");
    if (BVar20 == 0) {
LAB_00115513:
      puVar29 = (uint *)strdup((char *)local_640);
      if (puVar29 == (uint *)0x0) {
LAB_001156c8:
        free(local_640);
        goto LAB_001156d8;
      }
      local_5f0._0_4_ = 0;
    }
    else {
      pcVar34 = *(char **)&(tmpglyph->metrics).descent;
      lVar28 = strtol(pcVar34,(char **)&tmpchar,10);
      if (((*pcVar34 == '\0') ||
          (local_5f0._0_4_ = (int)lVar28, *(char *)&tmpchar->leftSideBearing != '\0')) ||
         ((int)local_5f0 < 1)) goto LAB_00115513;
      sVar27 = strlen(pcVar34);
      puVar29 = local_640;
      do {
        puVar48 = puVar29;
        uVar51 = *puVar48 + 0xfefefeff & ~*puVar48;
        uVar55 = uVar51 & 0x80808080;
        puVar29 = puVar48 + 1;
      } while (uVar55 == 0);
      bVar70 = (uVar51 & 0x8080) == 0;
      if (bVar70) {
        uVar55 = uVar55 >> 0x10;
      }
      puVar56 = puVar48 + 1;
      if (bVar70) {
        puVar56 = (uint *)((long)puVar48 + 6);
      }
      lVar28 = (-3 - (ulong)CARRY1((byte)uVar55,(byte)uVar55)) - (long)local_640;
      puVar29 = (uint *)malloc((long)puVar56 + sVar27 + lVar28 + 3);
      if (puVar29 == (uint *)0x0) goto LAB_001156c8;
      *(byte *)puVar29 = 0;
      pcVar26 = strrchr((char *)local_640,0x2f);
      if (pcVar26 == (char *)0x0) {
        *(byte *)puVar29 = 0x3a;
        pcVar34 = stpcpy((char *)((long)puVar29 + 1),pcVar34);
        *pcVar34 = ':';
        memcpy(pcVar34 + 1,local_640,(long)puVar56 + lVar28 + 1);
      }
      else {
        memcpy(puVar29,local_640,(long)puVar56 + lVar28 + 1);
        pcVar53 = strrchr((char *)puVar29,0x2f);
        pcVar53[1] = '\0';
        puVar48 = puVar29;
        do {
          puVar56 = puVar48;
          uVar51 = *puVar56 + 0xfefefeff & ~*puVar56;
          uVar55 = uVar51 & 0x80808080;
          puVar48 = puVar56 + 1;
        } while (uVar55 == 0);
        bVar70 = (uVar51 & 0x8080) == 0;
        if (bVar70) {
          uVar55 = uVar55 >> 0x10;
        }
        if (bVar70) {
          puVar48 = (uint *)((long)puVar56 + 6);
        }
        pbVar47 = (byte *)((long)puVar48 +
                          ((-3 - (ulong)CARRY1((byte)uVar55,(byte)uVar55)) - (long)puVar29));
        *(byte *)((long)puVar29 + (long)pbVar47) = 0x3a;
        pcVar34 = stpcpy((char *)((long)puVar29 + (long)(pbVar47 + 1)),pcVar34);
        *pcVar34 = ':';
        strcpy(pcVar34 + 1,pcVar26 + 1);
      }
    }
    BVar20 = SPropRecValList_search_record
                       (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,"AutoItalic");
    if (BVar20 != 0) {
      tmp_ttcap.autoItalic = *(double *)&(tmpglyph->metrics).descent;
    }
    BVar20 = SPropRecValList_search_record
                       (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,"Hinting");
    iVar44 = -1;
    if (BVar20 != 0) {
      iVar44._0_2_ = (tmpglyph->metrics).descent;
      iVar44._2_2_ = (tmpglyph->metrics).attributes;
    }
    BVar20 = SPropRecValList_search_record
                       (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,"ScaleWidth");
    if ((BVar20 == 0) ||
       (tmp_ttcap.scaleWidth = *(double *)&(tmpglyph->metrics).descent, 0.0 < tmp_ttcap.scaleWidth))
    {
      BVar20 = SPropRecValList_search_record
                         (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,"ScaleBBoxWidth");
      dVar77 = tmp_ttcap.scaleBBoxWidth;
      dVar74 = tmp_ttcap.scaleBBoxHeight;
      if (BVar20 != 0) {
        pxVar38 = *(xCharInfo **)&(tmpglyph->metrics).descent;
        if (*(char *)&pxVar38->leftSideBearing == '\0') {
LAB_001155f0:
          dVar77 = 1.0;
          dVar74 = 1.0;
          goto LAB_00115613;
        }
        dVar77 = strtod((char *)pxVar38,(char **)&tmpchar);
        cVar3 = *(char *)&tmpchar->leftSideBearing;
        if (pxVar38 == tmpchar) {
          if ((cVar3 != ',') && (cVar3 != ';')) goto LAB_001155f0;
          dVar77 = 1.0;
LAB_00116f32:
          pxVar38 = (xCharInfo *)((long)&tmpchar->leftSideBearing + 1);
          dVar74 = 1.0;
          if (cVar3 == ',') {
            dVar74 = strtod((char *)pxVar38,(char **)&tmpchar);
            if (tmpchar == pxVar38) {
              dVar74 = 1.0;
            }
            if ((*(char *)&tmpchar->leftSideBearing == ';') ||
               (*(char *)&tmpchar->leftSideBearing == ',')) {
              pxVar38 = (xCharInfo *)((long)&tmpchar->leftSideBearing + 1);
              goto LAB_00116f4b;
            }
          }
          else {
LAB_00116f4b:
            lVar28 = strtol((char *)pxVar38,(char **)&tmpchar,10);
            if (tmpchar != pxVar38) {
              tmp_ttcap.adjustBBoxWidthByPixel = (int)lVar28;
            }
            if (*(char *)&tmpchar->leftSideBearing == ',') {
              pxVar38 = (xCharInfo *)((long)&tmpchar->leftSideBearing + 1);
              lVar28 = strtol((char *)pxVar38,(char **)&tmpchar,10);
              if (pxVar38 != tmpchar) {
                tmp_ttcap.adjustLeftSideBearingByPixel = (int)lVar28;
              }
              if ((*(char *)&tmpchar->leftSideBearing == ',') &&
                 (pxVar38 = (xCharInfo *)((long)&tmpchar->leftSideBearing + 1),
                 lVar28 = strtol((char *)pxVar38,(char **)&tmpchar,10), pxVar38 != tmpchar)) {
                tmp_ttcap.adjustRightSideBearingByPixel = (int)lVar28;
              }
            }
          }
          if (dVar77 <= 0.0) goto LAB_00115a7b;
          if (0.0 < dVar74) goto LAB_00115613;
          fwrite("ScaleBBoxHeight needs plus.\n",1,0x1c,_stderr);
        }
        else {
          if ((cVar3 == ';') || (cVar3 == ',')) goto LAB_00116f32;
          if (0.0 < dVar77) {
            dVar74 = 1.0;
            goto LAB_00115613;
          }
LAB_00115a7b:
          fwrite("ScaleBBoxWitdh needs plus.\n",1,0x1b,_stderr);
        }
switchD_00115761_caseD_4f:
        bVar70 = true;
        face = (FTFacePtr)0x0;
        iVar22 = 0x53;
        goto LAB_0011565d;
      }
LAB_00115613:
      tmp_ttcap.scaleBBoxHeight = dVar74;
      tmp_ttcap.scaleBBoxWidth = dVar77;
      local_5e8._0_4_ =
           SPropRecValList_search_record
                     (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,"ForceSpacing");
      if (local_5e8._0_4_ != 0) {
        pcVar34 = *(char **)&(tmpglyph->metrics).descent;
        sVar27 = strlen(pcVar34);
        if (sVar27 == 1) {
          cVar3 = *pcVar34;
          if (cVar3 == 'c') {
LAB_00115a20:
            local_5e8._0_4_ = (Bool)cVar3;
            goto LAB_00115713;
          }
          if (cVar3 < 'd') {
            if (cVar3 == 'M') {
              tmp_ttcap.flags = tmp_ttcap.flags | 0x800;
              local_5e8._0_4_ = 0x6d;
              goto LAB_00115713;
            }
          }
          else if ((cVar3 == 'm') || (cVar3 == 'p')) goto LAB_00115a20;
        }
        goto switchD_00115761_caseD_4f;
      }
LAB_00115713:
      BVar20 = SPropRecValList_search_record
                         (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,"DoubleStrike");
      if (BVar20 != 0) {
        pcVar34 = *(char **)&(tmpglyph->metrics).descent;
        if ((*pcVar34 == '\0') || (false)) goto switchD_00115761_caseD_4f;
        switch(*pcVar34) {
        case 'L':
        case 'M':
        case 'l':
        case 'm':
          tmp_ttcap.flags = tmp_ttcap.flags | 3;
          break;
        case 'N':
        case 'n':
          tmp_ttcap.flags = tmp_ttcap.flags & 0xfffffffffffffff4;
          break;
        default:
          goto switchD_00115761_caseD_4f;
        case 'Y':
        case 'y':
          tmp_ttcap.flags = tmp_ttcap.flags | 1;
        }
        if (((pcVar34[1] != 0) && (uVar55 = (byte)pcVar34[1] - 0x42, (byte)uVar55 < 0x38)) &&
           ((0x80400100804001U >> ((ulong)uVar55 & 0x3f) & 1) != 0)) {
          tmp_ttcap.flags = tmp_ttcap.flags | 8;
        }
        pcVar26 = strchr(pcVar34,0x3b);
        if ((pcVar26 != (char *)0x0) || (pcVar26 = strchr(pcVar34,0x2c), pcVar26 != (char *)0x0)) {
          pxVar38 = (xCharInfo *)(pcVar26 + 1);
          if ((pcVar26[1] != '\0') &&
             ((lVar28 = strtol((char *)pxVar38,(char **)&tmpchar,10), tmpchar != pxVar38 &&
              ((int)lVar28 <= iVar22)))) {
            tmp_ttcap.flags = tmp_ttcap.flags & 0xfffffffffffffffd;
          }
          pcVar34 = strchr((char *)pxVar38,0x2c);
          if ((pcVar34 != (char *)0x0) && (pcVar34[1] != '\0')) {
            lVar28 = strtol(pcVar34 + 1,(char **)&tmpchar,10);
            if ((tmpchar != (xCharInfo *)(pcVar34 + 1)) &&
               (((int)lVar28 <= iVar22 && ((tmp_ttcap.flags & 1U) != 0)))) {
              tmp_ttcap.doubleStrikeShift = tmp_ttcap.doubleStrikeShift + iVar22 / (int)lVar28;
            }
          }
        }
      }
      BVar20 = SPropRecValList_search_record
                         (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,"VeryLazyMetrics");
      if (BVar20 != 0) {
        iVar22._0_2_ = (tmpglyph->metrics).descent;
        iVar22._2_2_ = (tmpglyph->metrics).attributes;
        if (iVar22 == -1) {
          tmp_ttcap.flags = tmp_ttcap.flags | 0x30;
        }
        else {
          tmp_ttcap.flags = tmp_ttcap.flags & 0xffffffffffffffefU | 0x20;
        }
      }
      BVar20 = SPropRecValList_search_record
                         (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,"EmbeddedBitmap");
      if (BVar20 == 0) {
        local_5d8 = -1;
        iVar22 = 0;
        goto LAB_00115aa8;
      }
      pcVar34 = *(char **)&(tmpglyph->metrics).descent;
      sVar27 = strlen(pcVar34);
      if ((sVar27 != 1) || (false)) goto switchD_00115761_caseD_4f;
      switch(*pcVar34) {
      case 'N':
      case 'n':
        local_5d8 = 0;
        iVar22 = 0;
        break;
      default:
        goto switchD_00115761_caseD_4f;
      case 'U':
      case 'u':
        local_5d8 = -1;
        iVar22 = 0;
        break;
      case 'Y':
      case 'y':
        local_5d8 = -1;
        iVar22 = -1;
      }
LAB_00115aa8:
      if (((tmp_ttcap.flags & 0x10U) != 0) &&
         (BVar20 = SPropRecValList_search_record
                             (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,
                              "VeryLazyBitmapWidthScale"), BVar20 != 0)) {
        dVar77 = *(double *)&(tmpglyph->metrics).descent;
        fwrite("Warning: `bs\' option is not required in X-TT version 2.\n",1,0x38,_stderr);
        tmp_ttcap.scaleBitmap = dVar77;
      }
      BVar20 = SPropRecValList_search_record
                         (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,"CodeRange");
      if (BVar20 == 0) {
        local_5f8 = (char *)0x0;
      }
      else {
        local_5f8 = strdup(*(char **)&(tmpglyph->metrics).descent);
        if (local_5f8 == (char *)0x0) {
          bVar70 = true;
          face = (FTFacePtr)0x0;
          iVar22 = 0x50;
          goto LAB_0011565d;
        }
      }
      last_col = 0xff;
      tmpchar = (xCharInfo *)CONCAT62(tmpchar._2_6_,0xff);
      first_col = 0;
      first_row = 0;
      BVar20 = SPropRecValList_search_record
                         (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,
                          "ForceConstantSpacingCodeRange");
      if ((BVar20 != 0) &&
         (iVar21 = restrict_code_range_by_str
                             (1,&first_col,&first_row,&last_col,(ushort *)&tmpchar,
                              *(char **)&(tmpglyph->metrics).descent), iVar21 == 1)) {
        tmp_ttcap.forceConstantSpacingBegin = (uint)first_row << 8 | (uint)first_col;
        tmp_ttcap.forceConstantSpacingEnd = (uint)(ushort)tmpchar << 8 | (uint)last_col;
        uVar60 = tmp_ttcap.flags | 0x400;
        tmp_ttcap.flags = tmp_ttcap.flags & 0xfffffffffffffbff;
        if ((uint)tmp_ttcap.forceConstantSpacingEnd < (uint)tmp_ttcap.forceConstantSpacingBegin) {
          tmp_ttcap.flags = uVar60;
        }
      }
      first_col_1 = 0;
      first_col = 0xff;
      last_col = 0;
      first_row = 0xff;
      BVar20 = SPropRecValList_search_record
                         (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,
                          "ForceConstantSpacingMetrics");
      if ((BVar20 != 0) &&
         (pxVar38 = *(xCharInfo **)&(tmpglyph->metrics).descent, pxVar38 != (xCharInfo *)0x0)) {
        pxVar30 = (xCharInfo *)strchr((char *)pxVar38,0x3b);
        pxVar31 = (xCharInfo *)strchr((char *)pxVar38,0x2c);
        pxVar32 = (xCharInfo *)strchr((char *)pxVar38,0x2e);
        if (pxVar31 == (xCharInfo *)0x0) {
LAB_00115bec:
          if ((pxVar30 == (xCharInfo *)0x0) || (pxVar32 == (xCharInfo *)0x0)) {
LAB_001175c0:
            pxVar31 = (xCharInfo *)((ulong)pxVar31 | (ulong)pxVar32);
          }
          else if (pxVar32 <= pxVar30) goto LAB_001173c0;
          if ((pxVar38 == pxVar30) || (pxVar31 != (xCharInfo *)0x0)) goto LAB_001173c0;
          iVar21 = restrict_code_range_by_str
                             (1,&first_col_1,&last_col,&first_col,&first_row,(char *)pxVar38);
          if (iVar21 == 1) {
            tmp_ttcap.force_c_representative_metrics_char_code =
                 (uint)last_col << 8 | (uint)first_col_1;
          }
        }
        else {
          if (pxVar30 == (xCharInfo *)0x0) goto LAB_001175c0;
          if (pxVar30 < pxVar31) {
            pxVar31 = (xCharInfo *)0x0;
            goto LAB_00115bec;
          }
LAB_001173c0:
          dVar77 = strtod((char *)pxVar38,(char **)&tmpchar);
          if (pxVar38 != tmpchar) {
            tmp_ttcap.force_c_scale_b_box_width = dVar77;
          }
          if (*(char *)&tmpchar->leftSideBearing == ',') {
            pxVar38 = (xCharInfo *)((long)&tmpchar->leftSideBearing + 1);
            dVar77 = strtod((char *)pxVar38,(char **)&tmpchar);
            if (pxVar38 != tmpchar) {
              tmp_ttcap.flags = tmp_ttcap.flags | 0x100;
              tmp_ttcap.force_c_scale_lsb = dVar77;
            }
            if (*(char *)&tmpchar->leftSideBearing == ',') {
              pxVar38 = (xCharInfo *)((long)&tmpchar->leftSideBearing + 1);
              dVar77 = strtod((char *)pxVar38,(char **)&tmpchar);
              if (pxVar38 != tmpchar) {
                tmp_ttcap.flags = tmp_ttcap.flags | 0x200;
                tmp_ttcap.force_c_scale_rsb = dVar77;
              }
              if ((*(char *)&tmpchar->leftSideBearing == ',') &&
                 (pxVar38 = (xCharInfo *)((long)&tmpchar->leftSideBearing + 1),
                 dVar77 = strtod((char *)pxVar38,(char **)&tmpchar), pxVar38 != tmpchar)) {
                tmp_ttcap.force_c_scale_b_box_height = dVar77;
              }
            }
          }
        }
        if (pxVar30 != (xCharInfo *)0x0) {
          pxVar38 = (xCharInfo *)((long)&pxVar30->leftSideBearing + 1);
          lVar28 = strtol((char *)pxVar38,(char **)&tmpchar,10);
          if (pxVar38 != tmpchar) {
            tmp_ttcap.force_c_adjust_width_by_pixel = (int)lVar28;
          }
          if (*(char *)&tmpchar->leftSideBearing == ',') {
            pxVar38 = (xCharInfo *)((long)&tmpchar->leftSideBearing + 1);
            lVar28 = strtol((char *)pxVar38,(char **)&tmpchar,10);
            if (pxVar38 != tmpchar) {
              tmp_ttcap.force_c_adjust_lsb_by_pixel = (int)lVar28;
            }
            if ((*(char *)&tmpchar->leftSideBearing == ',') &&
               (pxVar38 = (xCharInfo *)((long)&tmpchar->leftSideBearing + 1),
               lVar28 = strtol((char *)pxVar38,(char **)&tmpchar,10), pxVar38 != tmpchar)) {
              tmp_ttcap.force_c_adjust_rsb_by_pixel = (int)lVar28;
            }
          }
        }
      }
      BVar20 = SPropRecValList_search_record
                         (&listPropRecVal,(SPropRecValContainer *)&tmpglyph,"FontProperties");
      local_564 = -1;
      if (BVar20 != 0) {
        local_564._0_2_ = (tmpglyph->metrics).descent;
        local_564._2_2_ = (tmpglyph->metrics).attributes;
      }
      tmp_ttcap.force_c_adjust_rsb_by_pixel =
           tmp_ttcap.force_c_adjust_rsb_by_pixel + tmp_ttcap.adjustRightSideBearingByPixel;
      tmp_ttcap.force_c_scale_b_box_height =
           tmp_ttcap.force_c_scale_b_box_height * tmp_ttcap.scaleBBoxHeight;
      tmp_ttcap.force_c_adjust_lsb_by_pixel =
           tmp_ttcap.force_c_adjust_lsb_by_pixel + tmp_ttcap.adjustLeftSideBearingByPixel;
      uVar55 = (uint)(iVar44 == 0) * 2;
      if (local_5d8 == 0) {
        uVar55 = uVar55 | 8;
      }
      tmp_ttcap.force_c_scale_b_box_width =
           tmp_ttcap.force_c_scale_b_box_width * tmp_ttcap.scaleBBoxWidth * tmp_ttcap.scaleWidth;
      tmp_ttcap.scaleBBoxWidth = tmp_ttcap.scaleBBoxWidth * tmp_ttcap.scaleWidth;
      if (((false) || (tmp_ttcap.autoItalic != 0.0)) && (iVar22 == 0)) {
        uVar55 = uVar55 | 8;
      }
      if (ftypeInitP == 0) {
        uVar51 = FT_Init_FreeType(&ftypeLibrary);
        if (uVar51 == 0) {
          ftypeInitP = 1;
          goto LAB_00115e16;
        }
        face = (FTFacePtr)0x0;
        ErrorF("FreeType: error initializing ftypeEngine: %d\n",(ulong)uVar51);
        iVar22 = 0x50;
        bVar70 = true;
        goto LAB_00116d18;
      }
LAB_00115e16:
      bVar4 = *(byte *)puVar29;
      if (bVar4 == 0) {
        uVar51 = 0;
      }
      else {
        uVar51 = 0;
        puVar48 = puVar29;
        do {
          puVar48 = (uint *)((long)puVar48 + 1);
          uVar51 = (uVar51 << 5 | uVar51 >> 0x1b) + (uint)bVar4;
          bVar4 = *(byte *)puVar48;
        } while (bVar4 != 0);
        uVar51 = uVar51 & 0x1f;
      }
      for (face = faceTable[(int)uVar51]; face != (FTFacePtr)0x0; face = face->next) {
        iVar22 = strcmp(face->filename,(char *)puVar29);
        if (iVar22 == 0) goto LAB_00115e84;
      }
      p_Var33 = (FTFacePtr)calloc(1,0x30);
      face = p_Var33;
      if (p_Var33 == (FTFacePtr)0x0) goto LAB_00116d0a;
      pcVar34 = strdup((char *)puVar29);
      p_Var33->filename = pcVar34;
      if (pcVar34 == (char *)0x0) {
        iVar22 = 0x50;
        face = (FTFacePtr)0x0;
        free(p_Var33);
        bVar70 = true;
      }
      else {
        uVar25 = FT_New_Face(ftypeLibrary,local_640,(long)(int)local_5f0,&p_Var33->face);
        if (uVar25 == 0) {
          pFVar64 = p_Var33->face;
          uVar25 = ~(uint)pFVar64->face_flags & 1;
          p_Var33->bitmap = uVar25;
          if (uVar25 == 0) {
            lVar28 = FT_Get_Sfnt_Table(pFVar64,1);
            pFVar64 = p_Var33->face;
            if ((lVar28 != 0) && (*(short *)(lVar28 + 0xc) == 0)) {
              p_Var33->bitmap = 1;
            }
          }
          FVar15 = sfnt_get_ushort(pFVar64,0x68686561,0x22);
          p_Var33->num_hmetrics = (uint)FVar15;
          p_Var9 = faceTable[(int)uVar51];
          faceTable[(int)uVar51] = p_Var33;
          p_Var33->next = p_Var9;
LAB_00115e84:
          dVar73 = hypot(vals->point_matrix[2],vals->point_matrix[3]);
          dVar77 = vals->point_matrix[0];
          dVar74 = vals->point_matrix[3];
          dVar75 = vals->point_matrix[1];
          if (((long)((dVar77 / dVar73) * 65536.0) == 0x10000 &&
               (long)((dVar74 / dVar73) * 65536.0) == 0x10000) &&
             ((long)((vals->point_matrix[2] / dVar73) * 65536.0) == 0 &&
              (long)((dVar75 / dVar73) * 65536.0) == 0)) {
            iVar44 = -1;
          }
          else {
            uVar55 = uVar55 | 8;
            iVar44 = 0;
          }
          dVar73 = vals->pixel_matrix[0];
          dVar82 = vals->pixel_matrix[1];
          if (face->bitmap == 0) {
            vals->pixel_matrix[2] = tmp_ttcap.autoItalic * dVar73 + vals->pixel_matrix[2];
            vals->point_matrix[2] = dVar77 * tmp_ttcap.autoItalic + vals->point_matrix[2];
            vals->pixel_matrix[3] = tmp_ttcap.autoItalic * dVar82 + vals->pixel_matrix[3];
            vals->point_matrix[3] = tmp_ttcap.autoItalic * dVar75 + dVar74;
          }
          else {
            uVar55 = uVar55 & 0xfffffff7;
          }
          dVar74 = hypot(dVar73,dVar82);
          dVar75 = hypot(vals->pixel_matrix[2],vals->pixel_matrix[3]);
          dVar77 = dVar75;
          if (dVar75 < dVar74) {
            dVar77 = dVar74;
          }
          bVar70 = dVar77 < 1.0;
          iVar22 = 0x53;
          if (!bVar70) {
            iVar22 = FreeTypeLoadFont(font,info,face,(char *)puVar29,vals,entry,bmfmt,uVar55,
                                      &tmp_ttcap,local_5f8,local_5e8._0_4_);
            if (iVar22 == 0x55) {
              pFVar64 = face->face;
              p_Var8 = font->instance;
              dVar77 = 0.00048828125;
              if (pFVar64->units_per_EM != 0) {
                dVar77 = 1.0 / (double)pFVar64->units_per_EM;
              }
              iVar21 = p_Var8->spacing;
              pxVar38 = p_Var8->charcellMetrics;
              if (pxVar38 == (xCharInfo *)0x0) {
                dVar74 = (p_Var8->ttcap).scaleBBoxWidth;
                if (face->bitmap == 0) {
                  dVar73 = (double)(pFVar64->bbox).xMax;
                  dVar82 = (double)-(pFVar64->bbox).yMin;
                  dVar86 = (double)(pFVar64->bbox).yMax;
                  dVar87 = (double)(int)pFVar64->ascender;
                  if ((double)(int)pFVar64->ascender <= dVar86) {
                    dVar87 = dVar86;
                  }
                  dVar80 = (double)(pFVar64->bbox).xMin * dVar74;
                  dVar78 = (double)(int)pFVar64->max_advance_width;
                  dVar86 = (double)-(int)pFVar64->descender;
                  if ((double)-(int)pFVar64->descender <= dVar82) {
                    dVar86 = dVar82;
                  }
                  dVar82 = vals->pixel_matrix[1];
                  dVar2 = vals->pixel_matrix[3];
                  dVar79 = dVar78;
                  if (dVar78 <= dVar73) {
                    dVar79 = dVar73;
                  }
                  dVar73 = vals->pixel_matrix[0];
                  dVar83 = vals->pixel_matrix[2];
                  dVar88 = dVar73 * dVar80;
                  dVar80 = dVar80 * dVar82;
                  dVar85 = dVar83 * -dVar86;
                  dVar81 = -dVar86 * dVar2;
                  dVar76 = dVar88 + dVar85;
                  dVar84 = dVar80 + dVar81;
                  dVar88 = dVar88 + dVar83 * dVar87;
                  dVar80 = dVar80 + dVar2 * dVar87;
                  dVar89 = dVar88;
                  if (dVar88 <= dVar76) {
                    dVar89 = dVar76;
                  }
                  if (dVar76 <= dVar88) {
                    dVar88 = dVar76;
                  }
                  local_5e8 = dVar80;
                  if (dVar84 <= dVar80) {
                    local_5e8 = dVar84;
                  }
                  if (dVar80 <= dVar84) {
                    dVar80 = dVar84;
                  }
                  dVar76 = dVar73 * dVar79 * dVar74;
                  dVar84 = dVar79 * dVar74 * dVar82;
                  dVar85 = dVar85 + dVar76;
                  dVar81 = dVar81 + dVar84;
                  dVar79 = dVar85;
                  if (dVar85 <= dVar89) {
                    dVar79 = dVar89;
                  }
                  if (dVar88 <= dVar85) {
                    dVar85 = dVar88;
                  }
                  if (dVar81 < local_5e8) {
                    local_5e8 = dVar81;
                  }
                  dVar76 = dVar83 * dVar87 + dVar76;
                  dVar84 = dVar84 + dVar2 * dVar87;
                  if (dVar81 <= dVar80) {
                    dVar81 = dVar80;
                  }
                  dVar80 = dVar76;
                  if (dVar76 <= dVar79) {
                    dVar80 = dVar79;
                  }
                  if (dVar85 <= dVar76) {
                    dVar76 = dVar85;
                  }
                  if (dVar84 < local_5e8) {
                    local_5e8 = dVar84;
                  }
                  local_5e8 = -local_5e8;
                  if (dVar84 <= dVar81) {
                    dVar84 = dVar81;
                  }
                  dVar79 = dVar76 * dVar77 + 0.5;
                  if (ABS(dVar79) < 4503599627370496.0) {
                    dVar79 = (double)((ulong)dVar79 & 0x8000000000000000 |
                                     (ulong)((double)(long)dVar79 -
                                            (double)(-(ulong)(dVar79 < (double)(long)dVar79) &
                                                    0x3ff0000000000000)));
                  }
                  dVar80 = dVar80 * dVar77 + 0.5;
                  if (ABS(dVar80) < 4503599627370496.0) {
                    dVar80 = (double)((ulong)dVar80 & 0x8000000000000000 |
                                     (ulong)((double)(long)dVar80 -
                                            (double)(-(ulong)(dVar80 < (double)(long)dVar80) &
                                                    0x3ff0000000000000)));
                  }
                  sVar40 = (short)(int)dVar80;
                  dVar80 = local_5e8 * dVar77 - 0.5;
                  if (ABS(dVar80) < 4503599627370496.0) {
                    dVar80 = (double)((ulong)dVar80 & 0x8000000000000000 |
                                     (ulong)((double)(long)dVar80 +
                                            (double)(-(ulong)((double)(long)dVar80 < dVar80) &
                                                    0x3ff0000000000000)));
                  }
                  iVar23 = (int)dVar80;
                  dVar80 = dVar84 * dVar77 + 0.5;
                  if (ABS(dVar80) < 4503599627370496.0) {
                    dVar80 = (double)((ulong)dVar80 & 0x8000000000000000 |
                                     (ulong)((double)(long)dVar80 -
                                            (double)(-(ulong)(dVar80 < (double)(long)dVar80) &
                                                    0x3ff0000000000000)));
                  }
                  iVar24 = (int)dVar80;
                  if (pFVar64->max_advance_height < 1) {
                    dVar87 = dVar87 + dVar86;
                  }
                  else {
                    dVar87 = (double)(int)pFVar64->max_advance_height;
                  }
                  if ((false) || (dVar82 != 0.0)) {
                    dVar80 = (p_Var8->ttcap).scaleBBoxHeight * dVar87;
                    if ((false) || (dVar2 != 0.0)) {
                      dVar86 = ABS(dVar83 - (dVar73 * dVar2) / dVar82);
                      dVar80 = dVar80 * dVar86;
                      dVar73 = ABS(dVar73 - (dVar83 * dVar82) / dVar2);
                      dVar74 = dVar78 * dVar74 * dVar73;
                      if (dVar80 < dVar74) {
                        dVar73 = 0.0;
                      }
                      else {
                        dVar86 = 0.0;
                        dVar80 = dVar74;
                      }
                    }
                    else {
                      dVar73 = 0.0;
                      dVar86 = ABS(dVar83);
                      dVar80 = dVar80 * dVar86;
                    }
                  }
                  else {
                    dVar86 = 0.0;
                    dVar73 = ABS(dVar73);
                    dVar80 = dVar78 * dVar74 * dVar73;
                  }
                  dVar82 = dVar80 * dVar77;
                  dVar74 = dVar82 + 0.5;
                  if (ABS(dVar74) < 4503599627370496.0) {
                    dVar74 = (double)((ulong)dVar74 & 0x8000000000000000 |
                                     (ulong)((double)(long)dVar74 -
                                            (double)(-(ulong)(dVar74 < (double)(long)dVar74) &
                                                    0x3ff0000000000000)));
                  }
                  iVar63 = (int)dVar74;
                  uVar60 = (p_Var8->ttcap).flags;
                  iVar45 = iVar63;
                  if ((uVar60 & 8) != 0) {
                    iVar45 = iVar63 + (p_Var8->ttcap).doubleStrikeShift;
                  }
                  iVar45 = iVar45 + (p_Var8->ttcap).adjustBBoxWidthByPixel;
                  dVar74 = (p_Var8->ttcap).force_c_scale_lsb;
                  dVar2 = (p_Var8->ttcap).force_c_scale_rsb;
                  if ((false) || (dVar73 != 0.0)) {
                    local_5c8 = dVar74 * dVar78 * dVar73;
                    dVar83 = (p_Var8->ttcap).force_c_scale_b_box_width * dVar78 * dVar73;
                    dVar74 = dVar2 * dVar78 * dVar73;
                  }
                  else {
                    local_5c8 = dVar74 * dVar87 * dVar86;
                    dVar83 = (p_Var8->ttcap).force_c_scale_b_box_height * dVar87 * dVar86;
                    dVar74 = dVar87 * dVar2 * dVar86;
                  }
                  dVar87 = dVar83 * dVar77 + 0.5;
                  if (ABS(dVar87) < 4503599627370496.0) {
                    dVar87 = (double)((ulong)dVar87 & 0x8000000000000000 |
                                     (ulong)((double)(long)dVar87 -
                                            (double)(-(ulong)(dVar87 < (double)(long)dVar87) &
                                                    0x3ff0000000000000)));
                  }
                  local_568 = (int)dVar87;
                  iVar46 = local_568;
                  if ((uVar60 & 8) != 0) {
                    iVar46 = local_568 + (p_Var8->ttcap).doubleStrikeShift;
                  }
                  local_568 = local_568 + (p_Var8->ttcap).force_c_adjust_width_by_pixel;
                  sVar65 = (short)(int)dVar79;
                  if ((uVar60 & 0x100) != 0) {
                    dVar87 = local_5c8 * dVar77 + 0.5;
                    if (ABS(dVar87) < 4503599627370496.0) {
                      dVar87 = (double)((ulong)dVar87 & 0x8000000000000000 |
                                       (ulong)((double)(long)dVar87 -
                                              (double)(-(ulong)(dVar87 < (double)(long)dVar87) &
                                                      0x3ff0000000000000)));
                    }
                    sVar65 = (short)(int)dVar87;
                  }
                  local_58c = sVar40;
                  if ((uVar60 & 0x200) != 0) {
                    dVar74 = dVar74 * dVar77 + 0.5;
                    if (ABS(dVar74) < 4503599627370496.0) {
                      dVar74 = (double)((ulong)dVar74 & 0x8000000000000000 |
                                       (ulong)((double)(long)dVar74 -
                                              (double)(-(ulong)(dVar74 < (double)(long)dVar74) &
                                                      0x3ff0000000000000)));
                    }
                    local_58c = (short)(int)dVar74;
                  }
                  if (iVar44 == -1) {
                    dVar74 = (p_Var8->ttcap).autoItalic;
                    if ((false) || (dVar74 != 0.0)) {
                      dVar87 = (double)(iVar23 + iVar24);
                      if (dVar74 <= 0.0) {
                        iVar66 = (int)(0.5 - dVar74 * dVar87);
                        iVar44 = (int)(((double)iVar66 * (double)iVar24) / dVar87 + 0.5);
                        (p_Var8->ttcap).rsbShiftOfBitmapAutoItalic = iVar66 - iVar44;
                        (p_Var8->ttcap).lsbShiftOfBitmapAutoItalic = -iVar44;
                      }
                      else {
                        iVar44 = (int)(dVar74 * dVar87 + 0.5);
                        iVar66 = (int)(((double)iVar44 * (double)iVar24) / dVar87 + 0.5);
                        (p_Var8->ttcap).rsbShiftOfBitmapAutoItalic = iVar66;
                        (p_Var8->ttcap).lsbShiftOfBitmapAutoItalic = iVar66 - iVar44;
                      }
                    }
                  }
                  IVar59 = (short)(int)dVar79 + (short)(p_Var8->ttcap).adjustLeftSideBearingByPixel;
                  if ((uVar60 & 1) != 0) {
                    sVar43 = (short)(p_Var8->ttcap).doubleStrikeShift;
                    sVar40 = sVar40 + sVar43;
                    local_58c = local_58c + sVar43;
                  }
                  sVar40 = sVar40 + (short)(p_Var8->ttcap).adjustRightSideBearingByPixel;
                  local_58c = local_58c + (short)(p_Var8->ttcap).force_c_adjust_rsb_by_pixel;
                  sVar65 = sVar65 + (short)(p_Var8->ttcap).force_c_adjust_lsb_by_pixel;
                  dVar74 = dVar80 * 10.0 * dVar77 * ((double)iVar45 / (double)iVar63) + 0.5;
                  if (ABS(dVar74) < 4503599627370496.0) {
                    dVar74 = (double)((ulong)((double)(long)dVar74 -
                                             (double)(-(ulong)(dVar74 < (double)(long)dVar74) &
                                                     0x3ff0000000000000)) |
                                     (ulong)dVar74 & 0x8000000000000000);
                  }
                  dVar80 = ((double)iVar45 / (double)iVar63) * dVar82;
                  dVar87 = floor((dVar80 * 1000.0) / dVar75 + 0.5);
                  local_5b8 = (CARD16)(long)dVar87;
                  dVar87 = floor((dVar80 * 10.0 * 1000.0) / dVar75 + 0.5);
                  local_558 = (long)dVar87;
                  dVar77 = floor((((double)local_568 / (double)iVar46) * dVar83 * dVar77 * 1000.0) /
                                 dVar75 + 0.5);
                  local_5a0 = (CARD16)(long)dVar77;
                }
                else {
                  pFVar10 = p_Var8->size;
                  dVar77 = (double)(pFVar10->metrics).max_advance;
                  dVar73 = dVar77 * dVar74 * 0.015625 + 0.5;
                  if (ABS(dVar73) < 4503599627370496.0) {
                    dVar73 = (double)((ulong)dVar73 & 0x8000000000000000 |
                                     (ulong)((double)(long)dVar73 -
                                            (double)(-(ulong)(dVar73 < (double)(long)dVar73) &
                                                    0x3ff0000000000000)));
                  }
                  iVar45 = (int)dVar73;
                  sVar43 = (short)iVar45;
                  lVar28 = (pFVar10->metrics).descender;
                  lVar57 = (pFVar10->metrics).ascender;
                  if (lVar28 < 0) {
                    lVar28 = lVar28 + 0x3f;
                  }
                  iVar23 = -(int)(lVar28 >> 6);
                  lVar28 = lVar57 + 0x3f;
                  if (-1 < lVar57) {
                    lVar28 = lVar57;
                  }
                  dVar73 = (p_Var8->ttcap).force_c_scale_b_box_width * dVar77 * 0.015625 + 0.5;
                  iVar24 = (int)(lVar28 >> 6);
                  if (ABS(dVar73) < 4503599627370496.0) {
                    dVar73 = (double)((ulong)dVar73 & 0x8000000000000000 |
                                     (ulong)((double)(long)dVar73 -
                                            (double)(-(ulong)(dVar73 < (double)(long)dVar73) &
                                                    0x3ff0000000000000)));
                  }
                  local_568 = (int)dVar73;
                  if (vals->width == 0) {
                    dVar74 = dVar77 * 10.0 * dVar74 * 0.015625 + 0.5;
                    if (ABS(dVar74) < 4503599627370496.0) {
                      dVar74 = (double)((ulong)dVar74 & 0x8000000000000000 |
                                       (ulong)((double)(long)dVar74 -
                                              (double)(-(ulong)(dVar74 < (double)(long)dVar74) &
                                                      0x3ff0000000000000)));
                    }
                  }
                  else {
                    dVar74 = dVar74 * (double)vals->width + 0.5;
                    if (ABS(dVar74) < 4503599627370496.0) {
                      dVar74 = (double)((ulong)((double)(long)dVar74 -
                                               (double)(-(ulong)(dVar74 < (double)(long)dVar74) &
                                                       0x3ff0000000000000)) |
                                       (ulong)dVar74 & 0x8000000000000000);
                    }
                  }
                  dVar73 = dVar77 * 0.015625 + 0.5;
                  if (ABS(dVar73) < 4503599627370496.0) {
                    dVar73 = (double)((ulong)dVar73 & 0x8000000000000000 |
                                     (ulong)((double)(long)dVar73 -
                                            (double)(-(ulong)(dVar73 < (double)(long)dVar73) &
                                                    0x3ff0000000000000)));
                  }
                  uVar60 = (p_Var8->ttcap).flags;
                  dVar82 = (double)(int)dVar73;
                  dVar73 = vals->pixel_matrix[0];
                  sVar65 = 0;
                  if ((uVar60 & 0x100) != 0) {
                    dVar86 = (p_Var8->ttcap).force_c_scale_lsb * dVar77 * 0.015625 + 0.5;
                    if (ABS(dVar86) < 4503599627370496.0) {
                      dVar86 = (double)((ulong)dVar86 & 0x8000000000000000 |
                                       (ulong)((double)(long)dVar86 -
                                              (double)(-(ulong)(dVar86 < (double)(long)dVar86) &
                                                      0x3ff0000000000000)));
                    }
                    sVar65 = (short)(int)dVar86;
                  }
                  sVar62 = sVar43;
                  if ((uVar60 & 0x200) != 0) {
                    dVar77 = dVar77 * (p_Var8->ttcap).force_c_scale_rsb * 0.015625 + 0.5;
                    if (ABS(dVar77) < 4503599627370496.0) {
                      dVar77 = (double)((ulong)((double)(long)dVar77 -
                                               (double)(-(ulong)(dVar77 < (double)(long)dVar77) &
                                                       0x3ff0000000000000)) |
                                       (ulong)dVar77 & 0x8000000000000000);
                    }
                    sVar62 = (short)(int)dVar77;
                  }
                  dVar77 = (p_Var8->ttcap).autoItalic;
                  if ((false) || (dVar77 != 0.0)) {
                    dVar86 = (double)(iVar23 + iVar24);
                    if (dVar77 <= 0.0) {
                      iVar44 = (int)(0.5 - dVar77 * dVar86);
                      iVar63 = (int)(((double)iVar44 * (double)iVar24) / dVar86 + 0.5);
                      iVar44 = iVar44 - iVar63;
                      iVar63 = -iVar63;
                      (p_Var8->ttcap).rsbShiftOfBitmapAutoItalic = iVar44;
                      (p_Var8->ttcap).lsbShiftOfBitmapAutoItalic = iVar63;
                    }
                    else {
                      iVar63 = (int)(dVar77 * dVar86 + 0.5);
                      iVar44 = (int)(((double)iVar63 * (double)iVar24) / dVar86 + 0.5);
                      (p_Var8->ttcap).rsbShiftOfBitmapAutoItalic = iVar44;
                      iVar63 = iVar44 - iVar63;
                      (p_Var8->ttcap).lsbShiftOfBitmapAutoItalic = iVar63;
                    }
                  }
                  else {
                    iVar44 = (p_Var8->ttcap).rsbShiftOfBitmapAutoItalic;
                    iVar63 = (p_Var8->ttcap).lsbShiftOfBitmapAutoItalic;
                  }
                  if ((uVar60 & 8) != 0) {
                    iVar45 = (p_Var8->ttcap).doubleStrikeShift + iVar45;
                  }
                  IVar59 = (short)(p_Var8->ttcap).adjustLeftSideBearingByPixel + (short)iVar63;
                  if ((uVar60 & 1) != 0) {
                    sVar40 = (short)(p_Var8->ttcap).doubleStrikeShift;
                    sVar43 = sVar43 + sVar40;
                    sVar62 = sVar62 + sVar40;
                  }
                  sVar40 = (short)(p_Var8->ttcap).adjustRightSideBearingByPixel + sVar43 +
                           (short)iVar44;
                  dVar86 = 0.0;
                  local_5a0 = 0;
                  local_558 = 0;
                  local_58c = (short)iVar44 +
                              sVar62 + (short)(p_Var8->ttcap).force_c_adjust_rsb_by_pixel;
                  sVar65 = sVar65 + (short)(p_Var8->ttcap).force_c_adjust_lsb_by_pixel +
                           (short)iVar63;
                  local_5b8 = 0;
                }
                IVar69 = (INT16)iVar45;
                local_5e8._0_2_ = (short)iVar23;
                sVar43 = (short)iVar24;
                iVar44 = (int)dVar74;
                p_Var8->pixel_size = dVar75;
                p_Var8->advance = dVar82;
                if ((false) || (dVar73 != 0.0)) {
                  p_Var8->pixel_width_unit_y = 0.0;
                  p_Var8->pixel_width_unit_x = dVar73 / dVar75;
                }
                else {
                  p_Var8->pixel_width_unit_x = 0.0;
                  p_Var8->pixel_width_unit_y = dVar86 / dVar75;
                }
                pxVar38 = (xCharInfo *)malloc(0xc);
                p_Var8->charcellMetrics = pxVar38;
                if (pxVar38 != (xCharInfo *)0x0) {
                  pxVar38->ascent = sVar43;
                  p_Var8->charcellMetrics->descent = local_5e8._0_2_;
                  p_Var8->charcellMetrics->attributes = local_5b8;
                  p_Var8->charcellMetrics->rightSideBearing = sVar40;
                  p_Var8->charcellMetrics->leftSideBearing = IVar59;
                  p_Var8->charcellMetrics->characterWidth = IVar69;
                  p_Var8->averageWidth = iVar44;
                  p_Var8->rawAverageWidth = local_558;
                  iVar45 = FreeTypeInstanceGetGlyph(font->zero_idx,0,&tmpglyph,font->instance);
                  if (((iVar45 == 0x55) && (tmpglyph != (CharInfoPtr)0x0)) ||
                     ((iVar45 = FreeTypeInstanceGetGlyph(font->zero_idx,4,&tmpglyph,font->instance),
                      iVar45 == 0x55 && (tmpglyph != (CharInfoPtr)0x0)))) {
                    if ((p_Var8->ttcap).forceConstantSpacingEnd < 0) goto LAB_00116080;
                    tmpchar = (xCharInfo *)0x0;
                    uVar55 = (p_Var8->ttcap).force_c_representative_metrics_char_code;
                    if (p_Var8->forceConstantMetrics == (xCharInfo *)0x0) {
                      pxVar38 = (xCharInfo *)malloc(0xc);
                      p_Var8->forceConstantMetrics = pxVar38;
                      if (pxVar38 == (xCharInfo *)0x0) goto LAB_00116d0a;
                    }
                    if ((int)uVar55 < 0) {
LAB_00116c4c:
                      pxVar38 = p_Var8->forceConstantMetrics;
LAB_00116c53:
                      pxVar38->leftSideBearing = sVar65;
                      p_Var8->forceConstantMetrics->rightSideBearing = local_58c;
                      p_Var8->forceConstantMetrics->characterWidth = (INT16)local_568;
                      p_Var8->forceConstantMetrics->ascent = sVar43;
                      p_Var8->forceConstantMetrics->descent = local_5e8._0_2_;
                      p_Var8->forceConstantMetrics->attributes = local_5a0;
                    }
                    else {
                      iVar45 = FreeTypeFontGetGlyphMetrics(uVar55,0,&tmpchar,font);
                      if (iVar45 != 0x55) {
                        tmpchar = (xCharInfo *)0x0;
                        goto LAB_00116c4c;
                      }
                      pxVar38 = p_Var8->forceConstantMetrics;
                      if ((tmpchar == (xCharInfo *)0x0) || (tmpchar->characterWidth < 1))
                      goto LAB_00116c53;
                      pxVar38->leftSideBearing = tmpchar->leftSideBearing;
                      p_Var8->forceConstantMetrics->rightSideBearing = tmpchar->rightSideBearing;
                      p_Var8->forceConstantMetrics->characterWidth = tmpchar->characterWidth;
                      p_Var8->forceConstantMetrics->ascent = tmpchar->ascent;
                      p_Var8->forceConstantMetrics->descent = tmpchar->descent;
                      p_Var8->forceConstantMetrics->attributes = tmpchar->attributes;
                    }
                    iVar45 = FreeTypeInstanceGetGlyph(font->zero_idx,8,&tmpglyph,font->instance);
                    if (((iVar45 == 0x55) && (tmpglyph != (CharInfoPtr)0x0)) ||
                       ((iVar45 = FreeTypeInstanceGetGlyph
                                            (font->zero_idx,0xc,&tmpglyph,font->instance),
                        iVar45 == 0x55 && (tmpglyph != (CharInfoPtr)0x0)))) goto LAB_00116080;
                  }
                }
              }
              else {
                IVar69 = pxVar38->characterWidth;
                iVar44 = p_Var8->averageWidth;
                sVar43 = pxVar38->ascent;
                local_5e8._0_2_ = pxVar38->descent;
                local_5b8 = pxVar38->attributes;
                sVar40 = pxVar38->rightSideBearing;
                IVar59 = pxVar38->leftSideBearing;
                local_558 = p_Var8->rawAverageWidth;
LAB_00116080:
                if (iVar21 == 2) {
                  vals->width = iVar44;
                  if (info == (FontInfoPtr)0x0) goto LAB_001175d0;
                  (info->maxbounds).leftSideBearing = IVar59;
                  (info->maxbounds).rightSideBearing = sVar40;
                  (info->maxbounds).characterWidth = IVar69;
                  (info->maxbounds).ascent = sVar43;
                  (info->maxbounds).descent = local_5e8._0_2_;
                  (info->maxbounds).attributes = local_5b8;
                  IVar69 = (info->maxbounds).rightSideBearing;
                  IVar59 = (info->maxbounds).characterWidth;
                  IVar14 = (info->maxbounds).ascent;
                  (info->minbounds).leftSideBearing = (info->maxbounds).leftSideBearing;
                  (info->minbounds).rightSideBearing = IVar69;
                  (info->minbounds).characterWidth = IVar59;
                  (info->minbounds).ascent = IVar14;
                  CVar13 = (info->maxbounds).attributes;
                  (info->minbounds).descent = (info->maxbounds).descent;
                  (info->minbounds).attributes = CVar13;
                }
                else {
                  if (info == (FontInfoPtr)0x0) {
LAB_001175d0:
                    if (xf != (FontPtr)0x0) {
                      xf->fontPrivate = font;
                    }
                    goto LAB_00116d18;
                  }
                  uVar51 = (uint)info->lastCol;
                  tmpchar = (xCharInfo *)0x0;
                  p_Var8 = font->instance;
                  uVar55 = *(uint *)&(p_Var8->ttcap).flags & 0x400;
                  iVar44 = (info->lastCol + 1) - (uint)info->firstCol;
                  uVar25 = (uint)info->lastRow;
                  local_5a8 = (uint)info->firstRow;
                  if (info->lastRow < local_5a8) {
                    local_5c0 = -0x7fff;
                    sVar42 = 0x7fff;
                    sVar50 = 0x7fff;
                    sVar65 = 0x7fff;
                    sVar43 = -0x7fff;
                    CVar67 = 0x7fff;
                    sVar40 = 0x7fff;
                    CVar13 = 0x8001;
                    sVar62 = -0x7fff;
                    local_5e8._0_2_ = -0x7fff;
                    sVar12 = -0x7fff;
                    sVar68 = -0x7fff;
                    IVar69 = 0x7fff;
LAB_00118f59:
                    vals->width = 0;
                  }
                  else {
                    bVar71 = false;
                    local_5e8._0_2_ = -0x7fff;
                    sVar43 = -0x7fff;
                    sVar42 = 0x7fff;
                    CVar13 = 0x8001;
                    CVar67 = 0x7fff;
                    sVar12 = -0x7fff;
                    iVar23 = 0x7fff;
                    sVar40 = 0x7fff;
                    sVar65 = 0x7fff;
                    sVar68 = -0x7fff;
                    sVar62 = -0x7fff;
                    sVar50 = 0x7fff;
                    iVar21 = 0;
                    iVar45 = -0x7fff;
                    local_570 = 0;
                    local_578 = 0;
                    do {
                      if ((tmpchar == (xCharInfo *)0x0) || (!bVar71)) {
LAB_00117036:
                        uVar52 = (uint)info->firstCol;
                        if (info->firstCol <= uVar51) {
                          do {
                            uVar25 = (p_Var8->ttcap).forceConstantSpacingEnd;
                            code = local_5a8 << 8 | uVar52;
                            if (uVar55 == 0) {
                              if (code <= uVar25) {
LAB_0011708f:
                                if ((uint)(p_Var8->ttcap).forceConstantSpacingBegin <= code)
                                goto LAB_0011709c;
                              }
                              iVar24 = 0;
LAB_001171ea:
                              tmpchar = (xCharInfo *)0x0;
                              iVar63 = FreeTypeFontGetGlyphMetrics(code,iVar24,&tmpchar,font);
                              uVar51 = (uint)info->lastCol;
                              if (iVar63 == 0x55) goto LAB_001170aa;
                            }
                            else {
                              if (uVar25 < code) goto LAB_0011708f;
LAB_0011709c:
                              iVar24 = 8;
                              if (!bVar71) goto LAB_001171ea;
LAB_001170aa:
                              if (tmpchar != (xCharInfo *)0x0) {
                                sVar16 = tmpchar->ascent;
                                if (sVar16 < sVar42) {
                                  sVar42 = sVar16;
                                }
                                if (sVar16 <= sVar43) {
                                  sVar16 = sVar43;
                                }
                                sVar17 = tmpchar->descent;
                                if (sVar17 < sVar50) {
                                  sVar50 = sVar17;
                                }
                                if (sVar17 <= local_5e8._0_2_) {
                                  sVar17 = local_5e8._0_2_;
                                }
                                sVar18 = tmpchar->leftSideBearing;
                                if (sVar18 < sVar40) {
                                  sVar40 = sVar18;
                                }
                                if (sVar18 <= sVar12) {
                                  sVar18 = sVar12;
                                }
                                sVar43 = tmpchar->rightSideBearing;
                                if (sVar43 < (short)iVar23) {
                                  iVar23 = (int)sVar43;
                                }
                                if (sVar62 < sVar43) {
                                  sVar62 = sVar43;
                                }
                                sVar5 = tmpchar->characterWidth;
                                CVar54 = tmpchar->attributes;
                                if (sVar5 < sVar65) {
                                  sVar65 = sVar5;
                                }
                                if (sVar68 < sVar5) {
                                  sVar68 = sVar5;
                                }
                                if ((short)CVar54 < (short)CVar67) {
                                  CVar67 = CVar54;
                                }
                                if ((short)CVar54 <= (short)CVar13) {
                                  CVar54 = CVar13;
                                }
                                iVar63 = (int)sVar43 - (int)sVar5;
                                if (iVar63 <= iVar45) {
                                  iVar63 = iVar45;
                                }
                                sVar43 = sVar16;
                                sVar12 = sVar18;
                                CVar13 = CVar54;
                                iVar45 = iVar63;
                                local_5e8._0_2_ = sVar17;
                                if (sVar5 != 0) {
                                  iVar21 = iVar21 + 1;
                                  lVar28 = (long)-(int)sVar5;
                                  if (-1 < sVar5) {
                                    lVar28 = (long)sVar5;
                                  }
                                  local_570 = local_570 + sVar5;
                                  local_578 = local_578 + lVar28;
                                  if (iVar24 != 0) {
                                    bVar71 = true;
                                  }
                                }
                              }
                            }
                            uVar52 = uVar52 + 1;
                          } while ((int)uVar52 <= (int)uVar51);
                          uVar25 = (uint)info->lastRow;
                        }
                      }
                      else {
                        iVar24 = (p_Var8->ttcap).forceConstantSpacingBegin;
                        iVar63 = local_5a8 * 0x100;
                        if (uVar55 == 0) {
                          if (iVar24 < iVar63) goto LAB_001161c8;
LAB_00117518:
                          bVar71 = false;
                          goto LAB_00117036;
                        }
                        if (iVar63 <= iVar24) {
LAB_001161c8:
                          if ((int)((p_Var8->ttcap).forceConstantSpacingEnd & 0xff00U) <= iVar63)
                          goto LAB_00117518;
                        }
                        sVar16 = tmpchar->characterWidth;
                        if (sVar16 == 0) {
                          bVar71 = true;
                          goto LAB_00117036;
                        }
                        iVar21 = iVar21 + iVar44;
                        bVar71 = true;
                        local_570 = local_570 + sVar16 * iVar44;
                        local_578 = local_578 +
                                    (int)((((uint)(ushort)(sVar16 >> 0xf) ^ (int)sVar16) -
                                           (uint)(ushort)(sVar16 >> 0xf) & 0xffff) * iVar44);
                      }
                      IVar69 = (INT16)iVar23;
                      local_5a8 = local_5a8 + 1;
                    } while ((int)local_5a8 <= (int)uVar25);
                    local_5c0 = (short)iVar45;
                    if (iVar21 < 1) goto LAB_00118f59;
                    iVar44 = (int)(long)(((double)local_578 * 10.0 + (double)iVar21 * 0.5) /
                                        (double)iVar21);
                    if (local_570 < 0) {
                      iVar44 = -iVar44;
                    }
                    vals->width = iVar44;
                  }
                  (info->maxbounds).leftSideBearing = sVar12;
                  (info->maxbounds).rightSideBearing = sVar62;
                  (info->maxbounds).characterWidth = sVar68;
                  (info->minbounds).leftSideBearing = sVar40;
                  (info->maxbounds).ascent = sVar43;
                  (info->minbounds).rightSideBearing = IVar69;
                  (info->maxbounds).descent = local_5e8._0_2_;
                  (info->minbounds).characterWidth = sVar65;
                  (info->maxbounds).attributes = CVar13;
                  (info->minbounds).descent = sVar50;
                  (info->minbounds).ascent = sVar42;
                  (info->minbounds).attributes = CVar67;
                  info->maxOverlap = local_5c0;
                }
                info->fontAscent = sVar43;
                info->fontDescent = local_5e8._0_2_;
                IVar69 = (info->maxbounds).rightSideBearing;
                IVar59 = (info->maxbounds).characterWidth;
                IVar14 = (info->maxbounds).ascent;
                (info->ink_maxbounds).leftSideBearing = (info->maxbounds).leftSideBearing;
                (info->ink_maxbounds).rightSideBearing = IVar69;
                (info->ink_maxbounds).characterWidth = IVar59;
                (info->ink_maxbounds).ascent = IVar14;
                CVar13 = (info->maxbounds).attributes;
                (info->ink_maxbounds).descent = (info->maxbounds).descent;
                (info->ink_maxbounds).attributes = CVar13;
                IVar69 = (info->minbounds).rightSideBearing;
                IVar59 = (info->minbounds).characterWidth;
                IVar14 = (info->minbounds).ascent;
                (info->ink_minbounds).leftSideBearing = (info->minbounds).leftSideBearing;
                (info->ink_minbounds).rightSideBearing = IVar69;
                (info->ink_minbounds).characterWidth = IVar59;
                (info->ink_minbounds).ascent = IVar14;
                CVar13 = (info->minbounds).attributes;
                (info->ink_minbounds).descent = (info->minbounds).descent;
                (info->ink_minbounds).attributes = CVar13;
                *(uint *)&info->defaultCh = *(uint *)&info->defaultCh & 0xffdf0000 | 0x200000;
                FontComputeInfoAccelerators(info);
                if (xf != (FontPtr)0x0) {
                  xf->fontPrivate = font;
                }
                pcVar34 = (entry->name).name;
                p_Var8 = font->instance;
                p_Var33 = p_Var8->face;
                uVar6 = p_Var33->face->units_per_EM;
                uVar19 = 0x800;
                if (uVar6 != 0) {
                  uVar19 = uVar6;
                }
                ppxVar35 = (xCharInfo **)FT_Get_Sfnt_Table(p_Var33->face,2);
                ppxVar36 = (xCharInfo **)FT_Get_Sfnt_Table(p_Var33->face,5);
                iVar44 = FT_Get_PS_Font_Info(p_Var33->face,&tmpchar);
                ppxVar49 = (xCharInfo **)0x0;
                ppxVar11 = ppxVar49;
                if (iVar44 == 0) {
                  ppxVar35 = ppxVar49;
                  ppxVar11 = &tmpchar;
                  ppxVar36 = ppxVar49;
                }
                info->nprops = 0;
                __strcpy_chk((xCharInfo *)val,pcVar34,0x400);
                BVar20 = FontParseXLFDName(val,vals,3);
                uVar55 = -(uint)(BVar20 == 0) & 0xfffffff2;
                iVar44 = uVar55 + 0x14;
                if (p_Var33->bitmap == 0) {
                  iVar44 = uVar55 + 0x17;
                }
                bVar71 = false;
                iVar21 = iVar44 + 2;
                iVar45 = iVar21;
                if (local_564 != 0) {
                  bVar71 = ppxVar35 != (xCharInfo **)0x0;
                  if (bVar71) {
                    iVar21 = iVar44 + 8;
                  }
                  iVar45 = iVar21 + 2;
                  if (ppxVar36 != (xCharInfo **)0x0 || ppxVar11 != (xCharInfo **)0x0) {
                    iVar45 = iVar21 + 5;
                  }
                }
                __ptr = (FontPropPtr)malloc((long)iVar45 << 4);
                info->props = __ptr;
                if (__ptr != (FontPropPtr)0x0) {
                  pcVar34 = (char *)calloc((long)iVar45,1);
                  info->isStringProp = pcVar34;
                  if (pcVar34 != (char *)0x0) {
                    AVar37 = MakeAtom("FONT",4,1);
                    info->props->name = AVar37;
                    pxVar38 = (xCharInfo *)val;
                    do {
                      pxVar30 = pxVar38;
                      uVar51 = *(uint *)pxVar30 + 0xfefefeff & ~*(uint *)pxVar30;
                      uVar55 = uVar51 & 0x80808080;
                      pxVar38 = (xCharInfo *)&pxVar30->characterWidth;
                    } while (uVar55 == 0);
                    bVar72 = (uVar51 & 0x8080) == 0;
                    if (bVar72) {
                      uVar55 = uVar55 >> 0x10;
                    }
                    pIVar61 = &pxVar30->characterWidth;
                    if (bVar72) {
                      pIVar61 = &pxVar30->ascent;
                    }
                    AVar37 = MakeAtom(val,(((int)pIVar61 + -3) -
                                          (uint)CARRY1((byte)uVar55,(byte)uVar55)) -
                                          (int)(xCharInfo *)val,1);
                    info->props->value = AVar37;
                    *info->isStringProp = '\x01';
                    if ((val[0] != '\0') && (val[1] != '\0')) {
                      sVar27 = 7;
                      pcVar34 = val + 1;
                      pcVar26 = "FOUNDRY";
                      lVar28 = 1;
                      do {
                        local_600 = (int)lVar28;
                        pcVar53 = pcVar34;
                        if (local_600 == 0xe) {
                          if ((val[1] == '[') || (val[1] == '\0')) {
                            uVar55 = 0;
                          }
                          else {
                            do {
                              pcVar1 = pcVar53 + 1;
                              pcVar53 = pcVar53 + 1;
                              if (*pcVar1 == '\0') break;
                            } while (*pcVar1 != '[');
                            uVar55 = (int)pcVar53 - (int)pcVar34;
                          }
                          AVar37 = MakeAtom(pcVar26,(uint)sVar27,1);
                          info->props[lVar28].name = AVar37;
LAB_00117a98:
                          AVar37 = MakeAtom(pcVar34,uVar55,1);
                          info->props[lVar28].value = AVar37;
                          local_5d0 = local_600 + 1;
                          info->isStringProp[lVar28] = '\x01';
                          if (lVar28 == 0xe) goto LAB_00118aa8;
                        }
                        else {
                          if ((val[1] != '-') && (val[1] != '\0')) {
                            do {
                              pcVar1 = pcVar53 + 1;
                              pcVar53 = pcVar53 + 1;
                              if (*pcVar1 == '\0') break;
                            } while (*pcVar1 != '-');
                          }
                          AVar37 = MakeAtom(pcVar26,(uint)sVar27,1);
                          info->props[lVar28].name = AVar37;
                          if (false) {
switchD_001179b0_caseD_b:
                            uVar55 = (int)pcVar53 - (int)pcVar34;
                            goto LAB_00117a98;
                          }
                          switch(local_600) {
                          case 7:
                            info->props[lVar28].value =
                                 (long)(int)(ABS(vals->pixel_matrix[3]) + 0.5);
                            break;
                          case 8:
                            info->props[lVar28].value =
                                 (long)(int)(ABS(vals->point_matrix[3]) * 10.0 + 0.5);
                            break;
                          case 9:
                            info->props[lVar28].value = (long)vals->x;
                            break;
                          case 10:
                            info->props[lVar28].value = (long)vals->y;
                            break;
                          default:
                            goto switchD_001179b0_caseD_b;
                          case 0xc:
                            info->props[lVar28].value = (long)vals->width;
                          }
                        }
                        pcVar34 = pcVar53 + 1;
                        lVar28 = lVar28 + 1;
                        pcVar26 = xlfd_props[local_600];
                        sVar27 = strlen(pcVar26);
                        val[1] = *pcVar34;
                      } while( true );
                    }
                    local_600 = 3;
                    lVar28 = 0x30;
                    lVar57 = 0x20;
                    local_5f0 = 3;
                    lVar39 = 0x10;
                    local_5d0 = 1;
                    goto LAB_00117b76;
                  }
                  iVar22 = 0x50;
                  free(__ptr);
                  bVar70 = true;
                  goto LAB_00116d18;
                }
              }
LAB_00116d0a:
              bVar70 = true;
              iVar22 = 0x50;
            }
            else {
              bVar70 = true;
            }
          }
        }
        else {
          iVar22 = 0x53;
          ErrorF("FreeType: couldn\'t open face %s: %d\n",puVar29,(ulong)uVar25);
          free(p_Var33->filename);
          face = (FTFacePtr)0x0;
          free(p_Var33);
          bVar70 = true;
        }
      }
      goto LAB_00116d18;
    }
    face = (FTFacePtr)0x0;
    iVar22 = 0x53;
    fwrite("ScaleWitdh needs plus.\n",1,0x17,_stderr);
    bVar70 = true;
    goto LAB_0011565d;
  }
LAB_001156d8:
  iVar22 = 0x50;
  goto LAB_001156bc;
LAB_00118aa8:
  local_600 = local_600 + 3;
  lVar39 = (long)local_5d0 * 0x10;
  lVar57 = lVar39 + 0x10;
  local_5f0 = (long)local_600;
  lVar28 = lVar39 + 0x20;
LAB_00117b76:
  AVar37 = MakeAtom("RAW_PIXEL_SIZE",0xe,1);
  *(Atom *)((long)&info->props->name + lVar39) = AVar37;
  *(undefined8 *)((long)&info->props->value + lVar39) = 1000;
  AVar37 = MakeAtom("RAW_POINT_SIZE",0xe,1);
  *(Atom *)((long)&info->props->name + lVar57) = AVar37;
  *(long *)((long)&info->props->value + lVar57) = (long)(72270.0 / (double)vals->y + 0.5);
  if (p_Var33->bitmap == 0) {
    AVar37 = MakeAtom("RAW_AVERAGE_WIDTH",0x11,1);
    *(Atom *)((long)&info->props->name + lVar28) = AVar37;
    *(long *)((long)&info->props->value + lVar28) = (long)(int)local_558;
    local_600 = local_5d0 + 3;
    local_5f0 = (long)local_600;
    lVar28 = local_5f0 << 4;
  }
  local_5d0 = local_600 + 1;
  local_5e8 = (double)(long)local_5d0;
  lVar57 = (long)local_5e8 * 0x10;
  if (local_564 == 0) {
    lVar58 = lVar57;
    if (p_Var33->bitmap == 0) {
LAB_001187f1:
      AVar37 = MakeAtom("RAW_ASCENT",10,1);
      *(Atom *)((long)&info->props->name + lVar28) = AVar37;
      *(long *)((long)&info->props->value + lVar28) =
           (long)(((double)(int)p_Var33->face->ascender / (double)uVar19) * 1000.0);
      local_600 = local_5d0 + 1;
      lVar41 = (long)local_600;
      local_5f0 = (long)local_5e8;
      lVar39 = lVar41 << 4;
      lVar28 = lVar58;
      lVar57 = lVar58;
      lVar58 = lVar39;
      local_5e8 = (double)lVar41;
      iVar44 = local_600;
      if (local_564 != 0) goto LAB_0011897a;
      goto LAB_0011887f;
    }
  }
  else {
    AVar37 = MakeAtom("FONT_ASCENT",0xb,1);
    *(Atom *)((long)&info->props->name + lVar28) = AVar37;
    *(long *)((long)&info->props->value + lVar28) = (long)info->fontAscent;
    lVar39 = lVar57 + 0x10;
    local_5d0 = local_600 + 2;
    local_5e8 = (double)(long)local_5d0;
    lVar28 = lVar57;
    lVar58 = lVar39;
    iVar44 = local_5d0;
    if (p_Var33->bitmap == 0) goto LAB_001187f1;
LAB_0011897a:
    local_5d0 = iVar44;
    local_5f0 = (long)local_5e8;
    AVar37 = MakeAtom("FONT_DESCENT",0xc,1);
    *(Atom *)((long)&info->props->name + lVar57) = AVar37;
    *(long *)((long)&info->props->value + lVar57) = (long)info->fontDescent;
    local_600 = local_5d0 + 1;
    lVar41 = (long)local_600;
    lVar58 = lVar41 << 4;
    lVar28 = lVar39;
LAB_0011887f:
    iVar44 = local_5d0;
    if (p_Var33->bitmap == 0) {
      AVar37 = MakeAtom("RAW_DESCENT",0xb,1);
      *(Atom *)((long)&info->props->name + lVar28) = AVar37;
      *(long *)((long)&info->props->value + lVar28) =
           (long)-(((double)(int)p_Var33->face->descender / (double)uVar19) * 1000.0);
      local_5d0 = local_600 + 1;
      lVar28 = lVar58;
      lVar58 = (long)local_5d0 << 4;
      local_5f0 = lVar41;
      local_5e8 = (double)(long)local_5d0;
    }
    else {
      local_5d0 = local_600;
      local_600 = iVar44;
      local_5e8 = (double)lVar41;
    }
  }
  lVar57 = local_5f0;
  uVar55 = FTGetEnglishName(p_Var33->face,0,val,0x400);
  pxVar38 = (xCharInfo *)val;
  pxVar30 = (xCharInfo *)val;
  if ((int)uVar55 < 0) {
    lVar39 = lVar58;
    if (ppxVar11 == (xCharInfo **)0x0) {
      uVar55 = FTGetEnglishName(p_Var33->face,4,val,0x400);
      if ((int)uVar55 < 0) goto LAB_00117dd5;
    }
    else {
      pxVar38 = ppxVar11[1];
      if (pxVar38 != (xCharInfo *)0x0) {
        sVar27 = strlen((char *)pxVar38);
        uVar55 = (uint)sVar27;
        goto LAB_00117c69;
      }
      uVar55 = FTGetEnglishName(p_Var33->face,4,val,0x400);
      if (-1 < (int)uVar55) goto LAB_00117d33;
LAB_00118a26:
      pxVar30 = ppxVar11[2];
      if (pxVar30 == (xCharInfo *)0x0) goto LAB_00117dd5;
      sVar27 = strlen((char *)pxVar30);
      uVar55 = (uint)sVar27;
      lVar39 = lVar58;
    }
LAB_00117d33:
    lVar57 = local_5f0;
    lVar58 = lVar39;
    if (0 < (int)uVar55) {
      AVar37 = MakeAtom("FACE_NAME",9,1);
      *(Atom *)((long)&info->props->name + lVar28) = AVar37;
      AVar37 = MakeAtom((char *)pxVar30,uVar55,1);
      *(Atom *)((long)&info->props->value + lVar28) = AVar37;
      local_5f0 = (long)local_5e8;
      info->isStringProp[lVar57] = '\x01';
      local_600 = local_5d0;
      local_5e8 = (double)(long)(local_5d0 + 1);
      lVar58 = (long)local_5e8 << 4;
      lVar28 = lVar39;
      local_5d0 = local_5d0 + 1;
    }
  }
  else {
LAB_00117c69:
    if (0 < (int)uVar55) {
      AVar37 = MakeAtom("COPYRIGHT",9,1);
      *(Atom *)((long)&info->props->name + lVar28) = AVar37;
      AVar37 = MakeAtom((char *)pxVar38,uVar55,1);
      *(Atom *)((long)&info->props->value + lVar28) = AVar37;
      local_5f0 = (long)local_5e8;
      info->isStringProp[lVar57] = '\x01';
      local_600 = local_5d0;
      local_5e8 = (double)(long)(local_5d0 + 1);
      lVar28 = lVar58;
      lVar58 = (long)local_5e8 << 4;
      local_5d0 = local_5d0 + 1;
    }
    uVar55 = FTGetEnglishName(p_Var33->face,4,val,0x400);
    lVar39 = lVar58;
    if (-1 < (int)uVar55) goto LAB_00117d33;
    if (ppxVar11 != (xCharInfo **)0x0) goto LAB_00118a26;
  }
LAB_00117dd5:
  lVar57 = local_5f0;
  pxVar38 = (xCharInfo *)FT_Get_Postscript_Name(p_Var33->face);
  if (pxVar38 == (xCharInfo *)0x0) {
LAB_00117f88:
    uVar55 = FTGetEnglishName(p_Var33->face,6,val,0x400);
    pxVar38 = (xCharInfo *)val;
    if (-1 < (int)uVar55) goto LAB_00117e0a;
    if ((ppxVar11 != (xCharInfo **)0x0) && (pxVar38 = ppxVar11[2], pxVar38 != (xCharInfo *)0x0)) {
      sVar27 = strlen((char *)pxVar38);
      uVar55 = (uint)sVar27;
      goto LAB_00117e0a;
    }
  }
  else {
    sVar27 = strlen((char *)pxVar38);
    uVar55 = (uint)sVar27;
    if ((int)uVar55 < 0) goto LAB_00117f88;
LAB_00117e0a:
    if (0 < (int)uVar55) {
      AVar37 = MakeAtom("_ADOBE_POSTSCRIPT_FONTNAME",0x1a,1);
      *(Atom *)((long)&info->props->name + lVar28) = AVar37;
      AVar37 = MakeAtom((char *)pxVar38,uVar55,1);
      *(Atom *)((long)&info->props->value + lVar28) = AVar37;
      local_5f0 = (long)local_5e8;
      info->isStringProp[lVar57] = '\x01';
      local_600 = local_5d0;
      local_5e8 = (double)(long)(local_5d0 + 1);
      lVar28 = lVar58;
      lVar58 = (long)local_5e8 << 4;
    }
  }
  local_618 = local_600 + 2;
  if (bVar71) {
    AVar37 = MakeAtom("SUBSCRIPT_SIZE",0xe,1);
    dVar74 = (double)uVar19;
    *(Atom *)((long)&info->props->name + lVar28) = AVar37;
    dVar77 = ((double)(int)*(short *)((long)ppxVar35 + 0xc) / dVar74) * vals->pixel_matrix[3] + 0.5;
    if (ABS(dVar77) < 4503599627370496.0) {
      dVar77 = (double)((ulong)dVar77 & 0x8000000000000000 |
                       (ulong)((double)(long)dVar77 -
                              (double)(-(ulong)(dVar77 < (double)(long)dVar77) & 0x3ff0000000000000)
                              ));
    }
    *(long *)((long)&info->props->value + lVar28) = (long)(int)dVar77;
    AVar37 = MakeAtom("SUBSCRIPT_X",0xb,1);
    *(Atom *)((long)&info->props->name + lVar58) = AVar37;
    dVar77 = ((double)(int)*(short *)((long)ppxVar35 + 0xe) / dVar74) * vals->pixel_matrix[0] + 0.5;
    if (ABS(dVar77) < 4503599627370496.0) {
      dVar77 = (double)((ulong)dVar77 & 0x8000000000000000 |
                       (ulong)((double)(long)dVar77 -
                              (double)(-(ulong)(dVar77 < (double)(long)dVar77) & 0x3ff0000000000000)
                              ));
    }
    *(long *)((long)&info->props->value + lVar58) = (long)(int)dVar77;
    AVar37 = MakeAtom("SUBSCRIPT_Y",0xb,1);
    lVar57 = (long)local_618;
    info->props[lVar57].name = AVar37;
    dVar77 = ((double)(int)*(short *)(ppxVar35 + 2) / dVar74) * vals->pixel_matrix[3] + 0.5;
    if (ABS(dVar77) < 4503599627370496.0) {
      dVar77 = (double)((ulong)dVar77 & 0x8000000000000000 |
                       (ulong)((double)(long)dVar77 -
                              (double)(-(ulong)(dVar77 < (double)(long)dVar77) & 0x3ff0000000000000)
                              ));
    }
    info->props[lVar57].value = (long)(int)dVar77;
    AVar37 = MakeAtom("SUPERSCRIPT_SIZE",0x10,1);
    info->props[lVar57 + 1].name = AVar37;
    dVar77 = ((double)(int)*(short *)((long)ppxVar35 + 0x14) / dVar74) * vals->pixel_matrix[3] + 0.5
    ;
    if (ABS(dVar77) < 4503599627370496.0) {
      dVar77 = (double)((ulong)dVar77 & 0x8000000000000000 |
                       (ulong)((double)(long)dVar77 -
                              (double)(-(ulong)(dVar77 < (double)(long)dVar77) & 0x3ff0000000000000)
                              ));
    }
    info->props[lVar57 + 1].value = (long)(int)dVar77;
    AVar37 = MakeAtom("SUPERSCRIPT_X",0xd,1);
    info->props[lVar57 + 2].name = AVar37;
    dVar77 = ((double)(int)*(short *)((long)ppxVar35 + 0x16) / dVar74) * vals->pixel_matrix[0] + 0.5
    ;
    if (ABS(dVar77) < 4503599627370496.0) {
      dVar77 = (double)((ulong)dVar77 & 0x8000000000000000 |
                       (ulong)((double)(long)dVar77 -
                              (double)(-(ulong)(dVar77 < (double)(long)dVar77) & 0x3ff0000000000000)
                              ));
    }
    info->props[lVar57 + 2].value = (long)(int)dVar77;
    AVar37 = MakeAtom("SUPERSCRIPT_Y",0xd,1);
    info->props[lVar57 + 3].name = AVar37;
    dVar77 = ((double)(int)*(short *)(ppxVar35 + 3) / dVar74) * vals->pixel_matrix[3] + 0.5;
    if (ABS(dVar77) < 4503599627370496.0) {
      dVar77 = (double)((ulong)((double)(long)dVar77 -
                               (double)(-(ulong)(dVar77 < (double)(long)dVar77) & 0x3ff0000000000000
                                       )) | (ulong)dVar77 & 0x8000000000000000);
    }
    lVar28 = lVar57 * 0x10 + 0x40;
    lVar58 = lVar57 * 0x10 + 0x50;
    info->props[lVar57 + 3].value = (long)(int)dVar77;
    local_618 = local_600 + 8;
    local_5f0 = (long)(local_600 + 6);
    local_5e8 = (double)(long)(local_600 + 7);
    local_600 = local_600 + 6;
LAB_00118479:
    if (ppxVar36 != (xCharInfo **)0x0 || ppxVar11 != (xCharInfo **)0x0) {
      dVar74 = (double)uVar19;
      dVar77 = vals->pixel_matrix[3];
      if (ppxVar36 == (xCharInfo **)0x0) {
        dVar75 = ((double)-(int)*(short *)((long)ppxVar11 + 0x32) / dVar74) * dVar77 + 0.5;
        if (ABS(dVar75) < 4503599627370496.0) {
          dVar75 = (double)((ulong)dVar75 & 0x8000000000000000 |
                           (ulong)((double)(long)dVar75 -
                                  (double)(-(ulong)(dVar75 < (double)(long)dVar75) &
                                          0x3ff0000000000000)));
        }
        uVar55 = (uint)*(ushort *)((long)ppxVar11 + 0x34);
      }
      else {
        dVar75 = ((double)-(int)*(short *)(ppxVar36 + 2) / dVar74) * dVar77 + 0.5;
        if (ABS(dVar75) < 4503599627370496.0) {
          dVar75 = (double)((ulong)dVar75 & 0x8000000000000000 |
                           (ulong)((double)(long)dVar75 -
                                  (double)(-(ulong)(dVar75 < (double)(long)dVar75) &
                                          0x3ff0000000000000)));
        }
        uVar55 = (uint)*(short *)((long)ppxVar36 + 0x12);
      }
      dVar77 = ((double)(int)uVar55 / dVar74) * dVar77 + 0.5;
      if (ABS(dVar77) < 4503599627370496.0) {
        dVar77 = (double)((ulong)((double)(long)dVar77 -
                                 (double)(-(ulong)(dVar77 < (double)(long)dVar77) &
                                         0x3ff0000000000000)) | (ulong)dVar77 & 0x8000000000000000);
      }
      AVar37 = MakeAtom("UNDERLINE_THICKNESS",0x13,1);
      *(Atom *)((long)&info->props->name + lVar28) = AVar37;
      lVar57 = 1;
      if (0 < (int)dVar77) {
        lVar57 = (long)(int)dVar77;
      }
      *(long *)((long)&info->props->value + lVar28) = lVar57;
      AVar37 = MakeAtom("UNDERLINE_POSITION",0x12,1);
      *(Atom *)((long)&info->props->name + lVar58) = AVar37;
      *(long *)((long)&info->props->value + lVar58) = (long)(int)dVar75;
      local_5f0 = (long)local_618;
      lVar28 = local_5f0 * 0x10;
      if ((ppxVar36 == (xCharInfo **)0x0) ||
         ((p_Var8->transformation).matrix.xx != (p_Var8->transformation).matrix.yy)) {
        lVar58 = lVar28 + 0x10;
        iVar44 = local_618 + 1;
        local_618 = local_618 + 2;
        local_5e8 = (double)(long)iVar44;
      }
      else {
        AVar37 = MakeAtom("ITALIC_ANGLE",0xc,1);
        info->props[local_5f0].name = AVar37;
        info->props[local_5f0].value = ((long)ppxVar36[1] >> 10) + 0x1680;
        local_5f0 = (long)(local_600 + 3);
        lVar28 = local_5f0 * 0x10;
        local_5e8 = (double)(long)(local_600 + 4);
        lVar58 = lVar28 + 0x10;
        local_618 = local_600 + 5;
      }
    }
  }
  else if (local_564 != 0) goto LAB_00118479;
  AVar37 = MakeAtom("FONT_TYPE",9,1);
  *(Atom *)((long)&info->props->name + lVar28) = AVar37;
  pcVar34 = (char *)FT_Get_X11_Font_Format(p_Var33->face);
  sVar27 = strlen(pcVar34);
  AVar37 = MakeAtom(pcVar34,(uint)sVar27,1);
  *(Atom *)((long)&info->props->value + lVar28) = AVar37;
  info->isStringProp[local_5f0] = '\x01';
  AVar37 = MakeAtom("RASTERIZER_NAME",0xf,1);
  *(Atom *)((long)&info->props->name + lVar58) = AVar37;
  AVar37 = MakeAtom("FreeType",10,1);
  *(Atom *)((long)&info->props->value + lVar58) = AVar37;
  info->isStringProp[(long)local_5e8] = '\x01';
  info->nprops = local_618;
LAB_00116d18:
  if (local_5f8 != (char *)0x0) {
    free(local_5f8);
  }
LAB_0011565d:
  free(puVar29);
  free(local_640);
  if (!bVar70) goto LAB_00115676;
  if (((face != (FTFacePtr)0x0) && (font->instance == (FTInstancePtr)0x0)) &&
     (face->instances == (_FTInstance *)0x0)) {
    FreeTypeFreeFace(face);
  }
LAB_001156bc:
  FreeTypeFreeFont(font);
LAB_00115676:
  if (lVar7 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar22;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int FreeTypeGetInfoScalable
              (FontPathElementPtr fpe,FontInfoPtr info,FontEntryPtr entry,FontNamePtr fontName,
              char *fileName,FontScalablePtr vals)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  FontBitmapFormatRec bmfmt;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar2 = FreeTypeSetUpFont(fpe,(FontPtr)0x0,info,0,0,&bmfmt);
  if (iVar2 == 0x55) {
    bmfmt.glyph = bmfmt.glyph << 3;
    iVar2 = FreeTypeLoadXFont(fileName,vals,(FontPtr)0x0,info,&bmfmt,entry);
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int FreeTypeOpenScalable
              (FontPathElementPtr fpe,FontPtr *ppFont,int flags,FontEntryPtr entry,char *fileName,
              FontScalablePtr vals,fsBitmapFormat format,fsBitmapFormatMask fmask,
              FontPtr non_cachable_font)

{
  long lVar1;
  int iVar2;
  FontPtr xf;
  long in_FS_OFFSET;
  FontBitmapFormatRec bmfmt;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  xf = CreateFontRec();
  if (xf == (FontPtr)0x0) {
    iVar2 = 0x50;
  }
  else {
    iVar2 = FreeTypeSetUpFont(fpe,xf,&xf->info,format,fmask,&bmfmt);
    if (iVar2 == 0x55) {
      iVar2 = FreeTypeLoadXFont(fileName,vals,xf,&xf->info,&bmfmt,entry);
      if (iVar2 == 0x55) {
        *ppFont = xf;
        goto LAB_0011976f;
      }
    }
    DestroyFontRec(xf);
  }
LAB_0011976f:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void FreeTypeRegisterFontFileFunctions(void)

{
  FontFileRegisterRenderer(renderers);
  FontFileRegisterRenderer(renderers + 1);
  FontFileRegisterRenderer(renderers + 2);
  FontFileRegisterRenderer(renderers + 3);
  FontFileRegisterRenderer(renderers + 4);
  FontFileRegisterRenderer(renderers + 5);
  FontFilePriorityRegisterRenderer(alt_renderers,-10);
  FontFilePriorityRegisterRenderer(alt_renderers + 1,-10);
  return;
}



int FTGetName(FT_Face face,int nid,int pid,int eid,FT_SfntName *name_return)

{
  long lVar1;
  undefined8 uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  long in_FS_OFFSET;
  FT_SfntName name;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar3 = FT_Get_Sfnt_Name_Count();
  if (0 < iVar3) {
    iVar5 = 0;
    do {
      iVar4 = FT_Get_Sfnt_Name(face,iVar5,&name);
      if ((((iVar4 == 0) && ((uint)name.name_id == nid)) && ((uint)name.platform_id == pid)) &&
         ((eid == -1 || ((uint)name.encoding_id == eid)))) {
        if (name.platform_id < 2) {
          if (name.language_id == 0) goto LAB_0011990e;
        }
        else if ((name.platform_id != 3) || ((name.language_id - 0x409 & 0xfbff) != 0)) {
LAB_0011990e:
          uVar2 = CONCAT26(name.name_id,
                           CONCAT24(name.language_id,CONCAT22(name.encoding_id,name.platform_id)));
          name_return->string_len = name.string_len;
          *(undefined4 *)&name_return->field_0x14 = name._20_4_;
          iVar3 = 1;
          name_return->platform_id = (short)uVar2;
          name_return->encoding_id = (short)((ulong)uVar2 >> 0x10);
          name_return->language_id = (short)((ulong)uVar2 >> 0x20);
          name_return->name_id = (short)((ulong)uVar2 >> 0x30);
          name_return->string = name.string;
          goto LAB_00119932;
        }
      }
      iVar5 = iVar5 + 1;
    } while (iVar3 != iVar5);
  }
  iVar3 = 0;
LAB_00119932:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar3;
}



// WARNING: Unknown calling convention

int FTtoXReturnCode(int rc)

{
  return (uint)(rc != 0x40) * 3 + 0x50;
}



int FTGetEnglishName(FT_Face face,int nid,char *name_return,int name_len)

{
  long lVar1;
  int iVar2;
  ulong uVar3;
  FT_Byte FVar4;
  FT_Byte *pFVar5;
  FT_UInt FVar6;
  long in_FS_OFFSET;
  bool bVar7;
  FT_SfntName name;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar2 = FTGetName(face,nid,3,1,&name);
  if ((iVar2 == 0) && (iVar2 = FTGetName(face,nid,0,-1,&name), iVar2 == 0)) {
    iVar2 = FTGetName(face,nid,1,0,&name);
    if (iVar2 == 0) {
      FVar6 = 0xffffffff;
    }
    else {
      FVar6 = name.string_len;
      if (name_len <= (int)name.string_len) {
        FVar6 = name_len - 1;
      }
      memcpy(name_return,name.string,(long)(int)FVar6);
      name_return[(int)FVar6] = '\0';
    }
  }
  else {
    if (((int)name.string_len < 1) || (name_len < 2)) {
      FVar6 = 0;
    }
    else {
      uVar3 = 0;
      pFVar5 = (FT_Byte *)name_return;
      do {
        name_return = (char *)(pFVar5 + 1);
        FVar4 = '?';
        if (name.string[uVar3 * 2] == '\0') {
          FVar4 = name.string[uVar3 * 2 + 1];
        }
        *pFVar5 = FVar4;
        FVar6 = (int)uVar3 + 1;
      } while ((uVar3 != name.string_len - 1 >> 1) &&
              (bVar7 = uVar3 != name_len - 2, uVar3 = uVar3 + 1, pFVar5 = (FT_Byte *)name_return,
              bVar7));
    }
    *name_return = '\0';
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return FVar6;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Bool SPropRecValList_add_record(SDynPropRecValList *pThisList,char *recordName,char *strValue)

{
  ERecType EVar1;
  SPropRecValListNode *pSVar2;
  int iVar3;
  uint uVar4;
  ulong uVar5;
  SPropRecValListNode *pSVar6;
  int iVar7;
  char *pcVar8;
  ERecType EVar9;
  SPropertyRecord *pSVar10;
  long in_FS_OFFSET;
  anon_union_8_4_c4d4a926_for_uValue local_50;
  char *endPtr;
  long local_40;
  
  pSVar10 = validRecords;
  pcVar8 = "FontFile";
  iVar7 = 0;
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  while (pSVar10 = pSVar10 + 1, iVar3 = strcasecmp(pcVar8,recordName), iVar3 != 0) {
    iVar7 = iVar7 + 1;
    if (iVar7 == 0x11) {
      pcVar8 = "truetype font : invalid record name \"%s.\"\n";
      goto LAB_00119b48;
    }
    pcVar8 = pSVar10->strRecordName;
  }
  EVar1 = validRecords[iVar7].recordType;
  EVar9 = eRecTypeInteger;
  switch(EVar1) {
  case eRecTypeInteger:
    uVar5 = strtol(strValue,&endPtr,0);
    if (*endPtr != '\0') {
      pcVar8 = "truetype font property : %s record needs integer value.\n";
LAB_00119b48:
      EVar9 = eRecTypeVoid;
      __fprintf_chk(_stderr,1,pcVar8,recordName);
      goto LAB_00119b64;
    }
    local_50.dynStringValue = (char *)(uVar5 & 0xffffffff);
    EVar9 = EVar1;
    break;
  case eRecTypeDouble:
    local_50.doubleValue = strtod(strValue,&endPtr);
    if (*endPtr != '\0') {
      pcVar8 = "truetype font property : %s record needs floating point value.\n";
      goto LAB_00119b48;
    }
    break;
  case eRecTypeBool:
    iVar3 = strcasecmp(strValue,"yes");
    if (((((iVar3 == 0) || (iVar3 = strcasecmp(strValue,"y"), iVar3 == 0)) ||
         (iVar3 = strcasecmp(strValue,"on"), iVar3 == 0)) ||
        ((iVar3 = strcasecmp(strValue,"true"), iVar3 == 0 ||
         (iVar3 = strcasecmp(strValue,"t"), iVar3 == 0)))) ||
       (iVar3 = strcasecmp(strValue,"ok"), iVar3 == 0)) {
      uVar4 = 0xffffffff;
    }
    else {
      uVar4 = strcasecmp(strValue,"no");
      if (((uVar4 != 0) && (uVar4 = strcasecmp(strValue,"n"), uVar4 != 0)) &&
         ((uVar4 = strcasecmp(strValue,"off"), uVar4 != 0 &&
          ((uVar4 = strcasecmp(strValue,"false"), uVar4 != 0 &&
           (uVar4 = strcasecmp(strValue,"f"), uVar4 != 0)))))) {
        uVar4 = strcasecmp(strValue,"bad");
        pcVar8 = "truetype font property : %s record needs boolean value.\n";
        if (uVar4 != 0) goto LAB_00119b48;
      }
    }
    local_50._4_4_ = 0;
    local_50.integerValue = uVar4;
    break;
  case eRecTypeString:
    local_50.dynStringValue = strdup(strValue);
    if (local_50.dynStringValue != (char *)0x0) break;
    goto LAB_00119dd0;
  case eRecTypeVoid:
    if (*strValue != '\0') {
      __fprintf_chk(_stderr,1,"truetype font property : %s record needs void.\n",recordName);
      EVar9 = EVar1;
    }
  }
  pSVar6 = (SPropRecValListNode *)malloc(0x18);
  if (pSVar6 == (SPropRecValListNode *)0x0) {
LAB_00119dd0:
    EVar9 = eRecTypeVoid;
    fwrite("truetype font property : cannot allocate memory.\n",1,0x31,_stderr);
  }
  else {
    pSVar2 = pThisList->headNode;
    (pSVar6->containerE).refRecordType = validRecords + iVar7;
    pThisList->headNode = pSVar6;
    pSVar6->nextNode = pSVar2;
    (pSVar6->containerE).uValue = local_50;
  }
LAB_00119b64:
  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return EVar9;
}



// WARNING: Unknown calling convention

Bool SPropRecValList_new(SDynPropRecValList *pThisList)

{
  pThisList->headNode = (SPropRecValListNode *)0x0;
  return 0;
}



Bool SPropRecValList_search_record
               (SRefPropRecValList *pThisList,SPropRecValContainer *refRecValue,char *recordName)

{
  SPropRecValListNode *pSVar1;
  int iVar2;
  
  *refRecValue = (SPropRecValContainer)0x0;
  pSVar1 = pThisList->headNode;
  while( true ) {
    if (pSVar1 == (SPropRecValListNode *)0x0) {
      return 0;
    }
    iVar2 = strcasecmp(((pSVar1->containerE).refRecordType)->strRecordName,recordName);
    if (iVar2 == 0) break;
    pSVar1 = pSVar1->nextNode;
  }
  *refRecValue = (SPropRecValContainer)pSVar1;
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Bool SPropRecValList_add_by_font_cap(SDynPropRecValList *pThisList,char *strCapHead)

{
  char cVar1;
  int iVar2;
  Bool BVar3;
  char *pcVar4;
  ushort **ppuVar5;
  char *pcVar6;
  char *__s;
  char *pcVar7;
  char *strValue;
  int iVar8;
  size_t sVar9;
  anon_struct_16_2_de606a05 *paVar10;
  
  pcVar4 = strrchr(strCapHead,0x3a);
  if (pcVar4 != (char *)0x0) {
    pcVar6 = pcVar4 + -1;
    if (strCapHead <= pcVar6) {
      while (cVar1 = *pcVar6, cVar1 != ':') {
        ppuVar5 = __ctype_b_loc();
        if (((*(byte *)((long)*ppuVar5 + (long)cVar1 * 2 + 1) & 8) == 0) ||
           (pcVar6 = pcVar6 + -1, pcVar6 == strCapHead + -1)) goto LAB_00119f50;
      }
      if (pcVar6 != pcVar4) {
        iVar8 = (int)pcVar4 - (int)pcVar6;
        pcVar4 = (char *)malloc((long)iVar8);
        sVar9 = (size_t)(iVar8 + -1);
        memcpy(pcVar4,pcVar6 + 1,sVar9);
        pcVar4[sVar9] = '\0';
        SPropRecValList_add_record(pThisList,"FaceNumber",pcVar4);
        free(pcVar4);
        pcVar4 = pcVar6;
      }
    }
LAB_00119f50:
    if (strCapHead < pcVar4) {
      do {
        while( true ) {
          pcVar6 = strchr(strCapHead,0x3a);
          sVar9 = (long)pcVar6 - (long)strCapHead;
          if ((long)sVar9 < 1) break;
          __s = (char *)malloc(sVar9 + 1);
          memcpy(__s,strCapHead,sVar9);
          strValue = __s + sVar9;
          *strValue = '\0';
          pcVar7 = strchr(__s,0x3d);
          if (pcVar7 != (char *)0x0) {
            *pcVar7 = '\0';
            strValue = pcVar7 + 1;
          }
          paVar10 = correspondRelations;
          pcVar7 = "fn";
          iVar8 = 0;
          while( true ) {
            paVar10 = paVar10 + 1;
            iVar2 = strcasecmp(pcVar7,__s);
            if (iVar2 == 0) break;
            iVar8 = iVar8 + 1;
            if (iVar8 == 0xf) goto LAB_00119ffd;
            pcVar7 = paVar10->capVariable;
          }
          BVar3 = SPropRecValList_add_record
                            (pThisList,correspondRelations[iVar8].recordName,strValue);
          if (BVar3 != 0) {
LAB_00119ffd:
            fwrite("truetype font : Illegal Font Cap.\n",1,0x22,_stderr);
            return -1;
          }
          strCapHead = pcVar6 + 1;
          free(__s);
          if (pcVar4 <= strCapHead) {
            return 0;
          }
        }
        strCapHead = pcVar6 + 1;
      } while (strCapHead < pcVar4);
    }
  }
  return 0;
}



void bdfFreeFontBits(FontPtr pFont)

{
  void *__ptr;
  undefined8 *__ptr_00;
  int iVar1;
  void *__ptr_01;
  long lVar2;
  long lVar3;
  int iVar4;
  
  __ptr = pFont->fontPrivate;
  __ptr_00 = *(undefined8 **)((long)__ptr + 0x38);
  free(*(void **)((long)__ptr + 0x18));
  __ptr_01 = *(void **)((long)__ptr + 0x28);
  if (__ptr_01 != (void *)0x0) {
    iVar1 = (((uint)(pFont->info).lastCol - (uint)(pFont->info).firstCol) + 1) *
            (((uint)(pFont->info).lastRow - (uint)(pFont->info).firstRow) + 1);
    iVar4 = iVar1 + 0xfe;
    if (-1 < iVar1 + 0x7f) {
      iVar4 = iVar1 + 0x7f;
    }
    if (0 < iVar1) {
      lVar2 = 0;
      do {
        lVar3 = lVar2 * 8;
        lVar2 = lVar2 + 1;
        free(*(void **)((long)__ptr_01 + lVar3));
        __ptr_01 = *(void **)((long)__ptr + 0x28);
      } while ((int)lVar2 < iVar4 >> 7);
    }
  }
  free(__ptr_01);
  lVar2 = 0;
  if (0 < *(int *)((long)__ptr + 4)) {
    do {
      lVar3 = lVar2 + 1;
      free(*(void **)(*(long *)((long)__ptr + 0x10) + lVar2 * 0x18 + 0x10));
      lVar2 = lVar3;
    } while ((int)lVar3 < *(int *)((long)__ptr + 4));
  }
  free(*(void **)((long)__ptr + 0x10));
  if (__ptr_00 != (undefined8 *)0x0) {
    free((void *)*__ptr_00);
    free((void *)__ptr_00[1]);
    free(__ptr_00);
  }
  free((pFont->info).props);
  free(__ptr);
  return;
}



void bdfUnloadFont(FontPtr pFont)

{
  bdfFreeFontBits(pFont);
  DestroyFontRec(pFont);
  return;
}



int bdfReadFont(FontPtr pFont,FontFilePtr file,int bit,int byte,int glyph,int scan)

{
  undefined *puVar1;
  ushort uVar2;
  ushort uVar3;
  ushort uVar4;
  ushort uVar5;
  long lVar6;
  void *pvVar7;
  long *plVar8;
  CharInfoPtr p_Var9;
  short sVar10;
  uchar uVar11;
  byte bVar12;
  byte bVar13;
  short sVar14;
  int iVar15;
  uint uVar16;
  uint uVar17;
  Bool BVar18;
  int iVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  uchar *puVar23;
  byte *pbVar24;
  void *pvVar25;
  undefined8 *puVar26;
  char *pcVar27;
  FontPropPtr p_Var28;
  ushort **ppuVar29;
  Atom AVar30;
  void *pvVar31;
  CharInfoPtr *pp_Var32;
  size_t sVar33;
  CharInfoPtr *pp_Var34;
  long lVar35;
  long lVar36;
  long lVar37;
  ulong uVar38;
  ushort uVar39;
  int iVar40;
  uint uVar41;
  uint *puVar42;
  uint *puVar43;
  char cVar44;
  short sVar45;
  CharInfoPtr **ppp_Var46;
  bdfFileState *pbVar47;
  CharInfoPtr **ppp_Var48;
  FontPropPtr p_Var49;
  uint uVar50;
  int iVar51;
  byte *pbVar52;
  byte *pbVar53;
  long lVar54;
  long in_FS_OFFSET;
  bool bVar55;
  bool bVar56;
  bool bVar57;
  byte bVar58;
  char local_1d98;
  char local_1d94;
  char local_1d90;
  char local_1d8c;
  int local_1d80;
  CharInfoPtr local_1d78;
  long *local_1d60;
  uchar *local_1d58;
  int local_1d48;
  char *local_1d40;
  uint local_1d38;
  uint local_1d34;
  int local_1d24;
  uint local_1d20;
  int local_1cfc;
  int nchars;
  int wx;
  int wy;
  int bw;
  int bh;
  int bl;
  int bb;
  int enc;
  int nProps;
  short sStack_1cd4;
  short sStack_1cd2;
  undefined auStack_1cd0 [8];
  char *pcStack_1cc8;
  bdfFileState state;
  CharInfoPtr *bdfEncoding [256];
  char namebuf_1 [1024];
  char secondbuf [1024];
  char namebuf [1024];
  uchar lineBuf [1024];
  
  bVar58 = 0;
  lVar6 = *(long *)(in_FS_OFFSET + 0x28);
  pFont->fontPrivate = (void *)0x0;
  pbVar47 = &state;
  for (lVar37 = 0x8e; lVar37 != 0; lVar37 = lVar37 + -1) {
    *(undefined8 *)pbVar47 = 0;
    pbVar47 = (bdfFileState *)&pbVar47->fileName;
  }
  bdfFileLineNum = 0;
  puVar23 = bdfGetLine(file,lineBuf,0x400);
  if (puVar23 == (uchar *)0x0) {
LAB_0011a25c:
    bdfError("bad \'STARTFONT\'\n");
  }
  else {
    iVar15 = __isoc99_sscanf(puVar23,"STARTFONT %s",namebuf);
    if ((iVar15 != 1) || (namebuf._0_4_ != 0x312e32)) goto LAB_0011a25c;
    puVar23 = bdfGetLine(file,lineBuf,0x400);
    if (puVar23 == (uchar *)0x0) {
LAB_0011a2f8:
      bdfError("bad \'FONT\'\n");
    }
    else {
      iVar15 = __isoc99_sscanf(puVar23,&DAT_00132a56,state.fontName);
      if (iVar15 != 1) goto LAB_0011a2f8;
      pbVar24 = bdfGetLine(file,lineBuf,0x400);
      bVar55 = false;
      bVar56 = pbVar24 == (byte *)0x0;
      if (bVar56) {
LAB_0011a4d8:
        bdfError("missing \'SIZE\'\n");
      }
      else {
        lVar37 = 4;
        pbVar53 = pbVar24;
        pbVar52 = (byte *)0x1324cb;
        do {
          if (lVar37 == 0) break;
          lVar37 = lVar37 + -1;
          bVar55 = *pbVar53 < *pbVar52;
          bVar56 = *pbVar53 == *pbVar52;
          pbVar53 = pbVar53 + (ulong)bVar58 * -2 + 1;
          pbVar52 = pbVar52 + (ulong)bVar58 * -2 + 1;
        } while (bVar56);
        if ((!bVar55 && !bVar56) != bVar55) goto LAB_0011a4d8;
        iVar15 = __isoc99_sscanf(pbVar24,"SIZE %f%d%d",&state.pointSize,&state.resolution_x,
                                 &state.resolution_y);
        if (iVar15 == 3) {
          if (((state.pointSize < 1.0) || (state.resolution_x < 1)) || (state.resolution_y < 1)) {
            bdfError("SIZE values must be > 0\n");
          }
          else {
            pbVar24 = bdfGetLine(file,lineBuf,0x400);
            bVar55 = false;
            bVar56 = pbVar24 == (byte *)0x0;
            if (!bVar56) {
              lVar37 = 0xf;
              pbVar53 = (byte *)"FONTBOUNDINGBOX";
              do {
                if (lVar37 == 0) break;
                lVar37 = lVar37 + -1;
                bVar55 = *pbVar24 < *pbVar53;
                bVar56 = *pbVar24 == *pbVar53;
                pbVar24 = pbVar24 + (ulong)bVar58 * -2 + 1;
                pbVar53 = pbVar53 + (ulong)bVar58 * -2 + 1;
              } while (bVar56);
              if ((!bVar55 && !bVar56) == bVar55) {
                pvVar25 = calloc(1,0x40);
                if (pvVar25 == (void *)0x0) {
                  bdfError("Couldn\'t allocate bitmapFontRec (%d)\n",0x40);
                }
                else {
                  pFont->fontPrivate = pvVar25;
                  *(undefined8 *)((long)pvVar25 + 0x10) = 0;
                  *(undefined8 *)((long)pvVar25 + 0x18) = 0;
                  *(undefined8 *)((long)pvVar25 + 0x20) = 0;
                  *(undefined8 *)((long)pvVar25 + 0x28) = 0;
                  *(undefined8 *)((long)pvVar25 + 0x30) = 0;
                  puVar26 = (undefined8 *)calloc(1,0x78);
                  *(undefined8 **)((long)pvVar25 + 0x38) = puVar26;
                  if (puVar26 == (undefined8 *)0x0) {
                    bdfError("Couldn\'t allocate bitmapExtra (%d)\n",0x78);
                  }
                  else {
                    *puVar26 = 0;
                    puVar26[1] = 0;
                    pbVar24 = bdfGetLine(file,lineBuf,0x400);
                    bVar55 = false;
                    bVar56 = pbVar24 == (byte *)0x0;
                    if (!bVar56) {
                      lVar37 = 0xf;
                      pbVar53 = pbVar24;
                      pbVar52 = (byte *)"STARTPROPERTIES";
                      do {
                        if (lVar37 == 0) break;
                        lVar37 = lVar37 + -1;
                        bVar55 = *pbVar53 < *pbVar52;
                        bVar56 = *pbVar53 == *pbVar52;
                        pbVar53 = pbVar53 + (ulong)bVar58 * -2 + 1;
                        pbVar52 = pbVar52 + (ulong)bVar58 * -2 + 1;
                      } while (bVar56);
                      cVar44 = (!bVar55 && !bVar56) - bVar55;
                      local_1d48 = (int)cVar44;
                      if (cVar44 == '\0') {
                        iVar15 = __isoc99_sscanf(pbVar24,"STARTPROPERTIES %d",(CharInfoPtr)&nProps);
                        if (iVar15 != 1) {
                          bdfError("bad \'STARTPROPERTIES\'\n");
                          goto LAB_0011a26a;
                        }
                        (pFont->info).props = (FontPropPtr)0x0;
                        (pFont->info).nprops = 0;
                        pcVar27 = (char *)malloc((long)(CONCAT22(nProps._2_2_,(short)nProps) + 6));
                        (pFont->info).isStringProp = pcVar27;
                        if (pcVar27 == (char *)0x0) {
                          bdfError("Couldn\'t allocate stringProps (%d*%d)\n",
                                   (ulong)(CONCAT22(nProps._2_2_,(short)nProps) + 6),4);
                        }
                        else {
                          p_Var28 = (FontPropPtr)
                                    calloc((long)(CONCAT22(nProps._2_2_,(short)nProps) + 6),0x10);
                          (pFont->info).props = p_Var28;
                          iVar15 = CONCAT22(nProps._2_2_,(short)nProps);
                          if (p_Var28 == (FontPropPtr)0x0) {
                            bdfError("Couldn\'t allocate props (%d*%d)\n",(ulong)(iVar15 + 6),0x10);
                          }
                          else {
                            local_1d80 = iVar15 + -1;
                            if (0 < iVar15) {
                              do {
                                pbVar24 = bdfGetLine(file,lineBuf,0x400);
                                bVar55 = false;
                                bVar56 = pbVar24 == (byte *)0x0;
                                if (bVar56) {
LAB_0011b5f0:
                                  bdfError("\"STARTPROPERTIES %d\" followed by only %d properties\n"
                                           ,(ulong)CONCAT22(nProps._2_2_,(short)nProps),
                                           (ulong)((CONCAT22(nProps._2_2_,(short)nProps) -
                                                   local_1d80) - 1));
                                  goto LAB_0011a640;
                                }
                                lVar37 = 0xd;
                                pbVar53 = pbVar24;
                                pbVar52 = (byte *)"ENDPROPERTIES";
                                do {
                                  if (lVar37 == 0) break;
                                  lVar37 = lVar37 + -1;
                                  bVar55 = *pbVar53 < *pbVar52;
                                  bVar56 = *pbVar53 == *pbVar52;
                                  pbVar53 = pbVar53 + (ulong)bVar58 * -2 + 1;
                                  pbVar52 = pbVar52 + (ulong)bVar58 * -2 + 1;
                                } while (bVar56);
                                if ((!bVar55 && !bVar56) == bVar55) goto LAB_0011b5f0;
                                bVar12 = *pbVar24;
                                if (bVar12 != 0) {
                                  ppuVar29 = __ctype_b_loc();
                                  do {
                                    if ((*(byte *)((long)*ppuVar29 + (ulong)bVar12 * 2 + 1) & 0x20)
                                        == 0) break;
                                    bVar12 = pbVar24[1];
                                    pbVar24 = pbVar24 + 1;
                                  } while (bVar12 != 0);
                                }
                                iVar15 = __isoc99_sscanf(pbVar24,"%s%s%s",namebuf_1,secondbuf,
                                                         namebuf);
                                if (iVar15 == 2) {
                                  if (secondbuf[0] == '\"') {
                                    pcVar27[local_1d48] = '\x01';
                                    puVar43 = (uint *)namebuf_1;
                                    do {
                                      puVar42 = puVar43;
                                      uVar16 = *puVar42 + 0xfefefeff & ~*puVar42;
                                      uVar17 = uVar16 & 0x80808080;
                                      puVar43 = puVar42 + 1;
                                    } while (uVar17 == 0);
                                    bVar55 = (uVar16 & 0x8080) == 0;
                                    if (bVar55) {
                                      uVar17 = uVar17 >> 0x10;
                                    }
                                    if (bVar55) {
                                      puVar43 = (uint *)((long)puVar42 + 6);
                                    }
                                    bVar55 = CARRY1((byte)uVar17,(byte)uVar17);
                                    goto LAB_0011a707;
                                  }
                                  iVar15 = bdfIsInteger(secondbuf);
                                  if (iVar15 == 0) goto LAB_0011ba4b;
                                  pcVar27[local_1d48] = '\0';
                                  lVar37 = strtol(secondbuf,(char **)0x0,10);
                                  p_Var49 = p_Var28 + local_1d48;
                                  p_Var49->value = (long)(int)lVar37;
                                }
                                else {
                                  if (iVar15 != 3) {
                                    bdfError("missing \'%s\' parameter value\n",namebuf_1);
                                    goto LAB_0011a640;
                                  }
                                  if (secondbuf[0] != '\"') {
LAB_0011ba4b:
                                    bdfError("invalid \'%s\' parameter value\n",namebuf_1);
                                    goto LAB_0011a640;
                                  }
                                  pcVar27[local_1d48] = '\x01';
                                  puVar43 = (uint *)namebuf_1;
                                  do {
                                    puVar42 = puVar43;
                                    uVar16 = *puVar42 + 0xfefefeff & ~*puVar42;
                                    uVar17 = uVar16 & 0x80808080;
                                    puVar43 = puVar42 + 1;
                                  } while (uVar17 == 0);
                                  bVar55 = (uVar16 & 0x8080) == 0;
                                  if (bVar55) {
                                    uVar17 = uVar17 >> 0x10;
                                  }
                                  if (bVar55) {
                                    puVar43 = (uint *)((long)puVar42 + 6);
                                  }
                                  bVar55 = CARRY1((byte)uVar17,(byte)uVar17);
LAB_0011a707:
                                  AVar30 = bdfGetPropertyValue((char *)(pbVar24 +
                                                                       (long)((long)puVar43 +
                                                                             ((-2 - (ulong)bVar55) -
                                                                             (long)namebuf_1))));
                                  p_Var49 = p_Var28 + local_1d48;
                                  p_Var49->value = AVar30;
                                  if (AVar30 == 0) goto LAB_0011a640;
                                }
                                AVar30 = bdfForceMakeAtom(namebuf_1,(int *)0x0);
                                p_Var49->name = AVar30;
                                if (AVar30 == 0) {
                                  bdfError("Empty property name.\n");
                                  goto LAB_0011a640;
                                }
                                BVar18 = bdfSpecialProperty(pFont,p_Var49,pcVar27[local_1d48],&state
                                                           );
                                local_1d48 = local_1d48 + (uint)(BVar18 == 0);
                                local_1d80 = local_1d80 + -1;
                              } while (local_1d80 != -1);
                            }
                            pbVar24 = bdfGetLine(file,lineBuf,0x400);
                            bVar55 = false;
                            bVar56 = pbVar24 == (byte *)0x0;
                            if (!bVar56) {
                              lVar37 = 0xd;
                              pbVar53 = pbVar24;
                              pbVar52 = (byte *)"ENDPROPERTIES";
                              do {
                                if (lVar37 == 0) break;
                                lVar37 = lVar37 + -1;
                                bVar55 = *pbVar53 < *pbVar52;
                                bVar56 = *pbVar53 == *pbVar52;
                                pbVar53 = pbVar53 + (ulong)bVar58 * -2 + 1;
                                pbVar52 = pbVar52 + (ulong)bVar58 * -2 + 1;
                              } while (bVar56);
                              cVar44 = (!bVar55 && !bVar56) - bVar55;
                              local_1cfc = (int)cVar44;
                              if (cVar44 == '\0') {
                                if ((state.haveFontAscent == '\0') ||
                                   (state.haveFontDescent == '\0')) {
                                  bdfError(
                                          "missing \'FONT_ASCENT\' or \'FONT_DESCENT\' properties\n"
                                          );
                                  goto LAB_0011a640;
                                }
                                if (*(long *)((long)pvVar25 + 0x38) != 0) {
                                  *(short *)(*(long *)((long)pvVar25 + 0x38) + 0x60) =
                                       (pFont->info).fontAscent;
                                  *(short *)(*(long *)((long)pvVar25 + 0x38) + 0x62) =
                                       (pFont->info).fontDescent;
                                }
                                iVar15 = local_1d48;
                                if (state.pointSizeProp == (FontPropPtr)0x0) {
                                  AVar30 = bdfForceMakeAtom("POINT_SIZE",(int *)0x0);
                                  iVar15 = local_1d48 + 1;
                                  state.pointSizeProp = p_Var28 + local_1d48;
                                  (state.pointSizeProp)->name = AVar30;
                                  (state.pointSizeProp)->value = (long)(int)(state.pointSize * 10.0)
                                  ;
                                  pcVar27[local_1d48] = '\0';
                                }
                                iVar19 = iVar15;
                                if (state.fontProp == (FontPropPtr)0x0) {
                                  iVar19 = iVar15 + 1;
                                  AVar30 = bdfForceMakeAtom("FONT",(int *)0x0);
                                  p_Var49 = p_Var28 + iVar15;
                                  p_Var49->name = AVar30;
                                  AVar30 = bdfForceMakeAtom(state.fontName,(int *)0x0);
                                  p_Var49->value = (long)(int)AVar30;
                                  pcVar27[iVar15] = '\x01';
                                  state.fontProp = p_Var49;
                                }
                                iVar15 = iVar19;
                                if (state.weightProp == (FontPropPtr)0x0) {
                                  AVar30 = bdfForceMakeAtom("WEIGHT",(int *)0x0);
                                  iVar15 = iVar19 + 1;
                                  state.weightProp = p_Var28 + iVar19;
                                  pcVar27[iVar19] = '\0';
                                  (state.weightProp)->name = AVar30;
                                  (state.weightProp)->value = -1;
                                }
                                iVar19 = iVar15;
                                if ((state.resolutionProp == (FontPropPtr)0x0) &&
                                   (state.resolution_x == state.resolution_y)) {
                                  AVar30 = bdfForceMakeAtom("RESOLUTION",(int *)0x0);
                                  iVar19 = iVar15 + 1;
                                  state.resolutionProp = p_Var28 + iVar15;
                                  (state.resolutionProp)->name = AVar30;
                                  (state.resolutionProp)->value =
                                       (long)(int)(((double)state.resolution_x * 100.0) / 72.27);
                                  pcVar27[iVar15] = '\0';
                                }
                                iVar15 = iVar19;
                                if (state.resolutionXProp == (FontPropPtr)0x0) {
                                  AVar30 = bdfForceMakeAtom("RESOLUTION_X",(int *)0x0);
                                  iVar15 = iVar19 + 1;
                                  state.resolutionProp = p_Var28 + iVar19;
                                  (state.resolutionProp)->value = (long)state.resolution_x;
                                  (state.resolutionProp)->name = AVar30;
                                  pcVar27[iVar19] = '\0';
                                }
                                iVar19 = iVar15;
                                if (state.resolutionYProp == (FontPropPtr)0x0) {
                                  AVar30 = bdfForceMakeAtom("RESOLUTION_Y",(int *)0x0);
                                  iVar19 = iVar15 + 1;
                                  state.resolutionProp = p_Var28 + iVar15;
                                  (state.resolutionProp)->value = (long)state.resolution_y;
                                  (state.resolutionProp)->name = AVar30;
                                  pcVar27[iVar15] = '\0';
                                }
                                iVar15 = iVar19;
                                if (state.xHeightProp == (FontPropPtr)0x0) {
                                  AVar30 = bdfForceMakeAtom("X_HEIGHT",(int *)0x0);
                                  iVar15 = iVar19 + 1;
                                  state.xHeightProp = p_Var28 + iVar19;
                                  pcVar27[iVar19] = '\0';
                                  (state.xHeightProp)->name = AVar30;
                                  (state.xHeightProp)->value = -1;
                                }
                                iVar19 = iVar15;
                                if (state.quadWidthProp == (FontPropPtr)0x0) {
                                  AVar30 = bdfForceMakeAtom("QUAD_WIDTH",(int *)0x0);
                                  iVar19 = iVar15 + 1;
                                  pcVar27[iVar15] = '\0';
                                  state.quadWidthProp = p_Var28 + iVar15;
                                  (state.quadWidthProp)->name = AVar30;
                                  (state.quadWidthProp)->value = -1;
                                }
                                pvVar7 = pFont->fontPrivate;
                                (pFont->info).nprops = iVar19;
                                plVar8 = *(long **)((long)pvVar7 + 0x38);
                                if (plVar8 == (long *)0x0) {
                                  local_1d60 = (long *)0x0;
                                }
                                else {
                                  local_1d60 = plVar8 + 2;
                                  plVar8[2] = 0;
                                  plVar8[3] = 0;
                                }
                                ppp_Var46 = bdfEncoding;
                                ppp_Var48 = ppp_Var46;
                                for (lVar37 = 0x100; lVar37 != 0; lVar37 = lVar37 + -1) {
                                  *ppp_Var48 = (CharInfoPtr *)0x0;
                                  ppp_Var48 = ppp_Var48 + (ulong)bVar58 * -2 + 1;
                                }
                                *(undefined8 *)((long)pvVar7 + 0x10) = 0;
                                puVar23 = bdfGetLine(file,(uchar *)namebuf,0x400);
                                if ((puVar23 == (uchar *)0x0) ||
                                   (iVar15 = __isoc99_sscanf(puVar23,"CHARS %d",&nchars),
                                   iVar15 != 1)) {
                                  bdfError("bad \'CHARS\' in bdf file\n");
                                }
                                else if (nchars < 1) {
                                  bdfError("invalid number of CHARS in BDF file\n");
                                }
                                else {
                                  if (nchars < 0x5555556) {
                                    local_1d78 = (CharInfoPtr)calloc((long)nchars,0x18);
                                    if (local_1d78 == (CharInfoPtr)0x0) {
                                      bdfError("Couldn\'t allocate pCI (%d*%d)\n",
                                               (ulong)(uint)nchars,0x18);
                                      bdfEncoding[0] = (CharInfoPtr *)0x0;
                                    }
                                    else {
                                      *(CharInfoPtr *)((long)pvVar7 + 0x10) = local_1d78;
                                      if (plVar8 != (long *)0x0) {
                                        pvVar31 = malloc((long)nchars << 3);
                                        *plVar8 = (long)pvVar31;
                                        if (pvVar31 == (void *)0x0) {
                                          bdfError("Couldn\'t allocate glyphNames (%d*%d)\n",
                                                   (ulong)(uint)nchars,8);
                                          bdfEncoding[0] = (CharInfoPtr *)0x0;
                                          goto LAB_0011b040;
                                        }
                                        pvVar31 = malloc((long)nchars << 2);
                                        plVar8[1] = (long)pvVar31;
                                        if (pvVar31 == (void *)0x0) {
                                          bdfError("Couldn\'t allocate sWidth (%d *%d)\n",
                                                   (ulong)(uint)nchars,4);
                                          goto LAB_0011a26a;
                                        }
                                      }
                                      pp_Var32 = (CharInfoPtr *)
                                                 bdfGetLine(file,(uchar *)namebuf,0x400);
                                      uVar38 = (ulong)(uint)nchars;
                                      (pFont->info).firstCol = 0x100;
                                      (pFont->info).lastCol = 0;
                                      (pFont->info).firstRow = 0x100;
                                      (pFont->info).lastRow = 0;
                                      if (nchars < 1) {
                                        local_1d24 = 0;
                                        uVar17 = 0;
LAB_0011baaf:
                                        uVar16 = nchars;
                                        if (nchars != uVar17) goto LAB_0011b814;
                                        nchars = local_1cfc;
                                        *(int *)((long)pvVar7 + 4) = local_1cfc;
                                        bVar55 = false;
                                        bVar56 = pp_Var32 == (CharInfoPtr *)0x0;
                                        if (bVar56) {
LAB_0011b026:
                                          bdfError("missing \'ENDFONT\'\n");
                                        }
                                        else {
LAB_0011b85d:
                                          local_1d40 = "STARTCHAR";
                                          lVar37 = 9;
                                          pp_Var34 = pp_Var32;
                                          do {
                                            if (lVar37 == 0) break;
                                            lVar37 = lVar37 + -1;
                                            bVar55 = *(byte *)pp_Var34 < (byte)*local_1d40;
                                            bVar56 = *(byte *)pp_Var34 == *local_1d40;
                                            pp_Var34 = (CharInfoPtr *)
                                                       ((long)pp_Var34 + (ulong)bVar58 * -2 + 1);
                                            local_1d40 = (char *)((byte *)local_1d40 +
                                                                 (ulong)bVar58 * -2 + 1);
                                          } while (bVar56);
                                          bVar57 = false;
                                          bVar55 = (!bVar55 && !bVar56) == bVar55;
                                          if (bVar55) {
                                            bdfError("more characters than specified\n");
                                          }
                                          else {
                                            lVar37 = 7;
                                            pbVar24 = (byte *)"ENDFONT";
                                            do {
                                              if (lVar37 == 0) break;
                                              lVar37 = lVar37 + -1;
                                              bVar57 = *(byte *)pp_Var32 < *pbVar24;
                                              bVar55 = *(byte *)pp_Var32 == *pbVar24;
                                              pp_Var32 = (CharInfoPtr *)
                                                         ((long)pp_Var32 + (ulong)bVar58 * -2 + 1);
                                              pbVar24 = pbVar24 + (ulong)bVar58 * -2 + 1;
                                            } while (bVar55);
                                            cVar44 = (!bVar57 && !bVar55) - bVar57;
                                            uVar17 = (uint)cVar44;
                                            if (cVar44 != '\0') goto LAB_0011b026;
                                            if (local_1d24 == 0) {
                                              bdfWarning("No characters with valid encodings\n");
                                            }
                                            iVar15 = (((uint)(pFont->info).lastRow -
                                                      (uint)(pFont->info).firstRow) + 1) *
                                                     (((uint)(pFont->info).lastCol -
                                                      (uint)(pFont->info).firstCol) + 1);
                                            iVar19 = iVar15 + 0x7f;
                                            iVar15 = iVar15 + 0xfe;
                                            if (-1 < iVar19) {
                                              iVar15 = iVar19;
                                            }
                                            pvVar31 = calloc((long)(iVar15 >> 7),8);
                                            *(void **)((long)pvVar7 + 0x28) = pvVar31;
                                            if (pvVar31 != (void *)0x0) {
                                              puVar1 = &(pFont->info).field_0xa;
                                              *puVar1 = *puVar1 | 0x40;
                                              uVar2 = (pFont->info).firstRow;
                                              uVar38 = (ulong)uVar2;
                                              iVar15 = 0;
                                              if (uVar2 <= (pFont->info).lastRow) {
                                                do {
                                                  uVar2 = (pFont->info).lastCol;
                                                  uVar3 = (pFont->info).firstCol;
                                                  if (ppp_Var46[uVar38] == (CharInfoPtr *)0x0) {
                                                    puVar1 = &(pFont->info).field_0xa;
                                                    *puVar1 = *puVar1 & 0xbf;
                                                    iVar15 = iVar15 + 1 +
                                                             ((uint)uVar2 - (uint)uVar3);
                                                  }
                                                  else if (uVar3 <= uVar2) {
                                                    pp_Var32 = ppp_Var46[uVar38] + (uint)uVar3;
                                                    iVar19 = (uint)uVar3 - iVar15;
                                                    do {
                                                      p_Var9 = *pp_Var32;
                                                      if (p_Var9 == (CharInfoPtr)0x0) {
                                                        puVar1 = &(pFont->info).field_0xa;
                                                        *puVar1 = *puVar1 & 0xbf;
                                                      }
                                                      else {
                                                        iVar51 = iVar15 + 0x7f;
                                                        if (-1 < iVar15) {
                                                          iVar51 = iVar15;
                                                        }
                                                        plVar8 = (long *)(*(long *)((long)pvVar7 +
                                                                                   0x28) +
                                                                         (long)(iVar51 >> 7) * 8);
                                                        lVar37 = *plVar8;
                                                        if (lVar37 == 0) {
                                                          pvVar31 = calloc(0x80,8);
                                                          *plVar8 = (long)pvVar31;
                                                          lVar37 = *(long *)(*(long *)((long)pvVar7
                                                                                      + 0x28) +
                                                                            (long)(iVar51 >> 7) * 8)
                                                          ;
                                                          if (lVar37 == 0) goto LAB_0011b040;
                                                        }
                                                        *(CharInfoPtr *)
                                                         (lVar37 + (long)(iVar15 % 0x80) * 8) =
                                                             p_Var9;
                                                      }
                                                      iVar15 = iVar15 + 1;
                                                      pp_Var32 = pp_Var32 + 1;
                                                    } while ((uint)(iVar15 + iVar19) <=
                                                             (uint)(pFont->info).lastCol);
                                                  }
                                                  uVar38 = uVar38 + 1;
                                                } while ((uint)uVar38 <= (uint)(pFont->info).lastRow
                                                        );
                                              }
                                              do {
                                                if (*ppp_Var46 != (CharInfoPtr *)0x0) {
                                                  free(*ppp_Var46);
                                                }
                                                ppp_Var46 = ppp_Var46 + 1;
                                              } while ((CharInfoPtr **)namebuf_1 != ppp_Var46);
                                              if (state.haveDefaultCh != '\0') {
                                                uVar2 = (pFont->info).defaultCh;
                                                uVar3 = (pFont->info).firstRow;
                                                uVar39 = uVar2 >> 8;
                                                if ((uVar3 <= uVar39) &&
                                                   (uVar39 <= (pFont->info).lastRow)) {
                                                  uVar4 = (pFont->info).firstCol;
                                                  if ((uVar4 <= (uVar2 & 0xff)) &&
                                                     (uVar5 = (pFont->info).lastCol,
                                                     (uVar2 & 0xff) <= uVar5)) {
                                                    uVar16 = ((uint)(byte)uVar2 - (uint)uVar4) +
                                                             ((uint)uVar39 - (uint)uVar3) *
                                                             (((uint)uVar5 - (uint)uVar4) + 1);
                                                    lVar37 = *(long *)(*(long *)((long)pvVar25 +
                                                                                0x28) +
                                                                      (ulong)(uVar16 >> 7) * 8);
                                                    if (lVar37 != 0) {
                                                      lVar37 = *(long *)(lVar37 + (ulong)(uVar16 & 
                                                  0x7f) * 8);
                                                  }
                                                  *(long *)((long)pvVar25 + 0x30) = lVar37;
                                                  }
                                                }
                                              }
                                              local_1d94 = (char)bit;
                                              pFont->bit = local_1d94;
                                              local_1d8c = (char)byte;
                                              pFont->byte = local_1d8c;
                                              local_1d98 = (char)glyph;
                                              pFont->glyph = local_1d98;
                                              local_1d90 = (char)scan;
                                              pFont->scan = local_1d90;
                                              (pFont->info).field_0xb =
                                                   (pFont->info).field_0xb & 0xf9 | 2;
                                              bitmapComputeFontBounds(pFont);
                                              iVar15 = FontCouldBeTerminal(&pFont->info);
                                              if (iVar15 != 0) {
                                                auStack_1cd0._0_2_ = (pFont->info).fontDescent;
                                                sStack_1cd2 = (pFont->info).fontAscent;
                                                nProps._2_2_ = (pFont->info).minbounds.
                                                               characterWidth;
                                                pvVar7 = pFont->fontPrivate;
                                                iVar15 = (int)sStack_1cd2 +
                                                         (int)(short)auStack_1cd0._0_2_;
                                                stack0xffffffffffffe332 =
                                                     SUB1614((undefined  [16])0x0,2);
                                                cVar44 = pFont->glyph;
                                                nProps._0_2_ = 0;
                                                if (cVar44 == '\x01') {
                                                  uVar17 = (nProps._2_2_ + 7 >> 3) * iVar15;
                                                }
                                                else if (cVar44 == '\x02') {
                                                  uVar17 = (nProps._2_2_ + 0xf >> 3 & 0xfffffffeU) *
                                                           iVar15;
                                                }
                                                else if (cVar44 == '\x04') {
                                                  uVar17 = (nProps._2_2_ + 0x1f >> 3 & 0xfffffffcU)
                                                           * iVar15;
                                                }
                                                else if (cVar44 == '\b') {
                                                  uVar17 = (nProps._2_2_ + 0x3f >> 3 & 0xfffffff8U)
                                                           * iVar15;
                                                }
                                                lVar37 = 0;
                                                sStack_1cd4 = nProps._2_2_;
                                                if (0 < *(int *)((long)pvVar7 + 4)) {
                                                  do {
                                                    pvVar31 = malloc((long)(int)uVar17);
                                                    pcStack_1cc8 = (char *)pvVar31;
                                                    if (pvVar31 == (void *)0x0) {
                                                      bdfError("Couldn\'t allocate bits (%d)\n",
                                                               (ulong)uVar17);
                                                      goto LAB_0011bee3;
                                                    }
                                                    lVar36 = lVar37 * 0x18;
                                                    lVar54 = lVar37 + 1;
                                                    FontCharReshape(pFont,(CharInfoPtr)
                                                                          (*(long *)((long)pvVar7 +
                                                                                    0x10) + lVar36),
                                                                    (CharInfoPtr)&nProps);
                                                    lVar35 = *(long *)((long)pvVar7 + 0x10) + lVar36
                                                    ;
                                                    auStack_1cd0._2_2_ = *(CARD16 *)(lVar35 + 10);
                                                    free(*(void **)(lVar35 + 0x10));
                                                    lVar35 = *(long *)((long)pvVar7 + 0x10);
                                                    puVar26 = (undefined8 *)(lVar35 + lVar37 * 0x18)
                                                    ;
                                                    *puVar26 = CONCAT26(sStack_1cd2,
                                                                        CONCAT24(sStack_1cd4,
                                                                                 CONCAT22(nProps.
                                                  _2_2_,(short)nProps)));
                                                  puVar26[1] = auStack_1cd0;
                                                  *(char **)(lVar35 + 0x10 + lVar36) = pcStack_1cc8;
                                                  lVar37 = lVar54;
                                                  } while ((int)lVar54 < *(int *)((long)pvVar7 + 4))
                                                  ;
                                                }
                                                lVar37 = *(long *)((long)pvVar7 + 0x38);
                                                if (lVar37 != 0) {
                                                  iVar15 = (int)nProps._2_2_ - (int)(short)nProps;
                                                  lVar36 = 0;
                                                  do {
                                                    uVar17 = iVar15 + 7 >> 3;
                                                    if (((lVar36 == 0) ||
                                                        (iVar19 = (int)lVar36,
                                                        uVar17 = iVar15 + 0xf >> 3 & 0xfffffffe,
                                                        iVar19 == 1)) ||
                                                       (uVar17 = iVar15 + 0x1f >> 3 & 0xfffffffc,
                                                       iVar19 == 2)) {
                                                      *(uint *)(lVar37 + 0x10 + lVar36 * 4) =
                                                           uVar17 * ((int)sStack_1cd2 +
                                                                    (int)(short)auStack_1cd0._0_2_)
                                                           * *(int *)((long)pvVar7 + 4);
                                                    }
                                                    else {
                                                      *(uint *)(lVar37 + 0x10 + lVar36 * 4) =
                                                           *(int *)((long)pvVar7 + 4) *
                                                           (iVar15 + 0x3f >> 3 & 0xfffffff8U) *
                                                           ((int)sStack_1cd2 +
                                                           (int)(short)auStack_1cd0._0_2_);
                                                      if (iVar19 == 3) break;
                                                    }
                                                    lVar36 = lVar36 + 1;
                                                  } while( true );
                                                }
LAB_0011bee3:
                                                bitmapComputeFontBounds(pFont);
                                              }
                                              FontComputeInfoAccelerators(&pFont->info);
                                              if (*(long *)((long)pvVar25 + 0x38) == 0) {
                                                if (((pFont->info).field_0xa & 4) != 0)
                                                goto LAB_0011bd13;
                                              }
                                              else {
                                                FontComputeInfoAccelerators
                                                          ((FontInfoPtr)
                                                           (*(long *)((long)pvVar25 + 0x38) + 0x20))
                                                ;
                                                if (((pFont->info).field_0xa & 4) != 0) {
LAB_0011bd13:
                                                  BVar18 = bitmapAddInkMetrics(pFont);
                                                  if (BVar18 == 0) {
                                                    bdfError("Failed to add bitmap ink metrics\n");
                                                    goto LAB_0011a26a;
                                                  }
                                                }
                                                lVar37 = *(long *)((long)pvVar25 + 0x38);
                                                if (lVar37 != 0) {
                                                  *(byte *)(lVar37 + 0x2a) =
                                                       *(byte *)(lVar37 + 0x2a) & 0xdf |
                                                       (pFont->info).field_0xa & 0x20;
                                                }
                                              }
                                              bitmapComputeFontInkBounds(pFont);
                                              if ((state.xHeightProp != (FontPropPtr)0x0) &&
                                                 ((state.xHeightProp)->value == -1)) {
                                                lVar37 = (long)state.exHeight;
                                                if (state.exHeight == 0) {
                                                  lVar37 = (long)(pFont->info).ink_minbounds.ascent;
                                                }
                                                (state.xHeightProp)->value = lVar37;
                                              }
                                              if ((state.quadWidthProp != (FontPropPtr)0x0) &&
                                                 ((state.quadWidthProp)->value == -1)) {
                                                if (state.digitCount == 0) {
                                                  iVar15 = ((int)(pFont->info).ink_maxbounds.
                                                                 characterWidth +
                                                           (int)(pFont->info).ink_minbounds.
                                                                characterWidth) / 2;
                                                }
                                                else {
                                                  iVar15 = state.digitWidths / state.digitCount;
                                                }
                                                (state.quadWidthProp)->value = (long)iVar15;
                                              }
                                              if ((state.weightProp != (FontPropPtr)0x0) &&
                                                 ((state.weightProp)->value == -1)) {
                                                iVar15 = bitmapComputeWeight(pFont);
                                                (state.weightProp)->value = (long)iVar15;
                                              }
                                              iVar15 = 0x55;
                                              pFont->unload_glyphs = (_func_void_FontPtr *)0x0;
                                              pFont->get_glyphs = bitmapGetGlyphs;
                                              pFont->get_metrics = bitmapGetMetrics;
                                              pFont->unload_font = bdfUnloadFont;
                                              goto LAB_0011a282;
                                            }
                                            bdfError("Couldn\'t allocate ppCI (%d,%d)\n",
                                                     (ulong)(uint)(iVar15 >> 7),8);
                                          }
                                        }
                                      }
                                      else {
                                        bVar55 = pp_Var32 == (CharInfoPtr *)0x0;
                                        if (!bVar55) {
                                          local_1d24 = 0;
                                          local_1d48 = 0;
                                          local_1d40 = "STARTCHAR";
                                          do {
                                            uVar16 = (uint)uVar38;
                                            bVar56 = false;
                                            lVar37 = 9;
                                            pp_Var34 = pp_Var32;
                                            pbVar24 = (byte *)local_1d40;
                                            do {
                                              if (lVar37 == 0) break;
                                              lVar37 = lVar37 + -1;
                                              bVar56 = *(byte *)pp_Var34 < *pbVar24;
                                              bVar55 = *(byte *)pp_Var34 == *pbVar24;
                                              pp_Var34 = (CharInfoPtr *)
                                                         ((long)pp_Var34 + (ulong)bVar58 * -2 + 1);
                                              pbVar24 = pbVar24 + (ulong)bVar58 * -2 + 1;
                                            } while (bVar55);
                                            if ((!bVar56 && !bVar55) != bVar56) {
                                              uVar17 = local_1cfc + local_1d48;
                                              bVar55 = uVar16 < uVar17;
                                              bVar56 = uVar16 == uVar17;
                                              if (!bVar56) goto LAB_0011b814;
                                              nchars = local_1d48;
                                              *(int *)((long)pvVar7 + 4) = local_1d48;
                                              goto LAB_0011b85d;
                                            }
                                            iVar15 = __isoc99_sscanf(pp_Var32,"STARTCHAR %s",
                                                                     secondbuf);
                                            if (iVar15 != 1) {
                                              bdfError("bad character name in BDF file\n");
                                              goto LAB_0011b040;
                                            }
                                            if (plVar8 != (long *)0x0) {
                                              lVar37 = *plVar8;
                                              AVar30 = bdfForceMakeAtom(secondbuf,(int *)0x0);
                                              *(Atom *)(lVar37 + (long)local_1d48 * 8) = AVar30;
                                            }
                                            puVar23 = bdfGetLine(file,(uchar *)namebuf,0x400);
                                            if ((puVar23 == (uchar *)0x0) ||
                                               (iVar15 = __isoc99_sscanf(puVar23,"ENCODING %d %d",
                                                                         &enc,(CharInfoPtr)&nProps),
                                               iVar15 < 1)) {
                                              bdfError("bad \'ENCODING\' in BDF file\n");
                                              goto LAB_0011b040;
                                            }
                                            uVar38 = (ulong)(uint)enc;
                                            if (enc < -1) {
LAB_0011b7e5:
                                              bdfError("bad ENCODING value");
                                              goto LAB_0011b040;
                                            }
                                            bVar55 = false;
                                            if (iVar15 == 2) {
                                              uVar17 = CONCAT22(nProps._2_2_,(short)nProps);
                                              if ((int)uVar17 < -1) goto LAB_0011b7e5;
                                              if (enc == -1) {
                                                uVar38 = (ulong)uVar17;
                                                enc = uVar17;
                                                goto LAB_0011aae9;
                                              }
LAB_0011aaf2:
                                              if ((int)uVar38 < 0x10000) {
                                                bVar12 = (byte)(uVar38 >> 8);
                                                uVar38 = uVar38 & 0xff;
                                                if ((ushort)bVar12 < (pFont->info).firstRow) {
                                                  (pFont->info).firstRow = (ushort)bVar12;
                                                }
                                                if ((pFont->info).lastRow < (ushort)bVar12) {
                                                  (pFont->info).lastRow = (ushort)bVar12;
                                                }
                                                if ((uint)uVar38 < (uint)(pFont->info).firstCol) {
                                                  (pFont->info).firstCol = (ushort)uVar38;
                                                }
                                                if ((uint)(pFont->info).lastCol < (uint)uVar38) {
                                                  (pFont->info).lastCol = (ushort)uVar38;
                                                }
                                                uVar17 = (uint)bVar12;
                                                pp_Var32 = bdfEncoding[uVar17];
                                                if (pp_Var32 == (CharInfoPtr *)0x0) {
                                                  pp_Var32 = (CharInfoPtr *)malloc(0x800);
                                                  bdfEncoding[uVar17] = pp_Var32;
                                                  if (pp_Var32 == (CharInfoPtr *)0x0) {
                                                    bdfError(
                                                  "Couldn\'t allocate row %d of encoding (%d*%d)\n",
                                                  uVar17,0x100,8);
                                                  goto LAB_0011b040;
                                                  }
                                                  pp_Var34 = pp_Var32;
                                                  do {
                                                    *pp_Var34 = (CharInfoPtr)0x0;
                                                    pp_Var34 = pp_Var34 + 1;
                                                  } while (pp_Var32 + 0x100 != pp_Var34);
                                                }
                                                local_1d24 = local_1d24 + 1;
                                                pp_Var32[uVar38] = local_1d78;
                                              }
                                              else {
                                                bdfError("char \'%s\' has encoding too large (%d)\n"
                                                         ,secondbuf);
                                              }
                                            }
                                            else {
LAB_0011aae9:
                                              if ((int)uVar38 != -1) goto LAB_0011aaf2;
                                              if (plVar8 == (long *)0x0) {
                                                local_1cfc = local_1cfc + 1;
                                                bVar55 = true;
                                              }
                                            }
                                            iVar15 = local_1cfc;
                                            puVar23 = bdfGetLine(file,(uchar *)namebuf,0x400);
                                            if (puVar23 == (uchar *)0x0) {
LAB_0011b6fd:
                                              bdfError("bad \'SWIDTH\'\n");
                                              goto LAB_0011b040;
                                            }
                                            iVar19 = __isoc99_sscanf(puVar23,"SWIDTH %d %d",&wx,&wy)
                                            ;
                                            if (iVar19 != 2) goto LAB_0011b6fd;
                                            if (wy != 0) {
                                              bdfError("SWIDTH y value must be zero\n");
                                              goto LAB_0011b040;
                                            }
                                            if (plVar8 != (long *)0x0) {
                                              *(int *)(plVar8[1] + (long)local_1d48 * 4) = wx;
                                            }
                                            puVar23 = bdfGetLine(file,(uchar *)namebuf,0x400);
                                            if ((puVar23 == (uchar *)0x0) ||
                                               (iVar19 = __isoc99_sscanf(puVar23,"DWIDTH %d %d",&wx,
                                                                         &wy), iVar19 != 2)) {
                                              bdfError("bad \'DWIDTH\'\n");
                                              goto LAB_0011b040;
                                            }
                                            if (wy != 0) {
                                              bdfError("DWIDTH y value must be zero\n");
                                              goto LAB_0011b040;
                                            }
                                            puVar23 = bdfGetLine(file,(uchar *)namebuf,0x400);
                                            if ((puVar23 == (uchar *)0x0) ||
                                               (iVar19 = __isoc99_sscanf(puVar23,"BBX %d %d %d %d",
                                                                         &bw,&bh,&bl,&bb),
                                               iVar19 != 4)) {
                                              bdfError("bad \'BBX\'\n");
                                              goto LAB_0011b040;
                                            }
                                            if ((bh < 0) || (bw < 0)) {
                                              bdfError(
                                                  "character \'%s\' has a negative sized bitmap, %dx%d\n"
                                                  ,secondbuf);
                                              goto LAB_0011b040;
                                            }
                                            pbVar24 = bdfGetLine(file,(uchar *)namebuf,0x400);
                                            bVar56 = false;
                                            bVar57 = pbVar24 == (byte *)0x0;
                                            if (bVar57) {
LAB_0011acd1:
                                              (local_1d78->metrics).attributes = 0;
                                            }
                                            else {
                                              lVar37 = 10;
                                              pbVar53 = pbVar24;
                                              pbVar52 = (byte *)"ATTRIBUTES";
                                              do {
                                                if (lVar37 == 0) break;
                                                lVar37 = lVar37 + -1;
                                                bVar56 = *pbVar53 < *pbVar52;
                                                bVar57 = *pbVar53 == *pbVar52;
                                                pbVar53 = pbVar53 + (ulong)bVar58 * -2 + 1;
                                                pbVar52 = pbVar52 + (ulong)bVar58 * -2 + 1;
                                              } while (bVar57);
                                              if ((!bVar56 && !bVar57) != bVar56) goto LAB_0011acd1;
                                              pbVar53 = pbVar24 + 0xb;
                                              bVar12 = pbVar24[0xb];
                                              if (bVar12 != 0x20) goto LAB_0011b49d;
                                              do {
                                                do {
                                                  bVar12 = pbVar53[1];
                                                  pbVar53 = pbVar53 + 1;
                                                } while (bVar12 == 0x20);
LAB_0011b49d:
                                              } while (bVar12 == 9);
                                              bVar12 = bdfHexByte(pbVar53);
                                              bVar13 = bdfHexByte(pbVar53 + 2);
                                              (local_1d78->metrics).attributes =
                                                   (ushort)bVar12 * 0x100 + (ushort)bVar13;
                                              pbVar24 = bdfGetLine(file,(uchar *)namebuf,0x400);
                                            }
                                            iVar19 = bh;
                                            bVar56 = false;
                                            bVar57 = pbVar24 == (byte *)0x0;
                                            if (bVar57) {
LAB_0011b783:
                                              bdfError("missing \'BITMAP\'\n");
                                              goto LAB_0011b040;
                                            }
                                            lVar37 = 6;
                                            pbVar53 = (byte *)"BITMAP";
                                            do {
                                              if (lVar37 == 0) break;
                                              lVar37 = lVar37 + -1;
                                              bVar56 = *pbVar24 < *pbVar53;
                                              bVar57 = *pbVar24 == *pbVar53;
                                              pbVar24 = pbVar24 + (ulong)bVar58 * -2 + 1;
                                              pbVar53 = pbVar53 + (ulong)bVar58 * -2 + 1;
                                            } while (bVar57);
                                            cVar44 = (!bVar56 && !bVar57) - bVar56;
                                            iVar51 = (int)cVar44;
                                            puVar43 = (uint *)secondbuf;
                                            if (cVar44 != '\0') goto LAB_0011b783;
                                            do {
                                              puVar42 = puVar43;
                                              uVar16 = *puVar42 + 0xfefefeff & ~*puVar42;
                                              uVar17 = uVar16 & 0x80808080;
                                              puVar43 = puVar42 + 1;
                                            } while (uVar17 == 0);
                                            bVar56 = (uVar16 & 0x8080) == 0;
                                            if (bVar56) {
                                              uVar17 = uVar17 >> 0x10;
                                            }
                                            if (bVar56) {
                                              puVar43 = (uint *)((long)puVar42 + 6);
                                            }
                                            if ((char *)((long)puVar43 +
                                                        ((-3 - (ulong)CARRY1((byte)uVar17,
                                                                             (byte)uVar17)) -
                                                        (long)secondbuf)) == (char *)0x1) {
                                              if ((byte)(secondbuf[0] - 0x30U) < 10) {
                                                state.digitCount = state.digitCount + 1;
                                                state.digitWidths = state.digitWidths + wx;
                                              }
                                              else if ((secondbuf[0] == 'x') &&
                                                      (state.exHeight = bb + bh, state.exHeight < 1)
                                                      ) {
                                                state.exHeight = bh;
                                              }
                                            }
                                            if (bVar55) {
                                              do {
                                                iVar51 = iVar51 + 1;
                                                pbVar24 = bdfGetLine(file,lineBuf,0x400);
                                                bVar55 = false;
                                                bVar56 = pbVar24 == (byte *)0x0;
                                                if (bVar56) goto LAB_0011afcb;
                                                lVar37 = 7;
                                                pbVar53 = (byte *)"ENDCHAR";
                                                do {
                                                  if (lVar37 == 0) break;
                                                  lVar37 = lVar37 + -1;
                                                  bVar55 = *pbVar24 < *pbVar53;
                                                  bVar56 = *pbVar24 == *pbVar53;
                                                  pbVar24 = pbVar24 + (ulong)bVar58 * -2 + 1;
                                                  pbVar53 = pbVar53 + (ulong)bVar58 * -2 + 1;
                                                } while (bVar56);
                                              } while (((!bVar55 && !bVar56) != bVar55) &&
                                                      (iVar51 <= iVar19));
                                              if ((iVar51 != 1) && ((!bVar55 && !bVar56) != bVar55))
                                              {
                                                bdfError("Error in bitmap, missing \'ENDCHAR\'\n");
                                              }
                                            }
                                            else {
                                              sVar45 = (short)bh + (short)bb;
                                              sVar14 = -(short)bb;
                                              sVar10 = (short)bl;
                                              (local_1d78->metrics).leftSideBearing = sVar10;
                                              (local_1d78->metrics).rightSideBearing =
                                                   (short)bw + sVar10;
                                              (local_1d78->metrics).ascent = sVar45;
                                              iVar19 = (int)(short)((short)bw + sVar10) -
                                                       (int)sVar10;
                                              (local_1d78->metrics).descent = sVar14;
                                              uVar17 = (int)sVar14 + (int)sVar45;
                                              (local_1d78->metrics).characterWidth = (INT16)wx;
                                              local_1d78->bits = (char *)0x0;
                                              if (glyph == 1) {
                                                local_1d34 = iVar19 + 7 >> 3;
LAB_0011b518:
                                                local_1d20 = uVar17 * local_1d34;
                                                if ((int)local_1d20 < 1) {
                                                  local_1d58 = (uchar *)0x0;
                                                  goto LAB_0011ae10;
                                                }
                                                local_1d58 = (uchar *)malloc((long)(int)local_1d20);
                                                if (local_1d58 != (uchar *)0x0) goto LAB_0011ae10;
                                                bdfError("Couldn\'t allocate picture (%d*%d)\n",
                                                         (ulong)local_1d34,(ulong)uVar17);
LAB_0011b338:
                                                local_1d78->bits = (char *)0x0;
                                              }
                                              else {
                                                if (glyph == 2) {
                                                  local_1d34 = iVar19 + 0xf >> 3 & 0xfffffffe;
                                                  goto LAB_0011b518;
                                                }
                                                if (glyph == 4) {
                                                  local_1d34 = iVar19 + 0x1f >> 3 & 0xfffffffc;
                                                  goto LAB_0011b518;
                                                }
                                                if (glyph == 8) {
                                                  local_1d34 = iVar19 + 0x3f >> 3 & 0xfffffff8;
                                                  goto LAB_0011b518;
                                                }
                                                local_1d20 = 0;
                                                local_1d34 = 0;
                                                local_1d58 = (uchar *)0x0;
LAB_0011ae10:
                                                local_1d78->bits = (char *)local_1d58;
                                                uVar16 = iVar19 + 7 >> 3;
                                                if (local_1d60 != (long *)0x0) {
                                                  lVar37 = 0;
                                                  do {
                                                    iVar51 = *(int *)((long)local_1d60 + lVar37 * 4)
                                                    ;
                                                    uVar22 = uVar16;
                                                    if (((lVar37 == 0) ||
                                                        (iVar40 = (int)lVar37,
                                                        uVar22 = iVar19 + 0xf >> 3 & 0xfffffffe,
                                                        iVar40 == 1)) ||
                                                       (uVar22 = iVar19 + 0x1f >> 3 & 0xfffffffc,
                                                       iVar40 == 2)) {
                                                      *(uint *)((long)local_1d60 + lVar37 * 4) =
                                                           uVar22 * uVar17 + iVar51;
                                                    }
                                                    else {
                                                      *(uint *)((long)local_1d60 + lVar37 * 4) =
                                                           (iVar19 + 0x3f >> 3 & 0xfffffff8U) *
                                                           uVar17 + iVar51;
                                                      if (iVar40 == 3) break;
                                                    }
                                                    lVar37 = lVar37 + 1;
                                                  } while( true );
                                                }
                                                if ((int)uVar17 < 1) {
                                                  if (uVar17 == 0) {
                                                    uVar22 = 0;
                                                    goto LAB_0011b2f2;
                                                  }
LAB_0011b318:
                                                  bdfError("missing \'ENDCHAR\'\n");
LAB_0011b326:
                                                  if (local_1d58 != (uchar *)0x0) {
                                                    free(local_1d58);
                                                  }
                                                  goto LAB_0011b338;
                                                }
                                                local_1d38 = 0;
                                                uVar20 = 0xff << (8 - ((byte)iVar19 & 7) & 0x1f);
                                                bVar12 = (byte)uVar20;
                                                uVar21 = (local_1d34 - uVar16) - 1;
                                                uVar22 = 0;
                                                do {
                                                  pbVar24 = bdfGetLine(file,lineBuf,0x400);
                                                  if (pbVar24 == (byte *)0x0) goto LAB_0011b318;
                                                  bVar55 = false;
                                                  bVar56 = iVar19 == 0;
                                                  if (bVar56) {
                                                    lVar37 = 7;
                                                    pbVar53 = pbVar24;
                                                    pbVar52 = (byte *)"ENDCHAR";
                                                    do {
                                                      if (lVar37 == 0) break;
                                                      lVar37 = lVar37 + -1;
                                                      bVar55 = *pbVar53 < *pbVar52;
                                                      bVar56 = *pbVar53 == *pbVar52;
                                                      pbVar53 = pbVar53 + (ulong)bVar58 * -2 + 1;
                                                      pbVar52 = pbVar52 + (ulong)bVar58 * -2 + 1;
                                                    } while (bVar56);
                                                    bVar55 = (!bVar55 && !bVar56) == bVar55;
                                                    if (bVar55) goto LAB_0011af5f;
                                                  }
                                                  else {
                                                    sVar33 = strlen((char *)pbVar24);
                                                    iVar40 = (int)sVar33;
                                                    iVar51 = iVar40;
                                                    if ((sVar33 & 1) != 0) {
                                                      iVar51 = iVar40 + 1;
                                                      bdfError(
                                                  "odd number of characters in hex encoding\n");
                                                  pbVar24[iVar40] = 0x30;
                                                  pbVar24[iVar51] = 0;
                                                  }
                                                  uVar50 = iVar51 >> 1;
                                                  uVar41 = uVar50;
                                                  if ((int)uVar16 <= (int)uVar50) {
                                                    uVar41 = uVar16;
                                                  }
                                                  if (0 < (int)uVar41) {
                                                    puVar23 = local_1d58 + (int)uVar22;
                                                    pbVar53 = pbVar24;
                                                    do {
                                                      pbVar52 = pbVar53 + 2;
                                                      uVar11 = bdfHexByte(pbVar53);
                                                      *puVar23 = uVar11;
                                                      puVar23 = puVar23 + 1;
                                                      pbVar53 = pbVar52;
                                                    } while (pbVar52 !=
                                                             pbVar24 + (ulong)(uVar41 - 1) * 2 + 2);
                                                    uVar22 = uVar22 + 1 + (uVar41 - 1);
                                                  }
                                                  if ((int)uVar50 < (int)uVar16) {
                                                    if (0 < (int)(uVar16 - uVar50)) {
                                                      uVar41 = (uVar16 - uVar50) - 1;
                                                      puVar23 = local_1d58 + (int)uVar22;
                                                      do {
                                                        *puVar23 = '\0';
                                                        puVar23 = puVar23 + 1;
                                                      } while (local_1d58 +
                                                               (long)(int)uVar22 + (ulong)uVar41 + 1
                                                               != puVar23);
                                                      uVar22 = uVar22 + 1 + uVar41;
                                                    }
                                                  }
                                                  else if (bVar12 != 0) {
                                                    bVar13 = local_1d58[(long)(int)uVar22 + -1];
                                                    if ((~(uVar20 & 0xff) & (uint)bVar13) != 0) {
                                                      local_1d58[(long)(int)uVar22 + -1] =
                                                           bVar13 & bVar12;
                                                    }
                                                  }
                                                  if (((int)uVar16 < (int)local_1d34) &&
                                                     (0 < (int)(local_1d34 - uVar16))) {
                                                    puVar23 = local_1d58 + (int)uVar22;
                                                    do {
                                                      *puVar23 = '\0';
                                                      puVar23 = puVar23 + 1;
                                                    } while (local_1d58 +
                                                             (long)(int)uVar22 + (ulong)uVar21 + 1
                                                             != puVar23);
                                                    uVar22 = uVar22 + 1 + uVar21;
                                                  }
                                                  }
                                                  local_1d38 = local_1d38 + 1;
                                                  bVar55 = uVar17 < local_1d38;
                                                  bVar56 = uVar17 == local_1d38;
                                                } while (!bVar56);
                                                lVar37 = 7;
                                                pbVar53 = pbVar24;
                                                pbVar52 = (byte *)"ENDCHAR";
                                                do {
                                                  if (lVar37 == 0) break;
                                                  lVar37 = lVar37 + -1;
                                                  bVar55 = *pbVar53 < *pbVar52;
                                                  bVar56 = *pbVar53 == *pbVar52;
                                                  pbVar53 = pbVar53 + (ulong)bVar58 * -2 + 1;
                                                  pbVar52 = pbVar52 + (ulong)bVar58 * -2 + 1;
                                                } while (bVar56);
                                                bVar55 = (!bVar55 && !bVar56) == bVar55;
                                                if (!bVar55) {
LAB_0011b2f2:
                                                  pbVar24 = bdfGetLine(file,lineBuf,0x400);
                                                  bVar55 = pbVar24 == (byte *)0x0;
                                                  if (bVar55) goto LAB_0011b318;
                                                }
LAB_0011af5f:
                                                bVar56 = false;
                                                lVar37 = 7;
                                                pbVar53 = (byte *)"ENDCHAR";
                                                do {
                                                  if (lVar37 == 0) break;
                                                  lVar37 = lVar37 + -1;
                                                  bVar56 = *pbVar24 < *pbVar53;
                                                  bVar55 = *pbVar24 == *pbVar53;
                                                  pbVar24 = pbVar24 + (ulong)bVar58 * -2 + 1;
                                                  pbVar53 = pbVar53 + (ulong)bVar58 * -2 + 1;
                                                } while (bVar55);
                                                if ((!bVar56 && !bVar55) != bVar56)
                                                goto LAB_0011b318;
                                                if (uVar22 != local_1d20) {
                                                  bdfError(
                                                  "bytes != rows * bytes_per_row (%d != %d * %d)\n",
                                                  (ulong)uVar22,(ulong)uVar17,(ulong)local_1d34);
                                                  goto LAB_0011b326;
                                                }
                                                if (local_1d58 != (uchar *)0x0) {
                                                  if (bit == 0) {
                                                    BitOrderInvert(local_1d58,uVar22);
                                                  }
                                                  if (bit != byte) {
                                                    if (scan == 2) {
                                                      TwoByteSwap(local_1d58,uVar22);
                                                    }
                                                    else if (scan == 4) {
                                                      FourByteSwap(local_1d58,uVar22);
                                                    }
                                                  }
                                                }
                                              }
                                              local_1d78 = local_1d78 + 1;
                                              local_1d48 = local_1d48 + 1;
                                            }
LAB_0011afcb:
                                            pp_Var32 = (CharInfoPtr *)
                                                       bdfGetLine(file,(uchar *)namebuf,0x400);
                                            uVar38 = (ulong)(uint)nchars;
                                            if (nchars <= local_1d48) {
                                              local_1cfc = local_1d48;
                                              uVar17 = iVar15 + local_1d48;
                                              goto LAB_0011baaf;
                                            }
                                            bVar55 = pp_Var32 == (CharInfoPtr *)0x0;
                                          } while (!bVar55);
                                          uVar17 = local_1cfc + local_1d48;
                                          uVar16 = nchars;
                                          if (nchars == uVar17) {
                                            nchars = local_1d48;
                                            *(int *)((long)pvVar7 + 4) = local_1d48;
                                            goto LAB_0011b026;
                                          }
LAB_0011b814:
                                          uVar38 = (ulong)(uVar16 - uVar17);
                                          pp_Var32 = bdfEncoding[0];
                                        }
                                        bdfError("%d too few characters\n",uVar38);
                                        bdfEncoding[0] = pp_Var32;
                                      }
                                    }
                                  }
                                  else {
                                    bdfError("Couldn\'t allocate pCI (%d*%d)\n",(ulong)(uint)nchars,
                                             0x18);
                                    bdfEncoding[0] = (CharInfoPtr *)0x0;
                                  }
LAB_0011b040:
                                  ppp_Var46 = bdfEncoding;
                                  while( true ) {
                                    ppp_Var46 = ppp_Var46 + 1;
                                    if (bdfEncoding[0] != (CharInfoPtr *)0x0) {
                                      free(bdfEncoding[0]);
                                    }
                                    if ((CharInfoPtr **)namebuf_1 == ppp_Var46) break;
                                    bdfEncoding[0] = *ppp_Var46;
                                  }
                                }
                                goto LAB_0011a26a;
                              }
                            }
                            bdfError("missing \'ENDPROPERTIES\'\n");
                          }
                        }
LAB_0011a640:
                        pcVar27 = (pFont->info).isStringProp;
                        if (pcVar27 != (char *)0x0) {
                          free(pcVar27);
                          (pFont->info).isStringProp = (char *)0x0;
                        }
                        p_Var28 = (pFont->info).props;
                        if (p_Var28 != (FontPropPtr)0x0) {
                          free(p_Var28);
                          (pFont->info).props = (FontPropPtr)0x0;
                        }
                        while (bVar55 = pbVar24 == (byte *)0x0, !bVar55) {
                          bVar56 = false;
                          lVar37 = 0xd;
                          pbVar53 = (byte *)"ENDPROPERTIES";
                          do {
                            if (lVar37 == 0) break;
                            lVar37 = lVar37 + -1;
                            bVar56 = *pbVar24 < *pbVar53;
                            bVar55 = *pbVar24 == *pbVar53;
                            pbVar24 = pbVar24 + (ulong)bVar58 * -2 + 1;
                            pbVar53 = pbVar53 + (ulong)bVar58 * -2 + 1;
                          } while (bVar55);
                          if ((!bVar56 && !bVar55) != bVar56) break;
                          pbVar24 = bdfGetLine(file,lineBuf,0x400);
                        }
                        goto LAB_0011a26a;
                      }
                    }
                    bdfError("missing \'STARTPROPERTIES\'\n");
                  }
                }
                goto LAB_0011a26a;
              }
            }
            bdfError("missing \'FONTBOUNDINGBOX\'\n");
          }
        }
        else {
          bdfError("bad \'SIZE\'\n");
        }
      }
    }
  }
LAB_0011a26a:
  iVar15 = 0x50;
  if (pFont->fontPrivate != (void *)0x0) {
    bdfFreeFontBits(pFont);
  }
LAB_0011a282:
  if (lVar6 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar15;
}



int bdfReadFontInfo(FontInfoPtr pFontInfo,FontFilePtr file)

{
  long lVar1;
  undefined8 uVar2;
  FontPropPtr p_Var3;
  int iVar4;
  long lVar5;
  FontPtr p_Var6;
  long in_FS_OFFSET;
  FontRec font;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  p_Var6 = &font;
  for (lVar5 = 0x17; lVar5 != 0; lVar5 = lVar5 + -1) {
    *(undefined8 *)p_Var6 = 0;
    p_Var6 = (FontPtr)&p_Var6->info;
  }
  iVar4 = bdfReadFont(&font,file,1,0,1,1);
  p_Var3 = font.info.props;
  if (iVar4 == 0x55) {
    uVar2 = CONCAT44(font.info.nprops,font.info._64_4_);
    font.info.props = (FontPropPtr)0x0;
    pFontInfo->isStringProp = font.info.isStringProp;
    pFontInfo->firstCol = font.info.firstCol;
    pFontInfo->lastCol = font.info.lastCol;
    pFontInfo->firstRow = font.info.firstRow;
    pFontInfo->lastRow = font.info.lastRow;
    pFontInfo->defaultCh = font.info.defaultCh;
    *(undefined2 *)&pFontInfo->field_0xa = font.info._10_2_;
    pFontInfo->maxOverlap = font.info.maxOverlap;
    pFontInfo->pad = font.info.pad;
    (pFontInfo->maxbounds).leftSideBearing = font.info.maxbounds.leftSideBearing;
    (pFontInfo->maxbounds).rightSideBearing = font.info.maxbounds.rightSideBearing;
    (pFontInfo->maxbounds).characterWidth = font.info.maxbounds.characterWidth;
    (pFontInfo->maxbounds).ascent = font.info.maxbounds.ascent;
    *(undefined8 *)&(pFontInfo->maxbounds).descent = font.info._24_8_;
    (pFontInfo->minbounds).characterWidth = font.info.minbounds.characterWidth;
    (pFontInfo->minbounds).ascent = font.info.minbounds.ascent;
    (pFontInfo->minbounds).descent = font.info.minbounds.descent;
    (pFontInfo->minbounds).attributes = font.info.minbounds.attributes;
    (pFontInfo->ink_maxbounds).leftSideBearing = font.info.ink_maxbounds.leftSideBearing;
    (pFontInfo->ink_maxbounds).rightSideBearing = font.info.ink_maxbounds.rightSideBearing;
    (pFontInfo->ink_maxbounds).characterWidth = font.info.ink_maxbounds.characterWidth;
    (pFontInfo->ink_maxbounds).ascent = font.info.ink_maxbounds.ascent;
    *(undefined8 *)&(pFontInfo->ink_maxbounds).descent = font.info._48_8_;
    (pFontInfo->ink_minbounds).characterWidth = font.info.ink_minbounds.characterWidth;
    (pFontInfo->ink_minbounds).ascent = font.info.ink_minbounds.ascent;
    (pFontInfo->ink_minbounds).descent = font.info.ink_minbounds.descent;
    (pFontInfo->ink_minbounds).attributes = font.info.ink_minbounds.attributes;
    pFontInfo->fontAscent = (short)uVar2;
    pFontInfo->fontDescent = (short)((ulong)uVar2 >> 0x10);
    pFontInfo->nprops = (int)((ulong)uVar2 >> 0x20);
    pFontInfo->props = p_Var3;
    font.info.isStringProp = (char *)0x0;
    font.info.nprops = 0;
    bdfFreeFontBits(&font);
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bdfError(char *message,...)

{
  long lVar1;
  char in_AL;
  undefined8 in_RCX;
  undefined8 in_RDX;
  undefined8 in_RSI;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  va_list args;
  undefined local_c8 [8];
  undefined8 local_c0;
  undefined8 local_b8;
  undefined8 local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  
  if (in_AL != '\0') {
    local_98 = in_XMM0_Qa;
    local_88 = in_XMM1_Qa;
    local_78 = in_XMM2_Qa;
    local_68 = in_XMM3_Qa;
    local_58 = in_XMM4_Qa;
    local_48 = in_XMM5_Qa;
    local_38 = in_XMM6_Qa;
    local_28 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  args[0].overflow_arg_area = &stack0x00000008;
  args[0].reg_save_area = local_c8;
  args[0].gp_offset = 8;
  args[0].fp_offset = 0x30;
  local_c0 = in_RSI;
  local_b8 = in_RDX;
  local_b0 = in_RCX;
  local_a8 = in_R8;
  local_a0 = in_R9;
  __fprintf_chk(_stderr,1,"BDF Error on line %d: ",bdfFileLineNum);
  __vfprintf_chk(_stderr,1,message,args);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bdfWarning(char *message,...)

{
  long lVar1;
  char in_AL;
  undefined8 in_RCX;
  undefined8 in_RDX;
  undefined8 in_RSI;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  va_list args;
  undefined local_c8 [8];
  undefined8 local_c0;
  undefined8 local_b8;
  undefined8 local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  
  if (in_AL != '\0') {
    local_98 = in_XMM0_Qa;
    local_88 = in_XMM1_Qa;
    local_78 = in_XMM2_Qa;
    local_68 = in_XMM3_Qa;
    local_58 = in_XMM4_Qa;
    local_48 = in_XMM5_Qa;
    local_38 = in_XMM6_Qa;
    local_28 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  args[0].overflow_arg_area = &stack0x00000008;
  args[0].reg_save_area = local_c8;
  args[0].gp_offset = 8;
  args[0].fp_offset = 0x30;
  local_c0 = in_RSI;
  local_b8 = in_RDX;
  local_b0 = in_RCX;
  local_a8 = in_R8;
  local_a0 = in_R9;
  __fprintf_chk(_stderr,1,"BDF Warning on line %d: ",bdfFileLineNum);
  __vfprintf_chk(_stderr,1,message,args);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



uchar * bdfGetLine(FontFilePtr file,uchar *buf,int len)

{
  int iVar1;
  uint uVar2;
  long lVar3;
  uchar *puVar4;
  byte *pbVar5;
  byte *pbVar6;
  bool bVar7;
  bool bVar8;
  byte bVar9;
  
  bVar9 = 0;
  puVar4 = buf;
LAB_0011c703:
  iVar1 = file->left;
  file->left = iVar1 + -1;
  if (iVar1 == 0) goto LAB_0011c746;
LAB_0011c710:
  pbVar5 = file->bufp;
  file->bufp = pbVar5 + 1;
  uVar2 = (uint)*pbVar5;
  do {
    if (uVar2 == 0xd) goto LAB_0011c703;
    if (uVar2 == 10) {
      bdfFileLineNum = bdfFileLineNum + 1;
      *puVar4 = '\0';
LAB_0011c77e:
      bVar7 = puVar4 < buf;
      bVar8 = puVar4 == buf;
      puVar4 = buf;
      if (bVar8) goto LAB_0011c703;
      lVar3 = 7;
      pbVar5 = buf;
      pbVar6 = (byte *)"COMMENT";
      break;
    }
    if ((long)(len + -1) <= (long)puVar4 - (long)buf) {
      *puVar4 = '\0';
      goto LAB_0011c77e;
    }
    *puVar4 = (uchar)uVar2;
    iVar1 = file->left;
    puVar4 = puVar4 + 1;
    file->left = iVar1 + -1;
    if (iVar1 != 0) goto LAB_0011c710;
LAB_0011c746:
    uVar2 = (*file->input)(file);
    file->eof = uVar2;
    if (uVar2 == 0xffffffff) {
      *puVar4 = '\0';
      return (uchar *)0x0;
    }
  } while( true );
  while( true ) {
    lVar3 = lVar3 + -1;
    bVar7 = *pbVar5 < *pbVar6;
    bVar8 = *pbVar5 == *pbVar6;
    pbVar5 = pbVar5 + (ulong)bVar9 * -2 + 1;
    pbVar6 = pbVar6 + (ulong)bVar9 * -2 + 1;
    if (!bVar8) break;
    if (lVar3 == 0) break;
  }
  if ((!bVar7 && !bVar8) != bVar7) {
    return buf;
  }
  goto LAB_0011c703;
}



Atom bdfForceMakeAtom(char *str,int *size)

{
  size_t sVar1;
  Atom AVar2;
  
  sVar1 = strlen(str);
  if (size != (int *)0x0) {
    *size = *size + (uint)sVar1 + 1;
  }
  AVar2 = MakeAtom(str,(uint)sVar1,1);
  if (AVar2 != 0) {
    return AVar2;
  }
  bdfError("Atom allocation failed\n");
  return 0;
}



Atom bdfGetPropertyValue(char *s)

{
  byte bVar1;
  byte bVar2;
  Atom AVar3;
  size_t sVar4;
  byte *str;
  byte *pbVar5;
  byte *pbVar6;
  ulong __size;
  
  bVar1 = *s;
  pbVar6 = (byte *)s;
  while (bVar1 != 0) {
    if ((bVar1 != 0x20) && (bVar1 != 9)) {
      if (bVar1 == 0x22) {
        pbVar5 = pbVar6 + 1;
        sVar4 = strlen((char *)pbVar5);
        __size = (ulong)((int)sVar4 + 1);
        str = (byte *)malloc(__size);
        if (str == (byte *)0x0) {
          bdfError("Couldn\'t allocate property value string (%d)\n",__size);
          return 0;
        }
        bVar1 = pbVar6[1];
        pbVar6 = str;
        do {
          if (bVar1 == 0) {
            free(str);
            bdfError("unterminated quoted string property: %s\n",s);
            return 0;
          }
          bVar2 = pbVar5[1];
          if (bVar1 == 0x22) {
            if (bVar2 != 0x22) {
              *pbVar6 = 0;
              AVar3 = bdfForceMakeAtom((char *)str,(int *)0x0);
              free(str);
              return AVar3;
            }
            bVar2 = pbVar5[2];
            pbVar5 = pbVar5 + 2;
            *pbVar6 = 0x22;
          }
          else {
            bVar1 = *pbVar5;
            pbVar5 = pbVar5 + 1;
            *pbVar6 = bVar1;
          }
          pbVar6 = pbVar6 + 1;
          bVar1 = bVar2;
        } while( true );
      }
      bVar1 = *pbVar6;
      pbVar5 = pbVar6;
      if (bVar1 != 0) goto LAB_0011c88c;
      break;
    }
    pbVar5 = pbVar6 + 1;
    pbVar6 = pbVar6 + 1;
    bVar1 = *pbVar5;
  }
  goto LAB_0011c899;
  while( true ) {
    bVar1 = pbVar5[1];
    pbVar5 = pbVar5 + 1;
    if (bVar1 == 0) break;
LAB_0011c88c:
    if ((bVar1 < 0x21) && ((0x100002600U >> ((ulong)bVar1 & 0x3f) & 1) != 0)) {
      *pbVar5 = 0;
      break;
    }
  }
LAB_0011c899:
  AVar3 = bdfForceMakeAtom((char *)pbVar6,(int *)0x0);
  return AVar3;
}



int bdfIsInteger(char *str)

{
  char cVar1;
  ushort **ppuVar2;
  char *pcVar3;
  
  pcVar3 = str + 1;
  cVar1 = *str;
  ppuVar2 = __ctype_b_loc();
  if (((*(byte *)((long)*ppuVar2 + (long)cVar1 * 2 + 1) & 8) == 0) && ((cVar1 - 0x2bU & 0xfd) != 0))
  {
    return 0;
  }
  do {
    cVar1 = *pcVar3;
    pcVar3 = pcVar3 + 1;
    if (cVar1 == '\0') {
      return 1;
    }
  } while ((*(byte *)((long)*ppuVar2 + (long)cVar1 * 2 + 1) & 8) != 0);
  return 0;
}



uchar bdfHexByte(uchar *s)

{
  uchar *puVar1;
  uchar uVar2;
  uchar uVar3;
  
  uVar3 = '\0';
  puVar1 = s + 2;
  do {
    uVar2 = *s;
    s = s + 1;
    if ((byte)(uVar2 - 0x30) < 10) {
      uVar3 = uVar3 * '\x10' + (uVar2 - 0x30);
    }
    else if ((byte)(uVar2 + 0xbf) < 6) {
      uVar3 = uVar2 + 0xc9 + uVar3 * '\x10';
    }
    else if ((byte)(uVar2 + 0x9f) < 6) {
      uVar3 = uVar2 + 0xa9 + uVar3 * '\x10';
    }
    else {
      bdfError("bad hex char \'%c\'");
    }
  } while (puVar1 != s);
  return uVar3;
}



Bool bdfSpecialProperty(FontPtr pFont,FontPropPtr prop,char isString,bdfFileState *bdfState)

{
  Bool BVar1;
  int iVar2;
  char *__s1;
  char *__s2;
  char **ppcVar3;
  
  __s1 = NameForAtom(prop->name);
  if (SpecialAtoms[0] == (char *)0x0) {
switchD_0011cb06_caseD_13ea60:
    BVar1 = 1;
    if (isString == '\0') {
      (pFont->info).fontAscent = (short)prop->value;
      bdfState->haveFontAscent = '\x01';
      BVar1 = FUN_0011cb13();
      return BVar1;
    }
  }
  else {
    ppcVar3 = SpecialAtoms;
    __s2 = SpecialAtoms[0];
    do {
      iVar2 = strcmp(__s1,__s2);
      if (iVar2 == 0) break;
      __s2 = ppcVar3[1];
      ppcVar3 = ppcVar3 + 1;
    } while (__s2 != (char *)0x0);
    switch(ppcVar3) {
    case (char **)0x13ea60:
      goto switchD_0011cb06_caseD_13ea60;
    case (char **)0x13ea68:
      BVar1 = 1;
      if (isString == '\0') {
        (pFont->info).fontDescent = (short)prop->value;
        bdfState->haveFontDescent = '\x01';
        BVar1 = FUN_0011cb13();
        return BVar1;
      }
      break;
    case (char **)0x13ea70:
      BVar1 = 1;
      if (isString == '\0') {
        (pFont->info).defaultCh = (ushort)prop->value;
        bdfState->haveDefaultCh = '\x01';
        BVar1 = FUN_0011cb13();
        return BVar1;
      }
      break;
    case (char **)0x13ea78:
      bdfState->pointSizeProp = prop;
      BVar1 = FUN_0011cb13();
      return BVar1;
    case (char **)0x13ea80:
      bdfState->resolutionProp = prop;
      BVar1 = FUN_0011cb13();
      return BVar1;
    case (char **)0x13ea88:
      bdfState->xHeightProp = prop;
      BVar1 = FUN_0011cb13();
      return BVar1;
    case (char **)0x13ea90:
      bdfState->weightProp = prop;
      BVar1 = FUN_0011cb13();
      return BVar1;
    case (char **)0x13ea98:
      bdfState->quadWidthProp = prop;
      BVar1 = FUN_0011cb13();
      return BVar1;
    case (char **)0x13eaa0:
      bdfState->fontProp = prop;
      BVar1 = FUN_0011cb13();
      return BVar1;
    case (char **)0x13eaa8:
      bdfState->resolutionXProp = prop;
      BVar1 = 0;
      break;
    case (char **)0x13eab0:
      bdfState->resolutionYProp = prop;
      BVar1 = FUN_0011cb13();
      return BVar1;
    default:
      BVar1 = FUN_0011cb13();
      return BVar1;
    }
  }
  return BVar1;
}



void FUN_0011cb13(void)

{
  return;
}



undefined8 switchD_0011cb06::caseD_13ea60(void)

{
  undefined8 uVar1;
  long unaff_RBP;
  long unaff_R12;
  char unaff_R13B;
  long param_7;
  
  if (unaff_R13B == '\0') {
    *(short *)(param_7 + 0x48) = (short)*(undefined8 *)(unaff_RBP + 8);
    *(undefined *)(unaff_R12 + 0x468) = 1;
    uVar1 = FUN_0011cb13();
    return uVar1;
  }
  return 1;
}



int bitmapGetGlyphs(FontPtr pFont,ulong count,uchar *chars,FontEncoding charEncoding,
                   ulong *glyphCount,CharInfoPtr *glyphs)

{
  byte *pbVar1;
  byte bVar2;
  ushort uVar3;
  long lVar4;
  CharInfoPtr p_Var5;
  long lVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  ulong uVar10;
  long lVar11;
  CharInfoPtr *pp_Var12;
  CharInfoPtr p_Var13;
  uint uVar14;
  
  uVar3 = (pFont->info).firstCol;
  lVar4 = *(long *)((long)pFont->fontPrivate + 0x28);
  p_Var5 = *(CharInfoPtr *)((long)pFont->fontPrivate + 0x30);
  uVar14 = ((pFont->info).lastCol + 1) - (uint)uVar3;
  uVar9 = (uint)uVar3;
  if (charEncoding == Linear16Bit) {
    if ((((pFont->info).field_0xa & 0x40) == 0) || (p_Var5 == (CharInfoPtr)0x0)) {
      uVar10 = 0;
      pp_Var12 = glyphs;
      if (count != 0) {
        do {
          uVar7 = (ushort)(*(ushort *)(chars + uVar10 * 2) << 8 |
                          *(ushort *)(chars + uVar10 * 2) >> 8) - uVar9;
          if (((uVar7 < uVar14) &&
              (lVar11 = *(long *)(lVar4 + (ulong)(uVar7 >> 7) * 8), lVar11 != 0)) &&
             (p_Var13 = *(CharInfoPtr *)(lVar11 + (ulong)(uVar7 & 0x7f) * 8),
             p_Var13 != (CharInfoPtr)0x0)) {
            *pp_Var12 = p_Var13;
            pp_Var12 = pp_Var12 + 1;
          }
          else if (p_Var5 != (CharInfoPtr)0x0) {
            *pp_Var12 = p_Var5;
            pp_Var12 = pp_Var12 + 1;
          }
          uVar10 = uVar10 + 1;
        } while (count != uVar10);
        *glyphCount = (long)pp_Var12 - (long)glyphs >> 3;
        return 0x55;
      }
    }
    else if (count != 0) {
      uVar10 = 0;
      do {
        uVar9 = (uint)(ushort)(*(ushort *)(chars + uVar10 * 2) << 8 |
                              *(ushort *)(chars + uVar10 * 2) >> 8) - (uint)uVar3;
        if (uVar9 < uVar14) {
          p_Var13 = *(CharInfoPtr *)(lVar4 + (ulong)(uVar9 >> 7) * 8);
          if (p_Var13 != (CharInfoPtr)0x0) {
            p_Var13 = *(CharInfoPtr *)
                       (&(p_Var13->metrics).leftSideBearing + (ulong)(uVar9 & 0x7f) * 4);
          }
          glyphs[uVar10] = p_Var13;
        }
        else {
          glyphs[uVar10] = p_Var5;
        }
        uVar10 = uVar10 + 1;
      } while (uVar10 != count);
LAB_0011cea0:
      *glyphCount = (long)(count << 3) >> 3;
      return 0x55;
    }
  }
  else if (charEncoding < TwoD16Bit) {
    if ((pFont->info).firstRow != 0) {
LAB_0011cd50:
      *glyphCount = 0;
      return 0x55;
    }
    if ((((pFont->info).field_0xa & 0x40) == 0) || (p_Var5 == (CharInfoPtr)0x0)) {
      pbVar1 = chars + count;
      pp_Var12 = glyphs;
      if (count != 0) {
        do {
          bVar2 = *chars;
          chars = chars + 1;
          uVar7 = bVar2 - uVar9;
          if (((uVar7 < uVar14) &&
              (lVar11 = *(long *)(lVar4 + (ulong)(uVar7 >> 7) * 8), lVar11 != 0)) &&
             (p_Var13 = *(CharInfoPtr *)(lVar11 + (ulong)(uVar7 & 0x7f) * 8),
             p_Var13 != (CharInfoPtr)0x0)) {
            *pp_Var12 = p_Var13;
            pp_Var12 = pp_Var12 + 1;
          }
          else if (p_Var5 != (CharInfoPtr)0x0) {
            *pp_Var12 = p_Var5;
            pp_Var12 = pp_Var12 + 1;
          }
        } while (pbVar1 != chars);
        count = (long)pp_Var12 - (long)glyphs >> 3;
      }
    }
    else if (count != 0) {
      uVar10 = 0;
      do {
        uVar7 = chars[uVar10] - uVar9;
        if (uVar7 < uVar14) {
          p_Var13 = *(CharInfoPtr *)(lVar4 + (ulong)(uVar7 >> 7) * 8);
          if (p_Var13 != (CharInfoPtr)0x0) {
            p_Var13 = *(CharInfoPtr *)
                       (&(p_Var13->metrics).leftSideBearing + (ulong)(uVar7 & 0x7f) * 4);
          }
          glyphs[uVar10] = p_Var13;
        }
        else {
          glyphs[uVar10] = p_Var5;
        }
        uVar10 = uVar10 + 1;
      } while (uVar10 != count);
      goto LAB_0011cea0;
    }
  }
  else {
    if (charEncoding != TwoD16Bit) goto LAB_0011cd50;
    uVar3 = (pFont->info).lastRow;
    lVar11 = count - 1;
    uVar7 = (uint)(pFont->info).firstRow;
    pp_Var12 = glyphs;
    if (count != 0) {
      do {
        while( true ) {
          bVar2 = *chars;
          pbVar1 = chars + 1;
          chars = chars + 2;
          uVar8 = bVar2 - uVar7;
          if (((uVar3 + 1) - uVar7 <= uVar8) || (uVar14 <= *pbVar1 - uVar9)) break;
          uVar8 = uVar8 * uVar14 + (*pbVar1 - uVar9);
          lVar6 = *(long *)(lVar4 + (ulong)(uVar8 >> 7) * 8);
          if ((lVar6 == 0) ||
             (p_Var13 = *(CharInfoPtr *)(lVar6 + (ulong)(uVar8 & 0x7f) * 8),
             p_Var13 == (CharInfoPtr)0x0)) break;
          *pp_Var12 = p_Var13;
          pp_Var12 = pp_Var12 + 1;
LAB_0011ccfc:
          lVar11 = lVar11 + -1;
          if (lVar11 == -1) goto LAB_0011cd37;
        }
        if (p_Var5 == (CharInfoPtr)0x0) goto LAB_0011ccfc;
        lVar11 = lVar11 + -1;
        *pp_Var12 = p_Var5;
        pp_Var12 = pp_Var12 + 1;
      } while (lVar11 != -1);
LAB_0011cd37:
      count = (long)pp_Var12 - (long)glyphs >> 3;
    }
  }
  *glyphCount = count;
  return 0x55;
}



int bitmapGetMetrics(FontPtr pFont,ulong count,uchar *chars,FontEncoding charEncoding,
                    ulong *glyphCount,xCharInfo **glyphs)

{
  void *pvVar1;
  undefined8 uVar2;
  long lVar3;
  long lVar4;
  int iVar5;
  ulong uVar6;
  
  pvVar1 = pFont->fontPrivate;
  uVar2 = *(undefined8 *)((long)pvVar1 + 0x30);
  *(CharInfoRec **)((long)pvVar1 + 0x30) = &nonExistantChar;
  iVar5 = bitmapGetGlyphs(pFont,count,chars,charEncoding,glyphCount,(CharInfoPtr *)glyphs);
  if (((iVar5 == 0x55) && (lVar3 = *(long *)((long)pvVar1 + 0x18), lVar3 != 0)) &&
     (lVar4 = *(long *)((long)pvVar1 + 0x10), *glyphCount != 0)) {
    uVar6 = 0;
    do {
      if ((CharInfoRec *)glyphs[uVar6] != &nonExistantChar) {
        glyphs[uVar6] = (xCharInfo *)(lVar3 + ((long)glyphs[uVar6] - lVar4 >> 3) * 4);
      }
      uVar6 = uVar6 + 1;
    } while (uVar6 < *glyphCount);
    *(undefined8 *)((long)pvVar1 + 0x30) = uVar2;
    return 0x55;
  }
  *(undefined8 *)((long)pvVar1 + 0x30) = uVar2;
  return iVar5;
}



int BitmapGetInfoBitmap(FontPathElementPtr fpe,FontInfoPtr pFontInfo,FontEntryPtr entry,
                       char *fileName)

{
  int iVar1;
  FontRendererPtr p_Var2;
  FontFilePtr f;
  
  p_Var2 = FontFileMatchRenderer(fileName);
  if (p_Var2 != (FontRendererPtr)0x0) {
    f = FontFileOpen(fileName);
    if (f != (FontFilePtr)0x0) {
      iVar1 = (*readers[(int)((long)&p_Var2[-0x5b0d].OpenScalable >> 3) * -0x49249249].ReadInfo)
                        (pFontInfo,f);
      FontFileClose(f);
      return iVar1;
    }
  }
  return 0x53;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int BitmapOpenBitmap(FontPathElementPtr fpe,FontPtr *ppFont,int flags,FontEntryPtr entry,
                    char *fileName,fsBitmapFormat format,fsBitmapFormatMask fmask,
                    FontPtr non_cachable_font)

{
  FontRendererPtr p_Var1;
  int iVar2;
  FontFilePtr f;
  FontPtr __ptr;
  long in_FS_OFFSET;
  int bit;
  int byte;
  int glyph;
  int scan;
  int image;
  long local_40;
  
  p_Var1 = (entry->u).scalable.renderer;
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  f = FontFileOpen(fileName);
  if (f == (FontFilePtr)0x0) {
    iVar2 = 0x53;
  }
  else {
    __ptr = CreateFontRec();
    if (__ptr == (FontPtr)0x0) {
      iVar2 = 0x50;
      __fprintf_chk(_stderr,1,"Error: Couldn\'t allocate pFont (%ld)\n",0xb8);
      FontFileClose(f);
    }
    else {
      FontDefaultFormat(&bit,&byte,&glyph,&scan);
      CheckFSFormat(format,fmask,&bit,&byte,&scan,&glyph,&image);
      __ptr->refcnt = 0;
      iVar2 = (*readers[(int)((long)&p_Var1[-0x5b0d].OpenScalable >> 3) * -0x49249249].ReadFont)
                        (__ptr,f,bit,byte,glyph,scan);
      FontFileClose(f);
      if (iVar2 == 0x55) {
        *ppFont = __ptr;
      }
      else {
        free(__ptr);
      }
    }
  }
  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BitmapRegisterFontFileFunctions(void)

{
  FontRendererRec *renderer;
  FontRendererPtr p_Var1;
  
  renderer = renderers;
  do {
    p_Var1 = renderer + 1;
    FontFileRegisterRenderer(renderer);
    renderer = p_Var1;
  } while (p_Var1 != (FontRendererPtr)&maskmsb_11883);
  return;
}



// WARNING: Unknown calling convention

void bitmapComputeFontBounds(FontPtr pFont)

{
  CARD16 *pCVar1;
  ulong *puVar2;
  uint uVar3;
  ushort uVar4;
  ushort uVar5;
  ushort uVar6;
  void *pvVar7;
  long lVar8;
  bool bVar9;
  ulong *puVar10;
  uint uVar11;
  xCharInfo *pxVar12;
  int iVar13;
  xCharInfo *pxVar14;
  short sVar15;
  int iVar16;
  uint uVar17;
  int iVar18;
  int iVar19;
  int iVar20;
  
  pvVar7 = pFont->fontPrivate;
  lVar8 = *(long *)((long)pvVar7 + 0x38);
  if (lVar8 == 0) {
    pxVar14 = &(pFont->info).minbounds;
    pxVar12 = &(pFont->info).maxbounds;
  }
  else {
    pxVar14 = (xCharInfo *)(lVar8 + 0x3c);
    pxVar12 = (xCharInfo *)(lVar8 + 0x30);
  }
  pxVar14->leftSideBearing = 0x7fff;
  pxVar14->rightSideBearing = 0x7fff;
  pxVar14->characterWidth = 0x7fff;
  pxVar14->ascent = 0x7fff;
  pxVar14->descent = 0x7fff;
  pxVar14->attributes = 0xffff;
  pxVar12->leftSideBearing = -0x8000;
  pxVar12->rightSideBearing = -0x8000;
  pxVar12->characterWidth = -0x8000;
  pxVar12->ascent = -0x8000;
  pxVar12->descent = -0x8000;
  pxVar12->attributes = 0;
  puVar10 = *(ulong **)((long)pvVar7 + 0x10);
  if (*(int *)((long)pvVar7 + 4) < 1) {
    iVar13 = -0x8000;
    bVar9 = false;
    iVar18 = 0;
    iVar19 = 0;
  }
  else {
    iVar18 = 0;
    iVar19 = 0;
    puVar2 = puVar10 + (ulong)(*(int *)((long)pvVar7 + 4) - 1) * 3 + 3;
    iVar13 = -0x8000;
    do {
      sVar15 = *(short *)((long)puVar10 + 6);
      if (((sVar15 == 0) && (*(short *)(puVar10 + 1) == 0)) && ((*puVar10 & 0xffffffffffff) == 0)) {
LAB_0011d264:
        sVar15 = *(short *)((long)puVar10 + 4);
      }
      else {
        if (sVar15 < pxVar14->ascent) {
          pxVar14->ascent = sVar15;
          sVar15 = *(short *)((long)puVar10 + 6);
        }
        if (pxVar12->ascent < sVar15) {
          pxVar12->ascent = sVar15;
        }
        sVar15 = *(short *)(puVar10 + 1);
        if (sVar15 < pxVar14->descent) {
          pxVar14->descent = sVar15;
          sVar15 = *(short *)(puVar10 + 1);
        }
        if (pxVar12->descent < sVar15) {
          pxVar12->descent = sVar15;
        }
        sVar15 = *(short *)puVar10;
        if (sVar15 < pxVar14->leftSideBearing) {
          pxVar14->leftSideBearing = sVar15;
          sVar15 = *(short *)puVar10;
        }
        if (pxVar12->leftSideBearing < sVar15) {
          pxVar12->leftSideBearing = sVar15;
        }
        sVar15 = *(short *)((long)puVar10 + 2);
        if (sVar15 < pxVar14->rightSideBearing) {
          pxVar14->rightSideBearing = sVar15;
          sVar15 = *(short *)((long)puVar10 + 2);
        }
        if (pxVar12->rightSideBearing < sVar15) {
          pxVar12->rightSideBearing = sVar15;
        }
        sVar15 = *(short *)((long)puVar10 + 4);
        if (sVar15 < pxVar14->characterWidth) {
          pxVar14->characterWidth = sVar15;
          sVar15 = *(short *)((long)puVar10 + 4);
        }
        if (pxVar12->characterWidth < sVar15) {
          pxVar12->characterWidth = sVar15;
          goto LAB_0011d264;
        }
      }
      if (sVar15 < 0) {
        iVar19 = iVar19 + 1;
      }
      else {
        iVar18 = iVar18 + 1;
      }
      pxVar14->attributes = pxVar14->attributes & *(ushort *)((long)puVar10 + 10);
      pxVar12->attributes = pxVar12->attributes | *(ushort *)((long)puVar10 + 10);
      iVar16 = (int)*(short *)((long)puVar10 + 2) - (int)*(short *)((long)puVar10 + 4);
      if (iVar13 < iVar16) {
        iVar13 = iVar16;
      }
      puVar10 = puVar10 + 3;
    } while (puVar2 != puVar10);
    bVar9 = iVar18 < iVar19;
  }
  lVar8 = *(long *)((long)pvVar7 + 0x38);
  uVar17 = (uint)bVar9;
  if (lVar8 != 0) {
    *(ushort *)(lVar8 + 0x2a) = *(ushort *)(lVar8 + 0x2a) & 0xfe7f | (ushort)bVar9 << 7;
    *(short *)(*(long *)((long)pvVar7 + 0x38) + 0x2c) = (short)iVar13;
    uVar4 = (pFont->info).firstRow;
    uVar17 = (uint)uVar4;
    uVar5 = (pFont->info).lastRow;
    (pFont->info).minbounds.leftSideBearing = 0x7fff;
    (pFont->info).minbounds.rightSideBearing = 0x7fff;
    (pFont->info).minbounds.characterWidth = 0x7fff;
    (pFont->info).minbounds.ascent = 0x7fff;
    (pFont->info).minbounds.descent = 0x7fff;
    (pFont->info).minbounds.attributes = 0xffff;
    (pFont->info).maxbounds.leftSideBearing = -0x8000;
    (pFont->info).maxbounds.rightSideBearing = -0x8000;
    (pFont->info).maxbounds.characterWidth = -0x8000;
    (pFont->info).maxbounds.ascent = -0x8000;
    (pFont->info).maxbounds.descent = -0x8000;
    (pFont->info).maxbounds.attributes = 0;
    if (uVar5 < uVar4) {
      iVar13 = -0x8000;
      uVar17 = (uint)bVar9;
    }
    else {
      uVar4 = (pFont->info).lastCol;
      uVar6 = (pFont->info).firstCol;
      uVar11 = 0;
      iVar16 = -0x8000;
      iVar13 = -0x8000;
      do {
        if (uVar6 <= uVar4) {
          uVar3 = ((uVar4 + 1) - (uint)uVar6) + uVar11;
          do {
            lVar8 = *(long *)(*(long *)((long)pvVar7 + 0x28) + (long)((int)uVar11 >> 7) * 8);
            if ((lVar8 != 0) &&
               (puVar10 = *(ulong **)(lVar8 + (ulong)(uVar11 & 0x7f) * 8), puVar10 != (ulong *)0x0))
            {
              sVar15 = *(short *)((long)puVar10 + 6);
              if ((sVar15 == 0) &&
                 ((*(short *)(puVar10 + 1) == 0 && ((*puVar10 & 0xffffffffffff) == 0)))) {
LAB_0011d41c:
                sVar15 = *(short *)((long)puVar10 + 4);
              }
              else {
                if (sVar15 < (pFont->info).minbounds.ascent) {
                  (pFont->info).minbounds.ascent = sVar15;
                  sVar15 = *(short *)((long)puVar10 + 6);
                }
                if ((pFont->info).maxbounds.ascent < sVar15) {
                  (pFont->info).maxbounds.ascent = sVar15;
                }
                sVar15 = *(short *)(puVar10 + 1);
                if (sVar15 < (pFont->info).minbounds.descent) {
                  (pFont->info).minbounds.descent = sVar15;
                  sVar15 = *(short *)(puVar10 + 1);
                }
                if ((pFont->info).maxbounds.descent < sVar15) {
                  (pFont->info).maxbounds.descent = sVar15;
                }
                sVar15 = *(short *)puVar10;
                if (sVar15 < (pFont->info).minbounds.leftSideBearing) {
                  (pFont->info).minbounds.leftSideBearing = sVar15;
                  sVar15 = *(short *)puVar10;
                }
                if ((pFont->info).maxbounds.leftSideBearing < sVar15) {
                  (pFont->info).maxbounds.leftSideBearing = sVar15;
                }
                sVar15 = *(short *)((long)puVar10 + 2);
                if (sVar15 < (pFont->info).minbounds.rightSideBearing) {
                  (pFont->info).minbounds.rightSideBearing = sVar15;
                  sVar15 = *(short *)((long)puVar10 + 2);
                }
                if ((pFont->info).maxbounds.rightSideBearing < sVar15) {
                  (pFont->info).maxbounds.rightSideBearing = sVar15;
                }
                sVar15 = *(short *)((long)puVar10 + 4);
                if (sVar15 < (pFont->info).minbounds.characterWidth) {
                  (pFont->info).minbounds.characterWidth = sVar15;
                  sVar15 = *(short *)((long)puVar10 + 4);
                }
                if ((pFont->info).maxbounds.characterWidth < sVar15) {
                  (pFont->info).maxbounds.characterWidth = sVar15;
                  goto LAB_0011d41c;
                }
              }
              if (sVar15 < 0) {
                iVar19 = iVar19 + 1;
              }
              else {
                iVar18 = iVar18 + 1;
              }
              pCVar1 = &(pFont->info).minbounds.attributes;
              *pCVar1 = *pCVar1 & *(ushort *)((long)puVar10 + 10);
              pCVar1 = &(pFont->info).maxbounds.attributes;
              *pCVar1 = *pCVar1 | *(ushort *)((long)puVar10 + 10);
              iVar20 = (int)*(short *)((long)puVar10 + 2) - (int)*(short *)((long)puVar10 + 4);
              bVar9 = iVar13 < iVar20;
              iVar13 = iVar16;
              if (bVar9) {
                iVar13 = iVar20;
                iVar16 = iVar20;
              }
            }
            uVar11 = uVar11 + 1;
          } while (uVar3 != uVar11);
        }
        uVar17 = uVar17 + 1;
      } while (uVar5 + 1 != uVar17);
      uVar17 = (uint)(iVar18 < iVar19);
    }
  }
  (pFont->info).maxOverlap = (short)iVar13;
  *(ushort *)&(pFont->info).field_0xa =
       (ushort)(uVar17 << 7) | *(ushort *)&(pFont->info).field_0xa & 0xfe7f;
  return;
}



// WARNING: Unknown calling convention

void bitmapComputeFontInkBounds(FontPtr pFont)

{
  CARD16 *pCVar1;
  uint uVar2;
  ushort uVar3;
  ushort uVar4;
  ushort uVar5;
  int iVar6;
  void *pvVar7;
  long lVar8;
  short *psVar9;
  INT16 IVar10;
  INT16 IVar11;
  INT16 IVar12;
  CARD16 CVar13;
  short *psVar14;
  short *psVar15;
  uint uVar16;
  xCharInfo *pxVar17;
  xCharInfo *pxVar18;
  short sVar19;
  uint uVar20;
  
  pvVar7 = pFont->fontPrivate;
  lVar8 = *(long *)((long)pvVar7 + 0x38);
  if (*(long *)((long)pvVar7 + 0x18) != 0) {
    if (lVar8 == 0) {
      pxVar18 = &(pFont->info).ink_minbounds;
      pxVar17 = &(pFont->info).ink_maxbounds;
    }
    else {
      pxVar18 = (xCharInfo *)(lVar8 + 0x54);
      pxVar17 = (xCharInfo *)(lVar8 + 0x48);
    }
    pxVar18->leftSideBearing = 0x7fff;
    pxVar18->rightSideBearing = 0x7fff;
    pxVar18->characterWidth = 0x7fff;
    pxVar18->ascent = 0x7fff;
    pxVar18->descent = 0x7fff;
    pxVar18->attributes = 0xffff;
    pxVar17->leftSideBearing = -0x8000;
    pxVar17->rightSideBearing = -0x8000;
    pxVar17->characterWidth = -0x8000;
    pxVar17->ascent = -0x8000;
    pxVar17->descent = -0x8000;
    pxVar17->attributes = 0;
    iVar6 = *(int *)((long)pvVar7 + 4);
    psVar9 = *(short **)((long)pvVar7 + 0x18);
    if (0 < iVar6) {
      psVar14 = psVar9;
      do {
        sVar19 = psVar14[3];
        if ((((sVar19 != 0) || (psVar14[4] != 0)) || (*psVar14 != 0)) ||
           ((psVar14[1] != 0 || (psVar14[2] != 0)))) {
          if (sVar19 < pxVar18->ascent) {
            pxVar18->ascent = sVar19;
            sVar19 = psVar14[3];
          }
          if (pxVar17->ascent < sVar19) {
            pxVar17->ascent = sVar19;
          }
          sVar19 = psVar14[4];
          if (sVar19 < pxVar18->descent) {
            pxVar18->descent = sVar19;
            sVar19 = psVar14[4];
          }
          if (pxVar17->descent < sVar19) {
            pxVar17->descent = sVar19;
          }
          sVar19 = *psVar14;
          if (sVar19 < pxVar18->leftSideBearing) {
            pxVar18->leftSideBearing = sVar19;
            sVar19 = *psVar14;
          }
          if (pxVar17->leftSideBearing < sVar19) {
            pxVar17->leftSideBearing = sVar19;
          }
          sVar19 = psVar14[1];
          if (sVar19 < pxVar18->rightSideBearing) {
            pxVar18->rightSideBearing = sVar19;
            sVar19 = psVar14[1];
          }
          if (pxVar17->rightSideBearing < sVar19) {
            pxVar17->rightSideBearing = sVar19;
          }
          sVar19 = psVar14[2];
          if (sVar19 < pxVar18->characterWidth) {
            pxVar18->characterWidth = sVar19;
            sVar19 = psVar14[2];
          }
          if (pxVar17->characterWidth < sVar19) {
            pxVar17->characterWidth = sVar19;
          }
        }
        psVar15 = psVar14 + 6;
        pxVar18->attributes = pxVar18->attributes & psVar14[5];
        pxVar17->attributes = pxVar17->attributes | psVar14[5];
        psVar14 = psVar15;
      } while (psVar9 + ((ulong)(iVar6 - 1) * 3 + 3) * 2 != psVar15);
    }
    if (*(long *)((long)pvVar7 + 0x38) != 0) {
      (pFont->info).ink_maxbounds.descent = -0x8000;
      (pFont->info).ink_maxbounds.attributes = 0;
      uVar3 = (pFont->info).firstRow;
      uVar20 = (uint)uVar3;
      uVar4 = (pFont->info).lastRow;
      (pFont->info).ink_minbounds.leftSideBearing = 0x7fff;
      (pFont->info).ink_minbounds.rightSideBearing = 0x7fff;
      (pFont->info).ink_minbounds.characterWidth = 0x7fff;
      (pFont->info).ink_minbounds.ascent = 0x7fff;
      (pFont->info).ink_minbounds.descent = 0x7fff;
      (pFont->info).ink_minbounds.attributes = 0xffff;
      (pFont->info).ink_maxbounds.leftSideBearing = -0x8000;
      (pFont->info).ink_maxbounds.rightSideBearing = -0x8000;
      (pFont->info).ink_maxbounds.characterWidth = -0x8000;
      (pFont->info).ink_maxbounds.ascent = -0x8000;
      if (uVar3 <= uVar4) {
        uVar3 = (pFont->info).lastCol;
        uVar5 = (pFont->info).firstCol;
        uVar16 = 0;
        do {
          if (uVar5 <= uVar3) {
            uVar2 = ((uVar3 + 1) - (uint)uVar5) + uVar16;
            do {
              lVar8 = *(long *)(*(long *)((long)pvVar7 + 0x28) + (long)((int)uVar16 >> 7) * 8);
              if ((lVar8 != 0) &&
                 (lVar8 = *(long *)(lVar8 + (ulong)(uVar16 & 0x7f) * 8), lVar8 != 0)) {
                psVar9 = (short *)(*(long *)((long)pvVar7 + 0x18) +
                                  (long)((int)(lVar8 - *(long *)((long)pvVar7 + 0x10) >> 3) *
                                        -0x55555555) * 0xc);
                sVar19 = psVar9[3];
                if (((sVar19 != 0) || (((psVar9[4] != 0 || (*psVar9 != 0)) || (psVar9[1] != 0)))) ||
                   (psVar9[2] != 0)) {
                  if (sVar19 < (pFont->info).ink_minbounds.ascent) {
                    (pFont->info).ink_minbounds.ascent = sVar19;
                    sVar19 = psVar9[3];
                  }
                  if ((pFont->info).ink_maxbounds.ascent < sVar19) {
                    (pFont->info).ink_maxbounds.ascent = sVar19;
                  }
                  sVar19 = psVar9[4];
                  if (sVar19 < (pFont->info).ink_minbounds.descent) {
                    (pFont->info).ink_minbounds.descent = sVar19;
                    sVar19 = psVar9[4];
                  }
                  if ((pFont->info).ink_maxbounds.descent < sVar19) {
                    (pFont->info).ink_maxbounds.descent = sVar19;
                  }
                  sVar19 = *psVar9;
                  if (sVar19 < (pFont->info).ink_minbounds.leftSideBearing) {
                    (pFont->info).ink_minbounds.leftSideBearing = sVar19;
                    sVar19 = *psVar9;
                  }
                  if ((pFont->info).ink_maxbounds.leftSideBearing < sVar19) {
                    (pFont->info).ink_maxbounds.leftSideBearing = sVar19;
                  }
                  sVar19 = psVar9[1];
                  if (sVar19 < (pFont->info).ink_minbounds.rightSideBearing) {
                    (pFont->info).ink_minbounds.rightSideBearing = sVar19;
                    sVar19 = psVar9[1];
                  }
                  if ((pFont->info).ink_maxbounds.rightSideBearing < sVar19) {
                    (pFont->info).ink_maxbounds.rightSideBearing = sVar19;
                  }
                  sVar19 = psVar9[2];
                  if (sVar19 < (pFont->info).ink_minbounds.characterWidth) {
                    (pFont->info).ink_minbounds.characterWidth = sVar19;
                    sVar19 = psVar9[2];
                  }
                  if ((pFont->info).ink_maxbounds.characterWidth < sVar19) {
                    (pFont->info).ink_maxbounds.characterWidth = sVar19;
                  }
                }
                pCVar1 = &(pFont->info).ink_minbounds.attributes;
                *pCVar1 = *pCVar1 & psVar9[5];
                pCVar1 = &(pFont->info).ink_maxbounds.attributes;
                *pCVar1 = *pCVar1 | psVar9[5];
              }
              uVar16 = uVar16 + 1;
            } while (uVar2 != uVar16);
          }
          uVar20 = uVar20 + 1;
        } while (uVar4 + 1 != uVar20);
      }
    }
    return;
  }
  if (lVar8 != 0) {
    *(undefined8 *)(lVar8 + 0x54) = *(undefined8 *)(lVar8 + 0x3c);
    *(undefined4 *)(lVar8 + 0x5c) = *(undefined4 *)(lVar8 + 0x44);
    lVar8 = *(long *)((long)pvVar7 + 0x38);
    *(undefined8 *)(lVar8 + 0x48) = *(undefined8 *)(lVar8 + 0x30);
    *(undefined4 *)(lVar8 + 0x50) = *(undefined4 *)(lVar8 + 0x38);
  }
  IVar10 = (pFont->info).minbounds.rightSideBearing;
  IVar11 = (pFont->info).minbounds.characterWidth;
  IVar12 = (pFont->info).minbounds.ascent;
  (pFont->info).ink_minbounds.leftSideBearing = (pFont->info).minbounds.leftSideBearing;
  (pFont->info).ink_minbounds.rightSideBearing = IVar10;
  (pFont->info).ink_minbounds.characterWidth = IVar11;
  (pFont->info).ink_minbounds.ascent = IVar12;
  CVar13 = (pFont->info).minbounds.attributes;
  (pFont->info).ink_minbounds.descent = (pFont->info).minbounds.descent;
  (pFont->info).ink_minbounds.attributes = CVar13;
  IVar10 = (pFont->info).maxbounds.rightSideBearing;
  IVar11 = (pFont->info).maxbounds.characterWidth;
  IVar12 = (pFont->info).maxbounds.ascent;
  (pFont->info).ink_maxbounds.leftSideBearing = (pFont->info).maxbounds.leftSideBearing;
  (pFont->info).ink_maxbounds.rightSideBearing = IVar10;
  (pFont->info).ink_maxbounds.characterWidth = IVar11;
  (pFont->info).ink_maxbounds.ascent = IVar12;
  CVar13 = (pFont->info).maxbounds.attributes;
  (pFont->info).ink_maxbounds.descent = (pFont->info).maxbounds.descent;
  (pFont->info).ink_maxbounds.attributes = CVar13;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Bool bitmapAddInkMetrics(FontPtr pFont)

{
  long lVar1;
  xCharInfo *pInk;
  undefined *puVar2;
  int iVar3;
  void *pvVar4;
  Bool BVar5;
  void *pvVar6;
  long lVar7;
  int iVar8;
  
  pvVar4 = pFont->fontPrivate;
  iVar3 = *(int *)((long)pvVar4 + 4);
  pvVar6 = malloc((long)iVar3 * 0xc);
  *(void **)((long)pvVar4 + 0x18) = pvVar6;
  if (pvVar6 == (void *)0x0) {
    __fprintf_chk(_stderr,1,"Error: Couldn\'t allocate ink_metrics (%d*%ld)\n",iVar3,0xc);
    BVar5 = 0;
  }
  else {
    lVar7 = 0;
    iVar8 = 0;
    if (0 < iVar3) {
      while( true ) {
        pInk = (xCharInfo *)((long)pvVar6 + lVar7);
        iVar8 = iVar8 + 1;
        lVar1 = lVar7 * 2;
        lVar7 = lVar7 + 0xc;
        FontCharInkMetrics(pFont,(CharInfoPtr)(*(long *)((long)pvVar4 + 0x10) + lVar1),pInk);
        if (*(int *)((long)pvVar4 + 4) <= iVar8) break;
        pvVar6 = *(void **)((long)pvVar4 + 0x18);
      }
    }
    puVar2 = &(pFont->info).field_0xa;
    *puVar2 = *puVar2 | 0x20;
    BVar5 = 1;
  }
  return BVar5;
}



// WARNING: Unknown calling convention

int bitmapComputeWeight(FontPtr pFont)

{
  return 10;
}



Bool ComputeScaleFactors(FontScalablePtr from,FontScalablePtr to,double *dx,double *dy,double *sdx,
                        double *sdy,double *rescale_x)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  
  dVar1 = hypot(from->pixel_matrix[0],from->pixel_matrix[1]);
  dVar2 = hypot(to->pixel_matrix[0],to->pixel_matrix[1]);
  dVar3 = hypot(from->pixel_matrix[2],from->pixel_matrix[3]);
  dVar4 = hypot(to->pixel_matrix[2],to->pixel_matrix[3]);
  if (dVar1 < 1e-20) {
    *dx = 0.0;
    *sdx = 0.0;
  }
  else {
    *dx = dVar2 / dVar1;
    *sdx = 1000.0 / dVar1;
  }
  *rescale_x = 1.0;
  if (((0 < from->width) && (0 < to->width)) && (dVar1 = *dx, 1e-20 < ABS(dVar1))) {
    dVar2 = (double)from->width;
    dVar5 = (double)to->width / dVar2;
    if (((to->values_supplied & 3U) == 2) || ((to->values_supplied & 0xcU) == 8)) {
      if (10.0 <= ABS(dVar5 * dVar2 - dVar2 * dVar1)) {
        return 0;
      }
    }
    else {
      *rescale_x = dVar5 / dVar1;
      *dx = dVar5;
    }
  }
  if (dVar3 < 1e-20) {
    *dy = 0.0;
    *sdy = 0.0;
    return 1;
  }
  *dy = dVar4 / dVar3;
  *sdy = 1000.0 / dVar3;
  return 1;
}



int compute_xform_matrix
              (FontScalablePtr vals,double dx,double dy,double *xform,double *inv_xform,
              double *xmult,double *ymult)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  
  dVar5 = hypot(vals->pixel_matrix[2],vals->pixel_matrix[3]);
  dVar6 = hypot(vals->pixel_matrix[0],vals->pixel_matrix[1]);
  if ((1e-20 <= dVar5) && (1e-20 <= dVar6)) {
    xform[2] = 0.0;
    xform[1] = 0.0;
    dVar6 = dx / dVar6;
    dVar5 = dy / dVar5;
    *xform = dVar6;
    xform[3] = dVar5;
    dVar1 = vals->pixel_matrix[2];
    dVar2 = vals->pixel_matrix[0];
    dVar3 = vals->pixel_matrix[3];
    dVar4 = vals->pixel_matrix[1];
    dVar7 = dVar1 * 0.0 + dVar6 * dVar2;
    *xform = dVar7;
    xform[1] = dVar6 * dVar4 + dVar3 * 0.0;
    xform[3] = dVar4 * 0.0 + dVar3 * dVar5;
    xform[2] = dVar5 * dVar1 + dVar2 * 0.0;
    *xmult = dVar7;
    dVar6 = xform[3];
    *ymult = dVar6;
    dVar5 = *xform * dVar6 - xform[1] * xform[2];
    if (1e-20 <= ABS(dVar5)) {
      *inv_xform = dVar6 / dVar5;
      inv_xform[1] = -xform[1] / dVar5;
      inv_xform[2] = -xform[2] / dVar5;
      inv_xform[3] = *xform / dVar5;
      return 1;
    }
  }
  return 0;
}



void bitmapUnloadScalable(FontPtr pFont)

{
  long lVar1;
  void *pvVar2;
  int iVar3;
  long lVar4;
  void *__ptr;
  int iVar5;
  
  pvVar2 = pFont->fontPrivate;
  free((pFont->info).props);
  free((pFont->info).isStringProp);
  __ptr = *(void **)((long)pvVar2 + 0x28);
  if (__ptr != (void *)0x0) {
    iVar3 = (((uint)(pFont->info).lastCol - (uint)(pFont->info).firstCol) + 1) *
            (((uint)(pFont->info).lastRow - (uint)(pFont->info).firstRow) + 1);
    iVar5 = iVar3 + 0xfe;
    if (-1 < iVar3 + 0x7f) {
      iVar5 = iVar3 + 0x7f;
    }
    if (0 < iVar3) {
      lVar4 = 0;
      do {
        lVar1 = lVar4 * 8;
        lVar4 = lVar4 + 1;
        free(*(void **)((long)__ptr + lVar1));
        __ptr = *(void **)((long)pvVar2 + 0x28);
      } while ((int)lVar4 < iVar5 >> 7);
    }
  }
  free(__ptr);
  free(*(void **)((long)pvVar2 + 0x20));
  free(*(void **)((long)pvVar2 + 0x18));
  free(*(void **)((long)pvVar2 + 0x10));
  free(pFont->fontPrivate);
  DestroyFontRec(pFont);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int BitmapOpenScalable(FontPathElementPtr fpe,FontPtr *pFont,int flags,FontEntryPtr entry,
                      char *fileName,FontScalablePtr vals,fsBitmapFormat format,
                      fsBitmapFormatMask fmask,FontPtr non_cachable_font)

{
  undefined *puVar1;
  Atom *pAVar2;
  FontScaledPtr from;
  long *plVar3;
  char cVar4;
  byte bVar5;
  char cVar6;
  ushort uVar7;
  ushort uVar8;
  ushort uVar9;
  ushort uVar10;
  undefined4 uVar11;
  scaleType sVar12;
  long lVar13;
  FontScalableExtraPtr p_Var14;
  undefined4 *puVar15;
  ulong *puVar16;
  short *psVar17;
  FontRendererPtr __s;
  long lVar18;
  undefined2 uVar19;
  INT16 IVar20;
  INT16 IVar21;
  INT16 IVar22;
  INT16 IVar23;
  INT16 IVar24;
  INT16 IVar25;
  CARD16 CVar26;
  FontPtr p_Var27;
  byte bVar28;
  short sVar29;
  CARD16 CVar30;
  uint uVar31;
  uint uVar32;
  int iVar33;
  Bool BVar34;
  int iVar35;
  uint uVar36;
  uint uVar37;
  int iVar38;
  uint uVar39;
  size_t sVar40;
  FontEntryPtr p_Var41;
  FontPtr pFont_00;
  undefined4 *puVar42;
  void *pvVar43;
  undefined8 *puVar44;
  Atom AVar45;
  FontPropPtr p_Var46;
  char *pcVar47;
  uint *puVar48;
  ulong uVar49;
  byte *pbVar50;
  long lVar51;
  void *pvVar52;
  int iVar53;
  uint uVar54;
  fsRange *pfVar55;
  short sVar56;
  ushort uVar57;
  int iVar58;
  long lVar59;
  uint *puVar60;
  fsRange *pfVar61;
  FontPropPtr p_Var62;
  byte *pbVar63;
  long lVar64;
  FontPathElementPtr p_Var65;
  int *piVar66;
  char *pcVar67;
  int *piVar68;
  FontPropPtr p_Var69;
  int *piVar70;
  int iVar71;
  uint *puVar72;
  uint *puVar73;
  byte *pbVar74;
  short sVar75;
  short sVar76;
  int iVar77;
  int iVar78;
  fsRange *pfVar79;
  char *pcVar80;
  long lVar81;
  int iVar82;
  int iVar83;
  long lVar84;
  undefined8 uVar85;
  int iVar86;
  FontPropPtr p_Var87;
  int iVar88;
  byte *pbVar89;
  int iVar90;
  long lVar91;
  byte *pbVar92;
  fontProp *pfVar93;
  short *psVar94;
  fontProp *pfVar95;
  long in_FS_OFFSET;
  bool bVar96;
  double dVar97;
  double dVar98;
  double dVar99;
  double dVar100;
  double dVar101;
  double dVar102;
  double dVar103;
  double dVar104;
  double dVar105;
  double dVar106;
  double dVar107;
  double dVar108;
  double dVar109;
  double dVar110;
  int local_738;
  double local_728;
  FontEntryPtr local_720;
  byte *local_718;
  int local_710;
  FontPathElementPtr local_700;
  FontScaledPtr local_6f8;
  double local_6f0;
  double local_6e8;
  byte *local_6e0;
  double local_6d8;
  FontPtr local_6d0;
  FontPathElementPtr local_6c8;
  FontScaledPtr local_6a8;
  FontPtr local_6a0;
  double local_698;
  double local_690;
  int local_688;
  uint local_684;
  FontPathElementPtr local_680;
  long local_660;
  void *local_640;
  uint local_62c;
  int local_618;
  void *local_600;
  double dx;
  double sdx;
  double dy;
  double sdy;
  double dx_1;
  double sdx_1;
  double dy_1;
  double sdy_1;
  FontPtr sourceFont;
  FontNameRec zeroName;
  FontNameRec xlfdName;
  double xform [4];
  FontScalableRec best;
  FontScalableRec temp;
  char fontName [1024];
  
  lVar13 = *(long *)(in_FS_OFFSET + 0x28);
  dVar97 = hypot(vals->pixel_matrix[2],vals->pixel_matrix[3]);
  if ((dVar97 < 1.0) || (dVar97 = hypot(vals->pixel_matrix[0],vals->pixel_matrix[1]), dVar97 < 1.0))
  {
LAB_0011e2d8:
    local_738 = 0x53;
LAB_0011e2df:
    if (lVar13 == *(long *)(in_FS_OFFSET + 0x28)) {
      return local_738;
    }
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  lVar59 = (long)(entry->name).length;
  sourceFont = (FontPtr)0x3ff0000000000000;
  dx_1 = 0.0;
  sdx_1 = 0.0;
  dy_1 = 0.0;
  sdy_1 = 0.0;
  __memcpy_chk(fontName,(entry->name).name,lVar59,0x400);
  fontName[lVar59] = '\0';
  zeroName.name = fontName;
  FontParseXLFDName(fontName,&temp,2);
  puVar60 = (uint *)fontName;
  do {
    puVar48 = puVar60;
    uVar31 = *puVar48 + 0xfefefeff & ~*puVar48;
    uVar32 = uVar31 & 0x80808080;
    puVar60 = puVar48 + 1;
  } while (uVar32 == 0);
  pcVar47 = vals->xlfdName;
  bVar96 = (uVar31 & 0x8080) == 0;
  if (bVar96) {
    uVar32 = uVar32 >> 0x10;
  }
  if (bVar96) {
    puVar60 = (uint *)((long)puVar48 + 6);
  }
  zeroName.ndashes = (entry->name).ndashes;
  zeroName.length =
       (((short)puVar60 + -3) - (ushort)CARRY1((byte)uVar32,(byte)uVar32)) - (short)fontName;
  xlfdName.name = pcVar47;
  sVar40 = strlen(pcVar47);
  xlfdName.length = (short)sVar40;
  iVar33 = FontFileCountDashes(pcVar47,(int)xlfdName.length);
  local_700 = (FontPathElementPtr)0x0;
  xlfdName.ndashes = (short)iVar33;
  local_688 = 0x14;
  local_680 = (FontPathElementPtr)0x0;
  local_6c8 = (FontPathElementPtr)0x0;
  local_6f8 = (FontScaledPtr)0x0;
  local_6a0 = (FontPtr)0x0;
  local_6d0 = (FontPtr)0x0;
  local_690 = 0.0;
  local_698 = 0.0;
  local_6d8 = 0.0;
  local_6e0 = (byte *)0x0;
  local_6e8 = 0.0;
  local_6f0 = 0.0;
  local_684 = -1;
  iVar33 = 0;
  local_6a8 = (FontScaledPtr)0x0;
  local_728 = INFINITY;
  local_718 = (byte *)0x7ff0000000000000;
LAB_0011e09b:
  if (0 < FontFileBitmapSources.count) {
    local_720 = (FontEntryPtr)0x0;
    lVar59 = 0;
    do {
      p_Var65 = FontFileBitmapSources.fpe[lVar59];
      if ((local_720 == (FontEntryPtr)0x0) && (vals->xlfdName != (char *)0x0)) {
        p_Var41 = FontFileFindNameInDir((FontTablePtr)((long)p_Var65->private + 0x30),&xlfdName);
        local_700 = p_Var65;
        if (p_Var41 != (FontEntryPtr)0x0) {
          if (p_Var41->type == 2) {
            p_Var65 = FontFileBitmapSources.fpe[lVar59];
            local_720 = p_Var41;
            goto LAB_0011e0d3;
          }
          if ((local_688 != 0) && (p_Var41->type == 3)) goto LAB_00120717;
        }
        p_Var65 = FontFileBitmapSources.fpe[lVar59];
      }
LAB_0011e0d3:
      p_Var41 = entry;
      if (((fpe == p_Var65) ||
          (p_Var41 = FontFileFindNameInDir((FontTablePtr)((long)p_Var65->private + 0x18),&zeroName),
          p_Var41 != (FontEntryPtr)0x0)) &&
         (p_Var14 = (p_Var41->u).scalable.extra, 0 < p_Var14->numScaled)) {
        lVar91 = 0;
        do {
          from = p_Var14->scaled + lVar91;
          if ((from->bitmap != (FontEntryPtr)0x0) &&
             (BVar34 = ComputeScaleFactors(&from->vals,vals,&dx_1,&dy_1,&sdx_1,&sdy_1,
                                           (double *)&sourceFont), BVar34 != 0)) {
            if (dy_1 < 1.0) {
              iVar35 = (int)(dy_1 * 20.0);
            }
            else if ((false) || (dy_1 != 1.0)) {
              if ((false) || (dy_1 != 2.0)) {
                iVar35 = (int)(30.0 / dy_1);
              }
              else {
                iVar35 = 0x28;
              }
            }
            else {
              iVar35 = 0xa0;
            }
            if (dx_1 < 1.0) {
              iVar35 = iVar35 + (int)(dx_1 + dx_1);
            }
            else if ((false) || (dx_1 != 1.0)) {
              if ((false) || (dx_1 != 2.0)) {
                iVar35 = iVar35 + (int)(3.0 / dx_1);
              }
              else {
                iVar35 = iVar35 + 4;
              }
            }
            else {
              iVar35 = iVar35 + 0x10;
            }
            if ((iVar33 < iVar35) ||
               ((iVar35 == iVar33 &&
                ((dy_1 < local_728 ||
                 (((true && (dy_1 == local_728)) && (dx_1 < (double)local_718)))))))) {
              local_6e8 = sdx_1;
              local_6d8 = sdy_1;
              local_6c8 = FontFileBitmapSources.fpe[lVar59];
              local_6d0 = sourceFont;
              local_728 = dy_1;
              local_718 = (byte *)dx_1;
              local_6f8 = from;
              local_6f0 = dx_1;
              local_6e0 = (byte *)dy_1;
              iVar33 = iVar35;
            }
            if ((1e-20 < ABS(dx_1)) && (1e-20 < ABS(dy_1))) {
              dVar97 = vals->pixel_matrix[0];
              dVar100 = (from->vals).pixel_matrix[0];
              if ((ABS(dVar97 * (double)sourceFont - dVar100) < 1.0) &&
                 ((ABS(vals->pixel_matrix[1] * (double)sourceFont - (from->vals).pixel_matrix[1]) <
                   1e-20 && (ABS(vals->pixel_matrix[2] - (from->vals).pixel_matrix[2]) < 1e-20)))) {
                dVar98 = vals->pixel_matrix[3];
                dVar101 = (from->vals).pixel_matrix[3];
                if (ABS(dVar98 - dVar101) < 1.0) {
                  if (dVar98 / dVar101 < 1.0) {
                    dVar98 = dVar98 * 80.0;
                  }
                  else {
                    dVar98 = 80.0 / dVar98;
                  }
                  if ((dVar97 * (double)sourceFont) / dVar100 < 1.0) {
                    dVar97 = dVar97 * 8.0;
                  }
                  else {
                    dVar97 = 8.0 / dVar97;
                  }
                  iVar35 = (int)((dVar97 * (double)sourceFont) / dVar100) + (int)(dVar98 / dVar101);
                  if ((int)local_684 < iVar35) {
                    local_698 = sdx_1 / dx_1;
                    local_680 = FontFileBitmapSources.fpe[lVar59];
                    local_690 = sdy_1 / dy_1;
                    local_6a8 = from;
                    local_6a0 = sourceFont;
                    local_684 = iVar35;
                  }
                }
              }
            }
          }
          lVar91 = lVar91 + 1;
        } while ((int)lVar91 < p_Var14->numScaled);
      }
      lVar59 = lVar59 + 1;
      if (FontFileBitmapSources.count <= (int)lVar59) goto LAB_0011e32f;
    } while( true );
  }
  local_720 = (FontEntryPtr)0x0;
LAB_0011e32f:
  if (local_6a8 == (FontScaledPtr)0x0) {
    if (local_6f8 != (FontScaledPtr)0x0) {
      best.values_supplied = (local_6f8->vals).values_supplied;
      best._4_4_ = *(undefined4 *)&(local_6f8->vals).field_0x4;
      best.pixel_matrix[0] = (local_6f8->vals).pixel_matrix[0];
      best.pixel_matrix[1] = (local_6f8->vals).pixel_matrix[1];
      best.pixel_matrix[2] = (local_6f8->vals).pixel_matrix[2];
      best.pixel_matrix[3] = (local_6f8->vals).pixel_matrix[3];
      best.point_matrix[0] = (local_6f8->vals).point_matrix[0];
      best.point_matrix[1] = (local_6f8->vals).point_matrix[1];
      best.point_matrix[2] = (local_6f8->vals).point_matrix[2];
      best.point_matrix[3] = (local_6f8->vals).point_matrix[3];
      best._72_8_ = *(undefined8 *)&(local_6f8->vals).pixel;
      best._80_8_ = *(undefined8 *)&(local_6f8->vals).x;
      best._88_8_ = *(undefined8 *)&(local_6f8->vals).width;
      dx = local_6f0;
      best.xlfdName = (local_6f8->vals).xlfdName;
      best._104_8_ = *(undefined8 *)&(local_6f8->vals).nranges;
      sdx = local_6e8;
      sdy = local_6d8;
      best.ranges = (local_6f8->vals).ranges;
      dy = (double)local_6e0;
      sourceFont = local_6d0;
      p_Var41 = local_6f8->bitmap;
      local_680 = local_6c8;
      goto LAB_0011e3f7;
    }
    if (local_720 != (FontEntryPtr)0x0) goto LAB_0011e700;
    goto LAB_0011e2d8;
  }
  best.values_supplied = (local_6a8->vals).values_supplied;
  best._4_4_ = *(undefined4 *)&(local_6a8->vals).field_0x4;
  best.pixel_matrix[0] = (local_6a8->vals).pixel_matrix[0];
  best.pixel_matrix[1] = (local_6a8->vals).pixel_matrix[1];
  best.pixel_matrix[2] = (local_6a8->vals).pixel_matrix[2];
  best.pixel_matrix[3] = (local_6a8->vals).pixel_matrix[3];
  best.point_matrix[0] = (local_6a8->vals).point_matrix[0];
  best.point_matrix[1] = (local_6a8->vals).point_matrix[1];
  best.point_matrix[2] = (local_6a8->vals).point_matrix[2];
  best.point_matrix[3] = (local_6a8->vals).point_matrix[3];
  best._72_8_ = *(undefined8 *)&(local_6a8->vals).pixel;
  best._80_8_ = *(undefined8 *)&(local_6a8->vals).x;
  best._88_8_ = *(undefined8 *)&(local_6a8->vals).width;
  best.xlfdName = (local_6a8->vals).xlfdName;
  best._104_8_ = *(undefined8 *)&(local_6a8->vals).nranges;
  sdx = local_698;
  best.ranges = (local_6a8->vals).ranges;
  sdy = local_690;
  sourceFont = local_6a0;
  dx = 1.0;
  dy = 1.0;
  p_Var41 = local_6a8->bitmap;
LAB_0011e3f7:
  if (local_720 == (FontEntryPtr)0x0) {
    if (p_Var41 != (FontEntryPtr)0x0) goto LAB_0011e43e;
    goto LAB_0011e2d8;
  }
  if ((((p_Var41 == (FontEntryPtr)0x0) || (false)) || (dx != 1.0)) || ((false || (dy != 1.0)))) {
LAB_0011e700:
    FontParseXLFDName((local_720->name).name,&best,0);
    BVar34 = ComputeScaleFactors(&best,&best,&dx,&dy,&sdx,&sdy,(double *)&sourceFont);
    if (BVar34 == 0) goto LAB_0011e2d8;
  }
  else {
LAB_0011e43e:
    local_700 = local_680;
    local_720 = p_Var41;
  }
  if ((false) || ((double)sourceFont != 1.0)) {
    vals->values_supplied = vals->values_supplied & 0xfffffff3;
    vals->pixel_matrix[0] = vals->pixel_matrix[0] * (double)sourceFont;
    vals->pixel_matrix[1] = (double)sourceFont * vals->pixel_matrix[1];
    FontFileCompleteXLFD(vals,vals);
  }
  iVar33 = FontFileOpenBitmap(local_700,&sourceFont,1,local_720,format,fmask);
  p_Var27 = sourceFont;
  dVar98 = dy;
  dVar100 = sdx;
  dVar97 = dx;
  if (iVar33 != 0x55) goto LAB_0011e2d8;
  if (vals->width == 0) {
    vals->width = (int)((double)best.width * dx);
  }
  puVar15 = (undefined4 *)sourceFont->fontPrivate;
  pFont_00 = CreateFontRec();
  if (pFont_00 == (FontPtr)0x0) {
    __fprintf_chk(_stderr,1,"Error: Couldn\'t allocate FontRec (%ld)\n",0xb8);
LAB_0011f18a:
    local_738 = 0x50;
    if (sourceFont->refcnt == 0) {
      FontFileCloseFont((FontPathElementPtr)0x0,sourceFont);
    }
    goto LAB_0011e2df;
  }
  pFont_00->refcnt = 0;
  pFont_00->bit = p_Var27->bit;
  pFont_00->byte = p_Var27->byte;
  pFont_00->glyph = p_Var27->glyph;
  cVar4 = p_Var27->scan;
  pFont_00->unload_glyphs = (_func_void_FontPtr *)0x0;
  pFont_00->scan = cVar4;
  pFont_00->get_glyphs = bitmapGetGlyphs;
  pFont_00->get_metrics = bitmapGetMetrics;
  pFont_00->unload_font = bitmapUnloadScalable;
  uVar7 = (p_Var27->info).lastCol;
  uVar8 = (p_Var27->info).firstRow;
  uVar57 = (p_Var27->info).lastRow;
  uVar9 = (p_Var27->info).defaultCh;
  uVar19 = *(undefined2 *)&(p_Var27->info).field_0xa;
  sVar56 = (p_Var27->info).maxOverlap;
  sVar29 = (p_Var27->info).pad;
  (pFont_00->info).firstCol = (p_Var27->info).firstCol;
  (pFont_00->info).lastCol = uVar7;
  (pFont_00->info).firstRow = uVar8;
  (pFont_00->info).lastRow = uVar57;
  (pFont_00->info).defaultCh = uVar9;
  *(undefined2 *)&(pFont_00->info).field_0xa = uVar19;
  (pFont_00->info).maxOverlap = sVar56;
  (pFont_00->info).pad = sVar29;
  IVar20 = (p_Var27->info).maxbounds.rightSideBearing;
  IVar21 = (p_Var27->info).maxbounds.characterWidth;
  IVar22 = (p_Var27->info).maxbounds.ascent;
  uVar85 = *(undefined8 *)&(p_Var27->info).maxbounds.descent;
  (pFont_00->info).maxbounds.leftSideBearing = (p_Var27->info).maxbounds.leftSideBearing;
  (pFont_00->info).maxbounds.rightSideBearing = IVar20;
  (pFont_00->info).maxbounds.characterWidth = IVar21;
  (pFont_00->info).maxbounds.ascent = IVar22;
  *(undefined8 *)&(pFont_00->info).maxbounds.descent = uVar85;
  IVar20 = (p_Var27->info).minbounds.ascent;
  IVar21 = (p_Var27->info).minbounds.descent;
  CVar30 = (p_Var27->info).minbounds.attributes;
  IVar22 = (p_Var27->info).ink_maxbounds.leftSideBearing;
  IVar23 = (p_Var27->info).ink_maxbounds.rightSideBearing;
  IVar24 = (p_Var27->info).ink_maxbounds.characterWidth;
  IVar25 = (p_Var27->info).ink_maxbounds.ascent;
  (pFont_00->info).minbounds.characterWidth = (p_Var27->info).minbounds.characterWidth;
  (pFont_00->info).minbounds.ascent = IVar20;
  (pFont_00->info).minbounds.descent = IVar21;
  (pFont_00->info).minbounds.attributes = CVar30;
  (pFont_00->info).ink_maxbounds.leftSideBearing = IVar22;
  (pFont_00->info).ink_maxbounds.rightSideBearing = IVar23;
  (pFont_00->info).ink_maxbounds.characterWidth = IVar24;
  (pFont_00->info).ink_maxbounds.ascent = IVar25;
  IVar20 = (p_Var27->info).ink_minbounds.characterWidth;
  IVar21 = (p_Var27->info).ink_minbounds.ascent;
  IVar22 = (p_Var27->info).ink_minbounds.descent;
  CVar30 = (p_Var27->info).ink_minbounds.attributes;
  *(undefined8 *)&(pFont_00->info).ink_maxbounds.descent =
       *(undefined8 *)&(p_Var27->info).ink_maxbounds.descent;
  (pFont_00->info).ink_minbounds.characterWidth = IVar20;
  (pFont_00->info).ink_minbounds.ascent = IVar21;
  (pFont_00->info).ink_minbounds.descent = IVar22;
  (pFont_00->info).ink_minbounds.attributes = CVar30;
  sVar56 = (p_Var27->info).fontDescent;
  iVar33 = (p_Var27->info).nprops;
  p_Var46 = (p_Var27->info).props;
  (pFont_00->info).fontAscent = (p_Var27->info).fontAscent;
  (pFont_00->info).fontDescent = sVar56;
  (pFont_00->info).nprops = iVar33;
  (pFont_00->info).props = p_Var46;
  (pFont_00->info).isStringProp = (p_Var27->info).isStringProp;
  if (vals->nranges != 0) {
    puVar1 = &(pFont_00->info).field_0xa;
    *puVar1 = *puVar1 & 0xbf;
    if (0 < vals->nranges) {
      uVar31 = 0;
      uVar32 = 0xff;
      uVar37 = 0;
      uVar36 = 0xff;
      pfVar61 = vals->ranges + 1;
      pfVar55 = vals->ranges;
      pfVar79 = pfVar61;
      while( true ) {
        bVar28 = pfVar55->min_char_high;
        bVar5 = pfVar55->max_char_high;
        if (bVar28 != bVar5) {
          uVar32 = (uint)(p_Var27->info).firstCol;
          uVar31 = (uint)(p_Var27->info).lastCol;
        }
        if (pfVar55->min_char_low < uVar32) {
          uVar32 = (uint)pfVar55->min_char_low;
        }
        if (uVar31 < pfVar55->max_char_low) {
          uVar31 = (uint)pfVar55->max_char_low;
        }
        if (bVar28 < uVar36) {
          uVar36 = (uint)bVar28;
        }
        if (uVar37 < bVar5) {
          uVar37 = (uint)bVar5;
        }
        if (pfVar61 + (vals->nranges - 1) == pfVar79) break;
        pfVar55 = pfVar79;
        pfVar79 = pfVar79 + 1;
      }
      if ((uVar32 <= uVar31) && (uVar36 <= uVar37)) {
        uVar39 = (uint)(p_Var27->info).firstCol;
        if (uVar32 <= uVar39) {
          uVar32 = uVar39;
        }
        uVar39 = (uint)(p_Var27->info).lastCol;
        if (uVar31 < uVar39) {
          uVar39 = uVar31;
        }
        uVar31 = (uint)(p_Var27->info).firstRow;
        if (uVar36 <= uVar31) {
          uVar36 = uVar31;
        }
        uVar31 = (uint)(p_Var27->info).lastRow;
        if (uVar37 < uVar31) {
          uVar31 = uVar37;
        }
        goto LAB_0011eaf2;
      }
    }
LAB_0011f185:
    free(pFont_00);
    goto LAB_0011f18a;
  }
  uVar39 = (uint)(p_Var27->info).lastCol;
  uVar32 = (uint)(p_Var27->info).firstCol;
  uVar36 = (uint)(p_Var27->info).firstRow;
  uVar31 = (uint)(p_Var27->info).lastRow;
LAB_0011eaf2:
  puVar42 = (undefined4 *)malloc(0x40);
  if (puVar42 == (undefined4 *)0x0) {
    __fprintf_chk(_stderr,1,"Error: Couldn\'t allocate bitmapFont (%ld)\n",0x40);
    free(pFont_00);
    goto LAB_0011f18a;
  }
  iVar33 = (uVar39 - uVar32) + 1;
  uVar37 = ((uVar31 - uVar36) + 1) * iVar33;
  (pFont_00->info).firstCol = (ushort)uVar32;
  (pFont_00->info).firstRow = (ushort)uVar36;
  (pFont_00->info).lastRow = (ushort)uVar31;
  (pFont_00->info).lastCol = (ushort)uVar39;
  pFont_00->fontPrivate = puVar42;
  uVar11 = *puVar15;
  puVar42[1] = uVar37;
  *puVar42 = uVar11;
  uVar11 = puVar15[2];
  *(undefined8 *)(puVar42 + 6) = 0;
  puVar42[2] = uVar11;
  *(undefined8 *)(puVar42 + 8) = 0;
  *(undefined8 *)(puVar42 + 10) = 0;
  *(undefined8 *)(puVar42 + 0xe) = 0;
  *(undefined8 *)(puVar42 + 0xc) = 0;
  pvVar43 = malloc((long)(int)uVar37 * 0x18);
  *(void **)(puVar42 + 4) = pvVar43;
  if (pvVar43 == (void *)0x0) {
    uVar85 = 0x18;
    pcVar47 = "Error: Couldn\'t allocate metrics (%d*%ld)\n";
LAB_00121138:
    __fprintf_chk(_stderr,1,pcVar47,uVar37,uVar85);
LAB_0011f2b8:
    free(pFont_00);
    free(*(void **)(puVar42 + 4));
    free(*(void **)(puVar42 + 6));
    free(*(void **)(puVar42 + 8));
    pFont_00 = *(FontPtr *)(puVar42 + 10);
    if (pFont_00 != (FontPtr)0x0) {
      iVar33 = uVar37 + 0xfe;
      if (-1 < (int)(uVar37 + 0x7f)) {
        iVar33 = uVar37 + 0x7f;
      }
      if (0 < (int)uVar37) {
        lVar59 = 0;
        do {
          lVar91 = lVar59 * 2;
          lVar59 = lVar59 + 1;
          free(*(void **)(&pFont_00->refcnt + lVar91));
          pFont_00 = *(FontPtr *)(puVar42 + 10);
        } while ((int)lVar59 < iVar33 >> 7);
      }
    }
    goto LAB_0011f185;
  }
  iVar35 = uVar37 + 0xfe;
  if (-1 < (int)(uVar37 + 0x7f)) {
    iVar35 = uVar37 + 0x7f;
  }
  pvVar43 = calloc((long)(iVar35 >> 7),8);
  *(void **)(puVar42 + 10) = pvVar43;
  if (pvVar43 == (void *)0x0) {
    uVar85 = 8;
    pcVar47 = "Error: Couldn\'t allocate encoding (%d*%ld)\n";
    goto LAB_00121138;
  }
  if ((false) || (dVar97 != dVar98)) {
    bVar28 = (pFont_00->info).field_0xb | 4;
    (pFont_00->info).field_0xb = bVar28;
  }
  else {
    bVar28 = (pFont_00->info).field_0xb & 0xfb;
    (pFont_00->info).field_0xb = bVar28;
  }
  (pFont_00->info).field_0xb = bVar28 | 2;
  iVar35 = compute_xform_matrix
                     (vals,dVar97,dVar98,xform,(double *)&temp,(double *)&zeroName,
                      (double *)&xlfdName);
  if (iVar35 == 0) goto LAB_0011f2b8;
  (pFont_00->info).fontAscent =
       (short)(int)((double)(int)(p_Var27->info).fontAscent * (double)xlfdName.name);
  sVar56 = (p_Var27->info).fontDescent;
  *(undefined8 *)&(pFont_00->info).maxbounds.descent = 0x7fff7fff80008000;
  (pFont_00->info).minbounds.characterWidth = 0x7fff;
  (pFont_00->info).minbounds.ascent = 0x7fff;
  (pFont_00->info).minbounds.descent = 0x7fff;
  (pFont_00->info).minbounds.attributes = 0x7fff;
  (pFont_00->info).fontDescent = (short)(int)((double)(int)sVar56 * (double)xlfdName.name);
  (pFont_00->info).maxbounds.leftSideBearing = -0x8000;
  (pFont_00->info).maxbounds.rightSideBearing = -0x8000;
  (pFont_00->info).maxbounds.characterWidth = -0x8000;
  (pFont_00->info).maxbounds.ascent = -0x8000;
  psVar94 = *(short **)(puVar42 + 4);
  if ((int)uVar37 < 1) {
    IVar20 = (pFont_00->info).minbounds.leftSideBearing;
    IVar21 = (pFont_00->info).minbounds.rightSideBearing;
    IVar22 = (pFont_00->info).minbounds.characterWidth;
    IVar23 = (pFont_00->info).minbounds.ascent;
    (pFont_00->info).ink_maxbounds.leftSideBearing = -0x8000;
    (pFont_00->info).ink_maxbounds.rightSideBearing = -0x8000;
    (pFont_00->info).ink_maxbounds.characterWidth = -0x8000;
    (pFont_00->info).ink_maxbounds.ascent = -0x8000;
    IVar24 = (pFont_00->info).maxbounds.descent;
    CVar30 = (pFont_00->info).maxbounds.attributes;
    (pFont_00->info).ink_minbounds.leftSideBearing = IVar20;
    (pFont_00->info).ink_minbounds.rightSideBearing = IVar21;
    (pFont_00->info).ink_minbounds.characterWidth = IVar22;
    (pFont_00->info).ink_minbounds.ascent = IVar23;
    IVar20 = (pFont_00->info).minbounds.descent;
    CVar26 = (pFont_00->info).minbounds.attributes;
    (pFont_00->info).ink_maxbounds.descent = IVar24;
    (pFont_00->info).ink_maxbounds.attributes = CVar30;
    (pFont_00->info).ink_minbounds.descent = IVar20;
    (pFont_00->info).ink_minbounds.attributes = CVar26;
LAB_0012057f:
    vals->width = 0;
    local_660 = 0;
  }
  else {
    uVar31 = 0;
    iVar35 = 0;
    do {
      uVar39 = (uint)(p_Var27->info).firstCol;
      iVar38 = (int)uVar31 / iVar33 + uVar36;
      iVar77 = ((((p_Var27->info).lastCol - uVar39) + 1) * (iVar38 - (uint)(p_Var27->info).firstRow)
                + (int)uVar31 % iVar33 + uVar32) - uVar39;
      iVar82 = iVar77 + 0x7f;
      if (-1 < iVar77) {
        iVar82 = iVar77;
      }
      lVar59 = *(long *)(*(long *)(puVar15 + 10) + (long)(iVar82 >> 7) * 8);
      if ((lVar59 != 0) &&
         (puVar16 = *(ulong **)(lVar59 + (long)(iVar77 % 0x80) * 8), puVar16 != (ulong *)0x0)) {
        iVar82 = vals->nranges;
        if ((iVar82 == 0) || (iVar38 = (int)uVar31 % iVar33 + uVar32 + iVar38 * 0x100, iVar82 < 1))
        {
LAB_0011f045:
          if ((((*puVar16 & 0xffff0000ffffffff) != 0) || (*(short *)(puVar16 + 1) != 0)) ||
             (*(short *)((long)puVar16 + 4) != 0)) {
            plVar3 = (long *)(*(long *)(puVar42 + 10) + (long)((int)uVar31 >> 7) * 8);
            lVar59 = *plVar3;
            if (lVar59 == 0) {
              pvVar43 = calloc(0x80,8);
              *plVar3 = (long)pvVar43;
              lVar59 = *(long *)(*(long *)(puVar42 + 10) + (long)((int)uVar31 >> 7) * 8);
              if (lVar59 == 0) goto LAB_0011f2b8;
            }
            *(short **)(lVar59 + (ulong)(uVar31 & 0x7f) * 8) = psVar94;
            dVar107 = xform[0] * (double)(int)*(short *)puVar16;
            dVar104 = (double)(int)*(short *)puVar16 * xform[1];
            dVar109 = xform[2] * (double)-(int)*(short *)(puVar16 + 1);
            dVar103 = (double)-(int)*(short *)(puVar16 + 1) * xform[3];
            dVar106 = xform[2] * (double)(int)*(short *)((long)puVar16 + 6);
            dVar105 = xform[3] * (double)(int)*(short *)((long)puVar16 + 6);
            dVar102 = dVar107 + dVar109;
            dVar99 = dVar104 + dVar103;
            dVar107 = dVar107 + dVar106;
            dVar104 = dVar104 + dVar105;
            dVar101 = dVar107;
            if (dVar107 <= dVar102) {
              dVar101 = dVar102;
            }
            if (dVar102 <= dVar107) {
              dVar107 = dVar102;
            }
            dVar102 = dVar99;
            if (dVar104 < dVar99) {
              dVar102 = dVar104;
            }
            if (dVar104 <= dVar99) {
              dVar104 = dVar99;
            }
            dVar99 = xform[0] * (double)(int)*(short *)((long)puVar16 + 2);
            dVar110 = xform[1] * (double)(int)*(short *)((long)puVar16 + 2);
            dVar109 = dVar109 + dVar99;
            dVar103 = dVar103 + dVar110;
            dVar108 = dVar109;
            if (dVar109 <= dVar101) {
              dVar108 = dVar101;
            }
            if (dVar107 <= dVar109) {
              dVar109 = dVar107;
            }
            if (dVar103 < dVar102) {
              dVar102 = dVar103;
            }
            dVar99 = dVar99 + dVar106;
            dVar110 = dVar110 + dVar105;
            if (dVar103 <= dVar104) {
              dVar103 = dVar104;
            }
            dVar101 = dVar99;
            if (dVar99 <= dVar108) {
              dVar101 = dVar108;
            }
            if (dVar109 <= dVar99) {
              dVar99 = dVar109;
            }
            if (dVar110 < dVar102) {
              dVar102 = dVar110;
            }
            dVar102 = -dVar102;
            if (dVar110 <= dVar103) {
              dVar110 = dVar103;
            }
            if (ABS(dVar99) < 4503599627370496.0) {
              dVar99 = (double)((ulong)dVar99 & 0x8000000000000000 |
                               (ulong)((double)(long)dVar99 -
                                      (double)(-(ulong)(dVar99 < (double)(long)dVar99) &
                                              0x3ff0000000000000)));
            }
            dVar101 = dVar101 + 0.5;
            *psVar94 = (short)(int)dVar99;
            if (ABS(dVar101) < 4503599627370496.0) {
              dVar101 = (double)((ulong)dVar101 & 0x8000000000000000 |
                                (ulong)((double)(long)dVar101 -
                                       (double)(-(ulong)(dVar101 < (double)(long)dVar101) &
                                               0x3ff0000000000000)));
            }
            sVar56 = (short)(int)dVar101;
            psVar94[1] = sVar56;
            if (ABS(dVar102) < 4503599627370496.0) {
              dVar102 = (double)((ulong)dVar102 & 0x8000000000000000 |
                                (ulong)((double)(long)dVar102 +
                                       (double)(-(ulong)((double)(long)dVar102 < dVar102) &
                                               0x3ff0000000000000)));
            }
            dVar110 = dVar110 + 0.5;
            psVar94[4] = (short)(int)dVar102;
            if (ABS(dVar110) < 4503599627370496.0) {
              dVar110 = (double)((ulong)dVar110 & 0x8000000000000000 |
                                (ulong)((double)(long)dVar110 -
                                       (double)(-(ulong)(dVar110 < (double)(long)dVar110) &
                                               0x3ff0000000000000)));
            }
            sVar29 = (short)(int)dVar110;
            psVar94[3] = sVar29;
            iVar35 = iVar35 + *(short *)((long)puVar16 + 4);
            dVar101 = (double)(int)*(short *)((long)puVar16 + 4) * (double)zeroName.name;
            if (dVar101 < 0.0) {
              sVar75 = (short)(long)(dVar101 - 0.5);
            }
            else {
              sVar75 = (short)(long)(dVar101 + 0.5);
            }
            psVar94[2] = sVar75;
            dVar101 = (double)(int)*(short *)((long)puVar16 + 4) * dVar100;
            if (dVar101 < 0.0) {
              sVar76 = (short)(long)(dVar101 - 0.5);
            }
            else {
              sVar76 = (short)(long)(dVar101 + 0.5);
            }
            psVar94[5] = sVar76;
            if (sVar75 == 0) {
              if ((short)(int)dVar99 == sVar56) {
                psVar94[1] = sVar56 + 1;
              }
              if ((int)sVar29 + (int)(short)(int)dVar102 == 0) {
                psVar94[3] = sVar29 + 1;
              }
            }
            psVar94 = psVar94 + 0xc;
          }
        }
        else {
          pfVar61 = vals->ranges;
          iVar77 = 0;
          do {
            if (((int)((uint)pfVar61->min_char_high * 0x100 + (uint)pfVar61->min_char_low) <= iVar38
                ) && (iVar38 <= (int)((uint)pfVar61->max_char_high * 0x100 +
                                     (uint)pfVar61->max_char_low))) {
              if (iVar82 != iVar77) goto LAB_0011f045;
              break;
            }
            iVar77 = iVar77 + 1;
            pfVar61 = pfVar61 + 1;
          } while (iVar82 != iVar77);
        }
      }
      uVar31 = uVar31 + 1;
    } while (uVar37 != uVar31);
    lVar59 = 0;
    uVar31 = 0;
    iVar82 = 0;
    do {
      lVar91 = *(long *)(*(long *)(puVar42 + 10) + (long)((int)uVar31 >> 7) * 8);
      if ((lVar91 != 0) &&
         (psVar94 = *(short **)(lVar91 + (ulong)(uVar31 & 0x7f) * 8), psVar94 != (short *)0x0)) {
        uVar39 = (uint)(p_Var27->info).firstCol;
        iVar77 = ((int)uVar31 % iVar33 +
                  (((int)uVar31 / iVar33 + uVar36) - (uint)(p_Var27->info).firstRow) *
                  (((p_Var27->info).lastCol - uVar39) + 1) + uVar32) - uVar39;
        iVar38 = iVar77 + 0x7f;
        if (-1 < iVar77) {
          iVar38 = iVar77;
        }
        lVar91 = *(long *)(*(long *)(puVar15 + 10) + (long)(iVar38 >> 7) * 8);
        if ((lVar91 != 0) && (*(long *)(lVar91 + (long)(iVar77 % 0x80) * 8) != 0)) {
          iVar82 = iVar82 + 1;
          lVar59 = lVar59 + (ulong)((uint)(ushort)(psVar94[5] ^ psVar94[5] >> 0xf) -
                                    (uint)(ushort)(psVar94[5] >> 0xf) & 0xffff);
          sVar56 = *psVar94;
          if (sVar56 < (pFont_00->info).minbounds.leftSideBearing) {
            (pFont_00->info).minbounds.leftSideBearing = sVar56;
            sVar56 = *psVar94;
          }
          if ((pFont_00->info).maxbounds.leftSideBearing < sVar56) {
            (pFont_00->info).maxbounds.leftSideBearing = sVar56;
          }
          sVar56 = psVar94[1];
          if (sVar56 < (pFont_00->info).minbounds.rightSideBearing) {
            (pFont_00->info).minbounds.rightSideBearing = sVar56;
            sVar56 = psVar94[1];
          }
          if ((pFont_00->info).maxbounds.rightSideBearing < sVar56) {
            (pFont_00->info).maxbounds.rightSideBearing = sVar56;
          }
          sVar56 = psVar94[3];
          if (sVar56 < (pFont_00->info).minbounds.ascent) {
            (pFont_00->info).minbounds.ascent = sVar56;
            sVar56 = psVar94[3];
          }
          if ((pFont_00->info).maxbounds.ascent < sVar56) {
            (pFont_00->info).maxbounds.ascent = sVar56;
          }
          sVar56 = psVar94[4];
          if (sVar56 < (pFont_00->info).minbounds.descent) {
            (pFont_00->info).minbounds.descent = sVar56;
            sVar56 = psVar94[4];
          }
          if ((pFont_00->info).maxbounds.descent < sVar56) {
            (pFont_00->info).maxbounds.descent = sVar56;
          }
          sVar56 = psVar94[2];
          if (sVar56 < (pFont_00->info).minbounds.characterWidth) {
            (pFont_00->info).minbounds.characterWidth = sVar56;
            sVar56 = psVar94[2];
          }
          if ((pFont_00->info).maxbounds.characterWidth < sVar56) {
            (pFont_00->info).maxbounds.characterWidth = sVar56;
          }
          CVar30 = psVar94[5];
          if ((short)CVar30 < (short)(pFont_00->info).minbounds.attributes) {
            (pFont_00->info).minbounds.attributes = CVar30;
            CVar30 = psVar94[5];
          }
          if ((short)(pFont_00->info).maxbounds.attributes < (short)CVar30) {
            (pFont_00->info).maxbounds.attributes = CVar30;
          }
        }
      }
      uVar31 = uVar31 + 1;
    } while (uVar37 != uVar31);
    IVar20 = (pFont_00->info).minbounds.rightSideBearing;
    IVar21 = (pFont_00->info).minbounds.characterWidth;
    IVar22 = (pFont_00->info).minbounds.ascent;
    (pFont_00->info).ink_minbounds.leftSideBearing = (pFont_00->info).minbounds.leftSideBearing;
    (pFont_00->info).ink_minbounds.rightSideBearing = IVar20;
    (pFont_00->info).ink_minbounds.characterWidth = IVar21;
    (pFont_00->info).ink_minbounds.ascent = IVar22;
    CVar30 = (pFont_00->info).minbounds.attributes;
    (pFont_00->info).ink_minbounds.descent = (pFont_00->info).minbounds.descent;
    (pFont_00->info).ink_minbounds.attributes = CVar30;
    IVar20 = (pFont_00->info).maxbounds.rightSideBearing;
    IVar21 = (pFont_00->info).maxbounds.characterWidth;
    IVar22 = (pFont_00->info).maxbounds.ascent;
    (pFont_00->info).ink_maxbounds.leftSideBearing = (pFont_00->info).maxbounds.leftSideBearing;
    (pFont_00->info).ink_maxbounds.rightSideBearing = IVar20;
    (pFont_00->info).ink_maxbounds.characterWidth = IVar21;
    (pFont_00->info).ink_maxbounds.ascent = IVar22;
    CVar30 = (pFont_00->info).maxbounds.attributes;
    (pFont_00->info).ink_maxbounds.descent = (pFont_00->info).maxbounds.descent;
    (pFont_00->info).ink_maxbounds.attributes = CVar30;
    if (iVar82 == 0) goto LAB_0012057f;
    local_660 = ((long)(iVar82 >> 1) + lVar59 * 10) / (long)iVar82;
    if (iVar35 < 0) {
      local_660 = -local_660;
    }
    sVar56 = (pFont_00->info).minbounds.characterWidth;
    if (sVar56 == (pFont_00->info).maxbounds.characterWidth) {
      vals->width = sVar56 * 10;
    }
    else {
      dVar100 = ((double)local_660 * vals->pixel_matrix[0]) / 1000.0;
      if (dVar100 < 0.0) {
        iVar33 = (int)(long)(dVar100 - 0.5);
      }
      else {
        iVar33 = (int)(long)(dVar100 + 0.5);
      }
      vals->width = iVar33;
    }
  }
  FontComputeInfoAccelerators(&pFont_00->info);
  p_Var27 = sourceFont;
  uVar7 = (pFont_00->info).defaultCh;
  if (uVar7 != 0xffff) {
    uVar8 = (pFont_00->info).firstRow;
    uVar57 = uVar7 >> 8;
    if ((uVar8 <= uVar57) && (uVar57 <= (pFont_00->info).lastRow)) {
      uVar9 = (pFont_00->info).firstCol;
      if ((uVar9 <= (uVar7 & 0xff)) && (uVar10 = (pFont_00->info).lastCol, (uVar7 & 0xff) <= uVar10)
         ) {
        uVar32 = ((uint)(byte)uVar7 - (uint)uVar9) +
                 ((uint)uVar57 - (uint)uVar8) * (((uint)uVar10 - (uint)uVar9) + 1);
        lVar59 = *(long *)(*(long *)(puVar42 + 10) + (ulong)(uVar32 >> 7) * 8);
        if (lVar59 != 0) {
          lVar59 = *(long *)(lVar59 + (ulong)(uVar32 & 0x7f) * 8);
        }
        *(long *)(puVar42 + 0xc) = lVar59;
      }
    }
  }
  pvVar43 = pFont_00->fontPrivate;
  dx = (double)zeroName.name;
  pvVar52 = sourceFont->fontPrivate;
  dy = (double)xlfdName.name;
  iVar33 = compute_xform_matrix
                     (vals,dVar97,dVar98,xform,(double *)&temp,(double *)&zeroName,
                      (double *)&xlfdName);
  if (iVar33 == 0) {
    free(pFont_00);
    if (pvVar43 == (void *)0x0) goto LAB_0011f18a;
LAB_001205e2:
    free(*(void **)((long)pvVar43 + 0x10));
    free(*(void **)((long)pvVar43 + 0x18));
    free(*(void **)((long)pvVar43 + 0x20));
    pFont_00 = *(FontPtr *)((long)pvVar43 + 0x28);
    goto LAB_0011f185;
  }
  uVar31 = (uint)(pFont_00->info).firstCol;
  iVar33 = ((pFont_00->info).lastCol - uVar31) + 1;
  uVar36 = (uint)(pFont_00->info).firstRow;
  cVar4 = pFont_00->glyph;
  uVar32 = (((pFont_00->info).lastRow - uVar36) + 1) * iVar33;
  if (0 < (int)uVar32) {
    sVar40 = 0;
    lVar59 = *(long *)((long)pvVar43 + 0x28);
    uVar37 = 0;
    do {
      lVar91 = *(long *)(lVar59 + (long)((int)uVar37 >> 7) * 8);
      if ((lVar91 != 0) &&
         (psVar94 = *(short **)(lVar91 + (ulong)(uVar37 & 0x7f) * 8), psVar94 != (short *)0x0)) {
        iVar35 = (int)psVar94[4] + (int)psVar94[3];
        iVar82 = (int)sVar40;
        if (cVar4 == '\x01') {
          sVar40 = (size_t)(uint)(iVar82 + iVar35 * (((int)psVar94[1] - (int)*psVar94) + 7 >> 3));
        }
        else if (cVar4 == '\x02') {
          sVar40 = (size_t)(iVar82 + iVar35 * (((int)psVar94[1] - (int)*psVar94) + 0xf >> 3 &
                                              0xfffffffeU));
        }
        else if (cVar4 == '\x04') {
          sVar40 = (size_t)(iVar82 + iVar35 * (((int)psVar94[1] - (int)*psVar94) + 0x1f >> 3 &
                                              0xfffffffcU));
        }
        else if (cVar4 == '\b') {
          sVar40 = (size_t)(iVar82 + iVar35 * (((int)psVar94[1] - (int)*psVar94) + 0x3f >> 3 &
                                              0xfffffff8U));
        }
      }
      uVar37 = uVar37 + 1;
    } while (uVar32 != uVar37);
    local_640 = calloc(1,sVar40);
    *(void **)((long)pvVar43 + 0x20) = local_640;
    if (local_640 == (void *)0x0) {
      __fprintf_chk(_stderr,1,"Error: Couldn\'t allocate bitmaps (%d)\n",sVar40);
      free(pFont_00);
      free(*(void **)((long)pvVar43 + 0x10));
      free(*(void **)((long)pvVar43 + 0x18));
      free(*(void **)((long)pvVar43 + 0x20));
      pFont_00 = *(FontPtr *)((long)pvVar43 + 0x28);
      if (pFont_00 != (FontPtr)0x0) {
        lVar59 = 0;
        while( true ) {
          lVar91 = lVar59 * 2;
          lVar59 = lVar59 + 1;
          free(*(void **)(&pFont_00->refcnt + lVar91));
          if ((int)(uVar32 + 0x7f) >> 7 <= (int)lVar59) break;
          pFont_00 = *(FontPtr *)((long)pvVar43 + 0x28);
        }
        pFont_00 = *(FontPtr *)((long)pvVar43 + 0x28);
      }
      goto LAB_0011f185;
    }
    local_728._0_4_ = 0;
    do {
      lVar59 = *(long *)(lVar59 + (long)((int)local_728._0_4_ >> 7) * 8);
      if ((lVar59 != 0) &&
         (psVar94 = *(short **)(lVar59 + (ulong)(local_728._0_4_ & 0x7f) * 8),
         psVar94 != (short *)0x0)) {
        uVar37 = (uint)(p_Var27->info).firstCol;
        iVar82 = ((int)local_728._0_4_ % iVar33 +
                  (((int)local_728._0_4_ / iVar33 + uVar36) - (uint)(p_Var27->info).firstRow) *
                  (((p_Var27->info).lastCol - uVar37) + 1) + uVar31) - uVar37;
        iVar35 = iVar82 + 0x7f;
        if (-1 < iVar82) {
          iVar35 = iVar82;
        }
        lVar59 = *(long *)(*(long *)((long)pvVar52 + 0x28) + (long)(iVar35 >> 7) * 8);
        if ((lVar59 != 0) &&
           (psVar17 = *(short **)(lVar59 + (long)(iVar82 % 0x80) * 8), psVar17 != (short *)0x0)) {
          *(void **)(psVar94 + 8) = local_640;
          puVar44 = &maskmsb_11883;
          if (pFont_00->bit == '\0') {
            puVar44 = &masklsb_11882;
          }
          local_618 = (int)psVar94[3];
          local_688 = psVar94[4] + local_618;
          uVar37 = (int)psVar94[1] - (int)*psVar94;
          if ((uVar37 != 0) && (local_688 != 0)) {
            iVar82 = (int)psVar17[1] - (int)*psVar17;
            iVar35 = (int)psVar17[3] + (int)psVar17[4];
            if ((iVar82 != 0) && (iVar35 != 0)) {
              cVar6 = pFont_00->glyph;
              if (cVar6 == '\x01') {
                local_62c = iVar82 + 7 >> 3;
                local_684 = (int)(uVar37 + 7) >> 3;
              }
              else if (cVar6 == '\x02') {
                local_62c = iVar82 + 0xf >> 3 & 0xfffffffe;
                local_684 = (int)(uVar37 + 0xf) >> 3 & 0xfffffffe;
              }
              else if (cVar6 == '\x04') {
                local_62c = iVar82 + 0x1f >> 3 & 0xfffffffc;
                local_684 = (int)(uVar37 + 0x1f) >> 3 & 0xfffffffc;
              }
              else {
                local_62c = 0;
                local_684 = 0;
                if (cVar6 == '\b') {
                  local_62c = iVar82 + 0x3f >> 3 & 0xfffffff8;
                  local_684 = (int)(uVar37 + 0x3f) >> 3 & 0xfffffff8;
                }
              }
              lVar59 = *(long *)(psVar17 + 8);
              if (((dVar97 <= 0.0) || (dVar98 <= 0.0)) || ((1.0 <= dVar97 && (1.0 <= dVar98)))) {
LAB_0011f980:
                local_600 = (void *)0x0;
                piVar68 = (int *)0x0;
                piVar70 = (int *)0x0;
                local_6e0 = (byte *)0x0;
              }
              else {
                dVar100 = 1.0 / dVar97;
                if (ABS(dVar100) < 4503599627370496.0) {
                  dVar100 = (double)((ulong)dVar100 & 0x8000000000000000 |
                                    (ulong)((double)(long)dVar100 +
                                           (double)(-(ulong)((double)(long)dVar100 < dVar100) &
                                                   0x3ff0000000000000)));
                }
                dVar101 = 1.0 / dVar98;
                if (ABS(dVar101) < 4503599627370496.0) {
                  dVar101 = (double)((ulong)dVar101 & 0x8000000000000000 |
                                    (ulong)((double)(long)dVar101 +
                                           (double)(-(ulong)((double)(long)dVar101 < dVar101) &
                                                   0x3ff0000000000000)));
                }
                iVar38 = iVar82 / 2;
                iVar77 = iVar35 / 2;
                if (dVar100 < (double)iVar38) {
                  iVar38 = (int)dVar100;
                }
                if (dVar101 < (double)iVar77) {
                  iVar77 = (int)dVar101;
                }
                if ((iVar38 < 2) && (iVar77 < 2)) goto LAB_0011f980;
                iVar78 = iVar82 + 1;
                iVar90 = (iVar35 + 1) * iVar78;
                local_6e0 = (byte *)malloc((long)iVar90);
                if (local_6e0 == (byte *)0x0) {
                  piVar68 = (int *)0x0;
                  piVar70 = (int *)0x0;
                  __fprintf_chk(_stderr,1,"Warning: Couldn\'t allocate character grayscale (%d)\n",
                                iVar90);
                  local_600 = (void *)0x0;
                  local_618 = (int)psVar94[3];
                }
                else {
                  sVar40 = (size_t)(int)(uVar37 * 2 + 4);
                  local_600 = calloc(sVar40,4);
                  piVar68 = (int *)((long)(int)uVar37 * 4 + 0xc);
                  if (local_600 == (void *)0x0) {
                    piVar70 = (int *)0x4;
                    __fprintf_chk(_stderr,1,
                                  "Warning: Couldn\'t allocate diffusion workspace (%ld)\n",
                                  sVar40 * 4);
                    free(local_6e0);
                    local_6e0 = (byte *)0x0;
                    local_618 = (int)psVar94[3];
                  }
                  else {
                    piVar70 = (int *)((long)local_600 + 4);
                    piVar68 = (int *)((long)piVar68 + (long)local_600);
                    if (iVar35 < 1) {
                      if ((iVar38 < 2) || (1 < iVar77)) goto LAB_00120c80;
                    }
                    else {
                      iVar58 = 0;
                      pbVar74 = local_6e0;
                      lVar91 = lVar59;
                      do {
                        uVar49 = 0;
                        if (0 < iVar82) {
                          do {
                            pbVar74[uVar49] =
                                 -((*(byte *)((long)puVar44 + (ulong)((uint)uVar49 & 7)) &
                                   *(byte *)(lVar91 + ((int)(uint)uVar49 >> 3))) != 0);
                            bVar96 = iVar82 - 1 != uVar49;
                            uVar49 = uVar49 + 1;
                          } while (bVar96);
                          pbVar74 = pbVar74 + (ulong)(iVar82 - 1) + 1;
                        }
                        iVar58 = iVar58 + 1;
                        lVar91 = lVar91 + (int)local_62c;
                        pbVar74 = pbVar74 + 1;
                      } while (iVar35 != iVar58);
                      if (iVar38 < 2) {
LAB_00120c80:
                        iVar71 = iVar77 >> 1;
                        iVar90 = iVar77 - iVar71;
                        iVar58 = iVar90 + -1;
                        if (0 < iVar82) {
                          pbVar74 = local_6e0 + iVar82;
                          lVar81 = (long)iVar82 + 1;
                          lVar64 = (long)(iVar71 * iVar78);
                          pbVar92 = local_6e0 + lVar64;
                          lVar91 = (long)((1 - iVar90) * iVar78);
                          lVar51 = ((ulong)(iVar90 - 2) + 1) * lVar81;
                          pbVar63 = local_6e0;
                          do {
                            iVar53 = 0;
                            iVar83 = 0;
                            pbVar50 = pbVar63;
                            do {
                              bVar28 = *pbVar50;
                              iVar83 = iVar83 + 1;
                              pbVar50 = pbVar50 + iVar78;
                              iVar53 = iVar53 + (uint)bVar28;
                            } while (iVar71 != iVar83);
                            if (iVar58 < 1) {
                              local_710 = 0;
                              pbVar50 = pbVar74;
                              iVar83 = iVar71;
                              local_718 = pbVar63;
                            }
                            else {
                              iVar83 = iVar71 + 1;
                              lVar84 = 0;
                              do {
                                iVar53 = iVar53 + (uint)pbVar92[lVar84];
                                iVar88 = iVar53 / iVar83;
                                iVar83 = iVar83 + 1;
                                pbVar74[lVar84] = (byte)iVar88;
                                lVar84 = lVar84 + lVar81;
                              } while (iVar71 + iVar90 != iVar83);
                              pbVar50 = pbVar74 + lVar51;
                              iVar83 = iVar71 + iVar58;
                              local_718 = pbVar92 + (lVar51 - lVar64);
                              local_710 = iVar58;
                            }
                            if (iVar83 < iVar35) {
                              lVar84 = 0;
                              iVar83 = local_710 + iVar71;
                              do {
                                bVar28 = local_718[lVar84 + lVar64];
                                iVar83 = iVar83 + 1;
                                pbVar50[lVar84] = (byte)((int)(iVar53 + (uint)bVar28) / iVar77);
                                lVar18 = lVar84 + lVar91;
                                lVar84 = lVar84 + lVar81;
                                iVar53 = (iVar53 + (uint)bVar28) - (uint)local_718[lVar18];
                              } while (iVar83 < iVar35);
                              iVar83 = local_710 + 1 + iVar71;
                              lVar84 = (ulong)(uint)(iVar35 - iVar83) + 1;
                              if (iVar35 < iVar83) {
                                lVar84 = 1;
                              }
                              local_718 = local_718 + lVar84 * lVar81;
                              pbVar50 = pbVar50 + lVar84 * lVar81;
                            }
                            lVar84 = 0;
                            iVar83 = iVar71 + iVar58;
                            do {
                              pbVar50[lVar84] = (byte)(iVar53 / iVar83);
                              lVar18 = lVar84 + lVar91;
                              lVar84 = lVar84 + lVar81;
                              iVar53 = iVar53 - (uint)local_718[lVar18];
                              bVar96 = iVar90 != iVar83;
                              iVar83 = iVar83 + -1;
                            } while (bVar96);
                            lVar84 = 0;
                            iVar83 = 0;
                            if (0 < iVar35) {
                              do {
                                iVar83 = iVar83 + 1;
                                pbVar63[lVar84] = pbVar74[lVar84];
                                lVar84 = lVar84 + lVar81;
                              } while (iVar35 != iVar83);
                            }
                            pbVar63 = pbVar63 + 1;
                            pbVar92 = pbVar92 + 1;
                          } while (local_6e0 + lVar64 + 1 + (ulong)(iVar82 - 1) != pbVar92);
                        }
                        if (iVar35 < 1) goto LAB_0011f999;
                      }
                      else {
                        iVar58 = 0;
                        iVar83 = iVar38 >> 1;
                        iVar71 = iVar38 - iVar83;
                        pbVar92 = local_6e0 + (iVar90 - iVar78);
                        uVar39 = iVar83 - 1;
                        pbVar74 = local_6e0 + (ulong)uVar39 + 1;
                        pbVar63 = local_6e0 + iVar83;
                        local_718 = local_6e0;
                        do {
                          iVar90 = 0;
                          pbVar50 = local_718;
                          do {
                            bVar28 = *pbVar50;
                            pbVar50 = pbVar50 + 1;
                            iVar90 = iVar90 + (uint)bVar28;
                          } while (pbVar74 != pbVar50);
                          if (iVar71 < 2) {
                            local_6f0._0_4_ = 0;
                            pbVar50 = pbVar92;
                            pbVar89 = local_718;
                            iVar53 = iVar83;
                          }
                          else {
                            lVar91 = (ulong)(iVar71 - 2) + 1;
                            uVar49 = 0;
                            do {
                              iVar90 = iVar90 + (uint)pbVar63[uVar49];
                              pbVar92[uVar49] = (byte)(iVar90 / (iVar83 + 1 + (int)uVar49));
                              bVar96 = iVar71 - 2 != uVar49;
                              uVar49 = uVar49 + 1;
                            } while (bVar96);
                            pbVar50 = pbVar92 + lVar91;
                            pbVar89 = local_718 + lVar91;
                            iVar53 = iVar83 + iVar71 + -1;
                            local_6f0._0_4_ = iVar71 + -1;
                          }
                          if (iVar53 < iVar82) {
                            lVar91 = 0;
                            do {
                              bVar28 = pbVar89[lVar91 + iVar83];
                              pbVar50[lVar91] = (byte)((int)(iVar90 + (uint)bVar28) / iVar38);
                              lVar51 = lVar91 + (1 - iVar71);
                              lVar91 = lVar91 + 1;
                              iVar90 = (iVar90 + (uint)bVar28) - (uint)pbVar89[lVar51];
                            } while (iVar83 + local_6f0._0_4_ + (int)lVar91 < iVar82);
                            iVar53 = local_6f0._0_4_ + 1 + iVar83;
                            lVar91 = (ulong)(uint)(iVar82 - iVar53) + 1;
                            if (iVar82 < iVar53) {
                              lVar91 = 1;
                            }
                            pbVar89 = pbVar89 + lVar91;
                            pbVar50 = pbVar50 + lVar91;
                          }
                          uVar49 = 0;
                          do {
                            pbVar50[uVar49] =
                                 (byte)(iVar90 / (int)((iVar71 + uVar39) - (int)uVar49));
                            iVar90 = iVar90 - (uint)pbVar89[uVar49 + (long)(1 - iVar71)];
                            bVar96 = uVar39 != uVar49;
                            uVar49 = uVar49 + 1;
                          } while (bVar96);
                          memmove(local_718,pbVar92,(long)iVar82);
                          iVar58 = iVar58 + 1;
                          local_718 = local_718 + iVar78;
                          pbVar74 = pbVar74 + iVar78;
                          pbVar63 = pbVar63 + iVar78;
                        } while (iVar35 != iVar58);
                        if (1 < iVar77) goto LAB_00120c80;
                      }
                      iVar78 = 0;
                      pbVar74 = local_6e0;
                      do {
                        pbVar63 = pbVar74 + (ulong)(iVar82 - 1) + 1;
                        pbVar92 = pbVar74;
                        if (0 < iVar82) {
                          do {
                            bVar28 = 0xff;
                            iVar90 = (uint)*pbVar74 * iVar38 * iVar77 * 0xc0;
                            if ((iVar90 < 0x10000) &&
                               (bVar28 = (byte)((uint)(iVar90 + 0xff) >> 8), -1 < iVar90)) {
                              bVar28 = (byte)((uint)iVar90 >> 8);
                            }
                            *pbVar74 = bVar28;
                            pbVar74 = pbVar74 + 1;
                            pbVar92 = pbVar63;
                          } while (pbVar74 != pbVar63);
                        }
                        iVar78 = iVar78 + 1;
                        pbVar74 = pbVar92 + 1;
                      } while (iVar78 < iVar35);
                    }
                  }
                }
              }
LAB_0011f999:
              iVar77 = (int)((temp.pixel_matrix[1] * 0.0 + (double)temp._0_8_) * 65536.0);
              iVar38 = (int)(-(temp.pixel_matrix[2] * 0.0 + temp.pixel_matrix[0]) * 65536.0);
              if (0 < local_688) {
                iVar78 = 0;
                iVar90 = 0;
                do {
                  dVar100 = (double)(local_618 - iVar90) - 0.5;
                  iVar58 = (int)((((double)temp._0_8_ * ((double)(int)*psVar94 + 0.5) +
                                  temp.pixel_matrix[1] * dVar100) - (double)(int)*psVar17) * 65536.0
                                );
                  iVar71 = (int)(((double)(int)psVar17[3] -
                                 (((double)(int)*psVar94 + 0.5) * temp.pixel_matrix[0] +
                                 dVar100 * temp.pixel_matrix[2])) * 65536.0);
                  if (local_6e0 == (byte *)0x0) {
                    uVar39 = 0;
                    piVar66 = piVar68;
                    if (0 < (int)uVar37) {
                      do {
                        uVar54 = iVar58 >> 0x10;
                        if (((-1 < (int)uVar54) && ((int)uVar54 < iVar82)) &&
                           ((iVar83 = iVar71 >> 0x10, -1 < iVar83 &&
                            ((iVar83 < iVar35 &&
                             ((*(byte *)(lVar59 + (int)(iVar83 * local_62c + (iVar58 >> 0x13))) &
                              *(byte *)((long)puVar44 + (ulong)(uVar54 & 7))) != 0)))))) {
                          pbVar74 = (byte *)((long)local_640 + (long)(((int)uVar39 >> 3) + iVar78));
                          *pbVar74 = *pbVar74 | *(byte *)((long)puVar44 + (ulong)(uVar39 & 7));
                        }
                        uVar39 = uVar39 + 1;
                        iVar58 = iVar58 + iVar77;
                        iVar71 = iVar71 + iVar38;
                      } while (uVar37 != uVar39);
                      local_618 = (int)psVar94[3];
                    }
                  }
                  else {
                    uVar49 = 0;
                    if (0 < (int)uVar37) {
                      do {
                        iVar83 = iVar58 >> 0x10;
                        if ((((iVar83 < 0) || (iVar82 <= iVar83)) ||
                            (iVar53 = iVar71 >> 0x10, iVar53 < 0)) || (iVar35 <= iVar53)) {
                          uVar39 = 0;
                        }
                        else {
                          uVar39 = (uint)local_6e0[iVar53 * (iVar82 + 1) + iVar83];
                        }
                        iVar83 = piVar70[uVar49];
                        iVar53 = iVar83 + 0xf;
                        if (-1 < iVar83) {
                          iVar53 = iVar83;
                        }
                        iVar83 = (iVar53 >> 4) + uVar39;
                        if (iVar83 < 0x100) {
                          if (iVar83 < 0) {
                            iVar83 = 0;
                            iVar88 = 0;
                            iVar86 = 0;
                            iVar53 = 0;
                          }
                          else {
                            if (0x7f < iVar83) {
                              iVar53 = iVar83 + -0xff;
                              iVar88 = iVar53 * 3;
                              iVar86 = iVar53 * 7;
                              iVar83 = iVar53 * 5;
                              goto LAB_0011fbe8;
                            }
                            iVar53 = -iVar83;
                            iVar86 = iVar83 * -7;
                            iVar88 = iVar83 * -3;
                            iVar83 = iVar83 * -5;
                          }
                        }
                        else {
                          iVar83 = 0;
                          iVar88 = 0;
                          iVar86 = 0;
                          iVar53 = 0;
LAB_0011fbe8:
                          pbVar74 = (byte *)((long)local_640 +
                                            (long)(((int)(uint)uVar49 >> 3) + iVar78));
                          *pbVar74 = *pbVar74 | *(byte *)((long)puVar44 + (ulong)((uint)uVar49 & 7))
                          ;
                        }
                        piVar70[uVar49 + 1] = piVar70[uVar49 + 1] + iVar86;
                        iVar58 = iVar58 + iVar77;
                        iVar71 = iVar71 + iVar38;
                        piVar68[uVar49 - 1] = piVar68[uVar49 - 1] + iVar88;
                        piVar68[uVar49] = piVar68[uVar49] + iVar83;
                        piVar68[uVar49 + 1] = iVar53;
                        bVar96 = uVar37 - 1 != uVar49;
                        uVar49 = uVar49 + 1;
                      } while (bVar96);
                    }
                    *piVar68 = *piVar68 + piVar68[-1];
                    piVar68[(long)(int)uVar37 + -2] =
                         piVar68[(long)(int)uVar37 + -2] + piVar70[(int)uVar37];
                    piVar68[(long)(int)uVar37 + -1] =
                         piVar68[(long)(int)uVar37 + -1] + piVar68[(int)uVar37];
                    piVar68[(int)uVar37] = 0;
                    *piVar70 = 0;
                    piVar70[-1] = 0;
                    local_618 = (int)psVar94[3];
                    piVar66 = piVar70;
                    piVar70 = piVar68;
                  }
                  iVar90 = iVar90 + 1;
                  iVar78 = iVar78 + local_684;
                  piVar68 = piVar66;
                } while (local_688 != iVar90);
              }
              local_688 = psVar94[4] + local_618;
              if (local_6e0 != (byte *)0x0) {
                free(local_6e0);
                free(local_600);
              }
            }
          }
          if (cVar4 == '\x01') {
            local_640 = (void *)((long)local_640 +
                                (long)((((int)psVar94[1] - (int)*psVar94) + 7 >> 3) * local_688));
          }
          else if (cVar4 == '\x02') {
            local_640 = (void *)((long)local_640 +
                                (long)(int)((((int)psVar94[1] - (int)*psVar94) + 0xf >> 3 &
                                            0xfffffffeU) * local_688));
          }
          else if (cVar4 == '\x04') {
            local_640 = (void *)((long)local_640 +
                                (long)(int)((((int)psVar94[1] - (int)*psVar94) + 0x1f >> 3 &
                                            0xfffffffcU) * local_688));
          }
          else if (cVar4 == '\b') {
            local_640 = (void *)((long)local_640 +
                                (long)(int)((((int)psVar94[1] - (int)*psVar94) + 0x3f >> 3 &
                                            0xfffffff8U) * local_688));
          }
        }
      }
      local_728._0_4_ = local_728._0_4_ + 1;
      if (uVar32 == local_728._0_4_) goto LAB_0011fe78;
      lVar59 = *(long *)((long)pvVar43 + 0x28);
    } while( true );
  }
  pvVar52 = calloc(1,0);
  *(void **)((long)pvVar43 + 0x20) = pvVar52;
  if (pvVar52 == (void *)0x0) {
    __fprintf_chk(_stderr,1,"Error: Couldn\'t allocate bitmaps (%d)\n",0);
    free(pFont_00);
    goto LAB_001205e2;
  }
LAB_0011fe78:
  __strcpy_chk(fontName,(local_720->name).name,0x400);
  FontParseXLFDName(fontName,vals,3);
  p_Var27 = sourceFont;
  dVar101 = sdy;
  dVar98 = dy;
  dVar100 = sdx;
  dVar97 = dx;
  if (bitscaleGeneration != serverGeneration) {
    pfVar95 = fontNamePropTable;
    do {
      pcVar47 = pfVar95->name;
      pfVar93 = pfVar95 + 1;
      sVar40 = strlen(pcVar47);
      AVar45 = MakeAtom(pcVar47,(uint)sVar40,1);
      pfVar95->atom = AVar45;
      pfVar95 = pfVar93;
    } while (pfVar93 != (fontProp *)ink_mask_lsb);
    pfVar95 = fontPropTable;
    do {
      pcVar47 = pfVar95->name;
      pfVar93 = pfVar95 + 1;
      sVar40 = strlen(pcVar47);
      AVar45 = MakeAtom(pcVar47,(uint)sVar40,1);
      pfVar95->atom = AVar45;
      pfVar95 = pfVar93;
    } while (pfVar93 != fontNamePropTable);
    pfVar95 = rawFontPropTable;
    do {
      pcVar47 = pfVar95->name;
      pfVar93 = pfVar95 + 1;
      sVar40 = strlen(pcVar47);
      AVar45 = MakeAtom(pcVar47,(uint)sVar40,1);
      pfVar95->atom = AVar45;
      pfVar95 = pfVar93;
    } while (pfVar93 != (fontProp *)&DAT_0013eed8);
    bitscaleGeneration = serverGeneration;
  }
  p_Var46 = (FontPropPtr)malloc(0x460);
  if (p_Var46 == (FontPropPtr)0x0) {
    __fprintf_chk(_stderr,1,"Error: Couldn\'t allocate font properties (%ld*%d)\n",0x10,0x46);
LAB_001210ad:
    if (sourceFont->refcnt == 0) {
      FontFileCloseFont((FontPathElementPtr)0x0,sourceFont);
    }
    (pFont_00->info).props = p_Var46;
    (pFont_00->info).nprops = 1;
    (pFont_00->info).isStringProp = (char *)0x0;
    bitmapUnloadScalable(pFont_00);
    local_738 = 0x50;
    goto LAB_0011e2df;
  }
  pcVar47 = (char *)malloc(0x46);
  if (pcVar47 == (char *)0x0) {
    __fprintf_chk(_stderr,1,"Error: Couldn\'t allocate isStringProp (%d)\n",0x46);
    free(p_Var46);
    goto LAB_001210ad;
  }
  puVar60 = (uint *)0x0;
  pfVar95 = fontNamePropTable;
  pcVar67 = pcVar47;
  p_Var69 = p_Var46;
  puVar48 = (uint *)fontName;
  do {
    if (*(char *)puVar48 != '\0') {
      puVar60 = (uint *)((long)puVar48 + 1);
      puVar48 = (uint *)strchr((char *)puVar60,0x2d);
      if (puVar48 == (uint *)0x0) {
        sVar40 = strlen((char *)puVar60);
        puVar48 = (uint *)((long)puVar60 + sVar40);
      }
    }
    *pcVar67 = '\0';
    if (false) goto switchD_00120067_caseD_7;
    puVar72 = puVar48;
    switch(pfVar95->type) {
    case truncate_atom:
      cVar4 = *(char *)puVar60;
      puVar73 = puVar60;
      while ((puVar72 = puVar48, cVar4 != '\0' && (puVar72 = puVar73, cVar4 != '['))) {
        pcVar80 = (char *)((long)puVar73 + 1);
        puVar73 = (uint *)((long)puVar73 + 1);
        cVar4 = *pcVar80;
      }
    case atom:
      AVar45 = MakeAtom((char *)puVar60,(int)puVar72 - (int)puVar60,1);
      *pcVar67 = '\x01';
      p_Var69->value = AVar45;
      break;
    case pixel_size:
      dVar104 = vals->pixel_matrix[3];
      if (dVar104 < 0.0) {
        lVar59 = (long)(dVar104 - 0.5);
      }
      else {
        lVar59 = (long)(dVar104 + 0.5);
      }
      goto LAB_001202c8;
    case point_size:
      dVar104 = vals->point_matrix[3] * 10.0;
      if (dVar104 < 0.0) {
        lVar59 = (long)(dVar104 - 0.5);
      }
      else {
        lVar59 = (long)(dVar104 + 0.5);
      }
      goto LAB_001202c8;
    case resolution_x:
      p_Var69->value = (long)vals->x;
      break;
    case resolution_y:
      p_Var69->value = (long)vals->y;
      break;
    case average_width:
      p_Var69->value = (long)vals->width;
      break;
    case fontname:
      puVar72 = (uint *)fontName;
      do {
        puVar73 = puVar72;
        uVar31 = *puVar73 + 0xfefefeff & ~*puVar73;
        uVar32 = uVar31 & 0x80808080;
        puVar72 = puVar73 + 1;
      } while (uVar32 == 0);
      bVar96 = (uVar31 & 0x8080) == 0;
      if (bVar96) {
        uVar32 = uVar32 >> 0x10;
      }
      if (bVar96) {
        puVar72 = (uint *)((long)puVar73 + 6);
      }
      AVar45 = MakeAtom(fontName,(((int)puVar72 + -3) - (uint)CARRY1((byte)uVar32,(byte)uVar32)) -
                                 (int)fontName,1);
      *pcVar67 = '\x01';
      p_Var69->value = AVar45;
      break;
    case raw_ascent:
      p_Var69->value = (long)((double)(int)(p_Var27->info).fontAscent * dVar101);
      break;
    case raw_descent:
      p_Var69->value = (long)((double)(int)(p_Var27->info).fontDescent * dVar101);
      break;
    case raw_pixelsize:
      p_Var69->value = 1000;
      break;
    case raw_pointsize:
      p_Var69->value = (long)(72270.0 / (double)vals->y + 0.5);
      break;
    case raw_average_width:
      lVar59 = local_660;
LAB_001202c8:
      p_Var69->value = lVar59;
    }
switchD_00120067_caseD_7:
    pAVar2 = &pfVar95->atom;
    pfVar95 = pfVar95 + 1;
    pcVar67 = pcVar67 + 1;
    p_Var69->name = *pAVar2;
    p_Var69 = p_Var69 + 1;
  } while (pfVar95 != (fontProp *)ink_mask_lsb);
  p_Var69 = p_Var46 + 0x14;
  pcVar80 = (p_Var27->info).isStringProp;
  p_Var62 = (p_Var27->info).props;
  pcVar67 = pcVar47 + 0x14;
  iVar33 = (p_Var27->info).nprops;
  iVar35 = 0x14;
  if (iVar33 != 0) {
    iVar35 = 0;
    dVar104 = 0.0;
    p_Var87 = p_Var62 + (ulong)(iVar33 - 1) + 1;
    do {
      AVar45 = p_Var62->name;
      pfVar95 = fontPropTable;
      do {
        if (pfVar95->atom == AVar45) {
          sVar12 = pfVar95->type;
          if (sVar12 == scaledY) {
            dVar104 = (double)p_Var62->value * dVar98;
            if (dVar104 < 0.0) {
              dVar104 = dVar104 - 0.5;
            }
            else {
              dVar104 = dVar104 + 0.5;
            }
            p_Var69->value = (long)dVar104;
            AVar45 = p_Var62->name;
            dVar104 = dVar101;
          }
          else {
            if (sVar12 == unscaled) {
              iVar35 = iVar35 + 1;
              p_Var69->value = p_Var62->value;
              p_Var69->name = p_Var62->name;
              *pcVar67 = *pcVar80;
              p_Var69 = p_Var69 + 1;
              pcVar67 = pcVar67 + 1;
              break;
            }
            if (sVar12 == scaledX) {
              dVar104 = (double)p_Var62->value * dVar97;
              if (dVar104 < 0.0) {
                dVar104 = dVar104 - 0.5;
              }
              else {
                dVar104 = dVar104 + 0.5;
              }
              p_Var69->value = (long)dVar104;
              AVar45 = p_Var62->name;
              dVar104 = dVar100;
            }
          }
          p_Var69->name = AVar45;
          dVar109 = (double)p_Var62->value * dVar104;
          if (dVar109 < 0.0) {
            dVar109 = dVar109 - 0.5;
          }
          else {
            dVar109 = dVar109 + 0.5;
          }
          p_Var69[1].value = (long)dVar109;
          iVar35 = iVar35 + 2;
          p_Var69[1].name = (long)pfVar95[-0x15].name;
          *pcVar67 = *pcVar80;
          pcVar67[1] = *pcVar80;
          p_Var69 = p_Var69 + 2;
          pcVar67 = pcVar67 + 2;
          break;
        }
        pfVar95 = pfVar95 + 1;
      } while (pfVar95 != fontNamePropTable);
      p_Var62 = p_Var62 + 1;
      pcVar80 = pcVar80 + 1;
    } while (p_Var62 != p_Var87);
    iVar35 = iVar35 + 0x14;
  }
  if (sourceFont->refcnt == 0) {
    FontFileCloseFont((FontPathElementPtr)0x0,sourceFont);
  }
  (pFont_00->info).nprops = iVar35;
  (pFont_00->info).props = p_Var46;
  (pFont_00->info).isStringProp = pcVar47;
  *pFont = pFont_00;
  local_738 = 0x55;
  goto LAB_0011e2df;
LAB_00120717:
  __s = (p_Var41->u).scalable.renderer;
  local_688 = local_688 + -1;
  xlfdName.name = (char *)__s;
  sVar40 = strlen((char *)__s);
  xlfdName.length = (short)sVar40;
  iVar35 = FontFileCountDashes((char *)__s,(int)xlfdName.length);
  xlfdName.ndashes = (short)iVar35;
  goto LAB_0011e09b;
}



int BitmapGetInfoScalable
              (FontPathElementPtr fpe,FontInfoPtr pFontInfo,FontEntryPtr entry,FontNamePtr fontName,
              char *fileName,FontScalablePtr vals)

{
  undefined8 uVar1;
  FontPropPtr p_Var2;
  ushort uVar3;
  ushort uVar4;
  ushort uVar5;
  ushort uVar6;
  undefined2 uVar7;
  short sVar8;
  short sVar9;
  INT16 IVar10;
  INT16 IVar11;
  INT16 IVar12;
  CARD16 CVar13;
  INT16 IVar14;
  INT16 IVar15;
  INT16 IVar16;
  int iVar17;
  int iVar18;
  long in_FS_OFFSET;
  FontPtr pfont;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  iVar18 = BitmapOpenScalable(fpe,&pfont,0,entry,fileName,vals,0,0,(FontPtr)0x0);
  if (iVar18 == 0x55) {
    uVar3 = (pfont->info).lastCol;
    uVar4 = (pfont->info).firstRow;
    uVar5 = (pfont->info).lastRow;
    uVar6 = (pfont->info).defaultCh;
    uVar7 = *(undefined2 *)&(pfont->info).field_0xa;
    sVar8 = (pfont->info).maxOverlap;
    sVar9 = (pfont->info).pad;
    pFontInfo->firstCol = (pfont->info).firstCol;
    pFontInfo->lastCol = uVar3;
    pFontInfo->firstRow = uVar4;
    pFontInfo->lastRow = uVar5;
    pFontInfo->defaultCh = uVar6;
    *(undefined2 *)&pFontInfo->field_0xa = uVar7;
    pFontInfo->maxOverlap = sVar8;
    pFontInfo->pad = sVar9;
    IVar10 = (pfont->info).maxbounds.rightSideBearing;
    IVar11 = (pfont->info).maxbounds.characterWidth;
    IVar12 = (pfont->info).maxbounds.ascent;
    uVar1 = *(undefined8 *)&(pfont->info).maxbounds.descent;
    (pFontInfo->maxbounds).leftSideBearing = (pfont->info).maxbounds.leftSideBearing;
    (pFontInfo->maxbounds).rightSideBearing = IVar10;
    (pFontInfo->maxbounds).characterWidth = IVar11;
    (pFontInfo->maxbounds).ascent = IVar12;
    *(undefined8 *)&(pFontInfo->maxbounds).descent = uVar1;
    IVar10 = (pfont->info).minbounds.ascent;
    IVar11 = (pfont->info).minbounds.descent;
    CVar13 = (pfont->info).minbounds.attributes;
    IVar12 = (pfont->info).ink_maxbounds.leftSideBearing;
    IVar14 = (pfont->info).ink_maxbounds.rightSideBearing;
    IVar15 = (pfont->info).ink_maxbounds.characterWidth;
    IVar16 = (pfont->info).ink_maxbounds.ascent;
    (pFontInfo->minbounds).characterWidth = (pfont->info).minbounds.characterWidth;
    (pFontInfo->minbounds).ascent = IVar10;
    (pFontInfo->minbounds).descent = IVar11;
    (pFontInfo->minbounds).attributes = CVar13;
    (pFontInfo->ink_maxbounds).leftSideBearing = IVar12;
    (pFontInfo->ink_maxbounds).rightSideBearing = IVar14;
    (pFontInfo->ink_maxbounds).characterWidth = IVar15;
    (pFontInfo->ink_maxbounds).ascent = IVar16;
    IVar10 = (pfont->info).ink_minbounds.characterWidth;
    IVar11 = (pfont->info).ink_minbounds.ascent;
    IVar12 = (pfont->info).ink_minbounds.descent;
    CVar13 = (pfont->info).ink_minbounds.attributes;
    *(undefined8 *)&(pFontInfo->ink_maxbounds).descent =
         *(undefined8 *)&(pfont->info).ink_maxbounds.descent;
    (pFontInfo->ink_minbounds).characterWidth = IVar10;
    (pFontInfo->ink_minbounds).ascent = IVar11;
    (pFontInfo->ink_minbounds).descent = IVar12;
    (pFontInfo->ink_minbounds).attributes = CVar13;
    sVar8 = (pfont->info).fontDescent;
    iVar17 = (pfont->info).nprops;
    p_Var2 = (pfont->info).props;
    pFontInfo->fontAscent = (pfont->info).fontAscent;
    pFontInfo->fontDescent = sVar8;
    pFontInfo->nprops = iVar17;
    pFontInfo->props = p_Var2;
    pFontInfo->isStringProp = (pfont->info).isStringProp;
    (pfont->info).nprops = 0;
    (pfont->info).props = (FontPropPtr)0x0;
    (pfont->info).isStringProp = (char *)0x0;
    (*pfont->unload_font)(pfont);
  }
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar18;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void FontCharInkMetrics(FontPtr pFont,CharInfoPtr pCI,xCharInfo *pInk)

{
  int iVar1;
  char cVar2;
  byte bVar3;
  short sVar4;
  int iVar5;
  char *pcVar6;
  char *pcVar7;
  int iVar8;
  byte *pbVar9;
  short sVar10;
  uint uVar11;
  int iVar12;
  int iVar13;
  uint uVar14;
  byte bVar15;
  short sVar16;
  uint uVar17;
  byte *pbVar18;
  byte *local_40;
  uint local_38;
  
  local_40 = ink_mask_msb;
  if ((pFont->bit != '\x01') && (local_40 = (byte *)0x0, pFont->bit == '\0')) {
    local_40 = ink_mask_lsb;
  }
  pInk->characterWidth = (pCI->metrics).characterWidth;
  pInk->attributes = (pCI->metrics).attributes;
  sVar4 = (pCI->metrics).leftSideBearing;
  sVar10 = (pCI->metrics).ascent;
  sVar16 = (pCI->metrics).descent;
  iVar12 = (int)(pCI->metrics).rightSideBearing - (int)sVar4;
  cVar2 = pFont->glyph;
  uVar17 = iVar12 + 7 >> 3;
  if (cVar2 == '\x01') {
    iVar13 = 0;
    local_38 = uVar17;
  }
  else if (cVar2 == '\x02') {
    local_38 = iVar12 + 0xf >> 3 & 0xfffffffe;
    iVar13 = local_38 - uVar17;
  }
  else if (cVar2 == '\x04') {
    local_38 = iVar12 + 0x1f >> 3 & 0xfffffffc;
    iVar13 = local_38 - uVar17;
  }
  else if (cVar2 == '\b') {
    local_38 = iVar12 + 0x3f >> 3 & 0xfffffff8;
    iVar13 = local_38 - uVar17;
  }
  else {
    local_38 = 0;
    iVar13 = -uVar17;
  }
  iVar1 = sVar10 + -1 + (int)sVar16;
  pcVar7 = pCI->bits;
  uVar14 = uVar17 - 1;
  iVar8 = iVar1;
  if (-1 < iVar1) {
    do {
      pcVar6 = pcVar7;
      while (-1 < (int)((uVar14 + (int)pcVar7) - (int)pcVar6)) {
        cVar2 = *pcVar6;
        pcVar6 = pcVar6 + 1;
        if (cVar2 != '\0') {
          pInk->ascent = ((short)iVar8 - sVar16) + 1;
          pcVar7 = pCI->bits + (long)(int)(local_38 * iVar1) + (long)(int)uVar17;
          iVar8 = iVar1;
          goto LAB_00121443;
        }
      }
      iVar8 = iVar8 + -1;
      pcVar7 = pcVar6 + iVar13;
    } while (iVar8 != -1);
  }
  pInk->ascent = 0;
  pInk->descent = 0;
  pInk->leftSideBearing = sVar4;
  pInk->rightSideBearing = sVar4;
  return;
LAB_00121443:
  do {
    iVar5 = (int)pcVar7;
    while (-1 < (int)((uVar14 - iVar5) + (int)pcVar7)) {
      pcVar7 = pcVar7 + -1;
      if (*pcVar7 != '\0') goto LAB_00121470;
    }
    iVar8 = iVar8 + -1;
    pcVar7 = pcVar7 + -(long)iVar13;
  } while (iVar8 != -1);
LAB_00121470:
  pInk->descent = ((short)iVar8 - sVar10) + 1;
  if ((int)uVar17 < 1) {
    iVar13 = 0;
    iVar8 = 8;
    sVar10 = 0;
  }
  else {
    pbVar18 = (byte *)pCI->bits;
    iVar13 = 0;
    uVar11 = 0;
    iVar8 = 8;
    do {
      bVar15 = 0;
      pbVar9 = pbVar18;
      iVar5 = iVar1;
      do {
        iVar5 = iVar5 + -1;
        bVar15 = bVar15 | *pbVar9;
        pbVar9 = pbVar9 + (int)local_38;
      } while (iVar5 != -1);
      if (bVar15 != 0) {
        iVar5 = iVar12 + uVar11 * -8;
        pbVar9 = local_40;
        iVar13 = iVar8;
        if (uVar11 == uVar14) {
          iVar13 = iVar5;
          iVar8 = iVar5;
        }
        while (iVar13 = iVar13 + -1, -1 < iVar13) {
          bVar3 = *pbVar9;
          pbVar9 = pbVar9 + 1;
          if ((bVar3 & bVar15) != 0) {
            sVar10 = (short)(uVar11 << 3);
            goto LAB_001214de;
          }
        }
      }
      uVar11 = uVar11 + 1;
      pbVar18 = pbVar18 + 1;
    } while (uVar17 != uVar11);
    sVar10 = (short)uVar17 * 8;
  }
LAB_001214de:
  sVar16 = (short)iVar13;
  iVar12 = iVar12 + uVar14 * -8;
  pInk->leftSideBearing = ((short)iVar8 + sVar4 + -1 + sVar10) - sVar16;
  if (-1 < (int)uVar14) {
    pbVar18 = (byte *)(pCI->bits + (int)uVar14);
    do {
      bVar15 = 0;
      pbVar9 = pbVar18;
      iVar8 = iVar1;
      do {
        iVar8 = iVar8 + -1;
        bVar15 = bVar15 | *pbVar9;
        pbVar9 = pbVar9 + (int)local_38;
      } while (iVar8 != -1);
      if (bVar15 != 0) {
        pbVar9 = local_40 + iVar12;
        iVar13 = iVar12;
        while (iVar13 = iVar13 + -1, -1 < iVar13) {
          pbVar9 = pbVar9 + -1;
          if ((*pbVar9 & bVar15) != 0) goto LAB_00121542;
        }
      }
      uVar14 = uVar14 - 1;
      pbVar18 = pbVar18 + -1;
      iVar12 = 8;
    } while (uVar14 != 0xffffffff);
LAB_00121542:
    sVar16 = (short)iVar13;
  }
  pInk->rightSideBearing = sVar4 + 1 + sVar16 + (short)uVar14 * 8;
  return;
}



void FontCharReshape(FontPtr pFont,CharInfoPtr pSrc,CharInfoPtr pDst)

{
  byte *pbVar1;
  char cVar2;
  byte bVar3;
  int iVar4;
  int iVar5;
  void *pvVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  size_t __n;
  char *pcVar10;
  short sVar11;
  uint uVar12;
  short sVar13;
  int iVar14;
  uint uVar15;
  short sVar16;
  int iVar17;
  
  pcVar10 = pSrc->bits;
  iVar4 = (int)(pDst->metrics).rightSideBearing - (int)(pDst->metrics).leftSideBearing;
  iVar5 = (int)(pDst->metrics).ascent + (int)(pDst->metrics).descent;
  cVar2 = pFont->glyph;
  if (cVar2 == '\x01') {
    uVar12 = iVar4 + 7 >> 3;
    uVar15 = ((int)(pSrc->metrics).rightSideBearing - (int)(pSrc->metrics).leftSideBearing) + 7 >> 3
    ;
    __n = (size_t)(int)(iVar5 * uVar12);
  }
  else if (cVar2 == '\x02') {
    uVar12 = iVar4 + 0xf >> 3 & 0xfffffffe;
    uVar15 = ((int)(pSrc->metrics).rightSideBearing - (int)(pSrc->metrics).leftSideBearing) + 0xf >>
             3 & 0xfffffffe;
    __n = (size_t)(int)(iVar5 * uVar12);
  }
  else if (cVar2 == '\x04') {
    uVar12 = iVar4 + 0x1f >> 3 & 0xfffffffc;
    uVar15 = ((int)(pSrc->metrics).rightSideBearing - (int)(pSrc->metrics).leftSideBearing) + 0x1f
             >> 3 & 0xfffffffc;
    __n = (size_t)(int)(iVar5 * uVar12);
  }
  else if (cVar2 == '\b') {
    uVar12 = iVar4 + 0x3f >> 3 & 0xfffffff8;
    uVar15 = ((int)(pSrc->metrics).rightSideBearing - (int)(pSrc->metrics).leftSideBearing) + 0x3f
             >> 3 & 0xfffffff8;
    __n = (size_t)(int)(iVar5 * uVar12);
  }
  else {
    __n = 0;
    uVar12 = 0;
    uVar15 = 0;
  }
  pvVar6 = memset(pDst->bits,0,__n);
  sVar16 = (pDst->metrics).ascent;
  iVar4 = (int)sVar16;
  sVar13 = (pSrc->metrics).ascent;
  iVar5 = (int)sVar13;
  if (sVar13 < sVar16) {
    pvVar6 = (void *)((long)pvVar6 + (long)(int)((iVar4 - iVar5) * uVar12));
    iVar4 = iVar5;
  }
  else {
    pcVar10 = pcVar10 + (int)((iVar5 - iVar4) * uVar15);
  }
  iVar4 = -iVar4;
  sVar16 = (pSrc->metrics).descent;
  sVar13 = (pSrc->metrics).leftSideBearing;
  sVar11 = (pSrc->metrics).rightSideBearing;
  if ((pDst->metrics).descent <= sVar16) {
    sVar16 = (pDst->metrics).descent;
  }
  if (sVar13 <= (pDst->metrics).leftSideBearing) {
    sVar13 = (pDst->metrics).leftSideBearing;
  }
  if ((pDst->metrics).rightSideBearing <= sVar11) {
    sVar11 = (pDst->metrics).rightSideBearing;
  }
  iVar17 = (int)sVar16;
  iVar14 = (int)sVar13;
  iVar5 = (int)sVar11;
  if (pFont->bit == '\x01') {
    if (iVar4 < iVar17) {
      do {
        iVar9 = iVar14;
        if (iVar14 < iVar5) {
          do {
            iVar7 = iVar9 - (pSrc->metrics).leftSideBearing;
            iVar8 = iVar7 + 7;
            if (-1 < iVar7) {
              iVar8 = iVar7;
            }
            if (((byte)pcVar10[iVar8 >> 3] >> (7U - iVar7 % 8 & 0x1f) & 1) != 0) {
              iVar7 = iVar9 - (pDst->metrics).leftSideBearing;
              iVar8 = iVar7 + 7;
              if (-1 < iVar7) {
                iVar8 = iVar7;
              }
              bVar3 = (byte)(iVar7 >> 0x1f);
              pbVar1 = (byte *)((long)pvVar6 + (long)(iVar8 >> 3));
              *pbVar1 = *pbVar1 | (byte)(1 << (7 - (((char)iVar7 + (bVar3 >> 5) & 7) - (bVar3 >> 5))
                                              & 0x1f));
            }
            iVar9 = iVar9 + 1;
          } while (iVar5 != iVar9);
        }
        iVar4 = iVar4 + 1;
        pcVar10 = pcVar10 + (int)uVar15;
        pvVar6 = (void *)((long)pvVar6 + (long)(int)uVar12);
      } while (iVar17 != iVar4);
      return;
    }
  }
  else if (iVar4 < iVar17) {
    do {
      iVar9 = iVar14;
      if (iVar14 < iVar5) {
        do {
          iVar7 = iVar9 - (pSrc->metrics).leftSideBearing;
          iVar8 = iVar7 + 7;
          if (-1 < iVar7) {
            iVar8 = iVar7;
          }
          if (((byte)pcVar10[iVar8 >> 3] >> (iVar7 % 8 & 0x1fU) & 1) != 0) {
            iVar7 = iVar9 - (pDst->metrics).leftSideBearing;
            iVar8 = iVar7 + 7;
            if (-1 < iVar7) {
              iVar8 = iVar7;
            }
            bVar3 = (byte)(iVar7 >> 0x1f);
            pbVar1 = (byte *)((long)pvVar6 + (long)(iVar8 >> 3));
            *pbVar1 = *pbVar1 | (byte)(1 << (((char)iVar7 + (bVar3 >> 5) & 7) - (bVar3 >> 5) & 0x1f)
                                      );
          }
          iVar9 = iVar9 + 1;
        } while (iVar5 != iVar9);
      }
      iVar4 = iVar4 + 1;
      pcVar10 = pcVar10 + (int)uVar15;
      pvVar6 = (void *)((long)pvVar6 + (long)(int)uVar12);
    } while (iVar17 != iVar4);
  }
  return;
}



int pcfGetLSB32(FontFilePtr file)

{
  byte bVar1;
  byte *pbVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  
  iVar7 = file->left;
  iVar6 = iVar7 + -1;
  file->left = iVar6;
  if (iVar7 == 0) {
    uVar3 = (*file->input)(file);
    file->eof = uVar3;
    iVar6 = file->left;
    iVar7 = iVar6 + -1;
    file->left = iVar7;
  }
  else {
    pbVar2 = file->bufp;
    file->bufp = pbVar2 + 1;
    iVar7 = iVar7 + -2;
    uVar3 = (uint)*pbVar2;
    file->left = iVar7;
  }
  if (iVar6 == 0) {
    uVar4 = (*file->input)(file);
    iVar7 = file->left;
    file->eof = uVar4;
    iVar6 = iVar7 + -1;
    file->left = iVar6;
  }
  else {
    pbVar2 = file->bufp;
    file->bufp = pbVar2 + 1;
    bVar1 = *pbVar2;
    iVar6 = iVar7 + -1;
    file->left = iVar6;
    uVar4 = (uint)bVar1;
  }
  if (iVar7 == 0) {
    uVar5 = (*file->input)(file);
    iVar6 = file->left;
    file->eof = uVar5;
    file->left = iVar6 + -1;
  }
  else {
    pbVar2 = file->bufp;
    file->bufp = pbVar2 + 1;
    uVar5 = (uint)*pbVar2;
    file->left = iVar6 + -1;
  }
  uVar3 = uVar3 | uVar4 << 8 | uVar5 << 0x10;
  if (iVar6 == 0) {
    iVar6 = (*file->input)(file);
    position = position + 4;
    file->eof = iVar6;
    return iVar6 << 0x18 | uVar3;
  }
  pbVar2 = file->bufp;
  position = position + 4;
  file->bufp = pbVar2 + 1;
  return (uint)*pbVar2 << 0x18 | uVar3;
}



int pcfGetINT32(FontFilePtr file,CARD32 format)

{
  byte bVar1;
  byte *pbVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  
  iVar6 = file->left;
  iVar7 = iVar6 + -1;
  file->left = iVar7;
  if ((format & 4) != 0) {
    if (iVar6 == 0) {
      uVar3 = (*file->input)(file);
      iVar7 = file->left;
      file->eof = uVar3;
      iVar6 = iVar7 + -1;
      file->left = iVar6;
    }
    else {
      pbVar2 = file->bufp;
      file->bufp = pbVar2 + 1;
      bVar1 = *pbVar2;
      iVar6 = iVar6 + -2;
      file->left = iVar6;
      uVar3 = (uint)bVar1;
    }
    if (iVar7 == 0) {
      uVar5 = (*file->input)(file);
      iVar6 = file->left;
      file->eof = uVar5;
      iVar7 = iVar6 + -1;
      file->left = iVar7;
    }
    else {
      pbVar2 = file->bufp;
      file->bufp = pbVar2 + 1;
      bVar1 = *pbVar2;
      iVar7 = iVar6 + -1;
      file->left = iVar7;
      uVar5 = (uint)bVar1;
    }
    if (iVar6 == 0) {
      uVar4 = (*file->input)(file);
      iVar7 = file->left;
      file->eof = uVar4;
      file->left = iVar7 + -1;
    }
    else {
      pbVar2 = file->bufp;
      file->bufp = pbVar2 + 1;
      uVar4 = (uint)*pbVar2;
      file->left = iVar7 + -1;
    }
    uVar3 = uVar3 << 0x18 | uVar5 << 0x10 | uVar4 << 8;
    if (iVar7 == 0) {
      uVar5 = (*file->input)(file);
      position = position + 4;
      file->eof = uVar5;
      return uVar5 | uVar3;
    }
    pbVar2 = file->bufp;
    position = position + 4;
    file->bufp = pbVar2 + 1;
    return *pbVar2 | uVar3;
  }
  if (iVar6 == 0) {
    uVar3 = (*file->input)(file);
    iVar7 = file->left;
    file->eof = uVar3;
    iVar6 = iVar7 + -1;
    file->left = iVar6;
  }
  else {
    pbVar2 = file->bufp;
    file->bufp = pbVar2 + 1;
    iVar6 = iVar6 + -2;
    uVar3 = (uint)*pbVar2;
    file->left = iVar6;
  }
  if (iVar7 == 0) {
    uVar5 = (*file->input)(file);
    iVar6 = file->left;
    file->eof = uVar5;
    iVar7 = iVar6 + -1;
    file->left = iVar7;
  }
  else {
    pbVar2 = file->bufp;
    file->bufp = pbVar2 + 1;
    bVar1 = *pbVar2;
    iVar7 = iVar6 + -1;
    file->left = iVar7;
    uVar5 = (uint)bVar1;
  }
  if (iVar6 == 0) {
    uVar4 = (*file->input)(file);
    iVar7 = file->left;
    file->eof = uVar4;
    file->left = iVar7 + -1;
  }
  else {
    pbVar2 = file->bufp;
    file->bufp = pbVar2 + 1;
    uVar4 = (uint)*pbVar2;
    file->left = iVar7 + -1;
  }
  uVar3 = uVar3 | uVar5 << 8 | uVar4 << 0x10;
  if (iVar7 == 0) {
    iVar7 = (*file->input)(file);
    position = position + 4;
    file->eof = iVar7;
    return iVar7 << 0x18 | uVar3;
  }
  pbVar2 = file->bufp;
  position = position + 4;
  file->bufp = pbVar2 + 1;
  return (uint)*pbVar2 << 0x18 | uVar3;
}



int pcfGetINT16(FontFilePtr file,CARD32 format)

{
  int iVar1;
  byte *pbVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  
  iVar1 = file->left;
  iVar4 = iVar1 + -1;
  file->left = iVar4;
  if ((format & 4) == 0) {
    if (iVar1 == 0) {
      uVar3 = (*file->input)(file);
      iVar4 = file->left;
      file->eof = uVar3;
      file->left = iVar4 + -1;
    }
    else {
      pbVar2 = file->bufp;
      file->bufp = pbVar2 + 1;
      uVar3 = (uint)*pbVar2;
      file->left = iVar1 + -2;
    }
    if (iVar4 != 0) {
      pbVar2 = file->bufp;
      position = position + 2;
      file->bufp = pbVar2 + 1;
      return (uint)*pbVar2 << 8 | uVar3;
    }
    iVar4 = (*file->input)(file);
    position = position + 2;
    file->eof = iVar4;
    return iVar4 << 8 | uVar3;
  }
  if (iVar1 == 0) {
    uVar3 = (*file->input)(file);
    iVar4 = file->left;
    file->eof = uVar3;
    file->left = iVar4 + -1;
  }
  else {
    pbVar2 = file->bufp;
    file->bufp = pbVar2 + 1;
    uVar3 = (uint)*pbVar2;
    file->left = iVar1 + -2;
  }
  if (iVar4 != 0) {
    pbVar2 = file->bufp;
    position = position + 2;
    file->bufp = pbVar2 + 1;
    return (uint)*pbVar2 | uVar3 << 8;
  }
  uVar5 = (*file->input)(file);
  position = position + 2;
  file->eof = uVar5;
  return uVar5 | uVar3 << 8;
}



Bool pcfGetMetric(FontFilePtr file,CARD32 format,xCharInfo *metric)

{
  int iVar1;
  
  iVar1 = pcfGetINT16(file,format);
  metric->leftSideBearing = (INT16)iVar1;
  iVar1 = pcfGetINT16(file,format);
  metric->rightSideBearing = (INT16)iVar1;
  iVar1 = pcfGetINT16(file,format);
  metric->characterWidth = (INT16)iVar1;
  iVar1 = pcfGetINT16(file,format);
  metric->ascent = (INT16)iVar1;
  iVar1 = pcfGetINT16(file,format);
  metric->descent = (INT16)iVar1;
  iVar1 = pcfGetINT16(file,format);
  metric->attributes = (CARD16)iVar1;
  return (uint)(file->eof != -1);
}



Bool pcfSeekToType(FontFilePtr file,PCFTablePtr tables,int ntables,CARD32 type,CARD32 *formatp,
                  CARD32 *sizep)

{
  PCFTablePtr p_Var1;
  int iVar2;
  
  if (ntables < 1) {
    return 0;
  }
  p_Var1 = tables + (ulong)(ntables - 1) + 1;
  while (tables->type != type) {
    tables = tables + 1;
    if (tables == p_Var1) {
      return 0;
    }
  }
  if (tables->offset < (uint)position) {
    return 0;
  }
  iVar2 = (*file->skip)(file,tables->offset - position);
  file->eof = iVar2;
  if (iVar2 == -1) {
    return 0;
  }
  position = tables->offset;
  *sizep = tables->size;
  *formatp = tables->format;
  return 1;
}



Bool pcfGetAccel(FontInfoPtr pFontInfo,FontFilePtr file,PCFTablePtr tables,int ntables,CARD32 type)

{
  byte bVar1;
  byte *pbVar2;
  INT16 IVar3;
  INT16 IVar4;
  INT16 IVar5;
  CARD16 CVar6;
  Bool BVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  long in_FS_OFFSET;
  CARD32 format;
  CARD32 size;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  BVar7 = pcfSeekToType(file,tables,ntables,type,&format,&size);
  if ((BVar7 != 0) && (file->eof != -1)) {
    format = pcfGetLSB32(file);
    if ((format & 0xfffffe00) == 0) {
      iVar8 = position + 1;
      iVar10 = file->left;
      position = iVar8;
      file->left = iVar10 + -1;
      if (iVar10 == 0) {
        iVar8 = (*file->input)(file);
        file->eof = iVar8;
        bVar1 = (byte)iVar8;
        iVar8 = position;
      }
      else {
        pbVar2 = file->bufp;
        file->bufp = pbVar2 + 1;
        bVar1 = *pbVar2;
      }
      position = iVar8 + 1;
      pFontInfo->field_0xa = pFontInfo->field_0xa & 0xfe | bVar1 & 1;
      iVar10 = file->left;
      file->left = iVar10 + -1;
      if (iVar10 == 0) {
        uVar9 = (*file->input)(file);
        file->eof = uVar9;
      }
      else {
        pbVar2 = file->bufp;
        file->bufp = pbVar2 + 1;
        uVar9 = (uint)*pbVar2;
        position = iVar8 + 1;
      }
      iVar10 = position + 1;
      position = iVar10;
      pFontInfo->field_0xa = (byte)((uVar9 & 1) << 2) | pFontInfo->field_0xa & 0xfb;
      iVar8 = file->left;
      file->left = iVar8 + -1;
      if (iVar8 == 0) {
        uVar9 = (*file->input)(file);
        file->eof = uVar9;
      }
      else {
        pbVar2 = file->bufp;
        file->bufp = pbVar2 + 1;
        uVar9 = (uint)*pbVar2;
        position = iVar10;
      }
      iVar10 = position + 1;
      position = iVar10;
      pFontInfo->field_0xa = ((byte)uVar9 & 1) * '\x02' | pFontInfo->field_0xa & 0xfd;
      iVar8 = file->left;
      file->left = iVar8 + -1;
      if (iVar8 == 0) {
        uVar9 = (*file->input)(file);
        file->eof = uVar9;
      }
      else {
        pbVar2 = file->bufp;
        file->bufp = pbVar2 + 1;
        uVar9 = (uint)*pbVar2;
        position = iVar10;
      }
      iVar10 = position + 1;
      position = iVar10;
      pFontInfo->field_0xa = (byte)((uVar9 & 1) << 3) | pFontInfo->field_0xa & 0xf7;
      iVar8 = file->left;
      file->left = iVar8 + -1;
      if (iVar8 == 0) {
        uVar9 = (*file->input)(file);
        file->eof = uVar9;
      }
      else {
        pbVar2 = file->bufp;
        file->bufp = pbVar2 + 1;
        uVar9 = (uint)*pbVar2;
        position = iVar10;
      }
      iVar10 = position + 1;
      position = iVar10;
      pFontInfo->field_0xa = (byte)((uVar9 & 1) << 4) | pFontInfo->field_0xa & 0xef;
      iVar8 = file->left;
      file->left = iVar8 + -1;
      if (iVar8 == 0) {
        uVar9 = (*file->input)(file);
        file->eof = uVar9;
      }
      else {
        pbVar2 = file->bufp;
        file->bufp = pbVar2 + 1;
        uVar9 = (uint)*pbVar2;
        position = iVar10;
      }
      iVar10 = position + 1;
      position = iVar10;
      pFontInfo->field_0xa = (byte)((uVar9 & 1) << 5) | pFontInfo->field_0xa & 0xdf;
      iVar8 = file->left;
      file->left = iVar8 + -1;
      if (iVar8 == 0) {
        uVar9 = (*file->input)(file);
        file->eof = uVar9;
      }
      else {
        pbVar2 = file->bufp;
        file->bufp = pbVar2 + 1;
        uVar9 = (uint)*pbVar2;
        position = iVar10;
      }
      position = position + 1;
      *(ushort *)&pFontInfo->field_0xa =
           (ushort)((uVar9 & 3) << 7) | 0x200 | *(ushort *)&pFontInfo->field_0xa & 0xf87f;
      iVar8 = file->left;
      file->left = iVar8 + -1;
      if (iVar8 == 0) {
        iVar8 = (*file->input)(file);
        file->eof = iVar8;
      }
      else {
        file->bufp = file->bufp + 1;
      }
      iVar8 = pcfGetINT32(file,format);
      pFontInfo->fontAscent = (short)iVar8;
      iVar8 = pcfGetINT32(file,format);
      pFontInfo->fontDescent = (short)iVar8;
      iVar8 = pcfGetINT32(file,format);
      pFontInfo->maxOverlap = (short)iVar8;
      if (file->eof != -1) {
        BVar7 = pcfGetMetric(file,format,&pFontInfo->minbounds);
        if (BVar7 != 0) {
          BVar7 = pcfGetMetric(file,format,&pFontInfo->maxbounds);
          if (BVar7 != 0) {
            if (format >> 8 != 1) {
              IVar3 = (pFontInfo->minbounds).rightSideBearing;
              IVar4 = (pFontInfo->minbounds).characterWidth;
              IVar5 = (pFontInfo->minbounds).ascent;
              (pFontInfo->ink_minbounds).leftSideBearing = (pFontInfo->minbounds).leftSideBearing;
              (pFontInfo->ink_minbounds).rightSideBearing = IVar3;
              (pFontInfo->ink_minbounds).characterWidth = IVar4;
              (pFontInfo->ink_minbounds).ascent = IVar5;
              CVar6 = (pFontInfo->minbounds).attributes;
              (pFontInfo->ink_minbounds).descent = (pFontInfo->minbounds).descent;
              (pFontInfo->ink_minbounds).attributes = CVar6;
              IVar3 = (pFontInfo->maxbounds).rightSideBearing;
              IVar4 = (pFontInfo->maxbounds).characterWidth;
              IVar5 = (pFontInfo->maxbounds).ascent;
              (pFontInfo->ink_maxbounds).leftSideBearing = (pFontInfo->maxbounds).leftSideBearing;
              (pFontInfo->ink_maxbounds).rightSideBearing = IVar3;
              (pFontInfo->ink_maxbounds).characterWidth = IVar4;
              (pFontInfo->ink_maxbounds).ascent = IVar5;
              CVar6 = (pFontInfo->maxbounds).attributes;
              (pFontInfo->ink_maxbounds).descent = (pFontInfo->maxbounds).descent;
              (pFontInfo->ink_maxbounds).attributes = CVar6;
              uVar9 = 1;
              goto LAB_00122152;
            }
            BVar7 = pcfGetMetric(file,format,&pFontInfo->ink_minbounds);
            if (BVar7 != 0) {
              BVar7 = pcfGetMetric(file,format,&pFontInfo->ink_maxbounds);
              uVar9 = (uint)(BVar7 != 0);
              goto LAB_00122152;
            }
          }
        }
      }
    }
  }
  uVar9 = 0;
LAB_00122152:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar9;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void pcfUnloadFont(FontPtr pFont)

{
  long lVar1;
  void *__ptr;
  int iVar2;
  long lVar3;
  void *__ptr_00;
  int iVar4;
  
  __ptr = pFont->fontPrivate;
  free(*(void **)((long)__ptr + 0x18));
  __ptr_00 = *(void **)((long)__ptr + 0x28);
  if (__ptr_00 != (void *)0x0) {
    iVar2 = (((uint)(pFont->info).lastCol - (uint)(pFont->info).firstCol) + 1) *
            (((uint)(pFont->info).lastRow - (uint)(pFont->info).firstRow) + 1);
    iVar4 = iVar2 + 0xfe;
    if (-1 < iVar2 + 0x7f) {
      iVar4 = iVar2 + 0x7f;
    }
    if (0 < iVar2) {
      lVar3 = 0;
      do {
        lVar1 = lVar3 * 8;
        lVar3 = lVar3 + 1;
        free(*(void **)((long)__ptr_00 + lVar1));
        __ptr_00 = *(void **)((long)__ptr + 0x28);
      } while ((int)lVar3 < iVar4 >> 7);
    }
  }
  free(__ptr_00);
  free(*(void **)((long)__ptr + 0x20));
  free(*(void **)((long)__ptr + 0x10));
  free((pFont->info).isStringProp);
  free((pFont->info).props);
  free(__ptr);
  DestroyFontRec(pFont);
  return;
}



Bool pcfGetCompressedMetric(FontFilePtr file,CARD32 format,xCharInfo *metric)

{
  byte *pbVar1;
  short *psVar2;
  ushort uVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  undefined4 in_register_00000034;
  
  psVar2 = (short *)CONCAT44(in_register_00000034,format);
  iVar5 = position + 1;
  iVar6 = file->left;
  position = iVar5;
  file->left = iVar6 + -1;
  if (iVar6 == 0) {
    iVar5 = (*file->input)(file);
    file->eof = iVar5;
    uVar3 = (ushort)iVar5;
  }
  else {
    pbVar1 = file->bufp;
    file->bufp = pbVar1 + 1;
    uVar3 = (ushort)*pbVar1;
    position = iVar5;
  }
  *psVar2 = uVar3 - 0x80;
  iVar5 = file->left;
  iVar6 = position + 1;
  position = iVar6;
  file->left = iVar5 + -1;
  if (iVar5 == 0) {
    iVar5 = (*file->input)(file);
    file->eof = iVar5;
    uVar3 = (ushort)iVar5;
  }
  else {
    pbVar1 = file->bufp;
    file->bufp = pbVar1 + 1;
    uVar3 = (ushort)*pbVar1;
    position = iVar6;
  }
  psVar2[1] = uVar3 - 0x80;
  iVar5 = file->left;
  iVar6 = position + 1;
  position = iVar6;
  file->left = iVar5 + -1;
  if (iVar5 == 0) {
    iVar5 = (*file->input)(file);
    file->eof = iVar5;
    uVar3 = (ushort)iVar5;
  }
  else {
    pbVar1 = file->bufp;
    file->bufp = pbVar1 + 1;
    uVar3 = (ushort)*pbVar1;
    position = iVar6;
  }
  psVar2[2] = uVar3 - 0x80;
  iVar5 = file->left;
  iVar6 = position + 1;
  position = iVar6;
  file->left = iVar5 + -1;
  if (iVar5 == 0) {
    iVar5 = (*file->input)(file);
    file->eof = iVar5;
    uVar3 = (ushort)iVar5;
  }
  else {
    pbVar1 = file->bufp;
    file->bufp = pbVar1 + 1;
    uVar3 = (ushort)*pbVar1;
    position = iVar6;
  }
  psVar2[3] = uVar3 - 0x80;
  iVar5 = file->left;
  position = position + 1;
  file->left = iVar5 + -1;
  if (iVar5 == 0) {
    uVar4 = (*file->input)(file);
    file->eof = uVar4;
  }
  else {
    pbVar1 = file->bufp;
    file->bufp = pbVar1 + 1;
    uVar4 = (uint)*pbVar1;
  }
  psVar2[4] = (short)uVar4 + -0x80;
  psVar2[5] = 0;
  return (uint)(file->eof != -1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pcfError(char *message,...)

{
  long lVar1;
  char in_AL;
  undefined8 in_RCX;
  undefined8 in_RDX;
  undefined8 in_RSI;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  va_list args;
  undefined local_c8 [8];
  undefined8 local_c0;
  undefined8 local_b8;
  undefined8 local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  
  if (in_AL != '\0') {
    local_98 = in_XMM0_Qa;
    local_88 = in_XMM1_Qa;
    local_78 = in_XMM2_Qa;
    local_68 = in_XMM3_Qa;
    local_58 = in_XMM4_Qa;
    local_48 = in_XMM5_Qa;
    local_38 = in_XMM6_Qa;
    local_28 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  args[0].overflow_arg_area = &stack0x00000008;
  args[0].gp_offset = 8;
  args[0].reg_save_area = local_c8;
  args[0].fp_offset = 0x30;
  local_c0 = in_RSI;
  local_b8 = in_RDX;
  local_b0 = in_RCX;
  local_a8 = in_R8;
  local_a0 = in_R9;
  fwrite("PCF Error: ",1,0xb,_stderr);
  __vfprintf_chk(_stderr,1,message,args);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



PCFTablePtr pcfReadTOC(FontFilePtr file,int *countp)

{
  int iVar1;
  uint uVar2;
  CARD32 CVar3;
  PCFTablePtr __ptr;
  PCFTablePtr p_Var4;
  
  uVar2 = pcfGetLSB32(file);
  if (file->eof == -1) {
    __ptr = (PCFTablePtr)0x0;
  }
  else if (uVar2 < 0x8000000) {
    __ptr = (PCFTablePtr)malloc((long)(int)uVar2 << 4);
    if (__ptr == (PCFTablePtr)0x0) {
      pcfError("pcfReadTOC(): Couldn\'t allocate tables (%d*%d)\n",(ulong)uVar2,0x10);
    }
    else {
      if (uVar2 != 0) {
        p_Var4 = __ptr;
        do {
          CVar3 = pcfGetLSB32(file);
          p_Var4->type = CVar3;
          CVar3 = pcfGetLSB32(file);
          p_Var4->format = CVar3;
          CVar3 = pcfGetLSB32(file);
          p_Var4->size = CVar3;
          CVar3 = pcfGetLSB32(file);
          iVar1 = file->eof;
          p_Var4->offset = CVar3;
          if (iVar1 == -1) {
            free(__ptr);
            return (PCFTablePtr)0x0;
          }
          p_Var4 = p_Var4 + 1;
        } while (p_Var4 != __ptr + (ulong)(uVar2 - 1) + 1);
      }
      *countp = uVar2;
    }
  }
  else {
    __ptr = (PCFTablePtr)0x0;
    pcfError("pcfReadTOC(): invalid file format\n");
  }
  return __ptr;
}



Bool pcfGetProperties(FontInfoPtr pFontInfo,FontFilePtr file,PCFTablePtr tables,int ntables)

{
  byte *pbVar1;
  long lVar2;
  byte bVar3;
  Bool BVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  FontPropPtr __ptr;
  byte *__ptr_00;
  char *b;
  size_t sVar8;
  Atom AVar9;
  int iVar10;
  byte *pbVar11;
  long lVar12;
  FontPropPtr p_Var13;
  long in_FS_OFFSET;
  FontPropPtr local_50;
  CARD32 format;
  CARD32 size;
  long local_40;
  
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  BVar4 = pcfSeekToType(file,tables,ntables,1,&format,&size);
  if (BVar4 == 0) {
LAB_00122756:
    __ptr_00 = (byte *)0x0;
    __ptr = (FontPropPtr)0x0;
  }
  else {
    format = pcfGetLSB32(file);
    if ((format & 0xffffff00) != 0) goto LAB_00122756;
    uVar5 = pcfGetINT32(file,format);
    if (uVar5 - 1 < 0x7ffffff) {
      if (file->eof == -1) goto LAB_00122756;
      __ptr = (FontPropPtr)malloc((long)(int)uVar5 << 4);
      if (__ptr == (FontPropPtr)0x0) {
        __ptr_00 = (byte *)0x0;
        pcfError("pcfGetProperties(): Couldn\'t allocate props (%d*%d)\n",(ulong)uVar5,0x10);
      }
      else {
        __ptr_00 = (byte *)malloc((long)(int)uVar5);
        if (__ptr_00 == (byte *)0x0) {
          pcfError("pcfGetProperties(): Couldn\'t allocate isStringProp (%d*%d)\n",(ulong)uVar5,1);
        }
        else {
          pbVar11 = __ptr_00;
          p_Var13 = __ptr;
          do {
            iVar6 = pcfGetINT32(file,format);
            position = position + 1;
            p_Var13->name = (long)iVar6;
            iVar6 = file->left;
            file->left = iVar6 + -1;
            if (iVar6 == 0) {
              uVar7 = (*file->input)(file);
              file->eof = uVar7;
            }
            else {
              pbVar1 = file->bufp;
              file->bufp = pbVar1 + 1;
              uVar7 = (uint)*pbVar1;
            }
            *pbVar11 = (byte)uVar7;
            iVar6 = pcfGetINT32(file,format);
            p_Var13->value = (long)iVar6;
            bVar3 = *pbVar11;
            if ((p_Var13->name < 0) || (1 < bVar3)) {
LAB_001228b8:
              pcfError("pcfGetProperties(): invalid file format %ld %d %ld\n",p_Var13->name,
                       (ulong)(uint)(int)(char)bVar3);
              goto LAB_0012275c;
            }
            if (((long)iVar6 < 0) && ((bVar3 & 1) != 0)) {
              bVar3 = 1;
              goto LAB_001228b8;
            }
            if (file->eof == -1) goto LAB_0012275c;
            p_Var13 = p_Var13 + 1;
            pbVar11 = pbVar11 + 1;
          } while (p_Var13 != __ptr + (ulong)(uVar5 - 1) + 1);
          if ((uVar5 & 3) != 0) {
            iVar10 = 4 - (uVar5 & 3);
            iVar6 = (*file->skip)(file,iVar10);
            position = position + iVar10;
            file->eof = iVar6;
            if (iVar6 == -1) goto LAB_0012275c;
          }
          uVar7 = pcfGetINT32(file,format);
          if ((-1 < (int)uVar7) && (file->eof != -1)) {
            b = (char *)malloc((long)(int)uVar7);
            if (b == (char *)0x0) {
              pcfError("pcfGetProperties(): Couldn\'t allocate strings (%d)\n",(ulong)uVar7);
            }
            else {
              BufFileRead(file,b,uVar7);
              if (file->eof != -1) {
                position = position + uVar7;
                lVar12 = 0;
                local_50 = __ptr;
                do {
                  lVar2 = local_50->name;
                  sVar8 = strlen(b + lVar2);
                  AVar9 = MakeAtom(b + lVar2,(uint)sVar8,1);
                  bVar3 = __ptr_00[lVar12];
                  local_50->name = AVar9;
                  if (bVar3 != 0) {
                    lVar2 = local_50->value;
                    sVar8 = strlen(b + lVar2);
                    AVar9 = MakeAtom(b + lVar2,(uint)sVar8,1);
                    local_50->value = AVar9;
                  }
                  local_50 = local_50 + 1;
                  lVar12 = lVar12 + 1;
                } while ((int)lVar12 < (int)uVar5);
                free(b);
                pFontInfo->isStringProp = (char *)__ptr_00;
                pFontInfo->props = __ptr;
                pFontInfo->nprops = uVar5;
                BVar4 = 1;
                goto LAB_0012276e;
              }
            }
          }
        }
      }
    }
    else {
      __ptr_00 = (byte *)0x0;
      pcfError("pcfGetProperties(): invalid nprops value (%d)\n",(ulong)uVar5);
      __ptr = (FontPropPtr)0x0;
    }
  }
LAB_0012275c:
  free(__ptr_00);
  free(__ptr);
  BVar4 = 0;
LAB_0012276e:
  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return BVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int pcfReadFont(FontPtr pFont,FontFilePtr file,int bit,int byte,int glyph,int scan)

{
  FontInfoRec *pFontInfo;
  undefined *puVar1;
  long lVar2;
  long *plVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  short sVar7;
  ushort uVar8;
  ushort uVar9;
  ushort uVar10;
  ushort uVar11;
  bool bVar12;
  int iVar13;
  Bool BVar14;
  uint uVar15;
  uint uVar16;
  CARD32 CVar17;
  int iVar18;
  PCFTablePtr tables;
  PCFTablePtr p_Var19;
  xCharInfo *__ptr;
  uint *__ptr_00;
  uchar *puVar20;
  uint *puVar21;
  void *__ptr_01;
  undefined4 *puVar22;
  xCharInfo *pxVar23;
  void *pvVar24;
  ulong uVar25;
  int iVar26;
  xCharInfo *extraout_RDX;
  xCharInfo *extraout_RDX_00;
  xCharInfo *extraout_RDX_01;
  INT16 *pIVar27;
  xCharInfo *extraout_RDX_02;
  xCharInfo *extraout_RDX_03;
  xCharInfo *pxVar28;
  xCharInfo *extraout_RDX_04;
  uint *puVar29;
  long lVar30;
  ushort uVar31;
  CARD32 CVar32;
  xCharInfo *metric;
  CARD32 *pCVar33;
  long in_FS_OFFSET;
  uchar *local_c8;
  char local_c0;
  char local_b4;
  char local_b0;
  char local_ac;
  uint local_88;
  CARD32 format;
  CARD32 size;
  int ntables;
  CARD32 bitmapSizes [4];
  CARD32 local_48 [2];
  long local_40;
  
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  (pFont->info).nprops = 0;
  (pFont->info).props = (FontPropPtr)0x0;
  (pFont->info).isStringProp = (char *)0x0;
  position = 0;
  iVar13 = pcfGetLSB32(file);
  if (iVar13 != 0x70636601) {
    tables = (PCFTablePtr)0x0;
    __ptr_00 = (uint *)0x0;
    pxVar23 = (xCharInfo *)0x0;
    __ptr = (xCharInfo *)0x0;
    local_c8 = (uchar *)0x0;
    goto LAB_00122c34;
  }
  tables = pcfReadTOC(file,&ntables);
  if (tables != (PCFTablePtr)0x0) {
    pFontInfo = &pFont->info;
    BVar14 = pcfGetProperties(pFontInfo,file,tables,ntables);
    if (BVar14 == 0) goto LAB_00122b8f;
    if (0 < ntables) {
      p_Var19 = tables;
      do {
        if (p_Var19->type == 0x100) {
          bVar12 = true;
          goto LAB_00122b5d;
        }
        p_Var19 = p_Var19 + 1;
      } while (tables + (ulong)(ntables - 1) + 1 != p_Var19);
    }
    BVar14 = pcfGetAccel(pFontInfo,file,tables,ntables,2);
    if (BVar14 == 0) goto LAB_00122b8f;
    bVar12 = false;
LAB_00122b5d:
    BVar14 = pcfSeekToType(file,tables,ntables,4,&format,&size);
    if ((BVar14 == 0) || (format = pcfGetLSB32(file), (format & 0xfffffe00) != 0))
    goto LAB_00122b8f;
    if ((format & 0xffffff00) == 0) {
      uVar15 = pcfGetINT32(file,format);
    }
    else {
      uVar15 = pcfGetINT16(file,format);
    }
    if (file->eof == -1) goto LAB_00122b8f;
    if (0x5555555 < uVar15) {
      __ptr_00 = (uint *)0x0;
      __ptr_01 = (void *)0x0;
      pcfError("pcfReadFont(): invalid file format\n");
      __ptr = (xCharInfo *)0x0;
      local_c8 = (uchar *)0x0;
      goto LAB_00122ba0;
    }
    __ptr = (xCharInfo *)malloc((long)(int)uVar15 * 0x18);
    if (__ptr == (xCharInfo *)0x0) {
      __ptr_00 = (uint *)0x0;
      __ptr_01 = (void *)0x0;
      pcfError("pcfReadFont(): Couldn\'t allocate metrics (%d*%d)\n",uVar15,0x18);
      local_c8 = (uchar *)0x0;
      goto LAB_00122ba0;
    }
    if (uVar15 != 0) {
      pxVar23 = extraout_RDX;
      pxVar28 = __ptr;
      do {
        if ((format & 0xffffff00) == 0) {
          iVar13 = pcfGetMetric(file,format,pxVar28);
          pxVar23 = extraout_RDX_00;
        }
        else {
          iVar13 = pcfGetCompressedMetric(file,(CARD32)pxVar28,pxVar23);
          pxVar23 = extraout_RDX_01;
        }
        if (iVar13 == 0) {
          local_c8 = (uchar *)0x0;
          __ptr_00 = (uint *)0x0;
          pxVar23 = (xCharInfo *)0x0;
          goto LAB_00122c34;
        }
        pxVar28 = pxVar28 + 2;
      } while (__ptr + (ulong)(uVar15 - 1) * 2 + 2 != pxVar28);
    }
    BVar14 = pcfSeekToType(file,tables,ntables,8,&format,&size);
    if ((((BVar14 == 0) || (format = pcfGetLSB32(file), (format & 0xffffff00) != 0)) ||
        (uVar16 = pcfGetINT32(file,format), uVar15 != uVar16)) || (file->eof == -1)) {
      local_c8 = (uchar *)0x0;
      __ptr_00 = (uint *)0x0;
      __ptr_01 = (void *)0x0;
      goto LAB_00122ba0;
    }
    __ptr_00 = (uint *)malloc((long)(int)uVar16 << 2);
    if (__ptr_00 == (uint *)0x0) {
      __ptr_01 = (void *)0x0;
      pcfError("pcfReadFont(): Couldn\'t allocate offsets (%d*%d)\n",uVar15,4);
      local_c8 = (uchar *)0x0;
      goto LAB_00122ba0;
    }
    if (uVar16 != 0) {
      puVar21 = __ptr_00;
      do {
        uVar15 = pcfGetINT32(file,format);
        iVar13 = file->eof;
        *puVar21 = uVar15;
        if (iVar13 == -1) goto LAB_00122e25;
        puVar21 = puVar21 + 1;
      } while (__ptr_00 + (ulong)(uVar16 - 1) + 1 != puVar21);
    }
    pCVar33 = bitmapSizes;
    do {
      CVar17 = pcfGetINT32(file,format);
      iVar13 = file->eof;
      *pCVar33 = CVar17;
      if (iVar13 == -1) goto LAB_00122e25;
      pCVar33 = pCVar33 + 1;
    } while (local_48 != pCVar33);
    CVar17 = bitmapSizes[format & 3];
    CVar32 = 1;
    if (CVar17 != 0) {
      CVar32 = CVar17;
    }
    local_c8 = (uchar *)malloc((long)(int)CVar32);
    if (local_c8 == (uchar *)0x0) {
      __ptr_01 = (void *)0x0;
      pcfError("pcfReadFont(): Couldn\'t allocate bitmaps (%d)\n",CVar32);
      goto LAB_00122ba0;
    }
    BufFileRead(file,(char *)local_c8,CVar17);
    if (file->eof != -1) {
      position = position + CVar17;
      if ((format >> 3 & 1) != bit) {
        BitOrderInvert(local_c8,CVar17);
      }
      if ((bool)(~((byte)(format >> 2) ^ (byte)(format >> 3)) & 1) != (bit == byte)) {
        iVar13 = scan;
        if (bit == byte) {
          iVar13 = 1 << ((byte)(format >> 4) & 3);
        }
        if (iVar13 == 2) {
          TwoByteSwap(local_c8,CVar17);
        }
        else if (iVar13 == 4) {
          FourByteSwap(local_c8,CVar17);
        }
      }
      if (1 << ((byte)format & 3) != glyph) {
        if (glyph == 4) {
          uVar25 = 2;
        }
        else {
          uVar25 = (ulong)(glyph == 2);
        }
        CVar17 = bitmapSizes[uVar25];
        puVar20 = (uchar *)malloc((long)(int)CVar17);
        if (puVar20 == (uchar *)0x0) {
          pcfError("pcfReadFont(): Couldn\'t allocate padbitmaps (%d)\n",CVar17);
          __ptr_01 = (void *)0x0;
          goto LAB_00122ba0;
        }
        if (uVar16 != 0) {
          local_88 = 0;
          pxVar23 = __ptr;
          puVar21 = __ptr_00;
          do {
            uVar15 = *puVar21;
            puVar29 = puVar21 + 1;
            sVar4 = pxVar23->ascent;
            sVar5 = pxVar23->descent;
            sVar6 = pxVar23->rightSideBearing;
            sVar7 = pxVar23->leftSideBearing;
            *puVar21 = local_88;
            iVar13 = RepadBitmap((char *)(local_c8 + (int)uVar15),(char *)(puVar20 + (int)local_88),
                                 1 << ((byte)format & 3),glyph,(int)sVar6 - (int)sVar7,
                                 (int)sVar4 + (int)sVar5);
            local_88 = local_88 + iVar13;
            pxVar23 = pxVar23 + 2;
            puVar21 = puVar29;
          } while (__ptr_00 + (ulong)(uVar16 - 1) + 1 != puVar29);
        }
        free(local_c8);
        local_c8 = puVar20;
      }
      if (uVar16 != 0) {
        puVar21 = __ptr_00;
        pIVar27 = &__ptr[1].characterWidth;
        do {
          uVar15 = *puVar21;
          puVar21 = puVar21 + 1;
          *(uchar **)pIVar27 = local_c8 + uVar15;
          pIVar27 = pIVar27 + 0xc;
        } while (puVar21 != __ptr_00 + (ulong)(uVar16 - 1) + 1);
      }
      free(__ptr_00);
      BVar14 = pcfSeekToType(file,tables,ntables,0x10,&format,&size);
      pxVar23 = (xCharInfo *)0x0;
      if (BVar14 == 0) {
LAB_00123094:
        BVar14 = pcfSeekToType(file,tables,ntables,0x20,&format,&size);
        if ((BVar14 != 0) && (format = pcfGetLSB32(file), (format & 0xffffff00) == 0)) {
          iVar13 = pcfGetINT16(file,format);
          (pFont->info).firstCol = (ushort)iVar13;
          iVar13 = pcfGetINT16(file,format);
          (pFont->info).lastCol = (ushort)iVar13;
          iVar13 = pcfGetINT16(file,format);
          (pFont->info).firstRow = (ushort)iVar13;
          iVar13 = pcfGetINT16(file,format);
          (pFont->info).lastRow = (ushort)iVar13;
          iVar13 = pcfGetINT16(file,format);
          (pFont->info).defaultCh = (ushort)iVar13;
          if (file->eof != -1) {
            uVar8 = (pFont->info).firstCol;
            uVar9 = (pFont->info).lastCol;
            if (uVar8 <= uVar9) {
              uVar31 = (pFont->info).firstRow;
              uVar10 = (pFont->info).lastRow;
              if ((uVar31 <= uVar10) && (iVar13 = (uint)uVar9 - (uint)uVar8, iVar13 < 0x100)) {
                iVar26 = (((uint)uVar10 - (uint)uVar31) + 1) * (iVar13 + 1);
                iVar13 = (iVar26 + 0x7f) / 0x80;
                __ptr_01 = calloc((long)iVar13,8);
                if (__ptr_01 == (void *)0x0) {
                  __ptr_00 = (uint *)0x0;
                  pcfError("pcfReadFont(): Couldn\'t allocate encoding (%d*%d)\n",iVar26,8);
                  free(pxVar23);
                }
                else {
                  puVar1 = &(pFont->info).field_0xa;
                  *puVar1 = *puVar1 | 0x40;
                  for (uVar15 = 0; (int)uVar15 < iVar26; uVar15 = uVar15 + 1) {
                    iVar18 = pcfGetINT16(file,format);
                    if (file->eof == -1) {
LAB_00123567:
                      free(pxVar23);
                      goto LAB_00123581;
                    }
                    if (iVar18 == 0xffff) {
                      puVar1 = &(pFont->info).field_0xa;
                      *puVar1 = *puVar1 & 0xbf;
                    }
                    else {
                      plVar3 = (long *)((long)__ptr_01 + (long)((int)uVar15 >> 7) * 8);
                      if (*plVar3 == 0) {
                        pvVar24 = calloc(0x80,8);
                        *plVar3 = (long)pvVar24;
                        if (pvVar24 == (void *)0x0) goto LAB_00123567;
                      }
                      *(xCharInfo **)(*plVar3 + (ulong)(uVar15 & 0x7f) * 8) =
                           __ptr + (long)iVar18 * 2;
                    }
                  }
                  if ((!bVar12) ||
                     (BVar14 = pcfGetAccel(pFontInfo,file,tables,ntables,0x100), BVar14 != 0)) {
                    puVar22 = (undefined4 *)malloc(0x40);
                    if (puVar22 != (undefined4 *)0x0) {
                      *puVar22 = 0x70636601;
                      uVar8 = (pFont->info).defaultCh;
                      *(xCharInfo **)(puVar22 + 4) = __ptr;
                      puVar22[1] = uVar16;
                      *(xCharInfo **)(puVar22 + 6) = pxVar23;
                      puVar22[2] = ntables;
                      *(void **)(puVar22 + 10) = __ptr_01;
                      *(uchar **)(puVar22 + 8) = local_c8;
                      *(undefined8 *)(puVar22 + 0xc) = 0;
                      if (uVar8 != 0xffff) {
                        uVar9 = (pFont->info).firstRow;
                        uVar31 = uVar8 >> 8;
                        if ((uVar9 <= uVar31) && (uVar31 <= (pFont->info).lastRow)) {
                          uVar10 = (pFont->info).firstCol;
                          if ((uVar10 <= (uVar8 & 0xff)) &&
                             (uVar11 = (pFont->info).lastCol, (uVar8 & 0xff) <= uVar11)) {
                            uVar15 = (((uint)uVar11 - (uint)uVar10) + 1) *
                                     ((uint)uVar31 - (uint)uVar9) +
                                     ((uint)(byte)uVar8 - (uint)uVar10);
                            lVar30 = *(long *)((long)__ptr_01 + (ulong)(uVar15 >> 7) * 8);
                            if (lVar30 != 0) {
                              lVar30 = *(long *)(lVar30 + (ulong)(uVar15 & 0x7f) * 8);
                            }
                            *(long *)(puVar22 + 0xc) = lVar30;
                          }
                        }
                      }
                      *(undefined8 *)(puVar22 + 0xe) = 0;
                      pFont->fontPrivate = puVar22;
                      pFont->get_glyphs = bitmapGetGlyphs;
                      pFont->unload_glyphs = (_func_void_FontPtr *)0x0;
                      pFont->get_metrics = bitmapGetMetrics;
                      pFont->unload_font = pcfUnloadFont;
                      local_c0 = (char)bit;
                      pFont->bit = local_c0;
                      local_b0 = (char)byte;
                      pFont->byte = local_b0;
                      local_b4 = (char)glyph;
                      pFont->glyph = local_b4;
                      local_ac = (char)scan;
                      pFont->scan = local_ac;
                      free(tables);
                      iVar13 = 0x55;
                      goto LAB_00122bef;
                    }
                    pcfError("pcfReadFont(): Couldn\'t allocate bitmapFont (%d)\n",0x40);
                  }
                  free(pxVar23);
                  if (0 < iVar26) {
LAB_00123581:
                    lVar30 = 0;
                    do {
                      lVar2 = lVar30 * 8;
                      lVar30 = lVar30 + 1;
                      free(*(void **)((long)__ptr_01 + lVar2));
                    } while ((int)lVar30 < iVar13);
                  }
                  __ptr_00 = (uint *)0x0;
                }
                goto LAB_00122ba0;
              }
            }
          }
        }
        __ptr_00 = (uint *)0x0;
        __ptr_01 = (void *)0x0;
        free(pxVar23);
      }
      else {
        format = pcfGetLSB32(file);
        if ((format & 0xfffffe00) == 0) {
          if ((format & 0xffffff00) == 0) {
            uVar15 = pcfGetINT32(file,format);
          }
          else {
            uVar15 = pcfGetINT16(file,format);
          }
          if ((file->eof != -1) && (uVar15 == uVar16)) {
            pxVar23 = (xCharInfo *)malloc((long)(int)uVar15 * 0xc);
            if (pxVar23 == (xCharInfo *)0x0) {
              __ptr_00 = (uint *)0x0;
              __ptr_01 = (void *)0x0;
              pcfError("pcfReadFont(): Couldn\'t allocate ink_metrics (%d*%d)\n",(ulong)uVar15,0xc);
              goto LAB_00122ba0;
            }
            local_88 = 0;
            pxVar28 = extraout_RDX_02;
            metric = pxVar23;
            if (uVar15 != 0) {
              do {
                if ((format & 0xffffff00) == 0) {
                  iVar13 = pcfGetMetric(file,format,metric);
                  pxVar28 = extraout_RDX_03;
                }
                else {
                  iVar13 = pcfGetCompressedMetric(file,(CARD32)metric,pxVar28);
                  pxVar28 = extraout_RDX_04;
                }
                if (iVar13 == 0) {
                  __ptr_00 = (uint *)0x0;
                  goto LAB_00122c34;
                }
                local_88 = local_88 + 1;
                metric = metric + 1;
              } while (uVar15 != local_88);
            }
            goto LAB_00123094;
          }
        }
        __ptr_00 = (uint *)0x0;
        __ptr_01 = (void *)0x0;
      }
      goto LAB_00122ba0;
    }
    goto LAB_00122c3c;
  }
LAB_00122b8f:
  local_c8 = (uchar *)0x0;
  __ptr_00 = (uint *)0x0;
  __ptr_01 = (void *)0x0;
  __ptr = (xCharInfo *)0x0;
  goto LAB_00122ba0;
LAB_00122e25:
  local_c8 = (uchar *)0x0;
  pxVar23 = (xCharInfo *)0x0;
LAB_00122c34:
  free(pxVar23);
LAB_00122c3c:
  __ptr_01 = (void *)0x0;
LAB_00122ba0:
  free(__ptr_01);
  free(local_c8);
  free(__ptr);
  free((pFont->info).props);
  (pFont->info).nprops = 0;
  (pFont->info).props = (FontPropPtr)0x0;
  free((pFont->info).isStringProp);
  free(tables);
  free(__ptr_00);
  iVar13 = 0x50;
LAB_00122bef:
  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar13;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int pcfReadFontInfo(FontInfoPtr pFontInfo,FontFilePtr file)

{
  bool bVar1;
  int iVar2;
  Bool BVar3;
  int iVar4;
  PCFTablePtr tables;
  PCFTablePtr p_Var5;
  long in_FS_OFFSET;
  int ntables;
  CARD32 format;
  CARD32 size;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  pFontInfo->isStringProp = (char *)0x0;
  pFontInfo->props = (FontPropPtr)0x0;
  pFontInfo->nprops = 0;
  position = 0;
  iVar2 = pcfGetLSB32(file);
  if (iVar2 == 0x70636601) {
    tables = pcfReadTOC(file,&ntables);
    if (tables != (PCFTablePtr)0x0) {
      BVar3 = pcfGetProperties(pFontInfo,file,tables,ntables);
      if (BVar3 != 0) {
        if (0 < ntables) {
          p_Var5 = tables;
          do {
            if (p_Var5->type == 0x100) {
              bVar1 = true;
              goto LAB_001236eb;
            }
            p_Var5 = p_Var5 + 1;
          } while (p_Var5 != tables + (ulong)(ntables - 1) + 1);
        }
        BVar3 = pcfGetAccel(pFontInfo,file,tables,ntables,2);
        if (BVar3 != 0) {
          bVar1 = false;
LAB_001236eb:
          BVar3 = pcfSeekToType(file,tables,ntables,0x20,&format,&size);
          if (BVar3 != 0) {
            format = pcfGetLSB32(file);
            if ((format & 0xffffff00) == 0) {
              iVar2 = pcfGetINT16(file,format);
              pFontInfo->firstCol = (ushort)iVar2;
              iVar2 = pcfGetINT16(file,format);
              pFontInfo->lastCol = (ushort)iVar2;
              iVar2 = pcfGetINT16(file,format);
              pFontInfo->firstRow = (ushort)iVar2;
              iVar2 = pcfGetINT16(file,format);
              pFontInfo->lastRow = (ushort)iVar2;
              iVar2 = pcfGetINT16(file,format);
              pFontInfo->defaultCh = (ushort)iVar2;
              if (file->eof != -1) {
                if (pFontInfo->firstCol <= pFontInfo->lastCol) {
                  if ((pFontInfo->firstRow <= pFontInfo->lastRow) &&
                     (iVar2 = (uint)pFontInfo->lastCol - (uint)pFontInfo->firstCol, iVar2 < 0x100))
                  {
                    pFontInfo->field_0xa = pFontInfo->field_0xa | 0x40;
                    iVar2 = (((uint)pFontInfo->lastRow - (uint)pFontInfo->firstRow) + 1) *
                            (iVar2 + 1);
                    do {
                      if (iVar2 == 0) {
                        if (file->eof == -1) break;
                        if (bVar1) {
                          BVar3 = pcfGetAccel(pFontInfo,file,tables,ntables,0x100);
                          if (BVar3 == 0) break;
                        }
                        free(tables);
                        iVar2 = 0x55;
                        goto LAB_00123736;
                      }
                      iVar4 = pcfGetINT16(file,format);
                      if (iVar4 == 0xffff) {
                        pFontInfo->field_0xa = pFontInfo->field_0xa & 0xbf;
                      }
                      iVar2 = iVar2 + -1;
                    } while (file->eof != -1);
                  }
                }
              }
            }
          }
        }
      }
      goto LAB_00123710;
    }
  }
  tables = (PCFTablePtr)0x0;
LAB_00123710:
  pFontInfo->nprops = 0;
  free(pFontInfo->props);
  free(pFontInfo->isStringProp);
  free(tables);
  iVar2 = 0x50;
LAB_00123736:
  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int pcfPutLSB32(FontFilePtr file,int c)

{
  int *piVar1;
  BufChar *pBVar2;
  int iVar3;
  
  current_position = current_position + 4;
  piVar1 = &file->left;
  *piVar1 = *piVar1 + -1;
  if (*piVar1 == 0) {
    (*file->output)(c & 0xff,file);
  }
  else {
    pBVar2 = file->bufp;
    file->bufp = pBVar2 + 1;
    *pBVar2 = (BufChar)c;
  }
  iVar3 = file->left + -1;
  file->left = iVar3;
  if (iVar3 == 0) {
    (*file->output)(c >> 8 & 0xff,file);
  }
  else {
    pBVar2 = file->bufp;
    file->bufp = pBVar2 + 1;
    *pBVar2 = (BufChar)((uint)c >> 8);
  }
  iVar3 = file->left + -1;
  file->left = iVar3;
  if (iVar3 == 0) {
    (*file->output)(c >> 0x10 & 0xff,file);
  }
  else {
    pBVar2 = file->bufp;
    file->bufp = pBVar2 + 1;
    *pBVar2 = (BufChar)((uint)c >> 0x10);
  }
  iVar3 = file->left + -1;
  file->left = iVar3;
  if (iVar3 == 0) {
                    // WARNING: Could not recover jumptable at 0x0012394d. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar3 = (*file->output)((uint)c >> 0x18,file);
    return iVar3;
  }
  pBVar2 = file->bufp;
  file->bufp = pBVar2 + 1;
  *pBVar2 = (BufChar)((uint)c >> 0x18);
  return (uint)c >> 0x18;
}



int pcfPutINT32(FontFilePtr file,CARD32 format,int c)

{
  int *piVar1;
  BufChar *pBVar2;
  int iVar3;
  BufChar BVar4;
  BufChar BVar5;
  uint uVar7;
  BufChar BVar6;
  
  current_position = current_position + 4;
  iVar3 = file->left + -1;
  file->left = iVar3;
  BVar5 = (BufChar)((uint)c >> 8);
  BVar6 = (BufChar)((uint)c >> 0x10);
  BVar4 = (BufChar)((uint)c >> 0x18);
  if ((format & 4) == 0) {
    if (iVar3 == 0) {
      (*file->output)((int)c,file);
    }
    else {
      pBVar2 = file->bufp;
      file->bufp = pBVar2 + 1;
      *pBVar2 = (BufChar)c;
    }
    iVar3 = file->left + -1;
    file->left = iVar3;
    if (iVar3 == 0) {
      (*file->output)(c >> 8 & 0xff,file);
    }
    else {
      pBVar2 = file->bufp;
      file->bufp = pBVar2 + 1;
      *pBVar2 = BVar5;
    }
    iVar3 = file->left + -1;
    file->left = iVar3;
    if (iVar3 == 0) {
      (*file->output)(c >> 0x10 & 0xff,file);
    }
    else {
      pBVar2 = file->bufp;
      file->bufp = pBVar2 + 1;
      *pBVar2 = BVar6;
    }
    uVar7 = (uint)c >> 0x18;
    iVar3 = file->left + -1;
    file->left = iVar3;
    if (iVar3 != 0) {
      pBVar2 = file->bufp;
      file->bufp = pBVar2 + 1;
      *pBVar2 = BVar4;
      return uVar7;
    }
  }
  else {
    if (iVar3 == 0) {
      (*file->output)((uint)c >> 0x18,file);
    }
    else {
      pBVar2 = file->bufp;
      file->bufp = pBVar2 + 1;
      *pBVar2 = BVar4;
    }
    iVar3 = file->left + -1;
    file->left = iVar3;
    if (iVar3 == 0) {
      (*file->output)(c >> 0x10 & 0xff,file);
    }
    else {
      pBVar2 = file->bufp;
      file->bufp = pBVar2 + 1;
      *pBVar2 = BVar6;
    }
    iVar3 = file->left + -1;
    file->left = iVar3;
    if (iVar3 == 0) {
      (*file->output)(c >> 8 & 0xff,file);
    }
    else {
      pBVar2 = file->bufp;
      file->bufp = pBVar2 + 1;
      *pBVar2 = BVar5;
    }
    piVar1 = &file->left;
    *piVar1 = *piVar1 + -1;
    uVar7 = c & 0xff;
    if (*piVar1 != 0) {
      pBVar2 = file->bufp;
      file->bufp = pBVar2 + 1;
      *pBVar2 = (BufChar)c;
      return uVar7;
    }
  }
                    // WARNING: Could not recover jumptable at 0x00123b30. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar3 = (*file->output)(uVar7,file);
  return iVar3;
}



int pcfPutINT16(FontFilePtr file,CARD32 format,int c)

{
  int *piVar1;
  BufChar *pBVar2;
  int iVar3;
  uint uVar4;
  BufChar BVar5;
  uint uVar6;
  
  uVar6 = c >> 8;
  current_position = current_position + 2;
  iVar3 = file->left + -1;
  file->left = iVar3;
  BVar5 = (BufChar)((uint)c >> 8);
  if ((format & 4) == 0) {
    if (iVar3 == 0) {
      (*file->output)((int)c,file);
      piVar1 = &file->left;
      *piVar1 = *piVar1 + -1;
      iVar3 = *piVar1;
    }
    else {
      pBVar2 = file->bufp;
      file->bufp = pBVar2 + 1;
      *pBVar2 = (BufChar)c;
      piVar1 = &file->left;
      *piVar1 = *piVar1 + -1;
      iVar3 = *piVar1;
    }
    uVar4 = uVar6 & 0xff;
    if (iVar3 != 0) {
      pBVar2 = file->bufp;
      file->bufp = pBVar2 + 1;
      *pBVar2 = BVar5;
      return uVar6 & 0xff;
    }
  }
  else {
    if (iVar3 == 0) {
      (*file->output)(uVar6 & 0xff,file);
    }
    else {
      pBVar2 = file->bufp;
      file->bufp = pBVar2 + 1;
      *pBVar2 = BVar5;
    }
    piVar1 = &file->left;
    *piVar1 = *piVar1 + -1;
    uVar4 = c & 0xff;
    if (*piVar1 != 0) {
      pBVar2 = file->bufp;
      file->bufp = pBVar2 + 1;
      *pBVar2 = (BufChar)c;
      return uVar4;
    }
  }
                    // WARNING: Could not recover jumptable at 0x00123c54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar3 = (*file->output)(uVar4,file);
  return iVar3;
}



void pcfPutMetric(FontFilePtr file,CARD32 format,xCharInfo *metric)

{
  pcfPutINT16(file,format,(int)metric->leftSideBearing);
  pcfPutINT16(file,format,(int)metric->rightSideBearing);
  pcfPutINT16(file,format,(int)metric->characterWidth);
  pcfPutINT16(file,format,(int)metric->ascent);
  pcfPutINT16(file,format,(int)metric->descent);
  pcfPutINT16(file,format,(uint)metric->attributes);
  return;
}



int pcfPutINT8(FontFilePtr file,CARD32 format,int c)

{
  int *piVar1;
  BufChar *pBVar2;
  int iVar3;
  
  current_position = current_position + 1;
  piVar1 = &file->left;
  *piVar1 = *piVar1 + -1;
  if (*piVar1 == 0) {
                    // WARNING: Could not recover jumptable at 0x00123d0e. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar3 = (*file->output)((CARD32)format,file);
    return iVar3;
  }
  pBVar2 = file->bufp;
  file->bufp = pBVar2 + 1;
  *pBVar2 = (BufChar)format;
  return format & 0xff;
}



void pcfPutAccel(FontFilePtr file,CARD32 format,FontInfoPtr pFontInfo)

{
  int c;
  int c_00;
  int c_01;
  int c_02;
  int c_03;
  int c_04;
  int c_05;
  
  pcfPutINT8(file,(byte)pFontInfo->field_0xa & 1,(int)pFontInfo);
  pcfPutINT8(file,(byte)pFontInfo->field_0xa >> 2 & 1,c);
  pcfPutINT8(file,(byte)pFontInfo->field_0xa >> 1 & 1,c_00);
  pcfPutINT8(file,(byte)pFontInfo->field_0xa >> 3 & 1,c_01);
  pcfPutINT8(file,(byte)pFontInfo->field_0xa >> 4 & 1,c_02);
  pcfPutINT8(file,(byte)pFontInfo->field_0xa >> 5 & 1,c_03);
  pcfPutINT8(file,*(ushort *)&pFontInfo->field_0xa >> 7 & 3,c_04);
  pcfPutINT8(file,0,c_05);
  pcfPutINT32(file,format,(int)pFontInfo->fontAscent);
  pcfPutINT32(file,format,(int)pFontInfo->fontDescent);
  pcfPutINT32(file,format,(int)pFontInfo->maxOverlap);
  pcfPutMetric(file,format,&pFontInfo->minbounds);
  pcfPutMetric(file,format,&pFontInfo->maxbounds);
  if (format >> 8 != 1) {
    return;
  }
  pcfPutMetric(file,format,&pFontInfo->ink_minbounds);
  pcfPutMetric(file,format,&pFontInfo->ink_maxbounds);
  return;
}



void pcfPutCompressedMetric(FontFilePtr file,CARD32 format,xCharInfo *metric)

{
  int c;
  int c_00;
  int c_01;
  int c_02;
  undefined4 in_register_00000034;
  short *psVar1;
  
  psVar1 = (short *)CONCAT44(in_register_00000034,format);
  pcfPutINT8(file,(int)*psVar1 + 0x80,(int)metric);
  pcfPutINT8(file,(int)psVar1[1] + 0x80,c);
  pcfPutINT8(file,(int)psVar1[2] + 0x80,c_00);
  pcfPutINT8(file,(int)psVar1[3] + 0x80,c_01);
  pcfPutINT8(file,(int)psVar1[4] + 0x80,c_02);
  return;
}



int pcfWriteFont(FontPtr pFont,FontFilePtr file)

{
  short *psVar1;
  byte *pbVar2;
  byte bVar3;
  ushort uVar4;
  ushort uVar5;
  CARD16 CVar6;
  void *pvVar7;
  long lVar8;
  byte *pbVar9;
  xCharInfo *pxVar10;
  uint uVar11;
  uint uVar12;
  CARD32 CVar13;
  int *__ptr;
  char *pcVar14;
  size_t sVar15;
  PCFTableRec *pPVar16;
  uint uVar17;
  int c;
  PCFTableRec *pPVar18;
  ulong uVar19;
  ulong extraout_RDX;
  undefined8 extraout_RDX_00;
  undefined8 extraout_RDX_01;
  undefined8 uVar20;
  undefined8 extraout_RDX_02;
  int iVar21;
  long *plVar22;
  PCFTableRec *pPVar23;
  long lVar24;
  PCFTableRec *pPVar25;
  int *piVar26;
  byte *pbVar27;
  byte *pbVar28;
  long lVar29;
  uint uVar30;
  int iVar31;
  long in_FS_OFFSET;
  int local_288;
  int local_284;
  xCharInfo *local_278;
  xCharInfo *local_268;
  uint local_260;
  xCharInfo *local_258;
  xCharInfo *local_250;
  PCFTableRec tables [32];
  
  pvVar7 = pFont->fontPrivate;
  lVar8 = *(long *)(in_FS_OFFSET + 0x28);
  lVar29 = *(long *)((long)pvVar7 + 0x38);
  if (lVar29 == 0) {
    local_278 = &(pFont->info).minbounds;
    local_258 = &(pFont->info).maxbounds;
    local_268 = &(pFont->info).ink_minbounds;
    local_250 = &(pFont->info).ink_maxbounds;
  }
  else {
    local_278 = (xCharInfo *)(lVar29 + 0x3c);
    local_258 = (xCharInfo *)(lVar29 + 0x30);
    local_268 = (xCharInfo *)(lVar29 + 0x54);
    local_250 = (xCharInfo *)(lVar29 + 0x48);
  }
  uVar11 = (pFont->info).nprops;
  __ptr = (int *)malloc((long)(int)uVar11 << 4);
  if (__ptr == (int *)0x0) {
    pcfError("pcfWriteFont(): Couldn\'t allocate offsetProps (%d*%d)",(ulong)uVar11,0x10);
    iVar31 = 0x50;
  }
  else {
    local_288 = 0;
    if (0 < (int)uVar11) {
      local_288 = 0;
      plVar22 = (long *)(__ptr + 2);
      lVar29 = 0;
      do {
        while( true ) {
          plVar22[-1] = (long)local_288;
          pcVar14 = NameForAtom((pFont->info).props[lVar29].name);
          sVar15 = strlen(pcVar14);
          local_288 = local_288 + 1 + (int)sVar15;
          if ((pFont->info).isStringProp[lVar29] == '\0') break;
          lVar24 = lVar29 + 1;
          *plVar22 = (long)local_288;
          pcVar14 = NameForAtom((pFont->info).props[lVar29].value);
          sVar15 = strlen(pcVar14);
          local_288 = local_288 + 1 + (int)sVar15;
          plVar22 = plVar22 + 2;
          lVar29 = lVar24;
          if ((pFont->info).nprops <= (int)lVar24) goto LAB_00123fdf;
        }
        lVar24 = lVar29 + 1;
        *plVar22 = (pFont->info).props[lVar29].value;
        plVar22 = plVar22 + 2;
        lVar29 = lVar24;
      } while ((int)lVar24 < (pFont->info).nprops);
    }
LAB_00123fdf:
    uVar11 = 0x20;
    if (pFont->scan != '\x04') {
      uVar11 = (uint)(pFont->scan == '\x02') << 4;
    }
    if (pFont->bit == '\x01') {
      uVar11 = uVar11 | 8;
    }
    if (pFont->byte == '\x01') {
      uVar11 = uVar11 | 4;
    }
    uVar17 = 2;
    if (pFont->glyph != '\x04') {
      uVar17 = (uint)(pFont->glyph == '\x02');
    }
    uVar11 = uVar17 | uVar11;
    pPVar25 = tables;
    local_284 = 0;
    local_260 = 0;
    uVar30 = 0xfffffff;
    pPVar18 = pPVar25;
    do {
      while( true ) {
        uVar12 = -uVar30 & uVar30;
        pPVar18->type = uVar12;
        uVar30 = uVar30 & ~uVar12;
        if (uVar12 < 0x21) break;
        if (uVar12 == 0x80) {
          pPVar18->format = uVar11;
          iVar31 = *(int *)((long)pvVar7 + 4);
          if (iVar31 < 1) {
            uVar12 = 0;
          }
          else {
            lVar29 = 0;
            iVar21 = 0;
            do {
              lVar24 = lVar29 * 8;
              lVar29 = lVar29 + 1;
              pcVar14 = NameForAtom(*(Atom *)(**(long **)((long)pvVar7 + 0x38) + lVar24));
              sVar15 = strlen(pcVar14);
              iVar21 = iVar21 + 1 + (int)sVar15;
              iVar31 = *(int *)((long)pvVar7 + 4);
            } while ((int)lVar29 < iVar31);
            uVar12 = iVar21 + 3U & 0xfffffffc;
          }
          pPVar18->size = uVar12 + 0xc + iVar31 * 4;
        }
        else {
          if (uVar12 == 0x100) {
            pPVar18->size = 100;
            uVar12 = uVar11 | 0x100;
            if (((pFont->info).field_0xa & 0x20) == 0) {
              uVar12 = uVar11;
            }
            pPVar18->format = uVar12;
LAB_001240e1:
            pPVar18 = pPVar18 + 1;
            goto joined_r0x0012429c;
          }
          if (uVar12 != 0x40) goto joined_r0x0012429c;
          pPVar18->format = uVar11;
          pPVar18->size = *(int *)((long)pvVar7 + 4) * 4 + 8;
        }
joined_r0x0012439a:
        pPVar18 = pPVar18 + 1;
        if (uVar30 == 0) goto LAB_001240ea;
      }
      if ((uVar12 == 0) || (false)) goto joined_r0x0012429c;
      switch(uVar12) {
      case 1:
        pPVar18->format = uVar11;
        iVar31 = (pFont->info).nprops * 9;
        uVar12 = iVar31 + 0xbU & 0xfffffffc;
        local_284 = uVar12 - (iVar31 + 8);
        pPVar18->size = uVar12 + 4 + (local_288 + 3U & 0xfffffffc);
        goto joined_r0x0012439a;
      case 2:
        bVar3 = *(byte *)(*(long *)((long)pvVar7 + 0x38) + 0x2a);
        pPVar18->size = 100;
        uVar12 = uVar11 | 0x100;
        if ((bVar3 & 0x20) == 0) {
          uVar12 = uVar11;
        }
        pPVar18->format = uVar12;
        goto joined_r0x0012429c;
      case 4:
        if ((((ushort)(local_278->leftSideBearing + 0x80U) < 0x100) &&
            ((ushort)(local_278->rightSideBearing + 0x80U) < 0x100)) &&
           (((ushort)(local_278->characterWidth + 0x80U) < 0x100 &&
            (((ushort)(local_278->ascent + 0x80U) < 0x100 &&
             ((ushort)(local_278->descent + 0x80U) < 0x100)))))) {
          CVar6 = local_278->attributes;
          pxVar10 = local_258;
joined_r0x00124c6f:
          if (((((CVar6 == 0) && ((ushort)(pxVar10->leftSideBearing + 0x80U) < 0x100)) &&
               ((ushort)(pxVar10->rightSideBearing + 0x80U) < 0x100)) &&
              (((ushort)(pxVar10->characterWidth + 0x80U) < 0x100 &&
               ((ushort)(pxVar10->ascent + 0x80U) < 0x100)))) &&
             (((ushort)(pxVar10->descent + 0x80U) < 0x100 && (pxVar10->attributes == 0)))) {
            pPVar18->format = uVar11 | 0x100;
            pPVar18->size = *(int *)((long)pvVar7 + 4) * 5 + 9U & 0xfffffffc;
            goto LAB_001240e1;
          }
        }
LAB_001240c9:
        pPVar18->format = uVar11;
        pPVar18->size = *(int *)((long)pvVar7 + 4) * 0xc + 8;
        goto LAB_001240e1;
      case 8:
        pPVar18->format = uVar11;
        pPVar18->size =
             *(int *)(*(long *)((long)pvVar7 + 0x38) + 0x10 + (ulong)uVar17 * 4) + 0x1b +
             *(int *)((long)pvVar7 + 4) * 4 & 0xfffffffc;
joined_r0x0012429c:
        pPVar18 = pPVar18 + 1;
        break;
      case 0x10:
        if (*(long *)((long)pvVar7 + 0x18) != 0) {
          if (((((ushort)(local_268->leftSideBearing + 0x80U) < 0x100) &&
               ((ushort)(local_268->rightSideBearing + 0x80U) < 0x100)) &&
              ((ushort)(local_268->characterWidth + 0x80U) < 0x100)) &&
             (((ushort)(local_268->ascent + 0x80U) < 0x100 &&
              ((ushort)(local_268->descent + 0x80U) < 0x100)))) {
            CVar6 = local_268->attributes;
            pxVar10 = local_250;
            goto joined_r0x00124c6f;
          }
          goto LAB_001240c9;
        }
        break;
      case 0x20:
        uVar4 = (pFont->info).lastRow;
        uVar5 = (pFont->info).firstCol;
        pPVar18->format = uVar11;
        local_260 = (((uint)uVar4 - (uint)(pFont->info).firstRow) + 1) *
                    (((uint)(pFont->info).lastCol - (uint)uVar5) + 1);
        pPVar18->size = local_260 * 2 + 0x11 & 0xfffffffc;
        pPVar18 = pPVar18 + 1;
      }
joined_r0x0012429c:
    } while (uVar30 != 0);
LAB_001240ea:
    CVar13 = (int)((long)pPVar18 - (long)pPVar25) + 8;
    iVar31 = (int)((long)pPVar18 - (long)pPVar25 >> 4);
    if (iVar31 < 1) {
      current_position = 0;
      pcfPutLSB32(file,0x70636601);
      pcfPutLSB32(file,iVar31);
    }
    else {
      pPVar16 = pPVar25 + (ulong)(iVar31 - 1) + 1;
      pPVar18 = pPVar25;
      do {
        pPVar18->offset = CVar13;
        CVar13 = CVar13 + pPVar18->size;
        pPVar18 = pPVar18 + 1;
      } while (pPVar18 != pPVar16);
      current_position = 0;
      pcfPutLSB32(file,0x70636601);
      pcfPutLSB32(file,iVar31);
      pPVar18 = pPVar25;
      do {
        pPVar23 = pPVar18 + 1;
        pcfPutLSB32(file,pPVar18->type);
        pcfPutLSB32(file,pPVar18->format);
        pcfPutLSB32(file,pPVar18->size);
        pcfPutLSB32(file,pPVar18->offset);
        pPVar18 = pPVar23;
      } while (pPVar23 != pPVar16);
      do {
        uVar19 = (ulong)current_position;
        if (pPVar25->offset < current_position) {
          __printf_chk(1,"can\'t go backwards... %d > %d\n");
          free(__ptr);
          iVar31 = 0x53;
          goto LAB_001243ee;
        }
        if (current_position < pPVar25->offset) {
          do {
            pcfPutINT8(file,0,(int)uVar19);
            uVar19 = extraout_RDX;
          } while (current_position < pPVar25->offset);
        }
        pcfPutLSB32(file,pPVar25->format);
        uVar30 = pPVar25->type;
        if (uVar30 < 0x21) {
          if ((uVar30 != 0) && (true)) {
            switch(uVar30) {
            case 1:
              lVar29 = 0;
              pcfPutINT32(file,uVar11,(pFont->info).nprops);
              uVar20 = extraout_RDX_00;
              piVar26 = __ptr;
              if (0 < (pFont->info).nprops) {
                do {
                  pcfPutINT32(file,uVar11,*piVar26);
                  pcVar14 = (pFont->info).isStringProp + lVar29;
                  lVar29 = lVar29 + 1;
                  pcfPutINT8(file,(int)*pcVar14,c);
                  pcfPutINT32(file,uVar11,piVar26[2]);
                  uVar20 = extraout_RDX_01;
                  piVar26 = piVar26 + 4;
                } while ((int)lVar29 < (pFont->info).nprops);
              }
              iVar31 = 0;
              if (0 < local_284) {
                do {
                  iVar31 = iVar31 + 1;
                  pcfPutINT8(file,0,(int)uVar20);
                  uVar20 = extraout_RDX_02;
                } while (local_284 != iVar31);
              }
              lVar29 = 0;
              pcfPutINT32(file,uVar11,local_288);
              if (0 < (pFont->info).nprops) {
                do {
                  while( true ) {
                    pcVar14 = NameForAtom((pFont->info).props[lVar29].name);
                    sVar15 = strlen(pcVar14);
                    iVar31 = (int)sVar15 + 1;
                    current_position = current_position + iVar31;
                    BufFileWrite(file,pcVar14,iVar31);
                    if ((pFont->info).isStringProp[lVar29] == '\0') break;
                    lVar24 = lVar29 + 1;
                    pcVar14 = NameForAtom((pFont->info).props[lVar29].value);
                    sVar15 = strlen(pcVar14);
                    iVar31 = (int)sVar15 + 1;
                    current_position = current_position + iVar31;
                    BufFileWrite(file,pcVar14,iVar31);
                    lVar29 = lVar24;
                    if ((pFont->info).nprops <= (int)lVar24) goto joined_r0x00124632;
                  }
                  lVar29 = lVar29 + 1;
                } while ((int)lVar29 < (pFont->info).nprops);
              }
              break;
            case 2:
              pcfPutAccel(file,pPVar25->format,(FontInfoPtr)(*(long *)((long)pvVar7 + 0x38) + 0x20))
              ;
              break;
            case 4:
              if (pPVar25->format >> 8 == 1) {
                pcfPutINT16(file,uVar11,*(int *)((long)pvVar7 + 4));
                if (0 < *(int *)((long)pvVar7 + 4)) {
                  lVar29 = 0;
                  do {
                    lVar24 = lVar29 + 1;
                    pcfPutCompressedMetric
                              (file,(int)*(undefined8 *)((long)pvVar7 + 0x10) + (int)lVar29 * 0x18,
                               (xCharInfo *)(lVar29 * 3));
                    lVar29 = lVar24;
                  } while ((int)lVar24 < *(int *)((long)pvVar7 + 4));
                }
              }
              else {
                pcfPutINT32(file,uVar11,*(int *)((long)pvVar7 + 4));
                if (0 < *(int *)((long)pvVar7 + 4)) {
                  lVar29 = 0;
                  do {
                    lVar24 = lVar29 + 1;
                    pcfPutMetric(file,uVar11,
                                 (xCharInfo *)(*(long *)((long)pvVar7 + 0x10) + lVar29 * 0x18));
                    lVar29 = lVar24;
                  } while ((int)lVar24 < *(int *)((long)pvVar7 + 4));
                }
              }
              break;
            case 8:
              lVar29 = 0;
              pcfPutINT32(file,uVar11,*(int *)((long)pvVar7 + 4));
              iVar31 = 0;
              if (0 < *(int *)((long)pvVar7 + 4)) {
                do {
                  pcfPutINT32(file,uVar11,iVar31);
                  psVar1 = (short *)(*(long *)((long)pvVar7 + 0x10) + lVar29 * 0x18);
                  if (uVar17 == 0) {
                    uVar30 = ((int)psVar1[1] - (int)*psVar1) + 7 >> 3;
                  }
                  else {
                    iVar21 = (int)psVar1[1] - (int)*psVar1;
                    if (uVar17 == 1) {
                      uVar30 = iVar21 + 0xf >> 3 & 0xfffffffe;
                    }
                    else if (uVar17 == 2) {
                      uVar30 = iVar21 + 0x1f >> 3 & 0xfffffffc;
                    }
                    else {
                      uVar30 = iVar21 + 0x3f >> 3 & 0xfffffff8;
                    }
                  }
                  lVar29 = lVar29 + 1;
                  iVar31 = iVar31 + uVar30 * ((int)psVar1[3] + (int)psVar1[4]);
                } while ((int)lVar29 < *(int *)((long)pvVar7 + 4));
              }
              iVar31 = 0;
              do {
                lVar29 = (long)iVar31;
                iVar31 = iVar31 + 1;
                pcfPutINT32(file,uVar11,*(int *)(*(long *)((long)pvVar7 + 0x38) + 0x10 + lVar29 * 4)
                           );
              } while (iVar31 != 4);
              if (0 < *(int *)((long)pvVar7 + 4)) {
                lVar29 = 0;
                do {
                  psVar1 = (short *)(*(long *)((long)pvVar7 + 0x10) + lVar29 * 0x18);
                  iVar31 = (int)psVar1[1] - (int)*psVar1;
                  if (uVar17 == 0) {
                    uVar30 = iVar31 + 7 >> 3;
                  }
                  else if (uVar17 == 1) {
                    uVar30 = iVar31 + 0xf >> 3 & 0xfffffffe;
                  }
                  else if (uVar17 == 2) {
                    uVar30 = iVar31 + 0x1f >> 3 & 0xfffffffc;
                  }
                  else {
                    uVar30 = iVar31 + 0x3f >> 3 & 0xfffffff8;
                  }
                  iVar31 = uVar30 * ((int)psVar1[3] + (int)psVar1[4]);
                  current_position = current_position + iVar31;
                  pbVar2 = *(byte **)(psVar1 + 8) + (ulong)(iVar31 - 1) + 1;
                  pbVar27 = *(byte **)(psVar1 + 8);
                  if (iVar31 != 0) {
                    do {
                      while( true ) {
                        pbVar28 = pbVar27 + 1;
                        iVar31 = file->left + -1;
                        file->left = iVar31;
                        if (iVar31 != 0) break;
                        (*file->output)((uint)*pbVar27,file);
                        pbVar27 = pbVar28;
                        if (pbVar2 == pbVar28) goto LAB_00124b01;
                      }
                      pbVar9 = file->bufp;
                      file->bufp = pbVar9 + 1;
                      *pbVar9 = *pbVar27;
                      pbVar27 = pbVar28;
                    } while (pbVar2 != pbVar28);
                  }
LAB_00124b01:
                  lVar29 = lVar29 + 1;
                } while ((int)lVar29 < *(int *)((long)pvVar7 + 4));
              }
              break;
            case 0x10:
              if (pPVar25->format >> 8 == 1) {
                pcfPutINT16(file,uVar11,*(int *)((long)pvVar7 + 4));
                if (0 < *(int *)((long)pvVar7 + 4)) {
                  lVar29 = 0;
                  do {
                    lVar24 = lVar29 + 1;
                    pcfPutCompressedMetric
                              (file,(int)*(undefined8 *)((long)pvVar7 + 0x18) + (int)lVar29 * 0xc,
                               (xCharInfo *)(lVar29 * 3));
                    lVar29 = lVar24;
                  } while ((int)lVar24 < *(int *)((long)pvVar7 + 4));
                }
              }
              else {
                pcfPutINT32(file,uVar11,*(int *)((long)pvVar7 + 4));
                if (0 < *(int *)((long)pvVar7 + 4)) {
                  lVar29 = 0;
                  do {
                    lVar24 = lVar29 + 1;
                    pcfPutMetric(file,uVar11,
                                 (xCharInfo *)(*(long *)((long)pvVar7 + 0x18) + lVar29 * 0xc));
                    lVar29 = lVar24;
                  } while ((int)lVar24 < *(int *)((long)pvVar7 + 4));
                }
              }
              break;
            case 0x20:
              pcfPutINT16(file,uVar11,(uint)(pFont->info).firstCol);
              pcfPutINT16(file,uVar11,(uint)(pFont->info).lastCol);
              pcfPutINT16(file,uVar11,(uint)(pFont->info).firstRow);
              pcfPutINT16(file,uVar11,(uint)(pFont->info).lastRow);
              pcfPutINT16(file,uVar11,(uint)(pFont->info).defaultCh);
              if (0 < (int)local_260) {
                uVar30 = 0;
                do {
                  while ((lVar29 = *(long *)(*(long *)((long)pvVar7 + 0x28) +
                                            (long)((int)uVar30 >> 7) * 8), lVar29 != 0 &&
                         (lVar29 = *(long *)(lVar29 + (ulong)(uVar30 & 0x7f) * 8), lVar29 != 0))) {
                    uVar30 = uVar30 + 1;
                    pcfPutINT16(file,uVar11,
                                (int)(lVar29 - *(long *)((long)pvVar7 + 0x10) >> 3) * -0x55555555);
                    if (uVar30 == local_260) goto joined_r0x00124632;
                  }
                  uVar30 = uVar30 + 1;
                  pcfPutINT16(file,uVar11,0xffff);
                } while (uVar30 != local_260);
              }
            }
          }
        }
        else if (uVar30 == 0x80) {
          pcfPutINT32(file,uVar11,*(int *)((long)pvVar7 + 4));
          if (*(int *)((long)pvVar7 + 4) < 1) {
            iVar31 = 0;
          }
          else {
            iVar31 = 0;
            lVar29 = 0;
            do {
              pcfPutINT32(file,uVar11,iVar31);
              lVar24 = lVar29 * 8;
              lVar29 = lVar29 + 1;
              pcVar14 = NameForAtom(*(Atom *)(**(long **)((long)pvVar7 + 0x38) + lVar24));
              sVar15 = strlen(pcVar14);
              iVar31 = iVar31 + 1 + (int)sVar15;
            } while ((int)lVar29 < *(int *)((long)pvVar7 + 4));
          }
          pcfPutINT32(file,uVar11,iVar31);
          if (0 < *(int *)((long)pvVar7 + 4)) {
            lVar29 = 0;
            do {
              lVar24 = lVar29 * 8;
              lVar29 = lVar29 + 1;
              pcVar14 = NameForAtom(*(Atom *)(**(long **)((long)pvVar7 + 0x38) + lVar24));
              sVar15 = strlen(pcVar14);
              iVar31 = (int)sVar15 + 1;
              current_position = current_position + iVar31;
              BufFileWrite(file,pcVar14,iVar31);
            } while ((int)lVar29 < *(int *)((long)pvVar7 + 4));
          }
        }
        else if (uVar30 == 0x100) {
          pcfPutAccel(file,pPVar25->format,&pFont->info);
        }
        else if ((uVar30 == 0x40) &&
                (pcfPutINT32(file,uVar11,*(int *)((long)pvVar7 + 4)), 0 < *(int *)((long)pvVar7 + 4)
                )) {
          lVar29 = 0;
          do {
            lVar24 = lVar29 * 4;
            lVar29 = lVar29 + 1;
            pcfPutINT32(file,uVar11,*(int *)(*(long *)(*(long *)((long)pvVar7 + 0x38) + 8) + lVar24)
                       );
          } while ((int)lVar29 < *(int *)((long)pvVar7 + 4));
        }
joined_r0x00124632:
        pPVar25 = pPVar25 + 1;
      } while (pPVar25 != pPVar16);
    }
    free(__ptr);
    iVar31 = 0x55;
  }
LAB_001243ee:
  if (lVar8 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar31;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void snfUnloadFont(FontPtr pFont)

{
  void *__ptr;
  
  __ptr = pFont->fontPrivate;
  free(*(void **)((long)__ptr + 0x20));
  free(__ptr);
  DestroyFontRec(pFont);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void snfError(char *message,...)

{
  long lVar1;
  char in_AL;
  undefined8 in_RCX;
  undefined8 in_RDX;
  undefined8 in_RSI;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  va_list args;
  undefined local_c8 [8];
  undefined8 local_c0;
  undefined8 local_b8;
  undefined8 local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  
  if (in_AL != '\0') {
    local_98 = in_XMM0_Qa;
    local_88 = in_XMM1_Qa;
    local_78 = in_XMM2_Qa;
    local_68 = in_XMM3_Qa;
    local_58 = in_XMM4_Qa;
    local_48 = in_XMM5_Qa;
    local_38 = in_XMM6_Qa;
    local_28 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  args[0].overflow_arg_area = &stack0x00000008;
  args[0].gp_offset = 8;
  args[0].reg_save_area = local_c8;
  args[0].fp_offset = 0x30;
  local_c0 = in_RSI;
  local_b8 = in_RDX;
  local_b0 = in_RCX;
  local_a8 = in_R8;
  local_a0 = in_R9;
  fwrite("SNF Error: ",1,0xb,_stderr);
  __vfprintf_chk(_stderr,1,message,args);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int snfReadHeader(snfFontInfoPtr snfInfo,FontFilePtr file)

{
  int iVar1;
  bool bVar2;
  
  iVar1 = BufFileRead(file,(char *)snfInfo,0x6c);
  if ((iVar1 == 0x6c) && (snfInfo->version1 == 4)) {
    bVar2 = snfInfo->version2 == 4;
    return bVar2 + 0x53 + (uint)bVar2;
  }
  return 0x53;
}



// DWARF original prototype: int snfReadProps(snfFontInfoPtr snfInfo, FontInfoPtr pFontInfo,
// FontFilePtr file, FontInfoPtr pFontInfo, snfFontInfoPtr snfInfo)

int snfReadProps(snfFontInfoPtr snfInfo,FontInfoPtr pFontInfo,FontFilePtr file,
                FontInfoPtr pFontInfo_1,snfFontInfoPtr snfInfo_1)

{
  uint uVar1;
  int iVar2;
  uint *b;
  size_t sVar3;
  Atom AVar4;
  uint *puVar5;
  uint uVar6;
  char *pcVar7;
  Atom *pAVar8;
  long lVar9;
  
  uVar6 = (int)pFontInfo + snfInfo->version1 * 0xc;
  b = (uint *)malloc((long)(int)uVar6);
  if (b == (uint *)0x0) {
    snfError("snfReadProps(): Couldn\'t allocate propspace (%d)\n",(ulong)uVar6);
    iVar2 = 0x50;
  }
  else {
    uVar1 = BufFileRead((BufFilePtr)snfInfo_1,(char *)b,uVar6);
    if (uVar6 != uVar1) {
      free(b);
      return 0x53;
    }
    uVar6 = snfInfo->version1;
    pAVar8 = (Atom *)file->bufp;
    if (uVar6 != 0) {
      lVar9 = 0;
      puVar5 = b;
      do {
        pcVar7 = (char *)((long)b + (ulong)*puVar5 + (ulong)uVar6 * 0xc);
        sVar3 = strlen(pcVar7);
        AVar4 = MakeAtom(pcVar7,(uint)sVar3,1);
        *pAVar8 = AVar4;
        *(char *)(*(long *)pFontInfo_1 + lVar9) = (char)puVar5[2];
        if (puVar5[2] == 0) {
          pAVar8[1] = (long)(int)puVar5[1];
        }
        else {
          pcVar7 = (char *)((long)b + (long)(int)puVar5[1] + (ulong)uVar6 * 0xc);
          sVar3 = strlen(pcVar7);
          AVar4 = MakeAtom(pcVar7,(uint)sVar3,1);
          pAVar8[1] = (long)(int)AVar4;
        }
        pAVar8 = pAVar8 + 2;
        puVar5 = puVar5 + 3;
        lVar9 = lVar9 + 1;
      } while ((uint)lVar9 < snfInfo->version1);
    }
    free(b);
    iVar2 = 0x55;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

void SnfSetFormat(int bit,int byte,int glyph,int scan)

{
  snf_bit = bit;
  snf_byte = byte;
  snf_glyph = glyph;
  snf_scan = scan;
  snf_set = 1;
  return;
}



int snfReadFont(FontPtr pFont,FontFilePtr file,int bit,int byte,int glyph,int scan)

{
  long *plVar1;
  int iVar2;
  ushort uVar3;
  ushort uVar4;
  ushort uVar5;
  long lVar6;
  short *psVar7;
  byte bVar8;
  int srcPad;
  int iVar9;
  int iVar10;
  ushort uVar11;
  int iVar12;
  uint uVar13;
  int iVar14;
  void *__ptr;
  uchar *buf;
  long lVar15;
  long lVar16;
  char *pDst;
  ushort uVar17;
  short *psVar18;
  int iVar19;
  int iVar20;
  long lVar21;
  ulong uVar22;
  void *pvVar23;
  uint uVar24;
  undefined8 *puVar25;
  int iVar26;
  short *psVar27;
  uint uVar28;
  long in_FS_OFFSET;
  bool bVar29;
  char local_f8;
  char local_f4;
  char local_e4;
  char local_e0;
  snfCharInfoRec snfCharInfo;
  snfFontInfoRec fi;
  
  lVar6 = *(long *)(in_FS_OFFSET + 0x28);
  iVar12 = snfReadHeader(&fi,file);
  if (iVar12 != 0x55) goto LAB_001251a4;
  if (snf_set == 0) {
    FontDefaultFormat(&snf_bit,&snf_byte,&snf_glyph,&snf_scan);
  }
  iVar10 = snf_bit;
  iVar9 = snf_byte;
  srcPad = snf_glyph;
  iVar14 = snf_scan;
  uVar13 = (fi.maxbounds._12_4_ & 0xffffff) + 3 & 0xfffffffc;
  iVar19 = ((fi.lastRow + 1) - fi.firstRow) * ((fi.lastCol + 1) - fi.firstCol);
  iVar26 = iVar19 * 0x18 + 0x40;
  iVar12 = iVar19 + 0xfe;
  if (-1 < iVar19 + 0x7f) {
    iVar12 = iVar19 + 0x7f;
  }
  iVar2 = iVar26 + (iVar12 >> 7) * 8;
  iVar20 = fi.nProps * 0x10 + iVar2;
  uVar24 = fi.nProps + 3 + iVar20 & 0xfffffffc;
  uVar28 = uVar24 + iVar19 * 0xc;
  if ((fi._24_1_ & 8) == 0) {
    uVar28 = uVar24;
  }
  bVar8 = fi._24_1_ & 8;
  __ptr = malloc((ulong)uVar28);
  if (__ptr == (void *)0x0) {
    iVar12 = 0x50;
    snfError("snfReadFont(): Couldn\'t allocate fontspace (%d)\n",uVar28);
    goto LAB_001251a4;
  }
  buf = (uchar *)malloc((long)(int)uVar13);
  if (buf == (uchar *)0x0) {
    iVar12 = 0x50;
    snfError("snfReadFont(): Couldn\'t allocate bitmaps (%d)\n",(ulong)uVar13);
    free(__ptr);
    goto LAB_001251a4;
  }
  pvVar23 = (void *)((long)iVar26 + (long)__ptr);
  *(int *)((long)__ptr + 4) = iVar19;
  *(long *)((long)__ptr + 0x10) = (long)__ptr + 0x40;
  *(uchar **)((long)__ptr + 0x20) = buf;
  (pFont->info).isStringProp = (char *)((long)iVar20 + (long)__ptr);
  lVar15 = (long)(int)uVar24 + (long)__ptr;
  *(void **)((long)__ptr + 0x28) = pvVar23;
  if (bVar8 == 0) {
    lVar15 = 0;
  }
  (pFont->info).props = (FontPropPtr)((long)iVar2 + (long)__ptr);
  *(undefined8 *)((long)__ptr + 0x30) = 0;
  *(undefined8 *)((long)__ptr + 0x38) = 0;
  *(long *)((long)__ptr + 0x18) = lVar15;
  memset(pvVar23,0,(long)(iVar12 >> 7) << 3);
  if (iVar19 < 1) {
LAB_001254d4:
    uVar28 = BufFileRead(file,(char *)buf,uVar13);
    if (uVar28 != uVar13) {
      iVar12 = 0x53;
      free(buf);
      free(__ptr);
      goto LAB_001251a4;
    }
    if (bit != iVar10) {
      BitOrderInvert(buf,uVar13);
    }
    if ((iVar10 == iVar9) != (bit == byte)) {
      if (bit != byte) {
        iVar14 = scan;
      }
      if (iVar14 == 2) {
        TwoByteSwap(buf,uVar13);
      }
      else if (iVar14 == 4) {
        FourByteSwap(buf,uVar13);
      }
    }
    if (glyph != srcPad) {
      psVar7 = *(short **)((long)__ptr + 0x10);
      if (iVar19 < 1) {
        pvVar23 = malloc(0);
        if (pvVar23 == (void *)0x0) {
          uVar22 = 0;
          goto LAB_00125a6e;
        }
        *(void **)((long)__ptr + 0x20) = pvVar23;
      }
      else {
        uVar13 = 0;
        psVar18 = psVar7;
        do {
          if (*(long *)(psVar18 + 8) != 0) {
            iVar12 = (int)psVar18[4] + (int)psVar18[3];
            if (glyph == 1) {
              uVar13 = uVar13 + iVar12 * (((int)psVar18[1] - (int)*psVar18) + 7 >> 3);
            }
            else if (glyph == 2) {
              uVar13 = uVar13 + iVar12 * (((int)psVar18[1] - (int)*psVar18) + 0xf >> 3 & 0xfffffffeU
                                         );
            }
            else if (glyph == 4) {
              uVar13 = uVar13 + iVar12 * (((int)psVar18[1] - (int)*psVar18) + 0x1f >> 3 &
                                         0xfffffffcU);
            }
            else if (glyph == 8) {
              uVar13 = uVar13 + iVar12 * (((int)psVar18[1] - (int)*psVar18) + 0x3f >> 3 &
                                         0xfffffff8U);
            }
          }
          psVar18 = psVar18 + 0xc;
        } while (psVar18 != psVar7 + ((ulong)(iVar19 - 1) * 3 + 3) * 4);
        pDst = (char *)malloc((long)(int)uVar13);
        uVar22 = (ulong)uVar13;
        if (pDst == (char *)0x0) {
LAB_00125a6e:
          iVar12 = 0x50;
          snfError("snfReadFont(): Couldn\'t allocate padbitmaps (%d)\n",uVar22);
          free(buf);
          free(__ptr);
          goto LAB_001251a4;
        }
        *(char **)((long)__ptr + 0x20) = pDst;
        psVar18 = psVar7;
        do {
          psVar27 = psVar18 + 0xc;
          iVar12 = RepadBitmap(*(char **)(psVar18 + 8),pDst,srcPad,glyph,
                               (int)psVar18[1] - (int)*psVar18,(int)psVar18[3] + (int)psVar18[4]);
          *(char **)(psVar18 + 8) = pDst;
          pDst = pDst + iVar12;
          psVar18 = psVar27;
        } while (psVar27 != psVar7 + ((ulong)(iVar19 - 1) * 3 + 3) * 4);
      }
      free(buf);
    }
    iVar12 = snfReadProps((snfFontInfoPtr)&fi.nProps,(FontInfoPtr)(ulong)fi.lenStrings,
                          (FontFilePtr)&(pFont->info).props,(FontInfoPtr)&(pFont->info).isStringProp
                          ,(snfFontInfoPtr)file);
    if (iVar12 == 0x55) {
      (pFont->info).firstCol = (ushort)fi.firstCol;
      (pFont->info).lastCol = (ushort)fi.lastCol;
      (pFont->info).fontAscent = (short)fi.fontAscent;
      (pFont->info).firstRow = (ushort)fi.firstRow;
      (pFont->info).minbounds.leftSideBearing = fi.minbounds.metrics.leftSideBearing;
      (pFont->info).minbounds.rightSideBearing = fi.minbounds.metrics.rightSideBearing;
      (pFont->info).minbounds.characterWidth = fi.minbounds.metrics.characterWidth;
      (pFont->info).minbounds.ascent = fi.minbounds.metrics.ascent;
      (pFont->info).lastRow = (ushort)fi.lastRow;
      (pFont->info).minbounds.descent = fi.minbounds.metrics.descent;
      (pFont->info).minbounds.attributes = fi.minbounds.metrics.attributes;
      (pFont->info).defaultCh = (ushort)fi.chDefault;
      (pFont->info).fontDescent = (short)fi.fontDescent;
      *(uint *)&(pFont->info).field_0xa =
           fi.terminalFont * 2 & 2 | (uint)CONCAT11(2,(byte)fi.noOverlap & 1) |
           fi.constantMetrics * 4 & 4 | ((byte)fi._24_1_ >> 1 & 1) << 3 |
           ((byte)fi._24_1_ >> 2 & 1) << 4 | ((byte)fi._24_1_ >> 3 & 1) << 5 |
           (fi.allExist & 1) << 6 | (fi.drawDirection & 3) << 7 |
           *(uint *)&(pFont->info).field_0xa & 0xf800;
      (pFont->info).maxbounds.leftSideBearing = fi.maxbounds.metrics.leftSideBearing;
      (pFont->info).maxbounds.rightSideBearing = fi.maxbounds.metrics.rightSideBearing;
      (pFont->info).maxbounds.characterWidth = fi.maxbounds.metrics.characterWidth;
      (pFont->info).maxbounds.ascent = fi.maxbounds.metrics.ascent;
      (pFont->info).maxbounds.descent = fi.maxbounds.metrics.descent;
      (pFont->info).maxbounds.attributes = fi.maxbounds.metrics.attributes;
      (pFont->info).nprops = fi.nProps;
      if ((fi._24_1_ & 8) == 0) {
        (pFont->info).ink_minbounds.leftSideBearing = fi.minbounds.metrics.leftSideBearing;
        (pFont->info).ink_minbounds.rightSideBearing = fi.minbounds.metrics.rightSideBearing;
        (pFont->info).ink_minbounds.characterWidth = fi.minbounds.metrics.characterWidth;
        (pFont->info).ink_minbounds.ascent = fi.minbounds.metrics.ascent;
        (pFont->info).ink_minbounds.descent = fi.minbounds.metrics.descent;
        (pFont->info).ink_minbounds.attributes = fi.minbounds.metrics.attributes;
        (pFont->info).ink_maxbounds.leftSideBearing = fi.maxbounds.metrics.leftSideBearing;
        (pFont->info).ink_maxbounds.rightSideBearing = fi.maxbounds.metrics.rightSideBearing;
        (pFont->info).ink_maxbounds.characterWidth = fi.maxbounds.metrics.characterWidth;
        (pFont->info).ink_maxbounds.ascent = fi.maxbounds.metrics.ascent;
        (pFont->info).ink_maxbounds.descent = fi.maxbounds.metrics.descent;
        (pFont->info).ink_maxbounds.attributes = fi.maxbounds.metrics.attributes;
      }
      else {
        iVar14 = BufFileRead(file,(char *)&snfCharInfo,0x10);
        if (iVar14 == 0x10) {
          (pFont->info).ink_minbounds.leftSideBearing = snfCharInfo.metrics.leftSideBearing;
          (pFont->info).ink_minbounds.rightSideBearing = snfCharInfo.metrics.rightSideBearing;
          (pFont->info).ink_minbounds.characterWidth = snfCharInfo.metrics.characterWidth;
          (pFont->info).ink_minbounds.ascent = snfCharInfo.metrics.ascent;
          (pFont->info).ink_minbounds.descent = snfCharInfo.metrics.descent;
          (pFont->info).ink_minbounds.attributes = snfCharInfo.metrics.attributes;
        }
        iVar14 = BufFileRead(file,(char *)&snfCharInfo,0x10);
        if (iVar14 != 0x10) {
LAB_001259ac:
          iVar12 = 0x53;
          free(__ptr);
          goto LAB_001251a4;
        }
        (pFont->info).ink_maxbounds.leftSideBearing = snfCharInfo.metrics.leftSideBearing;
        (pFont->info).ink_maxbounds.rightSideBearing = snfCharInfo.metrics.rightSideBearing;
        (pFont->info).ink_maxbounds.characterWidth = snfCharInfo.metrics.characterWidth;
        (pFont->info).ink_maxbounds.ascent = snfCharInfo.metrics.ascent;
        (pFont->info).ink_maxbounds.descent = snfCharInfo.metrics.descent;
        (pFont->info).ink_maxbounds.attributes = snfCharInfo.metrics.attributes;
        if (iVar19 < 1) {
          fi.chDefault = (uint)(pFont->info).defaultCh;
        }
        else {
          lVar15 = 0;
          do {
            puVar25 = (undefined8 *)(*(long *)((long)__ptr + 0x18) + lVar15);
            iVar14 = BufFileRead(file,(char *)&snfCharInfo,0x10);
            if (iVar14 != 0x10) goto LAB_001259ac;
            lVar15 = lVar15 + 0xc;
            *puVar25 = snfCharInfo.metrics._0_8_;
            *(undefined4 *)(puVar25 + 1) = snfCharInfo.metrics._8_4_;
          } while (lVar15 != ((ulong)(iVar19 - 1) * 3 + 3) * 4);
          fi.chDefault = (uint)(pFont->info).defaultCh;
        }
      }
      if ((ushort)fi.chDefault != 0xffff) {
        uVar11 = (ushort)fi.chDefault >> 8;
        uVar3 = (pFont->info).firstRow;
        if ((uVar3 <= uVar11) && (uVar11 <= (pFont->info).lastRow)) {
          uVar4 = (pFont->info).firstCol;
          uVar17 = (ushort)(fi.chDefault & 0xff);
          if ((uVar4 <= uVar17) && (uVar5 = (pFont->info).lastCol, uVar17 <= uVar5)) {
            *(ulong *)((long)__ptr + 0x30) =
                 *(long *)((long)__ptr + 0x10) +
                 (ulong)(((uint)uVar11 - (uint)uVar3) * (((uint)uVar5 - (uint)uVar4) + 1) +
                        ((fi.chDefault & 0xff) - (uint)uVar4)) * 0x18;
          }
        }
      }
      *(undefined8 *)((long)__ptr + 0x38) = 0;
      pFont->get_glyphs = bitmapGetGlyphs;
      pFont->fontPrivate = __ptr;
      pFont->get_metrics = bitmapGetMetrics;
      pFont->unload_font = snfUnloadFont;
      local_f8 = (char)bit;
      pFont->unload_glyphs = (_func_void_FontPtr *)0x0;
      pFont->bit = local_f8;
      local_e4 = (char)byte;
      pFont->byte = local_e4;
      local_f4 = (char)glyph;
      pFont->glyph = local_f4;
      local_e0 = (char)scan;
      pFont->scan = local_e0;
      goto LAB_001251a4;
    }
  }
  else {
    lVar15 = 0;
    uVar28 = 0;
    do {
      lVar16 = *(long *)((long)__ptr + 0x10);
      iVar12 = BufFileRead(file,(char *)&snfCharInfo,0x10);
      if (iVar12 == 0x10) {
        puVar25 = (undefined8 *)(lVar16 + lVar15);
        *puVar25 = snfCharInfo.metrics._0_8_;
        *(undefined4 *)(puVar25 + 1) = snfCharInfo.metrics._8_4_;
        if ((snfCharInfo._12_4_ & 0x1000000) == 0) {
          puVar25[2] = 0;
        }
        else {
          puVar25[2] = buf + (snfCharInfo._12_4_ & 0xffffff);
        }
        lVar16 = *(long *)((long)__ptr + 0x10);
        iVar12 = 0x55;
        if (*(long *)(lVar16 + 0x10 + lVar15) != 0) goto LAB_001253f0;
        bVar29 = true;
      }
      else {
        lVar16 = *(long *)((long)__ptr + 0x10);
        if (*(long *)(lVar16 + 0x10 + lVar15) == 0) {
          uVar28 = uVar28 + 1;
          iVar12 = 0x53;
          goto LAB_0012547d;
        }
        iVar12 = 0x53;
LAB_001253f0:
        plVar1 = (long *)(*(long *)((long)__ptr + 0x28) + (long)((int)uVar28 >> 7) * 8);
        lVar21 = *plVar1;
        if (lVar21 == 0) {
          pvVar23 = calloc(0x80,8);
          *plVar1 = (long)pvVar23;
          lVar21 = *(long *)(*(long *)((long)__ptr + 0x28) + (long)((int)uVar28 >> 7) * 8);
          if (lVar21 == 0) {
            iVar12 = 0x50;
            goto LAB_0012547d;
          }
          lVar16 = *(long *)((long)__ptr + 0x10);
        }
        bVar29 = iVar12 == 0x55;
        *(long *)(lVar21 + (ulong)(uVar28 & 0x7f) * 8) = lVar16 + lVar15;
      }
      uVar28 = uVar28 + 1;
      lVar15 = lVar15 + 0x18;
    } while (((int)uVar28 < iVar19) && (bVar29));
    if (iVar12 == 0x55) goto LAB_001254d4;
LAB_0012547d:
    free(buf);
    lVar15 = *(long *)((long)__ptr + 0x28);
    if ((lVar15 != 0) && ((int)uVar28 >> 7 != 0)) {
      iVar14 = 0;
      while( true ) {
        iVar14 = iVar14 + 1;
        free(*(void **)(lVar15 + (long)(int)uVar28 * 8));
        if ((int)uVar28 >> 7 == iVar14) break;
        lVar15 = *(long *)((long)__ptr + 0x28);
      }
    }
  }
  free(__ptr);
LAB_001251a4:
  if (lVar6 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar12;
}



int snfReadFontInfo(FontInfoPtr pFontInfo,FontFilePtr file)

{
  long lVar1;
  INT16 IVar2;
  INT16 IVar3;
  INT16 IVar4;
  CARD16 CVar5;
  int iVar6;
  int iVar7;
  FontPropPtr p_Var8;
  char *pcVar9;
  ulong __size;
  long in_FS_OFFSET;
  snfCharInfoRec snfCharInfo;
  snfFontInfoRec fi;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar6 = snfReadHeader(&fi,file);
  if (iVar6 == 0x55) {
    __size = (ulong)fi.nProps;
    pFontInfo->firstCol = (ushort)fi.firstCol;
    pFontInfo->lastCol = (ushort)fi.lastCol;
    pFontInfo->defaultCh = (ushort)fi.chDefault;
    pFontInfo->firstRow = (ushort)fi.firstRow;
    pFontInfo->lastRow = (ushort)fi.lastRow;
    *(uint *)&pFontInfo->field_0xa =
         fi.terminalFont * 2 & 2 | (uint)CONCAT11(2,(byte)fi.noOverlap & 1) |
         fi.constantMetrics * 4 & 4 | ((byte)fi._24_1_ >> 1 & 1) << 3 |
         ((byte)fi._24_1_ >> 2 & 1) << 4 | ((byte)fi._24_1_ >> 3 & 1) << 5 | (fi.allExist & 1) << 6
         | (fi.drawDirection & 3) << 7 | *(uint *)&pFontInfo->field_0xa & 0xf800;
    (pFontInfo->minbounds).leftSideBearing = fi.minbounds.metrics.leftSideBearing;
    (pFontInfo->minbounds).rightSideBearing = fi.minbounds.metrics.rightSideBearing;
    (pFontInfo->minbounds).characterWidth = fi.minbounds.metrics.characterWidth;
    (pFontInfo->minbounds).ascent = fi.minbounds.metrics.ascent;
    (pFontInfo->minbounds).descent = fi.minbounds.metrics.descent;
    (pFontInfo->minbounds).attributes = fi.minbounds.metrics.attributes;
    (pFontInfo->maxbounds).leftSideBearing = fi.maxbounds.metrics.leftSideBearing;
    (pFontInfo->maxbounds).rightSideBearing = fi.maxbounds.metrics.rightSideBearing;
    (pFontInfo->maxbounds).characterWidth = fi.maxbounds.metrics.characterWidth;
    (pFontInfo->maxbounds).ascent = fi.maxbounds.metrics.ascent;
    (pFontInfo->maxbounds).descent = fi.maxbounds.metrics.descent;
    (pFontInfo->maxbounds).attributes = fi.maxbounds.metrics.attributes;
    pFontInfo->fontAscent = (short)fi.fontAscent;
    pFontInfo->fontDescent = (short)fi.fontDescent;
    pFontInfo->nprops = fi.nProps;
    p_Var8 = (FontPropPtr)malloc(__size << 4);
    pFontInfo->props = p_Var8;
    if (p_Var8 == (FontPropPtr)0x0) {
      iVar6 = 0x50;
      snfError("snfReadFontInfo(): Couldn\'t allocate props (%d*%d)\n",__size,0x10);
    }
    else {
      pcVar9 = (char *)malloc(__size);
      pFontInfo->isStringProp = pcVar9;
      if (pcVar9 == (char *)0x0) {
        iVar6 = 0x50;
        snfError("snfReadFontInfo(): Couldn\'t allocate isStringProp (%d*%d)\n",__size,1);
        free(pFontInfo->props);
      }
      else {
        iVar6 = (*file->skip)(file,((fi.maxbounds._12_4_ & 0xffffff) + 3 & 0xfffffffc) +
                                   ((fi.lastRow + 1) - fi.firstRow) *
                                   ((fi.lastCol + 1) - fi.firstCol) * 0x10);
        file->eof = iVar6;
        iVar6 = snfReadProps((snfFontInfoPtr)&fi.nProps,(FontInfoPtr)(ulong)fi.lenStrings,
                             (FontFilePtr)&pFontInfo->props,(FontInfoPtr)&pFontInfo->isStringProp,
                             (snfFontInfoPtr)file);
        if (iVar6 == 0x55) {
          if ((fi._24_1_ & 8) == 0) {
            IVar2 = (pFontInfo->minbounds).rightSideBearing;
            IVar3 = (pFontInfo->minbounds).characterWidth;
            IVar4 = (pFontInfo->minbounds).ascent;
            (pFontInfo->ink_minbounds).leftSideBearing = (pFontInfo->minbounds).leftSideBearing;
            (pFontInfo->ink_minbounds).rightSideBearing = IVar2;
            (pFontInfo->ink_minbounds).characterWidth = IVar3;
            (pFontInfo->ink_minbounds).ascent = IVar4;
            CVar5 = (pFontInfo->minbounds).attributes;
            (pFontInfo->ink_minbounds).descent = (pFontInfo->minbounds).descent;
            (pFontInfo->ink_minbounds).attributes = CVar5;
            IVar2 = (pFontInfo->maxbounds).rightSideBearing;
            IVar3 = (pFontInfo->maxbounds).characterWidth;
            IVar4 = (pFontInfo->maxbounds).ascent;
            (pFontInfo->ink_maxbounds).leftSideBearing = (pFontInfo->maxbounds).leftSideBearing;
            (pFontInfo->ink_maxbounds).rightSideBearing = IVar2;
            (pFontInfo->ink_maxbounds).characterWidth = IVar3;
            (pFontInfo->ink_maxbounds).ascent = IVar4;
            CVar5 = (pFontInfo->maxbounds).attributes;
            (pFontInfo->ink_maxbounds).descent = (pFontInfo->maxbounds).descent;
            (pFontInfo->ink_maxbounds).attributes = CVar5;
          }
          else {
            iVar7 = BufFileRead(file,(char *)&snfCharInfo,0x10);
            if (iVar7 == 0x10) {
              (pFontInfo->ink_minbounds).leftSideBearing = snfCharInfo.metrics.leftSideBearing;
              (pFontInfo->ink_minbounds).rightSideBearing = snfCharInfo.metrics.rightSideBearing;
              (pFontInfo->ink_minbounds).characterWidth = snfCharInfo.metrics.characterWidth;
              (pFontInfo->ink_minbounds).ascent = snfCharInfo.metrics.ascent;
              (pFontInfo->ink_minbounds).descent = snfCharInfo.metrics.descent;
              (pFontInfo->ink_minbounds).attributes = snfCharInfo.metrics.attributes;
              iVar7 = BufFileRead(file,(char *)&snfCharInfo,0x10);
              if (iVar7 == 0x10) {
                (pFontInfo->ink_maxbounds).leftSideBearing = snfCharInfo.metrics.leftSideBearing;
                (pFontInfo->ink_maxbounds).rightSideBearing = snfCharInfo.metrics.rightSideBearing;
                (pFontInfo->ink_maxbounds).characterWidth = snfCharInfo.metrics.characterWidth;
                (pFontInfo->ink_maxbounds).ascent = snfCharInfo.metrics.ascent;
                (pFontInfo->ink_maxbounds).descent = snfCharInfo.metrics.descent;
                (pFontInfo->ink_maxbounds).attributes = snfCharInfo.metrics.attributes;
                goto LAB_00125b00;
              }
            }
            iVar6 = 0x53;
            free(pFontInfo->props);
            free(pFontInfo->isStringProp);
          }
        }
        else {
          free(pFontInfo->props);
          free(pFontInfo->isStringProp);
        }
      }
    }
  }
LAB_00125b00:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int BuiltinReadDirectory(char *directory,FontDirectoryPtr *pdir)

{
  BuiltinDirPtr p_Var1;
  BuiltinAliasPtr p_Var2;
  Bool BVar3;
  FontDirectoryPtr dir;
  size_t sVar4;
  BuiltinAliasPtr p_Var5;
  char *pcVar6;
  BuiltinDirPtr p_Var7;
  char *pcVar8;
  char **ppcVar9;
  undefined **ppuVar10;
  int iVar11;
  undefined **ppuVar12;
  undefined **local_48;
  
  dir = FontFileMakeDir("",2);
  if (BuiltinReadDirectory::saved_builtin_dir == (BuiltinDirPtr)0x0) {
    p_Var7 = (BuiltinDirPtr)calloc(2,0x10);
    if ((p_Var7 != (BuiltinDirPtr)0x0) && (true)) {
      ppcVar9 = &p_Var7->font_name;
      ppuVar10 = &PTR_name_6x13_0013dae8;
      do {
        ppuVar12 = ppuVar10 + 2;
        pcVar8 = strdup(ppuVar10[-1]);
        pcVar6 = *ppuVar10;
        ((_BuiltinDir *)(ppcVar9 + -1))->file_name = pcVar8;
        pcVar6 = strdup(pcVar6);
        *ppcVar9 = pcVar6;
        ppcVar9 = ppcVar9 + 2;
        ppuVar10 = ppuVar12;
      } while (ppuVar12 != (undefined **)&DAT_0013db08);
    }
  }
  else {
    p_Var7 = BuiltinReadDirectory::saved_builtin_dir;
    if (true) {
      ppcVar9 = &BuiltinReadDirectory::saved_builtin_dir->font_name;
      ppuVar10 = &PTR_name_6x13_0013dae8;
      p_Var1 = BuiltinReadDirectory::saved_builtin_dir + 2;
      do {
        pcVar6 = *ppcVar9;
        if (pcVar6 != (char *)0x0) {
          sVar4 = strlen(pcVar6);
          memmove(*ppuVar10,pcVar6,sVar4);
        }
        ppcVar9 = ppcVar9 + 2;
        ppuVar10 = ppuVar10 + 2;
        p_Var7 = BuiltinReadDirectory::saved_builtin_dir;
      } while (ppcVar9 != &p_Var1->font_name);
    }
  }
  BuiltinReadDirectory::saved_builtin_dir = p_Var7;
  if (BuiltinReadDirectory::saved_builtin_alias == (BuiltinAliasPtr)0x0) {
    p_Var5 = (BuiltinAliasPtr)calloc(3,0x10);
    if (p_Var5 != (BuiltinAliasPtr)0x0) {
      if (false) goto LAB_001260aa;
      ppuVar10 = &PTR_name_6x13_0013daa8;
      ppcVar9 = &p_Var5->font_name;
      do {
        pcVar6 = *ppuVar10;
        ppuVar10 = ppuVar10 + 2;
        pcVar6 = strdup(pcVar6);
        *ppcVar9 = pcVar6;
        ppcVar9 = ppcVar9 + 2;
      } while (ppuVar10 != (undefined **)&DAT_0013dad8);
      goto LAB_00125f0b;
    }
    BuiltinReadDirectory::saved_builtin_alias = (BuiltinAliasPtr)0x0;
    if (true) goto LAB_00125f10;
LAB_00125f70:
    if (false) goto LAB_001260b3;
  }
  else {
    p_Var5 = BuiltinReadDirectory::saved_builtin_alias;
    if (false) {
LAB_001260aa:
      BuiltinReadDirectory::saved_builtin_alias = p_Var5;
      if (false) goto LAB_001260b3;
LAB_00125f10:
      ppuVar10 = &builtin_dir;
      iVar11 = 0;
      do {
        BVar3 = FontFileAddFontFile(dir,ppuVar10[1],*ppuVar10);
        if (BVar3 == 0) goto LAB_00125f40;
        iVar11 = iVar11 + 1;
        ppuVar10 = ppuVar10 + 2;
      } while (iVar11 < 2);
      goto LAB_00125f70;
    }
    ppcVar9 = &BuiltinReadDirectory::saved_builtin_alias->font_name;
    ppuVar10 = &PTR_name_6x13_0013daa8;
    p_Var2 = BuiltinReadDirectory::saved_builtin_alias + 3;
    do {
      pcVar6 = ((_BuiltinAlias *)(ppcVar9 + -1))->alias_name;
      if (pcVar6 != (char *)0x0) {
        sVar4 = strlen(pcVar6);
        memmove(ppuVar10[-1],pcVar6,sVar4);
      }
      pcVar6 = *ppcVar9;
      if (pcVar6 != (char *)0x0) {
        sVar4 = strlen(pcVar6);
        memmove(*ppuVar10,pcVar6,sVar4);
      }
      ppcVar9 = ppcVar9 + 2;
      ppuVar10 = ppuVar10 + 2;
      p_Var5 = BuiltinReadDirectory::saved_builtin_alias;
    } while (ppcVar9 != &p_Var2->font_name);
LAB_00125f0b:
    BuiltinReadDirectory::saved_builtin_alias = p_Var5;
    if (true) goto LAB_00125f10;
  }
  local_48 = &builtin_alias;
  iVar11 = 0;
  do {
    BVar3 = FontFileAddFontAlias(dir,*local_48,local_48[1]);
    if (BVar3 == 0) {
LAB_00125f40:
      FontFileFreeDir(dir);
      return 0x56;
    }
    iVar11 = iVar11 + 1;
    local_48 = local_48 + 2;
  } while (iVar11 < 3);
LAB_001260b3:
  FontFileSortDir(dir);
  *pdir = dir;
  return 0x55;
}



int BuiltinSkip(BufFilePtr f,int count)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  
  iVar1 = f->left;
  if (count <= iVar1) {
    f->bufp = f->bufp + count;
    f->left = iVar1 - count;
    return count;
  }
  piVar2 = (int *)f->private;
  iVar3 = *piVar2 + (count - iVar1);
  *piVar2 = iVar3;
  iVar1 = *(int *)(*(long *)(piVar2 + 2) + 8);
  if (iVar1 < iVar3) {
    *piVar2 = iVar1;
    iVar3 = iVar1;
  }
  if (-1 < iVar3) {
    f->left = 0;
    return count;
  }
  *piVar2 = 0;
  f->left = 0;
  return count;
}



int BuiltinClose(BufFilePtr f,int unused)

{
  free(f->private);
  return 1;
}



int BuiltinFill(BufFilePtr f)

{
  int iVar1;
  int *piVar2;
  uint uVar3;
  ulong uVar4;
  BufChar *pBVar5;
  undefined8 *puVar6;
  uint uVar7;
  int iVar8;
  long lVar9;
  
  piVar2 = (int *)f->private;
  lVar9 = *(long *)(piVar2 + 2);
  iVar1 = *piVar2;
  uVar7 = *(int *)(lVar9 + 8) - iVar1;
  if ((int)uVar7 < 1) {
    f->left = 0;
    return -1;
  }
  if ((int)uVar7 < 0x2000) {
    iVar8 = uVar7 - 1;
    pBVar5 = (BufChar *)((long)iVar1 + *(long *)(lVar9 + 0x10));
    uVar4 = (ulong)uVar7;
    uVar3 = uVar7;
    iVar1 = iVar8;
    if (7 < uVar7) goto LAB_001261ee;
  }
  else {
    pBVar5 = (BufChar *)((long)iVar1 + *(long *)(lVar9 + 0x10));
    iVar8 = 0x1fff;
    uVar7 = 0x2000;
    uVar4 = 0x2000;
    uVar3 = 0x2000;
    iVar1 = 0x1fff;
    if (true) {
LAB_001261ee:
      *(undefined8 *)f->buffer = *(undefined8 *)pBVar5;
      *(undefined8 *)(f->buffer + ((ulong)uVar7 - 8)) = *(undefined8 *)(pBVar5 + ((ulong)uVar7 - 8))
      ;
      puVar6 = (undefined8 *)((ulong)(f->buffer + 8) & 0xfffffffffffffff8);
      lVar9 = (long)f + (0x10 - (long)puVar6);
      pBVar5 = pBVar5 + -lVar9;
      for (uVar4 = (ulong)(uVar7 + (int)lVar9 >> 3); uVar4 != 0; uVar4 = uVar4 - 1) {
        *puVar6 = *(undefined8 *)pBVar5;
        pBVar5 = pBVar5 + 8;
        puVar6 = puVar6 + 1;
      }
      goto LAB_001261c2;
    }
  }
  iVar8 = iVar1;
  uVar7 = uVar3;
  if ((uVar7 & 4) == 0) {
    if (((int)uVar4 != 0) && (f->buffer[0] = *pBVar5, (uVar4 & 2) != 0)) {
      *(undefined2 *)(f->buffer + (uVar4 - 2)) = *(undefined2 *)(pBVar5 + (uVar4 - 2));
    }
  }
  else {
    *(undefined4 *)f->buffer = *(undefined4 *)pBVar5;
    *(undefined4 *)(f->buffer + (uVar4 - 4)) = *(undefined4 *)(pBVar5 + (uVar4 - 4));
  }
LAB_001261c2:
  *piVar2 = *piVar2 + uVar7;
  f->left = iVar8;
  f->bufp = f->buffer + 1;
  return (int)f->buffer[0];
}



FontFilePtr BuiltinFileOpen(char *name)

{
  char cVar1;
  BufChar *pBVar2;
  int iVar3;
  char *private;
  BufFilePtr f;
  BufFilePtr p_Var4;
  int iVar5;
  undefined **ppuVar6;
  
  cVar1 = *name;
  if (false) {
    if (true) {
      iVar5 = 0;
LAB_001262c0:
      private = (char *)malloc(0x10);
      if (private != (char *)0x0) {
        private[0] = '\0';
        private[1] = '\0';
        private[2] = '\0';
        private[3] = '\0';
        *(undefined ***)(private + 8) = &builtin_files + (long)iVar5 * 3;
        f = BufFileCreate(private,BuiltinFill,(_func_int_int_BufFilePtr *)0x0,BuiltinSkip,
                          BuiltinClose);
        if (f != (BufFilePtr)0x0) {
          p_Var4 = BufFilePushZIP(f);
          if (p_Var4 != (BufFilePtr)0x0) {
            return p_Var4;
          }
          pBVar2 = f->bufp;
          f->bufp = f->buffer;
          f->left = f->left + ((int)pBVar2 - (int)f->buffer);
          return f;
        }
        free(private);
      }
    }
  }
  else {
    ppuVar6 = &builtin_files;
    iVar5 = 0;
    do {
      iVar3 = strcmp(name + (cVar1 == '/'),*ppuVar6);
      if (iVar3 == 0) goto LAB_001262c0;
      iVar5 = iVar5 + 1;
      ppuVar6 = ppuVar6 + 3;
    } while (iVar5 != 2);
  }
  return (FontFilePtr)0x0;
}



int BuiltinFileClose(FontFilePtr f,int unused)

{
  int iVar1;
  
  iVar1 = BufFileClose(f,1);
  return iVar1;
}



// WARNING: Unknown calling convention

int BuiltinResetFPE(FontPathElementPtr fpe)

{
  return 0x55;
}



int BuiltinFreeFPE(FontPathElementPtr fpe)

{
  FontFileFreeDir((FontDirectoryPtr)fpe->private);
  return 0x55;
}



int BuiltinInitFPE(FontPathElementPtr fpe)

{
  int iVar1;
  long in_FS_OFFSET;
  FontDirectoryPtr dir;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = BuiltinReadDirectory(fpe->name,&dir);
  if (iVar1 == 0x55) {
    fpe->private = dir;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int BuiltinNameCheck(char *name)

{
  int iVar1;
  
  iVar1 = strcmp(name,"built-ins");
  return (int)(iVar1 == 0);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BuiltinRegisterFpeFunctions(void)

{
  BuiltinRegisterFontFileFunctions();
  RegisterFPEFunctions
            (BuiltinNameCheck,BuiltinInitFPE,BuiltinFreeFPE,BuiltinResetFPE,FontFileOpenFont,
             FontFileCloseFont,FontFileListFonts,FontFileStartListFontsWithInfo,
             FontFileListNextFontWithInfo,(WakeupFpeFunc)0x0,(ClientDiedFunc)0x0,(LoadGlyphsFunc)0x0
             ,(StartLaFunc)0x0,(NextLaFunc)0x0,(SetPathFunc)0x0);
  return;
}



// WARNING: Unknown calling convention

int BuiltinOpenScalable(FontPathElementPtr fpe,FontPtr *pFont,int flags,FontEntryPtr entry,
                       char *fileName,FontScalablePtr vals,fsBitmapFormat format,
                       fsBitmapFormatMask fmask,FontPtr non_cachable_font)

{
  return 0x53;
}



// WARNING: Unknown calling convention

int BuiltinGetInfoScalable
              (FontPathElementPtr fpe,FontInfoPtr pFontInfo,FontEntryPtr entry,FontNamePtr fontName,
              char *fileName,FontScalablePtr vals)

{
  return 0x53;
}



int BuiltinGetInfoBitmap
              (FontPathElementPtr fpe,FontInfoPtr pFontInfo,FontEntryPtr entry,char *fileName)

{
  int iVar1;
  FontFilePtr file;
  
  file = BuiltinFileOpen(fileName);
  if (file != (FontFilePtr)0x0) {
    iVar1 = pcfReadFontInfo(pFontInfo,file);
    BuiltinFileClose(file,0);
    return iVar1;
  }
  return 0x53;
}



int BuiltinOpenBitmap(FontPathElementPtr fpe,FontPtr *ppFont,int flags,FontEntryPtr entry,
                     char *fileName,fsBitmapFormat format,fsBitmapFormatMask fmask,FontPtr unused)

{
  int iVar1;
  FontFilePtr f;
  FontPtr pFont;
  long in_FS_OFFSET;
  int bit;
  int byte;
  int glyph;
  int scan;
  int image;
  long local_40;
  
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  f = BuiltinFileOpen(fileName);
  if (f == (FontFilePtr)0x0) {
    iVar1 = 0x53;
  }
  else {
    pFont = (FontPtr)malloc(0xb8);
    if (pFont == (FontPtr)0x0) {
      iVar1 = 0x50;
      BuiltinFileClose(f,0);
    }
    else {
      FontDefaultFormat(&bit,&byte,&glyph,&scan);
      CheckFSFormat(format,fmask,&bit,&byte,&scan,&glyph,&image);
      pFont->refcnt = 0;
      pFont->maxPrivate = -1;
      pFont->devPrivates = (void **)0x0;
      iVar1 = pcfReadFont(pFont,f,bit,byte,glyph,scan);
      BuiltinFileClose(f,0);
      if (iVar1 == 0x55) {
        *ppFont = pFont;
      }
      else {
        free(pFont);
      }
    }
  }
  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BuiltinRegisterFontFileFunctions(void)

{
  FontFileRegisterRenderer(renderers);
  return;
}



int _fs_get_metrics(FontPtr pFont,ulong count,uchar *chars,FontEncoding charEncoding,
                   ulong *glyphCount,xCharInfo **glyphs)

{
  byte *pbVar1;
  byte bVar2;
  ushort uVar3;
  long *plVar4;
  long lVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  ulong uVar9;
  xCharInfo **ppxVar10;
  xCharInfo **ppxVar11;
  xCharInfo *pxVar12;
  long lVar13;
  uint uVar14;
  xCharInfo *pxVar15;
  bool bVar16;
  
  plVar4 = (long *)pFont->fontPrivate;
  lVar5 = plVar4[2];
  if (*plVar4 == 0) {
    uVar3 = (pFont->info).firstCol;
    uVar8 = (uint)uVar3;
    uVar14 = ((pFont->info).lastCol + 1) - (uint)uVar3;
    pxVar15 = (xCharInfo *)0x0;
    if (charEncoding == Linear16Bit) {
      bVar16 = false;
      pxVar15 = (xCharInfo *)0x0;
LAB_00126804:
      uVar9 = 0;
      ppxVar11 = glyphs;
      if (count != 0) {
        do {
          uVar7 = (ushort)(*(ushort *)(chars + uVar9 * 2) << 8 | *(ushort *)(chars + uVar9 * 2) >> 8
                          ) - uVar8;
          if (uVar7 < uVar14) {
            *ppxVar11 = (xCharInfo *)(lVar5 + (ulong)uVar7 * 0x18);
            ppxVar11 = ppxVar11 + 1;
          }
          else if (bVar16) {
            *ppxVar11 = pxVar15;
            ppxVar11 = ppxVar11 + 1;
          }
          uVar9 = uVar9 + 1;
        } while (count != uVar9);
        *glyphCount = (long)ppxVar11 - (long)glyphs >> 3;
        return 0x55;
      }
      goto LAB_0012671c;
    }
LAB_001266c1:
    uVar8 = (uint)uVar3;
    if (Linear16Bit < charEncoding) {
      if (charEncoding == TwoD16Bit) {
        uVar3 = (pFont->info).lastRow;
        lVar13 = count - 1;
        uVar7 = (uint)(pFont->info).firstRow;
        ppxVar11 = glyphs;
        if (count != 0) {
          do {
            bVar2 = *chars;
            pbVar1 = chars + 1;
            chars = chars + 2;
            uVar6 = bVar2 - uVar7;
            if ((uVar6 < (uVar3 + 1) - uVar7) && (*pbVar1 - uVar8 < uVar14)) {
              ppxVar10 = ppxVar11 + 1;
              *ppxVar11 = (xCharInfo *)(lVar5 + (ulong)(uVar6 * uVar14 + (*pbVar1 - uVar8)) * 0x18);
            }
            else {
              ppxVar10 = ppxVar11;
              if (pxVar15 != (xCharInfo *)0x0) {
                *ppxVar11 = pxVar15;
                ppxVar10 = ppxVar11 + 1;
              }
            }
            lVar13 = lVar13 + -1;
            ppxVar11 = ppxVar10;
          } while (lVar13 != -1);
          *glyphCount = (long)ppxVar10 - (long)glyphs >> 3;
          return 0x55;
        }
        goto LAB_0012671c;
      }
LAB_001267d0:
      *glyphCount = 0;
      return 0x55;
    }
    if ((pFont->info).firstRow != 0) goto LAB_001267d0;
    if ((((pFont->info).field_0xa & 0x40) == 0) || (pxVar15 == (xCharInfo *)0x0)) {
      pbVar1 = chars + count;
      ppxVar11 = glyphs;
      if (count != 0) {
        do {
          bVar2 = *chars;
          chars = chars + 1;
          if (bVar2 - uVar8 < uVar14) {
            ppxVar10 = ppxVar11 + 1;
            *ppxVar11 = (xCharInfo *)(lVar5 + (ulong)(bVar2 - uVar8) * 0x18);
          }
          else {
            ppxVar10 = ppxVar11;
            if (pxVar15 != (xCharInfo *)0x0) {
              *ppxVar11 = pxVar15;
              ppxVar10 = ppxVar11 + 1;
            }
          }
          ppxVar11 = ppxVar10;
        } while (pbVar1 != chars);
        count = (long)ppxVar10 - (long)glyphs >> 3;
      }
      goto LAB_0012671c;
    }
    if (count == 0) goto LAB_0012671c;
    uVar9 = 0;
    do {
      pxVar12 = pxVar15;
      if (chars[uVar9] - uVar8 < uVar14) {
        pxVar12 = (xCharInfo *)(lVar5 + (ulong)(chars[uVar9] - uVar8) * 0x18);
      }
      glyphs[uVar9] = pxVar12;
      uVar9 = uVar9 + 1;
    } while (uVar9 != count);
  }
  else {
    uVar3 = (pFont->info).firstCol;
    pxVar15 = (xCharInfo *)((*plVar4 - plVar4[1]) + lVar5);
    uVar14 = ((pFont->info).lastCol + 1) - (uint)uVar3;
    if (charEncoding != Linear16Bit) goto LAB_001266c1;
    bVar16 = pxVar15 != (xCharInfo *)0x0;
    uVar8 = (uint)uVar3;
    if ((((pFont->info).field_0xa & 0x40) == 0) || (uVar8 = (uint)uVar3, !bVar16))
    goto LAB_00126804;
    if (count == 0) goto LAB_0012671c;
    uVar9 = 0;
    do {
      uVar8 = (uint)(ushort)(*(ushort *)(chars + uVar9 * 2) << 8 |
                            *(ushort *)(chars + uVar9 * 2) >> 8) - (uint)uVar3;
      pxVar12 = pxVar15;
      if (uVar8 < uVar14) {
        pxVar12 = (xCharInfo *)(lVar5 + (ulong)uVar8 * 0x18);
      }
      glyphs[uVar9] = pxVar12;
      uVar9 = uVar9 + 1;
    } while (uVar9 != count);
  }
  count = (long)(count << 3) >> 3;
LAB_0012671c:
  *glyphCount = count;
  return 0x55;
}



int _fs_get_glyphs(FontPtr pFont,ulong count,uchar *chars,FontEncoding charEncoding,
                  ulong *glyphCount,CharInfoPtr *glyphs)

{
  byte *pbVar1;
  CharInfoPtr p_Var2;
  byte bVar3;
  ushort uVar4;
  ushort uVar5;
  void *pvVar6;
  long lVar7;
  CharInfoPtr p_Var8;
  uint uVar9;
  uint uVar10;
  int iVar11;
  ulong uVar12;
  CharInfoPtr *pp_Var13;
  CharInfoPtr *pp_Var14;
  char *pcVar15;
  uint uVar16;
  bool bVar17;
  
  uVar4 = (pFont->info).firstCol;
  pvVar6 = pFont->fpePrivate;
  lVar7 = *(long *)((long)pFont->fontPrivate + 8);
                    // WARNING: Load size is inaccurate
  p_Var8 = *pFont->fontPrivate;
  uVar16 = ((pFont->info).lastCol + 1) - (uint)uVar4;
  uVar10 = (uint)uVar4;
  pp_Var13 = glyphs;
  if (charEncoding == Linear16Bit) {
    if ((((pFont->info).field_0xa & 0x40) != 0) && (p_Var8 != (CharInfoPtr)0x0)) {
LAB_00126b36:
      uVar12 = count - 1;
      pp_Var14 = pp_Var13;
      if (count != 0) {
        do {
          uVar5 = *(ushort *)chars;
          chars = (uchar *)((long)chars + 2);
          pp_Var13 = pp_Var14 + 1;
          uVar10 = (uint)(ushort)(uVar5 << 8 | uVar5 >> 8) - (uint)uVar4;
          if (uVar10 < uVar16) {
            p_Var2 = (CharInfoPtr)(lVar7 + (ulong)uVar10 * 0x18);
            if ((*(long *)((long)pvVar6 + 0x10) != 0) &&
               ((p_Var2->bits == &_fs_glyph_requested || (p_Var2->bits == &_fs_glyph_undefined))))
            goto LAB_00126ea0;
            *pp_Var14 = p_Var2;
          }
          else {
            *pp_Var14 = p_Var8;
          }
          uVar12 = uVar12 - 1;
          pp_Var14 = pp_Var13;
          if (uVar12 == 0xffffffffffffffff) break;
        } while( true );
      }
      goto LAB_001269b0;
    }
LAB_00126c84:
    do {
      bVar17 = count == 0;
      count = count - 1;
      pp_Var14 = pp_Var13;
      if (bVar17) goto LAB_001269b0;
      while( true ) {
        uVar4 = *(ushort *)chars;
        chars = (uchar *)((long)chars + 2);
        uVar9 = (ushort)(uVar4 << 8 | uVar4 >> 8) - uVar10;
        pp_Var13 = pp_Var14;
        if (uVar9 < uVar16) break;
        uVar12 = count - 1;
        if (p_Var8 == (CharInfoPtr)0x0) goto LAB_00126c84;
        pp_Var13 = pp_Var14 + 1;
        *pp_Var14 = p_Var8;
        count = uVar12;
        pp_Var14 = pp_Var13;
        if (uVar12 == 0xffffffffffffffff) goto LAB_001269b0;
      }
      p_Var2 = (CharInfoPtr)(lVar7 + (ulong)uVar9 * 0x18);
      iVar11 = 0x55;
      pcVar15 = p_Var2->bits;
      if ((*(long *)((long)pvVar6 + 0x10) != 0) &&
         ((pcVar15 == &_fs_glyph_requested || (pcVar15 == &_fs_glyph_undefined)))) {
        iVar11 = fs_load_all_glyphs(pFont);
        pcVar15 = p_Var2->bits;
      }
      if (pcVar15 == (char *)0x0) {
        if (p_Var8 != (CharInfoPtr)0x0) {
          *pp_Var14 = p_Var8;
          pp_Var13 = pp_Var14 + 1;
        }
      }
      else {
        *pp_Var14 = p_Var2;
        pp_Var13 = pp_Var14 + 1;
      }
    } while (iVar11 == 0x55);
LAB_00126a74:
    uVar12 = (long)pp_Var13 - (long)glyphs >> 3;
  }
  else {
    if (charEncoding < TwoD16Bit) {
      if ((pFont->info).firstRow == 0) {
        if ((((pFont->info).field_0xa & 0x40) != 0) && (p_Var8 != (CharInfoPtr)0x0)) {
LAB_0012699a:
          uVar12 = count - 1;
          pp_Var14 = pp_Var13;
          if (count != 0) {
            do {
              bVar3 = *chars;
              chars = chars + 1;
              pp_Var13 = pp_Var14 + 1;
              if (bVar3 - uVar10 < uVar16) {
                p_Var2 = (CharInfoPtr)(lVar7 + (ulong)(bVar3 - uVar10) * 0x18);
                if ((*(long *)((long)pvVar6 + 0x10) != 0) &&
                   ((p_Var2->bits == &_fs_glyph_undefined || (p_Var2->bits == &_fs_glyph_requested))
                   )) goto LAB_00126df0;
                *pp_Var14 = p_Var2;
              }
              else {
                *pp_Var14 = p_Var8;
              }
              uVar12 = uVar12 - 1;
              pp_Var14 = pp_Var13;
              if (uVar12 == 0xffffffffffffffff) break;
            } while( true );
          }
          goto LAB_001269b0;
        }
LAB_00126d94:
        do {
          bVar17 = count == 0;
          count = count - 1;
          if (bVar17) goto LAB_001269b0;
          while( true ) {
            bVar3 = *chars;
            chars = chars + 1;
            if (bVar3 - uVar10 < uVar16) break;
            uVar12 = count - 1;
            if (p_Var8 == (CharInfoPtr)0x0) goto LAB_00126d94;
            pp_Var14 = pp_Var13 + 1;
            *pp_Var13 = p_Var8;
            count = uVar12;
            pp_Var13 = pp_Var14;
            if (uVar12 == 0xffffffffffffffff) goto LAB_001269b0;
          }
          p_Var2 = (CharInfoPtr)(lVar7 + (ulong)(bVar3 - uVar10) * 0x18);
          iVar11 = 0x55;
          pcVar15 = p_Var2->bits;
          if ((*(long *)((long)pvVar6 + 0x10) != 0) &&
             ((pcVar15 == &_fs_glyph_undefined || (pcVar15 == &_fs_glyph_requested)))) {
            iVar11 = fs_load_all_glyphs(pFont);
            pcVar15 = p_Var2->bits;
          }
          if (pcVar15 == (char *)0x0) {
            if (p_Var8 != (CharInfoPtr)0x0) {
              *pp_Var13 = p_Var8;
              pp_Var13 = pp_Var13 + 1;
            }
          }
          else {
            *pp_Var13 = p_Var2;
            pp_Var13 = pp_Var13 + 1;
          }
        } while (iVar11 == 0x55);
        goto LAB_00126a74;
      }
    }
    else if (charEncoding == TwoD16Bit) {
      uVar4 = (pFont->info).lastRow;
      uVar5 = (pFont->info).firstRow;
LAB_001269ec:
      do {
        count = count - 1;
        if (count == 0xffffffffffffffff) goto LAB_001269b0;
        bVar3 = *chars;
        pbVar1 = chars + 1;
        chars = chars + 2;
        uVar9 = (uint)bVar3 - (uint)uVar5;
        if ((uVar9 < (uVar4 + 1) - (uint)uVar5) && (*pbVar1 - uVar10 < uVar16)) {
          p_Var2 = (CharInfoPtr)(lVar7 + (ulong)(uVar9 * uVar16 + (*pbVar1 - uVar10)) * 0x18);
          pcVar15 = p_Var2->bits;
          if ((*(long *)((long)pvVar6 + 0x10) == 0) ||
             ((pcVar15 != &_fs_glyph_undefined && (pcVar15 != &_fs_glyph_requested)))) {
            if (pcVar15 == (char *)0x0) {
              if (p_Var8 != (CharInfoPtr)0x0) {
                *pp_Var13 = p_Var8;
                pp_Var13 = pp_Var13 + 1;
              }
            }
            else {
              *pp_Var13 = p_Var2;
              pp_Var13 = pp_Var13 + 1;
            }
            goto LAB_001269ec;
          }
          iVar11 = fs_load_all_glyphs(pFont);
          if (p_Var2->bits == (char *)0x0) {
            if (p_Var8 != (CharInfoPtr)0x0) goto LAB_00126a63;
          }
          else {
            *pp_Var13 = p_Var2;
            pp_Var13 = pp_Var13 + 1;
          }
        }
        else {
          if (p_Var8 == (CharInfoPtr)0x0) goto LAB_001269ec;
          iVar11 = 0x55;
LAB_00126a63:
          *pp_Var13 = p_Var8;
          pp_Var13 = pp_Var13 + 1;
        }
      } while (iVar11 == 0x55);
      goto LAB_00126a74;
    }
    uVar12 = 0;
    iVar11 = 0x55;
  }
LAB_00126a7b:
  *glyphCount = uVar12;
  return iVar11;
LAB_00126ea0:
  iVar11 = fs_load_all_glyphs(pFont);
  *pp_Var14 = p_Var2;
  count = uVar12;
  if (iVar11 != 0x55) goto LAB_00126a74;
  goto LAB_00126b36;
LAB_00126df0:
  iVar11 = fs_load_all_glyphs(pFont);
  *pp_Var14 = p_Var2;
  count = uVar12;
  if (iVar11 != 0x55) goto LAB_00126a74;
  goto LAB_0012699a;
LAB_001269b0:
  iVar11 = 0x55;
  uVar12 = (long)pp_Var13 - (long)glyphs >> 3;
  goto LAB_00126a7b;
}



// WARNING: Unknown calling convention

void _fs_convert_char_info(fsXCharInfo *src,xCharInfo *dst)

{
  dst->ascent = src->ascent;
  dst->descent = src->descent;
  dst->leftSideBearing = src->left;
  dst->rightSideBearing = src->right;
  dst->characterWidth = src->width;
  dst->attributes = src->attributes;
  return;
}



void _fs_init_fontinfo(FSFpePtr_conflict conn,FontInfoPtr pfi)

{
  ushort *puVar1;
  ushort uVar2;
  short sVar3;
  INT16 IVar4;
  INT16 IVar5;
  INT16 IVar6;
  CARD16 CVar7;
  int iVar8;
  
  if (conn->fsMajorVersion == 1) {
    uVar2 = pfi->firstCol;
    puVar1 = &pfi->defaultCh;
    *puVar1 = *puVar1 << 8 | *puVar1 >> 8;
    pfi->firstCol = pfi->firstRow;
    pfi->firstRow = uVar2;
    uVar2 = pfi->lastCol;
    pfi->lastCol = pfi->lastRow;
    pfi->lastRow = uVar2;
  }
  iVar8 = FontCouldBeTerminal(pfi);
  if (iVar8 != 0) {
    sVar3 = pfi->fontDescent;
    pfi->field_0xa = pfi->field_0xa | 2;
    (pfi->minbounds).ascent = pfi->fontAscent;
    (pfi->minbounds).descent = sVar3;
    (pfi->minbounds).leftSideBearing = 0;
    (pfi->minbounds).rightSideBearing = (pfi->minbounds).characterWidth;
    IVar4 = (pfi->minbounds).rightSideBearing;
    IVar5 = (pfi->minbounds).characterWidth;
    IVar6 = (pfi->minbounds).ascent;
    (pfi->maxbounds).leftSideBearing = (pfi->minbounds).leftSideBearing;
    (pfi->maxbounds).rightSideBearing = IVar4;
    (pfi->maxbounds).characterWidth = IVar5;
    (pfi->maxbounds).ascent = IVar6;
    CVar7 = (pfi->minbounds).attributes;
    (pfi->maxbounds).descent = (pfi->minbounds).descent;
    (pfi->maxbounds).attributes = CVar7;
  }
  FontComputeInfoAccelerators(pfi);
  return;
}



int _fs_convert_props(fsPropInfo *pi,fsPropOffset *po,pointer pd,FontInfoPtr pfi)

{
  FontPropPtr p_Var1;
  CARD8 CVar2;
  CARD32 CVar3;
  uint uVar4;
  uint len;
  FontPropPtr p_Var5;
  Atom AVar6;
  FontPropPtr p_Var7;
  
  CVar3 = pi->num_offsets;
  pfi->nprops = CVar3;
  if (-1 < (int)CVar3) {
    p_Var5 = (FontPropPtr)malloc((long)(int)CVar3 * 0x11);
    if (p_Var5 != (FontPropPtr)0x0) {
      p_Var7 = p_Var5 + (int)CVar3;
      pfi->props = p_Var5;
      pfi->isStringProp = (char *)p_Var7;
      if (CVar3 == 0) {
        return 0;
      }
      p_Var1 = p_Var5 + (ulong)(CVar3 - 1) + 1;
      do {
        CVar2 = po->type;
        uVar4 = (po->value).position;
        len = (po->value).length;
        AVar6 = MakeAtom((char *)((ulong)(po->name).position + (long)pd),(po->name).length,1);
        p_Var5->name = AVar6;
        if (CVar2 == '\0') {
          *(undefined *)&p_Var7->name = 1;
          AVar6 = MakeAtom((char *)((ulong)uVar4 + (long)pd),len,1);
          p_Var5->value = (long)(int)AVar6;
        }
        else {
          *(undefined *)&p_Var7->name = 0;
          p_Var5->value = (ulong)uVar4;
        }
        po = po + 1;
        p_Var5 = p_Var5 + 1;
        p_Var7 = (FontPropPtr)((long)&p_Var7->name + 1);
      } while (p_Var1 != p_Var5);
      return CVar3;
    }
  }
  return -1;
}



void _fs_free_props(FontInfoPtr pfi)

{
  if (pfi->props != (FontPropPtr)0x0) {
    free(pfi->props);
    pfi->nprops = 0;
    pfi->props = (FontPropPtr)0x0;
  }
  return;
}



void _fs_unload_font(FontPtr pfont)

{
  void *__ptr;
  FSID *pFVar1;
  FontPtr p_Var2;
  undefined8 *__ptr_00;
  
  __ptr = pfont->fontPrivate;
  pFVar1 = (FSID *)pfont->fpePrivate;
  __ptr_00 = *(undefined8 **)((long)__ptr + 8);
  if (__ptr_00 != (undefined8 *)0x0) goto LAB_0012711f;
  while (__ptr_00 = *(undefined8 **)((long)__ptr + 0x18), __ptr_00 != (undefined8 *)0x0) {
    *(undefined8 *)((long)__ptr + 0x18) = *__ptr_00;
LAB_0012711f:
    free(__ptr_00);
  }
  p_Var2 = find_old_font(*pFVar1);
  if (p_Var2 != (FontPtr)0x0) {
    DeleteFontClientID(*pFVar1);
  }
  FUN_0010a1b0(&pfont->info);
  free(__ptr);
  DestroyFontRec(pfont);
  return;
}



int _fs_convert_lfwi_reply
              (FSFpePtr_conflict conn,FontInfoPtr pfi,fsListFontsWithXInfoReply *fsrep,
              fsPropInfo *pi,fsPropOffset *po,pointer pd)

{
  int iVar1;
  
  pfi->field_0xa = pfi->field_0xa & 0xbf | (byte)((*(byte *)&fsrep->font_header_flags & 1) << 6);
  *(ushort *)&pfi->field_0xa =
       *(ushort *)&pfi->field_0xa & 0xfe7f |
       (ushort)(fsrep->font_header_draw_direction != '\0') << 7;
  pfi->field_0xa = (byte)((fsrep->font_header_flags >> 1 & 1) << 4) | pfi->field_0xa & 0xef;
  pfi->firstRow = (ushort)fsrep->font_hdr_char_range_min_char_high;
  pfi->firstCol = (ushort)fsrep->font_hdr_char_range_min_char_low;
  pfi->lastRow = (ushort)fsrep->font_hdr_char_range_max_char_high;
  pfi->lastCol = (ushort)fsrep->font_hdr_char_range_max_char_low;
  pfi->defaultCh =
       (ushort)fsrep->font_header_default_char_high * 0x100 +
       (ushort)fsrep->font_header_default_char_low;
  pfi->fontDescent = fsrep->font_header_font_descent;
  pfi->fontAscent = fsrep->font_header_font_ascent;
  (pfi->minbounds).leftSideBearing = fsrep->font_header_min_bounds_left;
  (pfi->minbounds).rightSideBearing = fsrep->font_header_min_bounds_right;
  (pfi->minbounds).characterWidth = fsrep->font_header_min_bounds_width;
  (pfi->minbounds).ascent = fsrep->font_header_min_bounds_ascent;
  (pfi->minbounds).descent = fsrep->font_header_min_bounds_descent;
  (pfi->minbounds).attributes = fsrep->font_header_min_bounds_attributes;
  (pfi->ink_minbounds).leftSideBearing = fsrep->font_header_min_bounds_left;
  (pfi->ink_minbounds).rightSideBearing = fsrep->font_header_min_bounds_right;
  (pfi->ink_minbounds).characterWidth = fsrep->font_header_min_bounds_width;
  (pfi->ink_minbounds).ascent = fsrep->font_header_min_bounds_ascent;
  (pfi->ink_minbounds).descent = fsrep->font_header_min_bounds_descent;
  (pfi->ink_minbounds).attributes = fsrep->font_header_min_bounds_attributes;
  (pfi->maxbounds).leftSideBearing = fsrep->font_header_max_bounds_left;
  (pfi->maxbounds).rightSideBearing = fsrep->font_header_max_bounds_right;
  (pfi->maxbounds).characterWidth = fsrep->font_header_max_bounds_width;
  (pfi->maxbounds).ascent = fsrep->font_header_max_bounds_ascent;
  (pfi->maxbounds).descent = fsrep->font_header_max_bounds_descent;
  (pfi->maxbounds).attributes = fsrep->font_header_max_bounds_attributes;
  (pfi->ink_maxbounds).leftSideBearing = fsrep->font_header_max_bounds_left;
  (pfi->ink_maxbounds).rightSideBearing = fsrep->font_header_max_bounds_right;
  (pfi->ink_maxbounds).characterWidth = fsrep->font_header_max_bounds_width;
  (pfi->ink_maxbounds).ascent = fsrep->font_header_max_bounds_ascent;
  (pfi->ink_maxbounds).descent = fsrep->font_header_max_bounds_descent;
  (pfi->ink_maxbounds).attributes = fsrep->font_header_max_bounds_attributes;
  _fs_init_fontinfo(conn,pfi);
  iVar1 = _fs_convert_props(pi,po,pd,pfi);
  return (uint)(iVar1 != -1) * 5 + 0x50;
}



int fs_build_range(FontPtr pfont,Bool range_flag,uint count,int item_size,uchar *data,int *nranges,
                  fsRange **ranges)

{
  CARD8 *pCVar1;
  fsRange *pfVar2;
  byte *pbVar3;
  byte bVar4;
  ushort uVar5;
  ushort uVar6;
  ushort uVar7;
  ushort uVar8;
  long lVar9;
  long lVar10;
  char *pcVar11;
  int iVar12;
  uint uVar13;
  ulong uVar14;
  ulong uVar15;
  ulong uVar16;
  long lVar17;
  uint uVar18;
  ulong uVar19;
  ulong uVar20;
  ulong uVar21;
  uint uVar22;
  ulong uVar23;
  ushort uVar24;
  long *plVar25;
  long in_FS_OFFSET;
  bool bVar26;
  bool bVar27;
  ulong local_a8;
  uint local_98;
  long local_90;
  ulong local_80;
  fsRange *local_78;
  uint local_70;
  CARD8 local_6a;
  fsRange range;
  fsRange fullrange [1];
  
  lVar9 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(long *)((long)pfont->fpePrivate + 0x10) != 0) {
    uVar5 = (pfont->info).firstRow;
    uVar14 = (ulong)uVar5;
    lVar10 = *(long *)((long)pfont->fontPrivate + 8);
                    // WARNING: Load size is inaccurate
    lVar17 = *pfont->fontPrivate;
    uVar6 = (pfont->info).firstCol;
    uVar21 = (ulong)uVar6;
    uVar7 = (pfont->info).lastRow;
    uVar8 = (pfont->info).lastCol;
    uVar23 = (ulong)uVar8;
    bVar4 = (byte)uVar6;
    if (lVar17 == 0) {
      bVar26 = true;
    }
    else if (*(char **)(lVar17 + 0x10) == &_fs_glyph_undefined) {
      uVar16 = (lVar17 - lVar10 >> 3) * -0x5555555555555555;
      uVar19 = ((ulong)uVar8 + 1) - uVar21;
      range.min_char_high = (char)(uVar16 / uVar19) + (CARD8)uVar5;
      range.min_char_low = (char)(uVar16 % uVar19) + bVar4;
      range.max_char_high = range.min_char_high;
      range.max_char_low = range.min_char_low;
      iVar12 = add_range(&range,nranges,ranges,0);
      if (iVar12 != 0x55) goto LAB_00127578;
      bVar26 = false;
      *(char **)(lVar17 + 0x10) = &_fs_glyph_requested;
    }
    else {
      bVar26 = *(char **)(lVar17 + 0x10) != &_fs_glyph_requested;
    }
    if (range_flag == 0) {
      if (item_size != 1) {
        if (false) goto LAB_001275bb;
        goto LAB_0012774a;
      }
      if (uVar14 != 0) goto LAB_001275a8;
      if (count != 0) {
        pbVar3 = data + (ulong)(count - 1) + 1;
        do {
          while( true ) {
            bVar4 = *data;
            uVar14 = (ulong)bVar4;
            data = data + 1;
            if ((uVar21 <= uVar14) && (uVar14 <= uVar23)) break;
LAB_0012742c:
            if (data == pbVar3) goto LAB_00127568;
          }
          pcVar11 = *(char **)(lVar10 + 0x10 + (uVar14 - uVar21) * 0x18);
          if (pcVar11 != &_fs_glyph_undefined) {
            bVar26 = (bool)(bVar26 & pcVar11 != &_fs_glyph_requested);
            goto LAB_0012742c;
          }
          uVar14 = (ulong)(bVar4 & 0xf0);
          if ((bVar4 & 0xf0) < uVar21) {
            uVar14 = uVar21;
          }
          uVar16 = (ulong)(bVar4 & 0xf0) + 0xf;
          if (uVar23 < uVar16) {
            uVar16 = uVar23;
          }
          if (uVar16 < uVar14) goto LAB_0012742c;
          plVar25 = (long *)(lVar10 + 0x10 + (uVar14 - uVar21) * 0x18);
          while( true ) {
            if ((char *)*plVar25 == &_fs_glyph_undefined) {
              range.min_char_low = (CARD8)uVar14;
              range.max_char_high = '\0';
              range.min_char_high = '\0';
              range.max_char_low = range.min_char_low;
              iVar12 = add_range(&range,nranges,ranges,0);
              if (iVar12 != 0x55) goto LAB_00127578;
              bVar26 = false;
              *plVar25 = (long)&_fs_glyph_requested;
            }
            else {
              bVar26 = (bool)(bVar26 & (char *)*plVar25 != &_fs_glyph_requested);
            }
            if (uVar16 == uVar14) break;
            uVar14 = uVar14 + 1;
            plVar25 = plVar25 + 3;
          }
        } while (data != pbVar3);
      }
    }
    else {
LAB_001275bb:
      if (count == 0) {
        local_6a = (CARD8)uVar7;
        fullrange[0].max_char_low = (CARD8)uVar8;
        local_78 = fullrange;
        local_70 = 1;
        count = 2;
        fullrange[0].max_char_high = local_6a;
        uVar24 = uVar5;
        fullrange[0].min_char_high = (CARD8)uVar5;
        fullrange[0].min_char_low = bVar4;
        goto LAB_00127613;
      }
LAB_0012774a:
      local_70 = count - 1;
      if (count != 0) {
        uVar24 = (ushort)*data;
        bVar4 = data[1];
        local_78 = (fsRange *)data;
LAB_00127613:
        uVar16 = (ulong)uVar7;
        uVar18 = (uint)uVar8;
        do {
          uVar15 = (ulong)bVar4;
          uVar19 = (ulong)(byte)uVar24;
          uVar24 = uVar24 & 0xff;
          pCVar1 = &local_78->max_char_high;
          uVar22 = (uint)bVar4;
          local_98 = uVar18;
          if (range_flag == 0) {
            local_78 = (fsRange *)pCVar1;
            if ((((uVar14 <= uVar19) && (uVar19 <= uVar16)) && (uVar21 <= uVar15)) &&
               (local_98 = uVar22, local_80 = uVar19, uVar8 = uVar24, uVar15 <= uVar23)) {
LAB_0012780f:
              lVar17 = (uVar23 + 1) - uVar21;
              local_90 = (uVar19 - uVar14) * lVar17 - uVar21;
              local_a8 = (ulong)(int)uVar22;
              uVar15 = (long)(int)local_98;
LAB_00127861:
              do {
                if (local_a8 <= uVar15) {
                  uVar20 = local_a8;
                  plVar25 = (long *)(lVar10 + 0x10 + (local_90 + local_a8) * 0x18);
                  do {
                    while (pcVar11 = (char *)*plVar25, pcVar11 == &_fs_glyph_undefined) {
                      if ((uVar8 == uVar24) &&
                         (((((uVar22 & 0xf) != 0 && (uVar21 < local_a8)) ||
                           ((local_98 & 0xf) != 0xf)) && (uVar15 < uVar23)))) {
                        uVar22 = uVar22 & 0xf0;
                        local_98 = (local_98 & 0xf0) + 0xf;
                        local_a8 = (ulong)(int)uVar22;
                        if (local_a8 < uVar21) {
                          local_a8 = (ulong)uVar6;
                          uVar22 = (uint)uVar6;
                        }
                        uVar15 = (long)(int)local_98;
                        if (uVar23 < (ulong)(long)(int)local_98) {
                          uVar15 = uVar23;
                          local_98 = uVar18;
                        }
                        goto LAB_00127861;
                      }
                      range.min_char_low = (CARD8)uVar20;
                      range.min_char_high = (CARD8)uVar19;
                      range.max_char_high = range.min_char_high;
                      range.max_char_low = range.min_char_low;
                      iVar12 = add_range(&range,nranges,ranges,0);
                      if (iVar12 != 0x55) goto LAB_00127578;
                      uVar20 = uVar20 + 1;
                      bVar26 = false;
                      *plVar25 = (long)&_fs_glyph_requested;
                      plVar25 = plVar25 + 3;
                      if (uVar15 < uVar20) goto LAB_00127955;
                    }
                    uVar20 = uVar20 + 1;
                    plVar25 = plVar25 + 3;
                    bVar26 = (bool)(bVar26 & pcVar11 != &_fs_glyph_requested);
                  } while (uVar20 <= uVar15);
                }
LAB_00127955:
                local_90 = local_90 + lVar17;
                bVar27 = local_80 != uVar19;
                uVar19 = uVar19 + 1;
              } while (bVar27);
            }
          }
          else {
            local_80 = uVar16;
            uVar8 = uVar7;
            if (local_70 == 0) {
              uVar20 = uVar23;
              local_78 = (fsRange *)pCVar1;
              if (uVar19 < uVar14) goto LAB_001277a8;
            }
            else {
              pfVar2 = local_78 + 1;
              local_80 = (ulong)local_78->max_char_high;
              uVar20 = (ulong)local_78->max_char_low;
              uVar8 = (ushort)local_78->max_char_high;
              local_98 = (uint)local_78->max_char_low;
              local_70 = count - 2;
              local_78 = pfVar2;
              if (uVar19 < uVar14) {
LAB_001277a8:
                uVar19 = uVar14;
                uVar24 = uVar5;
              }
              if (uVar16 < local_80) {
                local_80 = uVar16;
                uVar8 = uVar7;
              }
            }
            uVar13 = (uint)uVar6;
            if (uVar21 <= uVar15) {
              uVar13 = uVar22;
            }
            if (uVar23 < uVar20) {
              local_98 = uVar18;
            }
            uVar22 = uVar13;
            if (uVar19 <= local_80) goto LAB_0012780f;
          }
          if (local_70 == 0) break;
          uVar24 = (ushort)local_78->min_char_high;
          bVar4 = local_78->min_char_low;
          count = local_70;
          local_70 = local_70 - 1;
        } while( true );
      }
    }
LAB_00127568:
    iVar12 = 0x55;
    if (!bVar26) goto LAB_00127578;
  }
LAB_001275a8:
  iVar12 = 0x400;
LAB_00127578:
  if (lVar9 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar12;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void _fs_clean_aborted_loadglyphs(FontPtr pfont,int num_expected_ranges,fsRange *expected_ranges)

{
  byte bVar1;
  ushort uVar2;
  void *pvVar3;
  long lVar4;
  long lVar5;
  uint uVar6;
  ushort uVar7;
  uint uVar8;
  uint uVar9;
  CARD8 *pCVar10;
  uint uVar11;
  int iVar12;
  long in_FS_OFFSET;
  fsRange full_range [1];
  
  pvVar3 = pfont->fontPrivate;
  lVar4 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(long *)((long)pvVar3 + 8) == 0) {
LAB_00127b40:
    if (lVar4 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    return;
  }
  if (num_expected_ranges == 0) {
    uVar2 = (pfont->info).firstRow;
    uVar6 = (uint)uVar2;
    expected_ranges = full_range;
    num_expected_ranges = 1;
    uVar7 = (pfont->info).lastRow;
    full_range[0].min_char_low = (CARD8)(pfont->info).firstCol;
    full_range[0].min_char_high = (CARD8)uVar2;
    full_range[0].max_char_high = (CARD8)uVar7;
    full_range[0].max_char_low = (CARD8)(pfont->info).lastCol;
  }
  else {
    if (num_expected_ranges < 1) goto LAB_00127b40;
    uVar6 = (uint)expected_ranges->min_char_high;
    uVar7 = (ushort)expected_ranges->max_char_high;
  }
  iVar12 = 0;
  pCVar10 = &expected_ranges->min_char_low;
  do {
    uVar11 = uVar6 & 0xff;
    if ((byte)uVar6 <= (byte)uVar7) {
      uVar6 = (uint)pCVar10[2];
      do {
        bVar1 = *pCVar10;
        uVar8 = (uint)bVar1;
        uVar9 = (uint)(pfont->info).firstCol;
        lVar5 = *(long *)((long)pvVar3 + 8) +
                (long)(int)(((((pfont->info).lastCol - uVar9) + 1) *
                             (uVar11 - (pfont->info).firstRow) + (uint)bVar1) - uVar9) * 0x18;
        if (bVar1 <= uVar6) {
          do {
            while (*(char **)(lVar5 + 0x10) != &_fs_glyph_requested) {
              uVar8 = uVar8 + 1;
              lVar5 = lVar5 + 0x18;
              if ((int)uVar6 < (int)uVar8) goto LAB_00127b1b;
            }
            uVar8 = uVar8 + 1;
            *(char **)(lVar5 + 0x10) = &_fs_glyph_undefined;
            uVar6 = (uint)pCVar10[2];
            lVar5 = lVar5 + 0x18;
          } while ((int)uVar8 <= (int)uVar6);
        }
LAB_00127b1b:
        uVar11 = uVar11 + 1;
      } while ((int)uVar11 <= (int)(uint)pCVar10[1]);
    }
    iVar12 = iVar12 + 1;
    if (num_expected_ranges <= iVar12) goto LAB_00127b40;
    uVar6 = (uint)pCVar10[3];
    uVar7 = (ushort)pCVar10[5];
    pCVar10 = pCVar10 + 4;
  } while( true );
}



FontPtr fs_create_font(FontPathElementPtr fpe,char *name,int namelen,fsBitmapFormat format,
                      fsBitmapFormatMask fmask)

{
  int iVar1;
  FontPtr pfont;
  undefined (*__ptr) [16];
  Font id;
  size_t __n;
  FontPtr p_Var2;
  long in_FS_OFFSET;
  int bit;
  int byte;
  int scan;
  int glyph;
  long local_40;
  
  __n = (size_t)namelen;
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  pfont = CreateFontRec();
  p_Var2 = pfont;
  if (pfont != (FontPtr)0x0) {
    __ptr = (undefined (*) [16])malloc(__n + 0x51);
    if (__ptr != (undefined (*) [16])0x0) {
      *__ptr = (undefined  [16])0x0;
      __ptr[1] = (undefined  [16])0x0;
      __ptr[2] = (undefined  [16])0x0;
      __ptr[3] = (undefined  [16])0x0;
      __ptr[4] = (undefined  [16])0x0;
      pfont->fpe = fpe;
      pfont->fontPrivate = __ptr;
      pfont->fpePrivate = __ptr + 2;
      CheckFSFormat(format,0x1b,&bit,&byte,&scan,&glyph,(int *)0x0);
      pfont->format = format;
      pfont->bit = (char)bit;
      (pfont->info).nprops = 0;
      pfont->byte = (char)byte;
      (pfont->info).props = (FontPropPtr)0x0;
      pfont->scan = (char)scan;
      (pfont->info).isStringProp = (char *)0x0;
      pfont->glyph = (char)glyph;
      pfont->get_glyphs = _fs_get_glyphs;
      pfont->get_metrics = _fs_get_metrics;
      pfont->unload_font = _fs_unload_font;
      pfont->unload_glyphs = (_func_void_FontPtr *)0x0;
      *(undefined (**) [16])__ptr[4] = __ptr + 5;
      *(fsBitmapFormat *)(__ptr[4] + 8) = format;
      *(fsBitmapFormatMask *)(__ptr[4] + 0xc) = fmask;
      memcpy(__ptr + 5,name,__n);
      __ptr[5][__n] = 0;
      id = GetNewFontClientID();
      *(Font *)__ptr[2] = id;
      iVar1 = StoreFontClientFont(pfont,id);
      if (iVar1 != 0) goto LAB_00127d09;
      free(__ptr);
    }
    p_Var2 = (FontPtr)0x0;
    DestroyFontRec(pfont);
  }
LAB_00127d09:
  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return p_Var2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



pointer fs_alloc_glyphs(FontPtr pFont,int size)

{
  void *pvVar1;
  undefined8 *puVar2;
  
  pvVar1 = pFont->fontPrivate;
  puVar2 = (undefined8 *)malloc((long)size + 8);
  *puVar2 = *(undefined8 *)((long)pvVar1 + 0x18);
  *(undefined8 **)((long)pvVar1 + 0x18) = puVar2;
  return puVar2 + 1;
}



void _fs_signal_clients_depending(FSClientsDependingPtr *clients_depending)

{
  FSClientsDependingPtr __ptr;
  
  __ptr = *clients_depending;
  while (__ptr != (FSClientsDependingPtr)0x0) {
    *clients_depending = __ptr->next;
    ClientSignal((ClientPtr)__ptr->client);
    free(__ptr);
    __ptr = *clients_depending;
  }
  return;
}



void fs_block_handler(pointer data,OSTimePtr wt,pointer LastSelectMask)

{
  timeval *ptVar1;
  timeval tVar2;
  FSFpePtr *pp_Var3;
  long lVar4;
  ulong uVar5;
  FSFpePtr p_Var6;
  CARD32 CVar7;
  uint uVar8;
  
  lVar4 = 0;
  do {
    *(ulong *)((long)LastSelectMask + lVar4) =
         *(ulong *)((long)LastSelectMask + lVar4) | *(ulong *)((long)_fs_fd_mask.fds_bits + lVar4);
    lVar4 = lVar4 + 8;
  } while (lVar4 != 0x80);
  p_Var6 = fs_fpes;
  if ((fs_blockState & 1) != 0) {
    for (; p_Var6 != (FSFpePtr)0x0; p_Var6 = p_Var6->next) {
      while ((*(byte *)&p_Var6->blockState & 1) == 0) {
        p_Var6 = p_Var6->next;
        if (p_Var6 == (FSFpePtr)0x0) goto joined_r0x00127e79;
      }
      _fs_flush(p_Var6);
    }
  }
joined_r0x00127e79:
  if ((fs_blockState & 0x20) == 0) {
    if ((fs_blockState & 0x4e) != 0) {
      uVar5 = GetTimeInMillis();
      CVar7 = (int)uVar5 + 10000000;
      p_Var6 = fs_fpes;
      if (fs_fpes == (FSFpePtr)0x0) {
        uVar8 = 10000000;
        fs_block_handler::block_timeout.tv_usec = 0;
        fs_block_handler::block_timeout.tv_sec = 10000;
      }
      else {
        do {
          uVar8 = p_Var6->blockState;
          if (((uVar8 & 0x40) != 0) && ((int)(p_Var6->blockedConnectTime - CVar7) < 0)) {
            CVar7 = p_Var6->blockedConnectTime;
          }
          if (((uVar8 & 4) != 0) && ((int)(p_Var6->brokenConnectionTime - CVar7) < 0)) {
            CVar7 = p_Var6->brokenConnectionTime;
          }
          if (((uVar8 & 2) != 0) && ((int)(p_Var6->brokenWriteTime - CVar7) < 0)) {
            CVar7 = p_Var6->brokenWriteTime;
          }
          if (((uVar8 & 8) != 0) && ((int)(p_Var6->blockedReplyTime - CVar7) < 0)) {
            CVar7 = p_Var6->blockedReplyTime;
          }
          pp_Var3 = &p_Var6->next;
          p_Var6 = *pp_Var3;
        } while (*pp_Var3 != (FSFpePtr)0x0);
        uVar8 = CVar7 - (int)uVar5;
        if ((int)uVar8 < 0) {
          uVar8 = 0;
        }
        fs_block_handler::block_timeout.tv_sec = (__time_t)(int)(uVar8 / 1000);
        fs_block_handler::block_timeout.tv_usec = (__suseconds_t)(int)((uVar8 % 1000) * 1000);
      }
      ptVar1 = *wt;
      if (ptVar1 == (timeval *)0x0) goto LAB_00127f80;
      if ((long)(int)uVar8 < ptVar1->tv_usec / 1000 + ptVar1->tv_sec * 1000) {
        tVar2.tv_usec = fs_block_handler::block_timeout.tv_usec;
        tVar2.tv_sec = fs_block_handler::block_timeout.tv_sec;
        *ptVar1 = tVar2;
      }
    }
  }
  else {
    fs_block_handler::block_timeout.tv_sec = 0;
    fs_block_handler::block_timeout.tv_usec = 0;
    if (*wt == (timeval *)0x0) {
LAB_00127f80:
      *wt = &fs_block_handler::block_timeout;
      return;
    }
    **wt = (timeval)ZEXT816(0);
  }
  return;
}



void _fs_client_resolution(FSFpePtr conn)

{
  long lVar1;
  int iVar2;
  FontResolutionPtr data;
  long in_FS_OFFSET;
  int num_res;
  fsSetResolutionReq srreq;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  data = GetClientResolutions(&num_res);
  if (num_res != 0) {
    conn->current_seq = conn->current_seq + 1;
    srreq.num_resolutions = (BYTE)num_res;
    srreq.reqType = '\v';
    srreq.length = (CARD16)(num_res * 6 + 7 >> 2);
    iVar2 = _fs_write(conn,(char *)&srreq,4);
    if (iVar2 != -1) {
      _fs_write_pad(conn,(char *)data,(long)(num_res * 6));
    }
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Bool fs_name_check(char *name)

{
  char *pcVar1;
  
  if ((name != (char *)0x0) && (*name != '/')) {
    pcVar1 = strchr(name,0x2f);
    return (Bool)(pcVar1 != (char *)0x0);
  }
  return 0;
}



char * _fs_catalog_name(char *servername)

{
  char *pcVar1;
  
  pcVar1 = strchr(servername,0x2f);
  if (pcVar1 != (char *)0x0) {
    pcVar1 = strrchr(pcVar1 + 1,0x2f);
    return pcVar1;
  }
  return (char *)0x0;
}



int _fs_send_init_packets(FSFpePtr conn)

{
  long lVar1;
  int iVar2;
  FontResolutionPtr data;
  char *pcVar3;
  char *__s;
  size_t sVar4;
  long lVar5;
  BYTE BVar6;
  int iVar7;
  long in_FS_OFFSET;
  char len;
  int num_res;
  fsSetResolutionReq srreq;
  fsSetCataloguesReq screq;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  data = GetClientResolutions(&num_res);
  if (num_res == 0) {
LAB_001280f8:
    if (conn->alternate == 0) {
      pcVar3 = _fs_catalog_name(conn->servername);
joined_r0x0012819c:
      if (pcVar3 == (char *)0x0) {
        conn->has_catalogues = 0;
        iVar7 = 1;
        goto LAB_001281f5;
      }
    }
    else {
      pcVar3 = _fs_catalog_name(conn->alts[(long)conn->alternate + -1].name);
      if (pcVar3 == (char *)0x0) {
        pcVar3 = _fs_catalog_name(conn->servername);
        goto joined_r0x0012819c;
      }
    }
    conn->has_catalogues = 1;
    __s = pcVar3 + 1;
    if (pcVar3[1] == '\0') {
      screq.length = 1;
      screq.num_catalogues = '\0';
      iVar7 = 0;
    }
    else {
      iVar7 = 0;
      BVar6 = '\0';
      pcVar3 = __s;
      do {
        BVar6 = BVar6 + '\x01';
        __s = strchr(pcVar3,0x2b);
        if (__s == (char *)0x0) {
          sVar4 = strlen(pcVar3);
          __s = pcVar3 + sVar4;
        }
        iVar7 = iVar7 + 1 + ((int)__s - (int)pcVar3);
        pcVar3 = __s;
      } while (*__s != '\0');
      screq.length = (CARD16)(iVar7 + 7 >> 2);
      screq.num_catalogues = BVar6;
    }
    conn->current_seq = conn->current_seq + 1;
    screq.reqType = '\x04';
    iVar2 = _fs_write(conn,(char *)&screq,4);
    if (iVar2 == 1) {
      while (*__s != '\0') {
        pcVar3 = strchr(__s,0x2b);
        if (pcVar3 == (char *)0x0) {
          sVar4 = strlen(__s);
          pcVar3 = __s + sVar4;
        }
        len = (char)pcVar3 - (char)__s;
        iVar2 = _fs_write(conn,&len,1);
        if ((iVar2 != 1) || (iVar2 = _fs_write(conn,__s,(long)len), __s = pcVar3, iVar2 != 1))
        goto LAB_001281f0;
      }
      lVar5 = _fs_pad_length((long)iVar7);
      iVar7 = _fs_write(conn,"....",lVar5 - iVar7);
      if (iVar7 == 1) {
        iVar7 = 1;
        goto LAB_001281f5;
      }
    }
  }
  else {
    conn->current_seq = conn->current_seq + 1;
    srreq.num_resolutions = (BYTE)num_res;
    srreq.reqType = '\v';
    srreq.length = (CARD16)(num_res * 6 + 7 >> 2);
    iVar7 = _fs_write(conn,(char *)&srreq,4);
    if ((iVar7 == 1) && (iVar7 = _fs_write_pad(conn,(char *)data,(long)(num_res * 6)), iVar7 == 1))
    goto LAB_001280f8;
  }
LAB_001281f0:
  iVar7 = -1;
LAB_001281f5:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar7;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int fs_reset_fpe(FontPathElementPtr fpe)

{
  _fs_send_init_packets((FSFpePtr)fpe->private);
  return 0x55;
}



Bool fs_reply_ready(FSFpePtr conn)

{
  byte bVar1;
  long lVar2;
  ulong uVar3;
  
  if (conn->fs_fd != -1) {
    lVar2 = __fdelt_chk();
    bVar1 = (byte)(conn->fs_fd >> 0x1f);
    if ((_fs_fd_mask.fds_bits[lVar2] &
        1L << (((char)conn->fs_fd + (bVar1 >> 2) & 0x3f) - (bVar1 >> 2) & 0x3f)) != 0) {
      lVar2 = (conn->inBuf).remove;
      uVar3 = (conn->inBuf).insert - lVar2;
      if (7 < uVar3) {
        return (Bool)((long)(ulong)(uint)(*(int *)((conn->inBuf).buf + lVar2 + 4) << 2) <=
                     (long)uVar3);
      }
    }
  }
  return 0;
}



fsGenericReply * fs_get_reply(FSFpePtr conn,int *error)

{
  byte bVar1;
  int iVar2;
  long lVar3;
  long in_FS_OFFSET;
  char *buf;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (conn->fs_fd != -1) {
    lVar3 = __fdelt_chk();
    bVar1 = (byte)(conn->fs_fd >> 0x1f);
    if ((_fs_fd_mask.fds_bits[lVar3] &
        1L << (((char)conn->fs_fd + (bVar1 >> 2) & 0x3f) - (bVar1 >> 2) & 0x3f)) != 0) {
      iVar2 = _fs_start_read(conn,8,&buf);
      if (iVar2 == 1) {
        iVar2 = _fs_start_read(conn,(ulong)(uint)(*(int *)(buf + 4) << 2),&buf);
        if (iVar2 == 1) {
          *error = 1;
          goto LAB_00128480;
        }
      }
    }
  }
  *error = 0;
  buf = (char *)0x0;
LAB_00128480:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return (fsGenericReply *)buf;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int fs_send_close_font(FontPathElementPtr fpe,Font id)

{
  long lVar1;
  long in_FS_OFFSET;
  fsCloseReq req;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if ((*(byte *)&fpe[4].private & 0x10) == 0) {
    fpe->type = fpe->type + 1;
    req.id = (CARD32)id;
    req.reqType = '\x15';
    req.pad = '\0';
    req.length = 2;
    _fs_write((FSFpePtr)fpe,(char *)&req,8);
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return 0x55;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void fs_close_font(FontPathElementPtr fpe,FontPtr pfont)

{
  if (*(int *)&((FontPathElementPtr)fpe->private)[1].field_0x4 !=
      *(int *)((long)pfont->fpePrivate + 8)) {
                    // WARNING: Could not recover jumptable at 0x00128523. Too many branches
                    // WARNING: Treating indirect jump as call
    (*pfont->unload_font)(pfont);
    return;
  }
                    // WARNING: Load size is inaccurate
  fs_send_close_font((FontPathElementPtr)fpe->private,*pfont->fpePrivate);
                    // WARNING: Could not recover jumptable at 0x00128538. Too many branches
                    // WARNING: Treating indirect jump as call
  (*pfont->unload_font)(pfont);
  return;
}



void fs_cleanup_bfont(FSBlockedFontPtr bfont)

{
  FontPtr p_Var1;
  void *pvVar2;
  
  p_Var1 = bfont->pfont;
  if (p_Var1 == (FontPtr)0x0) {
    return;
  }
  pvVar2 = p_Var1->fpePrivate;
  fs_send_close_font((FontPathElementPtr)p_Var1->fpe->private,bfont->fontid);
  if ((*(byte *)&bfont->flags & 0x20) != 0) {
    *(undefined4 *)((long)pvVar2 + 8) = 0xffffffff;
    return;
  }
  if (bfont->freeFont != 0) {
    (*bfont->pfont->unload_font)(bfont->pfont);
  }
  bfont->pfont = (FontPtr)0x0;
  return;
}



FSBlockDataPtr fs_new_block_rec(FontPathElementPtr fpe,pointer client,int type)

{
  long lVar1;
  FSBlockDataPtr p_Var2;
  int *piVar3;
  long lVar4;
  
  p_Var2 = (FSBlockDataPtr)malloc((long)*(int *)(CSWTCH_147 + (ulong)(type - 1) * 4) + 0x38);
  if (p_Var2 != (FSBlockDataPtr)0x0) {
    p_Var2->client = client;
    p_Var2->data = p_Var2 + 1;
    p_Var2->sequenceNumber = 0xffff;
    lVar1._0_4_ = fpe[5].type;
    lVar1._4_4_ = fpe[5].refcount;
    p_Var2->errcode = 0x51;
    p_Var2->type = type;
    p_Var2->depending = (_fs_block_data *)0x0;
    p_Var2->next = (_fs_block_data *)0x0;
    if (lVar1 == 0) {
      piVar3 = &fpe[5].type;
    }
    else {
      do {
        lVar4 = lVar1;
        lVar1 = *(long *)(lVar4 + 0x30);
      } while (lVar1 != 0);
      piVar3 = (int *)(lVar4 + 0x30);
    }
    *(FSBlockDataPtr *)piVar3 = p_Var2;
  }
  return p_Var2;
}



// DWARF original prototype: int fs_read_glyphs(FontPathElementPtr fpe, FSBlockDataPtr blockrec,
// FSBlockDataPtr blockrec)

int fs_read_glyphs(FontPathElementPtr fpe,FSBlockDataPtr blockrec,FSBlockDataPtr blockrec_1)

{
  long *plVar1;
  ushort uVar2;
  uint uVar3;
  FontPtr pFont;
  void *pvVar4;
  void *pvVar5;
  byte *pbVar6;
  int iVar11;
  int iVar7;
  fsGenericReply *pfVar8;
  void *__dest;
  ulong *puVar9;
  byte *pbVar10;
  ulong uVar12;
  ulong uVar13;
  uint uVar14;
  char *pcVar15;
  int iVar16;
  long lVar17;
  long lVar18;
  ulong __n;
  void *pvVar19;
  long in_FS_OFFSET;
  int ret;
  long local_40;
  
  pFont = *(FontPtr *)blockrec_1;
  pvVar4 = pFont->fpePrivate;
  pvVar5 = pFont->fontPrivate;
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  pfVar8 = fs_get_reply((FSFpePtr)fpe,&ret);
  if (pfVar8 == (fsGenericReply *)0x0) {
    iVar16 = 0x51;
    if (ret == 0) goto LAB_00128861;
LAB_0012895a:
    iVar16 = 0x50;
  }
  else if (pfVar8->type == '\x01') {
    iVar16 = 0x51;
    if (ret == 0) goto LAB_00128861;
    iVar16 = 0x50;
    _fs_done_read((FSFpePtr)fpe,(ulong)(pfVar8->length * 4));
  }
  else {
    uVar3 = pfVar8[1].length;
    uVar13 = (ulong)uVar3;
    pbVar10 = (byte *)0x0;
    if (blockrec->type == 2) {
      iVar16 = *(int *)&blockrec_1->client;
      pbVar6 = *(byte **)&blockrec_1->sequenceNumber;
      pbVar10 = pbVar6;
      if (iVar16 == 0) goto LAB_001286d5;
      uVar2 = (pFont->info).firstCol;
      pbVar10 = pbVar6 + 4;
      iVar11 = ((uint)(pFont->info).lastCol - (uint)uVar2) + 1;
      uVar14 = (uint)(pFont->info).firstRow;
      uVar12 = (ulong)(int)(((*pbVar6 - uVar14) * iVar11 + (uint)pbVar6[1]) - (uint)uVar2);
      uVar13 = (ulong)(int)(((pbVar6[2] - uVar14) * iVar11 + (uint)pbVar6[3]) - (uint)uVar2);
    }
    else {
LAB_001286d5:
      iVar16 = 0;
      uVar12 = 0;
    }
    iVar11._0_1_ = pfVar8[2].type;
    iVar11._1_1_ = pfVar8[2].data1;
    iVar11._2_2_ = pfVar8[2].sequenceNumber;
    __dest = fs_alloc_glyphs(pFont,iVar11);
    if (__dest == (pointer)0x0) goto LAB_0012895a;
    iVar11 = blockrec->type;
    if (pfVar8[1].length != 0) {
      lVar18 = 0;
      do {
        while( true ) {
          lVar17 = uVar12 * 0x18;
          puVar9 = (ulong *)(*(long *)((long)pvVar5 + 8) + lVar17);
          if ((iVar11 != 1) && ((char *)puVar9[2] != &_fs_glyph_requested)) break;
          pvVar19 = __dest;
          if (((*puVar9 & 0xffff0000ffffffff) != 0) ||
             ((*(short *)(puVar9 + 1) != 0 ||
              (pcVar15 = (char *)0x0, *(short *)((long)puVar9 + 4) != 0)))) {
            pcVar15 = &_fs_glyph_zero_length;
            __n = *(ulong *)&pfVar8[lVar18 + 2].length >> 0x20;
            if (__n != 0) {
              pvVar19 = (void *)(__n + (long)__dest);
              pcVar15 = (char *)memcpy(__dest,(void *)((long)&pfVar8[2].length +
                                                      (ulong)(uVar3 * 8) +
                                                      (*(ulong *)&pfVar8[lVar18 + 2].length &
                                                      0xffffffff)),__n);
              puVar9 = (ulong *)(lVar17 + *(long *)((long)pvVar5 + 8));
            }
          }
          if ((char *)puVar9[2] == &_fs_glyph_requested) {
            plVar1 = (long *)((long)pvVar4 + 0x10);
            *plVar1 = *plVar1 + -1;
            puVar9 = (ulong *)(*(long *)((long)pvVar5 + 8) + lVar17);
          }
          puVar9[2] = (ulong)pcVar15;
          iVar11 = blockrec->type;
          __dest = pvVar19;
          if (uVar13 != uVar12) goto LAB_00128753;
LAB_001287c3:
          iVar16 = iVar16 + -1;
          if (iVar16 == 0) goto LAB_00128822;
          uVar2 = (pFont->info).firstCol;
          lVar18 = lVar18 + 1;
          uVar14 = (uint)(pFont->info).firstRow;
          iVar7 = ((uint)(pFont->info).lastCol - (uint)uVar2) + 1;
          uVar12 = (ulong)(int)(((*pbVar10 - uVar14) * iVar7 + (uint)pbVar10[1]) - (uint)uVar2);
          uVar13 = (ulong)(int)(((uint)pbVar10[3] + iVar7 * (pbVar10[2] - uVar14)) - (uint)uVar2);
          pbVar10 = pbVar10 + 4;
          if (pfVar8[1].length <= (uint)lVar18) goto LAB_00128822;
        }
        if (uVar13 == uVar12) goto LAB_001287c3;
LAB_00128753:
        uVar12 = uVar12 + 1;
        lVar18 = lVar18 + 1;
      } while ((uint)lVar18 < pfVar8[1].length);
    }
LAB_00128822:
    iVar16 = 0x55;
    if (iVar11 == 1) {
      *(undefined8 *)((long)pvVar4 + 0x10) = 0;
      *(undefined4 *)&blockrec_1->sequenceNumber = 4;
    }
  }
  _fs_done_read((FSFpePtr)fpe,(ulong)(pfVar8->length << 2));
LAB_00128861:
  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar16;
}



void _fs_client_access(FSFpePtr conn,pointer client,Bool sync)

{
  FSClientPtr p_Var1;
  long lVar2;
  XID XVar3;
  int iVar4;
  int iVar5;
  _fs_client_data **pp_Var6;
  _fs_client_data *p_Var7;
  Font FVar8;
  long in_FS_OFFSET;
  int authlen;
  char *authorizations;
  fsCreateACReq crac;
  fsSetAuthorizationReq setac;
  char padding [4];
  
  p_Var1 = conn->clients;
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  padding[0] = '\0';
  padding[1] = '\0';
  padding[2] = '\0';
  padding[3] = '\0';
  if (p_Var1 != (FSClientPtr)0x0) {
    pp_Var6 = &conn->clients;
    p_Var7 = p_Var1;
    do {
      if (p_Var7->client == client) {
        if (&conn->clients != pp_Var6) {
          *pp_Var6 = p_Var7->next;
          p_Var7->next = conn->clients;
          conn->clients = p_Var7;
        }
        iVar5 = p_Var7->auth_generation;
        iVar4 = client_auth_generation((ClientPtr)client);
        if (iVar5 == iVar4) goto LAB_00128b0a;
        XVar3 = p_Var7->acid;
        conn->current_seq = conn->current_seq + 1;
        setac.id = (CARD32)XVar3;
        setac.reqType = '\t';
        setac.pad = '\0';
        setac.length = 2;
        _fs_write(conn,(char *)&setac,8);
        goto LAB_00128a85;
      }
      pp_Var6 = &p_Var7->next;
      p_Var7 = p_Var7->next;
    } while (p_Var7 != (_fs_client_data *)0x0);
  }
  p_Var7 = (_fs_client_data *)malloc(0x20);
  if (p_Var7 != (FSClientPtr)0x0) {
    p_Var7->client = client;
    p_Var7->next = p_Var1;
    conn->clients = p_Var7;
    FVar8 = GetNewFontClientID();
    p_Var7->acid = FVar8;
LAB_00128a85:
    crac.reqType = '\b';
    iVar5 = set_font_authorizations(&authorizations,&authlen,(ClientPtr)client);
    crac.num_auths = (BYTE)iVar5;
    if (crac.num_auths == '\0') {
      authlen = 4;
      authorizations = padding;
      crac.length = 3;
    }
    else {
      authlen = authlen + 3U & 0xfffffffc;
      crac.length = (CARD16)((long)authlen + 8U >> 2);
    }
    XVar3 = p_Var7->acid;
    conn->current_seq = conn->current_seq + 1;
    crac.acid = (CARD32)XVar3;
    _fs_write(conn,(char *)&crac,8);
    _fs_write(conn,authorizations,(long)authlen);
    conn->curacid = 0;
    iVar5 = client_auth_generation((ClientPtr)client);
    p_Var7->auth_generation = iVar5;
LAB_00128b0a:
    XVar3 = p_Var7->acid;
    if (conn->curacid != XVar3) {
      conn->current_seq = conn->current_seq + 1;
      setac.reqType = '\n';
      setac.pad = '\0';
      setac.length = 2;
      setac.id = (CARD32)XVar3;
      _fs_write(conn,(char *)&setac,8);
      conn->curacid = p_Var7->acid;
    }
  }
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void _fs_mark_block(FSFpePtr conn,CARD32 mask)

{
  conn->blockState = conn->blockState | mask;
  fs_blockState = fs_blockState | mask;
  return;
}



void _fs_pending_reply(FSFpePtr conn)

{
  ulong uVar1;
  
  _fs_mark_block(conn,8);
  uVar1 = GetTimeInMillis();
  conn->blockedReplyTime = (int)uVar1 + 30000;
  return;
}



void _fs_prepare_for_reply(FSFpePtr conn)

{
  if ((*(byte *)&conn->blockState & 8) != 0) {
    _fs_flush(conn);
    return;
  }
  _fs_pending_reply(conn);
  _fs_flush(conn);
  return;
}



int fs_send_load_glyphs(pointer client,FontPtr pfont,int nranges,fsRange *ranges)

{
  CARD8 CVar1;
  CARD8 CVar2;
  CARD8 CVar3;
  CARD8 CVar4;
  long lVar5;
  FSFpePtr conn;
  undefined8 *puVar6;
  ulong uVar7;
  FSBlockDataPtr p_Var8;
  CARD8 *pCVar9;
  ulong uVar10;
  ulong uVar11;
  long in_FS_OFFSET;
  int local_15c;
  fsQueryXBitmaps16Req req;
  char range_buffer [256];
  
  lVar5 = *(long *)(in_FS_OFFSET + 0x28);
  conn = (FSFpePtr)pfont->fpe->private;
  local_15c = 0x57;
  if ((*(byte *)&conn->blockState & 0x10) == 0) {
    p_Var8 = fs_new_block_rec((FontPathElementPtr)conn,client,2);
    if (p_Var8 == (FSBlockDataPtr)0x0) {
      local_15c = 0x50;
    }
    else {
      puVar6 = (undefined8 *)p_Var8->data;
      *puVar6 = pfont;
      *(int *)(puVar6 + 1) = nranges;
      puVar6[2] = ranges;
      puVar6[3] = 0;
      if ((conn->blockState & 0x44) == 0) {
        req.reqType = '\x14';
                    // WARNING: Load size is inaccurate
        req.range = '\x01';
        req.fid = (CARD32)*pfont->fpePrivate;
        req.format = pfont->format & 0xfffffff3 | 8;
        if (((pfont->info).field_0xa & 2) == 0) {
          req.format = pfont->format;
        }
        conn->current_seq = conn->current_seq + 1;
        req.length = (short)nranges + 4;
        req.num_ranges = nranges * 2;
        _fs_write(conn,(char *)&req,0x10);
        p_Var8->sequenceNumber = (CARD16)conn->current_seq;
        if ((nranges != 0) && (0 < nranges)) {
          uVar11 = (ulong)(nranges - 1) + 2;
          pCVar9 = (CARD8 *)range_buffer;
          uVar7 = 1;
          do {
            while( true ) {
              uVar10 = uVar7;
              CVar1 = ranges[uVar10 - 1].min_char_low;
              CVar2 = ranges[uVar10 - 1].min_char_high;
              CVar3 = ranges[uVar10 - 1].max_char_low;
              CVar4 = ranges[uVar10 - 1].max_char_high;
              if (conn->fsMajorVersion < 2) break;
              *pCVar9 = CVar2;
              pCVar9[1] = CVar1;
              pCVar9[2] = CVar4;
              pCVar9[3] = CVar3;
              if ((uVar10 & 0x3f) != 0) goto LAB_00128d8e;
LAB_00128dcd:
              _fs_write(conn,range_buffer,0x100);
              pCVar9 = (CARD8 *)range_buffer;
              uVar7 = uVar10 + 1;
              if (uVar11 == uVar10 + 1) goto LAB_00128de9;
            }
            *pCVar9 = CVar1;
            pCVar9[1] = CVar2;
            pCVar9[2] = CVar3;
            pCVar9[3] = CVar4;
            if ((uVar10 & 0x3f) == 0) goto LAB_00128dcd;
LAB_00128d8e:
            pCVar9 = pCVar9 + 4;
            uVar7 = uVar10 + 1;
          } while (uVar11 != uVar10 + 1);
LAB_00128de9:
          if ((uVar10 & 0x3f) != 0) {
            _fs_write(conn,range_buffer,(long)(int)(((uint)uVar10 & 0x3f) * 4));
          }
        }
        _fs_prepare_for_reply(conn);
        local_15c = 0x54;
      }
      else {
        local_15c = 0x54;
        if ((conn->blockState & 8) == 0) {
          local_15c = 0x54;
          _fs_pending_reply(conn);
        }
      }
    }
  }
  if (lVar5 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_15c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int fs_start_list_with_info
              (pointer client,FontPathElementPtr fpe,char *pattern,int len,int maxnames,
              pointer *pdata)

{
  uint sync;
  FSFpePtr conn;
  long lVar1;
  undefined8 *puVar2;
  FSBlockDataPtr p_Var3;
  ulong uVar4;
  undefined8 *puVar5;
  long in_FS_OFFSET;
  byte bVar6;
  int local_5c;
  fsListFontsWithXInfoReq req;
  
  bVar6 = 0;
  conn = (FSFpePtr)fpe->private;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  local_5c = 0x53;
  if ((*(byte *)&conn->blockState & 0x10) == 0) {
    p_Var3 = fs_new_block_rec((FontPathElementPtr)conn,client,4);
    local_5c = 0x50;
    if (p_Var3 != (FSBlockDataPtr)0x0) {
      puVar2 = (undefined8 *)p_Var3->data;
      *puVar2 = 0;
      puVar2[0x2c] = 0;
      puVar5 = (undefined8 *)((ulong)(puVar2 + 1) & 0xfffffffffffffff8);
      for (uVar4 = (ulong)(((int)puVar2 -
                           (int)(undefined8 *)((ulong)(puVar2 + 1) & 0xfffffffffffffff8)) + 0x168U
                          >> 3); uVar4 != 0; uVar4 = uVar4 - 1) {
        *puVar5 = 0;
        puVar5 = puVar5 + (ulong)bVar6 * -2 + 1;
      }
      *(undefined4 *)puVar2 = 0;
      sync = conn->blockState;
      if ((sync & 0x44) == 0) {
        _fs_client_access(conn,client,sync);
        _fs_client_resolution(conn);
        conn->current_seq = conn->current_seq + 1;
        req.reqType = '\x0e';
        req.pad = '\0';
        req.nbytes = (CARD16)len;
        req.length = (CARD16)(len + 0xf >> 2);
        req.maxNames = maxnames;
        _fs_write(conn,(char *)&req,0xc);
        _fs_write_pad(conn,pattern,(long)len);
        p_Var3->sequenceNumber = (CARD16)conn->current_seq;
        _fs_prepare_for_reply(conn);
        local_5c = 0x55;
      }
      else {
        local_5c = 0x54;
        if ((sync & 8) == 0) {
          local_5c = 0x54;
          _fs_pending_reply(conn);
        }
      }
    }
  }
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_5c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void _fs_unmark_block(FSFpePtr conn,CARD32 mask)

{
  FSFpePtr p_Var1;
  
  p_Var1 = fs_fpes;
  if ((conn->blockState & mask) != 0) {
    fs_blockState = 0;
    conn->blockState = ~mask & conn->blockState;
    if (p_Var1 != (FSFpePtr)0x0) {
      fs_blockState = 0;
      do {
        fs_blockState = fs_blockState | p_Var1->blockState;
        p_Var1 = p_Var1->next;
      } while (p_Var1 != (FSFpePtr)0x0);
    }
  }
  return;
}



void _fs_close_server(FSFpePtr conn)

{
  byte bVar1;
  long lVar2;
  
  _fs_unmark_block(conn,0x27);
  if (conn->trans_conn != (XtransConnInfo)0x0) {
    _FontTransClose(conn->trans_conn);
    conn->trans_conn = (_XtransConnInfo *)0x0;
    _fs_io_reinit(conn);
  }
  if (-1 < conn->fs_fd) {
    lVar2 = __fdelt_chk();
    bVar1 = (byte)(conn->fs_fd >> 0x1f);
    bVar1 = ((char)conn->fs_fd + (bVar1 >> 2) & 0x3f) - (bVar1 >> 2) & 0x3f;
    _fs_fd_mask.fds_bits[lVar2] =
         _fs_fd_mask.fds_bits[lVar2] & (-2L << bVar1 | 0xfffffffffffffffeU >> 0x40 - bVar1);
    conn->fs_fd = -1;
  }
  conn->fs_conn_state = 0;
  return;
}



int _fs_do_setup_connection(FSFpePtr conn)

{
  short *psVar1;
  byte bVar2;
  short *psVar3;
  int iVar4;
  XtransConnInfo p_Var5;
  ulong uVar6;
  fsGenericReply *pfVar7;
  FSFpeAltPtr p_Var8;
  long lVar9;
  ulong uVar10;
  undefined8 *puVar11;
  char *servername;
  undefined8 *puVar12;
  FSFpeAltPtr p_Var13;
  FSFpeAltPtr p_Var14;
  int iVar15;
  short *psVar16;
  long in_FS_OFFSET;
  byte bVar17;
  char *data;
  undefined2 uStack_48;
  undefined2 local_46;
  long local_40;
  
  bVar17 = 0;
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  iVar4 = conn->fs_conn_state;
  do {
    switch(iVar4) {
    case 0:
      if (conn->alternate == 0) {
        servername = conn->servername;
      }
      else {
        servername = conn->alts[(long)conn->alternate + -1].name;
      }
      p_Var5 = _fs_connect(servername,(int *)&data);
      conn->trans_conn = p_Var5;
      uVar6 = GetTimeInMillis();
      conn->blockedConnectTime = (int)uVar6 + 5000;
      iVar4 = CONCAT22(data._2_2_,CONCAT11(data._1_1_,data._0_1_));
      if (iVar4 == 0) {
        conn->fs_conn_state = 1;
LAB_00129350:
        uVar6 = GetTimeInMillis();
        if ((int)((int)uVar6 - conn->blockedConnectTime) < 0) {
          iVar4 = 0;
          goto LAB_001292c4;
        }
      }
      else {
LAB_00129103:
        if (iVar4 == 1) {
          iVar4 = conn->fs_conn_state;
          goto joined_r0x0012940f;
        }
LAB_001292bf:
        if (iVar4 != -1) goto LAB_001292c4;
      }
      break;
    case 1:
      iVar4 = _fs_poll_connect(conn->trans_conn,0);
      if (iVar4 != 1) {
LAB_001292b7:
        if (iVar4 != 0) goto LAB_001292bf;
        goto LAB_00129350;
      }
      iVar4 = _FontTransGetConnectionNumber(conn->trans_conn);
      conn->fs_fd = iVar4;
      lVar9 = __fdelt_chk((long)iVar4);
      _fs_fd_mask.fds_bits[lVar9] =
           _fs_fd_mask.fds_bits[lVar9] | 1L << ((byte)(conn->fs_fd % 0x40) & 0x3f);
      iVar4 = conn->fs_conn_state;
    default:
joined_r0x0012940f:
      if (iVar4 < 6) {
LAB_001292fb:
        iVar4 = iVar4 + 1;
        conn->fs_conn_state = iVar4;
      }
      goto LAB_00129275;
    case 2:
      data._0_1_ = 0x6c;
      data._1_1_ = 0;
      data._2_2_ = 2;
      data._4_4_ = 0;
      iVar4 = _fs_write(conn,(char *)&data,8);
      goto joined_r0x001293ae;
    case 3:
      iVar4 = _fs_start_read(conn,0xc,&data);
      if (iVar4 != 1) goto LAB_001292b7;
      psVar3 = (short *)CONCAT44(data._4_4_,CONCAT22(data._2_2_,CONCAT11(data._1_1_,data._0_1_)));
      if ((ushort)psVar3[1] < 3) {
        iVar15 = (uint)(ushort)psVar3[5] * 4 + 0xc + (uint)(ushort)psVar3[4] * 4;
        if (*psVar3 == 0) {
          iVar4 = _fs_start_read(conn,(long)(iVar15 + 0xc),&data);
          if (iVar4 != 1) goto LAB_001292b7;
          iVar15 = iVar15 + *(int *)(CONCAT44(data._4_4_,
                                              CONCAT22(data._2_2_,CONCAT11(data._1_1_,data._0_1_)))
                                    + (long)iVar15) * 4;
        }
        iVar4 = _fs_start_read(conn,(long)iVar15,&data);
        if (iVar4 != 1) goto LAB_001292b7;
        psVar3 = (short *)CONCAT44(data._4_4_,CONCAT22(data._2_2_,CONCAT11(data._1_1_,data._0_1_)));
        if (psVar3 != (short *)0x0) {
          conn->current_seq = 0;
          conn->fsMajorVersion = (uint)(ushort)psVar3[1];
          if (conn->alternate == 0) {
            if (conn->alts != (FSFpeAltPtr)0x0) {
              free(conn->alts);
              conn->alts = (FSFpeAltPtr)0x0;
              conn->numAlts = 0;
            }
            bVar2 = *(byte *)(psVar3 + 3);
            if (bVar2 != 0) {
              p_Var8 = (FSFpeAltPtr)
                       malloc((long)(int)((uint)(ushort)psVar3[4] << 2) + (ulong)bVar2 * 0x10);
              if (p_Var8 != (FSFpeAltPtr)0x0) {
                psVar16 = psVar3 + 6;
                p_Var14 = p_Var8 + bVar2;
                iVar4 = 0;
                p_Var13 = p_Var8;
                do {
                  psVar1 = psVar16 + 1;
                  p_Var13->subset = (int)*(char *)psVar16;
                  bVar2 = *(byte *)((long)psVar16 + 1);
                  uVar6 = (ulong)(char)bVar2;
                  p_Var13->name = (char *)p_Var14;
                  if (uVar6 < 8) {
                    if ((uVar6 & 4) == 0) {
                      if ((uVar6 != 0) &&
                         (*(char *)&p_Var14->name = *(char *)psVar1, (bVar2 & 2) != 0)) {
                        *(undefined2 *)((long)p_Var14 + (uVar6 - 2)) =
                             *(undefined2 *)((long)psVar16 + uVar6);
                      }
                    }
                    else {
                      *(undefined4 *)&p_Var14->name = *(undefined4 *)psVar1;
                      *(undefined4 *)((long)p_Var14 + (uVar6 - 4)) =
                           *(undefined4 *)((long)psVar16 + (uVar6 - 2));
                    }
                  }
                  else {
                    puVar12 = (undefined8 *)((ulong)&p_Var14->subset & 0xfffffffffffffff8);
                    p_Var14->name = *(char **)(psVar16 + 1);
                    *(undefined8 *)((long)p_Var14 + (uVar6 - 8)) =
                         *(undefined8 *)((long)psVar16 + (uVar6 - 6));
                    lVar9 = (long)p_Var14 - (long)puVar12;
                    puVar11 = (undefined8 *)((long)psVar1 - lVar9);
                    for (uVar10 = lVar9 + uVar6 >> 3; uVar10 != 0; uVar10 = uVar10 - 1) {
                      *puVar12 = *puVar11;
                      puVar11 = puVar11 + (ulong)bVar17 * -2 + 1;
                      puVar12 = puVar12 + (ulong)bVar17 * -2 + 1;
                    }
                  }
                  *(char *)((long)&p_Var14->name + uVar6) = '\0';
                  p_Var14 = (FSFpeAltPtr)((long)&p_Var14->name + uVar6 + 1);
                  iVar4 = iVar4 + 1;
                  lVar9 = _fs_pad_length((long)((char)bVar2 + 2));
                  psVar16 = (short *)((long)psVar16 + lVar9);
                  p_Var13 = p_Var13 + 1;
                } while (iVar4 < (int)(uint)*(byte *)(psVar3 + 3));
                conn->numAlts = (uint)*(byte *)(psVar3 + 3);
                conn->alts = p_Var8;
              }
            }
          }
          _fs_done_read(conn,(long)iVar15);
          if (*psVar3 == 0) {
            iVar4 = conn->fs_conn_state;
            goto joined_r0x0012940f;
          }
        }
      }
      break;
    case 4:
      iVar4 = _fs_send_init_packets(conn);
      if (conn->has_catalogues == 0) {
LAB_001290fb:
        if (iVar4 != 0) goto LAB_00129103;
        goto LAB_00129350;
      }
      conn->current_seq = conn->current_seq + 1;
      data._0_1_ = 3;
      data._2_2_ = 3;
      data._4_4_ = 0;
      uStack_48 = 0;
      local_46 = 0;
      iVar4 = _fs_write(conn,(char *)&data,0xc);
joined_r0x001293ae:
      if (iVar4 == 1) {
        uVar6 = GetTimeInMillis();
        conn->blockedConnectTime = (int)uVar6 + 30000;
        iVar4 = conn->fs_conn_state;
        goto joined_r0x0012940f;
      }
      break;
    case 5:
      if (conn->has_catalogues != 0) {
        pfVar7 = fs_get_reply(conn,(int *)&data);
        if (pfVar7 == (fsGenericReply *)0x0) {
          iVar4 = CONCAT22(data._2_2_,CONCAT11(data._1_1_,data._0_1_));
          goto LAB_001290fb;
        }
        uVar6 = (ulong)(pfVar7->length * 4);
        if ((pfVar7->type == '\x01') && (*(char *)&pfVar7[1].length == '\x04')) {
          _fs_done_read(conn,uVar6);
          break;
        }
        _fs_done_read(conn,uVar6);
        iVar4 = conn->fs_conn_state;
        goto joined_r0x0012940f;
      }
      goto LAB_001292fb;
    }
    _fs_close_server(conn);
    if (conn->numAlts <= conn->alternate) {
      conn->alternate = 0;
      iVar4 = -1;
      goto LAB_001292c4;
    }
    conn->alternate = conn->alternate + 1;
    iVar4 = conn->fs_conn_state;
LAB_00129275:
  } while (iVar4 != 6);
  generationCount = generationCount + 1;
  conn->generation = generationCount;
  iVar4 = 1;
LAB_001292c4:
  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar4;
}



void _fs_free_conn(FSFpePtr conn)

{
  _fs_close_server(conn);
  _fs_io_fini(conn);
  if (conn->alts != (FSFpeAltPtr)0x0) {
    free(conn->alts);
  }
  free(conn);
  return;
}



void _fs_remove_block_rec(FSFpePtr conn,FSBlockDataPtr blockrec)

{
  int iVar1;
  FSBlockDataPtr p_Var2;
  FSBlockDataPtr p_Var3;
  ulong uVar4;
  FSBlockDataPtr *pp_Var5;
  
  p_Var2 = conn->blockedRequests;
  if (p_Var2 == (FSBlockDataPtr)0x0) {
LAB_00129619:
    iVar1 = blockrec->type;
  }
  else {
    if (blockrec == p_Var2) {
      pp_Var5 = &conn->blockedRequests;
    }
    else {
      do {
        p_Var3 = p_Var2;
        p_Var2 = p_Var3->next;
        if (p_Var2 == (_fs_block_data *)0x0) goto LAB_00129619;
      } while (blockrec != p_Var2);
      pp_Var5 = &p_Var3->next;
    }
    *pp_Var5 = blockrec->next;
    iVar1 = blockrec->type;
  }
  if ((iVar1 == 2) && (*(int *)((long)blockrec->data + 8) != 0)) {
    free(*(void **)((long)blockrec->data + 0x10));
  }
  free(blockrec);
  p_Var2 = conn->blockedRequests;
  while( true ) {
    if (p_Var2 == (FSBlockDataPtr)0x0) {
      _fs_unmark_block(conn,8);
      return;
    }
    if (p_Var2->errcode == 0x51) break;
    p_Var2 = p_Var2->next;
  }
  uVar4 = GetTimeInMillis();
  conn->blockedReplyTime = (int)uVar4 + 30000;
  _fs_mark_block(conn,8);
  return;
}



void fs_abort_blockrec(FSFpePtr conn,FSBlockDataPtr blockrec)

{
  int iVar1;
  undefined8 *puVar2;
  FSBlockedFontPtr bfont;
  int *piVar3;
  byte bVar4;
  long lVar5;
  
  iVar1 = blockrec->type;
  if (iVar1 == 2) {
    puVar2 = (undefined8 *)blockrec->data;
    _fs_clean_aborted_loadglyphs((FontPtr)*puVar2,*(int *)(puVar2 + 1),(fsRange *)puVar2[2]);
    _fs_signal_clients_depending((FSClientsDependingPtr *)(puVar2 + 3));
    _fs_remove_block_rec(conn,blockrec);
    return;
  }
  if (iVar1 != 4) {
    if (iVar1 != 1) {
      _fs_remove_block_rec(conn,blockrec);
      return;
    }
    bfont = (FSBlockedFontPtr)blockrec->data;
    fs_cleanup_bfont(bfont);
    _fs_signal_clients_depending(&bfont->clients_depending);
    _fs_remove_block_rec(conn,blockrec);
    return;
  }
  piVar3 = (int *)blockrec->data;
  if (*piVar3 == 1) {
    lVar5 = __fdelt_chk((long)conn->fs_fd);
    bVar4 = (byte)(conn->fs_fd >> 0x1f);
    _fs_fd_mask.fds_bits[lVar5] =
         _fs_fd_mask.fds_bits[lVar5] |
         1L << (((char)conn->fs_fd + (bVar4 >> 2) & 0x3f) - (bVar4 >> 2) & 0x3f);
  }
  FUN_0010a1b0(piVar3 + 2);
  _fs_remove_block_rec(conn,blockrec);
  return;
}



void fs_client_died(pointer client,FontPathElementPtr fpe)

{
  FSFpePtr conn;
  long lVar1;
  XID XVar2;
  _fs_block_data *p_Var3;
  FSClientPtr __ptr;
  FSBlockDataPtr blockrec;
  FSClientPtr *pp_Var4;
  long in_FS_OFFSET;
  fsFreeACReq freeac;
  
  conn = (FSFpePtr)fpe->private;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  __ptr = conn->clients;
  if (__ptr != (FSClientPtr)0x0) {
    pp_Var4 = &conn->clients;
    do {
      if (__ptr->client == client) {
        XVar2 = __ptr->acid;
        conn->current_seq = conn->current_seq + 1;
        freeac.reqType = '\t';
        freeac.pad = '\0';
        freeac.length = 2;
        freeac.id = (CARD32)XVar2;
        _fs_write(conn,(char *)&freeac,8);
        *pp_Var4 = __ptr->next;
        free(__ptr);
        break;
      }
      pp_Var4 = &__ptr->next;
      __ptr = __ptr->next;
    } while (__ptr != (_fs_client_data *)0x0);
  }
  blockrec = conn->blockedRequests;
  do {
    if (blockrec == (FSBlockDataPtr)0x0) {
LAB_00129870:
      if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
        return;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    if (blockrec->client == client) {
      p_Var3 = blockrec->depending;
      if (p_Var3 != (_fs_block_data *)0x0) {
        blockrec->client = p_Var3->client;
        blockrec->depending = p_Var3->depending;
        blockrec = p_Var3;
      }
      fs_abort_blockrec(conn,blockrec);
      goto LAB_00129870;
    }
    blockrec = blockrec->next;
  } while( true );
}



int fs_next_list_with_info
              (pointer client,FontPathElementPtr fpe,char **namep,int *namelenp,
              FontInfoPtr *pFontInfo,int *numFonts,pointer private)

{
  int iVar1;
  FSFpePtr conn;
  FSBlockDataPtr blockrec;
  int *piVar2;
  byte bVar3;
  Bool BVar4;
  long lVar5;
  ulong uVar6;
  int iVar7;
  
  conn = (FSFpePtr)fpe->private;
  blockrec = conn->blockedRequests;
  while( true ) {
    if (blockrec == (FSBlockDataPtr)0x0) {
      return 0x53;
    }
    if ((blockrec->type == 4) && (blockrec->client == client)) break;
    blockrec = blockrec->next;
  }
  piVar2 = (int *)blockrec->data;
  iVar7 = 0x54;
  if (*piVar2 != 0) {
    *namep = (char *)(piVar2 + 0x18);
    *namelenp = piVar2[1];
    *pFontInfo = (FontInfoPtr)(piVar2 + 2);
    *numFonts = piVar2[0x58];
    lVar5 = __fdelt_chk((long)conn->fs_fd);
    bVar3 = (byte)(conn->fs_fd >> 0x1f);
    _fs_fd_mask.fds_bits[lVar5] =
         _fs_fd_mask.fds_bits[lVar5] |
         1L << (((char)conn->fs_fd + (bVar3 >> 2) & 0x3f) - (bVar3 >> 2) & 0x3f);
    BVar4 = fs_reply_ready(conn);
    if (BVar4 == 0) {
      iVar1 = *piVar2;
      iVar7 = blockrec->errcode;
    }
    else {
      _fs_mark_block(conn,0x20);
      iVar1 = *piVar2;
      iVar7 = blockrec->errcode;
    }
    if (iVar1 == 1) {
      *piVar2 = 0;
      blockrec->errcode = 0x51;
      uVar6 = GetTimeInMillis();
      conn->blockedReplyTime = (int)uVar6 + 30000;
      _fs_mark_block(conn,8);
      return iVar7;
    }
    if (iVar1 == 2) {
      _fs_remove_block_rec(conn,blockrec);
      return iVar7;
    }
  }
  return iVar7;
}



int fs_list_fonts(pointer client,FontPathElementPtr fpe,char *pattern,int patlen,int maxnames,
                 FontNamesPtr newnames)

{
  uint sync;
  FSFpePtr conn;
  long lVar1;
  FSBlockDataPtr p_Var2;
  long in_FS_OFFSET;
  int local_60;
  fsListFontsReq req;
  
  conn = (FSFpePtr)fpe->private;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  p_Var2 = conn->blockedRequests;
  do {
    if (p_Var2 == (FSBlockDataPtr)0x0) {
      local_60 = 0x53;
      if ((*(byte *)&conn->blockState & 0x10) == 0) {
        p_Var2 = fs_new_block_rec((FontPathElementPtr)conn,client,3);
        if (p_Var2 == (FSBlockDataPtr)0x0) {
          local_60 = 0x50;
        }
        else {
          *(FontNamesPtr *)p_Var2->data = newnames;
          sync = conn->blockState;
          if ((sync & 0x44) == 0) {
            _fs_client_access(conn,client,sync);
            _fs_client_resolution(conn);
            conn->current_seq = conn->current_seq + 1;
            req.reqType = '\r';
            req.pad = '\0';
            req.nbytes = (CARD16)patlen;
            req.length = (CARD16)(patlen + 0xf >> 2);
            req.maxNames = maxnames;
            _fs_write(conn,(char *)&req,0xc);
            _fs_write_pad(conn,pattern,(long)patlen);
            p_Var2->sequenceNumber = (CARD16)conn->current_seq;
            _fs_prepare_for_reply(conn);
            local_60 = 0x54;
          }
          else {
            local_60 = 0x54;
            if ((sync & 8) == 0) {
              _fs_pending_reply(conn);
              local_60 = 0x54;
            }
          }
        }
      }
LAB_00129a90:
      if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
        return local_60;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    if ((p_Var2->type == 3) && (p_Var2->client == client)) {
      local_60 = p_Var2->errcode;
      if (local_60 == 0x51) {
        local_60 = 0x54;
      }
      else {
        _fs_remove_block_rec(conn,p_Var2);
      }
      goto LAB_00129a90;
    }
    p_Var2 = p_Var2->next;
  } while( true );
}



void fs_read_reply(FontPathElementPtr fpe,pointer client)

{
  byte bVar1;
  ushort uVar2;
  ushort uVar3;
  ushort uVar4;
  CARD16 CVar5;
  CARD32 CVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  FSFpePtr conn;
  undefined4 *puVar11;
  FSBlockDataPtr blockrec_1;
  FSFpePtr p_Var12;
  FSBlockDataPtr p_Var13;
  long lVar14;
  long lVar15;
  long lVar16;
  long lVar17;
  long lVar18;
  FSFpePtr conn_00;
  bool bVar19;
  undefined8 uVar20;
  short sVar21;
  int iVar23;
  Bool BVar24;
  uint uVar25;
  uint uVar26;
  uint uVar41;
  undefined2 uVar22;
  fsGenericReply *pfVar27;
  fsListFontsWithXInfoReply *fsrep;
  _fs_block_data *p_Var28;
  fsGenericReply *pfVar29;
  xCharInfo *pxVar30;
  long lVar31;
  ulong *puVar32;
  void *pvVar33;
  ulong uVar34;
  FontPtr p_Var35;
  long lVar36;
  short sVar37;
  ulong uVar38;
  short sVar39;
  long *plVar40;
  _fs_block_data *blockrec;
  uint uVar44;
  undefined8 *puVar42;
  FontPropPtr p_Var43;
  undefined8 *puVar45;
  fsPropOffset *po;
  FontInfoPtr pfi;
  pointer pvVar46;
  fsListFontsWithXInfoReply *pi;
  xCharInfo *dst;
  ulong *puVar47;
  ulong *puVar48;
  long in_FS_OFFSET;
  byte bVar49;
  void *local_f0;
  int ret;
  int ret_2;
  fsQueryXBitmaps16Req bitreq;
  int ret_1;
  undefined4 uStack_94;
  CARD32 local_90;
  long local_40;
  
  bVar49 = 0;
  conn = (FSFpePtr)fpe->private;
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  pfVar27 = fs_get_reply(conn,&ret);
  uVar20 = _ret_1;
  if (pfVar27 == (fsGenericReply *)0x0) goto LAB_00129cc5;
  blockrec = conn->blockedRequests;
  if (blockrec != (FSBlockDataPtr)0x0) {
LAB_00129c2d:
    if (blockrec->sequenceNumber != pfVar27->sequenceNumber) goto LAB_00129c20;
    iVar23 = blockrec->type;
    if (iVar23 == 3) {
      p_Var12 = (FSFpePtr)fpe->private;
      puVar42 = (undefined8 *)blockrec->data;
      pfVar27 = fs_get_reply(p_Var12,&ret_1);
      if (pfVar27 == (fsGenericReply *)0x0) {
        if (ret_1 == 0) goto LAB_0012a290;
LAB_0012a26d:
        blockrec->errcode = 0x50;
        iVar23 = 0x50;
      }
      else {
        if (pfVar27->type != '\x01') {
          pfVar29 = pfVar27 + 2;
          if (pfVar27[1].length == 0) goto LAB_0012a2f4;
          uVar26 = 0;
          goto LAB_0012a19a;
        }
        if (ret_1 == 0) goto LAB_0012a290;
        iVar23 = 0x50;
        _fs_done_read(p_Var12,(ulong)(pfVar27->length << 2));
        blockrec->errcode = 0x50;
      }
      goto LAB_00129c80;
    }
    if (3 < iVar23) {
      if (iVar23 != 4) goto LAB_0012a108;
      puVar11 = (undefined4 *)blockrec->data;
      p_Var12 = (FSFpePtr)fpe->private;
      FUN_0010a1b0((FontInfoPtr)(puVar11 + 2));
      fsrep = (fsListFontsWithXInfoReply *)fs_get_reply(p_Var12,&ret_1);
      if ((fsrep == (fsListFontsWithXInfoReply *)0x0) || (fsrep->type == '\x01')) {
        if (ret_1 != 0) {
          *puVar11 = 2;
          _fs_done_read(p_Var12,(ulong)(fsrep->length << 2));
          goto LAB_0012a26d;
        }
        goto LAB_0012a290;
      }
      bVar1 = fsrep->nameLength;
      uVar34 = (ulong)bVar1;
      if (bVar1 == 0) {
        *puVar11 = 2;
        iVar23 = 0x53;
        _fs_done_read(p_Var12,(ulong)(fsrep->length << 2));
        blockrec->errcode = 0x53;
        goto LAB_00129c80;
      }
      pi = fsrep + 1;
      if (1 < p_Var12->fsMajorVersion) {
        po = (fsPropOffset *)&fsrep[1].nReplies;
        pvVar46 = (pointer)((long)po + (ulong)(uint)(*(int *)(fsrep + 1) * 0x14));
        puVar42 = (undefined8 *)((long)pvVar46 + (ulong)fsrep[1].length);
        goto LAB_00129d7f;
      }
      uVar26 = (uint)bVar1;
      uVar38 = (ulong)uVar26;
      if (uVar26 < 8) {
        if ((bVar1 & 4) == 0) {
          if ((uVar26 != 0) && (*(BYTE *)(puVar11 + 0x18) = pi->type, (bVar1 & 2) != 0)) {
            *(undefined2 *)((long)puVar11 + uVar38 + 0x5e) =
                 *(undefined2 *)((long)&fsrep->font_header_font_descent + uVar38);
          }
        }
        else {
          puVar11[0x18] = *(int *)pi;
          *(undefined4 *)((long)puVar11 + uVar38 + 0x5c) =
               *(undefined4 *)((long)&fsrep->font_header_font_ascent + uVar38);
        }
      }
      else {
        *(undefined8 *)(puVar11 + 0x18) = *(undefined8 *)(fsrep + 1);
        *(undefined8 *)((long)puVar11 + uVar34 + 0x58) =
             *(undefined8 *)((long)&fsrep->font_header_max_bounds_descent + uVar34);
        lVar31 = (long)puVar11 + (0x60 - (long)((ulong)(puVar11 + 0x1a) & 0xfffffffffffffff8));
        puVar42 = (undefined8 *)((long)pi - lVar31);
        puVar45 = (undefined8 *)((ulong)(puVar11 + 0x1a) & 0xfffffffffffffff8);
        for (uVar34 = (ulong)((int)lVar31 + uVar26 >> 3); uVar34 != 0; uVar34 = uVar34 - 1) {
          *puVar45 = *puVar42;
          puVar42 = puVar42 + (ulong)bVar49 * -2 + 1;
          puVar45 = puVar45 + (ulong)bVar49 * -2 + 1;
        }
      }
      lVar31 = _fs_pad_length((ulong)fsrep->nameLength);
      pi = (fsListFontsWithXInfoReply *)(&pi->type + lVar31);
      po = (fsPropOffset *)&pi->nReplies;
      pvVar46 = (pointer)((long)po + (ulong)(uint)(*(int *)pi * 0x14));
      if (1 < p_Var12->fsMajorVersion) {
        uVar34 = (ulong)fsrep->nameLength;
        puVar42 = (undefined8 *)((long)pvVar46 + (ulong)pi->length);
LAB_00129d7f:
        uVar26 = (uint)uVar34;
        if (uVar26 < 8) {
          if ((uVar34 & 4) == 0) {
            if ((uVar26 != 0) &&
               (*(undefined *)(puVar11 + 0x18) = *(undefined *)puVar42, (uVar34 & 2) != 0)) {
              *(undefined2 *)((long)puVar11 + uVar34 + 0x5e) =
                   *(undefined2 *)((long)puVar42 + (uVar34 - 2));
            }
          }
          else {
            puVar11[0x18] = *(undefined4 *)puVar42;
            *(undefined4 *)((long)puVar11 + uVar34 + 0x5c) =
                 *(undefined4 *)((long)puVar42 + (uVar34 - 4));
          }
        }
        else {
          *(undefined8 *)(puVar11 + 0x18) = *puVar42;
          *(undefined8 *)((long)puVar11 + uVar34 + 0x58) =
               *(undefined8 *)((long)puVar42 + (uVar34 - 8));
          lVar31 = (long)puVar11 + (0x60 - (long)((ulong)(puVar11 + 0x1a) & 0xfffffffffffffff8));
          puVar42 = (undefined8 *)((long)puVar42 - lVar31);
          puVar45 = (undefined8 *)((ulong)(puVar11 + 0x1a) & 0xfffffffffffffff8);
          for (uVar34 = (ulong)(uVar26 + (int)lVar31 >> 3); uVar34 != 0; uVar34 = uVar34 - 1) {
            *puVar45 = *puVar42;
            puVar42 = puVar42 + (ulong)bVar49 * -2 + 1;
            puVar45 = puVar45 + (ulong)bVar49 * -2 + 1;
          }
        }
        _fs_pad_length((ulong)fsrep->nameLength);
      }
      iVar23 = _fs_convert_lfwi_reply
                         (p_Var12,(FontInfoPtr)(puVar11 + 2),fsrep,(fsPropInfo *)pi,po,pvVar46);
      if (iVar23 != 0x55) {
        *puVar11 = 2;
        _fs_done_read(p_Var12,(ulong)(fsrep->length << 2));
        blockrec->errcode = iVar23;
        goto joined_r0x0012a110;
      }
      puVar11[1] = (uint)fsrep->nameLength;
      CVar6 = fsrep->nReplies;
      *puVar11 = 1;
      puVar11[0x58] = CVar6;
      _fs_unmark_block(p_Var12,0x20);
      lVar31 = __fdelt_chk((long)p_Var12->fs_fd);
      bVar49 = (byte)(p_Var12->fs_fd >> 0x1f);
      bVar49 = ((char)p_Var12->fs_fd + (bVar49 >> 2) & 0x3f) - (bVar49 >> 2) & 0x3f;
      _fs_fd_mask.fds_bits[lVar31] =
           _fs_fd_mask.fds_bits[lVar31] & (-2L << bVar49 | 0xfffffffffffffffeU >> 0x40 - bVar49);
      _fs_done_read(p_Var12,(ulong)(fsrep->length << 2));
      blockrec->errcode = 0x55;
      goto LAB_00129c80;
    }
    if (iVar23 != 1) {
      if (iVar23 == 2) {
        iVar23 = fs_read_glyphs((FontPathElementPtr)fpe->private,blockrec,
                                (FSBlockDataPtr)blockrec->data);
        blockrec->errcode = iVar23;
      }
      else {
LAB_0012a108:
        iVar23 = blockrec->errcode;
      }
      goto joined_r0x0012a110;
    }
    blockrec_1 = (FSBlockDataPtr)blockrec->data;
    iVar23 = *(int *)&blockrec_1->sequenceNumber;
    if (iVar23 == 2) {
      lVar31 = *(long *)blockrec_1;
      p_Var12 = (FSFpePtr)fpe->private;
      lVar36 = *(long *)(lVar31 + 0xa0);
      plVar40 = *(long **)(lVar31 + 0x98);
      pfVar27 = fs_get_reply(p_Var12,(int *)&bitreq);
      if (pfVar27 == (fsGenericReply *)0x0) {
        if (bitreq._0_4_ != 0) goto LAB_0012a2ce;
      }
      else {
        if (pfVar27->type != '\x01') {
          iVar23 = *(int *)(pfVar27 + 1);
          if (((*(byte *)(*(long *)blockrec_1 + 0x12) & 2) == 0) || (p_Var12->fsMajorVersion < 2)) {
            pvVar33 = malloc((long)iVar23 * 0x18);
            if (pvVar33 == (void *)0x0) goto LAB_0012acb7;
            bVar19 = false;
            plVar40[1] = (long)pvVar33;
            local_f0 = pvVar33;
          }
          else {
            local_f0 = malloc((long)(iVar23 * 2) * 0x18);
            if (local_f0 == (void *)0x0) {
LAB_0012acb7:
              _fs_done_read(p_Var12,(ulong)(pfVar27->length << 2));
              goto LAB_0012accc;
            }
            plVar40[1] = (long)local_f0;
            pvVar33 = (void *)((long)local_f0 + (long)iVar23 * 0x18);
            bVar19 = true;
          }
          plVar40[2] = (long)pvVar33;
          *(undefined8 *)(lVar36 + 0x10) = 0;
          dst = (xCharInfo *)plVar40[2];
          if (iVar23 < 1) {
            _fs_done_read(p_Var12,(ulong)(pfVar27->length << 2));
          }
          else {
            puVar42 = (undefined8 *)((long)local_f0 + 0x10);
            pxVar30 = dst + (ulong)(iVar23 - 1) * 2 + 2;
            pfVar29 = pfVar27;
            do {
              _ret_1 = *(undefined8 *)&pfVar29[1].length;
              local_90 = pfVar29[2].length;
              _fs_convert_char_info((fsXCharInfo *)&ret_1,dst);
              if (*(short *)(lVar31 + 0x1e) < dst->ascent) {
                ErrorF("fserve: warning: %s %s ascent (%d) > maxascent (%d)\n",fpe->name,
                       *(undefined8 *)(lVar36 + 0x20));
                dst->ascent = *(INT16 *)(lVar31 + 0x1e);
              }
              if (*(short *)(lVar31 + 0x20) < dst->descent) {
                ErrorF("fserve: warning: %s %s descent (%d) > maxdescent (%d)\n",fpe->name,
                       *(undefined8 *)(lVar36 + 0x20));
                dst->descent = *(INT16 *)(lVar31 + 0x20);
              }
              uVar34._0_2_ = dst->leftSideBearing;
              uVar34._2_2_ = dst->rightSideBearing;
              uVar34._4_2_ = dst->characterWidth;
              uVar34._6_2_ = dst->ascent;
              if ((((uVar34 & 0xffff0000ffffffff) == 0) && (dst->descent == 0)) &&
                 (dst->characterWidth == 0)) {
                *puVar42 = 0;
              }
              else if ((bVar19) ||
                      ((dst->leftSideBearing != dst->rightSideBearing &&
                       ((int)dst->ascent + (int)dst->descent != 0)))) {
                *puVar42 = &_fs_glyph_undefined;
                *(long *)(lVar36 + 0x10) = *(long *)(lVar36 + 0x10) + 1;
              }
              else {
                *puVar42 = &_fs_glyph_zero_length;
              }
              dst = dst + 2;
              puVar42 = puVar42 + 3;
              pfVar29 = (fsGenericReply *)&pfVar29[1].length;
            } while (dst != pxVar30);
            _fs_done_read(p_Var12,(ulong)(pfVar27->length << 2));
            if (bVar19) {
              puVar47 = (ulong *)plVar40[1];
              puVar48 = (ulong *)plVar40[2];
              puVar32 = puVar48 + (ulong)(iVar23 - 1) * 3 + 3;
              do {
                if ((((*puVar48 & 0xffff0000ffffffff) == 0) && (*(short *)(puVar48 + 1) == 0)) &&
                   (*(short *)((long)puVar48 + 4) == 0)) {
                  *puVar47 = *puVar48;
                  *(undefined4 *)(puVar47 + 1) = *(undefined4 *)(puVar48 + 1);
                  sVar21 = *(short *)((long)puVar47 + 6);
                }
                else {
                  uVar22 = 0;
                  if (*(short *)(lVar31 + 0x3c) < 1) {
                    uVar22 = *(undefined2 *)(lVar31 + 0x3c);
                  }
                  *(undefined2 *)puVar47 = uVar22;
                  sVar21 = *(short *)(lVar31 + 0x32);
                  if (*(short *)(lVar31 + 0x32) <= *(short *)(lVar31 + 0x34)) {
                    sVar21 = *(short *)(lVar31 + 0x34);
                  }
                  *(short *)((long)puVar47 + 2) = sVar21;
                  sVar21 = *(short *)(lVar31 + 0x48);
                  if (*(short *)(lVar31 + 0x48) <= *(short *)(lVar31 + 0x36)) {
                    sVar21 = *(short *)(lVar31 + 0x36);
                  }
                  *(short *)((long)puVar47 + 6) = sVar21;
                  sVar39 = *(short *)(lVar31 + 0x4a);
                  if (*(short *)(lVar31 + 0x4a) <= *(short *)(lVar31 + 0x38)) {
                    sVar39 = *(short *)(lVar31 + 0x38);
                  }
                  *(short *)(puVar47 + 1) = sVar39;
                  sVar39 = *(short *)(lVar31 + 0x32);
                  if (*(short *)(lVar31 + 0x32) <= *(short *)(lVar31 + 0x34)) {
                    sVar39 = *(short *)(lVar31 + 0x34);
                  }
                  sVar37 = 0;
                  if (*(short *)(lVar31 + 0x3c) < 1) {
                    sVar37 = *(short *)(lVar31 + 0x3c);
                  }
                  *(short *)((long)puVar47 + 4) = sVar39 - sVar37;
                  *(undefined2 *)((long)puVar47 + 10) = *(undefined2 *)((long)puVar48 + 10);
                }
                if (*(short *)(lVar31 + 0x1e) < sVar21) {
                  ErrorF("fserve: warning: %s %s ascent (%d) > maxascent (%d)\n",fpe->name,
                         *(undefined8 *)(lVar36 + 0x20));
                  *(undefined2 *)((long)puVar47 + 6) = *(undefined2 *)(lVar31 + 0x1e);
                }
                if (*(short *)(lVar31 + 0x20) < *(short *)(puVar47 + 1)) {
                  ErrorF("fserve: warning: %s %s descent (%d) > maxdescent (%d)\n",fpe->name,
                         *(undefined8 *)(lVar36 + 0x20));
                  *(undefined2 *)(puVar47 + 1) = *(undefined2 *)(lVar31 + 0x20);
                }
                puVar48 = puVar48 + 3;
                puVar47 = puVar47 + 3;
              } while (puVar48 != puVar32);
            }
          }
          lVar31 = *(long *)blockrec_1;
          uVar2 = *(ushort *)(lVar31 + 8);
          uVar3 = *(ushort *)(lVar31 + 10);
          uVar4 = *(ushort *)(lVar31 + 0x10);
          *plVar40 = 0;
          uVar26 = (uVar3 + 1) - (uint)uVar2;
          uVar3 = *(ushort *)(*(long *)blockrec_1 + 0xe);
          if (uVar3 == 0) {
            uVar25 = (uint)uVar4 - (uint)uVar2;
            if (uVar25 < uVar26) {
              *plVar40 = (long)((long)local_f0 + (ulong)uVar25 * 0x18);
            }
          }
          else {
            uVar41 = (uVar4 & 0xff) - (uint)uVar2;
            uVar44 = (uint)*(ushort *)(*(long *)blockrec_1 + 0xc);
            uVar25 = (uVar4 >> 8) - uVar44;
            if ((uVar25 < (uVar3 - uVar44) + 1) && (uVar41 < uVar26)) {
              *plVar40 = (long)((long)local_f0 + (ulong)(uVar25 * uVar26 + uVar41) * 0x18);
            }
          }
          *(undefined4 *)&blockrec_1->sequenceNumber = 3;
          if ((blockrec_1->field_0x14 & 8) == 0) goto LAB_0012a7dd;
          blockrec->sequenceNumber = *(CARD16 *)&blockrec_1->errcode;
          uVar34 = GetTimeInMillis();
          p_Var12->blockedReplyTime = (int)uVar34 + 30000;
          blockrec->errcode = 0x51;
          goto LAB_00129ca8;
        }
        if (bitreq._0_4_ != 0) {
          _fs_done_read(p_Var12,(ulong)(pfVar27->length << 2));
          goto LAB_0012a2ce;
        }
      }
      goto LAB_0012a290;
    }
    if (2 < iVar23) {
      if ((iVar23 != 3) || ((blockrec_1->field_0x14 & 8) == 0)) goto LAB_0012a0c8;
      iVar23 = fs_read_glyphs((FontPathElementPtr)fpe->private,blockrec,blockrec_1);
      if (iVar23 != 0x51) goto LAB_0012a22a;
      goto LAB_0012a290;
    }
    if (iVar23 == 0) {
      p_Var12 = (FSFpePtr)fpe->private;
      pfVar27 = fs_get_reply(p_Var12,&ret_1);
      if (pfVar27 == (fsGenericReply *)0x0) {
        if (ret_1 == 0) goto LAB_0012a290;
      }
      else {
        if (pfVar27->type != '\x01') {
          iVar23._0_1_ = pfVar27[1].type;
          iVar23._1_1_ = pfVar27[1].data1;
          iVar23._2_2_ = pfVar27[1].sequenceNumber;
          if ((iVar23 == 0) || ((blockrec_1->field_0x14 & 0x20) != 0)) {
            *(byte *)(*(long *)blockrec_1 + 0x13) =
                 *(byte *)(*(long *)blockrec_1 + 0x13) & 0xfd |
                 (*(char *)&pfVar27[1].length != '\0') * '\x02';
            CVar5 = *(CARD16 *)((long)&blockrec_1->data + 4);
            *(undefined4 *)&blockrec_1->sequenceNumber = 1;
            blockrec->sequenceNumber = CVar5;
            uVar34 = GetTimeInMillis();
            p_Var12->blockedReplyTime = (int)uVar34 + 30000;
            ret_1 = 0x51;
            goto LAB_0012a408;
          }
          fs_cleanup_bfont((FSBlockedFontPtr)blockrec_1);
          uVar26._0_1_ = pfVar27[1].type;
          uVar26._1_1_ = pfVar27[1].data1;
          uVar26._2_2_ = pfVar27[1].sequenceNumber;
          p_Var35 = find_old_font((ulong)uVar26);
          *(undefined4 *)&blockrec_1->data = 0;
          *(FontPtr *)blockrec_1 = p_Var35;
          uVar25._0_1_ = pfVar27[1].type;
          uVar25._1_1_ = pfVar27[1].data1;
          uVar25._2_2_ = pfVar27[1].sequenceNumber;
          *(undefined4 *)&blockrec_1->sequenceNumber = 4;
          blockrec_1->client = (pointer)(ulong)uVar25;
          p_Var13 = p_Var12->blockedRequests;
          goto joined_r0x0012ac55;
        }
        if (ret_1 == 0) goto LAB_0012a290;
        _fs_done_read(p_Var12,(ulong)(pfVar27->length << 2));
      }
      iVar23 = 0x53;
      fs_cleanup_bfont((FSBlockedFontPtr)blockrec_1);
      goto LAB_0012a429;
    }
    if (iVar23 != 1) goto LAB_0012a0c8;
    p_Var12 = (FSFpePtr)fpe->private;
    pfVar27 = fs_get_reply(p_Var12,&ret_2);
    if (pfVar27 == (fsGenericReply *)0x0) {
      if (ret_2 == 0) goto LAB_0012a290;
    }
    else {
      if (pfVar27->type != '\x01') {
        pfi = (FontInfoPtr)&ret_1;
        if ((blockrec_1->field_0x14 & 0x20) == 0) {
          pfi = (FontInfoPtr)(*(long *)blockrec_1 + 8);
        }
        pfi->field_0xa = pfi->field_0xa & 0xbf | (byte)((pfVar27[1].type & 1) << 6);
        *(ushort *)&pfi->field_0xa =
             *(ushort *)&pfi->field_0xa & 0xfe7f | (ushort)(pfVar27[2].type != '\0') << 7;
        uVar44._0_1_ = pfVar27[1].type;
        uVar44._1_1_ = pfVar27[1].data1;
        uVar44._2_2_ = pfVar27[1].sequenceNumber;
        pfi->field_0xa = (byte)((uVar44 >> 1 & 1) << 4) | pfi->field_0xa & 0xef;
        pfi->firstRow = (ushort)*(byte *)&pfVar27[1].length;
        pfi->firstCol = (ushort)*(byte *)((long)&pfVar27[1].length + 1);
        pfi->lastRow = (ushort)*(byte *)((long)&pfVar27[1].length + 2);
        pfi->lastCol = (ushort)*(byte *)((long)&pfVar27[1].length + 3);
        pfi->defaultCh =
             (ushort)*(byte *)&pfVar27[2].sequenceNumber * 0x100 +
             (ushort)*(byte *)((long)&pfVar27[2].sequenceNumber + 1);
        pfi->fontDescent = *(short *)((long)&pfVar27[5].length + 2);
        pfi->fontAscent = *(short *)&pfVar27[5].length;
        (pfi->minbounds).leftSideBearing = *(INT16 *)&pfVar27[2].length;
        (pfi->minbounds).rightSideBearing = *(INT16 *)((long)&pfVar27[2].length + 2);
        (pfi->minbounds).characterWidth = *(INT16 *)(pfVar27 + 3);
        (pfi->minbounds).ascent = pfVar27[3].sequenceNumber;
        (pfi->minbounds).descent = *(INT16 *)&pfVar27[3].length;
        (pfi->minbounds).attributes = *(CARD16 *)((long)&pfVar27[3].length + 2);
        (pfi->ink_minbounds).leftSideBearing = *(INT16 *)&pfVar27[2].length;
        (pfi->ink_minbounds).rightSideBearing = *(INT16 *)((long)&pfVar27[2].length + 2);
        (pfi->ink_minbounds).characterWidth = *(INT16 *)(pfVar27 + 3);
        (pfi->ink_minbounds).ascent = pfVar27[3].sequenceNumber;
        (pfi->ink_minbounds).descent = *(INT16 *)&pfVar27[3].length;
        (pfi->ink_minbounds).attributes = *(CARD16 *)((long)&pfVar27[3].length + 2);
        (pfi->maxbounds).leftSideBearing = *(INT16 *)(pfVar27 + 4);
        (pfi->maxbounds).rightSideBearing = pfVar27[4].sequenceNumber;
        (pfi->maxbounds).characterWidth = *(INT16 *)&pfVar27[4].length;
        (pfi->maxbounds).ascent = *(INT16 *)((long)&pfVar27[4].length + 2);
        (pfi->maxbounds).descent = *(INT16 *)(pfVar27 + 5);
        (pfi->maxbounds).attributes = pfVar27[5].sequenceNumber;
        (pfi->ink_maxbounds).leftSideBearing = *(INT16 *)(pfVar27 + 4);
        (pfi->ink_maxbounds).rightSideBearing = pfVar27[4].sequenceNumber;
        (pfi->ink_maxbounds).characterWidth = *(INT16 *)&pfVar27[4].length;
        (pfi->ink_maxbounds).ascent = *(INT16 *)((long)&pfVar27[4].length + 2);
        (pfi->ink_maxbounds).descent = *(INT16 *)(pfVar27 + 5);
        (pfi->ink_maxbounds).attributes = pfVar27[5].sequenceNumber;
        _fs_init_fontinfo(p_Var12,pfi);
        ret_2 = _fs_convert_props((fsPropInfo *)(pfVar27 + 6),(fsPropOffset *)(pfVar27 + 7),
                                  (pointer)((long)&(((fsPropOffset *)(pfVar27 + 7))->name).position
                                           + (ulong)(uint)(*(int *)(pfVar27 + 6) * 0x14)),pfi);
        _fs_done_read(p_Var12,(ulong)(pfVar27->length << 2));
        if (ret_2 == -1) {
LAB_0012accc:
          iVar23 = 0x50;
          fs_cleanup_bfont((FSBlockedFontPtr)blockrec_1);
          *(undefined4 *)&blockrec_1->sequenceNumber = 4;
          p_Var28 = blockrec->depending;
          if (p_Var28 != (_fs_block_data *)0x0) goto LAB_0012a0e8;
          blockrec->errcode = 0x50;
          goto LAB_00129c80;
        }
        uVar26 = *(uint *)&blockrec_1->field_0x14;
        lVar31 = *(long *)blockrec_1;
        if ((uVar26 & 0x20) == 0) {
          if ((*(byte *)(lVar31 + 0x12) & 2) != 0) {
            *(uint *)&blockrec_1->field_0x24 = *(uint *)&blockrec_1->field_0x24 & 0xfffffff3 | 8;
          }
          if ((glyphCachingMode == 0) ||
             ((glyphCachingMode == 1 && (*(short *)(lVar31 + 0xe) == 0)))) {
            uVar26 = uVar26 | 0xf;
            *(uint *)&blockrec_1->field_0x14 = uVar26;
          }
          if ((uVar26 & 8) != 0) {
            pvVar46 = blockrec->data;
            conn_00 = (FSFpePtr)fpe->private;
            bitreq.fid = (CARD32)*(undefined8 *)((long)pvVar46 + 8);
            bitreq.format = *(fsBitmapFormat *)((long)pvVar46 + 0x24);
            bitreq.reqType = '\x14';
            bitreq.range = '\x01';
            bitreq.length = 4;
            bitreq.num_ranges = 0;
            *(short *)((long)pvVar46 + 0x20) = *(short *)&conn_00->current_seq + 1;
            conn_00->current_seq = conn_00->current_seq + 1;
            _fs_write(conn_00,(char *)&bitreq,0x10);
            _fs_flush(p_Var12);
          }
          CVar5 = *(CARD16 *)((long)&blockrec_1->data + 6);
          *(undefined4 *)&blockrec_1->sequenceNumber = 2;
          blockrec->sequenceNumber = CVar5;
          uVar34 = GetTimeInMillis();
          p_Var12->blockedReplyTime = (int)uVar34 + 30000;
          blockrec->errcode = 0x51;
          goto LAB_00129ca8;
        }
        lVar36._0_2_ = pfi->firstCol;
        lVar36._2_2_ = pfi->lastCol;
        lVar36._4_2_ = pfi->firstRow;
        lVar36._6_2_ = pfi->lastRow;
        if (((((lVar36 != *(long *)(lVar31 + 8)) || (pfi->defaultCh != *(ushort *)(lVar31 + 0x10)))
             || ((((pfi->field_0xa ^ *(byte *)(lVar31 + 0x12)) & 0x7f) != 0 ||
                 ((((((*(ushort *)&pfi->field_0xa ^ *(ushort *)(lVar31 + 0x12)) & 0x180) != 0 ||
                    (((pfi->field_0xb ^ *(byte *)(lVar31 + 0x13)) & 6) != 0)) ||
                   (pfi->maxOverlap != *(short *)(lVar31 + 0x14))) ||
                  ((lVar14._0_2_ = pfi->fontAscent, lVar14._2_2_ = pfi->fontDescent,
                   lVar14._4_4_ = pfi->nprops, lVar14 != *(long *)(lVar31 + 0x48) ||
                   (lVar15._0_2_ = (pfi->maxbounds).leftSideBearing,
                   lVar15._2_2_ = (pfi->maxbounds).rightSideBearing,
                   lVar15._4_2_ = (pfi->maxbounds).characterWidth,
                   lVar15._6_2_ = (pfi->maxbounds).ascent, lVar15 != *(long *)(lVar31 + 0x18))))))))
             ) || (iVar7._0_2_ = (pfi->maxbounds).descent, iVar7._2_2_ = (pfi->maxbounds).attributes
                  , iVar7 != *(int *)(lVar31 + 0x20))) ||
           (((iVar8._0_2_ = (pfi->minbounds).leftSideBearing,
             iVar8._2_2_ = (pfi->minbounds).rightSideBearing, iVar8 != *(int *)(lVar31 + 0x24) ||
             (lVar16._0_2_ = (pfi->minbounds).characterWidth, lVar16._2_2_ = (pfi->minbounds).ascent
             , lVar16._4_2_ = (pfi->minbounds).descent, lVar16._6_2_ = (pfi->minbounds).attributes,
             lVar16 != *(long *)(lVar31 + 0x28))) ||
            ((lVar17._0_2_ = (pfi->ink_maxbounds).leftSideBearing,
             lVar17._2_2_ = (pfi->ink_maxbounds).rightSideBearing,
             lVar17._4_2_ = (pfi->ink_maxbounds).characterWidth,
             lVar17._6_2_ = (pfi->ink_maxbounds).ascent, lVar17 != *(long *)(lVar31 + 0x30) ||
             (((iVar9._0_2_ = (pfi->ink_maxbounds).descent,
               iVar9._2_2_ = (pfi->ink_maxbounds).attributes, iVar9 != *(int *)(lVar31 + 0x38) ||
               (iVar10._0_2_ = (pfi->ink_minbounds).leftSideBearing,
               iVar10._2_2_ = (pfi->ink_minbounds).rightSideBearing,
               iVar10 != *(int *)(lVar31 + 0x3c))) ||
              (lVar18._0_2_ = (pfi->ink_minbounds).characterWidth,
              lVar18._2_2_ = (pfi->ink_minbounds).ascent,
              lVar18._4_2_ = (pfi->ink_minbounds).descent,
              lVar18._6_2_ = (pfi->ink_minbounds).attributes, lVar18 != *(long *)(lVar31 + 0x40)))))
            )))) goto LAB_0012a0a8;
        lVar36 = 0;
        goto LAB_0012ae13;
      }
      if (ret_2 == 0) goto LAB_0012a290;
      _fs_done_read(p_Var12,(ulong)(pfVar27->length << 2));
    }
LAB_0012a2ce:
    fs_cleanup_bfont((FSBlockedFontPtr)blockrec_1);
    goto LAB_0012a0c8;
  }
LAB_0012a1e0:
  sVar21._0_1_ = pfVar27->type;
  sVar21._1_1_ = pfVar27->data1;
  if (sVar21 == 2) {
    uVar2 = (ushort)_ret_1;
    uStack_94 = SUB84(uVar20,4);
    ret_1 = CONCAT22(1,uVar2 & 0xff00);
    conn->current_seq = conn->current_seq + 1;
    _fs_write(conn,(char *)&ret_1,4);
  }
  _fs_done_read(conn,(ulong)(pfVar27->length << 2));
  goto LAB_00129ca8;
LAB_00129c20:
  blockrec = blockrec->next;
  if (blockrec == (_fs_block_data *)0x0) goto LAB_0012a1e0;
  goto LAB_00129c2d;
LAB_0012a19a:
  bVar49 = pfVar29->type;
  iVar23 = AddFontNamesName((FontNamesPtr)*puVar42,(char *)&pfVar29->data1,(uint)bVar49);
  if (iVar23 == 0x55) goto LAB_0012a188;
  _fs_done_read(p_Var12,(ulong)(pfVar27->length << 2));
  blockrec->errcode = iVar23;
joined_r0x0012a110:
  if (iVar23 != 0x51) goto LAB_00129c80;
  goto LAB_00129ca8;
LAB_0012a188:
  pfVar29 = (fsGenericReply *)(&pfVar29->data1 + bVar49);
  uVar26 = uVar26 + 1;
  if (pfVar27[1].length <= uVar26) goto LAB_0012a2f4;
  goto LAB_0012a19a;
LAB_0012a2f4:
  iVar23 = 0x55;
  _fs_done_read(p_Var12,(ulong)(pfVar27->length << 2));
  blockrec->errcode = 0x55;
  goto LAB_00129c80;
joined_r0x0012ac55:
  if (p_Var13 == (FSBlockDataPtr)0x0) goto LAB_0012ac9b;
  if (((p_Var13 != blockrec) && (p_Var13->type == 1)) &&
     (puVar42 = (undefined8 *)p_Var13->data, uVar41._0_1_ = pfVar27[1].type,
     uVar41._1_1_ = pfVar27[1].data1, uVar41._2_2_ = pfVar27[1].sequenceNumber,
     puVar42[1] == (ulong)uVar41)) {
    blockrec->depending = p_Var13->depending;
    p_Var13->depending = blockrec;
    *(undefined4 *)&blockrec_1->sequenceNumber = 5;
    *(undefined8 *)blockrec_1 = *puVar42;
    goto LAB_0012ac9b;
  }
  p_Var13 = p_Var13->next;
  goto joined_r0x0012ac55;
LAB_0012ac9b:
  ret_1 = (-(uint)(*(long *)blockrec_1 == 0) & 0xfffffc53) + 0x400;
LAB_0012a408:
  _fs_done_read(p_Var12,(ulong)(pfVar27->length << 2));
  iVar23 = ret_1;
  if (ret_1 != 0x51) {
LAB_0012a429:
    if (*(int *)&blockrec_1->sequenceNumber == 4) {
LAB_0012a7e5:
      p_Var28 = blockrec->depending;
      iVar23 = 0x55;
      if (p_Var28 != (_fs_block_data *)0x0) goto LAB_0012a0e8;
      blockrec->errcode = 0x55;
      goto LAB_00129c80;
    }
    if (*(int *)&blockrec_1->sequenceNumber != 5) {
LAB_0012a22a:
      *(undefined4 *)&blockrec_1->sequenceNumber = 4;
      p_Var28 = blockrec->depending;
      goto joined_r0x0012a239;
    }
  }
LAB_0012a290:
  blockrec->errcode = 0x51;
  goto LAB_00129ca8;
LAB_0012ae13:
  if (pfi->nprops <= (int)lVar36) {
    *(undefined4 *)&blockrec_1->sequenceNumber = 4;
    FUN_0010a1b0(pfi);
LAB_0012a7dd:
    *(undefined4 *)&blockrec_1->sequenceNumber = 4;
    goto LAB_0012a7e5;
  }
  if (pfi->isStringProp[lVar36] != *(char *)(*(long *)(lVar31 + 0x58) + lVar36)) goto LAB_0012a0a8;
  p_Var43 = pfi->props + lVar36;
  plVar40 = (long *)(lVar36 * 0x10 + *(long *)(lVar31 + 0x50));
  if ((p_Var43->name != *plVar40) || (lVar36 = lVar36 + 1, p_Var43->value != plVar40[1]))
  goto LAB_0012a0a8;
  goto LAB_0012ae13;
LAB_0012a0a8:
  fs_cleanup_bfont((FSBlockedFontPtr)blockrec_1);
  FUN_0010a1b0(pfi);
LAB_0012a0c8:
  *(undefined4 *)&blockrec_1->sequenceNumber = 4;
  p_Var28 = blockrec->depending;
  iVar23 = 0x53;
  if (p_Var28 == (_fs_block_data *)0x0) {
    blockrec->errcode = 0x53;
  }
  else {
LAB_0012a0e8:
    do {
      *(undefined4 *)((long)p_Var28->data + 0x10) = 4;
      p_Var28 = p_Var28->depending;
joined_r0x0012a239:
    } while (p_Var28 != (_fs_block_data *)0x0);
    blockrec->errcode = iVar23;
  }
LAB_00129c80:
  do {
    blockrec->errcode = iVar23;
    if ((ClientPtr)blockrec->client != (ClientPtr)client) {
      ClientSignal((ClientPtr)blockrec->client);
    }
    blockrec = blockrec->depending;
  } while (blockrec != (_fs_block_data *)0x0);
  _fs_unmark_block(conn,8);
LAB_00129ca8:
  BVar24 = fs_reply_ready(conn);
  if (BVar24 == 0) {
    _fs_unmark_block(conn,0x20);
  }
  else {
    _fs_mark_block(conn,0x20);
  }
LAB_00129cc5:
  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void _fs_check_reconnect(FSFpePtr conn)

{
  FSBlockDataPtr blockrec;
  int iVar1;
  ulong uVar2;
  
  iVar1 = _fs_do_setup_connection(conn);
  if (iVar1 == -1) {
    uVar2 = GetTimeInMillis();
    conn->brokenConnectionTime = (int)uVar2 + 1000;
    return;
  }
  if (iVar1 != 1) {
    return;
  }
  _fs_unmark_block(conn,0x50);
  _fs_unmark_block(conn,0x10);
  do {
    blockrec = conn->blockedRequests;
    do {
      if (blockrec == (FSBlockDataPtr)0x0) {
        return;
      }
    } while (blockrec->errcode != 0x51);
    ClientSignal((ClientPtr)blockrec->client);
    fs_abort_blockrec(conn,blockrec);
  } while( true );
}



int fs_free_fpe(FontPathElementPtr fpe)

{
  FSFpePtr conn;
  FSFpePtr p_Var1;
  _fs_client_data *p_Var2;
  FSClientPtr __ptr;
  FSFpePtr *pp_Var3;
  
  conn = (FSFpePtr)fpe->private;
  if (fs_fpes != (FSFpePtr)0x0) {
    p_Var1 = fs_fpes;
    if (conn == fs_fpes) {
      pp_Var3 = &fs_fpes;
    }
    else {
      do {
        pp_Var3 = &p_Var1->next;
        p_Var1 = ((FSFpePtr)pp_Var3)->next;
        if (p_Var1 == (FSFpePtr)0x0) goto LAB_0012afec;
      } while (conn != p_Var1);
    }
    ((FSFpePtr)pp_Var3)->next = conn->next;
  }
LAB_0012afec:
  _fs_unmark_block(conn,conn->blockState);
  _fs_close_server(conn);
  __ptr = conn->clients;
  while (__ptr != (FSClientPtr)0x0) {
    p_Var2 = __ptr->next;
    free(__ptr);
    __ptr = p_Var2;
  }
  conn->clients = (FSClientPtr)0x0;
  remove_fs_handlers(fpe,fs_block_handler,(uint)(fs_fpes == (FSFpePtr)0x0));
  _fs_free_conn(conn);
  fpe->private = (void *)0x0;
  return 0x55;
}



int fs_init_fpe(FontPathElementPtr fpe)

{
  FSFpePtr p_Var1;
  Bool BVar2;
  int iVar3;
  size_t sVar4;
  FSFpePtr conn;
  char *__s;
  
  __s = fpe->name + (*fpe->name == ':');
  sVar4 = strlen(__s);
  conn = (FSFpePtr)calloc(1,sVar4 + 0xc1);
  if (conn == (FSFpePtr)0x0) {
    iVar3 = 0x50;
  }
  else {
    BVar2 = _fs_io_init(conn);
    if (BVar2 == 0) {
      free(conn);
      return 0x50;
    }
    conn->servername = (char *)(conn + 1);
    conn->fs_fd = -1;
    conn->fs_conn_state = 0;
    strcpy((char *)(conn + 1),__s);
    iVar3 = init_fs_handlers(fpe,fs_block_handler);
    if (iVar3 == 0x55) {
      fpe->private = conn;
      p_Var1 = conn;
      conn->next = fs_fpes;
      fs_fpes = p_Var1;
      do {
        iVar3 = _fs_do_setup_connection(conn);
        if (iVar3 != 0) {
          if (iVar3 == 1) {
            return 0x55;
          }
          break;
        }
        if (conn->fs_conn_state < 2) {
          iVar3 = _fs_poll_connect(conn->trans_conn,1000);
        }
        else {
          iVar3 = _fs_wait_for_readable(conn,1000);
        }
      } while (iVar3 != -1);
      iVar3 = 0x56;
      fs_free_fpe(fpe);
    }
    else {
      iVar3 = 0x50;
      _fs_free_conn(conn);
    }
  }
  return iVar3;
}



void _fs_connection_died(FSFpePtr conn)

{
  _fs_client_data *p_Var1;
  FSClientPtr __ptr;
  ulong uVar2;
  
  if ((*(byte *)&conn->blockState & 4) != 0) {
    return;
  }
  _fs_close_server(conn);
  __ptr = conn->clients;
  while (__ptr != (FSClientPtr)0x0) {
    p_Var1 = __ptr->next;
    free(__ptr);
    __ptr = p_Var1;
  }
  conn->clients = (FSClientPtr)0x0;
  uVar2 = GetTimeInMillis();
  conn->brokenConnectionTime = (CARD32)uVar2;
  _fs_mark_block(conn,4);
  _fs_unmark_block(conn,0x43);
  return;
}



int fs_await_reply(FSFpePtr conn)

{
  int iVar1;
  fsGenericReply *pfVar2;
  long in_FS_OFFSET;
  int ret;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  do {
    pfVar2 = fs_get_reply(conn,&ret);
    if (pfVar2 != (fsGenericReply *)0x0) {
      ret = 1;
      goto LAB_0012b29f;
    }
    if (ret != 0) goto LAB_0012b29f;
    iVar1 = _fs_wait_for_readable(conn,30000);
  } while (iVar1 == 1);
  _fs_connection_died(conn);
  ret = -1;
LAB_0012b29f:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return ret;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int fs_send_open_font(pointer client,FontPathElementPtr fpe,Mask flags,char *name,int namelen,
                     fsBitmapFormat format,fsBitmapFormatMask fmask,XID id,FontPtr *ppfont)

{
  fsBitmapFormat fVar1;
  FSFpePtr conn;
  long lVar2;
  FSBlockedFontPtr bfont;
  int iVar3;
  FontPtr p_Var4;
  FSBlockDataPtr blockrec;
  Atom AVar5;
  size_t sVar6;
  FontPropPtr p_Var7;
  Bool extraout_EDX;
  Bool sync;
  Bool extraout_EDX_00;
  ulong uVar8;
  long *plVar9;
  long in_FS_OFFSET;
  bool bVar10;
  fsQueryXInfoReq inforeq;
  fsQueryXExtents16Req extreq;
  fsOpenBitmapFontReq openreq;
  uchar buf [1024];
  
  conn = (FSFpePtr)fpe->private;
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  iVar3 = 0x53;
  if (((*(byte *)&conn->blockState & 0x10) != 0) || (0x3fe < namelen - 1U)) goto LAB_0012b549;
  if ((flags & 0x20) == 0) {
    p_Var4 = fs_create_font(fpe,name,namelen,format,fmask);
    if (p_Var4 != (FontPtr)0x0) {
      plVar9 = (long *)p_Var4->fpePrivate;
      blockrec = fs_new_block_rec((FontPathElementPtr)p_Var4->fpe->private,client,1);
      sync = extraout_EDX;
      if (blockrec != (FSBlockDataPtr)0x0) goto LAB_0012b3cf;
      (*p_Var4->unload_font)(p_Var4);
    }
  }
  else {
    p_Var4 = *(FontPtr *)id;
    plVar9 = (long *)p_Var4->fpePrivate;
    AVar5 = MakeAtom("FONT",4,0);
    if ((AVar5 != 0) && (iVar3 = (p_Var4->info).nprops, 0 < iVar3)) {
      p_Var7 = (p_Var4->info).props;
      uVar8 = 0;
      do {
        if ((p_Var7->name == AVar5) && ((p_Var4->info).isStringProp[uVar8] != '\0')) {
          if ((p_Var7->value != 0) && (name = NameForAtom(p_Var7->value), name != (char *)0x0)) {
            sVar6 = strlen(name);
            namelen = (int)sVar6;
            goto LAB_0012b670;
          }
          break;
        }
        p_Var7 = p_Var7 + 1;
        bVar10 = iVar3 - 1 != uVar8;
        uVar8 = uVar8 + 1;
      } while (bVar10);
    }
    name = (char *)plVar9[4];
    namelen = *(int *)(plVar9 + 3);
LAB_0012b670:
    blockrec = fs_new_block_rec((FontPathElementPtr)p_Var4->fpe->private,client,1);
    sync = extraout_EDX_00;
    if (blockrec != (FSBlockDataPtr)0x0) {
LAB_0012b3cf:
      if ((conn->blockState & 0x44) == 0) {
        *(int *)(plVar9 + 1) = conn->generation;
        bfont = (FSBlockedFontPtr)blockrec->data;
        bfont->fontid = *plVar9;
        bfont->pfont = p_Var4;
        bfont->state = 0;
        bfont->flags = (int)flags;
        fVar1 = *(fsBitmapFormat *)(plVar9 + 5);
        bfont->clients_depending = (FSClientsDependingPtr)0x0;
        bfont->format = fVar1;
        bfont->freeFont = (uint)((flags & 0x20) == 0);
        _fs_client_access(conn,client,sync);
        _fs_client_resolution(conn);
        buf[0] = (uchar)namelen;
        __memcpy_chk(buf + 1,name,(long)namelen,0x3ff);
        openreq.reqType = '\x0f';
        openreq.pad = '\0';
        openreq.fid = (CARD32)*plVar9;
        openreq.format_hint = *(fsBitmapFormat *)(plVar9 + 5);
        openreq.format_mask = *(fsBitmapFormatMask *)((long)plVar9 + 0x2c);
        conn->current_seq = conn->current_seq + 1;
        openreq.length = (CARD16)(namelen + 0x14 >> 2);
        _fs_write(conn,(char *)&openreq,0x10);
        _fs_write_pad(conn,(char *)buf,(long)(namelen + 1));
        inforeq.reqType = '\x10';
        inforeq.pad = '\0';
        blockrec->sequenceNumber = (CARD16)conn->current_seq;
        inforeq.length = 2;
        inforeq.id = (CARD32)*plVar9;
        bfont->queryInfoSequence = *(short *)&conn->current_seq + 1;
        conn->current_seq = conn->current_seq + 1;
        _fs_write(conn,(char *)&inforeq,8);
        if ((*(byte *)&bfont->flags & 0x20) == 0) {
          extreq.reqType = '\x12';
          extreq.range = '\x01';
          extreq.length = 3;
          extreq.fid = (CARD32)*plVar9;
          extreq.num_ranges = 0;
          bfont->queryExtentsSequence = *(short *)&conn->current_seq + 1;
          conn->current_seq = conn->current_seq + 1;
          _fs_write(conn,(char *)&extreq,0xc);
        }
        _fs_prepare_for_reply(conn);
        iVar3 = blockrec->errcode;
        if ((*(byte *)&bfont->flags & 0x10) != 0) {
          while (iVar3 == 0x51) {
            if (((*(byte *)&conn->blockState & 0x20) == 0) &&
               (iVar3 = fs_await_reply(conn), iVar3 != 1)) {
              blockrec->errcode = 0x53;
              fs_cleanup_bfont(bfont);
              bfont->freeFont = 0;
              _fs_remove_block_rec(conn,blockrec);
              iVar3 = 0x53;
              goto LAB_0012b549;
            }
            fs_read_reply(p_Var4->fpe,client);
            iVar3 = blockrec->errcode;
          }
          if (iVar3 == 0x55) {
            *(FontPtr *)id = bfont->pfont;
          }
          else {
            fs_cleanup_bfont(bfont);
          }
          bfont->freeFont = 0;
          _fs_remove_block_rec(conn,blockrec);
          goto LAB_0012b549;
        }
        if (iVar3 != 0x51) goto LAB_0012b549;
      }
      else if ((conn->blockState & 8) == 0) {
        _fs_pending_reply(conn);
        iVar3 = 0x54;
        goto LAB_0012b549;
      }
      iVar3 = 0x54;
      goto LAB_0012b549;
    }
  }
  iVar3 = 0x50;
LAB_0012b549:
  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar3;
}



int _fs_load_glyphs(pointer client,FontPtr pfont,Bool range_flag,uint nchars,int item_size,
                   uchar *data)

{
  FSFpePtr conn;
  FSBlockDataPtr blockrec;
  long *plVar1;
  FSClientsDependingPtr pfVar2;
  int iVar3;
  FSClientsDependingPtr pfVar4;
  fs_clients_depending *pfVar5;
  fs_clients_depending **clients_depending;
  long in_FS_OFFSET;
  undefined4 in_stack_ffffffffffffff98;
  undefined4 in_stack_ffffffffffffff9c;
  FontPtr local_50 [2];
  int nranges;
  fsRange *ranges;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  nranges = 0;
  ranges = (fsRange *)0x0;
  conn = (FSFpePtr)pfont->fpe->private;
  for (blockrec = conn->blockedRequests; local_50[0] = pfont, blockrec != (FSBlockDataPtr)0x0;
      blockrec = blockrec->next) {
    if (blockrec->type == 2) {
                    // WARNING: Load size is inaccurate
      if (pfont == *blockrec->data) {
        clients_depending = (fs_clients_depending **)((long)blockrec->data + 0x18);
        if (blockrec->client == client) {
          iVar3 = blockrec->errcode;
          if (iVar3 == 0x51) goto LAB_0012b875;
          _fs_signal_clients_depending(clients_depending);
          _fs_remove_block_rec(conn,blockrec);
          goto LAB_0012b880;
        }
LAB_0012b81d:
        iVar3 = fs_build_range(pfont,range_flag,nchars,item_size,data,&nranges,&ranges);
        if (iVar3 != 0x55) goto LAB_0012b941;
        if (nranges != 0) {
          _fs_clean_aborted_loadglyphs(local_50[0],nranges,ranges);
          free(ranges);
        }
        pfVar2 = *clients_depending;
        if (*clients_depending != (FSClientsDependingPtr)0x0) goto LAB_0012b870;
        goto LAB_0012b9e5;
      }
    }
    else if ((blockrec->type == 1) && (plVar1 = (long *)blockrec->data, pfont == (FontPtr)*plVar1))
    {
      iVar3 = blockrec->errcode;
      if (blockrec->client == client) {
        if (iVar3 == 0x51) goto LAB_0012b875;
        _fs_signal_clients_depending((FSClientsDependingPtr *)(plVar1 + 5));
        _fs_remove_block_rec(conn,blockrec);
        if (iVar3 != 0x55) goto LAB_0012b880;
        in_stack_ffffffffffffff9c = 0x55;
        break;
      }
      if (iVar3 == 0x51) {
        clients_depending = (fs_clients_depending **)(plVar1 + 5);
        goto LAB_0012b81d;
      }
    }
  }
  iVar3 = fs_build_range(local_50[0],range_flag,nchars,item_size,data,&nranges,&ranges);
  if (iVar3 == 0x55) {
    if (*(int *)((long)local_50[0]->fpePrivate + 8) == conn->generation) {
      iVar3 = fs_send_load_glyphs(client,local_50[0],nranges,ranges);
    }
    else {
      _fs_clean_aborted_loadglyphs(local_50[0],nranges,ranges);
      free(ranges);
      iVar3 = fs_send_open_font(client,local_50[0]->fpe,0x20,(char *)0x0,0,0,0,(XID)local_50,
                                (FontPtr *)
                                CONCAT44(in_stack_ffffffffffffff9c,in_stack_ffffffffffffff98));
    }
  }
  else {
LAB_0012b941:
    if (iVar3 == 0x400) {
      iVar3 = 0x55;
    }
  }
  goto LAB_0012b880;
  while (pfVar2 = pfVar4->next, pfVar4->next != (fs_clients_depending *)0x0) {
LAB_0012b870:
    pfVar4 = pfVar2;
    if (client == pfVar4->client) goto LAB_0012b875;
  }
  clients_depending = &pfVar4->next;
LAB_0012b9e5:
  pfVar5 = (fs_clients_depending *)malloc(0x10);
  if (pfVar5 == (fs_clients_depending *)0x0) {
    iVar3 = 0xb;
  }
  else {
    pfVar5->client = client;
    pfVar5->next = (fs_clients_depending *)0x0;
    *clients_depending = pfVar5;
LAB_0012b875:
    iVar3 = 0x54;
  }
LAB_0012b880:
  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int fs_open_font(pointer client,FontPathElementPtr fpe,Mask flags,char *name,int namelen,
                fsBitmapFormat format,fsBitmapFormatMask fmask,XID id,FontPtr *ppfont,char **alias,
                FontPtr non_cachable_font)

{
  FSFpePtr conn;
  FSBlockDataPtr blockrec;
  int iVar1;
  
  conn = (FSFpePtr)fpe->private;
  *alias = (char *)0x0;
  blockrec = conn->blockedRequests;
  while( true ) {
    if (blockrec == (FSBlockDataPtr)0x0) {
      iVar1 = fs_send_open_font(client,fpe,flags,name,namelen,format & 0xfffffff3,fmask,(XID)ppfont,
                                ppfont);
      return iVar1;
    }
    if ((blockrec->type == 1) && (blockrec->client == client)) break;
    blockrec = blockrec->next;
  }
  iVar1 = blockrec->errcode;
  if (iVar1 == 0x51) {
    iVar1 = 0x54;
  }
  else {
    if (iVar1 == 0x55) {
      *ppfont = ((FSBlockedFontPtr)blockrec->data)->pfont;
    }
    else {
      fs_cleanup_bfont((FSBlockedFontPtr)blockrec->data);
    }
    _fs_remove_block_rec(conn,blockrec);
  }
  return iVar1;
}



int fs_wakeup(FontPathElementPtr fpe,ulong *mask)

{
  uint uVar1;
  FSFpePtr conn;
  FSBlockDataPtr blockrec;
  byte bVar2;
  int iVar3;
  long lVar4;
  ulong uVar5;
  
  conn = (FSFpePtr)fpe->private;
  uVar1 = conn->blockState;
  if ((uVar1 & 0x40) != 0) {
    _fs_check_reconnect(conn);
    uVar1 = conn->blockState;
    goto joined_r0x0012bb80;
  }
  if ((uVar1 & 0x20) == 0) {
    if (conn->fs_fd == -1) goto joined_r0x0012bb80;
    lVar4 = __fdelt_chk();
    bVar2 = (byte)(conn->fs_fd >> 0x1f);
    if ((mask[lVar4] & 1L << (((char)conn->fs_fd + (bVar2 >> 2) & 0x3f) - (bVar2 >> 2) & 0x3f)) != 0
       ) goto LAB_0012bb51;
  }
  else {
LAB_0012bb51:
    fs_read_reply(fpe,(pointer)0x0);
  }
  uVar1 = conn->blockState;
joined_r0x0012bb80:
  if ((uVar1 & 0xe) != 0) {
    uVar5 = GetTimeInMillis();
    uVar1 = conn->blockState;
    iVar3 = (int)uVar5;
    if (((uVar1 & 8) == 0) || (0 < (int)(conn->blockedReplyTime - iVar3))) {
      if ((uVar1 & 4) == 0) {
        if (((uVar1 & 2) != 0) && ((int)(conn->brokenWriteTime - iVar3) < 1)) {
          _fs_flush(conn);
        }
      }
      else if (((int)(conn->brokenConnectionTime - iVar3) < 1) && ((uVar1 & 0x40) == 0)) {
        conn->alternate = 0;
        _fs_mark_block(conn,0x40);
        _fs_unmark_block(conn,4);
        _fs_check_reconnect(conn);
      }
    }
    else if ((uVar1 & 0x10) == 0) {
      _fs_mark_block(conn,0x10);
      do {
        blockrec = conn->blockedRequests;
        do {
          if (blockrec == (FSBlockDataPtr)0x0) {
            if (conn->fs_fd < 0) {
              return 0;
            }
            _fs_connection_died(conn);
            return 0;
          }
        } while (blockrec->errcode != 0x51);
        ClientSignal((ClientPtr)blockrec->client);
        fs_abort_blockrec(conn,blockrec);
      } while( true );
    }
  }
  return 0;
}



int fs_load_all_glyphs(FontPtr pfont)

{
  FSFpePtr conn;
  int iVar1;
  
  conn = (FSFpePtr)pfont->fpe->private;
  do {
    iVar1 = _fs_load_glyphs(serverClient,pfont,1,0,0,(uchar *)0x0);
    if (iVar1 != 0x54) {
      return iVar1;
    }
    if ((*(byte *)&conn->blockState & 0x20) == 0) {
      iVar1 = fs_await_reply(conn);
      if (iVar1 != 1) {
        fs_client_died(serverClient,pfont->fpe);
        return 0x57;
      }
    }
    fs_read_reply(pfont->fpe,serverClient);
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void fs_register_fpe_functions(void)

{
  RegisterFPEFunctions
            (fs_name_check,fs_init_fpe,fs_free_fpe,fs_reset_fpe,fs_open_font,fs_close_font,
             fs_list_fonts,fs_start_list_with_info,fs_next_list_with_info,fs_wakeup,fs_client_died,
             _fs_load_glyphs,(StartLaFunc)0x0,(NextLaFunc)0x0,(SetPathFunc)0x0);
  return;
}



int _fs_resize(FSBufPtr buf,long size)

{
  long lVar1;
  char *pcVar2;
  size_t __n;
  ulong uVar3;
  int iVar4;
  
  lVar1 = buf->remove;
  if (lVar1 != 0) {
    __n = buf->insert - lVar1;
    if (lVar1 != buf->insert) {
      memmove(buf->buf,buf->buf + lVar1,__n);
      __n = buf->insert - buf->remove;
    }
    buf->insert = __n;
    buf->remove = 0;
  }
  iVar4 = 1;
  if (buf->size < size) {
    uVar3 = size + 0x400U;
    if ((long)(size + 0x400U) < 0) {
      uVar3 = size + 0x7ff;
    }
    pcVar2 = (char *)realloc(buf->buf,uVar3 & 0xfffffffffffffc00);
    if (pcVar2 != (char *)0x0) {
      buf->buf = pcVar2;
      buf->size = uVar3 & 0xfffffffffffffc00;
      return 1;
    }
    iVar4 = -1;
  }
  return iVar4;
}



int _fs_poll_connect(XtransConnInfo trans_conn,int timeout)

{
  long lVar1;
  byte bVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  int *piVar6;
  long lVar7;
  __fd_mask *p_Var8;
  long in_FS_OFFSET;
  timeval tv;
  fd_set w_mask;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar3 = _FontTransGetConnectionNumber(trans_conn);
  bVar2 = (byte)(iVar3 >> 0x1f);
  while( true ) {
    tv.tv_usec = 0;
    lVar7 = 0x10;
    p_Var8 = w_mask.fds_bits;
    for (; lVar7 != 0; lVar7 = lVar7 + -1) {
      *p_Var8 = 0;
      p_Var8 = p_Var8 + 1;
    }
    tv.tv_sec = (long)timeout;
    lVar7 = __fdelt_chk((long)iVar3);
    w_mask.fds_bits[lVar7] =
         w_mask.fds_bits[lVar7] | 1L << (((char)iVar3 + (bVar2 >> 2) & 0x3f) - (bVar2 >> 2) & 0x3f);
    iVar4 = select(iVar3 + 1,(fd_set *)0x0,(fd_set *)&w_mask,(fd_set *)0x0,(timeval *)&tv);
    if (-1 < iVar4) break;
    piVar6 = __errno_location();
    if (*piVar6 != 4) {
      uVar5 = 0xffffffff;
LAB_0012bebe:
      if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
        return uVar5;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
  }
  uVar5 = (uint)(iVar4 != 0);
  goto LAB_0012bebe;
}



XtransConnInfo _fs_connect(char *servername,int *err)

{
  int iVar1;
  XtransConnInfo ciptr;
  int iVar2;
  
  ciptr = _FontTransOpenCOTSClient(servername);
  if (ciptr == (XtransConnInfo)0x0) {
    *err = -1;
    return (XtransConnInfo)0x0;
  }
  iVar2 = 6;
  _FontTransSetOption(ciptr,1,1);
  do {
    iVar1 = _FontTransConnect(ciptr,servername);
    if (iVar1 != -2) {
      if (-1 < iVar1) {
        iVar2 = 1;
        goto LAB_0012bf69;
      }
      if (iVar1 == -3) {
        iVar2 = 0;
        goto LAB_0012bf69;
      }
      break;
    }
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  _FontTransClose(ciptr);
  iVar2 = -1;
  ciptr = (XtransConnInfo)0x0;
LAB_0012bf69:
  *err = iVar2;
  return ciptr;
}



void _fs_done_read(FSFpePtr conn,long size)

{
  long lVar1;
  long lVar2;
  char *pcVar3;
  
  lVar1 = (conn->inBuf).insert;
  lVar2 = (conn->inBuf).remove;
  if (lVar1 - lVar2 < size) {
    return;
  }
  lVar2 = lVar2 + size;
  conn->inNeed = conn->inNeed - size;
  (conn->inBuf).remove = lVar2;
  if (lVar1 == lVar2) {
    (conn->inBuf).remove = 0;
    (conn->inBuf).insert = 0;
    if (0x8000 < (conn->inBuf).size) {
      pcVar3 = (char *)realloc((conn->inBuf).buf,0x8000);
      (conn->inBuf).size = 0x8000;
      (conn->inBuf).buf = pcVar3;
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

long _fs_pad_length(long len)

{
  return padlength[(uint)len & 3] + len;
}



int _fs_flush(FSFpePtr conn)

{
  long lVar1;
  int iVar2;
  int *piVar3;
  ulong uVar4;
  char *pcVar5;
  long lVar6;
  long lVar7;
  
  if (conn->fs_fd < 0) {
    return -1;
  }
  lVar1 = (conn->outBuf).insert;
  lVar7 = (conn->outBuf).remove;
  lVar6 = lVar1 - lVar7;
joined_r0x0012c07a:
  do {
    if (lVar6 < 1) {
      if (lVar7 != lVar1) {
        return 1;
      }
LAB_0012c12c:
      _fs_unmark_block(conn,3);
      if (0x400 < (conn->outBuf).size) {
        pcVar5 = (char *)realloc((conn->outBuf).buf,0x400);
        (conn->outBuf).buf = pcVar5;
      }
      (conn->outBuf).insert = 0;
      (conn->outBuf).remove = 0;
      return 1;
    }
    iVar2 = _FontTransWrite(conn->trans_conn,(conn->outBuf).buf + lVar7,(int)lVar6);
    lVar7 = (long)iVar2;
    if (lVar7 < 1) {
      if (lVar7 != 0) {
        piVar3 = __errno_location();
        if (*piVar3 != 0xb) {
          if (*piVar3 != 4) {
            _fs_connection_died(conn);
            return -1;
          }
          lVar1 = (conn->outBuf).insert;
          lVar7 = (conn->outBuf).remove;
          lVar6 = lVar1 - lVar7;
          goto joined_r0x0012c07a;
        }
      }
      uVar4 = GetTimeInMillis();
      conn->brokenWriteTime = (int)uVar4 + 1000;
      _fs_mark_block(conn,2);
      if ((conn->outBuf).remove != (conn->outBuf).insert) {
        return 1;
      }
      goto LAB_0012c12c;
    }
    lVar1 = (conn->outBuf).insert;
    lVar7 = lVar7 + (conn->outBuf).remove;
    (conn->outBuf).remove = lVar7;
    lVar6 = lVar1 - lVar7;
  } while( true );
}



int _fs_do_write(FSFpePtr conn,char *data,long len,long size)

{
  long *plVar1;
  long lVar2;
  int iVar3;
  
  while( true ) {
    lVar2 = (conn->outBuf).insert;
    if (size + lVar2 <= (conn->outBuf).size) {
      memcpy((conn->outBuf).buf + lVar2,data,len);
      memset((conn->outBuf).buf + (conn->outBuf).insert + len,0,size - len);
      plVar1 = &(conn->outBuf).insert;
      *plVar1 = *plVar1 + size;
      _fs_mark_block(conn,1);
      return 1;
    }
    iVar3 = _fs_flush(conn);
    if (iVar3 < 0) break;
    iVar3 = _fs_resize(&conn->outBuf,size);
    if (iVar3 < 0) {
      _fs_connection_died(conn);
      return -1;
    }
  }
  return -1;
}



void _fs_io_reinit(FSFpePtr conn)

{
  char *pcVar1;
  
  (conn->outBuf).remove = 0;
  (conn->outBuf).insert = 0;
  if (0x400 < (conn->outBuf).size) {
    pcVar1 = (char *)realloc((conn->outBuf).buf,0x400);
    (conn->outBuf).size = 0x400;
    (conn->outBuf).buf = pcVar1;
  }
  (conn->inBuf).remove = 0;
  (conn->inBuf).insert = 0;
  if ((conn->inBuf).size < 0x8001) {
    return;
  }
  pcVar1 = (char *)realloc((conn->inBuf).buf,0x8000);
  (conn->inBuf).size = 0x8000;
  (conn->inBuf).buf = pcVar1;
  return;
}



Bool _fs_io_init(FSFpePtr conn)

{
  Bool BVar1;
  char *__ptr;
  char *pcVar2;
  
  (conn->outBuf).remove = 0;
  (conn->outBuf).insert = 0;
  __ptr = (char *)malloc(0x400);
  (conn->outBuf).buf = __ptr;
  if (__ptr == (char *)0x0) {
    BVar1 = 0;
  }
  else {
    (conn->outBuf).size = 0x400;
    (conn->inBuf).remove = 0;
    (conn->inBuf).insert = 0;
    pcVar2 = (char *)malloc(0x400);
    (conn->inBuf).buf = pcVar2;
    if (pcVar2 == (char *)0x0) {
      free(__ptr);
      (conn->outBuf).buf = (char *)0x0;
      BVar1 = 0;
    }
    else {
      (conn->inBuf).size = 0x400;
      BVar1 = 1;
    }
  }
  return BVar1;
}



void _fs_io_fini(FSFpePtr conn)

{
  char *pcVar1;
  
  pcVar1 = (conn->outBuf).buf;
  if (pcVar1 != (char *)0x0) {
    free(pcVar1);
  }
  pcVar1 = (conn->inBuf).buf;
  if (pcVar1 != (char *)0x0) {
    free(pcVar1);
    return;
  }
  return;
}



int _fs_write(FSFpePtr conn,char *data,long len)

{
  int iVar1;
  
  if (len == 0) {
    iVar1 = 1;
  }
  else {
    iVar1 = conn->fs_fd;
    if (iVar1 != -1) {
      iVar1 = _fs_do_write(conn,data,len,len);
      return iVar1;
    }
  }
  return iVar1;
}



int _fs_write_pad(FSFpePtr conn,char *data,long len)

{
  int iVar1;
  
  if (padlength[(uint)len & 3] + len == 0) {
    iVar1 = 1;
  }
  else {
    iVar1 = conn->fs_fd;
    if (iVar1 != -1) {
      iVar1 = _fs_do_write(conn,data,len,padlength[(uint)len & 3] + len);
      return iVar1;
    }
  }
  return iVar1;
}



int _fs_wait_for_readable(FSFpePtr conn,int ms)

{
  long lVar1;
  byte bVar2;
  int iVar3;
  int *piVar4;
  long lVar5;
  __fd_mask *p_Var6;
  long in_FS_OFFSET;
  timeval tv;
  fd_set r_mask;
  fd_set e_mask;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  do {
    if (conn->fs_fd < 0) break;
    lVar5 = 0x10;
    p_Var6 = r_mask.fds_bits;
    for (; lVar5 != 0; lVar5 = lVar5 + -1) {
      *p_Var6 = 0;
      p_Var6 = p_Var6 + 1;
    }
    lVar5 = 0x10;
    p_Var6 = e_mask.fds_bits;
    for (; lVar5 != 0; lVar5 = lVar5 + -1) {
      *p_Var6 = 0;
      p_Var6 = p_Var6 + 1;
    }
    tv.tv_sec = (long)(ms / 1000);
    tv.tv_usec = (long)((ms % 1000) * 1000);
    lVar5 = __fdelt_chk((long)conn->fs_fd);
    r_mask.fds_bits[lVar5] = r_mask.fds_bits[lVar5] | 1L << ((byte)(conn->fs_fd % 0x40) & 0x3f);
    lVar5 = __fdelt_chk();
    iVar3 = conn->fs_fd;
    bVar2 = (byte)(iVar3 >> 0x1f);
    e_mask.fds_bits[lVar5] =
         e_mask.fds_bits[lVar5] | 1L << (((char)iVar3 + (bVar2 >> 2) & 0x3f) - (bVar2 >> 2) & 0x3f);
    iVar3 = select(iVar3 + 1,(fd_set *)&r_mask,(fd_set *)0x0,(fd_set *)&e_mask,(timeval *)&tv);
    if (-1 < iVar3) {
      if (iVar3 == 0) goto LAB_0012c540;
      lVar5 = __fdelt_chk((long)conn->fs_fd);
      bVar2 = (byte)(conn->fs_fd >> 0x1f);
      if ((r_mask.fds_bits[lVar5] &
          1L << (((char)conn->fs_fd + (bVar2 >> 2) & 0x3f) - (bVar2 >> 2) & 0x3f)) != 0) {
        iVar3 = 1;
        goto LAB_0012c540;
      }
      break;
    }
    piVar4 = __errno_location();
  } while ((*piVar4 == 4) || (*piVar4 == 0xb));
  iVar3 = -1;
LAB_0012c540:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int _fs_start_read(FSFpePtr conn,long size,char **buf)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  long lVar4;
  long lVar5;
  
  lVar5 = (conn->inBuf).insert;
  lVar4 = (conn->inBuf).remove;
  conn->inNeed = size;
  if (lVar5 - lVar4 < size) {
    iVar2 = _fs_resize(&conn->inBuf,size);
    if (iVar2 != 1) {
LAB_0012c6dd:
      _fs_connection_died(conn);
      return -1;
    }
    iVar2 = _fs_flush(conn);
    if (iVar2 < 0) {
      return -1;
    }
    lVar5 = (conn->inBuf).insert;
    lVar4 = lVar5 - (conn->inBuf).remove;
    if (0 < conn->inNeed - lVar4) {
      piVar3 = __errno_location();
      bVar1 = false;
      do {
        lVar4 = (conn->inBuf).size;
        *piVar3 = 0;
        iVar2 = _FontTransRead(conn->trans_conn,(conn->inBuf).buf + (conn->inBuf).insert,
                               (int)lVar4 - (int)lVar5);
        lVar5 = (long)iVar2;
        if (lVar5 < 1) {
          if (lVar5 == 0) {
            if (!bVar1) goto LAB_0012c710;
            iVar2 = *piVar3;
          }
          else {
            iVar2 = *piVar3;
            if (iVar2 == 0xb) {
              if (!bVar1) {
LAB_0012c710:
                iVar2 = _fs_wait_for_readable(conn,0);
                if (iVar2 == 0) {
                  return 0;
                }
                lVar5 = (conn->inBuf).insert;
                bVar1 = true;
                goto LAB_0012c671;
              }
              goto LAB_0012c6dd;
            }
          }
          if (iVar2 != 4) goto LAB_0012c6dd;
          lVar5 = (conn->inBuf).insert;
        }
        else {
          lVar5 = lVar5 + (conn->inBuf).insert;
          bVar1 = false;
          (conn->inBuf).insert = lVar5;
        }
LAB_0012c671:
        lVar4 = lVar5 - (conn->inBuf).remove;
      } while (0 < conn->inNeed - lVar4);
    }
    if (lVar4 < size) {
      return 0;
    }
  }
  if (buf != (char **)0x0) {
    *buf = (conn->inBuf).buf + (conn->inBuf).remove;
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// DWARF original prototype: void ErrorF(char * f, char * f, ...)

void ErrorF(char *f,char *f_1,...)

{
  long lVar1;
  char in_AL;
  undefined8 in_RCX;
  undefined8 in_RDX;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  va_list args;
  undefined local_b8 [8];
  char *local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = in_XMM0_Qa;
    local_78 = in_XMM1_Qa;
    local_68 = in_XMM2_Qa;
    local_58 = in_XMM3_Qa;
    local_48 = in_XMM4_Qa;
    local_38 = in_XMM5_Qa;
    local_28 = in_XMM6_Qa;
    local_18 = in_XMM7_Qa;
  }
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  args[0].overflow_arg_area = &stack0x00000008;
  args[0].gp_offset = 8;
  args[0].reg_save_area = local_b8;
  args[0].fp_offset = 0x30;
  local_b0 = f_1;
  local_a8 = in_RDX;
  local_a0 = in_RCX;
  local_98 = in_R8;
  local_90 = in_R9;
  __vfprintf_chk(_stderr,1,"%s",args);
  fflush(_stderr);
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void prmsg(int lvl,char *f,...)

{
  int iVar1;
  long lVar2;
  char in_AL;
  int *piVar3;
  undefined8 in_RCX;
  undefined8 in_RDX;
  undefined8 in_R8;
  undefined8 in_R9;
  long in_FS_OFFSET;
  undefined8 in_XMM0_Qa;
  undefined8 in_XMM1_Qa;
  undefined8 in_XMM2_Qa;
  undefined8 in_XMM3_Qa;
  undefined8 in_XMM4_Qa;
  undefined8 in_XMM5_Qa;
  undefined8 in_XMM6_Qa;
  undefined8 in_XMM7_Qa;
  va_list args;
  undefined local_d8 [16];
  undefined8 local_c8;
  undefined8 local_c0;
  undefined8 local_b8;
  undefined8 local_b0;
  undefined8 local_a8;
  undefined8 local_98;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  
  if (in_AL != '\0') {
    local_a8 = in_XMM0_Qa;
    local_98 = in_XMM1_Qa;
    local_88 = in_XMM2_Qa;
    local_78 = in_XMM3_Qa;
    local_68 = in_XMM4_Qa;
    local_58 = in_XMM5_Qa;
    local_48 = in_XMM6_Qa;
    local_38 = in_XMM7_Qa;
  }
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  args[0].overflow_arg_area = &stack0x00000008;
  args[0].gp_offset = 0x10;
  args[0].reg_save_area = local_d8;
  args[0].fp_offset = 0x30;
  local_c8 = in_RDX;
  local_c0 = in_RCX;
  local_b8 = in_R8;
  local_b0 = in_R9;
  if (lvl == 1) {
    piVar3 = __errno_location();
    iVar1 = *piVar3;
    ErrorF("%s","_FontTrans");
    __vfprintf_chk(_stderr,1,f,args);
    fflush(_stderr);
    *piVar3 = iVar1;
  }
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int _FontTransSocketINETClose(XtransConnInfo ciptr)

{
  int iVar1;
  
  prmsg(2,"SocketINETClose(%p,%d)\n",ciptr,(ulong)(uint)ciptr->fd);
  iVar1 = close(ciptr->fd);
  return iVar1;
}



int _FontTransSocketRead(XtransConnInfo ciptr,char *buf,int size)

{
  ssize_t sVar1;
  
  prmsg(2,"SocketRead(%d,%p,%d)\n",(ulong)(uint)ciptr->fd,buf,(ulong)(uint)size);
  sVar1 = read(ciptr->fd,buf,(long)size);
  return (int)sVar1;
}



int _FontTransSocketSetOption(XtransConnInfo ciptr,int option,int arg)

{
  prmsg(2,"SocketSetOption(%d,%d,%d)\n",(ulong)(uint)ciptr->fd,option,(ulong)(uint)arg);
  return -1;
}



int _FontTransSocketUNIXCloseForCloning(XtransConnInfo ciptr)

{
  int iVar1;
  
  prmsg(2,"SocketUNIXCloseForCloning(%p,%d)\n",ciptr,(ulong)(uint)ciptr->fd);
  iVar1 = close(ciptr->fd);
  return iVar1;
}



int _FontTransSocketDisconnect(XtransConnInfo ciptr)

{
  int iVar1;
  
  prmsg(2,"SocketDisconnect(%p,%d)\n",ciptr,(ulong)(uint)ciptr->fd);
  iVar1 = shutdown(ciptr->fd,2);
  return iVar1;
}



int _FontTransSocketWritev(XtransConnInfo ciptr,iovec *buf,int size)

{
  ssize_t sVar1;
  
  prmsg(2,"SocketWritev(%d,%p,%d)\n",(ulong)(uint)ciptr->fd,buf,(ulong)(uint)size);
  sVar1 = writev(ciptr->fd,(iovec *)buf,size);
  return (int)sVar1;
}



int _FontTransSocketReadv(XtransConnInfo ciptr,iovec *buf,int size)

{
  ssize_t sVar1;
  
  prmsg(2,"SocketReadv(%d,%p,%d)\n",(ulong)(uint)ciptr->fd,buf,(ulong)(uint)size);
  sVar1 = readv(ciptr->fd,(iovec *)buf,size);
  return (int)sVar1;
}



int _FontTransSocketWrite(XtransConnInfo ciptr,char *buf,int size)

{
  ssize_t sVar1;
  
  prmsg(2,"SocketWrite(%d,%p,%d)\n",(ulong)(uint)ciptr->fd,buf,(ulong)(uint)size);
  sVar1 = write(ciptr->fd,buf,(long)size);
  return (int)sVar1;
}



int _FontTransSocketBytesReadable(XtransConnInfo ciptr,BytesReadable_t *pend)

{
  int iVar1;
  
  prmsg(2,"SocketBytesReadable(%p,%d,%p)\n",ciptr,(ulong)(uint)ciptr->fd,pend);
  iVar1 = ioctl(ciptr->fd,0x541b,pend);
  return iVar1;
}



XtransConnInfo
_FontTransSocketOpenCOTSClientBase
          (char *transname,char *protocol,char *host,char *port,int previndex)

{
  uint __type;
  uint __domain;
  char *__s2;
  int iVar1;
  XtransConnInfo __ptr;
  long lVar2;
  uint uVar3;
  Sockettrans2dev *pSVar4;
  long in_FS_OFFSET;
  socklen_t len;
  int tmp;
  long local_40;
  
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  prmsg(2,"SocketOpenCOTSClient(%s,%s,%s)\n",protocol,host,port);
LAB_0012cba5:
  do {
    uVar3 = previndex + 1;
    prmsg(3,"SocketSelectFamily(%s)\n",transname);
    if (5 < uVar3) {
LAB_0012ccd8:
      if (previndex == 0xffffffff) {
        __ptr = (XtransConnInfo)0x0;
        prmsg(1,"SocketOpenCOTSClient: Unable to determine socket type for %s\n",transname);
      }
      else {
        __ptr = (XtransConnInfo)0x0;
        prmsg(1,"SocketOpenCOTSClient: Unable to open socket for %s\n",transname);
      }
LAB_0012ccab:
      if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return __ptr;
    }
    pSVar4 = Sockettrans2devtab + previndex;
    while( true ) {
      __s2 = pSVar4[1].transname;
      iVar1 = strcmp(transname,__s2);
      if (iVar1 == 0) break;
      uVar3 = uVar3 + 1;
      pSVar4 = pSVar4 + 1;
      if (uVar3 == 6) goto LAB_0012ccd8;
    }
    __type = Sockettrans2devtab[(int)uVar3].devcotsname;
    prmsg(3,"SocketOpen(%d,%d)\n",(ulong)uVar3,(ulong)__type);
    __ptr = (XtransConnInfo)calloc(1,0x60);
    previndex = uVar3;
    if (__ptr != (XtransConnInfo)0x0) {
      __domain = Sockettrans2devtab[(int)uVar3].family;
      iVar1 = socket(__domain,__type,Sockettrans2devtab[(int)uVar3].protocol);
      __ptr->fd = iVar1;
      if ((-1 < iVar1) && (lVar2 = sysconf(4), iVar1 < lVar2)) {
        if ((__domain & 0xfffffff7) == 2) {
          tmp = 1;
          setsockopt(__ptr->fd,6,1,&tmp,4);
        }
        else if (__domain == 1) {
          len = 4;
          iVar1 = getsockopt(__ptr->fd,1,7,&tmp,&len);
          if ((iVar1 == 0) && (tmp < 0x10000)) {
            tmp = 0x10000;
            setsockopt(__ptr->fd,1,7,&tmp,4);
          }
        }
        __ptr->index = uVar3;
        goto LAB_0012ccab;
      }
      prmsg(2,"SocketOpen: socket() failed for %s\n",__s2);
      free(__ptr);
      goto LAB_0012cba5;
    }
    prmsg(1,"SocketOpen: malloc failed\n");
  } while( true );
}



XtransConnInfo
_FontTransSocketOpenCOTSClient(Xtransport *thistrans,char *protocol,char *host,char *port)

{
  XtransConnInfo p_Var1;
  
  p_Var1 = _FontTransSocketOpenCOTSClientBase(thistrans->TransName,protocol,host,port,-1);
  return p_Var1;
}



int _FontTransSocketUNIXClose(XtransConnInfo ciptr)

{
  short *psVar1;
  int iVar2;
  
  psVar1 = (short *)ciptr->addr;
  prmsg(2,"SocketUNIXClose(%p,%d)\n",ciptr,(ulong)(uint)ciptr->fd);
  iVar2 = close(ciptr->fd);
  if ((((ciptr->flags != 0) && (psVar1 != (short *)0x0)) && (*psVar1 == 1)) &&
     (((*(char *)(psVar1 + 1) != '\0' && ((ciptr->flags & 0x10U) == 0)) &&
      ((*(byte *)&ciptr->transptr->flags & 0x20) == 0)))) {
    unlink((char *)(psVar1 + 1));
  }
  return iVar2;
}



void _FontTransFreeConnInfo(XtransConnInfo ciptr)

{
  prmsg(3,"FreeConnInfo(%p)\n",ciptr);
  if (ciptr->addr != (char *)0x0) {
    free(ciptr->addr);
  }
  if (ciptr->peeraddr != (char *)0x0) {
    free(ciptr->peeraddr);
  }
  if (ciptr->port != (char *)0x0) {
    free(ciptr->port);
  }
  free(ciptr);
  return;
}



int _FontTransSetOption(XtransConnInfo ciptr,int option,int arg)

{
  uint __fd;
  int iVar1;
  uint uVar2;
  ulong uVar3;
  
  __fd = ciptr->fd;
  prmsg(2,"SetOption(%d,%d,%d)\n",(ulong)__fd,option,(ulong)(uint)arg);
  if (option == 1) {
    uVar2 = 0;
    if (arg == 1) {
      uVar2 = fcntl(__fd,3,0);
      if (uVar2 != 0xffffffff) {
        iVar1 = 4;
        uVar3 = (ulong)(uVar2 | 0x800);
        goto LAB_0012cf41;
      }
    }
  }
  else {
    uVar2 = 0;
    if (option == 2) {
      uVar3 = 1;
      iVar1 = 2;
LAB_0012cf41:
      iVar1 = fcntl(__fd,iVar1,uVar3);
      return iVar1;
    }
  }
  return uVar2;
}



int _FontTransBytesReadable(XtransConnInfo ciptr,BytesReadable_t *pend)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0012cf87. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*ciptr->transptr->BytesReadable)(ciptr,pend);
  return iVar1;
}



int _FontTransRead(XtransConnInfo ciptr,char *buf,int size)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0012cf97. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*ciptr->transptr->Read)(ciptr,buf,size);
  return iVar1;
}



int _FontTransWrite(XtransConnInfo ciptr,char *buf,int size)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0012cfa7. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*ciptr->transptr->Write)(ciptr,buf,size);
  return iVar1;
}



int _FontTransReadv(XtransConnInfo ciptr,iovec *buf,int size)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0012cfb7. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*ciptr->transptr->Readv)(ciptr,buf,size);
  return iVar1;
}



int _FontTransWritev(XtransConnInfo ciptr,iovec *buf,int size)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0012cfc7. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*ciptr->transptr->Writev)(ciptr,buf,size);
  return iVar1;
}



int _FontTransDisconnect(XtransConnInfo ciptr)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0012cfd7. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*ciptr->transptr->Disconnect)(ciptr);
  return iVar1;
}



int _FontTransClose(XtransConnInfo ciptr)

{
  int iVar1;
  
  prmsg(2,"Close(%d)\n",(ulong)(uint)ciptr->fd);
  iVar1 = (*ciptr->transptr->Close)(ciptr);
  _FontTransFreeConnInfo(ciptr);
  return iVar1;
}



int _FontTransCloseForCloning(XtransConnInfo ciptr)

{
  int iVar1;
  
  prmsg(2,"CloseForCloning(%d)\n",(ulong)(uint)ciptr->fd);
  iVar1 = (*ciptr->transptr->CloseForCloning)(ciptr);
  _FontTransFreeConnInfo(ciptr);
  return iVar1;
}



// WARNING: Unknown calling convention

int _FontTransIsLocal(XtransConnInfo ciptr)

{
  return (int)(ciptr->family == 1);
}



int _FontTransGetPeerAddr(XtransConnInfo ciptr,int *familyp,int *addrlenp,Xtransaddr **addrp)

{
  int iVar1;
  Xtransaddr *__dest;
  
  prmsg(2,"GetPeerAddr(%d)\n",(ulong)(uint)ciptr->fd);
  *familyp = ciptr->family;
  iVar1 = ciptr->peeraddrlen;
  *addrlenp = iVar1;
  __dest = (Xtransaddr *)malloc((long)iVar1);
  *addrp = __dest;
  if (__dest == (Xtransaddr *)0x0) {
    prmsg(1,"GetPeerAddr: malloc failed\n");
    iVar1 = -1;
  }
  else {
    memcpy(__dest,ciptr->peeraddr,(long)ciptr->peeraddrlen);
    iVar1 = 0;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int _FontTransGetConnectionNumber(XtransConnInfo ciptr)

{
  return ciptr->fd;
}



int _FontTransGetHostname(char *buf,int maxlen)

{
  long lVar1;
  size_t sVar2;
  int iVar3;
  long in_FS_OFFSET;
  utsname name;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  uname((utsname *)&name);
  sVar2 = strlen(name.nodename);
  iVar3 = maxlen + -1;
  if ((int)sVar2 < maxlen) {
    iVar3 = (int)sVar2;
  }
  strncpy(buf,name.nodename,(long)iVar3);
  buf[iVar3] = '\0';
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int _FontTransSocketINETConnect(XtransConnInfo ciptr,char *host,char *port)

{
  long lVar1;
  addrinfo *__ai;
  bool bVar2;
  int iVar3;
  int iVar4;
  char *pcVar5;
  uint *puVar6;
  addrinfo *paVar7;
  addrlist *paVar8;
  int *piVar9;
  long lVar10;
  ulong uVar11;
  sockaddr_storage *__addr;
  byte *pbVar12;
  byte *pbVar13;
  sockaddr_storage *psVar14;
  uint uVar15;
  socklen_t __len;
  char *__s2;
  sockaddr *__addr_00;
  long in_FS_OFFSET;
  bool bVar16;
  bool bVar17;
  bool bVar18;
  byte bVar19;
  XtransConnInfo local_250;
  int tmp;
  addrinfo hints;
  sockaddr_in socknamev4;
  sockaddr_storage socknamev6;
  char ntopbuf [46];
  char hostnamebuf [256];
  
  bVar19 = 0;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  prmsg(2,"SocketINETConnect(%d,%s,%s)\n",(ulong)(uint)ciptr->fd,host,port);
  if (host == (char *)0x0) {
    host = hostnamebuf;
    hostnamebuf[0] = '\0';
    _FontTransGetHostname(host,0x100);
    if (addrlist == (addrlist *)0x0) goto LAB_0012d840;
LAB_0012d225:
    paVar8 = addrlist;
    pcVar5 = addrlist->host;
    iVar3 = strcmp(host,pcVar5);
    __ai = (addrinfo *)paVar8->firstaddr;
    __s2 = paVar8->port;
    if ((iVar3 != 0) || (iVar3 = strcmp(port,__s2), iVar3 != 0)) {
      if (__ai != (addrinfo *)0x0) {
        freeaddrinfo(__ai);
      }
      paVar8->firstaddr = (addrinfo *)0x0;
      goto LAB_0012d3f7;
    }
    if (__ai == (addrinfo *)0x0) goto LAB_0012d3f7;
    paVar7 = paVar8->addr;
  }
  else {
    if (addrlist != (addrlist *)0x0) goto LAB_0012d225;
LAB_0012d840:
    paVar8 = (addrlist *)malloc(0x70);
    pcVar5 = paVar8->host;
    __s2 = paVar8->port;
    addrlist = paVar8;
    paVar8->firstaddr = (addrinfo *)0x0;
LAB_0012d3f7:
    strncpy(__s2,port,0x20);
    paVar8->port[0x1f] = '\0';
    strncpy(pcVar5,host,0x40);
    paVar8->host[0x3f] = '\0';
    hints.ai_addrlen = 0;
    hints._20_4_ = 0;
    hints.ai_addr = (sockaddr *)0x0;
    hints.ai_canonname = (char *)0x0;
    hints.ai_next = (addrinfo *)0x0;
    hints._0_16_ = ZEXT416((uint)Sockettrans2devtab[ciptr->index].devcotsname) << 0x40;
    iVar3 = getaddrinfo(host,port,(addrinfo *)&hints,(addrinfo **)&paVar8->firstaddr);
    paVar8 = addrlist;
    if (iVar3 != 0) {
      gai_strerror(iVar3);
      prmsg(1,"SocketINETConnect() can\'t get address for %s:%s: %s\n",host,port);
      piVar9 = __errno_location();
      iVar3 = -1;
      *piVar9 = 0x16;
      goto LAB_0012d7a6;
    }
    paVar7 = addrlist->firstaddr;
    addrlist->addr = paVar7;
    uVar15 = 0;
    while (paVar7 != (addrinfo *)0x0) {
      paVar7 = paVar7->ai_next;
      uVar15 = uVar15 + 1;
      paVar8->addr = paVar7;
    }
    prmsg(4,"Got New Address list with %d addresses\n",(ulong)uVar15);
    paVar8 = addrlist;
    paVar7 = (addrinfo *)0x0;
    addrlist->addr = (addrinfo *)0x0;
  }
  bVar17 = false;
  bVar2 = false;
  if (paVar7 == (addrinfo *)0x0) goto LAB_0012d2ad;
LAB_0012d288:
  iVar3 = paVar7->ai_family;
  __addr_00 = paVar7->ai_addr;
  __len = paVar7->ai_addrlen;
  bVar2 = bVar17;
  if (iVar3 == 2) goto LAB_0012d2d1;
LAB_0012d298:
  if (iVar3 != 10) goto LAB_0012d2a1;
  pcVar5 = inet_ntop(10,__addr_00->sa_data + 6,ntopbuf,0x2e);
  prmsg(4,"SocketINETConnect() sockname.sin6_addr = %s\n",pcVar5);
  prmsg(4,"SocketINETConnect() sockname.sin6_port = %d\n",
        (ulong)(ushort)(*(ushort *)__addr_00->sa_data << 8 | *(ushort *)__addr_00->sa_data >> 8));
  bVar17 = (uint)Sockettrans2devtab[ciptr->index].family < 2;
  bVar16 = Sockettrans2devtab[ciptr->index].family == 2;
  if (bVar16) {
    lVar10 = 4;
    pbVar12 = (byte *)Sockettrans2devtab[ciptr->index].transname;
    pbVar13 = &DAT_0013641d;
    do {
      if (lVar10 == 0) break;
      lVar10 = lVar10 + -1;
      bVar17 = *pbVar12 < *pbVar13;
      bVar16 = *pbVar12 == *pbVar13;
      pbVar12 = pbVar12 + (ulong)bVar19 * -2 + 1;
      pbVar13 = pbVar13 + (ulong)bVar19 * -2 + 1;
    } while (bVar16);
    if ((!bVar17 && !bVar16) != bVar17) {
      pcVar5 = "SocketINETConnect() Skipping IPv6 address\n";
      goto LAB_0012d66f;
    }
    _FontTransSocketINETClose(ciptr);
    local_250 = _FontTransSocketOpenCOTSClientBase("tcp","tcp",host,port,-1);
    if (local_250 == (XtransConnInfo)0x0) {
      prmsg(4,"SocketINETConnect() Cannot get IPv6 socket for IPv6 address\n");
      goto LAB_0012d5c7;
    }
    ciptr->fd = local_250->fd;
    if (Sockettrans2devtab[local_250->index].family != 10) {
      pcVar5 = "SocketINETConnect() Cannot get IPv6 socket for IPv6 address\n";
      do {
        prmsg(4,pcVar5);
        free(local_250);
LAB_0012d5c7:
        paVar7 = addrlist->addr;
        paVar8 = addrlist;
LAB_0012d2a1:
        paVar7 = paVar7->ai_next;
        paVar8->addr = paVar7;
        bVar17 = bVar2;
        if (paVar7 != (addrinfo *)0x0) goto LAB_0012d288;
LAB_0012d2ad:
        if (bVar2) {
          prmsg(1,"SocketINETConnect() no usable address for %s:%s\n",host,port);
          iVar3 = -1;
          goto LAB_0012d7a6;
        }
        paVar7 = paVar8->firstaddr;
        bVar17 = true;
        paVar8->addr = paVar7;
        iVar3 = paVar7->ai_family;
        __addr_00 = paVar7->ai_addr;
        __len = paVar7->ai_addrlen;
        bVar2 = bVar17;
        if (iVar3 != 2) goto LAB_0012d298;
LAB_0012d2d1:
        pcVar5 = inet_ntop(2,__addr_00->sa_data + 2,ntopbuf,0x2e);
        prmsg(4,"SocketINETConnect() sockname.sin_addr = %s\n",pcVar5);
        prmsg(4,"SocketINETConnect() sockname.sin_port = %d\n",
              (ulong)(ushort)(*(ushort *)__addr_00->sa_data << 8 |
                             *(ushort *)__addr_00->sa_data >> 8));
        bVar16 = (uint)Sockettrans2devtab[ciptr->index].family < 10;
        bVar18 = Sockettrans2devtab[ciptr->index].family == 10;
        if (!bVar18) goto LAB_0012d339;
        lVar10 = 4;
        pbVar12 = (byte *)Sockettrans2devtab[ciptr->index].transname;
        pbVar13 = &DAT_0013641d;
        do {
          if (lVar10 == 0) break;
          lVar10 = lVar10 + -1;
          bVar16 = *pbVar12 < *pbVar13;
          bVar18 = *pbVar12 == *pbVar13;
          pbVar12 = pbVar12 + (ulong)bVar19 * -2 + 1;
          pbVar13 = pbVar13 + (ulong)bVar19 * -2 + 1;
        } while (bVar18);
        bVar2 = bVar17;
        if ((!bVar16 && !bVar18) != bVar16) {
          pcVar5 = "SocketINETConnect Skipping IPv4 address\n";
LAB_0012d66f:
          prmsg(4,pcVar5);
          goto LAB_0012d5c7;
        }
        _FontTransSocketINETClose(ciptr);
        local_250 = _FontTransSocketOpenCOTSClientBase("tcp","tcp",host,port,ciptr->index);
        if (local_250 == (XtransConnInfo)0x0) {
          prmsg(4,"SocketINETConnect() Cannot get IPv4  socketfor IPv4 address\n");
          goto LAB_0012d5c7;
        }
        ciptr->fd = local_250->fd;
        if (Sockettrans2devtab[local_250->index].family == 2) break;
        pcVar5 = "SocketINETConnect() Cannot get IPv4  socketfor IPv4 address\n";
      } while( true );
    }
    free(local_250);
  }
LAB_0012d339:
  tmp = 1;
  setsockopt(ciptr->fd,1,9,&tmp,4);
  iVar3 = connect(ciptr->fd,(sockaddr *)__addr_00,__len);
  if (iVar3 < 0) {
    puVar6 = (uint *)__errno_location();
    uVar15 = *puVar6;
    paVar7 = addrlist->addr->ai_next;
    if ((uVar15 == 0x6f) || (uVar15 == 4)) {
LAB_0012d79d:
      iVar3 = -2;
    }
    else {
      if (((paVar7 == (addrinfo *)0x0) && (addrlist->firstaddr == addrlist->addr)) ||
         (0xf < uVar15 - 0x61)) {
        if ((uVar15 == 0xb) || (uVar15 == 0x73)) {
          iVar3 = -3;
          goto LAB_0012d7a3;
        }
      }
      else if ((0xa015UL >> ((ulong)(uVar15 - 0x61) & 0x3f) & 1) != 0) goto LAB_0012d79d;
      prmsg(2,"SocketINETConnect: Can\'t connect: errno = %d\n",(ulong)uVar15);
      iVar3 = -1;
      paVar7 = addrlist->addr->ai_next;
    }
  }
  else {
    __addr = &socknamev6;
    prmsg(3,"SocketINETGetAddr(%p)\n",ciptr);
    psVar14 = __addr;
    for (lVar10 = 0x10; lVar10 != 0; lVar10 = lVar10 + -1) {
      psVar14->ss_family = 0;
      psVar14->__ss_padding[0] = '\0';
      psVar14->__ss_padding[1] = '\0';
      psVar14->__ss_padding[2] = '\0';
      psVar14->__ss_padding[3] = '\0';
      psVar14->__ss_padding[4] = '\0';
      psVar14->__ss_padding[5] = '\0';
      psVar14 = (sockaddr_storage *)((long)psVar14 + (ulong)bVar19 * -0x10 + 8);
    }
    tmp = 0x80;
    iVar4 = getsockname(ciptr->fd,(sockaddr *)__addr,(socklen_t *)&tmp);
    iVar3 = tmp;
    if (iVar4 < 0) {
      puVar6 = (uint *)__errno_location();
      prmsg(1,"SocketINETGetAddr: getsockname() failed: %d\n",(ulong)*puVar6);
LAB_0012d96f:
      pcVar5 = "SocketINETConnect: ...SocketINETGetAddr() failed:\n";
    }
    else {
      pcVar5 = (char *)malloc((ulong)(uint)tmp);
      ciptr->addr = pcVar5;
      if (pcVar5 == (char *)0x0) {
        prmsg(1,"SocketINETGetAddr: Can\'t allocate space for the addr\n");
        goto LAB_0012d96f;
      }
      ciptr->addrlen = iVar3;
      ciptr->family = (uint)socknamev6.ss_family;
      memcpy(pcVar5,__addr,(long)iVar3);
      if (socknamev6.ss_family == 10) {
        uVar11 = 0x80;
        tmp = 0x80;
      }
      else {
        uVar11 = 0x10;
        tmp = 0x10;
        __addr = (sockaddr_storage *)&socknamev4;
      }
      psVar14 = __addr;
      for (uVar11 = uVar11 >> 3; uVar11 != 0; uVar11 = uVar11 - 1) {
        psVar14->ss_family = 0;
        psVar14->__ss_padding[0] = '\0';
        psVar14->__ss_padding[1] = '\0';
        psVar14->__ss_padding[2] = '\0';
        psVar14->__ss_padding[3] = '\0';
        psVar14->__ss_padding[4] = '\0';
        psVar14->__ss_padding[5] = '\0';
        psVar14 = (sockaddr_storage *)((long)psVar14 + (ulong)bVar19 * -0x10 + 8);
      }
      prmsg(3,"SocketINETGetPeerAddr(%p)\n",ciptr);
      iVar4 = getpeername(ciptr->fd,(sockaddr *)__addr,(socklen_t *)&tmp);
      iVar3 = tmp;
      if (iVar4 < 0) {
        puVar6 = (uint *)__errno_location();
        prmsg(1,"SocketINETGetPeerAddr: getpeername() failed: %d\n",(ulong)*puVar6);
      }
      else {
        pcVar5 = (char *)malloc((ulong)(uint)tmp);
        ciptr->peeraddr = pcVar5;
        if (pcVar5 != (char *)0x0) {
          ciptr->peeraddrlen = iVar3;
          memcpy(pcVar5,__addr,(long)iVar3);
          iVar3 = 0;
          goto LAB_0012d7a6;
        }
        prmsg(1,"SocketINETGetPeerAddr: Can\'t allocate space for the addr\n");
      }
      pcVar5 = "SocketINETConnect: ...SocketINETGetPeerAddr() failed:\n";
    }
    prmsg(1,pcVar5);
    iVar3 = -1;
    paVar7 = addrlist->addr->ai_next;
  }
LAB_0012d7a3:
  addrlist->addr = paVar7;
LAB_0012d7a6:
  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int _FontTransSocketUNIXConnect(XtransConnInfo ciptr,char *host,char *port)

{
  char cVar1;
  long lVar2;
  sockaddr *psVar3;
  sockaddr *psVar4;
  long lVar5;
  bool bVar6;
  int iVar7;
  bool bVar8;
  int iVar9;
  size_t sVar10;
  int *piVar11;
  addrinfo *paVar12;
  ulong uVar13;
  ulong uVar14;
  uint __len;
  byte *pbVar15;
  sockaddr_un *psVar16;
  addrinfo *paVar17;
  byte *pbVar18;
  long lVar19;
  uint uVar20;
  char *pcVar21;
  char *pcVar22;
  long in_FS_OFFSET;
  bool bVar23;
  bool bVar24;
  bool bVar25;
  byte bVar26;
  addrinfo *localhostaddr;
  addrinfo *otherhostaddr;
  sockaddr_un sockname;
  char hostnamebuf [256];
  
  bVar26 = 0;
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  uVar20 = ciptr->transptr->flags & 0x20;
  prmsg(2,"SocketUNIXConnect(%d,%s,%s)\n",(ulong)(uint)ciptr->fd,host,port);
  if (host != (char *)0x0) {
    cVar1 = *host;
    bVar23 = false;
    bVar6 = cVar1 != '/' && cVar1 != '\0';
    bVar25 = cVar1 == '/';
    bVar8 = cVar1 == '\0';
    bVar24 = bVar25 || bVar8;
    if (!bVar25 && !bVar8) {
      lVar19 = 5;
      pbVar15 = (byte *)host;
      pbVar18 = &DAT_00136485;
      do {
        if (lVar19 == 0) break;
        lVar19 = lVar19 + -1;
        bVar23 = *pbVar15 < *pbVar18;
        bVar24 = *pbVar15 == *pbVar18;
        pbVar15 = pbVar15 + (ulong)bVar26 * -2 + 1;
        pbVar18 = pbVar18 + (ulong)bVar26 * -2 + 1;
      } while (bVar24);
      if ((!bVar23 && !bVar24) != bVar23) {
        _FontTransGetHostname(hostnamebuf,0x100);
        iVar9 = strcmp(hostnamebuf,host);
        if (iVar9 != 0) {
          iVar9 = getaddrinfo(hostnamebuf,(char *)0x0,(addrinfo *)0x0,(addrinfo **)&localhostaddr);
          if (iVar9 == 0) {
            iVar9 = getaddrinfo(host,(char *)0x0,(addrinfo *)0x0,(addrinfo **)&otherhostaddr);
            if (iVar9 == 0) {
              paVar17 = localhostaddr;
              if (localhostaddr == (addrinfo *)0x0) {
                freeaddrinfo((addrinfo *)0x0);
                freeaddrinfo((addrinfo *)otherhostaddr);
              }
              else {
                do {
                  if (otherhostaddr == (addrinfo *)0x0) {
                    bVar25 = false;
                    bVar24 = bVar6;
                  }
                  else {
                    iVar9 = paVar17->ai_family;
                    paVar12 = otherhostaddr;
                    do {
                      bVar25 = false;
                      bVar24 = bVar6;
                      if (iVar9 == paVar12->ai_family) {
                        if (iVar9 == 2) {
                          bVar25 = *(int *)(paVar12->ai_addr->sa_data + 2) ==
                                   *(int *)(paVar17->ai_addr->sa_data + 2);
                          bVar24 = !bVar25;
                        }
                        else if (iVar9 == 10) {
                          psVar3 = paVar17->ai_addr;
                          psVar4 = paVar12->ai_addr;
                          lVar19._0_2_ = psVar3[1].sa_family;
                          lVar19._2_1_ = psVar3[1].sa_data[0];
                          lVar19._3_1_ = psVar3[1].sa_data[1];
                          lVar19._4_1_ = psVar3[1].sa_data[2];
                          lVar19._5_1_ = psVar3[1].sa_data[3];
                          lVar19._6_1_ = psVar3[1].sa_data[4];
                          lVar19._7_1_ = psVar3[1].sa_data[5];
                          lVar5._0_2_ = psVar4[1].sa_family;
                          lVar5._2_1_ = psVar4[1].sa_data[0];
                          lVar5._3_1_ = psVar4[1].sa_data[1];
                          lVar5._4_1_ = psVar4[1].sa_data[2];
                          lVar5._5_1_ = psVar4[1].sa_data[3];
                          lVar5._6_1_ = psVar4[1].sa_data[4];
                          lVar5._7_1_ = psVar4[1].sa_data[5];
                          bVar24 = *(long *)(psVar3->sa_data + 6) == *(long *)(psVar4->sa_data + 6);
                          bVar25 = lVar19 == lVar5 && bVar24;
                          bVar24 = lVar19 != lVar5 || !bVar24;
                        }
                      }
                      paVar12 = paVar12->ai_next;
                    } while ((paVar12 != (addrinfo *)0x0) && (bVar24));
                  }
                } while ((paVar17->ai_next != (addrinfo *)0x0) &&
                        (paVar17 = paVar17->ai_next, bVar24));
                freeaddrinfo((addrinfo *)localhostaddr);
                freeaddrinfo((addrinfo *)otherhostaddr);
                if (bVar25) goto LAB_0012da27;
              }
            }
            else {
              freeaddrinfo((addrinfo *)localhostaddr);
            }
          }
          prmsg(1,"SocketUNIXConnect: Cannot connect to non-local host %s\n",host);
          iVar9 = -1;
          goto LAB_0012db28;
        }
      }
    }
  }
LAB_0012da27:
  if ((port == (char *)0x0) || (cVar1 = *port, cVar1 == '\0')) {
    prmsg(1,"SocketUNIXConnect: Missing port specification\n");
    iVar9 = -1;
    goto LAB_0012db28;
  }
  sockname.sun_family = 1;
  if (cVar1 == '@') {
    pcVar21 = "";
    lVar19 = 0;
    pcVar22 = pcVar21;
  }
  else {
    lVar19 = 0x12;
    pcVar22 = "@";
    pcVar21 = "/tmp/.font-unix/fs";
    if (uVar20 == 0) {
      pcVar22 = "";
    }
    if (cVar1 == '/') {
      lVar19 = 0;
      pcVar21 = "";
    }
  }
  sVar10 = strlen(port);
  if (0x6b < sVar10 + lVar19) {
    prmsg(1,"SocketUNIXConnect: path too long\n");
    iVar9 = -1;
    goto LAB_0012db28;
  }
  __snprintf_chk(sockname.sun_path,0x6c,1,0x6c,"%s%s%s",pcVar22,pcVar21,port);
  sVar10 = strlen(sockname.sun_path);
  iVar7 = (int)sVar10;
  __len = iVar7 + 2;
  if (uVar20 != 0) {
    sockname.sun_path[0] = '\0';
  }
  iVar9 = connect(ciptr->fd,(sockaddr *)&sockname,__len);
  if (iVar9 < 0) {
    piVar11 = __errno_location();
    iVar9 = *piVar11;
    if ((iVar9 == 0xb) || (iVar9 == 0x73)) {
      iVar9 = -3;
    }
    else if (iVar9 == 4) {
      iVar9 = -2;
    }
    else if ((iVar9 == 2) || (iVar9 == 0x6f)) {
      iVar9 = -1;
      if (uVar20 != 0) {
        piVar11 = &ciptr->transptr->flags;
        *piVar11 = *piVar11 & 0xffffffdf;
        iVar9 = -2;
      }
    }
    else {
      prmsg(2,"SocketUNIXConnect: Can\'t connect: errno = %d\n");
      iVar9 = -1;
    }
    goto LAB_0012db28;
  }
  uVar14 = (ulong)__len;
  pcVar22 = (char *)malloc(uVar14);
  ciptr->addr = pcVar22;
  if (pcVar22 != (char *)0x0) {
    pcVar21 = (char *)malloc(uVar14);
    ciptr->peeraddr = pcVar21;
    if (pcVar21 != (char *)0x0) {
      if (uVar20 != 0) {
        sockname.sun_path[0] = '@';
      }
      ciptr->family = 1;
      ciptr->addrlen = __len;
      ciptr->peeraddrlen = __len;
      if (__len < 8) {
        if ((__len & 4) != 0) {
          *(undefined4 *)pcVar22 = sockname._0_4_;
          *(undefined4 *)(pcVar22 + (uVar14 - 4)) =
               *(undefined4 *)(sockname.sun_path + (uVar14 - 6));
          goto LAB_0012dca9;
        }
        if (__len != 0) {
          *pcVar22 = (char)sockname.sun_family;
          if ((__len & 2) != 0) {
            *(undefined2 *)(pcVar22 + (uVar14 - 2)) =
                 *(undefined2 *)(sockname.sun_path + (uVar14 - 4));
          }
          goto LAB_0012dca9;
        }
      }
      else {
        *(undefined8 *)(pcVar22 + (uVar14 - 8)) = *(undefined8 *)(sockname.sun_path + (uVar14 - 10))
        ;
        psVar16 = &sockname;
        for (uVar13 = (ulong)(iVar7 + 1U >> 3); uVar13 != 0; uVar13 = uVar13 - 1) {
          *(undefined8 *)pcVar22 = *(undefined8 *)psVar16;
          psVar16 = (sockaddr_un *)((long)psVar16 + (ulong)bVar26 * -0x10 + 8);
          pcVar22 = pcVar22 + (ulong)bVar26 * -0x10 + 8;
        }
LAB_0012dca9:
        if (7 < __len) {
          *(undefined8 *)(pcVar21 + (uVar14 - 8)) =
               *(undefined8 *)(sockname.sun_path + (uVar14 - 10));
          iVar9 = 0;
          psVar16 = &sockname;
          for (uVar14 = (ulong)(iVar7 + 1U >> 3); uVar14 != 0; uVar14 = uVar14 - 1) {
            *(undefined8 *)pcVar21 = *(undefined8 *)psVar16;
            psVar16 = (sockaddr_un *)((long)psVar16 + (ulong)bVar26 * -0x10 + 8);
            pcVar21 = pcVar21 + (ulong)bVar26 * -0x10 + 8;
          }
          goto LAB_0012db28;
        }
      }
      if ((__len & 4) == 0) {
        if ((__len == 0) || (*pcVar21 = (char)sockname.sun_family, (__len & 2) == 0)) {
          iVar9 = 0;
        }
        else {
          *(undefined2 *)(pcVar21 + (uVar14 - 2)) =
               *(undefined2 *)(sockname.sun_path + (uVar14 - 4));
          iVar9 = 0;
        }
      }
      else {
        *(undefined4 *)pcVar21 = sockname._0_4_;
        *(undefined4 *)(pcVar21 + (uVar14 - 4)) = *(undefined4 *)(sockname.sun_path + (uVar14 - 6));
        iVar9 = 0;
      }
      goto LAB_0012db28;
    }
  }
  prmsg(1,"SocketUNIXCreateListener: Can\'t allocate space for the addr\n");
  iVar9 = -1;
LAB_0012db28:
  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar9;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int _FontTransParseAddress(char *address,char **protocol,char **host,char **port)

{
  long lVar1;
  uint uVar2;
  int iVar3;
  byte *__s;
  byte *pbVar4;
  char *pcVar5;
  size_t sVar6;
  char *pcVar7;
  char *pcVar8;
  long lVar9;
  byte *pbVar10;
  byte *__s_00;
  long in_FS_OFFSET;
  bool bVar11;
  bool bVar12;
  bool bVar13;
  byte bVar14;
  sockaddr_in6 sin6;
  char hostnamebuf [256];
  
  bVar14 = 0;
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  prmsg(3,"ParseAddress(%s)\n",address);
  __s = (byte *)strdup(address);
  pbVar4 = (byte *)strchr((char *)__s,0x2f);
  if ((pbVar4 != (byte *)0x0) || (pbVar4 = (byte *)strrchr((char *)__s,0x3a), pbVar4 != (byte *)0x0)
     ) {
    if (*pbVar4 == 0x3a) {
      pcVar8 = "local";
      __s_00 = __s;
      if (pbVar4 != __s) {
        pcVar8 = &DAT_0013641d;
      }
    }
    else {
      *pbVar4 = 0;
      __s_00 = pbVar4 + 1;
      pcVar8 = (char *)__s;
      if ((*__s == 0) && (pcVar8 = &DAT_0013641d, pbVar4[1] == 0x3a)) {
        pcVar8 = "local";
      }
    }
    pcVar5 = strrchr((char *)__s_00,0x3a);
    if (pcVar5 != (char *)0x0) {
      *pcVar5 = '\0';
      sVar6 = strlen((char *)__s_00);
      uVar2 = (uint)sVar6;
      if (uVar2 == 0) {
        __s_00 = (byte *)hostnamebuf;
        _FontTransGetHostname((char *)__s_00,0x100);
      }
      else {
        bVar11 = uVar2 < 3;
        bVar13 = uVar2 == 3;
        if (3 < (int)uVar2) {
          lVar9 = 4;
          pbVar4 = (byte *)pcVar8;
          pbVar10 = &DAT_0013641d;
          do {
            if (lVar9 == 0) break;
            lVar9 = lVar9 + -1;
            bVar11 = *pbVar4 < *pbVar10;
            bVar13 = *pbVar4 == *pbVar10;
            pbVar4 = pbVar4 + (ulong)bVar14 * -2 + 1;
            pbVar10 = pbVar10 + (ulong)bVar14 * -2 + 1;
          } while (bVar13);
          bVar12 = false;
          bVar11 = (!bVar11 && !bVar13) == bVar11;
          if (!bVar11) {
            lVar9 = 6;
            pbVar4 = (byte *)pcVar8;
            pbVar10 = (byte *)"inet6";
            do {
              if (lVar9 == 0) break;
              lVar9 = lVar9 + -1;
              bVar12 = *pbVar4 < *pbVar10;
              bVar11 = *pbVar4 == *pbVar10;
              pbVar4 = pbVar4 + (ulong)bVar14 * -2 + 1;
              pbVar10 = pbVar10 + (ulong)bVar14 * -2 + 1;
            } while (bVar11);
            if ((!bVar12 && !bVar11) != bVar12) goto LAB_0012dfaa;
          }
          if ((*__s_00 == 0x5b) && (pbVar4 = __s_00 + (long)(int)uVar2 + -1, *pbVar4 == 0x5d)) {
            *pbVar4 = 0;
            iVar3 = inet_pton(10,(char *)(__s_00 + 1),&sin6);
            if (iVar3 == 1) {
              pcVar8 = "inet6";
              __s_00 = __s_00 + 1;
            }
            else {
              *pbVar4 = 0x5d;
            }
          }
        }
      }
LAB_0012dfaa:
      pcVar7 = strchr(pcVar5 + 1,0x2f);
      if (pcVar7 != (char *)0x0) {
        *pcVar7 = '\0';
      }
      pcVar8 = strdup(pcVar8);
      *protocol = pcVar8;
      if (pcVar8 == (char *)0x0) {
        *port = (char *)0x0;
        *host = (char *)0x0;
        *protocol = (char *)0x0;
        free(__s);
        iVar3 = 0;
      }
      else {
        pcVar8 = strdup((char *)__s_00);
        *host = pcVar8;
        if (pcVar8 == (char *)0x0) {
          *port = (char *)0x0;
        }
        else {
          pcVar8 = strdup(pcVar5 + 1);
          *port = pcVar8;
          if (pcVar8 != (char *)0x0) {
            free(__s);
            iVar3 = 1;
            goto LAB_0012e00e;
          }
          free(*host);
        }
        *host = (char *)0x0;
        free(*protocol);
        *protocol = (char *)0x0;
        free(__s);
        iVar3 = 0;
      }
      goto LAB_0012e00e;
    }
  }
  *protocol = (char *)0x0;
  *host = (char *)0x0;
  *port = (char *)0x0;
  free(__s);
  iVar3 = 0;
LAB_0012e00e:
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar3;
}



int _FontTransConnect(XtransConnInfo ciptr,char *address)

{
  int iVar1;
  long in_FS_OFFSET;
  char *protocol;
  char *host;
  char *port;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  prmsg(2,"Connect(%d,%s)\n",(ulong)(uint)ciptr->fd,address);
  iVar1 = _FontTransParseAddress(address,&protocol,&host,&port);
  if (iVar1 == 0) {
    iVar1 = -1;
    prmsg(1,"Connect: Unable to Parse address %s\n",address);
  }
  else {
    if ((port == (char *)0x0) || (*port == '\0')) {
      prmsg(1,"Connect: Missing port specification in %s\n",address);
      if (protocol != (char *)0x0) {
        free(protocol);
      }
      iVar1 = -1;
      port = host;
    }
    else {
      iVar1 = (*ciptr->transptr->Connect)(ciptr,host,port);
      if (protocol != (char *)0x0) {
        free(protocol);
      }
      if (host != (char *)0x0) {
        free(host);
      }
    }
    if (port != (char *)0x0) {
      free(port);
    }
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



XtransConnInfo _FontTransOpenCOTSClient(char *address)

{
  char *__s1;
  int iVar1;
  XtransConnInfo p_Var2;
  Xtransport *pXVar3;
  Xtransport_table *pXVar4;
  long in_FS_OFFSET;
  char *protocol;
  char *host;
  char *port;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  prmsg(2,"OpenCOTSClient(%s)\n",address);
  protocol = (char *)0x0;
  host = (char *)0x0;
  port = (char *)0x0;
  prmsg(2,"Open(%d,%s)\n",1,address);
  iVar1 = _FontTransParseAddress(address,&protocol,&host,&port);
  __s1 = protocol;
  if (iVar1 == 0) {
    p_Var2 = (XtransConnInfo)0x0;
    prmsg(1,"Open: Unable to Parse address %s\n",address);
  }
  else {
    pXVar4 = Xtransports;
    prmsg(3,"SelectTransport(%s)\n",protocol);
    pXVar3 = &_FontTransSocketTCPFuncs;
    iVar1 = strcasecmp(__s1,_FontTransSocketTCPFuncs.TransName);
    while (iVar1 != 0) {
      pXVar4 = (Xtransport_table *)((Elf64_Dyn *)pXVar4 + 1);
      if ((Elf64_Dyn *)pXVar4 == _DYNAMIC) {
        p_Var2 = (XtransConnInfo)0x0;
        prmsg(1,"Open: Unable to find transport for %s\n",protocol);
        free(protocol);
        free(host);
        free(port);
        goto LAB_0012e440;
      }
      pXVar3 = (Xtransport *)((Elf64_Dyn *)pXVar4)->d_tag;
      iVar1 = strcasecmp(__s1,pXVar3->TransName);
    }
    p_Var2 = (*pXVar3->OpenCOTSClient)(pXVar3,protocol,host,port);
    if (p_Var2 == (XtransConnInfo)0x0) {
      if ((*(byte *)&pXVar3->flags & 4) == 0) {
        prmsg(1,"Open: transport open failed for %s/%s:%s\n",protocol,host,port);
      }
      free(protocol);
      free(host);
      free(port);
    }
    else {
      p_Var2->transptr = pXVar3;
      p_Var2->port = port;
      free(protocol);
      free(host);
    }
  }
LAB_0012e440:
  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return p_Var2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Atom MakeAtom(char *string,uint len,int makeit)

{
  char *pcVar1;
  char cVar2;
  AtomListPtr p_Var3;
  int iVar4;
  uint uVar5;
  AtomListPtr p_Var6;
  ulong uVar7;
  AtomListPtr *pp_Var8;
  AtomListPtr *pp_Var9;
  uint uVar10;
  long lVar11;
  char *pcVar12;
  uint uVar13;
  AtomListPtr *pp_Var14;
  AtomListPtr *pp_Var15;
  int iVar16;
  int iVar17;
  size_t __size;
  int iVar18;
  
  pp_Var8 = hashTable;
  if (len == 0) {
    uVar5 = 0;
  }
  else {
    uVar5 = 0;
    pcVar12 = string;
    do {
      cVar2 = *pcVar12;
      pcVar12 = pcVar12 + 1;
      uVar5 = uVar5 << 3 ^ (int)cVar2;
    } while (pcVar12 != string + (ulong)(len - 1) + 1);
    uVar5 = (uVar5 ^ (int)uVar5 >> 0x1f) - ((int)uVar5 >> 0x1f);
  }
  if (hashTable == (AtomListPtr *)0x0) {
    uVar13 = 0;
  }
  else {
    uVar13 = hashMask & uVar5;
    p_Var6 = hashTable[(int)uVar13];
    if (p_Var6 != (AtomListPtr)0x0) {
      if ((p_Var6->hash == uVar5) && (p_Var6->len == len)) {
        uVar7 = 0;
        do {
          if (len == uVar7) {
            return p_Var6->atom;
          }
          pcVar12 = p_Var6->name + uVar7;
          pcVar1 = string + uVar7;
          uVar7 = uVar7 + 1;
        } while (*pcVar12 == *pcVar1);
      }
      while( true ) {
        uVar13 = uVar13 + ((int)uVar5 % rehash | 1U);
        if (hashSize <= (int)uVar13) {
          uVar13 = uVar13 - hashSize;
        }
        p_Var6 = hashTable[(int)uVar13];
        if (p_Var6 == (AtomListPtr)0x0) break;
        if ((p_Var6->hash == uVar5) && (p_Var6->len == len)) {
          uVar7 = 0;
          do {
            if (len == uVar7) {
              return p_Var6->atom;
            }
            pcVar12 = p_Var6->name + uVar7;
            pcVar1 = string + uVar7;
            uVar7 = uVar7 + 1;
          } while (*pcVar12 == *pcVar1);
        }
      }
    }
  }
  if (makeit == 0) {
    return 0;
  }
  uVar7 = (ulong)len;
  p_Var6 = (AtomListPtr)malloc(uVar7 + 0x19);
  if (p_Var6 == (AtomListPtr)0x0) {
    __fprintf_chk(_stderr,1,"MakeAtom(): Error: Couldn\'t allocate AtomListRec (%ld)\n",uVar7 + 0x19
                 );
    return 0;
  }
  p_Var6->len = len;
  p_Var6->name = (char *)(p_Var6 + 1);
  strncpy((char *)(p_Var6 + 1),string,uVar7);
  iVar16 = hashUsed;
  *(undefined *)((long)&p_Var6[1].name + uVar7) = 0;
  iVar4 = hashSize;
  lastAtom = lastAtom + 1;
  p_Var6->atom = lastAtom;
  p_Var6->hash = uVar5;
  if (iVar16 < iVar4 / 2) {
    pp_Var8 = pp_Var8 + (int)uVar13;
    goto LAB_0012e6d5;
  }
  if (iVar4 == 0) {
    pp_Var9 = (AtomListPtr *)calloc(0x400,8);
    lVar11 = 0x2000;
    if (pp_Var9 == (AtomListPtr *)0x0) goto LAB_0012e901;
    iVar17 = 0x3fd;
    uVar13 = 0x3ff;
    iVar18 = 0x400;
LAB_0012e850:
    free(pp_Var8);
    rehash = iVar17;
    hashMask = uVar13;
    hashSize = iVar18;
    hashTable = pp_Var9;
  }
  else {
    iVar18 = iVar4 * 2;
    pp_Var9 = (AtomListPtr *)calloc((long)iVar18,8);
    if (pp_Var9 != (AtomListPtr *)0x0) {
      uVar13 = iVar18 - 1;
      iVar17 = iVar18 + -3;
      if (0 < iVar4) {
        pp_Var15 = pp_Var8;
        do {
          p_Var3 = *pp_Var15;
          if (p_Var3 != (AtomListPtr)0x0) {
            uVar10 = uVar13 & p_Var3->hash;
            pp_Var14 = pp_Var9 + (int)uVar10;
            if (*pp_Var14 != (AtomListPtr)0x0) {
              do {
                uVar10 = uVar10 + (p_Var3->hash % iVar17 | 1U);
                if (iVar18 <= (int)uVar10) {
                  uVar10 = uVar10 + iVar4 * -2;
                }
                pp_Var14 = pp_Var9 + (int)uVar10;
              } while (*pp_Var14 != (AtomListPtr)0x0);
            }
            *pp_Var14 = p_Var3;
          }
          pp_Var15 = pp_Var15 + 1;
        } while (pp_Var8 + (ulong)(iVar4 - 1) + 1 != pp_Var15);
      }
      goto LAB_0012e850;
    }
    lVar11 = (long)iVar18 * 8;
LAB_0012e901:
    __fprintf_chk(_stderr,1,"ResizeHashTable(): Error: Couldn\'t allocate newHashTable (%ld)\n",
                  lVar11);
    iVar16 = hashUsed;
  }
  uVar13 = hashMask & uVar5;
  pp_Var8 = hashTable + (int)uVar13;
  if (*pp_Var8 != (AtomListPtr)0x0) {
    do {
      uVar13 = uVar13 + ((int)uVar5 % rehash | 1U);
      if (hashSize <= (int)uVar13) {
        uVar13 = uVar13 - hashSize;
      }
      pp_Var8 = hashTable + (int)uVar13;
    } while (*pp_Var8 != (AtomListPtr)0x0);
  }
LAB_0012e6d5:
  *pp_Var8 = p_Var6;
  hashUsed = iVar16 + 1;
  uVar7 = p_Var6->atom;
  if ((ulong)(long)reverseMapSize <= uVar7) {
    if (reverseMapSize == 0) {
      __size = 8000;
      iVar16 = 1000;
    }
    else {
      iVar16 = reverseMapSize * 2;
      __size = (long)iVar16 << 3;
    }
    pp_Var8 = (AtomListPtr *)realloc(reverseMap,__size);
    if (pp_Var8 == (AtomListPtr *)0x0) {
      __fprintf_chk(_stderr,1,"ResizeReverseMap(): Error: Couldn\'t reallocate reverseMap (%ld)\n",
                    __size);
      return 0;
    }
    uVar7 = p_Var6->atom;
    reverseMapSize = iVar16;
    reverseMap = pp_Var8;
  }
  reverseMap[uVar7] = p_Var6;
  return p_Var6->atom;
}



// WARNING: Unknown calling convention

int ValidAtom(Atom atom)

{
  uint uVar1;
  
  uVar1 = 0;
  if (atom != 0) {
    uVar1 = (uint)(atom <= lastAtom);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

char * NameForAtom(Atom atom)

{
  char *pcVar1;
  
  pcVar1 = (char *)0x0;
  if ((atom != 0) && (atom <= lastAtom)) {
    pcVar1 = reverseMap[atom]->name;
  }
  return pcVar1;
}



// WARNING: Unknown calling convention

void FontComputeInfoAccelerators(FontInfoPtr pFontInfo)

{
  short sVar1;
  short sVar2;
  short sVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  short sVar7;
  int iVar8;
  int iVar9;
  byte bVar10;
  uint uVar11;
  
  sVar1 = (pFontInfo->minbounds).leftSideBearing;
  sVar2 = (pFontInfo->minbounds).ascent;
  sVar3 = (pFontInfo->maxbounds).ascent;
  sVar4 = (pFontInfo->minbounds).characterWidth;
  bVar10 = pFontInfo->field_0xa | 1;
  if (sVar1 < pFontInfo->maxOverlap) {
    bVar10 = pFontInfo->field_0xa & 0xfe;
  }
  sVar5 = (pFontInfo->maxbounds).characterWidth;
  pFontInfo->field_0xa = bVar10;
  if ((((sVar2 == sVar3) &&
       (sVar6 = (pFontInfo->maxbounds).descent, (pFontInfo->minbounds).descent == sVar6)) &&
      (iVar8._0_2_ = (pFontInfo->maxbounds).leftSideBearing,
      iVar8._2_2_ = (pFontInfo->maxbounds).rightSideBearing,
      iVar9._0_2_ = (pFontInfo->minbounds).leftSideBearing,
      iVar9._2_2_ = (pFontInfo->minbounds).rightSideBearing, iVar9 == iVar8)) &&
     ((sVar5 == sVar4 && ((pFontInfo->minbounds).attributes == (pFontInfo->maxbounds).attributes))))
  {
    sVar7 = (pFontInfo->maxbounds).leftSideBearing;
    pFontInfo->field_0xa = bVar10 | 4;
    if (((sVar7 == 0) &&
        (((pFontInfo->maxbounds).rightSideBearing == sVar5 && (sVar2 == pFontInfo->fontAscent)))) &&
       (sVar6 == pFontInfo->fontDescent)) {
      pFontInfo->field_0xa = bVar10 | 6;
    }
    else {
      pFontInfo->field_0xa = pFontInfo->field_0xa & 0xfd;
    }
  }
  else {
    pFontInfo->field_0xa = pFontInfo->field_0xa & 0xf9;
  }
  pFontInfo->field_0xa = pFontInfo->field_0xa & 0xf7 | (sVar5 == sVar4) * '\b';
  bVar10 = (byte)~(byte)((ushort)sVar1 >> 8) >> 7 & pFontInfo->maxOverlap < 1;
  uVar11 = (uint)bVar10;
  if (bVar10 != 0) {
    sVar1 = pFontInfo->fontDescent;
    uVar11 = 0;
    if (((SBORROW4((int)sVar2,-(int)sVar1) == (int)sVar2 + (int)sVar1 < 0) &&
        (sVar3 <= pFontInfo->fontAscent)) &&
       (-(int)(pFontInfo->minbounds).descent <= (int)pFontInfo->fontAscent)) {
      uVar11 = (uint)((pFontInfo->maxbounds).descent <= sVar1);
    }
  }
  pFontInfo->field_0xa = (byte)(uVar11 << 4) | pFontInfo->field_0xa & 0xef;
  return;
}



// WARNING: Unknown calling convention

int FontCouldBeTerminal(FontInfoPtr pFontInfo)

{
  short sVar1;
  short sVar2;
  short sVar3;
  int iVar4;
  int iVar5;
  
  if (((((pFontInfo->minbounds).leftSideBearing < 0) ||
       (sVar1 = (pFontInfo->maxbounds).characterWidth,
       sVar1 < (pFontInfo->maxbounds).rightSideBearing)) ||
      (sVar1 != (pFontInfo->minbounds).characterWidth)) ||
     ((sVar2 = (pFontInfo->maxbounds).ascent, pFontInfo->fontAscent < sVar2 ||
      (sVar3 = (pFontInfo->maxbounds).descent, pFontInfo->fontDescent < sVar3)))) {
    return 0;
  }
  if (((pFontInfo->maxbounds).leftSideBearing == 0) &&
     ((sVar1 == (pFontInfo->minbounds).rightSideBearing &&
      (iVar4._0_2_ = (pFontInfo->minbounds).ascent, iVar4._2_2_ = (pFontInfo->minbounds).descent,
      iVar5._0_2_ = pFontInfo->fontAscent, iVar5._2_2_ = pFontInfo->fontDescent, iVar5 == iVar4))))
  {
    return 0;
  }
  return (int)(sVar2 != 0 || sVar3 != 0);
}



void FreeFontNames(FontNamesPtr pFN)

{
  char **ppcVar1;
  long lVar2;
  
  if (pFN != (FontNamesPtr)0x0) {
    if (0 < pFN->nnames) {
      lVar2 = 0;
      do {
        ppcVar1 = pFN->names + lVar2;
        lVar2 = lVar2 + 1;
        free(*ppcVar1);
      } while ((int)lVar2 < pFN->nnames);
    }
    free(pFN->names);
    free(pFN->length);
    free(pFN);
    return;
  }
  return;
}



FontNamesPtr MakeFontNamesRecord(uint size)

{
  FontNamesPtr __ptr;
  int *__ptr_00;
  char **__ptr_01;
  FontNamesPtr p_Var1;
  
  __ptr = (FontNamesPtr)malloc(0x18);
  p_Var1 = __ptr;
  if (__ptr != (FontNamesPtr)0x0) {
    __ptr->nnames = 0;
    __ptr->size = size;
    if (size == 0) {
      __ptr->length = (int *)0x0;
      __ptr->names = (char **)0x0;
    }
    else {
      __ptr_00 = (int *)malloc((ulong)size * 4);
      __ptr->length = __ptr_00;
      __ptr_01 = (char **)malloc((ulong)size * 8);
      __ptr->names = __ptr_01;
      if ((__ptr_00 == (int *)0x0) || (__ptr_01 == (char **)0x0)) {
        free(__ptr_00);
        free(__ptr_01);
        p_Var1 = (FontNamesPtr)0x0;
        free(__ptr);
      }
    }
  }
  return p_Var1;
}



int AddFontNamesName(FontNamesPtr names,char *name,int length)

{
  int iVar1;
  char *__dest;
  int *__ptr;
  char **__ptr_00;
  int iVar2;
  size_t __size;
  size_t __size_00;
  
  iVar1 = names->nnames;
  __dest = (char *)malloc((long)(length + 1));
  if (__dest == (char *)0x0) {
    iVar1 = 0x50;
  }
  else {
    __ptr = names->length;
    if (names->size <= iVar1) {
      iVar2 = names->size * 2;
      if (iVar2 == 0) {
        __size_00 = 0x40;
        __size = 0x20;
        iVar2 = 8;
      }
      else {
        __size = (long)iVar2 * 4;
        __size_00 = (long)iVar2 << 3;
      }
      __ptr = (int *)realloc(__ptr,__size);
      __ptr_00 = (char **)realloc(names->names,__size_00);
      if ((__ptr == (int *)0x0) || (__ptr_00 == (char **)0x0)) {
        free(__dest);
        free(__ptr);
        free(__ptr_00);
        return 0x50;
      }
      names->length = __ptr;
      names->names = __ptr_00;
      names->size = iVar2;
    }
    __ptr[iVar1] = length;
    names->names[iVar1] = __dest;
    strncpy(__dest,name,(long)length);
    names->nnames = names->nnames + 1;
    iVar1 = 0x55;
    __dest[length] = '\0';
  }
  return iVar1;
}



void GetGlyphs(FontPtr font,ulong count,uchar *chars,FontEncoding fontEncoding,ulong *glyphcount,
              CharInfoPtr *glyphs)

{
                    // WARNING: Could not recover jumptable at 0x0012edb4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*font->get_glyphs)(font,count,chars,fontEncoding,glyphcount,glyphs);
  return;
}



void QueryGlyphExtents(FontPtr pFont,CharInfoPtr *charinfo,ulong count,ExtentInfoRec *info)

{
  short sVar1;
  int iVar2;
  CharInfoPtr p_Var3;
  int iVar4;
  ulong uVar5;
  
  info->drawDirection = *(ushort *)&(pFont->info).field_0xa >> 7 & 3;
  info->fontAscent = (int)(pFont->info).fontAscent;
  info->fontDescent = (int)(pFont->info).fontDescent;
  if (count == 0) {
    info->overallAscent = 0;
    info->overallDescent = 0;
    info->overallWidth = 0;
    info->overallLeft = 0;
    info->overallRight = 0;
    return;
  }
  p_Var3 = *charinfo;
  sVar1 = (p_Var3->metrics).ascent;
  if (((((p_Var3->metrics).characterWidth != 0) || ((p_Var3->metrics).rightSideBearing != 0)) ||
      (sVar1 != 0 || (p_Var3->metrics).leftSideBearing != 0)) || ((p_Var3->metrics).descent != 0)) {
    info->overallAscent = (int)sVar1;
    info->overallDescent = (int)(p_Var3->metrics).descent;
    info->overallLeft = (int)(p_Var3->metrics).leftSideBearing;
    info->overallRight = (int)(p_Var3->metrics).rightSideBearing;
    info->overallWidth = (int)(p_Var3->metrics).characterWidth;
  }
  if (((pFont->info).field_0xa & 5) != 5) {
    uVar5 = 1;
    if (count < 2) {
      return;
    }
    do {
      p_Var3 = charinfo[uVar5];
      sVar1 = (p_Var3->metrics).ascent;
      if ((((p_Var3->metrics).characterWidth != 0) || ((p_Var3->metrics).rightSideBearing != 0)) ||
         ((sVar1 != 0 || (p_Var3->metrics).leftSideBearing != 0 || ((p_Var3->metrics).descent != 0))
         )) {
        iVar4 = (int)sVar1;
        if ((int)sVar1 <= info->overallAscent) {
          iVar4 = info->overallAscent;
        }
        info->overallAscent = iVar4;
        iVar4 = (int)(p_Var3->metrics).descent;
        if (iVar4 < info->overallDescent) {
          iVar4 = info->overallDescent;
        }
        iVar2 = info->overallWidth;
        info->overallDescent = iVar4;
        iVar4 = (p_Var3->metrics).leftSideBearing + iVar2;
        if (info->overallLeft < iVar4) {
          iVar4 = info->overallLeft;
        }
        info->overallLeft = iVar4;
        iVar4 = (p_Var3->metrics).rightSideBearing + iVar2;
        if (iVar4 < info->overallRight) {
          iVar4 = info->overallRight;
        }
        info->overallRight = iVar4;
        info->overallWidth = (p_Var3->metrics).characterWidth + iVar2;
      }
      uVar5 = uVar5 + 1;
    } while (count != uVar5);
    return;
  }
  iVar4 = (int)count * info->overallWidth;
  info->overallWidth = iVar4;
  info->overallRight = info->overallRight + (iVar4 - (p_Var3->metrics).characterWidth);
  return;
}



Bool QueryTextExtents(FontPtr pFont,ulong count,uchar *chars,ExtentInfoRec *info)

{
  byte bVar1;
  ushort uVar2;
  long lVar3;
  xCharInfo *pxVar4;
  FontEncoding FVar5;
  Bool BVar6;
  xCharInfo **__ptr;
  ulong uVar7;
  int iVar8;
  ulong uVar9;
  ulong uVar10;
  long in_FS_OFFSET;
  ulong n;
  ulong t;
  xCharInfo *defaultChar;
  uchar defc [2];
  
  lVar3 = *(long *)(in_FS_OFFSET + 0x28);
  defaultChar = (xCharInfo *)0x0;
  __ptr = (xCharInfo **)malloc(count * 8);
  if (__ptr == (xCharInfo **)0x0) {
    BVar6 = 0;
    goto LAB_0012f0b1;
  }
  FVar5 = SUB14((pFont->info).lastRow != 0,0) + Linear16Bit;
  (*pFont->get_metrics)(pFont,count,chars,FVar5,&n,__ptr);
  uVar2 = (pFont->info).defaultCh;
  defc = (uchar  [2])(uVar2 << 8 | uVar2 >> 8);
  iVar8 = (int)n;
  uVar10 = n & 0xffffffff;
  (*pFont->get_metrics)(pFont,1,defc,FVar5,&t,&defaultChar);
  if ((defaultChar == (xCharInfo *)0x0) ||
     ((((defaultChar->ascent == 0 && (defaultChar->descent == 0)) &&
       (defaultChar->leftSideBearing == 0)) &&
      ((defaultChar->rightSideBearing == 0 && (defaultChar->characterWidth == 0)))))) {
    defaultChar = (xCharInfo *)0x0;
    if (n == 0) goto LAB_0012f147;
LAB_0012f014:
    uVar7 = 0;
    do {
      pxVar4 = __ptr[uVar7];
      uVar9 = (ulong)(int)uVar10;
      if ((pxVar4 == (xCharInfo *)0x0) ||
         (((pxVar4->ascent == 0 && (pxVar4->descent == 0)) &&
          ((pxVar4->leftSideBearing == 0 &&
           ((pxVar4->rightSideBearing == 0 && (pxVar4->characterWidth == 0)))))))) {
        if (defaultChar != (xCharInfo *)0x0) {
          __ptr[uVar7] = defaultChar;
          goto LAB_0012f058;
        }
      }
      else {
LAB_0012f058:
        if (n == uVar9) {
          uVar10 = uVar7 & 0xffffffff;
          uVar9 = uVar7;
        }
      }
      uVar7 = uVar7 + 1;
    } while (n != uVar7);
  }
  else {
    if (n != 0) goto LAB_0012f014;
LAB_0012f147:
    uVar9 = (ulong)iVar8;
  }
  bVar1 = (pFont->info).field_0xa;
  (pFont->info).field_0xa = bVar1 & 0xfb;
  QueryGlyphExtents(pFont,(CharInfoPtr *)(__ptr + uVar9),n - uVar9,info);
  (pFont->info).field_0xa = (pFont->info).field_0xa & 0xfb | (byte)((bVar1 >> 2 & 1) << 2);
  free(__ptr);
  BVar6 = 1;
LAB_0012f0b1:
  if (lVar3 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar6;
}



Bool ParseGlyphCachingMode(char *str)

{
  long lVar1;
  byte *pbVar2;
  byte *pbVar3;
  undefined in_CF;
  bool bVar4;
  undefined in_ZF;
  bool bVar5;
  
  lVar1 = 5;
  pbVar2 = (byte *)str;
  pbVar3 = &DAT_00136c49;
  do {
    if (lVar1 == 0) break;
    lVar1 = lVar1 + -1;
    in_CF = *pbVar2 < *pbVar3;
    in_ZF = *pbVar2 == *pbVar3;
    pbVar2 = pbVar2 + 1;
    pbVar3 = pbVar3 + 1;
  } while ((bool)in_ZF);
  bVar4 = false;
  bVar5 = (!(bool)in_CF && !(bool)in_ZF) == (bool)in_CF;
  if (bVar5) {
    defaultGlyphCachingMode = 0;
    return 1;
  }
  lVar1 = 4;
  pbVar2 = (byte *)str;
  pbVar3 = &DAT_00136c4e;
  do {
    if (lVar1 == 0) break;
    lVar1 = lVar1 + -1;
    bVar4 = *pbVar2 < *pbVar3;
    bVar5 = *pbVar2 == *pbVar3;
    pbVar2 = pbVar2 + 1;
    pbVar3 = pbVar3 + 1;
  } while (bVar5);
  if ((!bVar4 && !bVar5) == bVar4) {
    defaultGlyphCachingMode = 2;
    return 1;
  }
  if (((*str == '1') && (str[1] == '6')) && (str[2] == '\0')) {
    defaultGlyphCachingMode = 1;
    return 1;
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void InitGlyphCaching(void)

{
  glyphCachingMode = defaultGlyphCachingMode;
  return;
}



// WARNING: Unknown calling convention

void SetGlyphCachingMode(int newmode)

{
  if ((newmode < glyphCachingMode) && (-1 < newmode)) {
    glyphCachingMode = newmode;
    return;
  }
  return;
}



int add_range(fsRange *newrange,int *nranges,fsRange **range,Bool charset_subset)

{
  byte bVar1;
  long lVar2;
  ushort uVar3;
  uint uVar4;
  ulong uVar5;
  ulong uVar6;
  void *pvVar7;
  fsRange *pfVar8;
  int iVar9;
  fsRange *pfVar10;
  uint uVar11;
  uint uVar12;
  fsRange *pfVar13;
  byte bVar14;
  int iVar15;
  fsRange *pfVar16;
  fsRange *__dest;
  int iVar17;
  fsRange *pfVar18;
  ulong uVar19;
  ulong uVar20;
  ushort uVar21;
  int iVar22;
  long in_FS_OFFSET;
  ulong local_60;
  uint local_54;
  fsRange temprange;
  
  bVar14 = newrange->min_char_high;
  uVar4 = (uint)bVar14;
  lVar2 = *(long *)(in_FS_OFFSET + 0x28);
  uVar11 = (uint)newrange->max_char_high;
  if (charset_subset == 0) {
    if (bVar14 != newrange->max_char_high) {
      if (uVar11 < bVar14) {
        iVar15 = 0;
      }
      else {
        do {
          temprange.min_char_low = newrange->min_char_low;
          temprange.min_char_high = (CARD8)uVar4;
          temprange.max_char_low = newrange->max_char_low;
          temprange.max_char_high = temprange.min_char_high;
          iVar15 = add_range(&temprange,nranges,range,0);
          if (iVar15 != 0x55) break;
          uVar4 = uVar4 + 1;
        } while ((int)uVar4 <= (int)(uint)newrange->max_char_high);
      }
      goto LAB_0012f3cc;
    }
    uVar6 = (long)(int)((uint)bVar14 * 0x100 + (uint)newrange->min_char_low);
    local_60 = (long)(int)(uVar11 * 0x100 + (uint)newrange->max_char_low);
  }
  else {
    local_60 = (ulong)(int)((uint)bVar14 * 0x100 + (uint)newrange->min_char_low);
    uVar19 = (ulong)(int)((uint)newrange->max_char_low + uVar11 * 0x100);
    uVar6 = uVar19;
    if (local_60 <= uVar19) {
      uVar6 = local_60;
      local_60 = uVar19;
    }
  }
  local_54 = *nranges;
  iVar15 = local_54 - 1;
  uVar21 = (ushort)uVar6;
  uVar3 = (ushort)local_60;
  if (iVar15 < 0) {
    uVar19 = 0;
    iVar17 = 0;
  }
  else {
    iVar9 = 0;
    do {
      while( true ) {
        iVar17 = iVar9 + iVar15 >> 1;
        pfVar8 = *range + iVar17;
        bVar1 = pfVar8->min_char_high;
        uVar20 = (ulong)bVar1;
        uVar11 = (uint)pfVar8->min_char_low;
        iVar22 = (uint)bVar1 * 0x100 + uVar11;
        uVar12 = (uint)pfVar8->max_char_low;
        uVar19 = (ulong)iVar22;
        uVar4 = (uint)pfVar8->max_char_high;
        uVar5 = (ulong)(int)((uint)pfVar8->max_char_high * 0x100 + uVar12);
        if ((iVar22 != 0) && (local_60 < uVar19 - 1)) break;
        if (uVar6 <= uVar5 + 1) {
          if ((bVar1 != bVar14) && (charset_subset == 0)) {
            iVar15 = iVar9 + -1;
          }
          if (iVar9 <= iVar15) {
            if (uVar6 < uVar19) {
              uVar11 = (uint)(byte)uVar6;
              uVar20 = uVar6 >> 8;
              uVar21 = uVar21 << 8 | uVar21 >> 8;
              pfVar8->min_char_high = (char)uVar21;
              pfVar8->min_char_low = (char)(uVar21 >> 8);
              uVar19 = (ulong)(int)((int)(uVar6 >> 8) * 0x100 + ((uint)uVar6 & 0xff));
            }
            if (uVar5 < local_60) {
              uVar12 = (uint)(byte)local_60;
              uVar3 = uVar3 << 8 | uVar3 >> 8;
              pfVar8->max_char_high = (char)uVar3;
              pfVar8->max_char_low = (char)(uVar3 >> 8);
              uVar4 = (uint)(local_60 >> 8);
              uVar5 = (ulong)(int)(uVar4 * 0x100 + ((uint)local_60 & 0xff));
            }
            pfVar10 = *range;
            pfVar13 = pfVar10 + *nranges;
            bVar14 = (byte)uVar20;
            if (pfVar8 < pfVar10) {
              __dest = pfVar8 + 1;
              pfVar18 = pfVar8;
              goto LAB_0012f55e;
            }
            uVar4 = uVar4 & 0xff;
            pfVar16 = pfVar8;
            goto LAB_0012f548;
          }
          goto LAB_0012f349;
        }
        iVar9 = iVar17 + 1;
        if (iVar15 < iVar9) goto LAB_0012f349;
      }
      iVar15 = iVar17 + -1;
    } while (iVar9 <= iVar15);
  }
LAB_0012f349:
  if ((local_54 == 0) || (pfVar8 = *range, pfVar8 == (fsRange *)0x0)) {
    pfVar8 = (fsRange *)malloc(0x40);
    *range = pfVar8;
    *nranges = 0;
    pfVar8 = *range;
    if (pfVar8 == (fsRange *)0x0) {
LAB_0012f692:
      *nranges = 0;
      iVar15 = 0x50;
      goto LAB_0012f3cc;
    }
    local_54 = 0;
    pfVar10 = pfVar8 + iVar17;
    pfVar13 = pfVar10 + 1;
  }
  else {
    if ((local_54 & 0xf) == 0) {
      pfVar8 = (fsRange *)realloc(pfVar8,(long)(int)(local_54 * 4 + 0x40));
      *range = pfVar8;
      if (pfVar8 == (fsRange *)0x0) goto LAB_0012f692;
      local_54 = *nranges;
    }
    pfVar10 = pfVar8 + iVar17;
    pfVar16 = pfVar10 + 1;
    pfVar13 = pfVar16;
    if ((uVar19 < uVar6) && (iVar17 < (int)local_54)) {
      pfVar13 = pfVar10 + 2;
      pfVar10 = pfVar16;
    }
  }
  uVar21 = uVar21 << 8 | uVar21 >> 8;
  memmove(pfVar13,pfVar10,(long)pfVar8 + ((long)(int)local_54 * 4 - (long)pfVar10));
  pfVar10->min_char_high = (char)uVar21;
  pfVar10->min_char_low = (char)(uVar21 >> 8);
  uVar3 = uVar3 << 8 | uVar3 >> 8;
  pfVar10->max_char_high = (char)uVar3;
  pfVar10->max_char_low = (char)(uVar3 >> 8);
  *nranges = *nranges + 1;
  iVar15 = 0x55;
LAB_0012f3cc:
  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar15;
LAB_0012f548:
  if (((ulong)(long)(int)(uVar4 * 0x100 + 1 + uVar12) < uVar19) ||
     ((charset_subset == 0 && (bVar14 != pfVar16->min_char_high)))) goto LAB_0012f557;
  pfVar18 = pfVar16 + -1;
  uVar6 = (ulong)(int)((uint)pfVar16->min_char_high * 0x100 + (uint)pfVar16->min_char_low);
  if (uVar6 < uVar19) {
    uVar19 = uVar6;
  }
  __dest = pfVar16;
  if (pfVar18 < pfVar10) goto LAB_0012f55e;
  uVar12 = (uint)pfVar16[-1].max_char_low;
  uVar4 = (uint)pfVar16[-1].max_char_high;
  pfVar16 = pfVar18;
  goto LAB_0012f548;
LAB_0012f557:
  __dest = pfVar16 + 1;
  pfVar18 = pfVar16;
LAB_0012f55e:
  if (pfVar8 < pfVar13) {
    while( true ) {
      if ((((char)uVar11 != '\0' || (byte)uVar20 != 0) &&
          (uVar5 < (ulong)(long)(int)(((uint)uVar20 & 0xff) * 0x100 + -1 + uVar11))) ||
         ((charset_subset == 0 && (bVar14 != (byte)uVar20)))) goto LAB_0012f6b0;
      uVar6 = (ulong)(int)((uint)pfVar8->max_char_high * 0x100 + (uint)pfVar8->max_char_low);
      if (uVar5 < uVar6) {
        uVar5 = uVar6;
      }
      if (pfVar13 <= pfVar8 + 1) break;
      uVar11 = (uint)pfVar8[1].min_char_low;
      uVar20 = (ulong)pfVar8[1].min_char_high;
      pfVar8 = pfVar8 + 1;
    }
  }
  else {
LAB_0012f6b0:
    pfVar8 = pfVar8 + -1;
  }
  if (__dest != pfVar8) {
    pvVar7 = memmove(__dest,pfVar8,(long)pfVar13 - (long)pfVar8);
    *nranges = *nranges - (int)((long)pfVar8 - (long)pvVar7 >> 2);
  }
  uVar21 = (ushort)uVar19 << 8 | (ushort)uVar19 >> 8;
  uVar3 = (ushort)uVar5 << 8 | (ushort)uVar5 >> 8;
  iVar15 = 0x55;
  pfVar18[1].min_char_high = (char)uVar21;
  pfVar18[1].min_char_low = (char)(uVar21 >> 8);
  pfVar18[1].max_char_high = (char)uVar3;
  pfVar18[1].max_char_low = (char)(uVar3 >> 8);
  goto LAB_0012f3cc;
}



char * readreal(char *ptr,double *result)

{
  long lVar1;
  char *pcVar2;
  char cVar3;
  char *pcVar4;
  char *pcVar5;
  long in_FS_OFFSET;
  double dVar6;
  char *p1;
  char buffer [80];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  if (locale == (lconv *)0x0) {
    locale = (lconv *)localeconv();
    pcVar4 = ((lconv *)locale)->decimal_point;
    if ((pcVar4 != (char *)0x0) && (*pcVar4 != '\0')) {
      radix = pcVar4;
    }
    pcVar4 = ((lconv *)locale)->positive_sign;
    if ((pcVar4 != (char *)0x0) && (*pcVar4 != '\0')) {
      plus = pcVar4;
    }
    pcVar4 = ((lconv *)locale)->negative_sign;
    if ((pcVar4 != (char *)0x0) && (*pcVar4 != '\0')) {
      minus = pcVar4;
    }
  }
  cVar3 = *ptr;
  if (cVar3 == '\0') {
    pcVar4 = buffer;
    p1 = ptr;
  }
  else {
    pcVar2 = ptr + 1;
    pcVar5 = buffer;
    do {
      p1 = pcVar2;
      if (cVar3 == '.') {
        *pcVar5 = *radix;
LAB_0012f772:
        cVar3 = *p1;
      }
      else {
        if (cVar3 != '~') {
          if (cVar3 == '+') {
            *pcVar5 = *plus;
          }
          else {
            *pcVar5 = cVar3;
          }
          goto LAB_0012f772;
        }
        *pcVar5 = *minus;
        cVar3 = *p1;
      }
      pcVar4 = pcVar5 + 1;
      if (cVar3 == '\0') break;
      pcVar4 = pcVar5 + 1;
      pcVar2 = p1 + 1;
      pcVar5 = pcVar4;
    } while ((ulong)((long)pcVar4 - (long)buffer) < 0x4f);
  }
  *pcVar4 = '\0';
  dVar6 = strtod(buffer,&p1);
  *result = dVar6;
  pcVar4 = (char *)0x0;
  if (p1 != buffer) {
    pcVar4 = ptr + ((long)p1 - (long)buffer);
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pcVar4;
}



char * GetMatrix(char *ptr,FontScalablePtr vals,int which)

{
  char cVar1;
  byte bVar2;
  ushort *puVar3;
  ushort **ppuVar4;
  char *pcVar5;
  int iVar6;
  ulong uVar7;
  uint uVar8;
  uint uVar9;
  double *result;
  
  result = vals->pixel_matrix;
  if ((which == 3) || (result = vals->point_matrix, which == 0xc)) {
    ppuVar4 = __ctype_b_loc();
    while( true ) {
      cVar1 = *ptr;
      uVar7 = (ulong)cVar1;
      if ((*(byte *)((long)*ppuVar4 + uVar7 * 2 + 1) & 0x20) == 0) break;
      ptr = ptr + 1;
    }
    if (cVar1 == '[') {
      pcVar5 = readreal(ptr + 1,result);
      if ((((pcVar5 != (char *)0x0) && (pcVar5 = readreal(pcVar5,result + 1), pcVar5 != (char *)0x0)
           ) && (pcVar5 = readreal(pcVar5,result + 2), pcVar5 != (char *)0x0)) &&
         (pcVar5 = readreal(pcVar5,result + 3), pcVar5 != (char *)0x0)) {
        cVar1 = *pcVar5;
        puVar3 = *ppuVar4;
        bVar2 = *(byte *)((long)puVar3 + (long)cVar1 * 2 + 1);
        while ((bVar2 & 0x20) != 0) {
          cVar1 = pcVar5[1];
          pcVar5 = pcVar5 + 1;
          bVar2 = *(byte *)((long)puVar3 + (long)cVar1 * 2 + 1);
        }
        if (cVar1 == ']') {
          cVar1 = pcVar5[1];
          bVar2 = *(byte *)((long)puVar3 + (long)cVar1 * 2 + 1);
          while (pcVar5 = pcVar5 + 1, (bVar2 & 0x20) != 0) {
            cVar1 = pcVar5[1];
            bVar2 = *(byte *)((long)puVar3 + (long)cVar1 * 2 + 1);
          }
          if (cVar1 == '-') {
            uVar9 = vals->values_supplied | 8;
            if (which != 0xc) {
              uVar9 = vals->values_supplied | 2;
            }
            vals->values_supplied = uVar9;
            return pcVar5;
          }
        }
      }
    }
    else if (cVar1 == '*') {
      if (ptr[1] == '-') {
        uVar8 = ~which & vals->values_supplied;
        uVar9 = uVar8 | 0x10;
        if (which == 0xc) {
          uVar9 = uVar8 | 0x20;
        }
        vals->values_supplied = uVar9;
        return ptr + 1;
      }
    }
    else {
      iVar6 = 0;
      if ((byte)(cVar1 - 0x30U) < 10) {
        do {
          ptr = ptr + 1;
          iVar6 = (int)uVar7 + -0x30 + iVar6 * 10;
          cVar1 = *ptr;
          uVar7 = (ulong)(uint)(int)cVar1;
        } while ((byte)(cVar1 - 0x30U) < 10);
        if (cVar1 == '-') {
          vals->values_supplied = vals->values_supplied & ~which;
          if (iVar6 == 0) {
            return ptr;
          }
          result[3] = (double)iVar6;
          if (which == 0xc) {
            result[3] = (double)iVar6 / 10.0;
            vals->values_supplied = vals->values_supplied | 4;
          }
          else {
            vals->values_supplied = vals->values_supplied | 1;
          }
          result[2] = 0.0;
          result[1] = 0.0;
          *result = result[3];
          return ptr;
        }
      }
      else if (cVar1 == '-') {
        vals->values_supplied = vals->values_supplied & ~which;
        return ptr;
      }
    }
  }
  return (char *)0x0;
}



char * xlfd_double_to_text(double value,char *buffer,int space_required)

{
  byte bVar1;
  byte *pbVar2;
  byte *pbVar3;
  byte *pbVar4;
  byte bVar5;
  ushort uVar6;
  int iVar7;
  size_t sVar8;
  long lVar9;
  ushort **ppuVar10;
  char *pcVar11;
  byte *pbVar12;
  byte *pbVar13;
  int iVar14;
  
  if (locale == (lconv *)0x0) {
    locale = (lconv *)localeconv();
    pcVar11 = ((lconv *)locale)->decimal_point;
    if ((pcVar11 != (char *)0x0) && (*pcVar11 != '\0')) {
      radix = pcVar11;
    }
    pcVar11 = ((lconv *)locale)->positive_sign;
    if ((pcVar11 != (char *)0x0) && (*pcVar11 != '\0')) {
      plus = pcVar11;
    }
    pcVar11 = ((lconv *)locale)->negative_sign;
    if ((pcVar11 != (char *)0x0) && (*pcVar11 != '\0')) {
      minus = pcVar11;
    }
  }
  if (space_required != 0) {
    *buffer = ' ';
    buffer = buffer + 1;
  }
  __sprintf_chk(value,buffer,1,0xffffffffffffffff,"%.*le");
  sVar8 = strlen(buffer);
  pbVar13 = (byte *)buffer + sVar8;
  do {
    pbVar12 = pbVar13;
    pbVar13 = pbVar12 + -1;
  } while ((*pbVar12 & 0xdf) != 0x45);
  lVar9 = strtol((char *)(pbVar12 + 1),(char **)0x0,10);
  pbVar12 = (byte *)buffer;
  if ((false) || (value != 0.0)) {
    iVar7 = (int)lVar9;
    if (buffer <= pbVar13) {
LAB_0012fb87:
      ppuVar10 = __ctype_b_loc();
LAB_0012fb90:
      uVar6 = (*ppuVar10)[(char)*pbVar13];
      if (((uVar6 & 0x800) == 0) || (*pbVar13 == 0x30)) goto LAB_0012fba9;
      if (buffer <= pbVar13) {
        iVar14 = 0;
        while( true ) {
          pbVar13 = pbVar13 + -1;
          iVar14 = (iVar14 + 1) - (uint)((uVar6 & 0x800) == 0);
          if (pbVar13 == (byte *)buffer + -1) break;
          uVar6 = (*ppuVar10)[(char)*pbVar13];
        }
        goto LAB_0012fbb8;
      }
    }
LAB_0012fbb2:
    iVar14 = 0;
LAB_0012fbb8:
    if ((iVar7 < 3) && (iVar14 - iVar7 < 5)) {
      iVar14 = iVar14 - (iVar7 + 1);
      if (iVar14 < 0) {
        iVar14 = 0;
      }
      __sprintf_chk(value,buffer,1,0xffffffffffffffff,"%.*lf",iVar14);
      if (iVar7 < 0) {
        bVar5 = *buffer;
        if (bVar5 == 0x30) {
          if (false) goto LAB_0012fc4a;
          pbVar13 = (byte *)buffer + 1;
        }
        else {
          pbVar4 = (byte *)buffer;
          if (bVar5 == 0) {
LAB_0012fc4a:
            return (char *)((byte *)buffer + -(long)space_required);
          }
          do {
            pbVar13 = pbVar4;
            bVar1 = pbVar13[1];
            if (bVar1 == 0) break;
            pbVar4 = pbVar13 + 1;
          } while (bVar1 != 0x30);
          pbVar13 = pbVar13 + 2;
          pbVar4 = (byte *)radix;
          pbVar2 = (byte *)plus;
          pbVar3 = (byte *)minus;
          if (bVar1 == 0) {
            do {
              while (*pbVar3 == bVar5) {
                *pbVar12 = 0x7e;
                bVar5 = pbVar12[1];
                pbVar12 = pbVar12 + 1;
                if (bVar5 == 0) goto LAB_0012fc4a;
              }
              if (*pbVar2 == bVar5) {
                *pbVar12 = 0x2b;
              }
              else if (*pbVar4 == bVar5) {
                *pbVar12 = 0x2e;
              }
              bVar5 = pbVar12[1];
              pbVar12 = pbVar12 + 1;
joined_r0x0012fbfe:
            } while (bVar5 != 0);
            goto LAB_0012fc4a;
          }
        }
        do {
          bVar5 = *pbVar13;
          pbVar13[-1] = bVar5;
          pbVar13 = pbVar13 + 1;
        } while (bVar5 != 0);
      }
      goto LAB_0012fbf7;
    }
    iVar14 = iVar14 + -1;
    pcVar11 = "%.*le";
  }
  else {
    iVar7 = 0;
    if (buffer <= pbVar13) goto LAB_0012fb87;
    iVar14 = 0;
    pcVar11 = "%.*lf";
  }
  __sprintf_chk(value,buffer,1,0xffffffffffffffff,pcVar11,iVar14);
LAB_0012fbf7:
  bVar5 = *buffer;
  pbVar3 = (byte *)minus;
  pbVar2 = (byte *)plus;
  pbVar4 = (byte *)radix;
  goto joined_r0x0012fbfe;
LAB_0012fba9:
  pbVar13 = pbVar13 + -1;
  if (pbVar13 < buffer) goto LAB_0012fbb2;
  goto LAB_0012fb90;
}



double xlfd_round_double(double x)

{
  uint uVar1;
  ushort uVar2;
  ulong uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  long in_FS_OFFSET;
  
  if ((false) || (x != 0.0)) {
    uVar4 = (uint)(byte)((ulong)x >> 0x38) << 4;
    uVar3 = (ulong)x & 0xffff00ffffffffff;
    uVar5 = (uint)((byte)((ulong)x >> 0x34) & 0xf);
    uVar1 = (uint)((ulong)x >> 0x20);
    if (((uVar1 >> 8 & 0xff) + 8 & 0x100) != 0) {
      uVar2 = (ushort)((ulong)x >> 0x30);
      uVar6 = uVar2 + 1;
      uVar3 = (ulong)x & 0xff0000ffffffffff | (ulong)(uVar6 & 0xff) << 0x30;
      if (((char)((uVar2 & 0xff) + 1 >> 8) != '\0') && ((uVar6 & 0xf0) != uVar5 << 4)) {
        uVar5 = (uVar4 & 0x7ff | uVar5) + 1;
        uVar3 = (ulong)(uVar6 & 0xf | (uVar5 & 0xf) << 4) << 0x30 |
                (ulong)(uint)((int)(uVar5 | uVar4 & 0x800) >> 4) << 0x38;
      }
    }
    x = (double)(uVar3 & 0xffff000000000000 | (ulong)((uVar1 >> 8) + 8 & 0xf8) << 0x28);
  }
  if (*(long *)(in_FS_OFFSET + 0x28) == *(long *)(in_FS_OFFSET + 0x28)) {
    return x;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Bool FontParseXLFDName(char *fname,FontScalablePtr vals,int subst)

{
  char cVar1;
  int iVar2;
  int iVar3;
  Bool BVar4;
  int iVar5;
  char *pcVar6;
  char *pcVar7;
  char *pcVar8;
  char *pcVar9;
  undefined8 uVar10;
  void *pvVar11;
  uint uVar12;
  long lVar13;
  char *pcVar14;
  ulong uVar15;
  ulong uVar16;
  undefined8 extraout_RDX;
  size_t __n;
  FontScalablePtr p_Var17;
  char *pcVar18;
  char *pcVar19;
  char cVar20;
  fsRange *pfVar21;
  long in_FS_OFFSET;
  byte bVar22;
  double dVar23;
  FontScalableRec tmpvals;
  char buffer [80];
  char tmpBuf [1024];
  undefined auStack_48 [8];
  long local_40;
  
  bVar22 = 0;
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  p_Var17 = &tmpvals;
  for (lVar13 = 0xf; lVar13 != 0; lVar13 = lVar13 + -1) {
    *(undefined8 *)p_Var17 = 0;
    p_Var17 = (FontScalablePtr)p_Var17->pixel_matrix;
  }
  if (subst != 3) {
    p_Var17 = vals;
    for (lVar13 = 0xf; lVar13 != 0; lVar13 = lVar13 + -1) {
      *(undefined8 *)p_Var17 = 0;
      p_Var17 = (FontScalablePtr)p_Var17->pixel_matrix;
    }
  }
  pcVar6 = fname + 1;
  if (*fname == '-') {
LAB_0012ffda:
    pcVar6 = strchr(pcVar6,0x2d);
    if ((pcVar6 != (char *)0x0) && (pcVar6 = strchr(pcVar6 + 1,0x2d), pcVar6 != (char *)0x0)) {
      pcVar9 = pcVar6 + 1;
      pcVar7 = strchr(pcVar9,0x2d);
      if ((pcVar7 != (char *)0x0) &&
         ((((pcVar7 = strchr(pcVar7 + 1,0x2d), pcVar7 != (char *)0x0 &&
            (pcVar7 = strchr(pcVar7 + 1,0x2d), pcVar7 != (char *)0x0)) &&
           (pcVar7 = strchr(pcVar7 + 1,0x2d), pcVar7 != (char *)0x0)) &&
          ((pcVar7 = GetMatrix(pcVar7 + 1,&tmpvals,3), pcVar7 != (char *)0x0 &&
           (pcVar7 = GetMatrix(pcVar7 + 1,&tmpvals,0xc), pcVar7 != (char *)0x0)))))) {
        if (pcVar7[1] == '*') {
          tmpvals.x = -1;
          pcVar14 = pcVar7 + 2;
          cVar20 = pcVar7[2];
        }
        else {
          tmpvals.x = 0;
          pcVar14 = pcVar7 + 1;
          cVar20 = pcVar7[1];
          if ((byte)(cVar20 - 0x30U) < 10) {
            tmpvals.x = 0;
            do {
              pcVar14 = pcVar14 + 1;
              tmpvals.x = cVar20 + -0x30 + tmpvals.x * 10;
              cVar20 = *pcVar14;
            } while ((byte)(cVar20 - 0x30U) < 10);
          }
        }
        if (cVar20 == '-') {
          if (pcVar14[1] == '*') {
            tmpvals.y = -1;
            pcVar18 = pcVar14 + 2;
            cVar20 = pcVar14[2];
          }
          else {
            tmpvals.y = 0;
            cVar20 = pcVar14[1];
            pcVar18 = pcVar14 + 1;
            if ((byte)(cVar20 - 0x30U) < 10) {
              tmpvals.y = 0;
              do {
                pcVar18 = pcVar18 + 1;
                tmpvals.y = cVar20 + -0x30 + tmpvals.y * 10;
                cVar20 = *pcVar18;
              } while ((byte)(cVar20 - 0x30U) < 10);
            }
          }
          if ((cVar20 == '-') && (pcVar14 = strchr(pcVar18 + 1,0x2d), pcVar14 != (char *)0x0)) {
            if (pcVar14[1] == '*') {
              tmpvals.width = -1;
              pcVar19 = pcVar14 + 2;
              cVar20 = pcVar14[2];
            }
            else {
              tmpvals.width = 0;
              pcVar19 = pcVar14 + 1;
              cVar20 = pcVar14[1];
              if ((byte)(cVar20 - 0x30U) < 10) {
                tmpvals.width = 0;
                do {
                  pcVar19 = pcVar19 + 1;
                  tmpvals.width = cVar20 + -0x30 + tmpvals.width * 10;
                  cVar20 = *pcVar19;
                } while ((byte)(cVar20 - 0x30U) < 10);
              }
            }
            if (((cVar20 == '-') && (pcVar8 = strchr(pcVar19 + 1,0x2d), pcVar8 != (char *)0x0)) &&
               (pcVar8 = strchr(pcVar8 + 1,0x2d), pcVar8 == (char *)0x0)) {
              if (subst != 0) {
                pcVar8 = strrchr(fname,0x2d);
                pcVar8 = strchr(pcVar8,0x5b);
                if (pcVar8 != (char *)0x0) {
                  tmpvals.values_supplied = tmpvals.values_supplied | 0x40;
                  *pcVar8 = '\0';
                }
              }
              if (tmpvals.pixel_matrix[3] < 0.0) {
                dVar23 = tmpvals.pixel_matrix[3] - 0.5;
              }
              else {
                dVar23 = tmpvals.pixel_matrix[3] + 0.5;
              }
              tmpvals.pixel = (int)dVar23;
              if (tmpvals.point_matrix[3] < 0.0) {
                dVar23 = tmpvals.point_matrix[3] * 10.0 - 0.5;
              }
              else {
                dVar23 = tmpvals.point_matrix[3] * 10.0 + 0.5;
              }
              tmpvals.point = (int)dVar23;
              iVar5 = ((int)pcVar14 - (int)pcVar18) + 1;
              if (subst == 2) {
                cVar20 = '0';
LAB_001302a8:
                lVar13 = __strcpy_chk(tmpBuf,pcVar7,0x400);
                pcVar6 = strchr(pcVar9,0x2d);
                pcVar6 = strchr(pcVar6 + 1,0x2d);
                pcVar6 = strchr(pcVar6 + 1,0x2d);
                pcVar9 = strchr(pcVar6 + 1,0x2d);
                uVar15 = 0xffffffffffffffff;
                pcVar6 = pcVar19 + (lVar13 - (long)pcVar7);
                do {
                  if (uVar15 == 0) break;
                  uVar15 = uVar15 - 1;
                  cVar1 = *pcVar6;
                  pcVar6 = pcVar6 + (ulong)bVar22 * -2 + 1;
                } while (cVar1 != '\0');
                __n = (size_t)iVar5;
                if ((char *)0x3ff < pcVar9 + ~uVar15 + __n + (10 - (long)fname)) goto LAB_0012ffa1;
                pcVar9[1] = cVar20;
                pcVar9[2] = '-';
                pcVar9[3] = cVar20;
                pcVar9[4] = '-';
                pcVar9[5] = '*';
                pcVar9[6] = '-';
                pcVar9[7] = '*';
                if (iVar5 < 3) {
                  pcVar9[8] = '-';
                  pcVar9[9] = '*';
                  pcVar6 = pcVar9 + 0xb;
                  pcVar9[10] = '-';
                }
                else {
                  pvVar11 = memcpy(pcVar9 + 8,pcVar18 + (lVar13 - (long)pcVar7),__n);
                  pcVar6 = (char *)((long)pvVar11 + __n);
                }
                *pcVar6 = cVar20;
                memcpy(pcVar6 + 1,pcVar19 + (lVar13 - (long)pcVar7),~uVar15);
LAB_0013039a:
                p_Var17 = &tmpvals;
                for (lVar13 = 0x1e; lVar13 != 0; lVar13 = lVar13 + -1) {
                  vals->values_supplied = p_Var17->values_supplied;
                  p_Var17 = (FontScalablePtr)((long)p_Var17 + (ulong)bVar22 * -8 + 4);
                  vals = (FontScalablePtr)((long)vals + (ulong)bVar22 * -8 + 4);
                }
              }
              else if (subst < 3) {
                if (subst == 0) goto LAB_0013039a;
                if (subst == 1) {
                  cVar20 = '*';
                  goto LAB_001302a8;
                }
              }
              else if (subst == 3) {
                uVar12 = vals->values_supplied & 3;
                if (uVar12 != 0) {
                  tmpvals.pixel_matrix[0] = vals->pixel_matrix[0];
                  tmpvals.pixel_matrix[1] = vals->pixel_matrix[1];
                  tmpvals.values_supplied = tmpvals.values_supplied & 0xfffffffcU | uVar12;
                  tmpvals.pixel_matrix[2] = vals->pixel_matrix[2];
                  tmpvals.pixel_matrix[3] = vals->pixel_matrix[3];
                }
                uVar12 = vals->values_supplied & 0xc;
                if (uVar12 != 0) {
                  tmpvals.point_matrix[0] = vals->point_matrix[0];
                  tmpvals.point_matrix[1] = vals->point_matrix[1];
                  tmpvals.values_supplied = uVar12 | tmpvals.values_supplied & 0xfffffff3U;
                  tmpvals.point_matrix[2] = vals->point_matrix[2];
                  tmpvals.point_matrix[3] = vals->point_matrix[3];
                }
                if (-1 < vals->x) {
                  tmpvals.x = vals->x;
                }
                if (-1 < vals->y) {
                  tmpvals.y = vals->y;
                }
                iVar2 = vals->width;
                iVar3 = iVar2;
                if ((iVar2 < 0) && (iVar3 = tmpvals.width, iVar2 != -1)) {
                  iVar3 = -iVar2;
                }
                tmpvals.width = iVar3;
                pcVar7 = strchr(pcVar9,0x2d);
                uVar15 = (long)pcVar7 - (long)pcVar9;
                pcVar6 = pcVar6 + (long)(int)uVar15 + 2;
                uVar10 = extraout_RDX;
                __sprintf_chk(tmpBuf,1,0x400,"%*.*s",uVar15 & 0xffffffff,uVar15 & 0xffffffff,pcVar9,
                              extraout_RDX);
                pcVar7 = strchr(pcVar6,0x2d);
                uVar16 = 0xffffffffffffffff;
                uVar15 = (long)pcVar7 - (long)pcVar6;
                pcVar7 = tmpBuf;
                do {
                  if (uVar16 == 0) break;
                  uVar16 = uVar16 - 1;
                  cVar20 = *pcVar7;
                  pcVar7 = pcVar7 + (ulong)bVar22 * -2 + 1;
                } while (cVar20 != '\0');
                pcVar7 = pcVar6 + (long)(int)uVar15 + 1;
                __sprintf_chk(buffer + ~uVar16 + 0x4f,1,0xffffffffffffffff,&DAT_00136c5e,
                              uVar15 & 0xffffffff,uVar15 & 0xffffffff,pcVar6,uVar10);
                pcVar14 = strchr(pcVar7,0x2d);
                uVar15 = 0xffffffffffffffff;
                pcVar6 = tmpBuf;
                do {
                  if (uVar15 == 0) break;
                  uVar15 = uVar15 - 1;
                  cVar20 = *pcVar6;
                  pcVar6 = pcVar6 + (ulong)bVar22 * -2 + 1;
                } while (cVar20 != '\0');
                uVar16 = (long)pcVar14 - (long)pcVar7;
                pcVar6 = pcVar7 + (long)(int)uVar16 + 1;
                __sprintf_chk(buffer + ~uVar15 + 0x4f,1,0xffffffffffffffff,&DAT_00136c5e,
                              uVar16 & 0xffffffff,uVar16 & 0xffffffff,pcVar7,uVar10);
                pcVar14 = strchr(pcVar6,0x2d);
                uVar15 = 0xffffffffffffffff;
                pcVar7 = tmpBuf;
                do {
                  if (uVar15 == 0) break;
                  uVar15 = uVar15 - 1;
                  cVar20 = *pcVar7;
                  pcVar7 = pcVar7 + (ulong)bVar22 * -2 + 1;
                } while (cVar20 != '\0');
                __sprintf_chk(buffer + ~uVar15 + 0x4f,1,0xffffffffffffffff,&DAT_00136c5e,
                              (long)pcVar14 - (long)pcVar6,(long)pcVar14 - (long)pcVar6 & 0xffffffff
                              ,pcVar6);
                uVar15 = 0xffffffffffffffff;
                pcVar6 = tmpBuf;
                do {
                  if (uVar15 == 0) break;
                  uVar15 = uVar15 - 1;
                  cVar20 = *pcVar6;
                  pcVar6 = pcVar6 + (ulong)bVar22 * -2 + 1;
                } while (cVar20 != '\0');
                (buffer + ~uVar15 + 0x4f)[0] = '-';
                (buffer + ~uVar15 + 0x4f)[1] = '\0';
                if ((tmpvals.values_supplied & 3U) == 2) {
                  __memcpy_chk(tmpBuf + ~uVar15,&DAT_00136c65,2);
                  pcVar6 = xlfd_double_to_text(tmpvals.pixel_matrix[0],buffer,0);
                  __strcat_chk(tmpBuf,pcVar6,0x400);
                  pcVar6 = xlfd_double_to_text(tmpvals.pixel_matrix[1],buffer,1);
                  __strcat_chk(tmpBuf,pcVar6,0x400);
                  pcVar6 = xlfd_double_to_text(tmpvals.pixel_matrix[2],buffer,1);
                  __strcat_chk(tmpBuf,pcVar6,0x400);
                  pcVar7 = xlfd_double_to_text(tmpvals.pixel_matrix[3],buffer,1);
                  uVar15 = 0xffffffffffffffff;
                  pcVar6 = tmpBuf;
                  do {
                    if (uVar15 == 0) break;
                    uVar15 = uVar15 - 1;
                    cVar20 = *pcVar6;
                    pcVar6 = pcVar6 + (ulong)bVar22 * -2 + 1;
                  } while (cVar20 != '\0');
                  lVar13 = __stpcpy_chk(buffer + ~uVar15 + 0x4f,pcVar7,0x400);
                  __memcpy_chk(lVar13,&DAT_00132a5f,2,auStack_48 + -lVar13);
                }
                else {
                  __sprintf_chk(tmpBuf + ~uVar15,1,0xffffffffffffffff,"%d");
                }
                uVar15 = 0xffffffffffffffff;
                pcVar6 = tmpBuf;
                do {
                  if (uVar15 == 0) break;
                  uVar15 = uVar15 - 1;
                  cVar20 = *pcVar6;
                  pcVar6 = pcVar6 + (ulong)bVar22 * -2 + 1;
                } while (cVar20 != '\0');
                (buffer + ~uVar15 + 0x4f)[0] = '-';
                (buffer + ~uVar15 + 0x4f)[1] = '\0';
                pcVar6 = tmpBuf + ~uVar15;
                if ((tmpvals.values_supplied & 0xcU) == 8) {
                  __memcpy_chk(pcVar6,&DAT_00136c65,2,auStack_48 + -(long)pcVar6);
                  pcVar6 = xlfd_double_to_text(tmpvals.point_matrix[0],buffer,0);
                  __strcat_chk(tmpBuf,pcVar6,0x400);
                  pcVar6 = xlfd_double_to_text(tmpvals.point_matrix[1],buffer,1);
                  __strcat_chk(tmpBuf,pcVar6,0x400);
                  pcVar6 = xlfd_double_to_text(tmpvals.point_matrix[2],buffer,1);
                  __strcat_chk(tmpBuf,pcVar6,0x400);
                  pcVar7 = xlfd_double_to_text(tmpvals.point_matrix[3],buffer,1);
                  uVar15 = 0xffffffffffffffff;
                  pcVar6 = tmpBuf;
                  do {
                    if (uVar15 == 0) break;
                    uVar15 = uVar15 - 1;
                    cVar20 = *pcVar6;
                    pcVar6 = pcVar6 + (ulong)bVar22 * -2 + 1;
                  } while (cVar20 != '\0');
                  uVar10 = __stpcpy_chk(buffer + ~uVar15 + 0x4f,pcVar7,0x400);
                  __memcpy_chk(uVar10,&DAT_00132a5f,2);
                }
                else {
                  __sprintf_chk(pcVar6,1,0xffffffffffffffff,"%d",
                                (int)(tmpvals.point_matrix[3] * 10.0 + 0.5));
                }
                uVar15 = 0xffffffffffffffff;
                pcVar6 = tmpBuf;
                do {
                  if (uVar15 == 0) break;
                  uVar15 = uVar15 - 1;
                  cVar20 = *pcVar6;
                  pcVar6 = pcVar6 + (ulong)bVar22 * -2 + 1;
                } while (cVar20 != '\0');
                __sprintf_chk(buffer + ~uVar15 + 0x4f,1,0xffffffffffffffff,"-%d-%d%*.*s%d%s",
                              tmpvals.x,tmpvals.y,iVar5,iVar5,pcVar18,tmpvals.width,pcVar19,~uVar15)
                ;
                strcpy(pcVar9,tmpBuf);
                if ((*(byte *)&vals->values_supplied & 0x40) == 0) {
                  iVar5 = vals->nranges;
                  pfVar21 = vals->ranges;
                  BVar4 = 1;
                  if (iVar5 == 0) goto LAB_0012ffa3;
                }
                else {
                  iVar5 = vals->nranges;
                  if (iVar5 == 0) {
                    strcat(fname,"[]");
                    goto LAB_001303a7;
                  }
                  pfVar21 = vals->ranges;
                }
                strcat(fname,"[");
                for (lVar13 = 0; (int)lVar13 < iVar5; lVar13 = lVar13 + 1) {
                  uVar15 = 0xffffffffffffffff;
                  pcVar6 = fname;
                  do {
                    if (uVar15 == 0) break;
                    uVar15 = uVar15 - 1;
                    cVar20 = *pcVar6;
                    pcVar6 = pcVar6 + (ulong)bVar22 * -2 + 1;
                  } while (cVar20 != '\0');
                  if (0x3f1 < ~uVar15 - 1) break;
                  if ((int)lVar13 != 0) {
                    (fname + (~uVar15 - 1))[0] = ' ';
                    (fname + (~uVar15 - 1))[1] = '\0';
                  }
                  uVar15 = 0xffffffffffffffff;
                  pcVar6 = fname;
                  do {
                    if (uVar15 == 0) break;
                    uVar15 = uVar15 - 1;
                    cVar20 = *pcVar6;
                    pcVar6 = pcVar6 + (ulong)bVar22 * -2 + 1;
                  } while (cVar20 != '\0');
                  __sprintf_chk(fname + (~uVar15 - 1),1,0xffffffffffffffff,"%d",
                                (uint)pfVar21[lVar13].min_char_high * 0x100 +
                                (uint)pfVar21[lVar13].min_char_low);
                  if ((pfVar21[lVar13].min_char_low != pfVar21[lVar13].max_char_low) ||
                     (pfVar21[lVar13].min_char_high != pfVar21[lVar13].max_char_high)) {
                    uVar15 = 0xffffffffffffffff;
                    pcVar6 = fname;
                    do {
                      if (uVar15 == 0) break;
                      uVar15 = uVar15 - 1;
                      cVar20 = *pcVar6;
                      pcVar6 = pcVar6 + (ulong)bVar22 * -2 + 1;
                    } while (cVar20 != '\0');
                    __sprintf_chk(fname + (~uVar15 - 1),1,0xffffffffffffffff,&DAT_00136c7a,
                                  (uint)pfVar21[lVar13].max_char_high * 0x100 +
                                  (uint)pfVar21[lVar13].max_char_low);
                  }
                }
                strcat(fname,"]");
                BVar4 = 1;
                goto LAB_0012ffa3;
              }
LAB_001303a7:
              BVar4 = 1;
              goto LAB_0012ffa3;
            }
          }
        }
      }
    }
  }
  else if ((*fname == '*') && (fname[1] == '-')) {
    pcVar6 = fname + 2;
    goto LAB_0012ffda;
  }
LAB_0012ffa1:
  BVar4 = 0;
LAB_0012ffa3:
  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar4;
}



fsRange * FontParseRanges(char *name,int *nranges)

{
  char *__nptr;
  char cVar1;
  fsRange *__s;
  ulong uVar2;
  int iVar3;
  CARD8 *pCVar4;
  CARD8 *pCVar5;
  long in_FS_OFFSET;
  fsRange thisrange;
  char *p2;
  fsRange *result;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  result = (fsRange *)0x0;
  __s = (fsRange *)strchr(name,0x2d);
  if (__s == (fsRange *)0x0) {
    *nranges = 0;
    __s = (fsRange *)0x0;
  }
  else {
    iVar3 = 1;
    do {
      iVar3 = iVar3 + 1;
      __s = (fsRange *)strchr((char *)&__s->min_char_low,0x2d);
      if (__s == (fsRange *)0x0) break;
    } while (iVar3 < 0xe);
    *nranges = 0;
    if ((__s != (fsRange *)0x0) &&
       (__s = (fsRange *)strchr((char *)__s,0x5b), __s != (fsRange *)0x0)) {
      pCVar4 = &__s->min_char_low;
      if ((__s->min_char_low == ']') || (__s->min_char_low == '\0')) {
        __s = (fsRange *)0x0;
      }
      else {
        while ((uVar2 = strtol((char *)pCVar4,&p2,0), __s = result, uVar2 < 0x10000 &&
               ((CARD8 *)p2 != pCVar4))) {
          thisrange._0_2_ = (ushort)uVar2 << 8 | (ushort)uVar2 >> 8;
          cVar1 = *p2;
          pCVar4 = (CARD8 *)p2;
          thisrange._2_2_ = thisrange._0_2_;
          if (cVar1 == ']') {
            if (false) {
LAB_00130c18:
              do {
                pCVar4 = pCVar4 + 1;
              } while (*pCVar4 == ' ');
            }
LAB_00130c21:
            iVar3 = add_range(&thisrange,nranges,&result,1);
            __s = result;
            if (iVar3 != 0x55) break;
          }
          else {
            if (cVar1 == ' ') goto LAB_00130c18;
            if (((cVar1 != '_') ||
                (__nptr = p2 + 1, uVar2 = strtol(__nptr,&p2,0), __s = result, p2 == __nptr)) ||
               (0xffff < uVar2)) break;
            thisrange._2_2_ = (ushort)uVar2 << 8 | (ushort)uVar2 >> 8;
            pCVar5 = (CARD8 *)p2;
            pCVar4 = (CARD8 *)p2;
            if (*p2 == ']') {
              if (true) goto LAB_00130c21;
LAB_00130c70:
              do {
                pCVar4 = pCVar5 + 1;
                if (pCVar5[1] != ' ') break;
                pCVar4 = pCVar5 + 2;
                pCVar5 = pCVar4;
              } while (*pCVar4 == ' ');
              goto LAB_00130c21;
            }
            if (*p2 == ' ') goto LAB_00130c70;
          }
          __s = result;
          if ((*pCVar4 == '\0') || (*pCVar4 == ']')) break;
        }
      }
    }
  }
  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return __s;
}



// WARNING: Type propagation algorithm not settling

int CheckFSFormat(fsBitmapFormat format,fsBitmapFormatMask fmask,int *bit_order,int *byte_order,
                 int *scan,int *glyph,int *image)

{
  uint uVar1;
  
  if ((fmask & 2) != 0) {
    *bit_order = format >> 1 & 1;
  }
  if ((fmask & 1) != 0) {
    *byte_order = format & 1;
  }
  if ((fmask & 0x10) != 0) {
    uVar1 = format & 0x3000;
    if (uVar1 == 0x1000) {
      *scan = 2;
    }
    else if (uVar1 == 0x2000) {
      *scan = 4;
    }
    else {
      if (uVar1 != 0) {
        *scan = uVar1;
        return 0x58;
      }
      *scan = 1;
    }
  }
  if ((fmask & 8) != 0) {
    uVar1 = format & 0x300;
    if (uVar1 == 0x100) {
      *glyph = 2;
    }
    else if (uVar1 == 0x200) {
      *glyph = 4;
    }
    else {
      if (uVar1 != 0) {
        *glyph = uVar1;
        return 0x58;
      }
      *glyph = 1;
    }
  }
  if ((fmask & 4) != 0) {
    *image = format & 0xc;
    if (((format & 8) != 0) && ((format & 0xc) != 8)) {
      return 0x58;
    }
  }
  return 0x55;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void register_fpe_functions(void)

{
  BuiltinRegisterFpeFunctions();
  FontFileRegisterFpeFunctions();
  fs_register_fpe_functions();
  return;
}



void EmptyFontPatternCache(FontPatternCachePtr cache)

{
  FontPatternCachePtr p_Var1;
  _FontPatternCacheEntry *p_Var2;
  _FontPatternCacheEntry *p_Var3;
  
  p_Var1 = cache;
  do {
    p_Var1->buckets[0] = (FontPatternCacheEntryPtr)0x0;
    p_Var1 = (FontPatternCachePtr)(p_Var1->buckets + 1);
  } while (p_Var1 != (FontPatternCachePtr)cache->entries);
  p_Var2 = cache->entries + 1;
  do {
    p_Var2[-1].next = p_Var2;
    p_Var3 = p_Var2 + 1;
    p_Var2[-1].prev = (_FontPatternCacheEntry **)0x0;
    p_Var2[-1].pFont = (FontPtr)0x0;
    free(p_Var2[-1].pattern);
    p_Var2[-1].pattern = (char *)0x0;
    p_Var2[-1].patlen = 0;
    p_Var2 = p_Var3;
  } while (p_Var3 != (_FontPatternCacheEntry *)(cache[1].buckets + 5));
  cache->free = cache->entries;
  cache->entries[0x3f].next = (_FontPatternCacheEntry *)0x0;
  return;
}



// WARNING: Unknown calling convention

FontPatternCachePtr MakeFontPatternCache(void)

{
  FontPatternCachePtr cache;
  short *psVar1;
  short *psVar2;
  
  cache = (FontPatternCachePtr)malloc(0xc88);
  if (cache != (FontPatternCachePtr)0x0) {
    psVar1 = &cache->entries[0].patlen;
    do {
      *(char **)(psVar1 + 4) = (char *)0x0;
      psVar2 = psVar1 + 0x18;
      *psVar1 = 0;
      *(FontPtr *)(psVar1 + 0xc) = (FontPtr)0x0;
      psVar1 = psVar2;
    } while ((FontPatternCacheEntryPtr *)psVar2 != cache[1].buckets + 1);
    EmptyFontPatternCache(cache);
  }
  return cache;
}



void FreeFontPatternCache(FontPatternCachePtr cache)

{
  char *__ptr;
  char **ppcVar1;
  
  ppcVar1 = &cache->entries[0].pattern;
  do {
    __ptr = *ppcVar1;
    ppcVar1 = ppcVar1 + 6;
    free(__ptr);
  } while ((FontPatternCacheEntryPtr *)ppcVar1 != cache[1].buckets + 2);
  free(cache);
  return;
}



void CacheFontPattern(FontPatternCachePtr cache,char *pattern,int patlen,FontPtr pFont)

{
  char cVar1;
  uint uVar2;
  char *pcVar3;
  FontPatternCachePtr p_Var4;
  size_t __size;
  _FontPatternCacheEntry *p_Var5;
  FontPatternCacheEntryPtr p_Var6;
  
  __size = (size_t)patlen;
  pcVar3 = (char *)malloc(__size);
  if (pcVar3 != (char *)0x0) {
    p_Var6 = cache->free;
    if (p_Var6 == (FontPatternCacheEntryPtr)0x0) {
      uVar2 = rand();
      uVar2 = (uVar2 ^ (int)uVar2 >> 0x1f) - ((int)uVar2 >> 0x1f) & 0x3f;
      p_Var6 = cache->entries + uVar2;
      p_Var5 = cache->entries[uVar2].next;
      if (p_Var5 != (_FontPatternCacheEntry *)0x0) {
        p_Var5->prev = cache->entries[uVar2].prev;
        p_Var5 = cache->entries[uVar2].next;
      }
      *cache->entries[uVar2].prev = p_Var5;
      free(cache->entries[uVar2].pattern);
    }
    else {
      cache->free = p_Var6->next;
    }
    memcpy(pcVar3,pattern,__size);
    p_Var6->pattern = pcVar3;
    p_Var6->patlen = (short)patlen;
    if (patlen == 0) {
      uVar2 = 0;
      p_Var4 = cache;
    }
    else {
      pcVar3 = pattern + (ulong)(patlen - 1) + 1;
      uVar2 = 0;
      do {
        cVar1 = *pattern;
        pattern = pattern + 1;
        uVar2 = uVar2 * 2 ^ (int)cVar1;
      } while (pattern != pcVar3);
      uVar2 = (uVar2 ^ (int)uVar2 >> 0x1f) - ((int)uVar2 >> 0x1f);
      __size = (size_t)(uVar2 & 0xf);
      p_Var4 = (FontPatternCachePtr)(cache->buckets + __size);
    }
    p_Var6->hash = uVar2;
    p_Var5 = cache->buckets[__size];
    p_Var6->next = p_Var5;
    if (p_Var5 != (_FontPatternCacheEntry *)0x0) {
      p_Var5->prev = &p_Var6->next;
    }
    cache->buckets[__size] = p_Var6;
    p_Var6->prev = p_Var4->buckets;
    p_Var6->pFont = pFont;
  }
  return;
}



FontPtr FindCachedFontPattern(FontPatternCachePtr cache,char *pattern,int patlen)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  char *pcVar4;
  uint uVar5;
  FontPtr p_Var6;
  
  if (patlen == 0) {
    uVar5 = 0;
    uVar2 = 0;
  }
  else {
    uVar2 = 0;
    pcVar4 = pattern;
    do {
      cVar1 = *pcVar4;
      pcVar4 = pcVar4 + 1;
      uVar2 = uVar2 * 2 ^ (int)cVar1;
    } while (pcVar4 != pattern + (ulong)(patlen - 1) + 1);
    uVar5 = (uVar2 ^ (int)uVar2 >> 0x1f) - ((int)uVar2 >> 0x1f);
    uVar2 = uVar5 & 0xf;
  }
  p_Var6 = (FontPtr)cache->buckets[(int)uVar2];
  if (p_Var6 != (FontPtr)0x0) {
    do {
      if ((((short)(p_Var6->info).defaultCh == patlen) &&
          (uVar2._0_2_ = (p_Var6->info).maxbounds.descent,
          uVar2._2_2_ = (p_Var6->info).maxbounds.attributes, uVar2 == uVar5)) &&
         (iVar3 = memcmp(*(void **)&(p_Var6->info).maxbounds,pattern,(long)patlen), iVar3 == 0)) {
        return *(FontPtr *)&(p_Var6->info).minbounds.characterWidth;
      }
      p_Var6 = *(FontPtr *)p_Var6;
    } while (p_Var6 != (FontPtr)0x0);
  }
  return p_Var6;
}



void RemoveCachedFontPattern(FontPatternCachePtr cache,FontPtr pFont)

{
  _FontPatternCacheEntry *p_Var1;
  FontPatternCacheEntryPtr p_Var2;
  FontPatternCacheEntryPtr p_Var3;
  
  p_Var2 = cache->entries;
  do {
    while (p_Var2->pFont != pFont) {
      p_Var2 = p_Var2 + 1;
      if (p_Var2 == (FontPatternCacheEntryPtr)&cache->free) {
        return;
      }
    }
    p_Var1 = p_Var2->next;
    p_Var2->pFont = (FontPtr)0x0;
    if (p_Var1 != (_FontPatternCacheEntry *)0x0) {
      p_Var1->prev = p_Var2->prev;
      p_Var1 = p_Var2->next;
    }
    *p_Var2->prev = p_Var1;
    p_Var2->next = cache->free;
    cache->free = p_Var2;
    p_Var3 = p_Var2 + 1;
    free(p_Var2->pattern);
    p_Var2->pattern = (char *)0x0;
    p_Var2 = p_Var3;
  } while (p_Var3 != (FontPatternCacheEntryPtr)&cache->free);
  return;
}



// WARNING: Unknown calling convention

int AllocateFontPrivateIndex(void)

{
  int iVar1;
  
  iVar1 = _FontPrivateAllocateIndex;
  _FontPrivateAllocateIndex = _FontPrivateAllocateIndex + 1;
  return iVar1;
}



// WARNING: Unknown calling convention

FontPtr CreateFontRec(void)

{
  int iVar1;
  FontPtr p_Var2;
  
  iVar1 = _FontPrivateAllocateIndex;
  p_Var2 = (FontPtr)calloc((long)(_FontPrivateAllocateIndex * 8 + 0xb8),1);
  if ((p_Var2 != (FontPtr)0x0) && (p_Var2->maxPrivate = iVar1 + -1, iVar1 != 0)) {
    p_Var2->devPrivates = (void **)(p_Var2 + 1);
  }
  return p_Var2;
}



void DestroyFontRec(FontPtr pFont)

{
  FontPtr __ptr;
  
  __ptr = (FontPtr)pFont->devPrivates;
  if ((__ptr != (FontPtr)0x0) && (__ptr != pFont + 1)) {
    free(__ptr);
  }
  free(pFont);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ResetFontPrivateIndex(void)

{
  _FontPrivateAllocateIndex = 0;
  return;
}



Bool _FontSetNewPrivate(FontPtr pFont,int n,pointer ptr)

{
  FontPtr __src;
  void *__dest;
  int iVar1;
  size_t __size;
  
  iVar1 = pFont->maxPrivate;
  __src = (FontPtr)pFont->devPrivates;
  if (iVar1 < n) {
    __size = (long)(n + 1) << 3;
    if (__src == (FontPtr)0x0) {
      __src = (FontPtr)malloc(__size);
      if (__src == (FontPtr)0x0) {
        return 0;
      }
      iVar1 = iVar1 + 1;
    }
    else if (__src == pFont + 1) {
      __dest = malloc(__size);
      if (__dest == (void *)0x0) {
        return 0;
      }
      iVar1 = iVar1 + 1;
      __src = (FontPtr)memcpy(__dest,__src,(long)iVar1 << 3);
    }
    else {
      __src = (FontPtr)realloc(__src,__size);
      if (__src == (FontPtr)0x0) {
        return 0;
      }
      iVar1 = pFont->maxPrivate + 1;
    }
    pFont->devPrivates = (void **)__src;
    pFont->maxPrivate = iVar1;
    if (iVar1 < n) {
      while( true ) {
        *(undefined8 *)(&__src->refcnt + (long)iVar1 * 2) = 0;
        iVar1 = pFont->maxPrivate + 1;
        pFont->maxPrivate = iVar1;
        if (n <= iVar1) break;
        __src = (FontPtr)pFont->devPrivates;
      }
      __src = (FontPtr)pFont->devPrivates;
    }
  }
  *(pointer *)(&__src->refcnt + (long)n * 2) = ptr;
  return 1;
}



void BitOrderInvert(uchar *buf,int nbytes)

{
  byte *pbVar1;
  byte *pbVar2;
  
  if (0 < nbytes) {
    pbVar1 = buf;
    do {
      pbVar2 = pbVar1 + 1;
      *pbVar1 = ""[*pbVar1];
      pbVar1 = pbVar2;
    } while (buf + (ulong)(nbytes - 1) + 1 != pbVar2);
  }
  return;
}



void TwoByteSwap(uchar *buf,int nbytes)

{
  uchar uVar1;
  uchar *puVar2;
  uchar *puVar3;
  
  if (0 < nbytes) {
    puVar2 = buf;
    do {
      uVar1 = *puVar2;
      puVar3 = puVar2 + 2;
      *puVar2 = puVar2[1];
      puVar2[1] = uVar1;
      puVar2 = puVar3;
    } while (puVar3 != buf + (ulong)(nbytes - 1U >> 1) * 2 + 2);
  }
  return;
}



void FourByteSwap(uchar *buf,int nbytes)

{
  uchar uVar1;
  uchar *puVar2;
  uchar *puVar3;
  
  if (0 < nbytes) {
    puVar2 = buf;
    do {
      uVar1 = *puVar2;
      puVar3 = puVar2 + 4;
      *puVar2 = puVar2[3];
      puVar2[3] = uVar1;
      uVar1 = puVar2[1];
      puVar2[1] = puVar2[2];
      puVar2[2] = uVar1;
      puVar2 = puVar3;
    } while (puVar3 != buf + (ulong)(nbytes - 1U >> 2) * 4 + 4);
  }
  return;
}



int RepadBitmap(char *pSrc,char *pDst,uint srcPad,uint dstPad,int width,int height)

{
  long lVar1;
  int iVar2;
  int iVar3;
  ulong uVar4;
  char *pcVar5;
  int iVar7;
  int iVar8;
  int iVar9;
  bool bVar10;
  char *pcVar6;
  
  if (srcPad == 4) {
    iVar9 = (width + 0x1f >> 5) << 2;
  }
  else if (srcPad < 5) {
    if (srcPad == 1) {
      iVar9 = width + 7 >> 3;
    }
    else {
      if (srcPad != 2) {
        return 0;
      }
      iVar9 = (width + 0xf >> 4) * 2;
    }
  }
  else {
    if (srcPad != 8) {
      return 0;
    }
    iVar9 = (width + 0x3f >> 6) << 3;
  }
  if (dstPad == 4) {
    iVar2 = (width + 0x1f >> 5) << 2;
  }
  else if (dstPad < 5) {
    if (dstPad == 1) {
      iVar2 = width + 7 >> 3;
    }
    else {
      if (dstPad != 2) {
        return 0;
      }
      iVar2 = (width + 0xf >> 4) * 2;
    }
  }
  else {
    if (dstPad != 8) {
      return 0;
    }
    iVar2 = (width + 0x3f >> 6) << 3;
  }
  iVar7 = iVar2;
  if (iVar9 <= iVar2) {
    iVar7 = iVar9;
  }
  if (0 < height) {
    iVar8 = 0;
    lVar1 = (ulong)(iVar7 - 1) + 1;
    do {
      while( true ) {
        uVar4 = 0;
        if (iVar7 < 1) {
          iVar3 = 0;
        }
        else {
          do {
            pDst[uVar4] = pSrc[uVar4];
            bVar10 = uVar4 != iVar7 - 1;
            uVar4 = uVar4 + 1;
          } while (bVar10);
          pSrc = pSrc + lVar1;
          pDst = pDst + lVar1;
          iVar3 = iVar7;
        }
        if (iVar2 <= iVar3) break;
        pcVar6 = pDst;
        do {
          pcVar5 = pcVar6 + 1;
          *pcVar6 = '\0';
          pcVar6 = pcVar5;
        } while (pcVar5 != pDst + (ulong)(uint)((iVar2 + -1) - iVar3) + 1);
        iVar8 = iVar8 + 1;
        pSrc = pSrc + (iVar9 - iVar7);
        pDst = pDst + (ulong)(uint)((iVar2 + -1) - iVar3) + 1;
        if (height == iVar8) goto LAB_00131529;
      }
      iVar8 = iVar8 + 1;
      pSrc = pSrc + (iVar9 - iVar7);
    } while (height != iVar8);
  }
LAB_00131529:
  return iVar2 * height;
}



// WARNING: Unknown calling convention

int client_auth_generation(ClientPtr client)

{
  return 0;
}



// WARNING: Unknown calling convention

Bool ClientSignal(ClientPtr client)

{
  return -1;
}



// WARNING: Unknown calling convention

void DeleteFontClientID(Font id)

{
  return;
}



// WARNING: Unknown calling convention

void ErrorF(char *f,...)

{
  return;
}



// WARNING: Unknown calling convention

void FatalError(char *f,...)

{
  return;
}



// WARNING: Unknown calling convention

FontPtr find_old_font(FSID id)

{
  return (FontPtr)0x0;
}



// WARNING: Unknown calling convention

FontResolutionPtr GetClientResolutions(int *num)

{
  return (FontResolutionPtr)0x0;
}



// WARNING: Unknown calling convention

int GetDefaultPointSize(void)

{
  return 0;
}



// WARNING: Unknown calling convention

Font GetNewFontClientID(void)

{
  return 0;
}



// WARNING: Unknown calling convention

ulong GetTimeInMillis(void)

{
  return 0;
}



// WARNING: Unknown calling convention

int init_fs_handlers(FontPathElementPtr fpe,BlockHandlerProcPtr block_handler)

{
  return 0x55;
}



// WARNING: Unknown calling convention

int RegisterFPEFunctions
              (NameCheckFunc name_func,InitFpeFunc init_func,FreeFpeFunc free_func,
              ResetFpeFunc reset_func,OpenFontFunc open_func,CloseFontFunc close_func,
              ListFontsFunc list_func,StartLfwiFunc start_lfwi_func,NextLfwiFunc next_lfwi_func,
              WakeupFpeFunc wakeup_func,ClientDiedFunc client_died,LoadGlyphsFunc load_glyphs,
              StartLaFunc start_list_alias_func,NextLaFunc next_list_alias_func,
              SetPathFunc set_path_func)

{
  return 0;
}



// WARNING: Unknown calling convention

void remove_fs_handlers(FontPathElementPtr fpe,BlockHandlerProcPtr blockHandler,Bool all)

{
  return;
}



// WARNING: Unknown calling convention

int set_font_authorizations(char **authorizations,int *authlen,ClientPtr client)

{
  return 0;
}



// WARNING: Unknown calling convention

int StoreFontClientFont(FontPtr pfont,Font id)

{
  return 0;
}



void _fini(void)

{
  return;
}



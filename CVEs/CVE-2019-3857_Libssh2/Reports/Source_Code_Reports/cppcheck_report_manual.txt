build/CMakeFiles/3.16.3/CompilerIdC/CMakeCCompilerId.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
example/direct_tcpip.c:242:5: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
    fprintf(stderr, "Forwarding connection from %s:%d here to remote %s:%d\n",
    ^
example/direct_tcpip.c:242:5: warning: %d in format string (no. 4) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
    fprintf(stderr, "Forwarding connection from %s:%d here to remote %s:%d\n",
    ^
example/direct_tcpip.c:273:17: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
                fprintf(stderr, "The client at %s:%d disconnected!\n", shost,
                ^
example/direct_tcpip.c:308:17: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
                fprintf(stderr, "The server at %s:%d disconnected!\n",
                ^
example/scp.c:122:9: style: Condition 'auth_pw' is always true [knownConditionTrueFalse]
    if (auth_pw) {
        ^
example/scp.c:36:28: note: Assignment 'auth_pw=1', assigned value is 1
    int sock, i, auth_pw = 1;
                           ^
example/scp.c:122:9: note: Condition 'auth_pw' is always true
    if (auth_pw) {
        ^
example/scp_nonblock.c:182:9: style: Condition 'auth_pw' is always true [knownConditionTrueFalse]
    if (auth_pw) {
        ^
example/scp_nonblock.c:83:28: note: Assignment 'auth_pw=1', assigned value is 1
    int sock, i, auth_pw = 1;
                           ^
example/scp_nonblock.c:182:9: note: Condition 'auth_pw' is always true
    if (auth_pw) {
        ^
example/scp_nonblock.c:232:13: style: Local variable 'rc' shadows outer variable [shadowVariable]
        int rc;
            ^
example/scp_nonblock.c:97:9: note: Shadowed declaration
    int rc;
        ^
example/scp_nonblock.c:232:13: note: Shadow variable
        int rc;
            ^
example/scp_write.c:141:9: style: Condition 'auth_pw' is always true [knownConditionTrueFalse]
    if (auth_pw) {
        ^
example/scp_write.c:36:28: note: Assignment 'auth_pw=1', assigned value is 1
    int sock, i, auth_pw = 1;
                           ^
example/scp_write.c:141:9: note: Condition 'auth_pw' is always true
    if (auth_pw) {
        ^
example/scp_write.c:102:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/scp_write.c:111:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/scp_write.c:118:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/scp_write.c:126:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/scp_write.c:173:19: style: The unsigned expression 'nread' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
        if (nread <= 0) {
                  ^
example/scp_write.c:165:13: style: Local variable 'err' shadows outer variable [shadowVariable]
        int err = libssh2_session_last_error(session, &errmsg, &errlen, 0);
            ^
example/scp_write.c:54:9: note: Shadowed declaration
    int err;
        ^
example/scp_write.c:165:13: note: Shadow variable
        int err = libssh2_session_last_error(session, &errmsg, &errlen, 0);
            ^
example/scp_write_nonblock.c:180:9: style: Condition 'auth_pw' is always true [knownConditionTrueFalse]
    if (auth_pw) {
        ^
example/scp_write_nonblock.c:71:28: note: Assignment 'auth_pw=1', assigned value is 1
    int sock, i, auth_pw = 1;
                           ^
example/scp_write_nonblock.c:180:9: note: Condition 'auth_pw' is always true
    if (auth_pw) {
        ^
example/scp_write_nonblock.c:146:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/scp_write_nonblock.c:153:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/scp_write_nonblock.c:219:19: style: The unsigned expression 'nread' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
        if (nread <= 0) {
                  ^
example/sftp.c:54:12: style: The scope of the variable 'n' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t n;
           ^
example/sftp_RW_nonblock.c:174:9: style: Condition 'auth_pw' is always true [knownConditionTrueFalse]
    if (auth_pw) {
        ^
example/sftp_RW_nonblock.c:78:28: note: Assignment 'auth_pw=1', assigned value is 1
    int sock, i, auth_pw = 1;
                           ^
example/sftp_RW_nonblock.c:174:9: note: Condition 'auth_pw' is always true
    if (auth_pw) {
        ^
example/sftp_RW_nonblock.c:303:23: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
                nread -= nread;
                      ^
example/sftp_RW_nonblock.c:288:16: style: The scope of the variable 'nread' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        size_t nread;
               ^
example/sftp_RW_nonblock.c:289:15: style: The scope of the variable 'ptr' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
        char *ptr;
              ^
example/sftp_RW_nonblock.c:292:22: style: The unsigned expression 'nread' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
            if(nread <= 0) {
                     ^
example/sftp_append.c:143:9: style: Condition 'auth_pw' is always true [knownConditionTrueFalse]
    if (auth_pw) {
        ^
example/sftp_append.c:39:28: note: Assignment 'auth_pw=1', assigned value is 1
    int sock, i, auth_pw = 1;
                           ^
example/sftp_append.c:143:9: note: Condition 'auth_pw' is always true
    if (auth_pw) {
        ^
example/sftp_append.c:110:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/sftp_append.c:117:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/sftp_append.c:128:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/sftp_append.c:198:19: style: The unsigned expression 'nread' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
        if (nread <= 0) {
                  ^
example/sftp_mkdir.c:124:9: style: Condition 'auth_pw' is always true [knownConditionTrueFalse]
    if (auth_pw) {
        ^
example/sftp_mkdir.c:39:28: note: Assignment 'auth_pw=1', assigned value is 1
    int sock, i, auth_pw = 1;
                           ^
example/sftp_mkdir.c:124:9: note: Condition 'auth_pw' is always true
    if (auth_pw) {
        ^
example/sftp_mkdir_nonblock.c:124:9: style: Condition 'auth_pw' is always true [knownConditionTrueFalse]
    if (auth_pw) {
        ^
example/sftp_mkdir_nonblock.c:39:28: note: Assignment 'auth_pw=1', assigned value is 1
    int sock, i, auth_pw = 1;
                           ^
example/sftp_mkdir_nonblock.c:124:9: note: Condition 'auth_pw' is always true
    if (auth_pw) {
        ^
example/sftp_nonblock.c:184:9: style: Condition 'auth_pw' is always true [knownConditionTrueFalse]
    if (auth_pw) {
        ^
example/sftp_nonblock.c:84:28: note: Assignment 'auth_pw=1', assigned value is 1
    int sock, i, auth_pw = 1;
                           ^
example/sftp_nonblock.c:184:9: note: Condition 'auth_pw' is always true
    if (auth_pw) {
        ^
example/sftp_write.c:142:9: style: Condition 'auth_pw' is always true [knownConditionTrueFalse]
    if (auth_pw) {
        ^
example/sftp_write.c:39:28: note: Assignment 'auth_pw=1', assigned value is 1
    int sock, i, auth_pw = 1;
                           ^
example/sftp_write.c:142:9: note: Condition 'auth_pw' is always true
    if (auth_pw) {
        ^
example/sftp_write.c:109:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/sftp_write.c:116:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/sftp_write.c:127:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/sftp_write.c:182:19: style: The unsigned expression 'nread' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
        if (nread <= 0) {
                  ^
example/sftp_write_nonblock.c:183:9: style: Condition 'auth_pw' is always true [knownConditionTrueFalse]
    if (auth_pw) {
        ^
example/sftp_write_nonblock.c:76:28: note: Assignment 'auth_pw=1', assigned value is 1
    int sock, i, auth_pw = 1;
                           ^
example/sftp_write_nonblock.c:183:9: note: Condition 'auth_pw' is always true
    if (auth_pw) {
        ^
example/sftp_write_nonblock.c:149:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/sftp_write_nonblock.c:156:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/sftp_write_nonblock.c:237:19: style: The unsigned expression 'nread' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
        if (nread <= 0) {
                  ^
example/sftp_write_sliding.c:183:9: style: Condition 'auth_pw' is always true [knownConditionTrueFalse]
    if (auth_pw) {
        ^
example/sftp_write_sliding.c:76:28: note: Assignment 'auth_pw=1', assigned value is 1
    int sock, i, auth_pw = 1;
                           ^
example/sftp_write_sliding.c:183:9: note: Condition 'auth_pw' is always true
    if (auth_pw) {
        ^
example/sftp_write_sliding.c:149:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/sftp_write_sliding.c:156:9: error: Resource leak: local [resourceLeak]
        return -1;
        ^
example/sftp_write_sliding.c:238:19: style: The unsigned expression 'nread' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
        if (nread <= 0) {
                  ^
example/sftpdir_nonblock.c:148:9: style: Condition 'auth_pw' is always true [knownConditionTrueFalse]
    if (auth_pw) {
        ^
example/sftpdir_nonblock.c:58:28: note: Assignment 'auth_pw=1', assigned value is 1
    int sock, i, auth_pw = 1;
                           ^
example/sftpdir_nonblock.c:148:9: note: Condition 'auth_pw' is always true
    if (auth_pw) {
        ^
example/ssh2_echo.c:252:17: style: Local variable 'rc' shadows outer variable [shadowVariable]
            int rc = (libssh2_poll(fds, 1, 10));
                ^
example/ssh2_echo.c:88:9: note: Shadowed declaration
    int rc;
        ^
example/ssh2_echo.c:252:17: note: Shadow variable
            int rc = (libssh2_poll(fds, 1, 10));
                ^
example/ssh2_exec.c:262:13: style: Local variable 'rc' shadows outer variable [shadowVariable]
        int rc;
            ^
example/ssh2_exec.c:88:9: note: Shadowed declaration
    int rc;
        ^
example/ssh2_exec.c:262:13: note: Shadow variable
        int rc;
            ^
example/subsystem_netconf.c:73:13: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    ssize_t len;
            ^
example/x11.c:112:11: style: The scope of the variable 'display_port' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int   display_port = 0;
          ^
example/x11.c:113:11: style: The scope of the variable 'sock' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int   sock         = 0;
          ^
example/x11.c:114:11: style: The scope of the variable 'rc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int   rc           = 0;
          ^
example/x11.c:112:24: style: Variable 'display_port' is assigned a value that is never used. [unreadVariable]
    int   display_port = 0;
                       ^
example/x11.c:113:24: style: Variable 'sock' is assigned a value that is never used. [unreadVariable]
    int   sock         = 0;
                       ^
example/x11.c:114:24: style: Variable 'rc' is assigned a value that is never used. [unreadVariable]
    int   rc           = 0;
                       ^
nw/nwlib.c:241:18: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
        if ((err = NXKeySetValue(key, thread_data))) {
                 ^
nw/nwlib.c:238:23: note: err is assigned
          err         = ENOMEM;
                      ^
nw/nwlib.c:241:18: note: err is overwritten
        if ((err = NXKeySetValue(key, thread_data))) {
                 ^
os400/os400sys.c:145:11: warning: The obsolete function 'alloca' is called. In C99 and later it is recommended to use a variable length array or a dynamically allocated array instead. The function 'alloca' is dangerous for many reasons (http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice and http://linux.die.net/man/3/alloca). [allocaCalled]
    buf = alloca(l);
          ^
os400/os400sys.c:192:18: warning: The obsolete function 'alloca' is called. In C99 and later it is recommended to use a variable length array or a dynamically allocated array instead. The function 'alloca' is dangerous for many reasons (http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice and http://linux.die.net/man/3/alloca). [allocaCalled]
    ebcversion = alloca(i + 1);
                 ^
os400/os400sys.c:210:18: warning: The obsolete function 'alloca' is called. In C99 and later it is recommended to use a variable length array or a dynamically allocated array instead. The function 'alloca' is dangerous for many reasons (http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice and http://linux.die.net/man/3/alloca). [allocaCalled]
    ebcversion = alloca(i + 1);
                 ^
src/agent.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/bcrypt_pbkdf.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/blowfish.c:428:11: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 uint32_t temp;
          ^
src/blowfish.c:467:11: style: The scope of the variable 'temp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
 uint32_t temp;
          ^
src/channel.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/channel.c:1027:9: style: The scope of the variable 'rc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int rc;
        ^
src/channel.c:1521:12: style: The scope of the variable 'namelen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t namelen = 0;
           ^
src/channel.c:1964:14: style: The scope of the variable 'read_local_id' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t read_local_id;
             ^
src/channel.c:2017:13: style: The scope of the variable 'wrote' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    ssize_t wrote = 0; /* counter for this specific this call */
            ^
src/channel.c:2251:9: style: The scope of the variable 'rc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int rc;
        ^
src/channel.c:2416:9: style: The scope of the variable 'rc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int rc;
        ^
src/channel.c:2483:9: style: The scope of the variable 'rc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int rc;
        ^
src/channel.c:1521:20: style: Variable 'namelen' is assigned a value that is never used. [unreadVariable]
    size_t namelen = 0;
                   ^
src/comp.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/crypt.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/global.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/hostkey.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/keepalive.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/kex.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/kex.c:399:9: error: Dangerous assignment - the function parameter is assigned the address of a local auto-variable. Local auto-variables are reserved from the stack which is freed when the function ends. So the pointer to a local variable is invalid after the function ends. [autoVariables]
        exchange_state->exchange_hash = (void *)&exchange_hash_ctx;
        ^
src/kex.c:1059:9: error: Dangerous assignment - the function parameter is assigned the address of a local auto-variable. Local auto-variables are reserved from the stack which is freed when the function ends. So the pointer to a local variable is invalid after the function ends. [autoVariables]
        exchange_state->exchange_hash = (void *)&exchange_hash_ctx;
        ^
src/kex.c:569:13: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA1_HASH(iv,
            ^
src/kex.c:577:13: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA1_HASH(secret,
            ^
src/kex.c:618:13: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA1_HASH(iv,
            ^
src/kex.c:626:13: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA1_HASH(secret,
            ^
src/kex.c:665:13: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA1_HASH(key,
            ^
src/kex.c:692:13: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA1_HASH(key,
            ^
src/kex.c:1231:13: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            LIBSSH2_KEX_METHOD_SHA_VALUE_HASH(256, iv,
            ^
src/kex.c:1239:13: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            LIBSSH2_KEX_METHOD_SHA_VALUE_HASH(256, secret,
            ^
src/kex.c:1280:13: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            LIBSSH2_KEX_METHOD_SHA_VALUE_HASH(256, iv,
            ^
src/kex.c:1288:13: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            LIBSSH2_KEX_METHOD_SHA_VALUE_HASH(256, secret,
            ^
src/kex.c:1327:13: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            LIBSSH2_KEX_METHOD_SHA_VALUE_HASH(256, key,
            ^
src/kex.c:1354:13: style: The scope of the variable 'len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
            LIBSSH2_KEX_METHOD_SHA_VALUE_HASH(256, key,
            ^
src/kex.c:3241:12: style: The scope of the variable 'kex_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t kex_len, hostkey_len = 0;
           ^
src/kex.c:3241:21: style: The scope of the variable 'hostkey_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t kex_len, hostkey_len = 0;
                    ^
src/kex.c:3242:12: style: The scope of the variable 'crypt_cs_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t crypt_cs_len, crypt_sc_len;
           ^
src/kex.c:3242:26: style: The scope of the variable 'crypt_sc_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t crypt_cs_len, crypt_sc_len;
                         ^
src/kex.c:3243:12: style: The scope of the variable 'comp_cs_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t comp_cs_len, comp_sc_len;
           ^
src/kex.c:3243:25: style: The scope of the variable 'comp_sc_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t comp_cs_len, comp_sc_len;
                        ^
src/kex.c:3244:12: style: The scope of the variable 'mac_cs_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t mac_cs_len, mac_sc_len;
           ^
src/kex.c:3244:24: style: The scope of the variable 'mac_sc_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t mac_cs_len, mac_sc_len;
                       ^
src/kex.c:3245:12: style: The scope of the variable 'lang_cs_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t lang_cs_len, lang_sc_len;
           ^
src/kex.c:3245:25: style: The scope of the variable 'lang_sc_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t lang_cs_len, lang_sc_len;
                        ^
src/kex.c:3246:27: style: The scope of the variable 's' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *data, *s;
                          ^
src/kex.c:3241:33: style: Variable 'hostkey_len' is assigned a value that is never used. [unreadVariable]
    size_t kex_len, hostkey_len = 0;
                                ^
src/knownhost.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/knownhost.c:680:10: style: The scope of the variable 'hostbuf' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char hostbuf[256];
         ^
src/knownhost.c:958:10: style: The scope of the variable 'buf' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    char buf[2048];
         ^
src/libgcrypt.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/mac.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/mbedtls.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/misc.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/misc.c:728:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    buf = NULL;
    ^
src/misc.c:278:11: style: The scope of the variable 'v' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    short v;
          ^
src/misc.c:678:18: style: The scope of the variable 'val' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned int val, carry;
                 ^
src/openssl.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/openssl.c:2469:12: warning: Identical condition and return expression 'rc', return value is always 0 [identicalConditionAfterEarlyExit]
    return rc;
           ^
src/openssl.c:2465:8: note: If condition 'rc' is true, the function will return/exit
    if(rc) {
       ^
src/openssl.c:2469:12: note: Returning identical expression 'rc'
    return rc;
           ^
src/openssl.c:328:13: style: Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]
        ret = EC_KEY_set_public_key(ec_key, point);
            ^
src/openssl.c:327:13: note: ret is assigned
        ret = EC_POINT_oct2point(ec_group, point, k, k_len, NULL);
            ^
src/openssl.c:328:13: note: ret is overwritten
        ret = EC_KEY_set_public_key(ec_key, point);
            ^
src/openssl.c:2861:15: style: The scope of the variable 'rc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int       rc;
              ^
src/openssl.c:2587:19: style: The unsigned expression 'secret_len' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
    if(secret_len <= 0 || secret_len > EC_MAX_POINT_LEN) {
                  ^
src/os400qc3.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/os400qc3.c:1007:22: warning: The obsolete function 'alloca' is called. In C99 and later it is recommended to use a variable length array or a dynamically allocated array instead. The function 'alloca' is dangerous for many reasons (http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice and http://linux.die.net/man/3/alloca). [allocaCalled]
        char *lkey = alloca(minkeylen);
                     ^
src/os400qc3.c:1290:14: warning: The obsolete function 'alloca' is called. In C99 and later it is recommended to use a variable length array or a dynamically allocated array instead. The function 'alloca' is dangerous for many reasons (http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice and http://linux.die.net/man/3/alloca). [allocaCalled]
    pubkey = alloca(pubkeysize);
             ^
src/os400qc3.c:1312:14: warning: The obsolete function 'alloca' is called. In C99 and later it is recommended to use a variable length array or a dynamically allocated array instead. The function 'alloca' is dangerous for many reasons (http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice and http://linux.die.net/man/3/alloca). [allocaCalled]
    pubkey = alloca(pubkeysize);
             ^
src/os400qc3.c:1315:17: warning: The obsolete function 'alloca' is called. In C99 and later it is recommended to use a variable length array or a dynamically allocated array instead. The function 'alloca' is dangerous for many reasons (http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice and http://linux.die.net/man/3/alloca). [allocaCalled]
    secretbuf = alloca(pubkeysize);
                ^
src/os400qc3.c:1433:11: warning: The obsolete function 'alloca' is called. In C99 and later it is recommended to use a variable length array or a dynamically allocated array instead. The function 'alloca' is dangerous for many reasons (http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice and http://linux.die.net/man/3/alloca). [allocaCalled]
    mac = alloca(pkcs5->hashlen);
          ^
src/os400qc3.c:1884:11: warning: The obsolete function 'alloca' is called. In C99 and later it is recommended to use a variable length array or a dynamically allocated array instead. The function 'alloca' is dangerous for many reasons (http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice and http://linux.die.net/man/3/alloca). [allocaCalled]
    buf = alloca(datalen);
          ^
src/os400qc3.c:2079:38: warning: The obsolete function 'alloca' is called. In C99 and later it is recommended to use a variable length array or a dynamically allocated array instead. The function 'alloca' is dangerous for many reasons (http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice and http://linux.die.net/man/3/alloca). [allocaCalled]
            data = (unsigned char *) alloca(datalen);
                                     ^
src/os400qc3.c:1951:8: style: Condition '!prvk' is always false [knownConditionTrueFalse]
    if(!prvk) {
       ^
src/os400qc3.c:1947:8: note: Assuming that condition '!prvk' is not redundant
    if(!prvk)
       ^
src/os400qc3.c:1951:8: note: Condition '!prvk' is always false
    if(!prvk) {
       ^
src/os400qc3.c:1620:28: warning: Variable 'effkeysize' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]
                effkeysize = 64;
                           ^
src/os400qc3.c:1618:28: note: $symbol is assigned
                effkeysize = 40;
                           ^
src/os400qc3.c:1620:28: note: $symbol is overwritten
                effkeysize = 64;
                           ^
src/os400qc3.c:1622:28: warning: Variable 'effkeysize' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]
                effkeysize = 128;
                           ^
src/os400qc3.c:1620:28: note: $symbol is assigned
                effkeysize = 64;
                           ^
src/os400qc3.c:1622:28: note: $symbol is overwritten
                effkeysize = 128;
                           ^
src/os400qc3.c:432:18: style: The scope of the variable 'hdrl' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned int hdrl = 2;
                 ^
src/os400qc3.c:433:18: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned int i;
                 ^
src/os400qc3.c:505:20: style: The scope of the variable 'p' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *p;
                   ^
src/os400qc3.c:530:20: style: The scope of the variable 'bp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *bp;
                   ^
src/os400qc3.c:810:18: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned int i;
                 ^
src/os400qc3.c:811:19: style: The scope of the variable 'b' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char b;
                  ^
src/os400qc3.c:2009:9: style: The scope of the variable 'c' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int c;
        ^
src/os400qc3.c:2010:9: style: The scope of the variable 'ret' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int ret;
        ^
src/os400qc3.c:2046:12: style: The scope of the variable 'datalen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    size_t datalen = 0;
           ^
src/os400qc3.c:2048:10: style: The scope of the variable 'filesize' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    long filesize;
         ^
src/os400qc3.c:584:54: portability: Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.
The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.
The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.
In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.
To reproduce you might be able to use this little code example on 64bit platforms. If the output includes "ERROR", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the "ERROR" output go away.
#include <stdarg.h>
#include <stdio.h>

void f(char *s, ...) {
    va_list ap;
    va_start(ap,s);
    for (;;) {
        char *p = va_arg(ap,char*);
        printf("%018p, %s\n", p, (long)p & 255 ? p : "");
        if(!p) break;
    }
    va_end(ap);
}

void g() {
    char *s2 = "x";
    char *s3 = "ERROR";

    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64
    f("first", s2, s2, s2, s2, s2, 0, s3, (char*)0);
}

void h() {
    int i;
    volatile unsigned char a[1000];
    for (i = 0; i<sizeof(a); i++)
        a[i] = -1;
}

int main() {
    h();
    g();
    return 0;
} [varFuncNullUB]
                              modulus, publicexponent, NULL);
                                                     ^
src/os400qc3.c:624:65: portability: Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.
The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.
The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.
In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.
To reproduce you might be able to use this little code example on 64bit platforms. If the output includes "ERROR", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the "ERROR" output go away.
#include <stdarg.h>
#include <stdio.h>

void f(char *s, ...) {
    va_list ap;
    va_start(ap,s);
    for (;;) {
        char *p = va_arg(ap,char*);
        printf("%018p, %s\n", p, (long)p & 255 ? p : "");
        if(!p) break;
    }
    va_end(ap);
}

void g() {
    char *s2 = "x";
    char *s3 = "ERROR";

    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64
    f("first", s2, s2, s2, s2, s2, 0, s3, (char*)0);
}

void h() {
    int i;
    volatile unsigned char a[1000];
    for (i = 0; i<sizeof(a); i++)
        a[i] = -1;
}

int main() {
    h();
    g();
    return 0;
} [varFuncNullUB]
                               exponent1, exponent2, coefficient, NULL);
                                                                ^
src/os400qc3.c:656:54: portability: Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.
The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.
The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.
In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.
To reproduce you might be able to use this little code example on 64bit platforms. If the output includes "ERROR", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the "ERROR" output go away.
#include <stdarg.h>
#include <stdio.h>

void f(char *s, ...) {
    va_list ap;
    va_start(ap,s);
    for (;;) {
        char *p = va_arg(ap,char*);
        printf("%018p, %s\n", p, (long)p & 255 ? p : "");
        if(!p) break;
    }
    va_end(ap);
}

void g() {
    char *s2 = "x";
    char *s3 = "ERROR";

    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64
    f("first", s2, s2, s2, s2, s2, 0, s3, (char*)0);
}

void h() {
    int i;
    volatile unsigned char a[1000];
    for (i = 0; i<sizeof(a); i++)
        a[i] = -1;
}

int main() {
    h();
    g();
    return 0;
} [varFuncNullUB]
                                algorithm, parameters, NULL);
                                                     ^
src/os400qc3.c:658:38: portability: Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.
The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.
The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.
In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.
To reproduce you might be able to use this little code example on 64bit platforms. If the output includes "ERROR", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the "ERROR" output go away.
#include <stdarg.h>
#include <stdio.h>

void f(char *s, ...) {
    va_list ap;
    va_start(ap,s);
    for (;;) {
        char *p = va_arg(ap,char*);
        printf("%018p, %s\n", p, (long)p & 255 ? p : "");
        if(!p) break;
    }
    va_end(ap);
}

void g() {
    char *s2 = "x";
    char *s3 = "ERROR";

    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64
    f("first", s2, s2, s2, s2, s2, 0, s3, (char*)0);
}

void h() {
    int i;
    volatile unsigned char a[1000];
    for (i = 0; i<sizeof(a); i++)
        a[i] = -1;
}

int main() {
    h();
    g();
    return 0;
} [varFuncNullUB]
                               pubkey, NULL);
                                     ^
src/os400qc3.c:660:59: portability: Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.
The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.
The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.
In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.
To reproduce you might be able to use this little code example on 64bit platforms. If the output includes "ERROR", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the "ERROR" output go away.
#include <stdarg.h>
#include <stdio.h>

void f(char *s, ...) {
    va_list ap;
    va_start(ap,s);
    for (;;) {
        char *p = va_arg(ap,char*);
        printf("%018p, %s\n", p, (long)p & 255 ? p : "");
        if(!p) break;
    }
    va_end(ap);
}

void g() {
    char *s2 = "x";
    char *s3 = "ERROR";

    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64
    f("first", s2, s2, s2, s2, s2, 0, s3, (char*)0);
}

void h() {
    int i;
    volatile unsigned char a[1000];
    for (i = 0; i<sizeof(a); i++)
        a[i] = -1;
}

int main() {
    h();
    g();
    return 0;
} [varFuncNullUB]
                                   algorithmid, subjpubkey, NULL);
                                                          ^
src/os400qc3.c:703:62: portability: Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.
The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.
The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.
In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.
To reproduce you might be able to use this little code example on 64bit platforms. If the output includes "ERROR", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the "ERROR" output go away.
#include <stdarg.h>
#include <stdio.h>

void f(char *s, ...) {
    va_list ap;
    va_start(ap,s);
    for (;;) {
        char *p = va_arg(ap,char*);
        printf("%018p, %s\n", p, (long)p & 255 ? p : "");
        if(!p) break;
    }
    va_end(ap);
}

void g() {
    char *s2 = "x";
    char *s3 = "ERROR";

    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64
    f("first", s2, s2, s2, s2, s2, 0, s3, (char*)0);
}

void h() {
    int i;
    volatile unsigned char a[1000];
    for (i = 0; i<sizeof(a); i++)
        a[i] = -1;
}

int main() {
    h();
    g();
    return 0;
} [varFuncNullUB]
                                        algorithm, parameters, NULL);
                                                             ^
src/os400qc3.c:704:58: portability: Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.
The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.
The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.
In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.
To reproduce you might be able to use this little code example on 64bit platforms. If the output includes "ERROR", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the "ERROR" output go away.
#include <stdarg.h>
#include <stdio.h>

void f(char *s, ...) {
    va_list ap;
    va_start(ap,s);
    for (;;) {
        char *p = va_arg(ap,char*);
        printf("%018p, %s\n", p, (long)p & 255 ? p : "");
        if(!p) break;
    }
    va_end(ap);
}

void g() {
    char *s2 = "x";
    char *s3 = "ERROR";

    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64
    f("first", s2, s2, s2, s2, s2, 0, s3, (char*)0);
}

void h() {
    int i;
    volatile unsigned char a[1000];
    for (i = 0; i<sizeof(a); i++)
        a[i] = -1;
}

int main() {
    h();
    g();
    return 0;
} [varFuncNullUB]
    privatekey = asn1container(ASN1_OCTET_STRING, privkey, NULL);
                                                         ^
src/os400qc3.c:706:64: portability: Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.
The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.
The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.
In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.
To reproduce you might be able to use this little code example on 64bit platforms. If the output includes "ERROR", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the "ERROR" output go away.
#include <stdarg.h>
#include <stdio.h>

void f(char *s, ...) {
    va_list ap;
    va_start(ap,s);
    for (;;) {
        char *p = va_arg(ap,char*);
        printf("%018p, %s\n", p, (long)p & 255 ? p : "");
        if(!p) break;
    }
    va_end(ap);
}

void g() {
    char *s2 = "x";
    char *s3 = "ERROR";

    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64
    f("first", s2, s2, s2, s2, s2, 0, s3, (char*)0);
}

void h() {
    int i;
    volatile unsigned char a[1000];
    for (i = 0; i<sizeof(a); i++)
        a[i] = -1;
}

int main() {
    h();
    g();
    return 0;
} [varFuncNullUB]
                                privatekeyalgorithm, privatekey, NULL);
                                                               ^
src/os400qc3.c:1274:44: portability: Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.
The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.
The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.
In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.
To reproduce you might be able to use this little code example on 64bit platforms. If the output includes "ERROR", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the "ERROR" output go away.
#include <stdarg.h>
#include <stdio.h>

void f(char *s, ...) {
    va_list ap;
    va_start(ap,s);
    for (;;) {
        char *p = va_arg(ap,char*);
        printf("%018p, %s\n", p, (long)p & 255 ? p : "");
        if(!p) break;
    }
    va_end(ap);
}

void g() {
    char *s2 = "x";
    char *s3 = "ERROR";

    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64
    f("first", s2, s2, s2, s2, s2, 0, s3, (char*)0);
}

void h() {
    int i;
    volatile unsigned char a[1000];
    for (i = 0; i<sizeof(a); i++)
        a[i] = -1;
}

int main() {
    h();
    g();
    return 0;
} [varFuncNullUB]
                                prime, base, NULL);
                                           ^
src/os400qc3.c:1280:54: portability: Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.
The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.
The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.
In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.
To reproduce you might be able to use this little code example on 64bit platforms. If the output includes "ERROR", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the "ERROR" output go away.
#include <stdarg.h>
#include <stdio.h>

void f(char *s, ...) {
    va_list ap;
    va_start(ap,s);
    for (;;) {
        char *p = va_arg(ap,char*);
        printf("%018p, %s\n", p, (long)p & 255 ? p : "");
        if(!p) break;
    }
    va_end(ap);
}

void g() {
    char *s2 = "x";
    char *s3 = "ERROR";

    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64
    f("first", s2, s2, s2, s2, s2, 0, s3, (char*)0);
}

void h() {
    int i;
    volatile unsigned char a[1000];
    for (i = 0; i<sizeof(a); i++)
        a[i] = -1;
}

int main() {
    h();
    g();
    return 0;
} [varFuncNullUB]
                          dhkeyagreement, dhparameter, NULL);
                                                     ^
src/os400qc3.c:1439:11: warning: Expression 'l' can have a negative value. That is converted to an unsigned value and used in an unsigned calculation. [signConversionCond]
    buf = LIBSSH2_ALLOC(session, l * pkcs5->hashlen);
          ^
src/os400qc3.c:1431:10: note: Assuming that condition 't>4294967295U' is not redundant
    if(t > 0xFFFFFFFF)
         ^
src/os400qc3.c:1438:9: note: Assignment 'l=t', assigned value is -1
    l = t;
        ^
src/os400qc3.c:1439:11: note: Negative value is converted to an unsigned value
    buf = LIBSSH2_ALLOC(session, l * pkcs5->hashlen);
          ^
src/os400qc3.c:1378:16: style: Variable 'data' is assigned a value that is never used. [unreadVariable]
    char *data = (char *) pkcs5->salt;
               ^
src/os400qc3.c:1541:23: style: Variable 'keyLength' is assigned a value that is never used. [unreadVariable]
            keyLength = prf;
                      ^
src/os400qc3.c:1689:12: style: Unused variable: pplen [unusedVariable]
    size_t pplen;
           ^
src/os400qc3.c:1691:19: style: Unused variable: t [unusedVariable]
    unsigned long t;
                  ^
src/os400qc3.c:1692:9: style: Unused variable: i [unusedVariable]
    int i;
        ^
src/os400qc3.c:1857:8: style: Variable 'cp' is assigned a value that is never used. [unreadVariable]
    cp = storewithlength(cp, m.beg, m.end - m.beg);
       ^
src/os400qc3.c:1879:17: style: Unused variable: parameters [unusedVariable]
    asn1Element parameters;
                ^
src/os400qc3.c:2046:20: style: Variable 'datalen' is assigned a value that is never used. [unreadVariable]
    size_t datalen = 0;
                   ^
src/os400qc3.c:2275:17: style: Unused variable: meth [unusedVariable]
    const char *meth;
                ^
src/packet.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/packet.c:233:29: style: Variable 'listen_state->state' is reassigned a value before the old one has been used. [redundantAssignment]
        listen_state->state = libssh2_NB_state_sent;
                            ^
src/packet.c:138:45: note: listen_state->state is assigned
                        listen_state->state = libssh2_NB_state_sent;
                                            ^
src/packet.c:233:29: note: listen_state->state is overwritten
        listen_state->state = libssh2_NB_state_sent;
                            ^
src/packet.c:233:29: style: Variable 'listen_state->state' is reassigned a value before the old one has been used. [redundantAssignment]
        listen_state->state = libssh2_NB_state_sent;
                            ^
src/packet.c:148:45: note: listen_state->state is assigned
                        listen_state->state = libssh2_NB_state_sent;
                                            ^
src/packet.c:233:29: note: listen_state->state is overwritten
        listen_state->state = libssh2_NB_state_sent;
                            ^
src/packet.c:233:29: style: Variable 'listen_state->state' is reassigned a value before the old one has been used. [redundantAssignment]
        listen_state->state = libssh2_NB_state_sent;
                            ^
src/packet.c:165:45: note: listen_state->state is assigned
                        listen_state->state = libssh2_NB_state_sent;
                                            ^
src/packet.c:233:29: note: listen_state->state is overwritten
        listen_state->state = libssh2_NB_state_sent;
                            ^
src/packet.c:1009:32: style: Variable 'session->packAdd_state' is reassigned a value before the old one has been used. [redundantAssignment]
        session->packAdd_state = libssh2_NB_state_idle;
                               ^
src/packet.c:998:36: note: session->packAdd_state is assigned
            session->packAdd_state = libssh2_NB_state_sent2;
                                   ^
src/packet.c:1009:32: note: session->packAdd_state is overwritten
        session->packAdd_state = libssh2_NB_state_idle;
                               ^
src/packet.c:1166:19: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char i, all_packets[255];
                  ^
src/packet.c:1166:22: style: The scope of the variable 'all_packets' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char i, all_packets[255];
                     ^
src/packet.c:1167:9: style: The scope of the variable 'ret' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int ret;
        ^
src/pem.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/pem.c:711:8: style: Condition 'b64data' is always true [knownConditionTrueFalse]
    if(b64data) {
       ^
src/pem.c:701:8: note: Assuming that condition '!b64data' is not redundant
    if(!b64data) {
       ^
src/pem.c:711:8: note: Condition 'b64data' is always true
    if(b64data) {
       ^
src/pem.c:523:69: style: The unsigned expression 'salt_len=_libssh2_get_c_string(&kdf_buf,&salt)' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
            if(((salt_len = _libssh2_get_c_string(&kdf_buf, &salt)) <= 0) ||
                                                                    ^
src/pem.c:733:41: style: The unsigned expression 'filedata_len' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
    if(filedata == NULL || filedata_len <= 0) {
                                        ^
src/publickey.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/publickey.c:138:19: style: The scope of the variable 'buffer' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char buffer[4];
                  ^
src/publickey.c:235:9: style: The scope of the variable 'response' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int response;
        ^
src/publickey.c:552:19: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned long i, packet_len = 19 + name_len + blob_len;
                  ^
src/publickey.c:554:19: style: The scope of the variable 'comment_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned long comment_len = 0;
                  ^
src/scp.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/session.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/session.c:150:14: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [knownConditionTrueFalse]
        if(c == '\0') {
             ^
src/session.c:114:18: note: 'c' is assigned value ''\0'' here.
        char c = '\0';
                 ^
src/session.c:150:14: note: The expression 'c == '\0'' is always true because 'c' and ''\0'' represent the same value.
        if(c == '\0') {
             ^
src/session.c:99:9: style: The scope of the variable 'ret' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int ret;
        ^
src/session.c:576:10: style: The scope of the variable 'elapsed_ms' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    long elapsed_ms;
         ^
src/session.c:847:22: style: The scope of the variable 'ch' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    LIBSSH2_CHANNEL *ch;
                     ^
src/session.c:848:23: style: The scope of the variable 'l' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    LIBSSH2_LISTENER *l;
                      ^
src/session.c:1109:19: style: The scope of the variable 'descr_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned long descr_len = 0, lang_len = 0;
                  ^
src/sftp.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/sftp.c:510:9: style: The scope of the variable 'rc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int rc;
        ^
src/sftp.c:550:9: style: The scope of the variable 'rc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int rc;
        ^
src/sftp.c:1871:14: style: The scope of the variable 'retcode' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t retcode;
             ^
src/sftp.c:1872:14: style: The scope of the variable 'packet_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint32_t packet_len;
             ^
src/transport.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/transport.c:737:16: warning: Identical condition and return expression 'rc', return value is always 0 [identicalConditionAfterEarlyExit]
        return rc;
               ^
src/transport.c:730:8: note: If condition 'rc' is true, the function will return/exit
    if(rc)
       ^
src/transport.c:737:16: note: Returning identical expression 'rc'
        return rc;
               ^
src/transport.c:167:19: style: The scope of the variable 'macbuf' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char macbuf[MAX_MACSIZE];
                  ^
src/transport.c:170:9: style: The scope of the variable 'compressed' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    int compressed;
        ^
src/userauth.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/userauth.c:70:19: style: The scope of the variable 'methods_len' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned long methods_len;
                  ^
src/userauth.c:1391:27: style: Variable 'pubkeydata_len' is assigned a value that is never used. [unreadVariable]
    size_t pubkeydata_len = 0;
                          ^
src/userauth.c:1393:20: style: Variable 'abstract' is assigned a value that is never used. [unreadVariable]
    void *abstract = &privkey_file;
                   ^
src/userauth.c:1453:27: style: Variable 'pubkeydata_len' is assigned a value that is never used. [unreadVariable]
    size_t pubkeydata_len = 0;
                          ^
src/userauth.c:1455:20: style: Variable 'abstract' is assigned a value that is never used. [unreadVariable]
    void *abstract = &privkey_file;
                   ^
src/version.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/wincng.c:0:0: information: The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. [toomanyconfigs]

^
src/wincng.c:583:8: style: Condition 'ret' is always true [knownConditionTrueFalse]
    if(ret && tryLoadRSA) {
       ^
src/wincng.c:581:16: note: Assignment 'ret=-1', assigned value is -1
    int ret = -1;
               ^
src/wincng.c:583:8: note: Condition 'ret' is always true
    if(ret && tryLoadRSA) {
       ^
src/wincng.c:618:8: style: Condition 'ret' is always true [knownConditionTrueFalse]
    if(ret && tryLoadRSA) {
       ^
src/wincng.c:614:16: note: Assignment 'ret=-1', assigned value is -1
    int ret = -1;
               ^
src/wincng.c:618:8: note: Condition 'ret' is always true
    if(ret && tryLoadRSA) {
       ^
src/wincng.c:755:43: style: The scope of the variable 'index' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned long cbDecoded, *rcbDecoded, index, length;
                                          ^
src/wincng.c:755:50: style: The scope of the variable 'length' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned long cbDecoded, *rcbDecoded, index, length;
                                                 ^
src/wincng.c:1108:36: style: The scope of the variable 'siglen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned long cbData, datalen, siglen;
                                   ^
src/wincng.c:1399:27: style: The scope of the variable 'sig' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *data, *sig;
                          ^
src/wincng.c:1400:36: style: The scope of the variable 'siglen' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned long cbData, datalen, siglen;
                                   ^
src/wincng.c:1786:20: style: The scope of the variable 'pbOutput' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *pbOutput, *pbInput;
                   ^
src/wincng.c:1952:26: style: The scope of the variable 'bignum' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    unsigned char *key, *bignum;
                         ^
tests/openssh_fixture.c:257:9: style: Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]
    ret = sock;
        ^
tests/openssh_fixture.c:229:13: note: ret is assigned
        ret = -1;
            ^
tests/openssh_fixture.c:257:9: note: ret is overwritten
    ret = sock;
        ^
tests/openssh_fixture.c:167:24: style: Variable 'attempt_no' is assigned a value that is never used. [unreadVariable]
        int attempt_no = 0;
                       ^
tests/openssh_fixture.c:168:23: style: Variable 'wait_time' is assigned a value that is never used. [unreadVariable]
        int wait_time = 500;
                      ^
tests/session_fixture.c:99:11: error: Using pointer to local variable 'wd_buf' that is out of scope. [invalidLifetime]
    chdir(wd);
          ^
tests/session_fixture.c:96:14: note: Array decayed to pointer here.
        wd = wd_buf;
             ^
tests/session_fixture.c:93:14: note: Variable created here.
        char wd_buf[MAXPATHLEN];
             ^
tests/session_fixture.c:99:11: note: Using pointer to local variable 'wd_buf' that is out of scope.
    chdir(wd);
          ^
tests/session_fixture.c:86:0: information: Skipping configuration 'FIXTURE_WORKDIR' since the value of 'FIXTURE_WORKDIR' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        wd = FIXTURE_WORKDIR;
^
tests/session_fixture.c:99:11: error: Using pointer to local variable 'wd_buf' that is out of scope. [invalidLifetime]
    chdir(wd);
          ^
tests/session_fixture.c:96:14: note: Array decayed to pointer here.
        wd = wd_buf;
             ^
tests/session_fixture.c:91:14: note: Variable created here.
        char wd_buf[_MAX_PATH];
             ^
tests/session_fixture.c:99:11: note: Using pointer to local variable 'wd_buf' that is out of scope.
    chdir(wd);
          ^
tests/simple.c:58:9: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
        fprintf(stderr,
        ^
tests/test_hostkey.c:52:9: warning: %ld in format string (no. 1) requires 'long' but the argument type is 'unsigned long'. [invalidPrintfArgType_sint]
        fprintf(stderr, "Hostkey does not have the expected length %ld != %d\n",
        ^
tests/test_hostkey.c:52:9: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
        fprintf(stderr, "Hostkey does not have the expected length %ld != %d\n",
        ^
tests/test_public_key_auth_succeeds_with_correct_ed25519_key_from_mem.c:53:9: style: Unused variable: rc [unusedVariable]
    int rc;
        ^
vms/man2help.c:183:12: style: Expression is always true because 'else if' condition is opposite to previous condition at line 179. [multiCondition]
        if ( !( status&1)) break;
           ^
vms/man2help.c:179:17: note: first condition
    if ( (status&1) ){
                ^
vms/man2help.c:183:12: note: else if condition is opposite to first condition
        if ( !( status&1)) break;
           ^
vms/man2help.c:211:20: error: Memory leak: in [memleak]
if ( man == NULL ) return(vaxc$errno);
                   ^
vms/man2help.c:211:20: error: Memory leak: uit [memleak]
if ( man == NULL ) return(vaxc$errno);
                   ^
vms/man2help.c:427:20: error: Resource leak: hlp [resourceLeak]
if ( !(status&1) ) return( status );
                   ^
vms/man2help.c:29:10: style: The scope of the variable 'is' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
char    *is, *os;
         ^
vms/man2help.c:29:15: style: The scope of the variable 'os' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
char    *is, *os;
              ^
vms/man2help.c:30:5: style: The scope of the variable 'i' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
int i;
    ^
src/openssl.c:856:6: error: Null pointer dereference: method_len [ctunullpointer]
    *method_len     = 7;
     ^
src/openssl.c:1088:54: note: Calling function gen_publickey_from_rsa_openssh_priv_data, 4th argument is null
        rc = gen_publickey_from_rsa_openssh_priv_data(session, decrypted,
                                                     ^
src/openssl.c:1021:14: note: Calling function gen_publickey_from_rsa_evp, 3rd argument is null
        rc = gen_publickey_from_rsa_evp(session, method, method_len,
             ^
src/openssl.c:856:6: note: Dereferencing argument method_len that is null
    *method_len     = 7;
     ^
src/openssl.c:858:6: error: Null pointer dereference: pubkeydata_len [ctunullpointer]
    *pubkeydata_len = key_len;
     ^
src/openssl.c:1088:54: note: Calling function gen_publickey_from_rsa_openssh_priv_data, 6th argument is null
        rc = gen_publickey_from_rsa_openssh_priv_data(session, decrypted,
                                                     ^
src/openssl.c:1021:14: note: Calling function gen_publickey_from_rsa_evp, 5th argument is null
        rc = gen_publickey_from_rsa_evp(session, method, method_len,
             ^
src/openssl.c:858:6: note: Dereferencing argument pubkeydata_len that is null
    *pubkeydata_len = key_len;
     ^
src/openssl.c:1242:6: error: Null pointer dereference: method_len [ctunullpointer]
    *method_len     = 7;
     ^
src/openssl.c:1387:54: note: Calling function gen_publickey_from_dsa_openssh_priv_data, 4th argument is null
        rc = gen_publickey_from_dsa_openssh_priv_data(session, decrypted,
                                                     ^
src/openssl.c:1320:14: note: Calling function gen_publickey_from_dsa_evp, 3rd argument is null
        rc = gen_publickey_from_dsa_evp(session, method, method_len,
             ^
src/openssl.c:1242:6: note: Dereferencing argument method_len that is null
    *method_len     = 7;
     ^
src/openssl.c:1244:6: error: Null pointer dereference: pubkeydata_len [ctunullpointer]
    *pubkeydata_len = key_len;
     ^
src/openssl.c:1387:54: note: Calling function gen_publickey_from_dsa_openssh_priv_data, 6th argument is null
        rc = gen_publickey_from_dsa_openssh_priv_data(session, decrypted,
                                                     ^
src/openssl.c:1320:14: note: Calling function gen_publickey_from_dsa_evp, 5th argument is null
        rc = gen_publickey_from_dsa_evp(session, method, method_len,
             ^
src/openssl.c:1244:6: note: Dereferencing argument pubkeydata_len that is null
    *pubkeydata_len = key_len;
     ^
nw/nwlib.c:138:0: style: The function 'GetOrSetUpData' is never used. [unusedFunction]

^
nw/nwlib.c:133:0: style: The function '_NonAppCheckUnload' is never used. [unusedFunction]

^
nw/nwlib.c:48:0: style: The function '_NonAppStart' is never used. [unusedFunction]

^
nw/keepscreen.c:14:0: style: The function '_NonAppStop' is never used. [unusedFunction]

^
src/os400qc3.c:870:0: style: The function '_libssh2_bn_from_bn' is never used. [unusedFunction]

^
src/openssl.c:3166:0: style: The function '_libssh2_dh_dtor' is never used. [unusedFunction]

^
src/openssl.c:3139:0: style: The function '_libssh2_dh_init' is never used. [unusedFunction]

^
src/openssl.c:3145:0: style: The function '_libssh2_dh_key_pair' is never used. [unusedFunction]

^
src/openssl.c:3156:0: style: The function '_libssh2_dh_secret' is never used. [unusedFunction]

^
src/openssl.c:1402:0: style: The function '_libssh2_dsa_new_private' is never used. [unusedFunction]

^
src/openssl.c:1126:0: style: The function '_libssh2_dsa_new_private_frommemory' is never used. [unusedFunction]

^
src/openssl.c:1844:0: style: The function '_libssh2_dsa_sha1_sign' is never used. [unusedFunction]

^
src/openssl.c:228:0: style: The function '_libssh2_dsa_sha1_verify' is never used. [unusedFunction]

^
src/openssl.c:2548:0: style: The function '_libssh2_ecdh_gen_k' is never used. [unusedFunction]

^
src/openssl.c:2481:0: style: The function '_libssh2_ecdsa_create_key' is never used. [unusedFunction]

^
src/openssl.c:2451:0: style: The function '_libssh2_ecdsa_new_private' is never used. [unusedFunction]

^
src/openssl.c:1429:0: style: The function '_libssh2_ecdsa_new_private_frommemory' is never used. [unusedFunction]

^
src/openssl.c:1890:0: style: The function '_libssh2_ecdsa_sign' is never used. [unusedFunction]

^
src/openssl.c:350:0: style: The function '_libssh2_ecdsa_verify' is never used. [unusedFunction]

^
src/misc.c:553:0: style: The function '_libssh2_list_prev' is never used. [unusedFunction]

^
src/misc.c:747:0: style: The function '_libssh2_match_string' is never used. [unusedFunction]

^
src/openssl.c:2159:0: style: The function '_libssh2_md5_init' is never used. [unusedFunction]

^
src/openssl.c:663:0: style: The function '_libssh2_openssl_crypto_exit' is never used. [unusedFunction]

^
src/openssl.c:639:0: style: The function '_libssh2_openssl_crypto_init' is never used. [unusedFunction]

^
os400/os400sys.c:115:0: style: The function '_libssh2_os400_connect' is never used. [unusedFunction]

^
os400/os400sys.c:201:0: style: The function '_libssh2_os400_deflateInit_' is never used. [unusedFunction]

^
os400/os400sys.c:183:0: style: The function '_libssh2_os400_inflateInit_' is never used. [unusedFunction]

^
os400/os400sys.c:169:0: style: The function '_libssh2_os400_snprintf' is never used. [unusedFunction]

^
src/os400qc3.c:1326:0: style: The function '_libssh2_os400qc3_dh_dtor' is never used. [unusedFunction]

^
src/os400qc3.c:1247:0: style: The function '_libssh2_os400qc3_dh_init' is never used. [unusedFunction]

^
src/os400qc3.c:1253:0: style: The function '_libssh2_os400qc3_dh_key_pair' is never used. [unusedFunction]

^
src/os400qc3.c:1301:0: style: The function '_libssh2_os400qc3_dh_secret' is never used. [unusedFunction]

^
src/os400qc3.c:2373:0: style: The function '_libssh2_os400qc3_rsa_sha1_signv' is never used. [unusedFunction]

^
src/pem.c:862:0: style: The function '_libssh2_pem_decode_integer' is never used. [unusedFunction]

^
src/pem.c:834:0: style: The function '_libssh2_pem_decode_sequence' is never used. [unusedFunction]

^
src/openssl.c:1102:0: style: The function '_libssh2_rsa_new_private' is never used. [unusedFunction]

^
src/openssl.c:754:0: style: The function '_libssh2_rsa_new_private_frommemory' is never used. [unusedFunction]

^
src/openssl.c:1812:0: style: The function '_libssh2_rsa_sha1_sign' is never used. [unusedFunction]

^
src/openssl.c:157:0: style: The function '_libssh2_rsa_sha1_verify' is never used. [unusedFunction]

^
src/openssl.c:1951:0: style: The function '_libssh2_sha1_init' is never used. [unusedFunction]

^
src/openssl.c:2003:0: style: The function '_libssh2_sha256_init' is never used. [unusedFunction]

^
src/openssl.c:2055:0: style: The function '_libssh2_sha384_init' is never used. [unusedFunction]

^
src/openssl.c:2107:0: style: The function '_libssh2_sha512_init' is never used. [unusedFunction]

^
src/wincng.c:2073:0: style: The function '_libssh2_wincng_bignum_from_bin' is never used. [unusedFunction]

^
src/wincng.c:2023:0: style: The function '_libssh2_wincng_bignum_set_word' is never used. [unusedFunction]

^
src/wincng.c:2108:0: style: The function '_libssh2_wincng_bignum_to_bin' is never used. [unusedFunction]

^
src/wincng.c:1780:0: style: The function '_libssh2_wincng_cipher_crypt' is never used. [unusedFunction]

^
src/wincng.c:1842:0: style: The function '_libssh2_wincng_cipher_dtor' is never used. [unusedFunction]

^
src/wincng.c:1681:0: style: The function '_libssh2_wincng_cipher_init' is never used. [unusedFunction]

^
src/wincng.c:1439:0: style: The function '_libssh2_wincng_dsa_free' is never used. [unusedFunction]

^
src/wincng.c:1321:0: style: The function '_libssh2_wincng_dsa_new_private' is never used. [unusedFunction]

^
src/wincng.c:1352:0: style: The function '_libssh2_wincng_dsa_new_private_frommemory' is never used. [unusedFunction]

^
src/wincng.c:1394:0: style: The function '_libssh2_wincng_dsa_sha1_sign' is never used. [unusedFunction]

^
src/wincng.c:1385:0: style: The function '_libssh2_wincng_dsa_sha1_verify' is never used. [unusedFunction]

^
src/wincng.c:296:0: style: The function '_libssh2_wincng_free' is never used. [unusedFunction]

^
src/wincng.c:463:0: style: The function '_libssh2_wincng_hmac_cleanup' is never used. [unusedFunction]

^
src/wincng.c:452:0: style: The function '_libssh2_wincng_hmac_final' is never used. [unusedFunction]

^
src/wincng.c:212:0: style: The function '_libssh2_wincng_init' is never used. [unusedFunction]

^
src/wincng.c:1599:0: style: The function '_libssh2_wincng_pub_priv_keyfile' is never used. [unusedFunction]

^
src/wincng.c:1636:0: style: The function '_libssh2_wincng_pub_priv_keyfilememory' is never used. [unusedFunction]

^
src/wincng.c:1149:0: style: The function '_libssh2_wincng_rsa_free' is never used. [unusedFunction]

^
src/wincng.c:838:0: style: The function '_libssh2_wincng_rsa_new' is never used. [unusedFunction]

^
src/wincng.c:1020:0: style: The function '_libssh2_wincng_rsa_new_private' is never used. [unusedFunction]

^
src/wincng.c:1053:0: style: The function '_libssh2_wincng_rsa_new_private_frommemory' is never used. [unusedFunction]

^
src/wincng.c:1099:0: style: The function '_libssh2_wincng_rsa_sha1_sign' is never used. [unusedFunction]

^
src/wincng.c:1088:0: style: The function '_libssh2_wincng_rsa_sha1_verify' is never used. [unusedFunction]

^
src/blowfish.c:609:0: style: The function 'blf_cbc_decrypt' is never used. [unusedFunction]

^
src/blowfish.c:584:0: style: The function 'blf_cbc_encrypt' is never used. [unusedFunction]

^
src/blowfish.c:527:0: style: The function 'blf_dec' is never used. [unusedFunction]

^
src/blowfish.c:562:0: style: The function 'blf_ecb_decrypt' is never used. [unusedFunction]

^
src/blowfish.c:540:0: style: The function 'blf_ecb_encrypt' is never used. [unusedFunction]

^
src/blowfish.c:504:0: style: The function 'blf_key' is never used. [unusedFunction]

^
src/crypt.c:109:0: style: The function 'crypt_dtor' is never used. [unusedFunction]

^
src/crypt.c:99:0: style: The function 'crypt_encrypt' is never used. [unusedFunction]

^
src/crypt.c:75:0: style: The function 'crypt_init' is never used. [unusedFunction]

^
src/session.c:455:0: style: The function 'libssh2_banner_set' is never used. [unusedFunction]

^
src/channel.c:1473:0: style: The function 'libssh2_channel_flush_ex' is never used. [unusedFunction]

^
src/channel.c:1755:0: style: The function 'libssh2_channel_handle_extended_data' is never used. [unusedFunction]

^
src/channel.c:340:0: style: The function 'libssh2_channel_open_ex' is never used. [unusedFunction]

^
src/channel.c:1362:0: style: The function 'libssh2_channel_process_startup' is never used. [unusedFunction]

^
src/channel.c:1931:0: style: The function 'libssh2_channel_read_ex' is never used. [unusedFunction]

^
src/channel.c:1652:0: style: The function 'libssh2_channel_receive_window_adjust' is never used. [unusedFunction]

^
src/channel.c:1683:0: style: The function 'libssh2_channel_receive_window_adjust2' is never used. [unusedFunction]

^
src/channel.c:1004:0: style: The function 'libssh2_channel_request_pty_ex' is never used. [unusedFunction]

^
src/channel.c:1080:0: style: The function 'libssh2_channel_request_pty_size_ex' is never used. [unusedFunction]

^
src/channel.c:1385:0: style: The function 'libssh2_channel_set_blocking' is never used. [unusedFunction]

^
src/channel.c:883:0: style: The function 'libssh2_channel_setenv_ex' is never used. [unusedFunction]

^
src/channel.c:2627:0: style: The function 'libssh2_channel_window_write_ex' is never used. [unusedFunction]

^
src/channel.c:1232:0: style: The function 'libssh2_channel_x11_req_ex' is never used. [unusedFunction]

^
src/misc.c:403:0: style: The function 'libssh2_free' is never used. [unusedFunction]

^
os400/ccsid.c:222:0: style: The function 'libssh2_from_ccsid' is never used. [unusedFunction]

^
src/keepalive.c:45:0: style: The function 'libssh2_keepalive_config' is never used. [unusedFunction]

^
src/knownhost.c:283:0: style: The function 'libssh2_knownhost_add' is never used. [unusedFunction]

^
src/knownhost.c:321:0: style: The function 'libssh2_knownhost_addc' is never used. [unusedFunction]

^
src/knownhost.c:564:0: style: The function 'libssh2_knownhost_del' is never used. [unusedFunction]

^
src/knownhost.c:1247:0: style: The function 'libssh2_knownhost_get' is never used. [unusedFunction]

^
src/knownhost.c:1167:0: style: The function 'libssh2_knownhost_writeline' is never used. [unusedFunction]

^
src/os400qc3.c:989:0: style: The function 'libssh2_os400qc3_hash' is never used. [unusedFunction]

^
src/publickey.c:542:0: style: The function 'libssh2_publickey_add_ex' is never used. [unusedFunction]

^
src/publickey.c:525:0: style: The function 'libssh2_publickey_init' is never used. [unusedFunction]

^
src/publickey.c:773:0: style: The function 'libssh2_publickey_list_fetch' is never used. [unusedFunction]

^
src/publickey.c:689:0: style: The function 'libssh2_publickey_remove_ex' is never used. [unusedFunction]

^
src/publickey.c:1039:0: style: The function 'libssh2_publickey_shutdown' is never used. [unusedFunction]

^
os400/ccsid.c:240:0: style: The function 'libssh2_release_string_cache' is never used. [unusedFunction]

^
src/scp.c:774:0: style: The function 'libssh2_scp_recv' is never used. [unusedFunction]

^
src/scp.c:1126:0: style: The function 'libssh2_scp_send64' is never used. [unusedFunction]

^
src/scp.c:1110:0: style: The function 'libssh2_scp_send_ex' is never used. [unusedFunction]

^
src/session.c:1237:0: style: The function 'libssh2_session_abstract' is never used. [unusedFunction]

^
src/session.c:1796:0: style: The function 'libssh2_session_banner_get' is never used. [unusedFunction]

^
src/session.c:1155:0: style: The function 'libssh2_session_disconnect_ex' is never used. [unusedFunction]

^
src/session.c:1331:0: style: The function 'libssh2_session_flag' is never used. [unusedFunction]

^
src/session.c:1381:0: style: The function 'libssh2_session_get_blocking' is never used. [unusedFunction]

^
src/session.c:1403:0: style: The function 'libssh2_session_get_timeout' is never used. [unusedFunction]

^
src/kex.c:4027:0: style: The function 'libssh2_session_method_pref' is never used. [unusedFunction]

^
src/session.c:1174:0: style: The function 'libssh2_session_methods' is never used. [unusedFunction]

^
src/session.c:1316:0: style: The function 'libssh2_session_set_last_error' is never used. [unusedFunction]

^
src/session.c:1393:0: style: The function 'libssh2_session_set_timeout' is never used. [unusedFunction]

^
src/kex.c:4143:0: style: The function 'libssh2_session_supported_algs' is never used. [unusedFunction]

^
src/sftp.c:2506:0: style: The function 'libssh2_sftp_close_handle' is never used. [unusedFunction]

^
src/sftp.c:2862:0: style: The function 'libssh2_sftp_fstatvfs' is never used. [unusedFunction]

^
src/sftp.c:2165:0: style: The function 'libssh2_sftp_fsync' is never used. [unusedFunction]

^
src/sftp.c:3494:0: style: The function 'libssh2_sftp_get_channel' is never used. [unusedFunction]

^
src/sftp.c:3103:0: style: The function 'libssh2_sftp_mkdir_ex' is never used. [unusedFunction]

^
src/sftp.c:1224:0: style: The function 'libssh2_sftp_open_ex' is never used. [unusedFunction]

^
src/sftp.c:2729:0: style: The function 'libssh2_sftp_rename_ex' is never used. [unusedFunction]

^
src/sftp.c:3197:0: style: The function 'libssh2_sftp_rmdir_ex' is never used. [unusedFunction]

^
src/sftp.c:2319:0: style: The function 'libssh2_sftp_seek' is never used. [unusedFunction]

^
src/sftp.c:3322:0: style: The function 'libssh2_sftp_stat_ex' is never used. [unusedFunction]

^
src/sftp.c:2989:0: style: The function 'libssh2_sftp_statvfs' is never used. [unusedFunction]

^
src/sftp.c:3465:0: style: The function 'libssh2_sftp_symlink_ex' is never used. [unusedFunction]

^
src/sftp.c:2328:0: style: The function 'libssh2_sftp_tell' is never used. [unusedFunction]

^
src/sftp.c:2343:0: style: The function 'libssh2_sftp_tell64' is never used. [unusedFunction]

^
src/sftp.c:2597:0: style: The function 'libssh2_sftp_unlink_ex' is never used. [unusedFunction]

^
os400/ccsid.c:231:0: style: The function 'libssh2_to_ccsid' is never used. [unusedFunction]

^
src/misc.c:501:0: style: The function 'libssh2_trace_sethandler' is never used. [unusedFunction]

^
src/userauth.c:1019:0: style: The function 'libssh2_userauth_hostbased_fromfile_ex' is never used. [unusedFunction]

^
src/userauth.c:1556:0: style: The function 'libssh2_userauth_publickey' is never used. [unusedFunction]

^
src/version.c:49:0: style: The function 'libssh2_version' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingInclude]


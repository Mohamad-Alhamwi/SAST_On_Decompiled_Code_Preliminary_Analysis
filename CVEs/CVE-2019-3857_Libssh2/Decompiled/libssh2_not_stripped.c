typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned char    dwfenc;
typedef unsigned int    dword;
typedef long long    longlong;
typedef unsigned long    qword;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined3;
typedef unsigned int    undefined4;
typedef unsigned long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef struct eh_frame_hdr eh_frame_hdr, *Peh_frame_hdr;

struct eh_frame_hdr {
    byte eh_frame_hdr_version; // Exception Handler Frame Header Version
    dwfenc eh_frame_pointer_encoding; // Exception Handler Frame Pointer Encoding
    dwfenc eh_frame_desc_entry_count_encoding; // Encoding of # of Exception Handler FDEs
    dwfenc eh_frame_table_encoding; // Exception Handler Table Encoding
};

typedef struct NoteGnuPropertyElement_4 NoteGnuPropertyElement_4, *PNoteGnuPropertyElement_4;

struct NoteGnuPropertyElement_4 {
    dword prType;
    dword prDatasz;
    byte data[4];
};

typedef struct fde_table_entry fde_table_entry, *Pfde_table_entry;

struct fde_table_entry {
    dword initial_loc; // Initial Location
    dword data_loc; // Data location
};

typedef struct hmac_ctx_st hmac_ctx_st, *Phmac_ctx_st;

typedef struct hmac_ctx_st HMAC_CTX;

typedef struct env_md_st env_md_st, *Penv_md_st;

typedef struct env_md_ctx_st env_md_ctx_st, *Penv_md_ctx_st;

typedef ulong size_t;

typedef struct env_md_ctx_st EVP_MD_CTX;

typedef struct env_md_st EVP_MD;

typedef struct engine_st engine_st, *Pengine_st;

typedef struct engine_st ENGINE;

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;

struct engine_st {
};

struct env_md_ctx_st {
    EVP_MD *digest;
    ENGINE *engine;
    ulong flags;
    void *md_data;
    EVP_PKEY_CTX *pctx;
    int (*update)(EVP_MD_CTX *, void *, size_t);
};

struct evp_pkey_ctx_st {
};

struct hmac_ctx_st {
    EVP_MD *md;
    EVP_MD_CTX md_ctx;
    EVP_MD_CTX i_ctx;
    EVP_MD_CTX o_ctx;
    uint key_length;
    uchar key[128];
};

struct env_md_st {
    int type;
    int pkey_type;
    int md_size;
    ulong flags;
    int (*init)(EVP_MD_CTX *);
    int (*update)(EVP_MD_CTX *, void *, size_t);
    int (*final)(EVP_MD_CTX *, uchar *);
    int (*copy)(EVP_MD_CTX *, EVP_MD_CTX *);
    int (*cleanup)(EVP_MD_CTX *);
    int (*sign)(int, uchar *, uint, uchar *, uint *, void *);
    int (*verify)(int, uchar *, uint, uchar *, uint, void *);
    int required_pkey_type[5];
    int block_size;
    int ctx_size;
    int (*md_ctrl)(EVP_MD_CTX *, int, int, void *);
};

typedef struct stack_st_void stack_st_void, *Pstack_st_void;

typedef struct stack_st stack_st, *Pstack_st;

typedef struct stack_st _STACK;

struct stack_st {
    int num;
    char **data;
    int sorted;
    int num_alloc;
    int (*comp)(void *, void *);
};

struct stack_st_void {
    _STACK stack;
};

typedef struct bio_st bio_st, *Pbio_st;

typedef struct bio_method_st bio_method_st, *Pbio_method_st;

typedef struct bio_st BIO;

typedef void (bio_info_cb)(struct bio_st *, int, char *, int, long, long);

typedef struct bio_method_st BIO_METHOD;

typedef struct crypto_ex_data_st crypto_ex_data_st, *Pcrypto_ex_data_st;

typedef struct crypto_ex_data_st CRYPTO_EX_DATA;

struct crypto_ex_data_st {
    struct stack_st_void *sk;
    int dummy;
};

struct bio_method_st {
    int type;
    char *name;
    int (*bwrite)(BIO *, char *, int);
    int (*bread)(BIO *, char *, int);
    int (*bputs)(BIO *, char *);
    int (*bgets)(BIO *, char *, int);
    long (*ctrl)(BIO *, int, long, void *);
    int (*create)(BIO *);
    int (*destroy)(BIO *);
    long (*callback_ctrl)(BIO *, int, bio_info_cb *);
};

struct bio_st {
    BIO_METHOD *method;
    long (*callback)(struct bio_st *, int, char *, int, long, long);
    char *cb_arg;
    int init;
    int shutdown;
    int flags;
    int retry_reason;
    int num;
    void *ptr;
    struct bio_st *next_bio;
    struct bio_st *prev_bio;
    int references;
    ulong num_read;
    ulong num_write;
    CRYPTO_EX_DATA ex_data;
};

typedef long __ssize_t;

typedef __ssize_t ssize_t;

typedef uint __socklen_t;

typedef long __time_t;

typedef long __suseconds_t;

typedef long __off64_t;

typedef long __off_t;

typedef struct pollfd pollfd, *Ppollfd;

struct pollfd {
    int fd;
    short events;
    short revents;
};

typedef ulong nfds_t;

typedef struct DSA_SIG_st DSA_SIG_st, *PDSA_SIG_st;

typedef struct DSA_SIG_st DSA_SIG;

typedef struct bignum_st bignum_st, *Pbignum_st;

typedef struct bignum_st BIGNUM;

struct bignum_st {
    ulong *d;
    int top;
    int dmax;
    int neg;
    int flags;
};

struct DSA_SIG_st {
    BIGNUM *r;
    BIGNUM *s;
};

typedef struct ECDSA_SIG_st ECDSA_SIG_st, *PECDSA_SIG_st;

typedef struct ECDSA_SIG_st ECDSA_SIG;

struct ECDSA_SIG_st {
    BIGNUM *r;
    BIGNUM *s;
};

typedef struct ec_group_st ec_group_st, *Pec_group_st;

typedef struct ec_group_st EC_GROUP;

struct ec_group_st {
};

typedef struct ec_key_st ec_key_st, *Pec_key_st;

typedef struct ec_key_st EC_KEY;

struct ec_key_st {
};

typedef enum enum_295 {
    POINT_CONVERSION_COMPRESSED=2,
    POINT_CONVERSION_UNCOMPRESSED=4,
    POINT_CONVERSION_HYBRID=6
} enum_295;

typedef struct ec_point_st ec_point_st, *Pec_point_st;

typedef struct ec_point_st EC_POINT;

struct ec_point_st {
};

typedef enum enum_295 point_conversion_form_t;

typedef ushort sa_family_t;

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

struct _IO_FILE {
    int _flags;
    char *_IO_read_ptr;
    char *_IO_read_end;
    char *_IO_read_base;
    char *_IO_write_base;
    char *_IO_write_ptr;
    char *_IO_write_end;
    char *_IO_buf_base;
    char *_IO_buf_end;
    char *_IO_save_base;
    char *_IO_backup_base;
    char *_IO_save_end;
    struct _IO_marker *_markers;
    struct _IO_FILE *_chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t *_lock;
    __off64_t _offset;
    void *__pad1;
    void *__pad2;
    void *__pad3;
    void *__pad4;
    size_t __pad5;
    int _mode;
    char _unused2[20];
};

struct _IO_marker {
    struct _IO_marker *_next;
    struct _IO_FILE *_sbuf;
    int _pos;
};

typedef int (pem_password_cb)(char *, int, int, void *);

typedef struct _IO_FILE FILE;

typedef struct sockaddr sockaddr, *Psockaddr;

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};

typedef __socklen_t socklen_t;

typedef struct pkcs8_priv_key_info_st pkcs8_priv_key_info_st, *Ppkcs8_priv_key_info_st;

typedef struct pkcs8_priv_key_info_st PKCS8_PRIV_KEY_INFO;

typedef struct asn1_string_st asn1_string_st, *Pasn1_string_st;

typedef struct asn1_string_st ASN1_INTEGER;

typedef struct X509_algor_st X509_algor_st, *PX509_algor_st;

typedef struct X509_algor_st X509_ALGOR;

typedef struct asn1_type_st asn1_type_st, *Pasn1_type_st;

typedef struct asn1_type_st ASN1_TYPE;

typedef struct stack_st_X509_ATTRIBUTE stack_st_X509_ATTRIBUTE, *Pstack_st_X509_ATTRIBUTE;

typedef struct asn1_object_st asn1_object_st, *Pasn1_object_st;

typedef struct asn1_object_st ASN1_OBJECT;

typedef union _union_257 _union_257, *P_union_257;

typedef int ASN1_BOOLEAN;

typedef struct asn1_string_st ASN1_STRING;

typedef struct asn1_string_st ASN1_ENUMERATED;

typedef struct asn1_string_st ASN1_BIT_STRING;

typedef struct asn1_string_st ASN1_OCTET_STRING;

typedef struct asn1_string_st ASN1_PRINTABLESTRING;

typedef struct asn1_string_st ASN1_T61STRING;

typedef struct asn1_string_st ASN1_IA5STRING;

typedef struct asn1_string_st ASN1_GENERALSTRING;

typedef struct asn1_string_st ASN1_BMPSTRING;

typedef struct asn1_string_st ASN1_UNIVERSALSTRING;

typedef struct asn1_string_st ASN1_UTCTIME;

typedef struct asn1_string_st ASN1_GENERALIZEDTIME;

typedef struct asn1_string_st ASN1_VISIBLESTRING;

typedef struct asn1_string_st ASN1_UTF8STRING;

typedef struct ASN1_VALUE_st ASN1_VALUE_st, *PASN1_VALUE_st;

typedef struct ASN1_VALUE_st ASN1_VALUE;

struct ASN1_VALUE_st {
};

struct X509_algor_st {
    ASN1_OBJECT *algorithm;
    ASN1_TYPE *parameter;
};

union _union_257 {
    char *ptr;
    ASN1_BOOLEAN boolean;
    ASN1_STRING *asn1_string;
    ASN1_OBJECT *object;
    ASN1_INTEGER *integer;
    ASN1_ENUMERATED *enumerated;
    ASN1_BIT_STRING *bit_string;
    ASN1_OCTET_STRING *octet_string;
    ASN1_PRINTABLESTRING *printablestring;
    ASN1_T61STRING *t61string;
    ASN1_IA5STRING *ia5string;
    ASN1_GENERALSTRING *generalstring;
    ASN1_BMPSTRING *bmpstring;
    ASN1_UNIVERSALSTRING *universalstring;
    ASN1_UTCTIME *utctime;
    ASN1_GENERALIZEDTIME *generalizedtime;
    ASN1_VISIBLESTRING *visiblestring;
    ASN1_UTF8STRING *utf8string;
    ASN1_STRING *set;
    ASN1_STRING *sequence;
    ASN1_VALUE *asn1_value;
};

struct asn1_type_st {
    int type;
    union _union_257 value;
};

struct pkcs8_priv_key_info_st {
    int broken;
    ASN1_INTEGER *version;
    X509_ALGOR *pkeyalg;
    ASN1_TYPE *pkey;
    struct stack_st_X509_ATTRIBUTE *attributes;
};

struct stack_st_X509_ATTRIBUTE {
    _STACK stack;
};

struct asn1_string_st {
    int length;
    int type;
    uchar *data;
    long flags;
};

struct asn1_object_st {
    char *sn;
    char **ln;
    int nid;
    int length;
    uchar *data;
    int flags;
};

typedef struct evp_pkey_st evp_pkey_st, *Pevp_pkey_st;

typedef struct evp_pkey_st EVP_PKEY;

typedef struct evp_pkey_asn1_method_st evp_pkey_asn1_method_st, *Pevp_pkey_asn1_method_st;

typedef struct evp_pkey_asn1_method_st EVP_PKEY_ASN1_METHOD;

typedef union _union_271 _union_271, *P_union_271;

typedef struct rsa_st rsa_st, *Prsa_st;

typedef struct dsa_st dsa_st, *Pdsa_st;

typedef struct dh_st dh_st, *Pdh_st;

typedef struct rsa_meth_st rsa_meth_st, *Prsa_meth_st;

typedef struct rsa_st RSA;

typedef struct bignum_ctx bignum_ctx, *Pbignum_ctx;

typedef struct bignum_ctx BN_CTX;

typedef struct bn_mont_ctx_st bn_mont_ctx_st, *Pbn_mont_ctx_st;

typedef struct bn_mont_ctx_st BN_MONT_CTX;

typedef struct bn_gencb_st bn_gencb_st, *Pbn_gencb_st;

typedef struct bn_gencb_st BN_GENCB;

typedef struct rsa_meth_st RSA_METHOD;

typedef struct bn_blinding_st bn_blinding_st, *Pbn_blinding_st;

typedef struct bn_blinding_st BN_BLINDING;

typedef struct dsa_method dsa_method, *Pdsa_method;

typedef struct dsa_st DSA;

typedef struct dsa_method DSA_METHOD;

typedef struct dh_method dh_method, *Pdh_method;

typedef struct dh_st DH;

typedef struct dh_method DH_METHOD;

typedef union _union_175 _union_175, *P_union_175;

union _union_175 {
    void (*cb_1)(int, int, void *);
    int (*cb_2)(int, int, BN_GENCB *);
};

struct bn_gencb_st {
    uint ver;
    void *arg;
    union _union_175 cb;
};

union _union_271 {
    char *ptr;
    struct rsa_st *rsa;
    struct dsa_st *dsa;
    struct dh_st *dh;
    struct ec_key_st *ec;
};

struct bignum_ctx {
};

struct dsa_st {
    int pad;
    long version;
    int write_params;
    BIGNUM *p;
    BIGNUM *q;
    BIGNUM *g;
    BIGNUM *pub_key;
    BIGNUM *priv_key;
    BIGNUM *kinv;
    BIGNUM *r;
    int flags;
    BN_MONT_CTX *method_mont_p;
    int references;
    CRYPTO_EX_DATA ex_data;
    DSA_METHOD *meth;
    ENGINE *engine;
};

struct rsa_st {
    int pad;
    long version;
    RSA_METHOD *meth;
    ENGINE *engine;
    BIGNUM *n;
    BIGNUM *e;
    BIGNUM *d;
    BIGNUM *p;
    BIGNUM *q;
    BIGNUM *dmp1;
    BIGNUM *dmq1;
    BIGNUM *iqmp;
    CRYPTO_EX_DATA ex_data;
    int references;
    int flags;
    BN_MONT_CTX *_method_mod_n;
    BN_MONT_CTX *_method_mod_p;
    BN_MONT_CTX *_method_mod_q;
    char *bignum_data;
    BN_BLINDING *blinding;
    BN_BLINDING *mt_blinding;
};

struct evp_pkey_asn1_method_st {
};

struct dh_st {
    int pad;
    int version;
    BIGNUM *p;
    BIGNUM *g;
    long length;
    BIGNUM *pub_key;
    BIGNUM *priv_key;
    int flags;
    BN_MONT_CTX *method_mont_p;
    BIGNUM *q;
    BIGNUM *j;
    uchar *seed;
    int seedlen;
    BIGNUM *counter;
    int references;
    CRYPTO_EX_DATA ex_data;
    DH_METHOD *meth;
    ENGINE *engine;
};

struct rsa_meth_st {
    char *name;
    int (*rsa_pub_enc)(int, uchar *, uchar *, RSA *, int);
    int (*rsa_pub_dec)(int, uchar *, uchar *, RSA *, int);
    int (*rsa_priv_enc)(int, uchar *, uchar *, RSA *, int);
    int (*rsa_priv_dec)(int, uchar *, uchar *, RSA *, int);
    int (*rsa_mod_exp)(BIGNUM *, BIGNUM *, RSA *, BN_CTX *);
    int (*bn_mod_exp)(BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *, BN_MONT_CTX *);
    int (*init)(RSA *);
    int (*finish)(RSA *);
    int flags;
    char *app_data;
    int (*rsa_sign)(int, uchar *, uint, uchar *, uint *, RSA *);
    int (*rsa_verify)(int, uchar *, uint, uchar *, uint, RSA *);
    int (*rsa_keygen)(RSA *, int, BIGNUM *, BN_GENCB *);
};

struct bn_blinding_st {
};

struct dh_method {
    char *name;
    int (*generate_key)(DH *);
    int (*compute_key)(uchar *, BIGNUM *, DH *);
    int (*bn_mod_exp)(DH *, BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *, BN_MONT_CTX *);
    int (*init)(DH *);
    int (*finish)(DH *);
    int flags;
    char *app_data;
    int (*generate_params)(DH *, int, int, BN_GENCB *);
};

struct dsa_method {
    char *name;
    DSA_SIG * (*dsa_do_sign)(uchar *, int, DSA *);
    int (*dsa_sign_setup)(DSA *, BN_CTX *, BIGNUM **, BIGNUM **);
    int (*dsa_do_verify)(uchar *, int, DSA_SIG *, DSA *);
    int (*dsa_mod_exp)(DSA *, BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *, BN_MONT_CTX *);
    int (*bn_mod_exp)(DSA *, BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *, BN_MONT_CTX *);
    int (*init)(DSA *);
    int (*finish)(DSA *);
    int flags;
    char *app_data;
    int (*dsa_paramgen)(DSA *, int, uchar *, int, int *, ulong *, BN_GENCB *);
    int (*dsa_keygen)(DSA *);
};

struct evp_pkey_st {
    int type;
    int save_type;
    int references;
    EVP_PKEY_ASN1_METHOD *ameth;
    ENGINE *engine;
    union _union_271 pkey;
    int save_parameters;
    struct stack_st_X509_ATTRIBUTE *attributes;
};

struct bn_mont_ctx_st {
    int ri;
    BIGNUM RR;
    BIGNUM N;
    BIGNUM Ni;
    ulong n0[2];
    int flags;
};

typedef struct evp_cipher_st evp_cipher_st, *Pevp_cipher_st;

typedef struct evp_cipher_ctx_st evp_cipher_ctx_st, *Pevp_cipher_ctx_st;

typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;

typedef struct evp_cipher_st EVP_CIPHER;

struct evp_cipher_ctx_st {
    EVP_CIPHER *cipher;
    ENGINE *engine;
    int encrypt;
    int buf_len;
    uchar oiv[16];
    uchar iv[16];
    uchar buf[32];
    int num;
    void *app_data;
    int key_len;
    ulong flags;
    void *cipher_data;
    int final_used;
    int block_mask;
    uchar final[32];
};

struct evp_cipher_st {
    int nid;
    int block_size;
    int key_len;
    int iv_len;
    ulong flags;
    int (*init)(EVP_CIPHER_CTX *, uchar *, uchar *, int);
    int (*do_cipher)(EVP_CIPHER_CTX *, uchar *, uchar *, size_t);
    int (*cleanup)(EVP_CIPHER_CTX *);
    int ctx_size;
    int (*set_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *);
    int (*get_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *);
    int (*ctrl)(EVP_CIPHER_CTX *, int, int, void *);
    void *app_data;
};

typedef struct X509_pubkey_st X509_pubkey_st, *PX509_pubkey_st;

typedef struct X509_pubkey_st X509_PUBKEY;

struct X509_pubkey_st {
    X509_ALGOR *algor;
    ASN1_BIT_STRING *public_key;
    EVP_PKEY *pkey;
};

typedef struct timezone timezone, *Ptimezone;

struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};

typedef __time_t time_t;

typedef struct timeval timeval, *Ptimeval;

struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};

typedef struct timezone *__timezone_ptr_t;

typedef enum Elf_ProgramHeaderType {
    PT_NULL=0,
    PT_LOAD=1,
    PT_DYNAMIC=2,
    PT_INTERP=3,
    PT_NOTE=4,
    PT_SHLIB=5,
    PT_PHDR=6,
    PT_TLS=7,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_STACK=1685382481,
    PT_GNU_RELRO=1685382482
} Elf_ProgramHeaderType;

typedef struct Elf64_Dyn Elf64_Dyn, *PElf64_Dyn;

typedef enum Elf64_DynTag {
    DT_NULL=0,
    DT_NEEDED=1,
    DT_PLTRELSZ=2,
    DT_PLTGOT=3,
    DT_HASH=4,
    DT_STRTAB=5,
    DT_SYMTAB=6,
    DT_RELA=7,
    DT_RELASZ=8,
    DT_RELAENT=9,
    DT_STRSZ=10,
    DT_SYMENT=11,
    DT_INIT=12,
    DT_FINI=13,
    DT_SONAME=14,
    DT_RPATH=15,
    DT_SYMBOLIC=16,
    DT_REL=17,
    DT_RELSZ=18,
    DT_RELENT=19,
    DT_PLTREL=20,
    DT_DEBUG=21,
    DT_TEXTREL=22,
    DT_JMPREL=23,
    DT_BIND_NOW=24,
    DT_INIT_ARRAY=25,
    DT_FINI_ARRAY=26,
    DT_INIT_ARRAYSZ=27,
    DT_FINI_ARRAYSZ=28,
    DT_RUNPATH=29,
    DT_FLAGS=30,
    DT_PREINIT_ARRAY=32,
    DT_PREINIT_ARRAYSZ=33,
    DT_RELRSZ=35,
    DT_RELR=36,
    DT_RELRENT=37,
    DT_ANDROID_REL=1610612751,
    DT_ANDROID_RELSZ=1610612752,
    DT_ANDROID_RELA=1610612753,
    DT_ANDROID_RELASZ=1610612754,
    DT_ANDROID_RELR=1879040000,
    DT_ANDROID_RELRSZ=1879040001,
    DT_ANDROID_RELRENT=1879040003,
    DT_GNU_PRELINKED=1879047669,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_CHECKSUM=1879047672,
    DT_PLTPADSZ=1879047673,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_FEATURE_1=1879047676,
    DT_POSFLAG_1=1879047677,
    DT_SYMINSZ=1879047678,
    DT_SYMINENT=1879047679,
    DT_GNU_XHASH=1879047924,
    DT_GNU_HASH=1879047925,
    DT_TLSDESC_PLT=1879047926,
    DT_TLSDESC_GOT=1879047927,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_LIBLIST=1879047929,
    DT_CONFIG=1879047930,
    DT_DEPAUDIT=1879047931,
    DT_AUDIT=1879047932,
    DT_PLTPAD=1879047933,
    DT_MOVETAB=1879047934,
    DT_SYMINFO=1879047935,
    DT_VERSYM=1879048176,
    DT_RELACOUNT=1879048185,
    DT_RELCOUNT=1879048186,
    DT_FLAGS_1=1879048187,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_AUXILIARY=2147483645,
    DT_FILTER=2147483647
} Elf64_DynTag;

struct Elf64_Dyn {
    enum Elf64_DynTag d_tag;
    qword d_val;
};

typedef struct Elf64_Shdr Elf64_Shdr, *PElf64_Shdr;

typedef enum Elf_SectionHeaderType {
    SHT_NULL=0,
    SHT_PROGBITS=1,
    SHT_SYMTAB=2,
    SHT_STRTAB=3,
    SHT_RELA=4,
    SHT_HASH=5,
    SHT_DYNAMIC=6,
    SHT_NOTE=7,
    SHT_NOBITS=8,
    SHT_REL=9,
    SHT_SHLIB=10,
    SHT_DYNSYM=11,
    SHT_INIT_ARRAY=14,
    SHT_FINI_ARRAY=15,
    SHT_PREINIT_ARRAY=16,
    SHT_GROUP=17,
    SHT_SYMTAB_SHNDX=18,
    SHT_ANDROID_REL=1610612737,
    SHT_ANDROID_RELA=1610612738,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_CHECKSUM=1879048184,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_syminfo=1879048188,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191
} Elf_SectionHeaderType;

struct Elf64_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType sh_type;
    qword sh_flags;
    qword sh_addr;
    qword sh_offset;
    qword sh_size;
    dword sh_link;
    dword sh_info;
    qword sh_addralign;
    qword sh_entsize;
};

typedef struct GnuBuildId GnuBuildId, *PGnuBuildId;

struct GnuBuildId {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
    byte hash[20];
};

typedef struct NoteGnuProperty_4 NoteGnuProperty_4, *PNoteGnuProperty_4;

struct NoteGnuProperty_4 {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
};

typedef struct Elf64_Ehdr Elf64_Ehdr, *PElf64_Ehdr;

struct Elf64_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_osabi;
    byte e_ident_abiversion;
    byte e_ident_pad[7];
    word e_type;
    word e_machine;
    dword e_version;
    qword e_entry;
    qword e_phoff;
    qword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};

typedef struct Elf64_Rela Elf64_Rela, *PElf64_Rela;

struct Elf64_Rela {
    qword r_offset; // location to apply the relocation action
    qword r_info; // the symbol table index and the type of relocation
    qword r_addend; // a constant addend used to compute the relocatable field value
};

typedef struct Elf64_Phdr Elf64_Phdr, *PElf64_Phdr;

struct Elf64_Phdr {
    enum Elf_ProgramHeaderType p_type;
    dword p_flags;
    qword p_offset;
    qword p_vaddr;
    qword p_paddr;
    qword p_filesz;
    qword p_memsz;
    qword p_align;
};

typedef struct Elf64_Sym Elf64_Sym, *PElf64_Sym;

struct Elf64_Sym {
    dword st_name;
    byte st_info;
    byte st_other;
    word st_shndx;
    qword st_value;
    qword st_size;
};




int _init(EVP_PKEY_CTX *ctx)

{
  int iVar1;
  
  iVar1 = 0x1512d0;
  if (true) {
    iVar1 = __gmon_start__();
  }
  return iVar1;
}



void FUN_00109020(void)

{
  (*(code *)(undefined *)0x0)();
  return;
}



void FUN_0010a270(void)

{
  __cxa_finalize();
  return;
}



void _libssh2_openssh_pem_parse_memory(void)

{
  _libssh2_openssh_pem_parse_memory();
  return;
}



undefined8
_libssh2_rsa_sha1_verify
          (RSA *param_1,uchar *param_2,uint param_3,undefined8 param_4,undefined8 param_5)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  uchar auStack_28 [24];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = _libssh2_sha1(param_4,param_5,auStack_28);
  if (iVar1 == 0) {
    iVar1 = RSA_verify(0x40,auStack_28,0x14,param_2,param_3,param_1);
    if (iVar1 == 1) {
      uVar2 = 0;
    }
    else {
      uVar2 = 0xffffffff;
    }
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EVP_PKEY_CTX * EVP_PKEY_CTX_new(EVP_PKEY *pkey,ENGINE *e)

{
  EVP_PKEY_CTX *pEVar1;
  
  pEVar1 = EVP_PKEY_CTX_new(pkey,e);
  return pEVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * getenv(char *__name)

{
  char *pcVar1;
  
  pcVar1 = getenv(__name);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ASN1_STRING_length(ASN1_STRING *x)

{
  int iVar1;
  
  iVar1 = ASN1_STRING_length(x);
  return iVar1;
}



int _libssh2_pub_priv_openssh_keyfilememory
              (long param_1,undefined8 *param_2,char *param_3,undefined8 param_4,undefined8 param_5,
              undefined8 param_6,undefined8 param_7,undefined8 param_8,undefined8 param_9,
              undefined8 param_10)

{
  int iVar1;
  size_t sVar2;
  long in_FS_OFFSET;
  undefined4 uStack_28;
  int iStack_24;
  char *pcStack_20;
  long lStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  pcStack_20 = (char *)0x0;
  lStack_18 = 0;
  if (param_2 != (undefined8 *)0x0) {
    *param_2 = 0;
  }
  if (param_1 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    iVar1 = -1;
  }
  else if ((param_3 == (char *)0x0) ||
          ((sVar2 = strlen(param_3), sVar2 < 0xc && (sVar2 = strlen(param_3), 6 < sVar2)))) {
    _libssh2_init_if_needed();
    iStack_24 = _libssh2_openssh_pem_parse_memory(param_1,param_10,param_8,param_9,&lStack_18);
    iVar1 = iStack_24;
    if (iStack_24 == 0) {
      iStack_24 = _libssh2_get_c_string(lStack_18,&pcStack_20);
      if ((iStack_24 < 1) || (pcStack_20 == (char *)0x0)) {
        _libssh2_error(param_1,0xfffffff2,"Public key type in decrypted key data not found");
        iVar1 = -1;
      }
      else {
        iVar1 = strcmp("ssh-ed25519",pcStack_20);
        if ((iVar1 == 0) &&
           ((param_3 == (char *)0x0 || (iVar1 = strcmp("ssh-ed25519",param_3), iVar1 == 0)))) {
          iStack_24 = gen_publickey_from_ed25519_openssh_priv_data
                                (param_1,lStack_18,param_4,param_5,param_6,param_7,param_2);
        }
        iVar1 = strcmp("ssh-rsa",pcStack_20);
        if ((iVar1 == 0) &&
           ((param_3 == (char *)0x0 || (iVar1 = strcmp("ssh-rsa",param_3), iVar1 == 0)))) {
          iStack_24 = gen_publickey_from_rsa_openssh_priv_data
                                (param_1,lStack_18,param_4,param_5,param_6,param_7,param_2);
        }
        iVar1 = strcmp("ssh-dss",pcStack_20);
        if ((iVar1 == 0) &&
           ((param_3 == (char *)0x0 || (iVar1 = strcmp("ssh-dss",param_3), iVar1 == 0)))) {
          iStack_24 = gen_publickey_from_dsa_openssh_priv_data
                                (param_1,lStack_18,param_4,param_5,param_6,param_7,param_2);
        }
        iVar1 = _libssh2_ecdsa_curve_type_from_name(pcStack_20,&uStack_28);
        if ((iVar1 == 0) &&
           ((param_3 == (char *)0x0 || (iVar1 = strcmp("ssh-ecdsa",param_3), iVar1 == 0)))) {
          iStack_24 = gen_publickey_from_ecdsa_openssh_priv_data
                                (param_1,uStack_28,lStack_18,param_4,param_5,param_6,param_7,param_2
                                );
        }
        iVar1 = iStack_24;
        if (lStack_18 != 0) {
          _libssh2_string_buf_free(param_1,lStack_18);
          iVar1 = iStack_24;
        }
      }
    }
  }
  else {
    _libssh2_error(param_1,0xfffffff2,"type is invalid");
    iVar1 = -1;
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



long _libssh2_channel_write(long param_1,int param_2,undefined8 param_3,ulong param_4)

{
  int iVar1;
  long lVar2;
  undefined uVar3;
  long in_FS_OFFSET;
  ulong uStack_58;
  undefined *puStack_28;
  long lStack_20;
  long lStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  lStack_20 = *(long *)(param_1 + 0x60);
  lStack_18 = 0;
  uStack_58 = param_4;
  if (0x7fbc < param_4) {
    uStack_58 = 0x7fbc;
  }
  if (*(int *)(param_1 + 0x268) == 0) {
    puStack_28 = (undefined *)(param_1 + 0x26c);
    if (*(char *)(param_1 + 0x40) != '\0') {
      iVar1 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xffffffe6,
                             "We\'ve already closed this channel");
      lVar2 = (long)iVar1;
      goto LAB_00117f19;
    }
    if (*(char *)(param_1 + 0x41) != '\0') {
      iVar1 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xffffffe5,
                             "EOF has already been received, data might be ignored");
      lVar2 = (long)iVar1;
      goto LAB_00117f19;
    }
    do {
      iVar1 = _libssh2_transport_read(lStack_20);
    } while (0 < iVar1);
    if ((iVar1 < 0) && (iVar1 != -0x25)) {
      iVar1 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),iVar1,
                             "Failure while draining incoming flow");
      lVar2 = (long)iVar1;
      goto LAB_00117f19;
    }
    if (*(int *)(param_1 + 0x38) == 0) {
      *(undefined4 *)(lStack_20 + 0x230) = 1;
      if (iVar1 == -0x25) {
        lVar2 = -0x25;
      }
      else {
        lVar2 = 0;
      }
      goto LAB_00117f19;
    }
    *(ulong *)(param_1 + 0x288) = uStack_58;
    if (param_2 == 0) {
      uVar3 = 0x5e;
    }
    else {
      uVar3 = 0x5f;
    }
    *puStack_28 = uVar3;
    puStack_28 = puStack_28 + 1;
    _libssh2_store_u32(&puStack_28,*(undefined4 *)(param_1 + 0x44));
    if (param_2 != 0) {
      _libssh2_store_u32(&puStack_28,param_2);
    }
    if ((ulong)*(uint *)(param_1 + 0x38) < *(ulong *)(param_1 + 0x288)) {
      *(ulong *)(param_1 + 0x288) = (ulong)*(uint *)(param_1 + 0x38);
    }
    if ((ulong)*(uint *)(param_1 + 0x3c) < *(ulong *)(param_1 + 0x288)) {
      *(ulong *)(param_1 + 0x288) = (ulong)*(uint *)(param_1 + 0x3c);
    }
    _libssh2_store_u32(&puStack_28,*(ulong *)(param_1 + 0x288) & 0xffffffff);
    *(long *)(param_1 + 0x280) = (long)puStack_28 - (param_1 + 0x26c);
    *(undefined4 *)(param_1 + 0x268) = 2;
  }
  if (*(int *)(param_1 + 0x268) == 2) {
    iVar1 = _libssh2_transport_send
                      (lStack_20,param_1 + 0x26c,*(undefined8 *)(param_1 + 0x280),param_3,
                       *(undefined8 *)(param_1 + 0x288));
    if (iVar1 == -0x25) {
      iVar1 = _libssh2_error(lStack_20,0xffffffdb,"Unable to send channel data");
      lVar2 = (long)iVar1;
    }
    else if (iVar1 == 0) {
      *(int *)(param_1 + 0x38) = *(int *)(param_1 + 0x38) - (int)*(undefined8 *)(param_1 + 0x288);
      lVar2 = lStack_18 + *(long *)(param_1 + 0x288);
      *(undefined4 *)(param_1 + 0x268) = 0;
      lStack_18 = lVar2;
    }
    else {
      *(undefined4 *)(param_1 + 0x268) = 0;
      iVar1 = _libssh2_error(lStack_20,iVar1,"Unable to send channel data");
      lVar2 = (long)iVar1;
    }
  }
  else {
    lVar2 = -0x22;
  }
LAB_00117f19:
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return lVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int BN_rand(BIGNUM *rnd,int bits,int top,int bottom)

{
  int iVar1;
  
  iVar1 = BN_rand(rnd,bits,top,bottom);
  return iVar1;
}



uint _libssh2_channel_nextid(long param_1)

{
  uint uStack_14;
  long lStack_10;
  
  uStack_14 = *(uint *)(param_1 + 0x210);
  for (lStack_10 = _libssh2_list_first(param_1 + 0x200); lStack_10 != 0;
      lStack_10 = _libssh2_list_next(lStack_10)) {
    if (uStack_14 < *(uint *)(lStack_10 + 0x30)) {
      uStack_14 = *(uint *)(lStack_10 + 0x30);
    }
  }
  *(uint *)(param_1 + 0x210) = uStack_14 + 1;
  return uStack_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void free(void *__ptr)

{
  free(__ptr);
  return;
}



ulong gen_publickey_from_ecdsa_openssh_priv_data
                (undefined8 param_1,undefined4 param_2,undefined8 param_3,long param_4,
                undefined8 param_5,long param_6,undefined8 param_7,undefined8 *param_8)

{
  int iVar1;
  int len;
  ulong uVar2;
  long in_FS_OFFSET;
  uint uStack_50;
  undefined auStack_40 [8];
  uchar *puStack_38;
  undefined8 uStack_30;
  EC_KEY *pEStack_28;
  BIGNUM *pBStack_20;
  EVP_PKEY *pEStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  pEStack_28 = (EC_KEY *)0x0;
  iVar1 = _libssh2_get_c_string(param_3,auStack_40);
  if (iVar1 < 1) {
    _libssh2_error(param_1,0xfffffff2,"ECDSA no curve");
    uVar2 = 0xffffffff;
  }
  else {
    iVar1 = _libssh2_get_c_string(param_3,&uStack_30);
    if (iVar1 < 1) {
      _libssh2_error(param_1,0xfffffff2,"ECDSA no point");
      uVar2 = 0xffffffff;
    }
    else {
      len = _libssh2_get_bignum_bytes(param_3,&puStack_38);
      if (len < 1) {
        _libssh2_error(param_1,0xfffffff2,"ECDSA no exponent");
        uVar2 = 0xffffffff;
      }
      else {
        iVar1 = _libssh2_ecdsa_curve_name_with_octal_new(&pEStack_28,uStack_30,(long)iVar1,param_2);
        if (iVar1 == 0) {
          pBStack_20 = BN_new();
          if (pBStack_20 != (BIGNUM *)0x0) {
            BN_bin2bn(puStack_38,len,pBStack_20);
            iVar1 = EC_KEY_set_private_key(pEStack_28,pBStack_20);
            uStack_50 = (uint)(iVar1 != 1);
            if ((((uStack_50 == 0) && (pEStack_28 != (EC_KEY *)0x0)) && (param_6 != 0)) &&
               (param_4 != 0)) {
              pEStack_18 = EVP_PKEY_new();
              EVP_PKEY_set1_EC_KEY(pEStack_18,pEStack_28);
              uStack_50 = gen_publickey_from_ec_evp
                                    (param_1,param_4,param_5,param_6,param_7,pEStack_18);
              if (pEStack_18 != (EVP_PKEY *)0x0) {
                EVP_PKEY_free(pEStack_18);
              }
            }
            if (param_8 == (undefined8 *)0x0) {
              EC_KEY_free(pEStack_28);
            }
            else {
              *param_8 = pEStack_28;
            }
            uVar2 = (ulong)uStack_50;
            goto LAB_0010f12c;
          }
        }
        else {
          _libssh2_error(param_1,0xfffffff2,"ECDSA could not create key");
        }
        if (pEStack_28 != (EC_KEY *)0x0) {
          EC_KEY_free(pEStack_28);
        }
        uVar2 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for private key data");
      }
    }
  }
LAB_0010f12c:
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t recv(int __fd,void *__buf,size_t __n,int __flags)

{
  ssize_t sVar1;
  
  sVar1 = recv(__fd,__buf,__n,__flags);
  return sVar1;
}



undefined4
_libssh2_ecdsa_sign(undefined8 param_1,EC_KEY *param_2,uchar *param_3,int param_4,
                   undefined8 *param_5,size_t *param_6)

{
  int iVar1;
  int iVar2;
  int iVar3;
  long in_FS_OFFSET;
  undefined4 uStack_54;
  BIGNUM *pBStack_48;
  BIGNUM *pBStack_40;
  size_t sStack_38;
  void *pvStack_30;
  void *pvStack_28;
  ECDSA_SIG *pEStack_20;
  void *pvStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_54 = 0;
  sStack_38 = 0;
  pBStack_48 = (BIGNUM *)0x0;
  pBStack_40 = (BIGNUM *)0x0;
  pvStack_30 = (void *)0x0;
  pvStack_28 = (void *)0x0;
  pEStack_20 = ECDSA_do_sign(param_3,param_4,param_2);
  if (pEStack_20 == (ECDSA_SIG *)0x0) {
    uStack_54 = 0xffffffff;
  }
  else {
    ECDSA_SIG_get0(pEStack_20,&pBStack_48,&pBStack_40);
    iVar1 = BN_num_bits(pBStack_48);
    iVar3 = iVar1 + 7;
    if (iVar1 + 7 < 0) {
      iVar3 = iVar1 + 0xe;
    }
    iVar1 = (iVar3 >> 3) + 1;
    iVar2 = BN_num_bits(pBStack_40);
    iVar3 = iVar2 + 7;
    if (iVar2 + 7 < 0) {
      iVar3 = iVar2 + 0xe;
    }
    iVar3 = (iVar3 >> 3) + 1;
    pvStack_30 = malloc((long)(iVar3 + iVar1 + 8));
    if (pvStack_30 == (void *)0x0) {
      uStack_54 = 0xffffffff;
    }
    else {
      pvStack_18 = pvStack_30;
      pvStack_18 = (void *)write_bn(pvStack_30,pBStack_48,iVar1);
      pvStack_18 = (void *)write_bn(pvStack_18,pBStack_40,iVar3);
      sStack_38 = (long)pvStack_18 - (long)pvStack_30;
      pvStack_28 = (void *)_libssh2_calloc(param_1,sStack_38);
      if (pvStack_28 == (void *)0x0) {
        uStack_54 = 0xffffffff;
      }
      else {
        memcpy(pvStack_28,pvStack_30,sStack_38);
        *param_5 = pvStack_28;
        *param_6 = sStack_38;
      }
    }
    if (pvStack_30 != (void *)0x0) {
      free(pvStack_30);
    }
    if (pEStack_20 != (ECDSA_SIG *)0x0) {
      ECDSA_SIG_free(pEStack_20);
    }
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uStack_54;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int _libssh2_ed25519_new_private(undefined8 *param_1,long param_2,char *param_3,undefined8 param_4)

{
  int iVar1;
  long in_FS_OFFSET;
  int iStack_34;
  char *pcStack_30;
  long lStack_28;
  long *plStack_20;
  FILE *pFStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  lStack_28 = 0;
  plStack_20 = (long *)0x0;
  if (param_2 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    iStack_34 = -1;
  }
  else {
    _libssh2_init_if_needed();
    pFStack_18 = fopen(param_3,"r");
    if (pFStack_18 == (FILE *)0x0) {
      _libssh2_error(param_2,0xfffffff0,"Unable to open ED25519 private key file");
      iStack_34 = -1;
    }
    else {
      iStack_34 = _libssh2_openssh_pem_parse(param_2,param_4,pFStack_18,&lStack_28);
      fclose(pFStack_18);
      if (iStack_34 == 0) {
        iStack_34 = _libssh2_get_c_string(lStack_28,&pcStack_30);
        if ((iStack_34 < 1) || (pcStack_30 == (char *)0x0)) {
          _libssh2_error(param_2,0xfffffff2,"Public key type in decrypted key data not found");
          iStack_34 = -1;
        }
        else {
          iVar1 = strcmp("ssh-ed25519",pcStack_30);
          if (iVar1 == 0) {
            iStack_34 = gen_publickey_from_ed25519_openssh_priv_data
                                  (param_2,lStack_28,0,0,0,0,&plStack_20);
          }
          if (lStack_28 != 0) {
            _libssh2_string_buf_free(param_2,lStack_28);
          }
          if (iStack_34 == 0) {
            if (param_1 == (undefined8 *)0x0) {
              if ((plStack_20 != (long *)0x0) && (plStack_20 != (long *)0x0)) {
                if (*plStack_20 != 0) {
                  EVP_PKEY_free((EVP_PKEY *)*plStack_20);
                }
                if (plStack_20[1] != 0) {
                  EVP_PKEY_free((EVP_PKEY *)plStack_20[1]);
                }
                free(plStack_20);
              }
            }
            else {
              *param_1 = plStack_20;
            }
          }
        }
      }
    }
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iStack_34;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void libssh2_poll_channel_read(void)

{
  libssh2_poll_channel_read();
  return;
}



void _libssh2_packet_askv(void)

{
  _libssh2_packet_askv();
  return;
}



int _libssh2_rsa_new_private_frommemory
              (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
              undefined8 param_5)

{
  int iStack_14;
  
  _libssh2_init_if_needed();
  iStack_14 = read_private_key_from_memory
                        (param_1,&PEM_read_bio_RSAPrivateKey,param_3,param_4,param_5);
  if (iStack_14 != 0) {
    iStack_14 = read_openssh_private_key_from_memory
                          (param_1,param_2,"ssh-rsa",param_3,param_4,param_5);
  }
  return iStack_14;
}



bool _libssh2_cipher_init
               (undefined8 *param_1,code *param_2,uchar *param_3,uchar *param_4,int param_5)

{
  int iVar1;
  EVP_CIPHER_CTX *pEVar2;
  EVP_CIPHER *cipher;
  
  pEVar2 = EVP_CIPHER_CTX_new();
  *param_1 = pEVar2;
  cipher = (EVP_CIPHER *)(*param_2)();
  iVar1 = EVP_CipherInit((EVP_CIPHER_CTX *)*param_1,cipher,param_4,param_3,param_5);
  return iVar1 == 0;
}



undefined8
_libssh2_ecdsa_create_key
          (long param_1,undefined8 *param_2,long *param_3,size_t *param_4,int param_5)

{
  BN_CTX *ctx;
  undefined8 uVar1;
  EC_KEY *key;
  EC_GROUP *group;
  EC_POINT *p;
  size_t len;
  size_t sVar2;
  long lVar3;
  long in_FS_OFFSET;
  int iStack_c4;
  uchar auStack_98 [136];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_c4 = 1;
  ctx = BN_CTX_new();
  if (ctx == (BN_CTX *)0x0) {
    uVar1 = 0xffffffff;
    goto LAB_0010f5be;
  }
  key = EC_KEY_new_by_curve_name(param_5);
  group = EC_KEY_get0_group(key);
  EC_KEY_generate_key(key);
  p = EC_KEY_get0_public_key(key);
  len = EC_POINT_point2oct(group,p,POINT_CONVERSION_UNCOMPRESSED,(uchar *)0x0,0,ctx);
  if (len < 0x86) {
    sVar2 = EC_POINT_point2oct(group,p,POINT_CONVERSION_UNCOMPRESSED,auStack_98,len,ctx);
    if (len == sVar2) {
      if (param_2 != (undefined8 *)0x0) {
        *param_2 = key;
      }
      if (param_3 != (long *)0x0) {
        lVar3 = (**(code **)(param_1 + 8))(len,param_1);
        *param_3 = lVar3;
        if (*param_3 == 0) {
          iStack_c4 = -1;
          goto LAB_0010f590;
        }
        memcpy((void *)*param_3,auStack_98,len);
      }
      if (param_4 != (size_t *)0x0) {
        *param_4 = len;
      }
    }
    else {
      iStack_c4 = -1;
    }
  }
  else {
    iStack_c4 = -1;
  }
LAB_0010f590:
  if (ctx != (BN_CTX *)0x0) {
    BN_CTX_free(ctx);
  }
  if (iStack_c4 == 1) {
    uVar1 = 0;
  }
  else {
    uVar1 = 0xffffffff;
  }
LAB_0010f5be:
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EC_KEY_set_public_key(EC_KEY *key,EC_POINT *pub)

{
  int iVar1;
  
  iVar1 = EC_KEY_set_public_key(key,pub);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

BIGNUM * BN_value_one(void)

{
  BIGNUM *pBVar1;
  
  pBVar1 = BN_value_one();
  return pBVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_CipherInit(EVP_CIPHER_CTX *ctx,EVP_CIPHER *cipher,uchar *key,uchar *iv,int enc)

{
  int iVar1;
  
  iVar1 = EVP_CipherInit(ctx,cipher,key,iv,enc);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strncpy(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncpy(__dest,__src,__n);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx,EVP_PKEY **ppkey)

{
  int iVar1;
  
  iVar1 = EVP_PKEY_keygen(ctx,ppkey);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}



void EVP_MD_CTX_free(void)

{
  EVP_MD_CTX_free();
  return;
}



void Blowfish_expand0state(long param_1,undefined8 param_2,undefined2 param_3)

{
  long in_FS_OFFSET;
  undefined2 uStack_22;
  ushort uStack_20;
  ushort uStack_1e;
  undefined4 uStack_1c;
  undefined4 uStack_18;
  uint uStack_14;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_22 = 0;
  for (uStack_20 = 0; uStack_20 < 0x12; uStack_20 = uStack_20 + 1) {
    uStack_14 = Blowfish_stream2word(param_2,param_3,&uStack_22);
    *(uint *)(param_1 + ((long)(int)(uint)uStack_20 + 0x400) * 4) =
         *(uint *)(param_1 + ((long)(int)(uint)uStack_20 + 0x400) * 4) ^ uStack_14;
  }
  uStack_22 = 0;
  uStack_1c = 0;
  uStack_18 = 0;
  for (uStack_20 = 0; uStack_20 < 0x12; uStack_20 = uStack_20 + 2) {
    Blowfish_encipher(param_1,&uStack_1c,&uStack_18);
    *(undefined4 *)(param_1 + ((long)(int)(uint)uStack_20 + 0x400) * 4) = uStack_1c;
    *(undefined4 *)(param_1 + ((long)(int)(uStack_20 + 1) + 0x400) * 4) = uStack_18;
  }
  for (uStack_20 = 0; uStack_20 < 4; uStack_20 = uStack_20 + 1) {
    for (uStack_1e = 0; uStack_1e < 0x100; uStack_1e = uStack_1e + 2) {
      Blowfish_encipher(param_1,&uStack_1c,&uStack_18);
      *(undefined4 *)
       (param_1 + ((long)(int)(uint)uStack_1e + (long)(int)(uint)uStack_20 * 0x100) * 4) = uStack_1c
      ;
      *(undefined4 *)
       (param_1 + ((long)(int)(uStack_1e + 1) + (long)(int)(uint)uStack_20 * 0x100) * 4) = uStack_18
      ;
    }
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int BN_set_word(BIGNUM *a,ulong w)

{
  int iVar1;
  
  iVar1 = BN_set_word(a,w);
  return iVar1;
}



void _libssh2_list_first(void)

{
  _libssh2_list_first();
  return;
}



void _libssh2_check_length(void)

{
  _libssh2_check_length();
  return;
}



void DSA_SIG_set0(void)

{
  DSA_SIG_set0();
  return;
}



undefined8 _libssh2_sha1(void *param_1,size_t param_2,uchar *param_3)

{
  int iVar1;
  EVP_MD_CTX *ctx;
  undefined8 uVar2;
  EVP_MD *type;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar2 = 1;
  }
  else {
    type = EVP_get_digestbyname("sha1");
    iVar1 = EVP_DigestInit(ctx,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(ctx);
      uVar2 = 1;
    }
    else {
      EVP_DigestUpdate(ctx,param_1,param_2);
      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
      EVP_MD_CTX_free(ctx);
      uVar2 = 0;
    }
  }
  return uVar2;
}



void _libssh2_calloc(void)

{
  _libssh2_calloc();
  return;
}



undefined8 _libssh2_sha256_init(long *param_1)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  lVar2 = EVP_MD_CTX_new();
  *param_1 = lVar2;
  if (*param_1 == 0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("sha256");
    iVar1 = EVP_DigestInit((EVP_MD_CTX *)*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = 0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



void EVP_PKEY_new_raw_public_key(void)

{
  EVP_PKEY_new_raw_public_key();
  return;
}



undefined8
_libssh2_rsa_sha1_sign
          (long param_1,RSA *param_2,uchar *param_3,uint param_4,undefined8 *param_5,ulong *param_6)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  uint uStack_20;
  int iStack_1c;
  uchar *puStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_20 = RSA_size(param_2);
  puStack_18 = (uchar *)(**(code **)(param_1 + 8))(uStack_20,param_1);
  if (puStack_18 == (uchar *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    iStack_1c = RSA_sign(0x40,param_3,param_4,puStack_18,&uStack_20,param_2);
    if (iStack_1c == 0) {
      (**(code **)(param_1 + 0x18))(puStack_18,param_1);
      uVar1 = 0xffffffff;
    }
    else {
      *param_5 = puStack_18;
      *param_6 = (ulong)uStack_20;
      uVar1 = 0;
    }
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void ECDSA_SIG_set0(void)

{
  ECDSA_SIG_set0();
  return;
}



void _libssh2_packet_require(void)

{
  _libssh2_packet_require();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ECDSA_do_verify(uchar *dgst,int dgst_len,ECDSA_SIG *sig,EC_KEY *eckey)

{
  int iVar1;
  
  iVar1 = ECDSA_do_verify(dgst,dgst_len,sig,eckey);
  return iVar1;
}



int _libssh2_rsa_new_openssh_private
              (undefined8 param_1,long param_2,char *param_3,undefined8 param_4)

{
  int iVar1;
  long in_FS_OFFSET;
  int iStack_2c;
  char *pcStack_28;
  long lStack_20;
  FILE *pFStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  pcStack_28 = (char *)0x0;
  lStack_20 = 0;
  if (param_2 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    iStack_2c = -1;
  }
  else {
    _libssh2_init_if_needed();
    pFStack_18 = fopen(param_3,"r");
    if (pFStack_18 == (FILE *)0x0) {
      _libssh2_error(param_2,0xfffffff0,"Unable to open OpenSSH RSA private key file");
      iStack_2c = -1;
    }
    else {
      iStack_2c = _libssh2_openssh_pem_parse(param_2,param_4,pFStack_18,&lStack_20);
      fclose(pFStack_18);
      if (iStack_2c == 0) {
        iVar1 = _libssh2_get_c_string(lStack_20,&pcStack_28);
        if ((iVar1 < 1) || (pcStack_28 == (char *)0x0)) {
          _libssh2_error(param_2,0xfffffff2,"Public key type in decrypted key data not found");
          iStack_2c = -1;
        }
        else {
          iVar1 = strcmp("ssh-rsa",pcStack_28);
          if (iVar1 == 0) {
            iStack_2c = gen_publickey_from_rsa_openssh_priv_data(param_2,lStack_20,0,0,0,0,param_1);
          }
          else {
            iStack_2c = -1;
          }
          if (lStack_20 != 0) {
            _libssh2_string_buf_free(param_2,lStack_20);
          }
        }
      }
    }
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iStack_2c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined4 _libssh2_channel_forward_cancel(long param_1)

{
  int iVar1;
  long in_FS_OFFSET;
  undefined4 uStack_50;
  undefined *puStack_48;
  long lStack_40;
  undefined *puStack_38;
  long lStack_30;
  size_t sStack_28;
  long lStack_20;
  long lStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  lStack_30 = *(long *)(param_1 + 0x18);
  sStack_28 = strlen(*(char **)(param_1 + 0x20));
  lStack_20 = sStack_28 + 0x22;
  uStack_50 = 0;
  if (*(int *)(param_1 + 0x48) == 0) {
    puStack_38 = (undefined *)(**(code **)(lStack_30 + 8))(lStack_20,lStack_30);
    if (puStack_38 == (undefined *)0x0) {
      puStack_48 = puStack_38;
      _libssh2_error(lStack_30,0xfffffffa,"Unable to allocate memory for setenv packet");
      uStack_50 = 0xfffffffa;
      goto LAB_00115719;
    }
    puStack_48 = puStack_38 + 1;
    *puStack_38 = 0x50;
    _libssh2_store_str(&puStack_48,"cancel-tcpip-forward",0x14);
    *puStack_48 = 0;
    puStack_48 = puStack_48 + 1;
    _libssh2_store_str(&puStack_48,*(undefined8 *)(param_1 + 0x20),sStack_28);
    _libssh2_store_u32(&puStack_48,*(undefined4 *)(param_1 + 0x28));
    *(undefined4 *)(param_1 + 0x48) = 2;
  }
  else {
    puStack_38 = *(undefined **)(param_1 + 0x50);
  }
  if (*(int *)(param_1 + 0x48) == 2) {
    iVar1 = _libssh2_transport_send(lStack_30,puStack_38,lStack_20,0,0);
    if (iVar1 == -0x25) {
      _libssh2_error(lStack_30,0xffffffdb,"Would block sending forward request");
      *(undefined **)(param_1 + 0x50) = puStack_38;
      uStack_50 = 0xffffffdb;
      goto LAB_00115719;
    }
    if (iVar1 != 0) {
      _libssh2_error(lStack_30,0xfffffff9,
                     "Unable to send global-request packet for forward listen request");
      *(undefined4 *)(param_1 + 0x48) = 3;
      uStack_50 = 0xfffffff9;
    }
    (**(code **)(lStack_30 + 0x18))(puStack_38,lStack_30);
    *(undefined4 *)(param_1 + 0x48) = 3;
  }
  lStack_40 = _libssh2_list_first(param_1 + 0x30);
  while (lStack_40 != 0) {
    lStack_18 = _libssh2_list_next(lStack_40);
    iVar1 = _libssh2_channel_free(lStack_40);
    if (iVar1 == -0x25) {
      uStack_50 = 0xffffffdb;
      goto LAB_00115719;
    }
    lStack_40 = lStack_18;
  }
  (**(code **)(lStack_30 + 0x18))(*(undefined8 *)(param_1 + 0x20),lStack_30);
  _libssh2_list_remove(param_1);
  (**(code **)(lStack_30 + 0x18))(param_1,lStack_30);
LAB_00115719:
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uStack_50;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}



void _libssh2_ntohu64(void)

{
  _libssh2_ntohu64();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

dsa_st * EVP_PKEY_get1_DSA(EVP_PKEY *pkey)

{
  dsa_st *pdVar1;
  
  pdVar1 = EVP_PKEY_get1_DSA(pkey);
  return pdVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EVP_MD * EVP_md5(void)

{
  EVP_MD *pEVar1;
  
  pEVar1 = EVP_md5();
  return pEVar1;
}



void _libssh2_list_next(void)

{
  _libssh2_list_next();
  return;
}



undefined8
gen_publickey_from_ed25519_openssh_priv_data
          (long param_1,long *param_2,long *param_3,undefined8 *param_4,long *param_5,
          undefined8 *param_6,undefined8 *param_7)

{
  int iVar1;
  undefined8 uVar2;
  long lVar3;
  long in_FS_OFFSET;
  uint uStack_64;
  undefined8 uStack_58;
  undefined8 uStack_50;
  void *pvStack_48;
  long lStack_40;
  long *plStack_38;
  void *pvStack_30;
  long lStack_28;
  undefined8 uStack_20;
  void *pvStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  plStack_38 = (long *)0x0;
  pvStack_30 = (void *)0x0;
  lStack_28 = 0;
  uStack_20 = 0;
  iVar1 = _libssh2_get_c_string(param_2,&uStack_58);
  if (iVar1 == 0x20) {
    iVar1 = _libssh2_get_c_string(param_2,&uStack_50);
    if (iVar1 == 0x40) {
      plStack_38 = (long *)calloc(1,0x10);
      if (plStack_38 == (long *)0x0) {
        _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for ed25519 key");
      }
      else {
        lVar3 = EVP_PKEY_new_raw_private_key(0x43f,0,uStack_50,0x20);
        plStack_38[1] = lVar3;
        lVar3 = EVP_PKEY_new_raw_public_key(0x43f,0,uStack_58,0x20);
        *plStack_38 = lVar3;
        iVar1 = _libssh2_get_c_string(param_2,&pvStack_48);
        if (iVar1 < 0) {
          _libssh2_error(param_1,0xfffffff2,"Unable to read comment");
        }
        else {
          if ((0 < iVar1) &&
             (pvStack_18 = (void *)_libssh2_calloc(param_1,(long)(iVar1 + 1)),
             pvStack_18 != (void *)0x0)) {
            memcpy(pvStack_18,pvStack_48,(long)iVar1);
            memcpy((void *)((long)pvStack_18 + (long)iVar1),&DAT_00144231,1);
            (**(code **)(param_1 + 0x18))(pvStack_18,param_1);
          }
          uStack_64 = 1;
          while ((ulong)param_2[1] < (ulong)(param_2[2] + *param_2)) {
            if (uStack_64 != *(byte *)param_2[1]) {
              _libssh2_error(param_1,0xfffffff2,"Wrong padding");
              goto LAB_0010ddc9;
            }
            uStack_64 = uStack_64 + 1;
            param_2[1] = param_2[1] + 1;
          }
          if ((true) &&
             (pvStack_30 = (void *)(**(code **)(param_1 + 8))(0xb,param_1),
             pvStack_30 != (void *)0x0)) {
            uStack_20 = 0x33;
            lStack_28 = _libssh2_calloc(param_1,0x33);
            if (lStack_28 != 0) {
              lStack_40 = lStack_28;
              _libssh2_store_str(&lStack_40,"ssh-ed25519",0xb);
              _libssh2_store_str(&lStack_40,uStack_58,0x20);
              memcpy(pvStack_30,"ssh-ed25519",0xb);
              if (param_3 == (long *)0x0) {
                (**(code **)(param_1 + 0x18))(pvStack_30,param_1);
              }
              else {
                *param_3 = (long)pvStack_30;
              }
              if (param_4 != (undefined8 *)0x0) {
                *param_4 = 0xb;
              }
              if (param_5 == (long *)0x0) {
                (**(code **)(param_1 + 0x18))(lStack_28,param_1);
              }
              else {
                *param_5 = lStack_28;
              }
              if (param_6 != (undefined8 *)0x0) {
                *param_6 = uStack_20;
              }
              if (param_7 == (undefined8 *)0x0) {
                if ((plStack_38 != (long *)0x0) && (plStack_38 != (long *)0x0)) {
                  if (*plStack_38 != 0) {
                    EVP_PKEY_free((EVP_PKEY *)*plStack_38);
                  }
                  if (plStack_38[1] != 0) {
                    EVP_PKEY_free((EVP_PKEY *)plStack_38[1]);
                  }
                  free(plStack_38);
                }
              }
              else {
                *param_7 = plStack_38;
              }
              uVar2 = 0;
              goto LAB_0010de5e;
            }
          }
        }
      }
    }
    else {
      _libssh2_error(param_1,0xfffffff2,"Wrong private key length");
    }
LAB_0010ddc9:
    if ((plStack_38 != (long *)0x0) && (plStack_38 != (long *)0x0)) {
      if (*plStack_38 != 0) {
        EVP_PKEY_free((EVP_PKEY *)*plStack_38);
      }
      if (plStack_38[1] != 0) {
        EVP_PKEY_free((EVP_PKEY *)plStack_38[1]);
      }
      free(plStack_38);
    }
    if (pvStack_30 != (void *)0x0) {
      (**(code **)(param_1 + 0x18))(pvStack_30,param_1);
    }
    if (lStack_28 != 0) {
      (**(code **)(param_1 + 0x18))(lStack_28,param_1);
    }
    uVar2 = 0xffffffff;
  }
  else {
    _libssh2_error(param_1,0xfffffff2,"Wrong public key length");
    uVar2 = 0xffffffff;
  }
LAB_0010de5e:
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void _libssh2_bcrypt_pbkdf(void)

{
  _libssh2_bcrypt_pbkdf();
  return;
}



void read_openssh_private_key_from_memory
               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
               undefined8 param_5,undefined8 param_6)

{
  _libssh2_pub_priv_openssh_keyfilememory(param_2,param_1,param_3,0,0,0,0,param_4,param_5,param_6);
  return;
}



void _libssh2_userauth_publickey(void)

{
  _libssh2_userauth_publickey();
  return;
}



undefined1 * _libssh2_comp_methods(long param_1)

{
  undefined1 *puVar1;
  
  if (*(int *)(param_1 + 0x70) == 0) {
    puVar1 = no_comp_methods;
  }
  else {
    puVar1 = comp_methods;
  }
  return puVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fcntl(int __fd,int __cmd,...)

{
  int iVar1;
  
  iVar1 = fcntl(__fd,__cmd);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

DSA * DSA_new(void)

{
  DSA *pDVar1;
  
  pDVar1 = DSA_new();
  return pDVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

BIGNUM * BN_new(void)

{
  BIGNUM *pBVar1;
  
  pBVar1 = BN_new();
  return pBVar1;
}



int libssh2_channel_free(long param_1)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = _libssh2_channel_free(param_1);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int RSA_size(RSA *rsa)

{
  int iVar1;
  
  iVar1 = RSA_size(rsa);
  return iVar1;
}



void EVP_DigestVerify(void)

{
  EVP_DigestVerify();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ASN1_OCTET_STRING * d2i_ASN1_OCTET_STRING(ASN1_OCTET_STRING **a,uchar **in,long len)

{
  ASN1_OCTET_STRING *pAVar1;
  
  pAVar1 = d2i_ASN1_OCTET_STRING(a,in,len);
  return pAVar1;
}



undefined8
_libssh2_ecdsa_verify
          (EC_KEY *param_1,uchar *param_2,int param_3,uchar *param_4,int param_5,undefined8 param_6,
          undefined8 param_7)

{
  int iVar1;
  ECDSA_SIG *sig;
  BIGNUM *ret;
  BIGNUM *ret_00;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int iStack_80;
  uchar auStack_58 [72];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_80 = 0;
  iVar1 = _libssh2_ecdsa_key_get_curve_type(param_1);
  sig = ECDSA_SIG_new();
  ret = BN_new();
  ret_00 = BN_new();
  BN_bin2bn(param_2,param_3,ret);
  BN_bin2bn(param_4,param_5,ret_00);
  ECDSA_SIG_set0(sig,ret,ret_00);
  if (iVar1 == 0x19f) {
    _libssh2_sha256(param_6,param_7,auStack_58);
    iStack_80 = ECDSA_do_verify(auStack_58,0x20,sig,param_1);
  }
  else if (iVar1 == 0x2cb) {
    _libssh2_sha384(param_6,param_7,auStack_58);
    iStack_80 = ECDSA_do_verify(auStack_58,0x30,sig,param_1);
  }
  else if (iVar1 == 0x2cc) {
    _libssh2_sha512(param_6,param_7,auStack_58);
    iStack_80 = ECDSA_do_verify(auStack_58,0x40,sig,param_1);
  }
  if (sig != (ECDSA_SIG *)0x0) {
    ECDSA_SIG_free(sig);
  }
  if (iStack_80 == 1) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ASN1_OCTET_STRING_free(ASN1_OCTET_STRING *a)

{
  ASN1_OCTET_STRING_free(a);
  return;
}



void _libssh2_openssh_pem_parse_data(void)

{
  _libssh2_openssh_pem_parse_data();
  return;
}



void RSA_set0_crt_params(void)

{
  RSA_set0_crt_params();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EVP_MD * EVP_sha512(void)

{
  EVP_MD *pEVar1;
  
  pEVar1 = EVP_sha512();
  return pEVar1;
}



void libssh2_session_block_directions(void)

{
  libssh2_session_block_directions();
  return;
}



void libssh2_knownhost_readline(void)

{
  libssh2_knownhost_readline();
  return;
}



ulong _libssh2_pub_priv_keyfile
                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                undefined8 param_5,char *param_6,void *param_7)

{
  int iVar1;
  BIO *bp;
  ulong uVar2;
  EVP_PKEY *pkey;
  uint uStack_24;
  
  bp = BIO_new_file(param_6,"r");
  if (bp == (BIO *)0x0) {
    uVar2 = _libssh2_error(param_1,0xfffffff0,
                           "Unable to extract public key from private key file: Unable to open private key file"
                          );
    return uVar2;
  }
  BIO_ctrl(bp,1,0,(void *)0x0);
  pkey = PEM_read_bio_PrivateKey(bp,(EVP_PKEY **)0x0,(undefined1 *)0x0,param_7);
  BIO_free(bp);
  if (pkey == (EVP_PKEY *)0x0) {
    iVar1 = _libssh2_pub_priv_openssh_keyfile
                      (param_1,param_2,param_3,param_4,param_5,param_6,param_7);
    if (iVar1 != 0) {
      uVar2 = _libssh2_error(param_1,0xfffffff0,
                             "Unable to extract public key from private key file: Wrong passphrase or invalid/unrecognized private key file format"
                            );
      return uVar2;
    }
    return 0;
  }
  iVar1 = EVP_PKEY_id(pkey);
  if (iVar1 == 0x198) {
    uStack_24 = gen_publickey_from_ec_evp(param_1,param_2,param_3,param_4,param_5,pkey);
    goto LAB_0011009a;
  }
  if (iVar1 < 0x199) {
    if (iVar1 == 6) {
      uStack_24 = gen_publickey_from_rsa_evp(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_0011009a;
    }
    if (iVar1 == 0x74) {
      uStack_24 = gen_publickey_from_dsa_evp(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_0011009a;
    }
  }
  uStack_24 = _libssh2_error(param_1,0xfffffff0,
                             "Unable to extract public key from private key file: Unsupported private key file format"
                            );
LAB_0011009a:
  EVP_PKEY_free(pkey);
  return (ulong)uStack_24;
}



int _libssh2_rsa_new_additional_parameters(undefined8 param_1)

{
  int iVar1;
  BIGNUM *pBVar2;
  long in_FS_OFFSET;
  int iStack_4c;
  BIGNUM *pBStack_48;
  BIGNUM *pBStack_40;
  BIGNUM *pBStack_38;
  BIGNUM *pBStack_30;
  BIGNUM *pBStack_28;
  BN_CTX *pBStack_20;
  BIGNUM *pBStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  pBStack_20 = (BN_CTX *)0x0;
  pBStack_18 = (BIGNUM *)0x0;
  pBStack_30 = (BIGNUM *)0x0;
  pBStack_28 = (BIGNUM *)0x0;
  pBStack_48 = (BIGNUM *)0x0;
  pBStack_40 = (BIGNUM *)0x0;
  pBStack_38 = (BIGNUM *)0x0;
  iStack_4c = 0;
  RSA_get0_key(param_1,0,0,&pBStack_38);
  RSA_get0_factors(param_1,&pBStack_48,&pBStack_40);
  pBStack_20 = BN_CTX_new();
  if (pBStack_20 == (BN_CTX *)0x0) {
    iStack_4c = -1;
    goto LAB_0010c622;
  }
  pBStack_18 = BN_new();
  if (pBStack_18 == (BIGNUM *)0x0) {
    iStack_4c = -1;
  }
  else {
    pBStack_30 = BN_new();
    if (pBStack_30 == (BIGNUM *)0x0) {
      iStack_4c = -1;
    }
    else {
      pBStack_28 = BN_new();
      if (pBStack_28 == (BIGNUM *)0x0) {
        iStack_4c = -1;
      }
      else {
        pBVar2 = BN_value_one();
        iVar1 = BN_sub(pBStack_18,pBStack_40,pBVar2);
        if ((iVar1 != 0) &&
           (iVar1 = BN_div((BIGNUM *)0x0,pBStack_28,pBStack_38,pBStack_18,pBStack_20), iVar1 != 0))
        {
          pBVar2 = BN_value_one();
          iVar1 = BN_sub(pBStack_18,pBStack_48,pBVar2);
          if ((iVar1 != 0) &&
             (iVar1 = BN_div((BIGNUM *)0x0,pBStack_30,pBStack_38,pBStack_18,pBStack_20), iVar1 != 0)
             ) {
            RSA_set0_crt_params(param_1,pBStack_30,pBStack_28,0);
            goto LAB_0010c5d4;
          }
        }
        iStack_4c = -1;
      }
    }
  }
LAB_0010c5d4:
  if (pBStack_18 != (BIGNUM *)0x0) {
    BN_clear_free(pBStack_18);
  }
  BN_CTX_free(pBStack_20);
  if (iStack_4c != 0) {
    if (pBStack_30 != (BIGNUM *)0x0) {
      BN_clear_free(pBStack_30);
    }
    if (pBStack_28 != (BIGNUM *)0x0) {
      BN_clear_free(pBStack_28);
    }
  }
LAB_0010c622:
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iStack_4c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EC_POINT * EC_KEY_get0_public_key(EC_KEY *key)

{
  EC_POINT *pEVar1;
  
  pEVar1 = EC_KEY_get0_public_key(key);
  return pEVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int BN_num_bits(BIGNUM *a)

{
  int iVar1;
  
  iVar1 = BN_num_bits(a);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



void _libssh2_mac_methods(void)

{
  _libssh2_mac_methods();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

DSA_SIG * DSA_SIG_new(void)

{
  DSA_SIG *pDVar1;
  
  pDVar1 = DSA_SIG_new();
  return pDVar1;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



uint Blowfish_stream2word(long param_1,ushort param_2,ushort *param_3)

{
  byte bStack_f;
  ushort uStack_e;
  uint uStack_c;
  
  uStack_c = 0;
  uStack_e = *param_3;
  for (bStack_f = 0; bStack_f < 4; bStack_f = bStack_f + 1) {
    if (param_2 <= uStack_e) {
      uStack_e = 0;
    }
    uStack_c = (uint)*(byte *)(param_1 + (ulong)uStack_e) | uStack_c << 8;
    uStack_e = uStack_e + 1;
  }
  *param_3 = uStack_e;
  return uStack_c;
}



void _libssh2_ntohu32(void)

{
  _libssh2_ntohu32();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EVP_MD * EVP_sha1(void)

{
  EVP_MD *pEVar1;
  
  pEVar1 = EVP_sha1();
  return pEVar1;
}



bool _libssh2_cipher_crypt
               (undefined8 *param_1,undefined8 param_2,undefined8 param_3,uchar *param_4,
               size_t param_5)

{
  int iVar1;
  long in_FS_OFFSET;
  uchar auStack_38 [40];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = EVP_Cipher((EVP_CIPHER_CTX *)*param_1,auStack_38,param_4,(uint)param_5);
  if (iVar1 == 1) {
    memcpy(param_4,auStack_38,param_5);
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1 != 1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void EVP_DigestSign(void)

{
  EVP_DigestSign();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

BIGNUM * BN_bin2bn(uchar *s,int len,BIGNUM *ret)

{
  BIGNUM *pBVar1;
  
  pBVar1 = BN_bin2bn(s,len,ret);
  return pBVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t send(int __fd,void *__buf,size_t __n,int __flags)

{
  ssize_t sVar1;
  
  sVar1 = send(__fd,__buf,__n,__flags);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int RAND_bytes(uchar *buf,int num)

{
  int iVar1;
  
  iVar1 = RAND_bytes(buf,num);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void RSA_free(RSA *r)

{
  RSA_free(r);
  return;
}



void _libssh2_dh_dtor(undefined8 *param_1)

{
  BN_clear_free((BIGNUM *)*param_1);
  *param_1 = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strchr(__s,__c);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int BN_sub(BIGNUM *r,BIGNUM *a,BIGNUM *b)

{
  int iVar1;
  
  iVar1 = BN_sub(r,a,b);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double difftime(time_t __time1,time_t __time0)

{
  double dVar1;
  
  dVar1 = difftime(__time1,__time0);
  return dVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void rewind(FILE *__stream)

{
  rewind(__stream);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void EVP_PKEY_free(EVP_PKEY *pkey)

{
  EVP_PKEY_free(pkey);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EC_POINT_oct2point(EC_GROUP *group,EC_POINT *p,uchar *buf,size_t len,BN_CTX *ctx)

{
  int iVar1;
  
  iVar1 = EC_POINT_oct2point(group,p,buf,len,ctx);
  return iVar1;
}



void libssh2_base64_decode(void)

{
  libssh2_base64_decode();
  return;
}



int _libssh2_ecdsa_new_private_frommemory
              (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
              undefined8 param_5)

{
  int iStack_14;
  
  _libssh2_init_if_needed();
  iStack_14 = read_private_key_from_memory
                        (param_1,&PEM_read_bio_ECPrivateKey,param_3,param_4,param_5);
  if (iStack_14 != 0) {
    iStack_14 = read_openssh_private_key_from_memory
                          (param_1,param_2,"ssh-ecdsa",param_3,param_4,param_5);
  }
  return iStack_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int snprintf(char *__s,size_t __maxlen,char *__format,...)

{
  int iVar1;
  
  iVar1 = snprintf(__s,__maxlen,__format);
  return iVar1;
}



void _libssh2_list_init(void)

{
  _libssh2_list_init();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strrchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strrchr(__s,__c);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int gettimeofday(timeval *__tv,__timezone_ptr_t __tz)

{
  int iVar1;
  
  iVar1 = gettimeofday(__tv,__tz);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_DigestInit(EVP_MD_CTX *ctx,EVP_MD *type)

{
  int iVar1;
  
  iVar1 = EVP_DigestInit(ctx,type);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __assert_fail(char *__assertion,char *__file,uint __line,char *__function)

{
                    // WARNING: Subroutine does not return
  __assert_fail(__assertion,__file,__line,__function);
}



long _libssh2_channel_packet_data_len(long param_1,int param_2)

{
  int iVar1;
  int iVar2;
  long lStack_18;
  
  lStack_18 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0);
  if (lStack_18 != 0) {
    for (; lStack_18 != 0; lStack_18 = _libssh2_list_next(lStack_18)) {
      iVar1 = _libssh2_ntohu32(*(long *)(lStack_18 + 0x18) + 1);
      if (((((param_2 != 0) && (**(char **)(lStack_18 + 0x18) == '_')) &&
           (iVar1 == *(int *)(param_1 + 0x30))) &&
          (iVar2 = _libssh2_ntohu32(*(long *)(lStack_18 + 0x18) + 5), param_2 == iVar2)) ||
         ((((param_2 == 0 && (**(char **)(lStack_18 + 0x18) == '^')) &&
           (iVar1 == *(int *)(param_1 + 0x30))) ||
          (((param_2 == 0 && (**(char **)(lStack_18 + 0x18) == '_')) &&
           ((iVar1 == *(int *)(param_1 + 0x30) && (*(char *)(param_1 + 0x56) == '\x02')))))))) {
        return *(long *)(lStack_18 + 0x20) - *(long *)(lStack_18 + 0x28);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_Cipher(EVP_CIPHER_CTX *c,uchar *out,uchar *in,uint inl)

{
  int iVar1;
  
  iVar1 = EVP_Cipher(c,out,in,inl);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ec_key_st * EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey)

{
  ec_key_st *peVar1;
  
  peVar1 = EVP_PKEY_get1_EC_KEY(pkey);
  return peVar1;
}



undefined4 _libssh2_curve25519_new(long param_1,undefined8 *param_2,long *param_3,long *param_4)

{
  int iVar1;
  undefined4 uVar2;
  long lVar3;
  long in_FS_OFFSET;
  int iStack_68;
  int iStack_64;
  undefined4 uStack_60;
  int iStack_5c;
  EVP_PKEY *pEStack_58;
  X509_PUBKEY *pXStack_50;
  uchar *puStack_48;
  uchar *puStack_40;
  ASN1_OCTET_STRING *pAStack_38;
  EVP_PKEY_CTX *pEStack_30;
  PKCS8_PRIV_KEY_INFO *pPStack_28;
  long *plStack_20;
  void *pvStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  pEStack_58 = (EVP_PKEY *)0x0;
  pEStack_30 = (EVP_PKEY_CTX *)0x0;
  pPStack_28 = (PKCS8_PRIV_KEY_INFO *)0x0;
  pAStack_38 = (ASN1_OCTET_STRING *)0x0;
  pXStack_50 = (X509_PUBKEY *)0x0;
  plStack_20 = (long *)0x0;
  uStack_60 = 0xffffffff;
  pEStack_30 = EVP_PKEY_CTX_new_id(0x40a,(ENGINE *)0x0);
  if (pEStack_30 == (EVP_PKEY_CTX *)0x0) {
    uVar2 = 0xffffffff;
    goto LAB_0010d96c;
  }
  EVP_PKEY_keygen_init(pEStack_30);
  EVP_PKEY_keygen(pEStack_30,&pEStack_58);
  pPStack_28 = EVP_PKEY2PKCS8(pEStack_58);
  if (((pPStack_28 != (PKCS8_PRIV_KEY_INFO *)0x0) &&
      (iVar1 = PKCS8_pkey_get0((ASN1_OBJECT **)0x0,&puStack_48,&iStack_64,(X509_ALGOR **)0x0,
                               pPStack_28), iVar1 != 0)) &&
     (pAStack_38 = d2i_ASN1_OCTET_STRING((ASN1_OCTET_STRING **)0x0,&puStack_48,(long)iStack_64),
     pAStack_38 != (ASN1_OCTET_STRING *)0x0)) {
    pvStack_18 = (void *)ASN1_STRING_get0_data(pAStack_38);
    iStack_5c = ASN1_STRING_length(pAStack_38);
    if (((iStack_5c == 0x20) && (pXStack_50 = X509_PUBKEY_new(), pXStack_50 != (X509_PUBKEY *)0x0))
       && ((iVar1 = X509_PUBKEY_set(&pXStack_50,pEStack_58), iVar1 != 0 &&
           ((iVar1 = X509_PUBKEY_get0_param
                               ((ASN1_OBJECT **)0x0,&puStack_40,&iStack_68,(X509_ALGOR **)0x0,
                                pXStack_50), iVar1 != 0 && (iStack_68 == 0x20)))))) {
      if (param_4 != (long *)0x0) {
        lVar3 = (**(code **)(param_1 + 8))(0x20,param_1);
        *param_4 = lVar3;
        if (*param_4 == 0) goto LAB_0010d906;
        memcpy((void *)*param_4,pvStack_18,0x20);
      }
      if (param_3 != (long *)0x0) {
        lVar3 = (**(code **)(param_1 + 8))(0x20,param_1);
        *param_3 = lVar3;
        if (*param_3 == 0) goto LAB_0010d906;
        memcpy((void *)*param_3,puStack_40,0x20);
      }
      if (param_2 == (undefined8 *)0x0) {
LAB_0010d8e1:
        uStack_60 = 0;
      }
      else {
        plStack_20 = (long *)malloc(0x10);
        if (plStack_20 != (long *)0x0) {
          lVar3 = EVP_PKEY_new_raw_private_key(0x40a,0,pvStack_18,0x20);
          plStack_20[1] = lVar3;
          lVar3 = EVP_PKEY_new_raw_public_key(0x40a,0,puStack_40,0x20);
          *plStack_20 = lVar3;
          if ((*plStack_20 != 0) && (plStack_20[1] != 0)) {
            *param_2 = plStack_20;
            goto LAB_0010d8e1;
          }
          if (plStack_20 != (long *)0x0) {
            if (*plStack_20 != 0) {
              EVP_PKEY_free((EVP_PKEY *)*plStack_20);
            }
            if (plStack_20[1] != 0) {
              EVP_PKEY_free((EVP_PKEY *)plStack_20[1]);
            }
            free(plStack_20);
          }
        }
      }
    }
  }
LAB_0010d906:
  if (pPStack_28 != (PKCS8_PRIV_KEY_INFO *)0x0) {
    PKCS8_PRIV_KEY_INFO_free(pPStack_28);
  }
  if (pEStack_30 != (EVP_PKEY_CTX *)0x0) {
    EVP_PKEY_CTX_free(pEStack_30);
  }
  if (pAStack_38 != (ASN1_OCTET_STRING *)0x0) {
    ASN1_OCTET_STRING_free(pAStack_38);
  }
  if (pXStack_50 != (X509_PUBKEY *)0x0) {
    X509_PUBKEY_free(pXStack_50);
  }
  uVar2 = uStack_60;
  if (pEStack_58 != (EVP_PKEY *)0x0) {
    EVP_PKEY_free(pEStack_58);
    uVar2 = uStack_60;
  }
LAB_0010d96c:
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void _libssh2_list_add(void)

{
  _libssh2_list_add();
  return;
}



int libssh2_channel_eof(long param_1)

{
  int iVar1;
  int iVar2;
  long lStack_28;
  
  if (param_1 == 0) {
    iVar2 = -0x27;
  }
  else {
    for (lStack_28 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0); lStack_28 != 0;
        lStack_28 = _libssh2_list_next(lStack_28)) {
      if (((**(char **)(lStack_28 + 0x18) == '^') || (**(char **)(lStack_28 + 0x18) == '_')) &&
         (iVar2 = *(int *)(param_1 + 0x30),
         iVar1 = _libssh2_ntohu32(*(long *)(lStack_28 + 0x18) + 1), iVar2 == iVar1)) {
        return 0;
      }
    }
    iVar2 = (int)*(char *)(param_1 + 0x55);
  }
  return iVar2;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memset(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memset(__s,__c,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BN_CTX_free(BN_CTX *c)

{
  BN_CTX_free(c);
  return;
}



int _libssh2_dsa_new_private_frommemory
              (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
              undefined8 param_5)

{
  int iStack_14;
  
  _libssh2_init_if_needed();
  iStack_14 = read_private_key_from_memory
                        (param_1,&PEM_read_bio_DSAPrivateKey,param_3,param_4,param_5);
  if (iStack_14 != 0) {
    iStack_14 = read_openssh_private_key_from_memory
                          (param_1,param_2,"ssh-dsa",param_3,param_4,param_5);
  }
  return iStack_14;
}



undefined8
_libssh2_channel_open
          (long param_1,void *param_2,uint param_3,undefined4 param_4,undefined4 param_5,
          undefined8 param_6,undefined8 param_7)

{
  long lVar1;
  undefined *puVar2;
  undefined4 uVar3;
  uint uVar4;
  int iVar5;
  undefined8 uVar6;
  long in_FS_OFFSET;
  undefined *puStack_30;
  undefined auStack_24 [4];
  long lStack_20;
  
  lStack_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd1f0) == 0) {
    *(undefined8 *)(param_1 + 0xd200) = 0;
    *(undefined8 *)(param_1 + 0xd208) = 0;
    *(undefined8 *)(param_1 + 0xd218) = 0;
    *(ulong *)(param_1 + 0xd210) = (ulong)(param_3 + 0x11);
    uVar3 = _libssh2_channel_nextid(param_1);
    *(undefined4 *)(param_1 + 0xd228) = uVar3;
    memset((void *)(param_1 + 0xd1f8),0,8);
    uVar6 = _libssh2_calloc(param_1,0x2b0);
    *(undefined8 *)(param_1 + 0xd200) = uVar6;
    if (*(long *)(param_1 + 0xd200) == 0) {
      _libssh2_error(param_1,0xfffffffa,"Unable to allocate space for channel data");
      uVar6 = 0;
      goto LAB_00114b04;
    }
    *(uint *)(*(long *)(param_1 + 0xd200) + 0x20) = param_3;
    lVar1 = *(long *)(param_1 + 0xd200);
    uVar6 = (**(code **)(param_1 + 8))(param_3,param_1);
    *(undefined8 *)(lVar1 + 0x18) = uVar6;
    if (*(long *)(*(long *)(param_1 + 0xd200) + 0x18) == 0) {
      _libssh2_error(param_1,0xfffffffa,"Failed allocating memory for channel type name");
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd200),param_1);
      *(undefined8 *)(param_1 + 0xd200) = 0;
      uVar6 = 0;
      goto LAB_00114b04;
    }
    memcpy(*(void **)(*(long *)(param_1 + 0xd200) + 0x18),param_2,(ulong)param_3);
    *(undefined4 *)(*(long *)(param_1 + 0xd200) + 0x30) = *(undefined4 *)(param_1 + 0xd228);
    *(undefined4 *)(*(long *)(param_1 + 0xd200) + 0x4c) = param_4;
    *(undefined4 *)(*(long *)(param_1 + 0xd200) + 0x48) = param_4;
    *(undefined4 *)(*(long *)(param_1 + 0xd200) + 0x50) = param_5;
    *(long *)(*(long *)(param_1 + 0xd200) + 0x60) = param_1;
    _libssh2_list_add(param_1 + 0x200,*(undefined8 *)(param_1 + 0xd200));
    uVar6 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_1 + 0xd210),param_1);
    *(undefined8 *)(param_1 + 0xd208) = uVar6;
    puVar2 = *(undefined **)(param_1 + 0xd208);
    if (*(long *)(param_1 + 0xd208) != 0) {
      puStack_30 = puVar2 + 1;
      *puVar2 = 0x5a;
      _libssh2_store_str(&puStack_30,param_2,param_3);
      _libssh2_store_u32(&puStack_30,*(undefined4 *)(param_1 + 0xd228));
      _libssh2_store_u32(&puStack_30,param_4);
      _libssh2_store_u32(&puStack_30,param_5);
      *(undefined4 *)(param_1 + 0xd1f0) = 2;
      goto LAB_001145ea;
    }
    puStack_30 = puVar2;
    _libssh2_error(param_1,0xfffffffa,"Unable to allocate temporary space for packet");
  }
  else {
LAB_001145ea:
    if (*(int *)(param_1 + 0xd1f0) == 2) {
      iVar5 = _libssh2_transport_send
                        (param_1,*(undefined8 *)(param_1 + 0xd208),*(undefined8 *)(param_1 + 0xd210)
                         ,param_6,param_7);
      if (iVar5 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block sending channel-open request");
        uVar6 = 0;
        goto LAB_00114b04;
      }
      if (iVar5 != 0) {
        _libssh2_error(param_1,iVar5,"Unable to send channel-open request");
        goto LAB_00114929;
      }
      *(undefined4 *)(param_1 + 0xd1f0) = 3;
    }
    if (*(int *)(param_1 + 0xd1f0) == 3) {
      iVar5 = _libssh2_packet_requirev
                        (param_1,&reply_codes_20197,param_1 + 0xd218,param_1 + 0xd220,1,
                         *(long *)(param_1 + 0xd208) + (ulong)param_3 + 5,4,param_1 + 0xd1f8);
      if (iVar5 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block");
        uVar6 = 0;
        goto LAB_00114b04;
      }
      if (iVar5 == 0) {
        if (**(char **)(param_1 + 0xd218) == '[') {
          lVar1 = *(long *)(param_1 + 0xd200);
          uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd218) + 5);
          *(undefined4 *)(lVar1 + 0x44) = uVar3;
          lVar1 = *(long *)(param_1 + 0xd200);
          uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd218) + 9);
          *(undefined4 *)(lVar1 + 0x38) = uVar3;
          lVar1 = *(long *)(param_1 + 0xd200);
          uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd218) + 9);
          *(undefined4 *)(lVar1 + 0x34) = uVar3;
          lVar1 = *(long *)(param_1 + 0xd200);
          uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd218) + 0xd);
          *(undefined4 *)(lVar1 + 0x3c) = uVar3;
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd208),param_1);
          *(undefined8 *)(param_1 + 0xd208) = 0;
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd218),param_1);
          *(undefined8 *)(param_1 + 0xd218) = 0;
          *(undefined4 *)(param_1 + 0xd1f0) = 0;
          uVar6 = *(undefined8 *)(param_1 + 0xd200);
          goto LAB_00114b04;
        }
        if (**(char **)(param_1 + 0xd218) == '\\') {
          uVar4 = _libssh2_ntohu32(*(long *)(param_1 + 0xd218) + 5);
          if (uVar4 == 4) {
            _libssh2_error(param_1,0xffffffeb,"Channel open failure (resource shortage)");
          }
          else if (uVar4 < 5) {
            if (uVar4 == 3) {
              _libssh2_error(param_1,0xffffffeb,"Channel open failure (unknown channel type)");
            }
            else {
              if (3 < uVar4) goto LAB_0011490b;
              if (uVar4 == 1) {
                _libssh2_error(param_1,0xffffffeb,
                               "Channel open failure (administratively prohibited)");
              }
              else {
                if (uVar4 != 2) goto LAB_0011490b;
                _libssh2_error(param_1,0xffffffeb,"Channel open failure (connect failed)");
              }
            }
          }
          else {
LAB_0011490b:
            _libssh2_error(param_1,0xffffffeb,"Channel open failure");
          }
        }
      }
    }
  }
LAB_00114929:
  if (*(long *)(param_1 + 0xd218) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd218),param_1);
    *(undefined8 *)(param_1 + 0xd218) = 0;
  }
  if (*(long *)(param_1 + 0xd208) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd208),param_1);
    *(undefined8 *)(param_1 + 0xd208) = 0;
  }
  if (*(long *)(param_1 + 0xd200) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(*(long *)(param_1 + 0xd200) + 0x18),param_1);
    _libssh2_list_remove(*(undefined8 *)(param_1 + 0xd200));
    _libssh2_htonu32(auStack_24,*(undefined4 *)(*(long *)(param_1 + 0xd200) + 0x30));
    while ((iVar5 = _libssh2_packet_ask(param_1,0x5e,param_1 + 0xd218,param_1 + 0xd220,1,auStack_24,
                                        4), -1 < iVar5 ||
           (iVar5 = _libssh2_packet_ask(param_1,0x5f,param_1 + 0xd218,param_1 + 0xd220,1,auStack_24,
                                        4), -1 < iVar5))) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd218),param_1);
      *(undefined8 *)(param_1 + 0xd218) = 0;
    }
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd200),param_1);
    *(undefined8 *)(param_1 + 0xd200) = 0;
  }
  *(undefined4 *)(param_1 + 0xd1f0) = 0;
  uVar6 = 0;
LAB_00114b04:
  if (lStack_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void HMAC_CTX_new(void)

{
  HMAC_CTX_new();
  return;
}



undefined8
_libssh2_channel_process_startup
          (long param_1,undefined8 param_2,long param_3,long param_4,ulong param_5)

{
  char cVar1;
  undefined *puVar2;
  int iVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  undefined *puStack_30;
  char *pcStack_28;
  undefined auStack_20 [8];
  long lStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  lStack_18 = *(long *)(param_1 + 0x60);
  if (*(int *)(param_1 + 0x210) == 0x10) {
    uVar4 = _libssh2_error(lStack_18,0xffffffd9,"Channel can not be reused");
    goto LAB_00116c85;
  }
  if (*(int *)(param_1 + 0x210) == 0) {
    *(long *)(param_1 + 0x220) = param_3 + 10;
    memset((void *)(param_1 + 0x230),0,8);
    if (param_4 != 0) {
      *(long *)(param_1 + 0x220) = *(long *)(param_1 + 0x220) + 4;
    }
    uVar4 = (**(code **)(lStack_18 + 8))(*(undefined8 *)(param_1 + 0x220),lStack_18);
    *(undefined8 *)(param_1 + 0x218) = uVar4;
    puVar2 = *(undefined **)(param_1 + 0x218);
    if (*(long *)(param_1 + 0x218) == 0) {
      puStack_30 = puVar2;
      uVar4 = _libssh2_error(lStack_18,0xfffffffa,
                             "Unable to allocate memory for channel-process request");
      goto LAB_00116c85;
    }
    puStack_30 = puVar2 + 1;
    *puVar2 = 0x62;
    _libssh2_store_u32(&puStack_30,*(undefined4 *)(param_1 + 0x44));
    _libssh2_store_str(&puStack_30,param_2,param_3);
    puVar2 = puStack_30 + 1;
    *puStack_30 = 1;
    puStack_30 = puVar2;
    if (param_4 != 0) {
      _libssh2_store_u32(&puStack_30,param_5 & 0xffffffff);
    }
    *(undefined4 *)(param_1 + 0x210) = 2;
  }
  if (*(int *)(param_1 + 0x210) == 2) {
    iVar3 = _libssh2_transport_send
                      (lStack_18,*(undefined8 *)(param_1 + 0x218),*(undefined8 *)(param_1 + 0x220),
                       param_4,param_5);
    if (iVar3 == -0x25) {
      _libssh2_error(lStack_18,0xffffffdb,"Would block sending channel request");
      uVar4 = 0xffffffdb;
      goto LAB_00116c85;
    }
    if (iVar3 != 0) {
      (**(code **)(lStack_18 + 0x18))(*(undefined8 *)(param_1 + 0x218),lStack_18);
      *(undefined8 *)(param_1 + 0x218) = 0;
      *(undefined4 *)(param_1 + 0x210) = 0x10;
      uVar4 = _libssh2_error(lStack_18,iVar3,"Unable to send channel request");
      goto LAB_00116c85;
    }
    (**(code **)(lStack_18 + 0x18))(*(undefined8 *)(param_1 + 0x218),lStack_18);
    *(undefined8 *)(param_1 + 0x218) = 0;
    _libssh2_htonu32(param_1 + 0x228,*(undefined4 *)(param_1 + 0x30));
    *(undefined4 *)(param_1 + 0x210) = 3;
  }
  if (*(int *)(param_1 + 0x210) == 3) {
    iVar3 = _libssh2_packet_requirev
                      (lStack_18,&reply_codes_20429,&pcStack_28,auStack_20,1,param_1 + 0x228,4,
                       param_1 + 0x230);
    if (iVar3 == -0x25) {
      uVar4 = 0xffffffdb;
      goto LAB_00116c85;
    }
    if (iVar3 != 0) {
      *(undefined4 *)(param_1 + 0x210) = 0x10;
      uVar4 = _libssh2_error(lStack_18,iVar3,"Failed waiting for channel success");
      goto LAB_00116c85;
    }
    cVar1 = *pcStack_28;
    (**(code **)(lStack_18 + 0x18))(pcStack_28,lStack_18);
    *(undefined4 *)(param_1 + 0x210) = 0x10;
    if (cVar1 == 'c') {
      uVar4 = 0;
      goto LAB_00116c85;
    }
  }
  uVar4 = _libssh2_error(lStack_18,0xffffffea,
                         "Unable to complete request for channel-process-startup");
LAB_00116c85:
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int close(int __fd)

{
  int iVar1;
  
  iVar1 = close(__fd);
  return iVar1;
}



int _libssh2_dsa_new_private
              (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  int iStack_14;
  
  _libssh2_init_if_needed();
  iStack_14 = read_private_key_from_file(param_1,&PEM_read_bio_DSAPrivateKey,param_3,param_4);
  if (iStack_14 != 0) {
    iStack_14 = _libssh2_dsa_new_openssh_private(param_1,param_2,param_3,param_4);
  }
  return iStack_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ECDSA_SIG_free(ECDSA_SIG *sig)

{
  ECDSA_SIG_free(sig);
  return;
}



void _libssh2_explicit_zero(void)

{
  _libssh2_explicit_zero();
  return;
}



long _libssh2_channel_read(long param_1,int param_2,long param_3,long param_4)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  undefined4 uVar4;
  int iVar5;
  long lVar6;
  long lVar7;
  int iStack_3c;
  int iStack_38;
  uint uStack_30;
  long lStack_28;
  
  lVar6 = *(long *)(param_1 + 0x60);
  iStack_3c = 0;
  iVar3 = (int)param_4;
  if ((*(int *)(param_1 + 0x260) == 0xb) ||
     ((ulong)*(uint *)(param_1 + 0x4c) < param_4 + (ulong)((*(uint *)(param_1 + 0x48) >> 2) * 3))) {
    uStack_30 = (iVar3 + *(int *)(param_1 + 0x48)) - *(int *)(param_1 + 0x4c);
    if (uStack_30 < 0x400) {
      uStack_30 = 0x400;
    }
    *(undefined4 *)(param_1 + 0x260) = 0xb;
    iVar2 = _libssh2_channel_receive_window_adjust(param_1,uStack_30,0,0);
    if (iVar2 != 0) {
      return (long)iVar2;
    }
    *(undefined4 *)(param_1 + 0x260) = 0;
  }
  do {
    iVar2 = _libssh2_transport_read(lVar6);
  } while (0 < iVar2);
  if ((iVar2 < 0) && (iVar2 != -0x25)) {
    iVar3 = _libssh2_error(lVar6,iVar2,"transport read");
    lVar6 = (long)iVar3;
  }
  else {
    lVar7 = _libssh2_list_first(lVar6 + 0x1f0);
    while ((lStack_28 = lVar7, lStack_28 != 0 && (iStack_3c < iVar3))) {
      lVar7 = _libssh2_list_next(lStack_28);
      uVar4 = _libssh2_ntohu32(*(long *)(lStack_28 + 0x18) + 1);
      *(undefined4 *)(param_1 + 0x264) = uVar4;
      if ((((param_2 != 0) &&
           (((**(char **)(lStack_28 + 0x18) == '_' &&
             (*(int *)(param_1 + 0x30) == *(int *)(param_1 + 0x264))) &&
            (iVar5 = _libssh2_ntohu32(*(long *)(lStack_28 + 0x18) + 5), param_2 == iVar5)))) ||
          (((param_2 == 0 && (**(char **)(lStack_28 + 0x18) == '^')) &&
           (*(int *)(param_1 + 0x30) == *(int *)(param_1 + 0x264))))) ||
         (((param_2 == 0 && (**(char **)(lStack_28 + 0x18) == '_')) &&
          ((*(int *)(param_1 + 0x30) == *(int *)(param_1 + 0x264) &&
           (*(char *)(param_1 + 0x56) == '\x02')))))) {
        iStack_38 = iVar3 - iStack_3c;
        bVar1 = (int)*(undefined8 *)(lStack_28 + 0x20) - (int)*(undefined8 *)(lStack_28 + 0x28) <=
                iStack_38;
        if (bVar1) {
          iStack_38 = (int)*(undefined8 *)(lStack_28 + 0x20) -
                      (int)*(undefined8 *)(lStack_28 + 0x28);
        }
        memcpy((void *)(iStack_3c + param_3),
               (void *)(*(long *)(lStack_28 + 0x18) + *(long *)(lStack_28 + 0x28)),(long)iStack_38);
        *(long *)(lStack_28 + 0x28) = *(long *)(lStack_28 + 0x28) + (long)iStack_38;
        iStack_3c = iStack_3c + iStack_38;
        if (bVar1) {
          _libssh2_list_remove(lStack_28);
          (**(code **)(lVar6 + 0x18))(*(undefined8 *)(lStack_28 + 0x18),lVar6);
          (**(code **)(lVar6 + 0x18))(lStack_28,lVar6);
        }
      }
    }
    if (iStack_3c == 0) {
      if ((*(char *)(param_1 + 0x55) == '\0') && (*(char *)(param_1 + 0x54) == '\0')) {
        if (iVar2 == -0x25) {
          iVar3 = _libssh2_error(lVar6,0xffffffdb,"would block");
          lVar6 = (long)iVar3;
        }
        else {
          lVar6 = 0;
        }
      }
      else {
        lVar6 = 0;
      }
    }
    else {
      *(int *)(param_1 + 0x5c) = *(int *)(param_1 + 0x5c) - iStack_3c;
      *(int *)(param_1 + 0x4c) = *(int *)(param_1 + 0x4c) - iStack_3c;
      lVar6 = (long)iStack_3c;
    }
  }
  return lVar6;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void DSA_free(DSA *r)

{
  DSA_free(r);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_DigestVerifyInit(EVP_MD_CTX *ctx,EVP_PKEY_CTX **pctx,EVP_MD *type,ENGINE *e,EVP_PKEY *pkey)

{
  int iVar1;
  
  iVar1 = EVP_DigestVerifyInit(ctx,pctx,type,e,pkey);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int PKCS8_pkey_get0(ASN1_OBJECT **ppkalg,uchar **pk,int *ppklen,X509_ALGOR **pa,
                   PKCS8_PRIV_KEY_INFO *p8)

{
  int iVar1;
  
  iVar1 = PKCS8_pkey_get0(ppkalg,pk,ppklen,pa,p8);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int X509_PUBKEY_get0_param
              (ASN1_OBJECT **ppkalg,uchar **pk,int *ppklen,X509_ALGOR **pa,X509_PUBKEY *pub)

{
  int iVar1;
  
  iVar1 = X509_PUBKEY_get0_param(ppkalg,pk,ppklen,pa,pub);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_DigestSignInit(EVP_MD_CTX *ctx,EVP_PKEY_CTX **pctx,EVP_MD *type,ENGINE *e,EVP_PKEY *pkey)

{
  int iVar1;
  
  iVar1 = EVP_DigestSignInit(ctx,pctx,type,e,pkey);
  return iVar1;
}



undefined8 libssh2_agent_disconnect(long param_1)

{
  undefined8 uVar1;
  
  if ((*(long *)(param_1 + 0x10) == 0) || (*(int *)(param_1 + 8) == -1)) {
    uVar1 = 0;
  }
  else {
    uVar1 = (**(code **)(*(long *)(param_1 + 0x10) + 0x10))(param_1);
  }
  return uVar1;
}



undefined8 _libssh2_channel_flush(long param_1,int param_2)

{
  char cVar1;
  undefined8 uVar2;
  uint uVar3;
  int iVar4;
  long lVar5;
  ulong uVar6;
  undefined8 uVar7;
  long lStack_20;
  
  if (*(int *)(param_1 + 0x238) == 0) {
    lVar5 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0);
    *(undefined8 *)(param_1 + 0x240) = 0;
    *(undefined8 *)(param_1 + 0x248) = 0;
    while (lStack_20 = lVar5, lStack_20 != 0) {
      lVar5 = _libssh2_list_next(lStack_20);
      cVar1 = **(char **)(lStack_20 + 0x18);
      if (((cVar1 == '^') || (cVar1 == '_')) &&
         (iVar4 = _libssh2_ntohu32(*(long *)(lStack_20 + 0x18) + 1),
         iVar4 == *(int *)(param_1 + 0x30))) {
        if (cVar1 == '^') {
          uVar6 = 0;
        }
        else {
          uVar3 = _libssh2_ntohu32(*(long *)(lStack_20 + 0x18) + 5);
          uVar6 = (ulong)uVar3;
        }
        if (((param_2 == -2) || ((cVar1 == '_' && ((param_2 == -1 || (uVar6 == (long)param_2))))))
           || ((cVar1 == '^' && (param_2 == 0)))) {
          uVar7 = *(undefined8 *)(lStack_20 + 0x20);
          uVar2 = *(undefined8 *)(lStack_20 + 0x28);
          *(long *)(param_1 + 0x240) =
               *(long *)(lStack_20 + 0x20) + *(long *)(param_1 + 0x240) + -0xd;
          *(long *)(param_1 + 0x248) = *(long *)(param_1 + 0x248) + (long)((int)uVar7 - (int)uVar2);
          (**(code **)(*(long *)(param_1 + 0x60) + 0x18))
                    (*(undefined8 *)(lStack_20 + 0x18),*(undefined8 *)(param_1 + 0x60));
          _libssh2_list_remove(lStack_20);
          (**(code **)(*(long *)(param_1 + 0x60) + 0x18))(lStack_20,*(undefined8 *)(param_1 + 0x60))
          ;
        }
      }
    }
    *(undefined4 *)(param_1 + 0x238) = 2;
  }
  *(int *)(param_1 + 0x5c) = *(int *)(param_1 + 0x5c) - (int)*(undefined8 *)(param_1 + 0x248);
  *(int *)(param_1 + 0x4c) = *(int *)(param_1 + 0x4c) - (int)*(undefined8 *)(param_1 + 0x248);
  if ((*(long *)(param_1 + 0x240) == 0) ||
     (iVar4 = _libssh2_channel_receive_window_adjust
                        (param_1,*(ulong *)(param_1 + 0x240) & 0xffffffff,1,0), iVar4 != -0x25)) {
    *(undefined4 *)(param_1 + 0x238) = 0;
    uVar7 = *(undefined8 *)(param_1 + 0x248);
  }
  else {
    uVar7 = 0xffffffdb;
  }
  return uVar7;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memchr(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memchr(__s,__c,__n);
  return pvVar1;
}



void _libssh2_string_buf_free(void)

{
  _libssh2_string_buf_free();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int memcmp(void *__s1,void *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = memcmp(__s1,__s2,__n);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * fgets(char *__s,int __n,FILE *__stream)

{
  char *pcVar1;
  
  pcVar1 = fgets(__s,__n,__stream);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int HMAC_Update(HMAC_CTX *ctx,uchar *data,size_t len)

{
  int iVar1;
  
  iVar1 = HMAC_Update(ctx,data,len);
  return iVar1;
}



int _libssh2_channel_close(long param_1)

{
  long lVar1;
  int iVar2;
  int iStack_14;
  
  lVar1 = *(long *)(param_1 + 0x60);
  iStack_14 = 0;
  if (*(char *)(param_1 + 0x40) == '\0') {
    if ((*(char *)(param_1 + 0x41) == '\0') &&
       (iStack_14 = channel_send_eof(param_1), iStack_14 != 0)) {
      if (iStack_14 == -0x25) {
        return -0x25;
      }
      _libssh2_error(lVar1,iStack_14,"Unable to send EOF, but closing channel anyway");
    }
    if (*(int *)(param_1 + 0x290) == 0) {
      *(undefined *)(param_1 + 0x294) = 0x61;
      _libssh2_htonu32(param_1 + 0x295,*(undefined4 *)(param_1 + 0x44));
      *(undefined4 *)(param_1 + 0x290) = 2;
    }
    if (*(int *)(param_1 + 0x290) == 2) {
      iStack_14 = _libssh2_transport_send(lVar1,param_1 + 0x294,5,0,0);
      if (iStack_14 == -0x25) {
        _libssh2_error(lVar1,0xffffffdb,"Would block sending close-channel");
        return -0x25;
      }
      if (iStack_14 == 0) {
        *(undefined4 *)(param_1 + 0x290) = 3;
      }
      else {
        _libssh2_error(lVar1,iStack_14,"Unable to send close-channel request, but closing anyway");
      }
    }
    if (*(int *)(param_1 + 0x290) == 3) {
      while (((*(char *)(param_1 + 0x54) == '\0' && (iStack_14 == 0)) &&
             (*(int *)(lVar1 + 0x22c) != -1))) {
        iStack_14 = _libssh2_transport_read(lVar1);
      }
    }
    if (iStack_14 != -0x25) {
      *(undefined *)(param_1 + 0x40) = 1;
      if (*(long *)(param_1 + 0x70) != 0) {
        (**(code **)(param_1 + 0x70))(lVar1,lVar1,param_1,param_1 + 0x68);
      }
      *(undefined4 *)(param_1 + 0x290) = 0;
    }
    iVar2 = 0;
    if (iStack_14 < 1) {
      iVar2 = iStack_14;
    }
  }
  else {
    *(undefined4 *)(param_1 + 0x290) = 0;
    iVar2 = 0;
  }
  return iVar2;
}



undefined4 libssh2_channel_window_read_ex(long param_1,long *param_2,ulong *param_3)

{
  int iVar1;
  undefined4 uVar2;
  long lStack_18;
  long lStack_10;
  
  if (param_1 == 0) {
    uVar2 = 0;
  }
  else {
    if (param_3 != (ulong *)0x0) {
      *param_3 = (ulong)*(uint *)(param_1 + 0x48);
    }
    if (param_2 != (long *)0x0) {
      lStack_18 = 0;
      for (lStack_10 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0); lStack_10 != 0;
          lStack_10 = _libssh2_list_next(lStack_10)) {
        if (((**(char **)(lStack_10 + 0x18) == '^') || (**(char **)(lStack_10 + 0x18) == '_')) &&
           (iVar1 = _libssh2_ntohu32(*(long *)(lStack_10 + 0x18) + 1),
           iVar1 == *(int *)(param_1 + 0x30))) {
          lStack_18 = lStack_18 + (*(long *)(lStack_10 + 0x20) - *(long *)(lStack_10 + 0x28));
        }
      }
      *param_2 = lStack_18;
    }
    uVar2 = *(undefined4 *)(param_1 + 0x4c);
  }
  return uVar2;
}



void _libssh2_store_u32(void)

{
  _libssh2_store_u32();
  return;
}



void _libssh2_ed25519_new_private_frommemory
               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
               undefined8 param_5)

{
  read_openssh_private_key_from_memory(param_1,param_2,"ssh-ed25519",param_3,param_4,param_5);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void DSA_SIG_free(DSA_SIG *a)

{
  DSA_SIG_free(a);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx)

{
  int iVar1;
  
  iVar1 = EVP_PKEY_derive_init(ctx);
  return iVar1;
}



int libssh2_keepalive_send(long param_1,int *param_2)

{
  int iVar1;
  time_t tVar2;
  long in_FS_OFFSET;
  undefined8 uStack_38;
  undefined8 uStack_30;
  undefined8 uStack_28;
  undefined4 uStack_20;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd630) == 0) {
    if (param_2 != (int *)0x0) {
      *param_2 = 0;
    }
    iVar1 = 0;
  }
  else {
    tVar2 = time((time_t *)0x0);
    if (tVar2 < (long)*(int *)(param_1 + 0xd630) + *(long *)(param_1 + 0xd638)) {
      if (param_2 != (int *)0x0) {
        *param_2 = ((int)*(undefined8 *)(param_1 + 0xd638) - (int)tVar2) +
                   *(int *)(param_1 + 0xd630);
      }
    }
    else {
      uStack_38 = 0x65656b1500000050;
      uStack_30 = 0x6c406576696c6170;
      uStack_28 = 0x6f2e326873736269;
      uStack_20 = 0x576772;
      iVar1 = _libssh2_transport_send(param_1,&uStack_38,0x1b,0,0);
      if ((iVar1 != 0) && (iVar1 != -0x25)) {
        _libssh2_error(param_1,0xfffffff9,"Unable to send keepalive message");
        goto LAB_0011a7ad;
      }
      *(time_t *)(param_1 + 0xd638) = tVar2;
      if (param_2 != (int *)0x0) {
        *param_2 = *(int *)(param_1 + 0xd630);
      }
    }
    iVar1 = 0;
  }
LAB_0011a7ad:
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * calloc(size_t __nmemb,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = calloc(__nmemb,__size);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EC_KEY_generate_key(EC_KEY *key)

{
  int iVar1;
  
  iVar1 = EC_KEY_generate_key(key);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a)

{
  EVP_CIPHER_CTX_free(a);
  return;
}



undefined4 _libssh2_channel_extended_data(long param_1,int param_2)

{
  int iVar1;
  
  if (*(int *)(param_1 + 0x2a8) == 0) {
    *(char *)(param_1 + 0x56) = (char)param_2;
    *(undefined4 *)(param_1 + 0x2a8) = 2;
  }
  if (((*(int *)(param_1 + 0x2a8) == 0) && (param_2 == 1)) &&
     (iVar1 = _libssh2_channel_flush(param_1,0xffffffff), iVar1 == -0x25)) {
    return 0xffffffdb;
  }
  *(undefined4 *)(param_1 + 0x2a8) = 0;
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ECDSA_SIG * ECDSA_SIG_new(void)

{
  ECDSA_SIG *pEVar1;
  
  pEVar1 = ECDSA_SIG_new();
  return pEVar1;
}



void _libssh2_base64_encode(void)

{
  _libssh2_base64_encode();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EC_KEY_set_private_key(EC_KEY *key,BIGNUM *prv)

{
  int iVar1;
  
  iVar1 = EC_KEY_set_private_key(key,prv);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

longlong strtoll(char *__nptr,char **__endptr,int __base)

{
  longlong lVar1;
  
  lVar1 = strtoll(__nptr,__endptr,__base);
  return lVar1;
}



undefined8 libssh2_init(uint param_1)

{
  if ((_libssh2_initialized == 0) && ((param_1 & 1) == 0)) {
    _libssh2_openssl_crypto_init();
  }
  _libssh2_initialized = _libssh2_initialized + 1;
  _libssh2_init_flags = _libssh2_init_flags | param_1;
  return 0;
}



void _libssh2_openssl_crypto_exit(void)

{
  return;
}



void _libssh2_string_buf_new(void)

{
  _libssh2_string_buf_new();
  return;
}



void libssh2_session_last_errno(void)

{
  libssh2_session_last_errno();
  return;
}



void _libssh2_packet_ask(void)

{
  _libssh2_packet_ask();
  return;
}



undefined8
_libssh2_dsa_new(undefined8 *param_1,uchar *param_2,int param_3,uchar *param_4,int param_5,
                uchar *param_6,int param_7,uchar *param_8,int param_9,uchar *param_10,long param_11)

{
  BIGNUM *ret;
  BIGNUM *ret_00;
  BIGNUM *ret_01;
  BIGNUM *ret_02;
  DSA *pDVar1;
  BIGNUM *pBStack_30;
  
  pBStack_30 = (BIGNUM *)0x0;
  ret = BN_new();
  BN_bin2bn(param_2,param_3,ret);
  ret_00 = BN_new();
  BN_bin2bn(param_4,param_5,ret_00);
  ret_01 = BN_new();
  BN_bin2bn(param_6,param_7,ret_01);
  ret_02 = BN_new();
  BN_bin2bn(param_8,param_9,ret_02);
  if (param_11 != 0) {
    pBStack_30 = BN_new();
    BN_bin2bn(param_10,(int)param_11,pBStack_30);
  }
  pDVar1 = DSA_new();
  *param_1 = pDVar1;
  DSA_set0_pqg(*param_1,ret,ret_00,ret_01);
  DSA_set0_key(*param_1,ret_02,pBStack_30);
  return 0;
}



undefined1 * libssh2_hostkey_methods(void)

{
  return hostkey_methods;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int feof(FILE *__stream)

{
  int iVar1;
  
  iVar1 = feof(__stream);
  return iVar1;
}



void DSA_set0_pqg(void)

{
  DSA_set0_pqg();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ECDSA_SIG * ECDSA_do_sign(uchar *dgst,int dgst_len,EC_KEY *eckey)

{
  ECDSA_SIG *pEVar1;
  
  pEVar1 = ECDSA_do_sign(dgst,dgst_len,eckey);
  return pEVar1;
}



undefined8
_libssh2_channel_receive_window_adjust(long param_1,int param_2,char param_3,undefined4 *param_4)

{
  int iVar1;
  undefined8 uVar2;
  int iStack_24;
  
  if (param_4 != (undefined4 *)0x0) {
    *param_4 = *(undefined4 *)(param_1 + 0x4c);
  }
  iStack_24 = param_2;
  if (*(int *)(param_1 + 0x250) == 0) {
    if ((param_3 == '\0') && ((uint)(param_2 + *(int *)(param_1 + 0x58)) < 0x400)) {
      *(int *)(param_1 + 0x58) = *(int *)(param_1 + 0x58) + param_2;
      return 0;
    }
    if ((param_2 == 0) && (*(int *)(param_1 + 0x58) == 0)) {
      return 0;
    }
    iStack_24 = param_2 + *(int *)(param_1 + 0x58);
    *(undefined4 *)(param_1 + 0x58) = 0;
    *(undefined *)(param_1 + 0x254) = 0x5d;
    _libssh2_htonu32(param_1 + 0x255,*(undefined4 *)(param_1 + 0x44));
    _libssh2_htonu32(param_1 + 0x259,iStack_24);
    *(undefined4 *)(param_1 + 0x250) = 2;
  }
  iVar1 = _libssh2_transport_send(*(undefined8 *)(param_1 + 0x60),param_1 + 0x254,9,0,0);
  if (iVar1 == -0x25) {
    _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xffffffdb,"Would block sending window adjust");
    uVar2 = 0xffffffdb;
  }
  else if (iVar1 == 0) {
    *(int *)(param_1 + 0x4c) = *(int *)(param_1 + 0x4c) + iStack_24;
    *(undefined4 *)(param_1 + 0x250) = 0;
    uVar2 = 0;
  }
  else {
    *(int *)(param_1 + 0x58) = iStack_24;
    uVar2 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xfffffff9,
                           "Unable to send transfer-window adjustment packet, deferring");
  }
  return uVar2;
}



void _libssh2_store_str(void)

{
  _libssh2_store_str();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int DSA_do_verify(uchar *dgst,int dgst_len,DSA_SIG *sig,DSA *dsa)

{
  int iVar1;
  
  iVar1 = DSA_do_verify(dgst,dgst_len,sig,dsa);
  return iVar1;
}



undefined8
_libssh2_dsa_sha1_verify(DSA *param_1,uchar *param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  BIGNUM *ret;
  BIGNUM *ret_00;
  DSA_SIG *sig;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int iStack_44;
  uchar auStack_28 [24];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_44 = -1;
  ret = BN_new();
  BN_bin2bn(param_2,0x14,ret);
  ret_00 = BN_new();
  BN_bin2bn(param_2 + 0x14,0x14,ret_00);
  sig = DSA_SIG_new();
  DSA_SIG_set0(sig,ret,ret_00);
  iVar1 = _libssh2_sha1(param_3,param_4,auStack_28);
  if (iVar1 == 0) {
    iStack_44 = DSA_do_verify(auStack_28,0x14,sig,param_1);
  }
  DSA_SIG_free(sig);
  if (iStack_44 == 1) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,__endptr,__base);
  return lVar1;
}



undefined8
_libssh2_dh_key_pair
          (undefined8 *param_1,BIGNUM *param_2,BIGNUM *param_3,BIGNUM *param_4,int param_5,
          BN_CTX *param_6)

{
  BN_rand((BIGNUM *)*param_1,param_5 * 8 + -1,0,-1);
  BN_mod_exp(param_2,param_3,(BIGNUM *)*param_1,param_4,param_6);
  return 0;
}



void Blowfish_encipher(long param_1,uint *param_2,uint *param_3)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  
  uVar1 = *param_2 ^ *(uint *)(param_1 + 0x1000);
  uVar2 = *param_3 ^
          *(uint *)(param_1 + 0x1004) ^
          (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
           *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
          *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
          *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1008) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x100c) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1010) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1014) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1018) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x101c) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1020) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1024) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1028) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x102c) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1030) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1034) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1038) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x103c) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  iVar3 = *(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4);
  iVar4 = *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4);
  uVar5 = *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4);
  iVar6 = *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar7 = *(uint *)(param_1 + 0x1040);
  *param_2 = *(uint *)(param_1 + 0x1044) ^ uVar2;
  *param_3 = uVar1 ^ uVar7 ^ (iVar3 + iVar4 ^ uVar5) + iVar6;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ENGINE_register_all_complete(void)

{
  int iVar1;
  
  iVar1 = ENGINE_register_all_complete();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EVP_PKEY_CTX * EVP_PKEY_CTX_new_id(int id,ENGINE *e)

{
  EVP_PKEY_CTX *pEVar1;
  
  pEVar1 = EVP_PKEY_CTX_new_id(id,e);
  return pEVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int BN_mod_exp(BIGNUM *r,BIGNUM *a,BIGNUM *p,BIGNUM *m,BN_CTX *ctx)

{
  int iVar1;
  
  iVar1 = BN_mod_exp(r,a,p,m,ctx);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_PKEY_derive(EVP_PKEY_CTX *ctx,uchar *key,size_t *keylen)

{
  int iVar1;
  
  iVar1 = EVP_PKEY_derive(ctx,key,keylen);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

BN_CTX * BN_CTX_new(void)

{
  BN_CTX *pBVar1;
  
  pBVar1 = BN_CTX_new();
  return pBVar1;
}



ulong _libssh2_pub_priv_keyfilememory
                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                undefined8 param_5,void *param_6,undefined8 param_7,void *param_8)

{
  int iVar1;
  BIO *bp;
  EVP_PKEY *pkey;
  ulong uVar2;
  uint uStack_20;
  
  bp = BIO_new_mem_buf(param_6,(int)param_7);
  if (bp == (BIO *)0x0) {
    return 0xffffffff;
  }
  BIO_ctrl(bp,1,0,(void *)0x0);
  pkey = PEM_read_bio_PrivateKey(bp,(EVP_PKEY **)0x0,(undefined1 *)0x0,param_8);
  BIO_free(bp);
  if (pkey == (EVP_PKEY *)0x0) {
    iVar1 = _libssh2_pub_priv_openssh_keyfilememory
                      (param_1,0,0,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
    if (iVar1 != 0) {
      uVar2 = _libssh2_error(param_1,0xfffffff0,
                             "Unable to extract public key from private key file: Wrong passphrase or invalid/unrecognized private key file format"
                            );
      return uVar2;
    }
    return 0;
  }
  iVar1 = EVP_PKEY_id(pkey);
  if (iVar1 == 0x198) {
    uStack_20 = gen_publickey_from_ec_evp(param_1,param_2,param_3,param_4,param_5,pkey);
    goto LAB_00110615;
  }
  if (iVar1 < 0x199) {
    if (iVar1 == 6) {
      uStack_20 = gen_publickey_from_rsa_evp(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_00110615;
    }
    if (iVar1 == 0x74) {
      uStack_20 = gen_publickey_from_dsa_evp(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_00110615;
    }
  }
  uStack_20 = _libssh2_error(param_1,0xfffffff0,
                             "Unable to extract public key from private key file: Unsupported private key file format"
                            );
LAB_00110615:
  EVP_PKEY_free(pkey);
  return (ulong)uStack_20;
}



void _libssh2_wait_socket(void)

{
  _libssh2_wait_socket();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

BIO * BIO_new_mem_buf(void *buf,int len)

{
  BIO *pBVar1;
  
  pBVar1 = BIO_new_mem_buf(buf,len);
  return pBVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_DigestUpdate(EVP_MD_CTX *ctx,void *d,size_t cnt)

{
  int iVar1;
  
  iVar1 = EVP_DigestUpdate(ctx,d,cnt);
  return iVar1;
}



void _libssh2_init_if_needed(void)

{
  if (_libssh2_initialized == 0) {
    libssh2_init(0);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t time(time_t *__timer)

{
  time_t tVar1;
  
  tVar1 = time(__timer);
  return tVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

X509_PUBKEY * X509_PUBKEY_new(void)

{
  X509_PUBKEY *pXVar1;
  
  pXVar1 = X509_PUBKEY_new();
  return pXVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EC_GROUP * EC_KEY_get0_group(EC_KEY *key)

{
  EC_GROUP *pEVar1;
  
  pEVar1 = EC_KEY_get0_group(key);
  return pEVar1;
}



void _libssh2_session_set_blocking(void)

{
  _libssh2_session_set_blocking();
  return;
}



undefined8
_libssh2_ed25519_new_public
          (undefined8 *param_1,undefined8 param_2,undefined8 param_3,undefined param_4)

{
  undefined8 uVar1;
  long lVar2;
  long *__ptr;
  
  if (param_1 == (undefined8 *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    lVar2 = EVP_PKEY_new_raw_public_key(0x43f,0,param_3,param_4);
    if (lVar2 == 0) {
      uVar1 = _libssh2_error(param_2,0xfffffff2,"could not create ED25519 public key");
    }
    else {
      __ptr = (long *)calloc(1,0x10);
      if (__ptr == (long *)0x0) {
        uVar1 = _libssh2_error(param_2,0xfffffffa,"could not alloc public/private key");
      }
      else {
        *__ptr = lVar2;
        if (param_1 == (undefined8 *)0x0) {
          if ((__ptr != (long *)0x0) && (__ptr != (long *)0x0)) {
            if (*__ptr != 0) {
              EVP_PKEY_free((EVP_PKEY *)*__ptr);
            }
            if (__ptr[1] != 0) {
              EVP_PKEY_free((EVP_PKEY *)__ptr[1]);
            }
            free(__ptr);
          }
        }
        else {
          *param_1 = __ptr;
        }
        uVar1 = 0;
      }
    }
  }
  return uVar1;
}



undefined8
bcrypt_pbkdf(void *param_1,size_t param_2,void *param_3,ulong param_4,long param_5,ulong param_6,
            uint param_7)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  ulong uStack_158;
  int iStack_11c;
  EVP_MD_CTX *pEStack_118;
  ulong uStack_110;
  ulong uStack_108;
  ulong uStack_100;
  ulong uStack_f8;
  void *pvStack_f0;
  ulong uStack_e8;
  ulong uStack_e0;
  undefined8 uStack_d8;
  undefined8 uStack_d0;
  undefined8 uStack_c8;
  undefined8 uStack_c0;
  undefined8 uStack_b8;
  undefined8 uStack_b0;
  undefined8 uStack_a8;
  undefined8 uStack_a0;
  uchar auStack_98 [64];
  uchar auStack_58 [72];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_f8 = param_6;
  if (param_7 == 0) {
    uVar1 = 0xffffffff;
  }
  else if ((((param_2 == 0) || (param_4 == 0)) || (param_6 == 0)) ||
          ((0x400 < param_6 || (0x100000 < param_4)))) {
    uVar1 = 0xffffffff;
  }
  else {
    pvStack_f0 = calloc(1,param_4 + 4);
    if (pvStack_f0 == (void *)0x0) {
      uVar1 = 0xffffffff;
    }
    else {
      uStack_e8 = param_6 + 0x1f >> 5;
      uStack_100 = ((uStack_e8 + param_6) - 1) / uStack_e8;
      memcpy(pvStack_f0,param_3,param_4);
      _libssh2_sha512_init(&pEStack_118);
      EVP_DigestUpdate(pEStack_118,param_1,param_2);
      EVP_DigestFinal(pEStack_118,auStack_98,(uint *)0x0);
      EVP_MD_CTX_free(pEStack_118);
      iStack_11c = 1;
      for (uStack_158 = param_6; uStack_158 != 0; uStack_158 = uStack_158 - uStack_110) {
        *(char *)(param_4 + (long)pvStack_f0) = (char)((uint)iStack_11c >> 0x18);
        *(char *)((long)pvStack_f0 + param_4 + 1) = (char)((uint)iStack_11c >> 0x10);
        *(char *)((long)pvStack_f0 + param_4 + 2) = (char)((uint)iStack_11c >> 8);
        *(char *)((long)pvStack_f0 + param_4 + 3) = (char)iStack_11c;
        _libssh2_sha512_init(&pEStack_118);
        EVP_DigestUpdate(pEStack_118,pvStack_f0,param_4 + 4);
        EVP_DigestFinal(pEStack_118,auStack_58,(uint *)0x0);
        EVP_MD_CTX_free(pEStack_118);
        bcrypt_hash(auStack_98,auStack_58,&uStack_b8);
        uStack_d8 = uStack_b8;
        uStack_d0 = uStack_b0;
        uStack_c8 = uStack_a8;
        uStack_c0 = uStack_a0;
        for (uStack_110 = 1; uStack_110 < param_7; uStack_110 = uStack_110 + 1) {
          _libssh2_sha512_init(&pEStack_118);
          EVP_DigestUpdate(pEStack_118,&uStack_b8,0x20);
          EVP_DigestFinal(pEStack_118,auStack_58,(uint *)0x0);
          EVP_MD_CTX_free(pEStack_118);
          bcrypt_hash(auStack_98,auStack_58,&uStack_b8);
          for (uStack_108 = 0; uStack_108 < 0x20; uStack_108 = uStack_108 + 1) {
            *(byte *)((long)&uStack_d8 + uStack_108) =
                 *(byte *)((long)&uStack_d8 + uStack_108) ^ *(byte *)((long)&uStack_b8 + uStack_108)
            ;
          }
        }
        if (uStack_158 <= uStack_100) {
          uStack_100 = uStack_158;
        }
        for (uStack_110 = 0;
            (uStack_110 < uStack_100 &&
            (uStack_e0 = uStack_110 * uStack_e8 + (ulong)(iStack_11c - 1), uStack_e0 < uStack_f8));
            uStack_110 = uStack_110 + 1) {
          *(undefined *)(param_5 + uStack_e0) = *(undefined *)((long)&uStack_d8 + uStack_110);
        }
        iStack_11c = iStack_11c + 1;
      }
      _libssh2_explicit_zero(&uStack_d8,0x20);
      free(pvStack_f0);
      uVar1 = 0;
    }
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void libssh2_sftp_seek64(void)

{
  libssh2_sftp_seek64();
  return;
}



undefined8 _libssh2_sha384(void *param_1,size_t param_2,uchar *param_3)

{
  int iVar1;
  EVP_MD_CTX *ctx;
  undefined8 uVar2;
  EVP_MD *type;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar2 = 1;
  }
  else {
    type = EVP_get_digestbyname("sha384");
    iVar1 = EVP_DigestInit(ctx,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(ctx);
      uVar2 = 1;
    }
    else {
      EVP_DigestUpdate(ctx,param_1,param_2);
      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
      EVP_MD_CTX_free(ctx);
      uVar2 = 0;
    }
  }
  return uVar2;
}



undefined8
_libssh2_ecdsa_new_private
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  undefined8 uVar2;
  
  _libssh2_init_if_needed();
  iVar1 = read_private_key_from_file(param_1,&PEM_read_bio_ECPrivateKey,param_3,param_4);
  if (iVar1 == 0) {
    uVar2 = 0;
  }
  else {
    uVar2 = _libssh2_ecdsa_new_openssh_private(param_1,param_2,param_3,param_4);
  }
  return uVar2;
}



void _libssh2_get_c_string(void)

{
  _libssh2_get_c_string();
  return;
}



long _libssh2_channel_locate(long param_1,int param_2)

{
  long lStack_18;
  long lStack_10;
  
  for (lStack_18 = _libssh2_list_first(param_1 + 0x200); lStack_18 != 0;
      lStack_18 = _libssh2_list_next(lStack_18)) {
    if (param_2 == *(int *)(lStack_18 + 0x30)) {
      return lStack_18;
    }
  }
  lStack_10 = _libssh2_list_first(param_1 + 0x218);
  do {
    if (lStack_10 == 0) {
      return 0;
    }
    for (lStack_18 = _libssh2_list_first(lStack_10 + 0x30); lStack_18 != 0;
        lStack_18 = _libssh2_list_next(lStack_18)) {
      if (param_2 == *(int *)(lStack_18 + 0x30)) {
        return lStack_18;
      }
    }
    lStack_10 = _libssh2_list_next(lStack_10);
  } while( true );
}



void _libssh2_transport_send(void)

{
  _libssh2_transport_send();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

rsa_st * EVP_PKEY_get1_RSA(EVP_PKEY *pkey)

{
  rsa_st *prVar1;
  
  prVar1 = EVP_PKEY_get1_RSA(pkey);
  return prVar1;
}



void _libssh2_list_remove(void)

{
  _libssh2_list_remove();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



void _libssh2_transport_read(void)

{
  _libssh2_transport_read();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EVP_MD * EVP_get_digestbyname(char *name)

{
  EVP_MD *pEVar1;
  
  pEVar1 = EVP_get_digestbyname(name);
  return pEVar1;
}



void ECDSA_SIG_get0(void)

{
  ECDSA_SIG_get0();
  return;
}



void _libssh2_ecdsa_key_get_curve_type(EC_KEY *param_1)

{
  EC_GROUP *group;
  
  group = EC_KEY_get0_group(param_1);
  EC_GROUP_get_curve_name(group);
  return;
}



void DSA_set0_key(void)

{
  DSA_set0_key();
  return;
}



void _libssh2_packet_add(void)

{
  _libssh2_packet_add();
  return;
}



void EVP_PKEY_new_raw_private_key(void)

{
  EVP_PKEY_new_raw_private_key();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int RSA_verify(int type,uchar *m,uint m_length,uchar *sigbuf,uint siglen,RSA *rsa)

{
  int iVar1;
  
  iVar1 = RSA_verify(type,m,m_length,sigbuf,siglen,rsa);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long BIO_ctrl(BIO *bp,int cmd,long larg,void *parg)

{
  long lVar1;
  
  lVar1 = BIO_ctrl(bp,cmd,larg,parg);
  return lVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int BIO_free(BIO *a)

{
  int iVar1;
  
  iVar1 = BIO_free(a);
  return iVar1;
}



void blf_enc(undefined8 param_1,long param_2,ushort param_3)

{
  ushort uStack_12;
  long lStack_10;
  
  lStack_10 = param_2;
  for (uStack_12 = 0; uStack_12 < param_3; uStack_12 = uStack_12 + 1) {
    Blowfish_encipher(param_1,lStack_10,lStack_10 + 4);
    lStack_10 = lStack_10 + 8;
  }
  return;
}



void Blowfish_expandstate
               (long param_1,undefined8 param_2,undefined2 param_3,undefined8 param_4,
               undefined2 param_5)

{
  uint uVar1;
  long in_FS_OFFSET;
  undefined2 uStack_22;
  ushort uStack_20;
  ushort uStack_1e;
  uint uStack_1c;
  uint uStack_18;
  uint uStack_14;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_22 = 0;
  for (uStack_20 = 0; uStack_20 < 0x12; uStack_20 = uStack_20 + 1) {
    uStack_14 = Blowfish_stream2word(param_4,param_5,&uStack_22);
    *(uint *)(param_1 + ((long)(int)(uint)uStack_20 + 0x400) * 4) =
         *(uint *)(param_1 + ((long)(int)(uint)uStack_20 + 0x400) * 4) ^ uStack_14;
  }
  uStack_22 = 0;
  uStack_1c = 0;
  uStack_18 = 0;
  for (uStack_20 = 0; uStack_20 < 0x12; uStack_20 = uStack_20 + 2) {
    uVar1 = Blowfish_stream2word(param_2,param_3,&uStack_22);
    uStack_1c = uVar1 ^ uStack_1c;
    uVar1 = Blowfish_stream2word(param_2,param_3,&uStack_22);
    uStack_18 = uVar1 ^ uStack_18;
    Blowfish_encipher(param_1,&uStack_1c,&uStack_18);
    *(uint *)(param_1 + ((long)(int)(uint)uStack_20 + 0x400) * 4) = uStack_1c;
    *(uint *)(param_1 + ((long)(int)(uStack_20 + 1) + 0x400) * 4) = uStack_18;
  }
  for (uStack_20 = 0; uStack_20 < 4; uStack_20 = uStack_20 + 1) {
    for (uStack_1e = 0; uStack_1e < 0x100; uStack_1e = uStack_1e + 2) {
      uVar1 = Blowfish_stream2word(param_2,param_3,&uStack_22);
      uStack_1c = uVar1 ^ uStack_1c;
      uVar1 = Blowfish_stream2word(param_2,param_3,&uStack_22);
      uStack_18 = uVar1 ^ uStack_18;
      Blowfish_encipher(param_1,&uStack_1c,&uStack_18);
      *(uint *)(param_1 + ((long)(int)(uint)uStack_1e + (long)(int)(uint)uStack_20 * 0x100) * 4) =
           uStack_1c;
      *(uint *)(param_1 + ((long)(int)(uStack_1e + 1) + (long)(int)(uint)uStack_20 * 0x100) * 4) =
           uStack_18;
    }
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void _libssh2_error(void)

{
  _libssh2_error();
  return;
}



void _libssh2_get_u32(void)

{
  _libssh2_get_u32();
  return;
}



undefined4 _libssh2_ecdh_gen_k(undefined8 *param_1,EC_KEY *param_2,uchar *param_3,size_t param_4)

{
  int iVar1;
  int iVar2;
  uint len;
  BN_CTX *ctx;
  EC_GROUP *group;
  EC_POINT *p;
  undefined4 uStack_38;
  uchar *puStack_30;
  
  uStack_38 = 0;
  puStack_30 = (uchar *)0x0;
  ctx = BN_CTX_new();
  if (ctx == (BN_CTX *)0x0) {
    uStack_38 = 0xffffffff;
  }
  else if (param_1 == (undefined8 *)0x0) {
    uStack_38 = 0xffffffff;
  }
  else {
    group = EC_KEY_get0_group(param_2);
    p = EC_POINT_new(group);
    if (p == (EC_POINT *)0x0) {
      uStack_38 = 0xffffffff;
    }
    else {
      iVar1 = EC_POINT_oct2point(group,p,param_3,param_4,ctx);
      if (iVar1 == 1) {
        iVar2 = EC_GROUP_get_degree(group);
        iVar1 = iVar2 + 7;
        if (iVar2 + 7 < 0) {
          iVar1 = iVar2 + 0xe;
        }
        puStack_30 = (uchar *)malloc((long)(iVar1 >> 3));
        if (puStack_30 == (uchar *)0x0) {
          uStack_38 = 0xffffffff;
        }
        else {
          len = ECDH_compute_key(puStack_30,(long)(iVar1 >> 3),p,param_2,(KDF *)0x0);
          if ((len == 0) || (0x85 < len)) {
            uStack_38 = 0xffffffff;
          }
          else {
            BN_bin2bn(puStack_30,len,(BIGNUM *)*param_1);
          }
        }
      }
      else {
        uStack_38 = 0xffffffff;
      }
      if (p != (EC_POINT *)0x0) {
        EC_POINT_free(p);
      }
      if (ctx != (BN_CTX *)0x0) {
        BN_CTX_free(ctx);
      }
      if (puStack_30 != (uchar *)0x0) {
        free(puStack_30);
      }
    }
  }
  return uStack_38;
}



undefined8 _libssh2_md5_init(long *param_1)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  lVar2 = EVP_MD_CTX_new();
  *param_1 = lVar2;
  if (*param_1 == 0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("md5");
    iVar1 = EVP_DigestInit((EVP_MD_CTX *)*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = 0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



void DSA_get0_key(void)

{
  DSA_get0_key();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EVP_MD * EVP_ripemd160(void)

{
  EVP_MD *pEVar1;
  
  pEVar1 = EVP_ripemd160();
  return pEVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_PKEY_set1_DSA(EVP_PKEY *pkey,dsa_st *key)

{
  int iVar1;
  
  iVar1 = EVP_PKEY_set1_DSA(pkey,key);
  return iVar1;
}



void _libssh2_openssh_pem_parse(void)

{
  _libssh2_openssh_pem_parse();
  return;
}



void RSA_get0_key(void)

{
  RSA_get0_key();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int BN_bn2bin(BIGNUM *a,uchar *to)

{
  int iVar1;
  
  iVar1 = BN_bn2bin(a,to);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

RSA * RSA_new(void)

{
  RSA *pRVar1;
  
  pRVar1 = RSA_new();
  return pRVar1;
}



void _libssh2_packet_requirev(void)

{
  _libssh2_packet_requirev();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EVP_PKEY * EVP_PKEY_new(void)

{
  EVP_PKEY *pEVar1;
  
  pEVar1 = EVP_PKEY_new();
  return pEVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t EC_POINT_point2oct(EC_GROUP *group,EC_POINT *p,point_conversion_form_t form,uchar *buf,
                         size_t len,BN_CTX *ctx)

{
  size_t sVar1;
  
  sVar1 = EC_POINT_point2oct(group,p,form,buf,len,ctx);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * realloc(void *__ptr,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = realloc(__ptr,__size);
  return pvVar1;
}



void EVP_MD_CTX_new(void)

{
  EVP_MD_CTX_new();
  return;
}



void RSA_get0_factors(void)

{
  RSA_get0_factors();
  return;
}



void _libssh2_error_flags(void)

{
  _libssh2_error_flags();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EC_GROUP_get_curve_name(EC_GROUP *group)

{
  int iVar1;
  
  iVar1 = EC_GROUP_get_curve_name(group);
  return iVar1;
}



void Blowfish_initstate(undefined8 *param_1)

{
  ulong uVar1;
  long lVar2;
  undefined8 *puVar3;
  undefined8 *puVar4;
  
  *param_1 = 0x98dfb5acd1310ba6;
  param_1[0x208] = 0x8979fb1b9216d5d9;
  lVar2 = (long)param_1 - (long)((ulong)(param_1 + 1) & 0xfffffffffffffff8);
  puVar3 = (undefined8 *)((long)&initstate_3017 - lVar2);
  puVar4 = (undefined8 *)((ulong)(param_1 + 1) & 0xfffffffffffffff8);
  for (uVar1 = (ulong)((int)lVar2 + 0x1048U >> 3); uVar1 != 0; uVar1 = uVar1 - 1) {
    *puVar4 = *puVar3;
    puVar3 = puVar3 + 1;
    puVar4 = puVar4 + 1;
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_DigestFinal(EVP_MD_CTX *ctx,uchar *md,uint *s)

{
  int iVar1;
  
  iVar1 = EVP_DigestFinal(ctx,md,s);
  return iVar1;
}



undefined8 _libssh2_sha256(void *param_1,size_t param_2,uchar *param_3)

{
  int iVar1;
  EVP_MD_CTX *ctx;
  undefined8 uVar2;
  EVP_MD *type;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar2 = 1;
  }
  else {
    type = EVP_get_digestbyname("sha256");
    iVar1 = EVP_DigestInit(ctx,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(ctx);
      uVar2 = 1;
    }
    else {
      EVP_DigestUpdate(ctx,param_1,param_2);
      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
      EVP_MD_CTX_free(ctx);
      uVar2 = 0;
    }
  }
  return uVar2;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int poll(pollfd *__fds,nfds_t __nfds,int __timeout)

{
  int iVar1;
  
  iVar1 = poll(__fds,__nfds,__timeout);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EVP_CIPHER_CTX * EVP_CIPHER_CTX_new(void)

{
  EVP_CIPHER_CTX *pEVar1;
  
  pEVar1 = EVP_CIPHER_CTX_new();
  return pEVar1;
}



undefined8 _libssh2_sha1_init(long *param_1)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  lVar2 = EVP_MD_CTX_new();
  *param_1 = lVar2;
  if (*param_1 == 0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("sha1");
    iVar1 = EVP_DigestInit((EVP_MD_CTX *)*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = 0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memmove(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memmove(__dest,__src,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void EC_KEY_free(EC_KEY *key)

{
  EC_KEY_free(key);
  return;
}



void ASN1_STRING_get0_data(void)

{
  ASN1_STRING_get0_data();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int HMAC_Final(HMAC_CTX *ctx,uchar *md,uint *len)

{
  int iVar1;
  
  iVar1 = HMAC_Final(ctx,md,len);
  return iVar1;
}



void HMAC_CTX_free(void)

{
  HMAC_CTX_free();
  return;
}



int _libssh2_rsa_new_private
              (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  int iStack_14;
  
  _libssh2_init_if_needed();
  iStack_14 = read_private_key_from_file(param_1,&PEM_read_bio_RSAPrivateKey,param_3,param_4);
  if (iStack_14 != 0) {
    iStack_14 = _libssh2_rsa_new_openssh_private(param_1,param_2,param_3,param_4);
  }
  return iStack_14;
}



void DSA_SIG_get0(void)

{
  DSA_SIG_get0();
  return;
}



undefined8
_libssh2_ecdsa_curve_name_with_octal_new
          (undefined8 *param_1,uchar *param_2,size_t param_3,int param_4)

{
  EC_KEY *key;
  EC_GROUP *group;
  EC_POINT *p;
  undefined8 uVar1;
  int iStack_24;
  
  iStack_24 = 0;
  key = EC_KEY_new_by_curve_name(param_4);
  if (key != (EC_KEY *)0x0) {
    group = EC_KEY_get0_group(key);
    p = EC_POINT_new(group);
    EC_POINT_oct2point(group,p,param_2,param_3,(BN_CTX *)0x0);
    iStack_24 = EC_KEY_set_public_key(key,p);
    if (p != (EC_POINT *)0x0) {
      EC_POINT_free(p);
    }
    if (param_1 != (undefined8 *)0x0) {
      *param_1 = key;
    }
  }
  if (iStack_24 == 1) {
    uVar1 = 0;
  }
  else {
    uVar1 = 0xffffffff;
  }
  return uVar1;
}



void _libssh2_packet_burn(void)

{
  _libssh2_packet_burn();
  return;
}



int _libssh2_ecdsa_new_openssh_private
              (undefined8 param_1,long param_2,char *param_3,undefined8 param_4)

{
  int iVar1;
  long in_FS_OFFSET;
  undefined4 uStack_30;
  int iStack_2c;
  long lStack_28;
  long lStack_20;
  FILE *pFStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  lStack_28 = 0;
  lStack_20 = 0;
  if (param_2 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    iVar1 = -1;
  }
  else {
    _libssh2_init_if_needed();
    pFStack_18 = fopen(param_3,"r");
    if (pFStack_18 == (FILE *)0x0) {
      _libssh2_error(param_2,0xfffffff0,"Unable to open OpenSSH ECDSA private key file");
      iVar1 = -1;
    }
    else {
      iStack_2c = _libssh2_openssh_pem_parse(param_2,param_4,pFStack_18,&lStack_20);
      fclose(pFStack_18);
      iVar1 = iStack_2c;
      if (iStack_2c == 0) {
        iStack_2c = _libssh2_get_c_string(lStack_20,&lStack_28);
        if ((iStack_2c < 1) || (lStack_28 == 0)) {
          _libssh2_error(param_2,0xfffffff2,"Public key type in decrypted key data not found");
          iVar1 = -1;
        }
        else {
          iStack_2c = _libssh2_ecdsa_curve_type_from_name(lStack_28,&uStack_30);
          if (iStack_2c == 0) {
            iStack_2c = gen_publickey_from_ecdsa_openssh_priv_data
                                  (param_2,uStack_30,lStack_20,0,0,0,0,param_1);
          }
          else {
            iStack_2c = -1;
          }
          iVar1 = iStack_2c;
          if (lStack_20 != 0) {
            _libssh2_string_buf_free(param_2,lStack_20);
            iVar1 = iStack_2c;
          }
        }
      }
    }
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * fopen(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen(__filename,__modes);
  return pFVar1;
}



undefined8
_libssh2_ed25519_verify
          (undefined8 *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
          undefined8 param_5)

{
  EVP_MD_CTX *ctx;
  undefined8 uVar1;
  int iStack_14;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    iStack_14 = EVP_DigestVerifyInit
                          (ctx,(EVP_PKEY_CTX **)0x0,(EVP_MD *)0x0,(ENGINE *)0x0,(EVP_PKEY *)*param_1
                          );
    if (iStack_14 == 1) {
      iStack_14 = EVP_DigestVerify(ctx,param_2,param_3,param_4,param_5);
    }
    EVP_MD_CTX_free(ctx);
    if (iStack_14 == 1) {
      uVar1 = 0;
    }
    else {
      uVar1 = 0xffffffff;
    }
  }
  return uVar1;
}



void RSA_set0_factors(void)

{
  RSA_set0_factors();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int HMAC_Init_ex(HMAC_CTX *ctx,void *key,int len,EVP_MD *md,ENGINE *impl)

{
  int iVar1;
  
  iVar1 = HMAC_Init_ex(ctx,key,len,md,impl);
  return iVar1;
}



undefined8 _libssh2_sha512_init(long *param_1)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  lVar2 = EVP_MD_CTX_new();
  *param_1 = lVar2;
  if (*param_1 == 0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("sha512");
    iVar1 = EVP_DigestInit((EVP_MD_CTX *)*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = 0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



void libssh2_publickey_list_free(void)

{
  libssh2_publickey_list_free();
  return;
}



undefined4 _libssh2_channel_free(long param_1)

{
  int iVar1;
  undefined4 uVar2;
  long in_FS_OFFSET;
  undefined8 uStack_30;
  undefined auStack_28 [8];
  long lStack_20;
  undefined auStack_14 [4];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  lStack_20 = *(long *)(param_1 + 0x60);
  if (lStack_20 == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("session",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-3857_Libssh2/Libssh2/src/channel.c"
                  ,0x9b5,"_libssh2_channel_free");
  }
  if (*(int *)(param_1 + 0x2a4) == 0) {
    *(undefined4 *)(param_1 + 0x2a4) = 2;
  }
  if (((*(char *)(param_1 + 0x40) == '\0') && (*(int *)(lStack_20 + 0x22c) == 0)) &&
     (iVar1 = _libssh2_channel_close(param_1), iVar1 == -0x25)) {
    uVar2 = 0xffffffdb;
  }
  else {
    *(undefined4 *)(param_1 + 0x2a4) = 0;
    if (*(long *)(param_1 + 0x28) != 0) {
      (**(code **)(lStack_20 + 0x18))(*(undefined8 *)(param_1 + 0x28),lStack_20);
    }
    _libssh2_htonu32(auStack_14,*(undefined4 *)(param_1 + 0x30));
    while ((iVar1 = _libssh2_packet_ask(lStack_20,0x5e,&uStack_30,auStack_28,1,auStack_14,4),
           -1 < iVar1 ||
           (iVar1 = _libssh2_packet_ask(lStack_20,0x5f,&uStack_30,auStack_28,1,auStack_14,4),
           -1 < iVar1))) {
      (**(code **)(lStack_20 + 0x18))(uStack_30,lStack_20);
    }
    if (*(long *)(param_1 + 0x18) != 0) {
      (**(code **)(lStack_20 + 0x18))(*(undefined8 *)(param_1 + 0x18),lStack_20);
    }
    _libssh2_list_remove(param_1);
    if (*(long *)(param_1 + 0x80) != 0) {
      (**(code **)(lStack_20 + 0x18))(*(undefined8 *)(param_1 + 0x80),lStack_20);
    }
    if (*(long *)(param_1 + 0x1f0) != 0) {
      (**(code **)(lStack_20 + 0x18))(*(undefined8 *)(param_1 + 0x1f0),lStack_20);
    }
    if (*(long *)(param_1 + 0x218) != 0) {
      (**(code **)(lStack_20 + 0x18))(*(undefined8 *)(param_1 + 0x218),lStack_20);
    }
    (**(code **)(lStack_20 + 0x18))(param_1,lStack_20);
    uVar2 = 0;
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 _libssh2_dsa_sha1_sign(DSA *param_1,uchar *param_2,undefined8 param_3,void *param_4)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  BIGNUM *pBStack_28;
  BIGNUM *pBStack_20;
  DSA_SIG *pDStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  pDStack_18 = DSA_do_sign(param_2,0x14,param_1);
  if (pDStack_18 == (DSA_SIG *)0x0) {
    uVar4 = 0xffffffff;
  }
  else {
    DSA_SIG_get0(pDStack_18,&pBStack_28,&pBStack_20);
    iVar1 = BN_num_bits(pBStack_28);
    iVar2 = iVar1 + 7;
    if (iVar1 + 7 < 0) {
      iVar2 = iVar1 + 0xe;
    }
    iVar2 = iVar2 >> 3;
    if ((iVar2 < 1) || (0x14 < iVar2)) {
      DSA_SIG_free(pDStack_18);
      uVar4 = 0xffffffff;
    }
    else {
      iVar3 = BN_num_bits(pBStack_20);
      iVar1 = iVar3 + 7;
      if (iVar3 + 7 < 0) {
        iVar1 = iVar3 + 0xe;
      }
      iVar1 = iVar1 >> 3;
      if ((iVar1 < 1) || (0x14 < iVar1)) {
        DSA_SIG_free(pDStack_18);
        uVar4 = 0xffffffff;
      }
      else {
        memset(param_4,0,0x28);
        BN_bn2bin(pBStack_28,(uchar *)((long)(0x14 - iVar2) + (long)param_4));
        BN_bn2bin(pBStack_20,(uchar *)((long)(0x14 - iVar1) + 0x14 + (long)param_4));
        DSA_SIG_free(pDStack_18);
        uVar4 = 0;
      }
    }
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 _libssh2_curve25519_gen_k(long *param_1,undefined8 param_2,undefined8 param_3)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int iStack_64;
  size_t sStack_60;
  EVP_PKEY_CTX *pEStack_58;
  EVP_PKEY *pEStack_50;
  EVP_PKEY *pEStack_48;
  BN_CTX *pBStack_40;
  uchar auStack_38 [40];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_64 = -1;
  pEStack_50 = (EVP_PKEY *)0x0;
  pEStack_48 = (EVP_PKEY *)0x0;
  pEStack_58 = (EVP_PKEY_CTX *)0x0;
  pBStack_40 = (BN_CTX *)0x0;
  sStack_60 = 0;
  if ((param_1 == (long *)0x0) || (*param_1 == 0)) {
    uVar2 = 0xffffffff;
  }
  else {
    pBStack_40 = BN_CTX_new();
    if (pBStack_40 == (BN_CTX *)0x0) {
      uVar2 = 0xffffffff;
    }
    else {
      pEStack_50 = (EVP_PKEY *)EVP_PKEY_new_raw_public_key(0x40a,0,param_3,0x20);
      pEStack_48 = (EVP_PKEY *)EVP_PKEY_new_raw_private_key(0x40a,0,param_2,0x20);
      if (((((pEStack_50 != (EVP_PKEY *)0x0) && (pEStack_48 != (EVP_PKEY *)0x0)) &&
           (pEStack_58 = EVP_PKEY_CTX_new(pEStack_48,(ENGINE *)0x0),
           pEStack_58 != (EVP_PKEY_CTX *)0x0)) &&
          ((iStack_64 = EVP_PKEY_derive_init(pEStack_58), 0 < iStack_64 &&
           (iStack_64 = EVP_PKEY_derive_set_peer(pEStack_58,pEStack_50), 0 < iStack_64)))) &&
         (iStack_64 = EVP_PKEY_derive(pEStack_58,(uchar *)0x0,&sStack_60), 0 < iStack_64)) {
        if (sStack_60 == 0x20) {
          iVar1 = EVP_PKEY_derive(pEStack_58,auStack_38,&sStack_60);
          if ((iVar1 == 1) && (sStack_60 == 0x20)) {
            BN_bin2bn(auStack_38,0x20,(BIGNUM *)*param_1);
            iStack_64 = 1;
          }
          else {
            iStack_64 = -1;
          }
        }
        else {
          iStack_64 = -1;
        }
      }
      if (pEStack_58 != (EVP_PKEY_CTX *)0x0) {
        EVP_PKEY_CTX_free(pEStack_58);
      }
      if (pEStack_50 != (EVP_PKEY *)0x0) {
        EVP_PKEY_free(pEStack_50);
      }
      if (pEStack_48 != (EVP_PKEY *)0x0) {
        EVP_PKEY_free(pEStack_48);
      }
      if (pBStack_40 != (BN_CTX *)0x0) {
        BN_CTX_free(pBStack_40);
      }
      if (iStack_64 == 1) {
        uVar2 = 0;
      }
      else {
        uVar2 = 0xffffffff;
      }
    }
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx)

{
  int iVar1;
  
  iVar1 = EVP_PKEY_keygen_init(ctx);
  return iVar1;
}



ulong gen_publickey_from_dsa_openssh_priv_data
                (undefined8 param_1,undefined8 param_2,long param_3,undefined8 param_4,long param_5,
                undefined8 param_6,undefined8 *param_7)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  ulong uVar6;
  long in_FS_OFFSET;
  uint uStack_70;
  undefined8 uStack_58;
  undefined8 uStack_50;
  undefined8 uStack_48;
  undefined8 uStack_40;
  undefined8 uStack_38;
  dsa_st *pdStack_30;
  EVP_PKEY *pEStack_28;
  long lStack_20;
  
  lStack_20 = *(long *)(in_FS_OFFSET + 0x28);
  pdStack_30 = (dsa_st *)0x0;
  iVar1 = _libssh2_get_bignum_bytes(param_2,&uStack_58);
  if (iVar1 < 1) {
    _libssh2_error(param_1,0xfffffff2,"DSA no p");
    uVar6 = 0xffffffff;
  }
  else {
    iVar2 = _libssh2_get_bignum_bytes(param_2,&uStack_50);
    if (iVar2 < 1) {
      _libssh2_error(param_1,0xfffffff2,"DSA no q");
      uVar6 = 0xffffffff;
    }
    else {
      iVar3 = _libssh2_get_bignum_bytes(param_2,&uStack_48);
      if (iVar3 < 1) {
        _libssh2_error(param_1,0xfffffff2,"DSA no g");
        uVar6 = 0xffffffff;
      }
      else {
        iVar4 = _libssh2_get_bignum_bytes(param_2,&uStack_40);
        if (iVar4 < 1) {
          _libssh2_error(param_1,0xfffffff2,"DSA no public key");
          uVar6 = 0xffffffff;
        }
        else {
          iVar5 = _libssh2_get_bignum_bytes(param_2,&uStack_38);
          if (iVar5 < 1) {
            _libssh2_error(param_1,0xfffffff2,"DSA no private key");
            uVar6 = 0xffffffff;
          }
          else {
            iVar1 = _libssh2_dsa_new(&pdStack_30,uStack_58,(long)iVar1,uStack_50,(long)iVar2,
                                     uStack_48,(long)iVar3,uStack_40,(long)iVar4,uStack_38,
                                     (long)iVar5);
            if (iVar1 == 0) {
              uStack_70 = 0;
              if (((pdStack_30 != (dsa_st *)0x0) && (param_5 != 0)) && (param_3 != 0)) {
                pEStack_28 = EVP_PKEY_new();
                EVP_PKEY_set1_DSA(pEStack_28,pdStack_30);
                uStack_70 = gen_publickey_from_dsa_evp
                                      (param_1,param_3,param_4,param_5,param_6,pEStack_28);
                if (pEStack_28 != (EVP_PKEY *)0x0) {
                  EVP_PKEY_free(pEStack_28);
                }
              }
              if (param_7 == (undefined8 *)0x0) {
                DSA_free(pdStack_30);
              }
              else {
                *param_7 = pdStack_30;
              }
              uVar6 = (ulong)uStack_70;
            }
            else {
              if (pdStack_30 != (dsa_st *)0x0) {
                DSA_free(pdStack_30);
              }
              uVar6 = _libssh2_error(param_1,0xfffffffa,
                                     "Unable to allocate memory for private key data");
            }
          }
        }
      }
    }
  }
  if (lStack_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int RSA_sign(int type,uchar *m,uint m_length,uchar *sigret,uint *siglen,RSA *rsa)

{
  int iVar1;
  
  iVar1 = RSA_sign(type,m,m_length,sigret,siglen,rsa);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EC_GROUP_get_degree(EC_GROUP *group)

{
  int iVar1;
  
  iVar1 = EC_GROUP_get_degree(group);
  return iVar1;
}



void _libssh2_get_bignum_bytes(void)

{
  _libssh2_get_bignum_bytes();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void X509_PUBKEY_free(X509_PUBKEY *a)

{
  X509_PUBKEY_free(a);
  return;
}



undefined8
_libssh2_rsa_new(undefined8 *param_1,uchar *param_2,int param_3,uchar *param_4,int param_5,
                uchar *param_6,int param_7,uchar *param_8,int param_9,uchar *param_10,int param_11,
                uchar *param_12,int param_13,uchar *param_14,int param_15,uchar *param_16,
                int param_17)

{
  BIGNUM *ret;
  BIGNUM *ret_00;
  RSA *pRVar1;
  BIGNUM *pBStack_48;
  BIGNUM *pBStack_40;
  BIGNUM *pBStack_38;
  BIGNUM *pBStack_30;
  BIGNUM *pBStack_28;
  BIGNUM *pBStack_20;
  
  pBStack_48 = (BIGNUM *)0x0;
  pBStack_40 = (BIGNUM *)0x0;
  pBStack_38 = (BIGNUM *)0x0;
  pBStack_30 = (BIGNUM *)0x0;
  pBStack_28 = (BIGNUM *)0x0;
  pBStack_20 = (BIGNUM *)0x0;
  ret = BN_new();
  BN_bin2bn(param_2,param_3,ret);
  ret_00 = BN_new();
  BN_bin2bn(param_4,param_5,ret_00);
  if (param_6 != (uchar *)0x0) {
    pBStack_48 = BN_new();
    BN_bin2bn(param_6,param_7,pBStack_48);
    pBStack_40 = BN_new();
    BN_bin2bn(param_8,param_9,pBStack_40);
    pBStack_38 = BN_new();
    BN_bin2bn(param_10,param_11,pBStack_38);
    pBStack_30 = BN_new();
    BN_bin2bn(param_12,param_13,pBStack_30);
    pBStack_28 = BN_new();
    BN_bin2bn(param_14,param_15,pBStack_28);
    pBStack_20 = BN_new();
    BN_bin2bn(param_16,param_17,pBStack_20);
  }
  pRVar1 = RSA_new();
  *param_1 = pRVar1;
  RSA_set0_key(*param_1,ret_00,ret,pBStack_48);
  RSA_set0_factors(*param_1,pBStack_40,pBStack_38);
  RSA_set0_crt_params(*param_1,pBStack_30,pBStack_28,pBStack_20);
  return 0;
}



undefined1 * libssh2_crypt_methods(void)

{
  return _libssh2_crypt_methods;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *a)

{
  PKCS8_PRIV_KEY_INFO_free(a);
  return;
}



ulong gen_publickey_from_rsa_openssh_priv_data
                (undefined8 param_1,undefined8 param_2,long param_3,undefined8 param_4,long param_5,
                undefined8 param_6,undefined8 *param_7)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  ulong uVar8;
  long in_FS_OFFSET;
  uint uStack_98;
  undefined8 uStack_78;
  undefined8 uStack_70;
  undefined8 uStack_68;
  undefined8 uStack_60;
  undefined8 uStack_58;
  undefined8 uStack_50;
  undefined auStack_48 [8];
  rsa_st *prStack_40;
  EVP_PKEY *pEStack_38;
  long lStack_30;
  
  lStack_30 = *(long *)(in_FS_OFFSET + 0x28);
  prStack_40 = (rsa_st *)0x0;
  iVar1 = _libssh2_get_bignum_bytes(param_2,&uStack_78);
  if (iVar1 < 1) {
    _libssh2_error(param_1,0xfffffff2,"RSA no n");
    uVar8 = 0xffffffff;
  }
  else {
    iVar2 = _libssh2_get_bignum_bytes(param_2,&uStack_70);
    if (iVar2 < 1) {
      _libssh2_error(param_1,0xfffffff2,"RSA no e");
      uVar8 = 0xffffffff;
    }
    else {
      iVar3 = _libssh2_get_bignum_bytes(param_2,&uStack_68);
      if (iVar3 < 1) {
        _libssh2_error(param_1,0xfffffff2,"RSA no d");
        uVar8 = 0xffffffff;
      }
      else {
        iVar4 = _libssh2_get_bignum_bytes(param_2,&uStack_50);
        if (iVar4 < 1) {
          _libssh2_error(param_1,0xfffffff2,"RSA no coeff");
          uVar8 = 0xffffffff;
        }
        else {
          iVar5 = _libssh2_get_bignum_bytes(param_2,&uStack_60);
          if (iVar5 < 1) {
            _libssh2_error(param_1,0xfffffff2,"RSA no p");
            uVar8 = 0xffffffff;
          }
          else {
            iVar6 = _libssh2_get_bignum_bytes(param_2,&uStack_58);
            if (iVar6 < 1) {
              _libssh2_error(param_1,0xfffffff2,"RSA no q");
              uVar8 = 0xffffffff;
            }
            else {
              iVar7 = _libssh2_get_c_string(param_2,auStack_48);
              if (iVar7 < 0) {
                _libssh2_error(param_1,0xfffffff2,"RSA no comment");
                uVar8 = 0xffffffff;
              }
              else {
                iVar1 = _libssh2_rsa_new(&prStack_40,uStack_70,(long)iVar2,uStack_78,(long)iVar1,
                                         uStack_68,(long)iVar3,uStack_60,(long)iVar5,uStack_58,
                                         (long)iVar6,0,0,0,0,uStack_50,(long)iVar4);
                if (iVar1 == 0) {
                  uStack_98 = 0;
                  if (prStack_40 != (rsa_st *)0x0) {
                    uStack_98 = _libssh2_rsa_new_additional_parameters(prStack_40);
                  }
                  if (((prStack_40 != (rsa_st *)0x0) && (param_5 != 0)) && (param_3 != 0)) {
                    pEStack_38 = EVP_PKEY_new();
                    EVP_PKEY_set1_RSA(pEStack_38,prStack_40);
                    uStack_98 = gen_publickey_from_rsa_evp
                                          (param_1,param_3,param_4,param_5,param_6,pEStack_38);
                    if (pEStack_38 != (EVP_PKEY *)0x0) {
                      EVP_PKEY_free(pEStack_38);
                    }
                  }
                  if (param_7 == (undefined8 *)0x0) {
                    RSA_free(prStack_40);
                  }
                  else {
                    *param_7 = prStack_40;
                  }
                  uVar8 = (ulong)uStack_98;
                }
                else {
                  if (prStack_40 != (rsa_st *)0x0) {
                    RSA_free(prStack_40);
                  }
                  uVar8 = _libssh2_error(param_1,0xfffffffa,
                                         "Unable to allocate memory for private key data");
                }
              }
            }
          }
        }
      }
    }
  }
  if (lStack_30 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar8;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EVP_PKEY * PEM_read_bio_PrivateKey(BIO *bp,EVP_PKEY **x,undefined1 *cb,void *u)

{
  EVP_PKEY *pEVar1;
  
  pEVar1 = PEM_read_bio_PrivateKey(bp,x,cb,u);
  return pEVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ENGINE_load_builtin_engines(void)

{
  ENGINE_load_builtin_engines();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int connect(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = connect(__fd,__addr,__len);
  return iVar1;
}



undefined8
_libssh2_dh_secret(undefined8 *param_1,BIGNUM *param_2,BIGNUM *param_3,BIGNUM *param_4,
                  BN_CTX *param_5)

{
  BN_mod_exp(param_2,param_3,(BIGNUM *)*param_1,param_4,param_5);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

PKCS8_PRIV_KEY_INFO * EVP_PKEY2PKCS8(EVP_PKEY *pkey)

{
  PKCS8_PRIV_KEY_INFO *pPVar1;
  
  pPVar1 = EVP_PKEY2PKCS8(pkey);
  return pPVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey,ec_key_st *key)

{
  int iVar1;
  
  iVar1 = EVP_PKEY_set1_EC_KEY(pkey,key);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int BN_div(BIGNUM *dv,BIGNUM *rem,BIGNUM *m,BIGNUM *d,BN_CTX *ctx)

{
  int iVar1;
  
  iVar1 = BN_div(dv,rem,m,d,ctx);
  return iVar1;
}



void _libssh2_htonu32(void)

{
  _libssh2_htonu32();
  return;
}



void libssh2_session_banner_set(void)

{
  libssh2_session_banner_set();
  return;
}



void libssh2_session_handshake(void)

{
  libssh2_session_handshake();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx,EVP_PKEY *peer)

{
  int iVar1;
  
  iVar1 = EVP_PKEY_derive_set_peer(ctx,peer);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BN_clear_free(BIGNUM *a)

{
  BN_clear_free(a);
  return;
}



undefined8 _libssh2_sha512(void *param_1,size_t param_2,uchar *param_3)

{
  int iVar1;
  EVP_MD_CTX *ctx;
  undefined8 uVar2;
  EVP_MD *type;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar2 = 1;
  }
  else {
    type = EVP_get_digestbyname("sha512");
    iVar1 = EVP_DigestInit(ctx,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(ctx);
      uVar2 = 1;
    }
    else {
      EVP_DigestUpdate(ctx,param_1,param_2);
      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
      EVP_MD_CTX_free(ctx);
      uVar2 = 0;
    }
  }
  return uVar2;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_PKEY_id(EVP_PKEY *pkey)

{
  int iVar1;
  
  iVar1 = EVP_PKEY_id(pkey);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EVP_MD * EVP_sha256(void)

{
  EVP_MD *pEVar1;
  
  pEVar1 = EVP_sha256();
  return pEVar1;
}



void _libssh2_kex_exchange(void)

{
  _libssh2_kex_exchange();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void EC_POINT_free(EC_POINT *point)

{
  EC_POINT_free(point);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EC_POINT * EC_POINT_new(EC_GROUP *group)

{
  EC_POINT *pEVar1;
  
  pEVar1 = EC_POINT_new(group);
  return pEVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int X509_PUBKEY_set(X509_PUBKEY **x,EVP_PKEY *pkey)

{
  int iVar1;
  
  iVar1 = X509_PUBKEY_set(x,pkey);
  return iVar1;
}



int libssh2_channel_handle_extended_data2(long param_1,undefined4 param_2)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = _libssh2_channel_extended_data(param_1,param_2);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



void _libssh2_openssl_crypto_init(void)

{
  ENGINE_load_builtin_engines();
  ENGINE_register_all_complete();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ECDH_compute_key(void *out,size_t outlen,EC_POINT *pub_key,EC_KEY *ecdh,KDF *KDF)

{
  int iVar1;
  
  iVar1 = ECDH_compute_key(out,outlen,pub_key,ecdh,KDF);
  return iVar1;
}



void Blowfish_decipher(long param_1,uint *param_2,uint *param_3)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  
  uVar1 = *param_2 ^ *(uint *)(param_1 + 0x1044);
  uVar2 = *param_3 ^
          *(uint *)(param_1 + 0x1040) ^
          (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
           *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
          *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
          *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x103c) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1038) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1034) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1030) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x102c) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1028) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1024) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1020) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x101c) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1018) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1014) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1010) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x100c) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1008) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  iVar3 = *(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4);
  iVar4 = *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4);
  uVar5 = *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4);
  iVar6 = *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar7 = *(uint *)(param_1 + 0x1004);
  *param_2 = *(uint *)(param_1 + 0x1000) ^ uVar2;
  *param_3 = uVar1 ^ uVar7 ^ (iVar3 + iVar4 ^ uVar5) + iVar6;
  return;
}



int _libssh2_dsa_new_openssh_private
              (undefined8 param_1,long param_2,char *param_3,undefined8 param_4)

{
  int iVar1;
  long in_FS_OFFSET;
  int iStack_2c;
  char *pcStack_28;
  long lStack_20;
  FILE *pFStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  pcStack_28 = (char *)0x0;
  lStack_20 = 0;
  if (param_2 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    iStack_2c = -1;
  }
  else {
    _libssh2_init_if_needed();
    pFStack_18 = fopen(param_3,"r");
    if (pFStack_18 == (FILE *)0x0) {
      _libssh2_error(param_2,0xfffffff0,"Unable to open OpenSSH DSA private key file");
      iStack_2c = -1;
    }
    else {
      iStack_2c = _libssh2_openssh_pem_parse(param_2,param_4,pFStack_18,&lStack_20);
      fclose(pFStack_18);
      if (iStack_2c == 0) {
        iVar1 = _libssh2_get_c_string(lStack_20,&pcStack_28);
        if ((iVar1 < 1) || (pcStack_28 == (char *)0x0)) {
          _libssh2_error(param_2,0xfffffff2,"Public key type in decrypted key data not found");
          iStack_2c = -1;
        }
        else {
          iVar1 = strcmp("ssh-dss",pcStack_28);
          if (iVar1 == 0) {
            iStack_2c = gen_publickey_from_dsa_openssh_priv_data(param_2,lStack_20,0,0,0,0,param_1);
          }
          else {
            iStack_2c = -1;
          }
          if (lStack_20 != 0) {
            _libssh2_string_buf_free(param_2,lStack_20);
          }
        }
      }
    }
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iStack_2c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

BIO * BIO_new_file(char *filename,char *mode)

{
  BIO *pBVar1;
  
  pBVar1 = BIO_new_file(filename,mode);
  return pBVar1;
}



undefined8
_libssh2_ed25519_sign
          (long param_1,long param_2,long *param_3,long *param_4,undefined8 param_5,
          undefined8 param_6)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int iStack_2c;
  long lStack_28;
  long lStack_20;
  EVP_MD_CTX *pEStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  iStack_2c = -1;
  pEStack_18 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  lStack_28 = 0;
  lStack_20 = 0;
  if (pEStack_18 != (EVP_MD_CTX *)0x0) {
    iVar1 = EVP_DigestSignInit(pEStack_18,(EVP_PKEY_CTX **)0x0,(EVP_MD *)0x0,(ENGINE *)0x0,
                               *(EVP_PKEY **)(param_1 + 8));
    if ((((iVar1 != 1) ||
         (iVar1 = EVP_DigestSign(pEStack_18,0,&lStack_28,param_5,param_6), iVar1 != 1)) ||
        (lStack_28 != 0x40)) || (lStack_20 = _libssh2_calloc(param_2,0x40), lStack_20 == 0))
    goto LAB_0010f8c2;
    iStack_2c = EVP_DigestSign(pEStack_18,lStack_20,&lStack_28,param_5,param_6);
  }
  if (iStack_2c == 1) {
    *param_3 = lStack_20;
    *param_4 = lStack_28;
  }
  else {
    *param_4 = 0;
    *param_3 = 0;
    (**(code **)(param_2 + 0x18))(lStack_20,param_2);
  }
LAB_0010f8c2:
  if (pEStack_18 != (EVP_MD_CTX *)0x0) {
    EVP_MD_CTX_free(pEStack_18);
  }
  if (iStack_2c == 1) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

EC_KEY * EC_KEY_new_by_curve_name(int nid)

{
  EC_KEY *pEVar1;
  
  pEVar1 = EC_KEY_new_by_curve_name(nid);
  return pEVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

DSA_SIG * DSA_do_sign(uchar *dgst,int dlen,DSA *dsa)

{
  DSA_SIG *pDVar1;
  
  pDVar1 = DSA_do_sign(dgst,dlen,dsa);
  return pDVar1;
}



void RSA_set0_key(void)

{
  RSA_set0_key();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx)

{
  EVP_PKEY_CTX_free(ctx);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ushort ** __ctype_b_loc(void)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  return ppuVar1;
}



int _libssh2_ecdsa_curve_type_from_name(char *param_1,undefined4 *param_2)

{
  int iVar1;
  size_t sVar2;
  int iStack_10;
  undefined4 uStack_c;
  
  iStack_10 = 0;
  if ((param_1 == (char *)0x0) || (sVar2 = strlen(param_1), sVar2 != 0x13)) {
    iStack_10 = -1;
  }
  else {
    iVar1 = strcmp(param_1,"ecdsa-sha2-nistp256");
    if (iVar1 == 0) {
      uStack_c = 0x19f;
    }
    else {
      iVar1 = strcmp(param_1,"ecdsa-sha2-nistp384");
      if (iVar1 == 0) {
        uStack_c = 0x2cb;
      }
      else {
        iVar1 = strcmp(param_1,"ecdsa-sha2-nistp521");
        if (iVar1 == 0) {
          uStack_c = 0x2cc;
        }
        else {
          iStack_10 = -1;
        }
      }
    }
    if ((iStack_10 == 0) && (param_2 != (undefined4 *)0x0)) {
      *param_2 = uStack_c;
    }
  }
  return iStack_10;
}



void DSA_get0_pqg(void)

{
  DSA_get0_pqg();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int EVP_PKEY_set1_RSA(EVP_PKEY *pkey,rsa_st *key)

{
  int iVar1;
  
  iVar1 = EVP_PKEY_set1_RSA(pkey,key);
  return iVar1;
}



undefined8 _libssh2_sha384_init(long *param_1)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  lVar2 = EVP_MD_CTX_new();
  *param_1 = lVar2;
  if (*param_1 == 0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("sha384");
    iVar1 = EVP_DigestInit((EVP_MD_CTX *)*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = 0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int socket(int __domain,int __type,int __protocol)

{
  int iVar1;
  
  iVar1 = socket(__domain,__type,__protocol);
  return iVar1;
}



int _libssh2_pub_priv_openssh_keyfile
              (long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
              undefined8 param_5,char *param_6,undefined8 param_7)

{
  int iVar1;
  long in_FS_OFFSET;
  undefined4 uStack_30;
  int iStack_2c;
  char *pcStack_28;
  long lStack_20;
  FILE *pFStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  pcStack_28 = (char *)0x0;
  lStack_20 = 0;
  iStack_2c = 0;
  if (param_1 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    iVar1 = -1;
  }
  else {
    _libssh2_init_if_needed();
    pFStack_18 = fopen(param_6,"r");
    if (pFStack_18 == (FILE *)0x0) {
      _libssh2_error(param_1,0xfffffff0,"Unable to open private key file");
      iVar1 = -1;
    }
    else {
      iStack_2c = _libssh2_openssh_pem_parse(param_1,param_7,pFStack_18,&lStack_20);
      fclose(pFStack_18);
      if (iStack_2c == 0) {
        iStack_2c = _libssh2_get_c_string(lStack_20,&pcStack_28);
        if ((iStack_2c < 1) || (pcStack_28 == (char *)0x0)) {
          _libssh2_error(param_1,0xfffffff2,"Public key type in decrypted key data not found");
          iVar1 = -1;
        }
        else {
          iStack_2c = -1;
          iVar1 = strcmp("ssh-ed25519",pcStack_28);
          if (iVar1 == 0) {
            iStack_2c = gen_publickey_from_ed25519_openssh_priv_data
                                  (param_1,lStack_20,param_2,param_3,param_4,param_5,0);
          }
          iVar1 = strcmp("ssh-rsa",pcStack_28);
          if (iVar1 == 0) {
            iStack_2c = gen_publickey_from_rsa_openssh_priv_data
                                  (param_1,lStack_20,param_2,param_3,param_4,param_5,0);
          }
          iVar1 = strcmp("ssh-dss",pcStack_28);
          if (iVar1 == 0) {
            iStack_2c = gen_publickey_from_dsa_openssh_priv_data
                                  (param_1,lStack_20,param_2,param_3,param_4,param_5,0);
          }
          iVar1 = _libssh2_ecdsa_curve_type_from_name(pcStack_28,&uStack_30);
          if (iVar1 == 0) {
            iStack_2c = gen_publickey_from_ecdsa_openssh_priv_data
                                  (param_1,uStack_30,lStack_20,param_2,param_3,param_4,param_5,0);
          }
          if (lStack_20 != 0) {
            _libssh2_string_buf_free(param_1,lStack_20);
          }
          iVar1 = iStack_2c;
          if (iStack_2c != 0) {
            _libssh2_error(param_1,0xfffffff0,"Unsupported OpenSSH key type");
            iVar1 = iStack_2c;
          }
        }
      }
      else {
        _libssh2_error(param_1,0xfffffff0,"Not an OpenSSH key file");
        iVar1 = iStack_2c;
      }
    }
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void FUN_0010b4b0(undefined8 *param_1)

{
  BIGNUM *pBVar1;
  
  pBVar1 = BN_new();
  *param_1 = pBVar1;
  return;
}



void processEntry deregister_tm_clones(void)

{
  if ((false) && (true)) {
    _ITM_deregisterTMCloneTable();
    return;
  }
  return;
}



void register_tm_clones(void)

{
  if ((false) && (true)) {
    _ITM_registerTMCloneTable();
    return;
  }
  return;
}



void __do_global_dtors_aux(undefined8 param_1,undefined8 param_2,undefined8 param_3)

{
  undefined8 extraout_RDX;
  
  if (completed_8061 == '\0') {
    if (true) {
      FUN_0010a270(__dso_handle);
      param_3 = extraout_RDX;
    }
    deregister_tm_clones(param_3,0x10b55c);
    completed_8061 = 1;
    return;
  }
  return;
}



void frame_dummy(void)

{
  register_tm_clones();
  return;
}



undefined8 dummy(void)

{
  return 0;
}



undefined * write_bn(long param_1,BIGNUM *param_2,int param_3)

{
  undefined *__dest;
  int local_2c;
  
  __dest = (undefined *)(param_1 + 4);
  *__dest = 0;
  BN_bn2bin(param_2,(uchar *)(param_1 + 5));
  local_2c = param_3;
  if (-1 < *(char *)(param_1 + 5)) {
    local_2c = param_3 + -1;
    memmove(__dest,(void *)(param_1 + 5),(long)local_2c);
  }
  _libssh2_htonu32(param_1,local_2c);
  return __dest + local_2c;
}



undefined8
_libssh2_rsa_new(undefined8 *param_1,uchar *param_2,int param_3,uchar *param_4,int param_5,
                uchar *param_6,int param_7,uchar *param_8,int param_9,uchar *param_10,int param_11,
                uchar *param_12,int param_13,uchar *param_14,int param_15,uchar *param_16,
                int param_17)

{
  BIGNUM *ret;
  BIGNUM *ret_00;
  RSA *pRVar1;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  
  local_48 = (BIGNUM *)0x0;
  local_40 = (BIGNUM *)0x0;
  local_38 = (BIGNUM *)0x0;
  local_30 = (BIGNUM *)0x0;
  local_28 = (BIGNUM *)0x0;
  local_20 = (BIGNUM *)0x0;
  ret = BN_new();
  BN_bin2bn(param_2,param_3,ret);
  ret_00 = BN_new();
  BN_bin2bn(param_4,param_5,ret_00);
  if (param_6 != (uchar *)0x0) {
    local_48 = BN_new();
    BN_bin2bn(param_6,param_7,local_48);
    local_40 = BN_new();
    BN_bin2bn(param_8,param_9,local_40);
    local_38 = BN_new();
    BN_bin2bn(param_10,param_11,local_38);
    local_30 = BN_new();
    BN_bin2bn(param_12,param_13,local_30);
    local_28 = BN_new();
    BN_bin2bn(param_14,param_15,local_28);
    local_20 = BN_new();
    BN_bin2bn(param_16,param_17,local_20);
  }
  pRVar1 = RSA_new();
  *param_1 = pRVar1;
  RSA_set0_key(*param_1,ret_00,ret,local_48);
  RSA_set0_factors(*param_1,local_40,local_38);
  RSA_set0_crt_params(*param_1,local_30,local_28,local_20);
  return 0;
}



undefined8
_libssh2_rsa_sha1_verify
          (RSA *param_1,uchar *param_2,uint param_3,undefined8 param_4,undefined8 param_5)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  uchar local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = _libssh2_sha1(param_4,param_5,local_28);
  if (iVar1 == 0) {
    iVar1 = RSA_verify(0x40,local_28,0x14,param_2,param_3,param_1);
    if (iVar1 == 1) {
      uVar2 = 0;
    }
    else {
      uVar2 = 0xffffffff;
    }
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
_libssh2_dsa_new(undefined8 *param_1,uchar *param_2,int param_3,uchar *param_4,int param_5,
                uchar *param_6,int param_7,uchar *param_8,int param_9,uchar *param_10,long param_11)

{
  BIGNUM *ret;
  BIGNUM *ret_00;
  BIGNUM *ret_01;
  BIGNUM *ret_02;
  DSA *pDVar1;
  undefined8 local_30;
  
  local_30 = (BIGNUM *)0x0;
  ret = BN_new();
  BN_bin2bn(param_2,param_3,ret);
  ret_00 = BN_new();
  BN_bin2bn(param_4,param_5,ret_00);
  ret_01 = BN_new();
  BN_bin2bn(param_6,param_7,ret_01);
  ret_02 = BN_new();
  BN_bin2bn(param_8,param_9,ret_02);
  if (param_11 != 0) {
    local_30 = BN_new();
    BN_bin2bn(param_10,(int)param_11,local_30);
  }
  pDVar1 = DSA_new();
  *param_1 = pDVar1;
  DSA_set0_pqg(*param_1,ret,ret_00,ret_01);
  DSA_set0_key(*param_1,ret_02,local_30);
  return 0;
}



undefined8
_libssh2_dsa_sha1_verify(DSA *param_1,uchar *param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  BIGNUM *ret;
  BIGNUM *ret_00;
  DSA_SIG *sig;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int local_44;
  uchar local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_44 = -1;
  ret = BN_new();
  BN_bin2bn(param_2,0x14,ret);
  ret_00 = BN_new();
  BN_bin2bn(param_2 + 0x14,0x14,ret_00);
  sig = DSA_SIG_new();
  DSA_SIG_set0(sig,ret,ret_00);
  iVar1 = _libssh2_sha1(param_3,param_4,local_28);
  if (iVar1 == 0) {
    local_44 = DSA_do_verify(local_28,0x14,sig,param_1);
  }
  DSA_SIG_free(sig);
  if (local_44 == 1) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



void _libssh2_ecdsa_key_get_curve_type(EC_KEY *param_1)

{
  EC_GROUP *group;
  
  group = EC_KEY_get0_group(param_1);
  EC_GROUP_get_curve_name(group);
  return;
}



int _libssh2_ecdsa_curve_type_from_name(char *param_1,undefined4 *param_2)

{
  int iVar1;
  size_t sVar2;
  int local_10;
  undefined4 local_c;
  
  local_10 = 0;
  if ((param_1 == (char *)0x0) || (sVar2 = strlen(param_1), sVar2 != 0x13)) {
    local_10 = -1;
  }
  else {
    iVar1 = strcmp(param_1,"ecdsa-sha2-nistp256");
    if (iVar1 == 0) {
      local_c = 0x19f;
    }
    else {
      iVar1 = strcmp(param_1,"ecdsa-sha2-nistp384");
      if (iVar1 == 0) {
        local_c = 0x2cb;
      }
      else {
        iVar1 = strcmp(param_1,"ecdsa-sha2-nistp521");
        if (iVar1 == 0) {
          local_c = 0x2cc;
        }
        else {
          local_10 = -1;
        }
      }
    }
    if ((local_10 == 0) && (param_2 != (undefined4 *)0x0)) {
      *param_2 = local_c;
    }
  }
  return local_10;
}



undefined8
_libssh2_ecdsa_curve_name_with_octal_new
          (undefined8 *param_1,uchar *param_2,size_t param_3,int param_4)

{
  EC_KEY *key;
  EC_GROUP *group;
  EC_POINT *p;
  undefined8 uVar1;
  undefined4 local_24;
  
  local_24 = 0;
  key = EC_KEY_new_by_curve_name(param_4);
  if (key != (EC_KEY *)0x0) {
    group = EC_KEY_get0_group(key);
    p = EC_POINT_new(group);
    EC_POINT_oct2point(group,p,param_2,param_3,(BN_CTX *)0x0);
    local_24 = EC_KEY_set_public_key(key,p);
    if (p != (EC_POINT *)0x0) {
      EC_POINT_free(p);
    }
    if (param_1 != (undefined8 *)0x0) {
      *param_1 = key;
    }
  }
  if (local_24 == 1) {
    uVar1 = 0;
  }
  else {
    uVar1 = 0xffffffff;
  }
  return uVar1;
}



undefined8
_libssh2_ecdsa_verify
          (EC_KEY *param_1,uchar *param_2,int param_3,uchar *param_4,int param_5,undefined8 param_6,
          undefined8 param_7)

{
  int iVar1;
  ECDSA_SIG *sig;
  BIGNUM *ret;
  BIGNUM *ret_00;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int local_80;
  uchar local_58 [72];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_80 = 0;
  iVar1 = _libssh2_ecdsa_key_get_curve_type(param_1);
  sig = ECDSA_SIG_new();
  ret = BN_new();
  ret_00 = BN_new();
  BN_bin2bn(param_2,param_3,ret);
  BN_bin2bn(param_4,param_5,ret_00);
  ECDSA_SIG_set0(sig,ret,ret_00);
  if (iVar1 == 0x19f) {
    _libssh2_sha256(param_6,param_7,local_58);
    local_80 = ECDSA_do_verify(local_58,0x20,sig,param_1);
  }
  else if (iVar1 == 0x2cb) {
    _libssh2_sha384(param_6,param_7,local_58);
    local_80 = ECDSA_do_verify(local_58,0x30,sig,param_1);
  }
  else if (iVar1 == 0x2cc) {
    _libssh2_sha512(param_6,param_7,local_58);
    local_80 = ECDSA_do_verify(local_58,0x40,sig,param_1);
  }
  if (sig != (ECDSA_SIG *)0x0) {
    ECDSA_SIG_free(sig);
  }
  if (local_80 == 1) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



bool _libssh2_cipher_init
               (undefined8 *param_1,code *param_2,uchar *param_3,uchar *param_4,int param_5)

{
  int iVar1;
  EVP_CIPHER_CTX *pEVar2;
  EVP_CIPHER *cipher;
  
  pEVar2 = EVP_CIPHER_CTX_new();
  *param_1 = pEVar2;
  cipher = (EVP_CIPHER *)(*param_2)();
  iVar1 = EVP_CipherInit((EVP_CIPHER_CTX *)*param_1,cipher,param_4,param_3,param_5);
  return iVar1 == 0;
}



bool _libssh2_cipher_crypt
               (undefined8 *param_1,undefined8 param_2,undefined8 param_3,uchar *param_4,
               size_t param_5)

{
  int iVar1;
  long in_FS_OFFSET;
  uchar local_38 [40];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = EVP_Cipher((EVP_CIPHER_CTX *)*param_1,local_38,param_4,(uint)param_5);
  if (iVar1 == 1) {
    memcpy(param_4,local_38,param_5);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1 != 1;
}



void _libssh2_openssl_crypto_init(void)

{
  ENGINE_load_builtin_engines();
  ENGINE_register_all_complete();
  return;
}



void _libssh2_openssl_crypto_exit(void)

{
  return;
}



int passphrase_cb(void *param_1,int param_2,undefined8 param_3,char *param_4)

{
  size_t sVar1;
  undefined4 local_c;
  
  sVar1 = strlen(param_4);
  local_c = (int)sVar1;
  if (param_2 <= local_c) {
    local_c = param_2 + -1;
  }
  memcpy(param_1,param_4,(long)local_c);
  *(undefined *)((long)param_1 + (long)local_c) = 0;
  return local_c;
}



undefined8
read_private_key_from_memory
          (long *param_1,code *param_2,void *param_3,int param_4,undefined8 param_5)

{
  BIO *a;
  undefined8 uVar1;
  long lVar2;
  
  *param_1 = 0;
  a = BIO_new_mem_buf(param_3,param_4);
  if (a == (BIO *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    lVar2 = (*param_2)(a,0,passphrase_cb,param_5);
    *param_1 = lVar2;
    BIO_free(a);
    if (*param_1 == 0) {
      uVar1 = 0xffffffff;
    }
    else {
      uVar1 = 0;
    }
  }
  return uVar1;
}



undefined8 read_private_key_from_file(long *param_1,code *param_2,char *param_3,undefined8 param_4)

{
  BIO *a;
  undefined8 uVar1;
  long lVar2;
  
  *param_1 = 0;
  a = BIO_new_file(param_3,"r");
  if (a == (BIO *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    lVar2 = (*param_2)(a,0,passphrase_cb,param_4);
    *param_1 = lVar2;
    BIO_free(a);
    if (*param_1 == 0) {
      uVar1 = 0xffffffff;
    }
    else {
      uVar1 = 0;
    }
  }
  return uVar1;
}



int _libssh2_rsa_new_private_frommemory
              (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
              undefined8 param_5)

{
  int local_14;
  
  _libssh2_init_if_needed();
  local_14 = read_private_key_from_memory
                       (param_1,&PEM_read_bio_RSAPrivateKey,param_3,param_4,param_5);
  if (local_14 != 0) {
    local_14 = read_openssh_private_key_from_memory
                         (param_1,param_2,"ssh-rsa",param_3,param_4,param_5);
  }
  return local_14;
}



long gen_publickey_from_rsa(long param_1,undefined8 param_2,long *param_3)

{
  int iVar1;
  int iVar2;
  int iVar3;
  long lVar4;
  long in_FS_OFFSET;
  BIGNUM *local_38;
  BIGNUM *local_30;
  long local_28;
  long local_20;
  void *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  RSA_get0_key(param_2,&local_30,&local_38,0);
  iVar1 = BN_num_bits(local_38);
  iVar2 = iVar1 + 7;
  if (iVar1 + 7 < 0) {
    iVar2 = iVar1 + 0xe;
  }
  iVar3 = BN_num_bits(local_30);
  iVar1 = iVar3 + 7;
  if (iVar3 + 7 < 0) {
    iVar1 = iVar3 + 0xe;
  }
  iVar1 = (iVar1 >> 3) + 1;
  local_28 = (long)(iVar1 + (iVar2 >> 3) + 0x14);
  local_20 = (**(code **)(param_1 + 8))(local_28,param_1);
  if (local_20 == 0) {
    lVar4 = 0;
  }
  else {
    local_18 = (void *)local_20;
    _libssh2_htonu32(local_20,7);
    local_18 = (void *)((long)local_18 + 4);
    memcpy(local_18,"ssh-rsa",7);
    local_18 = (void *)((long)local_18 + 7);
    local_18 = (void *)write_bn(local_18,local_38,(iVar2 >> 3) + 1);
    local_18 = (void *)write_bn(local_18,local_30,iVar1);
    *param_3 = (long)local_18 - local_20;
    lVar4 = local_20;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar4;
}



undefined8
gen_publickey_from_rsa_evp
          (long param_1,undefined8 *param_2,undefined8 *param_3,long *param_4,undefined8 *param_5,
          EVP_PKEY *param_6)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  undefined8 local_30;
  void *local_28;
  rsa_st *local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = (rsa_st *)0x0;
  local_28 = (void *)0x0;
  local_20 = EVP_PKEY_get1_RSA(param_6);
  if (((local_20 == (rsa_st *)0x0) ||
      (local_28 = (void *)(**(code **)(param_1 + 8))(7,param_1), local_28 == (void *)0x0)) ||
     (local_18 = gen_publickey_from_rsa(param_1,local_20,&local_30), local_18 == 0)) {
    if (local_20 != (rsa_st *)0x0) {
      RSA_free(local_20);
    }
    if (local_28 != (void *)0x0) {
      (**(code **)(param_1 + 0x18))(local_28,param_1);
    }
    uVar1 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for private key data");
  }
  else {
    RSA_free(local_20);
    memcpy(local_28,"ssh-rsa",7);
    *param_2 = local_28;
    *param_3 = 7;
    *param_4 = local_18;
    *param_5 = local_30;
    uVar1 = 0;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int _libssh2_rsa_new_additional_parameters(undefined8 param_1)

{
  int iVar1;
  BIGNUM *pBVar2;
  long in_FS_OFFSET;
  int local_4c;
  BIGNUM *local_48;
  BIGNUM *local_40;
  BIGNUM *local_38;
  BIGNUM *local_30;
  BIGNUM *local_28;
  BN_CTX *local_20;
  BIGNUM *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = (BN_CTX *)0x0;
  local_18 = (BIGNUM *)0x0;
  local_30 = (BIGNUM *)0x0;
  local_28 = (BIGNUM *)0x0;
  local_48 = (BIGNUM *)0x0;
  local_40 = (BIGNUM *)0x0;
  local_38 = (BIGNUM *)0x0;
  local_4c = 0;
  RSA_get0_key(param_1,0,0,&local_38);
  RSA_get0_factors(param_1,&local_48,&local_40);
  local_20 = BN_CTX_new();
  if (local_20 == (BN_CTX *)0x0) {
    local_4c = -1;
    goto LAB_0010c622;
  }
  local_18 = BN_new();
  if (local_18 == (BIGNUM *)0x0) {
    local_4c = -1;
  }
  else {
    local_30 = BN_new();
    if (local_30 == (BIGNUM *)0x0) {
      local_4c = -1;
    }
    else {
      local_28 = BN_new();
      if (local_28 == (BIGNUM *)0x0) {
        local_4c = -1;
      }
      else {
        pBVar2 = BN_value_one();
        iVar1 = BN_sub(local_18,local_40,pBVar2);
        if ((iVar1 != 0) &&
           (iVar1 = BN_div((BIGNUM *)0x0,local_28,local_38,local_18,local_20), iVar1 != 0)) {
          pBVar2 = BN_value_one();
          iVar1 = BN_sub(local_18,local_48,pBVar2);
          if ((iVar1 != 0) &&
             (iVar1 = BN_div((BIGNUM *)0x0,local_30,local_38,local_18,local_20), iVar1 != 0)) {
            RSA_set0_crt_params(param_1,local_30,local_28,0);
            goto LAB_0010c5d4;
          }
        }
        local_4c = -1;
      }
    }
  }
LAB_0010c5d4:
  if (local_18 != (BIGNUM *)0x0) {
    BN_clear_free(local_18);
  }
  BN_CTX_free(local_20);
  if (local_4c != 0) {
    if (local_30 != (BIGNUM *)0x0) {
      BN_clear_free(local_30);
    }
    if (local_28 != (BIGNUM *)0x0) {
      BN_clear_free(local_28);
    }
  }
LAB_0010c622:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_4c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong gen_publickey_from_rsa_openssh_priv_data
                (undefined8 param_1,undefined8 param_2,long param_3,undefined8 param_4,long param_5,
                undefined8 param_6,undefined8 *param_7)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  ulong uVar8;
  long in_FS_OFFSET;
  uint local_98;
  undefined8 local_78;
  undefined8 local_70;
  undefined8 local_68;
  undefined8 local_60;
  undefined8 local_58;
  undefined8 local_50;
  undefined local_48 [8];
  rsa_st *local_40;
  EVP_PKEY *local_38;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = (rsa_st *)0x0;
  iVar1 = _libssh2_get_bignum_bytes(param_2,&local_78);
  if (iVar1 < 1) {
    _libssh2_error(param_1,0xfffffff2,"RSA no n");
    uVar8 = 0xffffffff;
  }
  else {
    iVar2 = _libssh2_get_bignum_bytes(param_2,&local_70);
    if (iVar2 < 1) {
      _libssh2_error(param_1,0xfffffff2,"RSA no e");
      uVar8 = 0xffffffff;
    }
    else {
      iVar3 = _libssh2_get_bignum_bytes(param_2,&local_68);
      if (iVar3 < 1) {
        _libssh2_error(param_1,0xfffffff2,"RSA no d");
        uVar8 = 0xffffffff;
      }
      else {
        iVar4 = _libssh2_get_bignum_bytes(param_2,&local_50);
        if (iVar4 < 1) {
          _libssh2_error(param_1,0xfffffff2,"RSA no coeff");
          uVar8 = 0xffffffff;
        }
        else {
          iVar5 = _libssh2_get_bignum_bytes(param_2,&local_60);
          if (iVar5 < 1) {
            _libssh2_error(param_1,0xfffffff2,"RSA no p");
            uVar8 = 0xffffffff;
          }
          else {
            iVar6 = _libssh2_get_bignum_bytes(param_2,&local_58);
            if (iVar6 < 1) {
              _libssh2_error(param_1,0xfffffff2,"RSA no q");
              uVar8 = 0xffffffff;
            }
            else {
              iVar7 = _libssh2_get_c_string(param_2,local_48);
              if (iVar7 < 0) {
                _libssh2_error(param_1,0xfffffff2,"RSA no comment");
                uVar8 = 0xffffffff;
              }
              else {
                iVar1 = _libssh2_rsa_new(&local_40,local_70,(long)iVar2,local_78,(long)iVar1,
                                         local_68,(long)iVar3,local_60,(long)iVar5,local_58,
                                         (long)iVar6,0,0,0,0,local_50,(long)iVar4);
                if (iVar1 == 0) {
                  local_98 = 0;
                  if (local_40 != (rsa_st *)0x0) {
                    local_98 = _libssh2_rsa_new_additional_parameters(local_40);
                  }
                  if (((local_40 != (rsa_st *)0x0) && (param_5 != 0)) && (param_3 != 0)) {
                    local_38 = EVP_PKEY_new();
                    EVP_PKEY_set1_RSA(local_38,local_40);
                    local_98 = gen_publickey_from_rsa_evp
                                         (param_1,param_3,param_4,param_5,param_6,local_38);
                    if (local_38 != (EVP_PKEY *)0x0) {
                      EVP_PKEY_free(local_38);
                    }
                  }
                  if (param_7 == (undefined8 *)0x0) {
                    RSA_free(local_40);
                  }
                  else {
                    *param_7 = local_40;
                  }
                  uVar8 = (ulong)local_98;
                }
                else {
                  if (local_40 != (rsa_st *)0x0) {
                    RSA_free(local_40);
                  }
                  uVar8 = _libssh2_error(param_1,0xfffffffa,
                                         "Unable to allocate memory for private key data");
                }
              }
            }
          }
        }
      }
    }
  }
  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar8;
}



int _libssh2_rsa_new_openssh_private
              (undefined8 param_1,long param_2,char *param_3,undefined8 param_4)

{
  int iVar1;
  long in_FS_OFFSET;
  int local_2c;
  char *local_28;
  long local_20;
  FILE *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = (char *)0x0;
  local_20 = 0;
  if (param_2 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    local_2c = -1;
  }
  else {
    _libssh2_init_if_needed();
    local_18 = fopen(param_3,"r");
    if (local_18 == (FILE *)0x0) {
      _libssh2_error(param_2,0xfffffff0,"Unable to open OpenSSH RSA private key file");
      local_2c = -1;
    }
    else {
      local_2c = _libssh2_openssh_pem_parse(param_2,param_4,local_18,&local_20);
      fclose(local_18);
      if (local_2c == 0) {
        iVar1 = _libssh2_get_c_string(local_20,&local_28);
        if ((iVar1 < 1) || (local_28 == (char *)0x0)) {
          _libssh2_error(param_2,0xfffffff2,"Public key type in decrypted key data not found");
          local_2c = -1;
        }
        else {
          iVar1 = strcmp("ssh-rsa",local_28);
          if (iVar1 == 0) {
            local_2c = gen_publickey_from_rsa_openssh_priv_data(param_2,local_20,0,0,0,0,param_1);
          }
          else {
            local_2c = -1;
          }
          if (local_20 != 0) {
            _libssh2_string_buf_free(param_2,local_20);
          }
        }
      }
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_2c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int _libssh2_rsa_new_private
              (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  int local_14;
  
  _libssh2_init_if_needed();
  local_14 = read_private_key_from_file(param_1,&PEM_read_bio_RSAPrivateKey,param_3,param_4);
  if (local_14 != 0) {
    local_14 = _libssh2_rsa_new_openssh_private(param_1,param_2,param_3,param_4);
  }
  return local_14;
}



int _libssh2_dsa_new_private_frommemory
              (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
              undefined8 param_5)

{
  int local_14;
  
  _libssh2_init_if_needed();
  local_14 = read_private_key_from_memory
                       (param_1,&PEM_read_bio_DSAPrivateKey,param_3,param_4,param_5);
  if (local_14 != 0) {
    local_14 = read_openssh_private_key_from_memory
                         (param_1,param_2,"ssh-dsa",param_3,param_4,param_5);
  }
  return local_14;
}



long gen_publickey_from_dsa(long param_1,undefined8 param_2,long *param_3)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  long lVar6;
  long in_FS_OFFSET;
  BIGNUM *local_48;
  BIGNUM *local_40;
  BIGNUM *local_38;
  BIGNUM *local_30;
  long local_28;
  long local_20;
  void *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  DSA_get0_pqg(param_2,&local_48,&local_40,&local_38);
  DSA_get0_key(param_2,&local_30,0);
  iVar1 = BN_num_bits(local_48);
  iVar5 = iVar1 + 7;
  if (iVar1 + 7 < 0) {
    iVar5 = iVar1 + 0xe;
  }
  iVar1 = (iVar5 >> 3) + 1;
  iVar2 = BN_num_bits(local_40);
  iVar5 = iVar2 + 7;
  if (iVar2 + 7 < 0) {
    iVar5 = iVar2 + 0xe;
  }
  iVar2 = (iVar5 >> 3) + 1;
  iVar3 = BN_num_bits(local_38);
  iVar5 = iVar3 + 7;
  if (iVar3 + 7 < 0) {
    iVar5 = iVar3 + 0xe;
  }
  iVar3 = (iVar5 >> 3) + 1;
  iVar4 = BN_num_bits(local_30);
  iVar5 = iVar4 + 7;
  if (iVar4 + 7 < 0) {
    iVar5 = iVar4 + 0xe;
  }
  iVar5 = (iVar5 >> 3) + 1;
  local_28 = (long)(iVar5 + iVar3 + iVar2 + iVar1 + 0x1b);
  local_20 = (**(code **)(param_1 + 8))(local_28,param_1);
  if (local_20 == 0) {
    lVar6 = 0;
  }
  else {
    local_18 = (void *)local_20;
    _libssh2_htonu32(local_20,7);
    local_18 = (void *)((long)local_18 + 4);
    memcpy(local_18,"ssh-dss",7);
    local_18 = (void *)((long)local_18 + 7);
    local_18 = (void *)write_bn(local_18,local_48,iVar1);
    local_18 = (void *)write_bn(local_18,local_40,iVar2);
    local_18 = (void *)write_bn(local_18,local_38,iVar3);
    local_18 = (void *)write_bn(local_18,local_30,iVar5);
    *param_3 = (long)local_18 - local_20;
    lVar6 = local_20;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar6;
}



undefined8
gen_publickey_from_dsa_evp
          (long param_1,undefined8 *param_2,undefined8 *param_3,long *param_4,undefined8 *param_5,
          EVP_PKEY *param_6)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  undefined8 local_30;
  void *local_28;
  dsa_st *local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = (dsa_st *)0x0;
  local_28 = (void *)0x0;
  local_20 = EVP_PKEY_get1_DSA(param_6);
  if (((local_20 == (dsa_st *)0x0) ||
      (local_28 = (void *)(**(code **)(param_1 + 8))(7,param_1), local_28 == (void *)0x0)) ||
     (local_18 = gen_publickey_from_dsa(param_1,local_20,&local_30), local_18 == 0)) {
    if (local_20 != (dsa_st *)0x0) {
      DSA_free(local_20);
    }
    if (local_28 != (void *)0x0) {
      (**(code **)(param_1 + 0x18))(local_28,param_1);
    }
    uVar1 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for private key data");
  }
  else {
    DSA_free(local_20);
    memcpy(local_28,"ssh-dss",7);
    *param_2 = local_28;
    *param_3 = 7;
    *param_4 = local_18;
    *param_5 = local_30;
    uVar1 = 0;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong gen_publickey_from_dsa_openssh_priv_data
                (undefined8 param_1,undefined8 param_2,long param_3,undefined8 param_4,long param_5,
                undefined8 param_6,undefined8 *param_7)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  ulong uVar6;
  long in_FS_OFFSET;
  uint local_70;
  undefined8 local_58;
  undefined8 local_50;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  dsa_st *local_30;
  EVP_PKEY *local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = (dsa_st *)0x0;
  iVar1 = _libssh2_get_bignum_bytes(param_2,&local_58);
  if (iVar1 < 1) {
    _libssh2_error(param_1,0xfffffff2,"DSA no p");
    uVar6 = 0xffffffff;
  }
  else {
    iVar2 = _libssh2_get_bignum_bytes(param_2,&local_50);
    if (iVar2 < 1) {
      _libssh2_error(param_1,0xfffffff2,"DSA no q");
      uVar6 = 0xffffffff;
    }
    else {
      iVar3 = _libssh2_get_bignum_bytes(param_2,&local_48);
      if (iVar3 < 1) {
        _libssh2_error(param_1,0xfffffff2,"DSA no g");
        uVar6 = 0xffffffff;
      }
      else {
        iVar4 = _libssh2_get_bignum_bytes(param_2,&local_40);
        if (iVar4 < 1) {
          _libssh2_error(param_1,0xfffffff2,"DSA no public key");
          uVar6 = 0xffffffff;
        }
        else {
          iVar5 = _libssh2_get_bignum_bytes(param_2,&local_38);
          if (iVar5 < 1) {
            _libssh2_error(param_1,0xfffffff2,"DSA no private key");
            uVar6 = 0xffffffff;
          }
          else {
            iVar1 = _libssh2_dsa_new(&local_30,local_58,(long)iVar1,local_50,(long)iVar2,local_48,
                                     (long)iVar3,local_40,(long)iVar4,local_38,(long)iVar5);
            if (iVar1 == 0) {
              local_70 = 0;
              if (((local_30 != (dsa_st *)0x0) && (param_5 != 0)) && (param_3 != 0)) {
                local_28 = EVP_PKEY_new();
                EVP_PKEY_set1_DSA(local_28,local_30);
                local_70 = gen_publickey_from_dsa_evp
                                     (param_1,param_3,param_4,param_5,param_6,local_28);
                if (local_28 != (EVP_PKEY *)0x0) {
                  EVP_PKEY_free(local_28);
                }
              }
              if (param_7 == (undefined8 *)0x0) {
                DSA_free(local_30);
              }
              else {
                *param_7 = local_30;
              }
              uVar6 = (ulong)local_70;
            }
            else {
              if (local_30 != (dsa_st *)0x0) {
                DSA_free(local_30);
              }
              uVar6 = _libssh2_error(param_1,0xfffffffa,
                                     "Unable to allocate memory for private key data");
            }
          }
        }
      }
    }
  }
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar6;
}



int _libssh2_dsa_new_openssh_private
              (undefined8 param_1,long param_2,char *param_3,undefined8 param_4)

{
  int iVar1;
  long in_FS_OFFSET;
  int local_2c;
  char *local_28;
  long local_20;
  FILE *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = (char *)0x0;
  local_20 = 0;
  if (param_2 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    local_2c = -1;
  }
  else {
    _libssh2_init_if_needed();
    local_18 = fopen(param_3,"r");
    if (local_18 == (FILE *)0x0) {
      _libssh2_error(param_2,0xfffffff0,"Unable to open OpenSSH DSA private key file");
      local_2c = -1;
    }
    else {
      local_2c = _libssh2_openssh_pem_parse(param_2,param_4,local_18,&local_20);
      fclose(local_18);
      if (local_2c == 0) {
        iVar1 = _libssh2_get_c_string(local_20,&local_28);
        if ((iVar1 < 1) || (local_28 == (char *)0x0)) {
          _libssh2_error(param_2,0xfffffff2,"Public key type in decrypted key data not found");
          local_2c = -1;
        }
        else {
          iVar1 = strcmp("ssh-dss",local_28);
          if (iVar1 == 0) {
            local_2c = gen_publickey_from_dsa_openssh_priv_data(param_2,local_20,0,0,0,0,param_1);
          }
          else {
            local_2c = -1;
          }
          if (local_20 != 0) {
            _libssh2_string_buf_free(param_2,local_20);
          }
        }
      }
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_2c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int _libssh2_dsa_new_private
              (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  int local_14;
  
  _libssh2_init_if_needed();
  local_14 = read_private_key_from_file(param_1,&PEM_read_bio_DSAPrivateKey,param_3,param_4);
  if (local_14 != 0) {
    local_14 = _libssh2_dsa_new_openssh_private(param_1,param_2,param_3,param_4);
  }
  return local_14;
}



int _libssh2_ecdsa_new_private_frommemory
              (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
              undefined8 param_5)

{
  int local_14;
  
  _libssh2_init_if_needed();
  local_14 = read_private_key_from_memory
                       (param_1,&PEM_read_bio_ECPrivateKey,param_3,param_4,param_5);
  if (local_14 != 0) {
    local_14 = read_openssh_private_key_from_memory
                         (param_1,param_2,"ssh-ecdsa",param_3,param_4,param_5);
  }
  return local_14;
}



undefined4 _libssh2_curve25519_new(long param_1,undefined8 *param_2,long *param_3,long *param_4)

{
  int iVar1;
  undefined4 uVar2;
  long lVar3;
  long in_FS_OFFSET;
  int local_68;
  int local_64;
  undefined4 local_60;
  int local_5c;
  EVP_PKEY *local_58;
  X509_PUBKEY *local_50;
  uchar *local_48;
  uchar *local_40;
  ASN1_OCTET_STRING *local_38;
  EVP_PKEY_CTX *local_30;
  PKCS8_PRIV_KEY_INFO *local_28;
  long *local_20;
  void *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_58 = (EVP_PKEY *)0x0;
  local_30 = (EVP_PKEY_CTX *)0x0;
  local_28 = (PKCS8_PRIV_KEY_INFO *)0x0;
  local_38 = (ASN1_OCTET_STRING *)0x0;
  local_50 = (X509_PUBKEY *)0x0;
  local_20 = (long *)0x0;
  local_60 = 0xffffffff;
  local_30 = EVP_PKEY_CTX_new_id(0x40a,(ENGINE *)0x0);
  if (local_30 == (EVP_PKEY_CTX *)0x0) {
    uVar2 = 0xffffffff;
    goto LAB_0010d96c;
  }
  EVP_PKEY_keygen_init(local_30);
  EVP_PKEY_keygen(local_30,&local_58);
  local_28 = EVP_PKEY2PKCS8(local_58);
  if (((local_28 != (PKCS8_PRIV_KEY_INFO *)0x0) &&
      (iVar1 = PKCS8_pkey_get0((ASN1_OBJECT **)0x0,&local_48,&local_64,(X509_ALGOR **)0x0,local_28),
      iVar1 != 0)) &&
     (local_38 = d2i_ASN1_OCTET_STRING((ASN1_OCTET_STRING **)0x0,&local_48,(long)local_64),
     local_38 != (ASN1_OCTET_STRING *)0x0)) {
    local_18 = (void *)ASN1_STRING_get0_data(local_38);
    local_5c = ASN1_STRING_length(local_38);
    if (((local_5c == 0x20) && (local_50 = X509_PUBKEY_new(), local_50 != (X509_PUBKEY *)0x0)) &&
       ((iVar1 = X509_PUBKEY_set(&local_50,local_58), iVar1 != 0 &&
        ((iVar1 = X509_PUBKEY_get0_param
                            ((ASN1_OBJECT **)0x0,&local_40,&local_68,(X509_ALGOR **)0x0,local_50),
         iVar1 != 0 && (local_68 == 0x20)))))) {
      if (param_4 != (long *)0x0) {
        lVar3 = (**(code **)(param_1 + 8))(0x20,param_1);
        *param_4 = lVar3;
        if (*param_4 == 0) goto LAB_0010d906;
        memcpy((void *)*param_4,local_18,0x20);
      }
      if (param_3 != (long *)0x0) {
        lVar3 = (**(code **)(param_1 + 8))(0x20,param_1);
        *param_3 = lVar3;
        if (*param_3 == 0) goto LAB_0010d906;
        memcpy((void *)*param_3,local_40,0x20);
      }
      if (param_2 == (undefined8 *)0x0) {
LAB_0010d8e1:
        local_60 = 0;
      }
      else {
        local_20 = (long *)malloc(0x10);
        if (local_20 != (long *)0x0) {
          lVar3 = EVP_PKEY_new_raw_private_key(0x40a,0,local_18,0x20);
          local_20[1] = lVar3;
          lVar3 = EVP_PKEY_new_raw_public_key(0x40a,0,local_40,0x20);
          *local_20 = lVar3;
          if ((*local_20 != 0) && (local_20[1] != 0)) {
            *param_2 = local_20;
            goto LAB_0010d8e1;
          }
          if (local_20 != (long *)0x0) {
            if (*local_20 != 0) {
              EVP_PKEY_free((EVP_PKEY *)*local_20);
            }
            if (local_20[1] != 0) {
              EVP_PKEY_free((EVP_PKEY *)local_20[1]);
            }
            free(local_20);
          }
        }
      }
    }
  }
LAB_0010d906:
  if (local_28 != (PKCS8_PRIV_KEY_INFO *)0x0) {
    PKCS8_PRIV_KEY_INFO_free(local_28);
  }
  if (local_30 != (EVP_PKEY_CTX *)0x0) {
    EVP_PKEY_CTX_free(local_30);
  }
  if (local_38 != (ASN1_OCTET_STRING *)0x0) {
    ASN1_OCTET_STRING_free(local_38);
  }
  if (local_50 != (X509_PUBKEY *)0x0) {
    X509_PUBKEY_free(local_50);
  }
  uVar2 = local_60;
  if (local_58 != (EVP_PKEY *)0x0) {
    EVP_PKEY_free(local_58);
    uVar2 = local_60;
  }
LAB_0010d96c:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8
gen_publickey_from_ed25519_openssh_priv_data
          (long param_1,long *param_2,long *param_3,undefined8 *param_4,long *param_5,
          undefined8 *param_6,undefined8 *param_7)

{
  int iVar1;
  undefined8 uVar2;
  long lVar3;
  long in_FS_OFFSET;
  uint local_64;
  undefined8 local_58;
  undefined8 local_50;
  void *local_48;
  long local_40;
  long *local_38;
  void *local_30;
  long local_28;
  undefined8 local_20;
  void *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = (long *)0x0;
  local_30 = (void *)0x0;
  local_28 = 0;
  local_20 = 0;
  iVar1 = _libssh2_get_c_string(param_2,&local_58);
  if (iVar1 == 0x20) {
    iVar1 = _libssh2_get_c_string(param_2,&local_50);
    if (iVar1 == 0x40) {
      local_38 = (long *)calloc(1,0x10);
      if (local_38 == (long *)0x0) {
        _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for ed25519 key");
      }
      else {
        lVar3 = EVP_PKEY_new_raw_private_key(0x43f,0,local_50,0x20);
        local_38[1] = lVar3;
        lVar3 = EVP_PKEY_new_raw_public_key(0x43f,0,local_58,0x20);
        *local_38 = lVar3;
        iVar1 = _libssh2_get_c_string(param_2,&local_48);
        if (iVar1 < 0) {
          _libssh2_error(param_1,0xfffffff2,"Unable to read comment");
        }
        else {
          if ((0 < iVar1) &&
             (local_18 = (void *)_libssh2_calloc(param_1,(long)(iVar1 + 1)), local_18 != (void *)0x0
             )) {
            memcpy(local_18,local_48,(long)iVar1);
            memcpy((void *)((long)local_18 + (long)iVar1),&DAT_00144231,1);
            (**(code **)(param_1 + 0x18))(local_18,param_1);
          }
          local_64 = 1;
          while ((ulong)param_2[1] < (ulong)(param_2[2] + *param_2)) {
            if (local_64 != *(byte *)param_2[1]) {
              _libssh2_error(param_1,0xfffffff2,"Wrong padding");
              goto LAB_0010ddc9;
            }
            local_64 = local_64 + 1;
            param_2[1] = param_2[1] + 1;
          }
          if ((true) &&
             (local_30 = (void *)(**(code **)(param_1 + 8))(0xb,param_1), local_30 != (void *)0x0))
          {
            local_20 = 0x33;
            local_28 = _libssh2_calloc(param_1,0x33);
            if (local_28 != 0) {
              local_40 = local_28;
              _libssh2_store_str(&local_40,"ssh-ed25519",0xb);
              _libssh2_store_str(&local_40,local_58,0x20);
              memcpy(local_30,"ssh-ed25519",0xb);
              if (param_3 == (long *)0x0) {
                (**(code **)(param_1 + 0x18))(local_30,param_1);
              }
              else {
                *param_3 = (long)local_30;
              }
              if (param_4 != (undefined8 *)0x0) {
                *param_4 = 0xb;
              }
              if (param_5 == (long *)0x0) {
                (**(code **)(param_1 + 0x18))(local_28,param_1);
              }
              else {
                *param_5 = local_28;
              }
              if (param_6 != (undefined8 *)0x0) {
                *param_6 = local_20;
              }
              if (param_7 == (undefined8 *)0x0) {
                if ((local_38 != (long *)0x0) && (local_38 != (long *)0x0)) {
                  if (*local_38 != 0) {
                    EVP_PKEY_free((EVP_PKEY *)*local_38);
                  }
                  if (local_38[1] != 0) {
                    EVP_PKEY_free((EVP_PKEY *)local_38[1]);
                  }
                  free(local_38);
                }
              }
              else {
                *param_7 = local_38;
              }
              uVar2 = 0;
              goto LAB_0010de5e;
            }
          }
        }
      }
    }
    else {
      _libssh2_error(param_1,0xfffffff2,"Wrong private key length");
    }
LAB_0010ddc9:
    if ((local_38 != (long *)0x0) && (local_38 != (long *)0x0)) {
      if (*local_38 != 0) {
        EVP_PKEY_free((EVP_PKEY *)*local_38);
      }
      if (local_38[1] != 0) {
        EVP_PKEY_free((EVP_PKEY *)local_38[1]);
      }
      free(local_38);
    }
    if (local_30 != (void *)0x0) {
      (**(code **)(param_1 + 0x18))(local_30,param_1);
    }
    if (local_28 != 0) {
      (**(code **)(param_1 + 0x18))(local_28,param_1);
    }
    uVar2 = 0xffffffff;
  }
  else {
    _libssh2_error(param_1,0xfffffff2,"Wrong public key length");
    uVar2 = 0xffffffff;
  }
LAB_0010de5e:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int _libssh2_ed25519_new_private(undefined8 *param_1,long param_2,char *param_3,undefined8 param_4)

{
  int iVar1;
  long in_FS_OFFSET;
  int local_34;
  char *local_30;
  long local_28;
  long *local_20;
  FILE *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = 0;
  local_20 = (long *)0x0;
  if (param_2 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    local_34 = -1;
  }
  else {
    _libssh2_init_if_needed();
    local_18 = fopen(param_3,"r");
    if (local_18 == (FILE *)0x0) {
      _libssh2_error(param_2,0xfffffff0,"Unable to open ED25519 private key file");
      local_34 = -1;
    }
    else {
      local_34 = _libssh2_openssh_pem_parse(param_2,param_4,local_18,&local_28);
      fclose(local_18);
      if (local_34 == 0) {
        local_34 = _libssh2_get_c_string(local_28,&local_30);
        if ((local_34 < 1) || (local_30 == (char *)0x0)) {
          _libssh2_error(param_2,0xfffffff2,"Public key type in decrypted key data not found");
          local_34 = -1;
        }
        else {
          iVar1 = strcmp("ssh-ed25519",local_30);
          if (iVar1 == 0) {
            local_34 = gen_publickey_from_ed25519_openssh_priv_data
                                 (param_2,local_28,0,0,0,0,&local_20);
          }
          if (local_28 != 0) {
            _libssh2_string_buf_free(param_2,local_28);
          }
          if (local_34 == 0) {
            if (param_1 == (undefined8 *)0x0) {
              if ((local_20 != (long *)0x0) && (local_20 != (long *)0x0)) {
                if (*local_20 != 0) {
                  EVP_PKEY_free((EVP_PKEY *)*local_20);
                }
                if (local_20[1] != 0) {
                  EVP_PKEY_free((EVP_PKEY *)local_20[1]);
                }
                free(local_20);
              }
            }
            else {
              *param_1 = local_20;
            }
          }
        }
      }
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_34;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void _libssh2_ed25519_new_private_frommemory
               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
               undefined8 param_5)

{
  read_openssh_private_key_from_memory(param_1,param_2,"ssh-ed25519",param_3,param_4,param_5);
  return;
}



undefined8
_libssh2_ed25519_new_public
          (undefined8 *param_1,undefined8 param_2,undefined8 param_3,undefined param_4)

{
  undefined8 uVar1;
  long lVar2;
  long *__ptr;
  
  if (param_1 == (undefined8 *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    lVar2 = EVP_PKEY_new_raw_public_key(0x43f,0,param_3,param_4);
    if (lVar2 == 0) {
      uVar1 = _libssh2_error(param_2,0xfffffff2,"could not create ED25519 public key");
    }
    else {
      __ptr = (long *)calloc(1,0x10);
      if (__ptr == (long *)0x0) {
        uVar1 = _libssh2_error(param_2,0xfffffffa,"could not alloc public/private key");
      }
      else {
        *__ptr = lVar2;
        if (param_1 == (undefined8 *)0x0) {
          if ((__ptr != (long *)0x0) && (__ptr != (long *)0x0)) {
            if (*__ptr != 0) {
              EVP_PKEY_free((EVP_PKEY *)*__ptr);
            }
            if (__ptr[1] != 0) {
              EVP_PKEY_free((EVP_PKEY *)__ptr[1]);
            }
            free(__ptr);
          }
        }
        else {
          *param_1 = __ptr;
        }
        uVar1 = 0;
      }
    }
  }
  return uVar1;
}



undefined8
_libssh2_rsa_sha1_sign
          (long param_1,RSA *param_2,uchar *param_3,uint param_4,undefined8 *param_5,ulong *param_6)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  uint local_20;
  int local_1c;
  uchar *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = RSA_size(param_2);
  local_18 = (uchar *)(**(code **)(param_1 + 8))(local_20,param_1);
  if (local_18 == (uchar *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    local_1c = RSA_sign(0x40,param_3,param_4,local_18,&local_20,param_2);
    if (local_1c == 0) {
      (**(code **)(param_1 + 0x18))(local_18,param_1);
      uVar1 = 0xffffffff;
    }
    else {
      *param_5 = local_18;
      *param_6 = (ulong)local_20;
      uVar1 = 0;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



undefined8 _libssh2_dsa_sha1_sign(DSA *param_1,uchar *param_2,undefined8 param_3,void *param_4)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  BIGNUM *local_28;
  BIGNUM *local_20;
  DSA_SIG *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = DSA_do_sign(param_2,0x14,param_1);
  if (local_18 == (DSA_SIG *)0x0) {
    uVar4 = 0xffffffff;
  }
  else {
    DSA_SIG_get0(local_18,&local_28,&local_20);
    iVar1 = BN_num_bits(local_28);
    iVar2 = iVar1 + 7;
    if (iVar1 + 7 < 0) {
      iVar2 = iVar1 + 0xe;
    }
    iVar2 = iVar2 >> 3;
    if ((iVar2 < 1) || (0x14 < iVar2)) {
      DSA_SIG_free(local_18);
      uVar4 = 0xffffffff;
    }
    else {
      iVar3 = BN_num_bits(local_20);
      iVar1 = iVar3 + 7;
      if (iVar3 + 7 < 0) {
        iVar1 = iVar3 + 0xe;
      }
      iVar1 = iVar1 >> 3;
      if ((iVar1 < 1) || (0x14 < iVar1)) {
        DSA_SIG_free(local_18);
        uVar4 = 0xffffffff;
      }
      else {
        memset(param_4,0,0x28);
        BN_bn2bin(local_28,(uchar *)((long)(0x14 - iVar2) + (long)param_4));
        BN_bn2bin(local_20,(uchar *)((long)(0x14 - iVar1) + 0x14 + (long)param_4));
        DSA_SIG_free(local_18);
        uVar4 = 0;
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



undefined4
_libssh2_ecdsa_sign(undefined8 param_1,EC_KEY *param_2,uchar *param_3,int param_4,
                   undefined8 *param_5,size_t *param_6)

{
  int iVar1;
  int iVar2;
  int iVar3;
  long in_FS_OFFSET;
  undefined4 local_54;
  BIGNUM *local_48;
  BIGNUM *local_40;
  size_t local_38;
  void *local_30;
  void *local_28;
  ECDSA_SIG *local_20;
  void *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_54 = 0;
  local_38 = 0;
  local_48 = (BIGNUM *)0x0;
  local_40 = (BIGNUM *)0x0;
  local_30 = (void *)0x0;
  local_28 = (void *)0x0;
  local_20 = ECDSA_do_sign(param_3,param_4,param_2);
  if (local_20 == (ECDSA_SIG *)0x0) {
    local_54 = 0xffffffff;
  }
  else {
    ECDSA_SIG_get0(local_20,&local_48,&local_40);
    iVar1 = BN_num_bits(local_48);
    iVar3 = iVar1 + 7;
    if (iVar1 + 7 < 0) {
      iVar3 = iVar1 + 0xe;
    }
    iVar1 = (iVar3 >> 3) + 1;
    iVar2 = BN_num_bits(local_40);
    iVar3 = iVar2 + 7;
    if (iVar2 + 7 < 0) {
      iVar3 = iVar2 + 0xe;
    }
    iVar3 = (iVar3 >> 3) + 1;
    local_30 = malloc((long)(iVar3 + iVar1 + 8));
    if (local_30 == (void *)0x0) {
      local_54 = 0xffffffff;
    }
    else {
      local_18 = local_30;
      local_18 = (void *)write_bn(local_30,local_48,iVar1);
      local_18 = (void *)write_bn(local_18,local_40,iVar3);
      local_38 = (long)local_18 - (long)local_30;
      local_28 = (void *)_libssh2_calloc(param_1,local_38);
      if (local_28 == (void *)0x0) {
        local_54 = 0xffffffff;
      }
      else {
        memcpy(local_28,local_30,local_38);
        *param_5 = local_28;
        *param_6 = local_38;
      }
    }
    if (local_30 != (void *)0x0) {
      free(local_30);
    }
    if (local_20 != (ECDSA_SIG *)0x0) {
      ECDSA_SIG_free(local_20);
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_54;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 _libssh2_sha1_init(long *param_1)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  lVar2 = EVP_MD_CTX_new();
  *param_1 = lVar2;
  if (*param_1 == 0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("sha1");
    iVar1 = EVP_DigestInit((EVP_MD_CTX *)*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = 0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



undefined8 _libssh2_sha1(void *param_1,size_t param_2,uchar *param_3)

{
  int iVar1;
  EVP_MD_CTX *ctx;
  undefined8 uVar2;
  EVP_MD *type;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar2 = 1;
  }
  else {
    type = EVP_get_digestbyname("sha1");
    iVar1 = EVP_DigestInit(ctx,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(ctx);
      uVar2 = 1;
    }
    else {
      EVP_DigestUpdate(ctx,param_1,param_2);
      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
      EVP_MD_CTX_free(ctx);
      uVar2 = 0;
    }
  }
  return uVar2;
}



undefined8 _libssh2_sha256_init(long *param_1)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  lVar2 = EVP_MD_CTX_new();
  *param_1 = lVar2;
  if (*param_1 == 0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("sha256");
    iVar1 = EVP_DigestInit((EVP_MD_CTX *)*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = 0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



undefined8 _libssh2_sha256(void *param_1,size_t param_2,uchar *param_3)

{
  int iVar1;
  EVP_MD_CTX *ctx;
  undefined8 uVar2;
  EVP_MD *type;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar2 = 1;
  }
  else {
    type = EVP_get_digestbyname("sha256");
    iVar1 = EVP_DigestInit(ctx,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(ctx);
      uVar2 = 1;
    }
    else {
      EVP_DigestUpdate(ctx,param_1,param_2);
      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
      EVP_MD_CTX_free(ctx);
      uVar2 = 0;
    }
  }
  return uVar2;
}



undefined8 _libssh2_sha384_init(long *param_1)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  lVar2 = EVP_MD_CTX_new();
  *param_1 = lVar2;
  if (*param_1 == 0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("sha384");
    iVar1 = EVP_DigestInit((EVP_MD_CTX *)*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = 0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



undefined8 _libssh2_sha384(void *param_1,size_t param_2,uchar *param_3)

{
  int iVar1;
  EVP_MD_CTX *ctx;
  undefined8 uVar2;
  EVP_MD *type;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar2 = 1;
  }
  else {
    type = EVP_get_digestbyname("sha384");
    iVar1 = EVP_DigestInit(ctx,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(ctx);
      uVar2 = 1;
    }
    else {
      EVP_DigestUpdate(ctx,param_1,param_2);
      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
      EVP_MD_CTX_free(ctx);
      uVar2 = 0;
    }
  }
  return uVar2;
}



undefined8 _libssh2_sha512_init(long *param_1)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  lVar2 = EVP_MD_CTX_new();
  *param_1 = lVar2;
  if (*param_1 == 0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("sha512");
    iVar1 = EVP_DigestInit((EVP_MD_CTX *)*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = 0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



undefined8 _libssh2_sha512(void *param_1,size_t param_2,uchar *param_3)

{
  int iVar1;
  EVP_MD_CTX *ctx;
  undefined8 uVar2;
  EVP_MD *type;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar2 = 1;
  }
  else {
    type = EVP_get_digestbyname("sha512");
    iVar1 = EVP_DigestInit(ctx,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(ctx);
      uVar2 = 1;
    }
    else {
      EVP_DigestUpdate(ctx,param_1,param_2);
      EVP_DigestFinal(ctx,param_3,(uint *)0x0);
      EVP_MD_CTX_free(ctx);
      uVar2 = 0;
    }
  }
  return uVar2;
}



undefined8 _libssh2_md5_init(long *param_1)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  EVP_MD *type;
  
  lVar2 = EVP_MD_CTX_new();
  *param_1 = lVar2;
  if (*param_1 == 0) {
    uVar3 = 0;
  }
  else {
    type = EVP_get_digestbyname("md5");
    iVar1 = EVP_DigestInit((EVP_MD_CTX *)*param_1,type);
    if (iVar1 == 0) {
      EVP_MD_CTX_free(*param_1);
      *param_1 = 0;
      uVar3 = 0;
    }
    else {
      uVar3 = 1;
    }
  }
  return uVar3;
}



undefined8
gen_publickey_from_ec_evp
          (long param_1,undefined8 *param_2,undefined8 *param_3,long *param_4,long *param_5,
          EVP_PKEY *param_6)

{
  int iVar1;
  undefined8 uVar2;
  size_t sVar3;
  long in_FS_OFFSET;
  int local_68;
  long local_60;
  void *local_58;
  uchar *local_50;
  EC_KEY *local_48;
  long local_40;
  BN_CTX *local_38;
  EC_POINT *local_30;
  EC_GROUP *local_28;
  size_t local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_68 = 0;
  local_48 = (EC_KEY *)0x0;
  local_58 = (void *)0x0;
  local_40 = 0;
  local_50 = (uchar *)0x0;
  local_38 = BN_CTX_new();
  if (local_38 == (BN_CTX *)0x0) {
    uVar2 = 0xffffffff;
    goto LAB_0010eea3;
  }
  local_48 = EVP_PKEY_get1_EC_KEY(param_6);
  if (local_48 == (ec_key_st *)0x0) {
    local_68 = -1;
  }
  else {
    local_30 = EC_KEY_get0_public_key(local_48);
    local_28 = EC_KEY_get0_group(local_48);
    iVar1 = _libssh2_ecdsa_key_get_curve_type(local_48);
    local_58 = (void *)(**(code **)(param_1 + 8))(0x13,param_1);
    if (local_58 == (void *)0x0) {
      uVar2 = _libssh2_error(param_1,0xfffffffa,"out of memory");
      goto LAB_0010eea3;
    }
    if (iVar1 == 0x19f) {
      memcpy(local_58,"ecdsa-sha2-nistp256",0x13);
    }
    else if (iVar1 == 0x2cb) {
      memcpy(local_58,"ecdsa-sha2-nistp384",0x13);
    }
    else {
      if (iVar1 != 0x2cc) {
        local_68 = -1;
        goto LAB_0010ee39;
      }
      memcpy(local_58,"ecdsa-sha2-nistp521",0x13);
    }
    local_20 = EC_POINT_point2oct(local_28,local_30,POINT_CONVERSION_UNCOMPRESSED,(uchar *)0x0,0,
                                  local_38);
    if (local_20 < 0x86) {
      local_50 = (uchar *)malloc(local_20);
      if (local_50 == (uchar *)0x0) {
        local_68 = -1;
      }
      else {
        sVar3 = EC_POINT_point2oct(local_28,local_30,POINT_CONVERSION_UNCOMPRESSED,local_50,local_20
                                   ,local_38);
        if (local_20 == sVar3) {
          local_40 = local_20 + 0x27;
          local_18 = (**(code **)(param_1 + 8))(local_40,param_1);
          if (local_18 == 0) {
            local_68 = -1;
          }
          else {
            local_60 = local_18;
            _libssh2_store_str(&local_60,local_58,0x13);
            _libssh2_store_str(&local_60,(long)local_58 + 0xb,8);
            _libssh2_store_str(&local_60,local_50,local_20);
            *param_2 = local_58;
            *param_3 = 0x13;
            *param_4 = local_18;
            *param_5 = local_40;
          }
        }
        else {
          local_68 = -1;
        }
      }
    }
    else {
      local_68 = -1;
    }
  }
LAB_0010ee39:
  if (local_48 != (EC_KEY *)0x0) {
    EC_KEY_free(local_48);
  }
  if (local_38 != (BN_CTX *)0x0) {
    BN_CTX_free(local_38);
  }
  if (local_50 != (uchar *)0x0) {
    free(local_50);
  }
  if (local_68 == 0) {
    uVar2 = 0;
  }
  else {
    if (local_58 != (void *)0x0) {
      (**(code **)(param_1 + 0x18))(local_58,param_1);
    }
    uVar2 = 0xffffffff;
  }
LAB_0010eea3:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



ulong gen_publickey_from_ecdsa_openssh_priv_data
                (undefined8 param_1,undefined4 param_2,undefined8 param_3,long param_4,
                undefined8 param_5,long param_6,undefined8 param_7,undefined8 *param_8)

{
  int iVar1;
  int len;
  ulong uVar2;
  long in_FS_OFFSET;
  uint local_50;
  undefined local_40 [8];
  uchar *local_38;
  undefined8 local_30;
  EC_KEY *local_28;
  BIGNUM *local_20;
  EVP_PKEY *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = (EC_KEY *)0x0;
  iVar1 = _libssh2_get_c_string(param_3,local_40);
  if (iVar1 < 1) {
    _libssh2_error(param_1,0xfffffff2,"ECDSA no curve");
    uVar2 = 0xffffffff;
  }
  else {
    iVar1 = _libssh2_get_c_string(param_3,&local_30);
    if (iVar1 < 1) {
      _libssh2_error(param_1,0xfffffff2,"ECDSA no point");
      uVar2 = 0xffffffff;
    }
    else {
      len = _libssh2_get_bignum_bytes(param_3,&local_38);
      if (len < 1) {
        _libssh2_error(param_1,0xfffffff2,"ECDSA no exponent");
        uVar2 = 0xffffffff;
      }
      else {
        iVar1 = _libssh2_ecdsa_curve_name_with_octal_new(&local_28,local_30,(long)iVar1,param_2);
        if (iVar1 == 0) {
          local_20 = BN_new();
          if (local_20 != (BIGNUM *)0x0) {
            BN_bin2bn(local_38,len,local_20);
            iVar1 = EC_KEY_set_private_key(local_28,local_20);
            local_50 = (uint)(iVar1 != 1);
            if ((((local_50 == 0) && (local_28 != (EC_KEY *)0x0)) && (param_6 != 0)) &&
               (param_4 != 0)) {
              local_18 = EVP_PKEY_new();
              EVP_PKEY_set1_EC_KEY(local_18,local_28);
              local_50 = gen_publickey_from_ec_evp(param_1,param_4,param_5,param_6,param_7,local_18)
              ;
              if (local_18 != (EVP_PKEY *)0x0) {
                EVP_PKEY_free(local_18);
              }
            }
            if (param_8 == (undefined8 *)0x0) {
              EC_KEY_free(local_28);
            }
            else {
              *param_8 = local_28;
            }
            uVar2 = (ulong)local_50;
            goto LAB_0010f12c;
          }
        }
        else {
          _libssh2_error(param_1,0xfffffff2,"ECDSA could not create key");
        }
        if (local_28 != (EC_KEY *)0x0) {
          EC_KEY_free(local_28);
        }
        uVar2 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for private key data");
      }
    }
  }
LAB_0010f12c:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int _libssh2_ecdsa_new_openssh_private
              (undefined8 param_1,long param_2,char *param_3,undefined8 param_4)

{
  int iVar1;
  long in_FS_OFFSET;
  undefined4 local_30;
  int local_2c;
  long local_28;
  long local_20;
  FILE *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = 0;
  local_20 = 0;
  if (param_2 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    iVar1 = -1;
  }
  else {
    _libssh2_init_if_needed();
    local_18 = fopen(param_3,"r");
    if (local_18 == (FILE *)0x0) {
      _libssh2_error(param_2,0xfffffff0,"Unable to open OpenSSH ECDSA private key file");
      iVar1 = -1;
    }
    else {
      local_2c = _libssh2_openssh_pem_parse(param_2,param_4,local_18,&local_20);
      fclose(local_18);
      iVar1 = local_2c;
      if (local_2c == 0) {
        local_2c = _libssh2_get_c_string(local_20,&local_28);
        if ((local_2c < 1) || (local_28 == 0)) {
          _libssh2_error(param_2,0xfffffff2,"Public key type in decrypted key data not found");
          iVar1 = -1;
        }
        else {
          local_2c = _libssh2_ecdsa_curve_type_from_name(local_28,&local_30);
          if (local_2c == 0) {
            local_2c = gen_publickey_from_ecdsa_openssh_priv_data
                                 (param_2,local_30,local_20,0,0,0,0,param_1);
          }
          else {
            local_2c = -1;
          }
          iVar1 = local_2c;
          if (local_20 != 0) {
            _libssh2_string_buf_free(param_2,local_20);
            iVar1 = local_2c;
          }
        }
      }
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8
_libssh2_ecdsa_new_private
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  undefined8 uVar2;
  
  _libssh2_init_if_needed();
  iVar1 = read_private_key_from_file(param_1,&PEM_read_bio_ECPrivateKey,param_3,param_4);
  if (iVar1 == 0) {
    uVar2 = 0;
  }
  else {
    uVar2 = _libssh2_ecdsa_new_openssh_private(param_1,param_2,param_3,param_4);
  }
  return uVar2;
}



undefined8
_libssh2_ecdsa_create_key
          (long param_1,undefined8 *param_2,long *param_3,size_t *param_4,int param_5)

{
  BN_CTX *ctx;
  undefined8 uVar1;
  EC_KEY *key;
  EC_GROUP *group;
  EC_POINT *p;
  size_t len;
  size_t sVar2;
  long lVar3;
  long in_FS_OFFSET;
  int local_c4;
  uchar local_98 [136];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_c4 = 1;
  ctx = BN_CTX_new();
  if (ctx == (BN_CTX *)0x0) {
    uVar1 = 0xffffffff;
    goto LAB_0010f5be;
  }
  key = EC_KEY_new_by_curve_name(param_5);
  group = EC_KEY_get0_group(key);
  EC_KEY_generate_key(key);
  p = EC_KEY_get0_public_key(key);
  len = EC_POINT_point2oct(group,p,POINT_CONVERSION_UNCOMPRESSED,(uchar *)0x0,0,ctx);
  if (len < 0x86) {
    sVar2 = EC_POINT_point2oct(group,p,POINT_CONVERSION_UNCOMPRESSED,local_98,len,ctx);
    if (len == sVar2) {
      if (param_2 != (undefined8 *)0x0) {
        *param_2 = key;
      }
      if (param_3 != (long *)0x0) {
        lVar3 = (**(code **)(param_1 + 8))(len,param_1);
        *param_3 = lVar3;
        if (*param_3 == 0) {
          local_c4 = -1;
          goto LAB_0010f590;
        }
        memcpy((void *)*param_3,local_98,len);
      }
      if (param_4 != (size_t *)0x0) {
        *param_4 = len;
      }
    }
    else {
      local_c4 = -1;
    }
  }
  else {
    local_c4 = -1;
  }
LAB_0010f590:
  if (ctx != (BN_CTX *)0x0) {
    BN_CTX_free(ctx);
  }
  if (local_c4 == 1) {
    uVar1 = 0;
  }
  else {
    uVar1 = 0xffffffff;
  }
LAB_0010f5be:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



undefined4 _libssh2_ecdh_gen_k(undefined8 *param_1,EC_KEY *param_2,uchar *param_3,size_t param_4)

{
  int iVar1;
  int iVar2;
  uint len;
  BN_CTX *ctx;
  EC_GROUP *group;
  EC_POINT *p;
  undefined4 local_38;
  undefined8 local_30;
  
  local_38 = 0;
  local_30 = (uchar *)0x0;
  ctx = BN_CTX_new();
  if (ctx == (BN_CTX *)0x0) {
    local_38 = 0xffffffff;
  }
  else if (param_1 == (undefined8 *)0x0) {
    local_38 = 0xffffffff;
  }
  else {
    group = EC_KEY_get0_group(param_2);
    p = EC_POINT_new(group);
    if (p == (EC_POINT *)0x0) {
      local_38 = 0xffffffff;
    }
    else {
      iVar1 = EC_POINT_oct2point(group,p,param_3,param_4,ctx);
      if (iVar1 == 1) {
        iVar2 = EC_GROUP_get_degree(group);
        iVar1 = iVar2 + 7;
        if (iVar2 + 7 < 0) {
          iVar1 = iVar2 + 0xe;
        }
        local_30 = (uchar *)malloc((long)(iVar1 >> 3));
        if (local_30 == (uchar *)0x0) {
          local_38 = 0xffffffff;
        }
        else {
          len = ECDH_compute_key(local_30,(long)(iVar1 >> 3),p,param_2,(KDF *)0x0);
          if ((len == 0) || (0x85 < len)) {
            local_38 = 0xffffffff;
          }
          else {
            BN_bin2bn(local_30,len,(BIGNUM *)*param_1);
          }
        }
      }
      else {
        local_38 = 0xffffffff;
      }
      if (p != (EC_POINT *)0x0) {
        EC_POINT_free(p);
      }
      if (ctx != (BN_CTX *)0x0) {
        BN_CTX_free(ctx);
      }
      if (local_30 != (uchar *)0x0) {
        free(local_30);
      }
    }
  }
  return local_38;
}



undefined8
_libssh2_ed25519_sign
          (long param_1,long param_2,long *param_3,long *param_4,undefined8 param_5,
          undefined8 param_6)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int local_2c;
  long local_28;
  long local_20;
  EVP_MD_CTX *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_2c = -1;
  local_18 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  local_28 = 0;
  local_20 = 0;
  if (local_18 != (EVP_MD_CTX *)0x0) {
    iVar1 = EVP_DigestSignInit(local_18,(EVP_PKEY_CTX **)0x0,(EVP_MD *)0x0,(ENGINE *)0x0,
                               *(EVP_PKEY **)(param_1 + 8));
    if ((((iVar1 != 1) || (iVar1 = EVP_DigestSign(local_18,0,&local_28,param_5,param_6), iVar1 != 1)
         ) || (local_28 != 0x40)) || (local_20 = _libssh2_calloc(param_2,0x40), local_20 == 0))
    goto LAB_0010f8c2;
    local_2c = EVP_DigestSign(local_18,local_20,&local_28,param_5,param_6);
  }
  if (local_2c == 1) {
    *param_3 = local_20;
    *param_4 = local_28;
  }
  else {
    *param_4 = 0;
    *param_3 = 0;
    (**(code **)(param_2 + 0x18))(local_20,param_2);
  }
LAB_0010f8c2:
  if (local_18 != (EVP_MD_CTX *)0x0) {
    EVP_MD_CTX_free(local_18);
  }
  if (local_2c == 1) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 _libssh2_curve25519_gen_k(long *param_1,undefined8 param_2,undefined8 param_3)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int local_64;
  size_t local_60;
  EVP_PKEY_CTX *local_58;
  EVP_PKEY *local_50;
  EVP_PKEY *local_48;
  BN_CTX *local_40;
  uchar local_38 [40];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_64 = -1;
  local_50 = (EVP_PKEY *)0x0;
  local_48 = (EVP_PKEY *)0x0;
  local_58 = (EVP_PKEY_CTX *)0x0;
  local_40 = (BN_CTX *)0x0;
  local_60 = 0;
  if ((param_1 == (long *)0x0) || (*param_1 == 0)) {
    uVar2 = 0xffffffff;
  }
  else {
    local_40 = BN_CTX_new();
    if (local_40 == (BN_CTX *)0x0) {
      uVar2 = 0xffffffff;
    }
    else {
      local_50 = (EVP_PKEY *)EVP_PKEY_new_raw_public_key(0x40a,0,param_3,0x20);
      local_48 = (EVP_PKEY *)EVP_PKEY_new_raw_private_key(0x40a,0,param_2,0x20);
      if (((((local_50 != (EVP_PKEY *)0x0) && (local_48 != (EVP_PKEY *)0x0)) &&
           (local_58 = EVP_PKEY_CTX_new(local_48,(ENGINE *)0x0), local_58 != (EVP_PKEY_CTX *)0x0))
          && ((local_64 = EVP_PKEY_derive_init(local_58), 0 < local_64 &&
              (local_64 = EVP_PKEY_derive_set_peer(local_58,local_50), 0 < local_64)))) &&
         (local_64 = EVP_PKEY_derive(local_58,(uchar *)0x0,&local_60), 0 < local_64)) {
        if (local_60 == 0x20) {
          iVar1 = EVP_PKEY_derive(local_58,local_38,&local_60);
          if ((iVar1 == 1) && (local_60 == 0x20)) {
            BN_bin2bn(local_38,0x20,(BIGNUM *)*param_1);
            local_64 = 1;
          }
          else {
            local_64 = -1;
          }
        }
        else {
          local_64 = -1;
        }
      }
      if (local_58 != (EVP_PKEY_CTX *)0x0) {
        EVP_PKEY_CTX_free(local_58);
      }
      if (local_50 != (EVP_PKEY *)0x0) {
        EVP_PKEY_free(local_50);
      }
      if (local_48 != (EVP_PKEY *)0x0) {
        EVP_PKEY_free(local_48);
      }
      if (local_40 != (BN_CTX *)0x0) {
        BN_CTX_free(local_40);
      }
      if (local_64 == 1) {
        uVar2 = 0;
      }
      else {
        uVar2 = 0xffffffff;
      }
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8
_libssh2_ed25519_verify
          (undefined8 *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
          undefined8 param_5)

{
  EVP_MD_CTX *ctx;
  undefined8 uVar1;
  undefined4 local_14;
  
  ctx = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (ctx == (EVP_MD_CTX *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    local_14 = EVP_DigestVerifyInit
                         (ctx,(EVP_PKEY_CTX **)0x0,(EVP_MD *)0x0,(ENGINE *)0x0,(EVP_PKEY *)*param_1)
    ;
    if (local_14 == 1) {
      local_14 = EVP_DigestVerify(ctx,param_2,param_3,param_4,param_5);
    }
    EVP_MD_CTX_free(ctx);
    if (local_14 == 1) {
      uVar1 = 0;
    }
    else {
      uVar1 = 0xffffffff;
    }
  }
  return uVar1;
}



int _libssh2_pub_priv_openssh_keyfile
              (long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
              undefined8 param_5,char *param_6,undefined8 param_7)

{
  int iVar1;
  long in_FS_OFFSET;
  undefined4 local_30;
  int local_2c;
  char *local_28;
  long local_20;
  FILE *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = (char *)0x0;
  local_20 = 0;
  local_2c = 0;
  if (param_1 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    iVar1 = -1;
  }
  else {
    _libssh2_init_if_needed();
    local_18 = fopen(param_6,"r");
    if (local_18 == (FILE *)0x0) {
      _libssh2_error(param_1,0xfffffff0,"Unable to open private key file");
      iVar1 = -1;
    }
    else {
      local_2c = _libssh2_openssh_pem_parse(param_1,param_7,local_18,&local_20);
      fclose(local_18);
      if (local_2c == 0) {
        local_2c = _libssh2_get_c_string(local_20,&local_28);
        if ((local_2c < 1) || (local_28 == (char *)0x0)) {
          _libssh2_error(param_1,0xfffffff2,"Public key type in decrypted key data not found");
          iVar1 = -1;
        }
        else {
          local_2c = -1;
          iVar1 = strcmp("ssh-ed25519",local_28);
          if (iVar1 == 0) {
            local_2c = gen_publickey_from_ed25519_openssh_priv_data
                                 (param_1,local_20,param_2,param_3,param_4,param_5,0);
          }
          iVar1 = strcmp("ssh-rsa",local_28);
          if (iVar1 == 0) {
            local_2c = gen_publickey_from_rsa_openssh_priv_data
                                 (param_1,local_20,param_2,param_3,param_4,param_5,0);
          }
          iVar1 = strcmp("ssh-dss",local_28);
          if (iVar1 == 0) {
            local_2c = gen_publickey_from_dsa_openssh_priv_data
                                 (param_1,local_20,param_2,param_3,param_4,param_5,0);
          }
          iVar1 = _libssh2_ecdsa_curve_type_from_name(local_28,&local_30);
          if (iVar1 == 0) {
            local_2c = gen_publickey_from_ecdsa_openssh_priv_data
                                 (param_1,local_30,local_20,param_2,param_3,param_4,param_5,0);
          }
          if (local_20 != 0) {
            _libssh2_string_buf_free(param_1,local_20);
          }
          iVar1 = local_2c;
          if (local_2c != 0) {
            _libssh2_error(param_1,0xfffffff0,"Unsupported OpenSSH key type");
            iVar1 = local_2c;
          }
        }
      }
      else {
        _libssh2_error(param_1,0xfffffff0,"Not an OpenSSH key file");
        iVar1 = local_2c;
      }
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong _libssh2_pub_priv_keyfile
                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                undefined8 param_5,char *param_6,void *param_7)

{
  int iVar1;
  BIO *bp;
  ulong uVar2;
  EVP_PKEY *pkey;
  uint local_24;
  
  bp = BIO_new_file(param_6,"r");
  if (bp == (BIO *)0x0) {
    uVar2 = _libssh2_error(param_1,0xfffffff0,
                           "Unable to extract public key from private key file: Unable to open private key file"
                          );
    return uVar2;
  }
  BIO_ctrl(bp,1,0,(void *)0x0);
  pkey = PEM_read_bio_PrivateKey(bp,(EVP_PKEY **)0x0,(undefined1 *)0x0,param_7);
  BIO_free(bp);
  if (pkey == (EVP_PKEY *)0x0) {
    iVar1 = _libssh2_pub_priv_openssh_keyfile
                      (param_1,param_2,param_3,param_4,param_5,param_6,param_7);
    if (iVar1 != 0) {
      uVar2 = _libssh2_error(param_1,0xfffffff0,
                             "Unable to extract public key from private key file: Wrong passphrase or invalid/unrecognized private key file format"
                            );
      return uVar2;
    }
    return 0;
  }
  iVar1 = EVP_PKEY_id(pkey);
  if (iVar1 == 0x198) {
    local_24 = gen_publickey_from_ec_evp(param_1,param_2,param_3,param_4,param_5,pkey);
    goto LAB_0011009a;
  }
  if (iVar1 < 0x199) {
    if (iVar1 == 6) {
      local_24 = gen_publickey_from_rsa_evp(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_0011009a;
    }
    if (iVar1 == 0x74) {
      local_24 = gen_publickey_from_dsa_evp(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_0011009a;
    }
  }
  local_24 = _libssh2_error(param_1,0xfffffff0,
                            "Unable to extract public key from private key file: Unsupported private key file format"
                           );
LAB_0011009a:
  EVP_PKEY_free(pkey);
  return (ulong)local_24;
}



int _libssh2_pub_priv_openssh_keyfilememory
              (long param_1,undefined8 *param_2,char *param_3,undefined8 param_4,undefined8 param_5,
              undefined8 param_6,undefined8 param_7,undefined8 param_8,undefined8 param_9,
              undefined8 param_10)

{
  int iVar1;
  size_t sVar2;
  long in_FS_OFFSET;
  undefined4 local_28;
  int local_24;
  char *local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = (char *)0x0;
  local_18 = 0;
  if (param_2 != (undefined8 *)0x0) {
    *param_2 = 0;
  }
  if (param_1 == 0) {
    _libssh2_error(0,0xfffffff2,"Session is required");
    iVar1 = -1;
  }
  else if ((param_3 == (char *)0x0) ||
          ((sVar2 = strlen(param_3), sVar2 < 0xc && (sVar2 = strlen(param_3), 6 < sVar2)))) {
    _libssh2_init_if_needed();
    local_24 = _libssh2_openssh_pem_parse_memory(param_1,param_10,param_8,param_9,&local_18);
    iVar1 = local_24;
    if (local_24 == 0) {
      local_24 = _libssh2_get_c_string(local_18,&local_20);
      if ((local_24 < 1) || (local_20 == (char *)0x0)) {
        _libssh2_error(param_1,0xfffffff2,"Public key type in decrypted key data not found");
        iVar1 = -1;
      }
      else {
        iVar1 = strcmp("ssh-ed25519",local_20);
        if ((iVar1 == 0) &&
           ((param_3 == (char *)0x0 || (iVar1 = strcmp("ssh-ed25519",param_3), iVar1 == 0)))) {
          local_24 = gen_publickey_from_ed25519_openssh_priv_data
                               (param_1,local_18,param_4,param_5,param_6,param_7,param_2);
        }
        iVar1 = strcmp("ssh-rsa",local_20);
        if ((iVar1 == 0) &&
           ((param_3 == (char *)0x0 || (iVar1 = strcmp("ssh-rsa",param_3), iVar1 == 0)))) {
          local_24 = gen_publickey_from_rsa_openssh_priv_data
                               (param_1,local_18,param_4,param_5,param_6,param_7,param_2);
        }
        iVar1 = strcmp("ssh-dss",local_20);
        if ((iVar1 == 0) &&
           ((param_3 == (char *)0x0 || (iVar1 = strcmp("ssh-dss",param_3), iVar1 == 0)))) {
          local_24 = gen_publickey_from_dsa_openssh_priv_data
                               (param_1,local_18,param_4,param_5,param_6,param_7,param_2);
        }
        iVar1 = _libssh2_ecdsa_curve_type_from_name(local_20,&local_28);
        if ((iVar1 == 0) &&
           ((param_3 == (char *)0x0 || (iVar1 = strcmp("ssh-ecdsa",param_3), iVar1 == 0)))) {
          local_24 = gen_publickey_from_ecdsa_openssh_priv_data
                               (param_1,local_28,local_18,param_4,param_5,param_6,param_7,param_2);
        }
        iVar1 = local_24;
        if (local_18 != 0) {
          _libssh2_string_buf_free(param_1,local_18);
          iVar1 = local_24;
        }
      }
    }
  }
  else {
    _libssh2_error(param_1,0xfffffff2,"type is invalid");
    iVar1 = -1;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void read_openssh_private_key_from_memory
               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
               undefined8 param_5,undefined8 param_6)

{
  _libssh2_pub_priv_openssh_keyfilememory(param_2,param_1,param_3,0,0,0,0,param_4,param_5,param_6);
  return;
}



ulong _libssh2_pub_priv_keyfilememory
                (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                undefined8 param_5,void *param_6,undefined8 param_7,void *param_8)

{
  int iVar1;
  BIO *bp;
  EVP_PKEY *pkey;
  ulong uVar2;
  uint local_20;
  
  bp = BIO_new_mem_buf(param_6,(int)param_7);
  if (bp == (BIO *)0x0) {
    return 0xffffffff;
  }
  BIO_ctrl(bp,1,0,(void *)0x0);
  pkey = PEM_read_bio_PrivateKey(bp,(EVP_PKEY **)0x0,(undefined1 *)0x0,param_8);
  BIO_free(bp);
  if (pkey == (EVP_PKEY *)0x0) {
    iVar1 = _libssh2_pub_priv_openssh_keyfilememory
                      (param_1,0,0,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
    if (iVar1 != 0) {
      uVar2 = _libssh2_error(param_1,0xfffffff0,
                             "Unable to extract public key from private key file: Wrong passphrase or invalid/unrecognized private key file format"
                            );
      return uVar2;
    }
    return 0;
  }
  iVar1 = EVP_PKEY_id(pkey);
  if (iVar1 == 0x198) {
    local_20 = gen_publickey_from_ec_evp(param_1,param_2,param_3,param_4,param_5,pkey);
    goto LAB_00110615;
  }
  if (iVar1 < 0x199) {
    if (iVar1 == 6) {
      local_20 = gen_publickey_from_rsa_evp(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_00110615;
    }
    if (iVar1 == 0x74) {
      local_20 = gen_publickey_from_dsa_evp(param_1,param_2,param_3,param_4,param_5,pkey);
      goto LAB_00110615;
    }
  }
  local_20 = _libssh2_error(param_1,0xfffffff0,
                            "Unable to extract public key from private key file: Unsupported private key file format"
                           );
LAB_00110615:
  EVP_PKEY_free(pkey);
  return (ulong)local_20;
}



void _libssh2_dh_init(undefined8 *param_1)

{
  BIGNUM *pBVar1;
  
  pBVar1 = BN_new();
  *param_1 = pBVar1;
  return;
}



undefined8
_libssh2_dh_key_pair
          (undefined8 *param_1,BIGNUM *param_2,BIGNUM *param_3,BIGNUM *param_4,int param_5,
          BN_CTX *param_6)

{
  BN_rand((BIGNUM *)*param_1,param_5 * 8 + -1,0,-1);
  BN_mod_exp(param_2,param_3,(BIGNUM *)*param_1,param_4,param_6);
  return 0;
}



undefined8
_libssh2_dh_secret(undefined8 *param_1,BIGNUM *param_2,BIGNUM *param_3,BIGNUM *param_4,
                  BN_CTX *param_5)

{
  BN_mod_exp(param_2,param_3,(BIGNUM *)*param_1,param_4,param_5);
  return 0;
}



void _libssh2_dh_dtor(undefined8 *param_1)

{
  BN_clear_free((BIGNUM *)*param_1);
  *param_1 = 0;
  return;
}



undefined8 agent_connect_unix(undefined8 *param_1)

{
  int iVar1;
  char *__src;
  undefined8 uVar2;
  long in_FS_OFFSET;
  sockaddr local_88 [6];
  undefined local_1b;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  __src = getenv("SSH_AUTH_SOCK");
  if (__src == (char *)0x0) {
    uVar2 = _libssh2_error(*param_1,0xffffffd9,"no auth sock variable");
  }
  else {
    iVar1 = socket(1,1,0);
    *(int *)(param_1 + 1) = iVar1;
    if (*(int *)(param_1 + 1) < 0) {
      uVar2 = _libssh2_error(*param_1,0xffffffd3,"failed creating socket");
    }
    else {
      local_88[0].sa_family = 1;
      strncpy(local_88[0].sa_data,__src,0x6c);
      local_1b = 0;
      iVar1 = connect(*(int *)(param_1 + 1),local_88,0x6e);
      if (iVar1 == 0) {
        uVar2 = 0;
      }
      else {
        close(*(int *)(param_1 + 1));
        uVar2 = _libssh2_error(*param_1,0xffffffd6,"failed connecting with agent");
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8 agent_transact_unix(long *param_1,undefined8 *param_2)

{
  int iVar1;
  uint uVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  undefined local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_2 + 4) == 1) {
    _libssh2_htonu32(local_14,param_2[1] & 0xffffffff);
    iVar1 = (**(code **)(*param_1 + 0x48))(*(undefined4 *)(param_1 + 1),local_14,4,0,*param_1);
    if (iVar1 == -0xb) {
      uVar3 = 0xffffffdb;
      goto LAB_00110b25;
    }
    if (iVar1 < 0) {
      uVar3 = _libssh2_error(*param_1,0xfffffff9,"agent send failed");
      goto LAB_00110b25;
    }
    *(undefined4 *)(param_2 + 4) = 2;
  }
  if (*(int *)(param_2 + 4) == 2) {
    iVar1 = (**(code **)(*param_1 + 0x48))
                      (*(undefined4 *)(param_1 + 1),*param_2,param_2[1],0,*param_1);
    if (iVar1 == -0xb) {
      uVar3 = 0xffffffdb;
      goto LAB_00110b25;
    }
    if (iVar1 < 0) {
      uVar3 = _libssh2_error(*param_1,0xfffffff9,"agent send failed");
      goto LAB_00110b25;
    }
    *(undefined4 *)(param_2 + 4) = 3;
  }
  if (*(int *)(param_2 + 4) == 3) {
    iVar1 = (**(code **)(*param_1 + 0x50))(*(undefined4 *)(param_1 + 1),local_14,4,0,*param_1);
    if (iVar1 < 0) {
      if (iVar1 == -0xb) {
        uVar3 = 0xffffffdb;
      }
      else {
        uVar3 = _libssh2_error(*param_1,0xffffffd5,"agent recv failed");
      }
      goto LAB_00110b25;
    }
    uVar2 = _libssh2_ntohu32(local_14);
    param_2[3] = (ulong)uVar2;
    uVar3 = (**(code **)(*param_1 + 8))(param_2[3],*param_1);
    param_2[2] = uVar3;
    if (param_2[2] == 0) {
      uVar3 = 0xfffffffa;
      goto LAB_00110b25;
    }
    *(undefined4 *)(param_2 + 4) = 4;
  }
  if (*(int *)(param_2 + 4) == 4) {
    iVar1 = (**(code **)(*param_1 + 0x50))
                      (*(undefined4 *)(param_1 + 1),param_2[2],param_2[3],0,*param_1);
    if (iVar1 < 0) {
      if (iVar1 == -0xb) {
        uVar3 = 0xffffffdb;
      }
      else {
        uVar3 = _libssh2_error(*param_1,0xfffffff9,"agent recv failed");
      }
      goto LAB_00110b25;
    }
    *(undefined4 *)(param_2 + 4) = 5;
  }
  uVar3 = 0;
LAB_00110b25:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



undefined8 agent_disconnect_unix(undefined8 *param_1)

{
  int iVar1;
  undefined8 uVar2;
  
  iVar1 = close(*(int *)(param_1 + 1));
  if (iVar1 == -1) {
    uVar2 = _libssh2_error(*param_1,0xfffffff3,"failed closing the agent socket");
  }
  else {
    *(undefined4 *)(param_1 + 1) = 0xffffffff;
    uVar2 = 0;
  }
  return uVar2;
}



void agent_sign(long param_1,long *param_2,size_t *param_3,undefined8 param_4,long param_5,
               long *param_6)

{
  char *pcVar1;
  uint uVar2;
  long lVar3;
  long in_FS_OFFSET;
  int local_44;
  char *local_40;
  long local_38;
  long *local_30;
  long local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = *param_6;
  local_30 = (long *)(local_38 + 0x18);
  local_28 = *(long *)(local_38 + 0x40);
  local_20 = param_5 + *(long *)(local_28 + 0x30) + 0xd;
  if (*(int *)(local_38 + 0x38) == 0) {
    lVar3 = (**(code **)(param_1 + 8))(local_20,param_1);
    *local_30 = lVar3;
    pcVar1 = (char *)*local_30;
    if (*local_30 == 0) {
      local_40 = pcVar1;
      _libssh2_error(param_1,0xfffffffa,"out of memory");
      goto LAB_00110f73;
    }
    local_40 = pcVar1 + 1;
    *pcVar1 = '\r';
    _libssh2_store_str(&local_40,*(undefined8 *)(local_28 + 0x28),*(undefined8 *)(local_28 + 0x30));
    _libssh2_store_str(&local_40,param_4,param_5);
    _libssh2_store_u32(&local_40,0);
    local_30[1] = (long)local_40 - *local_30;
    *(undefined4 *)(local_30 + 4) = 1;
  }
  if (*(char *)*local_30 == '\r') {
    if (*(long *)(local_38 + 0x10) == 0) {
      _libssh2_error(param_1,0xffffffd9,"agent not connected");
    }
    else {
      local_44 = (**(code **)(*(long *)(local_38 + 0x10) + 8))(local_38,local_30);
      if (local_44 == 0) {
        (**(code **)(param_1 + 0x18))(*local_30,param_1);
        *local_30 = 0;
        lVar3 = local_30[3];
        pcVar1 = (char *)local_30[2];
        local_20 = lVar3 + -1;
        local_40 = pcVar1;
        if (local_20 < 0) {
          local_44 = -0x2a;
        }
        else if (*pcVar1 == '\x0e') {
          local_40 = pcVar1 + 1;
          local_20 = lVar3 + -5;
          if (local_20 < 0) {
            local_44 = -0x2a;
          }
          else {
            local_40 = pcVar1 + 5;
            local_20 = lVar3 + -9;
            if (local_20 < 0) {
              local_44 = -0x2a;
            }
            else {
              uVar2 = _libssh2_ntohu32(local_40);
              local_18 = (ulong)uVar2;
              local_40 = local_40 + 4;
              local_20 = local_20 - local_18;
              if (local_20 < 0) {
                local_44 = -0x2a;
              }
              else {
                local_40 = local_40 + local_18;
                local_20 = local_20 + -4;
                if (local_20 < 0) {
                  local_44 = -0x2a;
                }
                else {
                  uVar2 = _libssh2_ntohu32(local_40);
                  *param_3 = (ulong)uVar2;
                  local_40 = local_40 + 4;
                  local_20 = local_20 - *param_3;
                  if (local_20 < 0) {
                    local_44 = -0x2a;
                  }
                  else {
                    lVar3 = (**(code **)(param_1 + 8))(*param_3,param_1);
                    *param_2 = lVar3;
                    if (*param_2 == 0) {
                      local_44 = -6;
                    }
                    else {
                      memcpy((void *)*param_2,local_40,*param_3);
                    }
                  }
                }
              }
            }
          }
        }
        else {
          local_44 = -0x2a;
        }
      }
      (**(code **)(param_1 + 0x18))(*local_30,param_1);
      *local_30 = 0;
      (**(code **)(param_1 + 0x18))(local_30[2],param_1);
      local_30[2] = 0;
      _libssh2_error(param_1,local_44,"agent sign failure");
    }
  }
  else {
    _libssh2_error(param_1,0xffffffd9,"illegal request");
  }
LAB_00110f73:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void agent_list_identities(long *param_1)

{
  ulong uVar1;
  uint uVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  bool bVar4;
  undefined local_45;
  int local_44;
  long local_40;
  ulong local_38;
  char *local_30;
  long *local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = param_1 + 3;
  local_45 = 0xb;
  if (*(int *)(param_1 + 7) == 0) {
    *local_28 = (long)&local_45;
    param_1[4] = 1;
    *(undefined4 *)(param_1 + 7) = 1;
  }
  if (*(char *)*local_28 == '\v') {
    if (param_1[2] == 0) {
      _libssh2_error(*param_1,0xffffffd9,"agent not connected");
    }
    else {
      local_44 = (**(code **)(param_1[2] + 8))(param_1,local_28);
      if (local_44 == 0) {
        *local_28 = 0;
        local_30 = (char *)local_28[2];
        local_40 = local_28[3] + -1;
        if (local_40 < 0) {
          local_44 = -0x2a;
        }
        else if (*local_30 == '\f') {
          local_30 = local_30 + 1;
          local_40 = local_28[3] + -5;
          if (local_40 < 0) {
            local_44 = -0x2a;
          }
          else {
            uVar2 = _libssh2_ntohu32(local_30);
            local_38 = (ulong)uVar2;
            local_30 = local_30 + 4;
            while (uVar1 = local_38 - 1, bVar4 = local_38 != 0, local_38 = uVar1, bVar4) {
              local_40 = local_40 + -4;
              if (local_40 < 0) {
                local_44 = -0x2a;
                break;
              }
              local_20 = (**(code **)(*param_1 + 8))(0x40,*param_1);
              if (local_20 == 0) {
                local_44 = -6;
                break;
              }
              uVar2 = _libssh2_ntohu32(local_30);
              *(ulong *)(local_20 + 0x30) = (ulong)uVar2;
              local_30 = local_30 + 4;
              local_40 = local_40 - *(long *)(local_20 + 0x30);
              if (local_40 < 0) {
                local_44 = -0x2a;
                (**(code **)(*param_1 + 0x18))(local_20,*param_1);
                break;
              }
              uVar3 = (**(code **)(*param_1 + 8))(*(undefined8 *)(local_20 + 0x30),*param_1);
              *(undefined8 *)(local_20 + 0x28) = uVar3;
              if (*(long *)(local_20 + 0x28) == 0) {
                local_44 = -6;
                (**(code **)(*param_1 + 0x18))(local_20,*param_1);
                break;
              }
              memcpy(*(void **)(local_20 + 0x28),local_30,*(size_t *)(local_20 + 0x30));
              local_30 = local_30 + *(long *)(local_20 + 0x30);
              local_40 = local_40 + -4;
              if (local_40 < 0) {
                local_44 = -0x2a;
                (**(code **)(*param_1 + 0x18))(*(undefined8 *)(local_20 + 0x28),*param_1);
                (**(code **)(*param_1 + 0x18))(local_20,*param_1);
                break;
              }
              uVar2 = _libssh2_ntohu32(local_30);
              local_18 = (ulong)uVar2;
              local_30 = local_30 + 4;
              local_40 = local_40 - local_18;
              if (local_40 < 0) {
                local_44 = -0x2a;
                (**(code **)(*param_1 + 0x18))(*(undefined8 *)(local_20 + 0x28),*param_1);
                (**(code **)(*param_1 + 0x18))(local_20,*param_1);
                break;
              }
              uVar3 = (**(code **)(*param_1 + 8))(local_18 + 1,*param_1);
              *(undefined8 *)(local_20 + 0x38) = uVar3;
              if (*(long *)(local_20 + 0x38) == 0) {
                local_44 = -6;
                (**(code **)(*param_1 + 0x18))(*(undefined8 *)(local_20 + 0x28),*param_1);
                (**(code **)(*param_1 + 0x18))(local_20,*param_1);
                break;
              }
              *(undefined *)(local_18 + *(long *)(local_20 + 0x38)) = 0;
              memcpy(*(void **)(local_20 + 0x38),local_30,local_18);
              local_30 = local_30 + local_18;
              _libssh2_list_add(param_1 + 9,local_20);
            }
          }
        }
        else {
          local_44 = -0x2a;
        }
      }
      (**(code **)(*param_1 + 0x18))(local_28[2],*param_1);
      local_28[2] = 0;
      _libssh2_error(*param_1,local_44,"agent list id failed");
    }
  }
  else {
    _libssh2_error(*param_1,0xffffffd9,"illegal agent request");
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void agent_free_identities(long *param_1)

{
  long lVar1;
  long local_18;
  
  local_18 = _libssh2_list_first(param_1 + 9);
  while (local_18 != 0) {
    lVar1 = _libssh2_list_next(local_18);
    (**(code **)(*param_1 + 0x18))(*(undefined8 *)(local_18 + 0x28),*param_1);
    (**(code **)(*param_1 + 0x18))(*(undefined8 *)(local_18 + 0x38),*param_1);
    (**(code **)(*param_1 + 0x18))(local_18,*param_1);
    local_18 = lVar1;
  }
  _libssh2_list_init(param_1 + 9);
  return;
}



undefined4 * agent_publickey_to_external(long param_1)

{
  *(undefined4 *)(param_1 + 0x18) = 0x3bdefed2;
  *(long *)(param_1 + 0x20) = param_1;
  return (undefined4 *)(param_1 + 0x18);
}



undefined8 * libssh2_agent_init(undefined8 param_1)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_libssh2_calloc(param_1,0x58);
  if (puVar1 == (undefined8 *)0x0) {
    _libssh2_error(param_1,0xfffffffa,"Unable to allocate space for agent connection");
    puVar1 = (undefined8 *)0x0;
  }
  else {
    *(undefined4 *)(puVar1 + 1) = 0xffffffff;
    *puVar1 = param_1;
    _libssh2_list_init(puVar1 + 9);
  }
  return puVar1;
}



int libssh2_agent_connect(long param_1)

{
  int local_10;
  int local_c;
  
  local_c = -1;
  local_10 = 0;
  while( true ) {
    if (*(long *)(supported_backends + (long)local_10 * 0x10) == 0) {
      return local_c;
    }
    *(undefined8 *)(param_1 + 0x10) =
         *(undefined8 *)(supported_backends + (long)local_10 * 0x10 + 8);
    local_c = (*(code *)**(undefined8 **)(param_1 + 0x10))(param_1);
    if (local_c == 0) break;
    local_10 = local_10 + 1;
  }
  return 0;
}



void libssh2_agent_list_identities(long param_1)

{
  memset((void *)(param_1 + 0x18),0,0x28);
  agent_free_identities(param_1);
  agent_list_identities(param_1);
  return;
}



bool libssh2_agent_get_identity(long param_1,undefined8 *param_2,long param_3)

{
  undefined8 uVar1;
  undefined8 local_18;
  
  if ((param_3 == 0) || (*(long *)(param_3 + 8) == 0)) {
    local_18 = _libssh2_list_first(param_1 + 0x48);
  }
  else {
    local_18 = _libssh2_list_next(*(undefined8 *)(param_3 + 8));
  }
  if (local_18 != 0) {
    uVar1 = agent_publickey_to_external(local_18);
    *param_2 = uVar1;
  }
  return local_18 == 0;
}



int libssh2_agent_userauth(long *param_1,char *param_2,long param_3)

{
  undefined8 uVar1;
  undefined8 uVar2;
  size_t sVar3;
  long in_FS_OFFSET;
  int local_34;
  long *local_30;
  time_t local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = param_1;
  if (*(int *)(*param_1 + 0xd138) == 0) {
    memset(param_1 + 3,0,0x28);
    param_1[8] = *(long *)(param_3 + 8);
  }
  local_28 = time((time_t *)0x0);
  do {
    uVar1 = *(undefined8 *)(param_3 + 0x18);
    uVar2 = *(undefined8 *)(param_3 + 0x10);
    sVar3 = strlen(param_2);
    local_34 = _libssh2_userauth_publickey
                         (*param_1,param_2,sVar3 & 0xffffffff,uVar2,uVar1,agent_sign,&local_30);
    if ((local_34 != -0x25) || (*(int *)(*param_1 + 0x94) == 0)) break;
    local_34 = _libssh2_wait_socket(*param_1,local_28);
  } while (local_34 == 0);
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_34;
}



undefined8 libssh2_agent_disconnect(long param_1)

{
  undefined8 uVar1;
  
  if ((*(long *)(param_1 + 0x10) == 0) || (*(int *)(param_1 + 8) == -1)) {
    uVar1 = 0;
  }
  else {
    uVar1 = (**(code **)(*(long *)(param_1 + 0x10) + 0x10))(param_1);
  }
  return uVar1;
}



void libssh2_agent_free(long *param_1)

{
  if (*(int *)(param_1 + 1) != -1) {
    libssh2_agent_disconnect(param_1);
  }
  agent_free_identities(param_1);
  (**(code **)(*param_1 + 0x18))(param_1,*param_1);
  return;
}



void bcrypt_hash(undefined8 param_1,undefined8 param_2,long param_3)

{
  undefined4 uVar1;
  long in_FS_OFFSET;
  undefined2 local_10b6;
  int local_10b4;
  ulong local_10b0;
  undefined4 local_10a8 [8];
  undefined local_1088 [4176];
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = 0x6d6f72686379784f;
  local_30 = 0x776f6c4263697461;
  local_28 = 0x7461775368736966;
  local_20 = 0x6574696d616e7944;
  local_10b0 = 0x40;
  Blowfish_initstate(local_1088);
  Blowfish_expandstate(local_1088,param_2,local_10b0 & 0xffff,param_1,local_10b0 & 0xffff);
  for (local_10b4 = 0; local_10b4 < 0x40; local_10b4 = local_10b4 + 1) {
    Blowfish_expand0state(local_1088,param_2,local_10b0 & 0xffff);
    Blowfish_expand0state(local_1088,param_1,local_10b0 & 0xffff);
  }
  local_10b6 = 0;
  for (local_10b4 = 0; local_10b4 < 8; local_10b4 = local_10b4 + 1) {
    uVar1 = Blowfish_stream2word(&local_38,0x20,&local_10b6);
    local_10a8[local_10b4] = uVar1;
  }
  for (local_10b4 = 0; local_10b4 < 0x40; local_10b4 = local_10b4 + 1) {
    blf_enc(local_1088,local_10a8,4);
  }
  for (local_10b4 = 0; local_10b4 < 8; local_10b4 = local_10b4 + 1) {
    *(char *)(param_3 + (long)(local_10b4 << 2) + 3) = (char)((uint)local_10a8[local_10b4] >> 0x18);
    *(char *)(param_3 + (long)(local_10b4 << 2) + 2) = (char)((uint)local_10a8[local_10b4] >> 0x10);
    *(char *)(param_3 + (long)(local_10b4 << 2) + 1) = (char)((uint)local_10a8[local_10b4] >> 8);
    *(char *)(param_3 + (local_10b4 << 2)) = (char)local_10a8[local_10b4];
  }
  _libssh2_explicit_zero(&local_38,0x20);
  _libssh2_explicit_zero(local_10a8,0x20);
  _libssh2_explicit_zero(local_1088,0x1048);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



undefined8
bcrypt_pbkdf(void *param_1,size_t param_2,void *param_3,ulong param_4,long param_5,ulong param_6,
            uint param_7)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  ulong local_158;
  int local_11c;
  EVP_MD_CTX *local_118;
  ulong local_110;
  ulong local_108;
  ulong local_100;
  ulong local_f8;
  void *local_f0;
  ulong local_e8;
  ulong local_e0;
  undefined8 local_d8;
  undefined8 local_d0;
  undefined8 local_c8;
  undefined8 local_c0;
  undefined8 local_b8;
  undefined8 local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  uchar local_98 [64];
  uchar local_58 [72];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_f8 = param_6;
  if (param_7 == 0) {
    uVar1 = 0xffffffff;
  }
  else if ((((param_2 == 0) || (param_4 == 0)) || (param_6 == 0)) ||
          ((0x400 < param_6 || (0x100000 < param_4)))) {
    uVar1 = 0xffffffff;
  }
  else {
    local_f0 = calloc(1,param_4 + 4);
    if (local_f0 == (void *)0x0) {
      uVar1 = 0xffffffff;
    }
    else {
      local_e8 = param_6 + 0x1f >> 5;
      local_100 = ((local_e8 + param_6) - 1) / local_e8;
      memcpy(local_f0,param_3,param_4);
      _libssh2_sha512_init(&local_118);
      EVP_DigestUpdate(local_118,param_1,param_2);
      EVP_DigestFinal(local_118,local_98,(uint *)0x0);
      EVP_MD_CTX_free(local_118);
      local_11c = 1;
      for (local_158 = param_6; local_158 != 0; local_158 = local_158 - local_110) {
        *(char *)(param_4 + (long)local_f0) = (char)((uint)local_11c >> 0x18);
        *(char *)((long)local_f0 + param_4 + 1) = (char)((uint)local_11c >> 0x10);
        *(char *)((long)local_f0 + param_4 + 2) = (char)((uint)local_11c >> 8);
        *(char *)((long)local_f0 + param_4 + 3) = (char)local_11c;
        _libssh2_sha512_init(&local_118);
        EVP_DigestUpdate(local_118,local_f0,param_4 + 4);
        EVP_DigestFinal(local_118,local_58,(uint *)0x0);
        EVP_MD_CTX_free(local_118);
        bcrypt_hash(local_98,local_58,&local_b8);
        local_d8 = local_b8;
        local_d0 = local_b0;
        local_c8 = local_a8;
        local_c0 = local_a0;
        for (local_110 = 1; local_110 < param_7; local_110 = local_110 + 1) {
          _libssh2_sha512_init(&local_118);
          EVP_DigestUpdate(local_118,&local_b8,0x20);
          EVP_DigestFinal(local_118,local_58,(uint *)0x0);
          EVP_MD_CTX_free(local_118);
          bcrypt_hash(local_98,local_58,&local_b8);
          for (local_108 = 0; local_108 < 0x20; local_108 = local_108 + 1) {
            *(byte *)((long)&local_d8 + local_108) =
                 *(byte *)((long)&local_d8 + local_108) ^ *(byte *)((long)&local_b8 + local_108);
          }
        }
        if (local_158 <= local_100) {
          local_100 = local_158;
        }
        for (local_110 = 0;
            (local_110 < local_100 &&
            (local_e0 = local_110 * local_e8 + (ulong)(local_11c - 1), local_e0 < local_f8));
            local_110 = local_110 + 1) {
          *(undefined *)(param_5 + local_e0) = *(undefined *)((long)&local_d8 + local_110);
        }
        local_11c = local_11c + 1;
      }
      _libssh2_explicit_zero(&local_d8,0x20);
      free(local_f0);
      uVar1 = 0;
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void Blowfish_encipher(long param_1,uint *param_2,uint *param_3)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  
  uVar1 = *param_2 ^ *(uint *)(param_1 + 0x1000);
  uVar2 = *param_3 ^
          *(uint *)(param_1 + 0x1004) ^
          (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
           *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
          *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
          *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1008) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x100c) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1010) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1014) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1018) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x101c) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1020) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1024) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1028) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x102c) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1030) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1034) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1038) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x103c) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  iVar3 = *(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4);
  iVar4 = *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4);
  uVar5 = *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4);
  iVar6 = *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar7 = *(uint *)(param_1 + 0x1040);
  *param_2 = *(uint *)(param_1 + 0x1044) ^ uVar2;
  *param_3 = uVar1 ^ uVar7 ^ (iVar3 + iVar4 ^ uVar5) + iVar6;
  return;
}



void Blowfish_decipher(long param_1,uint *param_2,uint *param_3)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  
  uVar1 = *param_2 ^ *(uint *)(param_1 + 0x1044);
  uVar2 = *param_3 ^
          *(uint *)(param_1 + 0x1040) ^
          (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
           *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
          *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
          *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x103c) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1038) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1034) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1030) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x102c) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1028) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1024) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1020) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x101c) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1018) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x1014) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1010) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  uVar1 = uVar1 ^ *(uint *)(param_1 + 0x100c) ^
                  (*(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar2 = uVar2 ^ *(uint *)(param_1 + 0x1008) ^
                  (*(int *)(param_1 + (ulong)(uVar1 >> 0x18) * 4) +
                   *(int *)(param_1 + (ulong)((uVar1 >> 0x10 & 0xff) + 0x100) * 4) ^
                  *(uint *)(param_1 + (ulong)((uVar1 >> 8 & 0xff) + 0x200) * 4)) +
                  *(int *)(param_1 + (ulong)((uVar1 & 0xff) + 0x300) * 4);
  iVar3 = *(int *)(param_1 + (ulong)(uVar2 >> 0x18) * 4);
  iVar4 = *(int *)(param_1 + (ulong)((uVar2 >> 0x10 & 0xff) + 0x100) * 4);
  uVar5 = *(uint *)(param_1 + (ulong)((uVar2 >> 8 & 0xff) + 0x200) * 4);
  iVar6 = *(int *)(param_1 + (ulong)((uVar2 & 0xff) + 0x300) * 4);
  uVar7 = *(uint *)(param_1 + 0x1004);
  *param_2 = *(uint *)(param_1 + 0x1000) ^ uVar2;
  *param_3 = uVar1 ^ uVar7 ^ (iVar3 + iVar4 ^ uVar5) + iVar6;
  return;
}



void Blowfish_initstate(undefined8 *param_1)

{
  ulong uVar1;
  long lVar2;
  undefined8 *puVar3;
  undefined8 *puVar4;
  
  *param_1 = 0x98dfb5acd1310ba6;
  param_1[0x208] = 0x8979fb1b9216d5d9;
  lVar2 = (long)param_1 - (long)((ulong)(param_1 + 1) & 0xfffffffffffffff8);
  puVar3 = (undefined8 *)((long)&initstate_3017 - lVar2);
  puVar4 = (undefined8 *)((ulong)(param_1 + 1) & 0xfffffffffffffff8);
  for (uVar1 = (ulong)((int)lVar2 + 0x1048U >> 3); uVar1 != 0; uVar1 = uVar1 - 1) {
    *puVar4 = *puVar3;
    puVar3 = puVar3 + 1;
    puVar4 = puVar4 + 1;
  }
  return;
}



uint Blowfish_stream2word(long param_1,ushort param_2,ushort *param_3)

{
  undefined local_f;
  undefined2 local_e;
  undefined4 local_c;
  
  local_c = 0;
  local_e = *param_3;
  for (local_f = 0; local_f < 4; local_f = local_f + 1) {
    if (param_2 <= local_e) {
      local_e = 0;
    }
    local_c = (uint)*(byte *)(param_1 + (ulong)local_e) | local_c << 8;
    local_e = local_e + 1;
  }
  *param_3 = local_e;
  return local_c;
}



void Blowfish_expand0state(long param_1,undefined8 param_2,undefined2 param_3)

{
  long in_FS_OFFSET;
  undefined2 local_22;
  ushort local_20;
  ushort local_1e;
  undefined4 local_1c;
  undefined4 local_18;
  uint local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_22 = 0;
  for (local_20 = 0; local_20 < 0x12; local_20 = local_20 + 1) {
    local_14 = Blowfish_stream2word(param_2,param_3,&local_22);
    *(uint *)(param_1 + ((long)(int)(uint)local_20 + 0x400) * 4) =
         *(uint *)(param_1 + ((long)(int)(uint)local_20 + 0x400) * 4) ^ local_14;
  }
  local_22 = 0;
  local_1c = 0;
  local_18 = 0;
  for (local_20 = 0; local_20 < 0x12; local_20 = local_20 + 2) {
    Blowfish_encipher(param_1,&local_1c,&local_18);
    *(undefined4 *)(param_1 + ((long)(int)(uint)local_20 + 0x400) * 4) = local_1c;
    *(undefined4 *)(param_1 + ((long)(int)(local_20 + 1) + 0x400) * 4) = local_18;
  }
  for (local_20 = 0; local_20 < 4; local_20 = local_20 + 1) {
    for (local_1e = 0; local_1e < 0x100; local_1e = local_1e + 2) {
      Blowfish_encipher(param_1,&local_1c,&local_18);
      *(undefined4 *)(param_1 + ((long)(int)(uint)local_1e + (long)(int)(uint)local_20 * 0x100) * 4)
           = local_1c;
      *(undefined4 *)(param_1 + ((long)(int)(local_1e + 1) + (long)(int)(uint)local_20 * 0x100) * 4)
           = local_18;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void Blowfish_expandstate
               (long param_1,undefined8 param_2,undefined2 param_3,undefined8 param_4,
               undefined2 param_5)

{
  uint uVar1;
  long in_FS_OFFSET;
  undefined2 local_22;
  ushort local_20;
  ushort local_1e;
  uint local_1c;
  uint local_18;
  uint local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_22 = 0;
  for (local_20 = 0; local_20 < 0x12; local_20 = local_20 + 1) {
    local_14 = Blowfish_stream2word(param_4,param_5,&local_22);
    *(uint *)(param_1 + ((long)(int)(uint)local_20 + 0x400) * 4) =
         *(uint *)(param_1 + ((long)(int)(uint)local_20 + 0x400) * 4) ^ local_14;
  }
  local_22 = 0;
  local_1c = 0;
  local_18 = 0;
  for (local_20 = 0; local_20 < 0x12; local_20 = local_20 + 2) {
    uVar1 = Blowfish_stream2word(param_2,param_3,&local_22);
    local_1c = uVar1 ^ local_1c;
    uVar1 = Blowfish_stream2word(param_2,param_3,&local_22);
    local_18 = uVar1 ^ local_18;
    Blowfish_encipher(param_1,&local_1c,&local_18);
    *(uint *)(param_1 + ((long)(int)(uint)local_20 + 0x400) * 4) = local_1c;
    *(uint *)(param_1 + ((long)(int)(local_20 + 1) + 0x400) * 4) = local_18;
  }
  for (local_20 = 0; local_20 < 4; local_20 = local_20 + 1) {
    for (local_1e = 0; local_1e < 0x100; local_1e = local_1e + 2) {
      uVar1 = Blowfish_stream2word(param_2,param_3,&local_22);
      local_1c = uVar1 ^ local_1c;
      uVar1 = Blowfish_stream2word(param_2,param_3,&local_22);
      local_18 = uVar1 ^ local_18;
      Blowfish_encipher(param_1,&local_1c,&local_18);
      *(uint *)(param_1 + ((long)(int)(uint)local_1e + (long)(int)(uint)local_20 * 0x100) * 4) =
           local_1c;
      *(uint *)(param_1 + ((long)(int)(local_1e + 1) + (long)(int)(uint)local_20 * 0x100) * 4) =
           local_18;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void blf_key(undefined8 param_1,undefined8 param_2,undefined2 param_3)

{
  Blowfish_initstate(param_1);
  Blowfish_expand0state(param_1,param_2,param_3);
  return;
}



void blf_enc(undefined8 param_1,long param_2,ushort param_3)

{
  undefined2 local_12;
  undefined8 local_10;
  
  local_10 = param_2;
  for (local_12 = 0; local_12 < param_3; local_12 = local_12 + 1) {
    Blowfish_encipher(param_1,local_10,local_10 + 4);
    local_10 = local_10 + 8;
  }
  return;
}



void blf_dec(undefined8 param_1,long param_2,ushort param_3)

{
  undefined2 local_12;
  undefined8 local_10;
  
  local_10 = param_2;
  for (local_12 = 0; local_12 < param_3; local_12 = local_12 + 1) {
    Blowfish_decipher(param_1,local_10,local_10 + 4);
    local_10 = local_10 + 8;
  }
  return;
}



void blf_ecb_encrypt(undefined8 param_1,byte *param_2,uint param_3)

{
  long in_FS_OFFSET;
  byte *local_38;
  uint local_1c;
  uint local_18;
  uint local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = param_2;
  for (local_14 = 0; local_14 < param_3; local_14 = local_14 + 8) {
    local_1c = (uint)local_38[3] |
               (uint)*local_38 << 0x18 | (uint)local_38[1] << 0x10 | (uint)local_38[2] << 8;
    local_18 = (uint)local_38[7] |
               (uint)local_38[4] << 0x18 | (uint)local_38[5] << 0x10 | (uint)local_38[6] << 8;
    Blowfish_encipher(param_1,&local_1c,&local_18);
    *local_38 = (byte)(local_1c >> 0x18);
    local_38[1] = (byte)(local_1c >> 0x10);
    local_38[2] = (byte)(local_1c >> 8);
    local_38[3] = (byte)local_1c;
    local_38[4] = (byte)(local_18 >> 0x18);
    local_38[5] = (byte)(local_18 >> 0x10);
    local_38[6] = (byte)(local_18 >> 8);
    local_38[7] = (byte)local_18;
    local_38 = local_38 + 8;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void blf_ecb_decrypt(undefined8 param_1,byte *param_2,uint param_3)

{
  long in_FS_OFFSET;
  byte *local_38;
  uint local_1c;
  uint local_18;
  uint local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = param_2;
  for (local_14 = 0; local_14 < param_3; local_14 = local_14 + 8) {
    local_1c = (uint)local_38[3] |
               (uint)*local_38 << 0x18 | (uint)local_38[1] << 0x10 | (uint)local_38[2] << 8;
    local_18 = (uint)local_38[7] |
               (uint)local_38[4] << 0x18 | (uint)local_38[5] << 0x10 | (uint)local_38[6] << 8;
    Blowfish_decipher(param_1,&local_1c,&local_18);
    *local_38 = (byte)(local_1c >> 0x18);
    local_38[1] = (byte)(local_1c >> 0x10);
    local_38[2] = (byte)(local_1c >> 8);
    local_38[3] = (byte)local_1c;
    local_38[4] = (byte)(local_18 >> 0x18);
    local_38[5] = (byte)(local_18 >> 0x10);
    local_38[6] = (byte)(local_18 >> 8);
    local_38[7] = (byte)local_18;
    local_38 = local_38 + 8;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void blf_cbc_encrypt(undefined8 param_1,byte *param_2,byte *param_3,uint param_4)

{
  long in_FS_OFFSET;
  byte *local_40;
  byte *local_38;
  uint local_20;
  uint local_1c;
  uint local_18;
  uint local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = param_3;
  local_38 = param_2;
  for (local_18 = 0; local_18 < param_4; local_18 = local_18 + 8) {
    for (local_14 = 0; local_14 < 8; local_14 = local_14 + 1) {
      local_40[local_14] = local_40[local_14] ^ local_38[local_14];
    }
    local_20 = (uint)local_40[3] |
               (uint)*local_40 << 0x18 | (uint)local_40[1] << 0x10 | (uint)local_40[2] << 8;
    local_1c = (uint)local_40[7] |
               (uint)local_40[4] << 0x18 | (uint)local_40[5] << 0x10 | (uint)local_40[6] << 8;
    Blowfish_encipher(param_1,&local_20,&local_1c);
    *local_40 = (byte)(local_20 >> 0x18);
    local_40[1] = (byte)(local_20 >> 0x10);
    local_40[2] = (byte)(local_20 >> 8);
    local_40[3] = (byte)local_20;
    local_40[4] = (byte)(local_1c >> 0x18);
    local_40[5] = (byte)(local_1c >> 0x10);
    local_40[6] = (byte)(local_1c >> 8);
    local_40[7] = (byte)local_1c;
    local_38 = local_40;
    local_40 = local_40 + 8;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void blf_cbc_decrypt(undefined8 param_1,long param_2,long param_3,uint param_4)

{
  long in_FS_OFFSET;
  byte *local_40;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = param_3 + ((ulong)param_4 - 0x10);
  local_40 = (byte *)(param_3 + ((ulong)param_4 - 8));
  for (local_20 = param_4 - 8; 7 < local_20; local_20 = local_20 - 8) {
    local_28 = (uint)local_40[3] |
               (uint)*local_40 << 0x18 | (uint)local_40[1] << 0x10 | (uint)local_40[2] << 8;
    local_24 = (uint)local_40[7] |
               (uint)local_40[4] << 0x18 | (uint)local_40[5] << 0x10 | (uint)local_40[6] << 8;
    Blowfish_decipher(param_1,&local_28,&local_24);
    *local_40 = (byte)(local_28 >> 0x18);
    local_40[1] = (byte)(local_28 >> 0x10);
    local_40[2] = (byte)(local_28 >> 8);
    local_40[3] = (byte)local_28;
    local_40[4] = (byte)(local_24 >> 0x18);
    local_40[5] = (byte)(local_24 >> 0x10);
    local_40[6] = (byte)(local_24 >> 8);
    local_40[7] = (byte)local_24;
    for (local_1c = 0; local_1c < 8; local_1c = local_1c + 1) {
      local_40[local_1c] = local_40[local_1c] ^ *(byte *)(local_18 + (ulong)local_1c);
    }
    local_18 = local_18 + -8;
    local_40 = local_40 + -8;
  }
  local_28 = (uint)local_40[3] |
             (uint)*local_40 << 0x18 | (uint)local_40[1] << 0x10 | (uint)local_40[2] << 8;
  local_24 = (uint)local_40[7] |
             (uint)local_40[4] << 0x18 | (uint)local_40[5] << 0x10 | (uint)local_40[6] << 8;
  Blowfish_decipher(param_1,&local_28,&local_24);
  *local_40 = (byte)(local_28 >> 0x18);
  local_40[1] = (byte)(local_28 >> 0x10);
  local_40[2] = (byte)(local_28 >> 8);
  local_40[3] = (byte)local_28;
  local_40[4] = (byte)(local_24 >> 0x18);
  local_40[5] = (byte)(local_24 >> 0x10);
  local_40[6] = (byte)(local_24 >> 8);
  local_40[7] = (byte)local_24;
  for (local_1c = 0; local_1c < 8; local_1c = local_1c + 1) {
    local_40[local_1c] = local_40[local_1c] ^ *(byte *)(param_2 + (ulong)local_1c);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



uint _libssh2_channel_nextid(long param_1)

{
  undefined4 local_14;
  undefined8 local_10;
  
  local_14 = *(uint *)(param_1 + 0x210);
  for (local_10 = _libssh2_list_first(param_1 + 0x200); local_10 != 0;
      local_10 = _libssh2_list_next(local_10)) {
    if (local_14 < *(uint *)(local_10 + 0x30)) {
      local_14 = *(uint *)(local_10 + 0x30);
    }
  }
  *(uint *)(param_1 + 0x210) = local_14 + 1;
  return local_14;
}



long _libssh2_channel_locate(long param_1,int param_2)

{
  long local_18;
  long local_10;
  
  for (local_18 = _libssh2_list_first(param_1 + 0x200); local_18 != 0;
      local_18 = _libssh2_list_next(local_18)) {
    if (param_2 == *(int *)(local_18 + 0x30)) {
      return local_18;
    }
  }
  local_10 = _libssh2_list_first(param_1 + 0x218);
  do {
    if (local_10 == 0) {
      return 0;
    }
    for (local_18 = _libssh2_list_first(local_10 + 0x30); local_18 != 0;
        local_18 = _libssh2_list_next(local_18)) {
      if (param_2 == *(int *)(local_18 + 0x30)) {
        return local_18;
      }
    }
    local_10 = _libssh2_list_next(local_10);
  } while( true );
}



undefined8
_libssh2_channel_open
          (long param_1,void *param_2,uint param_3,undefined4 param_4,undefined4 param_5,
          undefined8 param_6,undefined8 param_7)

{
  long lVar1;
  undefined *puVar2;
  undefined4 uVar3;
  uint uVar4;
  int iVar5;
  undefined8 uVar6;
  long in_FS_OFFSET;
  undefined *local_30;
  undefined local_24 [4];
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd1f0) == 0) {
    *(undefined8 *)(param_1 + 0xd200) = 0;
    *(undefined8 *)(param_1 + 0xd208) = 0;
    *(undefined8 *)(param_1 + 0xd218) = 0;
    *(ulong *)(param_1 + 0xd210) = (ulong)(param_3 + 0x11);
    uVar3 = _libssh2_channel_nextid(param_1);
    *(undefined4 *)(param_1 + 0xd228) = uVar3;
    memset((void *)(param_1 + 0xd1f8),0,8);
    uVar6 = _libssh2_calloc(param_1,0x2b0);
    *(undefined8 *)(param_1 + 0xd200) = uVar6;
    if (*(long *)(param_1 + 0xd200) == 0) {
      _libssh2_error(param_1,0xfffffffa,"Unable to allocate space for channel data");
      uVar6 = 0;
      goto LAB_00114b04;
    }
    *(uint *)(*(long *)(param_1 + 0xd200) + 0x20) = param_3;
    lVar1 = *(long *)(param_1 + 0xd200);
    uVar6 = (**(code **)(param_1 + 8))(param_3,param_1);
    *(undefined8 *)(lVar1 + 0x18) = uVar6;
    if (*(long *)(*(long *)(param_1 + 0xd200) + 0x18) == 0) {
      _libssh2_error(param_1,0xfffffffa,"Failed allocating memory for channel type name");
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd200),param_1);
      *(undefined8 *)(param_1 + 0xd200) = 0;
      uVar6 = 0;
      goto LAB_00114b04;
    }
    memcpy(*(void **)(*(long *)(param_1 + 0xd200) + 0x18),param_2,(ulong)param_3);
    *(undefined4 *)(*(long *)(param_1 + 0xd200) + 0x30) = *(undefined4 *)(param_1 + 0xd228);
    *(undefined4 *)(*(long *)(param_1 + 0xd200) + 0x4c) = param_4;
    *(undefined4 *)(*(long *)(param_1 + 0xd200) + 0x48) = param_4;
    *(undefined4 *)(*(long *)(param_1 + 0xd200) + 0x50) = param_5;
    *(long *)(*(long *)(param_1 + 0xd200) + 0x60) = param_1;
    _libssh2_list_add(param_1 + 0x200,*(undefined8 *)(param_1 + 0xd200));
    uVar6 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_1 + 0xd210),param_1);
    *(undefined8 *)(param_1 + 0xd208) = uVar6;
    puVar2 = *(undefined **)(param_1 + 0xd208);
    if (*(long *)(param_1 + 0xd208) != 0) {
      local_30 = puVar2 + 1;
      *puVar2 = 0x5a;
      _libssh2_store_str(&local_30,param_2,param_3);
      _libssh2_store_u32(&local_30,*(undefined4 *)(param_1 + 0xd228));
      _libssh2_store_u32(&local_30,param_4);
      _libssh2_store_u32(&local_30,param_5);
      *(undefined4 *)(param_1 + 0xd1f0) = 2;
      goto LAB_001145ea;
    }
    local_30 = puVar2;
    _libssh2_error(param_1,0xfffffffa,"Unable to allocate temporary space for packet");
  }
  else {
LAB_001145ea:
    if (*(int *)(param_1 + 0xd1f0) == 2) {
      iVar5 = _libssh2_transport_send
                        (param_1,*(undefined8 *)(param_1 + 0xd208),*(undefined8 *)(param_1 + 0xd210)
                         ,param_6,param_7);
      if (iVar5 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block sending channel-open request");
        uVar6 = 0;
        goto LAB_00114b04;
      }
      if (iVar5 != 0) {
        _libssh2_error(param_1,iVar5,"Unable to send channel-open request");
        goto LAB_00114929;
      }
      *(undefined4 *)(param_1 + 0xd1f0) = 3;
    }
    if (*(int *)(param_1 + 0xd1f0) == 3) {
      iVar5 = _libssh2_packet_requirev
                        (param_1,&reply_codes_20197,param_1 + 0xd218,param_1 + 0xd220,1,
                         *(long *)(param_1 + 0xd208) + (ulong)param_3 + 5,4,param_1 + 0xd1f8);
      if (iVar5 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block");
        uVar6 = 0;
        goto LAB_00114b04;
      }
      if (iVar5 == 0) {
        if (**(char **)(param_1 + 0xd218) == '[') {
          lVar1 = *(long *)(param_1 + 0xd200);
          uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd218) + 5);
          *(undefined4 *)(lVar1 + 0x44) = uVar3;
          lVar1 = *(long *)(param_1 + 0xd200);
          uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd218) + 9);
          *(undefined4 *)(lVar1 + 0x38) = uVar3;
          lVar1 = *(long *)(param_1 + 0xd200);
          uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd218) + 9);
          *(undefined4 *)(lVar1 + 0x34) = uVar3;
          lVar1 = *(long *)(param_1 + 0xd200);
          uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd218) + 0xd);
          *(undefined4 *)(lVar1 + 0x3c) = uVar3;
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd208),param_1);
          *(undefined8 *)(param_1 + 0xd208) = 0;
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd218),param_1);
          *(undefined8 *)(param_1 + 0xd218) = 0;
          *(undefined4 *)(param_1 + 0xd1f0) = 0;
          uVar6 = *(undefined8 *)(param_1 + 0xd200);
          goto LAB_00114b04;
        }
        if (**(char **)(param_1 + 0xd218) == '\\') {
          uVar4 = _libssh2_ntohu32(*(long *)(param_1 + 0xd218) + 5);
          if (uVar4 == 4) {
            _libssh2_error(param_1,0xffffffeb,"Channel open failure (resource shortage)");
          }
          else if (uVar4 < 5) {
            if (uVar4 == 3) {
              _libssh2_error(param_1,0xffffffeb,"Channel open failure (unknown channel type)");
            }
            else {
              if (3 < uVar4) goto LAB_0011490b;
              if (uVar4 == 1) {
                _libssh2_error(param_1,0xffffffeb,
                               "Channel open failure (administratively prohibited)");
              }
              else {
                if (uVar4 != 2) goto LAB_0011490b;
                _libssh2_error(param_1,0xffffffeb,"Channel open failure (connect failed)");
              }
            }
          }
          else {
LAB_0011490b:
            _libssh2_error(param_1,0xffffffeb,"Channel open failure");
          }
        }
      }
    }
  }
LAB_00114929:
  if (*(long *)(param_1 + 0xd218) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd218),param_1);
    *(undefined8 *)(param_1 + 0xd218) = 0;
  }
  if (*(long *)(param_1 + 0xd208) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd208),param_1);
    *(undefined8 *)(param_1 + 0xd208) = 0;
  }
  if (*(long *)(param_1 + 0xd200) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(*(long *)(param_1 + 0xd200) + 0x18),param_1);
    _libssh2_list_remove(*(undefined8 *)(param_1 + 0xd200));
    _libssh2_htonu32(local_24,*(undefined4 *)(*(long *)(param_1 + 0xd200) + 0x30));
    while ((iVar5 = _libssh2_packet_ask(param_1,0x5e,param_1 + 0xd218,param_1 + 0xd220,1,local_24,4)
           , -1 < iVar5 ||
           (iVar5 = _libssh2_packet_ask(param_1,0x5f,param_1 + 0xd218,param_1 + 0xd220,1,local_24,4)
           , -1 < iVar5))) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd218),param_1);
      *(undefined8 *)(param_1 + 0xd218) = 0;
    }
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd200),param_1);
    *(undefined8 *)(param_1 + 0xd200) = 0;
  }
  *(undefined4 *)(param_1 + 0xd1f0) = 0;
  uVar6 = 0;
LAB_00114b04:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



long libssh2_channel_open_ex
               (long param_1,undefined8 param_2,undefined4 param_3,undefined4 param_4,
               undefined4 param_5,undefined8 param_6,undefined4 param_7)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  if (param_1 != 0) {
    tVar2 = time((time_t *)0x0);
    do {
      lVar3 = _libssh2_channel_open(param_1,param_2,param_3,param_4,param_5,param_6,param_7);
      if (*(int *)(param_1 + 0x94) == 0) {
        return lVar3;
      }
      if (lVar3 != 0) {
        return lVar3;
      }
      iVar1 = libssh2_session_last_errno(param_1);
      if (iVar1 != -0x25) {
        return 0;
      }
      iVar1 = _libssh2_wait_socket(param_1,tVar2);
    } while (iVar1 == 0);
  }
  return 0;
}



long channel_direct_tcpip
               (long param_1,char *param_2,undefined4 param_3,char *param_4,undefined4 param_5)

{
  int iVar1;
  size_t sVar2;
  undefined8 uVar3;
  long lVar4;
  long in_FS_OFFSET;
  undefined8 local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd22c) == 0) {
    sVar2 = strlen(param_2);
    *(size_t *)(param_1 + 0xd238) = sVar2;
    sVar2 = strlen(param_4);
    *(size_t *)(param_1 + 0xd240) = sVar2;
    *(long *)(param_1 + 0xd248) = *(long *)(param_1 + 0xd240) + *(long *)(param_1 + 0xd238) + 0x10;
    uVar3 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_1 + 0xd248),param_1);
    *(undefined8 *)(param_1 + 0xd230) = uVar3;
    local_20 = *(undefined8 *)(param_1 + 0xd230);
    if (*(long *)(param_1 + 0xd230) == 0) {
      _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for direct-tcpip connection");
      lVar4 = 0;
      goto LAB_00114dea;
    }
    _libssh2_store_str(&local_20,param_2,*(undefined8 *)(param_1 + 0xd238));
    _libssh2_store_u32(&local_20,param_3);
    _libssh2_store_str(&local_20,param_4,*(undefined8 *)(param_1 + 0xd240));
    _libssh2_store_u32(&local_20,param_5);
  }
  local_18 = _libssh2_channel_open
                       (param_1,"direct-tcpip",0xc,0x200000,0x8000,*(undefined8 *)(param_1 + 0xd230)
                        ,*(undefined8 *)(param_1 + 0xd248));
  if (local_18 == 0) {
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 == -0x25) {
      *(undefined4 *)(param_1 + 0xd22c) = 2;
      lVar4 = 0;
      goto LAB_00114dea;
    }
  }
  *(undefined4 *)(param_1 + 0xd22c) = 0;
  (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd230),param_1);
  *(undefined8 *)(param_1 + 0xd230) = 0;
  lVar4 = local_18;
LAB_00114dea:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar4;
}



long libssh2_channel_direct_tcpip_ex
               (long param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,
               undefined4 param_5)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  if (param_1 != 0) {
    tVar2 = time((time_t *)0x0);
    do {
      lVar3 = channel_direct_tcpip(param_1,param_2,param_3,param_4,param_5);
      if (*(int *)(param_1 + 0x94) == 0) {
        return lVar3;
      }
      if (lVar3 != 0) {
        return lVar3;
      }
      iVar1 = libssh2_session_last_errno(param_1);
      if (iVar1 != -0x25) {
        return 0;
      }
      iVar1 = _libssh2_wait_socket(param_1,tVar2);
    } while (iVar1 == 0);
  }
  return 0;
}



long channel_forward_listen
               (long param_1,char *param_2,int param_3,undefined4 *param_4,undefined4 param_5)

{
  undefined *puVar1;
  int iVar2;
  undefined4 uVar3;
  size_t sVar4;
  undefined8 uVar5;
  long lVar6;
  long in_FS_OFFSET;
  char *local_48;
  undefined *local_30;
  char *local_28;
  ulong local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_48 = param_2;
  if (param_2 == (char *)0x0) {
    local_48 = "0.0.0.0";
  }
  if (*(int *)(param_1 + 0xd250) == 0) {
    sVar4 = strlen(local_48);
    *(int *)(param_1 + 0xd260) = (int)sVar4;
    *(int *)(param_1 + 0xd264) = *(int *)(param_1 + 0xd260) + 0x1b;
    memset((void *)(param_1 + 0xd268),0,8);
    uVar5 = (**(code **)(param_1 + 8))(*(undefined4 *)(param_1 + 0xd264),param_1);
    *(undefined8 *)(param_1 + 0xd258) = uVar5;
    puVar1 = *(undefined **)(param_1 + 0xd258);
    if (*(long *)(param_1 + 0xd258) == 0) {
      local_30 = puVar1;
      _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for setenv packet");
      lVar6 = 0;
      goto LAB_001153e7;
    }
    local_30 = puVar1 + 1;
    *puVar1 = 0x50;
    _libssh2_store_str(&local_30,"tcpip-forward",0xd);
    *local_30 = 1;
    local_30 = local_30 + 1;
    _libssh2_store_str(&local_30,local_48,*(undefined4 *)(param_1 + 0xd260));
    _libssh2_store_u32(&local_30,param_3);
    *(undefined4 *)(param_1 + 0xd250) = 2;
  }
  if (*(int *)(param_1 + 0xd250) == 2) {
    iVar2 = _libssh2_transport_send
                      (param_1,*(undefined8 *)(param_1 + 0xd258),*(undefined4 *)(param_1 + 0xd264),0
                       ,0);
    if (iVar2 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,
                     "Would block sending global-request packet for forward listen request");
      lVar6 = 0;
      goto LAB_001153e7;
    }
    if (iVar2 != 0) {
      _libssh2_error(param_1,0xfffffff9,
                     "Unable to send global-request packet for forward listen request");
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd258),param_1);
      *(undefined8 *)(param_1 + 0xd258) = 0;
      *(undefined4 *)(param_1 + 0xd250) = 0;
      lVar6 = 0;
      goto LAB_001153e7;
    }
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd258),param_1);
    *(undefined8 *)(param_1 + 0xd258) = 0;
    *(undefined4 *)(param_1 + 0xd250) = 3;
  }
  if (*(int *)(param_1 + 0xd250) == 3) {
    iVar2 = _libssh2_packet_requirev
                      (param_1,&reply_codes_20255,&local_28,&local_20,0,0,0,param_1 + 0xd268);
    if (iVar2 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block");
      lVar6 = 0;
      goto LAB_001153e7;
    }
    if (iVar2 != 0) {
      _libssh2_error(param_1,0xfffffff2,"Unknown");
      *(undefined4 *)(param_1 + 0xd250) = 0;
      lVar6 = 0;
      goto LAB_001153e7;
    }
    if (*local_28 == 'Q') {
      local_18 = _libssh2_calloc(param_1,0x60);
      if (local_18 == 0) {
        _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for listener queue");
      }
      else {
        uVar5 = (**(code **)(param_1 + 8))(*(int *)(param_1 + 0xd260) + 1,param_1);
        *(undefined8 *)(local_18 + 0x20) = uVar5;
        if (*(long *)(local_18 + 0x20) == 0) {
          _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for listener queue");
          (**(code **)(param_1 + 0x18))(local_18,param_1);
          local_18 = 0;
        }
        else {
          *(long *)(local_18 + 0x18) = param_1;
          memcpy(*(void **)(local_18 + 0x20),local_48,(ulong)*(uint *)(param_1 + 0xd260));
          *(undefined *)((ulong)*(uint *)(param_1 + 0xd260) + *(long *)(local_18 + 0x20)) = 0;
          if ((local_20 < 5) || (param_3 != 0)) {
            *(int *)(local_18 + 0x28) = param_3;
          }
          else {
            uVar3 = _libssh2_ntohu32(local_28 + 1);
            *(undefined4 *)(local_18 + 0x28) = uVar3;
          }
          *(undefined4 *)(local_18 + 0x40) = 0;
          *(undefined4 *)(local_18 + 0x44) = param_5;
          _libssh2_list_add(param_1 + 0x218,local_18);
          if (param_4 != (undefined4 *)0x0) {
            *param_4 = *(undefined4 *)(local_18 + 0x28);
          }
        }
      }
      (**(code **)(param_1 + 0x18))(local_28,param_1);
      *(undefined4 *)(param_1 + 0xd250) = 0;
      lVar6 = local_18;
      goto LAB_001153e7;
    }
    if (*local_28 == 'R') {
      (**(code **)(param_1 + 0x18))(local_28,param_1);
      _libssh2_error(param_1,0xffffffe0,"Unable to complete request for forward-listen");
      *(undefined4 *)(param_1 + 0xd250) = 0;
      lVar6 = 0;
      goto LAB_001153e7;
    }
  }
  *(undefined4 *)(param_1 + 0xd250) = 0;
  lVar6 = 0;
LAB_001153e7:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar6;
}



long libssh2_channel_forward_listen_ex
               (long param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,
               undefined4 param_5)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  if (param_1 != 0) {
    tVar2 = time((time_t *)0x0);
    do {
      lVar3 = channel_forward_listen(param_1,param_2,param_3,param_4,param_5);
      if (*(int *)(param_1 + 0x94) == 0) {
        return lVar3;
      }
      if (lVar3 != 0) {
        return lVar3;
      }
      iVar1 = libssh2_session_last_errno(param_1);
      if (iVar1 != -0x25) {
        return 0;
      }
      iVar1 = _libssh2_wait_socket(param_1,tVar2);
    } while (iVar1 == 0);
  }
  return 0;
}



undefined4 _libssh2_channel_forward_cancel(long param_1)

{
  int iVar1;
  long in_FS_OFFSET;
  undefined4 local_50;
  undefined *local_48;
  long local_40;
  undefined *local_38;
  long local_30;
  size_t local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = *(long *)(param_1 + 0x18);
  local_28 = strlen(*(char **)(param_1 + 0x20));
  local_20 = local_28 + 0x22;
  local_50 = 0;
  if (*(int *)(param_1 + 0x48) == 0) {
    local_38 = (undefined *)(**(code **)(local_30 + 8))(local_20,local_30);
    if (local_38 == (undefined *)0x0) {
      local_48 = local_38;
      _libssh2_error(local_30,0xfffffffa,"Unable to allocate memory for setenv packet");
      local_50 = 0xfffffffa;
      goto LAB_00115719;
    }
    local_48 = local_38 + 1;
    *local_38 = 0x50;
    _libssh2_store_str(&local_48,"cancel-tcpip-forward",0x14);
    *local_48 = 0;
    local_48 = local_48 + 1;
    _libssh2_store_str(&local_48,*(undefined8 *)(param_1 + 0x20),local_28);
    _libssh2_store_u32(&local_48,*(undefined4 *)(param_1 + 0x28));
    *(undefined4 *)(param_1 + 0x48) = 2;
  }
  else {
    local_38 = *(undefined **)(param_1 + 0x50);
  }
  if (*(int *)(param_1 + 0x48) == 2) {
    iVar1 = _libssh2_transport_send(local_30,local_38,local_20,0,0);
    if (iVar1 == -0x25) {
      _libssh2_error(local_30,0xffffffdb,"Would block sending forward request");
      *(undefined **)(param_1 + 0x50) = local_38;
      local_50 = 0xffffffdb;
      goto LAB_00115719;
    }
    if (iVar1 != 0) {
      _libssh2_error(local_30,0xfffffff9,
                     "Unable to send global-request packet for forward listen request");
      *(undefined4 *)(param_1 + 0x48) = 3;
      local_50 = 0xfffffff9;
    }
    (**(code **)(local_30 + 0x18))(local_38,local_30);
    *(undefined4 *)(param_1 + 0x48) = 3;
  }
  local_40 = _libssh2_list_first(param_1 + 0x30);
  while (local_40 != 0) {
    local_18 = _libssh2_list_next(local_40);
    iVar1 = _libssh2_channel_free(local_40);
    if (iVar1 == -0x25) {
      local_50 = 0xffffffdb;
      goto LAB_00115719;
    }
    local_40 = local_18;
  }
  (**(code **)(local_30 + 0x18))(*(undefined8 *)(param_1 + 0x20),local_30);
  _libssh2_list_remove(param_1);
  (**(code **)(local_30 + 0x18))(param_1,local_30);
LAB_00115719:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_50;
}



int libssh2_channel_forward_cancel(long param_1)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = _libssh2_channel_forward_cancel(param_1);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x18) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x18),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



long channel_forward_accept(long param_1)

{
  int iVar1;
  long lVar2;
  
  do {
    iVar1 = _libssh2_transport_read(*(undefined8 *)(param_1 + 0x18));
  } while (0 < iVar1);
  lVar2 = _libssh2_list_first(param_1 + 0x30);
  if (lVar2 == 0) {
    if (iVar1 == -0x25) {
      _libssh2_error(*(undefined8 *)(param_1 + 0x18),0xffffffdb,"Would block waiting for packet");
    }
    else {
      _libssh2_error(*(undefined8 *)(param_1 + 0x18),0xffffffe9,"Channel not found");
    }
    lVar2 = 0;
  }
  else {
    lVar2 = _libssh2_list_first(param_1 + 0x30);
    _libssh2_list_remove(lVar2);
    *(int *)(param_1 + 0x40) = *(int *)(param_1 + 0x40) + -1;
    _libssh2_list_add(*(long *)(lVar2 + 0x60) + 0x200,lVar2);
  }
  return lVar2;
}



long libssh2_channel_forward_accept(long param_1)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  if (param_1 != 0) {
    tVar2 = time((time_t *)0x0);
    do {
      lVar3 = channel_forward_accept(param_1);
      if (*(int *)(*(long *)(param_1 + 0x18) + 0x94) == 0) {
        return lVar3;
      }
      if (lVar3 != 0) {
        return lVar3;
      }
      iVar1 = libssh2_session_last_errno(*(undefined8 *)(param_1 + 0x18));
      if (iVar1 != -0x25) {
        return 0;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x18),tVar2);
    } while (iVar1 == 0);
  }
  return 0;
}



ulong channel_setenv(long param_1,undefined8 param_2,int param_3,undefined8 param_4,int param_5)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  undefined8 uVar4;
  ulong uVar5;
  long in_FS_OFFSET;
  undefined *local_30;
  char *local_28;
  undefined local_20 [8];
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = *(long *)(param_1 + 0x60);
  if (*(int *)(param_1 + 0x78) == 0) {
    *(ulong *)(param_1 + 0x88) = (ulong)(param_5 + param_3 + 0x15);
    memset((void *)(param_1 + 0x98),0,8);
    uVar4 = (**(code **)(local_18 + 8))(*(undefined8 *)(param_1 + 0x88),local_18);
    *(undefined8 *)(param_1 + 0x80) = uVar4;
    puVar1 = *(undefined **)(param_1 + 0x80);
    if (*(long *)(param_1 + 0x80) == 0) {
      local_30 = puVar1;
      uVar5 = _libssh2_error(local_18,0xfffffffa,"Unable to allocate memory for setenv packet");
      goto LAB_00115c75;
    }
    local_30 = puVar1 + 1;
    *puVar1 = 0x62;
    _libssh2_store_u32(&local_30,*(undefined4 *)(param_1 + 0x44));
    _libssh2_store_str(&local_30,&DAT_00145a61,3);
    *local_30 = 1;
    local_30 = local_30 + 1;
    _libssh2_store_str(&local_30,param_2,param_3);
    _libssh2_store_str(&local_30,param_4,param_5);
    *(undefined4 *)(param_1 + 0x78) = 2;
  }
  if (*(int *)(param_1 + 0x78) == 2) {
    iVar2 = _libssh2_transport_send
                      (local_18,*(undefined8 *)(param_1 + 0x80),*(undefined8 *)(param_1 + 0x88),0,0)
    ;
    if (iVar2 == -0x25) {
      _libssh2_error(local_18,0xffffffdb,"Would block sending setenv request");
      uVar5 = 0xffffffdb;
      goto LAB_00115c75;
    }
    if (iVar2 != 0) {
      (**(code **)(local_18 + 0x18))(*(undefined8 *)(param_1 + 0x80),local_18);
      *(undefined8 *)(param_1 + 0x80) = 0;
      *(undefined4 *)(param_1 + 0x78) = 0;
      uVar5 = _libssh2_error(local_18,0xfffffff9,
                             "Unable to send channel-request packet for setenv request");
      goto LAB_00115c75;
    }
    (**(code **)(local_18 + 0x18))(*(undefined8 *)(param_1 + 0x80),local_18);
    *(undefined8 *)(param_1 + 0x80) = 0;
    _libssh2_htonu32(param_1 + 0x90,*(undefined4 *)(param_1 + 0x30));
    *(undefined4 *)(param_1 + 0x78) = 3;
  }
  if (*(int *)(param_1 + 0x78) == 3) {
    uVar3 = _libssh2_packet_requirev
                      (local_18,&reply_codes_20319,&local_28,local_20,1,param_1 + 0x90,4,
                       param_1 + 0x98);
    if (uVar3 == 0xffffffdb) {
      uVar5 = 0xffffffdb;
      goto LAB_00115c75;
    }
    if (uVar3 != 0) {
      *(undefined4 *)(param_1 + 0x78) = 0;
      uVar5 = (ulong)uVar3;
      goto LAB_00115c75;
    }
    if (*local_28 == 'c') {
      (**(code **)(local_18 + 0x18))(local_28,local_18);
      *(undefined4 *)(param_1 + 0x78) = 0;
      uVar5 = 0;
      goto LAB_00115c75;
    }
    (**(code **)(local_18 + 0x18))(local_28,local_18);
  }
  *(undefined4 *)(param_1 + 0x78) = 0;
  uVar5 = _libssh2_error(local_18,0xffffffea,"Unable to complete request for channel-setenv");
LAB_00115c75:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



int libssh2_channel_setenv_ex
              (long param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,
              undefined4 param_5)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = channel_setenv(param_1,param_2,param_3,param_4,param_5);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined8
channel_request_pty(long param_1,undefined8 param_2,int param_3,undefined8 param_4,int param_5,
                   undefined4 param_6,undefined4 param_7,undefined4 param_8,undefined4 param_9)

{
  char cVar1;
  int iVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  undefined *local_30;
  char *local_28;
  undefined local_20 [8];
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = *(long *)(param_1 + 0x60);
  if (*(int *)(param_1 + 0xa0) == 0) {
    if (0x100 < (uint)(param_5 + param_3)) {
      uVar3 = _libssh2_error(local_18,0xffffffde,"term + mode lengths too large");
      goto LAB_00116056;
    }
    *(ulong *)(param_1 + 0x1d0) = (ulong)(param_5 + param_3 + 0x29);
    memset((void *)(param_1 + 0x1e0),0,8);
    local_30 = (undefined *)(param_1 + 0xa5);
    *(undefined *)(param_1 + 0xa4) = 0x62;
    _libssh2_store_u32(&local_30,*(undefined4 *)(param_1 + 0x44));
    _libssh2_store_str(&local_30,"pty-req",7);
    *local_30 = 1;
    local_30 = local_30 + 1;
    _libssh2_store_str(&local_30,param_2,param_3);
    _libssh2_store_u32(&local_30,param_6);
    _libssh2_store_u32(&local_30,param_7);
    _libssh2_store_u32(&local_30,param_8);
    _libssh2_store_u32(&local_30,param_9);
    _libssh2_store_str(&local_30,param_4,param_5);
    *(undefined4 *)(param_1 + 0xa0) = 2;
  }
  if (*(int *)(param_1 + 0xa0) == 2) {
    iVar2 = _libssh2_transport_send(local_18,param_1 + 0xa4,*(undefined8 *)(param_1 + 0x1d0),0,0);
    if (iVar2 == -0x25) {
      _libssh2_error(local_18,0xffffffdb,"Would block sending pty request");
      uVar3 = 0xffffffdb;
      goto LAB_00116056;
    }
    if (iVar2 != 0) {
      *(undefined4 *)(param_1 + 0xa0) = 0;
      uVar3 = _libssh2_error(local_18,iVar2,"Unable to send pty-request packet");
      goto LAB_00116056;
    }
    _libssh2_htonu32(param_1 + 0x1d8,*(undefined4 *)(param_1 + 0x30));
    *(undefined4 *)(param_1 + 0xa0) = 3;
  }
  if (*(int *)(param_1 + 0xa0) == 3) {
    iVar2 = _libssh2_packet_requirev
                      (local_18,&reply_codes_20346,&local_28,local_20,1,param_1 + 0x1d8,4,
                       param_1 + 0x1e0);
    if (iVar2 == -0x25) {
      uVar3 = 0xffffffdb;
      goto LAB_00116056;
    }
    if (iVar2 != 0) {
      *(undefined4 *)(param_1 + 0xa0) = 0;
      uVar3 = _libssh2_error(local_18,0xfffffff2,"Failed to require the PTY package");
      goto LAB_00116056;
    }
    cVar1 = *local_28;
    (**(code **)(local_18 + 0x18))(local_28,local_18);
    *(undefined4 *)(param_1 + 0xa0) = 0;
    if (cVar1 == 'c') {
      uVar3 = 0;
      goto LAB_00116056;
    }
  }
  uVar3 = _libssh2_error(local_18,0xffffffea,"Unable to complete request for channel request-pty");
LAB_00116056:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



int libssh2_channel_request_pty_ex
              (long param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,
              undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
              undefined4 param_9)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = channel_request_pty(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,
                                  param_9);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



ulong channel_request_pty_size
                (long param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                undefined4 param_5)

{
  int iVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  uint local_28;
  undefined *local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = *(undefined8 *)(param_1 + 0x60);
  local_28 = 0xfffffff2;
  if (*(int *)(param_1 + 0xa0) == 0) {
    *(undefined8 *)(param_1 + 0x1d0) = 0x27;
    memset((void *)(param_1 + 0x1e0),0,8);
    local_20 = (undefined *)(param_1 + 0xa5);
    *(undefined *)(param_1 + 0xa4) = 0x62;
    _libssh2_store_u32(&local_20,*(undefined4 *)(param_1 + 0x44));
    _libssh2_store_str(&local_20,"window-change",0xd);
    *local_20 = 0;
    local_20 = local_20 + 1;
    _libssh2_store_u32(&local_20,param_2);
    _libssh2_store_u32(&local_20,param_3);
    _libssh2_store_u32(&local_20,param_4);
    _libssh2_store_u32(&local_20,param_5);
    *(undefined4 *)(param_1 + 0xa0) = 2;
  }
  if (*(int *)(param_1 + 0xa0) == 2) {
    iVar1 = _libssh2_transport_send(local_18,param_1 + 0xa4,*(undefined8 *)(param_1 + 0x1d0),0,0);
    if (iVar1 == -0x25) {
      _libssh2_error(local_18,0xffffffdb,"Would block sending window-change request");
      uVar2 = 0xffffffdb;
      goto LAB_0011630d;
    }
    if (iVar1 != 0) {
      *(undefined4 *)(param_1 + 0xa0) = 0;
      uVar2 = _libssh2_error(local_18,iVar1,"Unable to send window-change packet");
      goto LAB_0011630d;
    }
    _libssh2_htonu32(param_1 + 0x1d8,*(undefined4 *)(param_1 + 0x30));
    local_28 = 0;
  }
  *(undefined4 *)(param_1 + 0xa0) = 0;
  uVar2 = (ulong)local_28;
LAB_0011630d:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



int libssh2_channel_request_pty_size_ex
              (long param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
              undefined4 param_5)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = channel_request_pty_size(param_1,param_2,param_3,param_4,param_5);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined8 channel_x11_req(long param_1,int param_2,char *param_3,char *param_4,undefined4 param_5)

{
  char cVar1;
  undefined *puVar2;
  int iVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  int local_60;
  undefined *local_58;
  undefined local_50 [8];
  char *local_48;
  long local_40;
  size_t local_38;
  size_t local_30;
  byte local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = *(long *)(param_1 + 0x60);
  if (param_3 == (char *)0x0) {
    local_38 = 0x12;
  }
  else {
    local_38 = strlen(param_3);
  }
  if (param_4 == (char *)0x0) {
    local_30 = 0x20;
  }
  else {
    local_30 = strlen(param_4);
  }
  if (*(int *)(param_1 + 0x1e8) == 0) {
    *(size_t *)(param_1 + 0x1f8) = local_30 + local_38 + 0x1e;
    memset((void *)(param_1 + 0x208),0,8);
    uVar4 = (**(code **)(local_40 + 8))(*(undefined8 *)(param_1 + 0x1f8),local_40);
    *(undefined8 *)(param_1 + 0x1f0) = uVar4;
    puVar2 = *(undefined **)(param_1 + 0x1f0);
    if (*(long *)(param_1 + 0x1f0) == 0) {
      local_58 = puVar2;
      uVar4 = _libssh2_error(local_40,0xfffffffa,"Unable to allocate memory for pty-request");
      goto LAB_0011682d;
    }
    local_58 = puVar2 + 1;
    *puVar2 = 0x62;
    _libssh2_store_u32(&local_58,*(undefined4 *)(param_1 + 0x44));
    _libssh2_store_str(&local_58,"x11-req",7);
    puVar2 = local_58 + 1;
    *local_58 = 1;
    local_58 = local_58 + 2;
    *puVar2 = param_2 != 0;
    if (param_3 == (char *)0x0) {
      param_3 = "MIT-MAGIC-COOKIE-1";
    }
    _libssh2_store_str(&local_58,param_3,local_38);
    _libssh2_store_u32(&local_58,local_30 & 0xffffffff);
    if (param_4 == (char *)0x0) {
      RAND_bytes(local_28,0x10);
      for (local_60 = 0; local_60 < 0x10; local_60 = local_60 + 1) {
        snprintf(local_58 + local_60 * 2,3,"%02X%c",(ulong)local_28[local_60],0);
      }
    }
    else {
      memcpy(local_58,param_4,local_30);
    }
    local_58 = local_58 + local_30;
    _libssh2_store_u32(&local_58,param_5);
    *(undefined4 *)(param_1 + 0x1e8) = 2;
  }
  if (*(int *)(param_1 + 0x1e8) == 2) {
    iVar3 = _libssh2_transport_send
                      (local_40,*(undefined8 *)(param_1 + 0x1f0),*(undefined8 *)(param_1 + 0x1f8),0,
                       0);
    if (iVar3 == -0x25) {
      _libssh2_error(local_40,0xffffffdb,"Would block sending X11-req packet");
      uVar4 = 0xffffffdb;
      goto LAB_0011682d;
    }
    if (iVar3 != 0) {
      (**(code **)(local_40 + 0x18))(*(undefined8 *)(param_1 + 0x1f0),local_40);
      *(undefined8 *)(param_1 + 0x1f0) = 0;
      *(undefined4 *)(param_1 + 0x1e8) = 0;
      uVar4 = _libssh2_error(local_40,iVar3,"Unable to send x11-req packet");
      goto LAB_0011682d;
    }
    (**(code **)(local_40 + 0x18))(*(undefined8 *)(param_1 + 0x1f0),local_40);
    *(undefined8 *)(param_1 + 0x1f0) = 0;
    _libssh2_htonu32(param_1 + 0x200,*(undefined4 *)(param_1 + 0x30));
    *(undefined4 *)(param_1 + 0x1e8) = 3;
  }
  if (*(int *)(param_1 + 0x1e8) == 3) {
    iVar3 = _libssh2_packet_requirev
                      (local_40,&reply_codes_20397,&local_48,local_50,1,param_1 + 0x200,4,
                       param_1 + 0x208);
    if (iVar3 == -0x25) {
      uVar4 = 0xffffffdb;
      goto LAB_0011682d;
    }
    if (iVar3 != 0) {
      *(undefined4 *)(param_1 + 0x1e8) = 0;
      uVar4 = _libssh2_error(local_40,iVar3,"waiting for x11-req response packet");
      goto LAB_0011682d;
    }
    cVar1 = *local_48;
    (**(code **)(local_40 + 0x18))(local_48,local_40);
    *(undefined4 *)(param_1 + 0x1e8) = 0;
    if (cVar1 == 'c') {
      uVar4 = 0;
      goto LAB_0011682d;
    }
  }
  uVar4 = _libssh2_error(local_40,0xffffffea,"Unable to complete request for channel x11-req");
LAB_0011682d:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int libssh2_channel_x11_req_ex
              (long param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4,
              undefined4 param_5)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = channel_x11_req(param_1,param_2,param_3,param_4,param_5);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined8
_libssh2_channel_process_startup
          (long param_1,undefined8 param_2,long param_3,long param_4,ulong param_5)

{
  char cVar1;
  undefined *puVar2;
  int iVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  undefined *local_30;
  char *local_28;
  undefined local_20 [8];
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = *(long *)(param_1 + 0x60);
  if (*(int *)(param_1 + 0x210) == 0x10) {
    uVar4 = _libssh2_error(local_18,0xffffffd9,"Channel can not be reused");
    goto LAB_00116c85;
  }
  if (*(int *)(param_1 + 0x210) == 0) {
    *(long *)(param_1 + 0x220) = param_3 + 10;
    memset((void *)(param_1 + 0x230),0,8);
    if (param_4 != 0) {
      *(long *)(param_1 + 0x220) = *(long *)(param_1 + 0x220) + 4;
    }
    uVar4 = (**(code **)(local_18 + 8))(*(undefined8 *)(param_1 + 0x220),local_18);
    *(undefined8 *)(param_1 + 0x218) = uVar4;
    puVar2 = *(undefined **)(param_1 + 0x218);
    if (*(long *)(param_1 + 0x218) == 0) {
      local_30 = puVar2;
      uVar4 = _libssh2_error(local_18,0xfffffffa,
                             "Unable to allocate memory for channel-process request");
      goto LAB_00116c85;
    }
    local_30 = puVar2 + 1;
    *puVar2 = 0x62;
    _libssh2_store_u32(&local_30,*(undefined4 *)(param_1 + 0x44));
    _libssh2_store_str(&local_30,param_2,param_3);
    puVar2 = local_30 + 1;
    *local_30 = 1;
    local_30 = puVar2;
    if (param_4 != 0) {
      _libssh2_store_u32(&local_30,param_5 & 0xffffffff);
    }
    *(undefined4 *)(param_1 + 0x210) = 2;
  }
  if (*(int *)(param_1 + 0x210) == 2) {
    iVar3 = _libssh2_transport_send
                      (local_18,*(undefined8 *)(param_1 + 0x218),*(undefined8 *)(param_1 + 0x220),
                       param_4,param_5);
    if (iVar3 == -0x25) {
      _libssh2_error(local_18,0xffffffdb,"Would block sending channel request");
      uVar4 = 0xffffffdb;
      goto LAB_00116c85;
    }
    if (iVar3 != 0) {
      (**(code **)(local_18 + 0x18))(*(undefined8 *)(param_1 + 0x218),local_18);
      *(undefined8 *)(param_1 + 0x218) = 0;
      *(undefined4 *)(param_1 + 0x210) = 0x10;
      uVar4 = _libssh2_error(local_18,iVar3,"Unable to send channel request");
      goto LAB_00116c85;
    }
    (**(code **)(local_18 + 0x18))(*(undefined8 *)(param_1 + 0x218),local_18);
    *(undefined8 *)(param_1 + 0x218) = 0;
    _libssh2_htonu32(param_1 + 0x228,*(undefined4 *)(param_1 + 0x30));
    *(undefined4 *)(param_1 + 0x210) = 3;
  }
  if (*(int *)(param_1 + 0x210) == 3) {
    iVar3 = _libssh2_packet_requirev
                      (local_18,&reply_codes_20429,&local_28,local_20,1,param_1 + 0x228,4,
                       param_1 + 0x230);
    if (iVar3 == -0x25) {
      uVar4 = 0xffffffdb;
      goto LAB_00116c85;
    }
    if (iVar3 != 0) {
      *(undefined4 *)(param_1 + 0x210) = 0x10;
      uVar4 = _libssh2_error(local_18,iVar3,"Failed waiting for channel success");
      goto LAB_00116c85;
    }
    cVar1 = *local_28;
    (**(code **)(local_18 + 0x18))(local_28,local_18);
    *(undefined4 *)(param_1 + 0x210) = 0x10;
    if (cVar1 == 'c') {
      uVar4 = 0;
      goto LAB_00116c85;
    }
  }
  uVar4 = _libssh2_error(local_18,0xffffffea,
                         "Unable to complete request for channel-process-startup");
LAB_00116c85:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



int libssh2_channel_process_startup
              (long param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,
              undefined4 param_5)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = _libssh2_channel_process_startup(param_1,param_2,param_3,param_4,param_5);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



void libssh2_channel_set_blocking(long param_1,undefined4 param_2)

{
  if (param_1 != 0) {
    _libssh2_session_set_blocking(*(undefined8 *)(param_1 + 0x60),param_2);
  }
  return;
}



undefined8 _libssh2_channel_flush(long param_1,int param_2)

{
  char cVar1;
  undefined8 uVar2;
  uint uVar3;
  int iVar4;
  long lVar5;
  ulong uVar6;
  undefined8 uVar7;
  long local_20;
  
  if (*(int *)(param_1 + 0x238) == 0) {
    lVar5 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0);
    *(undefined8 *)(param_1 + 0x240) = 0;
    *(undefined8 *)(param_1 + 0x248) = 0;
    while (local_20 = lVar5, local_20 != 0) {
      lVar5 = _libssh2_list_next(local_20);
      cVar1 = **(char **)(local_20 + 0x18);
      if (((cVar1 == '^') || (cVar1 == '_')) &&
         (iVar4 = _libssh2_ntohu32(*(long *)(local_20 + 0x18) + 1),
         iVar4 == *(int *)(param_1 + 0x30))) {
        if (cVar1 == '^') {
          uVar6 = 0;
        }
        else {
          uVar3 = _libssh2_ntohu32(*(long *)(local_20 + 0x18) + 5);
          uVar6 = (ulong)uVar3;
        }
        if (((param_2 == -2) || ((cVar1 == '_' && ((param_2 == -1 || (uVar6 == (long)param_2))))))
           || ((cVar1 == '^' && (param_2 == 0)))) {
          uVar7 = *(undefined8 *)(local_20 + 0x20);
          uVar2 = *(undefined8 *)(local_20 + 0x28);
          *(long *)(param_1 + 0x240) =
               *(long *)(local_20 + 0x20) + *(long *)(param_1 + 0x240) + -0xd;
          *(long *)(param_1 + 0x248) = *(long *)(param_1 + 0x248) + (long)((int)uVar7 - (int)uVar2);
          (**(code **)(*(long *)(param_1 + 0x60) + 0x18))
                    (*(undefined8 *)(local_20 + 0x18),*(undefined8 *)(param_1 + 0x60));
          _libssh2_list_remove(local_20);
          (**(code **)(*(long *)(param_1 + 0x60) + 0x18))(local_20,*(undefined8 *)(param_1 + 0x60));
        }
      }
    }
    *(undefined4 *)(param_1 + 0x238) = 2;
  }
  *(int *)(param_1 + 0x5c) = *(int *)(param_1 + 0x5c) - (int)*(undefined8 *)(param_1 + 0x248);
  *(int *)(param_1 + 0x4c) = *(int *)(param_1 + 0x4c) - (int)*(undefined8 *)(param_1 + 0x248);
  if ((*(long *)(param_1 + 0x240) == 0) ||
     (iVar4 = _libssh2_channel_receive_window_adjust
                        (param_1,*(ulong *)(param_1 + 0x240) & 0xffffffff,1,0), iVar4 != -0x25)) {
    *(undefined4 *)(param_1 + 0x238) = 0;
    uVar7 = *(undefined8 *)(param_1 + 0x248);
  }
  else {
    uVar7 = 0xffffffdb;
  }
  return uVar7;
}



int libssh2_channel_flush_ex(long param_1,undefined4 param_2)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = _libssh2_channel_flush(param_1,param_2);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined4 libssh2_channel_get_exit_status(long param_1)

{
  undefined4 uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *(undefined4 *)(param_1 + 0x24);
  }
  return uVar1;
}



undefined8
libssh2_channel_get_exit_signal
          (long param_1,long *param_2,size_t *param_3,undefined8 *param_4,undefined8 *param_5,
          undefined8 *param_6,undefined8 *param_7)

{
  long lVar1;
  size_t __n;
  long lVar2;
  undefined8 uVar3;
  
  if (param_1 != 0) {
    lVar1 = *(long *)(param_1 + 0x60);
    if (*(long *)(param_1 + 0x28) == 0) {
      if (param_2 != (long *)0x0) {
        *param_2 = 0;
      }
      if (param_3 != (size_t *)0x0) {
        *param_3 = 0;
      }
    }
    else {
      __n = strlen(*(char **)(param_1 + 0x28));
      if (param_2 != (long *)0x0) {
        lVar2 = (**(code **)(lVar1 + 8))(__n + 1,lVar1);
        *param_2 = lVar2;
        if (*param_2 == 0) {
          uVar3 = _libssh2_error(lVar1,0xfffffffa,"Unable to allocate memory for signal name");
          return uVar3;
        }
        memcpy((void *)*param_2,*(void **)(param_1 + 0x28),__n);
        *(undefined *)(__n + *param_2) = 0;
      }
      if (param_3 != (size_t *)0x0) {
        *param_3 = __n;
      }
    }
    if (param_4 != (undefined8 *)0x0) {
      *param_4 = 0;
    }
    if (param_5 != (undefined8 *)0x0) {
      *param_5 = 0;
    }
    if (param_6 != (undefined8 *)0x0) {
      *param_6 = 0;
    }
    if (param_7 != (undefined8 *)0x0) {
      *param_7 = 0;
    }
  }
  return 0;
}



undefined8
_libssh2_channel_receive_window_adjust(long param_1,int param_2,char param_3,undefined4 *param_4)

{
  int iVar1;
  undefined8 uVar2;
  int local_24;
  
  if (param_4 != (undefined4 *)0x0) {
    *param_4 = *(undefined4 *)(param_1 + 0x4c);
  }
  local_24 = param_2;
  if (*(int *)(param_1 + 0x250) == 0) {
    if ((param_3 == '\0') && ((uint)(param_2 + *(int *)(param_1 + 0x58)) < 0x400)) {
      *(int *)(param_1 + 0x58) = *(int *)(param_1 + 0x58) + param_2;
      return 0;
    }
    if ((param_2 == 0) && (*(int *)(param_1 + 0x58) == 0)) {
      return 0;
    }
    local_24 = param_2 + *(int *)(param_1 + 0x58);
    *(undefined4 *)(param_1 + 0x58) = 0;
    *(undefined *)(param_1 + 0x254) = 0x5d;
    _libssh2_htonu32(param_1 + 0x255,*(undefined4 *)(param_1 + 0x44));
    _libssh2_htonu32(param_1 + 0x259,local_24);
    *(undefined4 *)(param_1 + 0x250) = 2;
  }
  iVar1 = _libssh2_transport_send(*(undefined8 *)(param_1 + 0x60),param_1 + 0x254,9,0,0);
  if (iVar1 == -0x25) {
    _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xffffffdb,"Would block sending window adjust");
    uVar2 = 0xffffffdb;
  }
  else if (iVar1 == 0) {
    *(int *)(param_1 + 0x4c) = *(int *)(param_1 + 0x4c) + local_24;
    *(undefined4 *)(param_1 + 0x250) = 0;
    uVar2 = 0;
  }
  else {
    *(int *)(param_1 + 0x58) = local_24;
    uVar2 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xfffffff9,
                           "Unable to send transfer-window adjustment packet, deferring");
  }
  return uVar2;
}



ulong libssh2_channel_receive_window_adjust(long param_1,undefined4 param_2,undefined param_3)

{
  ulong uVar1;
  long in_FS_OFFSET;
  uint local_20;
  int local_1c;
  time_t local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_1 == 0) {
    uVar1 = 0xffffffffffffffd9;
  }
  else {
    local_18 = time((time_t *)0x0);
    do {
      local_1c = _libssh2_channel_receive_window_adjust(param_1,param_2,param_3,&local_20);
      if ((local_1c != -0x25) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
      local_1c = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),local_18);
    } while (local_1c == 0);
    if (local_1c == 0) {
      uVar1 = (ulong)local_20;
    }
    else {
      uVar1 = (ulong)local_1c;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



int libssh2_channel_receive_window_adjust2
              (long param_1,undefined4 param_2,undefined param_3,undefined8 param_4)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = _libssh2_channel_receive_window_adjust(param_1,param_2,param_3,param_4);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined4 _libssh2_channel_extended_data(long param_1,int param_2)

{
  int iVar1;
  
  if (*(int *)(param_1 + 0x2a8) == 0) {
    *(char *)(param_1 + 0x56) = (char)param_2;
    *(undefined4 *)(param_1 + 0x2a8) = 2;
  }
  if (((*(int *)(param_1 + 0x2a8) == 0) && (param_2 == 1)) &&
     (iVar1 = _libssh2_channel_flush(param_1,0xffffffff), iVar1 == -0x25)) {
    return 0xffffffdb;
  }
  *(undefined4 *)(param_1 + 0x2a8) = 0;
  return 0;
}



int libssh2_channel_handle_extended_data2(long param_1,undefined4 param_2)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = _libssh2_channel_extended_data(param_1,param_2);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



void libssh2_channel_handle_extended_data(undefined8 param_1,undefined4 param_2)

{
  libssh2_channel_handle_extended_data2(param_1,param_2);
  return;
}



long _libssh2_channel_read(long param_1,int param_2,long param_3,long param_4)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  undefined4 uVar4;
  int iVar5;
  long lVar6;
  long lVar7;
  int local_3c;
  int local_38;
  uint local_30;
  long local_28;
  
  lVar6 = *(long *)(param_1 + 0x60);
  local_3c = 0;
  iVar3 = (int)param_4;
  if ((*(int *)(param_1 + 0x260) == 0xb) ||
     ((ulong)*(uint *)(param_1 + 0x4c) < param_4 + (ulong)((*(uint *)(param_1 + 0x48) >> 2) * 3))) {
    local_30 = (iVar3 + *(int *)(param_1 + 0x48)) - *(int *)(param_1 + 0x4c);
    if (local_30 < 0x400) {
      local_30 = 0x400;
    }
    *(undefined4 *)(param_1 + 0x260) = 0xb;
    iVar2 = _libssh2_channel_receive_window_adjust(param_1,local_30,0,0);
    if (iVar2 != 0) {
      return (long)iVar2;
    }
    *(undefined4 *)(param_1 + 0x260) = 0;
  }
  do {
    iVar2 = _libssh2_transport_read(lVar6);
  } while (0 < iVar2);
  if ((iVar2 < 0) && (iVar2 != -0x25)) {
    iVar3 = _libssh2_error(lVar6,iVar2,"transport read");
    lVar6 = (long)iVar3;
  }
  else {
    lVar7 = _libssh2_list_first(lVar6 + 0x1f0);
    while ((local_28 = lVar7, local_28 != 0 && (local_3c < iVar3))) {
      lVar7 = _libssh2_list_next(local_28);
      uVar4 = _libssh2_ntohu32(*(long *)(local_28 + 0x18) + 1);
      *(undefined4 *)(param_1 + 0x264) = uVar4;
      if ((((param_2 != 0) &&
           (((**(char **)(local_28 + 0x18) == '_' &&
             (*(int *)(param_1 + 0x30) == *(int *)(param_1 + 0x264))) &&
            (iVar5 = _libssh2_ntohu32(*(long *)(local_28 + 0x18) + 5), param_2 == iVar5)))) ||
          (((param_2 == 0 && (**(char **)(local_28 + 0x18) == '^')) &&
           (*(int *)(param_1 + 0x30) == *(int *)(param_1 + 0x264))))) ||
         (((param_2 == 0 && (**(char **)(local_28 + 0x18) == '_')) &&
          ((*(int *)(param_1 + 0x30) == *(int *)(param_1 + 0x264) &&
           (*(char *)(param_1 + 0x56) == '\x02')))))) {
        local_38 = iVar3 - local_3c;
        bVar1 = (int)*(undefined8 *)(local_28 + 0x20) - (int)*(undefined8 *)(local_28 + 0x28) <=
                local_38;
        if (bVar1) {
          local_38 = (int)*(undefined8 *)(local_28 + 0x20) - (int)*(undefined8 *)(local_28 + 0x28);
        }
        memcpy((void *)(local_3c + param_3),
               (void *)(*(long *)(local_28 + 0x18) + *(long *)(local_28 + 0x28)),(long)local_38);
        *(long *)(local_28 + 0x28) = *(long *)(local_28 + 0x28) + (long)local_38;
        local_3c = local_3c + local_38;
        if (bVar1) {
          _libssh2_list_remove(local_28);
          (**(code **)(lVar6 + 0x18))(*(undefined8 *)(local_28 + 0x18),lVar6);
          (**(code **)(lVar6 + 0x18))(local_28,lVar6);
        }
      }
    }
    if (local_3c == 0) {
      if ((*(char *)(param_1 + 0x55) == '\0') && (*(char *)(param_1 + 0x54) == '\0')) {
        if (iVar2 == -0x25) {
          iVar3 = _libssh2_error(lVar6,0xffffffdb,"would block");
          lVar6 = (long)iVar3;
        }
        else {
          lVar6 = 0;
        }
      }
      else {
        lVar6 = 0;
      }
    }
    else {
      *(int *)(param_1 + 0x5c) = *(int *)(param_1 + 0x5c) - local_3c;
      *(int *)(param_1 + 0x4c) = *(int *)(param_1 + 0x4c) - local_3c;
      lVar6 = (long)local_3c;
    }
  }
  return lVar6;
}



long libssh2_channel_read_ex(long param_1,undefined4 param_2,undefined8 param_3,ulong param_4)

{
  int iVar1;
  long lVar2;
  ulong uVar3;
  time_t tVar4;
  undefined4 local_24;
  
  if (param_1 == 0) {
    lVar2 = -0x27;
  }
  else {
    uVar3 = libssh2_channel_window_read_ex(param_1,0,0);
    if (uVar3 < param_4) {
      tVar4 = time((time_t *)0x0);
      do {
        iVar1 = _libssh2_channel_receive_window_adjust(param_1,param_4 & 0xffffffff,1,0);
        if ((iVar1 != -0x25) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
        iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar4);
      } while (iVar1 == 0);
    }
    tVar4 = time((time_t *)0x0);
    do {
      local_24 = _libssh2_channel_read(param_1,param_2,param_3,param_4);
      if ((local_24 != -0x25) || (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0)) break;
      local_24 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar4);
    } while (local_24 == 0);
    lVar2 = (long)local_24;
  }
  return lVar2;
}



long _libssh2_channel_packet_data_len(long param_1,int param_2)

{
  int iVar1;
  int iVar2;
  long local_18;
  
  local_18 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0);
  if (local_18 != 0) {
    for (; local_18 != 0; local_18 = _libssh2_list_next(local_18)) {
      iVar1 = _libssh2_ntohu32(*(long *)(local_18 + 0x18) + 1);
      if (((((param_2 != 0) && (**(char **)(local_18 + 0x18) == '_')) &&
           (iVar1 == *(int *)(param_1 + 0x30))) &&
          (iVar2 = _libssh2_ntohu32(*(long *)(local_18 + 0x18) + 5), param_2 == iVar2)) ||
         ((((param_2 == 0 && (**(char **)(local_18 + 0x18) == '^')) &&
           (iVar1 == *(int *)(param_1 + 0x30))) ||
          (((param_2 == 0 && (**(char **)(local_18 + 0x18) == '_')) &&
           ((iVar1 == *(int *)(param_1 + 0x30) && (*(char *)(param_1 + 0x56) == '\x02')))))))) {
        return *(long *)(local_18 + 0x20) - *(long *)(local_18 + 0x28);
      }
    }
  }
  return 0;
}



long _libssh2_channel_write(long param_1,int param_2,undefined8 param_3,ulong param_4)

{
  int iVar1;
  long lVar2;
  undefined uVar3;
  long in_FS_OFFSET;
  ulong local_58;
  undefined *local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = *(long *)(param_1 + 0x60);
  local_18 = 0;
  local_58 = param_4;
  if (0x7fbc < param_4) {
    local_58 = 0x7fbc;
  }
  if (*(int *)(param_1 + 0x268) == 0) {
    local_28 = (undefined *)(param_1 + 0x26c);
    if (*(char *)(param_1 + 0x40) != '\0') {
      iVar1 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xffffffe6,
                             "We\'ve already closed this channel");
      lVar2 = (long)iVar1;
      goto LAB_00117f19;
    }
    if (*(char *)(param_1 + 0x41) != '\0') {
      iVar1 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),0xffffffe5,
                             "EOF has already been received, data might be ignored");
      lVar2 = (long)iVar1;
      goto LAB_00117f19;
    }
    do {
      iVar1 = _libssh2_transport_read(local_20);
    } while (0 < iVar1);
    if ((iVar1 < 0) && (iVar1 != -0x25)) {
      iVar1 = _libssh2_error(*(undefined8 *)(param_1 + 0x60),iVar1,
                             "Failure while draining incoming flow");
      lVar2 = (long)iVar1;
      goto LAB_00117f19;
    }
    if (*(int *)(param_1 + 0x38) == 0) {
      *(undefined4 *)(local_20 + 0x230) = 1;
      if (iVar1 == -0x25) {
        lVar2 = -0x25;
      }
      else {
        lVar2 = 0;
      }
      goto LAB_00117f19;
    }
    *(ulong *)(param_1 + 0x288) = local_58;
    if (param_2 == 0) {
      uVar3 = 0x5e;
    }
    else {
      uVar3 = 0x5f;
    }
    *local_28 = uVar3;
    local_28 = local_28 + 1;
    _libssh2_store_u32(&local_28,*(undefined4 *)(param_1 + 0x44));
    if (param_2 != 0) {
      _libssh2_store_u32(&local_28,param_2);
    }
    if ((ulong)*(uint *)(param_1 + 0x38) < *(ulong *)(param_1 + 0x288)) {
      *(ulong *)(param_1 + 0x288) = (ulong)*(uint *)(param_1 + 0x38);
    }
    if ((ulong)*(uint *)(param_1 + 0x3c) < *(ulong *)(param_1 + 0x288)) {
      *(ulong *)(param_1 + 0x288) = (ulong)*(uint *)(param_1 + 0x3c);
    }
    _libssh2_store_u32(&local_28,*(ulong *)(param_1 + 0x288) & 0xffffffff);
    *(long *)(param_1 + 0x280) = (long)local_28 - (param_1 + 0x26c);
    *(undefined4 *)(param_1 + 0x268) = 2;
  }
  if (*(int *)(param_1 + 0x268) == 2) {
    iVar1 = _libssh2_transport_send
                      (local_20,param_1 + 0x26c,*(undefined8 *)(param_1 + 0x280),param_3,
                       *(undefined8 *)(param_1 + 0x288));
    if (iVar1 == -0x25) {
      iVar1 = _libssh2_error(local_20,0xffffffdb,"Unable to send channel data");
      lVar2 = (long)iVar1;
    }
    else if (iVar1 == 0) {
      *(int *)(param_1 + 0x38) = *(int *)(param_1 + 0x38) - (int)*(undefined8 *)(param_1 + 0x288);
      lVar2 = local_18 + *(long *)(param_1 + 0x288);
      *(undefined4 *)(param_1 + 0x268) = 0;
      local_18 = lVar2;
    }
    else {
      *(undefined4 *)(param_1 + 0x268) = 0;
      iVar1 = _libssh2_error(local_20,iVar1,"Unable to send channel data");
      lVar2 = (long)iVar1;
    }
  }
  else {
    lVar2 = -0x22;
  }
LAB_00117f19:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar2;
}



long libssh2_channel_write_ex(long param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  long lVar2;
  time_t tVar3;
  
  if (param_1 == 0) {
    lVar2 = -0x27;
  }
  else {
    tVar3 = time((time_t *)0x0);
    do {
      lVar2 = _libssh2_channel_write(param_1,param_2,param_3,param_4);
      if (lVar2 != -0x25) {
        return lVar2;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar3);
      lVar2 = (long)iVar1;
    } while (lVar2 == 0);
  }
  return lVar2;
}



undefined8 channel_send_eof(long param_1)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  undefined local_15;
  undefined auStack_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  uVar2 = *(undefined8 *)(param_1 + 0x60);
  local_15 = 0x60;
  _libssh2_htonu32(auStack_14,*(undefined4 *)(param_1 + 0x44));
  iVar1 = _libssh2_transport_send(uVar2,&local_15,5,0,0);
  if (iVar1 == -0x25) {
    _libssh2_error(uVar2,0xffffffdb,"Would block sending EOF");
    uVar2 = 0xffffffdb;
  }
  else if (iVar1 == 0) {
    *(undefined *)(param_1 + 0x41) = 1;
    uVar2 = 0;
  }
  else {
    uVar2 = _libssh2_error(uVar2,0xfffffff9,"Unable to send EOF on channel");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



int libssh2_channel_send_eof(long param_1)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = channel_send_eof(param_1);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



int libssh2_channel_eof(long param_1)

{
  int iVar1;
  int iVar2;
  long local_28;
  
  if (param_1 == 0) {
    iVar2 = -0x27;
  }
  else {
    for (local_28 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0); local_28 != 0;
        local_28 = _libssh2_list_next(local_28)) {
      if (((**(char **)(local_28 + 0x18) == '^') || (**(char **)(local_28 + 0x18) == '_')) &&
         (iVar2 = *(int *)(param_1 + 0x30), iVar1 = _libssh2_ntohu32(*(long *)(local_28 + 0x18) + 1)
         , iVar2 == iVar1)) {
        return 0;
      }
    }
    iVar2 = (int)*(char *)(param_1 + 0x55);
  }
  return iVar2;
}



undefined8 channel_wait_eof(long param_1)

{
  long lVar1;
  int iVar2;
  undefined8 uVar3;
  
  lVar1 = *(long *)(param_1 + 0x60);
  if (*(int *)(param_1 + 0x29c) == 0) {
    *(undefined4 *)(param_1 + 0x29c) = 2;
  }
  do {
    if (*(char *)(param_1 + 0x55) != '\0') {
      *(undefined4 *)(param_1 + 0x29c) = 0;
      return 0;
    }
    if ((*(int *)(param_1 + 0x4c) == *(int *)(param_1 + 0x5c)) && (*(int *)(lVar1 + 0x94) != 0)) {
      uVar3 = _libssh2_error(lVar1,0xffffffd1,"Receiving channel window has been exhausted");
      return uVar3;
    }
    iVar2 = _libssh2_transport_read(lVar1);
    if (iVar2 == -0x25) {
      return 0xffffffdb;
    }
  } while (-1 < iVar2);
  *(undefined4 *)(param_1 + 0x29c) = 0;
  uVar3 = _libssh2_error(lVar1,iVar2,"_libssh2_transport_read() bailed out!");
  return uVar3;
}



int libssh2_channel_wait_eof(long param_1)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = channel_wait_eof(param_1);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



int _libssh2_channel_close(long param_1)

{
  long lVar1;
  int iVar2;
  int local_14;
  
  lVar1 = *(long *)(param_1 + 0x60);
  local_14 = 0;
  if (*(char *)(param_1 + 0x40) == '\0') {
    if ((*(char *)(param_1 + 0x41) == '\0') && (local_14 = channel_send_eof(param_1), local_14 != 0)
       ) {
      if (local_14 == -0x25) {
        return -0x25;
      }
      _libssh2_error(lVar1,local_14,"Unable to send EOF, but closing channel anyway");
    }
    if (*(int *)(param_1 + 0x290) == 0) {
      *(undefined *)(param_1 + 0x294) = 0x61;
      _libssh2_htonu32(param_1 + 0x295,*(undefined4 *)(param_1 + 0x44));
      *(undefined4 *)(param_1 + 0x290) = 2;
    }
    if (*(int *)(param_1 + 0x290) == 2) {
      local_14 = _libssh2_transport_send(lVar1,param_1 + 0x294,5,0,0);
      if (local_14 == -0x25) {
        _libssh2_error(lVar1,0xffffffdb,"Would block sending close-channel");
        return -0x25;
      }
      if (local_14 == 0) {
        *(undefined4 *)(param_1 + 0x290) = 3;
      }
      else {
        _libssh2_error(lVar1,local_14,"Unable to send close-channel request, but closing anyway");
      }
    }
    if (*(int *)(param_1 + 0x290) == 3) {
      while (((*(char *)(param_1 + 0x54) == '\0' && (local_14 == 0)) &&
             (*(int *)(lVar1 + 0x22c) != -1))) {
        local_14 = _libssh2_transport_read(lVar1);
      }
    }
    if (local_14 != -0x25) {
      *(undefined *)(param_1 + 0x40) = 1;
      if (*(long *)(param_1 + 0x70) != 0) {
        (**(code **)(param_1 + 0x70))(lVar1,lVar1,param_1,param_1 + 0x68);
      }
      *(undefined4 *)(param_1 + 0x290) = 0;
    }
    iVar2 = 0;
    if (local_14 < 1) {
      iVar2 = local_14;
    }
  }
  else {
    *(undefined4 *)(param_1 + 0x290) = 0;
    iVar2 = 0;
  }
  return iVar2;
}



int libssh2_channel_close(long param_1)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = _libssh2_channel_close(param_1);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



ulong channel_wait_closed(long param_1)

{
  undefined8 uVar1;
  uint uVar2;
  ulong uVar3;
  
  uVar1 = *(undefined8 *)(param_1 + 0x60);
  if (*(char *)(param_1 + 0x55) == '\0') {
    uVar3 = _libssh2_error(uVar1,0xffffffde,
                           "libssh2_channel_wait_closed() invoked when channel is not in EOF state")
    ;
  }
  else {
    if (*(int *)(param_1 + 0x2a0) == 0) {
      *(undefined4 *)(param_1 + 0x2a0) = 2;
    }
    if (*(char *)(param_1 + 0x54) == '\0') {
      do {
        uVar2 = _libssh2_transport_read(uVar1);
        if (*(char *)(param_1 + 0x54) != '\0') break;
      } while (0 < (int)uVar2);
      if ((int)uVar2 < 0) {
        return (ulong)uVar2;
      }
    }
    *(undefined4 *)(param_1 + 0x2a0) = 0;
    uVar3 = 0;
  }
  return uVar3;
}



int libssh2_channel_wait_closed(long param_1)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = channel_wait_closed(param_1);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined4 _libssh2_channel_free(long param_1)

{
  int iVar1;
  undefined4 uVar2;
  long in_FS_OFFSET;
  undefined8 local_30;
  undefined local_28 [8];
  long local_20;
  undefined local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = *(long *)(param_1 + 0x60);
  if (local_20 == 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("session",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-3857_Libssh2/Libssh2/src/channel.c"
                  ,0x9b5,"_libssh2_channel_free");
  }
  if (*(int *)(param_1 + 0x2a4) == 0) {
    *(undefined4 *)(param_1 + 0x2a4) = 2;
  }
  if ((*(char *)(param_1 + 0x40) == '\0') && (*(int *)(local_20 + 0x22c) == 0)) {
    iVar1 = _libssh2_channel_close(param_1);
    if (iVar1 == -0x25) {
      uVar2 = 0xffffffdb;
      goto LAB_00118906;
    }
  }
  *(undefined4 *)(param_1 + 0x2a4) = 0;
  if (*(long *)(param_1 + 0x28) != 0) {
    (**(code **)(local_20 + 0x18))(*(undefined8 *)(param_1 + 0x28),local_20);
  }
  _libssh2_htonu32(local_14,*(undefined4 *)(param_1 + 0x30));
  do {
    iVar1 = _libssh2_packet_ask(local_20,0x5e,&local_30,local_28,1,local_14,4);
    if (iVar1 < 0) {
      iVar1 = _libssh2_packet_ask(local_20,0x5f,&local_30,local_28,1,local_14,4);
      if (iVar1 < 0) break;
    }
    (**(code **)(local_20 + 0x18))(local_30,local_20);
  } while( true );
  if (*(long *)(param_1 + 0x18) != 0) {
    (**(code **)(local_20 + 0x18))(*(undefined8 *)(param_1 + 0x18),local_20);
  }
  _libssh2_list_remove(param_1);
  if (*(long *)(param_1 + 0x80) != 0) {
    (**(code **)(local_20 + 0x18))(*(undefined8 *)(param_1 + 0x80),local_20);
  }
  if (*(long *)(param_1 + 0x1f0) != 0) {
    (**(code **)(local_20 + 0x18))(*(undefined8 *)(param_1 + 0x1f0),local_20);
  }
  if (*(long *)(param_1 + 0x218) != 0) {
    (**(code **)(local_20 + 0x18))(*(undefined8 *)(param_1 + 0x218),local_20);
  }
  (**(code **)(local_20 + 0x18))(param_1,local_20);
  uVar2 = 0;
LAB_00118906:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



int libssh2_channel_free(long param_1)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = _libssh2_channel_free(param_1);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined4 libssh2_channel_window_read_ex(long param_1,long *param_2,ulong *param_3)

{
  int iVar1;
  undefined4 uVar2;
  undefined8 local_18;
  undefined8 local_10;
  
  if (param_1 == 0) {
    uVar2 = 0;
  }
  else {
    if (param_3 != (ulong *)0x0) {
      *param_3 = (ulong)*(uint *)(param_1 + 0x48);
    }
    if (param_2 != (long *)0x0) {
      local_18 = 0;
      for (local_10 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0); local_10 != 0;
          local_10 = _libssh2_list_next(local_10)) {
        if ((**(char **)(local_10 + 0x18) == '^') || (**(char **)(local_10 + 0x18) == '_')) {
          iVar1 = _libssh2_ntohu32(*(long *)(local_10 + 0x18) + 1);
          if (iVar1 == *(int *)(param_1 + 0x30)) {
            local_18 = local_18 + (*(long *)(local_10 + 0x20) - *(long *)(local_10 + 0x28));
          }
        }
      }
      *param_2 = local_18;
    }
    uVar2 = *(undefined4 *)(param_1 + 0x4c);
  }
  return uVar2;
}



undefined4 libssh2_channel_window_write_ex(long param_1,ulong *param_2)

{
  undefined4 uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    if (param_2 != (ulong *)0x0) {
      *param_2 = (ulong)*(uint *)(param_1 + 0x34);
    }
    uVar1 = *(undefined4 *)(param_1 + 0x38);
  }
  return uVar1;
}



undefined8 comp_method_none_comp(void)

{
  return 0;
}



undefined8
comp_method_none_decomp
          (undefined8 param_1,undefined8 *param_2,undefined8 *param_3,undefined8 param_4,
          undefined8 param_5,undefined8 param_6)

{
  *param_2 = param_5;
  *param_3 = param_6;
  return 0;
}



undefined1 * _libssh2_comp_methods(long param_1)

{
  undefined1 *puVar1;
  
  if (*(int *)(param_1 + 0x70) == 0) {
    puVar1 = no_comp_methods;
  }
  else {
    puVar1 = comp_methods;
  }
  return puVar1;
}



undefined8
crypt_init(long param_1,long param_2,undefined8 param_3,undefined4 *param_4,undefined8 param_5,
          undefined4 *param_6,undefined4 param_7,long *param_8)

{
  int iVar1;
  undefined4 *puVar2;
  undefined8 uVar3;
  
  puVar2 = (undefined4 *)(**(code **)(param_1 + 8))(0x18,param_1);
  if (puVar2 == (undefined4 *)0x0) {
    uVar3 = 0xfffffffa;
  }
  else {
    *puVar2 = param_7;
    *(undefined8 *)(puVar2 + 2) = *(undefined8 *)(param_2 + 0x40);
    iVar1 = _libssh2_cipher_init(puVar2 + 4,*(undefined8 *)(puVar2 + 2),param_3,param_5,param_7);
    if (iVar1 == 0) {
      *param_8 = (long)puVar2;
      *param_4 = 1;
      *param_6 = 1;
      uVar3 = 0;
    }
    else {
      (**(code **)(param_1 + 0x18))(puVar2,param_1);
      uVar3 = 0xffffffff;
    }
  }
  return uVar3;
}



void crypt_encrypt(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 *param_4)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)*param_4;
  _libssh2_cipher_crypt(puVar1 + 4,*(undefined8 *)(puVar1 + 2),*puVar1,param_2,param_3);
  return;
}



undefined8 crypt_dtor(long param_1,long *param_2)

{
  if ((param_2 != (long *)0x0) && (*param_2 != 0)) {
    EVP_CIPHER_CTX_free(*(EVP_CIPHER_CTX **)(*param_2 + 0x10));
    (**(code **)(param_1 + 0x18))(*param_2,param_1);
    *param_2 = 0;
  }
  return 0;
}



int crypt_init_arcfour128
              (undefined8 param_1,long param_2,undefined8 param_3,undefined8 param_4,
              undefined8 param_5,undefined8 param_6,undefined4 param_7,undefined8 *param_8)

{
  undefined4 *puVar1;
  int iVar2;
  long in_FS_OFFSET;
  long local_28;
  undefined local_18 [8];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar2 = crypt_init(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
  if (iVar2 == 0) {
    puVar1 = (undefined4 *)*param_8;
    for (local_28 = 0x600; local_28 != 0; local_28 = local_28 + -8) {
      _libssh2_cipher_crypt
                (puVar1 + 4,*(undefined8 *)(puVar1 + 2),*puVar1,local_18,
                 (long)*(int *)(param_2 + 0x10));
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



undefined1 * libssh2_crypt_methods(void)

{
  return _libssh2_crypt_methods;
}



undefined8 libssh2_init(uint param_1)

{
  if ((_libssh2_initialized == 0) && ((param_1 & 1) == 0)) {
    _libssh2_openssl_crypto_init();
  }
  _libssh2_initialized = _libssh2_initialized + 1;
  _libssh2_init_flags = _libssh2_init_flags | param_1;
  return 0;
}



void libssh2_exit(void)

{
  if ((_libssh2_initialized != 0) &&
     (_libssh2_initialized = _libssh2_initialized + -1, (_libssh2_init_flags & 1) == 0)) {
    _libssh2_openssl_crypto_exit();
  }
  return;
}



void _libssh2_init_if_needed(void)

{
  if (_libssh2_initialized == 0) {
    libssh2_init(0);
  }
  return;
}



undefined8
hostkey_method_ssh_rsa_init(undefined8 param_1,long param_2,undefined8 param_3,long *param_4)

{
  uint uVar1;
  int iVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  long local_48;
  char *local_40;
  ulong local_38;
  ulong local_30;
  char *local_28;
  ulong local_20;
  char *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_4 != 0) {
    hostkey_method_ssh_rsa_dtor(param_1,param_4);
    *param_4 = 0;
  }
  local_40 = (char *)param_2;
  uVar1 = _libssh2_ntohu32(param_2);
  local_38 = (ulong)uVar1;
  local_40 = (char *)((long)local_40 + 4);
  if (local_38 == 7) {
    iVar2 = strncmp(local_40,"ssh-rsa",7);
    if (iVar2 == 0) {
      local_40 = local_40 + 7;
      uVar1 = _libssh2_ntohu32(local_40);
      local_30 = (ulong)uVar1;
      local_28 = local_40 + 4;
      local_40 = local_28 + local_30;
      uVar1 = _libssh2_ntohu32(local_40);
      local_20 = (ulong)uVar1;
      local_40 = local_40 + 4;
      local_18 = local_40;
      iVar2 = _libssh2_rsa_new(&local_48,local_28,local_30,local_40,local_20,0,0,0,0,0,0,0,0,0,0,0,0
                              );
      if (iVar2 == 0) {
        *param_4 = local_48;
        uVar3 = 0;
      }
      else {
        uVar3 = 0xffffffff;
      }
      goto LAB_00118fc5;
    }
  }
  uVar3 = 0xffffffff;
LAB_00118fc5:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



undefined8
hostkey_method_ssh_rsa_initPEM
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,long *param_4)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_4 != 0) {
    hostkey_method_ssh_rsa_dtor(param_1,param_4);
    *param_4 = 0;
  }
  iVar1 = _libssh2_rsa_new_private(&local_18,param_1,param_2,param_3);
  if (iVar1 == 0) {
    *param_4 = local_18;
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
hostkey_method_ssh_rsa_initPEMFromMemory
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,long *param_5
          )

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_5 != 0) {
    hostkey_method_ssh_rsa_dtor(param_1,param_5);
    *param_5 = 0;
  }
  iVar1 = _libssh2_rsa_new_private_frommemory(&local_18,param_1,param_2,param_3,param_4);
  if (iVar1 == 0) {
    *param_5 = local_18;
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



void hostkey_method_ssh_rsa_sig_verify
               (undefined8 param_1,long param_2,long param_3,undefined8 param_4,undefined8 param_5,
               undefined8 *param_6)

{
  _libssh2_rsa_sha1_verify(*param_6,param_2 + 0xf,param_3 + -0xf,param_4,param_5);
  return;
}



undefined8
hostkey_method_ssh_rsa_signv
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,int param_4,long param_5,
          undefined8 *param_6)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  int local_40;
  EVP_MD_CTX *local_38;
  undefined8 local_30;
  uchar local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = *param_6;
  _libssh2_sha1_init(&local_38);
  for (local_40 = 0; local_40 < param_4; local_40 = local_40 + 1) {
    EVP_DigestUpdate(local_38,*(void **)(param_5 + (long)local_40 * 0x10),
                     *(size_t *)(param_5 + (long)local_40 * 0x10 + 8));
  }
  EVP_DigestFinal(local_38,local_28,(uint *)0x0);
  EVP_MD_CTX_free(local_38);
  iVar1 = _libssh2_rsa_sha1_sign(param_1,local_30,local_28,0x14,param_2,param_3);
  if (iVar1 == 0) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8 hostkey_method_ssh_rsa_dtor(undefined8 param_1,undefined8 *param_2)

{
  RSA_free((RSA *)*param_2);
  *param_2 = 0;
  return 0;
}



undefined8
hostkey_method_ssh_dss_init(undefined8 param_1,long param_2,undefined8 param_3,long *param_4)

{
  uint uVar1;
  int iVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  long local_68;
  char *local_60;
  ulong local_58;
  ulong local_50;
  char *local_48;
  ulong local_40;
  char *local_38;
  ulong local_30;
  char *local_28;
  ulong local_20;
  char *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_4 != 0) {
    hostkey_method_ssh_dss_dtor(param_1,param_4);
    *param_4 = 0;
  }
  local_60 = (char *)param_2;
  uVar1 = _libssh2_ntohu32(param_2);
  local_58 = (ulong)uVar1;
  local_60 = (char *)((long)local_60 + 4);
  if (local_58 == 7) {
    iVar2 = strncmp(local_60,"ssh-dss",7);
    if (iVar2 == 0) {
      local_60 = local_60 + 7;
      uVar1 = _libssh2_ntohu32(local_60);
      local_50 = (ulong)uVar1;
      local_48 = local_60 + 4;
      local_60 = local_48 + local_50;
      uVar1 = _libssh2_ntohu32(local_60);
      local_40 = (ulong)uVar1;
      local_38 = local_60 + 4;
      local_60 = local_38 + local_40;
      uVar1 = _libssh2_ntohu32(local_60);
      local_30 = (ulong)uVar1;
      local_28 = local_60 + 4;
      local_60 = local_28 + local_30;
      uVar1 = _libssh2_ntohu32(local_60);
      local_20 = (ulong)uVar1;
      local_60 = local_60 + 4;
      local_18 = local_60;
      iVar2 = _libssh2_dsa_new(&local_68,local_48,local_50,local_38,local_40,local_28,local_30,
                               local_60,local_20,0,0);
      if (iVar2 == 0) {
        *param_4 = local_68;
        uVar3 = 0;
      }
      else {
        uVar3 = 0xffffffff;
      }
      goto LAB_0011947d;
    }
  }
  uVar3 = 0xffffffff;
LAB_0011947d:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



undefined8
hostkey_method_ssh_dss_initPEM
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,long *param_4)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_4 != 0) {
    hostkey_method_ssh_dss_dtor(param_1,param_4);
    *param_4 = 0;
  }
  iVar1 = _libssh2_dsa_new_private(&local_18,param_1,param_2,param_3);
  if (iVar1 == 0) {
    *param_4 = local_18;
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
hostkey_method_ssh_dss_initPEMFromMemory
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,long *param_5
          )

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_5 != 0) {
    hostkey_method_ssh_dss_dtor(param_1,param_5);
    *param_5 = 0;
  }
  iVar1 = _libssh2_dsa_new_private_frommemory(&local_18,param_1,param_2,param_3,param_4);
  if (iVar1 == 0) {
    *param_5 = local_18;
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



void hostkey_method_ssh_dss_sig_verify
               (undefined8 param_1,long param_2,long param_3,undefined8 param_4,undefined8 param_5,
               undefined8 *param_6)

{
  if (param_3 == 0x37) {
    _libssh2_dsa_sha1_verify(*param_6,param_2 + 0xf,param_4,param_5);
  }
  else {
    _libssh2_error(param_1,0xfffffff2,"Invalid DSS signature length");
  }
  return;
}



undefined8
hostkey_method_ssh_dss_signv
          (long param_1,long *param_2,undefined8 *param_3,int param_4,long param_5,
          undefined8 *param_6)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  int local_3c;
  EVP_MD_CTX *local_38;
  undefined8 local_30;
  uchar local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = *param_6;
  lVar2 = _libssh2_calloc(param_1,0x28);
  *param_2 = lVar2;
  if (*param_2 == 0) {
    uVar3 = 0xffffffff;
  }
  else {
    *param_3 = 0x28;
    _libssh2_sha1_init(&local_38);
    for (local_3c = 0; local_3c < param_4; local_3c = local_3c + 1) {
      EVP_DigestUpdate(local_38,*(void **)(param_5 + (long)local_3c * 0x10),
                       *(size_t *)(param_5 + (long)local_3c * 0x10 + 8));
    }
    EVP_DigestFinal(local_38,local_28,(uint *)0x0);
    EVP_MD_CTX_free(local_38);
    iVar1 = _libssh2_dsa_sha1_sign(local_30,local_28,0x14,*param_2);
    if (iVar1 == 0) {
      uVar3 = 0;
    }
    else {
      (**(code **)(param_1 + 0x18))(*param_2,param_1);
      uVar3 = 0xffffffff;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



undefined8 hostkey_method_ssh_dss_dtor(undefined8 param_1,undefined8 *param_2)

{
  DSA_free((DSA *)*param_2);
  *param_2 = 0;
  return 0;
}



undefined8
hostkey_method_ssh_ecdsa_init(undefined8 param_1,long param_2,ulong param_3,long *param_4)

{
  uint uVar1;
  int iVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  int local_44;
  long local_40;
  char *local_38;
  ulong local_30;
  ulong local_28;
  ulong local_20;
  char *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = 0;
  if ((param_4 != (long *)0x0) && (*param_4 != 0)) {
    hostkey_method_ssh_ecdsa_dtor(param_1,param_4);
    *param_4 = 0;
  }
  if (param_3 < 0x17) {
    uVar3 = 0xffffffff;
  }
  else {
    local_38 = (char *)param_2;
    uVar1 = _libssh2_ntohu32(param_2);
    local_30 = (ulong)uVar1;
    local_38 = (char *)((long)local_38 + 4);
    if (local_30 == 0x13) {
      iVar2 = strncmp(local_38,"ecdsa-sha2-nistp256",0x13);
      if (iVar2 == 0) {
        local_44 = 0x19f;
      }
      else {
        iVar2 = strncmp(local_38,"ecdsa-sha2-nistp384",0x13);
        if (iVar2 == 0) {
          local_44 = 0x2cb;
        }
        else {
          iVar2 = strncmp(local_38,"ecdsa-sha2-nistp521",0x13);
          if (iVar2 != 0) {
            uVar3 = 0xffffffff;
            goto LAB_00119a1e;
          }
          local_44 = 0x2cc;
        }
      }
      local_38 = local_38 + 0x13;
      uVar1 = _libssh2_ntohu32(local_38);
      local_28 = (ulong)uVar1;
      local_38 = local_38 + 4;
      if (local_28 == 8) {
        if (local_44 == 0x19f) {
          iVar2 = strncmp(local_38,"nistp256",8);
          if (iVar2 != 0) {
            uVar3 = 0xffffffff;
            goto LAB_00119a1e;
          }
        }
        if (local_44 == 0x2cb) {
          iVar2 = strncmp(local_38,"nistp384",8);
          if (iVar2 != 0) {
            uVar3 = 0xffffffff;
            goto LAB_00119a1e;
          }
        }
        if (local_44 == 0x2cc) {
          iVar2 = strncmp(local_38,"nistp521",8);
          if (iVar2 != 0) {
            uVar3 = 0xffffffff;
            goto LAB_00119a1e;
          }
        }
        local_38 = local_38 + 8;
        uVar1 = _libssh2_ntohu32(local_38);
        local_20 = (ulong)uVar1;
        local_38 = local_38 + 4;
        local_18 = local_38;
        iVar2 = _libssh2_ecdsa_curve_name_with_octal_new(&local_40,local_38,local_20,local_44);
        if (iVar2 == 0) {
          if (param_4 != (long *)0x0) {
            *param_4 = local_40;
          }
          uVar3 = 0;
        }
        else {
          uVar3 = 0xffffffff;
        }
      }
      else {
        uVar3 = 0xffffffff;
      }
    }
    else {
      uVar3 = 0xffffffff;
    }
  }
LAB_00119a1e:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



undefined4
hostkey_method_ssh_ecdsa_initPEM
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,long *param_4)

{
  undefined4 uVar1;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = 0;
  if ((param_4 != (long *)0x0) && (*param_4 != 0)) {
    hostkey_method_ssh_ecdsa_dtor(param_1,param_4);
    *param_4 = 0;
  }
  uVar1 = _libssh2_ecdsa_new_private(&local_18,param_1,param_2,param_3);
  if (param_4 != (long *)0x0) {
    *param_4 = local_18;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



undefined8
hostkey_method_ssh_ecdsa_initPEMFromMemory
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,long *param_5
          )

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = 0;
  if ((param_5 != (long *)0x0) && (*param_5 != 0)) {
    hostkey_method_ssh_ecdsa_dtor(param_1,param_5);
    *param_5 = 0;
  }
  iVar1 = _libssh2_ecdsa_new_private_frommemory(&local_18,param_1,param_2,param_3,param_4);
  if (iVar1 == 0) {
    if (param_5 != (long *)0x0) {
      *param_5 = local_18;
    }
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
hostkey_method_ssh_ecdsa_sig_verify
          (undefined8 param_1,long param_2,ulong param_3,undefined8 param_4,undefined8 param_5,
          undefined8 *param_6)

{
  long lVar1;
  uint uVar2;
  undefined4 uVar3;
  undefined8 uVar4;
  
  uVar4 = *param_6;
  if (param_3 < 0x23) {
    uVar4 = 0xffffffff;
  }
  else {
    uVar2 = _libssh2_ntohu32(param_2 + 0x1b);
    lVar1 = param_2 + 0x1f + (ulong)uVar2;
    uVar3 = _libssh2_ntohu32(lVar1);
    uVar4 = _libssh2_ecdsa_verify(uVar4,param_2 + 0x1f,(ulong)uVar2,lVar1 + 4,uVar3,param_4,param_5)
    ;
  }
  return uVar4;
}



undefined4
hostkey_method_ssh_ecdsa_signv
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,int param_4,long param_5,
          undefined8 *param_6)

{
  int iVar1;
  undefined4 uVar2;
  long in_FS_OFFSET;
  int local_78;
  int local_74;
  int local_70;
  EVP_MD_CTX *local_68;
  undefined8 local_60;
  uchar local_58 [72];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_60 = *param_6;
  iVar1 = _libssh2_ecdsa_key_get_curve_type(local_60);
  if (iVar1 == 0x19f) {
    _libssh2_sha256_init(&local_68);
    for (local_78 = 0; local_78 < param_4; local_78 = local_78 + 1) {
      EVP_DigestUpdate(local_68,*(void **)(param_5 + (long)local_78 * 0x10),
                       *(size_t *)(param_5 + (long)local_78 * 0x10 + 8));
    }
    EVP_DigestFinal(local_68,local_58,(uint *)0x0);
    EVP_MD_CTX_free(local_68);
    uVar2 = _libssh2_ecdsa_sign(param_1,local_60,local_58,0x20,param_2,param_3);
  }
  else if (iVar1 == 0x2cb) {
    _libssh2_sha384_init(&local_68);
    for (local_74 = 0; local_74 < param_4; local_74 = local_74 + 1) {
      EVP_DigestUpdate(local_68,*(void **)(param_5 + (long)local_74 * 0x10),
                       *(size_t *)(param_5 + (long)local_74 * 0x10 + 8));
    }
    EVP_DigestFinal(local_68,local_58,(uint *)0x0);
    EVP_MD_CTX_free(local_68);
    uVar2 = _libssh2_ecdsa_sign(param_1,local_60,local_58,0x30,param_2,param_3);
  }
  else if (iVar1 == 0x2cc) {
    _libssh2_sha512_init(&local_68);
    for (local_70 = 0; local_70 < param_4; local_70 = local_70 + 1) {
      EVP_DigestUpdate(local_68,*(void **)(param_5 + (long)local_70 * 0x10),
                       *(size_t *)(param_5 + (long)local_70 * 0x10 + 8));
    }
    EVP_DigestFinal(local_68,local_58,(uint *)0x0);
    EVP_MD_CTX_free(local_68);
    uVar2 = _libssh2_ecdsa_sign(param_1,local_60,local_58,0x40,param_2,param_3);
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 hostkey_method_ssh_ecdsa_dtor(undefined8 param_1,undefined8 *param_2)

{
  if ((EC_KEY *)*param_2 != (EC_KEY *)0x0) {
    EC_KEY_free((EC_KEY *)*param_2);
  }
  *param_2 = 0;
  return 0;
}



undefined8
hostkey_method_ssh_ed25519_init(undefined8 param_1,long param_2,ulong param_3,long *param_4)

{
  uint uVar1;
  int iVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  long local_30;
  char *local_28;
  ulong local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = 0;
  if (*param_4 != 0) {
    hostkey_method_ssh_ed25519_dtor(param_1,param_4);
    *param_4 = 0;
  }
  if (param_3 < 0xf) {
    uVar3 = 0xffffffff;
  }
  else {
    local_28 = (char *)param_2;
    uVar1 = _libssh2_ntohu32(param_2);
    local_20 = (ulong)uVar1;
    local_28 = (char *)((long)local_28 + 4);
    if (local_20 == 0xb) {
      iVar2 = strncmp(local_28,"ssh-ed25519",0xb);
      if (iVar2 == 0) {
        local_28 = local_28 + 0xb;
        uVar1 = _libssh2_ntohu32(local_28);
        local_18 = (ulong)uVar1;
        local_28 = local_28 + 4;
        iVar2 = _libssh2_ed25519_new_public(&local_30,param_1,local_28,local_18 & 0xff);
        if (iVar2 == 0) {
          *param_4 = local_30;
          uVar3 = 0;
        }
        else {
          uVar3 = 0xffffffff;
        }
        goto LAB_0011a0aa;
      }
    }
    uVar3 = 0xffffffff;
  }
LAB_0011a0aa:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



undefined4
hostkey_method_ssh_ed25519_initPEM
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,long *param_4)

{
  int iVar1;
  undefined4 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = 0;
  if (*param_4 != 0) {
    hostkey_method_ssh_ed25519_dtor(param_1,param_4);
    *param_4 = 0;
  }
  iVar1 = _libssh2_ed25519_new_private(&local_18,param_1,param_2,param_3);
  if (iVar1 == 0) {
    *param_4 = local_18;
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
hostkey_method_ssh_ed25519_initPEMFromMemory
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,long *param_5
          )

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = 0;
  if ((param_5 != (long *)0x0) && (*param_5 != 0)) {
    hostkey_method_ssh_ed25519_dtor(param_1,param_5);
    *param_5 = 0;
  }
  iVar1 = _libssh2_ed25519_new_private_frommemory(&local_18,param_1,param_2,param_3,param_4);
  if (iVar1 == 0) {
    if (param_5 != (long *)0x0) {
      *param_5 = local_18;
    }
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
hostkey_method_ssh_ed25519_sig_verify
          (undefined8 param_1,long param_2,ulong param_3,undefined8 param_4,undefined8 param_5,
          undefined8 *param_6)

{
  undefined8 uVar1;
  
  if (param_3 < 0x13) {
    uVar1 = 0xffffffff;
  }
  else if (param_3 == 0x53) {
    uVar1 = _libssh2_ed25519_verify(*param_6,param_2 + 0x13,0x40,param_4,param_5);
  }
  else {
    uVar1 = 0xffffffff;
  }
  return uVar1;
}



undefined8
hostkey_method_ssh_ed25519_signv
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,int param_4,undefined8 *param_5,
          undefined8 *param_6)

{
  undefined8 uVar1;
  
  if (param_4 == 1) {
    uVar1 = _libssh2_ed25519_sign(*param_6,param_1,param_2,param_3,*param_5,param_5[1]);
  }
  else {
    uVar1 = 0xffffffff;
  }
  return uVar1;
}



undefined8 hostkey_method_ssh_ed25519_dtor(undefined8 param_1,undefined8 *param_2)

{
  long *__ptr;
  
  __ptr = (long *)*param_2;
  if ((__ptr != (long *)0x0) && (__ptr != (long *)0x0)) {
    if (*__ptr != 0) {
      EVP_PKEY_free((EVP_PKEY *)*__ptr);
    }
    if (__ptr[1] != 0) {
      EVP_PKEY_free((EVP_PKEY *)__ptr[1]);
    }
    free(__ptr);
  }
  *param_2 = 0;
  return 0;
}



undefined1 * libssh2_hostkey_methods(void)

{
  return hostkey_methods;
}



long libssh2_hostkey_hash(long param_1,int param_2)

{
  if (param_2 == 3) {
    if (*(int *)(param_1 + 0x108) != 0) {
      return param_1 + 0xe8;
    }
    return 0;
  }
  if (param_2 < 4) {
    if (param_2 == 1) {
      if (*(int *)(param_1 + 0xcc) != 0) {
        return param_1 + 0xbc;
      }
      return 0;
    }
    if (param_2 == 2) {
      if (*(int *)(param_1 + 0xe4) != 0) {
        return param_1 + 0xd0;
      }
      return 0;
    }
  }
  return 0;
}



undefined8 hostkey_type(void *param_1,ulong param_2)

{
  int iVar1;
  undefined8 uVar2;
  
  if (param_2 < 0xb) {
    uVar2 = 0;
  }
  else {
    iVar1 = memcmp(rsa_20299,param_1,0xb);
    if (iVar1 == 0) {
      uVar2 = 1;
    }
    else {
      iVar1 = memcmp(&dss_20300,param_1,0xb);
      if (iVar1 == 0) {
        uVar2 = 2;
      }
      else if (param_2 < 0xf) {
        uVar2 = 0;
      }
      else {
        iVar1 = memcmp(ed25519_20304,param_1,0xf);
        if (iVar1 == 0) {
          uVar2 = 6;
        }
        else if (param_2 < 0x17) {
          uVar2 = 0;
        }
        else {
          iVar1 = memcmp(&ecdsa_256_20301,param_1,0x17);
          if (iVar1 == 0) {
            uVar2 = 3;
          }
          else {
            iVar1 = memcmp(&ecdsa_384_20302,param_1,0x17);
            if (iVar1 == 0) {
              uVar2 = 4;
            }
            else {
              iVar1 = memcmp(&ecdsa_521_20303,param_1,0x17);
              if (iVar1 == 0) {
                uVar2 = 5;
              }
              else {
                uVar2 = 0;
              }
            }
          }
        }
      }
    }
  }
  return uVar2;
}



undefined8 libssh2_session_hostkey(long param_1,ulong *param_2,undefined4 *param_3)

{
  undefined4 uVar1;
  undefined8 uVar2;
  
  if (*(int *)(param_1 + 0xb8) == 0) {
    if (param_2 != (ulong *)0x0) {
      *param_2 = 0;
    }
    uVar2 = 0;
  }
  else {
    if (param_2 != (ulong *)0x0) {
      *param_2 = (ulong)*(uint *)(param_1 + 0xb8);
    }
    if (param_3 != (undefined4 *)0x0) {
      uVar1 = hostkey_type(*(undefined8 *)(param_1 + 0xb0),*(undefined4 *)(param_1 + 0xb8));
      *param_3 = uVar1;
    }
    uVar2 = *(undefined8 *)(param_1 + 0xb0);
  }
  return uVar2;
}



void libssh2_keepalive_config(long param_1,int param_2,int param_3)

{
  if (param_3 == 1) {
    *(undefined4 *)(param_1 + 0xd630) = 2;
  }
  else {
    *(int *)(param_1 + 0xd630) = param_3;
  }
  *(uint *)(param_1 + 0xd634) = (uint)(param_2 != 0);
  return;
}



int libssh2_keepalive_send(long param_1,int *param_2)

{
  int iVar1;
  time_t tVar2;
  long in_FS_OFFSET;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined4 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd630) == 0) {
    if (param_2 != (int *)0x0) {
      *param_2 = 0;
    }
    iVar1 = 0;
  }
  else {
    tVar2 = time((time_t *)0x0);
    if (tVar2 < (long)*(int *)(param_1 + 0xd630) + *(long *)(param_1 + 0xd638)) {
      if (param_2 != (int *)0x0) {
        *param_2 = ((int)*(undefined8 *)(param_1 + 0xd638) - (int)tVar2) +
                   *(int *)(param_1 + 0xd630);
      }
    }
    else {
      local_38 = 0x65656b1500000050;
      local_30 = 0x6c406576696c6170;
      local_28 = 0x6f2e326873736269;
      local_20 = 0x576772;
      iVar1 = _libssh2_transport_send(param_1,&local_38,0x1b,0,0);
      if ((iVar1 != 0) && (iVar1 != -0x25)) {
        _libssh2_error(param_1,0xfffffff9,"Unable to send keepalive message");
        goto LAB_0011a7ad;
      }
      *(time_t *)(param_1 + 0xd638) = tVar2;
      if (param_2 != (int *)0x0) {
        *param_2 = *(int *)(param_1 + 0xd630);
      }
    }
    iVar1 = 0;
  }
LAB_0011a7ad:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int diffie_hellman_sha1(long param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4,
                       char param_5,undefined param_6,void *param_7,size_t param_8,int *param_9)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  undefined4 uVar4;
  BN_CTX *pBVar5;
  BIGNUM *pBVar6;
  undefined8 uVar7;
  size_t sVar8;
  long in_FS_OFFSET;
  int local_94;
  int local_90;
  int local_8c;
  int local_88;
  int local_84;
  EVP_MD_CTX *local_80;
  EVP_MD_CTX *local_78;
  void *local_70;
  void *local_68;
  ulong local_60;
  ulong local_58;
  void *local_50;
  void *local_48;
  ulong local_40;
  ulong local_38;
  void *local_30;
  ulong local_28;
  void *local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_8c = 0;
  if (*param_9 == 0) {
    param_9[2] = 0;
    param_9[3] = 0;
    param_9[4] = 0;
    param_9[5] = 0;
    param_9[0x2e] = 0;
    param_9[0x2f] = 0;
    pBVar5 = BN_CTX_new();
    *(BN_CTX **)(param_9 + 0x20) = pBVar5;
    FUN_0010b4b0(param_9 + 0x22);
    pBVar6 = BN_new();
    *(BIGNUM **)(param_9 + 0x24) = pBVar6;
    pBVar6 = BN_new();
    *(BIGNUM **)(param_9 + 0x26) = pBVar6;
    pBVar6 = BN_new();
    *(BIGNUM **)(param_9 + 0x28) = pBVar6;
    memset(param_9 + 0x3a,0,0x10);
    local_88 = _libssh2_dh_key_pair
                         (param_9 + 0x22,*(undefined8 *)(param_9 + 0x24),param_2,param_3,param_4,
                          *(undefined8 *)(param_9 + 0x20));
    iVar3 = local_8c;
    if (local_88 == 0) {
      iVar1 = BN_num_bits(*(BIGNUM **)(param_9 + 0x24));
      iVar3 = iVar1 + 7;
      if (iVar1 + 7 < 0) {
        iVar3 = iVar1 + 0xe;
      }
      *(long *)(param_9 + 0x1a) = (long)((iVar3 >> 3) + 6);
      uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x24));
      if ((uVar2 & 7) != 0) {
        *(long *)(param_9 + 0x1a) = *(long *)(param_9 + 0x1a) + -1;
      }
      uVar7 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_9 + 0x1a),param_1);
      *(undefined8 *)(param_9 + 2) = uVar7;
      if (*(long *)(param_9 + 2) != 0) {
        **(char **)(param_9 + 2) = param_5;
        _libssh2_htonu32(*(long *)(param_9 + 2) + 1,(int)*(undefined8 *)(param_9 + 0x1a) + -5);
        uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x24));
        if ((uVar2 & 7) == 0) {
          *(undefined *)(*(long *)(param_9 + 2) + 5) = 0;
          BN_bn2bin(*(BIGNUM **)(param_9 + 0x24),(uchar *)(*(long *)(param_9 + 2) + 6));
        }
        else {
          BN_bn2bin(*(BIGNUM **)(param_9 + 0x24),(uchar *)(*(long *)(param_9 + 2) + 5));
        }
        *param_9 = 2;
        goto LAB_0011aae5;
      }
      iVar3 = _libssh2_error(param_1,0xfffffffa,"Out of memory error");
    }
  }
  else {
LAB_0011aae5:
    if (*param_9 == 2) {
      local_88 = _libssh2_transport_send
                           (param_1,*(undefined8 *)(param_9 + 2),*(undefined8 *)(param_9 + 0x1a),0,0
                           );
      if (local_88 == -0x25) {
        iVar3 = -0x25;
        goto LAB_0011cbc4;
      }
      if (local_88 != 0) {
        iVar3 = _libssh2_error(param_1,local_88,"Unable to send KEX init message");
        goto LAB_0011ca27;
      }
      *param_9 = 3;
    }
    if (*param_9 == 3) {
      if ((*(byte *)(param_1 + 0x80) & 1) != 0) {
        local_84 = _libssh2_packet_burn(param_1,param_9 + 0x3e);
        iVar3 = local_84;
        if (local_84 == -0x25) goto LAB_0011cbc4;
        if (local_84 < 1) goto LAB_0011ca27;
        *(byte *)(param_1 + 0x80) = *(byte *)(param_1 + 0x80) & 0xfe;
      }
      *param_9 = 4;
    }
    if (*param_9 == 4) {
      local_88 = _libssh2_packet_require
                           (param_1,param_6,param_9 + 4,param_9 + 0x1c,0,0,0,param_9 + 0x3a);
      if (local_88 == -0x25) {
        iVar3 = -0x25;
        goto LAB_0011cbc4;
      }
      if (local_88 == 0) {
        *(long *)(param_9 + 0x2a) = *(long *)(param_9 + 4) + 1;
        uVar4 = _libssh2_ntohu32(*(undefined8 *)(param_9 + 0x2a));
        *(undefined4 *)(param_1 + 0xb8) = uVar4;
        *(long *)(param_9 + 0x2a) = *(long *)(param_9 + 0x2a) + 4;
        if (*(long *)(param_1 + 0xb0) != 0) {
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xb0),param_1);
        }
        uVar7 = (**(code **)(param_1 + 8))(*(undefined4 *)(param_1 + 0xb8),param_1);
        *(undefined8 *)(param_1 + 0xb0) = uVar7;
        if (*(long *)(param_1 + 0xb0) == 0) {
          iVar3 = _libssh2_error(param_1,0xfffffffa,
                                 "Unable to allocate memory for a copy of the host key");
        }
        else {
          memcpy(*(void **)(param_1 + 0xb0),*(void **)(param_9 + 0x2a),
                 (ulong)*(uint *)(param_1 + 0xb8));
          *(ulong *)(param_9 + 0x2a) = *(long *)(param_9 + 0x2a) + (ulong)*(uint *)(param_1 + 0xb8);
          iVar3 = _libssh2_md5_init(&local_78);
          if (iVar3 == 0) {
            *(undefined4 *)(param_1 + 0xcc) = 0;
          }
          else {
            EVP_DigestUpdate(local_78,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));
            EVP_DigestFinal(local_78,(uchar *)(param_1 + 0xbc),(uint *)0x0);
            EVP_MD_CTX_free(local_78);
            *(undefined4 *)(param_1 + 0xcc) = 1;
          }
          iVar3 = _libssh2_sha1_init(&local_78);
          if (iVar3 == 0) {
            *(undefined4 *)(param_1 + 0xe4) = 0;
          }
          else {
            EVP_DigestUpdate(local_78,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));
            EVP_DigestFinal(local_78,(uchar *)(param_1 + 0xd0),(uint *)0x0);
            EVP_MD_CTX_free(local_78);
            *(undefined4 *)(param_1 + 0xe4) = 1;
          }
          iVar3 = _libssh2_sha256_init(&local_78);
          if (iVar3 == 0) {
            *(undefined4 *)(param_1 + 0x108) = 0;
          }
          else {
            EVP_DigestUpdate(local_78,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));
            EVP_DigestFinal(local_78,(uchar *)(param_1 + 0xe8),(uint *)0x0);
            EVP_MD_CTX_free(local_78);
            *(undefined4 *)(param_1 + 0x108) = 1;
          }
          iVar3 = (**(code **)(*(long *)(param_1 + 0xa0) + 0x10))
                            (param_1,*(undefined8 *)(param_1 + 0xb0),*(undefined4 *)(param_1 + 0xb8)
                             ,param_1 + 0xa8);
          if (iVar3 == 0) {
            uVar2 = _libssh2_ntohu32(*(undefined8 *)(param_9 + 0x2a));
            *(ulong *)(param_9 + 0x32) = (ulong)uVar2;
            *(long *)(param_9 + 0x2a) = *(long *)(param_9 + 0x2a) + 4;
            *(undefined8 *)(param_9 + 0x2c) = *(undefined8 *)(param_9 + 0x2a);
            *(long *)(param_9 + 0x2a) = *(long *)(param_9 + 0x2a) + *(long *)(param_9 + 0x32);
            BN_bin2bn(*(uchar **)(param_9 + 0x2c),(int)*(undefined8 *)(param_9 + 0x32),
                      *(BIGNUM **)(param_9 + 0x26));
            uVar2 = _libssh2_ntohu32(*(undefined8 *)(param_9 + 0x2a));
            *(ulong *)(param_9 + 0x36) = (ulong)uVar2;
            *(long *)(param_9 + 0x2a) = *(long *)(param_9 + 0x2a) + 4;
            *(undefined8 *)(param_9 + 0x30) = *(undefined8 *)(param_9 + 0x2a);
            _libssh2_dh_secret(param_9 + 0x22,*(undefined8 *)(param_9 + 0x28),
                               *(undefined8 *)(param_9 + 0x26),param_3,
                               *(undefined8 *)(param_9 + 0x20));
            iVar1 = BN_num_bits(*(BIGNUM **)(param_9 + 0x28));
            iVar3 = iVar1 + 7;
            if (iVar1 + 7 < 0) {
              iVar3 = iVar1 + 0xe;
            }
            *(long *)(param_9 + 0x34) = (long)((iVar3 >> 3) + 5);
            uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x28));
            if ((uVar2 & 7) != 0) {
              *(long *)(param_9 + 0x34) = *(long *)(param_9 + 0x34) + -1;
            }
            uVar7 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_9 + 0x34),param_1);
            *(undefined8 *)(param_9 + 0x2e) = uVar7;
            if (*(long *)(param_9 + 0x2e) == 0) {
              iVar3 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for K");
            }
            else {
              _libssh2_htonu32(*(undefined8 *)(param_9 + 0x2e),
                               (int)*(undefined8 *)(param_9 + 0x34) + -4);
              uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x28));
              if ((uVar2 & 7) == 0) {
                *(undefined *)(*(long *)(param_9 + 0x2e) + 4) = 0;
                BN_bn2bin(*(BIGNUM **)(param_9 + 0x28),(uchar *)(*(long *)(param_9 + 0x2e) + 5));
              }
              else {
                BN_bn2bin(*(BIGNUM **)(param_9 + 0x28),(uchar *)(*(long *)(param_9 + 0x2e) + 4));
              }
              *(EVP_MD_CTX ***)(param_9 + 0x38) = &local_80;
              _libssh2_sha1_init(&local_80);
              if (*(long *)(param_1 + 0x180) == 0) {
                _libssh2_htonu32(param_9 + 8,0x19);
                EVP_DigestUpdate(local_80,param_9 + 8,4);
                EVP_DigestUpdate(local_80,"SSH-2.0-libssh2_1.9.0_DEV",0x19);
              }
              else {
                sVar8 = strlen(*(char **)(param_1 + 0x180));
                _libssh2_htonu32(param_9 + 8,(int)sVar8 + -2);
                EVP_DigestUpdate(local_80,param_9 + 8,4);
                sVar8 = strlen(*(char **)(param_1 + 0x180));
                EVP_DigestUpdate(local_80,*(void **)(param_1 + 0x180),sVar8 - 2);
              }
              sVar8 = strlen(*(char **)(param_1 + 0x110));
              _libssh2_htonu32(param_9 + 8,sVar8 & 0xffffffff);
              EVP_DigestUpdate(local_80,param_9 + 8,4);
              sVar8 = strlen(*(char **)(param_1 + 0x110));
              EVP_DigestUpdate(local_80,*(void **)(param_1 + 0x110),sVar8);
              _libssh2_htonu32(param_9 + 8,*(ulong *)(param_1 + 400) & 0xffffffff);
              EVP_DigestUpdate(local_80,param_9 + 8,4);
              EVP_DigestUpdate(local_80,*(void **)(param_1 + 0x188),*(size_t *)(param_1 + 400));
              _libssh2_htonu32(param_9 + 8,*(ulong *)(param_1 + 0x120) & 0xffffffff);
              EVP_DigestUpdate(local_80,param_9 + 8,4);
              EVP_DigestUpdate(local_80,*(void **)(param_1 + 0x118),*(size_t *)(param_1 + 0x120));
              _libssh2_htonu32(param_9 + 8,*(undefined4 *)(param_1 + 0xb8));
              EVP_DigestUpdate(local_80,param_9 + 8,4);
              EVP_DigestUpdate(local_80,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8))
              ;
              if (param_5 == ' ') {
                _libssh2_htonu32(param_9 + 8,0x400);
                _libssh2_htonu32(param_9 + 9,0x600);
                _libssh2_htonu32(param_9 + 10,0x800);
                EVP_DigestUpdate(local_80,param_9 + 8,0xc);
              }
              if (param_7 != (void *)0x0) {
                EVP_DigestUpdate(local_80,param_7,param_8);
              }
              EVP_DigestUpdate(local_80,(void *)(*(long *)(param_9 + 2) + 1),
                               *(long *)(param_9 + 0x1a) - 1);
              _libssh2_htonu32(param_9 + 8,*(ulong *)(param_9 + 0x32) & 0xffffffff);
              EVP_DigestUpdate(local_80,param_9 + 8,4);
              EVP_DigestUpdate(local_80,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32));
              EVP_DigestUpdate(local_80,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34));
              EVP_DigestFinal(local_80,(uchar *)(param_9 + 8),(uint *)0x0);
              EVP_MD_CTX_free(local_80);
              iVar3 = (**(code **)(*(long *)(param_1 + 0xa0) + 0x28))
                                (param_1,*(undefined8 *)(param_9 + 0x30),
                                 *(undefined8 *)(param_9 + 0x36),param_9 + 8,0x14,param_1 + 0xa8);
              if (iVar3 == 0) {
                *(undefined *)(param_9 + 0x18) = 0x15;
                *param_9 = 5;
                goto LAB_0011b834;
              }
              iVar3 = _libssh2_error(param_1,0xfffffff5,"Unable to verify hostkey signature");
            }
          }
          else {
            iVar3 = _libssh2_error(param_1,0xfffffff6,"Unable to initialize hostkey importer");
          }
        }
      }
      else {
        iVar3 = _libssh2_error(param_1,0xfffffff7,"Timed out waiting for KEX reply");
      }
    }
    else {
LAB_0011b834:
      if (*param_9 == 5) {
        local_88 = _libssh2_transport_send(param_1,param_9 + 0x18,1,0,0);
        if (local_88 == -0x25) {
          iVar3 = -0x25;
          goto LAB_0011cbc4;
        }
        if (local_88 != 0) {
          iVar3 = _libssh2_error(param_1,local_88,"Unable to send NEWKEYS message");
          goto LAB_0011ca27;
        }
        *param_9 = 6;
      }
      iVar3 = local_8c;
      if (*param_9 == 6) {
        local_88 = _libssh2_packet_require
                             (param_1,0x15,param_9 + 6,param_9 + 0x1e,0,0,0,param_9 + 0x3a);
        if (local_88 == -0x25) {
          iVar3 = -0x25;
          goto LAB_0011cbc4;
        }
        if (local_88 == 0) {
          *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 2;
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_9 + 6),param_1);
          if (*(long *)(param_1 + 0x88) == 0) {
            uVar7 = (**(code **)(param_1 + 8))(0x14,param_1);
            *(undefined8 *)(param_1 + 0x88) = uVar7;
            if (*(long *)(param_1 + 0x88) == 0) {
              iVar3 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for SHA digest");
              goto LAB_0011ca27;
            }
            memcpy(*(void **)(param_1 + 0x88),param_9 + 8,0x14);
            *(undefined4 *)(param_1 + 0x90) = 0x14;
          }
          if (*(long *)(*(long *)(param_1 + 0x198) + 0x38) != 0) {
            (**(code **)(*(long *)(param_1 + 0x198) + 0x38))(param_1,param_1 + 0x1a0);
          }
          if (*(long *)(*(long *)(param_1 + 0x198) + 0x28) == 0) {
LAB_0011bf04:
            if (*(long *)(*(long *)(param_1 + 0x128) + 0x38) != 0) {
              (**(code **)(*(long *)(param_1 + 0x128) + 0x38))(param_1,param_1 + 0x130);
            }
            if (*(long *)(*(long *)(param_1 + 0x128) + 0x28) == 0) {
LAB_0011c3c6:
              if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x20) != 0) {
                (**(code **)(*(long *)(param_1 + 0x1a8) + 0x20))(param_1,param_1 + 0x1b8);
              }
              if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x10) != 0) {
                local_30 = (void *)0x0;
                local_90 = 0;
                local_28 = 0;
                if (true) {
                  local_30 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x1a8) + 0xc) +
                                                      0x14),param_1);
                }
                if (local_30 != (void *)0x0) {
                  for (; local_28 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc);
                      local_28 = local_28 + 0x14) {
                    _libssh2_sha1_init(&local_78);
                    EVP_DigestUpdate(local_78,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34)
                                    );
                    EVP_DigestUpdate(local_78,param_9 + 8,0x14);
                    if (local_28 == 0) {
                      EVP_DigestUpdate(local_78,&DAT_00146571,1);
                      EVP_DigestUpdate(local_78,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_78,local_30,local_28);
                    }
                    EVP_DigestFinal(local_78,(uchar *)((long)local_30 + local_28),(uint *)0x0);
                    EVP_MD_CTX_free(local_78);
                  }
                }
                if (local_30 == (void *)0x0) {
                  local_8c = -5;
                  iVar3 = local_8c;
                  goto LAB_0011ca27;
                }
                (**(code **)(*(long *)(param_1 + 0x1a8) + 0x10))
                          (param_1,local_30,&local_90,param_1 + 0x1b8);
                if (local_90 != 0) {
                  _libssh2_explicit_zero(local_30,(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc));
                  (**(code **)(param_1 + 0x18))(local_30,param_1);
                }
              }
              if (*(long *)(*(long *)(param_1 + 0x138) + 0x20) != 0) {
                (**(code **)(*(long *)(param_1 + 0x138) + 0x20))(param_1,param_1 + 0x148);
              }
              if (*(long *)(*(long *)(param_1 + 0x138) + 0x10) != 0) {
                local_20 = (void *)0x0;
                local_90 = 0;
                local_18 = 0;
                if (true) {
                  local_20 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x138) + 0xc) +
                                                      0x14),param_1);
                }
                if (local_20 != (void *)0x0) {
                  for (; local_18 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc);
                      local_18 = local_18 + 0x14) {
                    _libssh2_sha1_init(&local_78);
                    EVP_DigestUpdate(local_78,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34)
                                    );
                    EVP_DigestUpdate(local_78,param_9 + 8,0x14);
                    if (local_18 == 0) {
                      EVP_DigestUpdate(local_78,&DAT_00146573,1);
                      EVP_DigestUpdate(local_78,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_78,local_20,local_18);
                    }
                    EVP_DigestFinal(local_78,(uchar *)((long)local_20 + local_18),(uint *)0x0);
                    EVP_MD_CTX_free(local_78);
                  }
                }
                if (local_20 == (void *)0x0) {
                  local_8c = -5;
                  iVar3 = local_8c;
                  goto LAB_0011ca27;
                }
                (**(code **)(*(long *)(param_1 + 0x138) + 0x10))
                          (param_1,local_20,&local_90,param_1 + 0x148);
                if (local_90 != 0) {
                  _libssh2_explicit_zero(local_20,(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc));
                  (**(code **)(param_1 + 0x18))(local_20,param_1);
                }
              }
              if ((*(long *)(param_1 + 0x1c0) != 0) &&
                 (*(long *)(*(long *)(param_1 + 0x1c0) + 0x28) != 0)) {
                (**(code **)(*(long *)(param_1 + 0x1c0) + 0x28))(param_1,1,param_1 + 0x1c8);
              }
              if (((*(long *)(param_1 + 0x1c0) == 0) ||
                  (*(long *)(*(long *)(param_1 + 0x1c0) + 0x10) == 0)) ||
                 (iVar3 = (**(code **)(*(long *)(param_1 + 0x1c0) + 0x10))
                                    (param_1,1,param_1 + 0x1c8), iVar3 == 0)) {
                if ((*(long *)(param_1 + 0x150) != 0) &&
                   (*(long *)(*(long *)(param_1 + 0x150) + 0x28) != 0)) {
                  (**(code **)(*(long *)(param_1 + 0x150) + 0x28))(param_1,0,param_1 + 0x158);
                }
                iVar3 = local_8c;
                if (((*(long *)(param_1 + 0x150) != 0) &&
                    (*(long *)(*(long *)(param_1 + 0x150) + 0x10) != 0)) &&
                   (iVar1 = (**(code **)(*(long *)(param_1 + 0x150) + 0x10))
                                      (param_1,0,param_1 + 0x158), iVar3 = local_8c, iVar1 != 0)) {
                  local_8c = -5;
                  iVar3 = local_8c;
                }
              }
              else {
                local_8c = -5;
                iVar3 = local_8c;
              }
            }
            else {
              local_50 = (void *)0x0;
              local_48 = (void *)0x0;
              local_94 = 0;
              local_90 = 0;
              local_40 = 0;
              if (true) {
                local_50 = (void *)(**(code **)(param_1 + 8))
                                             ((long)(*(int *)(*(long *)(param_1 + 0x128) + 0x14) +
                                                    0x14),param_1);
              }
              if (local_50 != (void *)0x0) {
                for (; local_40 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14);
                    local_40 = local_40 + 0x14) {
                  _libssh2_sha1_init(&local_78);
                  EVP_DigestUpdate(local_78,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34));
                  EVP_DigestUpdate(local_78,param_9 + 8,0x14);
                  if (local_40 == 0) {
                    EVP_DigestUpdate(local_78,&DAT_0014656d,1);
                    EVP_DigestUpdate(local_78,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_78,local_50,local_40);
                  }
                  EVP_DigestFinal(local_78,(uchar *)((long)local_50 + local_40),(uint *)0x0);
                  EVP_MD_CTX_free(local_78);
                }
              }
              if (local_50 == (void *)0x0) {
                local_8c = -5;
                iVar3 = local_8c;
              }
              else {
                local_38 = 0;
                if (local_48 == (void *)0x0) {
                  local_48 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x128) + 0x18) +
                                                      0x14),param_1);
                }
                if (local_48 != (void *)0x0) {
                  for (; local_38 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18);
                      local_38 = local_38 + 0x14) {
                    _libssh2_sha1_init(&local_78);
                    EVP_DigestUpdate(local_78,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34)
                                    );
                    EVP_DigestUpdate(local_78,param_9 + 8,0x14);
                    if (local_38 == 0) {
                      EVP_DigestUpdate(local_78,&DAT_0014656f,1);
                      EVP_DigestUpdate(local_78,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_78,local_48,local_38);
                    }
                    EVP_DigestFinal(local_78,(uchar *)((long)local_48 + local_38),(uint *)0x0);
                    EVP_MD_CTX_free(local_78);
                  }
                }
                if (local_48 == (void *)0x0) {
                  (**(code **)(param_1 + 0x18))(local_50,param_1);
                  local_8c = -5;
                  iVar3 = local_8c;
                }
                else {
                  iVar3 = (**(code **)(*(long *)(param_1 + 0x128) + 0x28))
                                    (param_1,*(undefined8 *)(param_1 + 0x128),local_50,&local_94,
                                     local_48,&local_90,0,param_1 + 0x130);
                  if (iVar3 == 0) {
                    if (local_94 != 0) {
                      _libssh2_explicit_zero
                                (local_50,(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14));
                      (**(code **)(param_1 + 0x18))(local_50,param_1);
                    }
                    if (local_90 != 0) {
                      _libssh2_explicit_zero
                                (local_48,(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18));
                      (**(code **)(param_1 + 0x18))(local_48,param_1);
                    }
                    goto LAB_0011c3c6;
                  }
                  (**(code **)(param_1 + 0x18))(local_50,param_1);
                  (**(code **)(param_1 + 0x18))(local_48,param_1);
                  local_8c = -5;
                  iVar3 = local_8c;
                }
              }
            }
          }
          else {
            local_70 = (void *)0x0;
            local_68 = (void *)0x0;
            local_94 = 0;
            local_90 = 0;
            local_60 = 0;
            if (true) {
              local_70 = (void *)(**(code **)(param_1 + 8))
                                           ((long)(*(int *)(*(long *)(param_1 + 0x198) + 0x14) +
                                                  0x14),param_1);
            }
            if (local_70 != (void *)0x0) {
              for (; local_60 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14);
                  local_60 = local_60 + 0x14) {
                _libssh2_sha1_init(&local_78);
                EVP_DigestUpdate(local_78,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34));
                EVP_DigestUpdate(local_78,param_9 + 8,0x14);
                if (local_60 == 0) {
                  EVP_DigestUpdate(local_78,&DAT_00146569,1);
                  EVP_DigestUpdate(local_78,*(void **)(param_1 + 0x88),
                                   (ulong)*(uint *)(param_1 + 0x90));
                }
                else {
                  EVP_DigestUpdate(local_78,local_70,local_60);
                }
                EVP_DigestFinal(local_78,(uchar *)((long)local_70 + local_60),(uint *)0x0);
                EVP_MD_CTX_free(local_78);
              }
            }
            if (local_70 == (void *)0x0) {
              local_8c = -1;
              iVar3 = local_8c;
            }
            else {
              local_58 = 0;
              if (local_68 == (void *)0x0) {
                local_68 = (void *)(**(code **)(param_1 + 8))
                                             ((long)(*(int *)(*(long *)(param_1 + 0x198) + 0x18) +
                                                    0x14),param_1);
              }
              if (local_68 != (void *)0x0) {
                for (; local_58 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18);
                    local_58 = local_58 + 0x14) {
                  _libssh2_sha1_init(&local_78);
                  EVP_DigestUpdate(local_78,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34));
                  EVP_DigestUpdate(local_78,param_9 + 8,0x14);
                  if (local_58 == 0) {
                    EVP_DigestUpdate(local_78,&DAT_0014656b,1);
                    EVP_DigestUpdate(local_78,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_78,local_68,local_58);
                  }
                  EVP_DigestFinal(local_78,(uchar *)((long)local_68 + local_58),(uint *)0x0);
                  EVP_MD_CTX_free(local_78);
                }
              }
              if (local_68 == (void *)0x0) {
                (**(code **)(param_1 + 0x18))(local_70,param_1);
                local_8c = -5;
                iVar3 = local_8c;
              }
              else {
                iVar3 = (**(code **)(*(long *)(param_1 + 0x198) + 0x28))
                                  (param_1,*(undefined8 *)(param_1 + 0x198),local_70,&local_94,
                                   local_68,&local_90,1,param_1 + 0x1a0);
                if (iVar3 == 0) {
                  if (local_94 != 0) {
                    _libssh2_explicit_zero
                              (local_70,(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14));
                    (**(code **)(param_1 + 0x18))(local_70,param_1);
                  }
                  if (local_90 != 0) {
                    _libssh2_explicit_zero
                              (local_68,(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18));
                    (**(code **)(param_1 + 0x18))(local_68,param_1);
                  }
                  goto LAB_0011bf04;
                }
                (**(code **)(param_1 + 0x18))(local_70,param_1);
                (**(code **)(param_1 + 0x18))(local_68,param_1);
                local_8c = -5;
                iVar3 = local_8c;
              }
            }
          }
        }
        else {
          iVar3 = _libssh2_error(param_1,local_88,"Timed out waiting for NEWKEYS");
        }
      }
    }
  }
LAB_0011ca27:
  local_8c = iVar3;
  _libssh2_dh_dtor(param_9 + 0x22);
  BN_clear_free(*(BIGNUM **)(param_9 + 0x24));
  param_9[0x24] = 0;
  param_9[0x25] = 0;
  BN_clear_free(*(BIGNUM **)(param_9 + 0x26));
  param_9[0x26] = 0;
  param_9[0x27] = 0;
  BN_clear_free(*(BIGNUM **)(param_9 + 0x28));
  param_9[0x28] = 0;
  param_9[0x29] = 0;
  BN_CTX_free(*(BN_CTX **)(param_9 + 0x20));
  param_9[0x20] = 0;
  param_9[0x21] = 0;
  if (*(long *)(param_9 + 2) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_9 + 2),param_1);
    param_9[2] = 0;
    param_9[3] = 0;
  }
  if (*(long *)(param_9 + 4) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_9 + 4),param_1);
    param_9[4] = 0;
    param_9[5] = 0;
  }
  if (*(long *)(param_9 + 0x2e) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_9 + 0x2e),param_1);
    param_9[0x2e] = 0;
    param_9[0x2f] = 0;
  }
  *param_9 = 0;
  iVar3 = local_8c;
LAB_0011cbc4:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int diffie_hellman_sha256
              (long param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4,char param_5,
              undefined param_6,void *param_7,size_t param_8,int *param_9)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  undefined4 uVar4;
  BN_CTX *pBVar5;
  BIGNUM *pBVar6;
  undefined8 uVar7;
  size_t sVar8;
  long in_FS_OFFSET;
  int local_94;
  int local_90;
  int local_8c;
  int local_88;
  int local_84;
  EVP_MD_CTX *local_80;
  EVP_MD_CTX *local_78;
  void *local_70;
  void *local_68;
  ulong local_60;
  ulong local_58;
  void *local_50;
  void *local_48;
  ulong local_40;
  ulong local_38;
  void *local_30;
  ulong local_28;
  void *local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_8c = 0;
  if (*param_9 == 0) {
    param_9[2] = 0;
    param_9[3] = 0;
    param_9[4] = 0;
    param_9[5] = 0;
    param_9[0x2e] = 0;
    param_9[0x2f] = 0;
    pBVar5 = BN_CTX_new();
    *(BN_CTX **)(param_9 + 0x20) = pBVar5;
    FUN_0010b4b0(param_9 + 0x22);
    pBVar6 = BN_new();
    *(BIGNUM **)(param_9 + 0x24) = pBVar6;
    pBVar6 = BN_new();
    *(BIGNUM **)(param_9 + 0x26) = pBVar6;
    pBVar6 = BN_new();
    *(BIGNUM **)(param_9 + 0x28) = pBVar6;
    memset(param_9 + 0x3a,0,0x10);
    local_88 = _libssh2_dh_key_pair
                         (param_9 + 0x22,*(undefined8 *)(param_9 + 0x24),param_2,param_3,param_4,
                          *(undefined8 *)(param_9 + 0x20));
    iVar3 = local_8c;
    if (local_88 == 0) {
      iVar1 = BN_num_bits(*(BIGNUM **)(param_9 + 0x24));
      iVar3 = iVar1 + 7;
      if (iVar1 + 7 < 0) {
        iVar3 = iVar1 + 0xe;
      }
      *(long *)(param_9 + 0x1a) = (long)((iVar3 >> 3) + 6);
      uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x24));
      if ((uVar2 & 7) != 0) {
        *(long *)(param_9 + 0x1a) = *(long *)(param_9 + 0x1a) + -1;
      }
      uVar7 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_9 + 0x1a),param_1);
      *(undefined8 *)(param_9 + 2) = uVar7;
      if (*(long *)(param_9 + 2) != 0) {
        **(char **)(param_9 + 2) = param_5;
        _libssh2_htonu32(*(long *)(param_9 + 2) + 1,(int)*(undefined8 *)(param_9 + 0x1a) + -5);
        uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x24));
        if ((uVar2 & 7) == 0) {
          *(undefined *)(*(long *)(param_9 + 2) + 5) = 0;
          BN_bn2bin(*(BIGNUM **)(param_9 + 0x24),(uchar *)(*(long *)(param_9 + 2) + 6));
        }
        else {
          BN_bn2bin(*(BIGNUM **)(param_9 + 0x24),(uchar *)(*(long *)(param_9 + 2) + 5));
        }
        *param_9 = 2;
        goto LAB_0011cefc;
      }
      iVar3 = _libssh2_error(param_1,0xfffffffa,"Out of memory error");
    }
  }
  else {
LAB_0011cefc:
    if (*param_9 == 2) {
      local_88 = _libssh2_transport_send
                           (param_1,*(undefined8 *)(param_9 + 2),*(undefined8 *)(param_9 + 0x1a),0,0
                           );
      if (local_88 == -0x25) {
        iVar3 = -0x25;
        goto LAB_0011efdb;
      }
      if (local_88 != 0) {
        iVar3 = _libssh2_error(param_1,local_88,"Unable to send KEX init message");
        goto LAB_0011ee3e;
      }
      *param_9 = 3;
    }
    if (*param_9 == 3) {
      if ((*(byte *)(param_1 + 0x80) & 1) != 0) {
        local_84 = _libssh2_packet_burn(param_1,param_9 + 0x3e);
        iVar3 = local_84;
        if (local_84 == -0x25) goto LAB_0011efdb;
        if (local_84 < 1) goto LAB_0011ee3e;
        *(byte *)(param_1 + 0x80) = *(byte *)(param_1 + 0x80) & 0xfe;
      }
      *param_9 = 4;
    }
    if (*param_9 == 4) {
      local_88 = _libssh2_packet_require
                           (param_1,param_6,param_9 + 4,param_9 + 0x1c,0,0,0,param_9 + 0x3a);
      if (local_88 == -0x25) {
        iVar3 = -0x25;
        goto LAB_0011efdb;
      }
      if (local_88 == 0) {
        *(long *)(param_9 + 0x2a) = *(long *)(param_9 + 4) + 1;
        uVar4 = _libssh2_ntohu32(*(undefined8 *)(param_9 + 0x2a));
        *(undefined4 *)(param_1 + 0xb8) = uVar4;
        *(long *)(param_9 + 0x2a) = *(long *)(param_9 + 0x2a) + 4;
        if (*(long *)(param_1 + 0xb0) != 0) {
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xb0),param_1);
        }
        uVar7 = (**(code **)(param_1 + 8))(*(undefined4 *)(param_1 + 0xb8),param_1);
        *(undefined8 *)(param_1 + 0xb0) = uVar7;
        if (*(long *)(param_1 + 0xb0) == 0) {
          iVar3 = _libssh2_error(param_1,0xfffffffa,
                                 "Unable to allocate memory for a copy of the host key");
        }
        else {
          memcpy(*(void **)(param_1 + 0xb0),*(void **)(param_9 + 0x2a),
                 (ulong)*(uint *)(param_1 + 0xb8));
          *(ulong *)(param_9 + 0x2a) = *(long *)(param_9 + 0x2a) + (ulong)*(uint *)(param_1 + 0xb8);
          iVar3 = _libssh2_md5_init(&local_78);
          if (iVar3 == 0) {
            *(undefined4 *)(param_1 + 0xcc) = 0;
          }
          else {
            EVP_DigestUpdate(local_78,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));
            EVP_DigestFinal(local_78,(uchar *)(param_1 + 0xbc),(uint *)0x0);
            EVP_MD_CTX_free(local_78);
            *(undefined4 *)(param_1 + 0xcc) = 1;
          }
          iVar3 = _libssh2_sha1_init(&local_78);
          if (iVar3 == 0) {
            *(undefined4 *)(param_1 + 0xe4) = 0;
          }
          else {
            EVP_DigestUpdate(local_78,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));
            EVP_DigestFinal(local_78,(uchar *)(param_1 + 0xd0),(uint *)0x0);
            EVP_MD_CTX_free(local_78);
            *(undefined4 *)(param_1 + 0xe4) = 1;
          }
          iVar3 = _libssh2_sha256_init(&local_78);
          if (iVar3 == 0) {
            *(undefined4 *)(param_1 + 0x108) = 0;
          }
          else {
            EVP_DigestUpdate(local_78,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));
            EVP_DigestFinal(local_78,(uchar *)(param_1 + 0xe8),(uint *)0x0);
            EVP_MD_CTX_free(local_78);
            *(undefined4 *)(param_1 + 0x108) = 1;
          }
          iVar3 = (**(code **)(*(long *)(param_1 + 0xa0) + 0x10))
                            (param_1,*(undefined8 *)(param_1 + 0xb0),*(undefined4 *)(param_1 + 0xb8)
                             ,param_1 + 0xa8);
          if (iVar3 == 0) {
            uVar2 = _libssh2_ntohu32(*(undefined8 *)(param_9 + 0x2a));
            *(ulong *)(param_9 + 0x32) = (ulong)uVar2;
            *(long *)(param_9 + 0x2a) = *(long *)(param_9 + 0x2a) + 4;
            *(undefined8 *)(param_9 + 0x2c) = *(undefined8 *)(param_9 + 0x2a);
            *(long *)(param_9 + 0x2a) = *(long *)(param_9 + 0x2a) + *(long *)(param_9 + 0x32);
            BN_bin2bn(*(uchar **)(param_9 + 0x2c),(int)*(undefined8 *)(param_9 + 0x32),
                      *(BIGNUM **)(param_9 + 0x26));
            uVar2 = _libssh2_ntohu32(*(undefined8 *)(param_9 + 0x2a));
            *(ulong *)(param_9 + 0x36) = (ulong)uVar2;
            *(long *)(param_9 + 0x2a) = *(long *)(param_9 + 0x2a) + 4;
            *(undefined8 *)(param_9 + 0x30) = *(undefined8 *)(param_9 + 0x2a);
            _libssh2_dh_secret(param_9 + 0x22,*(undefined8 *)(param_9 + 0x28),
                               *(undefined8 *)(param_9 + 0x26),param_3,
                               *(undefined8 *)(param_9 + 0x20));
            iVar1 = BN_num_bits(*(BIGNUM **)(param_9 + 0x28));
            iVar3 = iVar1 + 7;
            if (iVar1 + 7 < 0) {
              iVar3 = iVar1 + 0xe;
            }
            *(long *)(param_9 + 0x34) = (long)((iVar3 >> 3) + 5);
            uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x28));
            if ((uVar2 & 7) != 0) {
              *(long *)(param_9 + 0x34) = *(long *)(param_9 + 0x34) + -1;
            }
            uVar7 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_9 + 0x34),param_1);
            *(undefined8 *)(param_9 + 0x2e) = uVar7;
            if (*(long *)(param_9 + 0x2e) == 0) {
              iVar3 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for K");
            }
            else {
              _libssh2_htonu32(*(undefined8 *)(param_9 + 0x2e),
                               (int)*(undefined8 *)(param_9 + 0x34) + -4);
              uVar2 = BN_num_bits(*(BIGNUM **)(param_9 + 0x28));
              if ((uVar2 & 7) == 0) {
                *(undefined *)(*(long *)(param_9 + 0x2e) + 4) = 0;
                BN_bn2bin(*(BIGNUM **)(param_9 + 0x28),(uchar *)(*(long *)(param_9 + 0x2e) + 5));
              }
              else {
                BN_bn2bin(*(BIGNUM **)(param_9 + 0x28),(uchar *)(*(long *)(param_9 + 0x2e) + 4));
              }
              *(EVP_MD_CTX ***)(param_9 + 0x38) = &local_80;
              _libssh2_sha256_init(&local_80);
              if (*(long *)(param_1 + 0x180) == 0) {
                _libssh2_htonu32(param_9 + 8,0x19);
                EVP_DigestUpdate(local_80,param_9 + 8,4);
                EVP_DigestUpdate(local_80,"SSH-2.0-libssh2_1.9.0_DEV",0x19);
              }
              else {
                sVar8 = strlen(*(char **)(param_1 + 0x180));
                _libssh2_htonu32(param_9 + 8,(int)sVar8 + -2);
                EVP_DigestUpdate(local_80,param_9 + 8,4);
                sVar8 = strlen(*(char **)(param_1 + 0x180));
                EVP_DigestUpdate(local_80,*(void **)(param_1 + 0x180),sVar8 - 2);
              }
              sVar8 = strlen(*(char **)(param_1 + 0x110));
              _libssh2_htonu32(param_9 + 8,sVar8 & 0xffffffff);
              EVP_DigestUpdate(local_80,param_9 + 8,4);
              sVar8 = strlen(*(char **)(param_1 + 0x110));
              EVP_DigestUpdate(local_80,*(void **)(param_1 + 0x110),sVar8);
              _libssh2_htonu32(param_9 + 8,*(ulong *)(param_1 + 400) & 0xffffffff);
              EVP_DigestUpdate(local_80,param_9 + 8,4);
              EVP_DigestUpdate(local_80,*(void **)(param_1 + 0x188),*(size_t *)(param_1 + 400));
              _libssh2_htonu32(param_9 + 8,*(ulong *)(param_1 + 0x120) & 0xffffffff);
              EVP_DigestUpdate(local_80,param_9 + 8,4);
              EVP_DigestUpdate(local_80,*(void **)(param_1 + 0x118),*(size_t *)(param_1 + 0x120));
              _libssh2_htonu32(param_9 + 8,*(undefined4 *)(param_1 + 0xb8));
              EVP_DigestUpdate(local_80,param_9 + 8,4);
              EVP_DigestUpdate(local_80,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8))
              ;
              if (param_5 == ' ') {
                _libssh2_htonu32(param_9 + 8,0x400);
                _libssh2_htonu32(param_9 + 9,0x600);
                _libssh2_htonu32(param_9 + 10,0x800);
                EVP_DigestUpdate(local_80,param_9 + 8,0xc);
              }
              if (param_7 != (void *)0x0) {
                EVP_DigestUpdate(local_80,param_7,param_8);
              }
              EVP_DigestUpdate(local_80,(void *)(*(long *)(param_9 + 2) + 1),
                               *(long *)(param_9 + 0x1a) - 1);
              _libssh2_htonu32(param_9 + 8,*(ulong *)(param_9 + 0x32) & 0xffffffff);
              EVP_DigestUpdate(local_80,param_9 + 8,4);
              EVP_DigestUpdate(local_80,*(void **)(param_9 + 0x2c),*(size_t *)(param_9 + 0x32));
              EVP_DigestUpdate(local_80,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34));
              EVP_DigestFinal(local_80,(uchar *)(param_9 + 8),(uint *)0x0);
              EVP_MD_CTX_free(local_80);
              iVar3 = (**(code **)(*(long *)(param_1 + 0xa0) + 0x28))
                                (param_1,*(undefined8 *)(param_9 + 0x30),
                                 *(undefined8 *)(param_9 + 0x36),param_9 + 8,0x20,param_1 + 0xa8);
              if (iVar3 == 0) {
                *(undefined *)(param_9 + 0x18) = 0x15;
                *param_9 = 5;
                goto LAB_0011dc4b;
              }
              iVar3 = _libssh2_error(param_1,0xfffffff5,"Unable to verify hostkey signature");
            }
          }
          else {
            iVar3 = _libssh2_error(param_1,0xfffffff6,"Unable to initialize hostkey importer");
          }
        }
      }
      else {
        iVar3 = _libssh2_error(param_1,0xfffffff7,"Timed out waiting for KEX reply");
      }
    }
    else {
LAB_0011dc4b:
      if (*param_9 == 5) {
        local_88 = _libssh2_transport_send(param_1,param_9 + 0x18,1,0,0);
        if (local_88 == -0x25) {
          iVar3 = -0x25;
          goto LAB_0011efdb;
        }
        if (local_88 != 0) {
          iVar3 = _libssh2_error(param_1,local_88,"Unable to send NEWKEYS message");
          goto LAB_0011ee3e;
        }
        *param_9 = 6;
      }
      iVar3 = local_8c;
      if (*param_9 == 6) {
        local_88 = _libssh2_packet_require
                             (param_1,0x15,param_9 + 6,param_9 + 0x1e,0,0,0,param_9 + 0x3a);
        if (local_88 == -0x25) {
          iVar3 = -0x25;
          goto LAB_0011efdb;
        }
        if (local_88 == 0) {
          *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 2;
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_9 + 6),param_1);
          if (*(long *)(param_1 + 0x88) == 0) {
            uVar7 = (**(code **)(param_1 + 8))(0x20,param_1);
            *(undefined8 *)(param_1 + 0x88) = uVar7;
            if (*(long *)(param_1 + 0x88) == 0) {
              iVar3 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for SHA digest");
              goto LAB_0011ee3e;
            }
            memcpy(*(void **)(param_1 + 0x88),param_9 + 8,0x20);
            *(undefined4 *)(param_1 + 0x90) = 0x20;
          }
          if (*(long *)(*(long *)(param_1 + 0x198) + 0x38) != 0) {
            (**(code **)(*(long *)(param_1 + 0x198) + 0x38))(param_1,param_1 + 0x1a0);
          }
          if (*(long *)(*(long *)(param_1 + 0x198) + 0x28) == 0) {
LAB_0011e31b:
            if (*(long *)(*(long *)(param_1 + 0x128) + 0x38) != 0) {
              (**(code **)(*(long *)(param_1 + 0x128) + 0x38))(param_1,param_1 + 0x130);
            }
            if (*(long *)(*(long *)(param_1 + 0x128) + 0x28) == 0) {
LAB_0011e7dd:
              if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x20) != 0) {
                (**(code **)(*(long *)(param_1 + 0x1a8) + 0x20))(param_1,param_1 + 0x1b8);
              }
              if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x10) != 0) {
                local_30 = (void *)0x0;
                local_90 = 0;
                local_28 = 0;
                if (true) {
                  local_30 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x1a8) + 0xc) +
                                                      0x20),param_1);
                }
                if (local_30 != (void *)0x0) {
                  for (; local_28 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc);
                      local_28 = local_28 + 0x20) {
                    _libssh2_sha256_init(&local_78);
                    EVP_DigestUpdate(local_78,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34)
                                    );
                    EVP_DigestUpdate(local_78,param_9 + 8,0x20);
                    if (local_28 == 0) {
                      EVP_DigestUpdate(local_78,&DAT_00146571,1);
                      EVP_DigestUpdate(local_78,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_78,local_30,local_28);
                    }
                    EVP_DigestFinal(local_78,(uchar *)((long)local_30 + local_28),(uint *)0x0);
                    EVP_MD_CTX_free(local_78);
                  }
                }
                if (local_30 == (void *)0x0) {
                  local_8c = -5;
                  iVar3 = local_8c;
                  goto LAB_0011ee3e;
                }
                (**(code **)(*(long *)(param_1 + 0x1a8) + 0x10))
                          (param_1,local_30,&local_90,param_1 + 0x1b8);
                if (local_90 != 0) {
                  _libssh2_explicit_zero(local_30,(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc));
                  (**(code **)(param_1 + 0x18))(local_30,param_1);
                }
              }
              if (*(long *)(*(long *)(param_1 + 0x138) + 0x20) != 0) {
                (**(code **)(*(long *)(param_1 + 0x138) + 0x20))(param_1,param_1 + 0x148);
              }
              if (*(long *)(*(long *)(param_1 + 0x138) + 0x10) != 0) {
                local_20 = (void *)0x0;
                local_90 = 0;
                local_18 = 0;
                if (true) {
                  local_20 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x138) + 0xc) +
                                                      0x20),param_1);
                }
                if (local_20 != (void *)0x0) {
                  for (; local_18 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc);
                      local_18 = local_18 + 0x20) {
                    _libssh2_sha256_init(&local_78);
                    EVP_DigestUpdate(local_78,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34)
                                    );
                    EVP_DigestUpdate(local_78,param_9 + 8,0x20);
                    if (local_18 == 0) {
                      EVP_DigestUpdate(local_78,&DAT_00146573,1);
                      EVP_DigestUpdate(local_78,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_78,local_20,local_18);
                    }
                    EVP_DigestFinal(local_78,(uchar *)((long)local_20 + local_18),(uint *)0x0);
                    EVP_MD_CTX_free(local_78);
                  }
                }
                if (local_20 == (void *)0x0) {
                  local_8c = -5;
                  iVar3 = local_8c;
                  goto LAB_0011ee3e;
                }
                (**(code **)(*(long *)(param_1 + 0x138) + 0x10))
                          (param_1,local_20,&local_90,param_1 + 0x148);
                if (local_90 != 0) {
                  _libssh2_explicit_zero(local_20,(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc));
                  (**(code **)(param_1 + 0x18))(local_20,param_1);
                }
              }
              if ((*(long *)(param_1 + 0x1c0) != 0) &&
                 (*(long *)(*(long *)(param_1 + 0x1c0) + 0x28) != 0)) {
                (**(code **)(*(long *)(param_1 + 0x1c0) + 0x28))(param_1,1,param_1 + 0x1c8);
              }
              if (((*(long *)(param_1 + 0x1c0) == 0) ||
                  (*(long *)(*(long *)(param_1 + 0x1c0) + 0x10) == 0)) ||
                 (iVar3 = (**(code **)(*(long *)(param_1 + 0x1c0) + 0x10))
                                    (param_1,1,param_1 + 0x1c8), iVar3 == 0)) {
                if ((*(long *)(param_1 + 0x150) != 0) &&
                   (*(long *)(*(long *)(param_1 + 0x150) + 0x28) != 0)) {
                  (**(code **)(*(long *)(param_1 + 0x150) + 0x28))(param_1,0,param_1 + 0x158);
                }
                iVar3 = local_8c;
                if (((*(long *)(param_1 + 0x150) != 0) &&
                    (*(long *)(*(long *)(param_1 + 0x150) + 0x10) != 0)) &&
                   (iVar1 = (**(code **)(*(long *)(param_1 + 0x150) + 0x10))
                                      (param_1,0,param_1 + 0x158), iVar3 = local_8c, iVar1 != 0)) {
                  local_8c = -5;
                  iVar3 = local_8c;
                }
              }
              else {
                local_8c = -5;
                iVar3 = local_8c;
              }
            }
            else {
              local_50 = (void *)0x0;
              local_48 = (void *)0x0;
              local_94 = 0;
              local_90 = 0;
              local_40 = 0;
              if (true) {
                local_50 = (void *)(**(code **)(param_1 + 8))
                                             ((long)(*(int *)(*(long *)(param_1 + 0x128) + 0x14) +
                                                    0x20),param_1);
              }
              if (local_50 != (void *)0x0) {
                for (; local_40 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14);
                    local_40 = local_40 + 0x20) {
                  _libssh2_sha256_init(&local_78);
                  EVP_DigestUpdate(local_78,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34));
                  EVP_DigestUpdate(local_78,param_9 + 8,0x20);
                  if (local_40 == 0) {
                    EVP_DigestUpdate(local_78,&DAT_0014656d,1);
                    EVP_DigestUpdate(local_78,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_78,local_50,local_40);
                  }
                  EVP_DigestFinal(local_78,(uchar *)((long)local_50 + local_40),(uint *)0x0);
                  EVP_MD_CTX_free(local_78);
                }
              }
              if (local_50 == (void *)0x0) {
                local_8c = -5;
                iVar3 = local_8c;
              }
              else {
                local_38 = 0;
                if (local_48 == (void *)0x0) {
                  local_48 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x128) + 0x18) +
                                                      0x20),param_1);
                }
                if (local_48 != (void *)0x0) {
                  for (; local_38 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18);
                      local_38 = local_38 + 0x20) {
                    _libssh2_sha256_init(&local_78);
                    EVP_DigestUpdate(local_78,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34)
                                    );
                    EVP_DigestUpdate(local_78,param_9 + 8,0x20);
                    if (local_38 == 0) {
                      EVP_DigestUpdate(local_78,&DAT_0014656f,1);
                      EVP_DigestUpdate(local_78,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_78,local_48,local_38);
                    }
                    EVP_DigestFinal(local_78,(uchar *)((long)local_48 + local_38),(uint *)0x0);
                    EVP_MD_CTX_free(local_78);
                  }
                }
                if (local_48 == (void *)0x0) {
                  (**(code **)(param_1 + 0x18))(local_50,param_1);
                  local_8c = -5;
                  iVar3 = local_8c;
                }
                else {
                  iVar3 = (**(code **)(*(long *)(param_1 + 0x128) + 0x28))
                                    (param_1,*(undefined8 *)(param_1 + 0x128),local_50,&local_94,
                                     local_48,&local_90,0,param_1 + 0x130);
                  if (iVar3 == 0) {
                    if (local_94 != 0) {
                      _libssh2_explicit_zero
                                (local_50,(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14));
                      (**(code **)(param_1 + 0x18))(local_50,param_1);
                    }
                    if (local_90 != 0) {
                      _libssh2_explicit_zero
                                (local_48,(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18));
                      (**(code **)(param_1 + 0x18))(local_48,param_1);
                    }
                    goto LAB_0011e7dd;
                  }
                  (**(code **)(param_1 + 0x18))(local_50,param_1);
                  (**(code **)(param_1 + 0x18))(local_48,param_1);
                  local_8c = -5;
                  iVar3 = local_8c;
                }
              }
            }
          }
          else {
            local_70 = (void *)0x0;
            local_68 = (void *)0x0;
            local_94 = 0;
            local_90 = 0;
            local_60 = 0;
            if (true) {
              local_70 = (void *)(**(code **)(param_1 + 8))
                                           ((long)(*(int *)(*(long *)(param_1 + 0x198) + 0x14) +
                                                  0x20),param_1);
            }
            if (local_70 != (void *)0x0) {
              for (; local_60 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14);
                  local_60 = local_60 + 0x20) {
                _libssh2_sha256_init(&local_78);
                EVP_DigestUpdate(local_78,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34));
                EVP_DigestUpdate(local_78,param_9 + 8,0x20);
                if (local_60 == 0) {
                  EVP_DigestUpdate(local_78,&DAT_00146569,1);
                  EVP_DigestUpdate(local_78,*(void **)(param_1 + 0x88),
                                   (ulong)*(uint *)(param_1 + 0x90));
                }
                else {
                  EVP_DigestUpdate(local_78,local_70,local_60);
                }
                EVP_DigestFinal(local_78,(uchar *)((long)local_70 + local_60),(uint *)0x0);
                EVP_MD_CTX_free(local_78);
              }
            }
            if (local_70 == (void *)0x0) {
              local_8c = -1;
              iVar3 = local_8c;
            }
            else {
              local_58 = 0;
              if (local_68 == (void *)0x0) {
                local_68 = (void *)(**(code **)(param_1 + 8))
                                             ((long)(*(int *)(*(long *)(param_1 + 0x198) + 0x18) +
                                                    0x20),param_1);
              }
              if (local_68 != (void *)0x0) {
                for (; local_58 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18);
                    local_58 = local_58 + 0x20) {
                  _libssh2_sha256_init(&local_78);
                  EVP_DigestUpdate(local_78,*(void **)(param_9 + 0x2e),*(size_t *)(param_9 + 0x34));
                  EVP_DigestUpdate(local_78,param_9 + 8,0x20);
                  if (local_58 == 0) {
                    EVP_DigestUpdate(local_78,&DAT_0014656b,1);
                    EVP_DigestUpdate(local_78,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_78,local_68,local_58);
                  }
                  EVP_DigestFinal(local_78,(uchar *)((long)local_68 + local_58),(uint *)0x0);
                  EVP_MD_CTX_free(local_78);
                }
              }
              if (local_68 == (void *)0x0) {
                (**(code **)(param_1 + 0x18))(local_70,param_1);
                local_8c = -5;
                iVar3 = local_8c;
              }
              else {
                iVar3 = (**(code **)(*(long *)(param_1 + 0x198) + 0x28))
                                  (param_1,*(undefined8 *)(param_1 + 0x198),local_70,&local_94,
                                   local_68,&local_90,1,param_1 + 0x1a0);
                if (iVar3 == 0) {
                  if (local_94 != 0) {
                    _libssh2_explicit_zero
                              (local_70,(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14));
                    (**(code **)(param_1 + 0x18))(local_70,param_1);
                  }
                  if (local_90 != 0) {
                    _libssh2_explicit_zero
                              (local_68,(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18));
                    (**(code **)(param_1 + 0x18))(local_68,param_1);
                  }
                  goto LAB_0011e31b;
                }
                (**(code **)(param_1 + 0x18))(local_70,param_1);
                (**(code **)(param_1 + 0x18))(local_68,param_1);
                local_8c = -5;
                iVar3 = local_8c;
              }
            }
          }
        }
        else {
          iVar3 = _libssh2_error(param_1,local_88,"Timed out waiting for NEWKEYS");
        }
      }
    }
  }
LAB_0011ee3e:
  local_8c = iVar3;
  _libssh2_dh_dtor(param_9 + 0x22);
  BN_clear_free(*(BIGNUM **)(param_9 + 0x24));
  param_9[0x24] = 0;
  param_9[0x25] = 0;
  BN_clear_free(*(BIGNUM **)(param_9 + 0x26));
  param_9[0x26] = 0;
  param_9[0x27] = 0;
  BN_clear_free(*(BIGNUM **)(param_9 + 0x28));
  param_9[0x28] = 0;
  param_9[0x29] = 0;
  BN_CTX_free(*(BN_CTX **)(param_9 + 0x20));
  param_9[0x20] = 0;
  param_9[0x21] = 0;
  if (*(long *)(param_9 + 2) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_9 + 2),param_1);
    param_9[2] = 0;
    param_9[3] = 0;
  }
  if (*(long *)(param_9 + 4) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_9 + 4),param_1);
    param_9[4] = 0;
    param_9[5] = 0;
  }
  if (*(long *)(param_9 + 0x2e) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_9 + 0x2e),param_1);
    param_9[0x2e] = 0;
    param_9[0x2f] = 0;
  }
  *param_9 = 0;
  iVar3 = local_8c;
LAB_0011efdb:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int kex_method_diffie_hellman_group1_sha1_key_exchange(undefined8 param_1,int *param_2)

{
  int iVar1;
  BIGNUM *pBVar2;
  
  if (*param_2 == 0) {
    pBVar2 = BN_new();
    *(BIGNUM **)(param_2 + 0x46) = pBVar2;
    pBVar2 = BN_new();
    *(BIGNUM **)(param_2 + 0x48) = pBVar2;
    BN_set_word(*(BIGNUM **)(param_2 + 0x48),2);
    BN_bin2bn(p_value_20219,0x80,*(BIGNUM **)(param_2 + 0x46));
    *param_2 = 2;
  }
  iVar1 = diffie_hellman_sha1(param_1,*(undefined8 *)(param_2 + 0x48),
                              *(undefined8 *)(param_2 + 0x46),0x80,0x1e,0x1f,0,0,param_2 + 6);
  if (iVar1 != -0x25) {
    BN_clear_free(*(BIGNUM **)(param_2 + 0x46));
    param_2[0x46] = 0;
    param_2[0x47] = 0;
    BN_clear_free(*(BIGNUM **)(param_2 + 0x48));
    param_2[0x48] = 0;
    param_2[0x49] = 0;
    *param_2 = 0;
  }
  return iVar1;
}



int kex_method_diffie_hellman_group14_sha1_key_exchange(undefined8 param_1,int *param_2)

{
  int iVar1;
  BIGNUM *pBVar2;
  
  if (*param_2 == 0) {
    pBVar2 = BN_new();
    *(BIGNUM **)(param_2 + 0x46) = pBVar2;
    pBVar2 = BN_new();
    *(BIGNUM **)(param_2 + 0x48) = pBVar2;
    BN_set_word(*(BIGNUM **)(param_2 + 0x48),2);
    BN_bin2bn(p_value_20225,0x100,*(BIGNUM **)(param_2 + 0x46));
    *param_2 = 2;
  }
  iVar1 = diffie_hellman_sha1(param_1,*(undefined8 *)(param_2 + 0x48),
                              *(undefined8 *)(param_2 + 0x46),0x100,0x1e,0x1f,0,0,param_2 + 6);
  if (iVar1 != -0x25) {
    *param_2 = 0;
    BN_clear_free(*(BIGNUM **)(param_2 + 0x46));
    param_2[0x46] = 0;
    param_2[0x47] = 0;
    BN_clear_free(*(BIGNUM **)(param_2 + 0x48));
    param_2[0x48] = 0;
    param_2[0x49] = 0;
  }
  return iVar1;
}



int kex_method_diffie_hellman_group_exchange_sha1_key_exchange(long param_1,int *param_2)

{
  uchar *puVar1;
  long lVar2;
  int iVar3;
  uint len;
  BIGNUM *pBVar4;
  int local_28;
  
  local_28 = 0;
  if (*param_2 == 0) {
    pBVar4 = BN_new();
    *(BIGNUM **)(param_2 + 0x46) = pBVar4;
    pBVar4 = BN_new();
    *(BIGNUM **)(param_2 + 0x48) = pBVar4;
    *(undefined *)(param_2 + 0x4a) = 0x22;
    _libssh2_htonu32((long)param_2 + 0x129,0x400);
    _libssh2_htonu32((long)param_2 + 0x12d,0x600);
    _libssh2_htonu32((long)param_2 + 0x131,0x800);
    param_2[0x8c] = 0xd;
    param_2[0x8d] = 0;
    *param_2 = 2;
  }
  if (*param_2 == 2) {
    iVar3 = _libssh2_transport_send(param_1,param_2 + 0x4a,*(undefined8 *)(param_2 + 0x8c),0,0);
    if (iVar3 == -0x25) {
      return -0x25;
    }
    if (iVar3 != 0) {
      local_28 = _libssh2_error(param_1,iVar3,"Unable to send Group Exchange Request");
      goto LAB_0011f53a;
    }
    *param_2 = 3;
  }
  if (*param_2 == 3) {
    iVar3 = _libssh2_packet_require(param_1,0x1f,param_2 + 0x8a,param_2 + 0x8e,0,0,0,param_2 + 2);
    if (iVar3 == -0x25) {
      return -0x25;
    }
    if (iVar3 != 0) {
      local_28 = _libssh2_error(param_1,iVar3,"Timeout waiting for GEX_GROUP reply");
      goto LAB_0011f53a;
    }
    *param_2 = 4;
  }
  if (*param_2 == 4) {
    lVar2 = *(long *)(param_2 + 0x8a);
    len = _libssh2_ntohu32(lVar2 + 1);
    puVar1 = (uchar *)(lVar2 + 5);
    BN_bin2bn(puVar1,len,*(BIGNUM **)(param_2 + 0x46));
    puVar1 = puVar1 + len;
    iVar3 = _libssh2_ntohu32(puVar1);
    BN_bin2bn(puVar1 + 4,iVar3,*(BIGNUM **)(param_2 + 0x48));
    local_28 = diffie_hellman_sha1(param_1,*(undefined8 *)(param_2 + 0x48),
                                   *(undefined8 *)(param_2 + 0x46),(ulong)len,0x20,0x21,
                                   *(long *)(param_2 + 0x8a) + 1,*(long *)(param_2 + 0x8e) + -1,
                                   param_2 + 6);
    if (local_28 == -0x25) {
      return -0x25;
    }
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_2 + 0x8a),param_1);
  }
LAB_0011f53a:
  *param_2 = 0;
  BN_clear_free(*(BIGNUM **)(param_2 + 0x48));
  param_2[0x48] = 0;
  param_2[0x49] = 0;
  BN_clear_free(*(BIGNUM **)(param_2 + 0x46));
  param_2[0x46] = 0;
  param_2[0x47] = 0;
  return local_28;
}



int kex_method_diffie_hellman_group_exchange_sha256_key_exchange(long param_1,int *param_2)

{
  uchar *puVar1;
  long lVar2;
  int iVar3;
  uint len;
  BIGNUM *pBVar4;
  int local_28;
  
  local_28 = 0;
  if (*param_2 == 0) {
    pBVar4 = BN_new();
    *(BIGNUM **)(param_2 + 0x46) = pBVar4;
    pBVar4 = BN_new();
    *(BIGNUM **)(param_2 + 0x48) = pBVar4;
    *(undefined *)(param_2 + 0x4a) = 0x22;
    _libssh2_htonu32((long)param_2 + 0x129,0x400);
    _libssh2_htonu32((long)param_2 + 0x12d,0x600);
    _libssh2_htonu32((long)param_2 + 0x131,0x800);
    param_2[0x8c] = 0xd;
    param_2[0x8d] = 0;
    *param_2 = 2;
  }
  if (*param_2 == 2) {
    iVar3 = _libssh2_transport_send(param_1,param_2 + 0x4a,*(undefined8 *)(param_2 + 0x8c),0,0);
    if (iVar3 == -0x25) {
      return -0x25;
    }
    if (iVar3 != 0) {
      local_28 = _libssh2_error(param_1,iVar3,"Unable to send Group Exchange Request SHA256");
      goto LAB_0011f886;
    }
    *param_2 = 3;
  }
  if (*param_2 == 3) {
    iVar3 = _libssh2_packet_require(param_1,0x1f,param_2 + 0x8a,param_2 + 0x8e,0,0,0,param_2 + 2);
    if (iVar3 == -0x25) {
      return -0x25;
    }
    if (iVar3 != 0) {
      local_28 = _libssh2_error(param_1,iVar3,"Timeout waiting for GEX_GROUP reply SHA256");
      goto LAB_0011f886;
    }
    *param_2 = 4;
  }
  if (*param_2 == 4) {
    lVar2 = *(long *)(param_2 + 0x8a);
    len = _libssh2_ntohu32(lVar2 + 1);
    puVar1 = (uchar *)(lVar2 + 5);
    BN_bin2bn(puVar1,len,*(BIGNUM **)(param_2 + 0x46));
    puVar1 = puVar1 + len;
    iVar3 = _libssh2_ntohu32(puVar1);
    BN_bin2bn(puVar1 + 4,iVar3,*(BIGNUM **)(param_2 + 0x48));
    local_28 = diffie_hellman_sha256
                         (param_1,*(undefined8 *)(param_2 + 0x48),*(undefined8 *)(param_2 + 0x46),
                          (ulong)len,0x20,0x21,*(long *)(param_2 + 0x8a) + 1,
                          *(long *)(param_2 + 0x8e) + -1,param_2 + 6);
    if (local_28 == -0x25) {
      return -0x25;
    }
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_2 + 0x8a),param_1);
  }
LAB_0011f886:
  *param_2 = 0;
  BN_clear_free(*(BIGNUM **)(param_2 + 0x48));
  param_2[0x48] = 0;
  param_2[0x49] = 0;
  BN_clear_free(*(BIGNUM **)(param_2 + 0x46));
  param_2[0x46] = 0;
  param_2[0x47] = 0;
  return local_28;
}



int kex_session_ecdh_curve_type(char *param_1,undefined4 *param_2)

{
  int iVar1;
  int local_10;
  undefined4 local_c;
  
  local_10 = 0;
  if (param_1 == (char *)0x0) {
    local_10 = -1;
  }
  else {
    iVar1 = strcmp(param_1,"ecdh-sha2-nistp256");
    if (iVar1 == 0) {
      local_c = 0x19f;
    }
    else {
      iVar1 = strcmp(param_1,"ecdh-sha2-nistp384");
      if (iVar1 == 0) {
        local_c = 0x2cb;
      }
      else {
        iVar1 = strcmp(param_1,"ecdh-sha2-nistp521");
        if (iVar1 == 0) {
          local_c = 0x2cc;
        }
        else {
          local_10 = -1;
        }
      }
    }
    if ((local_10 == 0) && (param_2 != (undefined4 *)0x0)) {
      *param_2 = local_c;
    }
  }
  return local_10;
}



undefined4
ecdh_sha2_nistp(long param_1,uint param_2,long param_3,ulong param_4,void *param_5,ulong param_6,
               undefined8 param_7,int *param_8)

{
  undefined4 uVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  BIGNUM *pBVar5;
  undefined8 uVar6;
  size_t sVar7;
  long in_FS_OFFSET;
  int local_110;
  int local_10c;
  undefined4 local_108;
  int local_104;
  EVP_MD_CTX *local_100;
  size_t local_f8;
  void *local_f0;
  void *local_e8;
  ulong local_e0;
  ulong local_d8;
  ulong local_d0;
  ulong local_c8;
  ulong local_c0;
  ulong local_b8;
  void *local_b0;
  void *local_a8;
  ulong local_a0;
  ulong local_98;
  ulong local_90;
  ulong local_88;
  ulong local_80;
  ulong local_78;
  void *local_70;
  ulong local_68;
  ulong local_60;
  ulong local_58;
  void *local_50;
  ulong local_48;
  ulong local_40;
  ulong local_38;
  void *local_30;
  ulong local_28;
  void *local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_108 = 0;
  if (param_4 < 5) {
    local_108 = _libssh2_error(param_1,0xfffffff6,"Host key data is too short");
    uVar1 = local_108;
    goto LAB_00123621;
  }
  if (*param_8 == 0) {
    pBVar5 = BN_new();
    *(BIGNUM **)(param_8 + 0x28) = pBVar5;
    *param_8 = 2;
  }
  if (*param_8 == 2) {
    local_30 = (void *)(param_3 + 1);
    uVar1 = _libssh2_ntohu32(local_30);
    *(undefined4 *)(param_1 + 0xb8) = uVar1;
    local_30 = (void *)((long)local_30 + 4);
    uVar6 = (**(code **)(param_1 + 8))(*(undefined4 *)(param_1 + 0xb8),param_1);
    *(undefined8 *)(param_1 + 0xb0) = uVar6;
    if (*(long *)(param_1 + 0xb0) == 0) {
      local_108 = _libssh2_error(param_1,0xfffffffa,
                                 "Unable to allocate memory for a copy of the host key");
    }
    else {
      memcpy(*(void **)(param_1 + 0xb0),local_30,(ulong)*(uint *)(param_1 + 0xb8));
      local_30 = (void *)((long)local_30 + (ulong)*(uint *)(param_1 + 0xb8));
      iVar2 = _libssh2_md5_init(&local_100);
      if (iVar2 == 0) {
        *(undefined4 *)(param_1 + 0xcc) = 0;
      }
      else {
        EVP_DigestUpdate(local_100,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));
        EVP_DigestFinal(local_100,(uchar *)(param_1 + 0xbc),(uint *)0x0);
        EVP_MD_CTX_free(local_100);
        *(undefined4 *)(param_1 + 0xcc) = 1;
      }
      iVar2 = _libssh2_sha1_init(&local_100);
      if (iVar2 == 0) {
        *(undefined4 *)(param_1 + 0xe4) = 0;
      }
      else {
        EVP_DigestUpdate(local_100,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));
        EVP_DigestFinal(local_100,(uchar *)(param_1 + 0xd0),(uint *)0x0);
        EVP_MD_CTX_free(local_100);
        *(undefined4 *)(param_1 + 0xe4) = 1;
      }
      iVar2 = _libssh2_sha256_init(&local_100);
      if (iVar2 == 0) {
        *(undefined4 *)(param_1 + 0x108) = 0;
      }
      else {
        EVP_DigestUpdate(local_100,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));
        EVP_DigestFinal(local_100,(uchar *)(param_1 + 0xe8),(uint *)0x0);
        EVP_MD_CTX_free(local_100);
        *(undefined4 *)(param_1 + 0x108) = 1;
      }
      iVar2 = (**(code **)(*(long *)(param_1 + 0xa0) + 0x10))
                        (param_1,*(undefined8 *)(param_1 + 0xb0),*(undefined4 *)(param_1 + 0xb8),
                         param_1 + 0xa8);
      if (iVar2 == 0) {
        uVar3 = _libssh2_ntohu32(local_30);
        local_28 = (ulong)uVar3;
        local_20 = (void *)((long)local_30 + 4);
        local_30 = (void *)((long)local_20 + local_28);
        uVar3 = _libssh2_ntohu32(local_30);
        local_18 = (ulong)uVar3;
        *(long *)(param_8 + 0x30) = (long)local_30 + 4;
        *(ulong *)(param_8 + 0x36) = local_18;
        local_30 = (void *)((long)local_30 + 4 + local_18);
        local_104 = _libssh2_ecdh_gen_k(param_8 + 0x28,param_7,local_20,local_28);
        if (local_104 == 0) {
          iVar4 = BN_num_bits(*(BIGNUM **)(param_8 + 0x28));
          iVar2 = iVar4 + 7;
          if (iVar4 + 7 < 0) {
            iVar2 = iVar4 + 0xe;
          }
          *(long *)(param_8 + 0x34) = (long)((iVar2 >> 3) + 5);
          uVar3 = BN_num_bits(*(BIGNUM **)(param_8 + 0x28));
          if ((uVar3 & 7) != 0) {
            *(long *)(param_8 + 0x34) = *(long *)(param_8 + 0x34) + -1;
          }
          uVar6 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_8 + 0x34),param_1);
          *(undefined8 *)(param_8 + 0x2e) = uVar6;
          if (*(long *)(param_8 + 0x2e) == 0) {
            local_108 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for K");
          }
          else {
            _libssh2_htonu32(*(undefined8 *)(param_8 + 0x2e),
                             (int)*(undefined8 *)(param_8 + 0x34) + -4);
            uVar3 = BN_num_bits(*(BIGNUM **)(param_8 + 0x28));
            if ((uVar3 & 7) == 0) {
              *(undefined *)(*(long *)(param_8 + 0x2e) + 4) = 0;
              BN_bn2bin(*(BIGNUM **)(param_8 + 0x28),(uchar *)(*(long *)(param_8 + 0x2e) + 5));
            }
            else {
              BN_bn2bin(*(BIGNUM **)(param_8 + 0x28),(uchar *)(*(long *)(param_8 + 0x2e) + 4));
            }
            if (param_2 == 0x2cc) {
              *(EVP_MD_CTX ***)(param_8 + 0x38) = &local_100;
              _libssh2_sha512_init(&local_100);
              if (*(long *)(param_1 + 0x180) == 0) {
                _libssh2_htonu32(param_8 + 8,0x19);
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                EVP_DigestUpdate(local_100,"SSH-2.0-libssh2_1.9.0_DEV",0x19);
              }
              else {
                sVar7 = strlen(*(char **)(param_1 + 0x180));
                _libssh2_htonu32(param_8 + 8,(int)sVar7 + -2);
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                sVar7 = strlen(*(char **)(param_1 + 0x180));
                EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x180),sVar7 - 2);
              }
              sVar7 = strlen(*(char **)(param_1 + 0x110));
              _libssh2_htonu32(param_8 + 8,sVar7 & 0xffffffff);
              EVP_DigestUpdate(local_100,param_8 + 8,4);
              sVar7 = strlen(*(char **)(param_1 + 0x110));
              EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x110),sVar7);
              _libssh2_htonu32(param_8 + 8,*(ulong *)(param_1 + 400) & 0xffffffff);
              EVP_DigestUpdate(local_100,param_8 + 8,4);
              EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x188),*(size_t *)(param_1 + 400));
              _libssh2_htonu32(param_8 + 8,*(ulong *)(param_1 + 0x120) & 0xffffffff);
              EVP_DigestUpdate(local_100,param_8 + 8,4);
              EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x118),*(size_t *)(param_1 + 0x120));
              _libssh2_htonu32(param_8 + 8,*(undefined4 *)(param_1 + 0xb8));
              EVP_DigestUpdate(local_100,param_8 + 8,4);
              EVP_DigestUpdate(local_100,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8)
                              );
              _libssh2_htonu32(param_8 + 8,param_6 & 0xffffffff);
              EVP_DigestUpdate(local_100,param_8 + 8,4);
              EVP_DigestUpdate(local_100,param_5,param_6);
              _libssh2_htonu32(param_8 + 8,local_28 & 0xffffffff);
              EVP_DigestUpdate(local_100,param_8 + 8,4);
              EVP_DigestUpdate(local_100,local_20,local_28);
              EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),*(size_t *)(param_8 + 0x34));
              EVP_DigestFinal(local_100,(uchar *)(param_8 + 8),(uint *)0x0);
              EVP_MD_CTX_free(local_100);
              iVar2 = (**(code **)(*(long *)(param_1 + 0xa0) + 0x28))
                                (param_1,*(undefined8 *)(param_8 + 0x30),
                                 *(undefined8 *)(param_8 + 0x36),param_8 + 8,0x40,param_1 + 0xa8);
              if (iVar2 != 0) {
                local_104 = -1;
              }
            }
            else if (param_2 < 0x2cd) {
              if (param_2 == 0x19f) {
                *(EVP_MD_CTX ***)(param_8 + 0x38) = &local_100;
                _libssh2_sha256_init(&local_100);
                if (*(long *)(param_1 + 0x180) == 0) {
                  _libssh2_htonu32(param_8 + 8,0x19);
                  EVP_DigestUpdate(local_100,param_8 + 8,4);
                  EVP_DigestUpdate(local_100,"SSH-2.0-libssh2_1.9.0_DEV",0x19);
                }
                else {
                  sVar7 = strlen(*(char **)(param_1 + 0x180));
                  _libssh2_htonu32(param_8 + 8,(int)sVar7 + -2);
                  EVP_DigestUpdate(local_100,param_8 + 8,4);
                  sVar7 = strlen(*(char **)(param_1 + 0x180));
                  EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x180),sVar7 - 2);
                }
                sVar7 = strlen(*(char **)(param_1 + 0x110));
                _libssh2_htonu32(param_8 + 8,sVar7 & 0xffffffff);
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                sVar7 = strlen(*(char **)(param_1 + 0x110));
                EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x110),sVar7);
                _libssh2_htonu32(param_8 + 8,*(ulong *)(param_1 + 400) & 0xffffffff);
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x188),*(size_t *)(param_1 + 400));
                _libssh2_htonu32(param_8 + 8,*(ulong *)(param_1 + 0x120) & 0xffffffff);
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x118),*(size_t *)(param_1 + 0x120))
                ;
                _libssh2_htonu32(param_8 + 8,*(undefined4 *)(param_1 + 0xb8));
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                EVP_DigestUpdate(local_100,*(void **)(param_1 + 0xb0),
                                 (ulong)*(uint *)(param_1 + 0xb8));
                _libssh2_htonu32(param_8 + 8,param_6 & 0xffffffff);
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                EVP_DigestUpdate(local_100,param_5,param_6);
                _libssh2_htonu32(param_8 + 8,local_28 & 0xffffffff);
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                EVP_DigestUpdate(local_100,local_20,local_28);
                EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),*(size_t *)(param_8 + 0x34));
                EVP_DigestFinal(local_100,(uchar *)(param_8 + 8),(uint *)0x0);
                EVP_MD_CTX_free(local_100);
                iVar2 = (**(code **)(*(long *)(param_1 + 0xa0) + 0x28))
                                  (param_1,*(undefined8 *)(param_8 + 0x30),
                                   *(undefined8 *)(param_8 + 0x36),param_8 + 8,0x20,param_1 + 0xa8);
                if (iVar2 != 0) {
                  local_104 = -1;
                }
              }
              else if (param_2 == 0x2cb) {
                *(EVP_MD_CTX ***)(param_8 + 0x38) = &local_100;
                _libssh2_sha384_init(&local_100);
                if (*(long *)(param_1 + 0x180) == 0) {
                  _libssh2_htonu32(param_8 + 8,0x19);
                  EVP_DigestUpdate(local_100,param_8 + 8,4);
                  EVP_DigestUpdate(local_100,"SSH-2.0-libssh2_1.9.0_DEV",0x19);
                }
                else {
                  sVar7 = strlen(*(char **)(param_1 + 0x180));
                  _libssh2_htonu32(param_8 + 8,(int)sVar7 + -2);
                  EVP_DigestUpdate(local_100,param_8 + 8,4);
                  sVar7 = strlen(*(char **)(param_1 + 0x180));
                  EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x180),sVar7 - 2);
                }
                sVar7 = strlen(*(char **)(param_1 + 0x110));
                _libssh2_htonu32(param_8 + 8,sVar7 & 0xffffffff);
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                sVar7 = strlen(*(char **)(param_1 + 0x110));
                EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x110),sVar7);
                _libssh2_htonu32(param_8 + 8,*(ulong *)(param_1 + 400) & 0xffffffff);
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x188),*(size_t *)(param_1 + 400));
                _libssh2_htonu32(param_8 + 8,*(ulong *)(param_1 + 0x120) & 0xffffffff);
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x118),*(size_t *)(param_1 + 0x120))
                ;
                _libssh2_htonu32(param_8 + 8,*(undefined4 *)(param_1 + 0xb8));
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                EVP_DigestUpdate(local_100,*(void **)(param_1 + 0xb0),
                                 (ulong)*(uint *)(param_1 + 0xb8));
                _libssh2_htonu32(param_8 + 8,param_6 & 0xffffffff);
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                EVP_DigestUpdate(local_100,param_5,param_6);
                _libssh2_htonu32(param_8 + 8,local_28 & 0xffffffff);
                EVP_DigestUpdate(local_100,param_8 + 8,4);
                EVP_DigestUpdate(local_100,local_20,local_28);
                EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),*(size_t *)(param_8 + 0x34));
                EVP_DigestFinal(local_100,(uchar *)(param_8 + 8),(uint *)0x0);
                EVP_MD_CTX_free(local_100);
                iVar2 = (**(code **)(*(long *)(param_1 + 0xa0) + 0x28))
                                  (param_1,*(undefined8 *)(param_8 + 0x30),
                                   *(undefined8 *)(param_8 + 0x36),param_8 + 8,0x30,param_1 + 0xa8);
                if (iVar2 != 0) {
                  local_104 = -1;
                }
              }
            }
            if (local_104 == 0) {
              *(undefined *)(param_8 + 0x18) = 0x15;
              *param_8 = 3;
              goto LAB_00120e0b;
            }
            local_108 = _libssh2_error(param_1,0xfffffff5,"Unable to verify hostkey signature");
          }
        }
        else {
          local_108 = _libssh2_error(param_1,0xfffffffb,"Unable to create ECDH shared secret");
        }
      }
      else {
        local_108 = _libssh2_error(param_1,0xfffffff6,"Unable to initialize hostkey importer");
      }
    }
  }
  else {
LAB_00120e0b:
    if (*param_8 == 3) {
      local_104 = _libssh2_transport_send(param_1,param_8 + 0x18,1,0,0);
      if (local_104 == -0x25) {
        uVar1 = 0xffffffdb;
        goto LAB_00123621;
      }
      if (local_104 != 0) {
        local_108 = _libssh2_error(param_1,local_104,"Unable to send NEWKEYS message");
        goto LAB_00123599;
      }
      *param_8 = 5;
    }
    if (*param_8 == 5) {
      local_104 = _libssh2_packet_require
                            (param_1,0x15,param_8 + 6,param_8 + 0x1e,0,0,0,param_8 + 0x3a);
      if (local_104 == -0x25) {
        uVar1 = 0xffffffdb;
        goto LAB_00123621;
      }
      if (local_104 == 0) {
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 2;
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_8 + 6),param_1);
        if (*(long *)(param_1 + 0x88) == 0) {
          local_f8 = 0;
          if (param_2 == 0x19f) {
            local_f8 = 0x20;
          }
          else if (param_2 == 0x2cb) {
            local_f8 = 0x30;
          }
          else {
            if (param_2 != 0x2cc) {
              local_108 = _libssh2_error(param_1,0xfffffffb,"Unknown SHA digest for EC curve");
              goto LAB_00123599;
            }
            local_f8 = 0x40;
          }
          uVar6 = (**(code **)(param_1 + 8))(local_f8,param_1);
          *(undefined8 *)(param_1 + 0x88) = uVar6;
          if (*(long *)(param_1 + 0x88) == 0) {
            local_108 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for SHA digest"
                                      );
            goto LAB_00123599;
          }
          memcpy(*(void **)(param_1 + 0x88),param_8 + 8,local_f8);
          *(int *)(param_1 + 0x90) = (int)local_f8;
        }
        if (*(long *)(*(long *)(param_1 + 0x198) + 0x38) != 0) {
          (**(code **)(*(long *)(param_1 + 0x198) + 0x38))(param_1,param_1 + 0x1a0);
        }
        if (*(long *)(*(long *)(param_1 + 0x198) + 0x28) == 0) {
LAB_00121ce2:
          if (*(long *)(*(long *)(param_1 + 0x128) + 0x38) != 0) {
            (**(code **)(*(long *)(param_1 + 0x128) + 0x38))(param_1,param_1 + 0x130);
          }
          if (*(long *)(*(long *)(param_1 + 0x128) + 0x28) == 0) {
LAB_001228cb:
            if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x20) != 0) {
              (**(code **)(*(long *)(param_1 + 0x1a8) + 0x20))(param_1,param_1 + 0x1b8);
            }
            if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x10) != 0) {
              local_70 = (void *)0x0;
              local_10c = 0;
              if (param_2 == 0x19f) {
                local_68 = 0;
                if (true) {
                  local_70 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x1a8) + 0xc) +
                                                      0x20),param_1);
                }
                if (local_70 != (void *)0x0) {
                  for (; local_68 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc);
                      local_68 = local_68 + 0x20) {
                    _libssh2_sha256_init(&local_100);
                    EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),
                                     *(size_t *)(param_8 + 0x34));
                    EVP_DigestUpdate(local_100,param_8 + 8,0x20);
                    if (local_68 == 0) {
                      EVP_DigestUpdate(local_100,&DAT_00146571,1);
                      EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_100,local_70,local_68);
                    }
                    EVP_DigestFinal(local_100,(uchar *)((long)local_70 + local_68),(uint *)0x0);
                    EVP_MD_CTX_free(local_100);
                  }
                }
              }
              else if (param_2 == 0x2cb) {
                local_60 = 0;
                if (true) {
                  local_70 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x1a8) + 0xc) +
                                                      0x30),param_1);
                }
                if (local_70 != (void *)0x0) {
                  for (; local_60 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc);
                      local_60 = local_60 + 0x30) {
                    _libssh2_sha384_init(&local_100);
                    EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),
                                     *(size_t *)(param_8 + 0x34));
                    EVP_DigestUpdate(local_100,param_8 + 8,0x30);
                    if (local_60 == 0) {
                      EVP_DigestUpdate(local_100,&DAT_00146571,1);
                      EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_100,local_70,local_60);
                    }
                    EVP_DigestFinal(local_100,(uchar *)((long)local_70 + local_60),(uint *)0x0);
                    EVP_MD_CTX_free(local_100);
                  }
                }
              }
              else if (param_2 == 0x2cc) {
                local_58 = 0;
                if (true) {
                  local_70 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x1a8) + 0xc) +
                                                      0x40),param_1);
                }
                if (local_70 != (void *)0x0) {
                  for (; local_58 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc);
                      local_58 = local_58 + 0x40) {
                    _libssh2_sha512_init(&local_100);
                    EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),
                                     *(size_t *)(param_8 + 0x34));
                    EVP_DigestUpdate(local_100,param_8 + 8,0x40);
                    if (local_58 == 0) {
                      EVP_DigestUpdate(local_100,&DAT_00146571,1);
                      EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_100,local_70,local_58);
                    }
                    EVP_DigestFinal(local_100,(uchar *)((long)local_70 + local_58),(uint *)0x0);
                    EVP_MD_CTX_free(local_100);
                  }
                }
              }
              if (local_70 == (void *)0x0) {
                local_108 = 0xfffffffb;
                goto LAB_00123599;
              }
              (**(code **)(*(long *)(param_1 + 0x1a8) + 0x10))
                        (param_1,local_70,&local_10c,param_1 + 0x1b8);
              if (local_10c != 0) {
                _libssh2_explicit_zero(local_70,(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc));
                (**(code **)(param_1 + 0x18))(local_70,param_1);
              }
            }
            if (*(long *)(*(long *)(param_1 + 0x138) + 0x20) != 0) {
              (**(code **)(*(long *)(param_1 + 0x138) + 0x20))(param_1,param_1 + 0x148);
            }
            if (*(long *)(*(long *)(param_1 + 0x138) + 0x10) != 0) {
              local_50 = (void *)0x0;
              local_10c = 0;
              if (param_2 == 0x19f) {
                local_48 = 0;
                if (true) {
                  local_50 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x138) + 0xc) +
                                                      0x20),param_1);
                }
                if (local_50 != (void *)0x0) {
                  for (; local_48 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc);
                      local_48 = local_48 + 0x20) {
                    _libssh2_sha256_init(&local_100);
                    EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),
                                     *(size_t *)(param_8 + 0x34));
                    EVP_DigestUpdate(local_100,param_8 + 8,0x20);
                    if (local_48 == 0) {
                      EVP_DigestUpdate(local_100,&DAT_00146573,1);
                      EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_100,local_50,local_48);
                    }
                    EVP_DigestFinal(local_100,(uchar *)((long)local_50 + local_48),(uint *)0x0);
                    EVP_MD_CTX_free(local_100);
                  }
                }
              }
              else if (param_2 == 0x2cb) {
                local_40 = 0;
                if (true) {
                  local_50 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x138) + 0xc) +
                                                      0x30),param_1);
                }
                if (local_50 != (void *)0x0) {
                  for (; local_40 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc);
                      local_40 = local_40 + 0x30) {
                    _libssh2_sha384_init(&local_100);
                    EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),
                                     *(size_t *)(param_8 + 0x34));
                    EVP_DigestUpdate(local_100,param_8 + 8,0x30);
                    if (local_40 == 0) {
                      EVP_DigestUpdate(local_100,&DAT_00146573,1);
                      EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_100,local_50,local_40);
                    }
                    EVP_DigestFinal(local_100,(uchar *)((long)local_50 + local_40),(uint *)0x0);
                    EVP_MD_CTX_free(local_100);
                  }
                }
              }
              else if (param_2 == 0x2cc) {
                local_38 = 0;
                if (true) {
                  local_50 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x138) + 0xc) +
                                                      0x40),param_1);
                }
                if (local_50 != (void *)0x0) {
                  for (; local_38 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc);
                      local_38 = local_38 + 0x40) {
                    _libssh2_sha512_init(&local_100);
                    EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),
                                     *(size_t *)(param_8 + 0x34));
                    EVP_DigestUpdate(local_100,param_8 + 8,0x40);
                    if (local_38 == 0) {
                      EVP_DigestUpdate(local_100,&DAT_00146573,1);
                      EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_100,local_50,local_38);
                    }
                    EVP_DigestFinal(local_100,(uchar *)((long)local_50 + local_38),(uint *)0x0);
                    EVP_MD_CTX_free(local_100);
                  }
                }
              }
              if (local_50 == (void *)0x0) {
                local_108 = 0xfffffffb;
                goto LAB_00123599;
              }
              (**(code **)(*(long *)(param_1 + 0x138) + 0x10))
                        (param_1,local_50,&local_10c,param_1 + 0x148);
              if (local_10c != 0) {
                _libssh2_explicit_zero(local_50,(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc));
                (**(code **)(param_1 + 0x18))(local_50,param_1);
              }
            }
            if ((*(long *)(param_1 + 0x1c0) != 0) &&
               (*(long *)(*(long *)(param_1 + 0x1c0) + 0x28) != 0)) {
              (**(code **)(*(long *)(param_1 + 0x1c0) + 0x28))(param_1,1,param_1 + 0x1c8);
            }
            if (((*(long *)(param_1 + 0x1c0) == 0) ||
                (*(long *)(*(long *)(param_1 + 0x1c0) + 0x10) == 0)) ||
               (iVar2 = (**(code **)(*(long *)(param_1 + 0x1c0) + 0x10))(param_1,1,param_1 + 0x1c8),
               iVar2 == 0)) {
              if ((*(long *)(param_1 + 0x150) != 0) &&
                 (*(long *)(*(long *)(param_1 + 0x150) + 0x28) != 0)) {
                (**(code **)(*(long *)(param_1 + 0x150) + 0x28))(param_1,0,param_1 + 0x158);
              }
              if (((*(long *)(param_1 + 0x150) != 0) &&
                  (*(long *)(*(long *)(param_1 + 0x150) + 0x10) != 0)) &&
                 (iVar2 = (**(code **)(*(long *)(param_1 + 0x150) + 0x10))
                                    (param_1,0,param_1 + 0x158), iVar2 != 0)) {
                local_108 = 0xfffffffb;
              }
            }
            else {
              local_108 = 0xfffffffb;
            }
          }
          else {
            local_b0 = (void *)0x0;
            local_a8 = (void *)0x0;
            local_110 = 0;
            local_10c = 0;
            if (param_2 == 0x19f) {
              local_a0 = 0;
              if (true) {
                local_b0 = (void *)(**(code **)(param_1 + 8))
                                             ((long)(*(int *)(*(long *)(param_1 + 0x128) + 0x14) +
                                                    0x20),param_1);
              }
              if (local_b0 != (void *)0x0) {
                for (; local_a0 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14);
                    local_a0 = local_a0 + 0x20) {
                  _libssh2_sha256_init(&local_100);
                  EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),*(size_t *)(param_8 + 0x34))
                  ;
                  EVP_DigestUpdate(local_100,param_8 + 8,0x20);
                  if (local_a0 == 0) {
                    EVP_DigestUpdate(local_100,&DAT_0014656d,1);
                    EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_100,local_b0,local_a0);
                  }
                  EVP_DigestFinal(local_100,(uchar *)((long)local_b0 + local_a0),(uint *)0x0);
                  EVP_MD_CTX_free(local_100);
                }
              }
            }
            else if (param_2 == 0x2cb) {
              local_98 = 0;
              if (true) {
                local_b0 = (void *)(**(code **)(param_1 + 8))
                                             ((long)(*(int *)(*(long *)(param_1 + 0x128) + 0x14) +
                                                    0x30),param_1);
              }
              if (local_b0 != (void *)0x0) {
                for (; local_98 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14);
                    local_98 = local_98 + 0x30) {
                  _libssh2_sha384_init(&local_100);
                  EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),*(size_t *)(param_8 + 0x34))
                  ;
                  EVP_DigestUpdate(local_100,param_8 + 8,0x30);
                  if (local_98 == 0) {
                    EVP_DigestUpdate(local_100,&DAT_0014656d,1);
                    EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_100,local_b0,local_98);
                  }
                  EVP_DigestFinal(local_100,(uchar *)((long)local_b0 + local_98),(uint *)0x0);
                  EVP_MD_CTX_free(local_100);
                }
              }
            }
            else if (param_2 == 0x2cc) {
              local_90 = 0;
              if (true) {
                local_b0 = (void *)(**(code **)(param_1 + 8))
                                             ((long)(*(int *)(*(long *)(param_1 + 0x128) + 0x14) +
                                                    0x40),param_1);
              }
              if (local_b0 != (void *)0x0) {
                for (; local_90 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14);
                    local_90 = local_90 + 0x40) {
                  _libssh2_sha512_init(&local_100);
                  EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),*(size_t *)(param_8 + 0x34))
                  ;
                  EVP_DigestUpdate(local_100,param_8 + 8,0x40);
                  if (local_90 == 0) {
                    EVP_DigestUpdate(local_100,&DAT_0014656d,1);
                    EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_100,local_b0,local_90);
                  }
                  EVP_DigestFinal(local_100,(uchar *)((long)local_b0 + local_90),(uint *)0x0);
                  EVP_MD_CTX_free(local_100);
                }
              }
            }
            if (local_b0 == (void *)0x0) {
              local_108 = 0xfffffffb;
            }
            else {
              if (param_2 == 0x19f) {
                local_88 = 0;
                if (local_a8 == (void *)0x0) {
                  local_a8 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x128) + 0x18) +
                                                      0x20),param_1);
                }
                if (local_a8 != (void *)0x0) {
                  for (; local_88 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18);
                      local_88 = local_88 + 0x20) {
                    _libssh2_sha256_init(&local_100);
                    EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),
                                     *(size_t *)(param_8 + 0x34));
                    EVP_DigestUpdate(local_100,param_8 + 8,0x20);
                    if (local_88 == 0) {
                      EVP_DigestUpdate(local_100,&DAT_0014656f,1);
                      EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_100,local_a8,local_88);
                    }
                    EVP_DigestFinal(local_100,(uchar *)((long)local_a8 + local_88),(uint *)0x0);
                    EVP_MD_CTX_free(local_100);
                  }
                }
              }
              else if (param_2 == 0x2cb) {
                local_80 = 0;
                if (local_a8 == (void *)0x0) {
                  local_a8 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x128) + 0x18) +
                                                      0x30),param_1);
                }
                if (local_a8 != (void *)0x0) {
                  for (; local_80 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18);
                      local_80 = local_80 + 0x30) {
                    _libssh2_sha384_init(&local_100);
                    EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),
                                     *(size_t *)(param_8 + 0x34));
                    EVP_DigestUpdate(local_100,param_8 + 8,0x30);
                    if (local_80 == 0) {
                      EVP_DigestUpdate(local_100,&DAT_0014656f,1);
                      EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_100,local_a8,local_80);
                    }
                    EVP_DigestFinal(local_100,(uchar *)((long)local_a8 + local_80),(uint *)0x0);
                    EVP_MD_CTX_free(local_100);
                  }
                }
              }
              else if (param_2 == 0x2cc) {
                local_78 = 0;
                if (local_a8 == (void *)0x0) {
                  local_a8 = (void *)(**(code **)(param_1 + 8))
                                               ((long)(*(int *)(*(long *)(param_1 + 0x128) + 0x18) +
                                                      0x40),param_1);
                }
                if (local_a8 != (void *)0x0) {
                  for (; local_78 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18);
                      local_78 = local_78 + 0x40) {
                    _libssh2_sha512_init(&local_100);
                    EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),
                                     *(size_t *)(param_8 + 0x34));
                    EVP_DigestUpdate(local_100,param_8 + 8,0x40);
                    if (local_78 == 0) {
                      EVP_DigestUpdate(local_100,&DAT_0014656f,1);
                      EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                       (ulong)*(uint *)(param_1 + 0x90));
                    }
                    else {
                      EVP_DigestUpdate(local_100,local_a8,local_78);
                    }
                    EVP_DigestFinal(local_100,(uchar *)((long)local_a8 + local_78),(uint *)0x0);
                    EVP_MD_CTX_free(local_100);
                  }
                }
              }
              if (local_a8 == (void *)0x0) {
                (**(code **)(param_1 + 0x18))(local_b0,param_1);
                local_108 = 0xfffffffb;
              }
              else {
                iVar2 = (**(code **)(*(long *)(param_1 + 0x128) + 0x28))
                                  (param_1,*(undefined8 *)(param_1 + 0x128),local_b0,&local_110,
                                   local_a8,&local_10c,0,param_1 + 0x130);
                if (iVar2 == 0) {
                  if (local_110 != 0) {
                    _libssh2_explicit_zero
                              (local_b0,(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14));
                    (**(code **)(param_1 + 0x18))(local_b0,param_1);
                  }
                  if (local_10c != 0) {
                    _libssh2_explicit_zero
                              (local_a8,(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18));
                    (**(code **)(param_1 + 0x18))(local_a8,param_1);
                  }
                  goto LAB_001228cb;
                }
                (**(code **)(param_1 + 0x18))(local_b0,param_1);
                (**(code **)(param_1 + 0x18))(local_a8,param_1);
                local_108 = 0xfffffffb;
              }
            }
          }
        }
        else {
          local_f0 = (void *)0x0;
          local_e8 = (void *)0x0;
          local_110 = 0;
          local_10c = 0;
          if (param_2 == 0x19f) {
            local_e0 = 0;
            if (true) {
              local_f0 = (void *)(**(code **)(param_1 + 8))
                                           ((long)(*(int *)(*(long *)(param_1 + 0x198) + 0x14) +
                                                  0x20),param_1);
            }
            if (local_f0 != (void *)0x0) {
              for (; local_e0 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14);
                  local_e0 = local_e0 + 0x20) {
                _libssh2_sha256_init(&local_100);
                EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),*(size_t *)(param_8 + 0x34));
                EVP_DigestUpdate(local_100,param_8 + 8,0x20);
                if (local_e0 == 0) {
                  EVP_DigestUpdate(local_100,&DAT_00146569,1);
                  EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                   (ulong)*(uint *)(param_1 + 0x90));
                }
                else {
                  EVP_DigestUpdate(local_100,local_f0,local_e0);
                }
                EVP_DigestFinal(local_100,(uchar *)((long)local_f0 + local_e0),(uint *)0x0);
                EVP_MD_CTX_free(local_100);
              }
            }
          }
          else if (param_2 == 0x2cb) {
            local_d8 = 0;
            if (true) {
              local_f0 = (void *)(**(code **)(param_1 + 8))
                                           ((long)(*(int *)(*(long *)(param_1 + 0x198) + 0x14) +
                                                  0x30),param_1);
            }
            if (local_f0 != (void *)0x0) {
              for (; local_d8 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14);
                  local_d8 = local_d8 + 0x30) {
                _libssh2_sha384_init(&local_100);
                EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),*(size_t *)(param_8 + 0x34));
                EVP_DigestUpdate(local_100,param_8 + 8,0x30);
                if (local_d8 == 0) {
                  EVP_DigestUpdate(local_100,&DAT_00146569,1);
                  EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                   (ulong)*(uint *)(param_1 + 0x90));
                }
                else {
                  EVP_DigestUpdate(local_100,local_f0,local_d8);
                }
                EVP_DigestFinal(local_100,(uchar *)((long)local_f0 + local_d8),(uint *)0x0);
                EVP_MD_CTX_free(local_100);
              }
            }
          }
          else if (param_2 == 0x2cc) {
            local_d0 = 0;
            if (true) {
              local_f0 = (void *)(**(code **)(param_1 + 8))
                                           ((long)(*(int *)(*(long *)(param_1 + 0x198) + 0x14) +
                                                  0x40),param_1);
            }
            if (local_f0 != (void *)0x0) {
              for (; local_d0 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14);
                  local_d0 = local_d0 + 0x40) {
                _libssh2_sha512_init(&local_100);
                EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),*(size_t *)(param_8 + 0x34));
                EVP_DigestUpdate(local_100,param_8 + 8,0x40);
                if (local_d0 == 0) {
                  EVP_DigestUpdate(local_100,&DAT_00146569,1);
                  EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                   (ulong)*(uint *)(param_1 + 0x90));
                }
                else {
                  EVP_DigestUpdate(local_100,local_f0,local_d0);
                }
                EVP_DigestFinal(local_100,(uchar *)((long)local_f0 + local_d0),(uint *)0x0);
                EVP_MD_CTX_free(local_100);
              }
            }
          }
          if (local_f0 == (void *)0x0) {
            local_108 = 0xffffffff;
          }
          else {
            if (param_2 == 0x19f) {
              local_c8 = 0;
              if (local_e8 == (void *)0x0) {
                local_e8 = (void *)(**(code **)(param_1 + 8))
                                             ((long)(*(int *)(*(long *)(param_1 + 0x198) + 0x18) +
                                                    0x20),param_1);
              }
              if (local_e8 != (void *)0x0) {
                for (; local_c8 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18);
                    local_c8 = local_c8 + 0x20) {
                  _libssh2_sha256_init(&local_100);
                  EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),*(size_t *)(param_8 + 0x34))
                  ;
                  EVP_DigestUpdate(local_100,param_8 + 8,0x20);
                  if (local_c8 == 0) {
                    EVP_DigestUpdate(local_100,&DAT_0014656b,1);
                    EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_100,local_e8,local_c8);
                  }
                  EVP_DigestFinal(local_100,(uchar *)((long)local_e8 + local_c8),(uint *)0x0);
                  EVP_MD_CTX_free(local_100);
                }
              }
            }
            else if (param_2 == 0x2cb) {
              local_c0 = 0;
              if (local_e8 == (void *)0x0) {
                local_e8 = (void *)(**(code **)(param_1 + 8))
                                             ((long)(*(int *)(*(long *)(param_1 + 0x198) + 0x18) +
                                                    0x30),param_1);
              }
              if (local_e8 != (void *)0x0) {
                for (; local_c0 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18);
                    local_c0 = local_c0 + 0x30) {
                  _libssh2_sha384_init(&local_100);
                  EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),*(size_t *)(param_8 + 0x34))
                  ;
                  EVP_DigestUpdate(local_100,param_8 + 8,0x30);
                  if (local_c0 == 0) {
                    EVP_DigestUpdate(local_100,&DAT_0014656b,1);
                    EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_100,local_e8,local_c0);
                  }
                  EVP_DigestFinal(local_100,(uchar *)((long)local_e8 + local_c0),(uint *)0x0);
                  EVP_MD_CTX_free(local_100);
                }
              }
            }
            else if (param_2 == 0x2cc) {
              local_b8 = 0;
              if (local_e8 == (void *)0x0) {
                local_e8 = (void *)(**(code **)(param_1 + 8))
                                             ((long)(*(int *)(*(long *)(param_1 + 0x198) + 0x18) +
                                                    0x40),param_1);
              }
              if (local_e8 != (void *)0x0) {
                for (; local_b8 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18);
                    local_b8 = local_b8 + 0x40) {
                  _libssh2_sha512_init(&local_100);
                  EVP_DigestUpdate(local_100,*(void **)(param_8 + 0x2e),*(size_t *)(param_8 + 0x34))
                  ;
                  EVP_DigestUpdate(local_100,param_8 + 8,0x40);
                  if (local_b8 == 0) {
                    EVP_DigestUpdate(local_100,&DAT_0014656b,1);
                    EVP_DigestUpdate(local_100,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_100,local_e8,local_b8);
                  }
                  EVP_DigestFinal(local_100,(uchar *)((long)local_e8 + local_b8),(uint *)0x0);
                  EVP_MD_CTX_free(local_100);
                }
              }
            }
            if (local_e8 == (void *)0x0) {
              (**(code **)(param_1 + 0x18))(local_f0,param_1);
              local_108 = 0xfffffffb;
            }
            else {
              iVar2 = (**(code **)(*(long *)(param_1 + 0x198) + 0x28))
                                (param_1,*(undefined8 *)(param_1 + 0x198),local_f0,&local_110,
                                 local_e8,&local_10c,1,param_1 + 0x1a0);
              if (iVar2 == 0) {
                if (local_110 != 0) {
                  _libssh2_explicit_zero(local_f0,(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14))
                  ;
                  (**(code **)(param_1 + 0x18))(local_f0,param_1);
                }
                if (local_10c != 0) {
                  _libssh2_explicit_zero(local_e8,(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18))
                  ;
                  (**(code **)(param_1 + 0x18))(local_e8,param_1);
                }
                goto LAB_00121ce2;
              }
              (**(code **)(param_1 + 0x18))(local_f0,param_1);
              (**(code **)(param_1 + 0x18))(local_e8,param_1);
              local_108 = 0xfffffffb;
            }
          }
        }
      }
      else {
        local_108 = _libssh2_error(param_1,local_104,"Timed out waiting for NEWKEYS");
      }
    }
  }
LAB_00123599:
  BN_clear_free(*(BIGNUM **)(param_8 + 0x28));
  param_8[0x28] = 0;
  param_8[0x29] = 0;
  if (*(long *)(param_8 + 0x2e) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_8 + 0x2e),param_1);
    param_8[0x2e] = 0;
    param_8[0x2f] = 0;
  }
  *param_8 = 0;
  uVar1 = local_108;
LAB_00123621:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int kex_method_ecdh_key_exchange(long param_1,int *param_2)

{
  int iVar1;
  long in_FS_OFFSET;
  undefined4 local_24;
  int local_20;
  int local_1c;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = 0;
  local_1c = 0;
  if (*param_2 == 0) {
    param_2[0x92] = 0;
    param_2[0x93] = 0;
    *param_2 = 2;
  }
  if (*param_2 == 2) {
    local_1c = kex_session_ecdh_curve_type(**(undefined8 **)(param_1 + 0x78),&local_24);
    if (local_1c == 0) {
      local_1c = _libssh2_ecdsa_create_key
                           (param_1,param_2 + 0x90,param_2 + 0x92,param_2 + 0x94,local_24);
      if (local_1c == 0) {
        *(undefined *)(param_2 + 0x4a) = 0x1e;
        local_18 = (long)param_2 + 0x129;
        _libssh2_store_str(&local_18,*(undefined8 *)(param_2 + 0x92),*(undefined8 *)(param_2 + 0x94)
                          );
        *(long *)(param_2 + 0x8c) = *(long *)(param_2 + 0x94) + 5;
        *param_2 = 3;
        goto LAB_0012379f;
      }
      local_20 = _libssh2_error(param_1,local_1c,"Unable to create private key");
    }
    else {
      local_20 = _libssh2_error(param_1,0xffffffff,"Unknown KEX nistp curve type");
    }
  }
  else {
LAB_0012379f:
    if (*param_2 == 3) {
      local_1c = _libssh2_transport_send(param_1,param_2 + 0x4a,*(undefined8 *)(param_2 + 0x8c),0,0)
      ;
      if (local_1c == -0x25) {
        iVar1 = -0x25;
        goto LAB_001239db;
      }
      if (local_1c != 0) {
        local_20 = _libssh2_error(param_1,local_1c,"Unable to send ECDH_INIT");
        goto LAB_0012395e;
      }
      *param_2 = 4;
    }
    if (*param_2 == 4) {
      local_1c = _libssh2_packet_require
                           (param_1,0x1f,param_2 + 0x8a,param_2 + 0x8e,0,0,0,param_2 + 2);
      if (local_1c == -0x25) {
        iVar1 = -0x25;
        goto LAB_001239db;
      }
      if (local_1c != 0) {
        local_20 = _libssh2_error(param_1,local_1c,"Timeout waiting for ECDH_REPLY reply");
        goto LAB_0012395e;
      }
      *param_2 = 5;
    }
    if (*param_2 == 5) {
      kex_session_ecdh_curve_type(**(undefined8 **)(param_1 + 0x78),&local_24);
      local_20 = ecdh_sha2_nistp(param_1,local_24,*(undefined8 *)(param_2 + 0x8a),
                                 *(undefined8 *)(param_2 + 0x8e),*(undefined8 *)(param_2 + 0x92),
                                 *(undefined8 *)(param_2 + 0x94),*(undefined8 *)(param_2 + 0x90),
                                 param_2 + 6);
      iVar1 = local_20;
      if (local_20 == -0x25) goto LAB_001239db;
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_2 + 0x8a),param_1);
    }
  }
LAB_0012395e:
  if (*(long *)(param_2 + 0x92) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_2 + 0x92),param_1);
    param_2[0x92] = 0;
    param_2[0x93] = 0;
  }
  if (*(long *)(param_2 + 0x90) != 0) {
    EC_KEY_free(*(EC_KEY **)(param_2 + 0x90));
    param_2[0x90] = 0;
    param_2[0x91] = 0;
  }
  *param_2 = 0;
  iVar1 = local_20;
LAB_001239db:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong curve25519_sha256(long param_1,long param_2,ulong param_3,void *param_4,undefined8 param_5,
                       int *param_6)

{
  void *pvVar1;
  undefined4 uVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  ulong uVar6;
  BIGNUM *pBVar7;
  undefined8 uVar8;
  size_t sVar9;
  long in_FS_OFFSET;
  int local_b4;
  int local_b0;
  uint local_ac;
  int local_a8;
  int local_a4;
  EVP_MD_CTX *local_a0;
  void *local_98;
  void *local_90;
  ulong local_88;
  ulong local_80;
  void *local_78;
  void *local_70;
  ulong local_68;
  ulong local_60;
  void *local_58;
  ulong local_50;
  void *local_48;
  ulong local_40;
  void *local_38;
  ulong local_30;
  void *local_28;
  ulong local_20;
  size_t local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_ac = 0;
  local_a4 = 0x20;
  if (param_3 < 5) {
    uVar6 = _libssh2_error(param_1,0xfffffff6,"Data is too short");
    goto LAB_001258a3;
  }
  if (*param_6 == 0) {
    pBVar7 = BN_new();
    *(BIGNUM **)(param_6 + 0x28) = pBVar7;
    *param_6 = 2;
  }
  if (*param_6 == 2) {
    local_38 = (void *)(param_2 + 1);
    uVar2 = _libssh2_ntohu32(local_38);
    *(undefined4 *)(param_1 + 0xb8) = uVar2;
    local_38 = (void *)((long)local_38 + 4);
    uVar8 = (**(code **)(param_1 + 8))(*(undefined4 *)(param_1 + 0xb8),param_1);
    *(undefined8 *)(param_1 + 0xb0) = uVar8;
    if (*(long *)(param_1 + 0xb0) == 0) {
      local_ac = _libssh2_error(param_1,0xfffffffa,
                                "Unable to allocate memory for a copy of the host key");
    }
    else {
      memcpy(*(void **)(param_1 + 0xb0),local_38,(ulong)*(uint *)(param_1 + 0xb8));
      local_38 = (void *)((long)local_38 + (ulong)*(uint *)(param_1 + 0xb8));
      iVar3 = _libssh2_md5_init(&local_a0);
      if (iVar3 == 0) {
        *(undefined4 *)(param_1 + 0xcc) = 0;
      }
      else {
        EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));
        EVP_DigestFinal(local_a0,(uchar *)(param_1 + 0xbc),(uint *)0x0);
        EVP_MD_CTX_free(local_a0);
        *(undefined4 *)(param_1 + 0xcc) = 1;
      }
      iVar3 = _libssh2_sha1_init(&local_a0);
      if (iVar3 == 0) {
        *(undefined4 *)(param_1 + 0xe4) = 0;
      }
      else {
        EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));
        EVP_DigestFinal(local_a0,(uchar *)(param_1 + 0xd0),(uint *)0x0);
        EVP_MD_CTX_free(local_a0);
        *(undefined4 *)(param_1 + 0xe4) = 1;
      }
      iVar3 = _libssh2_sha256_init(&local_a0);
      if (iVar3 == 0) {
        *(undefined4 *)(param_1 + 0x108) = 0;
      }
      else {
        EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8));
        EVP_DigestFinal(local_a0,(uchar *)(param_1 + 0xe8),(uint *)0x0);
        EVP_MD_CTX_free(local_a0);
        *(undefined4 *)(param_1 + 0x108) = 1;
      }
      iVar3 = (**(code **)(*(long *)(param_1 + 0xa0) + 0x10))
                        (param_1,*(undefined8 *)(param_1 + 0xb0),*(undefined4 *)(param_1 + 0xb8),
                         param_1 + 0xa8);
      if (iVar3 == 0) {
        uVar4 = _libssh2_ntohu32(local_38);
        local_30 = (ulong)uVar4;
        pvVar1 = (void *)((long)local_38 + 4);
        if (local_30 == 0x20) {
          local_38 = (void *)((long)local_38 + 0x24);
          local_28 = pvVar1;
          uVar4 = _libssh2_ntohu32(local_38);
          local_20 = (ulong)uVar4;
          *(long *)(param_6 + 0x30) = (long)local_38 + 4;
          *(ulong *)(param_6 + 0x36) = local_20;
          local_38 = (void *)((long)local_38 + 4 + local_20);
          local_a8 = _libssh2_curve25519_gen_k(param_6 + 0x28,param_5,local_28);
          if (local_a8 == 0) {
            iVar5 = BN_num_bits(*(BIGNUM **)(param_6 + 0x28));
            iVar3 = iVar5 + 7;
            if (iVar5 + 7 < 0) {
              iVar3 = iVar5 + 0xe;
            }
            *(long *)(param_6 + 0x34) = (long)((iVar3 >> 3) + 5);
            uVar4 = BN_num_bits(*(BIGNUM **)(param_6 + 0x28));
            if ((uVar4 & 7) != 0) {
              *(long *)(param_6 + 0x34) = *(long *)(param_6 + 0x34) + -1;
            }
            uVar8 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_6 + 0x34),param_1);
            *(undefined8 *)(param_6 + 0x2e) = uVar8;
            if (*(long *)(param_6 + 0x2e) == 0) {
              local_ac = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for K");
            }
            else {
              _libssh2_htonu32(*(undefined8 *)(param_6 + 0x2e),
                               (int)*(undefined8 *)(param_6 + 0x34) + -4);
              uVar4 = BN_num_bits(*(BIGNUM **)(param_6 + 0x28));
              if ((uVar4 & 7) == 0) {
                *(undefined *)(*(long *)(param_6 + 0x2e) + 4) = 0;
                BN_bn2bin(*(BIGNUM **)(param_6 + 0x28),(uchar *)(*(long *)(param_6 + 0x2e) + 5));
              }
              else {
                BN_bn2bin(*(BIGNUM **)(param_6 + 0x28),(uchar *)(*(long *)(param_6 + 0x2e) + 4));
              }
              *(EVP_MD_CTX ***)(param_6 + 0x38) = &local_a0;
              _libssh2_sha256_init(&local_a0);
              if (*(long *)(param_1 + 0x180) == 0) {
                _libssh2_htonu32(param_6 + 8,0x19);
                EVP_DigestUpdate(local_a0,param_6 + 8,4);
                EVP_DigestUpdate(local_a0,"SSH-2.0-libssh2_1.9.0_DEV",0x19);
              }
              else {
                sVar9 = strlen(*(char **)(param_1 + 0x180));
                _libssh2_htonu32(param_6 + 8,(int)sVar9 + -2);
                EVP_DigestUpdate(local_a0,param_6 + 8,4);
                sVar9 = strlen(*(char **)(param_1 + 0x180));
                EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0x180),sVar9 - 2);
              }
              sVar9 = strlen(*(char **)(param_1 + 0x110));
              _libssh2_htonu32(param_6 + 8,sVar9 & 0xffffffff);
              EVP_DigestUpdate(local_a0,param_6 + 8,4);
              sVar9 = strlen(*(char **)(param_1 + 0x110));
              EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0x110),sVar9);
              _libssh2_htonu32(param_6 + 8,*(ulong *)(param_1 + 400) & 0xffffffff);
              EVP_DigestUpdate(local_a0,param_6 + 8,4);
              EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0x188),*(size_t *)(param_1 + 400));
              _libssh2_htonu32(param_6 + 8,*(ulong *)(param_1 + 0x120) & 0xffffffff);
              EVP_DigestUpdate(local_a0,param_6 + 8,4);
              EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0x118),*(size_t *)(param_1 + 0x120));
              _libssh2_htonu32(param_6 + 8,*(undefined4 *)(param_1 + 0xb8));
              EVP_DigestUpdate(local_a0,param_6 + 8,4);
              EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0xb0),(ulong)*(uint *)(param_1 + 0xb8))
              ;
              _libssh2_htonu32(param_6 + 8,local_a4);
              EVP_DigestUpdate(local_a0,param_6 + 8,4);
              EVP_DigestUpdate(local_a0,param_4,(long)local_a4);
              _libssh2_htonu32(param_6 + 8,local_30 & 0xffffffff);
              EVP_DigestUpdate(local_a0,param_6 + 8,4);
              EVP_DigestUpdate(local_a0,local_28,local_30);
              EVP_DigestUpdate(local_a0,*(void **)(param_6 + 0x2e),*(size_t *)(param_6 + 0x34));
              EVP_DigestFinal(local_a0,(uchar *)(param_6 + 8),(uint *)0x0);
              EVP_MD_CTX_free(local_a0);
              iVar3 = (**(code **)(*(long *)(param_1 + 0xa0) + 0x28))
                                (param_1,*(undefined8 *)(param_6 + 0x30),
                                 *(undefined8 *)(param_6 + 0x36),param_6 + 8,0x20,param_1 + 0xa8);
              if (iVar3 != 0) {
                local_a8 = -1;
              }
              if (local_a8 == 0) {
                *(undefined *)(param_6 + 0x18) = 0x15;
                *param_6 = 3;
                goto LAB_00124529;
              }
              local_ac = _libssh2_error(param_1,0xfffffff5,"Unable to verify hostkey signature");
            }
          }
          else {
            local_ac = _libssh2_error(param_1,0xfffffffb,"Unable to create ECDH shared secret");
          }
        }
        else {
          local_38 = pvVar1;
          local_ac = _libssh2_error(param_1,0xfffffff6,
                                    "Unexpected curve25519 server public key length");
        }
      }
      else {
        local_ac = _libssh2_error(param_1,0xfffffff6,"Unable to initialize hostkey importer");
      }
    }
  }
  else {
LAB_00124529:
    if (*param_6 == 3) {
      local_a8 = _libssh2_transport_send(param_1,param_6 + 0x18,1,0,0);
      if (local_a8 == -0x25) {
        uVar6 = 0xffffffdb;
        goto LAB_001258a3;
      }
      if (local_a8 != 0) {
        local_ac = _libssh2_error(param_1,local_a8,"Unable to send NEWKEYS message");
        goto LAB_0012581b;
      }
      *param_6 = 5;
    }
    if (*param_6 == 5) {
      local_a8 = _libssh2_packet_require
                           (param_1,0x15,param_6 + 6,param_6 + 0x1e,0,0,0,param_6 + 0x3a);
      if (local_a8 == -0x25) {
        uVar6 = 0xffffffdb;
        goto LAB_001258a3;
      }
      if (local_a8 == 0) {
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 2;
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_6 + 6),param_1);
        if (*(long *)(param_1 + 0x88) == 0) {
          local_18 = 0x20;
          uVar8 = (**(code **)(param_1 + 8))(0x20,param_1);
          *(undefined8 *)(param_1 + 0x88) = uVar8;
          if (*(long *)(param_1 + 0x88) == 0) {
            local_ac = _libssh2_error(param_1,0xfffffffa,"Unable to allocate buffer for SHA digest")
            ;
            goto LAB_0012581b;
          }
          memcpy(*(void **)(param_1 + 0x88),param_6 + 8,local_18);
          *(int *)(param_1 + 0x90) = (int)local_18;
        }
        if (*(long *)(*(long *)(param_1 + 0x198) + 0x38) != 0) {
          (**(code **)(*(long *)(param_1 + 0x198) + 0x38))(param_1,param_1 + 0x1a0);
        }
        if (*(long *)(*(long *)(param_1 + 0x198) + 0x28) == 0) {
LAB_00124c9b:
          if (*(long *)(*(long *)(param_1 + 0x128) + 0x38) != 0) {
            (**(code **)(*(long *)(param_1 + 0x128) + 0x38))(param_1,param_1 + 0x130);
          }
          if (*(long *)(*(long *)(param_1 + 0x128) + 0x28) == 0) {
LAB_0012518d:
            if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x20) != 0) {
              (**(code **)(*(long *)(param_1 + 0x1a8) + 0x20))(param_1,param_1 + 0x1b8);
            }
            if (*(long *)(*(long *)(param_1 + 0x1a8) + 0x10) != 0) {
              local_58 = (void *)0x0;
              local_b0 = 0;
              local_50 = 0;
              if (true) {
                local_58 = (void *)(**(code **)(param_1 + 8))
                                             ((long)(*(int *)(*(long *)(param_1 + 0x1a8) + 0xc) +
                                                    0x20),param_1);
              }
              if (local_58 != (void *)0x0) {
                for (; local_50 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc);
                    local_50 = local_50 + 0x20) {
                  _libssh2_sha256_init(&local_a0);
                  EVP_DigestUpdate(local_a0,*(void **)(param_6 + 0x2e),*(size_t *)(param_6 + 0x34));
                  EVP_DigestUpdate(local_a0,param_6 + 8,0x20);
                  if (local_50 == 0) {
                    EVP_DigestUpdate(local_a0,&DAT_00146571,1);
                    EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_a0,local_58,local_50);
                  }
                  EVP_DigestFinal(local_a0,(uchar *)((long)local_58 + local_50),(uint *)0x0);
                  EVP_MD_CTX_free(local_a0);
                }
              }
              if (local_58 == (void *)0x0) {
                local_ac = 0xfffffffb;
                goto LAB_0012581b;
              }
              (**(code **)(*(long *)(param_1 + 0x1a8) + 0x10))
                        (param_1,local_58,&local_b0,param_1 + 0x1b8);
              if (local_b0 != 0) {
                _libssh2_explicit_zero(local_58,(long)*(int *)(*(long *)(param_1 + 0x1a8) + 0xc));
                (**(code **)(param_1 + 0x18))(local_58,param_1);
              }
            }
            if (*(long *)(*(long *)(param_1 + 0x138) + 0x20) != 0) {
              (**(code **)(*(long *)(param_1 + 0x138) + 0x20))(param_1,param_1 + 0x148);
            }
            if (*(long *)(*(long *)(param_1 + 0x138) + 0x10) != 0) {
              local_48 = (void *)0x0;
              local_b0 = 0;
              local_40 = 0;
              if (true) {
                local_48 = (void *)(**(code **)(param_1 + 8))
                                             ((long)(*(int *)(*(long *)(param_1 + 0x138) + 0xc) +
                                                    0x20),param_1);
              }
              if (local_48 != (void *)0x0) {
                for (; local_40 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc);
                    local_40 = local_40 + 0x20) {
                  _libssh2_sha256_init(&local_a0);
                  EVP_DigestUpdate(local_a0,*(void **)(param_6 + 0x2e),*(size_t *)(param_6 + 0x34));
                  EVP_DigestUpdate(local_a0,param_6 + 8,0x20);
                  if (local_40 == 0) {
                    EVP_DigestUpdate(local_a0,&DAT_00146573,1);
                    EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_a0,local_48,local_40);
                  }
                  EVP_DigestFinal(local_a0,(uchar *)((long)local_48 + local_40),(uint *)0x0);
                  EVP_MD_CTX_free(local_a0);
                }
              }
              if (local_48 == (void *)0x0) {
                local_ac = 0xfffffffb;
                goto LAB_0012581b;
              }
              (**(code **)(*(long *)(param_1 + 0x138) + 0x10))
                        (param_1,local_48,&local_b0,param_1 + 0x148);
              if (local_b0 != 0) {
                _libssh2_explicit_zero(local_48,(long)*(int *)(*(long *)(param_1 + 0x138) + 0xc));
                (**(code **)(param_1 + 0x18))(local_48,param_1);
              }
            }
            if ((*(long *)(param_1 + 0x1c0) != 0) &&
               (*(long *)(*(long *)(param_1 + 0x1c0) + 0x28) != 0)) {
              (**(code **)(*(long *)(param_1 + 0x1c0) + 0x28))(param_1,1,param_1 + 0x1c8);
            }
            if (((*(long *)(param_1 + 0x1c0) == 0) ||
                (*(long *)(*(long *)(param_1 + 0x1c0) + 0x10) == 0)) ||
               (iVar3 = (**(code **)(*(long *)(param_1 + 0x1c0) + 0x10))(param_1,1,param_1 + 0x1c8),
               iVar3 == 0)) {
              if ((*(long *)(param_1 + 0x150) != 0) &&
                 (*(long *)(*(long *)(param_1 + 0x150) + 0x28) != 0)) {
                (**(code **)(*(long *)(param_1 + 0x150) + 0x28))(param_1,0,param_1 + 0x158);
              }
              if (((*(long *)(param_1 + 0x150) != 0) &&
                  (*(long *)(*(long *)(param_1 + 0x150) + 0x10) != 0)) &&
                 (iVar3 = (**(code **)(*(long *)(param_1 + 0x150) + 0x10))
                                    (param_1,0,param_1 + 0x158), iVar3 != 0)) {
                local_ac = 0xfffffffb;
              }
            }
            else {
              local_ac = 0xfffffffb;
            }
          }
          else {
            local_78 = (void *)0x0;
            local_70 = (void *)0x0;
            local_b4 = 0;
            local_b0 = 0;
            local_68 = 0;
            if (true) {
              local_78 = (void *)(**(code **)(param_1 + 8))
                                           ((long)(*(int *)(*(long *)(param_1 + 0x128) + 0x14) +
                                                  0x20),param_1);
            }
            if (local_78 != (void *)0x0) {
              for (; local_68 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14);
                  local_68 = local_68 + 0x20) {
                _libssh2_sha256_init(&local_a0);
                EVP_DigestUpdate(local_a0,*(void **)(param_6 + 0x2e),*(size_t *)(param_6 + 0x34));
                EVP_DigestUpdate(local_a0,param_6 + 8,0x20);
                if (local_68 == 0) {
                  EVP_DigestUpdate(local_a0,&DAT_0014656d,1);
                  EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0x88),
                                   (ulong)*(uint *)(param_1 + 0x90));
                }
                else {
                  EVP_DigestUpdate(local_a0,local_78,local_68);
                }
                EVP_DigestFinal(local_a0,(uchar *)((long)local_78 + local_68),(uint *)0x0);
                EVP_MD_CTX_free(local_a0);
              }
            }
            if (local_78 == (void *)0x0) {
              local_ac = 0xfffffffb;
            }
            else {
              local_60 = 0;
              if (local_70 == (void *)0x0) {
                local_70 = (void *)(**(code **)(param_1 + 8))
                                             ((long)(*(int *)(*(long *)(param_1 + 0x128) + 0x18) +
                                                    0x20),param_1);
              }
              if (local_70 != (void *)0x0) {
                for (; local_60 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18);
                    local_60 = local_60 + 0x20) {
                  _libssh2_sha256_init(&local_a0);
                  EVP_DigestUpdate(local_a0,*(void **)(param_6 + 0x2e),*(size_t *)(param_6 + 0x34));
                  EVP_DigestUpdate(local_a0,param_6 + 8,0x20);
                  if (local_60 == 0) {
                    EVP_DigestUpdate(local_a0,&DAT_0014656f,1);
                    EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0x88),
                                     (ulong)*(uint *)(param_1 + 0x90));
                  }
                  else {
                    EVP_DigestUpdate(local_a0,local_70,local_60);
                  }
                  EVP_DigestFinal(local_a0,(uchar *)((long)local_70 + local_60),(uint *)0x0);
                  EVP_MD_CTX_free(local_a0);
                }
              }
              if (local_70 == (void *)0x0) {
                (**(code **)(param_1 + 0x18))(local_78,param_1);
                local_ac = 0xfffffffb;
              }
              else {
                iVar3 = (**(code **)(*(long *)(param_1 + 0x128) + 0x28))
                                  (param_1,*(undefined8 *)(param_1 + 0x128),local_78,&local_b4,
                                   local_70,&local_b0,0,param_1 + 0x130);
                if (iVar3 == 0) {
                  if (local_b4 != 0) {
                    _libssh2_explicit_zero
                              (local_78,(long)*(int *)(*(long *)(param_1 + 0x128) + 0x14));
                    (**(code **)(param_1 + 0x18))(local_78,param_1);
                  }
                  if (local_b0 != 0) {
                    _libssh2_explicit_zero
                              (local_70,(long)*(int *)(*(long *)(param_1 + 0x128) + 0x18));
                    (**(code **)(param_1 + 0x18))(local_70,param_1);
                  }
                  goto LAB_0012518d;
                }
                (**(code **)(param_1 + 0x18))(local_78,param_1);
                (**(code **)(param_1 + 0x18))(local_70,param_1);
                local_ac = 0xfffffffb;
              }
            }
          }
        }
        else {
          local_98 = (void *)0x0;
          local_90 = (void *)0x0;
          local_b4 = 0;
          local_b0 = 0;
          local_88 = 0;
          if (true) {
            local_98 = (void *)(**(code **)(param_1 + 8))
                                         ((long)(*(int *)(*(long *)(param_1 + 0x198) + 0x14) + 0x20)
                                          ,param_1);
          }
          if (local_98 != (void *)0x0) {
            for (; local_88 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14);
                local_88 = local_88 + 0x20) {
              _libssh2_sha256_init(&local_a0);
              EVP_DigestUpdate(local_a0,*(void **)(param_6 + 0x2e),*(size_t *)(param_6 + 0x34));
              EVP_DigestUpdate(local_a0,param_6 + 8,0x20);
              if (local_88 == 0) {
                EVP_DigestUpdate(local_a0,&DAT_00146569,1);
                EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0x88),
                                 (ulong)*(uint *)(param_1 + 0x90));
              }
              else {
                EVP_DigestUpdate(local_a0,local_98,local_88);
              }
              EVP_DigestFinal(local_a0,(uchar *)((long)local_98 + local_88),(uint *)0x0);
              EVP_MD_CTX_free(local_a0);
            }
          }
          if (local_98 == (void *)0x0) {
            local_ac = 0xffffffff;
          }
          else {
            local_80 = 0;
            if (local_90 == (void *)0x0) {
              local_90 = (void *)(**(code **)(param_1 + 8))
                                           ((long)(*(int *)(*(long *)(param_1 + 0x198) + 0x18) +
                                                  0x20),param_1);
            }
            if (local_90 != (void *)0x0) {
              for (; local_80 < (ulong)(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18);
                  local_80 = local_80 + 0x20) {
                _libssh2_sha256_init(&local_a0);
                EVP_DigestUpdate(local_a0,*(void **)(param_6 + 0x2e),*(size_t *)(param_6 + 0x34));
                EVP_DigestUpdate(local_a0,param_6 + 8,0x20);
                if (local_80 == 0) {
                  EVP_DigestUpdate(local_a0,&DAT_0014656b,1);
                  EVP_DigestUpdate(local_a0,*(void **)(param_1 + 0x88),
                                   (ulong)*(uint *)(param_1 + 0x90));
                }
                else {
                  EVP_DigestUpdate(local_a0,local_90,local_80);
                }
                EVP_DigestFinal(local_a0,(uchar *)((long)local_90 + local_80),(uint *)0x0);
                EVP_MD_CTX_free(local_a0);
              }
            }
            if (local_90 == (void *)0x0) {
              (**(code **)(param_1 + 0x18))(local_98,param_1);
              local_ac = 0xfffffffb;
            }
            else {
              iVar3 = (**(code **)(*(long *)(param_1 + 0x198) + 0x28))
                                (param_1,*(undefined8 *)(param_1 + 0x198),local_98,&local_b4,
                                 local_90,&local_b0,1,param_1 + 0x1a0);
              if (iVar3 == 0) {
                if (local_b4 != 0) {
                  _libssh2_explicit_zero(local_98,(long)*(int *)(*(long *)(param_1 + 0x198) + 0x14))
                  ;
                  (**(code **)(param_1 + 0x18))(local_98,param_1);
                }
                if (local_b0 != 0) {
                  _libssh2_explicit_zero(local_90,(long)*(int *)(*(long *)(param_1 + 0x198) + 0x18))
                  ;
                  (**(code **)(param_1 + 0x18))(local_90,param_1);
                }
                goto LAB_00124c9b;
              }
              (**(code **)(param_1 + 0x18))(local_98,param_1);
              (**(code **)(param_1 + 0x18))(local_90,param_1);
              local_ac = 0xfffffffb;
            }
          }
        }
      }
      else {
        local_ac = _libssh2_error(param_1,local_a8,"Timed out waiting for NEWKEYS");
      }
    }
  }
LAB_0012581b:
  BN_clear_free(*(BIGNUM **)(param_6 + 0x28));
  param_6[0x28] = 0;
  param_6[0x29] = 0;
  if (*(long *)(param_6 + 0x2e) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_6 + 0x2e),param_1);
    param_6[0x2e] = 0;
    param_6[0x2f] = 0;
  }
  *param_6 = 0;
  uVar6 = (ulong)local_ac;
LAB_001258a3:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int kex_method_curve25519_key_exchange(long param_1,int *param_2)

{
  int iVar1;
  long in_FS_OFFSET;
  int local_20;
  int local_1c;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = 0;
  if (*param_2 == 0) {
    param_2[0x92] = 0;
    param_2[0x93] = 0;
    *param_2 = 2;
  }
  if (*param_2 == 2) {
    local_18 = 0;
    local_1c = strcmp((char *)**(undefined8 **)(param_1 + 0x78),"curve25519-sha256@libssh.org");
    if (local_1c != 0) {
      local_1c = strcmp((char *)**(undefined8 **)(param_1 + 0x78),"curve25519-sha256");
    }
    if (local_1c == 0) {
      iVar1 = _libssh2_curve25519_new(param_1,0,param_2 + 0x96,param_2 + 0x98);
      if (iVar1 == 0) {
        *(undefined *)(param_2 + 0x4a) = 0x1e;
        local_18 = (long)param_2 + 0x129;
        _libssh2_store_str(&local_18,*(undefined8 *)(param_2 + 0x96),0x20);
        param_2[0x8c] = 0x25;
        param_2[0x8d] = 0;
        *param_2 = 3;
        goto LAB_00125a2f;
      }
      local_20 = _libssh2_error(param_1,iVar1,"Unable to create private key");
    }
    else {
      local_20 = _libssh2_error(param_1,0xffffffff,"Unknown KEX curve25519 curve type");
    }
  }
  else {
LAB_00125a2f:
    if (*param_2 == 3) {
      iVar1 = _libssh2_transport_send(param_1,param_2 + 0x4a,*(undefined8 *)(param_2 + 0x8c),0,0);
      if (iVar1 == -0x25) {
        local_20 = -0x25;
        goto LAB_00125c77;
      }
      if (iVar1 != 0) {
        local_20 = _libssh2_error(param_1,iVar1,"Unable to send ECDH_INIT");
        goto LAB_00125bbe;
      }
      *param_2 = 4;
    }
    if (*param_2 == 4) {
      iVar1 = _libssh2_packet_require(param_1,0x1f,param_2 + 0x8a,param_2 + 0x8e,0,0,0,param_2 + 2);
      if (iVar1 == -0x25) {
        local_20 = -0x25;
        goto LAB_00125c77;
      }
      if (iVar1 != 0) {
        local_20 = _libssh2_error(param_1,iVar1,"Timeout waiting for ECDH_REPLY reply");
        goto LAB_00125bbe;
      }
      *param_2 = 5;
    }
    if (*param_2 == 5) {
      local_20 = curve25519_sha256(param_1,*(undefined8 *)(param_2 + 0x8a),
                                   *(undefined8 *)(param_2 + 0x8e),*(undefined8 *)(param_2 + 0x96),
                                   *(undefined8 *)(param_2 + 0x98),param_2 + 6);
      if (local_20 == -0x25) goto LAB_00125c77;
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_2 + 0x8a),param_1);
    }
  }
LAB_00125bbe:
  if (*(long *)(param_2 + 0x96) != 0) {
    _libssh2_explicit_zero(*(undefined8 *)(param_2 + 0x96),0x20);
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_2 + 0x96),param_1);
    param_2[0x96] = 0;
    param_2[0x97] = 0;
  }
  if (*(long *)(param_2 + 0x98) != 0) {
    _libssh2_explicit_zero(*(undefined8 *)(param_2 + 0x98),0x20);
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_2 + 0x98),param_1);
    param_2[0x98] = 0;
    param_2[0x99] = 0;
  }
  *param_2 = 0;
LAB_00125c77:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_20;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



long kex_method_strlen(long *param_1)

{
  size_t sVar1;
  long *local_20;
  long local_10;
  
  local_10 = 0;
  if ((param_1 == (long *)0x0) || (local_20 = param_1, *param_1 == 0)) {
    local_10 = 0;
  }
  else {
    for (; (*local_20 != 0 && (*(long *)*local_20 != 0)); local_20 = local_20 + 1) {
      sVar1 = strlen(*(char **)*local_20);
      local_10 = sVar1 + local_10 + 1;
    }
    local_10 = local_10 + -1;
  }
  return local_10;
}



long kex_method_list(long param_1,ulong param_2,long *param_3)

{
  undefined *puVar1;
  long lVar2;
  size_t sVar3;
  long *local_30;
  undefined *local_20;
  
  _libssh2_htonu32(param_1,param_2 & 0xffffffff);
  local_20 = (undefined *)(param_1 + 4);
  if ((param_3 == (long *)0x0) || (local_30 = param_3, *param_3 == 0)) {
    lVar2 = 4;
  }
  else {
    for (; (*local_30 != 0 && (*(long *)*local_30 != 0)); local_30 = local_30 + 1) {
      sVar3 = strlen(*(char **)*local_30);
      memcpy(local_20,*(void **)*local_30,(long)(int)sVar3);
      puVar1 = local_20 + (int)sVar3;
      local_20 = puVar1 + 1;
      *puVar1 = 0x2c;
    }
    lVar2 = param_2 + 4;
  }
  return lVar2;
}



undefined8 kexinit(long param_1)

{
  int iVar1;
  ulong __n;
  ulong __n_00;
  ulong __n_01;
  ulong __n_02;
  ulong __n_03;
  ulong __n_04;
  ulong __n_05;
  ulong __n_06;
  ulong __n_07;
  ulong __n_08;
  undefined8 uVar2;
  long lVar3;
  long local_70;
  undefined *local_68;
  undefined *local_60;
  
  if (*(int *)(param_1 + 0xcc70) == 0) {
    if (*(long *)(param_1 + 0x58) == 0) {
      __n = kex_method_strlen(&libssh2_kex_methods);
    }
    else {
      __n = strlen(*(char **)(param_1 + 0x58));
    }
    if (*(long *)(param_1 + 0x60) == 0) {
      uVar2 = libssh2_hostkey_methods();
      __n_00 = kex_method_strlen(uVar2);
    }
    else {
      __n_00 = strlen(*(char **)(param_1 + 0x60));
    }
    if (*(long *)(param_1 + 0x1d0) == 0) {
      uVar2 = libssh2_crypt_methods();
      __n_01 = kex_method_strlen(uVar2);
    }
    else {
      __n_01 = strlen(*(char **)(param_1 + 0x1d0));
    }
    if (*(long *)(param_1 + 0x160) == 0) {
      uVar2 = libssh2_crypt_methods();
      __n_02 = kex_method_strlen(uVar2);
    }
    else {
      __n_02 = strlen(*(char **)(param_1 + 0x160));
    }
    if (*(long *)(param_1 + 0x1d8) == 0) {
      uVar2 = _libssh2_mac_methods();
      __n_03 = kex_method_strlen(uVar2);
    }
    else {
      __n_03 = strlen(*(char **)(param_1 + 0x1d8));
    }
    if (*(long *)(param_1 + 0x168) == 0) {
      uVar2 = _libssh2_mac_methods();
      __n_04 = kex_method_strlen(uVar2);
    }
    else {
      __n_04 = strlen(*(char **)(param_1 + 0x168));
    }
    if (*(long *)(param_1 + 0x1e0) == 0) {
      uVar2 = _libssh2_comp_methods(param_1);
      __n_05 = kex_method_strlen(uVar2);
    }
    else {
      __n_05 = strlen(*(char **)(param_1 + 0x1e0));
    }
    if (*(long *)(param_1 + 0x170) == 0) {
      uVar2 = _libssh2_comp_methods(param_1);
      __n_06 = kex_method_strlen(uVar2);
    }
    else {
      __n_06 = strlen(*(char **)(param_1 + 0x170));
    }
    if (*(long *)(param_1 + 0x1e8) == 0) {
      __n_07 = kex_method_strlen(0);
    }
    else {
      __n_07 = strlen(*(char **)(param_1 + 0x1e8));
    }
    if (*(long *)(param_1 + 0x178) == 0) {
      __n_08 = kex_method_strlen(0);
    }
    else {
      __n_08 = strlen(*(char **)(param_1 + 0x178));
    }
    local_70 = __n_08 + __n + __n_00 + __n_01 + __n_02 + __n_05 + __n_06 + __n_03 + __n_04 + __n_07
               + 0x3e;
    local_68 = (undefined *)(**(code **)(param_1 + 8))(local_70,param_1);
    if (local_68 == (undefined *)0x0) {
      uVar2 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory");
      return uVar2;
    }
    *local_68 = 0x14;
    RAND_bytes(local_68 + 1,0x10);
    local_60 = local_68 + 0x11;
    if (*(long *)(param_1 + 0x58) == 0) {
      lVar3 = kex_method_list(local_60,__n,&libssh2_kex_methods);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n & 0xffffffff);
      memcpy(local_68 + 0x15,*(void **)(param_1 + 0x58),__n);
      local_60 = local_68 + 0x15 + __n;
    }
    if (*(long *)(param_1 + 0x60) == 0) {
      uVar2 = libssh2_hostkey_methods();
      lVar3 = kex_method_list(local_60,__n_00,uVar2);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_00 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x60),__n_00);
      local_60 = local_60 + 4 + __n_00;
    }
    if (*(long *)(param_1 + 0x1d0) == 0) {
      uVar2 = libssh2_crypt_methods();
      lVar3 = kex_method_list(local_60,__n_01,uVar2);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_01 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x1d0),__n_01);
      local_60 = local_60 + 4 + __n_01;
    }
    if (*(long *)(param_1 + 0x160) == 0) {
      uVar2 = libssh2_crypt_methods();
      lVar3 = kex_method_list(local_60,__n_02,uVar2);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_02 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x160),__n_02);
      local_60 = local_60 + 4 + __n_02;
    }
    if (*(long *)(param_1 + 0x1d8) == 0) {
      uVar2 = _libssh2_mac_methods();
      lVar3 = kex_method_list(local_60,__n_03,uVar2);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_03 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x1d8),__n_03);
      local_60 = local_60 + 4 + __n_03;
    }
    if (*(long *)(param_1 + 0x168) == 0) {
      uVar2 = _libssh2_mac_methods();
      lVar3 = kex_method_list(local_60,__n_04,uVar2);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_04 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x168),__n_04);
      local_60 = local_60 + 4 + __n_04;
    }
    if (*(long *)(param_1 + 0x1e0) == 0) {
      uVar2 = _libssh2_comp_methods(param_1);
      lVar3 = kex_method_list(local_60,__n_05,uVar2);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_05 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x1e0),__n_05);
      local_60 = local_60 + 4 + __n_05;
    }
    if (*(long *)(param_1 + 0x170) == 0) {
      uVar2 = _libssh2_comp_methods(param_1);
      lVar3 = kex_method_list(local_60,__n_06,uVar2);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_06 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x170),__n_06);
      local_60 = local_60 + 4 + __n_06;
    }
    if (*(long *)(param_1 + 0x1e8) == 0) {
      lVar3 = kex_method_list(local_60,__n_07,0);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_07 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x1e8),__n_07);
      local_60 = local_60 + 4 + __n_07;
    }
    if (*(long *)(param_1 + 0x178) == 0) {
      lVar3 = kex_method_list(local_60,__n_08,0);
      local_60 = local_60 + lVar3;
    }
    else {
      _libssh2_htonu32(local_60,__n_08 & 0xffffffff);
      memcpy(local_60 + 4,*(void **)(param_1 + 0x178),__n_08);
      local_60 = local_60 + 4 + __n_08;
    }
    *local_60 = 0;
    _libssh2_htonu32(local_60 + 1,0);
    *(undefined4 *)(param_1 + 0xcc70) = 2;
  }
  else {
    local_68 = *(undefined **)(param_1 + 0xcc78);
    local_70 = *(long *)(param_1 + 0xcc80);
    *(undefined8 *)(param_1 + 0xcc78) = 0;
    *(undefined8 *)(param_1 + 0xcc80) = 0;
  }
  iVar1 = _libssh2_transport_send(param_1,local_68,local_70,0,0);
  if (iVar1 == -0x25) {
    *(undefined **)(param_1 + 0xcc78) = local_68;
    *(long *)(param_1 + 0xcc80) = local_70;
    uVar2 = 0xffffffdb;
  }
  else if (iVar1 == 0) {
    if (*(long *)(param_1 + 0x188) != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x188),param_1);
    }
    *(undefined **)(param_1 + 0x188) = local_68;
    *(long *)(param_1 + 400) = local_70;
    *(undefined4 *)(param_1 + 0xcc70) = 0;
    uVar2 = 0;
  }
  else {
    (**(code **)(param_1 + 0x18))(local_68,param_1);
    *(undefined4 *)(param_1 + 0xcc70) = 0;
    uVar2 = _libssh2_error(param_1,iVar1,"Unable to send KEXINIT packet to remote host");
  }
  return uVar2;
}



char * kex_agree_instr(char *param_1,char *param_2,char *param_3,char *param_4)

{
  int iVar1;
  char *local_10;
  
  if (param_2 < param_4) {
    param_1 = (char *)0x0;
  }
  else {
    iVar1 = strncmp(param_1,param_3,(size_t)param_4);
    local_10 = param_1;
    if ((iVar1 != 0) || ((param_4 != param_2 && (param_1[(long)param_4] != ',')))) {
      while ((local_10 = strchr(local_10,0x2c), local_10 != (char *)0x0 &&
             (param_4 < param_2 + -((long)local_10 - (long)param_1)))) {
        local_10 = local_10 + 1;
        iVar1 = strncmp(local_10,param_3,(size_t)param_4);
        if (iVar1 == 0) {
          if (param_2 == local_10 + ((long)param_4 - (long)param_1)) {
            return local_10;
          }
          if (local_10[(long)param_4] == ',') {
            return local_10;
          }
        }
      }
      param_1 = (char *)0x0;
    }
  }
  return param_1;
}



long kex_get_method_by_name(char *param_1,size_t param_2,long *param_3)

{
  int iVar1;
  size_t sVar2;
  long *local_20;
  
  local_20 = param_3;
  while( true ) {
    if (*local_20 == 0) {
      return 0;
    }
    sVar2 = strlen(*(char **)*local_20);
    if ((param_2 == sVar2) && (iVar1 = strncmp(*(char **)*local_20,param_1,param_2), iVar1 == 0))
    break;
    local_20 = local_20 + 1;
  }
  return *local_20;
}



undefined8 kex_agree_hostkey(long param_1,ulong param_2,undefined8 param_3,undefined8 param_4)

{
  char *pcVar1;
  size_t sVar2;
  long lVar3;
  long *local_30;
  char *local_28;
  
  local_30 = (long *)libssh2_hostkey_methods();
  if (*(long *)(param_1 + 0x60) == 0) {
    for (; ((local_30 != (long *)0x0 && (*local_30 != 0)) && (*(long *)*local_30 != 0));
        local_30 = local_30 + 1) {
      sVar2 = strlen(*(char **)*local_30);
      lVar3 = kex_agree_instr(param_3,param_4,*(undefined8 *)*local_30,sVar2);
      if (((lVar3 != 0) && (((param_2 & 1) == 0 || (*(long *)(*local_30 + 0x38) != 0)))) &&
         (((param_2 & 2) == 0 || (*(long *)(*local_30 + 0x28) != 0)))) {
        *(long *)(param_1 + 0xa0) = *local_30;
        return 0;
      }
    }
  }
  else {
    local_28 = *(char **)(param_1 + 0x60);
    while ((local_28 != (char *)0x0 && (*local_28 != '\0'))) {
      pcVar1 = strchr(local_28,0x2c);
      if (pcVar1 == (char *)0x0) {
        sVar2 = strlen(local_28);
      }
      else {
        sVar2 = (long)pcVar1 - (long)local_28;
      }
      lVar3 = kex_agree_instr(param_3,param_4,local_28,sVar2);
      if (lVar3 != 0) {
        lVar3 = kex_get_method_by_name(local_28,sVar2,local_30);
        if (lVar3 == 0) {
          return 0xffffffff;
        }
        if ((((param_2 & 1) == 0) || (*(long *)(lVar3 + 0x38) != 0)) &&
           (((param_2 & 2) == 0 || (*(long *)(lVar3 + 0x28) != 0)))) {
          *(long *)(param_1 + 0xa0) = lVar3;
          return 0;
        }
      }
      if (pcVar1 == (char *)0x0) {
        local_28 = (char *)0x0;
      }
      else {
        local_28 = pcVar1 + 1;
      }
    }
  }
  return 0xffffffff;
}



undefined8
kex_agree_kex_hostkey
          (long param_1,long param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5)

{
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  long lVar4;
  long lVar5;
  undefined **local_38;
  char *local_30;
  
  local_38 = &libssh2_kex_methods;
  if (*(long *)(param_1 + 0x58) == 0) {
    for (; (*local_38 != (undefined *)0x0 && (*(long *)*local_38 != 0)); local_38 = local_38 + 1) {
      sVar3 = strlen(*(char **)*local_38);
      lVar4 = kex_agree_instr(param_2,param_3,*(undefined8 *)*local_38,sVar3);
      if ((lVar4 != 0) &&
         (iVar1 = kex_agree_hostkey(param_1,*(undefined8 *)(*local_38 + 0x10),param_4,param_5),
         iVar1 == 0)) {
        *(undefined **)(param_1 + 0x78) = *local_38;
        if (((*(byte *)(param_1 + 0x80) & 1) != 0) && (param_2 == lVar4)) {
          *(byte *)(param_1 + 0x80) = *(byte *)(param_1 + 0x80) & 0xfe;
        }
        return 0;
      }
    }
  }
  else {
    local_30 = *(char **)(param_1 + 0x58);
    while ((local_30 != (char *)0x0 && (*local_30 != '\0'))) {
      pcVar2 = strchr(local_30,0x2c);
      if (pcVar2 == (char *)0x0) {
        sVar3 = strlen(local_30);
      }
      else {
        sVar3 = (long)pcVar2 - (long)local_30;
      }
      lVar4 = kex_agree_instr(param_2,param_3,local_30,sVar3);
      if (lVar4 != 0) {
        lVar5 = kex_get_method_by_name(local_30,sVar3,&libssh2_kex_methods);
        if (lVar5 == 0) {
          return 0xffffffff;
        }
        iVar1 = kex_agree_hostkey(param_1,*(undefined8 *)(lVar5 + 0x10),param_4,param_5);
        if (iVar1 == 0) {
          *(long *)(param_1 + 0x78) = lVar5;
          if (((*(byte *)(param_1 + 0x80) & 1) != 0) && (param_2 == lVar4)) {
            *(byte *)(param_1 + 0x80) = *(byte *)(param_1 + 0x80) & 0xfe;
          }
          return 0;
        }
      }
      if (pcVar2 == (char *)0x0) {
        local_30 = (char *)0x0;
      }
      else {
        local_30 = pcVar2 + 1;
      }
    }
  }
  return 0xffffffff;
}



undefined8 kex_agree_crypt(undefined8 param_1,long param_2,undefined8 param_3,undefined8 param_4)

{
  char *pcVar1;
  size_t sVar2;
  long lVar3;
  long *local_30;
  char *local_28;
  
  local_30 = (long *)libssh2_crypt_methods();
  if (*(long *)(param_2 + 0x50) == 0) {
    for (; (*local_30 != 0 && (*(long *)*local_30 != 0)); local_30 = local_30 + 1) {
      sVar2 = strlen(*(char **)*local_30);
      lVar3 = kex_agree_instr(param_3,param_4,*(undefined8 *)*local_30,sVar2);
      if (lVar3 != 0) {
        *(long *)(param_2 + 0x18) = *local_30;
        return 0;
      }
    }
  }
  else {
    local_28 = *(char **)(param_2 + 0x50);
    while ((local_28 != (char *)0x0 && (*local_28 != '\0'))) {
      pcVar1 = strchr(local_28,0x2c);
      if (pcVar1 == (char *)0x0) {
        sVar2 = strlen(local_28);
      }
      else {
        sVar2 = (long)pcVar1 - (long)local_28;
      }
      lVar3 = kex_agree_instr(param_3,param_4,local_28,sVar2);
      if (lVar3 != 0) {
        lVar3 = kex_get_method_by_name(local_28,sVar2,local_30);
        if (lVar3 != 0) {
          *(long *)(param_2 + 0x18) = lVar3;
          return 0;
        }
        return 0xffffffff;
      }
      if (pcVar1 == (char *)0x0) {
        local_28 = (char *)0x0;
      }
      else {
        local_28 = pcVar1 + 1;
      }
    }
  }
  return 0xffffffff;
}



undefined8 kex_agree_mac(undefined8 param_1,long param_2,undefined8 param_3,undefined8 param_4)

{
  char *pcVar1;
  size_t sVar2;
  long lVar3;
  long *local_30;
  char *local_28;
  
  local_30 = (long *)_libssh2_mac_methods();
  if (*(long *)(param_2 + 0x58) == 0) {
    for (; (*local_30 != 0 && (*(long *)*local_30 != 0)); local_30 = local_30 + 1) {
      sVar2 = strlen(*(char **)*local_30);
      lVar3 = kex_agree_instr(param_3,param_4,*(undefined8 *)*local_30,sVar2);
      if (lVar3 != 0) {
        *(long *)(param_2 + 0x28) = *local_30;
        return 0;
      }
    }
  }
  else {
    local_28 = *(char **)(param_2 + 0x58);
    while ((local_28 != (char *)0x0 && (*local_28 != '\0'))) {
      pcVar1 = strchr(local_28,0x2c);
      if (pcVar1 == (char *)0x0) {
        sVar2 = strlen(local_28);
      }
      else {
        sVar2 = (long)pcVar1 - (long)local_28;
      }
      lVar3 = kex_agree_instr(param_3,param_4,local_28,sVar2);
      if (lVar3 != 0) {
        lVar3 = kex_get_method_by_name(local_28,sVar2,local_30);
        if (lVar3 != 0) {
          *(long *)(param_2 + 0x28) = lVar3;
          return 0;
        }
        return 0xffffffff;
      }
      if (pcVar1 == (char *)0x0) {
        local_28 = (char *)0x0;
      }
      else {
        local_28 = pcVar1 + 1;
      }
    }
  }
  return 0xffffffff;
}



undefined8 kex_agree_comp(undefined8 param_1,long param_2,undefined8 param_3,undefined8 param_4)

{
  char *pcVar1;
  size_t sVar2;
  long lVar3;
  long *local_30;
  char *local_28;
  
  local_30 = (long *)_libssh2_comp_methods(param_1);
  if (*(long *)(param_2 + 0x60) == 0) {
    for (; (*local_30 != 0 && (*(long *)*local_30 != 0)); local_30 = local_30 + 1) {
      sVar2 = strlen(*(char **)*local_30);
      lVar3 = kex_agree_instr(param_3,param_4,*(undefined8 *)*local_30,sVar2);
      if (lVar3 != 0) {
        *(long *)(param_2 + 0x40) = *local_30;
        return 0;
      }
    }
  }
  else {
    local_28 = *(char **)(param_2 + 0x60);
    while ((local_28 != (char *)0x0 && (*local_28 != '\0'))) {
      pcVar1 = strchr(local_28,0x2c);
      if (pcVar1 == (char *)0x0) {
        sVar2 = strlen(local_28);
      }
      else {
        sVar2 = (long)pcVar1 - (long)local_28;
      }
      lVar3 = kex_agree_instr(param_3,param_4,local_28,sVar2);
      if (lVar3 != 0) {
        lVar3 = kex_get_method_by_name(local_28,sVar2,local_30);
        if (lVar3 != 0) {
          *(long *)(param_2 + 0x40) = lVar3;
          return 0;
        }
        return 0xffffffff;
      }
      if (pcVar1 == (char *)0x0) {
        local_28 = (char *)0x0;
      }
      else {
        local_28 = pcVar1 + 1;
      }
    }
  }
  return 0xffffffff;
}



bool kex_string_pair(long *param_1,long param_2,long param_3,ulong *param_4,long *param_5)

{
  long lVar1;
  bool bVar2;
  uint uVar3;
  
  lVar1 = *param_1;
  uVar3 = _libssh2_ntohu32(lVar1);
  *param_4 = (ulong)uVar3;
  bVar2 = *param_4 <= (param_3 - (lVar1 - param_2)) - 4U;
  if (bVar2) {
    *param_5 = lVar1 + 4;
    *param_1 = lVar1 + *param_4 + 4;
  }
  return !bVar2;
}



undefined8 kex_agree_methods(long param_1,long param_2,uint param_3)

{
  byte *pbVar1;
  int iVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_80;
  undefined8 local_78;
  undefined8 local_70;
  undefined8 local_68;
  undefined8 local_60;
  undefined8 local_58;
  undefined8 local_50;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  byte *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = (byte *)(param_2 + 0x11);
  iVar2 = kex_string_pair(&local_18,param_2,param_3,&local_58,&local_98);
  if (iVar2 == 0) {
    iVar2 = kex_string_pair(&local_18,param_2,param_3,&local_50,&local_90);
    if (iVar2 == 0) {
      iVar2 = kex_string_pair(&local_18,param_2,param_3,&local_48,&local_88);
      if (iVar2 == 0) {
        iVar2 = kex_string_pair(&local_18,param_2,param_3,&local_40,&local_80);
        if (iVar2 == 0) {
          iVar2 = kex_string_pair(&local_18,param_2,param_3,&local_28,&local_68);
          if (iVar2 == 0) {
            iVar2 = kex_string_pair(&local_18,param_2,param_3,&local_20,&local_60);
            if (iVar2 == 0) {
              iVar2 = kex_string_pair(&local_18,param_2,param_3,&local_38,&local_78);
              if (iVar2 == 0) {
                iVar2 = kex_string_pair(&local_18,param_2,param_3,&local_30,&local_70);
                if (iVar2 == 0) {
                  pbVar1 = local_18 + 1;
                  *(byte *)(param_1 + 0x80) = *(byte *)(param_1 + 0x80) & 0xfe | *local_18 & 1;
                  local_18 = pbVar1;
                  if (param_3 < (uint)((int)pbVar1 - (int)param_2)) {
                    uVar3 = 0xffffffff;
                  }
                  else {
                    iVar2 = kex_agree_kex_hostkey(param_1,local_98,local_58,local_90,local_50);
                    if (iVar2 == 0) {
                      iVar2 = kex_agree_crypt(param_1,param_1 + 0x180,local_88,local_48);
                      if (iVar2 == 0) {
                        iVar2 = kex_agree_crypt(param_1,param_1 + 0x110,local_80,local_40);
                        if (iVar2 == 0) {
                          iVar2 = kex_agree_mac(param_1,param_1 + 0x180,local_68,local_28);
                          if (iVar2 == 0) {
                            iVar2 = kex_agree_mac(param_1,param_1 + 0x110,local_60,local_20);
                            if (iVar2 == 0) {
                              iVar2 = kex_agree_comp(param_1,param_1 + 0x180,local_78,local_38);
                              if (iVar2 == 0) {
                                iVar2 = kex_agree_comp(param_1,param_1 + 0x110,local_70,local_30);
                                if (iVar2 == 0) {
                                  uVar3 = 0;
                                  goto LAB_00127515;
                                }
                              }
                              uVar3 = 0xffffffff;
                              goto LAB_00127515;
                            }
                          }
                          uVar3 = 0xffffffff;
                          goto LAB_00127515;
                        }
                      }
                      uVar3 = 0xffffffff;
                    }
                    else {
                      uVar3 = 0xffffffff;
                    }
                  }
                }
                else {
                  uVar3 = 0xffffffff;
                }
              }
              else {
                uVar3 = 0xffffffff;
              }
            }
            else {
              uVar3 = 0xffffffff;
            }
          }
          else {
            uVar3 = 0xffffffff;
          }
        }
        else {
          uVar3 = 0xffffffff;
        }
      }
      else {
        uVar3 = 0xffffffff;
      }
    }
    else {
      uVar3 = 0xffffffff;
    }
  }
  else {
    uVar3 = 0xffffffff;
  }
LAB_00127515:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



int _libssh2_kex_exchange(long param_1,int param_2,int *param_3)

{
  int iVar1;
  int local_10;
  
  local_10 = 0;
  *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 8;
  if (*param_3 == 0) {
    *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 1;
    if (param_2 != 0) {
      *(undefined8 *)(param_1 + 0x78) = 0;
      if ((*(long *)(param_1 + 0xa0) != 0) && (*(long *)(*(long *)(param_1 + 0xa0) + 0x40) != 0)) {
        (**(code **)(*(long *)(param_1 + 0xa0) + 0x40))(param_1,param_1 + 0xa8);
      }
      *(undefined8 *)(param_1 + 0xa0) = 0;
    }
    *param_3 = 2;
  }
  if ((*(long *)(param_1 + 0x78) == 0) || (*(long *)(param_1 + 0xa0) == 0)) {
    if (*param_3 == 2) {
      *(undefined8 *)(param_3 + 0xa4) = *(undefined8 *)(param_1 + 0x188);
      *(undefined8 *)(param_3 + 0xa6) = *(undefined8 *)(param_1 + 400);
      *(undefined8 *)(param_1 + 0x188) = 0;
      *param_3 = 3;
    }
    if (*param_3 == 3) {
      iVar1 = kexinit(param_1);
      if (iVar1 == -0x25) {
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffff7;
        return -0x25;
      }
      if (iVar1 != 0) {
        *(undefined8 *)(param_1 + 0x188) = *(undefined8 *)(param_3 + 0xa4);
        *(undefined8 *)(param_1 + 400) = *(undefined8 *)(param_3 + 0xa6);
        *param_3 = 0;
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffff7;
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffffe;
        return -1;
      }
      *param_3 = 4;
    }
    if (*param_3 == 4) {
      iVar1 = _libssh2_packet_require(param_1,0x14,param_3 + 0xa0,param_3 + 0xa2,0,0,0,param_3 + 2);
      if (iVar1 == -0x25) {
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffff7;
        return -0x25;
      }
      if (iVar1 != 0) {
        if (*(long *)(param_1 + 0x188) != 0) {
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x188),param_1);
        }
        *(undefined8 *)(param_1 + 0x188) = *(undefined8 *)(param_3 + 0xa4);
        *(undefined8 *)(param_1 + 400) = *(undefined8 *)(param_3 + 0xa6);
        *param_3 = 0;
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffff7;
        *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffffe;
        return -1;
      }
      if (*(long *)(param_1 + 0x118) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x118),param_1);
      }
      *(undefined8 *)(param_1 + 0x118) = *(undefined8 *)(param_3 + 0xa0);
      *(undefined8 *)(param_1 + 0x120) = *(undefined8 *)(param_3 + 0xa2);
      iVar1 = kex_agree_methods(param_1,*(undefined8 *)(param_3 + 0xa0),
                                *(ulong *)(param_3 + 0xa2) & 0xffffffff);
      if (iVar1 != 0) {
        local_10 = -5;
      }
      *param_3 = 5;
    }
  }
  else {
    *param_3 = 5;
  }
  if (((local_10 == 0) && (*(long *)(param_1 + 0x78) != 0)) && (*param_3 == 5)) {
    iVar1 = (**(code **)(*(long *)(param_1 + 0x78) + 8))(param_1,param_3 + 6);
    if (iVar1 == -0x25) {
      *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffff7;
      return -0x25;
    }
    if (iVar1 != 0) {
      local_10 = _libssh2_error(param_1,0xfffffff8,"Unrecoverable error exchanging keys");
    }
  }
  if (*(long *)(param_1 + 0x188) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x188),param_1);
    *(undefined8 *)(param_1 + 0x188) = 0;
  }
  if (*(long *)(param_1 + 0x118) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x118),param_1);
    *(undefined8 *)(param_1 + 0x118) = 0;
  }
  *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffff7;
  *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) & 0xfffffffe;
  *param_3 = 0;
  return local_10;
}



undefined8 libssh2_session_method_pref(long param_1,undefined4 param_2,char *param_3)

{
  int iVar1;
  size_t sVar2;
  undefined8 uVar3;
  char *__dest;
  char *pcVar4;
  long lVar5;
  long *local_30;
  char *local_28;
  undefined **local_20;
  
  sVar2 = strlen(param_3);
  switch(param_2) {
  case 0:
    local_30 = (long *)(param_1 + 0x58);
    local_20 = &libssh2_kex_methods;
    break;
  case 1:
    local_30 = (long *)(param_1 + 0x60);
    local_20 = (undefined **)libssh2_hostkey_methods();
    break;
  case 2:
    local_30 = (long *)(param_1 + 0x1d0);
    local_20 = (undefined **)libssh2_crypt_methods();
    break;
  case 3:
    local_30 = (long *)(param_1 + 0x160);
    local_20 = (undefined **)libssh2_crypt_methods();
    break;
  case 4:
    local_30 = (long *)(param_1 + 0x1d8);
    local_20 = (undefined **)_libssh2_mac_methods();
    break;
  case 5:
    local_30 = (long *)(param_1 + 0x168);
    local_20 = (undefined **)_libssh2_mac_methods();
    break;
  case 6:
    local_30 = (long *)(param_1 + 0x1e0);
    local_20 = (undefined **)_libssh2_comp_methods(param_1);
    break;
  case 7:
    local_30 = (long *)(param_1 + 0x170);
    local_20 = (undefined **)_libssh2_comp_methods(param_1);
    break;
  case 8:
    local_30 = (long *)(param_1 + 0x1e8);
    local_20 = (undefined **)0x0;
    break;
  case 9:
    local_30 = (long *)(param_1 + 0x178);
    local_20 = (undefined **)0x0;
    break;
  default:
    uVar3 = _libssh2_error(param_1,0xffffffde,"Invalid parameter specified for method_type");
    return uVar3;
  }
  __dest = (char *)(**(code **)(param_1 + 8))((long)((int)sVar2 + 1),param_1);
  if (__dest == (char *)0x0) {
    uVar3 = _libssh2_error(param_1,0xfffffffa,"Error allocated space for method preferences");
  }
  else {
    memcpy(__dest,param_3,(long)((int)sVar2 + 1));
    local_28 = __dest;
    while (((local_28 != (char *)0x0 && (*local_28 != '\0')) && (local_20 != (undefined **)0x0))) {
      pcVar4 = strchr(local_28,0x2c);
      if (pcVar4 == (char *)0x0) {
        sVar2 = strlen(local_28);
        iVar1 = (int)sVar2;
      }
      else {
        iVar1 = (int)pcVar4 - (int)local_28;
      }
      lVar5 = kex_get_method_by_name(local_28,(long)iVar1,local_20);
      if (lVar5 == 0) {
        if (pcVar4 == (char *)0x0) {
          if (__dest < local_28) {
            local_28 = local_28 + -1;
            *local_28 = '\0';
          }
          else {
            *local_28 = '\0';
          }
        }
        else {
          sVar2 = strlen(local_28);
          memcpy(local_28,pcVar4 + 1,sVar2 - (long)iVar1);
        }
      }
      else if (pcVar4 == (char *)0x0) {
        local_28 = (char *)0x0;
      }
      else {
        local_28 = pcVar4 + 1;
      }
    }
    if (*__dest == '\0') {
      (**(code **)(param_1 + 0x18))(__dest,param_1);
      uVar3 = _libssh2_error(param_1,0xffffffdf,
                             "The requested method(s) are not currently supported");
    }
    else {
      if (*local_30 != 0) {
        (**(code **)(param_1 + 0x18))(*local_30,param_1);
      }
      *local_30 = (long)__dest;
      uVar3 = 0;
    }
  }
  return uVar3;
}



ulong libssh2_session_supported_algs(long param_1,undefined4 param_2,long *param_3)

{
  ulong uVar1;
  long lVar2;
  uint local_1c;
  uint local_18;
  uint local_14;
  undefined **local_10;
  
  if (param_3 == (long *)0x0) {
    uVar1 = _libssh2_error(param_1,0xffffffd9,"algs must not be NULL");
  }
  else {
    switch(param_2) {
    case 0:
      local_10 = &libssh2_kex_methods;
      break;
    case 1:
      local_10 = (undefined **)libssh2_hostkey_methods();
      break;
    case 2:
    case 3:
      local_10 = (undefined **)libssh2_crypt_methods();
      break;
    case 4:
    case 5:
      local_10 = (undefined **)_libssh2_mac_methods();
      break;
    case 6:
    case 7:
      local_10 = (undefined **)_libssh2_comp_methods(param_1);
      break;
    default:
      uVar1 = _libssh2_error(param_1,0xffffffdf,"Unknown method type");
      return uVar1;
    }
    if (local_10 == (undefined **)0x0) {
      uVar1 = _libssh2_error(param_1,0xffffffde,"No algorithm found");
    }
    else {
      local_14 = 0;
      for (local_1c = 0; local_10[local_1c] != (undefined *)0x0; local_1c = local_1c + 1) {
        if (*(long *)local_10[local_1c] != 0) {
          local_14 = local_14 + 1;
        }
      }
      if (local_14 == 0) {
        uVar1 = _libssh2_error(param_1,0xffffffde,"No algorithm found");
      }
      else {
        lVar2 = (**(code **)(param_1 + 8))((ulong)local_14 << 3,param_1);
        *param_3 = lVar2;
        if (*param_3 == 0) {
          uVar1 = _libssh2_error(param_1,0xfffffffa,"Memory allocation failed");
        }
        else {
          local_1c = 0;
          local_18 = 0;
          while ((local_10[local_1c] != (undefined *)0x0 && (local_18 < local_14))) {
            if (*(long *)local_10[local_1c] != 0) {
              *(undefined8 *)(*param_3 + (ulong)local_18 * 8) = *(undefined8 *)local_10[local_1c];
              local_18 = local_18 + 1;
            }
            local_1c = local_1c + 1;
          }
          if (local_18 == local_14) {
            uVar1 = (ulong)local_14;
          }
          else {
            (**(code **)(param_1 + 0x18))(*param_3,param_1);
            *param_3 = 0;
            uVar1 = _libssh2_error(param_1,0xffffffd9,"Internal error");
          }
        }
      }
    }
  }
  return uVar1;
}



void free_host(long param_1,long param_2)

{
  if (param_2 != 0) {
    if (*(long *)(param_2 + 0x58) != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_2 + 0x58),param_1);
    }
    if (*(long *)(param_2 + 0x48) != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_2 + 0x48),param_1);
    }
    if (*(long *)(param_2 + 0x40) != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_2 + 0x40),param_1);
    }
    if (*(long *)(param_2 + 0x30) != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_2 + 0x30),param_1);
    }
    if (*(long *)(param_2 + 0x18) != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_2 + 0x18),param_1);
    }
    (**(code **)(param_1 + 0x18))(param_2,param_1);
  }
  return;
}



long * libssh2_knownhost_init(long param_1)

{
  long *plVar1;
  
  plVar1 = (long *)(**(code **)(param_1 + 8))(0x18,param_1);
  if (plVar1 == (long *)0x0) {
    _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for known-hosts collection");
    plVar1 = (long *)0x0;
  }
  else {
    *plVar1 = param_1;
    _libssh2_list_init(plVar1 + 1);
  }
  return plVar1;
}



undefined4 * knownhost_to_external(long param_1)

{
  undefined8 uVar1;
  
  *(undefined4 *)(param_1 + 0x68) = 0xdeadcafe;
  *(long *)(param_1 + 0x70) = param_1;
  if ((*(uint *)(param_1 + 0x2c) & 0xffff) == 1) {
    uVar1 = *(undefined8 *)(param_1 + 0x18);
  }
  else {
    uVar1 = 0;
  }
  *(undefined8 *)(param_1 + 0x78) = uVar1;
  *(undefined8 *)(param_1 + 0x80) = *(undefined8 *)(param_1 + 0x40);
  *(undefined4 *)(param_1 + 0x88) = *(undefined4 *)(param_1 + 0x2c);
  return (undefined4 *)(param_1 + 0x68);
}



ulong knownhost_add(long *param_1,char *param_2,char *param_3,void *param_4,size_t param_5,
                   char *param_6,size_t param_7,void *param_8,long param_9,uint param_10,
                   undefined8 *param_11)

{
  uint uVar1;
  ulong uVar2;
  size_t sVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  uint local_38;
  uint local_34;
  undefined8 local_30;
  size_t local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = strlen(param_2);
  if ((param_10 & 0x3c0000) == 0) {
    uVar2 = _libssh2_error(*param_1,0xffffffde,"No key type set");
    goto LAB_001286c7;
  }
  local_20 = _libssh2_calloc(*param_1,0x90);
  if (local_20 == 0) {
    uVar2 = _libssh2_error(*param_1,0xfffffffa,"Unable to allocate memory for known host entry");
    goto LAB_001286c7;
  }
  *(uint *)(local_20 + 0x2c) = param_10;
  uVar1 = *(uint *)(local_20 + 0x2c) & 0xffff;
  if (uVar1 == 3) {
LAB_001282ae:
    uVar4 = (**(code **)(*param_1 + 8))(local_28 + 1,*param_1);
    *(undefined8 *)(local_20 + 0x18) = uVar4;
    if (*(long *)(local_20 + 0x18) == 0) {
      local_34 = _libssh2_error(*param_1,0xfffffffa,"Unable to allocate memory for host name");
    }
    else {
      memcpy(*(void **)(local_20 + 0x18),param_2,local_28 + 1);
      *(size_t *)(local_20 + 0x20) = local_28;
LAB_001283fc:
      if ((param_10 & 0x20000) == 0) {
        local_18 = _libssh2_base64_encode(*param_1,param_6,param_7,&local_30);
        if (local_18 != 0) {
          *(undefined8 *)(local_20 + 0x40) = local_30;
          goto LAB_0012850b;
        }
        local_34 = _libssh2_error(*param_1,0xfffffffa,
                                  "Unable to allocate memory for base64-encoded key");
      }
      else {
        if (param_7 == 0) {
          param_7 = strlen(param_6);
        }
        uVar4 = (**(code **)(*param_1 + 8))(param_7 + 1,*param_1);
        *(undefined8 *)(local_20 + 0x40) = uVar4;
        if (*(long *)(local_20 + 0x40) != 0) {
          memcpy(*(void **)(local_20 + 0x40),param_6,param_7 + 1);
          *(undefined *)(param_7 + *(long *)(local_20 + 0x40)) = 0;
LAB_0012850b:
          if ((param_4 != (void *)0x0) && ((param_10 & 0x3c0000) == 0x3c0000)) {
            uVar4 = (**(code **)(*param_1 + 8))(param_5 + 1,*param_1);
            *(undefined8 *)(local_20 + 0x48) = uVar4;
            if (*(long *)(local_20 + 0x48) == 0) {
              local_34 = _libssh2_error(*param_1,0xfffffffa,"Unable to allocate memory for key type"
                                       );
              goto LAB_001286ae;
            }
            memcpy(*(void **)(local_20 + 0x48),param_4,param_5);
            *(undefined *)(param_5 + *(long *)(local_20 + 0x48)) = 0;
            *(size_t *)(local_20 + 0x50) = param_5;
          }
          if (param_8 == (void *)0x0) {
            *(undefined8 *)(local_20 + 0x58) = 0;
          }
          else {
            uVar4 = (**(code **)(*param_1 + 8))(param_9 + 1,*param_1);
            *(undefined8 *)(local_20 + 0x58) = uVar4;
            if (*(long *)(local_20 + 0x58) == 0) {
              local_34 = _libssh2_error(*param_1,0xfffffffa,"Unable to allocate memory for comment")
              ;
              goto LAB_001286ae;
            }
            memcpy(*(void **)(local_20 + 0x58),param_8,param_9 + 1);
            *(undefined *)(param_9 + *(long *)(local_20 + 0x58)) = 0;
            *(long *)(local_20 + 0x60) = param_9;
          }
          _libssh2_list_add(param_1 + 1,local_20);
          if (param_11 != (undefined8 *)0x0) {
            uVar4 = knownhost_to_external(local_20);
            *param_11 = uVar4;
          }
          uVar2 = 0;
          goto LAB_001286c7;
        }
        local_34 = _libssh2_error(*param_1,0xfffffffa,"Unable to allocate memory for key");
      }
    }
  }
  else {
    if (3 < uVar1) {
LAB_001283d9:
      local_34 = _libssh2_error(*param_1,0xffffffdf,"Unknown host name type");
      goto LAB_001286ae;
    }
    if (uVar1 == 1) goto LAB_001282ae;
    if (uVar1 != 2) goto LAB_001283d9;
    local_34 = libssh2_base64_decode(*param_1,&local_30,&local_38,param_2,local_28 & 0xffffffff);
    if (local_34 == 0) {
      *(undefined8 *)(local_20 + 0x18) = local_30;
      *(ulong *)(local_20 + 0x20) = (ulong)local_38;
      sVar3 = strlen(param_3);
      local_34 = libssh2_base64_decode(*param_1,&local_30,&local_38,param_3,sVar3 & 0xffffffff);
      if (local_34 == 0) {
        *(undefined8 *)(local_20 + 0x30) = local_30;
        *(ulong *)(local_20 + 0x38) = (ulong)local_38;
        goto LAB_001283fc;
      }
    }
  }
LAB_001286ae:
  free_host(*param_1,local_20);
  uVar2 = (ulong)local_34;
LAB_001286c7:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void libssh2_knownhost_add
               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
               undefined8 param_5,undefined4 param_6,undefined8 param_7)

{
  knownhost_add(param_1,param_2,param_3,0,0,param_4,param_5,0,0,param_6,param_7);
  return;
}



void libssh2_knownhost_addc
               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
               undefined8 param_5,undefined8 param_6,undefined8 param_7,undefined4 param_8,
               undefined8 param_9)

{
  knownhost_add(param_1,param_2,param_3,0,0,param_4,param_5,param_6,param_7,param_8,param_9);
  return;
}



undefined4
knownhost_check(long *param_1,uchar *param_2,uint param_3,char *param_4,undefined8 param_5,
               uint param_6,undefined8 *param_7)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  EVP_MD *md;
  size_t len;
  undefined8 uVar4;
  long in_FS_OFFSET;
  bool bVar5;
  char *local_1b8;
  undefined4 local_194;
  int local_190;
  char *local_178;
  HMAC_CTX *local_170;
  long local_168;
  long local_160;
  uchar *local_158;
  long local_150;
  uchar local_148 [32];
  uchar local_128 [280];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_160 = 0;
  uVar1 = param_6 & 0xffff;
  local_178 = (char *)0x0;
  local_194 = 2;
  bVar5 = false;
  if (uVar1 == 2) {
    local_194 = 1;
  }
  else {
    if ((int)param_3 < 0) {
      local_190 = 1;
      local_158 = param_2;
    }
    else {
      iVar2 = snprintf((char *)local_128,0x10e,"[%s]:%d",param_2,(ulong)param_3);
      if ((iVar2 < 0) || (0x10d < iVar2)) {
        _libssh2_error(*param_1,0xffffffda,"Known-host write buffer too small");
        local_194 = 3;
        goto LAB_00128cce;
      }
      local_158 = local_128;
      local_190 = 2;
    }
    local_1b8 = param_4;
    if ((param_6 & 0x20000) == 0) {
      local_150 = _libssh2_base64_encode(*param_1,param_4,param_5,&local_178);
      if (local_150 == 0) {
        _libssh2_error(*param_1,0xfffffffa,"Unable to allocate memory for base64-encoded key");
        local_194 = 3;
        goto LAB_00128cce;
      }
      local_1b8 = local_178;
    }
    do {
      for (local_168 = _libssh2_list_first(param_1 + 1); local_168 != 0;
          local_168 = _libssh2_list_next(local_168)) {
        uVar3 = *(uint *)(local_168 + 0x2c) & 0xffff;
        if (uVar3 == 3) {
          if (uVar1 == 3) {
            iVar2 = strcmp((char *)local_158,*(char **)(local_168 + 0x18));
            bVar5 = iVar2 == 0;
          }
        }
        else if (uVar3 < 4) {
          if (uVar3 == 1) {
            if (uVar1 == 1) {
              iVar2 = strcmp((char *)local_158,*(char **)(local_168 + 0x18));
              bVar5 = iVar2 == 0;
            }
          }
          else if (((uVar3 == 2) && (uVar1 == 1)) &&
                  (local_170 = (HMAC_CTX *)HMAC_CTX_new(), *(long *)(local_168 + 0x20) == 0x14)) {
            md = EVP_sha1();
            HMAC_Init_ex(local_170,*(void **)(local_168 + 0x30),
                         (int)*(undefined8 *)(local_168 + 0x38),md,(ENGINE *)0x0);
            len = strlen((char *)local_158);
            HMAC_Update(local_170,local_158,len);
            HMAC_Final(local_170,local_148,(uint *)0x0);
            HMAC_CTX_free(local_170);
            iVar2 = memcmp(local_148,*(void **)(local_168 + 0x18),0x14);
            if (iVar2 == 0) {
              bVar5 = true;
            }
          }
        }
        if (bVar5) {
          uVar3 = param_6 & 0x3c0000;
          if ((uVar3 != 0x3c0000) &&
             ((uVar3 == 0 || (uVar3 == (*(uint *)(local_168 + 0x2c) & 0x3c0000))))) {
            iVar2 = strcmp(local_1b8,*(char **)(local_168 + 0x40));
            if (iVar2 == 0) {
              if (param_7 != (undefined8 *)0x0) {
                uVar4 = knownhost_to_external(local_168);
                *param_7 = uVar4;
              }
              local_160 = 0;
              local_194 = 0;
              break;
            }
            if (local_160 == 0) {
              local_160 = local_168;
            }
          }
          bVar5 = false;
        }
      }
    } while ((!bVar5) && (local_190 = local_190 + -1, local_158 = param_2, local_190 != 0));
    local_158 = param_2;
    if (local_160 != 0) {
      if (param_7 != (undefined8 *)0x0) {
        uVar4 = knownhost_to_external(local_160);
        *param_7 = uVar4;
      }
      local_194 = 1;
    }
    if (local_178 != (char *)0x0) {
      (**(code **)(*param_1 + 0x18))(local_178,*param_1);
    }
  }
LAB_00128cce:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_194;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void libssh2_knownhost_check
               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
               undefined4 param_5,undefined8 param_6)

{
  knownhost_check(param_1,param_2,0xffffffff,param_3,param_4,param_5,param_6);
  return;
}



void libssh2_knownhost_checkp
               (undefined8 param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,
               undefined8 param_5,undefined4 param_6,undefined8 param_7)

{
  knownhost_check(param_1,param_2,param_3,param_4,param_5,param_6,param_7);
  return;
}



undefined8 libssh2_knownhost_del(undefined8 *param_1,int *param_2)

{
  undefined8 uVar1;
  
  if ((param_2 == (int *)0x0) || (*param_2 != -0x21523502)) {
    uVar1 = _libssh2_error(*param_1,0xffffffde,"Invalid host information");
  }
  else {
    uVar1 = *(undefined8 *)(param_2 + 2);
    _libssh2_list_remove(uVar1);
    memset(param_2,0,0x28);
    free_host(*param_1,uVar1);
    uVar1 = 0;
  }
  return uVar1;
}



void libssh2_knownhost_free(long *param_1)

{
  long lVar1;
  long local_18;
  
  local_18 = _libssh2_list_first(param_1 + 1);
  while (local_18 != 0) {
    lVar1 = _libssh2_list_next(local_18);
    free_host(*param_1,local_18);
    local_18 = lVar1;
  }
  (**(code **)(*param_1 + 0x18))(param_1,*param_1);
  return;
}



ulong oldstyle_hostline(undefined8 *param_1,void *param_2,long param_3,undefined8 param_4,
                       undefined8 param_5,undefined8 param_6,undefined8 param_7,uint param_8,
                       undefined8 param_9,undefined8 param_10)

{
  void *__src;
  uint uVar1;
  ulong uVar2;
  long in_FS_OFFSET;
  ulong local_128;
  void *local_120;
  undefined local_118;
  undefined auStack_117 [263];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_128 = 0;
  uVar2 = local_128;
  __src = (void *)(param_3 + (long)param_2);
  if (param_3 == 0) {
    uVar2 = _libssh2_error(*param_1,0xffffffdf,"Failed to parse known_hosts line (no host names)");
  }
  else {
    while (local_120 = __src, local_128 = uVar2, param_2 < local_120) {
      __src = (void *)((long)local_120 + -1);
      uVar2 = local_128 + 1;
      if ((__src == param_2) || (*(char *)((long)local_120 + -2) == ',')) {
        if (0xfe < uVar2) {
          uVar2 = _libssh2_error(*param_1,0xffffffdf,
                                 "Failed to parse known_hosts line (unexpected length)");
          goto LAB_0012909b;
        }
        memcpy(&local_118,__src,uVar2);
        auStack_117[local_128] = 0;
        uVar1 = knownhost_add(param_1,&local_118,0,param_4,param_5,param_6,param_7,param_9,param_10,
                              param_8 | 0x20001,0);
        if (uVar1 != 0) {
          uVar2 = (ulong)uVar1;
          goto LAB_0012909b;
        }
        if (param_2 < __src) {
          local_128 = 0;
          uVar2 = local_128;
          __src = (void *)((long)local_120 + -2);
        }
      }
    }
    uVar2 = 0;
  }
LAB_0012909b:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
hashed_hostline(undefined8 *param_1,long param_2,long param_3,undefined8 param_4,undefined8 param_5,
               undefined8 param_6,undefined8 param_7,uint param_8,undefined8 param_9,
               undefined8 param_10)

{
  char *__src;
  ulong __n;
  undefined8 uVar1;
  ulong __n_00;
  long in_FS_OFFSET;
  char *local_158;
  undefined local_138 [28];
  undefined auStack_11c [4];
  undefined local_118 [264];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  __src = (char *)(param_2 + 3);
  for (local_158 = __src; (*local_158 != '\0' && (*local_158 != '|')); local_158 = local_158 + 1) {
  }
  if (*local_158 == '|') {
    __n = (long)local_158 - (long)__src;
    if (__n < 0x1f) {
      memcpy(local_138,__src,__n);
      local_138[__n] = 0;
      __n_00 = (param_3 - __n) - 4;
      if (__n_00 < 0xff) {
        memcpy(local_118,local_158 + 1,__n_00);
        auStack_11c[param_3 - __n] = 0;
        uVar1 = knownhost_add(param_1,local_118,local_138,param_4,param_5,param_6,param_7,param_9,
                              param_10,param_8 | 0x20002,0);
      }
      else {
        uVar1 = _libssh2_error(*param_1,0xffffffdf,
                               "Failed to parse known_hosts line (unexpected length)");
      }
    }
    else {
      uVar1 = _libssh2_error(*param_1,0xffffffdf,
                             "Failed to parse known_hosts line (unexpectedly long salt)");
    }
  }
  else {
    uVar1 = 0;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



void hostline(undefined8 *param_1,void *param_2,ulong param_3,char *param_4,ulong param_5)

{
  int iVar1;
  ulong local_60;
  char *local_58;
  undefined4 local_2c;
  char *local_28;
  char *local_20;
  ulong local_18;
  size_t local_10;
  
  local_28 = (char *)0x0;
  local_20 = (char *)0x0;
  local_18 = 0;
  local_10 = 0;
  if (param_5 < 0x14) {
    _libssh2_error(*param_1,0xffffffdf,"Failed to parse known_hosts line (key too short)");
  }
  else {
    local_60 = param_5;
    local_58 = param_4;
    if ((int)*param_4 - 0x30U < 10) {
      local_2c = 0x40000;
    }
    else {
      for (; (((local_60 != 0 && (*local_58 != '\0')) && (*local_58 != ' ')) && (*local_58 != '\t'))
          ; local_58 = local_58 + 1) {
        local_60 = local_60 - 1;
      }
      local_10 = (long)local_58 - (long)param_4;
      iVar1 = strncmp(param_4,"ssh-dss",local_10);
      if (iVar1 == 0) {
        local_2c = 0xc0000;
      }
      else {
        iVar1 = strncmp(param_4,"ssh-rsa",local_10);
        if (iVar1 == 0) {
          local_2c = 0x80000;
        }
        else {
          iVar1 = strncmp(param_4,"ecdsa-sha2-nistp256",local_10);
          if (iVar1 == 0) {
            local_2c = 0x100000;
          }
          else {
            iVar1 = strncmp(param_4,"ecdsa-sha2-nistp384",local_10);
            if (iVar1 == 0) {
              local_2c = 0x140000;
            }
            else {
              iVar1 = strncmp(param_4,"ecdsa-sha2-nistp521",local_10);
              if (iVar1 == 0) {
                local_2c = 0x180000;
              }
              else {
                iVar1 = strncmp(param_4,"ssh-ed25519",local_10);
                if (iVar1 == 0) {
                  local_2c = 0x1c0000;
                }
                else {
                  local_2c = 0x3c0000;
                }
              }
            }
          }
        }
      }
      for (; (*local_58 == ' ' || (*local_58 == '\t')); local_58 = local_58 + 1) {
        local_60 = local_60 - 1;
      }
      local_18 = local_60;
      for (local_28 = local_58;
          ((local_18 != 0 && (*local_28 != '\0')) && ((*local_28 != ' ' && (*local_28 != '\t'))));
          local_28 = local_28 + 1) {
        local_18 = local_18 - 1;
      }
      local_60 = local_60 - local_18;
      if (local_18 == 0) {
        local_28 = (char *)0x0;
      }
      for (; ((local_20 = param_4, local_18 != 0 && (*local_28 != '\0')) &&
             ((*local_28 == ' ' || (*local_28 == '\t')))); local_28 = local_28 + 1) {
        local_18 = local_18 - 1;
      }
    }
    if ((param_3 < 3) || (iVar1 = memcmp(param_2,&DAT_00146e89,3), iVar1 == 0)) {
      hashed_hostline(param_1,param_2,param_3,local_20,local_10,local_58,local_60,local_2c,local_28,
                      local_18);
    }
    else {
      oldstyle_hostline(param_1,param_2,param_3,local_20,local_10,local_58,local_60,local_2c,
                        local_28,local_18);
    }
  }
  return;
}



ulong libssh2_knownhost_readline(undefined8 *param_1,char *param_2,long param_3,int param_4)

{
  char *pcVar1;
  char *pcVar2;
  uint uVar3;
  ulong uVar4;
  long lVar5;
  long local_50;
  char *local_30;
  long local_28;
  
  local_50 = param_3;
  local_30 = param_2;
  if (param_4 == 1) {
    for (; (pcVar1 = local_30, local_50 != 0 && ((*local_30 == ' ' || (*local_30 == '\t'))));
        local_30 = local_30 + 1) {
      local_50 = local_50 + -1;
    }
    if ((((local_50 == 0) || (*local_30 == '\0')) || (*local_30 == '#')) || (*local_30 == '\n')) {
      uVar4 = 0;
    }
    else {
      for (; ((local_50 != 0 && (*local_30 != '\0')) && ((*local_30 != ' ' && (*local_30 != '\t'))))
          ; local_30 = local_30 + 1) {
        local_50 = local_50 + -1;
      }
      lVar5 = (long)local_30 - (long)pcVar1;
      for (; ((pcVar2 = local_30, local_28 = local_50, local_50 != 0 && (*local_30 != '\0')) &&
             ((*local_30 == ' ' || (*local_30 == '\t')))); local_30 = local_30 + 1) {
        local_50 = local_50 + -1;
      }
      if ((*local_30 == '\0') || (local_50 == 0)) {
        uVar4 = _libssh2_error(*param_1,0xffffffdf,"Failed to parse known_hosts line");
      }
      else {
        for (; ((local_50 != 0 && (*local_30 != '\0')) && (*local_30 != '\n'));
            local_30 = local_30 + 1) {
          local_50 = local_50 + -1;
        }
        if (*local_30 == '\n') {
          local_28 = local_28 + -1;
        }
        uVar3 = hostline(param_1,pcVar1,lVar5,pcVar2,local_28);
        if (uVar3 == 0) {
          uVar4 = 0;
        }
        else {
          uVar4 = (ulong)uVar3;
        }
      }
    }
  }
  else {
    uVar4 = _libssh2_error(*param_1,0xffffffdf,"Unsupported type of known-host information store");
  }
  return uVar4;
}



ulong libssh2_knownhost_readfile(undefined8 *param_1,char *param_2,int param_3)

{
  int iVar1;
  ulong uVar2;
  FILE *__stream;
  size_t sVar3;
  char *pcVar4;
  long in_FS_OFFSET;
  uint local_824;
  char local_818 [2056];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_824 = 0;
  if (param_3 == 1) {
    __stream = fopen(param_2,"r");
    if (__stream == (FILE *)0x0) {
      uVar2 = _libssh2_error(*param_1,0xfffffff0,"Failed to open file");
    }
    else {
      while (pcVar4 = fgets(local_818,0x800,__stream), pcVar4 != (char *)0x0) {
        sVar3 = strlen(local_818);
        iVar1 = libssh2_knownhost_readline(param_1,local_818,sVar3,1);
        if (iVar1 != 0) {
          local_824 = _libssh2_error(*param_1,0xffffffd2,"Failed to parse known hosts file");
          break;
        }
        local_824 = local_824 + 1;
      }
      fclose(__stream);
      uVar2 = (ulong)local_824;
    }
  }
  else {
    uVar2 = _libssh2_error(*param_1,0xffffffdf,"Unsupported type of known-host information store");
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8
knownhost_writeline(long *param_1,long param_2,char *param_3,ulong param_4,long *param_5,int param_6
                   )

{
  uint uVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  undefined8 local_48;
  undefined8 local_40;
  size_t local_38;
  char *local_30;
  long local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_6 != 1) {
    uVar2 = _libssh2_error(*param_1,0xffffffdf,"Unsupported type of known-host information store");
    goto LAB_00129f38;
  }
  uVar1 = *(uint *)(param_2 + 0x2c) & 0x3c0000;
  if (uVar1 == 0x3c0000) {
    local_30 = *(char **)(param_2 + 0x48);
    if (local_30 != (char *)0x0) {
      local_28 = *(long *)(param_2 + 0x50);
      goto LAB_00129af2;
    }
  }
  else if (uVar1 < 0x3c0001) {
    if (uVar1 == 0x1c0000) {
      local_30 = "ssh-ed25519";
      local_28 = 0xb;
    }
    else {
      if (0x1c0000 < uVar1) goto LAB_00129ad2;
      if (uVar1 == 0x180000) {
        local_30 = "ecdsa-sha2-nistp521";
        local_28 = 0x13;
      }
      else {
        if (0x180000 < uVar1) goto LAB_00129ad2;
        if (uVar1 == 0x140000) {
          local_30 = "ecdsa-sha2-nistp384";
          local_28 = 0x13;
        }
        else {
          if (0x140000 < uVar1) goto LAB_00129ad2;
          if (uVar1 == 0x100000) {
            local_30 = "ecdsa-sha2-nistp256";
            local_28 = 0x13;
          }
          else {
            if (0x100000 < uVar1) goto LAB_00129ad2;
            if (uVar1 == 0xc0000) {
              local_30 = "ssh-dss";
              local_28 = 7;
            }
            else {
              if (0xc0000 < uVar1) goto LAB_00129ad2;
              if (uVar1 == 0x40000) {
                local_30 = (char *)0x0;
                local_28 = 0;
              }
              else {
                if (uVar1 != 0x80000) goto LAB_00129ad2;
                local_30 = "ssh-rsa";
                local_28 = 7;
              }
            }
          }
        }
      }
    }
LAB_00129af2:
    local_38 = strlen(*(char **)(param_2 + 0x40));
    if (local_28 != 0) {
      local_38 = local_38 + local_28 + 1;
    }
    if (*(long *)(param_2 + 0x58) != 0) {
      local_38 = local_38 + *(long *)(param_2 + 0x60) + 1;
    }
    if ((*(uint *)(param_2 + 0x2c) & 0xffff) == 2) {
      local_20 = _libssh2_base64_encode
                           (*param_1,*(undefined8 *)(param_2 + 0x18),*(undefined8 *)(param_2 + 0x20)
                            ,&local_48);
      if (local_20 == 0) {
        uVar2 = _libssh2_error(*param_1,0xfffffffa,
                               "Unable to allocate memory for base64-encoded host name");
        goto LAB_00129f38;
      }
      local_18 = _libssh2_base64_encode
                           (*param_1,*(undefined8 *)(param_2 + 0x30),*(undefined8 *)(param_2 + 0x38)
                            ,&local_40);
      if (local_18 == 0) {
        (**(code **)(*param_1 + 0x18))(local_48,*param_1);
        uVar2 = _libssh2_error(*param_1,0xfffffffa,
                               "Unable to allocate memory for base64-encoded salt");
        goto LAB_00129f38;
      }
      local_38 = local_38 + local_18 + local_20 + 7;
      if (local_38 <= param_4) {
        if ((*(long *)(param_2 + 0x58) == 0) || (local_28 == 0)) {
          if (*(long *)(param_2 + 0x58) == 0) {
            if (local_28 == 0) {
              snprintf(param_3,param_4,"|1|%s|%s %s\n",local_40,local_48,
                       *(undefined8 *)(param_2 + 0x40));
            }
            else {
              snprintf(param_3,param_4,"|1|%s|%s %s %s\n",local_40,local_48,local_30,
                       *(undefined8 *)(param_2 + 0x40));
            }
          }
          else {
            snprintf(param_3,param_4,"|1|%s|%s %s %s\n",local_40,local_48,
                     *(undefined8 *)(param_2 + 0x40),*(undefined8 *)(param_2 + 0x58));
          }
        }
        else {
          snprintf(param_3,param_4,"|1|%s|%s %s %s %s\n",local_40,local_48,local_30,
                   *(undefined8 *)(param_2 + 0x40),*(undefined8 *)(param_2 + 0x58));
        }
      }
      (**(code **)(*param_1 + 0x18))(local_48,*param_1);
      (**(code **)(*param_1 + 0x18))(local_40,*param_1);
    }
    else {
      local_38 = local_38 + *(long *)(param_2 + 0x20) + 3;
      if (local_38 <= param_4) {
        if ((*(long *)(param_2 + 0x58) == 0) || (local_28 == 0)) {
          if (*(long *)(param_2 + 0x58) == 0) {
            if (local_28 == 0) {
              snprintf(param_3,param_4,"%s %s\n",*(undefined8 *)(param_2 + 0x18),
                       *(undefined8 *)(param_2 + 0x40));
            }
            else {
              snprintf(param_3,param_4,"%s %s %s\n",*(undefined8 *)(param_2 + 0x18),local_30,
                       *(undefined8 *)(param_2 + 0x40));
            }
          }
          else {
            snprintf(param_3,param_4,"%s %s %s\n",*(undefined8 *)(param_2 + 0x18),
                     *(undefined8 *)(param_2 + 0x40),*(undefined8 *)(param_2 + 0x58));
          }
        }
        else {
          snprintf(param_3,param_4,"%s %s %s %s\n",*(undefined8 *)(param_2 + 0x18),local_30,
                   *(undefined8 *)(param_2 + 0x40),*(undefined8 *)(param_2 + 0x58));
        }
      }
    }
    *param_5 = local_38 - 1;
    if (param_4 < local_38) {
      uVar2 = _libssh2_error(*param_1,0xffffffda,"Known-host write buffer too small");
    }
    else {
      uVar2 = 0;
    }
    goto LAB_00129f38;
  }
LAB_00129ad2:
  uVar2 = _libssh2_error(*param_1,0xffffffdf,"Unsupported type of known-host entry");
LAB_00129f38:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void libssh2_knownhost_writeline
               (undefined8 *param_1,int *param_2,undefined8 param_3,undefined8 param_4,
               undefined8 param_5,undefined4 param_6)

{
  if (*param_2 == -0x21523502) {
    knownhost_writeline(param_1,*(undefined8 *)(param_2 + 2),param_3,param_4,param_5,param_6);
  }
  else {
    _libssh2_error(*param_1,0xffffffde,"Invalid host information");
  }
  return;
}



ulong libssh2_knownhost_writefile(undefined8 *param_1,char *param_2,int param_3)

{
  ulong uVar1;
  long in_FS_OFFSET;
  uint local_83c;
  size_t local_838;
  long local_830;
  FILE *local_828;
  size_t local_820;
  undefined local_818 [2056];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_83c = 0;
  if (param_3 == 1) {
    local_828 = fopen(param_2,"w");
    if (local_828 == (FILE *)0x0) {
      uVar1 = _libssh2_error(*param_1,0xfffffff0,"Failed to open file");
    }
    else {
      for (local_830 = _libssh2_list_first(param_1 + 1); local_830 != 0;
          local_830 = _libssh2_list_next(local_830)) {
        local_838 = 0;
        local_83c = knownhost_writeline(param_1,local_830,local_818,0x800,&local_838,1);
        if (local_83c != 0) break;
        local_820 = fwrite(local_818,1,local_838,local_828);
        if (local_820 != local_838) {
          local_83c = _libssh2_error(*param_1,0xfffffff0,"Write failed");
          break;
        }
      }
      fclose(local_828);
      uVar1 = (ulong)local_83c;
    }
  }
  else {
    uVar1 = _libssh2_error(*param_1,0xffffffdf,"Unsupported type of known-host information store");
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



bool libssh2_knownhost_get(long param_1,undefined8 *param_2,long param_3)

{
  undefined8 uVar1;
  undefined8 local_18;
  
  if ((param_3 == 0) || (*(long *)(param_3 + 8) == 0)) {
    local_18 = _libssh2_list_first(param_1 + 8);
  }
  else {
    local_18 = _libssh2_list_next(*(undefined8 *)(param_3 + 8));
  }
  if (local_18 != 0) {
    uVar1 = knownhost_to_external(local_18);
    *param_2 = uVar1;
  }
  return local_18 == 0;
}



undefined8
mac_method_common_init
          (undefined8 param_1,undefined8 param_2,undefined4 *param_3,undefined8 *param_4)

{
  *param_4 = param_2;
  *param_3 = 0;
  return 0;
}



undefined8 mac_method_common_dtor(long param_1,long *param_2)

{
  if (*param_2 != 0) {
    (**(code **)(param_1 + 0x18))(*param_2,param_1);
  }
  *param_2 = 0;
  return 0;
}



undefined8
mac_method_hmac_sha2_512_hash
          (undefined8 param_1,uchar *param_2,undefined4 param_3,uchar *param_4,uint param_5,
          uchar *param_6,uint param_7,undefined8 *param_8)

{
  HMAC_CTX *ctx;
  EVP_MD *md;
  long in_FS_OFFSET;
  uchar local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  _libssh2_htonu32(local_14,param_3);
  ctx = (HMAC_CTX *)HMAC_CTX_new();
  md = EVP_sha512();
  HMAC_Init_ex(ctx,(void *)*param_8,0x40,md,(ENGINE *)0x0);
  HMAC_Update(ctx,local_14,4);
  HMAC_Update(ctx,param_4,(ulong)param_5);
  if ((param_6 != (uchar *)0x0) && (param_7 != 0)) {
    HMAC_Update(ctx,param_6,(ulong)param_7);
  }
  HMAC_Final(ctx,param_2,(uint *)0x0);
  HMAC_CTX_free(ctx);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined8
mac_method_hmac_sha2_256_hash
          (undefined8 param_1,uchar *param_2,undefined4 param_3,uchar *param_4,uint param_5,
          uchar *param_6,uint param_7,undefined8 *param_8)

{
  HMAC_CTX *ctx;
  EVP_MD *md;
  long in_FS_OFFSET;
  uchar local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  _libssh2_htonu32(local_14,param_3);
  ctx = (HMAC_CTX *)HMAC_CTX_new();
  md = EVP_sha256();
  HMAC_Init_ex(ctx,(void *)*param_8,0x20,md,(ENGINE *)0x0);
  HMAC_Update(ctx,local_14,4);
  HMAC_Update(ctx,param_4,(ulong)param_5);
  if ((param_6 != (uchar *)0x0) && (param_7 != 0)) {
    HMAC_Update(ctx,param_6,(ulong)param_7);
  }
  HMAC_Final(ctx,param_2,(uint *)0x0);
  HMAC_CTX_free(ctx);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined8
mac_method_hmac_sha1_hash
          (undefined8 param_1,uchar *param_2,undefined4 param_3,uchar *param_4,uint param_5,
          uchar *param_6,uint param_7,undefined8 *param_8)

{
  HMAC_CTX *ctx;
  EVP_MD *md;
  long in_FS_OFFSET;
  uchar local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  _libssh2_htonu32(local_14,param_3);
  ctx = (HMAC_CTX *)HMAC_CTX_new();
  md = EVP_sha1();
  HMAC_Init_ex(ctx,(void *)*param_8,0x14,md,(ENGINE *)0x0);
  HMAC_Update(ctx,local_14,4);
  HMAC_Update(ctx,param_4,(ulong)param_5);
  if ((param_6 != (uchar *)0x0) && (param_7 != 0)) {
    HMAC_Update(ctx,param_6,(ulong)param_7);
  }
  HMAC_Final(ctx,param_2,(uint *)0x0);
  HMAC_CTX_free(ctx);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined8
mac_method_hmac_sha1_96_hash
          (undefined8 param_1,void *param_2,undefined4 param_3,undefined8 param_4,undefined4 param_5
          ,undefined8 param_6,undefined4 param_7,undefined8 param_8)

{
  long in_FS_OFFSET;
  undefined local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  mac_method_hmac_sha1_hash(param_1,local_28,param_3,param_4,param_5,param_6,param_7,param_8);
  memcpy(param_2,local_28,0xc);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined8
mac_method_hmac_md5_hash
          (undefined8 param_1,uchar *param_2,undefined4 param_3,uchar *param_4,uint param_5,
          uchar *param_6,uint param_7,undefined8 *param_8)

{
  HMAC_CTX *ctx;
  EVP_MD *md;
  long in_FS_OFFSET;
  uchar local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  _libssh2_htonu32(local_14,param_3);
  ctx = (HMAC_CTX *)HMAC_CTX_new();
  md = EVP_md5();
  HMAC_Init_ex(ctx,(void *)*param_8,0x10,md,(ENGINE *)0x0);
  HMAC_Update(ctx,local_14,4);
  HMAC_Update(ctx,param_4,(ulong)param_5);
  if ((param_6 != (uchar *)0x0) && (param_7 != 0)) {
    HMAC_Update(ctx,param_6,(ulong)param_7);
  }
  HMAC_Final(ctx,param_2,(uint *)0x0);
  HMAC_CTX_free(ctx);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined8
mac_method_hmac_md5_96_hash
          (undefined8 param_1,void *param_2,undefined4 param_3,undefined8 param_4,undefined4 param_5
          ,undefined8 param_6,undefined4 param_7,undefined8 param_8)

{
  long in_FS_OFFSET;
  undefined local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  mac_method_hmac_md5_hash(param_1,local_28,param_3,param_4,param_5,param_6,param_7,param_8);
  memcpy(param_2,local_28,0xc);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined8
mac_method_hmac_ripemd160_hash
          (undefined8 param_1,uchar *param_2,undefined4 param_3,uchar *param_4,uint param_5,
          uchar *param_6,uint param_7,undefined8 *param_8)

{
  HMAC_CTX *ctx;
  EVP_MD *md;
  long in_FS_OFFSET;
  uchar local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  _libssh2_htonu32(local_14,param_3);
  ctx = (HMAC_CTX *)HMAC_CTX_new();
  md = EVP_ripemd160();
  HMAC_Init_ex(ctx,(void *)*param_8,0x14,md,(ENGINE *)0x0);
  HMAC_Update(ctx,local_14,4);
  HMAC_Update(ctx,param_4,(ulong)param_5);
  if ((param_6 != (uchar *)0x0) && (param_7 != 0)) {
    HMAC_Update(ctx,param_6,(ulong)param_7);
  }
  HMAC_Final(ctx,param_2,(uint *)0x0);
  HMAC_CTX_free(ctx);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



undefined1 * _libssh2_mac_methods(void)

{
  return mac_methods;
}



undefined4 _libssh2_error_flags(long param_1,undefined4 param_2,char *param_3,uint param_4)

{
  size_t sVar1;
  void *__dest;
  
  if ((*(uint *)(param_1 + 0x244) & 1) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x238),param_1);
  }
  *(undefined4 *)(param_1 + 0x240) = param_2;
  *(undefined4 *)(param_1 + 0x244) = 0;
  if ((param_3 == (char *)0x0) || ((param_4 & 1) == 0)) {
    *(char **)(param_1 + 0x238) = param_3;
  }
  else {
    sVar1 = strlen(param_3);
    __dest = (void *)(**(code **)(param_1 + 8))(sVar1 + 1,param_1);
    if (__dest == (void *)0x0) {
      *(char **)(param_1 + 0x238) = "former error forgotten (OOM)";
    }
    else {
      memcpy(__dest,param_3,sVar1 + 1);
      *(undefined4 *)(param_1 + 0x244) = 1;
      *(void **)(param_1 + 0x238) = __dest;
    }
  }
  return param_2;
}



void _libssh2_error(undefined8 param_1,undefined4 param_2,undefined8 param_3)

{
  _libssh2_error_flags(param_1,param_2,param_3,0);
  return;
}



ssize_t _libssh2_recv(int param_1,void *param_2,size_t param_3,int param_4)

{
  ssize_t sVar1;
  int *piVar2;
  
  sVar1 = recv(param_1,param_2,param_3,param_4);
  if (sVar1 < 0) {
    piVar2 = __errno_location();
    if (*piVar2 == 2) {
      sVar1 = -0xb;
    }
    else {
      piVar2 = __errno_location();
      sVar1 = (ssize_t)-*piVar2;
    }
  }
  return sVar1;
}



ssize_t _libssh2_send(int param_1,void *param_2,size_t param_3,int param_4)

{
  ssize_t sVar1;
  int *piVar2;
  
  sVar1 = send(param_1,param_2,param_3,param_4);
  if (sVar1 < 0) {
    piVar2 = __errno_location();
    sVar1 = (ssize_t)-*piVar2;
  }
  return sVar1;
}



uint _libssh2_ntohu32(byte *param_1)

{
  return (uint)param_1[3] |
         (uint)*param_1 << 0x18 | (uint)param_1[1] << 0x10 | (uint)param_1[2] << 8;
}



ulong _libssh2_ntohu64(byte *param_1)

{
  return ((ulong)param_1[3] |
         (ulong)*param_1 << 0x18 | (ulong)param_1[1] << 0x10 | (ulong)param_1[2] << 8) << 0x20 |
         (ulong)param_1[7] |
         (ulong)param_1[4] << 0x18 | (ulong)param_1[5] << 0x10 | (ulong)param_1[6] << 8;
}



void _libssh2_htonu32(undefined *param_1,undefined4 param_2)

{
  *param_1 = (char)((uint)param_2 >> 0x18);
  param_1[1] = (char)((uint)param_2 >> 0x10);
  param_1[2] = (char)((uint)param_2 >> 8);
  param_1[3] = (char)param_2;
  return;
}



void _libssh2_store_u32(long *param_1,undefined4 param_2)

{
  _libssh2_htonu32(*param_1,param_2);
  *param_1 = *param_1 + 4;
  return;
}



void _libssh2_store_str(long *param_1,void *param_2,ulong param_3)

{
  _libssh2_store_u32(param_1,param_3 & 0xffffffff);
  if (param_3 != 0) {
    memcpy((void *)*param_1,param_2,param_3);
    *param_1 = *param_1 + param_3;
  }
  return;
}



undefined8 libssh2_base64_decode(long param_1,long *param_2,int *param_3,byte *param_4,uint param_5)

{
  short sVar1;
  byte bVar2;
  int iVar3;
  long lVar4;
  undefined8 uVar5;
  int local_20;
  int local_1c;
  byte *local_18;
  
  local_20 = 0;
  local_1c = 0;
  lVar4 = (**(code **)(param_1 + 8))((param_5 * 3 >> 2) + 1,param_1);
  *param_2 = lVar4;
  lVar4 = *param_2;
  local_18 = param_4;
  if (lVar4 == 0) {
    uVar5 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for base64 decoding");
  }
  else {
    for (; local_18 < param_4 + param_5; local_18 = local_18 + 1) {
      sVar1 = *(short *)(base64_reverse_table + (long)(int)(uint)*local_18 * 2);
      if (-1 < sVar1) {
        iVar3 = local_20 % 4;
        bVar2 = (byte)sVar1;
        if (iVar3 == 3) {
          *(byte *)(lVar4 + local_1c) = *(byte *)(lVar4 + local_1c) | bVar2;
          local_1c = local_1c + 1;
        }
        else if (iVar3 < 4) {
          if (iVar3 == 2) {
            *(byte *)(lVar4 + local_1c) = *(byte *)(lVar4 + local_1c) | (byte)(sVar1 >> 2);
            *(byte *)(lVar4 + (local_1c + 1)) = bVar2 << 6;
            local_1c = local_1c + 1;
          }
          else if (iVar3 < 3) {
            if (iVar3 == 0) {
              *(byte *)(lVar4 + local_1c) = bVar2 * '\x04';
            }
            else if (iVar3 == 1) {
              *(byte *)(lVar4 + local_1c) = *(byte *)(lVar4 + local_1c) | (byte)(sVar1 >> 4);
              *(byte *)(lVar4 + (local_1c + 1)) = bVar2 << 4;
              local_1c = local_1c + 1;
            }
          }
        }
        local_20 = local_20 + 1;
      }
    }
    if (local_20 % 4 == 1) {
      (**(code **)(param_1 + 0x18))(*param_2,param_1);
      *param_2 = 0;
      uVar5 = _libssh2_error(param_1,0xffffffde,"Invalid base64");
    }
    else {
      *param_3 = local_1c;
      uVar5 = 0;
    }
  }
  return uVar5;
}



size_t _libssh2_base64_encode(long param_1,byte *param_2,size_t param_3,undefined8 *param_4)

{
  char *__s;
  size_t sVar1;
  long in_FS_OFFSET;
  size_t local_50;
  int local_38;
  int local_34;
  char *local_30;
  byte *local_28;
  byte local_17 [4];
  byte local_13;
  byte local_12;
  byte local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  *param_4 = 0;
  local_50 = param_3;
  if (param_3 == 0) {
    local_50 = strlen((char *)param_2);
  }
  __s = (char *)(**(code **)(param_1 + 8))((local_50 << 2) / 3 + 4,param_1);
  local_30 = __s;
  local_28 = param_2;
  if (__s == (char *)0x0) {
    sVar1 = 0;
  }
  else {
    while (local_50 != 0) {
      local_34 = 0;
      for (local_38 = 0; local_38 < 3; local_38 = local_38 + 1) {
        if (local_50 == 0) {
          local_17[local_38] = 0;
        }
        else {
          local_34 = local_34 + 1;
          local_17[local_38] = *local_28;
          local_28 = local_28 + 1;
          local_50 = local_50 - 1;
        }
      }
      local_17[3] = local_17[0] >> 2;
      local_13 = local_17[1] >> 4 | (byte)((local_17[0] & 3) << 4);
      local_12 = local_17[2] >> 6 | (byte)((local_17[1] & 0xf) << 2);
      local_11 = local_17[2] & 0x3f;
      if (local_34 == 1) {
        snprintf(local_30,5,"%c%c==",
                 (ulong)(uint)(int)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                   [(int)(uint)local_17[3]],
                 (ulong)(uint)(int)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                   [(int)(uint)local_13]);
      }
      else if (local_34 == 2) {
        snprintf(local_30,5,"%c%c%c=",
                 (ulong)(uint)(int)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                   [(int)(uint)local_17[3]],
                 (ulong)(uint)(int)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                   [(int)(uint)local_13],
                 (ulong)(uint)(int)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                   [(int)(uint)local_12]);
      }
      else {
        snprintf(local_30,5,"%c%c%c%c",
                 (ulong)(uint)(int)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                   [(int)(uint)local_17[3]],
                 (ulong)(uint)(int)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                   [(int)(uint)local_13],
                 (ulong)(uint)(int)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                   [(int)(uint)local_12],
                 (ulong)(uint)(int)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                                   [(int)(uint)local_11]);
      }
      local_30 = local_30 + 4;
    }
    *local_30 = '\0';
    *param_4 = __s;
    sVar1 = strlen(__s);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return sVar1;
}



void libssh2_free(long param_1,undefined8 param_2)

{
  (**(code **)(param_1 + 0x18))(param_2,param_1);
  return;
}



undefined8 libssh2_trace(void)

{
  return 0;
}



undefined8 libssh2_trace_sethandler(void)

{
  return 0;
}



void _libssh2_list_init(undefined8 *param_1)

{
  *param_1 = 0;
  param_1[1] = *param_1;
  return;
}



void _libssh2_list_add(undefined8 *param_1,undefined8 *param_2)

{
  param_2[2] = param_1;
  *param_2 = 0;
  param_2[1] = *param_1;
  *param_1 = param_2;
  if (param_2[1] == 0) {
    param_1[1] = param_2;
  }
  else {
    *(undefined8 **)param_2[1] = param_2;
  }
  return;
}



undefined8 _libssh2_list_first(long param_1)

{
  return *(undefined8 *)(param_1 + 8);
}



undefined8 _libssh2_list_next(undefined8 *param_1)

{
  return *param_1;
}



undefined8 _libssh2_list_prev(long param_1)

{
  return *(undefined8 *)(param_1 + 8);
}



void _libssh2_list_remove(long *param_1)

{
  if (param_1[1] == 0) {
    *(long *)(param_1[2] + 8) = *param_1;
  }
  else {
    *(long *)param_1[1] = *param_1;
  }
  if (*param_1 == 0) {
    *(long *)param_1[2] = param_1[1];
  }
  else {
    *(long *)(*param_1 + 8) = param_1[1];
  }
  return;
}



void * _libssh2_calloc(long param_1,size_t param_2)

{
  void *__s;
  
  __s = (void *)(**(code **)(param_1 + 8))(param_2,param_1);
  if (__s != (void *)0x0) {
    memset(__s,0,param_2);
  }
  return __s;
}



void _libssh2_xor_data(byte *param_1,byte *param_2,byte *param_3,ulong param_4)

{
  byte *local_30;
  byte *local_28;
  byte *local_20;
  ulong local_10;
  
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  for (local_10 = 0; local_10 < param_4; local_10 = local_10 + 1) {
    *local_20 = *local_28 ^ *local_30;
    local_30 = local_30 + 1;
    local_28 = local_28 + 1;
    local_20 = local_20 + 1;
  }
  return;
}



void _libssh2_aes_ctr_increment(byte *param_1,long param_2)

{
  byte bVar1;
  uint local_18;
  byte *local_10;
  
  local_18 = 1;
  local_10 = param_1 + param_2 + -1;
  while (param_1 <= local_10) {
    bVar1 = *local_10;
    *local_10 = (byte)(local_18 + bVar1);
    local_18 = local_18 + bVar1 >> 8;
    local_10 = local_10 + -1;
  }
  return;
}



void _libssh2_explicit_zero(undefined8 param_1,undefined8 param_2)

{
  (*(code *)memset_libssh)(param_1,0,param_2);
  return;
}



long _libssh2_string_buf_new(undefined8 param_1)

{
  long lVar1;
  
  lVar1 = _libssh2_calloc(param_1,0x20);
  if (lVar1 == 0) {
    lVar1 = 0;
  }
  return lVar1;
}



void _libssh2_string_buf_free(long param_1,long *param_2)

{
  if (param_2 != (long *)0x0) {
    if (*param_2 != 0) {
      (**(code **)(param_1 + 0x18))(*param_2,param_1);
    }
    (**(code **)(param_1 + 0x18))(param_2,param_1);
  }
  return;
}



undefined8 _libssh2_get_u32(long param_1,int *param_2)

{
  byte *pbVar1;
  int iVar2;
  undefined8 uVar3;
  
  iVar2 = _libssh2_check_length(param_1,4);
  if (iVar2 == 0) {
    uVar3 = 0xffffffff;
  }
  else {
    pbVar1 = *(byte **)(param_1 + 8);
    *param_2 = (uint)*pbVar1 * 0x1000000 + (uint)pbVar1[1] * 0x10000 + (uint)pbVar1[2] * 0x100 +
               (uint)pbVar1[3];
    *(long *)(param_1 + 8) = *(long *)(param_1 + 8) + 4;
    *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 4;
    uVar3 = 0;
  }
  return uVar3;
}



undefined8 _libssh2_match_string(undefined8 param_1,char *param_2)

{
  int iVar1;
  size_t sVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  char *local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = _libssh2_get_c_string(param_1,&local_28);
  sVar2 = strlen(param_2);
  if ((long)iVar1 == sVar2) {
    sVar2 = strlen(param_2);
    iVar1 = strncmp(local_28,param_2,sVar2);
    if (iVar1 == 0) {
      uVar3 = 0;
      goto LAB_0012b756;
    }
  }
  uVar3 = 0xffffffff;
LAB_0012b756:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



uint _libssh2_get_c_string(long param_1,undefined8 *param_2)

{
  int iVar1;
  long in_FS_OFFSET;
  uint local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = _libssh2_get_u32(param_1,&local_14);
  if (iVar1 == 0) {
    iVar1 = _libssh2_check_length(param_1,local_14);
    if (iVar1 == 0) {
      local_14 = 0xffffffff;
    }
    else {
      *param_2 = *(undefined8 *)(param_1 + 8);
      *(ulong *)(param_1 + 8) = (ulong)local_14 + *(long *)(param_1 + 8);
      *(ulong *)(param_1 + 0x18) = (ulong)local_14 + *(long *)(param_1 + 0x18);
    }
  }
  else {
    local_14 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_14;
}



uint _libssh2_get_bignum_bytes(long param_1,undefined8 *param_2)

{
  int iVar1;
  uint uVar2;
  long in_FS_OFFSET;
  uint local_20;
  uint local_1c;
  char *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = _libssh2_get_u32(param_1,&local_20);
  if (iVar1 == 0) {
    iVar1 = _libssh2_check_length(param_1,local_20);
    if (iVar1 == 0) {
      uVar2 = 0xffffffff;
    }
    else {
      local_1c = local_20;
      for (local_18 = *(char **)(param_1 + 8); (local_1c != 0 && (*local_18 == '\0'));
          local_18 = local_18 + 1) {
        local_1c = local_1c - 1;
      }
      *param_2 = local_18;
      *(ulong *)(param_1 + 8) = (ulong)local_20 + *(long *)(param_1 + 8);
      *(ulong *)(param_1 + 0x18) = (ulong)local_20 + *(long *)(param_1 + 0x18);
      uVar2 = local_1c;
    }
  }
  else {
    uVar2 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



bool _libssh2_check_length(undefined8 *param_1,int param_2)

{
  return (int)param_1[1] - (int)*param_1 <= (int)param_1[2] - param_2;
}



void _libssh2_bcrypt_pbkdf
               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
               undefined8 param_5,undefined8 param_6,undefined4 param_7)

{
  bcrypt_pbkdf(param_1,param_2,param_3,param_4,param_5,param_6,param_7);
  return;
}



undefined8 packet_queue_listener(long param_1,long param_2,undefined8 param_3,int *param_4)

{
  int iVar1;
  undefined4 uVar2;
  size_t sVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  undefined local_3d;
  long local_38;
  long local_30;
  undefined8 local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = 0x26;
  local_30 = _libssh2_list_first(param_1 + 0x218);
  local_3d = 1;
  if (*param_4 == 0) {
    local_20 = param_2 + 0x14;
    iVar1 = _libssh2_ntohu32(local_20);
    param_4[0x10] = iVar1;
    local_20 = local_20 + 4;
    iVar1 = _libssh2_ntohu32(local_20);
    param_4[0x11] = iVar1;
    local_20 = local_20 + 4;
    iVar1 = _libssh2_ntohu32(local_20);
    param_4[0x12] = iVar1;
    local_20 = local_20 + 4;
    iVar1 = _libssh2_ntohu32(local_20);
    param_4[0x15] = iVar1;
    *(long *)(param_4 + 0xc) = local_20 + 4;
    local_20 = local_20 + 4 + (ulong)(uint)param_4[0x15];
    iVar1 = _libssh2_ntohu32(local_20);
    param_4[0x13] = iVar1;
    local_20 = local_20 + 4;
    iVar1 = _libssh2_ntohu32(local_20);
    param_4[0x16] = iVar1;
    *(long *)(param_4 + 0xe) = local_20 + 4;
    local_20 = local_20 + 4 + (ulong)(uint)param_4[0x16];
    iVar1 = _libssh2_ntohu32(local_20);
    param_4[0x14] = iVar1;
    *param_4 = 1;
  }
  if (*param_4 != 3) {
    for (; local_30 != 0; local_30 = _libssh2_list_next(local_30)) {
      if (((*(int *)(local_30 + 0x28) == param_4[0x13]) &&
          (sVar3 = strlen(*(char **)(local_30 + 0x20)), sVar3 == (uint)param_4[0x15])) &&
         (iVar1 = memcmp(*(void **)(local_30 + 0x20),*(void **)(param_4 + 0xc),
                         (ulong)(uint)param_4[0x15]), iVar1 == 0)) {
        local_18 = 0;
        param_4[0x18] = 0;
        param_4[0x19] = 0;
        if (*param_4 == 1) {
          if ((*(int *)(local_30 + 0x44) != 0) &&
             (*(int *)(local_30 + 0x44) <= *(int *)(local_30 + 0x40))) {
            local_3d = 4;
            *param_4 = 3;
            break;
          }
          local_18 = _libssh2_calloc(param_1,0x2b0);
          if (local_18 == 0) {
            _libssh2_error(param_1,0xfffffffa,"Unable to allocate a channel for new connection");
            local_3d = 4;
            *param_4 = 3;
            break;
          }
          *(long *)(param_4 + 0x18) = local_18;
          *(long *)(local_18 + 0x60) = param_1;
          *(undefined4 *)(local_18 + 0x20) = 0xf;
          uVar4 = (**(code **)(param_1 + 8))(*(int *)(local_18 + 0x20) + 1,param_1);
          *(undefined8 *)(local_18 + 0x18) = uVar4;
          if (*(long *)(local_18 + 0x18) == 0) {
            _libssh2_error(param_1,0xfffffffa,"Unable to allocate a channel for new connection");
            (**(code **)(param_1 + 0x18))(local_18,param_1);
            local_3d = 4;
            *param_4 = 3;
            break;
          }
          memcpy(*(void **)(local_18 + 0x18),"forwarded-tcpip",
                 (ulong)(*(int *)(local_18 + 0x20) + 1));
          *(int *)(local_18 + 0x44) = param_4[0x10];
          *(undefined4 *)(local_18 + 0x48) = 0x200000;
          *(undefined4 *)(local_18 + 0x4c) = 0x200000;
          *(undefined4 *)(local_18 + 0x50) = 0x8000;
          uVar2 = _libssh2_channel_nextid(param_1);
          *(undefined4 *)(local_18 + 0x30) = uVar2;
          *(int *)(local_18 + 0x34) = param_4[0x11];
          *(int *)(local_18 + 0x38) = param_4[0x11];
          *(int *)(local_18 + 0x3c) = param_4[0x12];
          local_38 = (long)param_4 + 5;
          *(undefined *)(param_4 + 1) = 0x5b;
          _libssh2_store_u32(&local_38,*(undefined4 *)(local_18 + 0x44));
          _libssh2_store_u32(&local_38,*(undefined4 *)(local_18 + 0x30));
          _libssh2_store_u32(&local_38,*(undefined4 *)(local_18 + 0x48));
          _libssh2_store_u32(&local_38,*(undefined4 *)(local_18 + 0x50));
          *param_4 = 2;
        }
        if (*param_4 == 2) {
          iVar1 = _libssh2_transport_send(param_1,param_4 + 1,0x11,0,0);
          if (iVar1 == -0x25) {
            uVar4 = 0xffffffdb;
          }
          else if (iVar1 == 0) {
            if (*(long *)(param_4 + 0x18) != 0) {
              _libssh2_list_add(local_30 + 0x30,*(undefined8 *)(param_4 + 0x18));
              *(int *)(local_30 + 0x40) = *(int *)(local_30 + 0x40) + 1;
            }
            *param_4 = 0;
            uVar4 = 0;
          }
          else {
            *param_4 = 0;
            uVar4 = _libssh2_error(param_1,iVar1,"Unable to send channel open confirmation");
          }
          goto LAB_0012bf55;
        }
      }
    }
    *param_4 = 3;
  }
  local_38 = (long)param_4 + 5;
  *(undefined *)(param_4 + 1) = 0x5c;
  _libssh2_store_u32(&local_38,param_4[0x10]);
  _libssh2_store_u32(&local_38,local_3d);
  _libssh2_store_str(&local_38,"Forward not requested",0x15);
  _libssh2_htonu32(local_38,0);
  iVar1 = _libssh2_transport_send(param_1,param_4 + 1,local_28,0,0);
  if (iVar1 == -0x25) {
    uVar4 = 0xffffffdb;
  }
  else if (iVar1 == 0) {
    *param_4 = 0;
    uVar4 = 0;
  }
  else {
    *param_4 = 0;
    uVar4 = _libssh2_error(param_1,iVar1,"Unable to send open failure");
  }
LAB_0012bf55:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 packet_x11_open(long param_1,long param_2,undefined8 param_3,int *param_4)

{
  int iVar1;
  undefined4 uVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  undefined4 local_38;
  long local_30;
  long local_28;
  undefined8 local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = 2;
  local_20 = 0x28;
  local_28 = *(long *)(param_4 + 0x14);
  if (*param_4 == 0) {
    local_18 = param_2 + 8;
    iVar1 = _libssh2_ntohu32(local_18);
    param_4[0xe] = iVar1;
    local_18 = local_18 + 4;
    iVar1 = _libssh2_ntohu32(local_18);
    param_4[0xf] = iVar1;
    local_18 = local_18 + 4;
    iVar1 = _libssh2_ntohu32(local_18);
    param_4[0x10] = iVar1;
    local_18 = local_18 + 4;
    iVar1 = _libssh2_ntohu32(local_18);
    param_4[0x12] = iVar1;
    *(long *)(param_4 + 0xc) = local_18 + 4;
    local_18 = local_18 + 4 + (ulong)(uint)param_4[0x12];
    iVar1 = _libssh2_ntohu32(local_18);
    param_4[0x11] = iVar1;
    *param_4 = 1;
  }
  if (*(long *)(param_1 + 0x40) == 0) {
    local_38 = 4;
  }
  else if (*param_4 == 1) {
    local_28 = _libssh2_calloc(param_1,0x2b0);
    if (local_28 == 0) {
      _libssh2_error(param_1,0xfffffffa,"allocate a channel for new connection");
      local_38 = 4;
    }
    else {
      *(long *)(local_28 + 0x60) = param_1;
      *(undefined4 *)(local_28 + 0x20) = 3;
      uVar3 = (**(code **)(param_1 + 8))(*(int *)(local_28 + 0x20) + 1,param_1);
      *(undefined8 *)(local_28 + 0x18) = uVar3;
      if (*(long *)(local_28 + 0x18) != 0) {
        memcpy(*(void **)(local_28 + 0x18),&DAT_00147426,(ulong)(*(int *)(local_28 + 0x20) + 1));
        *(int *)(local_28 + 0x44) = param_4[0xe];
        *(undefined4 *)(local_28 + 0x48) = 0x200000;
        *(undefined4 *)(local_28 + 0x4c) = 0x200000;
        *(undefined4 *)(local_28 + 0x50) = 0x8000;
        uVar2 = _libssh2_channel_nextid(param_1);
        *(undefined4 *)(local_28 + 0x30) = uVar2;
        *(int *)(local_28 + 0x34) = param_4[0xf];
        *(int *)(local_28 + 0x38) = param_4[0xf];
        *(int *)(local_28 + 0x3c) = param_4[0x10];
        local_30 = (long)param_4 + 5;
        *(undefined *)(param_4 + 1) = 0x5b;
        _libssh2_store_u32(&local_30,*(undefined4 *)(local_28 + 0x44));
        _libssh2_store_u32(&local_30,*(undefined4 *)(local_28 + 0x30));
        _libssh2_store_u32(&local_30,*(undefined4 *)(local_28 + 0x48));
        _libssh2_store_u32(&local_30,*(undefined4 *)(local_28 + 0x50));
        *param_4 = 2;
        goto LAB_0012c24d;
      }
      _libssh2_error(param_1,0xfffffffa,"allocate a channel for new connection");
      (**(code **)(param_1 + 0x18))(local_28,param_1);
      local_38 = 4;
    }
  }
  else {
LAB_0012c24d:
    if (*param_4 == 2) {
      iVar1 = _libssh2_transport_send(param_1,param_4 + 1,0x11,0,0);
      if (iVar1 == -0x25) {
        uVar3 = 0xffffffdb;
      }
      else if (iVar1 == 0) {
        _libssh2_list_add(param_1 + 0x200,local_28);
        (**(code **)(*(long *)(local_28 + 0x60) + 0x40))
                  (*(undefined8 *)(local_28 + 0x60),local_28,*(undefined8 *)(param_4 + 0xc),
                   param_4[0x11],*(undefined8 *)(local_28 + 0x60));
        *param_4 = 0;
        uVar3 = 0;
      }
      else {
        *param_4 = 0;
        uVar3 = _libssh2_error(param_1,0xfffffff9,"Unable to send channel open confirmation");
      }
      goto LAB_0012c404;
    }
  }
  local_30 = (long)param_4 + 5;
  *(undefined *)(param_4 + 1) = 0x5c;
  _libssh2_store_u32(&local_30,param_4[0xe]);
  _libssh2_store_u32(&local_30,local_38);
  _libssh2_store_str(&local_30,"X11 Forward Unavailable",0x17);
  _libssh2_htonu32(local_30,0);
  iVar1 = _libssh2_transport_send(param_1,param_4 + 1,local_20,0,0);
  if (iVar1 == -0x25) {
    uVar3 = 0xffffffdb;
  }
  else if (iVar1 == 0) {
    *param_4 = 0;
    uVar3 = 0;
  }
  else {
    *param_4 = 0;
    uVar3 = _libssh2_error(param_1,iVar1,"Unable to send open failure");
  }
LAB_0012c404:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



ulong _libssh2_packet_add(long param_1,byte *param_2,ulong param_3,int param_4)

{
  byte bVar1;
  undefined4 uVar2;
  uint uVar3;
  int iVar4;
  undefined8 uVar5;
  long lVar6;
  ulong uVar7;
  long in_FS_OFFSET;
  ulong local_90;
  byte local_77;
  byte local_76;
  uint local_74;
  byte *local_58;
  byte *local_50;
  ulong local_48;
  ulong local_40;
  long local_38;
  ulong local_30;
  undefined local_15;
  undefined4 local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_74 = 0;
  local_58 = (byte *)0x0;
  local_50 = (byte *)0x0;
  local_48 = 0;
  local_40 = 0;
  local_38 = 0;
  local_30 = 0;
  bVar1 = *param_2;
  local_90 = param_3;
  if (false) goto LAB_0012c54c;
  switch(*(undefined4 *)(param_1 + 0xd2b8)) {
  case 0:
    if ((param_4 == -1) &&
       ((*(long *)(param_1 + 0x38) == 0 ||
        (iVar4 = (**(code **)(param_1 + 0x38))(param_1,param_2,param_3 & 0xffffffff,param_1),
        iVar4 != 0)))) {
      (**(code **)(param_1 + 0x18))(param_2,param_1);
      uVar7 = _libssh2_error(param_1,0xfffffffc,"Invalid MAC received");
      goto LAB_0012d387;
    }
    *(undefined4 *)(param_1 + 0xd2b8) = 1;
    break;
  case 0xb:
    goto LAB_0012cb0c;
  case 0xc:
    goto LAB_0012d05b;
  case 0xd:
    goto LAB_0012d0f5;
  case 0xe:
    goto LAB_0012cec8;
  case 0xf:
    goto LAB_0012c961;
  }
LAB_0012c54c:
  if (*(int *)(param_1 + 0xd2b8) != 1) goto LAB_0012d1fe;
  if (0x62 < bVar1) goto LAB_0012d1f0;
  if (bVar1 < 0x50) {
    if (bVar1 == 4) {
      if (1 < param_3) {
        bVar1 = param_2[1];
        if (5 < param_3) {
          uVar3 = _libssh2_ntohu32(param_2 + 2);
          local_48 = (ulong)uVar3;
          if (local_48 <= param_3 - 10) {
            local_58 = param_2 + 6;
            uVar3 = _libssh2_ntohu32(param_2 + local_48 + 6);
            local_40 = (ulong)uVar3;
            if (local_40 <= (param_3 - local_48) - 10) {
              local_50 = param_2 + local_48 + 10;
            }
          }
        }
        if (*(long *)(param_1 + 0x28) != 0) {
          (**(code **)(param_1 + 0x28))(param_1,bVar1,local_58,local_48,local_50,local_40,param_1);
        }
      }
      (**(code **)(param_1 + 0x18))(param_2,param_1);
      *(undefined4 *)(param_1 + 0xd2b8) = 0;
      uVar7 = 0;
      goto LAB_0012d387;
    }
    if (bVar1 < 5) {
      if (bVar1 == 1) {
        if (4 < param_3) {
          uVar2 = _libssh2_ntohu32(param_2 + 1);
          if (8 < param_3) {
            uVar3 = _libssh2_ntohu32(param_2 + 5);
            local_48 = (ulong)uVar3;
            if (local_48 < param_3 - 0xd) {
              local_58 = param_2 + 9;
              uVar3 = _libssh2_ntohu32(param_2 + local_48 + 9);
              local_40 = (ulong)uVar3;
              local_50 = param_2 + local_48 + 0xd;
              if ((param_3 - local_48) - 0xd < local_40) {
                local_58 = (byte *)0x0;
                local_50 = (byte *)0x0;
                local_48 = 0;
                local_40 = 0;
              }
            }
            else {
              local_48 = 0;
            }
          }
          if (*(long *)(param_1 + 0x30) != 0) {
            (**(code **)(param_1 + 0x30))(param_1,uVar2,local_58,local_48,local_50,local_40,param_1)
            ;
          }
        }
        (**(code **)(param_1 + 0x18))(param_2,param_1);
        *(undefined4 *)(param_1 + 0x22c) = 0xffffffff;
        *(undefined4 *)(param_1 + 0xd2b8) = 0;
        uVar7 = _libssh2_error(param_1,0xfffffff3,"socket disconnect");
        goto LAB_0012d387;
      }
      if (bVar1 == 2) {
        if (param_3 < 2) {
          if (*(long *)(param_1 + 0x20) != 0) {
            (**(code **)(param_1 + 0x20))(param_1,&DAT_00147469,0,param_1);
          }
        }
        else if (*(long *)(param_1 + 0x20) != 0) {
          (**(code **)(param_1 + 0x20))(param_1,param_2 + 1,(int)param_3 + -1,param_1);
        }
        (**(code **)(param_1 + 0x18))(param_2,param_1);
        *(undefined4 *)(param_1 + 0xd2b8) = 0;
        uVar7 = 0;
        goto LAB_0012d387;
      }
    }
    goto LAB_0012d1f0;
  }
  if (false) goto LAB_0012d1f0;
  switch(bVar1) {
  case 0x50:
    if (4 < param_3) {
      local_77 = 0;
      iVar4 = _libssh2_ntohu32(param_2 + 1);
      if (iVar4 + 6 <= param_3) {
        local_77 = param_2[iVar4 + 5];
      }
      if (local_77 != 0) {
LAB_0012c961:
        *(undefined4 *)(param_1 + 0xd2b8) = 0xf;
        iVar4 = _libssh2_transport_send(param_1,&packet_20245,1,0,0);
        if (iVar4 == -0x25) {
          uVar7 = 0xffffffdb;
          break;
        }
      }
    }
    (**(code **)(param_1 + 0x18))(param_2,param_1);
    *(undefined4 *)(param_1 + 0xd2b8) = 0;
    uVar7 = 0;
    break;
  default:
    goto LAB_0012d1f0;
  case 0x5a:
    if (0x10 < param_3) {
      if (((param_3 < 0x14) || (iVar4 = _libssh2_ntohu32(param_2 + 1), iVar4 != 0xf)) ||
         (iVar4 = memcmp(param_2 + 5,"forwarded-tcpip",0xf), iVar4 != 0)) {
        if (((7 < param_3) && (iVar4 = _libssh2_ntohu32(param_2 + 1), iVar4 == 3)) &&
           (iVar4 = memcmp(param_2 + 5,&DAT_00147426,3), iVar4 == 0)) {
          memset((void *)(param_1 + 0xd330),0,0x58);
LAB_0012d0f5:
          *(undefined4 *)(param_1 + 0xd2b8) = 0xd;
          local_74 = packet_x11_open(param_1,param_2,param_3,param_1 + 0xd330);
        }
      }
      else {
        memset((void *)(param_1 + 0xd2c8),0,0x68);
LAB_0012d05b:
        *(undefined4 *)(param_1 + 0xd2b8) = 0xc;
        local_74 = packet_queue_listener(param_1,param_2,param_3,param_1 + 0xd2c8);
      }
    }
    if (local_74 == 0xffffffdb) {
      uVar7 = 0xffffffdb;
    }
    else {
      (**(code **)(param_1 + 0x18))(param_2,param_1);
      *(undefined4 *)(param_1 + 0xd2b8) = 0;
      uVar7 = (ulong)local_74;
    }
    break;
  case 0x5d:
    if (8 < param_3) {
      iVar4 = _libssh2_ntohu32(param_2 + 5);
      uVar2 = _libssh2_ntohu32(param_2 + 1);
      lVar6 = _libssh2_channel_locate(param_1,uVar2);
      if (lVar6 != 0) {
        *(int *)(lVar6 + 0x38) = *(int *)(lVar6 + 0x38) + iVar4;
      }
    }
    (**(code **)(param_1 + 0x18))(param_2,param_1);
    *(undefined4 *)(param_1 + 0xd2b8) = 0;
    uVar7 = 0;
    break;
  case 0x5e:
    goto switchD_0012c5c2_caseD_5e;
  case 0x5f:
    local_30 = 4;
switchD_0012c5c2_caseD_5e:
    local_30 = local_30 + 9;
    if (local_30 <= param_3) {
      uVar2 = _libssh2_ntohu32(param_2 + 1);
      local_38 = _libssh2_channel_locate(param_1,uVar2);
    }
    if (local_38 == 0) {
      _libssh2_error(param_1,0xffffffe9,"Packet received for unknown channel");
      (**(code **)(param_1 + 0x18))(param_2,param_1);
      *(undefined4 *)(param_1 + 0xd2b8) = 0;
      uVar7 = 0;
    }
    else if ((*(char *)(local_38 + 0x56) == '\x01') && (bVar1 == 0x5f)) {
      (**(code **)(param_1 + 0x18))(param_2,param_1);
      if ((ulong)*(uint *)(local_38 + 0x4c) <= (param_3 + *(uint *)(local_38 + 0x5c)) - local_30) {
        local_90 = local_30 + (uint)(*(int *)(local_38 + 0x4c) - *(int *)(local_38 + 0x5c));
      }
      *(int *)(local_38 + 0x4c) = ((int)local_30 - (int)local_90) + *(int *)(local_38 + 0x4c);
      *(long *)(param_1 + 0xd2c0) = local_38;
LAB_0012cb0c:
      *(undefined4 *)(param_1 + 0xd2b8) = 0xb;
      iVar4 = _libssh2_channel_receive_window_adjust
                        (*(undefined8 *)(param_1 + 0xd2c0),(int)local_90 + -0xd,1,0);
      if (iVar4 == -0x25) {
        uVar7 = 0xffffffdb;
      }
      else {
        *(undefined4 *)(param_1 + 0xd2b8) = 0;
        uVar7 = 0;
      }
    }
    else {
      if ((ulong)*(uint *)(local_38 + 0x50) < param_3 - local_30) {
        _libssh2_error(param_1,0xffffffe7,
                       "Packet contains more data than we offered to receive, truncating");
        local_90 = local_30 + *(uint *)(local_38 + 0x50);
      }
      if (*(uint *)(local_38 + 0x5c) < *(uint *)(local_38 + 0x4c)) {
        *(undefined *)(local_38 + 0x55) = 0;
        if ((ulong)*(uint *)(local_38 + 0x4c) < (local_90 + *(uint *)(local_38 + 0x5c)) - local_30)
        {
          _libssh2_error(param_1,0xffffffe8,
                         "Remote sent more data than current window allows, truncating");
          local_90 = local_30 + (uint)(*(int *)(local_38 + 0x4c) - *(int *)(local_38 + 0x5c));
        }
        *(int *)(local_38 + 0x5c) = ((int)local_90 - (int)local_30) + *(int *)(local_38 + 0x5c);
LAB_0012d1f0:
        *(undefined4 *)(param_1 + 0xd2b8) = 3;
LAB_0012d1fe:
        if (*(int *)(param_1 + 0xd2b8) == 3) {
          lVar6 = (**(code **)(param_1 + 8))(0x30,param_1);
          if (lVar6 == 0) {
            (**(code **)(param_1 + 0x18))(param_2,param_1);
            *(undefined4 *)(param_1 + 0xd2b8) = 0;
            uVar7 = 0xfffffffa;
            break;
          }
          *(byte **)(lVar6 + 0x18) = param_2;
          *(ulong *)(lVar6 + 0x20) = local_90;
          *(ulong *)(lVar6 + 0x28) = local_30;
          _libssh2_list_add(param_1 + 0x1f0,lVar6);
          *(undefined4 *)(param_1 + 0xd2b8) = 4;
        }
        if (((bVar1 == 0x14) && ((*(uint *)(param_1 + 0x68) & 1) == 0)) ||
           (*(int *)(param_1 + 0xd2b8) == 5)) {
          if (*(int *)(param_1 + 0xd2b8) == 4) {
            *(undefined4 *)(param_1 + 0xd2b8) = 5;
          }
          *(undefined4 *)(param_1 + 0xd090) = 0;
          *(undefined8 *)(param_1 + 0x4270) = 0;
          *(undefined4 *)(param_1 + 0xd2b8) = 0;
          *(undefined4 *)(param_1 + 0xd388) = 0;
          memset((void *)(param_1 + 0xccd0),0,0x2a0);
          iVar4 = _libssh2_kex_exchange(param_1,1,param_1 + 0xccd0);
          if (iVar4 == -0x25) {
            uVar7 = 0xffffffdb;
            break;
          }
        }
        *(undefined4 *)(param_1 + 0xd2b8) = 0;
        uVar7 = 0;
      }
      else {
        _libssh2_error(param_1,0xffffffe8,"The current receive window is full, data ignored");
        (**(code **)(param_1 + 0x18))(param_2,param_1);
        *(undefined4 *)(param_1 + 0xd2b8) = 0;
        uVar7 = 0;
      }
    }
    break;
  case 0x60:
    if (4 < param_3) {
      uVar2 = _libssh2_ntohu32(param_2 + 1);
      local_38 = _libssh2_channel_locate(param_1,uVar2);
    }
    if (local_38 != 0) {
      *(undefined *)(local_38 + 0x55) = 1;
    }
    (**(code **)(param_1 + 0x18))(param_2,param_1);
    *(undefined4 *)(param_1 + 0xd2b8) = 0;
    uVar7 = 0;
    break;
  case 0x61:
    if (4 < param_3) {
      uVar2 = _libssh2_ntohu32(param_2 + 1);
      local_38 = _libssh2_channel_locate(param_1,uVar2);
    }
    if (local_38 == 0) {
      (**(code **)(param_1 + 0x18))(param_2,param_1);
      *(undefined4 *)(param_1 + 0xd2b8) = 0;
      uVar7 = 0;
    }
    else {
      *(undefined *)(local_38 + 0x54) = 1;
      *(undefined *)(local_38 + 0x55) = 1;
      (**(code **)(param_1 + 0x18))(param_2,param_1);
      *(undefined4 *)(param_1 + 0xd2b8) = 0;
      uVar7 = 0;
    }
    break;
  case 0x62:
    if (8 < param_3) {
      uVar2 = _libssh2_ntohu32(param_2 + 1);
      uVar3 = _libssh2_ntohu32(param_2 + 5);
      local_76 = 1;
      if ((ulong)uVar3 < param_3 - 10) {
        local_76 = param_2[uVar3 + 9];
      }
      if ((uVar3 == 0xb) && (iVar4 = memcmp("exit-status",param_2 + 9,0xb), iVar4 == 0)) {
        if (0x13 < param_3) {
          local_38 = _libssh2_channel_locate(param_1,uVar2);
        }
        if (local_38 != 0) {
          uVar2 = _libssh2_ntohu32(param_2 + 0x15);
          *(undefined4 *)(local_38 + 0x24) = uVar2;
        }
      }
      else if ((uVar3 == 0xb) && (iVar4 = memcmp("exit-signal",param_2 + 9,0xb), iVar4 == 0)) {
        if (0x13 < param_3) {
          local_38 = _libssh2_channel_locate(param_1,uVar2);
        }
        if (local_38 != 0) {
          uVar3 = _libssh2_ntohu32(param_2 + 0x15);
          uVar5 = (**(code **)(param_1 + 8))(uVar3 + 1,param_1);
          *(undefined8 *)(local_38 + 0x28) = uVar5;
          if (*(long *)(local_38 + 0x28) == 0) {
            local_74 = _libssh2_error(param_1,0xfffffffa,"memory for signal name");
          }
          else {
            memcpy(*(void **)(local_38 + 0x28),param_2 + 0x19,(ulong)uVar3);
            *(undefined *)((ulong)uVar3 + *(long *)(local_38 + 0x28)) = 0;
          }
        }
      }
      if (local_76 != 0) {
LAB_0012cec8:
        *(undefined4 *)(param_1 + 0xd2b8) = 0xe;
        local_15 = 100;
        local_14 = *(undefined4 *)(param_2 + 1);
        local_74 = _libssh2_transport_send(param_1,&local_15,5,0,0);
        if (local_74 == 0xffffffdb) {
          uVar7 = 0xffffffdb;
          break;
        }
      }
    }
    (**(code **)(param_1 + 0x18))(param_2,param_1);
    *(undefined4 *)(param_1 + 0xd2b8) = 0;
    uVar7 = (ulong)local_74;
  }
LAB_0012d387:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar7;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8
_libssh2_packet_ask(long param_1,char param_2,undefined8 *param_3,undefined8 *param_4,int param_5,
                   void *param_6,size_t param_7)

{
  int iVar1;
  long local_10;
  
  local_10 = _libssh2_list_first(param_1 + 0x1f0);
  while( true ) {
    if (local_10 == 0) {
      return 0xffffffff;
    }
    if (((param_2 == **(char **)(local_10 + 0x18)) &&
        (param_7 + (long)param_5 <= *(ulong *)(local_10 + 0x20))) &&
       ((param_6 == (void *)0x0 ||
        (iVar1 = memcmp((void *)(*(long *)(local_10 + 0x18) + (long)param_5),param_6,param_7),
        iVar1 == 0)))) break;
    local_10 = _libssh2_list_next(local_10);
  }
  *param_3 = *(undefined8 *)(local_10 + 0x18);
  *param_4 = *(undefined8 *)(local_10 + 0x20);
  _libssh2_list_remove(local_10);
  (**(code **)(param_1 + 0x18))(local_10,param_1);
  return 0;
}



undefined8
_libssh2_packet_askv
          (undefined8 param_1,char *param_2,undefined8 param_3,undefined8 param_4,undefined4 param_5
          ,undefined8 param_6,undefined8 param_7)

{
  int iVar1;
  size_t sVar2;
  int local_10;
  
  sVar2 = strlen(param_2);
  local_10 = 0;
  while( true ) {
    if ((int)sVar2 <= local_10) {
      return 0xffffffff;
    }
    iVar1 = _libssh2_packet_ask(param_1,param_2[local_10],param_3,param_4,param_5,param_6,param_7);
    if (iVar1 == 0) break;
    local_10 = local_10 + 1;
  }
  return 0;
}



uint _libssh2_packet_require
               (long param_1,byte param_2,undefined8 param_3,undefined8 param_4,undefined4 param_5,
               undefined8 param_6,undefined8 param_7,long param_8)

{
  int iVar1;
  uint uVar2;
  time_t tVar3;
  
  if (*(long *)(param_8 + 8) == 0) {
    iVar1 = _libssh2_packet_ask(param_1,param_2,param_3,param_4,param_5,param_6,param_7);
    if (iVar1 == 0) {
      return 0;
    }
    tVar3 = time((time_t *)0x0);
    *(time_t *)(param_8 + 8) = tVar3;
  }
  while( true ) {
    if (*(int *)(param_1 + 0x22c) != 0) {
      return 0xfffffff3;
    }
    uVar2 = _libssh2_transport_read(param_1);
    if (uVar2 == 0xffffffdb) {
      return 0xffffffdb;
    }
    if ((int)uVar2 < 0) {
      *(undefined8 *)(param_8 + 8) = 0;
      return uVar2;
    }
    if (uVar2 == param_2) break;
    if (uVar2 == 0) {
      tVar3 = time((time_t *)0x0);
      if (0x3c - (tVar3 - *(long *)(param_8 + 8)) < 1) {
        *(undefined8 *)(param_8 + 8) = 0;
        uVar2 = 0xfffffff7;
      }
      else {
        uVar2 = 0xffffffff;
      }
      return uVar2;
    }
  }
  uVar2 = _libssh2_packet_ask(param_1,param_2,param_3,param_4,param_5,param_6,param_7);
  *(undefined8 *)(param_8 + 8) = 0;
  return uVar2;
}



uint _libssh2_packet_burn(long param_1,int *param_2)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  long in_FS_OFFSET;
  byte local_12d;
  byte *local_128;
  undefined local_120 [8];
  byte local_118 [254];
  undefined local_1a;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_2 == 0) {
    for (local_12d = 1; local_12d != 0xff; local_12d = local_12d + 1) {
      local_118[(int)(local_12d - 1)] = local_12d;
    }
    local_1a = 0;
    iVar2 = _libssh2_packet_askv(param_1,local_118,&local_128,local_120,0,0,0);
    if (iVar2 == 0) {
      bVar1 = *local_128;
      (**(code **)(param_1 + 0x18))(local_128,param_1);
      uVar3 = (uint)bVar1;
      goto LAB_0012d8a0;
    }
    *param_2 = 2;
  }
  do {
    if (*(int *)(param_1 + 0x22c) != 0) {
      uVar3 = 0xfffffff3;
      goto LAB_0012d8a0;
    }
    uVar3 = _libssh2_transport_read(param_1);
    if (uVar3 == 0xffffffdb) goto LAB_0012d8a0;
    if ((int)uVar3 < 0) {
      *param_2 = 0;
      goto LAB_0012d8a0;
    }
  } while ((uVar3 == 0) ||
          (iVar2 = _libssh2_packet_ask(param_1,uVar3 & 0xff,&local_128,local_120,0,0,0), iVar2 != 0)
          );
  (**(code **)(param_1 + 0x18))(local_128,param_1);
  *param_2 = 0;
LAB_0012d8a0:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong _libssh2_packet_requirev
                (long param_1,char *param_2,undefined8 param_3,undefined8 param_4,undefined4 param_5
                ,undefined8 param_6,undefined8 param_7,long *param_8)

{
  int iVar1;
  uint __c;
  ulong uVar2;
  time_t tVar3;
  char *pcVar4;
  
  iVar1 = _libssh2_packet_askv(param_1,param_2,param_3,param_4,param_5,param_6,param_7);
  if (iVar1 == 0) {
    *param_8 = 0;
    uVar2 = 0;
  }
  else {
    if (*param_8 == 0) {
      tVar3 = time((time_t *)0x0);
      *param_8 = tVar3;
    }
    do {
      if (*(int *)(param_1 + 0x22c) == -1) {
        *param_8 = 0;
        return 0xfffffff3;
      }
      __c = _libssh2_transport_read(param_1);
      if (((int)__c < 0) && (__c != 0xffffffdb)) {
        *param_8 = 0;
        return (ulong)__c;
      }
      if ((int)__c < 1) {
        tVar3 = time((time_t *)0x0);
        if (0x3c - (tVar3 - *param_8) < 1) {
          *param_8 = 0;
          return 0xfffffff7;
        }
        if (__c == 0xffffffdb) {
          return 0xffffffdb;
        }
      }
      pcVar4 = strchr(param_2,__c);
    } while (pcVar4 == (char *)0x0);
    uVar2 = _libssh2_packet_askv(param_1,param_2,param_3,param_4,param_5,param_6,param_7);
  }
  return uVar2;
}



undefined8 readline(char *param_1,int param_2,FILE *param_3)

{
  undefined8 uVar1;
  char *pcVar2;
  size_t sVar3;
  
  if (param_1 == (char *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    pcVar2 = fgets(param_1,param_2,param_3);
    if (pcVar2 == (char *)0x0) {
      uVar1 = 0xffffffff;
    }
    else {
      if (*param_1 != '\0') {
        sVar3 = strlen(param_1);
        if ((sVar3 != 0) && (param_1[sVar3 - 1] == '\n')) {
          param_1[sVar3 - 1] = '\0';
        }
      }
      if (*param_1 != '\0') {
        sVar3 = strlen(param_1);
        if ((sVar3 != 0) && (param_1[sVar3 - 1] == '\r')) {
          param_1[sVar3 - 1] = '\0';
        }
      }
      uVar1 = 0;
    }
  }
  return uVar1;
}



undefined8 readline_memory(void *param_1,long param_2,long param_3,ulong param_4,long *param_5)

{
  long lVar1;
  undefined8 local_18;
  
  lVar1 = *param_5;
  for (local_18 = 0;
      (((local_18 + lVar1 < param_4 && (local_18 < param_2 - 1U)) &&
       (*(char *)(param_3 + lVar1 + local_18) != '\n')) &&
      (*(char *)(param_3 + lVar1 + local_18) != '\r')); local_18 = local_18 + 1) {
  }
  if (local_18 != 0) {
    memcpy(param_1,(void *)(param_3 + lVar1),local_18);
    *param_5 = *param_5 + local_18;
  }
  *(undefined *)(local_18 + (long)param_1) = 0;
  *param_5 = *param_5 + 1;
  return 0;
}



int hex_decode(byte param_1)

{
  int iVar1;
  
  if ((char)param_1 < 'A') {
    iVar1 = param_1 - 0x30;
  }
  else {
    iVar1 = param_1 - 0x37;
  }
  return iVar1;
}



undefined4
_libssh2_pem_parse(long param_1,char *param_2,char *param_3,char *param_4,undefined8 param_5,
                  long *param_6,uint *param_7)

{
  long *plVar1;
  byte bVar2;
  int iVar3;
  undefined4 uVar4;
  size_t sVar5;
  long in_FS_OFFSET;
  undefined4 local_1a8;
  int local_1a4;
  uint local_1a0;
  undefined4 local_19c;
  int local_198;
  int local_194;
  uint local_190;
  uint local_18c;
  undefined local_188 [8];
  EVP_MD_CTX *local_180;
  long local_178;
  long local_170;
  long *local_168;
  long local_160;
  size_t local_158;
  long local_150;
  uchar local_148 [16];
  uchar auStack_138 [16];
  char local_128;
  undefined auStack_127 [127];
  byte local_a8 [136];
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_178 = 0;
  local_1a0 = 0;
  local_170 = 0;
  do {
    local_128 = '\0';
    iVar3 = readline(&local_128,0x80,param_5);
    if (iVar3 != 0) {
      uVar4 = 0xffffffff;
      goto LAB_0012e5ce;
    }
    iVar3 = strcmp(&local_128,param_2);
  } while (iVar3 != 0);
  iVar3 = readline(&local_128,0x80,param_5);
  if (iVar3 != 0) {
    uVar4 = 0xffffffff;
    goto LAB_0012e5ce;
  }
  if (param_4 == (char *)0x0) {
LAB_0012df3c:
    do {
      if (local_128 != '\0') {
        local_158 = strlen(&local_128);
        if (local_178 == 0) {
          local_150 = (**(code **)(param_1 + 8))(local_158 + local_1a0,param_1);
        }
        else {
          local_150 = (**(code **)(param_1 + 0x10))(local_178,local_1a0 + local_158,param_1);
        }
        if (local_150 == 0) {
          local_19c = 0xffffffff;
          goto LAB_0012e585;
        }
        memcpy((void *)((ulong)local_1a0 + local_150),&local_128,local_158);
        local_178 = local_150;
        local_1a0 = local_1a0 + (int)local_158;
      }
      local_128 = '\0';
      iVar3 = readline(&local_128,0x80,param_5);
      if (iVar3 != 0) {
        local_19c = 0xffffffff;
        goto LAB_0012e585;
      }
      iVar3 = strcmp(&local_128,param_3);
    } while (iVar3 != 0);
    if (local_178 == 0) {
      uVar4 = 0xffffffff;
      goto LAB_0012e5ce;
    }
    iVar3 = libssh2_base64_decode(param_1,param_6,param_7,local_178,local_1a0);
    if (iVar3 == 0) {
      if (local_170 == 0) {
LAB_0012e57b:
        local_19c = 0;
      }
      else {
        local_1a8 = 0;
        local_1a4 = 0;
        local_194 = 0;
        local_190 = 0;
        local_18c = *(uint *)(local_170 + 0x10);
        iVar3 = _libssh2_md5_init(&local_180);
        if (iVar3 == 0) {
          local_19c = 0xffffffff;
        }
        else {
          sVar5 = strlen(param_4);
          EVP_DigestUpdate(local_180,param_4,sVar5);
          EVP_DigestUpdate(local_180,local_a8,8);
          EVP_DigestFinal(local_180,local_148,(uint *)0x0);
          EVP_MD_CTX_free(local_180);
          if (0x10 < *(int *)(local_170 + 0x18)) {
            iVar3 = _libssh2_md5_init(&local_180);
            if (iVar3 == 0) {
              local_19c = 0xffffffff;
              goto LAB_0012e585;
            }
            EVP_DigestUpdate(local_180,local_148,0x10);
            sVar5 = strlen(param_4);
            EVP_DigestUpdate(local_180,param_4,sVar5);
            EVP_DigestUpdate(local_180,local_a8,8);
            EVP_DigestFinal(local_180,auStack_138,(uint *)0x0);
            EVP_MD_CTX_free(local_180);
          }
          iVar3 = (**(code **)(local_170 + 0x28))
                            (param_1,local_170,local_a8,&local_1a8,local_148,&local_1a4,0,local_188)
          ;
          if (iVar3 == 0) {
            if (local_1a4 != 0) {
              _libssh2_explicit_zero(local_148,0x20);
            }
            if (*param_7 % local_18c == 0) {
              for (; local_194 <= (int)(*param_7 - local_18c); local_194 = local_194 + local_18c) {
                iVar3 = (**(code **)(local_170 + 0x30))
                                  (param_1,*param_6 + (long)local_194,(long)(int)local_18c,local_188
                                  );
                if (iVar3 != 0) {
                  local_19c = 0xfffffff4;
                  _libssh2_explicit_zero(local_148,0x20);
                  (**(code **)(local_170 + 0x38))(param_1,local_188);
                  _libssh2_explicit_zero(*param_6,*param_7);
                  (**(code **)(param_1 + 0x18))(*param_6,param_1);
                  goto LAB_0012e585;
                }
              }
              local_190 = (uint)*(byte *)((ulong)(*param_7 - 1) + *param_6);
              memset((void *)(*param_6 + (ulong)(*param_7 - local_190)),0,(long)(int)local_190);
              *param_7 = *param_7 - local_190;
              _libssh2_explicit_zero(local_148,0x20);
              (**(code **)(local_170 + 0x38))(param_1,local_188);
              goto LAB_0012e57b;
            }
            _libssh2_explicit_zero(local_148,0x20);
            (**(code **)(local_170 + 0x38))(param_1,local_188);
            _libssh2_explicit_zero(*param_6,*param_7);
            (**(code **)(param_1 + 0x18))(*param_6,param_1);
            local_19c = 0xffffffff;
          }
          else {
            _libssh2_explicit_zero(local_148,0x20);
            (**(code **)(param_1 + 0x18))(param_6,param_1);
            local_19c = 0xffffffff;
          }
        }
      }
    }
    else {
      local_19c = 0xffffffff;
    }
  }
  else {
    sVar5 = strlen(crypt_annotation);
    iVar3 = memcmp(&local_128,crypt_annotation,sVar5);
    if (iVar3 != 0) goto LAB_0012df3c;
    iVar3 = readline(&local_128,0x80,param_5);
    if (iVar3 == 0) {
      local_168 = (long *)libssh2_crypt_methods();
      while( true ) {
        plVar1 = local_168 + 1;
        local_160 = *local_168;
        local_168 = plVar1;
        if (local_160 == 0) break;
        if (**(char **)(local_160 + 8) != '\0') {
          sVar5 = strlen(*(char **)(local_160 + 8));
          iVar3 = memcmp(&local_128,*(void **)(local_160 + 8),sVar5);
          if (iVar3 == 0) {
            local_170 = local_160;
            iVar3 = *(int *)(local_160 + 0x14);
            sVar5 = strlen(*(char **)(local_160 + 8));
            memcpy(local_a8,auStack_127 + sVar5,(long)(iVar3 * 2));
          }
        }
      }
      local_160 = 0;
      if (local_170 == 0) {
        uVar4 = 0xffffffff;
        goto LAB_0012e5ce;
      }
      for (local_198 = 0; local_198 < *(int *)(local_170 + 0x14); local_198 = local_198 + 1) {
        iVar3 = hex_decode((int)(char)local_a8[local_198 * 2]);
        local_a8[local_198] = (byte)(iVar3 << 4);
        bVar2 = hex_decode((int)(char)local_a8[local_198 * 2 + 1]);
        local_a8[local_198] = bVar2 | local_a8[local_198];
      }
      iVar3 = readline(&local_128,0x80,param_5);
      if (iVar3 == 0) goto LAB_0012df3c;
      local_19c = 0xffffffff;
    }
    else {
      local_19c = 0xffffffff;
    }
  }
LAB_0012e585:
  uVar4 = local_19c;
  if (local_178 != 0) {
    _libssh2_explicit_zero(local_178,local_1a0);
    (**(code **)(param_1 + 0x18))(local_178,param_1);
    uVar4 = local_19c;
  }
LAB_0012e5ce:
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined4
_libssh2_pem_parse_memory
          (long param_1,char *param_2,char *param_3,undefined8 param_4,undefined8 param_5,
          undefined8 param_6,undefined8 param_7)

{
  int iVar1;
  long in_FS_OFFSET;
  uint local_c0;
  undefined4 local_bc;
  undefined8 local_b8;
  long local_b0;
  size_t local_a8;
  long local_a0;
  char local_98 [136];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_b0 = 0;
  local_c0 = 0;
  local_b8 = 0;
  do {
    local_98[0] = '\0';
    iVar1 = readline_memory(local_98,0x80,param_4,param_5,&local_b8);
    if (iVar1 != 0) {
      local_bc = 0xffffffff;
      goto LAB_0012e8b6;
    }
    iVar1 = strcmp(local_98,param_2);
  } while (iVar1 != 0);
  local_98[0] = '\0';
  do {
    if (local_98[0] != '\0') {
      local_a8 = strlen(local_98);
      if (local_b0 == 0) {
        local_a0 = (**(code **)(param_1 + 8))(local_a8 + local_c0,param_1);
      }
      else {
        local_a0 = (**(code **)(param_1 + 0x10))(local_b0,local_c0 + local_a8,param_1);
      }
      if (local_a0 == 0) {
        local_bc = 0xffffffff;
        goto LAB_0012e86d;
      }
      memcpy((void *)((ulong)local_c0 + local_a0),local_98,local_a8);
      local_b0 = local_a0;
      local_c0 = local_c0 + (int)local_a8;
    }
    local_98[0] = '\0';
    iVar1 = readline_memory(local_98,0x80,param_4,param_5,&local_b8);
    if (iVar1 != 0) {
      local_bc = 0xffffffff;
      goto LAB_0012e86d;
    }
    iVar1 = strcmp(local_98,param_3);
  } while (iVar1 != 0);
  if (local_b0 == 0) {
    local_bc = 0xffffffff;
  }
  else {
    iVar1 = libssh2_base64_decode(param_1,param_6,param_7,local_b0,local_c0);
    if (iVar1 == 0) {
      local_bc = 0;
    }
    else {
      local_bc = 0xffffffff;
    }
LAB_0012e86d:
    if (local_b0 != 0) {
      _libssh2_explicit_zero(local_b0,local_c0);
      (**(code **)(param_1 + 0x18))(local_b0,param_1);
    }
  }
LAB_0012e8b6:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_bc;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Type propagation algorithm not settling

undefined4
_libssh2_openssh_pem_parse_data
          (long param_1,char *param_2,undefined8 param_3,undefined4 param_4,undefined8 *param_5)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  uint uVar3;
  undefined8 uVar4;
  int iVar5;
  size_t sVar6;
  long lVar7;
  long in_FS_OFFSET;
  int local_140;
  undefined4 local_13c;
  uint local_138 [11];
  int local_10c;
  char *local_108;
  char *local_100;
  long local_f8;
  void *local_f0;
  undefined8 local_e8;
  char *local_e0;
  undefined8 local_d8;
  undefined8 *local_d0;
  void *local_c8;
  void *local_c0;
  void *local_b8;
  undefined8 *local_b0;
  undefined8 *local_a8;
  long *local_a0;
  char *local_98;
  char *local_90;
  ulong local_88;
  void *local_78;
  void *local_70;
  ulong local_68;
  long local_58;
  long local_50;
  long local_48;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  local_d0 = (undefined8 *)0x0;
  local_108 = (char *)0x0;
  local_100 = (char *)0x0;
  local_f8 = 0;
  local_f0 = (void *)0x0;
  local_e8 = 0;
  local_13c = 0;
  local_c8 = (void *)0x0;
  local_c0 = (void *)0x0;
  local_b8 = (void *)0x0;
  local_e0 = (char *)0x0;
  local_138[0] = 0;
  local_138[3] = 0;
  local_138[8] = 0;
  local_138[9] = 0;
  local_138[4] = 0;
  local_138[5] = 0;
  local_138[6] = 0;
  if (param_5 != (undefined8 *)0x0) {
    *param_5 = 0;
  }
  iVar5 = libssh2_base64_decode(param_1,&local_e0,local_138,param_3,param_4);
  if (iVar5 != 0) {
    local_138[3] = 0xffffffff;
    goto LAB_0012f518;
  }
  local_98 = local_e0;
  local_90 = local_e0;
  local_88 = (ulong)local_138[0];
  if (local_88 < 0xe) {
    local_138[3] = _libssh2_error(param_1,0xfffffff2,"key too short");
    goto LAB_0012f518;
  }
  iVar5 = strncmp(local_e0,"openssh-key-v1",0xe);
  if (iVar5 != 0) {
    local_138[3] = _libssh2_error(param_1,0xfffffff2,"key auth magic mismatch");
    goto LAB_0012f518;
  }
  local_90 = local_90 + 0xf;
  iVar5 = _libssh2_get_c_string(&local_98,&local_108);
  if (iVar5 == 0) {
    local_138[3] = _libssh2_error(param_1,0xfffffff2,"ciphername is missing");
    goto LAB_0012f518;
  }
  iVar5 = _libssh2_get_c_string(&local_98,&local_100);
  if (iVar5 == 0) {
    local_138[3] = _libssh2_error(param_1,0xfffffff2,"kdfname is missing");
    goto LAB_0012f518;
  }
  local_138[9] = _libssh2_get_c_string(&local_98,&local_f8);
  if (local_f8 == 0) {
    local_138[3] = _libssh2_error(param_1,0xfffffff2,"kdf is missing");
    goto LAB_0012f518;
  }
  local_58 = local_f8;
  local_50 = local_f8;
  local_48 = (long)(int)local_138[9];
  if ((param_2 == (char *)0x0) || (*param_2 == '\0')) {
    iVar5 = strcmp(local_108,"none");
    if (iVar5 != 0) {
      local_138[3] = 0xffffffd0;
      goto LAB_0012f518;
    }
  }
  iVar5 = strcmp(local_100,"none");
  if (iVar5 != 0) {
    iVar5 = strcmp(local_100,"bcrypt");
    if (iVar5 != 0) {
      local_138[3] = _libssh2_error(param_1,0xfffffff2,"unknown cipher");
      goto LAB_0012f518;
    }
  }
  iVar5 = strcmp(local_100,"none");
  if (iVar5 == 0) {
    iVar5 = strcmp(local_108,"none");
    if (iVar5 != 0) {
      local_138[3] = _libssh2_error(param_1,0xfffffff2,"invalid format");
      goto LAB_0012f518;
    }
  }
  iVar5 = _libssh2_get_u32(&local_98,&local_140);
  if ((iVar5 != 0) || (local_140 != 1)) {
    local_138[3] = _libssh2_error(param_1,0xfffffff2,"Multiple keys are unsupported");
    goto LAB_0012f518;
  }
  iVar5 = _libssh2_get_c_string(&local_98,&local_f0);
  if (iVar5 < 0) {
    local_138[3] = _libssh2_error(param_1,0xfffffff2,
                                  "Invalid private key; expect embedded public key");
    goto LAB_0012f518;
  }
  local_138[8] = _libssh2_get_c_string(&local_98,&local_f0);
  if ((int)local_138[8] < 1) {
    local_138[3] = _libssh2_error(param_1,0xfffffff2,"Private key data not found");
    goto LAB_0012f518;
  }
  local_70 = local_f0;
  local_78 = local_f0;
  local_68 = (ulong)(int)local_138[8];
  if (local_108 != (char *)0x0) {
    iVar5 = strcmp(local_108,"none");
    if (iVar5 != 0) {
      local_b0 = (undefined8 *)libssh2_crypt_methods();
      while( true ) {
        puVar1 = local_b0 + 1;
        local_a8 = (undefined8 *)*local_b0;
        local_b0 = puVar1;
        if (local_a8 == (undefined8 *)0x0) break;
        if (*(char *)*local_a8 != '\0') {
          sVar6 = strlen((char *)*local_a8);
          iVar5 = memcmp(local_108,(void *)*local_a8,sVar6);
          if (iVar5 == 0) {
            local_d0 = local_a8;
          }
        }
      }
      if (local_d0 == (undefined8 *)0x0) {
        local_138[3] = _libssh2_error(param_1,0xfffffff2,"No supported cipher found");
        goto LAB_0012f518;
      }
    }
  }
  if (local_d0 == (undefined8 *)0x0) {
LAB_0012f385:
    iVar5 = _libssh2_get_u32(&local_78,local_138 + 2);
    if (iVar5 == 0) {
      iVar5 = _libssh2_get_u32(&local_78,&local_d8);
      if ((iVar5 == 0) && (local_138[2] == (int)local_d8)) {
        if (param_5 != (undefined8 *)0x0) {
          local_a0 = (long *)_libssh2_string_buf_new(param_1);
          if (local_a0 == (long *)0x0) {
            local_138[3] = _libssh2_error(param_1,0xfffffffa,
                                          "Unable to allocate memory for decrypted struct");
          }
          else {
            lVar7 = _libssh2_calloc(param_1,local_68);
            *local_a0 = lVar7;
            if (*local_a0 == 0) {
              local_138[3] = _libssh2_error(param_1,0xfffffffa,
                                            "Unable to allocate memory for decrypted struct");
              _libssh2_string_buf_free(param_1,local_a0);
            }
            else {
              memcpy((void *)*local_a0,local_78,local_68);
              local_a0[1] = (long)local_70 + (*local_a0 - (long)local_78);
              local_a0[2] = local_68;
              *param_5 = local_a0;
            }
          }
        }
        goto LAB_0012f518;
      }
    }
    _libssh2_error(param_1,0xfffffff2,"Private key unpack failed (correct password?)");
    local_138[3] = 0xffffffd0;
  }
  else {
    local_138[1] = 0;
    local_138[2] = 0;
    local_138[7] = 0;
    local_d8 = 0;
    local_138[4] = *(uint *)(local_d0 + 3);
    local_138[5] = *(int *)((long)local_d0 + 0x14);
    local_138[6] = local_138[5] + local_138[4];
    local_c8 = (void *)_libssh2_calloc(param_1,(long)(int)local_138[6]);
    if (local_c8 == (void *)0x0) {
      local_138[3] = _libssh2_error(param_1,0xfffffff2,"Could not alloc key");
      goto LAB_0012f518;
    }
    iVar5 = strcmp(local_100,"bcrypt");
    if ((iVar5 != 0) || (param_2 == (char *)0x0)) {
      local_138[3] = _libssh2_error(param_1,0xffffffd0,"bcrypted without passphrase");
      (**(code **)(param_1 + 0x18))(local_c8,param_1);
      goto LAB_0012f518;
    }
    local_138[10] = _libssh2_get_c_string(&local_58,&local_e8);
    if (local_138[10] != 0) {
      iVar5 = _libssh2_get_u32(&local_58,&local_13c);
      uVar4 = local_e8;
      uVar3 = local_138[10];
      uVar2 = local_13c;
      if (iVar5 == 0) {
        iVar5 = local_138[5] + local_138[4];
        sVar6 = strlen(param_2);
        iVar5 = _libssh2_bcrypt_pbkdf(param_2,sVar6,uVar4,uVar3,local_c8,(long)iVar5,uVar2);
        if (iVar5 < 0) {
          local_138[3] = _libssh2_error(param_1,0xfffffff4,"invalid format");
          (**(code **)(param_1 + 0x18))(local_c8,param_1);
          goto LAB_0012f518;
        }
        local_10c = *(int *)(local_d0 + 2);
        local_c0 = (void *)_libssh2_calloc(param_1,(long)(int)local_138[4]);
        if (local_c0 == (void *)0x0) {
          local_138[3] = _libssh2_error(param_1,0xfffffff2,"Could not alloc key part");
          goto LAB_0012f518;
        }
        local_b8 = (void *)_libssh2_calloc(param_1,(long)(int)local_138[5]);
        if (local_b8 == (void *)0x0) {
          local_138[3] = _libssh2_error(param_1,0xfffffff2,"Could not alloc iv part");
          goto LAB_0012f518;
        }
        memcpy(local_c0,local_c8,(long)(int)local_138[4]);
        memcpy(local_b8,(void *)((long)(int)local_138[4] + (long)local_c8),(long)(int)local_138[5]);
        iVar5 = (*(code *)local_d0[5])
                          (param_1,local_d0,local_b8,local_138 + 1,local_c0,local_138 + 2,0,
                           &local_d8);
        if (iVar5 != 0) {
          local_138[3] = 0xfffffff4;
          goto LAB_0012f518;
        }
        if (local_68 % (ulong)(long)local_10c != 0) {
          (*(code *)local_d0[7])(param_1,&local_d8);
          local_138[3] = 0xfffffff4;
          goto LAB_0012f518;
        }
        for (; (ulong)(long)(int)local_138[7] <= local_68 - (long)local_10c;
            local_138[7] = local_138[7] + local_10c) {
          iVar5 = (*(code *)local_d0[6])
                            (param_1,(long)local_78 + (long)(int)local_138[7],(long)local_10c,
                             &local_d8);
          if (iVar5 != 0) {
            local_138[3] = 0xfffffff4;
            (*(code *)local_d0[7])(param_1,&local_d8);
            goto LAB_0012f518;
          }
        }
        (*(code *)local_d0[7])(param_1,&local_d8);
        goto LAB_0012f385;
      }
    }
    local_138[3] = _libssh2_error(param_1,0xfffffff2,"kdf contains unexpected values");
    (**(code **)(param_1 + 0x18))(local_c8,param_1);
  }
LAB_0012f518:
  if (local_c8 != (void *)0x0) {
    _libssh2_explicit_zero(local_c8,(long)(int)local_138[6]);
    (**(code **)(param_1 + 0x18))(local_c8,param_1);
  }
  if (local_c0 != (void *)0x0) {
    _libssh2_explicit_zero(local_c0,(long)(int)local_138[4]);
    (**(code **)(param_1 + 0x18))(local_c0,param_1);
  }
  if (local_b8 != (void *)0x0) {
    _libssh2_explicit_zero(local_b8,(long)(int)local_138[5]);
    (**(code **)(param_1 + 0x18))(local_b8,param_1);
  }
  if (local_e0 != (char *)0x0) {
    _libssh2_explicit_zero(local_e0,local_138[0]);
    (**(code **)(param_1 + 0x18))(local_e0,param_1);
  }
  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_138[3];
}



undefined4
_libssh2_openssh_pem_parse(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  size_t __n;
  long in_FS_OFFSET;
  uint local_b8;
  undefined4 local_b4;
  long local_b0;
  char local_98 [136];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_b0 = 0;
  local_b8 = 0;
  do {
    local_98[0] = '\0';
    iVar1 = readline(local_98,0x80,param_3);
    if (iVar1 != 0) {
      local_b4 = 0xffffffff;
      goto LAB_0012f8f5;
    }
    iVar1 = strcmp(local_98,"-----BEGIN OPENSSH PRIVATE KEY-----");
  } while (iVar1 != 0);
  iVar1 = readline(local_98,0x80,param_3);
  if (iVar1 == 0) {
    do {
      if (local_98[0] != '\0') {
        __n = strlen(local_98);
        if (local_b0 == 0) {
          local_b0 = (**(code **)(param_1 + 8))(__n + local_b8,param_1);
        }
        else {
          local_b0 = (**(code **)(param_1 + 0x10))(local_b0,local_b8 + __n,param_1);
        }
        if (local_b0 == 0) {
          local_b4 = 0xffffffff;
          goto LAB_0012f8f5;
        }
        memcpy((void *)((ulong)local_b8 + local_b0),local_98,__n);
        local_b8 = local_b8 + (int)__n;
      }
      local_98[0] = '\0';
      iVar1 = readline(local_98,0x80,param_3);
      if (iVar1 != 0) {
        local_b4 = 0xffffffff;
        goto LAB_0012f8f5;
      }
      iVar1 = strcmp(local_98,"-----END OPENSSH PRIVATE KEY-----");
    } while (iVar1 != 0);
    if (local_b0 == 0) {
      local_b4 = 0xffffffff;
    }
    else {
      local_b4 = _libssh2_openssh_pem_parse_data(param_1,param_2,local_b0,local_b8,param_4);
      if (local_b0 != 0) {
        _libssh2_explicit_zero(local_b0,local_b8);
        (**(code **)(param_1 + 0x18))(local_b0,param_1);
      }
    }
  }
  else {
    local_b4 = 0xffffffff;
  }
LAB_0012f8f5:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_b4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined4
_libssh2_openssh_pem_parse_memory
          (long param_1,undefined8 param_2,long param_3,ulong param_4,undefined8 param_5)

{
  int iVar1;
  long in_FS_OFFSET;
  uint local_c0;
  undefined4 local_bc;
  ulong local_b8;
  long local_b0;
  size_t local_a8;
  long local_a0;
  char local_98 [136];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_b0 = 0;
  local_c0 = 0;
  local_b8 = 0;
  if ((param_3 == 0) || (param_4 == 0)) {
    local_bc = 0xffffffff;
  }
  else {
    do {
      local_98[0] = '\0';
      if (param_4 <= local_b8) {
        local_bc = 0xffffffff;
        goto LAB_0012fc01;
      }
      iVar1 = readline_memory(local_98,0x80,param_3,param_4,&local_b8);
      if (iVar1 != 0) {
        local_bc = 0xffffffff;
        goto LAB_0012fc01;
      }
      iVar1 = strcmp(local_98,"-----BEGIN OPENSSH PRIVATE KEY-----");
    } while (iVar1 != 0);
    local_98[0] = '\0';
    do {
      if (local_98[0] != '\0') {
        local_a8 = strlen(local_98);
        if (local_b0 == 0) {
          local_a0 = (**(code **)(param_1 + 8))(local_a8 + local_c0,param_1);
        }
        else {
          local_a0 = (**(code **)(param_1 + 0x10))(local_b0,local_c0 + local_a8,param_1);
        }
        if (local_a0 == 0) {
          local_bc = 0xffffffff;
          goto LAB_0012fbb8;
        }
        memcpy((void *)((ulong)local_c0 + local_a0),local_98,local_a8);
        local_b0 = local_a0;
        local_c0 = local_c0 + (int)local_a8;
      }
      local_98[0] = '\0';
      if (param_4 <= local_b8) {
        local_bc = 0xffffffff;
        goto LAB_0012fbb8;
      }
      iVar1 = readline_memory(local_98,0x80,param_3,param_4,&local_b8);
      if (iVar1 != 0) {
        local_bc = 0xffffffff;
        goto LAB_0012fbb8;
      }
      iVar1 = strcmp(local_98,"-----END OPENSSH PRIVATE KEY-----");
    } while (iVar1 != 0);
    if (local_b0 == 0) {
      local_bc = 0xffffffff;
    }
    else {
      local_bc = _libssh2_openssh_pem_parse_data(param_1,param_2,local_b0,local_c0,param_5);
LAB_0012fbb8:
      if (local_b0 != 0) {
        _libssh2_explicit_zero(local_b0,local_c0);
        (**(code **)(param_1 + 0x18))(local_b0,param_1);
      }
    }
  }
LAB_0012fc01:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_bc;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int read_asn1_length(byte *param_1,uint param_2,uint *param_3)

{
  int iVar1;
  uint local_10;
  
  if (param_2 == 0) {
    iVar1 = -1;
  }
  else {
    *param_3 = (uint)*param_1;
    if (*param_3 < 0x80) {
      local_10 = 0;
    }
    else {
      local_10 = *param_3 & 0x7f;
      *param_3 = (uint)param_1[1];
      if (param_2 < local_10 + 1) {
        return -1;
      }
      if (1 < local_10) {
        *param_3 = *param_3 << 8;
        *param_3 = *param_3 | (uint)param_1[2];
      }
    }
    iVar1 = local_10 + 1;
    if ((2 < local_10) || (param_2 < local_10 + *param_3 + 1)) {
      iVar1 = -1;
    }
  }
  return iVar1;
}



undefined8 _libssh2_pem_decode_sequence(long *param_1,int *param_2)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  int local_18;
  int local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_2 == 0) {
    uVar1 = 0xffffffff;
  }
  else if (*(char *)*param_1 == '0') {
    *param_1 = *param_1 + 1;
    *param_2 = *param_2 + -1;
    local_14 = read_asn1_length(*param_1,*param_2,&local_18);
    if ((local_14 < 0) || (local_14 + local_18 != *param_2)) {
      uVar1 = 0xffffffff;
    }
    else {
      *param_1 = *param_1 + (long)local_14;
      *param_2 = *param_2 - local_14;
      uVar1 = 0;
    }
  }
  else {
    uVar1 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



undefined8 _libssh2_pem_decode_integer(long *param_1,uint *param_2,long *param_3,uint *param_4)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  uint local_18;
  int local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_2 == 0) {
    uVar1 = 0xffffffff;
  }
  else if (*(char *)*param_1 == '\x02') {
    *param_1 = *param_1 + 1;
    *param_2 = *param_2 - 1;
    local_14 = read_asn1_length(*param_1,*param_2,&local_18);
    if ((local_14 < 0) || (*param_2 < local_14 + local_18)) {
      uVar1 = 0xffffffff;
    }
    else {
      *param_1 = *param_1 + (long)local_14;
      *param_2 = *param_2 - local_14;
      *param_3 = *param_1;
      *param_4 = local_18;
      *param_1 = (ulong)local_18 + *param_1;
      *param_2 = *param_2 - local_18;
      uVar1 = 0;
    }
  }
  else {
    uVar1 = 0xffffffff;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



void publickey_status_error(long param_1,undefined8 param_2,int param_3)

{
  int local_2c;
  char *local_10;
  
  local_2c = param_3;
  if (((param_3 == 6) && (param_1 != 0)) && (*(int *)(param_1 + 8) == 1)) {
    local_2c = 7;
  }
  if ((local_2c < 0) || (8 < local_2c)) {
    local_10 = "unknown";
  }
  else {
    local_10 = *(char **)(publickey_status_codes + (long)local_2c * 0x18 + 8);
  }
  _libssh2_error(param_2,0xffffffdc,local_10);
  return;
}



undefined8 publickey_packet_receive(long *param_1,long *param_2,long *param_3)

{
  long lVar1;
  long lVar2;
  int iVar3;
  uint uVar4;
  undefined8 uVar5;
  long lVar6;
  long in_FS_OFFSET;
  undefined local_14 [4];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  lVar1 = *param_1;
  lVar2 = *(long *)(lVar1 + 0x60);
  *param_2 = 0;
  *param_3 = 0;
  if (*(int *)((long)param_1 + 0xc) == 0) {
    iVar3 = _libssh2_channel_read(lVar1,0,local_14,4);
    if (iVar3 == -0x25) {
      uVar5 = 0xffffffdb;
      goto LAB_0013018c;
    }
    if (iVar3 != 4) {
      uVar5 = _libssh2_error(lVar2,0xffffffdc,"Invalid response from publickey subsystem");
      goto LAB_0013018c;
    }
    uVar4 = _libssh2_ntohu32(local_14);
    param_1[3] = (ulong)uVar4;
    lVar6 = (**(code **)(lVar2 + 8))(param_1[3],lVar2);
    param_1[2] = lVar6;
    if (param_1[2] == 0) {
      uVar5 = _libssh2_error(lVar2,0xfffffffa,"Unable to allocate publickey response buffer");
      goto LAB_0013018c;
    }
    *(undefined4 *)((long)param_1 + 0xc) = 3;
  }
  if (*(int *)((long)param_1 + 0xc) == 3) {
    iVar3 = _libssh2_channel_read(lVar1,0,param_1[2],param_1[3]);
    if (iVar3 == -0x25) {
      uVar5 = 0xffffffdb;
      goto LAB_0013018c;
    }
    if (iVar3 != (int)param_1[3]) {
      (**(code **)(lVar2 + 0x18))(param_1[2],lVar2);
      param_1[2] = 0;
      *(undefined4 *)((long)param_1 + 0xc) = 0;
      uVar5 = _libssh2_error(lVar2,0xffffffe2,
                             "Timeout waiting for publickey subsystem response packet");
      goto LAB_0013018c;
    }
    *param_2 = param_1[2];
    *param_3 = param_1[3];
  }
  *(undefined4 *)((long)param_1 + 0xc) = 0;
  uVar5 = 0;
LAB_0013018c:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



undefined4 publickey_response_id(long *param_1,ulong param_2)

{
  char *__s2;
  long lVar1;
  uint uVar2;
  int iVar3;
  ulong __n;
  undefined4 *local_20;
  
  lVar1 = *param_1;
  local_20 = &publickey_response_codes;
  if (3 < param_2) {
    uVar2 = _libssh2_ntohu32(lVar1);
    __n = (ulong)uVar2;
    __s2 = (char *)(lVar1 + 4);
    if (__n <= param_2 - 4) {
      for (; *(long *)(local_20 + 2) != 0; local_20 = local_20 + 6) {
        if ((__n == (long)(int)local_20[4]) &&
           (iVar3 = strncmp(*(char **)(local_20 + 2),__s2,__n), iVar3 == 0)) {
          *param_1 = (long)(__s2 + __n);
          return *local_20;
        }
      }
    }
  }
  return 0xffffffff;
}



undefined8 publickey_response_success(long *param_1)

{
  int iVar1;
  uint uVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = *(long *)(*param_1 + 0x60);
  do {
    iVar1 = publickey_packet_receive(param_1,&local_38,&local_28);
    if (iVar1 == -0x25) {
      uVar3 = 0xffffffdb;
LAB_001303bd:
      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return uVar3;
    }
    if (iVar1 != 0) {
      uVar3 = _libssh2_error(local_20,0xffffffe2,
                             "Timeout waiting for response from publickey subsystem");
      goto LAB_001303bd;
    }
    local_30 = local_38;
    iVar1 = publickey_response_id(&local_30,local_28);
    if (iVar1 == 0) {
      uVar2 = _libssh2_ntohu32(local_30);
      local_18 = (ulong)uVar2;
      (**(code **)(local_20 + 0x18))(local_38,local_20);
      if (local_18 == 0) {
        uVar3 = 0;
      }
      else {
        publickey_status_error(param_1,local_20,local_18 & 0xffffffff);
        uVar3 = 0xffffffff;
      }
      goto LAB_001303bd;
    }
    (**(code **)(local_20 + 0x18))(local_38,local_20);
    if (iVar1 < 0) {
      uVar3 = _libssh2_error(local_20,0xffffffdc,"Invalid publickey subsystem response");
      goto LAB_001303bd;
    }
    _libssh2_error(local_20,0xffffffdc,"Unexpected publickey subsystem response");
    local_38 = 0;
  } while( true );
}



undefined8 publickey_init(long param_1)

{
  long lVar1;
  int iVar2;
  uint uVar3;
  undefined4 uVar4;
  undefined8 uVar5;
  long in_FS_OFFSET;
  ulong local_48;
  void *local_40;
  ulong local_38;
  ulong local_30;
  ulong local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd270) == 0) {
    *(undefined8 *)(param_1 + 0xd288) = 0;
    *(undefined8 *)(param_1 + 0xd278) = 0;
    *(undefined8 *)(param_1 + 0xd280) = 0;
    *(undefined4 *)(param_1 + 0xd270) = 1;
  }
  if (*(int *)(param_1 + 0xd270) == 1) {
    uVar5 = _libssh2_channel_open(param_1,"session",7,0x200000,0x8000,0,0);
    *(undefined8 *)(param_1 + 0xd280) = uVar5;
    if (*(long *)(param_1 + 0xd280) != 0) {
      *(undefined4 *)(param_1 + 0xd270) = 3;
      goto LAB_001304e3;
    }
    iVar2 = libssh2_session_last_errno(param_1);
    if (iVar2 == -0x25) {
      uVar5 = 0;
      goto LAB_00130b4c;
    }
    _libssh2_error(param_1,0xffffffeb,"Unable to startup channel");
  }
  else {
LAB_001304e3:
    if (*(int *)(param_1 + 0xd270) == 3) {
      iVar2 = _libssh2_channel_process_startup
                        (*(undefined8 *)(param_1 + 0xd280),"subsystem",9,"publickey",9);
      if (iVar2 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block starting publickey subsystem");
        uVar5 = 0;
        goto LAB_00130b4c;
      }
      if (iVar2 != 0) {
        _libssh2_error(param_1,0xffffffeb,"Unable to request publickey subsystem");
        goto LAB_00130a61;
      }
      *(undefined4 *)(param_1 + 0xd270) = 4;
    }
    if (*(int *)(param_1 + 0xd270) == 4) {
      iVar2 = _libssh2_channel_extended_data(*(undefined8 *)(param_1 + 0xd280),1);
      if (iVar2 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block starting publickey subsystem");
        uVar5 = 0;
        goto LAB_00130b4c;
      }
      uVar5 = _libssh2_calloc(param_1,0x80);
      *(undefined8 *)(param_1 + 0xd278) = uVar5;
      if (*(long *)(param_1 + 0xd278) == 0) {
        _libssh2_error(param_1,0xfffffffa,"Unable to allocate a new publickey structure");
        goto LAB_00130a61;
      }
      **(undefined8 **)(param_1 + 0xd278) = *(undefined8 *)(param_1 + 0xd280);
      *(undefined4 *)(*(long *)(param_1 + 0xd278) + 8) = 0;
      local_40 = (void *)(param_1 + 0xd298);
      _libssh2_htonu32(local_40,0xf);
      local_40 = (void *)((long)local_40 + 4);
      _libssh2_htonu32(local_40,7);
      local_40 = (void *)((long)local_40 + 4);
      memcpy(local_40,"version",7);
      local_40 = (void *)((long)local_40 + 7);
      _libssh2_htonu32(local_40,2);
      *(undefined8 *)(param_1 + 0xd2b0) = 0;
      *(undefined4 *)(param_1 + 0xd270) = 5;
    }
    if (*(int *)(param_1 + 0xd270) == 5) {
      iVar2 = _libssh2_channel_write
                        (*(undefined8 *)(param_1 + 0xd280),0,param_1 + 0xd298,
                         0x13 - *(long *)(param_1 + 0xd2b0));
      if (iVar2 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block sending publickey version packet");
        uVar5 = 0;
        goto LAB_00130b4c;
      }
      if (iVar2 < 0) {
        _libssh2_error(param_1,iVar2,"Unable to send publickey version packet");
        goto LAB_00130a61;
      }
      *(long *)(param_1 + 0xd2b0) = *(long *)(param_1 + 0xd2b0) + (long)iVar2;
      if (*(ulong *)(param_1 + 0xd2b0) < 0x13) {
        _libssh2_error(param_1,0xffffffdb,"Need to be called again to complete this");
        uVar5 = 0;
        goto LAB_00130b4c;
      }
      *(undefined4 *)(param_1 + 0xd270) = 6;
    }
    if (*(int *)(param_1 + 0xd270) == 6) {
      while( true ) {
        iVar2 = publickey_packet_receive
                          (*(undefined8 *)(param_1 + 0xd278),param_1 + 0xd288,param_1 + 0xd290);
        if (iVar2 == -0x25) break;
        if (iVar2 != 0) {
          _libssh2_error(param_1,0xffffffe2,"Timeout waiting for response from publickey subsystem")
          ;
          goto LAB_00130a61;
        }
        local_48 = *(ulong *)(param_1 + 0xd288);
        iVar2 = publickey_response_id(&local_48,*(undefined8 *)(param_1 + 0xd290));
        if (iVar2 < 0) {
          _libssh2_error(param_1,0xffffffdc,"Invalid publickey subsystem response code");
          goto LAB_00130a61;
        }
        if (iVar2 == 0) {
          uVar3 = _libssh2_ntohu32(local_48);
          local_38 = (ulong)uVar3;
          local_48 = local_48 + 4;
          uVar3 = _libssh2_ntohu32(local_48);
          local_30 = (ulong)uVar3;
          local_48 = local_30 + local_48 + 4;
          uVar3 = _libssh2_ntohu32(local_48);
          local_28 = (ulong)uVar3;
          local_48 = local_28 + local_48 + 4;
          if ((ulong)(*(long *)(param_1 + 0xd288) + *(long *)(param_1 + 0xd290)) < local_48) {
            _libssh2_error(param_1,0xffffffdc,"Malformed publickey subsystem packet");
          }
          else {
            publickey_status_error(0,param_1,local_38 & 0xffffffff);
          }
          goto LAB_00130a61;
        }
        if (iVar2 == 1) {
          lVar1 = *(long *)(param_1 + 0xd278);
          uVar4 = _libssh2_ntohu32(local_48);
          *(undefined4 *)(lVar1 + 8) = uVar4;
          if (2 < *(uint *)(*(long *)(param_1 + 0xd278) + 8)) {
            *(undefined4 *)(*(long *)(param_1 + 0xd278) + 8) = 2;
          }
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd288),param_1);
          *(undefined8 *)(param_1 + 0xd288) = 0;
          *(undefined4 *)(param_1 + 0xd270) = 0;
          uVar5 = *(undefined8 *)(param_1 + 0xd278);
          goto LAB_00130b4c;
        }
        _libssh2_error(param_1,0xffffffdc,"Unexpected publickey subsystem response, ignoring");
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd288),param_1);
        *(undefined8 *)(param_1 + 0xd288) = 0;
      }
      _libssh2_error(param_1,0xffffffdb,"Would block waiting for response from publickey subsystem")
      ;
      uVar5 = 0;
      goto LAB_00130b4c;
    }
  }
LAB_00130a61:
  *(undefined4 *)(param_1 + 0xd270) = 7;
  if (*(long *)(param_1 + 0xd280) != 0) {
    iVar2 = _libssh2_channel_close(*(undefined8 *)(param_1 + 0xd280));
    if (iVar2 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block closing channel");
      uVar5 = 0;
      goto LAB_00130b4c;
    }
  }
  if (*(long *)(param_1 + 0xd278) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd278),param_1);
    *(undefined8 *)(param_1 + 0xd278) = 0;
  }
  if (*(long *)(param_1 + 0xd288) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd288),param_1);
    *(undefined8 *)(param_1 + 0xd288) = 0;
  }
  *(undefined4 *)(param_1 + 0xd270) = 0;
  uVar5 = 0;
LAB_00130b4c:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



long libssh2_publickey_init(long param_1)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  tVar2 = time((time_t *)0x0);
  do {
    lVar3 = publickey_init(param_1);
    if (*(int *)(param_1 + 0x94) == 0) {
      return lVar3;
    }
    if (lVar3 != 0) {
      return lVar3;
    }
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 != -0x25) {
      return 0;
    }
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
  } while (iVar1 == 0);
  return 0;
}



ulong libssh2_publickey_add_ex
                (long *param_1,void *param_2,ulong param_3,void *param_4,ulong param_5,char param_6,
                ulong param_7,long param_8)

{
  char cVar1;
  long lVar2;
  long lVar3;
  int iVar4;
  uint uVar5;
  long lVar6;
  ulong uVar7;
  ulong local_38;
  long local_30;
  void *local_28;
  ulong local_20;
  
  local_28 = (void *)0x0;
  local_20 = 0;
  if (param_1 == (long *)0x0) {
    return 0xffffffd9;
  }
  lVar2 = *param_1;
  lVar3 = *(long *)(lVar2 + 0x60);
  if (*(int *)(param_1 + 4) == 0) {
    param_1[5] = 0;
    if (*(int *)(param_1 + 1) == 1) {
      for (local_38 = 0; local_38 < param_7; local_38 = local_38 + 1) {
        if ((*(long *)(param_8 + local_38 * 0x28 + 8) == 7) &&
           (iVar4 = strncmp(*(char **)(param_8 + local_38 * 0x28),"comment",7), iVar4 == 0)) {
          local_28 = *(void **)(param_8 + local_38 * 0x28 + 0x10);
          local_20 = *(ulong *)(param_8 + local_38 * 0x28 + 0x18);
          break;
        }
      }
      local_30 = param_5 + param_3 + local_20 + 0x17;
    }
    else {
      local_30 = param_5 + param_3 + 0x18;
      for (local_38 = 0; local_38 < param_7; local_38 = local_38 + 1) {
        local_30 = local_30 +
                   *(long *)(param_8 + local_38 * 0x28 + 8) +
                   *(long *)(param_8 + local_38 * 0x28 + 0x18) + 9;
      }
    }
    lVar6 = (**(code **)(lVar3 + 8))(local_30,lVar3);
    param_1[5] = lVar6;
    if (param_1[5] == 0) {
      uVar7 = _libssh2_error(lVar3,0xfffffffa,
                             "Unable to allocate memory for publickey \"add\" packet");
      return uVar7;
    }
    param_1[6] = param_1[5];
    _libssh2_htonu32(param_1[6],(int)local_30 + -4);
    param_1[6] = param_1[6] + 4;
    _libssh2_htonu32(param_1[6],3);
    param_1[6] = param_1[6] + 4;
    memcpy((void *)param_1[6],&DAT_00147cc5,3);
    param_1[6] = param_1[6] + 3;
    if (*(int *)(param_1 + 1) == 1) {
      _libssh2_htonu32(param_1[6],local_20 & 0xffffffff);
      param_1[6] = param_1[6] + 4;
      if (local_28 != (void *)0x0) {
        memcpy((void *)param_1[6],local_28,local_20);
        param_1[6] = param_1[6] + local_20;
      }
      _libssh2_htonu32(param_1[6],param_3 & 0xffffffff);
      param_1[6] = param_1[6] + 4;
      memcpy((void *)param_1[6],param_2,param_3);
      param_1[6] = param_1[6] + param_3;
      _libssh2_htonu32(param_1[6],param_5 & 0xffffffff);
      param_1[6] = param_1[6] + 4;
      memcpy((void *)param_1[6],param_4,param_5);
      param_1[6] = param_1[6] + param_5;
    }
    else {
      _libssh2_htonu32(param_1[6],param_3 & 0xffffffff);
      param_1[6] = param_1[6] + 4;
      memcpy((void *)param_1[6],param_2,param_3);
      param_1[6] = param_1[6] + param_3;
      _libssh2_htonu32(param_1[6],param_5 & 0xffffffff);
      param_1[6] = param_1[6] + 4;
      memcpy((void *)param_1[6],param_4,param_5);
      param_1[6] = param_1[6] + param_5;
      lVar6 = param_1[6];
      param_1[6] = lVar6 + 1;
      *(bool *)lVar6 = param_6 != '\0';
      _libssh2_htonu32(param_1[6],param_7 & 0xffffffff);
      param_1[6] = param_1[6] + 4;
      for (local_38 = 0; local_38 < param_7; local_38 = local_38 + 1) {
        _libssh2_htonu32(param_1[6],*(ulong *)(param_8 + local_38 * 0x28 + 8) & 0xffffffff);
        param_1[6] = param_1[6] + 4;
        memcpy((void *)param_1[6],*(void **)(param_8 + local_38 * 0x28),
               *(size_t *)(param_8 + local_38 * 0x28 + 8));
        param_1[6] = param_1[6] + *(long *)(param_8 + local_38 * 0x28 + 8);
        _libssh2_htonu32(param_1[6],*(ulong *)(param_8 + local_38 * 0x28 + 0x18) & 0xffffffff);
        param_1[6] = param_1[6] + 4;
        memcpy((void *)param_1[6],*(void **)(param_8 + local_38 * 0x28 + 0x10),
               *(size_t *)(param_8 + local_38 * 0x28 + 0x18));
        param_1[6] = param_1[6] + *(long *)(param_8 + local_38 * 0x28 + 0x18);
        cVar1 = *(char *)(param_8 + local_38 * 0x28 + 0x20);
        lVar6 = param_1[6];
        param_1[6] = lVar6 + 1;
        *(bool *)lVar6 = cVar1 != '\0';
      }
    }
    *(undefined4 *)(param_1 + 4) = 2;
  }
  if (*(int *)(param_1 + 4) == 2) {
    iVar4 = _libssh2_channel_write(lVar2,0,param_1[5],param_1[6] - param_1[5]);
    if (iVar4 == -0x25) {
      return 0xffffffdb;
    }
    if (param_1[6] - param_1[5] != (long)iVar4) {
      (**(code **)(lVar3 + 0x18))(param_1[5],lVar3);
      param_1[5] = 0;
      uVar7 = _libssh2_error(lVar3,0xfffffff9,"Unable to send publickey add packet");
      return uVar7;
    }
    (**(code **)(lVar3 + 0x18))(param_1[5],lVar3);
    param_1[5] = 0;
    *(undefined4 *)(param_1 + 4) = 3;
  }
  uVar5 = publickey_response_success(param_1);
  if (uVar5 == 0xffffffdb) {
    uVar7 = 0xffffffdb;
  }
  else {
    *(undefined4 *)(param_1 + 4) = 0;
    uVar7 = (ulong)uVar5;
  }
  return uVar7;
}



ulong libssh2_publickey_remove_ex
                (long *param_1,void *param_2,ulong param_3,void *param_4,ulong param_5)

{
  long lVar1;
  long lVar2;
  int iVar3;
  uint uVar4;
  long lVar5;
  long lVar6;
  ulong uVar7;
  
  lVar5 = param_5 + param_3 + 0x16;
  if (param_1 == (long *)0x0) {
    return 0xffffffd9;
  }
  lVar1 = *param_1;
  lVar2 = *(long *)(lVar1 + 0x60);
  if (*(int *)(param_1 + 7) == 0) {
    param_1[8] = 0;
    lVar6 = (**(code **)(lVar2 + 8))(lVar5,lVar2);
    param_1[8] = lVar6;
    if (param_1[8] == 0) {
      uVar7 = _libssh2_error(lVar2,0xfffffffa,
                             "Unable to allocate memory for publickey \"remove\" packet");
      return uVar7;
    }
    param_1[9] = param_1[8];
    _libssh2_htonu32(param_1[9],(int)lVar5 + -4);
    param_1[9] = param_1[9] + 4;
    _libssh2_htonu32(param_1[9],6);
    param_1[9] = param_1[9] + 4;
    memcpy((void *)param_1[9],"remove",6);
    param_1[9] = param_1[9] + 6;
    _libssh2_htonu32(param_1[9],param_3 & 0xffffffff);
    param_1[9] = param_1[9] + 4;
    memcpy((void *)param_1[9],param_2,param_3);
    param_1[9] = param_1[9] + param_3;
    _libssh2_htonu32(param_1[9],param_5 & 0xffffffff);
    param_1[9] = param_1[9] + 4;
    memcpy((void *)param_1[9],param_4,param_5);
    param_1[9] = param_1[9] + param_5;
    *(undefined4 *)(param_1 + 7) = 2;
  }
  if (*(int *)(param_1 + 7) == 2) {
    iVar3 = _libssh2_channel_write(lVar1,0,param_1[8],param_1[9] - param_1[8]);
    if (iVar3 == -0x25) {
      return 0xffffffdb;
    }
    if (param_1[9] - param_1[8] != (long)iVar3) {
      (**(code **)(lVar2 + 0x18))(param_1[8],lVar2);
      param_1[8] = 0;
      *(undefined4 *)(param_1 + 7) = 0;
      uVar7 = _libssh2_error(lVar2,0xfffffff9,"Unable to send publickey remove packet");
      return uVar7;
    }
    (**(code **)(lVar2 + 0x18))(param_1[8],lVar2);
    param_1[8] = 0;
    *(undefined4 *)(param_1 + 7) = 3;
  }
  uVar4 = publickey_response_success(param_1);
  if (uVar4 == 0xffffffdb) {
    uVar7 = 0xffffffdb;
  }
  else {
    *(undefined4 *)(param_1 + 7) = 0;
    uVar7 = (ulong)uVar4;
  }
  return uVar7;
}



undefined8 libssh2_publickey_list_fetch(long *param_1,ulong *param_2,long *param_3)

{
  long lVar1;
  int iVar2;
  uint uVar3;
  undefined8 uVar4;
  long lVar5;
  ulong uVar6;
  long local_78;
  ulong local_70;
  ulong local_68;
  ulong local_60;
  
  local_78 = 0;
  local_70 = 0;
  local_68 = 0;
  if (param_1 == (long *)0x0) {
    return 0xffffffd9;
  }
  lVar5 = *param_1;
  lVar1 = *(long *)(lVar5 + 0x60);
  if (*(int *)(param_1 + 10) == 0) {
    param_1[0xe] = 0;
    param_1[0xb] = (long)(param_1 + 0xc);
    _libssh2_htonu32(param_1[0xb],8);
    param_1[0xb] = param_1[0xb] + 4;
    _libssh2_htonu32(param_1[0xb],4);
    param_1[0xb] = param_1[0xb] + 4;
    memcpy((void *)param_1[0xb],&DAT_00147d5f,4);
    param_1[0xb] = param_1[0xb] + 4;
    *(undefined4 *)(param_1 + 10) = 2;
  }
  if (*(int *)(param_1 + 10) == 2) {
    iVar2 = _libssh2_channel_write(lVar5,0,param_1 + 0xc,param_1[0xb] - (long)(param_1 + 0xc));
    if (iVar2 == -0x25) {
      return 0xffffffdb;
    }
    if (param_1[0xb] - (long)(param_1 + 0xc) != (long)iVar2) {
      *(undefined4 *)(param_1 + 10) = 0;
      uVar4 = _libssh2_error(lVar1,0xfffffff9,"Unable to send publickey list packet");
      return uVar4;
    }
    *(undefined4 *)(param_1 + 10) = 3;
  }
  while( true ) {
    iVar2 = publickey_packet_receive(param_1,param_1 + 0xe,param_1 + 0xf);
    if (iVar2 == -0x25) {
      return 0xffffffdb;
    }
    if (iVar2 != 0) break;
    param_1[0xb] = param_1[0xe];
    iVar2 = publickey_response_id(param_1 + 0xb,param_1[0xf]);
    if (iVar2 < 0) {
      _libssh2_error(lVar1,0xffffffdc,"Invalid publickey subsystem response code");
      goto LAB_001325d3;
    }
    if (iVar2 == 0) {
      iVar2 = _libssh2_ntohu32(param_1[0xb]);
      param_1[0xb] = param_1[0xb] + 4;
      uVar3 = _libssh2_ntohu32(param_1[0xb]);
      param_1[0xb] = param_1[0xb] + 4;
      param_1[0xb] = param_1[0xb] + (ulong)uVar3;
      uVar3 = _libssh2_ntohu32(param_1[0xb]);
      param_1[0xb] = param_1[0xb] + 4;
      param_1[0xb] = param_1[0xb] + (ulong)uVar3;
      if ((ulong)(param_1[0xf] + param_1[0xe]) < (ulong)param_1[0xb]) {
        _libssh2_error(lVar1,0xffffffdc,"Malformed publickey subsystem packet");
      }
      else {
        if (iVar2 == 0) {
          (**(code **)(lVar1 + 0x18))(param_1[0xe],lVar1);
          param_1[0xe] = 0;
          *param_3 = local_78;
          *param_2 = local_70;
          *(undefined4 *)(param_1 + 10) = 0;
          return 0;
        }
        publickey_status_error(param_1,lVar1,iVar2);
      }
      goto LAB_001325d3;
    }
    if (iVar2 == 2) {
      lVar5 = local_78;
      if (local_68 <= local_70) {
        if (local_78 == 0) {
          lVar5 = (**(code **)(lVar1 + 8))((local_68 + 9) * 0x38,lVar1);
        }
        else {
          lVar5 = (**(code **)(lVar1 + 0x10))(local_78,(local_68 + 9) * 0x38,lVar1);
        }
        local_68 = local_68 + 8;
        if (lVar5 == 0) {
          _libssh2_error(lVar1,0xfffffffa,"Unable to allocate memory for publickey list");
          goto LAB_001325d3;
        }
      }
      local_78 = lVar5;
      if (*(int *)(param_1 + 1) == 1) {
        uVar3 = _libssh2_ntohu32(param_1[0xb]);
        uVar6 = (ulong)uVar3;
        param_1[0xb] = param_1[0xb] + 4;
        if (uVar6 == 0) {
          *(undefined8 *)(local_78 + local_70 * 0x38 + 0x28) = 0;
          *(undefined8 *)(local_78 + local_70 * 0x38 + 0x30) = 0;
        }
        else {
          *(undefined8 *)(local_78 + local_70 * 0x38 + 0x28) = 1;
          uVar4 = (**(code **)(lVar1 + 8))(0x28,lVar1);
          *(undefined8 *)(local_70 * 0x38 + local_78 + 0x30) = uVar4;
          if (*(long *)(local_78 + local_70 * 0x38 + 0x30) == 0) {
            _libssh2_error(lVar1,0xfffffffa,"Unable to allocate memory for publickey attributes");
            goto LAB_001325d3;
          }
          **(undefined8 **)(local_78 + local_70 * 0x38 + 0x30) = "comment";
          *(undefined8 *)(*(long *)(local_78 + local_70 * 0x38 + 0x30) + 8) = 7;
          *(long *)(*(long *)(local_78 + local_70 * 0x38 + 0x30) + 0x10) = param_1[0xb];
          *(ulong *)(*(long *)(local_78 + local_70 * 0x38 + 0x30) + 0x18) = uVar6;
          *(undefined *)(*(long *)(local_78 + local_70 * 0x38 + 0x30) + 0x20) = 0;
          param_1[0xb] = param_1[0xb] + uVar6;
        }
        uVar3 = _libssh2_ntohu32(param_1[0xb]);
        *(ulong *)(local_78 + local_70 * 0x38 + 0x10) = (ulong)uVar3;
        param_1[0xb] = param_1[0xb] + 4;
        *(long *)(local_70 * 0x38 + local_78 + 8) = param_1[0xb];
        param_1[0xb] = param_1[0xb] + *(long *)(local_78 + local_70 * 0x38 + 0x10);
        uVar3 = _libssh2_ntohu32(param_1[0xb]);
        *(ulong *)(local_78 + local_70 * 0x38 + 0x20) = (ulong)uVar3;
        param_1[0xb] = param_1[0xb] + 4;
        *(long *)(local_70 * 0x38 + local_78 + 0x18) = param_1[0xb];
        param_1[0xb] = param_1[0xb] + *(long *)(local_78 + local_70 * 0x38 + 0x20);
      }
      else {
        uVar3 = _libssh2_ntohu32(param_1[0xb]);
        *(ulong *)(local_78 + local_70 * 0x38 + 0x10) = (ulong)uVar3;
        param_1[0xb] = param_1[0xb] + 4;
        *(long *)(local_70 * 0x38 + local_78 + 8) = param_1[0xb];
        param_1[0xb] = param_1[0xb] + *(long *)(local_78 + local_70 * 0x38 + 0x10);
        uVar3 = _libssh2_ntohu32(param_1[0xb]);
        *(ulong *)(local_78 + local_70 * 0x38 + 0x20) = (ulong)uVar3;
        param_1[0xb] = param_1[0xb] + 4;
        *(long *)(local_70 * 0x38 + local_78 + 0x18) = param_1[0xb];
        param_1[0xb] = param_1[0xb] + *(long *)(local_78 + local_70 * 0x38 + 0x20);
        uVar3 = _libssh2_ntohu32(param_1[0xb]);
        *(ulong *)(local_78 + local_70 * 0x38 + 0x28) = (ulong)uVar3;
        param_1[0xb] = param_1[0xb] + 4;
        if (*(long *)(local_78 + local_70 * 0x38 + 0x28) == 0) {
          *(undefined8 *)(local_78 + local_70 * 0x38 + 0x30) = 0;
        }
        else {
          uVar4 = (**(code **)(lVar1 + 8))
                            (*(long *)(local_78 + local_70 * 0x38 + 0x28) * 0x28,lVar1);
          *(undefined8 *)(local_70 * 0x38 + local_78 + 0x30) = uVar4;
          if (*(long *)(local_78 + local_70 * 0x38 + 0x30) == 0) {
            _libssh2_error(lVar1,0xfffffffa,"Unable to allocate memory for publickey attributes");
            goto LAB_001325d3;
          }
          for (local_60 = 0; local_60 < *(ulong *)(local_78 + local_70 * 0x38 + 0x28);
              local_60 = local_60 + 1) {
            uVar3 = _libssh2_ntohu32(param_1[0xb]);
            *(ulong *)(local_60 * 0x28 + *(long *)(local_78 + local_70 * 0x38 + 0x30) + 8) =
                 (ulong)uVar3;
            param_1[0xb] = param_1[0xb] + 4;
            *(long *)(*(long *)(local_78 + local_70 * 0x38 + 0x30) + local_60 * 0x28) = param_1[0xb]
            ;
            param_1[0xb] = param_1[0xb] +
                           *(long *)(local_60 * 0x28 + *(long *)(local_78 + local_70 * 0x38 + 0x30)
                                    + 8);
            uVar3 = _libssh2_ntohu32(param_1[0xb]);
            *(ulong *)(local_60 * 0x28 + *(long *)(local_78 + local_70 * 0x38 + 0x30) + 0x18) =
                 (ulong)uVar3;
            param_1[0xb] = param_1[0xb] + 4;
            *(long *)(*(long *)(local_78 + local_70 * 0x38 + 0x30) + local_60 * 0x28 + 0x10) =
                 param_1[0xb];
            param_1[0xb] = param_1[0xb] +
                           *(long *)(local_60 * 0x28 + *(long *)(local_78 + local_70 * 0x38 + 0x30)
                                    + 0x18);
            *(undefined *)(local_60 * 0x28 + *(long *)(local_78 + local_70 * 0x38 + 0x30) + 0x20) =
                 0;
          }
        }
      }
      *(long *)(local_70 * 0x38 + local_78) = param_1[0xe];
      local_70 = local_70 + 1;
      *(undefined8 *)(local_78 + local_70 * 0x38) = 0;
      param_1[0xe] = 0;
    }
    else {
      _libssh2_error(lVar1,0xffffffdc,"Unexpected publickey subsystem response");
      (**(code **)(lVar1 + 0x18))(param_1[0xe],lVar1);
      param_1[0xe] = 0;
    }
  }
  _libssh2_error(lVar1,0xffffffe2,"Timeout waiting for response from publickey subsystem");
LAB_001325d3:
  if (param_1[0xe] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[0xe],lVar1);
    param_1[0xe] = 0;
  }
  if (local_78 != 0) {
    libssh2_publickey_list_free(param_1,local_78);
  }
  *(undefined4 *)(param_1 + 10) = 0;
  return 0xffffffff;
}



void libssh2_publickey_list_free(long *param_1,long *param_2)

{
  long lVar1;
  long *local_18;
  
  if ((param_1 != (long *)0x0) && (param_2 != (long *)0x0)) {
    lVar1 = *(long *)(*param_1 + 0x60);
    for (local_18 = param_2; *local_18 != 0; local_18 = local_18 + 7) {
      if (local_18[6] != 0) {
        (**(code **)(lVar1 + 0x18))(local_18[6],lVar1);
      }
      (**(code **)(lVar1 + 0x18))(*local_18,lVar1);
    }
    (**(code **)(lVar1 + 0x18))(param_2,lVar1);
  }
  return;
}



undefined4 libssh2_publickey_shutdown(long *param_1)

{
  long lVar1;
  int iVar2;
  undefined4 uVar3;
  
  if (param_1 == (long *)0x0) {
    uVar3 = 0xffffffd9;
  }
  else {
    lVar1 = *(long *)(*param_1 + 0x60);
    if (param_1[2] != 0) {
      (**(code **)(lVar1 + 0x18))(param_1[2],lVar1);
      param_1[2] = 0;
    }
    if (param_1[5] != 0) {
      (**(code **)(lVar1 + 0x18))(param_1[5],lVar1);
      param_1[5] = 0;
    }
    if (param_1[8] != 0) {
      (**(code **)(lVar1 + 0x18))(param_1[8],lVar1);
      param_1[8] = 0;
    }
    if (param_1[0xe] != 0) {
      (**(code **)(lVar1 + 0x18))(param_1[0xe],lVar1);
      param_1[0xe] = 0;
    }
    iVar2 = _libssh2_channel_free(*param_1);
    if (iVar2 == -0x25) {
      uVar3 = 0xffffffdb;
    }
    else {
      (**(code **)(lVar1 + 0x18))(param_1,lVar1);
      uVar3 = 0;
    }
  }
  return uVar3;
}



long shell_quotearg(char *param_1,char *param_2,uint param_3)

{
  char *pcVar1;
  char *pcVar2;
  long lVar3;
  uint local_24;
  char *local_20;
  char *local_18;
  
  local_24 = 0;
  pcVar2 = param_2 + param_3;
  local_20 = param_1;
  local_18 = param_2;
  while( true ) {
    if ((*local_20 == '\0') || (pcVar2 + -1 <= local_18)) {
      if (local_24 == 2) {
        if (pcVar2 <= local_18 + 1) {
          return 0;
        }
        *local_18 = '\"';
        local_18 = local_18 + 1;
      }
      else if (((local_24 < 3) && (local_24 != 0)) && (local_24 == 1)) {
        if (pcVar2 <= local_18 + 1) {
          return 0;
        }
        *local_18 = '\'';
        local_18 = local_18 + 1;
      }
      if (local_18 + 1 < pcVar2) {
        *local_18 = '\0';
        lVar3 = (long)local_18 - (long)param_2;
      }
      else {
        lVar3 = 0;
      }
      return lVar3;
    }
    if (*local_20 == '!') {
      if (local_24 == 2) {
        if (pcVar2 <= local_18 + 2) {
          return 0;
        }
        pcVar1 = local_18 + 1;
        *local_18 = '\"';
        local_18 = local_18 + 2;
        *pcVar1 = '\\';
      }
      else if (local_24 < 3) {
        if (local_24 == 0) {
          if (pcVar2 <= local_18 + 1) {
            return 0;
          }
          *local_18 = '\\';
          local_18 = local_18 + 1;
        }
        else if (local_24 == 1) {
          if (pcVar2 <= local_18 + 2) {
            return 0;
          }
          *local_18 = '\'';
          local_18[1] = '\\';
          local_18 = local_18 + 2;
        }
      }
      local_24 = 0;
    }
    else if (*local_20 == '\'') {
      if ((local_24 != 2) && (local_24 < 3)) {
        if (local_24 == 0) {
          if (pcVar2 <= local_18 + 1) {
            return 0;
          }
          *local_18 = '\"';
          local_18 = local_18 + 1;
        }
        else if (local_24 == 1) {
          if (pcVar2 <= local_18 + 2) {
            return 0;
          }
          *local_18 = '\'';
          local_18[1] = '\"';
          local_18 = local_18 + 2;
        }
      }
      local_24 = 2;
    }
    else {
      if (local_24 == 2) {
        if (pcVar2 <= local_18 + 2) {
          return 0;
        }
        pcVar1 = local_18 + 1;
        *local_18 = '\"';
        local_18 = local_18 + 2;
        *pcVar1 = '\'';
      }
      else if ((local_24 < 3) && (local_24 == 0)) {
        if (pcVar2 <= local_18 + 1) {
          return 0;
        }
        *local_18 = '\'';
        local_18 = local_18 + 1;
      }
      local_24 = 1;
    }
    if (pcVar2 <= local_18 + 1) break;
    *local_18 = *local_20;
    local_20 = local_20 + 1;
    local_18 = local_18 + 1;
  }
  return 0;
}



undefined8 scp_recv(long param_1,char *param_2,void *param_3)

{
  undefined4 uVar1;
  int iVar2;
  int iVar3;
  size_t sVar4;
  undefined8 uVar5;
  undefined *puVar6;
  char *pcVar7;
  long lVar8;
  longlong lVar9;
  long in_FS_OFFSET;
  char *local_50;
  char *local_48;
  char *local_40;
  long local_38;
  long local_30;
  char *local_28;
  char *local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd3c0) == 0) {
    *(undefined8 *)(param_1 + 0xd4e0) = 0;
    *(undefined8 *)(param_1 + 0xd4e8) = 0;
    *(undefined8 *)(param_1 + 0xd4f0) = 0;
    *(undefined8 *)(param_1 + 0xd4f8) = 0;
    sVar4 = strlen(param_2);
    *(size_t *)(param_1 + 0xd3d0) = sVar4 * 3 + (ulong)(param_3 != (void *)0x0) + 10;
    uVar5 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_1 + 0xd3d0),param_1);
    *(undefined8 *)(param_1 + 0xd3c8) = uVar5;
    if (*(long *)(param_1 + 0xd3c8) == 0) {
      _libssh2_error(param_1,0xfffffffa,"Unable to allocate a command buffer for SCP session");
      uVar5 = 0;
      goto LAB_00133b0e;
    }
    if (param_3 == (void *)0x0) {
      puVar6 = &DAT_00147e2e;
    }
    else {
      puVar6 = &DAT_00147e2c;
    }
    snprintf(*(char **)(param_1 + 0xd3c8),*(size_t *)(param_1 + 0xd3d0),"scp -%sf ",puVar6);
    sVar4 = strlen(*(char **)(param_1 + 0xd3c8));
    iVar3 = (int)sVar4;
    iVar2 = shell_quotearg(param_2,*(long *)(param_1 + 0xd3c8) + (long)iVar3,
                           (int)*(undefined8 *)(param_1 + 0xd3d0) - iVar3);
    *(long *)(param_1 + 0xd3d0) = (long)(iVar2 + iVar3);
    *(undefined4 *)(param_1 + 0xd3c0) = 2;
  }
  if (*(int *)(param_1 + 0xd3c0) == 2) {
    uVar5 = _libssh2_channel_open(param_1,"session",7,0x200000,0x8000,0,0);
    *(undefined8 *)(param_1 + 0xd500) = uVar5;
    if (*(long *)(param_1 + 0xd500) == 0) {
      iVar3 = libssh2_session_last_errno(param_1);
      if (iVar3 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block starting up channel");
      }
      else {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd3c8),param_1);
        *(undefined8 *)(param_1 + 0xd3c8) = 0;
        *(undefined4 *)(param_1 + 0xd3c0) = 0;
      }
      uVar5 = 0;
      goto LAB_00133b0e;
    }
    *(undefined4 *)(param_1 + 0xd3c0) = 3;
  }
  if (*(int *)(param_1 + 0xd3c0) == 3) {
    iVar3 = _libssh2_channel_process_startup
                      (*(undefined8 *)(param_1 + 0xd500),&DAT_00147e68,4,
                       *(undefined8 *)(param_1 + 0xd3c8),*(undefined8 *)(param_1 + 0xd3d0));
    if (iVar3 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block requesting SCP startup");
      uVar5 = 0;
      goto LAB_00133b0e;
    }
    if (iVar3 != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd3c8),param_1);
      *(undefined8 *)(param_1 + 0xd3c8) = 0;
      goto LAB_00133a9b;
    }
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd3c8),param_1);
    *(undefined8 *)(param_1 + 0xd3c8) = 0;
    *(undefined *)(param_1 + 0xd3d8) = 0;
    *(undefined4 *)(param_1 + 0xd3c0) = 4;
  }
  if (*(int *)(param_1 + 0xd3c0) == 4) {
    iVar3 = _libssh2_channel_write(*(undefined8 *)(param_1 + 0xd500),0,param_1 + 0xd3d8,1);
    if (iVar3 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block sending initial wakeup");
      uVar5 = 0;
      goto LAB_00133b0e;
    }
    if (iVar3 != 1) goto LAB_00133a9b;
    *(undefined8 *)(param_1 + 0xd4d8) = 0;
    *(undefined4 *)(param_1 + 0xd3c0) = 5;
  }
  if ((*(int *)(param_1 + 0xd3c0) == 5) || (*(int *)(param_1 + 0xd3c0) == 6)) {
LAB_001334c4:
    do {
      if ((param_3 == (void *)0x0) || (0xff < *(ulong *)(param_1 + 0xd4d8))) goto LAB_001334e5;
      if (*(int *)(param_1 + 0xd3c0) == 5) {
        iVar3 = _libssh2_channel_read
                          (*(undefined8 *)(param_1 + 0xd500),0,
                           param_1 + 0xd3d8 + *(long *)(param_1 + 0xd4d8),1);
        if (iVar3 == -0x25) {
          _libssh2_error(param_1,0xffffffdb,"Would block waiting for SCP response");
          uVar5 = 0;
          goto LAB_00133b0e;
        }
        if (iVar3 < 0) {
          _libssh2_error(param_1,iVar3,"Failed reading SCP response");
          goto LAB_00133a9b;
        }
        if (iVar3 == 0) goto LAB_00133a5c;
        *(long *)(param_1 + 0xd4d8) = *(long *)(param_1 + 0xd4d8) + 1;
        if (*(char *)(param_1 + 0xd3d8) != 'T') {
          local_38 = _libssh2_channel_packet_data_len(*(undefined8 *)(param_1 + 0xd500),0);
          local_30 = (**(code **)(param_1 + 8))(local_38 + 1,param_1);
          if (local_30 == 0) {
            _libssh2_error(param_1,0xfffffffa,"Failed to get memory ");
          }
          else {
            _libssh2_channel_read(*(undefined8 *)(param_1 + 0xd500),0,local_30,local_38);
            *(undefined *)(local_38 + local_30) = 0;
            _libssh2_error(param_1,0xffffffe4,"Failed to recv file");
            (**(code **)(param_1 + 0x18))(local_30,param_1);
          }
          goto LAB_00133a9b;
        }
        if ((1 < *(ulong *)(param_1 + 0xd4d8)) &&
           ((((*(byte *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7) < 0x30 ||
              (0x39 < *(byte *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7))) &&
             (*(char *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7) != ' ')) &&
            ((*(char *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7) != '\r' &&
             (*(char *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7) != '\n')))))) {
          _libssh2_error(param_1,0xffffffe4,"Invalid data in SCP response");
          goto LAB_00133a9b;
        }
        if ((*(ulong *)(param_1 + 0xd4d8) < 9) ||
           (*(char *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7) != '\n')) {
          if (*(long *)(param_1 + 0xd4d8) == 0x100) {
            _libssh2_error(param_1,0xffffffe4,"Unterminated response from SCP server");
            goto LAB_00133a9b;
          }
          goto LAB_001334c4;
        }
        while ((*(char *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7) == '\r' ||
               (*(char *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7) == '\n'))) {
          *(long *)(param_1 + 0xd4d8) = *(long *)(param_1 + 0xd4d8) + -1;
        }
        *(undefined *)(param_1 + 0xd3d8 + *(long *)(param_1 + 0xd4d8)) = 0;
        if (*(ulong *)(param_1 + 0xd4d8) < 8) {
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, too short");
          goto LAB_00133a9b;
        }
        local_48 = (char *)(param_1 + 0xd3d9);
        pcVar7 = strchr(local_48,0x20);
        if ((pcVar7 == (char *)0x0) || (pcVar7 == local_48 || (long)pcVar7 - (long)local_48 < 0)) {
          local_40 = pcVar7;
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, malformed mtime");
          goto LAB_00133a9b;
        }
        local_40 = pcVar7 + 1;
        *pcVar7 = '\0';
        lVar8 = strtol(local_48,(char **)0x0,10);
        *(long *)(param_1 + 0xd4f0) = lVar8;
        local_48 = strchr(local_40,0x20);
        if ((local_48 == (char *)0x0) ||
           (local_48 == local_40 || (long)local_48 - (long)local_40 < 0)) {
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, malformed mtime.usec"
                        );
          goto LAB_00133a9b;
        }
        local_48 = local_48 + 1;
        local_40 = strchr(local_48,0x20);
        if ((local_40 == (char *)0x0) ||
           (local_40 == local_48 || (long)local_40 - (long)local_48 < 0)) {
          _libssh2_error(param_1,0xffffffe4,
                         "Invalid response from SCP server, too short or malformed");
          goto LAB_00133a9b;
        }
        *local_40 = '\0';
        lVar8 = strtol(local_48,(char **)0x0,10);
        *(long *)(param_1 + 0xd4f8) = lVar8;
        *(undefined *)(param_1 + 0xd3d8) = 0;
        *(undefined4 *)(param_1 + 0xd3c0) = 6;
      }
    } while (*(int *)(param_1 + 0xd3c0) != 6);
    iVar3 = _libssh2_channel_write(*(undefined8 *)(param_1 + 0xd500),0,param_1 + 0xd3d8,1);
    if (iVar3 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block waiting to send SCP ACK");
      uVar5 = 0;
      goto LAB_00133b0e;
    }
    if (iVar3 != 1) goto LAB_00133a9b;
LAB_001334e5:
    *(undefined4 *)(param_1 + 0xd3c0) = 7;
  }
  if (*(int *)(param_1 + 0xd3c0) == 7) {
    *(undefined8 *)(param_1 + 0xd4d8) = 0;
    *(undefined4 *)(param_1 + 0xd3c0) = 8;
  }
  if ((*(int *)(param_1 + 0xd3c0) == 8) || (*(int *)(param_1 + 0xd3c0) == 9)) {
LAB_001339a7:
    do {
      if (0xff < *(ulong *)(param_1 + 0xd4d8)) goto LAB_001339c1;
      local_50 = (char *)0x0;
      if (*(int *)(param_1 + 0xd3c0) == 8) {
        iVar3 = _libssh2_channel_read
                          (*(undefined8 *)(param_1 + 0xd500),0,
                           param_1 + 0xd3d8 + *(long *)(param_1 + 0xd4d8),1);
        if (iVar3 == -0x25) {
          _libssh2_error(param_1,0xffffffdb,"Would block waiting for SCP response");
          uVar5 = 0;
          goto LAB_00133b0e;
        }
        if (iVar3 < 0) {
          _libssh2_error(param_1,iVar3,"Failed reading SCP response");
          goto LAB_00133a9b;
        }
        if (iVar3 == 0) goto LAB_00133a5c;
        *(long *)(param_1 + 0xd4d8) = *(long *)(param_1 + 0xd4d8) + 1;
        if (*(char *)(param_1 + 0xd3d8) != 'C') {
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server");
          goto LAB_00133a9b;
        }
        if ((((1 < *(ulong *)(param_1 + 0xd4d8)) &&
             (*(char *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7) != '\r')) &&
            (*(char *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7) != '\n')) &&
           (*(byte *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7) < 0x20)) {
          _libssh2_error(param_1,0xffffffe4,"Invalid data in SCP response");
          goto LAB_00133a9b;
        }
        if ((*(ulong *)(param_1 + 0xd4d8) < 7) ||
           (*(char *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7) != '\n')) {
          if (*(long *)(param_1 + 0xd4d8) == 0x100) {
            _libssh2_error(param_1,0xffffffe4,"Unterminated response from SCP server");
            goto LAB_00133a9b;
          }
          goto LAB_001339a7;
        }
        while ((*(char *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7) == '\r' ||
               (*(char *)(param_1 + *(long *)(param_1 + 0xd4d8) + 0xd3d7) == '\n'))) {
          *(long *)(param_1 + 0xd4d8) = *(long *)(param_1 + 0xd4d8) + -1;
        }
        *(undefined *)(param_1 + 0xd3d8 + *(long *)(param_1 + 0xd4d8)) = 0;
        if (*(ulong *)(param_1 + 0xd4d8) < 6) {
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, too short");
          goto LAB_00133a9b;
        }
        local_28 = (char *)(param_1 + 0xd3d9);
        pcVar7 = strchr(local_28,0x20);
        if ((pcVar7 == (char *)0x0) || (pcVar7 == local_28 || (long)pcVar7 - (long)local_28 < 0)) {
          local_20 = pcVar7;
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, malformed mode");
          goto LAB_00133a9b;
        }
        local_20 = pcVar7 + 1;
        *pcVar7 = '\0';
        lVar8 = strtol(local_28,&local_50,8);
        *(long *)(param_1 + 0xd4e0) = lVar8;
        if ((local_50 != (char *)0x0) && (*local_50 != '\0')) {
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, invalid mode");
          goto LAB_00133a9b;
        }
        local_28 = strchr(local_20,0x20);
        if ((local_28 == (char *)0x0) ||
           (local_28 == local_20 || (long)local_28 - (long)local_20 < 0)) {
          _libssh2_error(param_1,0xffffffe4,
                         "Invalid response from SCP server, too short or malformed");
          goto LAB_00133a9b;
        }
        *local_28 = '\0';
        lVar9 = strtoll(local_20,&local_50,10);
        *(longlong *)(param_1 + 0xd4e8) = lVar9;
        if ((local_50 != (char *)0x0) && (*local_50 != '\0')) {
          _libssh2_error(param_1,0xffffffe4,"Invalid response from SCP server, invalid size");
          goto LAB_00133a9b;
        }
        *(undefined *)(param_1 + 0xd3d8) = 0;
        *(undefined4 *)(param_1 + 0xd3c0) = 9;
      }
    } while (*(int *)(param_1 + 0xd3c0) != 9);
    iVar3 = _libssh2_channel_write(*(undefined8 *)(param_1 + 0xd500),0,param_1 + 0xd3d8,1);
    if (iVar3 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block sending SCP ACK");
      uVar5 = 0;
      goto LAB_00133b0e;
    }
    if (iVar3 != 1) goto LAB_00133a9b;
LAB_001339c1:
    *(undefined4 *)(param_1 + 0xd3c0) = 10;
  }
  if (param_3 != (void *)0x0) {
    memset(param_3,0,0x90);
    *(undefined8 *)((long)param_3 + 0x58) = *(undefined8 *)(param_1 + 0xd4f0);
    *(undefined8 *)((long)param_3 + 0x48) = *(undefined8 *)(param_1 + 0xd4f8);
    *(undefined8 *)((long)param_3 + 0x30) = *(undefined8 *)(param_1 + 0xd4e8);
    *(uint *)((long)param_3 + 0x18) = (uint)*(undefined8 *)(param_1 + 0xd4e0) & 0xffff;
  }
  *(undefined4 *)(param_1 + 0xd3c0) = 0;
  uVar5 = *(undefined8 *)(param_1 + 0xd500);
  goto LAB_00133b0e;
LAB_00133a5c:
  iVar3 = libssh2_channel_eof(*(undefined8 *)(param_1 + 0xd500));
  if (iVar3 == 0) {
    uVar5 = *(undefined8 *)(param_1 + 0xd500);
    goto LAB_00133b0e;
  }
  _libssh2_error(param_1,0xffffffe4,"Unexpected channel close");
LAB_00133a9b:
  uVar1 = *(undefined4 *)(param_1 + 0x240);
  local_18 = *(undefined8 *)(param_1 + 0x238);
  do {
    iVar3 = libssh2_channel_free(*(undefined8 *)(param_1 + 0xd500));
  } while (iVar3 == -0x25);
  *(undefined4 *)(param_1 + 0x240) = uVar1;
  *(undefined8 *)(param_1 + 0x238) = local_18;
  *(undefined8 *)(param_1 + 0xd500) = 0;
  *(undefined4 *)(param_1 + 0xd3c0) = 0;
  uVar5 = 0;
LAB_00133b0e:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



long libssh2_scp_recv(long param_1,undefined8 param_2,void *param_3)

{
  int iVar1;
  undefined8 *puVar2;
  time_t tVar3;
  long lVar4;
  long in_FS_OFFSET;
  undefined8 local_a8 [3];
  undefined4 local_90;
  undefined8 local_78;
  undefined8 local_60;
  undefined8 local_50;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  puVar2 = local_a8;
  for (lVar4 = 0x12; lVar4 != 0; lVar4 = lVar4 + -1) {
    *puVar2 = 0;
    puVar2 = puVar2 + 1;
  }
  if (param_3 == (void *)0x0) {
    puVar2 = (undefined8 *)0x0;
  }
  else {
    puVar2 = local_a8;
  }
  tVar3 = time((time_t *)0x0);
  do {
    lVar4 = scp_recv(param_1,param_2,puVar2);
    if ((*(int *)(param_1 + 0x94) == 0) || (lVar4 != 0)) break;
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 != -0x25) break;
    iVar1 = _libssh2_wait_socket(param_1,tVar3);
  } while (iVar1 == 0);
  if (param_3 != (void *)0x0) {
    memset(param_3,0,0x90);
    *(undefined8 *)((long)param_3 + 0x58) = local_50;
    *(undefined8 *)((long)param_3 + 0x48) = local_60;
    *(undefined8 *)((long)param_3 + 0x30) = local_78;
    *(undefined4 *)((long)param_3 + 0x18) = local_90;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar4;
}



long libssh2_scp_recv2(long param_1,undefined8 param_2,undefined8 param_3)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  tVar2 = time((time_t *)0x0);
  do {
    lVar3 = scp_recv(param_1,param_2,param_3);
    if (*(int *)(param_1 + 0x94) == 0) {
      return lVar3;
    }
    if (lVar3 != 0) {
      return lVar3;
    }
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 != -0x25) {
      return 0;
    }
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
  } while (iVar1 == 0);
  return 0;
}



undefined8
scp_send(long param_1,char *param_2,uint param_3,undefined8 param_4,long param_5,long param_6)

{
  undefined4 uVar1;
  int iVar2;
  int iVar3;
  size_t sVar4;
  undefined8 uVar5;
  undefined *puVar6;
  char *pcVar7;
  long lVar8;
  long lVar9;
  char *local_28;
  
  if (*(int *)(param_1 + 0xd508) == 0) {
    sVar4 = strlen(param_2);
    if ((param_5 == 0) && (param_6 == 0)) {
      lVar9 = 0;
    }
    else {
      lVar9 = 1;
    }
    *(size_t *)(param_1 + 0xd518) = sVar4 * 3 + lVar9 + 10;
    uVar5 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_1 + 0xd518),param_1);
    *(undefined8 *)(param_1 + 0xd510) = uVar5;
    if (*(long *)(param_1 + 0xd510) == 0) {
      _libssh2_error(param_1,0xfffffffa,"Unable to allocate a command buffer for SCP session");
      return 0;
    }
    if ((param_5 == 0) && (param_6 == 0)) {
      puVar6 = &DAT_00147e2e;
    }
    else {
      puVar6 = &DAT_00147e2c;
    }
    snprintf(*(char **)(param_1 + 0xd510),*(size_t *)(param_1 + 0xd518),"scp -%st ",puVar6);
    sVar4 = strlen(*(char **)(param_1 + 0xd510));
    iVar3 = (int)sVar4;
    iVar2 = shell_quotearg(param_2,*(long *)(param_1 + 0xd510) + (long)iVar3,
                           (int)*(undefined8 *)(param_1 + 0xd518) - iVar3);
    *(long *)(param_1 + 0xd518) = (long)(iVar2 + iVar3);
    *(undefined4 *)(param_1 + 0xd508) = 2;
  }
  if (*(int *)(param_1 + 0xd508) == 2) {
    uVar5 = _libssh2_channel_open(param_1,"session",7,0x200000,0x8000,0,0);
    *(undefined8 *)(param_1 + 0xd628) = uVar5;
    if (*(long *)(param_1 + 0xd628) == 0) {
      iVar3 = libssh2_session_last_errno(param_1);
      if (iVar3 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block starting up channel");
      }
      else {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd510),param_1);
        *(undefined8 *)(param_1 + 0xd510) = 0;
        *(undefined4 *)(param_1 + 0xd508) = 0;
      }
      return 0;
    }
    *(undefined4 *)(param_1 + 0xd508) = 3;
  }
  if (*(int *)(param_1 + 0xd508) == 3) {
    iVar3 = _libssh2_channel_process_startup
                      (*(undefined8 *)(param_1 + 0xd628),&DAT_00147e68,4,
                       *(undefined8 *)(param_1 + 0xd510),*(undefined8 *)(param_1 + 0xd518));
    if (iVar3 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block requesting SCP startup");
      return 0;
    }
    if (iVar3 != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd510),param_1);
      *(undefined8 *)(param_1 + 0xd510) = 0;
      _libssh2_error(param_1,0xffffffe4,"Unknown error while getting error string");
      goto LAB_00134662;
    }
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd510),param_1);
    *(undefined8 *)(param_1 + 0xd510) = 0;
    *(undefined4 *)(param_1 + 0xd508) = 4;
  }
  if (*(int *)(param_1 + 0xd508) == 4) {
    iVar3 = _libssh2_channel_read(*(undefined8 *)(param_1 + 0xd628),0,param_1 + 0xd520,1);
    if (iVar3 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block waiting for response from remote");
      return 0;
    }
    if (iVar3 < 0) {
      _libssh2_error(param_1,iVar3,"SCP failure");
      goto LAB_00134662;
    }
    if (iVar3 != 0) {
      if (*(char *)(param_1 + 0xd520) != '\0') {
        _libssh2_error(param_1,0xffffffe4,"Invalid ACK response from remote");
        goto LAB_00134662;
      }
      if ((param_5 != 0) || (param_6 != 0)) {
        iVar3 = snprintf((char *)(param_1 + 0xd520),0x100,"T%ld 0 %ld 0\n",param_5,param_6);
        *(long *)(param_1 + 0xd620) = (long)iVar3;
      }
      *(undefined4 *)(param_1 + 0xd508) = 5;
      goto LAB_001341ae;
    }
  }
  else {
LAB_001341ae:
    if ((param_5 == 0) && (param_6 == 0)) {
      if (*(int *)(param_1 + 0xd508) == 5) {
        *(undefined4 *)(param_1 + 0xd508) = 7;
      }
    }
    else {
      if (*(int *)(param_1 + 0xd508) == 5) {
        iVar3 = _libssh2_channel_write
                          (*(undefined8 *)(param_1 + 0xd628),0,param_1 + 0xd520,
                           *(undefined8 *)(param_1 + 0xd620));
        if (iVar3 == -0x25) {
          _libssh2_error(param_1,0xffffffdb,"Would block sending time data for SCP file");
          return 0;
        }
        if (iVar3 != (int)*(undefined8 *)(param_1 + 0xd620)) {
          _libssh2_error(param_1,0xfffffff9,"Unable to send time data for SCP file");
          goto LAB_00134662;
        }
        *(undefined4 *)(param_1 + 0xd508) = 6;
      }
      if (*(int *)(param_1 + 0xd508) == 6) {
        iVar3 = _libssh2_channel_read(*(undefined8 *)(param_1 + 0xd628),0,param_1 + 0xd520,1);
        if (iVar3 == -0x25) {
          _libssh2_error(param_1,0xffffffdb,"Would block waiting for response");
          return 0;
        }
        if (iVar3 < 0) {
          _libssh2_error(param_1,iVar3,"SCP failure");
          goto LAB_00134662;
        }
        if (iVar3 == 0) goto LAB_00134624;
        if (*(char *)(param_1 + 0xd520) != '\0') {
          _libssh2_error(param_1,0xffffffe4,"Invalid SCP ACK response");
          goto LAB_00134662;
        }
        *(undefined4 *)(param_1 + 0xd508) = 7;
      }
    }
    if (*(int *)(param_1 + 0xd508) == 7) {
      pcVar7 = strrchr(param_2,0x2f);
      local_28 = param_2;
      if (pcVar7 != (char *)0x0) {
        local_28 = pcVar7 + 1;
      }
      iVar3 = snprintf((char *)(param_1 + 0xd520),0x100,"C0%o %lld %s\n",(ulong)param_3,param_4,
                       local_28);
      *(long *)(param_1 + 0xd620) = (long)iVar3;
      *(undefined4 *)(param_1 + 0xd508) = 8;
    }
    if (*(int *)(param_1 + 0xd508) == 8) {
      iVar3 = _libssh2_channel_write
                        (*(undefined8 *)(param_1 + 0xd628),0,param_1 + 0xd520,
                         *(undefined8 *)(param_1 + 0xd620));
      if (iVar3 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block send core file data for SCP file");
        return 0;
      }
      if (iVar3 != (int)*(undefined8 *)(param_1 + 0xd620)) {
        _libssh2_error(param_1,0xfffffff9,"Unable to send core file data for SCP file");
        goto LAB_00134662;
      }
      *(undefined4 *)(param_1 + 0xd508) = 9;
    }
    if (*(int *)(param_1 + 0xd508) != 9) {
LAB_001345ff:
      *(undefined4 *)(param_1 + 0xd508) = 0;
      return *(undefined8 *)(param_1 + 0xd628);
    }
    iVar3 = _libssh2_channel_read(*(undefined8 *)(param_1 + 0xd628),0,param_1 + 0xd520,1);
    if (iVar3 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block waiting for response");
      return 0;
    }
    if (iVar3 < 0) {
      _libssh2_error(param_1,0xffffffe4,"Invalid ACK response from remote");
      goto LAB_00134662;
    }
    if (iVar3 != 0) {
      if (*(char *)(param_1 + 0xd520) == '\0') goto LAB_001345ff;
      lVar9 = _libssh2_channel_packet_data_len(*(undefined8 *)(param_1 + 0xd628),0);
      lVar8 = (**(code **)(param_1 + 8))(lVar9 + 1,param_1);
      if (lVar8 == 0) {
        _libssh2_error(param_1,0xfffffffa,"failed to get memory");
      }
      else {
        iVar3 = _libssh2_channel_read(*(undefined8 *)(param_1 + 0xd628),0,lVar8,lVar9);
        if (0 < iVar3) {
          *(undefined *)(lVar9 + lVar8) = 0;
        }
        (**(code **)(param_1 + 0x18))(lVar8,param_1);
        _libssh2_error(param_1,0xffffffe4,"failed to send file");
      }
      goto LAB_00134662;
    }
  }
LAB_00134624:
  iVar3 = libssh2_channel_eof(*(undefined8 *)(param_1 + 0xd628));
  if (iVar3 == 0) {
    return *(undefined8 *)(param_1 + 0xd628);
  }
  _libssh2_error(param_1,0xffffffe4,"Unexpected channel close");
LAB_00134662:
  uVar1 = *(undefined4 *)(param_1 + 0x240);
  uVar5 = *(undefined8 *)(param_1 + 0x238);
  do {
    iVar3 = libssh2_channel_free(*(undefined8 *)(param_1 + 0xd628));
  } while (iVar3 == -0x25);
  *(undefined4 *)(param_1 + 0x240) = uVar1;
  *(undefined8 *)(param_1 + 0x238) = uVar5;
  *(undefined8 *)(param_1 + 0xd628) = 0;
  *(undefined4 *)(param_1 + 0xd508) = 0;
  return 0;
}



long libssh2_scp_send_ex(long param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,
                        undefined8 param_5,undefined8 param_6)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  tVar2 = time((time_t *)0x0);
  do {
    lVar3 = scp_send(param_1,param_2,param_3,param_4,param_5,param_6);
    if (*(int *)(param_1 + 0x94) == 0) {
      return lVar3;
    }
    if (lVar3 != 0) {
      return lVar3;
    }
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 != -0x25) {
      return 0;
    }
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
  } while (iVar1 == 0);
  return 0;
}



long libssh2_scp_send64(long param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,
                       undefined8 param_5,undefined8 param_6)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  tVar2 = time((time_t *)0x0);
  do {
    lVar3 = scp_send(param_1,param_2,param_3,param_4,param_5,param_6);
    if (*(int *)(param_1 + 0x94) == 0) {
      return lVar3;
    }
    if (lVar3 != 0) {
      return lVar3;
    }
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 != -0x25) {
      return 0;
    }
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
  } while (iVar1 == 0);
  return 0;
}



void libssh2_default_alloc(size_t param_1)

{
  malloc(param_1);
  return;
}



void libssh2_default_free(void *param_1)

{
  free(param_1);
  return;
}



void libssh2_default_realloc(void *param_1,size_t param_2)

{
  realloc(param_1,param_2);
  return;
}



undefined8 banner_receive(long param_1)

{
  undefined8 uVar1;
  long in_FS_OFFSET;
  char local_19;
  int local_18;
  int local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xcb60) == 0) {
    local_18 = 0;
    *(undefined4 *)(param_1 + 0xcb60) = 2;
  }
  else {
    local_18 = (int)*(undefined8 *)(param_1 + 0xcc68);
  }
  do {
    if ((0xff < local_18) ||
       ((local_18 != 0 && (*(char *)(param_1 + 0xcb64 + (long)(local_18 + -1)) == '\n')))) {
      while ((local_18 != 0 &&
             ((*(char *)(param_1 + 0xcb64 + (long)(local_18 + -1)) == '\n' ||
              (*(char *)(param_1 + 0xcb64 + (long)(local_18 + -1)) == '\r'))))) {
        local_18 = local_18 + -1;
      }
      *(undefined4 *)(param_1 + 0xcb60) = 0;
      *(undefined8 *)(param_1 + 0xcc68) = 0;
      if (local_18 == 0) {
        uVar1 = 0xfffffffe;
      }
      else {
        uVar1 = (**(code **)(param_1 + 8))((long)(local_18 + 1),param_1);
        *(undefined8 *)(param_1 + 0x110) = uVar1;
        if (*(long *)(param_1 + 0x110) == 0) {
          uVar1 = _libssh2_error(param_1,0xfffffffa,"Error allocating space for remote banner");
        }
        else {
          memcpy(*(void **)(param_1 + 0x110),(void *)(param_1 + 0xcb64),(long)local_18);
          *(undefined *)((long)local_18 + *(long *)(param_1 + 0x110)) = 0;
          uVar1 = 0;
        }
      }
LAB_00134b37:
      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
        return uVar1;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    local_19 = '\0';
    *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) & 0xfffffffe;
    if (*(int *)(param_1 + 0x6c) == 0) {
      uVar1 = 0x4000;
    }
    else {
      uVar1 = 0;
    }
    local_14 = (**(code **)(param_1 + 0x50))
                         (*(undefined4 *)(param_1 + 0x228),&local_19,1,uVar1,param_1);
    if (local_14 < 0) {
      if (local_14 == -0xb) {
        *(undefined4 *)(param_1 + 0x230) = 1;
        *(long *)(param_1 + 0xcc68) = (long)local_18;
        uVar1 = 0xffffffdb;
      }
      else {
        *(undefined4 *)(param_1 + 0xcb60) = 0;
        *(undefined8 *)(param_1 + 0xcc68) = 0;
        uVar1 = 0xffffffd5;
      }
      goto LAB_00134b37;
    }
    if (local_14 == 0) {
      *(undefined4 *)(param_1 + 0x22c) = 0xffffffff;
      uVar1 = 0xfffffff3;
      goto LAB_00134b37;
    }
    if (local_19 == '\0') {
      *(undefined4 *)(param_1 + 0xcb60) = 0;
      *(undefined8 *)(param_1 + 0xcc68) = 0;
      uVar1 = 0xfffffffe;
      goto LAB_00134b37;
    }
    *(char *)(param_1 + 0xcb64 + (long)local_18) = local_19;
    local_18 = local_18 + 1;
  } while( true );
}



undefined8 banner_send(long param_1)

{
  size_t sVar1;
  long lVar2;
  undefined8 uVar3;
  int local_1c;
  char *local_18;
  
  local_18 = "SSH-2.0-libssh2_1.9.0_DEV\r\n";
  local_1c = 0x1b;
  if (*(int *)(param_1 + 0xcb60) == 0) {
    if (*(long *)(param_1 + 0x180) != 0) {
      sVar1 = strlen(*(char **)(param_1 + 0x180));
      local_1c = (int)sVar1;
      local_18 = *(char **)(param_1 + 0x180);
    }
    *(undefined4 *)(param_1 + 0xcb60) = 2;
  }
  *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) & 0xfffffffd;
  if (*(int *)(param_1 + 0x6c) == 0) {
    uVar3 = 0x4000;
  }
  else {
    uVar3 = 0;
  }
  lVar2 = (**(code **)(param_1 + 0x48))
                    (*(undefined4 *)(param_1 + 0x228),local_18 + *(long *)(param_1 + 0xcc68),
                     (long)local_1c - *(long *)(param_1 + 0xcc68),uVar3,param_1);
  if (lVar2 == (long)local_1c - *(long *)(param_1 + 0xcc68)) {
    *(undefined4 *)(param_1 + 0xcb60) = 0;
    *(undefined8 *)(param_1 + 0xcc68) = 0;
    uVar3 = 0;
  }
  else if ((lVar2 < 0) && (lVar2 != -0xb)) {
    *(undefined4 *)(param_1 + 0xcb60) = 0;
    *(undefined8 *)(param_1 + 0xcc68) = 0;
    uVar3 = 0xffffffd5;
  }
  else {
    *(undefined4 *)(param_1 + 0x230) = 2;
    if (0 < lVar2) {
      *(long *)(param_1 + 0xcc68) = *(long *)(param_1 + 0xcc68) + lVar2;
    }
    uVar3 = 0xffffffdb;
  }
  return uVar3;
}



void session_nonblock(int param_1,int param_2)

{
  uint uVar1;
  
  uVar1 = fcntl(param_1,3,0);
  if (param_2 == 0) {
    fcntl(param_1,4,(ulong)(uVar1 & 0xfffff7ff));
  }
  else {
    fcntl(param_1,4,(ulong)(uVar1 | 0x800));
  }
  return;
}



uint get_socket_nonblocking(int param_1)

{
  uint uVar1;
  
  uVar1 = fcntl(param_1,3,0);
  if (uVar1 == 0xffffffff) {
    uVar1 = 1;
  }
  else {
    uVar1 = uVar1 & 0x800;
  }
  return uVar1;
}



undefined8 libssh2_session_banner_set(long param_1,char *param_2)

{
  size_t __n;
  undefined8 uVar1;
  
  if (param_2 == (char *)0x0) {
    __n = 0;
  }
  else {
    __n = strlen(param_2);
  }
  if (*(long *)(param_1 + 0x180) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x180),param_1);
    *(undefined8 *)(param_1 + 0x180) = 0;
  }
  if (__n == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = (**(code **)(param_1 + 8))(__n + 3,param_1);
    *(undefined8 *)(param_1 + 0x180) = uVar1;
    if (*(long *)(param_1 + 0x180) == 0) {
      uVar1 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for local banner");
    }
    else {
      memcpy(*(void **)(param_1 + 0x180),param_2,__n);
      *(undefined *)(__n + *(long *)(param_1 + 0x180)) = 0;
      *(undefined *)(__n + *(long *)(param_1 + 0x180)) = 0xd;
      *(undefined *)(__n + 1 + *(long *)(param_1 + 0x180)) = 10;
      *(undefined *)(__n + 2 + *(long *)(param_1 + 0x180)) = 0;
      uVar1 = 0;
    }
  }
  return uVar1;
}



void libssh2_banner_set(undefined8 param_1,undefined8 param_2)

{
  libssh2_session_banner_set(param_1,param_2);
  return;
}



undefined8 * libssh2_session_init_ex(code *param_1,code *param_2,code *param_3,undefined8 param_4)

{
  undefined8 local_48;
  code *local_40;
  code *local_38;
  code *local_30;
  code *local_28;
  code *local_20;
  code *local_18;
  undefined8 *local_10;
  
  local_28 = libssh2_default_alloc;
  local_20 = libssh2_default_free;
  local_18 = libssh2_default_realloc;
  if (param_1 != (code *)0x0) {
    local_28 = param_1;
  }
  if (param_2 != (code *)0x0) {
    local_20 = param_2;
  }
  if (param_3 != (code *)0x0) {
    local_18 = param_3;
  }
  local_48 = param_4;
  local_40 = param_3;
  local_38 = param_2;
  local_30 = param_1;
  local_10 = (undefined8 *)(*local_28)(0xd640,&local_48);
  if (local_10 != (undefined8 *)0x0) {
    memset(local_10,0,0xd640);
    local_10[1] = local_28;
    local_10[3] = local_20;
    local_10[2] = local_18;
    local_10[9] = _libssh2_send;
    local_10[10] = _libssh2_recv;
    *local_10 = local_48;
    local_10[0x13] = 0;
    *(undefined4 *)((long)local_10 + 0x94) = 1;
    _libssh2_init_if_needed();
  }
  return local_10;
}



undefined8 libssh2_session_callback_set(long param_1,undefined4 param_2,undefined8 param_3)

{
  undefined8 uVar1;
  
  switch(param_2) {
  case 0:
    uVar1 = *(undefined8 *)(param_1 + 0x20);
    *(undefined8 *)(param_1 + 0x20) = param_3;
    break;
  case 1:
    uVar1 = *(undefined8 *)(param_1 + 0x28);
    *(undefined8 *)(param_1 + 0x28) = param_3;
    break;
  case 2:
    uVar1 = *(undefined8 *)(param_1 + 0x30);
    *(undefined8 *)(param_1 + 0x30) = param_3;
    break;
  case 3:
    uVar1 = *(undefined8 *)(param_1 + 0x38);
    *(undefined8 *)(param_1 + 0x38) = param_3;
    break;
  case 4:
    uVar1 = *(undefined8 *)(param_1 + 0x40);
    *(undefined8 *)(param_1 + 0x40) = param_3;
    break;
  case 5:
    uVar1 = *(undefined8 *)(param_1 + 0x48);
    *(undefined8 *)(param_1 + 0x48) = param_3;
    break;
  case 6:
    uVar1 = *(undefined8 *)(param_1 + 0x50);
    *(undefined8 *)(param_1 + 0x50) = param_3;
    break;
  default:
    uVar1 = 0;
  }
  return uVar1;
}



ulong _libssh2_wait_socket(long param_1,time_t param_2)

{
  ulong uVar1;
  int __timeout;
  long in_FS_OFFSET;
  double dVar2;
  int local_40;
  int local_3c;
  uint local_38;
  uint local_34;
  long local_30;
  time_t local_28;
  long local_20;
  pollfd local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = 0;
  *(undefined4 *)(param_1 + 0x240) = 0;
  local_38 = libssh2_keepalive_send(param_1,&local_40);
  if ((int)local_38 < 0) {
    uVar1 = (ulong)local_38;
  }
  else {
    local_30 = (long)(local_40 * 1000);
    local_34 = libssh2_session_block_directions(param_1);
    if (local_34 == 0) {
      local_30 = 1000;
    }
    if ((*(long *)(param_1 + 0x98) < 1) ||
       ((local_40 != 0 && (local_30 <= *(long *)(param_1 + 0x98))))) {
      if (local_30 < 1) {
        local_3c = 0;
      }
      else {
        local_3c = 1;
      }
    }
    else {
      local_28 = time((time_t *)0x0);
      dVar2 = difftime(local_28,param_2);
      local_20 = (long)(dVar2 * 1000.0);
      if (*(long *)(param_1 + 0x98) < local_20) {
        uVar1 = _libssh2_error(param_1,0xfffffff7,"API timeout expired");
        goto LAB_0013535d;
      }
      local_30 = *(long *)(param_1 + 0x98) - local_20;
      local_3c = 1;
    }
    local_18.fd = *(int *)(param_1 + 0x228);
    local_18.revents = 0;
    local_18.events = (short)((local_34 & 1) != 0);
    if ((local_34 & 2) != 0) {
      local_18.events = local_18.events | 4;
    }
    if (local_3c == 0) {
      __timeout = -1;
    }
    else {
      __timeout = (int)local_30;
    }
    local_38 = poll(&local_18,1,__timeout);
    if (local_38 == 0) {
      uVar1 = _libssh2_error(param_1,0xfffffff7,"Timed out waiting on socket");
    }
    else if ((int)local_38 < 0) {
      uVar1 = _libssh2_error(param_1,0xfffffff7,"Error waiting on socket");
    }
    else {
      uVar1 = 0;
    }
  }
LAB_0013535d:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



ulong session_startup(long param_1,int param_2)

{
  int iVar1;
  uint uVar2;
  ulong uVar3;
  
  if (*(int *)(param_1 + 0xcc88) == 0) {
    if (param_2 == -1) {
      uVar3 = _libssh2_error(param_1,0xffffffd3,"Bad socket provided");
      return uVar3;
    }
    *(int *)(param_1 + 0x228) = param_2;
    iVar1 = get_socket_nonblocking(*(undefined4 *)(param_1 + 0x228));
    *(uint *)(param_1 + 0x234) = (uint)(iVar1 == 0);
    if ((*(int *)(param_1 + 0x234) != 0) &&
       (iVar1 = session_nonblock(*(undefined4 *)(param_1 + 0x228),1), iVar1 != 0)) {
      uVar3 = _libssh2_error(param_1,iVar1,
                             "Failed changing socket\'s blocking state to non-blocking");
      return uVar3;
    }
    *(undefined4 *)(param_1 + 0xcc88) = 2;
  }
  if (*(int *)(param_1 + 0xcc88) == 2) {
    iVar1 = banner_send(param_1);
    if (iVar1 == -0x25) {
      return 0xffffffdb;
    }
    if (iVar1 != 0) {
      uVar3 = _libssh2_error(param_1,iVar1,"Failed sending banner");
      return uVar3;
    }
    *(undefined4 *)(param_1 + 0xcc88) = 3;
    *(undefined4 *)(param_1 + 0xcb60) = 0;
  }
  if (*(int *)(param_1 + 0xcc88) == 3) {
    do {
      iVar1 = banner_receive(param_1);
      if (iVar1 == -0x25) {
        return 0xffffffdb;
      }
      if (iVar1 != 0) {
        uVar3 = _libssh2_error(param_1,iVar1,"Failed getting banner");
        return uVar3;
      }
      iVar1 = strncmp("SSH-",*(char **)(param_1 + 0x110),4);
    } while (iVar1 != 0);
    *(undefined4 *)(param_1 + 0xcc88) = 4;
  }
  if (*(int *)(param_1 + 0xcc88) == 4) {
    iVar1 = _libssh2_kex_exchange(param_1,0,param_1 + 0xccd0);
    if (iVar1 == -0x25) {
      return 0xffffffdb;
    }
    if (iVar1 != 0) {
      uVar3 = _libssh2_error(param_1,iVar1,"Unable to exchange encryption keys");
      return uVar3;
    }
    *(undefined4 *)(param_1 + 0xcc88) = 5;
  }
  if (*(int *)(param_1 + 0xcc88) == 5) {
    *(undefined *)(param_1 + 0xcca0) = 5;
    _libssh2_htonu32(param_1 + 0xcca1,0xc);
    memcpy((void *)(param_1 + 0xcca5),"ssh-userauth",0xc);
    *(undefined4 *)(param_1 + 0xcc88) = 6;
  }
  if (*(int *)(param_1 + 0xcc88) == 6) {
    iVar1 = _libssh2_transport_send(param_1,param_1 + 0xcca0,0x11,0,0);
    if (iVar1 == -0x25) {
      return 0xffffffdb;
    }
    if (iVar1 != 0) {
      uVar3 = _libssh2_error(param_1,iVar1,"Unable to ask for ssh-userauth service");
      return uVar3;
    }
    *(undefined4 *)(param_1 + 0xcc88) = 7;
  }
  if (*(int *)(param_1 + 0xcc88) == 7) {
    uVar2 = _libssh2_packet_require
                      (param_1,6,param_1 + 0xcc90,param_1 + 0xcc98,0,0,0,param_1 + 0xccc0);
    if (uVar2 == 0) {
      uVar2 = _libssh2_ntohu32(*(long *)(param_1 + 0xcc90) + 1);
      *(ulong *)(param_1 + 0xccb8) = (ulong)uVar2;
      if ((*(long *)(param_1 + 0xccb8) == 0xc) &&
         (iVar1 = strncmp("ssh-userauth",(char *)(*(long *)(param_1 + 0xcc90) + 5),
                          *(size_t *)(param_1 + 0xccb8)), iVar1 == 0)) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xcc90),param_1);
        *(undefined8 *)(param_1 + 0xcc90) = 0;
        *(undefined4 *)(param_1 + 0xcc88) = 0;
        return 0;
      }
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xcc90),param_1);
      *(undefined8 *)(param_1 + 0xcc90) = 0;
      uVar3 = _libssh2_error(param_1,0xfffffff2,"Invalid response received from server");
    }
    else {
      uVar3 = (ulong)uVar2;
    }
  }
  else {
    uVar3 = 0xffffffde;
  }
  return uVar3;
}



int libssh2_session_handshake(long param_1,undefined4 param_2)

{
  int iVar1;
  time_t tVar2;
  
  tVar2 = time((time_t *)0x0);
  while( true ) {
    iVar1 = session_startup(param_1,param_2);
    if (iVar1 != -0x25) {
      return iVar1;
    }
    if (*(int *)(param_1 + 0x94) == 0) break;
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
    if (iVar1 != 0) {
      return iVar1;
    }
  }
  return -0x25;
}



void libssh2_session_startup(undefined8 param_1,undefined4 param_2)

{
  libssh2_session_handshake(param_1,param_2);
  return;
}



undefined4 session_free(long param_1)

{
  int iVar1;
  undefined4 uVar2;
  long lVar3;
  
  if (*(int *)(param_1 + 0xcf70) == 0) {
    *(undefined4 *)(param_1 + 0xcf70) = 2;
  }
  if (*(int *)(param_1 + 0xcf70) == 2) {
    do {
      lVar3 = _libssh2_list_first(param_1 + 0x200);
      if (lVar3 == 0) {
        *(undefined4 *)(param_1 + 0xcf70) = 3;
        goto LAB_001358f4;
      }
      iVar1 = _libssh2_channel_free(lVar3);
    } while (iVar1 != -0x25);
    uVar2 = 0xffffffdb;
  }
  else {
LAB_001358f4:
    if (*(int *)(param_1 + 0xcf70) == 3) {
      do {
        lVar3 = _libssh2_list_first(param_1 + 0x218);
        if (lVar3 == 0) {
          *(undefined4 *)(param_1 + 0xcf70) = 4;
          goto LAB_0013594d;
        }
        iVar1 = _libssh2_channel_forward_cancel(lVar3);
      } while (iVar1 != -0x25);
      uVar2 = 0xffffffdb;
    }
    else {
LAB_0013594d:
      if ((*(uint *)(param_1 + 0x68) & 2) != 0) {
        if ((*(long *)(param_1 + 0xa0) != 0) && (*(long *)(*(long *)(param_1 + 0xa0) + 0x40) != 0))
        {
          (**(code **)(*(long *)(param_1 + 0xa0) + 0x40))(param_1,param_1 + 0xa8);
        }
        if ((*(long *)(param_1 + 0x198) != 0) && (*(long *)(*(long *)(param_1 + 0x198) + 0x38) != 0)
           ) {
          (**(code **)(*(long *)(param_1 + 0x198) + 0x38))(param_1,param_1 + 0x1a0);
        }
        if ((*(long *)(param_1 + 0x1c0) != 0) && (*(long *)(*(long *)(param_1 + 0x1c0) + 0x28) != 0)
           ) {
          (**(code **)(*(long *)(param_1 + 0x1c0) + 0x28))(param_1,1,param_1 + 0x1c8);
        }
        if ((*(long *)(param_1 + 0x1a8) != 0) && (*(long *)(*(long *)(param_1 + 0x1a8) + 0x20) != 0)
           ) {
          (**(code **)(*(long *)(param_1 + 0x1a8) + 0x20))(param_1,param_1 + 0x1b8);
        }
        if ((*(long *)(param_1 + 0x128) != 0) && (*(long *)(*(long *)(param_1 + 0x128) + 0x38) != 0)
           ) {
          (**(code **)(*(long *)(param_1 + 0x128) + 0x38))(param_1,param_1 + 0x130);
        }
        if ((*(long *)(param_1 + 0x150) != 0) && (*(long *)(*(long *)(param_1 + 0x150) + 0x28) != 0)
           ) {
          (**(code **)(*(long *)(param_1 + 0x150) + 0x28))(param_1,0,param_1 + 0x158);
        }
        if ((*(long *)(param_1 + 0x138) != 0) && (*(long *)(*(long *)(param_1 + 0x138) + 0x20) != 0)
           ) {
          (**(code **)(*(long *)(param_1 + 0x138) + 0x20))(param_1,param_1 + 0x148);
        }
        if (*(long *)(param_1 + 0x88) != 0) {
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x88),param_1);
        }
      }
      if (*(long *)(param_1 + 0x110) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x110),param_1);
      }
      if (*(long *)(param_1 + 0x180) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x180),param_1);
      }
      if (*(long *)(param_1 + 0x58) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x58),param_1);
      }
      if (*(long *)(param_1 + 0x60) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x60),param_1);
      }
      if (*(long *)(param_1 + 0x188) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x188),param_1);
      }
      if (*(long *)(param_1 + 0x1d0) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x1d0),param_1);
      }
      if (*(long *)(param_1 + 0x1d8) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x1d8),param_1);
      }
      if (*(long *)(param_1 + 0x1e0) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x1e0),param_1);
      }
      if (*(long *)(param_1 + 0x1e8) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x1e8),param_1);
      }
      if (*(long *)(param_1 + 0x118) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x118),param_1);
      }
      if (*(long *)(param_1 + 0x160) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x160),param_1);
      }
      if (*(long *)(param_1 + 0x168) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x168),param_1);
      }
      if (*(long *)(param_1 + 0x170) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x170),param_1);
      }
      if (*(long *)(param_1 + 0x178) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x178),param_1);
      }
      if (*(long *)(param_1 + 0xcc78) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xcc78),param_1);
      }
      if (*(long *)(param_1 + 0xcc90) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xcc90),param_1);
      }
      if (*(long *)(param_1 + 0xd0a0) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0a0),param_1);
      }
      if (*(long *)(param_1 + 0xd0c0) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0c0),param_1);
      }
      if (*(long *)(param_1 + 0xd0d8) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0d8),param_1);
      }
      if (*(long *)(param_1 + 0xd108) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd108),param_1);
      }
      if (*(long *)(param_1 + 0xd118) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd118),param_1);
      }
      if (*(long *)(param_1 + 0xd0f8) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0f8),param_1);
      }
      if (*(long *)(param_1 + 0xd140) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd140),param_1);
      }
      if (*(long *)(param_1 + 0xd150) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd150),param_1);
      }
      if (*(long *)(param_1 + 0xd160) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd160),param_1);
      }
      if (*(long *)(param_1 + 0xd190) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd190),param_1);
      }
      if (*(long *)(param_1 + 0xd1a0) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd1a0),param_1);
      }
      if (*(long *)(param_1 + 0xd1c8) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd1c8),param_1);
      }
      if (*(long *)(param_1 + 0xd208) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd208),param_1);
      }
      if (*(long *)(param_1 + 0xd218) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd218),param_1);
      }
      if (*(long *)(param_1 + 0xd230) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd230),param_1);
      }
      if (*(long *)(param_1 + 0xd258) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd258),param_1);
      }
      if (*(long *)(param_1 + 0xd288) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd288),param_1);
      }
      if (*(long *)(param_1 + 0xd3c8) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd3c8),param_1);
      }
      if (*(long *)(param_1 + 0xd510) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd510),param_1);
      }
      if (*(long *)(param_1 + 0xd3a0) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd3a0),param_1);
      }
      if (*(long *)(param_1 + 0x4270) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x4278),param_1);
      }
      while (lVar3 = _libssh2_list_first(param_1 + 0x1f0), lVar3 != 0) {
        _libssh2_list_remove(lVar3);
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(lVar3 + 0x18),param_1);
        (**(code **)(param_1 + 0x18))(lVar3,param_1);
      }
      if (*(int *)(param_1 + 0x234) != 0) {
        session_nonblock(*(undefined4 *)(param_1 + 0x228),0);
      }
      if (*(long *)(param_1 + 0xb0) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xb0),param_1);
      }
      if ((*(long *)(param_1 + 0x238) != 0) && ((*(uint *)(param_1 + 0x244) & 1) != 0)) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0x238),param_1);
      }
      (**(code **)(param_1 + 0x18))(param_1,param_1);
      uVar2 = 0;
    }
  }
  return uVar2;
}



int libssh2_session_free(long param_1)

{
  int iVar1;
  time_t tVar2;
  
  tVar2 = time((time_t *)0x0);
  while( true ) {
    iVar1 = session_free(param_1);
    if (iVar1 != -0x25) {
      return iVar1;
    }
    if (*(int *)(param_1 + 0x94) == 0) break;
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
    if (iVar1 != 0) {
      return iVar1;
    }
  }
  return -0x25;
}



undefined8 session_disconnect(long param_1,undefined4 param_2,char *param_3,char *param_4)

{
  int iVar1;
  undefined8 uVar2;
  long in_FS_OFFSET;
  long local_28;
  size_t local_20;
  size_t local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = 0;
  local_18 = 0;
  if (*(int *)(param_1 + 0xcf74) == 0) {
    if (param_3 != (char *)0x0) {
      local_20 = strlen(param_3);
    }
    if (param_4 != (char *)0x0) {
      local_18 = strlen(param_4);
    }
    if (0x100 < local_20) {
      uVar2 = _libssh2_error(param_1,0xffffffde,"too long description");
      goto LAB_00136541;
    }
    *(size_t *)(param_1 + 0xd088) = local_18 + local_20 + 0xd;
    local_28 = param_1 + 0xcf79;
    *(undefined *)(param_1 + 0xcf78) = 1;
    _libssh2_store_u32(&local_28,param_2);
    _libssh2_store_str(&local_28,param_3,local_20);
    _libssh2_store_u32(&local_28,local_18 & 0xffffffff);
    *(undefined4 *)(param_1 + 0xcf74) = 2;
  }
  iVar1 = _libssh2_transport_send
                    (param_1,param_1 + 0xcf78,*(undefined8 *)(param_1 + 0xd088),param_4,local_18);
  if (iVar1 == -0x25) {
    uVar2 = 0xffffffdb;
  }
  else {
    *(undefined4 *)(param_1 + 0xcf74) = 0;
    uVar2 = 0;
  }
LAB_00136541:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



int libssh2_session_disconnect_ex
              (long param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  time_t tVar2;
  
  tVar2 = time((time_t *)0x0);
  while( true ) {
    iVar1 = session_disconnect(param_1,param_2,param_3,param_4);
    if (iVar1 != -0x25) {
      return iVar1;
    }
    if (*(int *)(param_1 + 0x94) == 0) break;
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
    if (iVar1 != 0) {
      return iVar1;
    }
  }
  return -0x25;
}



undefined * libssh2_session_methods(long param_1,undefined4 param_2)

{
  undefined *puVar1;
  undefined8 *local_10;
  
  switch(param_2) {
  case 0:
    local_10 = *(undefined8 **)(param_1 + 0x78);
    break;
  case 1:
    local_10 = *(undefined8 **)(param_1 + 0xa0);
    break;
  case 2:
    local_10 = *(undefined8 **)(param_1 + 0x198);
    break;
  case 3:
    local_10 = *(undefined8 **)(param_1 + 0x128);
    break;
  case 4:
    local_10 = *(undefined8 **)(param_1 + 0x1a8);
    break;
  case 5:
    local_10 = *(undefined8 **)(param_1 + 0x138);
    break;
  case 6:
    local_10 = *(undefined8 **)(param_1 + 0x1c0);
    break;
  case 7:
    local_10 = *(undefined8 **)(param_1 + 0x150);
    break;
  case 8:
    return &DAT_00148533;
  case 9:
    return &DAT_00148533;
  default:
    _libssh2_error(param_1,0xffffffde,"Invalid parameter specified for method_type");
    return (undefined *)0x0;
  }
  if (local_10 == (undefined8 *)0x0) {
    _libssh2_error(param_1,0xffffffef,"No method negotiated");
    puVar1 = (undefined *)0x0;
  }
  else {
    puVar1 = (undefined *)*local_10;
  }
  return puVar1;
}



undefined8 libssh2_session_abstract(undefined8 param_1)

{
  return param_1;
}



undefined4 libssh2_session_last_error(long param_1,long *param_2,undefined4 *param_3,int param_4)

{
  undefined4 uVar1;
  long lVar2;
  char *__s;
  size_t local_18;
  
  local_18 = 0;
  if (*(int *)(param_1 + 0x240) == 0) {
    if (param_2 != (long *)0x0) {
      if (param_4 == 0) {
        *param_2 = (long)&DAT_00148533;
      }
      else {
        lVar2 = (**(code **)(param_1 + 8))(1,param_1);
        *param_2 = lVar2;
        if (*param_2 != 0) {
          *(undefined *)*param_2 = 0;
        }
      }
    }
    if (param_3 != (undefined4 *)0x0) {
      *param_3 = 0;
    }
    uVar1 = 0;
  }
  else {
    if (param_2 != (long *)0x0) {
      if (*(long *)(param_1 + 0x238) == 0) {
        __s = "";
      }
      else {
        __s = *(char **)(param_1 + 0x238);
      }
      local_18 = strlen(__s);
      if (param_4 == 0) {
        *param_2 = (long)__s;
      }
      else {
        lVar2 = (**(code **)(param_1 + 8))(local_18 + 1,param_1);
        *param_2 = lVar2;
        if (*param_2 != 0) {
          memcpy((void *)*param_2,__s,local_18);
          *(undefined *)(local_18 + *param_2) = 0;
        }
      }
    }
    if (param_3 != (undefined4 *)0x0) {
      *param_3 = (int)local_18;
    }
    uVar1 = *(undefined4 *)(param_1 + 0x240);
  }
  return uVar1;
}



undefined4 libssh2_session_last_errno(long param_1)

{
  return *(undefined4 *)(param_1 + 0x240);
}



void libssh2_session_set_last_error(undefined8 param_1,undefined4 param_2,undefined8 param_3)

{
  _libssh2_error_flags(param_1,param_2,param_3,1);
  return;
}



undefined8 libssh2_session_flag(long param_1,int param_2,undefined4 param_3)

{
  if (param_2 == 1) {
    *(undefined4 *)(param_1 + 0x6c) = param_3;
  }
  else {
    if (param_2 != 2) {
      return 0xffffffde;
    }
    *(undefined4 *)(param_1 + 0x70) = param_3;
  }
  return 0;
}



undefined4 _libssh2_session_set_blocking(long param_1,undefined4 param_2)

{
  undefined4 uVar1;
  
  uVar1 = *(undefined4 *)(param_1 + 0x94);
  *(undefined4 *)(param_1 + 0x94) = param_2;
  return uVar1;
}



void libssh2_session_set_blocking(undefined8 param_1,undefined4 param_2)

{
  _libssh2_session_set_blocking(param_1,param_2);
  return;
}



undefined4 libssh2_session_get_blocking(long param_1)

{
  return *(undefined4 *)(param_1 + 0x94);
}



void libssh2_session_set_timeout(long param_1,undefined8 param_2)

{
  *(undefined8 *)(param_1 + 0x98) = param_2;
  return;
}



undefined8 libssh2_session_get_timeout(long param_1)

{
  return *(undefined8 *)(param_1 + 0x98);
}



undefined8 libssh2_poll_channel_read(long param_1,int param_2)

{
  int iVar1;
  int iVar2;
  undefined8 uVar3;
  long local_28;
  
  if (param_1 == 0) {
    uVar3 = 0xffffffd9;
  }
  else {
    for (local_28 = _libssh2_list_first(*(long *)(param_1 + 0x60) + 0x1f0); local_28 != 0;
        local_28 = _libssh2_list_next(local_28)) {
      iVar1 = *(int *)(param_1 + 0x30);
      iVar2 = _libssh2_ntohu32(*(long *)(local_28 + 0x18) + 1);
      if (iVar1 == iVar2) {
        if ((param_2 == 1) &&
           ((**(char **)(local_28 + 0x18) == '_' || (**(char **)(local_28 + 0x18) == '^')))) {
          return 1;
        }
        if ((param_2 == 0) && (**(char **)(local_28 + 0x18) == '^')) {
          return 1;
        }
      }
    }
    uVar3 = 0;
  }
  return uVar3;
}



bool poll_channel_write(long param_1)

{
  return *(int *)(param_1 + 0x38) != 0;
}



bool poll_listener_queued(long param_1)

{
  long lVar1;
  
  lVar1 = _libssh2_list_first(param_1 + 0x30);
  return lVar1 != 0;
}



int libssh2_poll(long param_1,uint param_2,long param_3)

{
  char cVar1;
  byte bVar2;
  int iVar3;
  long in_FS_OFFSET;
  uint local_854;
  int local_850;
  long local_848;
  long local_840;
  timeval local_838;
  timeval local_828;
  pollfd local_818 [257];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_840 = 0;
  if (param_2 < 0x101) {
    for (local_854 = 0; local_848 = param_3, local_854 < param_2; local_854 = local_854 + 1) {
      *(undefined8 *)(param_1 + (ulong)local_854 * 0x20 + 0x18) = 0;
      bVar2 = *(byte *)(param_1 + (ulong)local_854 * 0x20);
      if (bVar2 == 3) {
        local_818[local_854].fd =
             *(int *)(*(long *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x18) + 0x228);
        local_818[local_854].events = 1;
        local_818[local_854].revents = 0;
        if (local_840 == 0) {
          local_840 = *(long *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x18);
        }
      }
      else {
        if (3 < bVar2) {
LAB_00136d01:
          if (local_840 != 0) {
            _libssh2_error(local_840,0xffffffdd,"Invalid descriptor passed to libssh2_poll()");
          }
          local_850 = -1;
          goto LAB_00137563;
        }
        if (bVar2 == 1) {
          local_818[local_854].fd = *(int *)(param_1 + (ulong)local_854 * 0x20 + 8);
          local_818[local_854].events =
               (short)*(undefined8 *)(param_1 + (ulong)local_854 * 0x20 + 0x10);
          local_818[local_854].revents = 0;
        }
        else {
          if (bVar2 != 2) goto LAB_00136d01;
          local_818[local_854].fd =
               *(int *)(*(long *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x60) + 0x228);
          local_818[local_854].events = 1;
          local_818[local_854].revents = 0;
          if (local_840 == 0) {
            local_840 = *(long *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x60);
          }
        }
      }
    }
    do {
      local_850 = 0;
      for (local_854 = 0; local_854 < param_2; local_854 = local_854 + 1) {
        if (*(long *)(param_1 + (ulong)local_854 * 0x20 + 0x10) !=
            *(long *)(param_1 + (ulong)local_854 * 0x20 + 0x18)) {
          cVar1 = *(char *)(param_1 + (ulong)local_854 * 0x20);
          if (cVar1 == '\x02') {
            if (((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x10) & 1) != 0) &&
               ((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) & 1) == 0)) {
              iVar3 = libssh2_poll_channel_read
                                (*(undefined8 *)(param_1 + (ulong)local_854 * 0x20 + 8),0);
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   (long)(int)(uint)(iVar3 != 0) |
                   *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18);
            }
            if (((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x10) & 2) != 0) &&
               ((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) & 2) == 0)) {
              iVar3 = libssh2_poll_channel_read
                                (*(undefined8 *)(param_1 + (ulong)local_854 * 0x20 + 8),1);
              if (iVar3 == 0) {
                iVar3 = 0;
              }
              else {
                iVar3 = 2;
              }
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   (long)iVar3 | *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18);
            }
            if (((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x10) & 4) != 0) &&
               ((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) & 4) == 0)) {
              iVar3 = poll_channel_write(*(undefined8 *)(param_1 + (ulong)local_854 * 0x20 + 8));
              if (iVar3 == 0) {
                iVar3 = 0;
              }
              else {
                iVar3 = 4;
              }
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   (long)iVar3 | *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18);
            }
            if ((*(char *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x54) != '\0') ||
               (*(char *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x40) != '\0')) {
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) | 0x80;
            }
            if (*(int *)(*(long *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x60) + 0x22c)
                == -1) {
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) | 0x90;
            }
          }
          else if (cVar1 == '\x03') {
            if (((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x10) & 1) != 0) &&
               ((*(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) & 1) == 0)) {
              iVar3 = poll_listener_queued(*(undefined8 *)(param_1 + (ulong)local_854 * 0x20 + 8));
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   (long)(int)(uint)(iVar3 != 0) |
                   *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18);
            }
            if (*(int *)(*(long *)(*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x18) + 0x22c)
                == -1) {
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) | 0x90;
            }
          }
        }
        if (*(long *)(param_1 + (ulong)local_854 * 0x20 + 0x18) != 0) {
          local_850 = local_850 + 1;
        }
      }
      if (local_850 != 0) {
        local_848 = 0;
      }
      gettimeofday(&local_838,(__timezone_ptr_t)0x0);
      iVar3 = poll(local_818,(ulong)param_2,(int)local_848);
      gettimeofday(&local_828,(__timezone_ptr_t)0x0);
      local_848 = (local_848 + (local_828.tv_sec - local_838.tv_sec) * -1000) -
                  (local_828.tv_usec - local_838.tv_usec) / 1000;
      if (0 < iVar3) {
        for (local_854 = 0; local_854 < param_2; local_854 = local_854 + 1) {
          bVar2 = *(byte *)(param_1 + (ulong)local_854 * 0x20);
          if (bVar2 == 3) {
            if ((local_818[local_854].events & 1U) != 0) {
              do {
                iVar3 = _libssh2_transport_read
                                  (*(undefined8 *)
                                    (*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x18));
              } while (0 < iVar3);
            }
            if ((local_818[local_854].revents & 0x10U) != 0) {
              *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) | 0x90;
            }
            local_818[local_854].revents = 0;
          }
          else if (bVar2 < 4) {
            if (bVar2 == 1) {
              *(long *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                   (long)local_818[local_854].revents;
              local_818[local_854].revents = 0;
              if (*(long *)(param_1 + (ulong)local_854 * 0x20 + 0x18) != 0) {
                local_850 = local_850 + 1;
              }
            }
            else if (bVar2 == 2) {
              if ((local_818[local_854].events & 1U) != 0) {
                do {
                  iVar3 = _libssh2_transport_read
                                    (*(undefined8 *)
                                      (*(long *)(param_1 + (ulong)local_854 * 0x20 + 8) + 0x60));
                } while (0 < iVar3);
              }
              if ((local_818[local_854].revents & 0x10U) != 0) {
                *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) =
                     *(ulong *)(param_1 + (ulong)local_854 * 0x20 + 0x18) | 0x90;
              }
              local_818[local_854].revents = 0;
            }
          }
        }
      }
    } while ((0 < local_848) && (local_850 == 0));
  }
  else {
    local_850 = -1;
  }
LAB_00137563:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_850;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined4 libssh2_session_block_directions(long param_1)

{
  return *(undefined4 *)(param_1 + 0x230);
}



undefined8 libssh2_session_banner_get(long param_1)

{
  undefined8 uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else if (*(long *)(param_1 + 0x110) == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *(undefined8 *)(param_1 + 0x110);
  }
  return uVar1;
}



int sftp_attrsize(uint param_1)

{
  return (param_1 & 8) + (param_1 & 1) * 8 + 4 + (param_1 & 2) * 4 + (param_1 & 4);
}



void _libssh2_store_u64(long *param_1,undefined8 param_2)

{
  undefined *puVar1;
  
  puVar1 = (undefined *)*param_1;
  *puVar1 = (char)((ulong)param_2 >> 0x38);
  puVar1[1] = (char)((ulong)param_2 >> 0x30);
  puVar1[2] = (char)((ulong)param_2 >> 0x28);
  puVar1[3] = (char)((ulong)param_2 >> 0x20);
  puVar1[4] = (char)((ulong)param_2 >> 0x18);
  puVar1[5] = (char)((ulong)param_2 >> 0x10);
  puVar1[6] = (char)((ulong)param_2 >> 8);
  puVar1[7] = (char)param_2;
  *param_1 = *param_1 + 8;
  return;
}



long find_zombie_request(long param_1,int param_2)

{
  long local_10;
  
  for (local_10 = _libssh2_list_first(param_1 + 0x20);
      (local_10 != 0 && (param_2 != *(int *)(local_10 + 0x18)));
      local_10 = _libssh2_list_next(local_10)) {
  }
  return local_10;
}



void remove_zombie_request(long *param_1,undefined4 param_2)

{
  long lVar1;
  long lVar2;
  
  lVar1 = *(long *)(*param_1 + 0x60);
  lVar2 = find_zombie_request(param_1,param_2);
  if (lVar2 != 0) {
    _libssh2_list_remove(lVar2);
    (**(code **)(lVar1 + 0x18))(lVar2,lVar1);
  }
  return;
}



undefined8 add_zombie_request(long *param_1,undefined4 param_2)

{
  long lVar1;
  undefined8 uVar2;
  
  uVar2 = *(undefined8 *)(*param_1 + 0x60);
  lVar1 = (**(code **)(*(long *)(*param_1 + 0x60) + 8))(0x20,*(undefined8 *)(*param_1 + 0x60));
  if (lVar1 == 0) {
    uVar2 = _libssh2_error(uVar2,0xfffffffa,"malloc fail for zombie request  ID");
  }
  else {
    *(undefined4 *)(lVar1 + 0x18) = param_2;
    _libssh2_list_add(param_1 + 4,lVar1);
    uVar2 = 0;
  }
  return uVar2;
}



undefined8 sftp_packet_add(long *param_1,byte *param_2,undefined8 param_3)

{
  byte bVar1;
  long lVar2;
  uint uVar3;
  undefined4 uVar4;
  undefined8 uVar5;
  long lVar6;
  
  lVar2 = *(long *)(*param_1 + 0x60);
  bVar1 = *param_2;
  if (0xc9 < bVar1) goto LAB_0013786e;
  uVar3 = (uint)bVar1;
  if (uVar3 < 200) {
    if (uVar3 < 0x15) {
      if (bVar1 != 0) goto code_r0x0013788c;
    }
    else if (uVar3 - 0x65 < 5) goto code_r0x0013788c;
LAB_0013786e:
    uVar5 = _libssh2_error(lVar2,0xffffffe1,"Out of sync with the world");
  }
  else {
code_r0x0013788c:
    uVar4 = _libssh2_ntohu32(param_2 + 1);
    if (((*param_2 == 0x65) || (*param_2 == 0x67)) &&
       (lVar6 = find_zombie_request(param_1,uVar4), lVar6 != 0)) {
      (**(code **)(lVar2 + 0x18))(param_2,lVar2);
      remove_zombie_request(param_1,uVar4);
      uVar5 = 0;
    }
    else {
      lVar6 = (**(code **)(lVar2 + 8))(0x30,lVar2);
      if (lVar6 == 0) {
        uVar5 = _libssh2_error(lVar2,0xfffffffa,"Unable to allocate datablock for SFTP packet");
      }
      else {
        *(byte **)(lVar6 + 0x20) = param_2;
        *(undefined8 *)(lVar6 + 0x28) = param_3;
        *(undefined4 *)(lVar6 + 0x18) = uVar4;
        _libssh2_list_add(param_1 + 2,lVar6);
        uVar5 = 0;
      }
    }
  }
  return uVar5;
}



ulong sftp_packet_read(long *param_1)

{
  byte bVar1;
  long lVar2;
  long lVar3;
  undefined4 uVar4;
  int iVar5;
  ulong uVar6;
  byte *local_30;
  
  lVar2 = *param_1;
  lVar3 = *(long *)(lVar2 + 0x60);
  local_30 = (byte *)0x0;
  if (*(int *)(param_1 + 0x13) == 3) {
    *(undefined4 *)(param_1 + 0x13) = 0;
    local_30 = (byte *)param_1[10];
  }
  else {
    if (*(int *)(param_1 + 0x13) == 4) {
      *(undefined4 *)(param_1 + 0x13) = 0;
      local_30 = (byte *)param_1[10];
    }
    if (local_30 != (byte *)0x0) goto LAB_00137c8e;
    uVar6 = _libssh2_channel_read(lVar2,0,(long)param_1 + param_1[9] + 0x44,4 - param_1[9]);
    if (uVar6 == 0xffffffffffffffdb) {
      return 0xffffffffffffffdb;
    }
    if ((long)uVar6 < 0) {
      uVar6 = _libssh2_error(lVar3,uVar6 & 0xffffffff,"channel read");
      return uVar6;
    }
    param_1[9] = param_1[9] + uVar6;
    if (param_1[9] != 4) {
      return 0xffffffdb;
    }
    uVar4 = _libssh2_ntohu32((long)param_1 + 0x44);
    *(undefined4 *)(param_1 + 0xb) = uVar4;
    if (0x40000 < *(uint *)(param_1 + 0xb)) {
      uVar6 = _libssh2_error(lVar3,0xffffffe7,"SFTP packet too large");
      return uVar6;
    }
    local_30 = (byte *)(**(code **)(lVar3 + 8))(*(undefined4 *)(param_1 + 0xb),lVar3);
    if (local_30 == (byte *)0x0) {
      uVar6 = _libssh2_error(lVar3,0xfffffffa,"Unable to allocate SFTP packet");
      return uVar6;
    }
    param_1[9] = 0;
    param_1[0xc] = 0;
    param_1[10] = (long)local_30;
  }
  uVar6 = libssh2_channel_window_read_ex(lVar2,0,0);
  if (uVar6 < *(uint *)(param_1 + 0xb)) {
    iVar5 = _libssh2_channel_receive_window_adjust(lVar2,*(int *)(param_1 + 0xb) * 2,1,0);
    if (iVar5 == -0x25) {
      uVar4 = 3;
    }
    else {
      uVar4 = 0;
    }
    *(undefined4 *)(param_1 + 0x13) = uVar4;
    if (iVar5 == -0x25) {
      return 0xffffffffffffffdb;
    }
  }
LAB_00137c8e:
  while( true ) {
    if ((ulong)*(uint *)(param_1 + 0xb) <= (ulong)param_1[0xc]) {
      param_1[10] = 0;
      bVar1 = *local_30;
      iVar5 = sftp_packet_add(param_1,local_30,*(undefined4 *)(param_1 + 0xb));
      uVar6 = (ulong)iVar5;
      if (uVar6 == 0) {
        uVar6 = (ulong)bVar1;
      }
      else {
        (**(code **)(lVar3 + 0x18))(local_30,lVar3);
      }
      return uVar6;
    }
    uVar6 = _libssh2_channel_read
                      (lVar2,0,local_30 + param_1[0xc],
                       (ulong)*(uint *)(param_1 + 0xb) - param_1[0xc]);
    if (uVar6 == 0xffffffffffffffdb) break;
    if ((long)uVar6 < 0) {
      (**(code **)(lVar3 + 0x18))(local_30,lVar3);
      param_1[10] = 0;
      uVar6 = _libssh2_error(lVar3,uVar6 & 0xffffffff,"Error waiting for SFTP packet");
      return uVar6;
    }
    param_1[0xc] = param_1[0xc] + uVar6;
  }
  *(undefined4 *)(param_1 + 0x13) = 4;
  return 0xffffffffffffffdb;
}



void sftp_packetlist_flush(long param_1)

{
  long in_FS_OFFSET;
  int local_44;
  undefined8 local_40;
  undefined local_38 [8];
  long local_30;
  long *local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *(long **)(param_1 + 0x18);
  local_20 = *(long *)(*local_28 + 0x60);
  local_30 = _libssh2_list_first(param_1 + 0x178);
  while (local_30 != 0) {
    local_18 = _libssh2_list_next(local_30);
    local_44 = sftp_packet_ask(local_28,0x65,*(undefined4 *)(local_30 + 0x38),&local_40,local_38);
    if (local_44 != 0) {
      local_44 = sftp_packet_ask(local_28,0x67,*(undefined4 *)(local_30 + 0x38),&local_40,local_38);
    }
    if (local_44 == 0) {
      (**(code **)(local_20 + 0x18))(local_40,local_20);
    }
    else if (*(long *)(local_30 + 0x28) != 0) {
      add_zombie_request(local_28,*(undefined4 *)(local_30 + 0x38));
    }
    _libssh2_list_remove(local_30);
    (**(code **)(local_20 + 0x18))(local_30,local_20);
    local_30 = local_18;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



undefined8
sftp_packet_ask(long *param_1,char param_2,int param_3,undefined8 *param_4,undefined8 *param_5)

{
  long lVar1;
  long local_18;
  
  lVar1 = *(long *)(*param_1 + 0x60);
  local_18 = _libssh2_list_first(param_1 + 2);
  if (local_18 != 0) {
    for (; local_18 != 0; local_18 = _libssh2_list_next(local_18)) {
      if ((param_2 == **(char **)(local_18 + 0x20)) &&
         ((param_2 == '\x02' || (param_3 == *(int *)(local_18 + 0x18))))) {
        *param_4 = *(undefined8 *)(local_18 + 0x20);
        *param_5 = *(undefined8 *)(local_18 + 0x28);
        _libssh2_list_remove(local_18);
        (**(code **)(lVar1 + 0x18))(local_18,lVar1);
        return 0;
      }
    }
  }
  return 0xffffffff;
}



int sftp_packet_require(long *param_1,undefined param_2,undefined4 param_3,undefined8 param_4,
                       undefined8 param_5)

{
  long lVar1;
  int iVar2;
  
  lVar1 = *(long *)(*param_1 + 0x60);
  iVar2 = sftp_packet_ask(param_1,param_2,param_3,param_4,param_5);
  while( true ) {
    if (iVar2 == 0) {
      return 0;
    }
    if (*(int *)(lVar1 + 0x22c) != 0) break;
    iVar2 = sftp_packet_read(param_1);
    if (iVar2 < 0) {
      return iVar2;
    }
    iVar2 = sftp_packet_ask(param_1,param_2,param_3,param_4,param_5);
  }
  return -0xd;
}



int sftp_packet_requirev
              (long *param_1,int param_2,long param_3,undefined4 param_4,undefined8 param_5,
              undefined8 param_6)

{
  int iVar1;
  time_t tVar2;
  int local_18;
  
  if (param_1[0xd] == 0) {
    tVar2 = time((time_t *)0x0);
    param_1[0xd] = tVar2;
  }
  do {
    do {
      if (*(int *)(*(long *)(*param_1 + 0x60) + 0x22c) != 0) {
        param_1[0xd] = 0;
        return -0xd;
      }
      for (local_18 = 0; local_18 < param_2; local_18 = local_18 + 1) {
        iVar1 = sftp_packet_ask(param_1,*(undefined *)(param_3 + local_18),param_4,param_5,param_6);
        if (iVar1 == 0) {
          param_1[0xd] = 0;
          return 0;
        }
      }
      iVar1 = sftp_packet_read(param_1);
      if ((iVar1 < 0) && (iVar1 != -0x25)) {
        param_1[0xd] = 0;
        return iVar1;
      }
    } while (0 < iVar1);
    tVar2 = time((time_t *)0x0);
    if (0x3c - (tVar2 - param_1[0xd]) < 1) {
      param_1[0xd] = 0;
      return -9;
    }
  } while (iVar1 != -0x25);
  return -0x25;
}



long sftp_attr2bin(long param_1,ulong *param_2)

{
  long in_FS_OFFSET;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = param_1;
  if (param_2 == (ulong *)0x0) {
    _libssh2_htonu32(param_1,0);
    param_1 = 4;
  }
  else {
    _libssh2_store_u32(&local_18,(uint)*param_2 & 0xf);
    if ((*param_2 & 1) != 0) {
      _libssh2_store_u64(&local_18,param_2[1]);
    }
    if ((*param_2 & 2) != 0) {
      _libssh2_store_u32(&local_18,param_2[2] & 0xffffffff);
      _libssh2_store_u32(&local_18,param_2[3] & 0xffffffff);
    }
    if ((*param_2 & 4) != 0) {
      _libssh2_store_u32(&local_18,param_2[4] & 0xffffffff);
    }
    if ((*param_2 & 8) != 0) {
      _libssh2_store_u32(&local_18,param_2[5] & 0xffffffff);
      _libssh2_store_u32(&local_18,param_2[6] & 0xffffffff);
    }
    param_1 = local_18 - param_1;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return param_1;
}



long sftp_bin2attr(ulong *param_1,long param_2)

{
  uint uVar1;
  ulong uVar2;
  long local_10;
  
  memset(param_1,0,0x38);
  uVar1 = _libssh2_ntohu32(param_2);
  *param_1 = (ulong)uVar1;
  local_10 = param_2 + 4;
  if ((*param_1 & 1) != 0) {
    uVar2 = _libssh2_ntohu64(local_10);
    param_1[1] = uVar2;
    local_10 = param_2 + 0xc;
  }
  if ((*param_1 & 2) != 0) {
    uVar1 = _libssh2_ntohu32(local_10);
    param_1[2] = (ulong)uVar1;
    uVar1 = _libssh2_ntohu32(local_10 + 4);
    param_1[3] = (ulong)uVar1;
    local_10 = local_10 + 8;
  }
  if ((*param_1 & 4) != 0) {
    uVar1 = _libssh2_ntohu32(local_10);
    param_1[4] = (ulong)uVar1;
    local_10 = local_10 + 4;
  }
  if ((*param_1 & 8) != 0) {
    uVar1 = _libssh2_ntohu32(local_10);
    param_1[5] = (ulong)uVar1;
    uVar1 = _libssh2_ntohu32(local_10 + 4);
    param_1[6] = (ulong)uVar1;
    local_10 = local_10 + 8;
  }
  return local_10 - param_2;
}



void libssh2_sftp_dtor(long param_1,undefined8 param_2,undefined8 param_3,long *param_4)

{
  long lVar1;
  
  lVar1 = *param_4;
  if (*(long *)(lVar1 + 0x50) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(lVar1 + 0x50),param_1);
  }
  if (*(long *)(lVar1 + 0xb8) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(lVar1 + 0xb8),param_1);
  }
  (**(code **)(param_1 + 0x18))(lVar1,param_1);
  return;
}



long * sftp_init(long param_1)

{
  int iVar1;
  undefined4 uVar2;
  uint uVar3;
  undefined8 uVar4;
  long *plVar5;
  long in_FS_OFFSET;
  long local_48;
  ulong local_40;
  ulong local_38;
  long *local_30;
  long local_28;
  ulong local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd39c) == 0) {
    if (*(long *)(param_1 + 0xd3a0) != 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("session->sftpInit_sftp == NULL",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-3857_Libssh2/Libssh2/src/sftp.c"
                    ,0x2dc,"sftp_init");
    }
    *(undefined8 *)(param_1 + 0xd3a0) = 0;
    *(undefined4 *)(param_1 + 0xd39c) = 2;
  }
  local_30 = *(long **)(param_1 + 0xd3a0);
  if (*(int *)(param_1 + 0xd39c) == 2) {
    uVar4 = _libssh2_channel_open(param_1,"session",7,0x200000,0x8000,0,0);
    *(undefined8 *)(param_1 + 0xd3a8) = uVar4;
    if (*(long *)(param_1 + 0xd3a8) == 0) {
      iVar1 = libssh2_session_last_errno(param_1);
      if (iVar1 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block starting up channel");
      }
      else {
        _libssh2_error(param_1,0xffffffeb,"Unable to startup channel");
        *(undefined4 *)(param_1 + 0xd39c) = 0;
      }
      plVar5 = (long *)0x0;
      goto LAB_00138a8c;
    }
    *(undefined4 *)(param_1 + 0xd39c) = 3;
  }
  if (*(int *)(param_1 + 0xd39c) == 3) {
    iVar1 = _libssh2_channel_process_startup
                      (*(undefined8 *)(param_1 + 0xd3a8),"subsystem",9,&DAT_0014878a,4);
    if (iVar1 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block to request SFTP subsystem");
      plVar5 = (long *)0x0;
      goto LAB_00138a8c;
    }
    if (iVar1 == 0) {
      *(undefined4 *)(param_1 + 0xd39c) = 4;
      goto LAB_00138646;
    }
    _libssh2_error(param_1,0xffffffeb,"Unable to request SFTP subsystem");
  }
  else {
LAB_00138646:
    if (*(int *)(param_1 + 0xd39c) == 4) {
      iVar1 = _libssh2_channel_extended_data(*(undefined8 *)(param_1 + 0xd3a8),1);
      local_28 = (long)iVar1;
      if (local_28 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block requesting handle extended data");
        plVar5 = (long *)0x0;
        goto LAB_00138a8c;
      }
      uVar4 = _libssh2_calloc(param_1,0x160);
      *(undefined8 *)(param_1 + 0xd3a0) = uVar4;
      local_30 = *(long **)(param_1 + 0xd3a0);
      if (local_30 == (long *)0x0) {
        _libssh2_error(param_1,0xfffffffa,"Unable to allocate a new SFTP structure");
        goto LAB_00138a14;
      }
      *local_30 = *(long *)(param_1 + 0xd3a8);
      *(undefined4 *)(local_30 + 1) = 0;
      _libssh2_htonu32(param_1 + 0xd3b0,5);
      *(undefined *)(param_1 + 0xd3b4) = 1;
      _libssh2_htonu32(param_1 + 0xd3b5,3);
      *(undefined4 *)(param_1 + 0xd3bc) = 0;
      *(undefined4 *)(param_1 + 0xd39c) = 5;
    }
    if (*(int *)(param_1 + 0xd39c) == 5) {
      local_28 = _libssh2_channel_write
                           (*(undefined8 *)(param_1 + 0xd3a8),0,
                            param_1 + 0xd3b0 + (long)*(int *)(param_1 + 0xd3bc),
                            (long)(9 - *(int *)(param_1 + 0xd3bc)));
      if (local_28 == -0x25) {
        _libssh2_error(param_1,0xffffffdb,"Would block sending SSH_FXP_INIT");
        plVar5 = (long *)0x0;
        goto LAB_00138a8c;
      }
      if (local_28 < 0) {
        _libssh2_error(param_1,0xfffffff9,"Unable to send SSH_FXP_INIT");
        goto LAB_00138a14;
      }
      *(int *)(param_1 + 0xd3bc) = (int)local_28 + *(int *)(param_1 + 0xd3bc);
      if (*(int *)(param_1 + 0xd3bc) == 9) {
        *(undefined4 *)(param_1 + 0xd39c) = 6;
      }
    }
    iVar1 = sftp_packet_require(local_30,2,0,&local_48,&local_40);
    local_28 = (long)iVar1;
    if (local_28 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block receiving SSH_FXP_VERSION");
      plVar5 = (long *)0x0;
      goto LAB_00138a8c;
    }
    if (local_28 == 0) {
      if (4 < local_40) {
        local_38 = local_48 + 1;
        uVar2 = _libssh2_ntohu32(local_38);
        *(undefined4 *)((long)local_30 + 0xc) = uVar2;
        local_38 = local_38 + 4;
        if (3 < *(uint *)((long)local_30 + 0xc)) {
          *(undefined4 *)((long)local_30 + 0xc) = 3;
        }
        for (; local_38 < local_40 + local_48; local_38 = local_38 + 4 + local_18) {
          uVar3 = _libssh2_ntohu32(local_38);
          local_20 = (ulong)uVar3;
          local_38 = local_38 + 4 + local_20;
          uVar3 = _libssh2_ntohu32(local_38);
          local_18 = (ulong)uVar3;
        }
        (**(code **)(param_1 + 0x18))(local_48,param_1);
        *(long **)(*local_30 + 0x68) = local_30;
        *(code **)(*local_30 + 0x70) = libssh2_sftp_dtor;
        *(undefined4 *)(param_1 + 0xd39c) = 0;
        *(undefined8 *)(param_1 + 0xd3a0) = 0;
        *(undefined8 *)(param_1 + 0xd3a8) = 0;
        _libssh2_list_init(local_30 + 6);
        plVar5 = local_30;
        goto LAB_00138a8c;
      }
      _libssh2_error(param_1,0xffffffe1,"Invalid SSH_FXP_VERSION response");
      (**(code **)(param_1 + 0x18))(local_48,param_1);
    }
    else {
      _libssh2_error(param_1,iVar1,"Timeout waiting for response from SFTP subsystem");
    }
  }
LAB_00138a14:
  do {
    iVar1 = _libssh2_channel_free(*(undefined8 *)(param_1 + 0xd3a8));
  } while (iVar1 == -0x25);
  *(undefined8 *)(param_1 + 0xd3a8) = 0;
  if (*(long *)(param_1 + 0xd3a0) != 0) {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd3a0),param_1);
    *(undefined8 *)(param_1 + 0xd3a0) = 0;
  }
  *(undefined4 *)(param_1 + 0xd39c) = 0;
  plVar5 = (long *)0x0;
LAB_00138a8c:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return plVar5;
}



long libssh2_sftp_init(long param_1)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  if (param_1 != 0) {
    if ((*(uint *)(param_1 + 0x68) & 4) == 0) {
      _libssh2_error(param_1,0xffffffde,"session not authenticated yet");
    }
    else {
      tVar2 = time((time_t *)0x0);
      do {
        lVar3 = sftp_init(param_1);
        if (*(int *)(param_1 + 0x94) == 0) {
          return lVar3;
        }
        if (lVar3 != 0) {
          return lVar3;
        }
        iVar1 = libssh2_session_last_errno(param_1);
        if (iVar1 != -0x25) {
          return 0;
        }
        iVar1 = _libssh2_wait_socket(param_1,tVar2);
      } while (iVar1 == 0);
    }
  }
  return 0;
}



undefined4 sftp_shutdown(long *param_1)

{
  long lVar1;
  undefined4 uVar2;
  
  lVar1 = *(long *)(*param_1 + 0x60);
  if (param_1[10] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[10],lVar1);
    param_1[10] = 0;
  }
  if (param_1[0xf] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[0xf],lVar1);
    param_1[0xf] = 0;
  }
  if (param_1[0x17] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[0x17],lVar1);
    param_1[0x17] = 0;
  }
  if (param_1[0x19] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[0x19],lVar1);
    param_1[0x19] = 0;
  }
  if (param_1[0x1b] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[0x1b],lVar1);
    param_1[0x1b] = 0;
  }
  if (param_1[0x1d] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[0x1d],lVar1);
    param_1[0x1d] = 0;
  }
  if (param_1[0x20] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[0x20],lVar1);
    param_1[0x20] = 0;
  }
  if (param_1[0x22] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[0x22],lVar1);
    param_1[0x22] = 0;
  }
  if (param_1[0x24] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[0x24],lVar1);
    param_1[0x24] = 0;
  }
  if (param_1[0x26] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[0x26],lVar1);
    param_1[0x26] = 0;
  }
  if (param_1[0x28] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[0x28],lVar1);
    param_1[0x28] = 0;
  }
  if (param_1[0x2a] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[0x2a],lVar1);
    param_1[0x2a] = 0;
  }
  if (param_1[0x15] != 0) {
    (**(code **)(lVar1 + 0x18))(param_1[0x15],lVar1);
    param_1[0x15] = 0;
  }
  sftp_packet_flush(param_1);
  uVar2 = _libssh2_channel_free(*param_1);
  return uVar2;
}



int libssh2_sftp_shutdown(long *param_1)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == (long *)0x0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = sftp_shutdown(param_1);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



long sftp_open(long *param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4,ulong param_5,
              int param_6)

{
  bool bVar1;
  int iVar2;
  undefined4 uVar3;
  uint uVar4;
  long lVar5;
  undefined uVar6;
  long in_FS_OFFSET;
  bool bVar7;
  undefined *local_80;
  ulong local_78;
  char *local_70;
  long local_68;
  long local_60;
  ulong local_58;
  long local_50;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  ulong local_28;
  undefined8 local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_68 = *param_1;
  local_60 = *(long *)(local_68 + 0x60);
  local_48 = 4;
  local_40 = 0;
  local_38 = 0;
  local_30 = 0;
  local_28 = 0;
  local_20 = 0;
  local_18 = 0;
  bVar7 = param_6 == 0;
  if (*(int *)(param_1 + 0xe) == 0) {
    if (bVar7) {
      iVar2 = sftp_attrsize(4);
      iVar2 = iVar2 + 4;
    }
    else {
      iVar2 = 0;
    }
    *(int *)(param_1 + 0x10) = (int)param_3 + iVar2 + 0xd;
    param_1[0x11] = 0;
    lVar5 = (**(code **)(local_60 + 8))(*(undefined4 *)(param_1 + 0x10),local_60);
    param_1[0xf] = lVar5;
    local_80 = (undefined *)param_1[0xf];
    if (param_1[0xf] == 0) {
      _libssh2_error(local_60,0xfffffffa,
                     "Unable to allocate memory for FXP_OPEN or FXP_OPENDIR packet");
      lVar5 = 0;
      goto LAB_001396a6;
    }
    if (bVar7) {
      local_28 = 0x8000;
    }
    else {
      local_28 = 0x4000;
    }
    local_28 = local_28 | param_5;
    _libssh2_store_u32(&local_80,*(int *)(param_1 + 0x10) + -4);
    if (bVar7) {
      uVar6 = 3;
    }
    else {
      uVar6 = 0xb;
    }
    *local_80 = uVar6;
    iVar2 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar2 + 1;
    *(int *)(param_1 + 0x12) = iVar2;
    local_80 = local_80 + 1;
    _libssh2_store_u32(&local_80,*(undefined4 *)(param_1 + 0x12));
    _libssh2_store_str(&local_80,param_2,param_3);
    if (bVar7) {
      _libssh2_store_u32(&local_80,param_4);
      lVar5 = sftp_attr2bin(local_80,&local_48);
      local_80 = local_80 + lVar5;
    }
    *(undefined4 *)(param_1 + 0xe) = 2;
  }
  if (*(int *)(param_1 + 0xe) == 2) {
    local_58 = _libssh2_channel_write
                         (local_68,0,param_1[0xf] + param_1[0x11],
                          (ulong)*(uint *)(param_1 + 0x10) - param_1[0x11]);
    if (local_58 == 0xffffffffffffffdb) {
      _libssh2_error(local_60,0xffffffdb,"Would block sending FXP_OPEN or FXP_OPENDIR command");
      lVar5 = 0;
      goto LAB_001396a6;
    }
    if ((long)local_58 < 0) {
      _libssh2_error(local_60,local_58 & 0xffffffff,"Unable to send FXP_OPEN*");
      (**(code **)(local_60 + 0x18))(param_1[0xf],local_60);
      param_1[0xf] = 0;
      *(undefined4 *)(param_1 + 0xe) = 0;
      lVar5 = 0;
      goto LAB_001396a6;
    }
    param_1[0x11] = param_1[0x11] + local_58;
    if ((ulong)*(uint *)(param_1 + 0x10) == param_1[0x11]) {
      (**(code **)(local_60 + 0x18))(param_1[0xf],local_60);
      param_1[0xf] = 0;
      *(undefined4 *)(param_1 + 0xe) = 3;
    }
  }
  if (*(int *)(param_1 + 0xe) == 3) {
    iVar2 = sftp_packet_requirev
                      (param_1,2,&fopen_responses_20404,*(undefined4 *)(param_1 + 0x12),&local_70,
                       &local_78);
    local_58 = (ulong)iVar2;
    if (local_58 == 0xffffffffffffffdb) {
      _libssh2_error(local_60,0xffffffdb,"Would block waiting for status message");
      lVar5 = 0;
    }
    else {
      *(undefined4 *)(param_1 + 0xe) = 0;
      if (local_58 == 0) {
        if (*local_70 == 'e') {
          bVar1 = true;
          if (local_78 < 9) {
            _libssh2_error(local_60,0xffffffe1,"Too small FXP_STATUS");
            (**(code **)(local_60 + 0x18))(local_70,local_60);
            lVar5 = 0;
            goto LAB_001396a6;
          }
          uVar3 = _libssh2_ntohu32(local_70 + 5);
          *(undefined4 *)(param_1 + 8) = uVar3;
          if (*(int *)(param_1 + 8) == 0) {
            (**(code **)(local_60 + 0x18))(local_70,local_60);
            iVar2 = sftp_packet_require(param_1,0x66,*(undefined4 *)(param_1 + 0x12),&local_70,
                                        &local_78);
            local_58 = (ulong)iVar2;
            if (local_58 == 0xffffffffffffffdb) {
              *(undefined4 *)(param_1 + 0xe) = 3;
              lVar5 = 0;
              goto LAB_001396a6;
            }
            if (local_58 == 0) {
              bVar1 = false;
            }
          }
          if (bVar1) {
            _libssh2_error(local_60,0xffffffe1,"Failed opening remote file");
            (**(code **)(local_60 + 0x18))(local_70,local_60);
            lVar5 = 0;
            goto LAB_001396a6;
          }
        }
        if (local_78 < 10) {
          _libssh2_error(local_60,0xffffffe1,"Too small FXP_HANDLE");
          (**(code **)(local_60 + 0x18))(local_70,local_60);
          lVar5 = 0;
        }
        else {
          local_50 = _libssh2_calloc(local_60,0x188);
          if (local_50 == 0) {
            _libssh2_error(local_60,0xfffffffa,"Unable to allocate new SFTP handle structure");
            (**(code **)(local_60 + 0x18))(local_70,local_60);
            lVar5 = 0;
          }
          else {
            *(uint *)(local_50 + 0x128) = (uint)!bVar7;
            uVar4 = _libssh2_ntohu32(local_70 + 5);
            *(ulong *)(local_50 + 0x120) = (ulong)uVar4;
            if (0x100 < *(ulong *)(local_50 + 0x120)) {
              *(undefined8 *)(local_50 + 0x120) = 0x100;
            }
            if (local_78 - 9 < *(ulong *)(local_50 + 0x120)) {
              *(ulong *)(local_50 + 0x120) = local_78 - 9;
            }
            memcpy((void *)(local_50 + 0x20),local_70 + 9,*(size_t *)(local_50 + 0x120));
            (**(code **)(local_60 + 0x18))(local_70,local_60);
            _libssh2_list_add(param_1 + 6,local_50);
            *(long **)(local_50 + 0x18) = param_1;
            *(undefined8 *)(local_50 + 0x130) = 0;
            *(undefined8 *)(local_50 + 0x138) = 0;
            lVar5 = local_50;
          }
        }
      }
      else {
        _libssh2_error(local_60,iVar2,"Timeout waiting for status message");
        lVar5 = 0;
      }
    }
  }
  else {
    lVar5 = 0;
  }
LAB_001396a6:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return lVar5;
}



long libssh2_sftp_open_ex
               (long *param_1,undefined8 param_2,undefined4 param_3,undefined4 param_4,
               undefined8 param_5,undefined4 param_6)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  if (param_1 != (long *)0x0) {
    tVar2 = time((time_t *)0x0);
    do {
      lVar3 = sftp_open(param_1,param_2,param_3,param_4,param_5,param_6);
      if (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0) {
        return lVar3;
      }
      if (lVar3 != 0) {
        return lVar3;
      }
      iVar1 = libssh2_session_last_errno(*(undefined8 *)(*param_1 + 0x60));
      if (iVar1 != -0x25) {
        return 0;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return 0;
}



size_t sftp_read(long param_1,void *param_2,ulong param_3)

{
  uint uVar1;
  int iVar2;
  ulong uVar3;
  long lVar4;
  size_t sVar5;
  long in_FS_OFFSET;
  uint local_a0;
  uint local_9c;
  char *local_90;
  undefined *local_88;
  ulong local_80;
  long local_78;
  size_t local_70;
  void *local_68;
  ulong local_60;
  long *local_58;
  long local_50;
  long local_48;
  long *local_40;
  ulong local_38;
  ulong local_30;
  size_t local_28;
  size_t local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_58 = *(long **)(param_1 + 0x18);
  local_50 = *local_58;
  local_48 = *(long *)(local_50 + 0x60);
  local_80 = 0;
  local_40 = (long *)(param_1 + 0x130);
  local_70 = 0;
  uVar1 = *(uint *)((long)local_58 + 0x94);
  local_68 = param_2;
  if (uVar1 != 5) {
    if (5 < uVar1) {
LAB_0013a12b:
                    // WARNING: Subroutine does not return
      __assert_fail("!\"State machine error; unrecognised read state\"",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-3857_Libssh2/Libssh2/src/sftp.c"
                    ,0x655,"sftp_read");
    }
    if (uVar1 == 0) {
      if (*(long *)(param_1 + 0x158) != 0) {
        local_20 = *(ulong *)(param_1 + 0x158);
        if (param_3 <= *(ulong *)(param_1 + 0x158)) {
          local_20 = param_3;
        }
        memcpy(param_2,(void *)(*(long *)(param_1 + 0x148) +
                               (*(long *)(param_1 + 0x150) - *(long *)(param_1 + 0x158))),local_20);
        local_40[5] = local_40[5] - local_20;
        *local_40 = *local_40 + local_20;
        sVar5 = local_20;
        if (local_40[5] == 0) {
          (**(code **)(local_48 + 0x18))(local_40[3],local_48);
          local_40[3] = 0;
          sVar5 = local_20;
        }
        goto LAB_0013a165;
      }
      if (*(char *)(param_1 + 0x160) != '\0') {
        sVar5 = 0;
        goto LAB_0013a165;
      }
      local_38 = *(long *)(param_1 + 0x138) - *local_40;
      local_60 = param_3 << 2;
      if (0x800000 < local_60) {
        local_60 = 0x800000;
      }
      if (local_38 < local_60) {
        local_80 = local_60 - local_38;
      }
      local_30 = libssh2_channel_window_read_ex(*local_58,0,0);
      if (local_30 < local_60) {
        iVar2 = _libssh2_channel_receive_window_adjust(*local_58,(int)local_60 * 8,1,0);
        local_28 = (size_t)iVar2;
        if ((local_28 == 0xffffffffffffffdb) && (local_40[5] != 0)) {
                    // WARNING: Subroutine does not return
          __assert_fail("rc != LIBSSH2_ERROR_EAGAIN || !filep->data_left",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-3857_Libssh2/Libssh2/src/sftp.c"
                        ,0x557,"sftp_read");
        }
        if ((local_28 == 0xffffffffffffffdb) && (*(char *)(local_40 + 6) != '\0')) {
                    // WARNING: Subroutine does not return
          __assert_fail("rc != LIBSSH2_ERROR_EAGAIN || !filep->eof",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-3857_Libssh2/Libssh2/src/sftp.c"
                        ,0x558,"sftp_read");
        }
        sVar5 = local_28;
        if (local_28 != 0) goto LAB_0013a165;
      }
      for (; local_80 != 0; local_80 = local_80 - uVar3) {
        iVar2 = (int)*(undefined8 *)(param_1 + 0x120);
        uVar1 = iVar2 + 0x19;
        local_a0 = (uint)local_80;
        if ((local_80 & 0xffffffff) < param_3) {
          local_a0 = (uint)param_3;
        }
        if (30000 < local_a0) {
          local_a0 = 30000;
        }
        local_78 = (**(code **)(local_48 + 8))((ulong)uVar1 + 0x40,local_48);
        if (local_78 == 0) {
          iVar2 = _libssh2_error(local_48,0xfffffffa,"malloc fail for FXP_WRITE");
          sVar5 = (long)iVar2;
          goto LAB_0013a165;
        }
        *(long *)(local_78 + 0x18) = local_40[1];
        *(ulong *)(local_78 + 0x20) = (ulong)local_a0;
        *(ulong *)(local_78 + 0x30) = (ulong)uVar1;
        *(undefined8 *)(local_78 + 0x28) = 0;
        local_88 = (undefined *)(local_78 + 0x3c);
        _libssh2_store_u32(&local_88,iVar2 + 0x15);
        *local_88 = 5;
        iVar2 = *(int *)(local_58 + 1);
        *(int *)(local_58 + 1) = iVar2 + 1;
        *(int *)(local_78 + 0x38) = iVar2;
        local_88 = local_88 + 1;
        _libssh2_store_u32(&local_88,iVar2);
        _libssh2_store_str(&local_88,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
        _libssh2_store_u64(&local_88,local_40[1]);
        local_40[1] = local_40[1] + (ulong)local_a0;
        _libssh2_store_u32(&local_88,local_a0);
        _libssh2_list_add(param_1 + 0x178,local_78);
        uVar3 = (ulong)local_a0;
        if (local_80 <= local_a0) {
          uVar3 = local_80;
        }
      }
    }
    else if (uVar1 != 3) goto LAB_0013a12b;
    *(undefined4 *)((long)local_58 + 0x94) = 0;
    local_78 = _libssh2_list_first(param_1 + 0x178);
    do {
      while( true ) {
        if (local_78 == 0) goto LAB_00139d2e;
        if (*(long *)(local_78 + 0x30) != 0) break;
LAB_00139d10:
        local_78 = _libssh2_list_next(local_78);
      }
      local_28 = _libssh2_channel_write
                           (local_50,0,local_78 + *(long *)(local_78 + 0x28) + 0x3c,
                            *(undefined8 *)(local_78 + 0x30));
      if ((long)local_28 < 0) {
        *(undefined4 *)((long)local_58 + 0x94) = 3;
        sVar5 = local_28;
        goto LAB_0013a165;
      }
      *(size_t *)(local_78 + 0x30) = *(long *)(local_78 + 0x30) - local_28;
      *(size_t *)(local_78 + 0x28) = *(long *)(local_78 + 0x28) + local_28;
      if (*(long *)(local_78 + 0x30) == 0) goto LAB_00139d10;
      lVar4 = _libssh2_list_first(param_1 + 0x178);
    } while (local_78 == lVar4);
  }
LAB_00139d2e:
  *(undefined4 *)((long)local_58 + 0x94) = 0;
  local_78 = _libssh2_list_first(param_1 + 0x178);
  while (sVar5 = local_70, local_78 != 0) {
    if (*(long *)(local_78 + 0x30) != 0) {
      if (local_70 == 0) {
        iVar2 = _libssh2_error(local_48,0xffffffe1,"sftp_read() internal error");
        sVar5 = (long)iVar2;
      }
      goto LAB_0013a165;
    }
    iVar2 = sftp_packet_requirev
                      (local_58,2,"geheiesftp_close_handle",*(undefined4 *)(local_78 + 0x38),
                       &local_90,&local_88);
    local_28 = (size_t)iVar2;
    if ((local_28 == 0xffffffffffffffdb) && (sVar5 = local_70, local_70 != 0)) goto LAB_0013a165;
    if ((long)local_28 < 0) {
      *(undefined4 *)((long)local_58 + 0x94) = 5;
      sVar5 = local_28;
      goto LAB_0013a165;
    }
    if (*local_90 == 'e') {
      _libssh2_list_remove(local_78);
      (**(code **)(local_48 + 0x18))(local_78,local_48);
      sftp_packetlist_flush(param_1);
      iVar2 = _libssh2_ntohu32(local_90 + 5);
      (**(code **)(local_48 + 0x18))(local_90,local_48);
      if (iVar2 == 1) {
        *(undefined *)(local_40 + 6) = 1;
        sVar5 = local_70;
      }
      else {
        *(int *)(local_58 + 8) = iVar2;
        iVar2 = _libssh2_error(local_48,0xffffffe1,"SFTP READ error");
        sVar5 = (long)iVar2;
      }
      goto LAB_0013a165;
    }
    if (*local_90 != 'g') {
      iVar2 = _libssh2_error(local_48,0xffffffe1,
                             "SFTP Protocol badness: unrecognised read request response");
      sVar5 = (long)iVar2;
      goto LAB_0013a165;
    }
    if (*(long *)(local_78 + 0x18) != *local_40) {
      iVar2 = _libssh2_error(local_48,0xffffffe1,"Read Packet At Unexpected Offset");
      sVar5 = (long)iVar2;
      goto LAB_0013a165;
    }
    local_9c = _libssh2_ntohu32(local_90 + 5);
    if (local_88 + -9 < (undefined *)(ulong)local_9c) {
      iVar2 = _libssh2_error(local_48,0xffffffe1,"SFTP Protocol badness");
      sVar5 = (long)iVar2;
      goto LAB_0013a165;
    }
    if (*(ulong *)(local_78 + 0x20) < (ulong)local_9c) {
      iVar2 = _libssh2_error(local_48,0xffffffe1,"FXP_READ response too big");
      sVar5 = (long)iVar2;
      goto LAB_0013a165;
    }
    if ((ulong)local_9c != *(ulong *)(local_78 + 0x20)) {
      local_40[1] = local_40[1] + ((ulong)local_9c - *(long *)(local_78 + 0x20));
    }
    if (param_3 < local_70 + local_9c) {
      local_40[5] = (local_70 + local_9c) - param_3;
      local_9c = (uint)param_3 - (int)local_70;
      local_40[3] = (long)local_90;
      local_40[4] = (long)local_88;
    }
    else {
      local_40[4] = 0;
    }
    memcpy(local_68,local_90 + 9,(ulong)local_9c);
    *local_40 = *local_40 + (ulong)local_9c;
    local_70 = local_70 + local_9c;
    local_68 = (void *)((long)local_68 + (ulong)local_9c);
    if (local_40[4] == 0) {
      (**(code **)(local_48 + 0x18))(local_90,local_48);
    }
    local_18 = _libssh2_list_next(local_78);
    _libssh2_list_remove(local_78);
    (**(code **)(local_48 + 0x18))(local_78,local_48);
    if (local_70 < param_3) {
      local_78 = local_18;
    }
    else {
      local_78 = 0;
    }
  }
  if (local_70 == 0) {
    iVar2 = _libssh2_error(local_48,0xffffffe1,"sftp_read() internal error");
    sVar5 = (long)iVar2;
  }
LAB_0013a165:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return sVar5;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



long libssh2_sftp_read(long param_1,undefined8 param_2,undefined8 param_3)

{
  int iVar1;
  long lVar2;
  time_t tVar3;
  
  if (param_1 == 0) {
    lVar2 = -0x27;
  }
  else {
    tVar3 = time((time_t *)0x0);
    do {
      lVar2 = sftp_read(param_1,param_2,param_3);
      if (lVar2 != -0x25) {
        return lVar2;
      }
      if (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar3);
      lVar2 = (long)iVar1;
    } while (lVar2 == 0);
  }
  return lVar2;
}



ulong sftp_readdir(long param_1,void *param_2,ulong param_3,void *param_4,ulong param_5,
                  char **param_6)

{
  uint uVar1;
  int iVar2;
  long lVar3;
  ulong uVar4;
  long in_FS_OFFSET;
  undefined local_98 [8];
  undefined *local_90;
  ulong local_88;
  long *local_80;
  long local_78;
  long local_70;
  ulong local_68;
  ulong local_60;
  ulong local_58;
  ulong local_50;
  char *local_48 [7];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_80 = *(long **)(param_1 + 0x18);
  local_78 = *local_80;
  local_70 = *(long *)(local_78 + 0x60);
  iVar2 = (int)*(undefined8 *)(param_1 + 0x120);
  uVar1 = iVar2 + 0xd;
  if (*(int *)((long)local_80 + 0xb4) == 0) {
    if (*(int *)(param_1 + 0x130) != 0) {
      local_90 = *(undefined **)(param_1 + 0x140);
      uVar1 = _libssh2_ntohu32(local_90);
      local_68 = (ulong)uVar1;
      local_90 = local_90 + 4;
      if (local_68 < param_3) {
        local_88 = local_68;
        memcpy(param_2,local_90,local_68);
        *(undefined *)(local_88 + (long)param_2) = 0;
        local_90 = local_90 + local_68;
        uVar1 = _libssh2_ntohu32(local_90);
        local_60 = (ulong)uVar1;
        local_90 = local_90 + 4;
        if ((param_4 != (void *)0x0) && (1 < param_5)) {
          local_58 = local_60;
          if (param_5 <= local_60) {
            local_88 = 0xffffffffffffffda;
            goto LAB_0013a47e;
          }
          memcpy(param_4,local_90,local_60);
          *(undefined *)(local_58 + (long)param_4) = 0;
        }
        local_90 = local_90 + local_60;
        if (param_6 == (char **)0x0) {
          param_6 = local_48;
        }
        else {
          memset(param_6,0,0x38);
        }
        iVar2 = sftp_bin2attr(param_6,local_90);
        local_90 = local_90 + iVar2;
        *(undefined **)(param_1 + 0x140) = local_90;
      }
      else {
        local_88 = 0xffffffffffffffda;
      }
LAB_0013a47e:
      *(int *)(param_1 + 0x130) = *(int *)(param_1 + 0x130) + -1;
      uVar4 = local_88;
      if (*(int *)(param_1 + 0x130) == 0) {
        (**(code **)(local_70 + 0x18))(*(undefined8 *)(param_1 + 0x138),local_70);
        uVar4 = local_88;
      }
      goto LAB_0013a89e;
    }
    lVar3 = (**(code **)(local_70 + 8))(uVar1,local_70);
    local_80[0x17] = lVar3;
    local_90 = (undefined *)local_80[0x17];
    if (local_80[0x17] == 0) {
      iVar2 = _libssh2_error(local_70,0xfffffffa,"Unable to allocate memory for FXP_READDIR packet")
      ;
      uVar4 = (long)iVar2;
      goto LAB_0013a89e;
    }
    _libssh2_store_u32(&local_90,iVar2 + 9);
    *local_90 = 0xc;
    iVar2 = *(int *)(local_80 + 1);
    *(int *)(local_80 + 1) = iVar2 + 1;
    *(int *)(local_80 + 0x18) = iVar2;
    local_90 = local_90 + 1;
    _libssh2_store_u32(&local_90,*(undefined4 *)(local_80 + 0x18));
    _libssh2_store_str(&local_90,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
    *(undefined4 *)((long)local_80 + 0xb4) = 2;
  }
  if (*(int *)((long)local_80 + 0xb4) == 2) {
    local_50 = _libssh2_channel_write(local_78,0,local_80[0x17],uVar1);
    if (local_50 == 0xffffffffffffffdb) {
      uVar4 = 0xffffffffffffffdb;
      goto LAB_0013a89e;
    }
    if (local_50 != uVar1) {
      (**(code **)(local_70 + 0x18))(local_80[0x17],local_70);
      local_80[0x17] = 0;
      *(undefined4 *)((long)local_80 + 0xb4) = 0;
      iVar2 = _libssh2_error(local_70,0xfffffff9,"_libssh2_channel_write() failed");
      uVar4 = (long)iVar2;
      goto LAB_0013a89e;
    }
    (**(code **)(local_70 + 0x18))(local_80[0x17],local_70);
    local_80[0x17] = 0;
    *(undefined4 *)((long)local_80 + 0xb4) = 3;
  }
  iVar2 = sftp_packet_requirev
                    (local_80,2,"heiesftp_close_handle",*(undefined4 *)(local_80 + 0x18),local_48,
                     local_98);
  local_50 = (ulong)iVar2;
  if (local_50 == 0xffffffffffffffdb) {
    uVar4 = 0xffffffffffffffdb;
  }
  else if (local_50 == 0) {
    if (*local_48[0] == 'e') {
      uVar1 = _libssh2_ntohu32(local_48[0] + 5);
      local_50 = (ulong)uVar1;
      (**(code **)(local_70 + 0x18))(local_48[0],local_70);
      if (local_50 == 1) {
        *(undefined4 *)((long)local_80 + 0xb4) = 0;
        uVar4 = 0;
      }
      else {
        *(int *)(local_80 + 8) = (int)local_50;
        *(undefined4 *)((long)local_80 + 0xb4) = 0;
        iVar2 = _libssh2_error(local_70,0xffffffe1,"SFTP Protocol Error");
        uVar4 = (long)iVar2;
      }
    }
    else {
      *(undefined4 *)((long)local_80 + 0xb4) = 0;
      iVar2 = _libssh2_ntohu32(local_48[0] + 5);
      if (iVar2 == 0) {
        (**(code **)(local_70 + 0x18))(local_48[0],local_70);
        uVar4 = 0;
      }
      else {
        *(int *)(param_1 + 0x130) = iVar2;
        *(char **)(param_1 + 0x138) = local_48[0];
        *(char **)(param_1 + 0x140) = local_48[0] + 9;
        uVar4 = sftp_readdir(param_1,param_2,param_3,param_4,param_5,param_6);
      }
    }
  }
  else {
    *(undefined4 *)((long)local_80 + 0xb4) = 0;
    iVar2 = _libssh2_error(local_70,iVar2,"Timeout waiting for status message");
    uVar4 = (long)iVar2;
  }
LAB_0013a89e:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



int libssh2_sftp_readdir_ex
              (long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
              undefined8 param_5,undefined8 param_6)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = sftp_readdir(param_1,param_2,param_3,param_4,param_5,param_6);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



ulong sftp_write(long param_1,long param_2,ulong param_3)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  ulong uVar4;
  long in_FS_OFFSET;
  ulong local_a0;
  long local_98;
  undefined local_78 [8];
  undefined *local_70;
  long local_68;
  long local_60;
  ulong local_58;
  long *local_50;
  long local_48;
  long local_40;
  ulong local_38;
  ulong local_30;
  ulong local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_50 = *(long **)(param_1 + 0x18);
  local_48 = *local_50;
  local_40 = *(long *)(local_48 + 0x60);
  local_58 = 0;
  local_38 = param_3;
  if (*(int *)((long)local_50 + 0x9c) != 3) {
    local_30 = *(long *)(param_1 + 0x140) +
               (*(long *)(param_1 + 0x138) - *(long *)(param_1 + 0x130));
    if (param_3 < local_30) {
      local_a0 = 0;
      local_98 = param_2;
    }
    else {
      local_98 = param_2 + local_30;
      local_a0 = param_3 - local_30;
    }
    *(undefined4 *)((long)local_50 + 0x9c) = 0;
    for (; local_a0 != 0; local_a0 = local_a0 - uVar1) {
      uVar1 = 30000;
      if (local_a0 < 0x7531) {
        uVar1 = (uint)local_a0;
      }
      iVar3 = uVar1 + (int)*(undefined8 *)(param_1 + 0x120);
      uVar2 = iVar3 + 0x19;
      local_60 = (**(code **)(local_40 + 8))((ulong)uVar2 + 0x40,local_40);
      if (local_60 == 0) {
        iVar3 = _libssh2_error(local_40,0xfffffffa,"malloc fail for FXP_WRITE");
        uVar4 = (ulong)iVar3;
        goto LAB_0013af15;
      }
      *(ulong *)(local_60 + 0x20) = (ulong)uVar1;
      *(undefined8 *)(local_60 + 0x28) = 0;
      *(ulong *)(local_60 + 0x30) = (ulong)uVar2;
      local_70 = (undefined *)(local_60 + 0x3c);
      _libssh2_store_u32(&local_70,iVar3 + 0x15);
      *local_70 = 6;
      iVar3 = *(int *)(local_50 + 1);
      *(int *)(local_50 + 1) = iVar3 + 1;
      *(int *)(local_60 + 0x38) = iVar3;
      local_70 = local_70 + 1;
      _libssh2_store_u32(&local_70,iVar3);
      _libssh2_store_str(&local_70,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
      _libssh2_store_u64(&local_70,*(undefined8 *)(param_1 + 0x138));
      *(ulong *)(param_1 + 0x138) = *(long *)(param_1 + 0x138) + (ulong)uVar1;
      _libssh2_store_str(&local_70,local_98,uVar1);
      _libssh2_list_add(param_1 + 0x178,local_60);
      local_98 = local_98 + (ulong)uVar1;
    }
    for (local_60 = _libssh2_list_first(param_1 + 0x178); local_60 != 0;
        local_60 = _libssh2_list_next(local_60)) {
      if (*(long *)(local_60 + 0x30) != 0) {
        uVar4 = _libssh2_channel_write
                          (local_48,0,local_60 + *(long *)(local_60 + 0x28) + 0x3c,
                           *(undefined8 *)(local_60 + 0x30));
        local_28 = uVar4;
        if ((long)uVar4 < 0) goto LAB_0013af15;
        *(ulong *)(local_60 + 0x30) = *(long *)(local_60 + 0x30) - uVar4;
        *(ulong *)(local_60 + 0x28) = *(long *)(local_60 + 0x28) + uVar4;
        if (*(long *)(local_60 + 0x30) != 0) break;
      }
    }
  }
  *(undefined4 *)((long)local_50 + 0x9c) = 0;
  local_60 = _libssh2_list_first(param_1 + 0x178);
  while (((local_60 != 0 && (*(long *)(local_60 + 0x30) == 0)) && (local_58 == 0))) {
    iVar3 = sftp_packet_require(local_50,0x65,*(undefined4 *)(local_60 + 0x38),&local_68,local_78);
    uVar4 = (ulong)iVar3;
    local_28 = uVar4;
    if ((long)uVar4 < 0) {
      if (uVar4 == 0xffffffffffffffdb) {
        *(undefined4 *)((long)local_50 + 0x9c) = 3;
      }
      goto LAB_0013af15;
    }
    iVar3 = _libssh2_ntohu32(local_68 + 5);
    (**(code **)(local_40 + 0x18))(local_68,local_40);
    *(int *)(local_50 + 8) = iVar3;
    if (iVar3 != 0) {
      sftp_packetlist_flush(param_1);
      *(long *)(param_1 + 0x130) = *(long *)(param_1 + 0x130) - *(long *)(param_1 + 0x140);
      *(undefined8 *)(param_1 + 0x138) = *(undefined8 *)(param_1 + 0x130);
      *(undefined8 *)(param_1 + 0x140) = 0;
      iVar3 = _libssh2_error(local_40,0xffffffe1,"FXP write failed");
      uVar4 = (ulong)iVar3;
      goto LAB_0013af15;
    }
    local_58 = local_58 + *(long *)(local_60 + 0x20);
    *(long *)(param_1 + 0x130) = *(long *)(param_1 + 0x130) + *(long *)(local_60 + 0x20);
    local_20 = _libssh2_list_next(local_60);
    _libssh2_list_remove(local_60);
    (**(code **)(local_40 + 0x18))(local_60,local_40);
    local_60 = local_20;
  }
  local_58 = local_58 + *(long *)(param_1 + 0x140);
  if (local_58 == 0) {
    uVar4 = 0;
  }
  else {
    uVar4 = local_58;
    if (local_38 <= local_58) {
      uVar4 = local_38;
    }
    *(ulong *)(param_1 + 0x140) = local_58 - uVar4;
    local_18 = uVar4;
  }
LAB_0013af15:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



long libssh2_sftp_write(long param_1,undefined8 param_2,undefined8 param_3)

{
  int iVar1;
  long lVar2;
  time_t tVar3;
  
  if (param_1 == 0) {
    lVar2 = -0x27;
  }
  else {
    tVar3 = time((time_t *)0x0);
    do {
      lVar2 = sftp_write(param_1,param_2,param_3);
      if (lVar2 != -0x25) {
        return lVar2;
      }
      if (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar3);
      lVar2 = (long)iVar1;
    } while (lVar2 == 0);
  }
  return lVar2;
}



undefined8 sftp_fsync(long param_1)

{
  uint uVar1;
  int iVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  undefined local_50 [8];
  undefined *local_48;
  long local_40;
  undefined *local_38;
  long *local_30;
  long local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = *(long **)(param_1 + 0x18);
  local_28 = *local_30;
  local_20 = *(long *)(local_28 + 0x60);
  iVar2 = (int)*(undefined8 *)(param_1 + 0x120);
  uVar1 = iVar2 + 0x22;
  if (*(int *)(local_30 + 0x14) == 0) {
    local_48 = (undefined *)(**(code **)(local_20 + 8))(uVar1,local_20);
    local_38 = local_48;
    if (local_48 == (undefined *)0x0) {
      uVar3 = _libssh2_error(local_20,0xfffffffa,"Unable to allocate memory for FXP_EXTENDED packet"
                            );
      goto LAB_0013b2c4;
    }
    _libssh2_store_u32(&local_48,iVar2 + 0x1e);
    *local_48 = 200;
    iVar2 = *(int *)(local_30 + 1);
    *(int *)(local_30 + 1) = iVar2 + 1;
    *(int *)(local_30 + 0x16) = iVar2;
    local_48 = local_48 + 1;
    _libssh2_store_u32(&local_48,*(undefined4 *)(local_30 + 0x16));
    _libssh2_store_str(&local_48,"fsync@openssh.com",0x11);
    _libssh2_store_str(&local_48,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
    *(undefined4 *)(local_30 + 0x14) = 2;
  }
  else {
    local_38 = (undefined *)local_30[0x15];
  }
  if (*(int *)(local_30 + 0x14) == 2) {
    local_18 = _libssh2_channel_write(local_28,0,local_38,uVar1);
    if ((local_18 == -0x25) || ((-1 < local_18 && (local_18 < (long)(ulong)uVar1)))) {
      local_30[0x15] = (long)local_38;
      uVar3 = 0xffffffdb;
      goto LAB_0013b2c4;
    }
    (**(code **)(local_20 + 0x18))(local_38,local_20);
    local_30[0x15] = 0;
    if (local_18 < 0) {
      *(undefined4 *)(local_30 + 0x14) = 0;
      uVar3 = _libssh2_error(local_20,0xfffffff9,"_libssh2_channel_write() failed");
      goto LAB_0013b2c4;
    }
    *(undefined4 *)(local_30 + 0x14) = 3;
  }
  iVar2 = sftp_packet_require(local_30,0x65,*(undefined4 *)(local_30 + 0x16),&local_40,local_50);
  local_18 = (long)iVar2;
  if (local_18 == -0x25) {
    uVar3 = 0xffffffffffffffdb;
  }
  else if (local_18 == 0) {
    *(undefined4 *)(local_30 + 0x14) = 0;
    iVar2 = _libssh2_ntohu32(local_40 + 5);
    (**(code **)(local_20 + 0x18))(local_40,local_20);
    if (iVar2 == 0) {
      uVar3 = 0;
    }
    else {
      *(int *)(local_30 + 8) = iVar2;
      uVar3 = _libssh2_error(local_20,0xffffffe1,"fsync failed");
    }
  }
  else {
    *(undefined4 *)(local_30 + 0x14) = 0;
    uVar3 = _libssh2_error(local_20,iVar2,"Error waiting for FXP EXTENDED REPLY");
  }
LAB_0013b2c4:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



int libssh2_sftp_fsync(long param_1)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = sftp_fsync(param_1);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined8 sftp_fstat(long param_1,undefined8 *param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  long lVar3;
  undefined8 uVar4;
  char *pcVar5;
  undefined uVar6;
  long in_FS_OFFSET;
  undefined local_58 [8];
  undefined *local_50;
  char *local_48;
  long *local_40;
  long local_38;
  long local_30;
  ulong local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = *(long **)(param_1 + 0x18);
  local_38 = *local_40;
  local_30 = *(long *)(local_38 + 0x60);
  uVar4 = *(undefined8 *)(param_1 + 0x120);
  if (param_3 == 0) {
    iVar1 = 0;
  }
  else {
    iVar1 = sftp_attrsize(*param_2);
  }
  iVar1 = iVar1 + (int)uVar4;
  uVar2 = iVar1 + 0xd;
  if (*(int *)((long)local_40 + 0xc4) == 0) {
    lVar3 = (**(code **)(local_30 + 8))(uVar2,local_30);
    local_40[0x19] = lVar3;
    local_50 = (undefined *)local_40[0x19];
    if (local_40[0x19] == 0) {
      uVar4 = _libssh2_error(local_30,0xfffffffa,
                             "Unable to allocate memory for FSTAT/FSETSTAT packet");
      goto LAB_0013b722;
    }
    _libssh2_store_u32(&local_50,iVar1 + 9);
    if (param_3 == 0) {
      uVar6 = 8;
    }
    else {
      uVar6 = 10;
    }
    *local_50 = uVar6;
    iVar1 = *(int *)(local_40 + 1);
    *(int *)(local_40 + 1) = iVar1 + 1;
    *(int *)(local_40 + 0x1a) = iVar1;
    local_50 = local_50 + 1;
    _libssh2_store_u32(&local_50,*(undefined4 *)(local_40 + 0x1a));
    _libssh2_store_str(&local_50,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
    if (param_3 != 0) {
      lVar3 = sftp_attr2bin(local_50,param_2);
      local_50 = local_50 + lVar3;
    }
    *(undefined4 *)((long)local_40 + 0xc4) = 2;
  }
  if (*(int *)((long)local_40 + 0xc4) == 2) {
    local_28 = _libssh2_channel_write(local_38,0,local_40[0x19],uVar2);
    if (local_28 == 0xffffffffffffffdb) {
      uVar4 = 0xffffffffffffffdb;
      goto LAB_0013b722;
    }
    if (local_28 != uVar2) {
      (**(code **)(local_30 + 0x18))(local_40[0x19],local_30);
      local_40[0x19] = 0;
      *(undefined4 *)((long)local_40 + 0xc4) = 0;
      if (param_3 == 0) {
        pcVar5 = "Unable to send FXP_FSTAT command";
      }
      else {
        pcVar5 = "Unable to send FXP_FSETSTAT";
      }
      uVar4 = _libssh2_error(local_30,0xfffffff9,pcVar5);
      goto LAB_0013b722;
    }
    (**(code **)(local_30 + 0x18))(local_40[0x19],local_30);
    local_40[0x19] = 0;
    *(undefined4 *)((long)local_40 + 0xc4) = 3;
  }
  iVar1 = sftp_packet_requirev
                    (local_40,2,"iesftp_close_handle",*(undefined4 *)(local_40 + 0x1a),&local_48,
                     local_58);
  local_28 = (ulong)iVar1;
  if (local_28 == 0xffffffffffffffdb) {
    uVar4 = 0xffffffffffffffdb;
  }
  else if (local_28 == 0) {
    *(undefined4 *)((long)local_40 + 0xc4) = 0;
    if (*local_48 == 'e') {
      iVar1 = _libssh2_ntohu32(local_48 + 5);
      (**(code **)(local_30 + 0x18))(local_48,local_30);
      if (iVar1 == 0) {
        uVar4 = 0;
      }
      else {
        *(int *)(local_40 + 8) = iVar1;
        uVar4 = _libssh2_error(local_30,0xffffffe1,"SFTP Protocol Error");
      }
    }
    else {
      sftp_bin2attr(param_2,local_48 + 5);
      (**(code **)(local_30 + 0x18))(local_48,local_30);
      uVar4 = 0;
    }
  }
  else {
    *(undefined4 *)((long)local_40 + 0xc4) = 0;
    uVar4 = _libssh2_error(local_30,iVar1,"Timeout waiting for status message");
  }
LAB_0013b722:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



int libssh2_sftp_fstat_ex(long param_1,long param_2,undefined4 param_3)

{
  int iVar1;
  time_t tVar2;
  
  if ((param_1 == 0) || (param_2 == 0)) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = sftp_fstat(param_1,param_2,param_3);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



void libssh2_sftp_seek64(long param_1,long param_2)

{
  if ((param_1 != 0) &&
     ((param_2 != *(long *)(param_1 + 0x130) || (param_2 != *(long *)(param_1 + 0x138))))) {
    *(long *)(param_1 + 0x138) = param_2;
    *(undefined8 *)(param_1 + 0x130) = *(undefined8 *)(param_1 + 0x138);
    sftp_packetlist_flush(param_1);
    if (*(long *)(param_1 + 0x158) != 0) {
      (**(code **)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x18))
                (*(undefined8 *)(param_1 + 0x148),
                 *(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60));
      *(undefined8 *)(param_1 + 0x150) = 0;
      *(undefined8 *)(param_1 + 0x158) = *(undefined8 *)(param_1 + 0x150);
      *(undefined8 *)(param_1 + 0x148) = 0;
    }
    *(undefined *)(param_1 + 0x160) = 0;
  }
  return;
}



void libssh2_sftp_seek(undefined8 param_1,undefined8 param_2)

{
  libssh2_sftp_seek64(param_1,param_2);
  return;
}



undefined8 libssh2_sftp_tell(long param_1)

{
  undefined8 uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *(undefined8 *)(param_1 + 0x130);
  }
  return uVar1;
}



undefined8 libssh2_sftp_tell64(long param_1)

{
  undefined8 uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *(undefined8 *)(param_1 + 0x130);
  }
  return uVar1;
}



void sftp_packet_flush(long *param_1)

{
  long lVar1;
  long lVar2;
  long local_38;
  long local_30;
  
  lVar1 = *(long *)(*param_1 + 0x60);
  local_38 = _libssh2_list_first(param_1 + 2);
  local_30 = _libssh2_list_first(param_1 + 4);
  while (local_38 != 0) {
    lVar2 = _libssh2_list_next(local_38);
    _libssh2_list_remove(local_38);
    (**(code **)(lVar1 + 0x18))(*(undefined8 *)(local_38 + 0x20),lVar1);
    (**(code **)(lVar1 + 0x18))(local_38,lVar1);
    local_38 = lVar2;
  }
  while (local_30 != 0) {
    lVar2 = _libssh2_list_next(local_30);
    _libssh2_list_remove(local_30);
    (**(code **)(lVar1 + 0x18))(local_30,lVar1);
    local_30 = lVar2;
  }
  return;
}



int sftp_close_handle(long param_1)

{
  uint uVar1;
  int iVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  int local_4c;
  undefined local_40 [8];
  undefined *local_38;
  long local_30;
  long *local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *(long **)(param_1 + 0x18);
  local_20 = *local_28;
  local_18 = *(long *)(local_20 + 0x60);
  iVar2 = (int)*(undefined8 *)(param_1 + 0x120);
  uVar1 = iVar2 + 0xd;
  local_30 = 0;
  local_4c = 0;
  if (*(int *)(param_1 + 0x168) == 0) {
    uVar3 = (**(code **)(local_18 + 8))(uVar1,local_18);
    *(undefined8 *)(param_1 + 0x170) = uVar3;
    local_38 = *(undefined **)(param_1 + 0x170);
    if (*(long *)(param_1 + 0x170) == 0) {
      *(undefined4 *)(param_1 + 0x168) = 0;
      local_4c = _libssh2_error(local_18,0xfffffffa,"Unable to allocate memory for FXP_CLOSE packet"
                               );
    }
    else {
      _libssh2_store_u32(&local_38,iVar2 + 9);
      *local_38 = 4;
      iVar2 = *(int *)(local_28 + 1);
      *(int *)(local_28 + 1) = iVar2 + 1;
      *(int *)(param_1 + 0x16c) = iVar2;
      local_38 = local_38 + 1;
      _libssh2_store_u32(&local_38,*(undefined4 *)(param_1 + 0x16c));
      _libssh2_store_str(&local_38,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
      *(undefined4 *)(param_1 + 0x168) = 2;
    }
  }
  if (*(int *)(param_1 + 0x168) == 2) {
    local_4c = _libssh2_channel_write(local_20,0,*(undefined8 *)(param_1 + 0x170),uVar1);
    if (local_4c == -0x25) goto LAB_0013be35;
    if ((ulong)uVar1 == (long)local_4c) {
      *(undefined4 *)(param_1 + 0x168) = 3;
    }
    else {
      *(undefined4 *)(param_1 + 0x168) = 0;
      local_4c = _libssh2_error(local_18,0xfffffff9,"Unable to send FXP_CLOSE command");
    }
    (**(code **)(local_18 + 0x18))(*(undefined8 *)(param_1 + 0x170),local_18);
    *(undefined8 *)(param_1 + 0x170) = 0;
  }
  if (*(int *)(param_1 + 0x168) == 3) {
    local_4c = sftp_packet_require(local_28,0x65,*(undefined4 *)(param_1 + 0x16c),&local_30,local_40
                                  );
    if (local_4c == -0x25) goto LAB_0013be35;
    if (local_4c != 0) {
      _libssh2_error(local_18,local_4c,"Error waiting for status message");
    }
    *(undefined4 *)(param_1 + 0x168) = 4;
  }
  if (local_30 == 0) {
    if (local_4c == 0) {
                    // WARNING: Subroutine does not return
      __assert_fail("rc",
                    "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-3857_Libssh2/Libssh2/src/sftp.c"
                    ,0x99f,"sftp_close_handle");
    }
  }
  else {
    iVar2 = _libssh2_ntohu32(local_30 + 5);
    (**(code **)(local_18 + 0x18))(local_30,local_18);
    if (iVar2 != 0) {
      *(int *)(local_28 + 8) = iVar2;
      *(undefined4 *)(param_1 + 0x168) = 0;
      local_4c = _libssh2_error(local_18,0xffffffe1,"SFTP Protocol Error");
    }
  }
  _libssh2_list_remove(param_1);
  if ((*(int *)(param_1 + 0x128) == 1) && (*(int *)(param_1 + 0x130) != 0)) {
    (**(code **)(local_18 + 0x18))(*(undefined8 *)(param_1 + 0x138),local_18);
  }
  else if (*(long *)(param_1 + 0x148) != 0) {
    (**(code **)(local_18 + 0x18))(*(undefined8 *)(param_1 + 0x148),local_18);
  }
  sftp_packetlist_flush(param_1);
  *(undefined4 *)((long)local_28 + 0x94) = 0;
  *(undefined4 *)(param_1 + 0x168) = 0;
  (**(code **)(local_18 + 0x18))(param_1,local_18);
LAB_0013be35:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_4c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int libssh2_sftp_close_handle(long param_1)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = sftp_close_handle(param_1);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined8 sftp_unlink(long *param_1,undefined8 param_2,undefined8 param_3)

{
  uint uVar1;
  int iVar2;
  long lVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  undefined local_38 [8];
  undefined *local_30;
  long local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = *param_1;
  local_18 = *(long *)(local_20 + 0x60);
  uVar1 = (int)param_3 + 0xd;
  if (*(int *)((long)param_1 + 0xd4) == 0) {
    lVar3 = (**(code **)(local_18 + 8))(uVar1,local_18);
    param_1[0x1b] = lVar3;
    local_30 = (undefined *)param_1[0x1b];
    if (param_1[0x1b] == 0) {
      uVar4 = _libssh2_error(local_18,0xfffffffa,"Unable to allocate memory for FXP_REMOVE packet");
      goto LAB_0013c1b6;
    }
    _libssh2_store_u32(&local_30,(int)param_3 + 9);
    *local_30 = 0xd;
    iVar2 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar2 + 1;
    *(int *)(param_1 + 0x1c) = iVar2;
    local_30 = local_30 + 1;
    _libssh2_store_u32(&local_30,*(undefined4 *)(param_1 + 0x1c));
    _libssh2_store_str(&local_30,param_2,param_3);
    *(undefined4 *)((long)param_1 + 0xd4) = 2;
  }
  if (*(int *)((long)param_1 + 0xd4) == 2) {
    iVar2 = _libssh2_channel_write(local_20,0,param_1[0x1b],uVar1);
    if (iVar2 == -0x25) {
      uVar4 = 0xffffffdb;
      goto LAB_0013c1b6;
    }
    if ((ulong)uVar1 != (long)iVar2) {
      (**(code **)(local_18 + 0x18))(param_1[0x1b],local_18);
      param_1[0x1b] = 0;
      *(undefined4 *)((long)param_1 + 0xd4) = 0;
      uVar4 = _libssh2_error(local_18,0xfffffff9,"Unable to send FXP_REMOVE command");
      goto LAB_0013c1b6;
    }
    (**(code **)(local_18 + 0x18))(param_1[0x1b],local_18);
    param_1[0x1b] = 0;
    *(undefined4 *)((long)param_1 + 0xd4) = 3;
  }
  iVar2 = sftp_packet_require(param_1,0x65,*(undefined4 *)(param_1 + 0x1c),&local_28,local_38);
  if (iVar2 == -0x25) {
    uVar4 = 0xffffffdb;
  }
  else if (iVar2 == 0) {
    *(undefined4 *)((long)param_1 + 0xd4) = 0;
    iVar2 = _libssh2_ntohu32(local_28 + 5);
    (**(code **)(local_18 + 0x18))(local_28,local_18);
    if (iVar2 == 0) {
      uVar4 = 0;
    }
    else {
      *(int *)(param_1 + 8) = iVar2;
      uVar4 = _libssh2_error(local_18,0xffffffe1,"SFTP Protocol Error");
    }
  }
  else {
    *(undefined4 *)((long)param_1 + 0xd4) = 0;
    uVar4 = _libssh2_error(local_18,iVar2,"Error waiting for FXP STATUS");
  }
LAB_0013c1b6:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



int libssh2_sftp_unlink_ex(long *param_1,undefined8 param_2,undefined4 param_3)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == (long *)0x0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = sftp_unlink(param_1,param_2,param_3);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



ulong sftp_rename(long *param_1,undefined8 param_2,int param_3,undefined8 param_4,int param_5,
                 undefined4 param_6)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  ulong uVar4;
  long lVar5;
  long in_FS_OFFSET;
  uint local_40;
  undefined local_38 [8];
  long local_30;
  long local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *param_1;
  local_20 = *(long *)(local_28 + 0x60);
  if (*(uint *)((long)param_1 + 0xc) < 5) {
    iVar2 = 0;
  }
  else {
    iVar2 = 4;
  }
  iVar2 = iVar2 + param_3 + param_5;
  uVar3 = iVar2 + 0x11;
  if (*(uint *)((long)param_1 + 0xc) < 2) {
    uVar4 = _libssh2_error(local_20,0xffffffe1,"Server does not support RENAME");
    goto LAB_0013c67b;
  }
  if (*(int *)((long)param_1 + 0xe4) == 0) {
    lVar5 = (**(code **)(local_20 + 8))(uVar3,local_20);
    param_1[0x1d] = lVar5;
    param_1[0x1e] = param_1[0x1d];
    if (param_1[0x1d] == 0) {
      uVar4 = _libssh2_error(local_20,0xfffffffa,"Unable to allocate memory for FXP_RENAME packet");
      goto LAB_0013c67b;
    }
    _libssh2_store_u32(param_1 + 0x1e,iVar2 + 0xd);
    puVar1 = (undefined *)param_1[0x1e];
    param_1[0x1e] = (long)(puVar1 + 1);
    *puVar1 = 0x12;
    iVar2 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar2 + 1;
    *(int *)(param_1 + 0x1f) = iVar2;
    _libssh2_store_u32(param_1 + 0x1e,*(undefined4 *)(param_1 + 0x1f));
    _libssh2_store_str(param_1 + 0x1e,param_2,param_3);
    _libssh2_store_str(param_1 + 0x1e,param_4,param_5);
    if (4 < *(uint *)((long)param_1 + 0xc)) {
      _libssh2_store_u32(param_1 + 0x1e,param_6);
    }
    *(undefined4 *)((long)param_1 + 0xe4) = 2;
  }
  if (*(int *)((long)param_1 + 0xe4) == 2) {
    local_18 = _libssh2_channel_write(local_28,0,param_1[0x1d],param_1[0x1e] - param_1[0x1d]);
    if (local_18 == 0xffffffffffffffdb) {
      uVar4 = 0xffffffffffffffdb;
      goto LAB_0013c67b;
    }
    if (local_18 != uVar3) {
      (**(code **)(local_20 + 0x18))(param_1[0x1d],local_20);
      param_1[0x1d] = 0;
      *(undefined4 *)((long)param_1 + 0xe4) = 0;
      uVar4 = _libssh2_error(local_20,0xfffffff9,"Unable to send FXP_RENAME command");
      goto LAB_0013c67b;
    }
    (**(code **)(local_20 + 0x18))(param_1[0x1d],local_20);
    param_1[0x1d] = 0;
    *(undefined4 *)((long)param_1 + 0xe4) = 3;
  }
  iVar2 = sftp_packet_require(param_1,0x65,*(undefined4 *)(param_1 + 0x1f),&local_30,local_38);
  local_18 = (ulong)iVar2;
  if (local_18 == 0xffffffffffffffdb) {
    uVar4 = 0xffffffffffffffdb;
    goto LAB_0013c67b;
  }
  if (local_18 != 0) {
    *(undefined4 *)((long)param_1 + 0xe4) = 0;
    uVar4 = _libssh2_error(local_20,iVar2,"Error waiting for FXP STATUS");
    goto LAB_0013c67b;
  }
  *(undefined4 *)((long)param_1 + 0xe4) = 0;
  iVar2 = _libssh2_ntohu32(local_30 + 5);
  (**(code **)(local_20 + 0x18))(local_30,local_20);
  *(int *)(param_1 + 8) = iVar2;
  if (iVar2 == 0xb) {
    local_40 = _libssh2_error(local_20,0xffffffe1,
                              "File already exists and SSH_FXP_RENAME_OVERWRITE not specified");
  }
  else if (iVar2 < 0xc) {
    if (iVar2 == 0) {
      local_40 = 0;
    }
    else {
      if (iVar2 != 8) goto LAB_0013c65c;
      local_40 = _libssh2_error(local_20,0xffffffe1,"Operation Not Supported");
    }
  }
  else {
LAB_0013c65c:
    local_40 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error");
  }
  uVar4 = (ulong)local_40;
LAB_0013c67b:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int libssh2_sftp_rename_ex
              (long *param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,
              undefined4 param_5,undefined8 param_6)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == (long *)0x0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = sftp_rename(param_1,param_2,param_3,param_4,param_5,param_6);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined8 sftp_fstatvfs(long param_1,undefined8 *param_2)

{
  uint uVar1;
  int iVar2;
  undefined4 uVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  ulong local_50;
  undefined *local_48;
  char *local_40;
  undefined *local_38;
  long *local_30;
  long local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = *(long **)(param_1 + 0x18);
  local_28 = *local_30;
  local_20 = *(long *)(local_28 + 0x60);
  iVar2 = (int)*(undefined8 *)(param_1 + 0x120);
  uVar1 = iVar2 + 0x25;
  if (*(int *)((long)local_30 + 0xfc) == 0) {
    local_48 = (undefined *)(**(code **)(local_20 + 8))(uVar1,local_20);
    local_38 = local_48;
    if (local_48 == (undefined *)0x0) {
      uVar4 = _libssh2_error(local_20,0xfffffffa,"Unable to allocate memory for FXP_EXTENDED packet"
                            );
      goto LAB_0013cbed;
    }
    _libssh2_store_u32(&local_48,iVar2 + 0x21);
    *local_48 = 200;
    iVar2 = *(int *)(local_30 + 1);
    *(int *)(local_30 + 1) = iVar2 + 1;
    *(int *)(local_30 + 0x21) = iVar2;
    local_48 = local_48 + 1;
    _libssh2_store_u32(&local_48,*(undefined4 *)(local_30 + 0x21));
    _libssh2_store_str(&local_48,"fstatvfs@openssh.com",0x14);
    _libssh2_store_str(&local_48,param_1 + 0x20,*(undefined8 *)(param_1 + 0x120));
    *(undefined4 *)((long)local_30 + 0xfc) = 2;
  }
  else {
    local_38 = (undefined *)local_30[0x20];
  }
  if (*(int *)((long)local_30 + 0xfc) == 2) {
    local_18 = _libssh2_channel_write(local_28,0,local_38,uVar1);
    if ((local_18 == -0x25) || ((-1 < local_18 && (local_18 < (long)(ulong)uVar1)))) {
      local_30[0x20] = (long)local_38;
      uVar4 = 0xffffffdb;
      goto LAB_0013cbed;
    }
    (**(code **)(local_20 + 0x18))(local_38,local_20);
    local_30[0x20] = 0;
    if (local_18 < 0) {
      *(undefined4 *)((long)local_30 + 0xfc) = 0;
      uVar4 = _libssh2_error(local_20,0xfffffff9,"_libssh2_channel_write() failed");
      goto LAB_0013cbed;
    }
    *(undefined4 *)((long)local_30 + 0xfc) = 3;
  }
  iVar2 = sftp_packet_requirev
                    (local_30,2,&responses_20715,*(undefined4 *)(local_30 + 0x21),&local_40,
                     &local_50);
  local_18 = (long)iVar2;
  if (local_18 == -0x25) {
    uVar4 = 0xffffffffffffffdb;
  }
  else if (local_18 == 0) {
    if (*local_40 == 'e') {
      uVar3 = _libssh2_ntohu32(local_40 + 5);
      *(undefined4 *)((long)local_30 + 0xfc) = 0;
      (**(code **)(local_20 + 0x18))(local_40,local_20);
      *(undefined4 *)(local_30 + 8) = uVar3;
      uVar4 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error");
    }
    else if (local_50 < 0x5d) {
      (**(code **)(local_20 + 0x18))(local_40,local_20);
      *(undefined4 *)((long)local_30 + 0xfc) = 0;
      uVar4 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error: short response");
    }
    else {
      *(undefined4 *)((long)local_30 + 0xfc) = 0;
      uVar4 = _libssh2_ntohu64(local_40 + 5);
      *param_2 = uVar4;
      uVar4 = _libssh2_ntohu64(local_40 + 0xd);
      param_2[1] = uVar4;
      uVar4 = _libssh2_ntohu64(local_40 + 0x15);
      param_2[2] = uVar4;
      uVar4 = _libssh2_ntohu64(local_40 + 0x1d);
      param_2[3] = uVar4;
      uVar4 = _libssh2_ntohu64(local_40 + 0x25);
      param_2[4] = uVar4;
      uVar4 = _libssh2_ntohu64(local_40 + 0x2d);
      param_2[5] = uVar4;
      uVar4 = _libssh2_ntohu64(local_40 + 0x35);
      param_2[6] = uVar4;
      uVar4 = _libssh2_ntohu64(local_40 + 0x3d);
      param_2[7] = uVar4;
      uVar4 = _libssh2_ntohu64(local_40 + 0x45);
      param_2[8] = uVar4;
      uVar1 = _libssh2_ntohu64(local_40 + 0x4d);
      uVar4 = _libssh2_ntohu64(local_40 + 0x55);
      param_2[10] = uVar4;
      param_2[9] = (ulong)(uVar1 & 1);
      param_2[9] = (ulong)(uVar1 & 2) | param_2[9];
      (**(code **)(local_20 + 0x18))(local_40,local_20);
      uVar4 = 0;
    }
  }
  else {
    *(undefined4 *)((long)local_30 + 0xfc) = 0;
    uVar4 = _libssh2_error(local_20,iVar2,"Error waiting for FXP EXTENDED REPLY");
  }
LAB_0013cbed:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



int libssh2_sftp_fstatvfs(long param_1,long param_2)

{
  int iVar1;
  time_t tVar2;
  
  if ((param_1 == 0) || (param_2 == 0)) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = sftp_fstatvfs(param_1,param_2);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(**(long **)(param_1 + 0x18) + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(**(long **)(param_1 + 0x18) + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined8 sftp_statvfs(long *param_1,undefined8 param_2,int param_3,undefined8 *param_4)

{
  uint uVar1;
  int iVar2;
  undefined4 uVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  ulong local_48;
  undefined *local_40;
  char *local_38;
  undefined *local_30;
  long local_28;
  long local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *param_1;
  local_20 = *(long *)(local_28 + 0x60);
  uVar1 = param_3 + 0x24;
  if (*(int *)((long)param_1 + 0x10c) == 0) {
    local_40 = (undefined *)(**(code **)(local_20 + 8))(uVar1,local_20);
    local_30 = local_40;
    if (local_40 == (undefined *)0x0) {
      uVar4 = _libssh2_error(local_20,0xfffffffa,"Unable to allocate memory for FXP_EXTENDED packet"
                            );
      goto LAB_0013d135;
    }
    _libssh2_store_u32(&local_40,param_3 + 0x20);
    *local_40 = 200;
    iVar2 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar2 + 1;
    *(int *)(param_1 + 0x23) = iVar2;
    local_40 = local_40 + 1;
    _libssh2_store_u32(&local_40,*(undefined4 *)(param_1 + 0x23));
    _libssh2_store_str(&local_40,"statvfs@openssh.com",0x13);
    _libssh2_store_str(&local_40,param_2,param_3);
    *(undefined4 *)((long)param_1 + 0x10c) = 2;
  }
  else {
    local_30 = (undefined *)param_1[0x22];
  }
  if (*(int *)((long)param_1 + 0x10c) == 2) {
    local_18 = _libssh2_channel_write(local_28,0,local_30,uVar1);
    if ((local_18 == -0x25) || ((-1 < local_18 && (local_18 < (long)(ulong)uVar1)))) {
      param_1[0x22] = (long)local_30;
      uVar4 = 0xffffffdb;
      goto LAB_0013d135;
    }
    (**(code **)(local_20 + 0x18))(local_30,local_20);
    param_1[0x22] = 0;
    if (local_18 < 0) {
      *(undefined4 *)((long)param_1 + 0x10c) = 0;
      uVar4 = _libssh2_error(local_20,0xfffffff9,"_libssh2_channel_write() failed");
      goto LAB_0013d135;
    }
    *(undefined4 *)((long)param_1 + 0x10c) = 3;
  }
  iVar2 = sftp_packet_requirev
                    (param_1,2,&responses_20740,*(undefined4 *)(param_1 + 0x23),&local_38,&local_48)
  ;
  local_18 = (long)iVar2;
  if (local_18 == -0x25) {
    uVar4 = 0xffffffffffffffdb;
  }
  else if (local_18 == 0) {
    if (*local_38 == 'e') {
      uVar3 = _libssh2_ntohu32(local_38 + 5);
      *(undefined4 *)((long)param_1 + 0x10c) = 0;
      (**(code **)(local_20 + 0x18))(local_38,local_20);
      *(undefined4 *)(param_1 + 8) = uVar3;
      uVar4 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error");
    }
    else if (local_48 < 0x5d) {
      (**(code **)(local_20 + 0x18))(local_38,local_20);
      *(undefined4 *)((long)param_1 + 0x10c) = 0;
      uVar4 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error: short response");
    }
    else {
      *(undefined4 *)((long)param_1 + 0x10c) = 0;
      uVar4 = _libssh2_ntohu64(local_38 + 5);
      *param_4 = uVar4;
      uVar4 = _libssh2_ntohu64(local_38 + 0xd);
      param_4[1] = uVar4;
      uVar4 = _libssh2_ntohu64(local_38 + 0x15);
      param_4[2] = uVar4;
      uVar4 = _libssh2_ntohu64(local_38 + 0x1d);
      param_4[3] = uVar4;
      uVar4 = _libssh2_ntohu64(local_38 + 0x25);
      param_4[4] = uVar4;
      uVar4 = _libssh2_ntohu64(local_38 + 0x2d);
      param_4[5] = uVar4;
      uVar4 = _libssh2_ntohu64(local_38 + 0x35);
      param_4[6] = uVar4;
      uVar4 = _libssh2_ntohu64(local_38 + 0x3d);
      param_4[7] = uVar4;
      uVar4 = _libssh2_ntohu64(local_38 + 0x45);
      param_4[8] = uVar4;
      uVar1 = _libssh2_ntohu64(local_38 + 0x4d);
      uVar4 = _libssh2_ntohu64(local_38 + 0x55);
      param_4[10] = uVar4;
      param_4[9] = (ulong)(uVar1 & 1);
      param_4[9] = (ulong)(uVar1 & 2) | param_4[9];
      (**(code **)(local_20 + 0x18))(local_38,local_20);
      uVar4 = 0;
    }
  }
  else {
    *(undefined4 *)((long)param_1 + 0x10c) = 0;
    uVar4 = _libssh2_error(local_20,iVar2,"Error waiting for FXP EXTENDED REPLY");
  }
LAB_0013d135:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



int libssh2_sftp_statvfs(long *param_1,undefined8 param_2,undefined4 param_3,long param_4)

{
  int iVar1;
  time_t tVar2;
  
  if ((param_1 == (long *)0x0) || (param_4 == 0)) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = sftp_statvfs(param_1,param_2,param_3,param_4);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined8 sftp_mkdir(long *param_1,undefined8 param_2,int param_3,ulong param_4)

{
  int iVar1;
  undefined8 uVar2;
  long lVar3;
  long in_FS_OFFSET;
  undefined local_80 [8];
  undefined *local_78;
  long local_70;
  undefined *local_68;
  long local_60;
  long local_58;
  ulong local_50;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  ulong local_28;
  undefined8 local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_60 = *param_1;
  local_58 = *(long *)(local_60 + 0x60);
  local_48 = 0;
  local_40 = 0;
  local_38 = 0;
  local_30 = 0;
  local_28 = 0;
  local_20 = 0;
  local_18 = 0;
  if (param_4 != 0xffffffffffffffff) {
    local_48 = 4;
    local_28 = param_4 | 0x4000;
  }
  iVar1 = sftp_attrsize(local_48);
  local_50 = (ulong)(param_3 + iVar1 + 0xd);
  if (*(int *)((long)param_1 + 0x11c) == 0) {
    local_78 = (undefined *)(**(code **)(local_58 + 8))(local_50,local_58);
    local_68 = local_78;
    if (local_78 == (undefined *)0x0) {
      uVar2 = _libssh2_error(local_58,0xfffffffa,"Unable to allocate memory for FXP_MKDIR packet");
      goto LAB_0013d592;
    }
    _libssh2_store_u32(&local_78,(int)local_50 + -4);
    *local_78 = 0xe;
    iVar1 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar1 + 1;
    *(int *)(param_1 + 0x25) = iVar1;
    local_78 = local_78 + 1;
    _libssh2_store_u32(&local_78,*(undefined4 *)(param_1 + 0x25));
    _libssh2_store_str(&local_78,param_2,param_3);
    lVar3 = sftp_attr2bin(local_78,&local_48);
    local_78 = local_78 + lVar3;
    *(undefined4 *)((long)param_1 + 0x11c) = 2;
  }
  else {
    local_68 = (undefined *)param_1[0x24];
  }
  if (*(int *)((long)param_1 + 0x11c) == 2) {
    iVar1 = _libssh2_channel_write(local_60,0,local_68,local_50);
    if (iVar1 == -0x25) {
      param_1[0x24] = (long)local_68;
      uVar2 = 0xffffffdb;
      goto LAB_0013d592;
    }
    if (local_50 != (long)iVar1) {
      (**(code **)(local_58 + 0x18))(local_68,local_58);
      *(undefined4 *)((long)param_1 + 0x11c) = 0;
      uVar2 = _libssh2_error(local_58,0xfffffff9,"_libssh2_channel_write() failed");
      goto LAB_0013d592;
    }
    (**(code **)(local_58 + 0x18))(local_68,local_58);
    *(undefined4 *)((long)param_1 + 0x11c) = 3;
    param_1[0x24] = 0;
  }
  iVar1 = sftp_packet_require(param_1,0x65,*(undefined4 *)(param_1 + 0x25),&local_70,local_80);
  if (iVar1 == -0x25) {
    uVar2 = 0xffffffdb;
  }
  else if (iVar1 == 0) {
    *(undefined4 *)((long)param_1 + 0x11c) = 0;
    iVar1 = _libssh2_ntohu32(local_70 + 5);
    (**(code **)(local_58 + 0x18))(local_70,local_58);
    if (iVar1 == 0) {
      uVar2 = 0;
    }
    else {
      *(int *)(param_1 + 8) = iVar1;
      uVar2 = _libssh2_error(local_58,0xffffffe1,"SFTP Protocol Error");
    }
  }
  else {
    *(undefined4 *)((long)param_1 + 0x11c) = 0;
    uVar2 = _libssh2_error(local_58,iVar1,"Error waiting for FXP STATUS");
  }
LAB_0013d592:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



int libssh2_sftp_mkdir_ex(long *param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == (long *)0x0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = sftp_mkdir(param_1,param_2,param_3,param_4);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined8 sftp_rmdir(long *param_1,undefined8 param_2,int param_3)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  undefined local_40 [8];
  undefined *local_38;
  long local_30;
  long local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *param_1;
  local_20 = *(long *)(local_28 + 0x60);
  local_18 = (ulong)(param_3 + 0xd);
  if (*(int *)((long)param_1 + 300) == 0) {
    lVar2 = (**(code **)(local_20 + 8))(local_18,local_20);
    param_1[0x26] = lVar2;
    local_38 = (undefined *)param_1[0x26];
    if (param_1[0x26] == 0) {
      uVar3 = _libssh2_error(local_20,0xfffffffa,"Unable to allocate memory for FXP_RMDIR packet");
      goto LAB_0013d922;
    }
    _libssh2_store_u32(&local_38,(int)local_18 + -4);
    *local_38 = 0xf;
    iVar1 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar1 + 1;
    *(int *)(param_1 + 0x27) = iVar1;
    local_38 = local_38 + 1;
    _libssh2_store_u32(&local_38,*(undefined4 *)(param_1 + 0x27));
    _libssh2_store_str(&local_38,param_2,param_3);
    *(undefined4 *)((long)param_1 + 300) = 2;
  }
  if (*(int *)((long)param_1 + 300) == 2) {
    iVar1 = _libssh2_channel_write(local_28,0,param_1[0x26],local_18);
    if (iVar1 == -0x25) {
      uVar3 = 0xffffffdb;
      goto LAB_0013d922;
    }
    if (local_18 != (long)iVar1) {
      (**(code **)(local_20 + 0x18))(param_1[0x26],local_20);
      param_1[0x26] = 0;
      *(undefined4 *)((long)param_1 + 300) = 0;
      uVar3 = _libssh2_error(local_20,0xfffffff9,"Unable to send FXP_RMDIR command");
      goto LAB_0013d922;
    }
    (**(code **)(local_20 + 0x18))(param_1[0x26],local_20);
    param_1[0x26] = 0;
    *(undefined4 *)((long)param_1 + 300) = 3;
  }
  iVar1 = sftp_packet_require(param_1,0x65,*(undefined4 *)(param_1 + 0x27),&local_30,local_40);
  if (iVar1 == -0x25) {
    uVar3 = 0xffffffdb;
  }
  else if (iVar1 == 0) {
    *(undefined4 *)((long)param_1 + 300) = 0;
    iVar1 = _libssh2_ntohu32(local_30 + 5);
    (**(code **)(local_20 + 0x18))(local_30,local_20);
    if (iVar1 == 0) {
      uVar3 = 0;
    }
    else {
      *(int *)(param_1 + 8) = iVar1;
      uVar3 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error");
    }
  }
  else {
    *(undefined4 *)((long)param_1 + 300) = 0;
    uVar3 = _libssh2_error(local_20,iVar1,"Error waiting for FXP STATUS");
  }
LAB_0013d922:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



int libssh2_sftp_rmdir_ex(long *param_1,undefined8 param_2,undefined4 param_3)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == (long *)0x0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = sftp_rmdir(param_1,param_2,param_3);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined8 sftp_stat(long *param_1,undefined8 param_2,int param_3,int param_4,undefined8 *param_5)

{
  int iVar1;
  long lVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  undefined local_40 [8];
  undefined *local_38;
  char *local_30;
  long local_28;
  long local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *param_1;
  local_20 = *(long *)(local_28 + 0x60);
  if (param_4 == 2) {
    iVar1 = sftp_attrsize(*param_5);
  }
  else {
    iVar1 = 0;
  }
  local_18 = (ulong)(param_3 + iVar1 + 0xd);
  if (*(int *)((long)param_1 + 0x13c) == 0) {
    lVar2 = (**(code **)(local_20 + 8))(local_18,local_20);
    param_1[0x28] = lVar2;
    local_38 = (undefined *)param_1[0x28];
    if (param_1[0x28] == 0) {
      uVar3 = _libssh2_error(local_20,0xfffffffa,"Unable to allocate memory for FXP_*STAT packet");
      goto LAB_0013dda2;
    }
    _libssh2_store_u32(&local_38,(int)local_18 + -4);
    if (param_4 == 1) {
      *local_38 = 7;
    }
    else if (param_4 == 2) {
      *local_38 = 9;
    }
    else {
      *local_38 = 0x11;
    }
    local_38 = local_38 + 1;
    iVar1 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar1 + 1;
    *(int *)(param_1 + 0x29) = iVar1;
    _libssh2_store_u32(&local_38,*(undefined4 *)(param_1 + 0x29));
    _libssh2_store_str(&local_38,param_2,param_3);
    if (param_4 == 2) {
      lVar2 = sftp_attr2bin(local_38,param_5);
      local_38 = local_38 + lVar2;
    }
    *(undefined4 *)((long)param_1 + 0x13c) = 2;
  }
  if (*(int *)((long)param_1 + 0x13c) == 2) {
    iVar1 = _libssh2_channel_write(local_28,0,param_1[0x28],local_18);
    if (iVar1 == -0x25) {
      uVar3 = 0xffffffdb;
      goto LAB_0013dda2;
    }
    if (local_18 != (long)iVar1) {
      (**(code **)(local_20 + 0x18))(param_1[0x28],local_20);
      param_1[0x28] = 0;
      *(undefined4 *)((long)param_1 + 0x13c) = 0;
      uVar3 = _libssh2_error(local_20,0xfffffff9,"Unable to send STAT/LSTAT/SETSTAT command");
      goto LAB_0013dda2;
    }
    (**(code **)(local_20 + 0x18))(param_1[0x28],local_20);
    param_1[0x28] = 0;
    *(undefined4 *)((long)param_1 + 0x13c) = 3;
  }
  iVar1 = sftp_packet_requirev
                    (param_1,2,&stat_responses_20813,*(undefined4 *)(param_1 + 0x29),&local_30,
                     local_40);
  if (iVar1 == -0x25) {
    uVar3 = 0xffffffdb;
  }
  else if (iVar1 == 0) {
    *(undefined4 *)((long)param_1 + 0x13c) = 0;
    if (*local_30 == 'e') {
      iVar1 = _libssh2_ntohu32(local_30 + 5);
      (**(code **)(local_20 + 0x18))(local_30,local_20);
      if (iVar1 == 0) {
        memset(param_5,0,0x38);
        uVar3 = 0;
      }
      else {
        *(int *)(param_1 + 8) = iVar1;
        uVar3 = _libssh2_error(local_20,0xffffffe1,"SFTP Protocol Error");
      }
    }
    else {
      memset(param_5,0,0x38);
      sftp_bin2attr(param_5,local_30 + 5);
      (**(code **)(local_20 + 0x18))(local_30,local_20);
      uVar3 = 0;
    }
  }
  else {
    *(undefined4 *)((long)param_1 + 0x13c) = 0;
    uVar3 = _libssh2_error(local_20,iVar1,"Timeout waiting for status message");
  }
LAB_0013dda2:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



int libssh2_sftp_stat_ex
              (long *param_1,undefined8 param_2,undefined4 param_3,undefined4 param_4,
              undefined8 param_5)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == (long *)0x0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = sftp_stat(param_1,param_2,param_3,param_4,param_5);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



ulong sftp_symlink(long *param_1,undefined8 param_2,int param_3,void *param_4,uint param_5,
                  int param_6)

{
  int iVar1;
  uint uVar2;
  ulong uVar3;
  long lVar4;
  long in_FS_OFFSET;
  uint local_54;
  undefined local_50 [8];
  undefined *local_48;
  char *local_40;
  long local_38;
  long local_30;
  ulong local_28;
  ulong local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = *param_1;
  local_30 = *(long *)(local_38 + 0x60);
  if (param_6 == 0) {
    iVar1 = param_5 + 4;
  }
  else {
    iVar1 = 0;
  }
  local_28 = (ulong)(param_3 + iVar1 + 0xd);
  if ((*(uint *)((long)param_1 + 0xc) < 3) && (param_6 != 2)) {
    uVar3 = _libssh2_error(local_30,0xffffffe1,"Server does not support SYMLINK or READLINK");
    goto LAB_0013e2b2;
  }
  if (*(int *)((long)param_1 + 0x14c) == 0) {
    lVar4 = (**(code **)(local_30 + 8))(local_28,local_30);
    param_1[0x2a] = lVar4;
    local_48 = (undefined *)param_1[0x2a];
    if (param_1[0x2a] == 0) {
      uVar3 = _libssh2_error(local_30,0xfffffffa,
                             "Unable to allocate memory for SYMLINK/READLINK/REALPATH packet");
      goto LAB_0013e2b2;
    }
    _libssh2_store_u32(&local_48,(int)local_28 + -4);
    if (param_6 == 0) {
      *local_48 = 0x14;
    }
    else if (param_6 == 2) {
      *local_48 = 0x10;
    }
    else {
      *local_48 = 0x13;
    }
    local_48 = local_48 + 1;
    iVar1 = *(int *)(param_1 + 1);
    *(int *)(param_1 + 1) = iVar1 + 1;
    *(int *)(param_1 + 0x2b) = iVar1;
    _libssh2_store_u32(&local_48,*(undefined4 *)(param_1 + 0x2b));
    _libssh2_store_str(&local_48,param_2,param_3);
    if (param_6 == 0) {
      _libssh2_store_str(&local_48,param_4,param_5);
    }
    *(undefined4 *)((long)param_1 + 0x14c) = 2;
  }
  if (*(int *)((long)param_1 + 0x14c) == 2) {
    local_20 = _libssh2_channel_write(local_38,0,param_1[0x2a],local_28);
    if (local_20 == 0xffffffffffffffdb) {
      uVar3 = 0xffffffffffffffdb;
      goto LAB_0013e2b2;
    }
    if (local_28 != local_20) {
      (**(code **)(local_30 + 0x18))(param_1[0x2a],local_30);
      param_1[0x2a] = 0;
      *(undefined4 *)((long)param_1 + 0x14c) = 0;
      uVar3 = _libssh2_error(local_30,0xfffffff9,"Unable to send SYMLINK/READLINK command");
      goto LAB_0013e2b2;
    }
    (**(code **)(local_30 + 0x18))(param_1[0x2a],local_30);
    param_1[0x2a] = 0;
    *(undefined4 *)((long)param_1 + 0x14c) = 3;
  }
  iVar1 = sftp_packet_requirev
                    (param_1,2,&link_responses_20847,*(undefined4 *)(param_1 + 0x2b),&local_40,
                     local_50);
  if (iVar1 == -0x25) {
    uVar3 = 0xffffffdb;
  }
  else if (iVar1 == 0) {
    *(undefined4 *)((long)param_1 + 0x14c) = 0;
    if (*local_40 == 'e') {
      iVar1 = _libssh2_ntohu32(local_40 + 5);
      (**(code **)(local_30 + 0x18))(local_40,local_30);
      if (iVar1 == 0) {
        uVar3 = 0;
      }
      else {
        *(int *)(param_1 + 8) = iVar1;
        uVar3 = _libssh2_error(local_30,0xffffffe1,"SFTP Protocol Error");
      }
    }
    else {
      iVar1 = _libssh2_ntohu32(local_40 + 5);
      if (iVar1 == 0) {
        (**(code **)(local_30 + 0x18))(local_40,local_30);
        uVar3 = _libssh2_error(local_30,0xffffffe1,
                               "Invalid READLINK/REALPATH response, no name entries");
      }
      else {
        uVar2 = _libssh2_ntohu32(local_40 + 9);
        local_18 = (ulong)uVar2;
        if (local_18 < param_5) {
          memcpy(param_4,local_40 + 0xd,local_18);
          *(undefined *)(local_18 + (long)param_4) = 0;
          local_54 = (uint)local_18;
        }
        else {
          local_54 = 0xffffffda;
        }
        (**(code **)(local_30 + 0x18))(local_40,local_30);
        uVar3 = (ulong)local_54;
      }
    }
  }
  else {
    *(undefined4 *)((long)param_1 + 0x14c) = 0;
    uVar3 = _libssh2_error(local_30,iVar1,"Error waiting for status message");
  }
LAB_0013e2b2:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



int libssh2_sftp_symlink_ex
              (long *param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,
              undefined4 param_5,undefined4 param_6)

{
  int iVar1;
  time_t tVar2;
  
  if (param_1 == (long *)0x0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      iVar1 = sftp_symlink(param_1,param_2,param_3,param_4,param_5,param_6);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(*(long *)(*param_1 + 0x60) + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(*(undefined8 *)(*param_1 + 0x60),tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined4 libssh2_sftp_last_error(long param_1)

{
  undefined4 uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *(undefined4 *)(param_1 + 0x40);
  }
  return uVar1;
}



undefined8 libssh2_sftp_get_channel(undefined8 *param_1)

{
  undefined8 uVar1;
  
  if (param_1 == (undefined8 *)0x0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *param_1;
  }
  return uVar1;
}



int decrypt(EVP_PKEY_CTX *ctx,uchar *out,size_t *outlen,uchar *in,size_t inlen)

{
  int iVar1;
  int iVar2;
  int local_34;
  size_t *local_30;
  uchar *local_28;
  
  local_34 = (int)in;
  iVar1 = *(int *)(*(long *)(ctx + 0x128) + 0x10);
  local_30 = outlen;
  local_28 = out;
  if (local_34 % iVar1 != 0) {
                    // WARNING: Subroutine does not return
    __assert_fail("(len % blocksize) == 0",
                  "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-3857_Libssh2/Libssh2/src/transport.c"
                  ,0x8b,"decrypt");
  }
  while( true ) {
    if (local_34 < iVar1) {
      return 0;
    }
    iVar2 = (**(code **)(*(long *)(ctx + 0x128) + 0x30))(ctx,local_28,(long)iVar1,ctx + 0x130);
    if (iVar2 != 0) break;
    memcpy(local_30,local_28,(long)iVar1);
    local_34 = local_34 - iVar1;
    local_30 = (size_t *)((long)local_30 + (long)iVar1);
    local_28 = local_28 + iVar1;
  }
  (**(code **)(ctx + 0x18))(*(undefined8 *)(ctx + 0x4278),ctx);
  return -0xc;
}



int fullpacket(long param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  long in_FS_OFFSET;
  undefined8 local_70;
  undefined8 local_68;
  long local_60;
  undefined local_58 [72];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_60 = param_1 + 0x248;
  if (*(int *)(param_1 + 0xd388) == 0) {
    *(undefined4 *)(param_1 + 0xd38c) = 0;
    *(ulong *)(param_1 + 0xd390) = (ulong)(*(int *)(param_1 + 0x4260) - 1);
    if (param_2 != 0) {
      (**(code **)(*(long *)(param_1 + 0x138) + 0x18))
                (param_1,local_58,*(undefined4 *)(param_1 + 0x140),param_1 + 0x4248,5,
                 *(undefined8 *)(param_1 + 0x4278),*(ulong *)(param_1 + 0xd390) & 0xffffffff,
                 param_1 + 0x148);
      iVar2 = memcmp(local_58,(void *)(*(long *)(local_60 + 0x4030) + *(long *)(param_1 + 0xd390)),
                     (long)*(int *)(*(long *)(param_1 + 0x138) + 8));
      if (iVar2 != 0) {
        *(undefined4 *)(param_1 + 0xd38c) = 0xffffffff;
      }
    }
    *(int *)(param_1 + 0x140) = *(int *)(param_1 + 0x140) + 1;
    *(ulong *)(param_1 + 0xd390) = *(long *)(param_1 + 0xd390) - (ulong)*(byte *)(local_60 + 0x401c)
    ;
    if (((*(long *)(param_1 + 0x1c0) == 0) || (*(int *)(*(long *)(param_1 + 0x1c0) + 8) == 0)) ||
       (((*(uint *)(param_1 + 0x68) & 4) == 0 && (*(int *)(*(long *)(param_1 + 0x1c0) + 0xc) == 0)))
       ) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if ((bVar1) && (*(long *)(param_1 + 0x158) != 0)) {
      iVar2 = (**(code **)(*(long *)(param_1 + 0x150) + 0x20))
                        (param_1,&local_70,&local_68,40000,*(undefined8 *)(local_60 + 0x4030),
                         *(undefined8 *)(param_1 + 0xd390),param_1 + 0x158);
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(local_60 + 0x4030),param_1);
      if (iVar2 != 0) goto LAB_0013e7d8;
      *(undefined8 *)(local_60 + 0x4030) = local_70;
      *(undefined8 *)(param_1 + 0xd390) = local_68;
    }
    *(uint *)(param_1 + 0xd398) = (uint)**(byte **)(local_60 + 0x4030);
    *(undefined4 *)(param_1 + 0xd388) = 2;
  }
  if (*(int *)(param_1 + 0xd388) == 2) {
    iVar2 = _libssh2_packet_add(param_1,*(undefined8 *)(local_60 + 0x4030),
                                *(undefined8 *)(param_1 + 0xd390),*(undefined4 *)(param_1 + 0xd38c))
    ;
    if (iVar2 == -0x25) goto LAB_0013e7d8;
    if (iVar2 != 0) {
      *(undefined4 *)(param_1 + 0xd388) = 0;
      goto LAB_0013e7d8;
    }
  }
  *(undefined4 *)(param_1 + 0xd388) = 0;
  iVar2 = *(int *)(param_1 + 0xd398);
LAB_0013e7d8:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int _libssh2_transport_read(EVP_PKEY_CTX *param_1)

{
  int iVar1;
  undefined4 uVar2;
  EVP_PKEY_CTX *__dest;
  long lVar3;
  ulong uVar4;
  uint uVar5;
  EVP_PKEY_CTX *in_R8;
  undefined8 uVar6;
  long in_FS_OFFSET;
  uint local_74;
  uint local_70;
  uint local_6c;
  uint local_68;
  int local_64;
  undefined8 local_38;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  __dest = param_1 + 0x248;
  local_64 = 1;
  *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) & 0xfffffffe;
  if ((((*(uint *)(param_1 + 0x68) & 1) == 0) || ((*(uint *)(param_1 + 0x68) & 8) != 0)) ||
     (iVar1 = _libssh2_kex_exchange(param_1,1,param_1 + 0xccd0), iVar1 == 0)) {
    if (*(int *)(param_1 + 0xd090) == 0xb) {
      *(undefined4 *)(param_1 + 0xd090) = 0;
      local_64 = *(int *)(param_1 + 0xd094);
    }
    else {
      do {
        if (*(int *)(param_1 + 0x22c) == -1) {
          iVar1 = 0;
          goto LAB_0013ef74;
        }
        if ((*(uint *)(param_1 + 0x68) & 2) == 0) {
          local_64 = 0;
          local_68 = 5;
        }
        else {
          local_68 = *(uint *)(*(long *)(param_1 + 0x128) + 0x10);
        }
        local_74 = (int)*(undefined8 *)(param_1 + 0x4250) - (int)*(undefined8 *)(param_1 + 0x4258);
        if ((int)local_74 < 0) {
                    // WARNING: Subroutine does not return
          __assert_fail("remainbuf >= 0",
                        "/home/remnux/Desktop/Thesis-Experiments/Third_Experiment/SAST_With_SRE/CVEs/CVE-2019-3857_Libssh2/Libssh2/src/transport.c"
                        ,0x15e,"_libssh2_transport_read");
        }
        if ((int)local_74 < (int)local_68) {
          if (local_74 == 0) {
            *(undefined8 *)(param_1 + 0x4250) = 0;
            *(undefined8 *)(param_1 + 0x4258) = *(undefined8 *)(param_1 + 0x4250);
          }
          else {
            memmove(__dest,__dest + *(long *)(param_1 + 0x4258),(long)(int)local_74);
            *(undefined8 *)(param_1 + 0x4258) = 0;
            *(long *)(param_1 + 0x4250) = (long)(int)local_74;
          }
          if (*(int *)(param_1 + 0x6c) == 0) {
            uVar6 = 0x4000;
          }
          else {
            uVar6 = 0;
          }
          in_R8 = param_1;
          lVar3 = (**(code **)(param_1 + 0x50))
                            (*(undefined4 *)(param_1 + 0x228),__dest + (int)local_74,
                             (long)(int)(0x4000 - local_74),uVar6);
          if (lVar3 < 1) {
            if ((lVar3 < 0) && (lVar3 == -0xb)) {
              *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) | 1;
              iVar1 = -0x25;
            }
            else {
              iVar1 = -0x2b;
            }
            goto LAB_0013ef74;
          }
          *(long *)(param_1 + 0x4250) = *(long *)(param_1 + 0x4250) + lVar3;
          local_74 = (int)*(undefined8 *)(param_1 + 0x4250) - (int)*(undefined8 *)(param_1 + 0x4258)
          ;
        }
        local_70 = local_74;
        if (*(long *)(param_1 + 0x4270) == 0) {
          if ((int)local_74 < (int)local_68) {
            *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) | 1;
            iVar1 = -0x25;
            goto LAB_0013ef74;
          }
          if (local_64 == 0) {
            memcpy(&local_38,__dest + *(long *)(param_1 + 0x4258),(long)(int)local_68);
          }
          else {
            iVar1 = decrypt(param_1,(uchar *)(__dest + *(long *)(param_1 + 0x4258)),&local_38,
                            (uchar *)(ulong)local_68,(size_t)in_R8);
            if (iVar1 != 0) goto LAB_0013ef74;
            memcpy(param_1 + 0x4248,&local_38,5);
          }
          *(long *)(param_1 + 0x4258) = *(long *)(param_1 + 0x4258) + (long)(int)local_68;
          uVar2 = _libssh2_ntohu32(&local_38);
          *(undefined4 *)(param_1 + 0x4260) = uVar2;
          if (*(int *)(param_1 + 0x4260) == 0) {
            iVar1 = -0xc;
            goto LAB_0013ef74;
          }
          param_1[0x4264] = local_38._4_1_;
          if (local_64 == 0) {
            iVar1 = 0;
          }
          else {
            iVar1 = *(int *)(*(long *)(param_1 + 0x138) + 8);
          }
          uVar4 = (ulong)((iVar1 + *(int *)(param_1 + 0x4260)) - 1);
          if (40000 < uVar4) {
            iVar1 = -0x29;
            goto LAB_0013ef74;
          }
          uVar6 = (**(code **)(param_1 + 8))(uVar4,param_1);
          *(undefined8 *)(param_1 + 0x4278) = uVar6;
          if (*(long *)(param_1 + 0x4278) == 0) {
            iVar1 = -6;
            goto LAB_0013ef74;
          }
          *(ulong *)(param_1 + 0x4270) = uVar4;
          *(undefined8 *)(param_1 + 0x4280) = *(undefined8 *)(param_1 + 0x4278);
          if (5 < (int)local_68) {
            memcpy(*(void **)(param_1 + 0x4280),(void *)((long)&local_38 + 5),
                   (long)(int)(local_68 - 5));
            *(long *)(param_1 + 0x4280) = (long)(int)local_68 + -5 + *(long *)(param_1 + 0x4280);
          }
          *(long *)(param_1 + 17000) = *(long *)(param_1 + 0x4280) - *(long *)(param_1 + 0x4278);
          local_70 = local_74 - local_68;
        }
        uVar5 = (int)*(undefined8 *)(param_1 + 0x4270) - (int)*(undefined8 *)(param_1 + 17000);
        if ((int)uVar5 < (int)local_70) {
          local_70 = uVar5;
        }
        if (local_64 == 0) {
          local_6c = 0;
        }
        else if ((ulong)(*(long *)(param_1 + 0x4270) -
                        (long)*(int *)(*(long *)(param_1 + 0x138) + 8)) <
                 (ulong)(*(long *)(param_1 + 17000) + (long)(int)local_70)) {
          local_6c = ((int)*(undefined8 *)(param_1 + 0x4270) -
                     *(int *)(*(long *)(param_1 + 0x138) + 8)) -
                     (int)*(undefined8 *)(param_1 + 17000);
        }
        else {
          local_6c = local_70;
          if ((int)local_70 % (int)local_68 != 0) {
            local_6c = local_70 - (int)local_70 % (int)local_68;
            local_70 = 0;
          }
        }
        if (0 < (int)local_6c) {
          iVar1 = decrypt(param_1,(uchar *)(__dest + *(long *)(param_1 + 0x4258)),
                          *(size_t **)(param_1 + 0x4280),(uchar *)(ulong)local_6c,(size_t)in_R8);
          if (iVar1 != 0) {
            *(undefined8 *)(param_1 + 0x4270) = 0;
            goto LAB_0013ef74;
          }
          *(long *)(param_1 + 0x4258) = *(long *)(param_1 + 0x4258) + (long)(int)local_6c;
          *(long *)(param_1 + 0x4280) = *(long *)(param_1 + 0x4280) + (long)(int)local_6c;
          *(long *)(param_1 + 17000) = *(long *)(param_1 + 17000) + (long)(int)local_6c;
          local_70 = local_70 - local_6c;
        }
        if (0 < (int)local_70) {
          memcpy(*(void **)(param_1 + 0x4280),__dest + *(long *)(param_1 + 0x4258),
                 (long)(int)local_70);
          *(long *)(param_1 + 0x4258) = *(long *)(param_1 + 0x4258) + (long)(int)local_70;
          *(long *)(param_1 + 0x4280) = *(long *)(param_1 + 0x4280) + (long)(int)local_70;
          *(long *)(param_1 + 17000) = *(long *)(param_1 + 17000) + (long)(int)local_70;
        }
      } while ((int)*(undefined8 *)(param_1 + 0x4270) != (int)*(undefined8 *)(param_1 + 17000));
    }
    iVar1 = fullpacket(param_1,local_64);
    if (iVar1 == -0x25) {
      if (*(int *)(param_1 + 0xd2b8) != 0) {
        *(int *)(param_1 + 0xd094) = local_64;
        *(undefined4 *)(param_1 + 0xd090) = 0xb;
      }
    }
    else {
      *(undefined8 *)(param_1 + 0x4270) = 0;
    }
  }
LAB_0013ef74:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 send_existing(long param_1,long param_2,long param_3,undefined8 *param_4)

{
  undefined8 uVar1;
  long lVar2;
  long lVar3;
  
  if (*(long *)(param_1 + 0xcb50) == 0) {
    *param_4 = 0;
    uVar1 = 0;
  }
  else if ((param_2 == *(long *)(param_1 + 0xcb48)) && (param_3 == *(long *)(param_1 + 0xcb50))) {
    *param_4 = 1;
    lVar3 = (long)*(int *)(param_1 + 0xcb40) - *(long *)(param_1 + 0xcb58);
    if (*(int *)(param_1 + 0x6c) == 0) {
      uVar1 = 0x4000;
    }
    else {
      uVar1 = 0;
    }
    lVar2 = (**(code **)(param_1 + 0x48))
                      (*(undefined4 *)(param_1 + 0x228),
                       *(long *)(param_1 + 0xcb58) + param_1 + 0x4288,lVar3,uVar1,param_1);
    if (lVar2 == lVar3) {
      *(undefined4 *)(param_1 + 0xcb40) = 0;
      *(undefined8 *)(param_1 + 0xcb50) = 0;
      uVar1 = 0;
    }
    else if (lVar2 < 0) {
      if (lVar2 == -0xb) {
        *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) | 2;
        uVar1 = 0xffffffdb;
      }
      else {
        uVar1 = 0xfffffff9;
      }
    }
    else {
      *(long *)(param_1 + 0xcb58) = *(long *)(param_1 + 0xcb58) + lVar2;
      if (lVar2 < lVar3) {
        uVar1 = 0xffffffdb;
      }
      else {
        uVar1 = 0;
      }
    }
  }
  else {
    uVar1 = 0xffffffd9;
  }
  return uVar1;
}



int _libssh2_transport_send(long param_1,void *param_2,size_t param_3,void *param_4,size_t param_5)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  long lVar5;
  undefined8 uVar6;
  long in_FS_OFFSET;
  long local_90;
  int local_70;
  int local_6c;
  long local_58;
  long local_50;
  long local_48;
  ulong local_40;
  long local_38;
  void *local_30;
  size_t local_28;
  ulong local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if ((*(uint *)(param_1 + 0x68) & 2) == 0) {
    iVar3 = 8;
  }
  else {
    iVar3 = *(int *)(*(long *)(param_1 + 0x198) + 0x10);
  }
  local_38 = param_1 + 0x248;
  local_30 = param_2;
  local_28 = param_3;
  if (((((*(uint *)(param_1 + 0x68) & 1) != 0) && ((*(uint *)(param_1 + 0x68) & 8) == 0)) &&
      (local_6c = _libssh2_kex_exchange(param_1,1,param_1 + 0xccd0), local_6c != 0)) ||
     ((local_6c = send_existing(param_1,param_2,param_3,&local_58), local_6c != 0 ||
      (*(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) & 0xfffffffd, local_58 != 0))))
  goto LAB_0013f723;
  uVar2 = *(int *)(param_1 + 0x68) >> 1 & 1;
  if (((*(long *)(param_1 + 0x1c0) == 0) || (*(int *)(*(long *)(param_1 + 0x1c0) + 8) == 0)) ||
     (((*(uint *)(param_1 + 0x68) & 4) == 0 && (*(int *)(*(long *)(param_1 + 0x1c0) + 0xc) == 0))))
  {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if ((uVar2 == 0) || (!bVar1)) {
    if (0x87b7 < param_5 + param_3) {
      local_6c = -0x22;
      goto LAB_0013f723;
    }
    memcpy((void *)(local_38 + 0x4045),param_2,param_3);
    if ((param_4 != (void *)0x0) && (param_5 != 0)) {
      memcpy((void *)(param_3 + 0x4045 + local_38),param_4,param_5);
    }
    local_90 = param_3 + param_5;
  }
  else {
    local_50 = 0x87b3;
    local_48 = 0x87b3;
    local_6c = (**(code **)(*(long *)(param_1 + 0x1c0) + 0x18))
                         (param_1,local_38 + 0x4045,&local_50,param_2,param_3,param_1 + 0x1c8);
    if (local_6c != 0) goto LAB_0013f723;
    if ((param_4 == (void *)0x0) || (param_5 == 0)) {
      local_48 = 0;
    }
    else {
      local_48 = local_48 - local_50;
      local_6c = (**(code **)(*(long *)(param_1 + 0x1c0) + 0x18))
                           (param_1,local_50 + 0x4045 + local_38,&local_48,param_4,param_5,
                            param_1 + 0x1c8);
    }
    if (local_6c != 0) goto LAB_0013f723;
    local_90 = local_48 + local_50;
  }
  local_70 = iVar3 - (int)((local_90 + 5U) % (ulong)(long)iVar3);
  if (local_70 < 4) {
    local_70 = local_70 + iVar3;
  }
  local_20 = local_90 + 5U + (long)local_70;
  if (uVar2 == 0) {
    iVar3 = 0;
  }
  else {
    iVar3 = *(int *)(*(long *)(param_1 + 0x1a8) + 8);
  }
  iVar3 = (int)local_20 + iVar3;
  _libssh2_htonu32(local_38 + 0x4040,(int)local_20 + -4);
  *(char *)(local_38 + 0x4044) = (char)local_70;
  RAND_bytes((uchar *)(local_38 + local_90 + 0x4045),local_70);
  if (uVar2 != 0) {
    (**(code **)(*(long *)(param_1 + 0x1a8) + 0x18))
              (param_1,local_38 + 0x4040 + local_20,*(undefined4 *)(param_1 + 0x1b0),
               local_38 + 0x4040,local_20 & 0xffffffff,0,0,param_1 + 0x1b8);
    for (local_40 = 0; local_40 < local_20;
        local_40 = local_40 + (long)*(int *)(*(long *)(param_1 + 0x198) + 0x10)) {
      local_18 = local_38 + local_40 + 0x4040;
      iVar4 = (**(code **)(*(long *)(param_1 + 0x198) + 0x30))
                        (param_1,local_18,(long)*(int *)(*(long *)(param_1 + 0x198) + 0x10),
                         param_1 + 0x1a0);
      if (iVar4 != 0) {
        local_6c = -0x2c;
        goto LAB_0013f723;
      }
    }
  }
  *(int *)(param_1 + 0x1b0) = *(int *)(param_1 + 0x1b0) + 1;
  if (*(int *)(param_1 + 0x6c) == 0) {
    uVar6 = 0x4000;
  }
  else {
    uVar6 = 0;
  }
  local_58 = (**(code **)(param_1 + 0x48))
                       (*(undefined4 *)(param_1 + 0x228),local_38 + 0x4040,(long)iVar3,uVar6,param_1
                       );
  if (iVar3 == local_58) {
    *(undefined8 *)(local_38 + 0xc900) = 0;
    *(undefined8 *)(local_38 + 0xc908) = 0;
    local_6c = 0;
  }
  else if ((local_58 < 0) && (local_58 != -0xb)) {
    local_6c = -7;
  }
  else {
    *(uint *)(param_1 + 0x230) = *(uint *)(param_1 + 0x230) | 2;
    *(void **)(local_38 + 0xc900) = local_30;
    *(size_t *)(local_38 + 0xc908) = local_28;
    lVar5 = local_58;
    if (local_58 < 0) {
      lVar5 = 0;
    }
    *(long *)(local_38 + 0xc910) = lVar5;
    *(int *)(local_38 + 0xc8f8) = iVar3;
    local_6c = -0x25;
  }
LAB_0013f723:
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_6c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 userauth_list(long param_1,undefined8 param_2,int param_3)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  undefined *local_20;
  ulong local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd098) == 0) {
    memset((void *)(param_1 + 0xd0b0),0,8);
    *(ulong *)(param_1 + 0xd0a8) = (ulong)(param_3 + 0x1b);
    uVar4 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_1 + 0xd0a8),param_1);
    *(undefined8 *)(param_1 + 0xd0a0) = uVar4;
    puVar1 = *(undefined **)(param_1 + 0xd0a0);
    if (*(long *)(param_1 + 0xd0a0) == 0) {
      local_20 = puVar1;
      _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for userauth_list");
      uVar4 = 0;
      goto LAB_0013faf5;
    }
    local_20 = puVar1 + 1;
    *puVar1 = 0x32;
    _libssh2_store_str(&local_20,param_2,param_3);
    _libssh2_store_str(&local_20,"ssh-connection",0xe);
    _libssh2_store_u32(&local_20,4);
    *(undefined4 *)(param_1 + 0xd098) = 2;
  }
  if (*(int *)(param_1 + 0xd098) == 2) {
    iVar2 = _libssh2_transport_send
                      (param_1,*(undefined8 *)(param_1 + 0xd0a0),*(undefined8 *)(param_1 + 0xd0a8),
                       &DAT_00149263,4);
    if (iVar2 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block requesting userauth list");
      uVar4 = 0;
      goto LAB_0013faf5;
    }
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0a0),param_1);
    *(undefined8 *)(param_1 + 0xd0a0) = 0;
    if (iVar2 != 0) {
      _libssh2_error(param_1,0xfffffff9,"Unable to send userauth-none request");
      *(undefined4 *)(param_1 + 0xd098) = 0;
      uVar4 = 0;
      goto LAB_0013faf5;
    }
    *(undefined4 *)(param_1 + 0xd098) = 3;
  }
  if (*(int *)(param_1 + 0xd098) == 3) {
    iVar2 = _libssh2_packet_requirev
                      (param_1,&reply_codes_20210,param_1 + 0xd0a0,param_1 + 0xd0a8,0,0,0,
                       param_1 + 0xd0b0);
    if (iVar2 == -0x25) {
      _libssh2_error(param_1,0xffffffdb,"Would block requesting userauth list");
      uVar4 = 0;
      goto LAB_0013faf5;
    }
    if (iVar2 != 0) {
      _libssh2_error(param_1,iVar2,"Failed getting response");
      *(undefined4 *)(param_1 + 0xd098) = 0;
      uVar4 = 0;
      goto LAB_0013faf5;
    }
    if (**(char **)(param_1 + 0xd0a0) == '4') {
      _libssh2_error(param_1,0,"No error");
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0a0),param_1);
      *(undefined8 *)(param_1 + 0xd0a0) = 0;
      *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 4;
      *(undefined4 *)(param_1 + 0xd098) = 0;
      uVar4 = 0;
      goto LAB_0013faf5;
    }
    uVar3 = _libssh2_ntohu32(*(long *)(param_1 + 0xd0a0) + 1);
    local_18 = (ulong)uVar3;
    memmove(*(void **)(param_1 + 0xd0a0),(void *)(*(long *)(param_1 + 0xd0a0) + 5),local_18);
    *(undefined *)(local_18 + *(long *)(param_1 + 0xd0a0)) = 0;
  }
  *(undefined4 *)(param_1 + 0xd098) = 0;
  uVar4 = *(undefined8 *)(param_1 + 0xd0a0);
LAB_0013faf5:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



long libssh2_userauth_list(long param_1,undefined8 param_2,undefined4 param_3)

{
  int iVar1;
  time_t tVar2;
  long lVar3;
  
  tVar2 = time((time_t *)0x0);
  do {
    lVar3 = userauth_list(param_1,param_2,param_3);
    if (*(int *)(param_1 + 0x94) == 0) {
      return lVar3;
    }
    if (lVar3 != 0) {
      return lVar3;
    }
    iVar1 = libssh2_session_last_errno(param_1);
    if (iVar1 != -0x25) {
      return 0;
    }
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
  } while (iVar1 == 0);
  return 0;
}



uint libssh2_userauth_authenticated(long param_1)

{
  return *(int *)(param_1 + 0x68) >> 2 & 1;
}



undefined8
userauth_password(long param_1,undefined8 param_2,int param_3,undefined8 param_4,int param_5,
                 code *param_6)

{
  undefined *puVar1;
  int iVar2;
  undefined8 uVar3;
  long in_FS_OFFSET;
  undefined *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd0b8) == 0) {
    memset((void *)(param_1 + 0xd0e8),0,8);
    *(ulong *)(param_1 + 0xd0d0) = (ulong)(param_3 + 0x28);
    *(undefined *)(param_1 + 0xd0c8) = 0xc3;
    uVar3 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_1 + 0xd0d0),param_1);
    *(undefined8 *)(param_1 + 0xd0c0) = uVar3;
    puVar1 = *(undefined **)(param_1 + 0xd0c0);
    if (*(long *)(param_1 + 0xd0c0) == 0) {
      local_18 = puVar1;
      uVar3 = _libssh2_error(param_1,0xfffffffa,
                             "Unable to allocate memory for userauth-password request");
      goto LAB_0014038a;
    }
    local_18 = puVar1 + 1;
    *puVar1 = 0x32;
    _libssh2_store_str(&local_18,param_2,param_3);
    _libssh2_store_str(&local_18,"ssh-connection",0xe);
    _libssh2_store_str(&local_18,"password",8);
    *local_18 = 0;
    local_18 = local_18 + 1;
    _libssh2_store_u32(&local_18,param_5);
    *(undefined4 *)(param_1 + 0xd0b8) = 2;
  }
  if (*(int *)(param_1 + 0xd0b8) != 2) {
LAB_0013fde9:
    do {
      if (((*(int *)(param_1 + 0xd0b8) != 3) && (*(int *)(param_1 + 0xd0b8) != 4)) &&
         (*(int *)(param_1 + 0xd0b8) != 5)) {
LAB_00140336:
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0c0),param_1);
        *(undefined8 *)(param_1 + 0xd0c0) = 0;
        *(undefined4 *)(param_1 + 0xd0b8) = 0;
        uVar3 = _libssh2_error(param_1,0xffffffee,"Authentication failed");
        goto LAB_0014038a;
      }
      if (*(int *)(param_1 + 0xd0b8) == 3) {
        iVar2 = _libssh2_packet_requirev
                          (param_1,&reply_codes_20240,param_1 + 0xd0c0,param_1 + 0xd0d0,0,0,0,
                           param_1 + 0xd0e8);
        if (iVar2 != 0) {
          if (iVar2 != -0x25) {
            *(undefined4 *)(param_1 + 0xd0b8) = 0;
          }
          uVar3 = _libssh2_error(param_1,iVar2,"Waiting for password response");
          goto LAB_0014038a;
        }
        if (**(char **)(param_1 + 0xd0c0) == '4') {
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0c0),param_1);
          *(undefined8 *)(param_1 + 0xd0c0) = 0;
          *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 4;
          *(undefined4 *)(param_1 + 0xd0b8) = 0;
          uVar3 = 0;
          goto LAB_0014038a;
        }
        if (**(char **)(param_1 + 0xd0c0) == '3') {
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0c0),param_1);
          *(undefined8 *)(param_1 + 0xd0c0) = 0;
          *(undefined4 *)(param_1 + 0xd0b8) = 0;
          uVar3 = _libssh2_error(param_1,0xffffffee,"Authentication failed (username/password)");
          goto LAB_0014038a;
        }
        *(undefined8 *)(param_1 + 0xd0d8) = 0;
        *(undefined4 *)(param_1 + 0xd0e0) = 0;
        *(undefined4 *)(param_1 + 0xd0b8) = 4;
      }
      if ((**(char **)(param_1 + 0xd0c0) != '<') && (*(char *)(param_1 + 0xd0c8) != '<'))
      goto LAB_00140336;
      *(undefined *)(param_1 + 0xd0c8) = 0x3c;
      if ((*(int *)(param_1 + 0xd0b8) != 4) && (*(int *)(param_1 + 0xd0b8) != 5)) {
        *(undefined4 *)(param_1 + 0xd0b8) = 0;
        uVar3 = _libssh2_error(param_1,0xfffffff1,"Password Expired, and no callback specified");
        goto LAB_0014038a;
      }
      if (*(int *)(param_1 + 0xd0b8) == 4) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0c0),param_1);
        *(undefined8 *)(param_1 + 0xd0c0) = 0;
      }
      if (param_6 == (code *)0x0) goto LAB_00140336;
      if (*(int *)(param_1 + 0xd0b8) == 4) {
        (*param_6)(param_1,param_1 + 0xd0d8,param_1 + 0xd0e0,param_1);
        if (*(long *)(param_1 + 0xd0d8) == 0) {
          uVar3 = _libssh2_error(param_1,0xfffffff1,"Password expired, and callback failed");
          goto LAB_0014038a;
        }
        *(ulong *)(param_1 + 0xd0d0) = (ulong)(param_5 + param_3 + 0x2c);
        uVar3 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_1 + 0xd0d0),param_1);
        *(undefined8 *)(param_1 + 0xd0c0) = uVar3;
        puVar1 = *(undefined **)(param_1 + 0xd0c0);
        if (*(long *)(param_1 + 0xd0c0) == 0) {
          local_18 = puVar1;
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0d8),param_1);
          *(undefined8 *)(param_1 + 0xd0d8) = 0;
          uVar3 = _libssh2_error(param_1,0xfffffffa,
                                 "Unable to allocate memory for userauth password change request");
          goto LAB_0014038a;
        }
        local_18 = puVar1 + 1;
        *puVar1 = 0x32;
        _libssh2_store_str(&local_18,param_2,param_3);
        _libssh2_store_str(&local_18,"ssh-connection",0xe);
        _libssh2_store_str(&local_18,"password",8);
        *local_18 = 1;
        local_18 = local_18 + 1;
        _libssh2_store_str(&local_18,param_4,param_5);
        _libssh2_store_u32(&local_18,*(undefined4 *)(param_1 + 0xd0e0));
        *(undefined4 *)(param_1 + 0xd0b8) = 5;
      }
      if (*(int *)(param_1 + 0xd0b8) != 5) goto LAB_00140336;
      iVar2 = _libssh2_transport_send
                        (param_1,*(undefined8 *)(param_1 + 0xd0c0),*(undefined8 *)(param_1 + 0xd0d0)
                         ,*(undefined8 *)(param_1 + 0xd0d8),(long)*(int *)(param_1 + 0xd0e0));
      if (iVar2 == -0x25) {
        uVar3 = _libssh2_error(param_1,0xffffffdb,"Would block waiting");
        goto LAB_0014038a;
      }
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0c0),param_1);
      *(undefined8 *)(param_1 + 0xd0c0) = 0;
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0d8),param_1);
      *(undefined8 *)(param_1 + 0xd0d8) = 0;
      if (iVar2 != 0) goto code_r0x001402dd;
      *(undefined4 *)(param_1 + 0xd0b8) = 3;
    } while( true );
  }
  iVar2 = _libssh2_transport_send
                    (param_1,*(undefined8 *)(param_1 + 0xd0c0),*(undefined8 *)(param_1 + 0xd0d0),
                     param_4,param_5);
  if (iVar2 == -0x25) {
    uVar3 = _libssh2_error(param_1,0xffffffdb,"Would block writing password request");
  }
  else {
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0c0),param_1);
    *(undefined8 *)(param_1 + 0xd0c0) = 0;
    if (iVar2 == 0) {
      *(undefined4 *)(param_1 + 0xd0b8) = 3;
      goto LAB_0013fde9;
    }
    *(undefined4 *)(param_1 + 0xd0b8) = 0;
    uVar3 = _libssh2_error(param_1,0xfffffff9,"Unable to send userauth-password request");
  }
  goto LAB_0014038a;
code_r0x001402dd:
  uVar3 = _libssh2_error(param_1,0xfffffff9,"Unable to send userauth password-change request");
LAB_0014038a:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



int libssh2_userauth_password_ex
              (long param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,
              undefined4 param_5,undefined8 param_6)

{
  int iVar1;
  time_t tVar2;
  
  tVar2 = time((time_t *)0x0);
  while( true ) {
    iVar1 = userauth_password(param_1,param_2,param_3,param_4,param_5,param_6);
    if (iVar1 != -0x25) {
      return iVar1;
    }
    if (*(int *)(param_1 + 0x94) == 0) break;
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
    if (iVar1 != 0) {
      return iVar1;
    }
  }
  return -0x25;
}



undefined8
memory_read_publickey
          (long param_1,undefined8 *param_2,long *param_3,undefined8 *param_4,ulong *param_5,
          void *param_6,ulong param_7)

{
  int iVar1;
  undefined8 uVar2;
  ushort **ppuVar3;
  long in_FS_OFFSET;
  uint local_3c;
  undefined8 local_38;
  void *local_30;
  ulong local_28;
  void *local_20;
  void *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_20 = (void *)0x0;
  local_28 = param_7;
  if (param_7 < 2) {
    uVar2 = _libssh2_error(param_1,0xfffffff0,"Invalid data in public key file");
  }
  else {
    local_20 = (void *)(**(code **)(param_1 + 8))(param_7,param_1);
    if (local_20 == (void *)0x0) {
      uVar2 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for public key data");
    }
    else {
      memcpy(local_20,param_6,param_7);
      for (; local_28 != 0; local_28 = local_28 - 1) {
        ppuVar3 = __ctype_b_loc();
        if (((*ppuVar3)[*(byte *)((long)local_20 + (local_28 - 1))] & 0x2000) == 0) break;
      }
      if (local_28 == 0) {
        (**(code **)(param_1 + 0x18))(local_20,param_1);
        uVar2 = _libssh2_error(param_1,0xfffffff0,"Missing public key data");
      }
      else {
        local_18 = memchr(local_20,0x20,local_28);
        if (local_18 == (void *)0x0) {
          (**(code **)(param_1 + 0x18))(local_20,param_1);
          uVar2 = _libssh2_error(param_1,0xfffffff0,"Invalid public key data");
        }
        else {
          local_18 = (void *)((long)local_18 + 1);
          local_30 = memchr(local_18,0x20,local_28 - ((long)local_18 - (long)local_20));
          if (local_30 == (void *)0x0) {
            local_30 = (void *)(local_28 + (long)local_20);
          }
          iVar1 = libssh2_base64_decode
                            (param_1,&local_38,&local_3c,local_18,(int)local_30 - (int)local_18);
          if (iVar1 == 0) {
            *param_2 = local_20;
            *param_3 = (long)local_18 + (-1 - (long)local_20);
            *param_4 = local_38;
            *param_5 = (ulong)local_3c;
            uVar2 = 0;
          }
          else {
            (**(code **)(param_1 + 0x18))(local_20,param_1);
            uVar2 = _libssh2_error(param_1,0xfffffff0,"Invalid key data, not base64 encoded");
          }
        }
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
file_read_publickey(long param_1,undefined8 *param_2,long *param_3,undefined8 *param_4,
                   ulong *param_5,char *param_6)

{
  int iVar1;
  undefined8 uVar2;
  size_t sVar3;
  ushort **ppuVar4;
  long in_FS_OFFSET;
  char local_4d;
  uint local_4c;
  undefined8 local_48;
  void *local_40;
  size_t local_38;
  void *local_30;
  FILE *local_28;
  void *local_20;
  long local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = (void *)0x0;
  local_38 = 0;
  local_28 = fopen(param_6,"r");
  if (local_28 == (FILE *)0x0) {
    uVar2 = _libssh2_error(param_1,0xfffffff0,"Unable to open public key file");
  }
  else {
    while( true ) {
      iVar1 = feof(local_28);
      if (iVar1 != 0) break;
      sVar3 = fread(&local_4d,1,1,local_28);
      if (((sVar3 != 1) || (local_4d == '\r')) || (local_4d == '\n')) break;
      local_38 = local_38 + 1;
    }
    rewind(local_28);
    if (local_38 < 2) {
      fclose(local_28);
      uVar2 = _libssh2_error(param_1,0xfffffff0,"Invalid data in public key file");
    }
    else {
      local_30 = (void *)(**(code **)(param_1 + 8))(local_38,param_1);
      if (local_30 == (void *)0x0) {
        fclose(local_28);
        uVar2 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for public key data");
      }
      else {
        sVar3 = fread(local_30,1,local_38,local_28);
        if (local_38 == sVar3) {
          fclose(local_28);
          for (; local_38 != 0; local_38 = local_38 - 1) {
            ppuVar4 = __ctype_b_loc();
            if (((*ppuVar4)[*(byte *)((long)local_30 + (local_38 - 1))] & 0x2000) == 0) break;
          }
          if (local_38 == 0) {
            (**(code **)(param_1 + 0x18))(local_30,param_1);
            uVar2 = _libssh2_error(param_1,0xfffffff0,"Missing public key data");
          }
          else {
            local_20 = memchr(local_30,0x20,local_38);
            if (local_20 == (void *)0x0) {
              (**(code **)(param_1 + 0x18))(local_30,param_1);
              uVar2 = _libssh2_error(param_1,0xfffffff0,"Invalid public key data");
            }
            else {
              local_20 = (void *)((long)local_20 + 1);
              if (local_30 < local_20) {
                local_18 = (long)local_20 + (-1 - (long)local_30);
              }
              else {
                local_18 = 0;
              }
              local_40 = memchr(local_20,0x20,local_38 - local_18);
              if (local_40 == (void *)0x0) {
                local_40 = (void *)(local_38 + (long)local_30);
              }
              iVar1 = libssh2_base64_decode
                                (param_1,&local_48,&local_4c,local_20,(int)local_40 - (int)local_20)
              ;
              if (iVar1 == 0) {
                *param_2 = local_30;
                *param_3 = (long)local_20 + (-1 - (long)local_30);
                *param_4 = local_48;
                *param_5 = (ulong)local_4c;
                uVar2 = 0;
              }
              else {
                (**(code **)(param_1 + 0x18))(local_30,param_1);
                uVar2 = _libssh2_error(param_1,0xfffffff0,"Invalid key data, not base64 encoded");
              }
            }
          }
        }
        else {
          (**(code **)(param_1 + 0x18))(local_30,param_1);
          fclose(local_28);
          uVar2 = _libssh2_error(param_1,0xfffffff0,"Unable to read public key from file");
        }
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar2;
}



undefined8
memory_read_privatekey
          (undefined8 param_1,long *param_2,undefined8 *param_3,char *param_4,int param_5,
          undefined8 param_6,undefined8 param_7,undefined8 param_8)

{
  int iVar1;
  undefined8 uVar2;
  long *local_10;
  
  local_10 = (long *)libssh2_hostkey_methods();
  *param_2 = 0;
  *param_3 = 0;
  do {
    if ((*local_10 == 0) || (*(long *)*local_10 == 0)) goto LAB_00140ae9;
    if (*(long *)(*local_10 + 0x20) != 0) {
      iVar1 = strncmp(*(char **)*local_10,param_4,(long)param_5);
      if (iVar1 == 0) {
        *param_2 = *local_10;
LAB_00140ae9:
        if (*param_2 == 0) {
          uVar2 = _libssh2_error(param_1,0xffffffef,"No handler for specified private key");
        }
        else {
          iVar1 = (**(code **)(*param_2 + 0x20))(param_1,param_6,param_7,param_8,param_3);
          if (iVar1 == 0) {
            uVar2 = 0;
          }
          else {
            uVar2 = _libssh2_error(param_1,0xfffffff0,"Unable to initialize private key from file");
          }
        }
        return uVar2;
      }
    }
    local_10 = local_10 + 1;
  } while( true );
}



undefined8
file_read_privatekey
          (undefined8 param_1,long *param_2,undefined8 *param_3,char *param_4,int param_5,
          undefined8 param_6,undefined8 param_7)

{
  int iVar1;
  undefined8 uVar2;
  long *local_10;
  
  local_10 = (long *)libssh2_hostkey_methods();
  *param_2 = 0;
  *param_3 = 0;
  do {
    if ((*local_10 == 0) || (*(long *)*local_10 == 0)) goto LAB_00140c07;
    if (*(long *)(*local_10 + 0x18) != 0) {
      iVar1 = strncmp(*(char **)*local_10,param_4,(long)param_5);
      if (iVar1 == 0) {
        *param_2 = *local_10;
LAB_00140c07:
        if (*param_2 == 0) {
          uVar2 = _libssh2_error(param_1,0xffffffef,"No handler for specified private key");
        }
        else {
          iVar1 = (**(code **)(*param_2 + 0x18))(param_1,param_6,param_7,param_3);
          if (iVar1 == 0) {
            uVar2 = 0;
          }
          else {
            uVar2 = _libssh2_error(param_1,0xfffffff0,"Unable to initialize private key from file");
          }
        }
        return uVar2;
      }
    }
    local_10 = local_10 + 1;
  } while( true );
}



int sign_frommemory(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                   undefined8 param_5,long *param_6)

{
  undefined8 uVar1;
  int iVar2;
  size_t sVar3;
  long in_FS_OFFSET;
  long local_50;
  undefined local_48 [8];
  undefined8 *local_40;
  undefined8 local_38;
  undefined8 local_30;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = (undefined8 *)*param_6;
  uVar1 = local_40[1];
  sVar3 = strlen((char *)*local_40);
  iVar2 = memory_read_privatekey
                    (param_1,&local_50,local_48,*(undefined8 *)(param_1 + 0xd160),
                     *(ulong *)(param_1 + 0xd168) & 0xffffffff,*local_40,sVar3,uVar1);
  if (iVar2 == 0) {
    local_38 = param_4;
    local_30 = param_5;
    iVar2 = (**(code **)(local_50 + 0x30))(param_1,param_2,param_3,1,&local_38,local_48);
    if (iVar2 == 0) {
      if (*(long *)(local_50 + 0x40) != 0) {
        (**(code **)(local_50 + 0x40))(param_1,local_48);
      }
      iVar2 = 0;
    }
    else {
      if (*(long *)(local_50 + 0x40) != 0) {
        (**(code **)(local_50 + 0x40))(param_1,local_48);
      }
      iVar2 = -1;
    }
  }
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int sign_fromfile(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                 undefined8 param_5,long *param_6)

{
  int iVar1;
  long in_FS_OFFSET;
  long local_40;
  undefined local_38 [8];
  undefined8 *local_30;
  undefined8 local_28;
  undefined8 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_30 = (undefined8 *)*param_6;
  iVar1 = file_read_privatekey
                    (param_1,&local_40,local_38,*(undefined8 *)(param_1 + 0xd160),
                     *(ulong *)(param_1 + 0xd168) & 0xffffffff,*local_30,local_30[1]);
  if (iVar1 == 0) {
    local_28 = param_4;
    local_20 = param_5;
    iVar1 = (**(code **)(local_40 + 0x30))(param_1,param_2,param_3,1,&local_28,local_38);
    if (iVar1 == 0) {
      if (*(long *)(local_40 + 0x40) != 0) {
        (**(code **)(local_40 + 0x40))(param_1,local_38);
      }
      iVar1 = 0;
    }
    else {
      if (*(long *)(local_40 + 0x40) != 0) {
        (**(code **)(local_40 + 0x40))(param_1,local_38);
      }
      iVar1 = -1;
    }
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return iVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ulong userauth_hostbased_fromfile
                (long param_1,undefined8 param_2,long param_3,long param_4,undefined8 param_5,
                undefined8 param_6,undefined8 param_7,long param_8,undefined8 param_9,long param_10)

{
  undefined *puVar1;
  uint uVar2;
  int iVar3;
  undefined8 uVar4;
  ulong uVar5;
  long in_FS_OFFSET;
  long local_90;
  undefined8 local_88;
  undefined8 local_80;
  ulong local_78;
  ulong local_70;
  undefined local_68 [8];
  long local_60;
  undefined *local_58;
  undefined8 local_50;
  undefined8 local_48;
  ulong local_40;
  undefined8 local_38;
  undefined8 local_30;
  undefined local_15 [5];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd0f0) == 0) {
    local_80 = 0;
    local_78 = 0;
    local_70 = 0;
    memset((void *)(param_1 + 0xd130),0,8);
    if (param_4 == 0) {
      uVar2 = _libssh2_pub_priv_keyfile
                        (param_1,param_1 + 0xd118,param_1 + 0xd120,&local_88,&local_78,param_5,
                         param_6);
      if (uVar2 != 0) {
        uVar5 = (ulong)uVar2;
        goto LAB_00141b3d;
      }
    }
    else {
      uVar2 = file_read_publickey(param_1,param_1 + 0xd118,param_1 + 0xd120,&local_88,&local_78,
                                  param_4);
      if (uVar2 != 0) {
        uVar5 = (ulong)uVar2;
        goto LAB_00141b3d;
      }
    }
    *(ulong *)(param_1 + 0xd110) =
         local_78 + *(long *)(param_1 + 0xd120) + param_3 + param_8 + param_10 + 0x34;
    uVar4 = (**(code **)(param_1 + 8))
                      (local_78 + *(long *)(param_1 + 0xd110) + *(long *)(param_1 + 0xd120) + 0xc,
                       param_1);
    *(undefined8 *)(param_1 + 0xd108) = uVar4;
    *(undefined8 *)(param_1 + 0xd128) = *(undefined8 *)(param_1 + 0xd108);
    if (*(long *)(param_1 + 0xd108) == 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd118),param_1);
      *(undefined8 *)(param_1 + 0xd118) = 0;
      (**(code **)(param_1 + 0x18))(local_88,param_1);
      uVar5 = _libssh2_error(param_1,0xfffffffa,"Out of memory");
      goto LAB_00141b3d;
    }
    puVar1 = *(undefined **)(param_1 + 0xd128);
    *(undefined **)(param_1 + 0xd128) = puVar1 + 1;
    *puVar1 = 0x32;
    _libssh2_store_str(param_1 + 0xd128,param_2,param_3);
    _libssh2_store_str(param_1 + 0xd128,"ssh-connection",0xe);
    _libssh2_store_str(param_1 + 0xd128,"hostbased",9);
    _libssh2_store_str(param_1 + 0xd128,*(undefined8 *)(param_1 + 0xd118),
                       *(undefined8 *)(param_1 + 0xd120));
    _libssh2_store_str(param_1 + 0xd128,local_88,local_78);
    (**(code **)(param_1 + 0x18))(local_88,param_1);
    _libssh2_store_str(param_1 + 0xd128,param_7,param_8);
    _libssh2_store_str(param_1 + 0xd128,param_9,param_10);
    uVar2 = file_read_privatekey
                      (param_1,&local_90,local_68,*(undefined8 *)(param_1 + 0xd118),
                       *(ulong *)(param_1 + 0xd120) & 0xffffffff,param_5,param_6);
    if (uVar2 != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd118),param_1);
      *(undefined8 *)(param_1 + 0xd118) = 0;
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd108),param_1);
      *(undefined8 *)(param_1 + 0xd108) = 0;
      uVar5 = (ulong)uVar2;
      goto LAB_00141b3d;
    }
    _libssh2_htonu32(local_15,*(undefined4 *)(param_1 + 0x90));
    local_58 = local_15;
    local_50 = 4;
    local_48 = *(undefined8 *)(param_1 + 0x88);
    local_40 = (ulong)*(uint *)(param_1 + 0x90);
    local_38 = *(undefined8 *)(param_1 + 0xd108);
    local_30 = *(undefined8 *)(param_1 + 0xd110);
    if ((local_90 != 0) && (*(long *)(local_90 + 0x30) != 0)) {
      iVar3 = (**(code **)(local_90 + 0x30))(param_1,&local_80,&local_70,3,&local_58,local_68);
      if (iVar3 != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd118),param_1);
        *(undefined8 *)(param_1 + 0xd118) = 0;
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd108),param_1);
        *(undefined8 *)(param_1 + 0xd108) = 0;
        if (*(long *)(local_90 + 0x40) != 0) {
          (**(code **)(local_90 + 0x40))(param_1,local_68);
        }
        uVar5 = 0xffffffff;
        goto LAB_00141b3d;
      }
    }
    if ((local_90 != 0) && (*(long *)(local_90 + 0x40) != 0)) {
      (**(code **)(local_90 + 0x40))(param_1,local_68);
    }
    if (local_78 < local_70) {
      if (*(long *)(param_1 + 0xd108) == 0) {
        local_60 = (**(code **)(param_1 + 8))
                             (local_70 + *(long *)(param_1 + 0xd110) + *(long *)(param_1 + 0xd120) +
                              0xc,param_1);
      }
      else {
        local_60 = (**(code **)(param_1 + 0x10))
                             (*(undefined8 *)(param_1 + 0xd108),
                              local_70 + *(long *)(param_1 + 0xd110) + *(long *)(param_1 + 0xd120) +
                              0xc,param_1);
      }
      if (local_60 == 0) {
        (**(code **)(param_1 + 0x18))(local_80,param_1);
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd108),param_1);
        *(undefined8 *)(param_1 + 0xd108) = 0;
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd118),param_1);
        *(undefined8 *)(param_1 + 0xd118) = 0;
        uVar5 = _libssh2_error(param_1,0xfffffffa,
                               "Failed allocating additional space for userauth-hostbased packet");
        goto LAB_00141b3d;
      }
      *(long *)(param_1 + 0xd108) = local_60;
    }
    *(long *)(param_1 + 0xd128) = *(long *)(param_1 + 0xd108) + *(long *)(param_1 + 0xd110);
    _libssh2_store_u32(param_1 + 0xd128,(int)local_70 + (int)*(undefined8 *)(param_1 + 0xd120) + 8);
    _libssh2_store_str(param_1 + 0xd128,*(undefined8 *)(param_1 + 0xd118),
                       *(undefined8 *)(param_1 + 0xd120));
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd118),param_1);
    *(undefined8 *)(param_1 + 0xd118) = 0;
    _libssh2_store_str(param_1 + 0xd128,local_80,local_70);
    (**(code **)(param_1 + 0x18))(local_80,param_1);
    *(undefined4 *)(param_1 + 0xd0f0) = 2;
  }
  if (*(int *)(param_1 + 0xd0f0) == 2) {
    iVar3 = _libssh2_transport_send
                      (param_1,*(undefined8 *)(param_1 + 0xd108),
                       *(long *)(param_1 + 0xd128) - *(long *)(param_1 + 0xd108),0,0);
    if (iVar3 == -0x25) {
      uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block");
      goto LAB_00141b3d;
    }
    if (iVar3 != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd108),param_1);
      *(undefined8 *)(param_1 + 0xd108) = 0;
      *(undefined4 *)(param_1 + 0xd0f0) = 0;
      uVar5 = _libssh2_error(param_1,0xfffffff9,"Unable to send userauth-hostbased request");
      goto LAB_00141b3d;
    }
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd108),param_1);
    *(undefined8 *)(param_1 + 0xd108) = 0;
    *(undefined4 *)(param_1 + 0xd0f0) = 3;
  }
  if (*(int *)(param_1 + 0xd0f0) == 3) {
    iVar3 = _libssh2_packet_requirev
                      (param_1,&reply_codes_20378,param_1 + 0xd0f8,local_68,0,0,0,param_1 + 0xd130);
    if (iVar3 == -0x25) {
      uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block");
      goto LAB_00141b3d;
    }
    *(undefined4 *)(param_1 + 0xd0f0) = 0;
    if (iVar3 != 0) {
      uVar5 = _libssh2_error(param_1,0xffffffed,"Auth failed");
      goto LAB_00141b3d;
    }
    if (**(char **)(param_1 + 0xd0f8) == '4') {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0f8),param_1);
      *(undefined8 *)(param_1 + 0xd0f8) = 0;
      *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 4;
      uVar5 = 0;
      goto LAB_00141b3d;
    }
  }
  (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd0f8),param_1);
  *(undefined8 *)(param_1 + 0xd0f8) = 0;
  uVar5 = _libssh2_error(param_1,0xffffffed,
                         "Invalid signature for supplied public key, or bad username/public key combination"
                        );
LAB_00141b3d:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



int libssh2_userauth_hostbased_fromfile_ex
              (long param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,
              undefined8 param_5,undefined8 param_6,undefined8 param_7,undefined4 param_8,
              undefined8 param_9,undefined4 param_10)

{
  int iVar1;
  time_t tVar2;
  
  tVar2 = time((time_t *)0x0);
  while( true ) {
    iVar1 = userauth_hostbased_fromfile
                      (param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9,
                       param_10);
    if (iVar1 != -0x25) {
      return iVar1;
    }
    if (*(int *)(param_1 + 0x94) == 0) break;
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
    if (iVar1 != 0) {
      return iVar1;
    }
  }
  return -0x25;
}



undefined8
_libssh2_userauth_publickey
          (long param_1,undefined8 param_2,uint param_3,long param_4,ulong param_5,code *param_6,
          undefined8 param_7)

{
  ulong uVar1;
  undefined *puVar2;
  uint uVar3;
  int iVar4;
  undefined8 uVar5;
  long in_FS_OFFSET;
  undefined *local_50;
  undefined8 local_48;
  ulong local_40;
  undefined *local_38;
  long local_30;
  uint3 local_24;
  undefined uStack_21;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  _local_24 = 0x3c3334;
  if (*(int *)(param_1 + 0xd138) == 0) {
    if (param_5 < 4) {
      uVar5 = _libssh2_error(param_1,0xffffffed,"Invalid public key, too short");
      goto LAB_001429af;
    }
    memset((void *)(param_1 + 0xd180),0,8);
    if (*(long *)(param_1 + 0xd160) == 0) {
      uVar3 = _libssh2_ntohu32(param_4);
      *(ulong *)(param_1 + 0xd168) = (ulong)uVar3;
      if (param_5 < *(ulong *)(param_1 + 0xd168)) {
        uVar5 = _libssh2_error(param_1,0xffffffed,"Invalid public key");
        goto LAB_001429af;
      }
      uVar5 = (**(code **)(param_1 + 8))(*(undefined8 *)(param_1 + 0xd168),param_1);
      *(undefined8 *)(param_1 + 0xd160) = uVar5;
      if (*(long *)(param_1 + 0xd160) == 0) {
        uVar5 = _libssh2_error(param_1,0xfffffffa,"Unable to allocate memory for public key data");
        goto LAB_001429af;
      }
      memcpy(*(void **)(param_1 + 0xd160),(void *)(param_4 + 4),*(size_t *)(param_1 + 0xd168));
    }
    else {
      uVar1 = *(ulong *)(param_1 + 0xd168);
      uVar3 = _libssh2_ntohu32(param_4);
      if (uVar1 != uVar3) {
        uVar5 = _libssh2_error(param_1,0xffffffed,"Invalid public key");
        goto LAB_001429af;
      }
    }
    *(ulong *)(param_1 + 0xd158) = param_5 + (ulong)param_3 + *(long *)(param_1 + 0xd168) + 0x2d;
    uVar5 = (**(code **)(param_1 + 8))
                      (param_5 + *(long *)(param_1 + 0xd158) + *(long *)(param_1 + 0xd168) + 0xc,
                       param_1);
    *(undefined8 *)(param_1 + 0xd150) = uVar5;
    puVar2 = *(undefined **)(param_1 + 0xd150);
    if (*(long *)(param_1 + 0xd150) == 0) {
      local_50 = puVar2;
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd160),param_1);
      *(undefined8 *)(param_1 + 0xd160) = 0;
      uVar5 = _libssh2_error(param_1,0xfffffffa,"Out of memory");
      goto LAB_001429af;
    }
    local_50 = puVar2 + 1;
    *puVar2 = 0x32;
    _libssh2_store_str(&local_50,param_2,param_3);
    _libssh2_store_str(&local_50,"ssh-connection",0xe);
    _libssh2_store_str(&local_50,"publickey",9);
    *(undefined **)(param_1 + 0xd178) = local_50;
    *local_50 = 0;
    local_50 = local_50 + 1;
    _libssh2_store_str(&local_50,*(undefined8 *)(param_1 + 0xd160),*(undefined8 *)(param_1 + 0xd168)
                      );
    _libssh2_store_str(&local_50,param_4,param_5);
    *(undefined4 *)(param_1 + 0xd138) = 2;
  }
  if (*(int *)(param_1 + 0xd138) == 2) {
    iVar4 = _libssh2_transport_send
                      (param_1,*(undefined8 *)(param_1 + 0xd150),*(undefined8 *)(param_1 + 0xd158),0
                       ,0);
    if (iVar4 == -0x25) {
      uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block");
      goto LAB_001429af;
    }
    if (iVar4 != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd150),param_1);
      *(undefined8 *)(param_1 + 0xd150) = 0;
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd160),param_1);
      *(undefined8 *)(param_1 + 0xd160) = 0;
      *(undefined4 *)(param_1 + 0xd138) = 0;
      uVar5 = _libssh2_error(param_1,0xfffffff9,"Unable to send userauth-publickey request");
      goto LAB_001429af;
    }
    *(undefined4 *)(param_1 + 0xd138) = 3;
  }
  if (*(int *)(param_1 + 0xd138) == 3) {
    iVar4 = _libssh2_packet_requirev
                      (param_1,&local_24,param_1 + 0xd140,param_1 + 0xd148,0,0,0,param_1 + 0xd180);
    if (iVar4 == -0x25) {
      uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block");
      goto LAB_001429af;
    }
    if (iVar4 != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd150),param_1);
      *(undefined8 *)(param_1 + 0xd150) = 0;
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd160),param_1);
      *(undefined8 *)(param_1 + 0xd160) = 0;
      *(undefined4 *)(param_1 + 0xd138) = 0;
      uVar5 = _libssh2_error(param_1,0xffffffed,"Waiting for USERAUTH response");
      goto LAB_001429af;
    }
    if (**(char **)(param_1 + 0xd140) == '4') {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd140),param_1);
      *(undefined8 *)(param_1 + 0xd140) = 0;
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd150),param_1);
      *(undefined8 *)(param_1 + 0xd150) = 0;
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd160),param_1);
      *(undefined8 *)(param_1 + 0xd160) = 0;
      *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 4;
      *(undefined4 *)(param_1 + 0xd138) = 0;
      uVar5 = 0;
      goto LAB_001429af;
    }
    if (**(char **)(param_1 + 0xd140) == '3') {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd140),param_1);
      *(undefined8 *)(param_1 + 0xd140) = 0;
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd150),param_1);
      *(undefined8 *)(param_1 + 0xd150) = 0;
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd160),param_1);
      *(undefined8 *)(param_1 + 0xd160) = 0;
      *(undefined4 *)(param_1 + 0xd138) = 0;
      uVar5 = _libssh2_error(param_1,0xffffffee,"Username/PublicKey combination invalid");
      goto LAB_001429af;
    }
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd140),param_1);
    *(undefined8 *)(param_1 + 0xd140) = 0;
    **(undefined **)(param_1 + 0xd178) = 1;
    *(undefined4 *)(param_1 + 0xd138) = 4;
  }
  if (*(int *)(param_1 + 0xd138) == 4) {
    local_50 = (undefined *)
               (**(code **)(param_1 + 8))
                         (*(long *)(param_1 + 0xd158) + (ulong)(*(int *)(param_1 + 0x90) + 4),
                          param_1);
    local_38 = local_50;
    if (local_50 == (undefined *)0x0) {
      uVar5 = _libssh2_error(param_1,0xfffffffa,
                             "Unable to allocate memory for userauth-publickey signed data");
      goto LAB_001429af;
    }
    _libssh2_store_str(&local_50,*(undefined8 *)(param_1 + 0x88),*(undefined4 *)(param_1 + 0x90));
    memcpy(local_50,*(void **)(param_1 + 0xd150),*(size_t *)(param_1 + 0xd158));
    local_50 = local_50 + *(long *)(param_1 + 0xd158);
    iVar4 = (*param_6)(param_1,&local_48,&local_40,local_38,(long)local_50 - (long)local_38,param_7)
    ;
    (**(code **)(param_1 + 0x18))(local_38,param_1);
    if (iVar4 == -0x25) {
      uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block");
      goto LAB_001429af;
    }
    if (iVar4 != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd160),param_1);
      *(undefined8 *)(param_1 + 0xd160) = 0;
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd150),param_1);
      *(undefined8 *)(param_1 + 0xd150) = 0;
      *(undefined4 *)(param_1 + 0xd138) = 0;
      uVar5 = _libssh2_error(param_1,0xffffffed,"Callback returned error");
      goto LAB_001429af;
    }
    if (param_5 < local_40) {
      if (*(long *)(param_1 + 0xd150) == 0) {
        local_30 = (**(code **)(param_1 + 8))
                             (local_40 + *(long *)(param_1 + 0xd158) + *(long *)(param_1 + 0xd168) +
                              0xc,param_1);
      }
      else {
        local_30 = (**(code **)(param_1 + 0x10))
                             (*(undefined8 *)(param_1 + 0xd150),
                              local_40 + *(long *)(param_1 + 0xd158) + *(long *)(param_1 + 0xd168) +
                              0xc,param_1);
      }
      if (local_30 == 0) {
        (**(code **)(param_1 + 0x18))(local_48,param_1);
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd150),param_1);
        *(undefined8 *)(param_1 + 0xd150) = 0;
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd160),param_1);
        *(undefined8 *)(param_1 + 0xd160) = 0;
        *(undefined4 *)(param_1 + 0xd138) = 0;
        uVar5 = _libssh2_error(param_1,0xfffffffa,
                               "Failed allocating additional space for userauth-publickey packet");
        goto LAB_001429af;
      }
      *(long *)(param_1 + 0xd150) = local_30;
    }
    local_50 = (undefined *)(*(long *)(param_1 + 0xd158) + *(long *)(param_1 + 0xd150));
    *(undefined8 *)(param_1 + 0xd178) = 0;
    _libssh2_store_u32(&local_50,(int)local_40 + (int)*(undefined8 *)(param_1 + 0xd168) + 8);
    _libssh2_store_str(&local_50,*(undefined8 *)(param_1 + 0xd160),*(undefined8 *)(param_1 + 0xd168)
                      );
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd160),param_1);
    *(undefined8 *)(param_1 + 0xd160) = 0;
    _libssh2_store_str(&local_50,local_48,local_40);
    (**(code **)(param_1 + 0x18))(local_48,param_1);
    *(undefined **)(param_1 + 0xd170) = local_50;
    *(undefined4 *)(param_1 + 0xd138) = 5;
  }
  if (*(int *)(param_1 + 0xd138) == 5) {
    iVar4 = _libssh2_transport_send
                      (param_1,*(undefined8 *)(param_1 + 0xd150),
                       *(long *)(param_1 + 0xd170) - *(long *)(param_1 + 0xd150),0,0);
    if (iVar4 == -0x25) {
      uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block");
      goto LAB_001429af;
    }
    if (iVar4 != 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd150),param_1);
      *(undefined8 *)(param_1 + 0xd150) = 0;
      *(undefined4 *)(param_1 + 0xd138) = 0;
      uVar5 = _libssh2_error(param_1,0xfffffff9,"Unable to send userauth-publickey request");
      goto LAB_001429af;
    }
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd150),param_1);
    *(undefined8 *)(param_1 + 0xd150) = 0;
    *(undefined4 *)(param_1 + 0xd138) = 6;
  }
  local_24 = (uint3)(ushort)local_24;
  iVar4 = _libssh2_packet_requirev
                    (param_1,&local_24,param_1 + 0xd140,param_1 + 0xd148,0,0,0,param_1 + 0xd180);
  if (iVar4 == -0x25) {
    uVar5 = _libssh2_error(param_1,0xffffffdb,"Would block requesting userauth list");
  }
  else if (iVar4 == 0) {
    if (**(char **)(param_1 + 0xd140) == '4') {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd140),param_1);
      *(undefined8 *)(param_1 + 0xd140) = 0;
      *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 4;
      *(undefined4 *)(param_1 + 0xd138) = 0;
      uVar5 = 0;
    }
    else {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd140),param_1);
      *(undefined8 *)(param_1 + 0xd140) = 0;
      *(undefined4 *)(param_1 + 0xd138) = 0;
      uVar5 = _libssh2_error(param_1,0xffffffed,
                             "Invalid signature for supplied public key, or bad username/public key combination"
                            );
    }
  }
  else {
    *(undefined4 *)(param_1 + 0xd138) = 0;
    uVar5 = _libssh2_error(param_1,0xffffffed,"Waiting for publickey USERAUTH response");
  }
LAB_001429af:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar5;
}



ulong userauth_publickey_frommemory
                (long param_1,undefined8 param_2,undefined4 param_3,long param_4,long param_5,
                long param_6,long param_7,undefined8 param_8)

{
  uint uVar1;
  int iVar2;
  ulong uVar3;
  long in_FS_OFFSET;
  long local_40;
  undefined8 local_38;
  long *local_30;
  long local_28;
  undefined8 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = 0;
  local_38 = 0;
  local_30 = &local_28;
  local_20 = param_8;
  local_28 = param_6;
  if (*(int *)(param_1 + 0xd138) == 0) {
    if ((param_5 == 0) || (param_4 == 0)) {
      if ((param_7 == 0) || (param_6 == 0)) {
        uVar3 = _libssh2_error(param_1,0xfffffff0,"Invalid data in public and private key.");
        goto LAB_00142b93;
      }
      iVar2 = _libssh2_pub_priv_keyfilememory
                        (param_1,param_1 + 0xd160,param_1 + 0xd168,&local_40,&local_38,param_6,
                         param_7,param_8);
      if (iVar2 != 0) {
        uVar3 = _libssh2_error(param_1,0xfffffff0,"Unable to extract public key from private key.");
        goto LAB_00142b93;
      }
    }
    else {
      uVar1 = memory_read_publickey
                        (param_1,param_1 + 0xd160,param_1 + 0xd168,&local_40,&local_38,param_4,
                         param_5);
      if (uVar1 != 0) {
        uVar3 = (ulong)uVar1;
        goto LAB_00142b93;
      }
    }
  }
  uVar1 = _libssh2_userauth_publickey
                    (param_1,param_2,param_3,local_40,local_38,sign_frommemory,&local_30);
  if (local_40 != 0) {
    (**(code **)(param_1 + 0x18))(local_40,param_1);
  }
  uVar3 = (ulong)uVar1;
LAB_00142b93:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar3;
}



int userauth_publickey_fromfile
              (long param_1,undefined8 param_2,undefined4 param_3,long param_4,undefined8 param_5,
              undefined8 param_6)

{
  int iVar1;
  long in_FS_OFFSET;
  long local_40;
  undefined8 local_38;
  undefined8 *local_30;
  undefined8 local_28;
  undefined8 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_40 = 0;
  local_38 = 0;
  local_30 = &local_28;
  local_28 = param_5;
  local_20 = param_6;
  if (*(int *)(param_1 + 0xd138) == 0) {
    if (param_4 == 0) {
      iVar1 = _libssh2_pub_priv_keyfile
                        (param_1,param_1 + 0xd160,param_1 + 0xd168,&local_40,&local_38,param_5,
                         param_6);
    }
    else {
      iVar1 = file_read_publickey(param_1,param_1 + 0xd160,param_1 + 0xd168,&local_40,&local_38,
                                  param_4);
    }
    if (iVar1 != 0) goto LAB_00142d1e;
  }
  iVar1 = _libssh2_userauth_publickey
                    (param_1,param_2,param_3,local_40,local_38,sign_fromfile,&local_30);
  if (local_40 != 0) {
    (**(code **)(param_1 + 0x18))(local_40,param_1);
  }
LAB_00142d1e:
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar1;
}



int libssh2_userauth_publickey_frommemory
              (long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
              undefined8 param_5,undefined8 param_6,undefined8 param_7,undefined *param_8)

{
  int iVar1;
  time_t tVar2;
  
  if (param_8 == (undefined *)0x0) {
    param_8 = &DAT_001498c0;
  }
  tVar2 = time((time_t *)0x0);
  while( true ) {
    iVar1 = userauth_publickey_frommemory
                      (param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
    if (iVar1 != -0x25) {
      return iVar1;
    }
    if (*(int *)(param_1 + 0x94) == 0) break;
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
    if (iVar1 != 0) {
      return iVar1;
    }
  }
  return -0x25;
}



int libssh2_userauth_publickey_fromfile_ex
              (long param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,
              undefined8 param_5,undefined *param_6)

{
  int iVar1;
  time_t tVar2;
  undefined *local_48;
  
  local_48 = param_6;
  if (param_6 == (undefined *)0x0) {
    local_48 = &DAT_001498c0;
  }
  tVar2 = time((time_t *)0x0);
  while( true ) {
    iVar1 = userauth_publickey_fromfile(param_1,param_2,param_3,param_4,param_5,local_48);
    if (iVar1 != -0x25) {
      return iVar1;
    }
    if (*(int *)(param_1 + 0x94) == 0) break;
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
    if (iVar1 != 0) {
      return iVar1;
    }
  }
  return -0x25;
}



int libssh2_userauth_publickey
              (long param_1,char *param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5,
              undefined8 param_6)

{
  int iVar1;
  time_t tVar2;
  size_t sVar3;
  
  if (param_1 == 0) {
    iVar1 = -0x27;
  }
  else {
    tVar2 = time((time_t *)0x0);
    do {
      sVar3 = strlen(param_2);
      iVar1 = _libssh2_userauth_publickey
                        (param_1,param_2,sVar3 & 0xffffffff,param_3,param_4,param_5,param_6);
      if (iVar1 != -0x25) {
        return iVar1;
      }
      if (*(int *)(param_1 + 0x94) == 0) {
        return -0x25;
      }
      iVar1 = _libssh2_wait_socket(param_1,tVar2);
    } while (iVar1 == 0);
  }
  return iVar1;
}



undefined8 userauth_keyboard_interactive(long param_1,undefined8 param_2,int param_3,code *param_4)

{
  long lVar1;
  int iVar2;
  undefined4 uVar3;
  uint uVar4;
  undefined *puVar5;
  undefined8 uVar6;
  long in_FS_OFFSET;
  uint local_34;
  undefined *local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(int *)(param_1 + 0xd188) == 0) {
    *(undefined8 *)(param_1 + 0xd1b8) = 0;
    *(undefined8 *)(param_1 + 0xd1c8) = 0;
    *(undefined4 *)(param_1 + 0xd1d0) = 0;
    *(undefined4 *)(param_1 + 0xd1d4) = 1;
    *(undefined8 *)(param_1 + 0xd1d8) = 0;
    *(undefined8 *)(param_1 + 0xd1e0) = 0;
    memset((void *)(param_1 + 0xd1e8),0,8);
    *(ulong *)(param_1 + 0xd1a8) = (ulong)(param_3 + 0x37);
    puVar5 = (undefined *)(**(code **)(param_1 + 8))(*(undefined8 *)(param_1 + 0xd1a8),param_1);
    *(undefined **)(param_1 + 0xd190) = puVar5;
    if (puVar5 == (undefined *)0x0) {
      local_28 = puVar5;
      uVar6 = _libssh2_error(param_1,0xfffffffa,
                             "Unable to allocate memory for keyboard-interactive authentication");
      goto LAB_00143c36;
    }
    local_28 = puVar5 + 1;
    *puVar5 = 0x32;
    _libssh2_store_str(&local_28,param_2,param_3);
    _libssh2_store_str(&local_28,"ssh-connection",0xe);
    _libssh2_store_str(&local_28,"keyboard-interactive",0x14);
    _libssh2_store_u32(&local_28,0);
    _libssh2_store_u32(&local_28,0);
    *(undefined4 *)(param_1 + 0xd188) = 2;
  }
  if (*(int *)(param_1 + 0xd188) != 2) {
LAB_001431df:
    do {
      if (*(int *)(param_1 + 0xd188) == 3) {
        iVar2 = _libssh2_packet_requirev
                          (param_1,&reply_codes_20506,param_1 + 0xd190,param_1 + 0xd198,0,0,0,
                           param_1 + 0xd1e8);
        if (iVar2 == -0x25) {
          uVar6 = _libssh2_error(param_1,0xffffffdb,"Would block");
          goto LAB_00143c36;
        }
        if (iVar2 != 0) {
          *(undefined4 *)(param_1 + 0xd188) = 0;
          uVar6 = _libssh2_error(param_1,0xffffffee,"Waiting for keyboard USERAUTH response");
          goto LAB_00143c36;
        }
        if (**(char **)(param_1 + 0xd190) == '4') {
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd190),param_1);
          *(undefined8 *)(param_1 + 0xd190) = 0;
          *(uint *)(param_1 + 0x68) = *(uint *)(param_1 + 0x68) | 4;
          *(undefined4 *)(param_1 + 0xd188) = 0;
          uVar6 = 0;
          goto LAB_00143c36;
        }
        if (**(char **)(param_1 + 0xd190) == '3') {
          (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd190),param_1);
          *(undefined8 *)(param_1 + 0xd190) = 0;
          *(undefined4 *)(param_1 + 0xd188) = 0;
          uVar6 = _libssh2_error(param_1,0xffffffee,"Authentication failed (keyboard-interactive)");
          goto LAB_00143c36;
        }
        local_28 = (undefined *)(*(long *)(param_1 + 0xd190) + 1);
        uVar3 = _libssh2_ntohu32(local_28);
        *(undefined4 *)(param_1 + 0xd1b0) = uVar3;
        local_28 = local_28 + 4;
        if (*(int *)(param_1 + 0xd1b0) == 0) {
LAB_00143442:
          uVar3 = _libssh2_ntohu32(local_28);
          *(undefined4 *)(param_1 + 0xd1c0) = uVar3;
          local_28 = local_28 + 4;
          if (*(int *)(param_1 + 0xd1c0) != 0) {
            uVar6 = (**(code **)(param_1 + 8))(*(undefined4 *)(param_1 + 0xd1c0),param_1);
            *(undefined8 *)(param_1 + 0xd1c8) = uVar6;
            if (*(long *)(param_1 + 0xd1c8) == 0) {
              _libssh2_error(param_1,0xfffffffa,
                             "Unable to allocate memory for keyboard-interactive \'instruction\' request field"
                            );
              goto LAB_001439f2;
            }
            memcpy(*(void **)(param_1 + 0xd1c8),local_28,(ulong)*(uint *)(param_1 + 0xd1c0));
            local_28 = local_28 + *(uint *)(param_1 + 0xd1c0);
          }
          uVar4 = _libssh2_ntohu32(local_28);
          local_28 = local_28 + (ulong)uVar4 + 4;
          uVar3 = _libssh2_ntohu32(local_28);
          *(undefined4 *)(param_1 + 0xd1d0) = uVar3;
          local_28 = local_28 + 4;
          if (*(int *)(param_1 + 0xd1d0) == 0) {
LAB_0014377c:
            (*param_4)(*(undefined8 *)(param_1 + 0xd1b8),*(undefined4 *)(param_1 + 0xd1b0),
                       *(undefined8 *)(param_1 + 0xd1c8),*(undefined4 *)(param_1 + 0xd1c0),
                       *(undefined4 *)(param_1 + 0xd1d0),*(undefined8 *)(param_1 + 0xd1d8),
                       *(undefined8 *)(param_1 + 0xd1e0),param_1);
            *(undefined8 *)(param_1 + 0xd1a8) = 5;
            for (local_34 = 0; local_34 < *(uint *)(param_1 + 0xd1d0); local_34 = local_34 + 1) {
              *(ulong *)(param_1 + 0xd1a8) =
                   *(long *)(param_1 + 0xd1a8) +
                   (ulong)(*(int *)(*(long *)(param_1 + 0xd1e0) + (ulong)local_34 * 0x10 + 8) + 4);
            }
            (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd190),param_1);
            local_28 = (undefined *)
                       (**(code **)(param_1 + 8))(*(undefined8 *)(param_1 + 0xd1a8),param_1);
            *(undefined **)(param_1 + 0xd190) = local_28;
            if (local_28 != (undefined *)0x0) {
              *local_28 = 0x3d;
              local_28 = local_28 + 1;
              _libssh2_store_u32(&local_28,*(undefined4 *)(param_1 + 0xd1d0));
              for (local_34 = 0; local_34 < *(uint *)(param_1 + 0xd1d0); local_34 = local_34 + 1) {
                _libssh2_store_str(&local_28,
                                   *(undefined8 *)
                                    (*(long *)(param_1 + 0xd1e0) + (ulong)local_34 * 0x10),
                                   *(undefined4 *)
                                    (*(long *)(param_1 + 0xd1e0) + (ulong)local_34 * 0x10 + 8));
              }
              *(undefined4 *)(param_1 + 0xd188) = 4;
              goto LAB_0014395b;
            }
            _libssh2_error(param_1,0xfffffffa,
                           "Unable to allocate memory for keyboard-interactive response packet");
          }
          else {
            uVar6 = _libssh2_calloc(param_1,(ulong)*(uint *)(param_1 + 0xd1d0) << 4);
            *(undefined8 *)(param_1 + 0xd1d8) = uVar6;
            if (*(long *)(param_1 + 0xd1d8) == 0) {
              _libssh2_error(param_1,0xfffffffa,
                             "Unable to allocate memory for keyboard-interactive prompts array");
            }
            else {
              uVar6 = _libssh2_calloc(param_1,(ulong)*(uint *)(param_1 + 0xd1d0) << 4);
              *(undefined8 *)(param_1 + 0xd1e0) = uVar6;
              if (*(long *)(param_1 + 0xd1e0) != 0) {
                for (local_34 = 0; local_34 < *(uint *)(param_1 + 0xd1d0); local_34 = local_34 + 1)
                {
                  lVar1 = *(long *)(param_1 + 0xd1d8);
                  uVar3 = _libssh2_ntohu32(local_28);
                  *(undefined4 *)(lVar1 + (ulong)local_34 * 0x10 + 8) = uVar3;
                  local_28 = local_28 + 4;
                  lVar1 = *(long *)(param_1 + 0xd1d8);
                  uVar6 = _libssh2_calloc(param_1,*(undefined4 *)
                                                   (*(long *)(param_1 + 0xd1d8) +
                                                    (ulong)local_34 * 0x10 + 8));
                  *(undefined8 *)(lVar1 + (ulong)local_34 * 0x10) = uVar6;
                  if (*(long *)(*(long *)(param_1 + 0xd1d8) + (ulong)local_34 * 0x10) == 0) {
                    _libssh2_error(param_1,0xfffffffa,
                                   "Unable to allocate memory for keyboard-interactive prompt message"
                                  );
                    goto LAB_001439f2;
                  }
                  memcpy(*(void **)(*(long *)(param_1 + 0xd1d8) + (ulong)local_34 * 0x10),local_28,
                         (ulong)*(uint *)(*(long *)(param_1 + 0xd1d8) + (ulong)local_34 * 0x10 + 8))
                  ;
                  puVar5 = local_28 +
                           *(uint *)(*(long *)(param_1 + 0xd1d8) + (ulong)local_34 * 0x10 + 8);
                  local_28 = puVar5 + 1;
                  *(undefined *)(*(long *)(param_1 + 0xd1d8) + (ulong)local_34 * 0x10 + 0xc) =
                       *puVar5;
                }
                goto LAB_0014377c;
              }
              _libssh2_error(param_1,0xfffffffa,
                             "Unable to allocate memory for keyboard-interactive responses array");
            }
          }
        }
        else {
          uVar6 = (**(code **)(param_1 + 8))(*(undefined4 *)(param_1 + 0xd1b0),param_1);
          *(undefined8 *)(param_1 + 0xd1b8) = uVar6;
          if (*(long *)(param_1 + 0xd1b8) != 0) {
            memcpy(*(void **)(param_1 + 0xd1b8),local_28,(ulong)*(uint *)(param_1 + 0xd1b0));
            local_28 = local_28 + *(uint *)(param_1 + 0xd1b0);
            goto LAB_00143442;
          }
          _libssh2_error(param_1,0xfffffffa,
                         "Unable to allocate memory for keyboard-interactive \'name\' request field"
                        );
        }
      }
      else {
LAB_0014395b:
        if (*(int *)(param_1 + 0xd188) == 4) {
          iVar2 = _libssh2_transport_send
                            (param_1,*(undefined8 *)(param_1 + 0xd190),
                             *(undefined8 *)(param_1 + 0xd1a8),0,0);
          if (iVar2 == -0x25) {
            uVar6 = _libssh2_error(param_1,0xffffffdb,"Would block");
            goto LAB_00143c36;
          }
          if (iVar2 == 0) {
            *(undefined4 *)(param_1 + 0xd1d4) = 0;
          }
          else {
            _libssh2_error(param_1,0xfffffff9,"Unable to send userauth-keyboard-interactive request"
                          );
          }
        }
      }
LAB_001439f2:
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd190),param_1);
      *(undefined8 *)(param_1 + 0xd190) = 0;
      if (*(long *)(param_1 + 0xd1d8) != 0) {
        for (local_34 = 0; local_34 < *(uint *)(param_1 + 0xd1d0); local_34 = local_34 + 1) {
          (**(code **)(param_1 + 0x18))
                    (*(undefined8 *)(*(long *)(param_1 + 0xd1d8) + (ulong)local_34 * 0x10),param_1);
          *(undefined8 *)(*(long *)(param_1 + 0xd1d8) + (ulong)local_34 * 0x10) = 0;
        }
      }
      if (*(long *)(param_1 + 0xd1e0) != 0) {
        for (local_34 = 0; local_34 < *(uint *)(param_1 + 0xd1d0); local_34 = local_34 + 1) {
          (**(code **)(param_1 + 0x18))
                    (*(undefined8 *)(*(long *)(param_1 + 0xd1e0) + (ulong)local_34 * 0x10),param_1);
          *(undefined8 *)(*(long *)(param_1 + 0xd1e0) + (ulong)local_34 * 0x10) = 0;
        }
      }
      if (*(long *)(param_1 + 0xd1d8) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd1d8),param_1);
        *(undefined8 *)(param_1 + 0xd1d8) = 0;
      }
      if (*(long *)(param_1 + 0xd1e0) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd1e0),param_1);
        *(undefined8 *)(param_1 + 0xd1e0) = 0;
      }
      if (*(long *)(param_1 + 0xd1b8) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd1b8),param_1);
        *(undefined8 *)(param_1 + 0xd1b8) = 0;
      }
      if (*(long *)(param_1 + 0xd1c8) != 0) {
        (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd1c8),param_1);
        *(undefined8 *)(param_1 + 0xd1c8) = 0;
      }
      if (*(int *)(param_1 + 0xd1d4) != 0) goto code_r0x00143c0e;
      *(undefined4 *)(param_1 + 0xd188) = 3;
    } while( true );
  }
  iVar2 = _libssh2_transport_send
                    (param_1,*(undefined8 *)(param_1 + 0xd190),*(undefined8 *)(param_1 + 0xd1a8),0,0
                    );
  if (iVar2 == -0x25) {
    uVar6 = _libssh2_error(param_1,0xffffffdb,"Would block");
  }
  else {
    if (iVar2 == 0) {
      (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd190),param_1);
      *(undefined8 *)(param_1 + 0xd190) = 0;
      *(undefined4 *)(param_1 + 0xd188) = 3;
      goto LAB_001431df;
    }
    (**(code **)(param_1 + 0x18))(*(undefined8 *)(param_1 + 0xd190),param_1);
    *(undefined8 *)(param_1 + 0xd190) = 0;
    *(undefined4 *)(param_1 + 0xd188) = 0;
    uVar6 = _libssh2_error(param_1,0xfffffff9,"Unable to send keyboard-interactive request");
  }
  goto LAB_00143c36;
code_r0x00143c0e:
  *(undefined4 *)(param_1 + 0xd188) = 0;
  uVar6 = 0xffffffff;
LAB_00143c36:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar6;
}



int libssh2_userauth_keyboard_interactive_ex
              (long param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4)

{
  int iVar1;
  time_t tVar2;
  
  tVar2 = time((time_t *)0x0);
  while( true ) {
    iVar1 = userauth_keyboard_interactive(param_1,param_2,param_3,param_4);
    if (iVar1 != -0x25) {
      return iVar1;
    }
    if (*(int *)(param_1 + 0x94) == 0) break;
    iVar1 = _libssh2_wait_socket(param_1,tVar2);
    if (iVar1 != 0) {
      return iVar1;
    }
  }
  return -0x25;
}



char * libssh2_version(int param_1)

{
  char *pcVar1;
  
  if (param_1 < 0x10901) {
    pcVar1 = "1.9.0_DEV";
  }
  else {
    pcVar1 = (char *)0x0;
  }
  return pcVar1;
}



void _fini(void)

{
  return;
}



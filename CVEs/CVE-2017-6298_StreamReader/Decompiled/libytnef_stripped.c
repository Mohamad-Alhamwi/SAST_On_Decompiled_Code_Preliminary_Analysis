typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned char    dwfenc;
typedef unsigned int    dword;
typedef unsigned long    qword;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined4;
typedef unsigned long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef struct eh_frame_hdr eh_frame_hdr, *Peh_frame_hdr;

struct eh_frame_hdr {
    byte eh_frame_hdr_version; // Exception Handler Frame Header Version
    dwfenc eh_frame_pointer_encoding; // Exception Handler Frame Pointer Encoding
    dwfenc eh_frame_desc_entry_count_encoding; // Encoding of # of Exception Handler FDEs
    dwfenc eh_frame_table_encoding; // Exception Handler Table Encoding
};

typedef struct NoteGnuPropertyElement_4 NoteGnuPropertyElement_4, *PNoteGnuPropertyElement_4;

struct NoteGnuPropertyElement_4 {
    dword prType;
    dword prDatasz;
    byte data[4];
};

typedef struct fde_table_entry fde_table_entry, *Pfde_table_entry;

struct fde_table_entry {
    dword initial_loc; // Initial Location
    dword data_loc; // Data location
};

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef long __off64_t;

typedef ulong size_t;

struct _IO_FILE {
    int _flags;
    char *_IO_read_ptr;
    char *_IO_read_end;
    char *_IO_read_base;
    char *_IO_write_base;
    char *_IO_write_ptr;
    char *_IO_write_end;
    char *_IO_buf_base;
    char *_IO_buf_end;
    char *_IO_save_base;
    char *_IO_backup_base;
    char *_IO_save_end;
    struct _IO_marker *_markers;
    struct _IO_FILE *_chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t *_lock;
    __off64_t _offset;
    void *__pad1;
    void *__pad2;
    void *__pad3;
    void *__pad4;
    size_t __pad5;
    int _mode;
    char _unused2[20];
};

struct _IO_marker {
    struct _IO_marker *_next;
    struct _IO_FILE *_sbuf;
    int _pos;
};

typedef struct _IO_FILE FILE;

typedef enum Elf_ProgramHeaderType {
    PT_NULL=0,
    PT_LOAD=1,
    PT_DYNAMIC=2,
    PT_INTERP=3,
    PT_NOTE=4,
    PT_SHLIB=5,
    PT_PHDR=6,
    PT_TLS=7,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_STACK=1685382481,
    PT_GNU_RELRO=1685382482
} Elf_ProgramHeaderType;

typedef struct Elf64_Dyn Elf64_Dyn, *PElf64_Dyn;

typedef enum Elf64_DynTag {
    DT_NULL=0,
    DT_NEEDED=1,
    DT_PLTRELSZ=2,
    DT_PLTGOT=3,
    DT_HASH=4,
    DT_STRTAB=5,
    DT_SYMTAB=6,
    DT_RELA=7,
    DT_RELASZ=8,
    DT_RELAENT=9,
    DT_STRSZ=10,
    DT_SYMENT=11,
    DT_INIT=12,
    DT_FINI=13,
    DT_SONAME=14,
    DT_RPATH=15,
    DT_SYMBOLIC=16,
    DT_REL=17,
    DT_RELSZ=18,
    DT_RELENT=19,
    DT_PLTREL=20,
    DT_DEBUG=21,
    DT_TEXTREL=22,
    DT_JMPREL=23,
    DT_BIND_NOW=24,
    DT_INIT_ARRAY=25,
    DT_FINI_ARRAY=26,
    DT_INIT_ARRAYSZ=27,
    DT_FINI_ARRAYSZ=28,
    DT_RUNPATH=29,
    DT_FLAGS=30,
    DT_PREINIT_ARRAY=32,
    DT_PREINIT_ARRAYSZ=33,
    DT_RELRSZ=35,
    DT_RELR=36,
    DT_RELRENT=37,
    DT_ANDROID_REL=1610612751,
    DT_ANDROID_RELSZ=1610612752,
    DT_ANDROID_RELA=1610612753,
    DT_ANDROID_RELASZ=1610612754,
    DT_ANDROID_RELR=1879040000,
    DT_ANDROID_RELRSZ=1879040001,
    DT_ANDROID_RELRENT=1879040003,
    DT_GNU_PRELINKED=1879047669,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_CHECKSUM=1879047672,
    DT_PLTPADSZ=1879047673,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_FEATURE_1=1879047676,
    DT_POSFLAG_1=1879047677,
    DT_SYMINSZ=1879047678,
    DT_SYMINENT=1879047679,
    DT_GNU_XHASH=1879047924,
    DT_GNU_HASH=1879047925,
    DT_TLSDESC_PLT=1879047926,
    DT_TLSDESC_GOT=1879047927,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_LIBLIST=1879047929,
    DT_CONFIG=1879047930,
    DT_DEPAUDIT=1879047931,
    DT_AUDIT=1879047932,
    DT_PLTPAD=1879047933,
    DT_MOVETAB=1879047934,
    DT_SYMINFO=1879047935,
    DT_VERSYM=1879048176,
    DT_RELACOUNT=1879048185,
    DT_RELCOUNT=1879048186,
    DT_FLAGS_1=1879048187,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_AUXILIARY=2147483645,
    DT_FILTER=2147483647
} Elf64_DynTag;

struct Elf64_Dyn {
    enum Elf64_DynTag d_tag;
    qword d_val;
};

typedef struct Elf64_Rela Elf64_Rela, *PElf64_Rela;

struct Elf64_Rela {
    qword r_offset; // location to apply the relocation action
    qword r_info; // the symbol table index and the type of relocation
    qword r_addend; // a constant addend used to compute the relocatable field value
};

typedef struct Elf64_Shdr Elf64_Shdr, *PElf64_Shdr;

typedef enum Elf_SectionHeaderType {
    SHT_NULL=0,
    SHT_PROGBITS=1,
    SHT_SYMTAB=2,
    SHT_STRTAB=3,
    SHT_RELA=4,
    SHT_HASH=5,
    SHT_DYNAMIC=6,
    SHT_NOTE=7,
    SHT_NOBITS=8,
    SHT_REL=9,
    SHT_SHLIB=10,
    SHT_DYNSYM=11,
    SHT_INIT_ARRAY=14,
    SHT_FINI_ARRAY=15,
    SHT_PREINIT_ARRAY=16,
    SHT_GROUP=17,
    SHT_SYMTAB_SHNDX=18,
    SHT_ANDROID_REL=1610612737,
    SHT_ANDROID_RELA=1610612738,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_CHECKSUM=1879048184,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_syminfo=1879048188,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191
} Elf_SectionHeaderType;

struct Elf64_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType sh_type;
    qword sh_flags;
    qword sh_addr;
    qword sh_offset;
    qword sh_size;
    dword sh_link;
    dword sh_info;
    qword sh_addralign;
    qword sh_entsize;
};

typedef struct GnuBuildId GnuBuildId, *PGnuBuildId;

struct GnuBuildId {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
    byte hash[20];
};

typedef struct NoteGnuProperty_4 NoteGnuProperty_4, *PNoteGnuProperty_4;

struct NoteGnuProperty_4 {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
};

typedef struct Elf64_Ehdr Elf64_Ehdr, *PElf64_Ehdr;

struct Elf64_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_osabi;
    byte e_ident_abiversion;
    byte e_ident_pad[7];
    word e_type;
    word e_machine;
    dword e_version;
    qword e_entry;
    qword e_phoff;
    qword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};

typedef struct Elf64_Phdr Elf64_Phdr, *PElf64_Phdr;

struct Elf64_Phdr {
    enum Elf_ProgramHeaderType p_type;
    dword p_flags;
    qword p_offset;
    qword p_vaddr;
    qword p_paddr;
    qword p_filesz;
    qword p_memsz;
    qword p_align;
};

typedef struct Elf64_Sym Elf64_Sym, *PElf64_Sym;

struct Elf64_Sym {
    dword st_name;
    byte st_info;
    byte st_other;
    word st_shndx;
    qword st_value;
    qword st_size;
};




void _DT_INIT(void)

{
  if (true) {
    __gmon_start__();
  }
  return;
}



void FUN_00102020(void)

{
  (*(code *)(undefined *)0x0)();
  return;
}



void FUN_00102250(void)

{
  __cxa_finalize();
  return;
}



undefined8 TNEFRawRead(long param_1,byte *param_2,undefined8 param_3,short *param_4)

{
  byte *pbVar1;
  byte bVar2;
  short sVar3;
  uint uVar4;
  uint uVar5;
  undefined8 uVar6;
  
  uVar4 = (**(code **)(param_1 + 0x298))(param_1 + 0x290,1,param_3,param_2);
  uVar5 = (uint)param_3;
  if (uVar4 < uVar5) {
    uVar6 = 0xfffffffd;
    if (0 < *(int *)(param_1 + 0x28c)) {
      puts("ERROR: Error reading data");
    }
  }
  else {
    if ((param_4 != (short *)0x0) && (*param_4 = 0, uVar5 != 0)) {
      pbVar1 = param_2 + (ulong)(uVar5 - 1) + 1;
      sVar3 = 0;
      do {
        bVar2 = *param_2;
        param_2 = param_2 + 1;
        sVar3 = sVar3 + (ushort)bVar2;
        *param_4 = sVar3;
      } while (param_2 != pbVar1);
    }
    uVar6 = 0;
  }
  return uVar6;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void free(void *__ptr)

{
  free(__ptr);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int putchar(int __c)

{
  int iVar1;
  
  iVar1 = putchar(__c);
  return iVar1;
}



undefined8 SwapDDWord(long param_1,uint param_2)

{
  long lVar1;
  uint uVar2;
  long in_FS_OFFSET;
  undefined8 uStack_18;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  lVar1 = 0;
  uStack_18 = 0;
  uVar2 = 8;
  if (param_2 < 9) {
    uVar2 = param_2;
  }
  if (param_2 == 0) {
    uStack_18 = 0;
  }
  else {
    do {
      *(undefined *)((long)&uStack_18 + lVar1) = *(undefined *)(param_1 + lVar1);
      lVar1 = lVar1 + 1;
    } while ((int)lVar1 < (int)uVar2);
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uStack_18;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int puts(char *__s)

{
  int iVar1;
  
  iVar1 = puts(__s);
  return iVar1;
}



ushort SwapWord(byte *param_1,int param_2)

{
  ushort uVar1;
  long in_FS_OFFSET;
  
  uVar1 = 0;
  if (param_2 != 0) {
    uVar1 = (ushort)*param_1;
    if (param_2 != 1) {
      uVar1 = CONCAT11(param_1[1],*param_1);
    }
  }
  if (*(long *)(in_FS_OFFSET + 0x28) != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}



void TNEFFillMapi(long param_1,long param_2,uint param_3,uint *param_4)

{
  char cVar1;
  long lVar2;
  undefined2 uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  undefined4 uVar7;
  undefined4 *puVar8;
  void *__dest;
  void *pvVar9;
  undefined8 *puVar10;
  undefined8 uVar11;
  ushort uVar12;
  ulong uVar13;
  long lVar14;
  ulong uVar15;
  undefined8 *puVar16;
  char *pcVar17;
  int iVar18;
  undefined8 *puVar19;
  undefined8 *puVar20;
  long in_FS_OFFSET;
  bool bVar21;
  int iStack_80;
  uint uStack_7c;
  ulong uStack_70;
  undefined2 uStack_4e;
  undefined4 uStack_4c;
  undefined8 uStack_48;
  long lStack_40;
  
  puVar20 = (undefined8 *)(param_2 + 4);
  lStack_40 = *(long *)(in_FS_OFFSET + 0x28);
  uVar4 = SwapDWord(param_2,4);
  *param_4 = uVar4;
  puVar8 = (undefined4 *)calloc((ulong)uVar4,0x30);
  *(undefined4 **)(param_4 + 2) = puVar8;
  if (uVar4 == 0) {
    param_2 = 4;
  }
  else {
    uStack_7c = 0;
    iVar18 = -1;
    do {
      if (iVar18 == -1) {
        iVar5 = SwapDWord(puVar20,4);
        *puVar8 = 0;
        puVar8[5] = iVar5;
        *(undefined8 *)(puVar8 + 6) = 1;
        if (iVar5 < 0) {
          uVar11 = *(undefined8 *)((long)puVar20 + 0xc);
          puVar16 = puVar20 + 3;
          *(undefined8 *)(puVar8 + 1) = *(undefined8 *)((long)puVar20 + 4);
          *(undefined8 *)(puVar8 + 3) = uVar11;
          uVar4 = SwapDWord((long)puVar20 + 0x14,4);
          if (uVar4 == 0) {
            uVar3 = SwapDWord(puVar16,4);
            *(undefined2 *)((long)puVar8 + 0x16) = uVar3;
            puVar16 = (undefined8 *)((long)puVar20 + 0x1c);
          }
          else {
            puVar8[7] = uVar4;
            lVar14 = (ulong)(uVar4 - 1) << 4;
            pvVar9 = calloc((ulong)uVar4,0x10);
            *(void **)(puVar8 + 8) = pvVar9;
            do {
              uVar4 = SwapDWord(puVar16,4);
              lVar2 = *(long *)(puVar8 + 8);
              uVar13 = (ulong)uVar4;
              pvVar9 = calloc(uVar13,1);
              *(uint *)((undefined8 *)(lVar2 + lVar14) + 1) = uVar4;
              *(undefined8 *)(lVar2 + lVar14) = pvVar9;
              if (uVar4 >> 1 != 0) {
                uVar15 = 0;
                while( true ) {
                  *(undefined *)((long)pvVar9 + uVar15) =
                       *(undefined *)((long)puVar16 + uVar15 * 2 + 4);
                  if ((uVar4 >> 1) - 1 == uVar15) break;
                  pvVar9 = *(void **)(*(long *)(puVar8 + 8) + lVar14);
                  uVar15 = uVar15 + 1;
                }
              }
              if ((uVar4 & 3) != 0) {
                uVar13 = (ulong)((uVar4 + 4) - (uVar4 & 3));
              }
              lVar14 = lVar14 + -0x10;
              puVar16 = (undefined8 *)((long)puVar16 + uVar13 + 4);
            } while (lVar14 != -0x10);
          }
          *puVar8 = 1;
        }
        else {
          puVar16 = (undefined8 *)((long)puVar20 + 4);
        }
        if (2 < *(int *)(param_1 + 0x28c)) {
          __printf_chk(1,"DEBUG(%i/%i):",3);
          __printf_chk(1,"Type id = %04x, Prop id = %04x",puVar8[5] & 0xffff,(uint)puVar8[5] >> 0x10
                      );
          putchar(10);
        }
        uVar4 = puVar8[5];
        uVar12 = (ushort)uVar4;
        bVar21 = (uVar4 & 0x1000) != 0;
        if (bVar21) {
          iVar18 = 0;
          puVar20 = (undefined8 *)((long)puVar16 + 4);
          puVar8[5] = uVar4 & 0xffff0000 | (uVar4 & 0xffff) - 0x1000;
          uVar6 = SwapDWord(puVar16,4);
          uVar4 = puVar8[5];
          puVar8[6] = uVar6;
          iStack_80 = 0;
          uVar12 = (ushort)uVar4;
        }
        else {
          iStack_80 = -1;
          uVar6 = puVar8[6];
          puVar20 = puVar16;
        }
        bVar21 = !bVar21;
        puVar16 = (undefined8 *)calloc((ulong)uVar6,0x10);
        uStack_7c = uStack_7c + 1;
        *(undefined8 **)(puVar8 + 10) = puVar16;
      }
      else {
        iVar18 = iVar18 + 1;
        uVar4 = puVar8[5];
        bVar21 = false;
        uVar12 = (ushort)uVar4;
        puVar16 = (undefined8 *)((long)iVar18 * 0x10 + *(long *)(puVar8 + 10));
        iStack_80 = iVar18;
      }
      uVar13 = (ulong)uVar4;
      puVar19 = puVar20;
      if (0x48 < uVar12) {
        if (uVar12 == 0x102) {
switchD_0010328e_caseD_d:
          puVar19 = (undefined8 *)((long)puVar20 + 4);
          if (iVar18 == -1) {
            uVar7 = SwapDWord(puVar20,4);
            *(undefined4 *)(puVar16 + 1) = uVar7;
            puVar19 = puVar20 + 1;
            puVar20 = (undefined8 *)((long)puVar20 + 4);
          }
          iVar5 = SwapDWord(puVar20,4);
          *(int *)(puVar16 + 1) = iVar5;
          if (iVar5 == 0) {
            *puVar16 = 0;
            uVar13 = (ulong)(uint)puVar8[5];
            uVar15 = 0;
          }
          else {
            uVar4 = puVar8[5];
            if ((short)uVar4 == 0x1f) {
              uVar11 = to_utf8(iVar5,puVar19);
              uVar4 = puVar8[5];
              *puVar16 = uVar11;
            }
            else {
              pvVar9 = calloc((long)iVar5,1);
              *puVar16 = pvVar9;
              memcpy(pvVar9,puVar19,(long)iVar5);
            }
            uVar13 = (ulong)uVar4;
            uVar4 = *(uint *)(puVar16 + 1);
            uVar15 = (ulong)uVar4;
            if ((uVar4 & 3) != 0) {
              uVar15 = (ulong)((uVar4 + 4) - (uVar4 & 3));
            }
          }
          puVar19 = (undefined8 *)((long)puVar19 + uVar15);
        }
        goto switchD_0010328e_caseD_8;
      }
      if ((uVar12 < 2) || (false)) goto switchD_0010328e_caseD_8;
      switch(uVar12) {
      case 2:
        *(undefined4 *)(puVar16 + 1) = 2;
        pvVar9 = calloc(2,2);
        puVar19 = (undefined8 *)((long)puVar20 + 4);
        *puVar16 = pvVar9;
        uStack_4e = SwapWord(puVar20,2);
        memcpy((void *)*puVar16,&uStack_4e,(long)*(int *)(puVar16 + 1));
        uVar13 = (ulong)(uint)puVar8[5];
        break;
      case 3:
      case 4:
      case 6:
      case 7:
      case 10:
      case 0xb:
        *(undefined4 *)(puVar16 + 1) = 4;
        pvVar9 = calloc(4,1);
        puVar19 = (undefined8 *)((long)puVar20 + 4);
        *puVar16 = pvVar9;
        uStack_4c = SwapDWord(puVar20,4);
        memcpy((void *)*puVar16,&uStack_4c,(long)*(int *)(puVar16 + 1));
        uVar13 = (ulong)(uint)puVar8[5];
        break;
      case 5:
      case 0x14:
      case 0x40:
        *(undefined4 *)(puVar16 + 1) = 8;
        pvVar9 = calloc(8,1);
        *puVar16 = pvVar9;
        uStack_48 = SwapDDWord(puVar20,8);
        memcpy((void *)*puVar16,&uStack_48,(long)*(int *)(puVar16 + 1));
        uVar4 = puVar8[5];
        uVar6 = uVar4 >> 0x10;
        puVar20 = puVar20 + 1;
        goto joined_r0x00103425;
      case 0xd:
      case 0x1e:
      case 0x1f:
        goto switchD_0010328e_caseD_d;
      case 0x48:
        *(undefined4 *)(puVar16 + 1) = 0x10;
        puVar19 = puVar20 + 2;
        puVar10 = (undefined8 *)calloc(0x10,1);
        uVar13 = (ulong)uVar4;
        *puVar16 = puVar10;
        uVar11 = puVar20[1];
        *puVar10 = *puVar20;
        puVar10[1] = uVar11;
      }
switchD_0010328e_caseD_8:
      uVar4 = (uint)uVar13;
      uVar6 = (uint)(uVar13 >> 0x10);
      puVar20 = puVar19;
joined_r0x00103425:
      if (uVar4 < 0x710000) {
        if ((0x36 < uVar6) && ((0x200000000040003U >> ((ulong)(uVar6 - 0x37) & 0x3f) & 1) != 0)) {
LAB_0010343b:
          if (*(int *)(param_1 + 0x28c) < 3) {
            if (*(int *)(param_1 + 0x28) == 0) {
LAB_00103455:
              __dest = calloc((ulong)param_3,1);
              iVar5 = *(int *)(puVar16 + 1);
              *(void **)(param_1 + 0x20) = __dest;
              pvVar9 = (void *)*puVar16;
              *(int *)(param_1 + 0x28) = iVar5;
              pvVar9 = memcpy(__dest,pvVar9,(long)*(int *)(puVar16 + 1));
              if (iVar5 != 0) {
                lVar14 = 0;
                while( true ) {
                  cVar1 = *(char *)((long)pvVar9 + lVar14);
                  if (((cVar1 == '/') || (cVar1 == '\\')) || (cVar1 == '\0')) {
                    *(char *)((long)pvVar9 + lVar14) = '_';
                  }
                  lVar14 = lVar14 + 1;
                  if (*(int *)(param_1 + 0x28) == (int)lVar14) break;
                  pvVar9 = *(void **)(param_1 + 0x20);
                }
              }
            }
          }
          else {
            __printf_chk(1,"DEBUG(%i/%i): %s\n",3,*(int *)(param_1 + 0x28c),"Got a Subject");
            if (*(int *)(param_1 + 0x28) == 0) {
              if (2 < *(int *)(param_1 + 0x28c)) {
                __printf_chk(1,"DEBUG(%i/%i): %s\n",3,*(int *)(param_1 + 0x28c),
                             "Assigning a Subject");
              }
              goto LAB_00103455;
            }
          }
        }
      }
      else if (uVar6 == 0xe1d) goto LAB_0010343b;
      if ((puVar8[6] + -1 == iStack_80) || (bVar21)) {
        puVar8 = puVar8 + 0xc;
        iVar18 = -1;
      }
    } while (uStack_7c < *param_4);
    param_2 = (long)puVar20 - param_2;
  }
  uStack_70 = (ulong)param_3;
  if (param_2 < (long)uStack_70) {
    if (0 < *(int *)(param_1 + 0x28c)) {
      puts("ERROR DURING MAPI READ");
      __printf_chk(1,"Read %td bytes, Expected %u bytes\n",param_2,param_3);
      if (lStack_40 == *(long *)(in_FS_OFFSET + 0x28)) {
        pcVar17 = "%td bytes missing\n";
        param_2 = uStack_70 - param_2;
LAB_00103829:
        __printf_chk(1,pcVar17,param_2);
        return;
      }
      goto LAB_00103943;
    }
  }
  else if (((long)uStack_70 < param_2) && (0 < *(int *)(param_1 + 0x28c))) {
    puts("ERROR DURING MAPI READ");
    __printf_chk(1,"Read %td bytes, Expected %u bytes\n",param_2,param_3);
    if (lStack_40 == *(long *)(in_FS_OFFSET + 0x28)) {
      param_2 = param_2 - uStack_70;
      pcVar17 = "%li bytes extra\n";
      goto LAB_00103829;
    }
    goto LAB_00103943;
  }
  if (lStack_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
LAB_00103943:
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



void TNEFFreeMapiProps(uint *param_1)

{
  long lVar1;
  long lVar2;
  undefined8 *puVar3;
  void *pvVar4;
  long lVar5;
  long lVar6;
  long lVar7;
  
  lVar2 = 0;
  if (*param_1 != 0) {
    do {
      lVar1 = *(long *)(param_1 + 2);
      lVar5 = 0;
      lVar6 = lVar2 * 0x30;
      pvVar4 = *(void **)(lVar1 + lVar6 + 0x28);
      if (*(int *)(lVar1 + lVar6 + 0x18) != 0) {
        do {
          while( true ) {
            lVar7 = lVar5 * 0x10;
            puVar3 = (undefined8 *)((long)pvVar4 + lVar7);
            if (*(int *)(puVar3 + 1) < 1) break;
            lVar5 = lVar5 + 1;
            free((void *)*puVar3);
            lVar1 = *(long *)(param_1 + 2);
            pvVar4 = *(void **)(lVar1 + lVar6 + 0x28);
            *(undefined4 *)((long)pvVar4 + lVar7 + 8) = 0;
            if (*(uint *)(lVar1 + lVar6 + 0x18) <= (uint)lVar5) goto LAB_001047d4;
          }
          lVar5 = lVar5 + 1;
          pvVar4 = *(void **)(lVar1 + lVar6 + 0x28);
        } while ((uint)lVar5 < *(uint *)(lVar1 + lVar6 + 0x18));
      }
LAB_001047d4:
      free(pvVar4);
      lVar1 = *(long *)(param_1 + 2);
      pvVar4 = *(void **)(lVar1 + lVar6 + 0x20);
      if (0 < *(int *)(lVar1 + lVar6 + 0x1c)) {
        lVar5 = 0;
        do {
          while( true ) {
            lVar7 = lVar5 * 0x10;
            puVar3 = (undefined8 *)((long)pvVar4 + lVar7);
            if (*(int *)(puVar3 + 1) < 1) break;
            lVar5 = lVar5 + 1;
            free((void *)*puVar3);
            lVar1 = *(long *)(param_1 + 2);
            pvVar4 = *(void **)(lVar1 + lVar6 + 0x20);
            *(undefined4 *)((long)pvVar4 + lVar7 + 8) = 0;
            if (*(int *)(lVar1 + lVar6 + 0x1c) <= (int)lVar5) goto LAB_00104842;
          }
          lVar5 = lVar5 + 1;
          pvVar4 = *(void **)(lVar1 + lVar6 + 0x20);
        } while ((int)lVar5 < *(int *)(lVar1 + lVar6 + 0x1c));
      }
LAB_00104842:
      free(pvVar4);
      lVar2 = lVar2 + 1;
    } while ((uint)lVar2 < *param_1);
  }
  free(*(void **)(param_1 + 2));
  *param_1 = 0;
  return;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 TNEFGetKey(long param_1,undefined2 *param_2)

{
  undefined2 uVar1;
  int iVar2;
  undefined8 uVar3;
  
  iVar2 = (**(code **)(param_1 + 0x298))(param_1 + 0x290,2,1,param_2);
  if (iVar2 < 1) {
    uVar3 = 0xfffffffd;
    if (0 < *(int *)(param_1 + 0x28c)) {
      puts("Error reading Key");
    }
  }
  else {
    uVar1 = SwapWord(param_2,2);
    iVar2 = *(int *)(param_1 + 0x28c);
    *param_2 = uVar1;
    if (1 < iVar2) {
      __printf_chk(1,"DEBUG(%i/%i):",2);
      __printf_chk(1,"Key = 0x%X",*param_2);
      putchar(10);
      if (1 < *(int *)(param_1 + 0x28c)) {
        __printf_chk(1,"DEBUG(%i/%i):",2);
        __printf_chk(1,"Key = %i",*param_2);
        putchar(10);
      }
    }
    uVar3 = 0;
  }
  return uVar3;
}



void TNEFInitMapi(undefined4 *param_1)

{
  *param_1 = 0;
  *(undefined8 *)(param_1 + 2) = 0;
  return;
}



bool IsCompressedRTF(long *param_1)

{
  int iVar1;
  
  iVar1 = SwapDWord(*param_1 + 8,4);
  return iVar1 == 0x75465a4c || iVar1 == 0x414c454d;
}



byte * to_utf8(int param_1,long param_2)

{
  long lVar1;
  byte *pbVar2;
  byte bVar3;
  byte bVar4;
  ushort uVar5;
  byte *pbVar6;
  byte *pbVar7;
  int iVar8;
  
  pbVar6 = (byte *)malloc((long)((param_1 * 3) / 2 + 1));
  pbVar7 = pbVar6;
  if (1 < param_1) {
    lVar1 = param_2 + 2 + (ulong)(param_1 - 2U >> 1) * 2;
    iVar8 = 0;
    do {
      while( true ) {
        uVar5 = SwapWord(param_2,2);
        pbVar2 = pbVar6 + iVar8;
        pbVar7 = pbVar6 + (iVar8 + 1);
        if (0x7f < uVar5) break;
        *pbVar2 = (byte)uVar5;
        iVar8 = iVar8 + 1;
LAB_001030fd:
        param_2 = param_2 + 2;
        if (param_2 == lVar1) goto LAB_00103164;
      }
      bVar4 = (byte)uVar5 & 0x3f | 0x80;
      bVar3 = (byte)(uVar5 >> 6);
      if (0x7fe < uVar5) {
        *pbVar2 = (byte)(uVar5 >> 0xc) | 0xe0;
        *pbVar7 = bVar3 & 0x3f | 0x80;
        pbVar6[iVar8 + 2] = bVar4;
        pbVar7 = pbVar6 + (iVar8 + 3);
        iVar8 = iVar8 + 3;
        goto LAB_001030fd;
      }
      param_2 = param_2 + 2;
      *pbVar2 = bVar3 | 0xc0;
      *pbVar7 = bVar4;
      pbVar7 = pbVar6 + (iVar8 + 2);
      iVar8 = iVar8 + 2;
    } while (param_2 != lVar1);
  }
LAB_00103164:
  *pbVar7 = 0;
  return pbVar6;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * calloc(size_t __nmemb,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = calloc(__nmemb,__size);
  return pvVar1;
}



void __memcpy_chk(void)

{
  __memcpy_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



void * DecompressRTF(long *param_1,uint *param_2)

{
  uint uVar1;
  byte bVar2;
  undefined uVar3;
  long lVar4;
  undefined8 uVar5;
  undefined8 uVar6;
  undefined8 uVar7;
  undefined8 uVar8;
  undefined8 uVar9;
  undefined8 uVar10;
  undefined8 uVar11;
  undefined8 uVar12;
  undefined8 uVar13;
  undefined8 uVar14;
  undefined8 uVar15;
  undefined8 uVar16;
  undefined8 uVar17;
  undefined8 uVar18;
  int iVar19;
  uint uVar20;
  int iVar21;
  uint uVar22;
  undefined8 *__ptr;
  undefined8 *__ptr_00;
  void *__dest;
  byte bVar23;
  uint uVar24;
  ulong uVar25;
  undefined *puVar26;
  ulong uVar27;
  uint uVar28;
  uint uVar29;
  uint uVar30;
  uint uVar31;
  
  __ptr = (undefined8 *)calloc(0xd0,1);
  lVar4 = *param_1;
  *__ptr = 0x615c316674725c7b;
  __ptr[1] = 0x5c63616d5c69736e;
  __ptr[2] = 0x65645c3066666564;
  __ptr[3] = 0x7b30323762617466;
  __ptr[4] = 0x6c6274746e6f665c;
  __ptr[5] = 0x665c30665c7b7d3b;
  __ptr[6] = 0x6f72665c206c696e;
  __ptr[7] = 0x7773665c206e616d;
  __ptr[8] = 0x6f6d665c20737369;
  __ptr[9] = 0x73665c206e726564;
  __ptr[10] = 0x665c207470697263;
  __ptr[0xb] = 0x534d20726f636564;
  __ptr[0xc] = 0x655320736e615320;
  __ptr[0xd] = 0x6f626d7953666972;
  __ptr[0xe] = 0x69546c616972416c;
  __ptr[0xf] = 0x2077654e2073656d;
  __ptr[0x10] = 0x756f436e616d6f52;
  __ptr[0x11] = 0x6f635c7b72656972;
  __ptr[0x12] = 0x725c6c6274726f6c;
  __ptr[0x13] = 0x656572675c306465;
  __ptr[0x14] = 0x3065756c625c306e;
  __ptr[0x15] = 0x5c207261705c0d0a;
  __ptr[0x16] = 0x616c705c64726170;
  __ptr[0x17] = 0x73665c30665c6e69;
  __ptr[0x18] = 0x755c695c625c3032;
  *(undefined4 *)(__ptr + 0x19) = 0x6261745c;
  *(undefined2 *)((long)__ptr + 0xcc) = 0x745c;
  *(undefined *)((long)__ptr + 0xce) = 0x78;
  iVar19 = SwapDWord(lVar4,4);
  uVar20 = SwapDWord(lVar4 + 4,4);
  iVar21 = SwapDWord(lVar4 + 8,4);
  if (*(int *)(param_1 + 1) + -4 == iVar19) {
    if (iVar21 != 0x414c454d) {
      if (iVar21 == 0x75465a4c) {
        uVar28 = uVar20 + 0xcf;
        __ptr_00 = (undefined8 *)calloc((ulong)uVar28,1);
        uVar5 = __ptr[1];
        uVar6 = __ptr[2];
        uVar7 = __ptr[3];
        uVar8 = __ptr[4];
        uVar9 = __ptr[5];
        uVar10 = __ptr[6];
        uVar11 = __ptr[7];
        uVar12 = __ptr[8];
        uVar13 = __ptr[9];
        *__ptr_00 = *__ptr;
        __ptr_00[1] = uVar5;
        uVar5 = __ptr[10];
        uVar14 = __ptr[0xb];
        __ptr_00[2] = uVar6;
        __ptr_00[3] = uVar7;
        uVar6 = __ptr[0xc];
        uVar7 = __ptr[0xd];
        uVar15 = __ptr[0xe];
        uVar16 = __ptr[0xf];
        __ptr_00[4] = uVar8;
        __ptr_00[5] = uVar9;
        uVar8 = __ptr[0x10];
        uVar9 = __ptr[0x11];
        uVar17 = __ptr[0x12];
        uVar18 = __ptr[0x13];
        __ptr_00[6] = uVar10;
        __ptr_00[7] = uVar11;
        uVar10 = __ptr[0x14];
        uVar11 = __ptr[0x15];
        __ptr_00[8] = uVar12;
        __ptr_00[9] = uVar13;
        uVar12 = __ptr[0x16];
        uVar13 = __ptr[0x17];
        __ptr_00[10] = uVar5;
        __ptr_00[0xb] = uVar14;
        __ptr_00[0xc] = uVar6;
        __ptr_00[0xd] = uVar7;
        __ptr_00[0xe] = uVar15;
        __ptr_00[0xf] = uVar16;
        __ptr_00[0x10] = uVar8;
        __ptr_00[0x11] = uVar9;
        __ptr_00[0x12] = uVar17;
        __ptr_00[0x13] = uVar18;
        __ptr_00[0x14] = uVar10;
        __ptr_00[0x15] = uVar11;
        __ptr_00[0x16] = uVar12;
        __ptr_00[0x17] = uVar13;
        __ptr_00[0x18] = __ptr[0x18];
        *(undefined4 *)(__ptr_00 + 0x19) = *(undefined4 *)(__ptr + 0x19);
        *(undefined2 *)((long)__ptr_00 + 0xcc) = *(undefined2 *)((long)__ptr + 0xcc);
        *(undefined *)((long)__ptr_00 + 0xce) = *(undefined *)((long)__ptr + 0xce);
        if (0xcf < uVar28) {
          uVar30 = 0;
          uVar31 = 0;
          uVar22 = 0xcf;
          uVar25 = 0x10;
          do {
            while( true ) {
              uVar24 = (uint)uVar25;
              uVar29 = uVar24 + 1;
              bVar2 = *(byte *)(lVar4 + uVar25);
              if ((uVar30 & 7) == 0) break;
              uVar31 = (int)uVar31 >> 1;
              uVar25 = (ulong)uVar29;
              bVar23 = bVar2;
              uVar29 = uVar24;
              if ((uVar31 & 1) == 0) goto LAB_001056f4;
LAB_0010572a:
              iVar19 = (*(byte *)(lVar4 + uVar25) & 0xf) + 2;
              uVar24 = ((int)(uint)*(byte *)(lVar4 + uVar25) >> 4 | (uint)bVar23 << 4) +
                       (uVar22 & 0xfffff000);
              if (uVar22 <= uVar24) {
                uVar24 = uVar24 - 0x1000;
              }
              if ((int)uVar24 < (int)(uVar24 + iVar19)) {
                uVar1 = iVar19 + uVar22;
                puVar26 = (undefined *)((long)(int)uVar24 + (long)__ptr_00);
                do {
                  uVar3 = *puVar26;
                  uVar25 = (ulong)uVar22;
                  uVar22 = uVar22 + 1;
                  puVar26 = puVar26 + 1;
                  *(undefined *)((long)__ptr_00 + uVar25) = uVar3;
                } while (uVar1 != uVar22);
              }
              uVar25 = (ulong)(uVar29 + 2);
              uVar30 = uVar30 + 1;
              if (uVar28 <= uVar22) goto LAB_0010579d;
            }
            uVar31 = (uint)bVar2;
            uVar25 = (ulong)(uVar24 + 2);
            bVar23 = *(byte *)(lVar4 + (ulong)uVar29);
            if ((bVar2 & 1) != 0) goto LAB_0010572a;
LAB_001056f4:
            uVar27 = (ulong)uVar22;
            uVar22 = uVar22 + 1;
            uVar30 = uVar30 + 1;
            *(byte *)((long)__ptr_00 + uVar27) = bVar23;
          } while (uVar22 < uVar28);
        }
LAB_0010579d:
        __dest = calloc((ulong)uVar20,1);
        memcpy(__dest,(void *)((long)__ptr_00 + 0xcf),(ulong)uVar20);
        free(__ptr_00);
        *param_2 = uVar20;
        free(__ptr);
        return __dest;
      }
      __printf_chk(1,"Unknown compression type (magic number %x)\n",iVar21);
    }
    free(__ptr);
  }
  else {
    __printf_chk(1," Size Mismatch: %u != %i\n",iVar19);
    free(__ptr);
  }
  return (void *)0x0;
}



undefined4 SwapDWord(long param_1,uint param_2)

{
  long lVar1;
  uint uVar2;
  long in_FS_OFFSET;
  undefined4 uStack_14;
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  lVar1 = 0;
  uStack_14 = 0;
  uVar2 = 4;
  if (param_2 < 5) {
    uVar2 = param_2;
  }
  if (param_2 == 0) {
    uStack_14 = 0;
  }
  else {
    do {
      *(undefined *)((long)&uStack_14 + lVar1) = *(undefined *)(param_1 + lVar1);
      lVar1 = lVar1 + 1;
    } while ((int)lVar1 < (int)uVar2);
  }
  if (lStack_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uStack_14;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



void TNEFPrintDate(ulong param_1,ulong param_2)

{
  ushort uVar1;
  ushort uVar2;
  ulong uVar3;
  long in_FS_OFFSET;
  undefined2 uStack_164;
  undefined8 uStack_158;
  undefined4 uStack_150;
  undefined2 uStack_14c;
  undefined uStack_14a;
  undefined8 uStack_149;
  undefined4 uStack_141;
  undefined2 uStack_13d;
  undefined uStack_13b;
  undefined8 uStack_13a;
  undefined4 uStack_132;
  undefined2 uStack_12e;
  undefined uStack_12c;
  undefined8 uStack_12b;
  undefined4 uStack_123;
  undefined2 uStack_11f;
  undefined uStack_11d;
  undefined8 uStack_11c;
  undefined4 uStack_114;
  undefined2 uStack_110;
  undefined uStack_10e;
  undefined8 uStack_10d;
  undefined4 uStack_105;
  undefined2 uStack_101;
  undefined uStack_ff;
  undefined8 uStack_fe;
  undefined4 uStack_f6;
  undefined2 uStack_f2;
  undefined uStack_f0;
  undefined8 uStack_e8;
  undefined4 uStack_e0;
  undefined2 uStack_dc;
  undefined uStack_da;
  undefined8 uStack_d9;
  undefined4 uStack_d1;
  undefined2 uStack_cd;
  undefined uStack_cb;
  undefined8 uStack_ca;
  undefined4 uStack_c2;
  undefined2 uStack_be;
  undefined uStack_bc;
  undefined8 uStack_bb;
  undefined4 uStack_b3;
  undefined2 uStack_af;
  undefined uStack_ad;
  undefined8 uStack_ac;
  undefined4 uStack_a4;
  undefined2 uStack_a0;
  undefined uStack_9e;
  undefined8 uStack_9d;
  undefined4 uStack_95;
  undefined2 uStack_91;
  undefined uStack_8f;
  undefined8 uStack_8e;
  undefined4 uStack_86;
  undefined2 uStack_82;
  undefined uStack_80;
  undefined8 uStack_7f;
  undefined4 uStack_77;
  undefined2 uStack_73;
  undefined uStack_71;
  undefined8 uStack_70;
  undefined4 uStack_68;
  undefined2 uStack_64;
  undefined uStack_62;
  undefined8 uStack_61;
  undefined4 uStack_59;
  undefined2 uStack_55;
  undefined uStack_53;
  undefined8 uStack_52;
  undefined4 uStack_4a;
  undefined2 uStack_46;
  undefined uStack_44;
  undefined8 uStack_43;
  undefined4 uStack_3b;
  undefined2 uStack_37;
  undefined uStack_35;
  long lStack_30;
  
  uVar1 = (ushort)(param_1 >> 0x10);
  lStack_30 = *(long *)(in_FS_OFFSET + 0x28);
  uStack_158 = 0x7961646e7553;
  uStack_149 = 0x7961646e6f4d;
  uStack_13d = 0;
  uStack_12e = 0;
  uStack_14c = 0;
  uStack_13a = 0x79616473657554;
  uStack_12b = 0x616473656e646557;
  uStack_11f = 0;
  uStack_11c = 0x7961647372756854;
  uStack_110 = 0;
  uStack_10d = 0x796164697246;
  uStack_101 = 0;
  uStack_150 = 0;
  uStack_14a = 0;
  uStack_141 = 0;
  uStack_13b = 0;
  uStack_132 = 0;
  uStack_12c = 0;
  uStack_123 = 0x79;
  uStack_11d = 0;
  uStack_114 = 0;
  uStack_10e = 0;
  uStack_105 = 0;
  uStack_ff = 0;
  uStack_fe = 0x7961647275746153;
  uStack_cd = 0;
  uStack_be = 0;
  uStack_e8 = 0x797261756e614a;
  uStack_af = 0;
  uStack_d9 = 0x7972617572626546;
  uStack_ca = 0x686372614d;
  uStack_bb = 0x6c69727041;
  uStack_a0 = 0;
  uStack_f2 = 0;
  uStack_82 = 0;
  uStack_7f = 0x747375677541;
  uStack_f6 = 0;
  uStack_f0 = 0;
  uStack_e0 = 0;
  uStack_dc = 0;
  uStack_da = 0;
  uStack_d1 = 0;
  uStack_cb = 0;
  uStack_c2 = 0;
  uStack_bc = 0;
  uStack_b3 = 0;
  uStack_ad = 0;
  uStack_ac = 0x79614d;
  uStack_a4 = 0;
  uStack_9e = 0;
  uStack_9d = 0x656e754a;
  uStack_95 = 0;
  uStack_91 = 0;
  uStack_8f = 0;
  uStack_8e = 0x796c754a;
  uStack_86 = 0;
  uStack_80 = 0;
  uStack_77 = 0;
  uStack_70 = 0x65626d6574706553;
  uStack_73 = 0;
  uStack_64 = 0;
  uStack_71 = 0;
  uStack_68 = 0x72;
  uStack_62 = 0;
  uStack_61 = 0x7265626f74634f;
  uStack_59 = 0;
  uStack_55 = 0;
  uStack_53 = 0;
  uStack_52 = 0x7265626d65766f4e;
  uStack_4a = 0;
  uStack_46 = 0;
  uStack_44 = 0;
  uStack_43 = 0x7265626d65636544;
  uStack_3b = 0;
  uStack_37 = 0;
  uStack_35 = 0;
  uVar2 = (ushort)(param_2 >> 0x20);
  if (uVar2 < 7) {
    __printf_chk(1,&DAT_00107101,(long)&uStack_158 + (ulong)uVar2 * 0xf);
  }
  if ((ushort)(uVar1 - 1) < 0xc) {
    __printf_chk(1,&DAT_00107101,(long)&uStack_e8 + (long)(int)(uVar1 - 1) * 0xf);
  }
  uStack_164 = (undefined2)(param_1 >> 0x20);
  __printf_chk(1,"%hu, %hu ",uStack_164,param_1 & 0xffff);
  uVar3 = param_2 >> 0x10 & 0xffff;
  param_2 = param_2 & 0xffff;
  uVar1 = (ushort)(param_1 >> 0x30);
  if (uVar1 < 0xd) {
    if (uVar1 == 0xc) {
      __printf_chk(1,"%hu:%02hu:%02hu pm",0xc,param_2,uVar3);
    }
    else {
      __printf_chk(1,"%hu:%02hu:%02hu am",param_1 >> 0x30,param_2,uVar3);
    }
  }
  else {
    __printf_chk(1,"%i:%02hu:%02hu pm",uVar1 - 0xc,param_2,uVar3);
  }
  if (lStack_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void TNEFFreeAttachment(long param_1)

{
  if (0 < *(int *)(param_1 + 0x18)) {
    free(*(void **)(param_1 + 0x10));
    *(undefined4 *)(param_1 + 0x18) = 0;
  }
  if (0 < *(int *)(param_1 + 0x28)) {
    free(*(void **)(param_1 + 0x20));
    *(undefined4 *)(param_1 + 0x28) = 0;
  }
  if (0 < *(int *)(param_1 + 0x58)) {
    free(*(void **)(param_1 + 0x50));
    *(undefined4 *)(param_1 + 0x58) = 0;
  }
  if (0 < *(int *)(param_1 + 0x90)) {
    free(*(void **)(param_1 + 0x88));
    *(undefined4 *)(param_1 + 0x90) = 0;
  }
  if (0 < *(int *)(param_1 + 0xa0)) {
    free(*(void **)(param_1 + 0x98));
    *(undefined4 *)(param_1 + 0xa0) = 0;
  }
  TNEFFreeMapiProps(param_1 + 0x70);
  return;
}



undefined8 TNEFParse(long param_1)

{
  long lVar1;
  int *piVar2;
  int iVar3;
  code *pcVar4;
  void *__ptr;
  ulong __nmemb;
  int *piVar5;
  undefined8 uVar6;
  long in_FS_OFFSET;
  undefined auStack_52 [2];
  short sStack_50;
  short sStack_4e;
  int iStack_4c;
  uint uStack_48;
  undefined4 uStack_44;
  long lStack_40;
  
  lStack_40 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(long *)(param_1 + 0x298) == 0) {
    uVar6 = 0xfffffff8;
    puts("ERROR: Setup incorrectly: No ReadProc");
    goto LAB_00104e79;
  }
  pcVar4 = *(code **)(param_1 + 0x290);
  lVar1 = param_1 + 0x290;
  iVar3 = *(int *)(param_1 + 0x28c);
  if (pcVar4 == (code *)0x0) {
LAB_00104df4:
    if (1 < iVar3) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,iVar3,"Reading Signature");
    }
  }
  else {
    if (1 < iVar3) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,iVar3,"About to initialize");
      pcVar4 = *(code **)(param_1 + 0x290);
    }
    iVar3 = (*pcVar4)(param_1 + 0x290);
    if (iVar3 != 0) {
      uVar6 = 0xffffffff;
      goto LAB_00104e79;
    }
    if (1 < *(int *)(param_1 + 0x28c)) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),"Initialization finished");
      iVar3 = *(int *)(param_1 + 0x28c);
      goto LAB_00104df4;
    }
  }
  iVar3 = (**(code **)(param_1 + 0x298))(param_1 + 0x290,4,1,&uStack_44);
  if (iVar3 < 1) {
    uVar6 = 0xfffffffd;
    puts("ERROR: Error reading signature");
    pcVar4 = *(code **)(param_1 + 0x2a0);
  }
  else {
    if (1 < *(int *)(param_1 + 0x28c)) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),"Checking Signature");
    }
    iVar3 = TNEFCheckForSignature(uStack_44);
    if (iVar3 < 0) {
      uVar6 = 0xfffffffe;
      puts("ERROR: Signature does not match. Not TNEF.");
      pcVar4 = *(code **)(param_1 + 0x2a0);
    }
    else {
      if (1 < *(int *)(param_1 + 0x28c)) {
        __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),"Reading Key.");
      }
      iVar3 = TNEFGetKey(param_1,auStack_52);
      if (-1 < iVar3) {
        if (1 < *(int *)(param_1 + 0x28c)) {
          __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),
                       "Starting Full Processing.");
        }
        while (iVar3 = TNEFGetHeader(param_1,&iStack_4c,&uStack_48), iVar3 == 0) {
          if (1 < *(int *)(param_1 + 0x28c)) {
            __printf_chk(1,"DEBUG(%i/%i):",2);
            __printf_chk(1,"Header says type=0x%X, size=%u",iStack_4c,uStack_48);
            putchar(10);
            if (1 < *(int *)(param_1 + 0x28c)) {
              __printf_chk(1,"DEBUG(%i/%i):",2);
              __printf_chk(1,"Header says type=%u, size=%u",iStack_4c,uStack_48);
              putchar(10);
            }
          }
          __nmemb = (ulong)uStack_48;
          __ptr = calloc(__nmemb,1);
          iVar3 = TNEFRawRead(param_1,__ptr,__nmemb,&sStack_4e);
          if (iVar3 < 0) {
            puts("ERROR: Unable to read data.");
            pcVar4 = *(code **)(param_1 + 0x2a0);
joined_r0x00104ee4:
            if (pcVar4 != (code *)0x0) {
              (*pcVar4)(lVar1);
            }
            uVar6 = 0xfffffffd;
            free(__ptr);
            goto LAB_00104e79;
          }
          iVar3 = TNEFRawRead(param_1,&sStack_50,2,0);
          if (iVar3 < 0) {
            puts("ERROR: Unable to read checksum.");
            pcVar4 = *(code **)(param_1 + 0x2a0);
            goto joined_r0x00104ee4;
          }
          sStack_50 = SwapWord(&sStack_50,2);
          if (sStack_50 != sStack_4e) {
            puts("ERROR: Checksum mismatch. Data corruption?:");
            if (*(code **)(param_1 + 0x2a0) != (code *)0x0) {
              (**(code **)(param_1 + 0x2a0))(lVar1);
            }
            uVar6 = 0xfffffffb;
            free(__ptr);
            goto LAB_00104e79;
          }
          piVar5 = &TNEFList;
          iVar3 = 0;
LAB_00104c86:
          do {
            if (*piVar5 == iStack_4c) {
              if (*(code **)(piVar5 + 0xc) != (code *)0x0) {
                iVar3 = (**(code **)(piVar5 + 0xc))(param_1,iVar3,__ptr,uStack_48);
                if (iVar3 < 0) {
                  uVar6 = 0xfffffffa;
                  free(__ptr);
                  pcVar4 = *(code **)(param_1 + 0x2a0);
                  goto joined_r0x00104dbf;
                }
                break;
              }
              if (0 < *(int *)(param_1 + 0x28c)) {
                __printf_chk(1,"DEBUG(%i/%i):",1);
                piVar2 = piVar5 + 1;
                iVar3 = iVar3 + 1;
                piVar5 = piVar5 + 0xe;
                __printf_chk(1,"No handler for %s: %u bytes",piVar2,uStack_48);
                putchar(10);
                if (iVar3 == 0x21) break;
                goto LAB_00104c86;
              }
            }
            iVar3 = iVar3 + 1;
            piVar5 = piVar5 + 0xe;
          } while (iVar3 != 0x21);
          free(__ptr);
        }
        uVar6 = 0;
        if (*(code **)(param_1 + 0x2a0) != (code *)0x0) {
          (**(code **)(param_1 + 0x2a0))(lVar1);
        }
        goto LAB_00104e79;
      }
      uVar6 = 0xfffffffc;
      puts("ERROR: Unable to retrieve key.");
      pcVar4 = *(code **)(param_1 + 0x2a0);
    }
  }
joined_r0x00104dbf:
  if (pcVar4 != (code *)0x0) {
    (*pcVar4)(lVar1);
  }
LAB_00104e79:
  if (lStack_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void __printf_chk(void)

{
  __printf_chk();
  return;
}



void TNEFInitAttachment(undefined8 *param_1)

{
  *param_1 = 0;
  *(undefined4 *)(param_1 + 1) = 0;
  *(undefined2 *)((long)param_1 + 0xc) = 0;
  param_1[2] = 0;
  *(undefined4 *)(param_1 + 3) = 0;
  param_1[4] = 0;
  *(undefined4 *)(param_1 + 5) = 0;
  param_1[6] = 0;
  param_1[7] = 0;
  param_1[8] = 0;
  *(undefined4 *)(param_1 + 9) = 0;
  param_1[10] = 0;
  *(undefined4 *)(param_1 + 0xb) = 0;
  param_1[0x11] = 0;
  *(undefined4 *)(param_1 + 0x12) = 0;
  param_1[0x13] = 0;
  *(undefined4 *)(param_1 + 0x14) = 0;
  *(undefined (*) [16])(param_1 + 0xc) = (undefined  [16])0x0;
  TNEFInitMapi();
  param_1[0x10] = 0;
  return;
}



void MAPIPrint(uint *param_1)

{
  undefined *puVar1;
  undefined8 uVar2;
  bool bVar3;
  uint uVar4;
  int iVar5;
  size_t sVar6;
  ushort **ppuVar7;
  uint *puVar8;
  uint uVar9;
  int *piVar10;
  long lVar11;
  long *plVar12;
  long lVar13;
  ulong uVar14;
  long in_FS_OFFSET;
  ulong uStack_90;
  undefined8 uStack_66;
  undefined2 uStack_5e;
  undefined2 uStack_5c;
  undefined2 uStack_5a;
  char *pcStack_58;
  undefined auStack_50 [16];
  long lStack_40;
  
  lStack_40 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_1 != 0) {
    uStack_90 = 0;
    do {
      piVar10 = (int *)(uStack_90 * 0x30 + *(long *)(param_1 + 2));
      __printf_chk(1,"   #%i: Type: [",uStack_90 & 0xffffffff);
      switch(*(short *)(piVar10 + 5)) {
      case 0:
        __printf_chk(1,"  NONE   ");
        break;
      case 1:
        __printf_chk(1,"  NULL   ");
        break;
      case 2:
        __printf_chk(1,&DAT_00107356);
        break;
      case 3:
        __printf_chk(1,"  LONG   ");
        break;
      case 4:
        __printf_chk(1,"   R4    ");
        break;
      case 5:
        __printf_chk(1," DOUBLE  ");
        break;
      case 6:
        __printf_chk(1,"CURRENCY ");
        break;
      case 7:
        __printf_chk(1,"APP TIME ");
        break;
      case 8:
      case 9:
      case 0xc:
      case 0xe:
      case 0xf:
      case 0x10:
      case 0x11:
      case 0x12:
      case 0x13:
      case 0x15:
      case 0x16:
      case 0x17:
      case 0x18:
      case 0x19:
      case 0x1a:
      case 0x1b:
      case 0x1c:
      case 0x1d:
      case 0x20:
      case 0x21:
      case 0x22:
      case 0x23:
      case 0x24:
      case 0x25:
      case 0x26:
      case 0x27:
      case 0x28:
      case 0x29:
      case 0x2a:
      case 0x2b:
      case 0x2c:
      case 0x2d:
      case 0x2e:
      case 0x2f:
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x3a:
      case 0x3b:
      case 0x3c:
      case 0x3d:
      case 0x3e:
      case 0x3f:
      case 0x41:
      case 0x42:
      case 0x43:
      case 0x44:
      case 0x45:
      case 0x46:
      case 0x47:
switchD_001058a0_caseD_8:
        __printf_chk(1,&DAT_001073ec);
        break;
      case 10:
        __printf_chk(1,"  ERROR  ");
        break;
      case 0xb:
        __printf_chk(1," BOOLEAN ");
        break;
      case 0xd:
        __printf_chk(1," OBJECT  ");
        break;
      case 0x14:
        __printf_chk(1,"   I8    ");
        break;
      case 0x1e:
        __printf_chk(1," STRING8 ");
        break;
      case 0x1f:
        __printf_chk(1," UNICODE ");
        break;
      case 0x40:
        __printf_chk(1,"SYS TIME ");
        break;
      case 0x48:
        __printf_chk(1,"OLE GUID ");
        break;
      default:
        if (*(short *)(piVar10 + 5) != 0x102) goto switchD_001058a0_caseD_8;
        __printf_chk(1," BINARY  ");
      }
      __printf_chk(1,"]  Code: [");
      if (*piVar10 == 1) {
        __printf_chk(1,"UD:x%04x",*(undefined2 *)((long)piVar10 + 0x16));
      }
      else {
        puVar8 = &MPList;
        bVar3 = false;
        do {
          while ((*puVar8 != (uint)*(ushort *)((long)piVar10 + 0x16) || (bVar3))) {
            puVar8 = puVar8 + 0x21;
            if (puVar8 == &TNEFList) goto LAB_00105942;
          }
          __printf_chk(1,"%s",puVar8 + 1);
          puVar8 = puVar8 + 0x21;
          bVar3 = true;
        } while (puVar8 != &TNEFList);
LAB_00105942:
        if (!bVar3) {
          __printf_chk(1,"0x%04x",*(undefined2 *)((long)piVar10 + 0x16));
        }
      }
      puts("]");
      if (0 < piVar10[7]) {
        lVar11 = 0;
        do {
          lVar13 = lVar11 + 1;
          __printf_chk(1,"    Name: %s\n",*(undefined8 *)(lVar11 * 0x10 + *(long *)(piVar10 + 8)));
          lVar11 = lVar13;
        } while ((int)lVar13 < piVar10[7]);
      }
      uVar9 = piVar10[6];
      if (uVar9 != 0) {
        uVar14 = 0;
        do {
          plVar12 = (long *)(uVar14 * 0x10 + *(long *)(piVar10 + 10));
          if (uVar9 == 1) {
            __printf_chk(1,&DAT_0010735b);
          }
          else {
            __printf_chk(1,"    [%i/%u] ",uVar14 & 0xffffffff);
          }
          __printf_chk(1,"Size: %i",*(undefined4 *)(plVar12 + 1));
          uVar9 = piVar10[5];
          uVar4 = uVar9 & 0xffff;
          if (0x1e < (ushort)uVar9) {
            if (uVar4 == 0x48) {
              lVar11 = 0;
              __printf_chk(1,"    Value: ");
              __printf_chk(1,"[HEX: ");
              do {
                puVar1 = (undefined *)(*plVar12 + lVar11);
                lVar11 = lVar11 + 1;
                __printf_chk(1," %02x",*puVar1);
              } while (lVar11 != 0x10);
LAB_00105cd2:
              puts("]");
            }
            else if (uVar4 == 0x102) {
              iVar5 = IsCompressedRTF(plVar12);
              if (iVar5 != 1) {
                __printf_chk(1,"    Value: [");
                if (0 < *(int *)(plVar12 + 1)) {
                  ppuVar7 = __ctype_b_loc();
                  lVar11 = 0;
                  do {
                    uVar9 = (uint)*(byte *)(*plVar12 + lVar11);
                    if ((*(byte *)((long)*ppuVar7 + (ulong)*(byte *)(*plVar12 + lVar11) * 2 + 1) &
                        0x40) == 0) {
                      uVar9 = 0x2e;
                    }
                    putchar(uVar9);
                    lVar11 = lVar11 + 1;
                  } while ((int)lVar11 < *(int *)(plVar12 + 1));
                  goto LAB_00105d6f;
                }
                goto LAB_00105cd2;
              }
              __printf_chk(1,"    Detected Compressed RTF. ");
              puts("Decompressed text follows");
              puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
              pcStack_58 = (char *)DecompressRTF(plVar12,auStack_50);
              if (pcStack_58 != (char *)0x0) {
                puts(pcStack_58);
                free(pcStack_58);
              }
              puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
            }
            else {
              if (uVar4 != 0x40) goto switchD_00105a04_caseD_0;
              lVar11 = 0;
              MAPISysTimetoDTR(*plVar12,&uStack_66);
              __printf_chk(1,"    Value: ");
              uVar2 = *(undefined8 *)*plVar12;
              TNEFPrintDate(uStack_66,(ulong)CONCAT24(uStack_5a,CONCAT22(uStack_5c,uStack_5e)));
              __printf_chk(1,&DAT_0010743e);
              do {
                puVar1 = (undefined *)(*plVar12 + lVar11);
                lVar11 = lVar11 + 1;
                __printf_chk(1," %02x",*puVar1);
              } while (lVar11 != 8);
              __printf_chk(1,"] (%llu)\n",uVar2);
            }
            goto LAB_00105a40;
          }
          if ((uVar9 & 0xfffe) == 0) {
switchD_00105a04_caseD_0:
            __printf_chk(1,"    Value: [%s]\n",*plVar12);
          }
          else {
            switch(uVar4) {
            default:
              goto switchD_00105a04_caseD_0;
            case 2:
              __printf_chk(1,"    Value: %hi\n",(int)*(short *)*plVar12);
              break;
            case 3:
              __printf_chk(1,"    Value: %li\n",*(undefined8 *)*plVar12);
              break;
            case 0xb:
              if (*(char *)**(undefined8 **)(piVar10 + 10) == '\0') {
                puts("    Value: False");
              }
              else {
                puts("    Value: True");
              }
              break;
            case 0xd:
              putchar(10);
              break;
            case 0x1e:
              __printf_chk(1,"    Value: [%s]\n",*plVar12);
              sVar6 = strlen((char *)*plVar12);
              if (sVar6 != (long)(*(int *)(plVar12 + 1) + -1)) {
                __printf_chk(1,"Detected Hidden data: [");
                if (*(int *)(plVar12 + 1) < 1) goto LAB_00105cd2;
                ppuVar7 = __ctype_b_loc();
                lVar11 = 0;
                do {
                  uVar9 = (uint)*(byte *)(*plVar12 + lVar11);
                  if ((*(byte *)((long)*ppuVar7 + (ulong)*(byte *)(*plVar12 + lVar11) * 2 + 1) &
                      0x40) == 0) {
                    uVar9 = 0x2e;
                  }
                  putchar(uVar9);
                  lVar11 = lVar11 + 1;
                } while ((int)lVar11 < *(int *)(plVar12 + 1));
LAB_00105d6f:
                puts("]");
              }
            }
          }
LAB_00105a40:
          uVar14 = uVar14 + 1;
          uVar9 = piVar10[6];
        } while ((uint)uVar14 < uVar9);
      }
      uStack_90 = uStack_90 + 1;
    } while ((uint)uStack_90 < *param_1);
  }
  if (lStack_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



undefined8 MAPISysTimetoDTR(ulong *param_1,ushort *param_2)

{
  uint uVar1;
  uint uVar2;
  ulong uVar3;
  ulong uVar4;
  int iVar5;
  ulong uVar6;
  int iVar7;
  ushort uVar8;
  long in_FS_OFFSET;
  uint auStack_48 [14];
  long lStack_10;
  
  uVar6 = *param_1;
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  auStack_48[0] = 0x1f;
  auStack_48[1] = 0x1c;
  auStack_48[2] = 0x1f;
  auStack_48[3] = 0x1e;
  auStack_48[4] = 0x1f;
  auStack_48[5] = 0x1e;
  auStack_48[6] = 0x1f;
  auStack_48[7] = 0x1f;
  auStack_48[8] = 0x1e;
  auStack_48[9] = 0x1f;
  auStack_48[10] = 0x1e;
  auStack_48[0xb] = 0x1f;
  uVar3 = uVar6 / 10000000;
  uVar4 = uVar3 / 0x3c;
  param_2[5] = (short)uVar3 + ((short)(uVar4 << 4) - (short)uVar4) * -4;
  uVar3 = uVar4 / 0x3c;
  param_2[4] = (short)uVar4 + ((short)(uVar3 << 4) - (short)uVar3) * -4;
  uVar4 = uVar3 / 0x18;
  param_2[3] = (short)uVar3 + (short)uVar4 * -0x18;
  if (uVar6 < 0x11ed178c6c000) {
    iVar5 = 1;
    *param_2 = 0x641;
  }
  else {
    uVar4 = uVar4 - 0x16d;
    uVar6 = 2;
    uVar8 = 0x642;
    *param_2 = 0x642;
    iVar7 = 0x16d;
    while( true ) {
      iVar5 = (int)(uVar6 * 0x24924925 >> 0x20);
      iVar5 = (int)uVar6 + (((uint)((int)uVar6 - iVar5) >> 1) + iVar5 >> 2) * -7;
      if (uVar4 < (ulong)(long)iVar7) break;
      uVar8 = uVar8 + 1;
      uVar4 = uVar4 - (long)iVar7;
      uVar6 = (ulong)(iVar5 + 1);
      iVar7 = 0x16d;
      *param_2 = uVar8;
      if (((uVar8 & 3) == 0) &&
         ((0x28f < (ushort)((ushort)(uVar8 * 0x5c29) >> 2 | uVar8 * 0x4000) ||
          ((ushort)((ushort)(uVar8 * 0x5c29) >> 4 | uVar8 * -0x7000) < 0xa4)))) {
        uVar6 = (ulong)(iVar5 + 2);
        iVar7 = 0x16e;
      }
    }
    if ((uVar8 & 3) == 0) {
      auStack_48[0] = 0x1f;
      auStack_48[1] = 0x1d;
    }
  }
  uVar1 = (uint)uVar4;
  uVar6 = uVar4 & 0xffffffff;
  param_2[6] = (short)(iVar5 + uVar1) + (short)((iVar5 + uVar1) / 7) * -7;
  if (uVar4 < 0x20) {
    uVar8 = 1;
  }
  else {
    uVar8 = 1;
    uVar2 = 0x1f;
    do {
      uVar1 = (int)uVar6 - uVar2;
      uVar6 = (ulong)uVar1;
      uVar3 = (ulong)uVar8;
      uVar8 = uVar8 + 1;
      uVar2 = auStack_48[uVar3];
    } while (uVar2 < uVar1);
  }
  param_2[1] = uVar8;
  param_2[2] = (short)uVar1 + 1;
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * fopen(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen(__filename,__modes);
  return pFVar1;
}



undefined8 TNEFGetHeader(long param_1,undefined4 *param_2,undefined4 *param_3)

{
  long lVar1;
  int iVar2;
  undefined4 uVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  undefined uStack_31;
  long lStack_30;
  
  lStack_30 = *(long *)(in_FS_OFFSET + 0x28);
  if (1 < *(int *)(param_1 + 0x28c)) {
    __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),"About to read Component");
  }
  lVar1 = param_1 + 0x290;
  iVar2 = (**(code **)(param_1 + 0x298))(lVar1,1,1,&uStack_31);
  if (0 < iVar2) {
    if (1 < *(int *)(param_1 + 0x28c)) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),"About to read type");
    }
    iVar2 = (**(code **)(param_1 + 0x298))(lVar1,4,1,param_2);
    if (iVar2 < 1) {
      if (0 < *(int *)(param_1 + 0x28c)) {
        puts("ERROR: Error reading type");
      }
    }
    else {
      if (1 < *(int *)(param_1 + 0x28c)) {
        __printf_chk(1,"DEBUG(%i/%i):",2);
        __printf_chk(1,"Type = 0x%X",*param_2);
        putchar(10);
        if (1 < *(int *)(param_1 + 0x28c)) {
          __printf_chk(1,"DEBUG(%i/%i):",2);
          __printf_chk(1,"Type = %u",*param_2);
          putchar(10);
          if (1 < *(int *)(param_1 + 0x28c)) {
            __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),"About to read size");
          }
        }
      }
      iVar2 = (**(code **)(param_1 + 0x298))(lVar1,4,1,param_3);
      if (0 < iVar2) {
        if (1 < *(int *)(param_1 + 0x28c)) {
          __printf_chk(1,"DEBUG(%i/%i):",2);
          __printf_chk(1,"Size = %u",*param_3);
          putchar(10);
        }
        uVar3 = SwapDWord(param_2,4);
        *param_2 = uVar3;
        uVar3 = SwapDWord(param_3,4);
        *param_3 = uVar3;
        uVar4 = 0;
        goto LAB_00104212;
      }
      if (0 < *(int *)(param_1 + 0x28c)) {
        puts("ERROR: Error reading size");
        uVar4 = 0xfffffffd;
        goto LAB_00104212;
      }
    }
  }
  uVar4 = 0xfffffffd;
LAB_00104212:
  if (lStack_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ushort ** __ctype_b_loc(void)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  return ppuVar1;
}



int TNEFCheckForSignature(undefined4 param_1)

{
  int iVar1;
  undefined4 auStack_c [3];
  
  auStack_c[0] = param_1;
  iVar1 = SwapDWord(auStack_c,4);
  return ((iVar1 == 0x223e9f78) - 2) + (uint)(iVar1 == 0x223e9f78);
}



void FUN_00102470(void)

{
  __sprintf_chk();
  return;
}



void processEntry entry(void)

{
  if ((false) && (true)) {
    _ITM_deregisterTMCloneTable();
    return;
  }
  return;
}



void FUN_001024b0(void)

{
  if ((false) && (true)) {
    _ITM_registerTMCloneTable();
    return;
  }
  return;
}



void _FINI_0(undefined8 param_1,undefined8 param_2,undefined8 param_3)

{
  undefined8 extraout_RDX;
  
  if (DAT_00118758 == '\0') {
    if (true) {
      FUN_00102250(PTR_LOOP_0010a140);
      param_3 = extraout_RDX;
    }
    entry(param_3,0x10251c);
    DAT_00118758 = 1;
    return;
  }
  return;
}



void _INIT_0(void)

{
  FUN_001024b0();
  return;
}



undefined8 TNEFMemory_Open(long param_1)

{
  (*(undefined8 **)(param_1 + 0x18))[1] = **(undefined8 **)(param_1 + 0x18);
  return 0;
}



undefined8 TNEFMemory_Close(void)

{
  return 0;
}



undefined8 TNEFParentID(long param_1,undefined8 param_2,undefined8 *param_3,uint param_4)

{
  uint uVar1;
  uint uVar2;
  long lVar3;
  ulong uVar4;
  ulong uVar5;
  
  if (0x31 < param_4) {
    param_4 = 0x32;
  }
  if (param_4 < 8) {
    if ((param_4 & 4) == 0) {
      if ((param_4 != 0) &&
         (*(undefined *)(param_1 + 0xba) = *(undefined *)param_3, (param_4 & 2) != 0)) {
        *(undefined2 *)(param_1 + 0xb8 + (ulong)param_4) =
             *(undefined2 *)((long)param_3 + ((ulong)param_4 - 2));
      }
    }
    else {
      *(undefined4 *)(param_1 + 0xba) = *(undefined4 *)param_3;
      *(undefined4 *)(param_1 + 0xb6 + (ulong)param_4) =
           *(undefined4 *)((long)param_3 + ((ulong)param_4 - 4));
    }
  }
  else {
    *(undefined8 *)(param_1 + 0xba) = *param_3;
    uVar5 = param_1 + 0xc2U & 0xfffffffffffffff8;
    *(undefined8 *)(param_1 + 0xb2 + (ulong)param_4) =
         *(undefined8 *)((long)param_3 + ((ulong)param_4 - 8));
    lVar3 = (param_1 + 0xba) - uVar5;
    uVar2 = param_4 + (int)lVar3 & 0xfffffff8;
    if (7 < uVar2) {
      uVar1 = 0;
      do {
        uVar4 = (ulong)uVar1;
        uVar1 = uVar1 + 8;
        *(undefined8 *)(uVar5 + uVar4) = *(undefined8 *)((long)param_3 + (uVar4 - lVar3));
      } while (uVar1 < uVar2);
      return 0;
    }
  }
  return 0;
}



undefined8 TNEFMessageID(long param_1,undefined8 param_2,undefined8 *param_3,uint param_4)

{
  uint uVar1;
  uint uVar2;
  long lVar3;
  ulong uVar4;
  ulong uVar5;
  
  if (0x31 < param_4) {
    param_4 = 0x32;
  }
  if (param_4 < 8) {
    if ((param_4 & 4) == 0) {
      if ((param_4 != 0) &&
         (*(undefined *)(param_1 + 0x88) = *(undefined *)param_3, (param_4 & 2) != 0)) {
        *(undefined2 *)(param_1 + 0x86 + (ulong)param_4) =
             *(undefined2 *)((long)param_3 + ((ulong)param_4 - 2));
      }
    }
    else {
      *(undefined4 *)(param_1 + 0x88) = *(undefined4 *)param_3;
      *(undefined4 *)(param_1 + 0x84 + (ulong)param_4) =
           *(undefined4 *)((long)param_3 + ((ulong)param_4 - 4));
    }
  }
  else {
    *(undefined8 *)(param_1 + 0x88) = *param_3;
    uVar5 = param_1 + 0x90U & 0xfffffffffffffff8;
    *(undefined8 *)(param_1 + 0x80 + (ulong)param_4) =
         *(undefined8 *)((long)param_3 + ((ulong)param_4 - 8));
    lVar3 = (param_1 + 0x88) - uVar5;
    uVar2 = param_4 + (int)lVar3 & 0xfffffff8;
    if (7 < uVar2) {
      uVar1 = 0;
      do {
        uVar4 = (ulong)uVar1;
        uVar1 = uVar1 + 8;
        *(undefined8 *)(uVar5 + uVar4) = *(undefined8 *)((long)param_3 + (uVar4 - lVar3));
      } while (uVar1 < uVar2);
      return 0;
    }
  }
  return 0;
}



undefined8 TNEFMessageClass(long param_1,undefined8 param_2,undefined8 *param_3,uint param_4)

{
  uint uVar1;
  uint uVar2;
  long lVar3;
  ulong uVar4;
  ulong uVar5;
  
  if (0x31 < param_4) {
    param_4 = 0x32;
  }
  if (param_4 < 8) {
    if ((param_4 & 4) == 0) {
      if ((param_4 != 0) &&
         (*(undefined *)(param_1 + 0x56) = *(undefined *)param_3, (param_4 & 2) != 0)) {
        *(undefined2 *)(param_1 + 0x54 + (ulong)param_4) =
             *(undefined2 *)((long)param_3 + ((ulong)param_4 - 2));
      }
    }
    else {
      *(undefined4 *)(param_1 + 0x56) = *(undefined4 *)param_3;
      *(undefined4 *)(param_1 + 0x52 + (ulong)param_4) =
           *(undefined4 *)((long)param_3 + ((ulong)param_4 - 4));
    }
  }
  else {
    *(undefined8 *)(param_1 + 0x56) = *param_3;
    uVar5 = param_1 + 0x5eU & 0xfffffffffffffff8;
    *(undefined8 *)(param_1 + 0x4e + (ulong)param_4) =
         *(undefined8 *)((long)param_3 + ((ulong)param_4 - 8));
    lVar3 = (param_1 + 0x56) - uVar5;
    uVar2 = param_4 + (int)lVar3 & 0xfffffff8;
    if (7 < uVar2) {
      uVar1 = 0;
      do {
        uVar4 = (ulong)uVar1;
        uVar1 = uVar1 + 8;
        *(undefined8 *)(uVar5 + uVar4) = *(undefined8 *)((long)param_3 + (uVar4 - lVar3));
      } while (uVar1 < uVar2);
      return 0;
    }
  }
  return 0;
}



int TNEFMemory_Read(long param_1,int param_2,int param_3,void *param_4)

{
  long *plVar1;
  void *__src;
  size_t __n;
  
  __n = (size_t)(param_2 * param_3);
  plVar1 = *(long **)(param_1 + 0x18);
  __src = (void *)plVar1[1];
  if ((plVar1[2] + *plVar1) - (long)__src < (long)__n) {
    param_3 = -1;
  }
  else {
    if (2 < *(int *)(plVar1 + 3)) {
      __printf_chk(1,"DEBUG(%i/%i):",3);
      __printf_chk(1,"Copying %i bytes",param_2 * param_3);
      putchar(10);
      __src = (void *)plVar1[1];
    }
    memcpy(param_4,__src,__n);
    plVar1[1] = plVar1[1] + __n;
  }
  return param_3;
}



undefined8 TNEFCodePage(long param_1,undefined8 param_2,void *param_3,int param_4)

{
  void *__dest;
  
  *(int *)(param_1 + 0x210) = param_4;
  __dest = calloc((long)param_4,1);
  *(void **)(param_1 + 0x208) = __dest;
  memcpy(__dest,param_3,(long)param_4);
  return 0;
}



undefined8 TNEFBody(long param_1,undefined8 param_2,void *param_3,int param_4)

{
  void *__dest;
  
  *(int *)(param_1 + 0x128) = param_4;
  __dest = calloc((long)param_4,1);
  *(void **)(param_1 + 0x120) = __dest;
  memcpy(__dest,param_3,(long)param_4);
  return 0;
}



undefined8 TNEFOriginalMsgClass(long param_1,undefined8 param_2,void *param_3,int param_4)

{
  void *__dest;
  
  *(int *)(param_1 + 0x220) = param_4;
  __dest = calloc((long)param_4,1);
  *(void **)(param_1 + 0x218) = __dest;
  memcpy(__dest,param_3,(long)param_4);
  return 0;
}



undefined8 TNEFFromHandler(long param_1,undefined8 param_2,void *param_3,int param_4)

{
  void *__dest;
  
  __dest = calloc((long)param_4,1);
  *(int *)(param_1 + 0x18) = param_4;
  *(void **)(param_1 + 0x10) = __dest;
  memcpy(__dest,param_3,(long)param_4);
  return 0;
}



undefined8 TNEFIcon(long param_1,undefined8 param_2,void *param_3,int param_4)

{
  long lVar1;
  void *__dest;
  long lVar2;
  
  lVar1 = param_1 + 0x140;
  do {
    lVar2 = lVar1;
    lVar1 = *(long *)(lVar2 + 0x80);
  } while (*(long *)(lVar2 + 0x80) != 0);
  *(int *)(lVar2 + 0xa0) = param_4;
  __dest = calloc((long)param_4,1);
  *(void **)(lVar2 + 0x98) = __dest;
  memcpy(__dest,param_3,(long)param_4);
  return 0;
}



undefined8 TNEFAttachmentFilename(long param_1,undefined8 param_2,void *param_3,int param_4)

{
  long lVar1;
  void *__dest;
  long lVar2;
  
  lVar1 = param_1 + 0x140;
  do {
    lVar2 = lVar1;
    lVar1 = *(long *)(lVar2 + 0x80);
  } while (*(long *)(lVar2 + 0x80) != 0);
  *(int *)(lVar2 + 0x18) = param_4;
  __dest = calloc((long)param_4,1);
  *(void **)(lVar2 + 0x10) = __dest;
  memcpy(__dest,param_3,(long)param_4);
  return 0;
}



undefined8 TNEFAttachmentSave(long param_1,undefined8 param_2,void *param_3,int param_4)

{
  long lVar1;
  void *__dest;
  long lVar2;
  
  lVar1 = param_1 + 0x140;
  do {
    lVar2 = lVar1;
    lVar1 = *(long *)(lVar2 + 0x80);
  } while (*(long *)(lVar2 + 0x80) != 0);
  __dest = calloc(1,(long)param_4);
  *(int *)(lVar2 + 0x90) = param_4;
  *(void **)(lVar2 + 0x88) = __dest;
  memcpy(__dest,param_3,(long)param_4);
  return 0;
}



undefined8 TNEFSubjectHandler(long param_1,undefined8 param_2,void *param_3,int param_4)

{
  void *__dest;
  
  if (*(void **)(param_1 + 0x20) != (void *)0x0) {
    free(*(void **)(param_1 + 0x20));
  }
  __dest = calloc((long)param_4,1);
  *(int *)(param_1 + 0x28) = param_4;
  *(void **)(param_1 + 0x20) = __dest;
  memcpy(__dest,param_3,(long)param_4);
  return 0;
}



int TNEFFile_Open(long param_1)

{
  undefined8 *puVar1;
  FILE *pFVar2;
  
  puVar1 = *(undefined8 **)(param_1 + 0x18);
  if (2 < *(int *)(puVar1 + 2)) {
    __printf_chk(1,"DEBUG(%i/%i):",3);
    __printf_chk(1,"Opening %s",*puVar1);
    putchar(10);
  }
  pFVar2 = fopen((char *)*puVar1,"rb");
  puVar1[1] = pFVar2;
  return -(uint)(pFVar2 == (FILE *)0x0);
}



size_t TNEFFile_Read(long param_1,int param_2,int param_3,void *param_4)

{
  long lVar1;
  FILE *__stream;
  size_t sVar2;
  
  lVar1 = *(long *)(param_1 + 0x18);
  if (2 < *(int *)(lVar1 + 0x10)) {
    __printf_chk(1,"DEBUG(%i/%i):",3);
    __printf_chk(1,"Reading %i blocks of %i size",param_3,param_2);
    putchar(10);
  }
  __stream = *(FILE **)(lVar1 + 8);
  if (__stream == (FILE *)0x0) {
    sVar2 = 0xffffffff;
  }
  else {
    sVar2 = fread(param_4,(long)param_2,(long)param_3,__stream);
  }
  return sVar2;
}



undefined8 TNEFFile_Close(long param_1)

{
  undefined8 *puVar1;
  
  puVar1 = *(undefined8 **)(param_1 + 0x18);
  if (2 < *(int *)(puVar1 + 2)) {
    __printf_chk(1,"DEBUG(%i/%i):",3);
    __printf_chk(1,"Closing file %s",*puVar1);
    putchar(10);
  }
  if ((FILE *)puVar1[1] != (FILE *)0x0) {
    fclose((FILE *)puVar1[1]);
    puVar1[1] = 0;
  }
  return 0;
}



undefined8 TNEFDefaultHandler(long param_1,int param_2,undefined8 param_3,undefined8 param_4)

{
  if (*(int *)(param_1 + 0x28c) < 1) {
    return 0;
  }
  __printf_chk(1,"%s: [%i] %s\n",&DAT_00118024 + (long)param_2 * 0x38,param_4,param_3);
  return 0;
}



ushort SwapWord(byte *param_1,int param_2)

{
  ushort uVar1;
  long in_FS_OFFSET;
  
  uVar1 = 0;
  if (param_2 != 0) {
    uVar1 = (ushort)*param_1;
    if (param_2 != 1) {
      uVar1 = CONCAT11(param_1[1],*param_1);
    }
  }
  if (*(long *)(in_FS_OFFSET + 0x28) != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar1;
}



undefined8 TNEFVersion(undefined8 param_1,undefined8 param_2,long param_3,int param_4)

{
  undefined2 uVar1;
  undefined2 uVar2;
  
  uVar1 = SwapWord(param_3,param_4);
  uVar2 = SwapWord(param_3 + 2,param_4 + -2);
  FUN_00102470(param_1,1,10,"TNEF%i.%i",uVar2,uVar1);
  return 0;
}



undefined8 TNEFSentFor(long param_1,undefined8 param_2,long param_3,int param_4)

{
  ushort uVar1;
  uint uVar2;
  long lVar3;
  long lVar4;
  
  lVar4 = param_3;
  if (0 < (long)param_4) {
    do {
      uVar1 = SwapWord(lVar4,2);
      if (0 < *(int *)(param_1 + 0x28c)) {
        __printf_chk(1,"Sent For : %s",lVar4 + 2);
      }
      lVar3 = lVar4 + 2 + (ulong)uVar1;
      lVar4 = lVar3 + 2;
      uVar2 = SwapWord(lVar3,2);
      if (0 < *(int *)(param_1 + 0x28c)) {
        __printf_chk(1,"<%s>\n",lVar4);
      }
      lVar4 = lVar4 + ((ulong)uVar2 & 0xffff);
    } while (lVar4 - param_3 < (long)param_4);
  }
  return 0;
}



undefined8 TNEFDateHandler(long param_1,int param_2,long param_3)

{
  uint uVar1;
  long lVar2;
  undefined2 uVar3;
  long lVar4;
  undefined2 *puVar5;
  undefined2 *puVar6;
  undefined2 *puVar7;
  undefined8 uVar8;
  
  uVar1 = (&TNEFList)[(long)param_2 * 0xe];
  if (0x38020 < uVar1) goto switchD_00102e6f_caseD_38007;
  if (uVar1 < 0x38005) {
    if (uVar1 == 0x30006) {
      puVar5 = (undefined2 *)(param_1 + 600);
    }
    else {
      if (uVar1 != 0x30007) goto switchD_00102e6f_caseD_38007;
      puVar5 = (undefined2 *)(param_1 + 0x266);
    }
    goto LAB_00102e88;
  }
  if (uVar1 - 0x38005 < 0x1c) {
    lVar2 = param_1 + 0x140;
    switch(uVar1) {
    case 0x38005:
      puVar5 = (undefined2 *)(param_1 + 0x30);
      break;
    case 0x38006:
      puVar5 = (undefined2 *)(param_1 + 0x3e);
      break;
    default:
      goto switchD_00102e6f_caseD_38007;
    case 0x38012:
      do {
        lVar4 = lVar2;
        lVar2 = *(long *)(lVar4 + 0x80);
      } while (lVar2 != 0);
      puVar5 = (undefined2 *)(lVar4 + 0x30);
      break;
    case 0x38013:
      do {
        lVar4 = lVar2;
        lVar2 = *(long *)(lVar4 + 0x80);
      } while (lVar2 != 0);
      puVar5 = (undefined2 *)(lVar4 + 0x3e);
      break;
    case 0x38020:
      puVar5 = (undefined2 *)(param_1 + 0x1e8);
    }
LAB_00102e88:
    puVar6 = puVar5;
    do {
      puVar7 = puVar6 + 1;
      uVar3 = SwapWord(param_3,2);
      *puVar6 = uVar3;
      puVar6 = puVar7;
      param_3 = param_3 + 2;
    } while (puVar7 != puVar5 + 7);
    uVar8 = 0;
  }
  else {
switchD_00102e6f_caseD_38007:
    uVar8 = 0xfffffff9;
    if (0 < *(int *)(param_1 + 0x28c)) {
      puts("MISSING CASE");
    }
  }
  return uVar8;
}



undefined4 SwapDWord(long param_1,uint param_2)

{
  long lVar1;
  uint uVar2;
  long in_FS_OFFSET;
  undefined4 local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  lVar1 = 0;
  local_14 = 0;
  uVar2 = 4;
  if (param_2 < 5) {
    uVar2 = param_2;
  }
  if (param_2 == 0) {
    local_14 = 0;
  }
  else {
    do {
      *(undefined *)((long)&local_14 + lVar1) = *(undefined *)(param_1 + lVar1);
      lVar1 = lVar1 + 1;
    } while ((int)lVar1 < (int)uVar2);
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return local_14;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 TNEFRecipTable(undefined8 param_1,undefined8 param_2,undefined8 param_3)

{
  SwapDWord(param_3,4);
  return 0;
}



undefined8 TNEFPriority(long param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4)

{
  int iVar1;
  undefined4 uVar2;
  
  iVar1 = SwapDWord(param_3,param_4);
  if (iVar1 == 2) {
    *(undefined4 *)(param_1 + 0x130) = 0x6d726f6e;
    *(undefined2 *)(param_1 + 0x134) = 0x6c61;
    *(undefined *)(param_1 + 0x136) = 0;
    return 0;
  }
  if (iVar1 != 3) {
    uVar2 = 0x776f6c;
    if (iVar1 != 1) {
      uVar2 = 0x412f4e;
    }
    *(undefined4 *)(param_1 + 0x130) = uVar2;
    return 0;
  }
  *(undefined4 *)(param_1 + 0x130) = 0x68676968;
  *(undefined *)(param_1 + 0x134) = 0;
  return 0;
}



undefined8 SwapDDWord(long param_1,uint param_2)

{
  long lVar1;
  uint uVar2;
  long in_FS_OFFSET;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  lVar1 = 0;
  local_18 = 0;
  uVar2 = 8;
  if (param_2 < 9) {
    uVar2 = param_2;
  }
  if (param_2 == 0) {
    local_18 = 0;
  }
  else {
    do {
      *(undefined *)((long)&local_18 + lVar1) = *(undefined *)(param_1 + lVar1);
      lVar1 = lVar1 + 1;
    } while ((int)lVar1 < (int)uVar2);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_18;
}



byte * to_utf8(int param_1,long param_2)

{
  long lVar1;
  byte *pbVar2;
  byte bVar3;
  byte bVar4;
  ushort uVar5;
  byte *pbVar6;
  byte *pbVar7;
  int iVar8;
  
  pbVar6 = (byte *)malloc((long)((param_1 * 3) / 2 + 1));
  pbVar7 = pbVar6;
  if (1 < param_1) {
    lVar1 = param_2 + 2 + (ulong)(param_1 - 2U >> 1) * 2;
    iVar8 = 0;
    do {
      while( true ) {
        uVar5 = SwapWord(param_2,2);
        pbVar2 = pbVar6 + iVar8;
        pbVar7 = pbVar6 + (iVar8 + 1);
        if (0x7f < uVar5) break;
        *pbVar2 = (byte)uVar5;
        iVar8 = iVar8 + 1;
LAB_001030fd:
        param_2 = param_2 + 2;
        if (param_2 == lVar1) goto LAB_00103164;
      }
      bVar4 = (byte)uVar5 & 0x3f | 0x80;
      bVar3 = (byte)(uVar5 >> 6);
      if (0x7fe < uVar5) {
        *pbVar2 = (byte)(uVar5 >> 0xc) | 0xe0;
        *pbVar7 = bVar3 & 0x3f | 0x80;
        pbVar6[iVar8 + 2] = bVar4;
        pbVar7 = pbVar6 + (iVar8 + 3);
        iVar8 = iVar8 + 3;
        goto LAB_001030fd;
      }
      param_2 = param_2 + 2;
      *pbVar2 = bVar3 | 0xc0;
      *pbVar7 = bVar4;
      pbVar7 = pbVar6 + (iVar8 + 2);
      iVar8 = iVar8 + 2;
    } while (param_2 != lVar1);
  }
LAB_00103164:
  *pbVar7 = 0;
  return pbVar6;
}



void TNEFFillMapi(long param_1,long param_2,uint param_3,uint *param_4)

{
  char cVar1;
  long lVar2;
  undefined2 uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  undefined4 uVar7;
  undefined4 *puVar8;
  void *__dest;
  void *pvVar9;
  undefined8 *puVar10;
  undefined8 uVar11;
  ushort uVar12;
  ulong uVar13;
  long lVar14;
  ulong uVar15;
  undefined8 *puVar16;
  char *pcVar17;
  int iVar18;
  undefined8 *puVar19;
  undefined8 *puVar20;
  long in_FS_OFFSET;
  bool bVar21;
  int local_80;
  uint local_7c;
  ulong local_70;
  undefined2 local_4e;
  undefined4 local_4c;
  undefined8 local_48;
  long local_40;
  
  puVar20 = (undefined8 *)(param_2 + 4);
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  uVar4 = SwapDWord(param_2,4);
  *param_4 = uVar4;
  puVar8 = (undefined4 *)calloc((ulong)uVar4,0x30);
  *(undefined4 **)(param_4 + 2) = puVar8;
  if (uVar4 == 0) {
    param_2 = 4;
  }
  else {
    local_7c = 0;
    iVar18 = -1;
    do {
      if (iVar18 == -1) {
        iVar5 = SwapDWord(puVar20,4);
        *puVar8 = 0;
        puVar8[5] = iVar5;
        *(undefined8 *)(puVar8 + 6) = 1;
        if (iVar5 < 0) {
          uVar11 = *(undefined8 *)((long)puVar20 + 0xc);
          puVar16 = puVar20 + 3;
          *(undefined8 *)(puVar8 + 1) = *(undefined8 *)((long)puVar20 + 4);
          *(undefined8 *)(puVar8 + 3) = uVar11;
          uVar4 = SwapDWord((long)puVar20 + 0x14,4);
          if (uVar4 == 0) {
            uVar3 = SwapDWord(puVar16,4);
            *(undefined2 *)((long)puVar8 + 0x16) = uVar3;
            puVar16 = (undefined8 *)((long)puVar20 + 0x1c);
          }
          else {
            puVar8[7] = uVar4;
            lVar14 = (ulong)(uVar4 - 1) << 4;
            pvVar9 = calloc((ulong)uVar4,0x10);
            *(void **)(puVar8 + 8) = pvVar9;
            do {
              uVar4 = SwapDWord(puVar16,4);
              lVar2 = *(long *)(puVar8 + 8);
              uVar13 = (ulong)uVar4;
              pvVar9 = calloc(uVar13,1);
              *(uint *)((undefined8 *)(lVar2 + lVar14) + 1) = uVar4;
              *(undefined8 *)(lVar2 + lVar14) = pvVar9;
              if (uVar4 >> 1 != 0) {
                uVar15 = 0;
                while( true ) {
                  *(undefined *)((long)pvVar9 + uVar15) =
                       *(undefined *)((long)puVar16 + uVar15 * 2 + 4);
                  if ((uVar4 >> 1) - 1 == uVar15) break;
                  pvVar9 = *(void **)(*(long *)(puVar8 + 8) + lVar14);
                  uVar15 = uVar15 + 1;
                }
              }
              if ((uVar4 & 3) != 0) {
                uVar13 = (ulong)((uVar4 + 4) - (uVar4 & 3));
              }
              lVar14 = lVar14 + -0x10;
              puVar16 = (undefined8 *)((long)puVar16 + uVar13 + 4);
            } while (lVar14 != -0x10);
          }
          *puVar8 = 1;
        }
        else {
          puVar16 = (undefined8 *)((long)puVar20 + 4);
        }
        if (2 < *(int *)(param_1 + 0x28c)) {
          __printf_chk(1,"DEBUG(%i/%i):",3);
          __printf_chk(1,"Type id = %04x, Prop id = %04x",puVar8[5] & 0xffff,(uint)puVar8[5] >> 0x10
                      );
          putchar(10);
        }
        uVar4 = puVar8[5];
        uVar12 = (ushort)uVar4;
        bVar21 = (uVar4 & 0x1000) != 0;
        if (bVar21) {
          iVar18 = 0;
          puVar20 = (undefined8 *)((long)puVar16 + 4);
          puVar8[5] = uVar4 & 0xffff0000 | (uVar4 & 0xffff) - 0x1000;
          uVar6 = SwapDWord(puVar16,4);
          uVar4 = puVar8[5];
          puVar8[6] = uVar6;
          local_80 = 0;
          uVar12 = (ushort)uVar4;
        }
        else {
          local_80 = -1;
          uVar6 = puVar8[6];
          puVar20 = puVar16;
        }
        bVar21 = !bVar21;
        puVar16 = (undefined8 *)calloc((ulong)uVar6,0x10);
        local_7c = local_7c + 1;
        *(undefined8 **)(puVar8 + 10) = puVar16;
      }
      else {
        iVar18 = iVar18 + 1;
        uVar4 = puVar8[5];
        bVar21 = false;
        uVar12 = (ushort)uVar4;
        puVar16 = (undefined8 *)((long)iVar18 * 0x10 + *(long *)(puVar8 + 10));
        local_80 = iVar18;
      }
      uVar13 = (ulong)uVar4;
      puVar19 = puVar20;
      if (0x48 < uVar12) {
        if (uVar12 == 0x102) {
switchD_0010328e_caseD_d:
          puVar19 = (undefined8 *)((long)puVar20 + 4);
          if (iVar18 == -1) {
            uVar7 = SwapDWord(puVar20,4);
            *(undefined4 *)(puVar16 + 1) = uVar7;
            puVar19 = puVar20 + 1;
            puVar20 = (undefined8 *)((long)puVar20 + 4);
          }
          iVar5 = SwapDWord(puVar20,4);
          *(int *)(puVar16 + 1) = iVar5;
          if (iVar5 == 0) {
            *puVar16 = 0;
            uVar13 = (ulong)(uint)puVar8[5];
            uVar15 = 0;
          }
          else {
            uVar4 = puVar8[5];
            if ((short)uVar4 == 0x1f) {
              uVar11 = to_utf8(iVar5,puVar19);
              uVar4 = puVar8[5];
              *puVar16 = uVar11;
            }
            else {
              pvVar9 = calloc((long)iVar5,1);
              *puVar16 = pvVar9;
              memcpy(pvVar9,puVar19,(long)iVar5);
            }
            uVar13 = (ulong)uVar4;
            uVar4 = *(uint *)(puVar16 + 1);
            uVar15 = (ulong)uVar4;
            if ((uVar4 & 3) != 0) {
              uVar15 = (ulong)((uVar4 + 4) - (uVar4 & 3));
            }
          }
          puVar19 = (undefined8 *)((long)puVar19 + uVar15);
        }
        goto switchD_0010328e_caseD_8;
      }
      if ((uVar12 < 2) || (false)) goto switchD_0010328e_caseD_8;
      switch(uVar12) {
      case 2:
        *(undefined4 *)(puVar16 + 1) = 2;
        pvVar9 = calloc(2,2);
        puVar19 = (undefined8 *)((long)puVar20 + 4);
        *puVar16 = pvVar9;
        local_4e = SwapWord(puVar20,2);
        memcpy((void *)*puVar16,&local_4e,(long)*(int *)(puVar16 + 1));
        uVar13 = (ulong)(uint)puVar8[5];
        break;
      case 3:
      case 4:
      case 6:
      case 7:
      case 10:
      case 0xb:
        *(undefined4 *)(puVar16 + 1) = 4;
        pvVar9 = calloc(4,1);
        puVar19 = (undefined8 *)((long)puVar20 + 4);
        *puVar16 = pvVar9;
        local_4c = SwapDWord(puVar20,4);
        memcpy((void *)*puVar16,&local_4c,(long)*(int *)(puVar16 + 1));
        uVar13 = (ulong)(uint)puVar8[5];
        break;
      case 5:
      case 0x14:
      case 0x40:
        *(undefined4 *)(puVar16 + 1) = 8;
        pvVar9 = calloc(8,1);
        *puVar16 = pvVar9;
        local_48 = SwapDDWord(puVar20,8);
        memcpy((void *)*puVar16,&local_48,(long)*(int *)(puVar16 + 1));
        uVar4 = puVar8[5];
        uVar6 = uVar4 >> 0x10;
        puVar20 = puVar20 + 1;
        goto joined_r0x00103425;
      case 0xd:
      case 0x1e:
      case 0x1f:
        goto switchD_0010328e_caseD_d;
      case 0x48:
        *(undefined4 *)(puVar16 + 1) = 0x10;
        puVar19 = puVar20 + 2;
        puVar10 = (undefined8 *)calloc(0x10,1);
        uVar13 = (ulong)uVar4;
        *puVar16 = puVar10;
        uVar11 = puVar20[1];
        *puVar10 = *puVar20;
        puVar10[1] = uVar11;
      }
switchD_0010328e_caseD_8:
      uVar4 = (uint)uVar13;
      uVar6 = (uint)(uVar13 >> 0x10);
      puVar20 = puVar19;
joined_r0x00103425:
      if (uVar4 < 0x710000) {
        if ((0x36 < uVar6) && ((0x200000000040003U >> ((ulong)(uVar6 - 0x37) & 0x3f) & 1) != 0)) {
LAB_0010343b:
          if (*(int *)(param_1 + 0x28c) < 3) {
            if (*(int *)(param_1 + 0x28) == 0) {
LAB_00103455:
              __dest = calloc((ulong)param_3,1);
              iVar5 = *(int *)(puVar16 + 1);
              *(void **)(param_1 + 0x20) = __dest;
              pvVar9 = (void *)*puVar16;
              *(int *)(param_1 + 0x28) = iVar5;
              pvVar9 = memcpy(__dest,pvVar9,(long)*(int *)(puVar16 + 1));
              if (iVar5 != 0) {
                lVar14 = 0;
                while( true ) {
                  cVar1 = *(char *)((long)pvVar9 + lVar14);
                  if (((cVar1 == '/') || (cVar1 == '\\')) || (cVar1 == '\0')) {
                    *(char *)((long)pvVar9 + lVar14) = '_';
                  }
                  lVar14 = lVar14 + 1;
                  if (*(int *)(param_1 + 0x28) == (int)lVar14) break;
                  pvVar9 = *(void **)(param_1 + 0x20);
                }
              }
            }
          }
          else {
            __printf_chk(1,"DEBUG(%i/%i): %s\n",3,*(int *)(param_1 + 0x28c),"Got a Subject");
            if (*(int *)(param_1 + 0x28) == 0) {
              if (2 < *(int *)(param_1 + 0x28c)) {
                __printf_chk(1,"DEBUG(%i/%i): %s\n",3,*(int *)(param_1 + 0x28c),
                             "Assigning a Subject");
              }
              goto LAB_00103455;
            }
          }
        }
      }
      else if (uVar6 == 0xe1d) goto LAB_0010343b;
      if ((puVar8[6] + -1 == local_80) || (bVar21)) {
        puVar8 = puVar8 + 0xc;
        iVar18 = -1;
      }
    } while (local_7c < *param_4);
    param_2 = (long)puVar20 - param_2;
  }
  local_70 = (ulong)param_3;
  if (param_2 < (long)local_70) {
    if (0 < *(int *)(param_1 + 0x28c)) {
      puts("ERROR DURING MAPI READ");
      __printf_chk(1,"Read %td bytes, Expected %u bytes\n",param_2,param_3);
      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
        pcVar17 = "%td bytes missing\n";
        param_2 = local_70 - param_2;
LAB_00103829:
        __printf_chk(1,pcVar17,param_2);
        return;
      }
      goto LAB_00103943;
    }
  }
  else if (((long)local_70 < param_2) && (0 < *(int *)(param_1 + 0x28c))) {
    puts("ERROR DURING MAPI READ");
    __printf_chk(1,"Read %td bytes, Expected %u bytes\n",param_2,param_3);
    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
      param_2 = param_2 - local_70;
      pcVar17 = "%li bytes extra\n";
      goto LAB_00103829;
    }
    goto LAB_00103943;
  }
  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
LAB_00103943:
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 TNEFAttachmentMAPI(long param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4)

{
  long lVar1;
  long lVar2;
  
  lVar1 = param_1 + 0x140;
  do {
    lVar2 = lVar1;
    lVar1 = *(long *)(lVar2 + 0x80);
  } while (lVar1 != 0);
  TNEFFillMapi(param_1,param_3,param_4,lVar2 + 0x70);
  return 0;
}



void TNEFPrintDate(ulong param_1,ulong param_2)

{
  ushort uVar1;
  ushort uVar2;
  ulong uVar3;
  long in_FS_OFFSET;
  undefined2 uStack_164;
  undefined8 local_158;
  undefined4 local_150;
  undefined2 local_14c;
  undefined local_14a;
  undefined8 local_149;
  undefined4 local_141;
  undefined2 local_13d;
  undefined local_13b;
  undefined8 local_13a;
  undefined4 local_132;
  undefined2 local_12e;
  undefined local_12c;
  undefined8 local_12b;
  undefined4 local_123;
  undefined2 local_11f;
  undefined local_11d;
  undefined8 local_11c;
  undefined4 local_114;
  undefined2 local_110;
  undefined local_10e;
  undefined8 local_10d;
  undefined4 local_105;
  undefined2 local_101;
  undefined local_ff;
  undefined8 local_fe;
  undefined4 local_f6;
  undefined2 local_f2;
  undefined local_f0;
  undefined8 local_e8;
  undefined4 local_e0;
  undefined2 local_dc;
  undefined local_da;
  undefined8 local_d9;
  undefined4 local_d1;
  undefined2 local_cd;
  undefined local_cb;
  undefined8 local_ca;
  undefined4 local_c2;
  undefined2 local_be;
  undefined local_bc;
  undefined8 local_bb;
  undefined4 local_b3;
  undefined2 local_af;
  undefined local_ad;
  undefined8 local_ac;
  undefined4 local_a4;
  undefined2 local_a0;
  undefined local_9e;
  undefined8 local_9d;
  undefined4 local_95;
  undefined2 local_91;
  undefined local_8f;
  undefined8 local_8e;
  undefined4 local_86;
  undefined2 local_82;
  undefined local_80;
  undefined8 local_7f;
  undefined4 local_77;
  undefined2 local_73;
  undefined local_71;
  undefined8 local_70;
  undefined4 local_68;
  undefined2 local_64;
  undefined local_62;
  undefined8 local_61;
  undefined4 local_59;
  undefined2 local_55;
  undefined local_53;
  undefined8 local_52;
  undefined4 local_4a;
  undefined2 local_46;
  undefined local_44;
  undefined8 local_43;
  undefined4 local_3b;
  undefined2 local_37;
  undefined local_35;
  long local_30;
  
  uVar1 = (ushort)(param_1 >> 0x10);
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  local_158 = 0x7961646e7553;
  local_149 = 0x7961646e6f4d;
  local_13d = 0;
  local_12e = 0;
  local_14c = 0;
  local_13a = 0x79616473657554;
  local_12b = 0x616473656e646557;
  local_11f = 0;
  local_11c = 0x7961647372756854;
  local_110 = 0;
  local_10d = 0x796164697246;
  local_101 = 0;
  local_150 = 0;
  local_14a = 0;
  local_141 = 0;
  local_13b = 0;
  local_132 = 0;
  local_12c = 0;
  local_123 = 0x79;
  local_11d = 0;
  local_114 = 0;
  local_10e = 0;
  local_105 = 0;
  local_ff = 0;
  local_fe = 0x7961647275746153;
  local_cd = 0;
  local_be = 0;
  local_e8 = 0x797261756e614a;
  local_af = 0;
  local_d9 = 0x7972617572626546;
  local_ca = 0x686372614d;
  local_bb = 0x6c69727041;
  local_a0 = 0;
  local_f2 = 0;
  local_82 = 0;
  local_7f = 0x747375677541;
  local_f6 = 0;
  local_f0 = 0;
  local_e0 = 0;
  local_dc = 0;
  local_da = 0;
  local_d1 = 0;
  local_cb = 0;
  local_c2 = 0;
  local_bc = 0;
  local_b3 = 0;
  local_ad = 0;
  local_ac = 0x79614d;
  local_a4 = 0;
  local_9e = 0;
  local_9d = 0x656e754a;
  local_95 = 0;
  local_91 = 0;
  local_8f = 0;
  local_8e = 0x796c754a;
  local_86 = 0;
  local_80 = 0;
  local_77 = 0;
  local_70 = 0x65626d6574706553;
  local_73 = 0;
  local_64 = 0;
  local_71 = 0;
  local_68 = 0x72;
  local_62 = 0;
  local_61 = 0x7265626f74634f;
  local_59 = 0;
  local_55 = 0;
  local_53 = 0;
  local_52 = 0x7265626d65766f4e;
  local_4a = 0;
  local_46 = 0;
  local_44 = 0;
  local_43 = 0x7265626d65636544;
  local_3b = 0;
  local_37 = 0;
  local_35 = 0;
  uVar2 = (ushort)(param_2 >> 0x20);
  if (uVar2 < 7) {
    __printf_chk(1,&DAT_00107101,(long)&local_158 + (ulong)uVar2 * 0xf);
  }
  if ((ushort)(uVar1 - 1) < 0xc) {
    __printf_chk(1,&DAT_00107101,(long)&local_e8 + (long)(int)(uVar1 - 1) * 0xf);
  }
  uStack_164 = (undefined2)(param_1 >> 0x20);
  __printf_chk(1,"%hu, %hu ",uStack_164,param_1 & 0xffff);
  uVar3 = param_2 >> 0x10 & 0xffff;
  param_2 = param_2 & 0xffff;
  uVar1 = (ushort)(param_1 >> 0x30);
  if (uVar1 < 0xd) {
    if (uVar1 == 0xc) {
      __printf_chk(1,"%hu:%02hu:%02hu pm",0xc,param_2,uVar3);
    }
    else {
      __printf_chk(1,"%hu:%02hu:%02hu am",param_1 >> 0x30,param_2,uVar3);
    }
  }
  else {
    __printf_chk(1,"%i:%02hu:%02hu pm",uVar1 - 0xc,param_2,uVar3);
  }
  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 TNEFHexBreakdown(long param_1,int param_2,char *param_3,int param_4)

{
  ulong uVar1;
  
  if (*(int *)(param_1 + 0x28c) == 0) {
    return 0;
  }
  __printf_chk(1,"%s: [%i bytes] \n",&DAT_00118024 + (long)param_2 * 0x38);
  if (0 < param_4) {
    __printf_chk(1,"%02x ",(int)*param_3);
    for (uVar1 = 2; (ulong)(param_4 - 1) + 2 != uVar1; uVar1 = uVar1 + 1) {
      __printf_chk(1,"%02x ",(int)param_3[uVar1 - 1]);
      if ((uVar1 & 0xf) == 0) {
        putchar(10);
      }
    }
  }
  putchar(10);
  return 0;
}



undefined8 TNEFDetailedPrint(long param_1,int param_2,char *param_3,int param_4)

{
  char *pcVar1;
  char cVar2;
  
  if (*(int *)(param_1 + 0x28c) == 0) {
    return 0;
  }
  __printf_chk(1,"%s: [%i bytes] \n",&DAT_00118024 + (long)param_2 * 0x38);
  if (0 < param_4) {
    pcVar1 = param_3 + (ulong)(param_4 - 1) + 1;
    do {
      cVar2 = *param_3;
      param_3 = param_3 + 1;
      putchar((int)cVar2);
    } while (param_3 != pcVar1);
  }
  putchar(10);
  return 0;
}



int TNEFCheckForSignature(undefined4 param_1)

{
  int iVar1;
  undefined4 local_c [3];
  
  local_c[0] = param_1;
  iVar1 = SwapDWord(local_c,4);
  return ((iVar1 == 0x223e9f78) - 2) + (uint)(iVar1 == 0x223e9f78);
}



undefined8 TNEFGetKey(long param_1,undefined2 *param_2)

{
  undefined2 uVar1;
  int iVar2;
  undefined8 uVar3;
  
  iVar2 = (**(code **)(param_1 + 0x298))(param_1 + 0x290,2,1,param_2);
  if (iVar2 < 1) {
    uVar3 = 0xfffffffd;
    if (0 < *(int *)(param_1 + 0x28c)) {
      puts("Error reading Key");
    }
  }
  else {
    uVar1 = SwapWord(param_2,2);
    iVar2 = *(int *)(param_1 + 0x28c);
    *param_2 = uVar1;
    if (1 < iVar2) {
      __printf_chk(1,"DEBUG(%i/%i):",2);
      __printf_chk(1,"Key = 0x%X",*param_2);
      putchar(10);
      if (1 < *(int *)(param_1 + 0x28c)) {
        __printf_chk(1,"DEBUG(%i/%i):",2);
        __printf_chk(1,"Key = %i",*param_2);
        putchar(10);
      }
    }
    uVar3 = 0;
  }
  return uVar3;
}



undefined8 TNEFGetHeader(long param_1,undefined4 *param_2,undefined4 *param_3)

{
  long lVar1;
  int iVar2;
  undefined4 uVar3;
  undefined8 uVar4;
  long in_FS_OFFSET;
  undefined local_31;
  long local_30;
  
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  if (1 < *(int *)(param_1 + 0x28c)) {
    __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),"About to read Component");
  }
  lVar1 = param_1 + 0x290;
  iVar2 = (**(code **)(param_1 + 0x298))(lVar1,1,1,&local_31);
  if (0 < iVar2) {
    if (1 < *(int *)(param_1 + 0x28c)) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),"About to read type");
    }
    iVar2 = (**(code **)(param_1 + 0x298))(lVar1,4,1,param_2);
    if (iVar2 < 1) {
      if (0 < *(int *)(param_1 + 0x28c)) {
        puts("ERROR: Error reading type");
      }
    }
    else {
      if (1 < *(int *)(param_1 + 0x28c)) {
        __printf_chk(1,"DEBUG(%i/%i):",2);
        __printf_chk(1,"Type = 0x%X",*param_2);
        putchar(10);
        if (1 < *(int *)(param_1 + 0x28c)) {
          __printf_chk(1,"DEBUG(%i/%i):",2);
          __printf_chk(1,"Type = %u",*param_2);
          putchar(10);
          if (1 < *(int *)(param_1 + 0x28c)) {
            __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),"About to read size");
          }
        }
      }
      iVar2 = (**(code **)(param_1 + 0x298))(lVar1,4,1,param_3);
      if (0 < iVar2) {
        if (1 < *(int *)(param_1 + 0x28c)) {
          __printf_chk(1,"DEBUG(%i/%i):",2);
          __printf_chk(1,"Size = %u",*param_3);
          putchar(10);
        }
        uVar3 = SwapDWord(param_2,4);
        *param_2 = uVar3;
        uVar3 = SwapDWord(param_3,4);
        *param_3 = uVar3;
        uVar4 = 0;
        goto LAB_00104212;
      }
      if (0 < *(int *)(param_1 + 0x28c)) {
        puts("ERROR: Error reading size");
        uVar4 = 0xfffffffd;
        goto LAB_00104212;
      }
    }
  }
  uVar4 = 0xfffffffd;
LAB_00104212:
  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 TNEFRawRead(long param_1,byte *param_2,undefined8 param_3,short *param_4)

{
  byte *pbVar1;
  byte bVar2;
  short sVar3;
  uint uVar4;
  uint uVar5;
  undefined8 uVar6;
  
  uVar4 = (**(code **)(param_1 + 0x298))(param_1 + 0x290,1,param_3,param_2);
  uVar5 = (uint)param_3;
  if (uVar4 < uVar5) {
    uVar6 = 0xfffffffd;
    if (0 < *(int *)(param_1 + 0x28c)) {
      puts("ERROR: Error reading data");
    }
  }
  else {
    if ((param_4 != (short *)0x0) && (*param_4 = 0, uVar5 != 0)) {
      pbVar1 = param_2 + (ulong)(uVar5 - 1) + 1;
      sVar3 = 0;
      do {
        bVar2 = *param_2;
        param_2 = param_2 + 1;
        sVar3 = sVar3 + (ushort)bVar2;
        *param_4 = sVar3;
      } while (param_2 != pbVar1);
    }
    uVar6 = 0;
  }
  return uVar6;
}



void TNEFInitMapi(undefined4 *param_1)

{
  *param_1 = 0;
  *(undefined8 *)(param_1 + 2) = 0;
  return;
}



void TNEFInitAttachment(undefined8 *param_1)

{
  *param_1 = 0;
  *(undefined4 *)(param_1 + 1) = 0;
  *(undefined2 *)((long)param_1 + 0xc) = 0;
  param_1[2] = 0;
  *(undefined4 *)(param_1 + 3) = 0;
  param_1[4] = 0;
  *(undefined4 *)(param_1 + 5) = 0;
  param_1[6] = 0;
  param_1[7] = 0;
  param_1[8] = 0;
  *(undefined4 *)(param_1 + 9) = 0;
  param_1[10] = 0;
  *(undefined4 *)(param_1 + 0xb) = 0;
  param_1[0x11] = 0;
  *(undefined4 *)(param_1 + 0x12) = 0;
  param_1[0x13] = 0;
  *(undefined4 *)(param_1 + 0x14) = 0;
  *(undefined (*) [16])(param_1 + 0xc) = (undefined  [16])0x0;
  TNEFInitMapi();
  param_1[0x10] = 0;
  return;
}



undefined8 TNEFRendData(long param_1,undefined8 param_2,undefined8 param_3,uint param_4)

{
  long lVar1;
  void *pvVar2;
  long lVar3;
  
  lVar1 = param_1 + 0x140;
  do {
    lVar3 = lVar1;
    lVar1 = *(long *)(lVar3 + 0x80);
  } while (lVar1 != 0);
  pvVar2 = calloc(1,0xa8);
  *(void **)(lVar3 + 0x80) = pvVar2;
  TNEFInitAttachment(pvVar2);
  if (0xf < param_4) {
    param_4 = 0x10;
  }
  __memcpy_chk((long)pvVar2 + 0x60,param_3,(long)(int)param_4,0x48);
  return 0;
}



void TNEFInitialize(undefined8 *param_1)

{
  *(undefined2 *)(param_1 + 1) = 0;
  *(undefined2 *)((long)param_1 + 0x54) = 0;
  *(undefined2 *)((long)param_1 + 0x86) = 0;
  *(undefined2 *)(param_1 + 0x17) = 0;
  *(undefined (*) [16])((long)param_1 + 0x56) = (undefined  [16])0x0;
  *(undefined (*) [16])((long)param_1 + 0x66) = (undefined  [16])0x0;
  *(undefined (*) [16])((long)param_1 + 0x76) = (undefined  [16])0x0;
  *(undefined (*) [16])(param_1 + 0x11) = (undefined  [16])0x0;
  *(undefined (*) [16])(param_1 + 0x13) = (undefined  [16])0x0;
  *(undefined (*) [16])(param_1 + 0x15) = (undefined  [16])0x0;
  *(undefined (*) [16])((long)param_1 + 0xba) = (undefined  [16])0x0;
  *(undefined (*) [16])((long)param_1 + 0xca) = (undefined  [16])0x0;
  *(undefined (*) [16])((long)param_1 + 0xda) = (undefined  [16])0x0;
  *param_1 = 0;
  param_1[2] = 0;
  *(undefined4 *)(param_1 + 3) = 0;
  param_1[4] = 0;
  *(undefined4 *)(param_1 + 5) = 0;
  param_1[6] = 0;
  param_1[7] = 0;
  param_1[8] = 0;
  *(undefined4 *)(param_1 + 9) = 0;
  *(undefined8 *)((long)param_1 + 0x4c) = 0;
  *(undefined2 *)((long)param_1 + 0xea) = 0;
  *(undefined2 *)((long)param_1 + 0x11c) = 0;
  *(undefined (*) [16])((long)param_1 + 0xec) = (undefined  [16])0x0;
  *(undefined (*) [16])((long)param_1 + 0xfc) = (undefined  [16])0x0;
  *(undefined (*) [16])((long)param_1 + 0x10c) = (undefined  [16])0x0;
  param_1[0x24] = 0;
  *(undefined4 *)(param_1 + 0x25) = 0;
  param_1[0x26] = 0;
  *(undefined2 *)(param_1 + 0x27) = 0;
  TNEFInitAttachment(param_1 + 0x28);
  param_1[0x3d] = 0;
  *(undefined4 *)(param_1 + 0x3e) = 0;
  *(undefined2 *)((long)param_1 + 500) = 0;
  TNEFInitMapi(param_1 + 0x3f);
  param_1[0x41] = 0;
  *(undefined4 *)(param_1 + 0x42) = 0;
  param_1[0x43] = 0;
  *(undefined4 *)(param_1 + 0x44) = 0;
  param_1[0x45] = 0;
  *(undefined4 *)(param_1 + 0x46) = 0;
  param_1[0x47] = 0;
  *(undefined4 *)(param_1 + 0x48) = 0;
  param_1[0x49] = 0;
  *(undefined4 *)(param_1 + 0x4a) = 0;
  param_1[0x4b] = 0;
  param_1[0x4c] = 0;
  param_1[0x4d] = 0;
  *(undefined4 *)(param_1 + 0x4e) = 0;
  param_1[0x4f] = 0;
  *(undefined4 *)(param_1 + 0x50) = 0;
  *(undefined4 *)(param_1 + 0x51) = 0;
  param_1[0x55] = 0;
  param_1[0x52] = 0;
  param_1[0x53] = 0;
  param_1[0x54] = 0;
  return;
}



void TNEFFreeMapiProps(uint *param_1)

{
  long lVar1;
  long lVar2;
  undefined8 *puVar3;
  void *pvVar4;
  long lVar5;
  long lVar6;
  long lVar7;
  
  lVar2 = 0;
  if (*param_1 != 0) {
    do {
      lVar1 = *(long *)(param_1 + 2);
      lVar5 = 0;
      lVar6 = lVar2 * 0x30;
      pvVar4 = *(void **)(lVar1 + lVar6 + 0x28);
      if (*(int *)(lVar1 + lVar6 + 0x18) != 0) {
        do {
          while( true ) {
            lVar7 = lVar5 * 0x10;
            puVar3 = (undefined8 *)((long)pvVar4 + lVar7);
            if (*(int *)(puVar3 + 1) < 1) break;
            lVar5 = lVar5 + 1;
            free((void *)*puVar3);
            lVar1 = *(long *)(param_1 + 2);
            pvVar4 = *(void **)(lVar1 + lVar6 + 0x28);
            *(undefined4 *)((long)pvVar4 + lVar7 + 8) = 0;
            if (*(uint *)(lVar1 + lVar6 + 0x18) <= (uint)lVar5) goto LAB_001047d4;
          }
          lVar5 = lVar5 + 1;
          pvVar4 = *(void **)(lVar1 + lVar6 + 0x28);
        } while ((uint)lVar5 < *(uint *)(lVar1 + lVar6 + 0x18));
      }
LAB_001047d4:
      free(pvVar4);
      lVar1 = *(long *)(param_1 + 2);
      pvVar4 = *(void **)(lVar1 + lVar6 + 0x20);
      if (0 < *(int *)(lVar1 + lVar6 + 0x1c)) {
        lVar5 = 0;
        do {
          while( true ) {
            lVar7 = lVar5 * 0x10;
            puVar3 = (undefined8 *)((long)pvVar4 + lVar7);
            if (*(int *)(puVar3 + 1) < 1) break;
            lVar5 = lVar5 + 1;
            free((void *)*puVar3);
            lVar1 = *(long *)(param_1 + 2);
            pvVar4 = *(void **)(lVar1 + lVar6 + 0x20);
            *(undefined4 *)((long)pvVar4 + lVar7 + 8) = 0;
            if (*(int *)(lVar1 + lVar6 + 0x1c) <= (int)lVar5) goto LAB_00104842;
          }
          lVar5 = lVar5 + 1;
          pvVar4 = *(void **)(lVar1 + lVar6 + 0x20);
        } while ((int)lVar5 < *(int *)(lVar1 + lVar6 + 0x1c));
      }
LAB_00104842:
      free(pvVar4);
      lVar2 = lVar2 + 1;
    } while ((uint)lVar2 < *param_1);
  }
  free(*(void **)(param_1 + 2));
  *param_1 = 0;
  return;
}



void TNEFFreeAttachment(long param_1)

{
  if (0 < *(int *)(param_1 + 0x18)) {
    free(*(void **)(param_1 + 0x10));
    *(undefined4 *)(param_1 + 0x18) = 0;
  }
  if (0 < *(int *)(param_1 + 0x28)) {
    free(*(void **)(param_1 + 0x20));
    *(undefined4 *)(param_1 + 0x28) = 0;
  }
  if (0 < *(int *)(param_1 + 0x58)) {
    free(*(void **)(param_1 + 0x50));
    *(undefined4 *)(param_1 + 0x58) = 0;
  }
  if (0 < *(int *)(param_1 + 0x90)) {
    free(*(void **)(param_1 + 0x88));
    *(undefined4 *)(param_1 + 0x90) = 0;
  }
  if (0 < *(int *)(param_1 + 0xa0)) {
    free(*(void **)(param_1 + 0x98));
    *(undefined4 *)(param_1 + 0xa0) = 0;
  }
  TNEFFreeMapiProps(param_1 + 0x70);
  return;
}



void TNEFFree(long param_1)

{
  void *pvVar1;
  void *__ptr;
  
  if (0 < *(int *)(param_1 + 0x18)) {
    free(*(void **)(param_1 + 0x10));
    *(undefined4 *)(param_1 + 0x18) = 0;
  }
  if (0 < *(int *)(param_1 + 0x28)) {
    free(*(void **)(param_1 + 0x20));
    *(undefined4 *)(param_1 + 0x28) = 0;
  }
  if (0 < *(int *)(param_1 + 0x128)) {
    free(*(void **)(param_1 + 0x120));
    *(undefined4 *)(param_1 + 0x128) = 0;
  }
  if (0 < *(int *)(param_1 + 0x210)) {
    free(*(void **)(param_1 + 0x208));
    *(undefined4 *)(param_1 + 0x210) = 0;
  }
  if (0 < *(int *)(param_1 + 0x220)) {
    free(*(void **)(param_1 + 0x218));
    *(undefined4 *)(param_1 + 0x220) = 0;
  }
  if (0 < *(int *)(param_1 + 0x230)) {
    free(*(void **)(param_1 + 0x228));
    *(undefined4 *)(param_1 + 0x230) = 0;
  }
  if (0 < *(int *)(param_1 + 0x240)) {
    free(*(void **)(param_1 + 0x238));
    *(undefined4 *)(param_1 + 0x240) = 0;
  }
  if (0 < *(int *)(param_1 + 0x250)) {
    free(*(void **)(param_1 + 0x248));
    *(undefined4 *)(param_1 + 0x250) = 0;
  }
  if (0 < *(int *)(param_1 + 0x280)) {
    free(*(void **)(param_1 + 0x278));
    *(undefined4 *)(param_1 + 0x280) = 0;
  }
  TNEFFreeMapiProps(param_1 + 0x1f8);
  __ptr = *(void **)(param_1 + 0x1c0);
  while (__ptr != (void *)0x0) {
    TNEFFreeAttachment(__ptr);
    pvVar1 = *(void **)((long)__ptr + 0x80);
    free(__ptr);
    __ptr = pvVar1;
  }
  return;
}



undefined8 TNEFParse(long param_1)

{
  long lVar1;
  int *piVar2;
  int iVar3;
  code *pcVar4;
  void *__ptr;
  ulong __nmemb;
  int *piVar5;
  undefined8 uVar6;
  long in_FS_OFFSET;
  undefined local_52 [2];
  short local_50;
  short local_4e;
  int local_4c;
  uint local_48;
  undefined4 local_44;
  long local_40;
  
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(long *)(param_1 + 0x298) == 0) {
    uVar6 = 0xfffffff8;
    puts("ERROR: Setup incorrectly: No ReadProc");
    goto LAB_00104e79;
  }
  pcVar4 = *(code **)(param_1 + 0x290);
  lVar1 = param_1 + 0x290;
  iVar3 = *(int *)(param_1 + 0x28c);
  if (pcVar4 == (code *)0x0) {
LAB_00104df4:
    if (1 < iVar3) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,iVar3,"Reading Signature");
    }
  }
  else {
    if (1 < iVar3) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,iVar3,"About to initialize");
      pcVar4 = *(code **)(param_1 + 0x290);
    }
    iVar3 = (*pcVar4)(param_1 + 0x290);
    if (iVar3 != 0) {
      uVar6 = 0xffffffff;
      goto LAB_00104e79;
    }
    if (1 < *(int *)(param_1 + 0x28c)) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),"Initialization finished");
      iVar3 = *(int *)(param_1 + 0x28c);
      goto LAB_00104df4;
    }
  }
  iVar3 = (**(code **)(param_1 + 0x298))(param_1 + 0x290,4,1,&local_44);
  if (iVar3 < 1) {
    uVar6 = 0xfffffffd;
    puts("ERROR: Error reading signature");
    pcVar4 = *(code **)(param_1 + 0x2a0);
  }
  else {
    if (1 < *(int *)(param_1 + 0x28c)) {
      __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),"Checking Signature");
    }
    iVar3 = TNEFCheckForSignature(local_44);
    if (iVar3 < 0) {
      uVar6 = 0xfffffffe;
      puts("ERROR: Signature does not match. Not TNEF.");
      pcVar4 = *(code **)(param_1 + 0x2a0);
    }
    else {
      if (1 < *(int *)(param_1 + 0x28c)) {
        __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),"Reading Key.");
      }
      iVar3 = TNEFGetKey(param_1,local_52);
      if (-1 < iVar3) {
        if (1 < *(int *)(param_1 + 0x28c)) {
          __printf_chk(1,"DEBUG(%i/%i): %s\n",2,*(int *)(param_1 + 0x28c),
                       "Starting Full Processing.");
        }
        while (iVar3 = TNEFGetHeader(param_1,&local_4c,&local_48), iVar3 == 0) {
          if (1 < *(int *)(param_1 + 0x28c)) {
            __printf_chk(1,"DEBUG(%i/%i):",2);
            __printf_chk(1,"Header says type=0x%X, size=%u",local_4c,local_48);
            putchar(10);
            if (1 < *(int *)(param_1 + 0x28c)) {
              __printf_chk(1,"DEBUG(%i/%i):",2);
              __printf_chk(1,"Header says type=%u, size=%u",local_4c,local_48);
              putchar(10);
            }
          }
          __nmemb = (ulong)local_48;
          __ptr = calloc(__nmemb,1);
          iVar3 = TNEFRawRead(param_1,__ptr,__nmemb,&local_4e);
          if (iVar3 < 0) {
            puts("ERROR: Unable to read data.");
            pcVar4 = *(code **)(param_1 + 0x2a0);
joined_r0x00104ee4:
            if (pcVar4 != (code *)0x0) {
              (*pcVar4)(lVar1);
            }
            uVar6 = 0xfffffffd;
            free(__ptr);
            goto LAB_00104e79;
          }
          iVar3 = TNEFRawRead(param_1,&local_50,2,0);
          if (iVar3 < 0) {
            puts("ERROR: Unable to read checksum.");
            pcVar4 = *(code **)(param_1 + 0x2a0);
            goto joined_r0x00104ee4;
          }
          local_50 = SwapWord(&local_50,2);
          if (local_50 != local_4e) {
            puts("ERROR: Checksum mismatch. Data corruption?:");
            if (*(code **)(param_1 + 0x2a0) != (code *)0x0) {
              (**(code **)(param_1 + 0x2a0))(lVar1);
            }
            uVar6 = 0xfffffffb;
            free(__ptr);
            goto LAB_00104e79;
          }
          piVar5 = &TNEFList;
          iVar3 = 0;
LAB_00104c86:
          do {
            if (*piVar5 == local_4c) {
              if (*(code **)(piVar5 + 0xc) != (code *)0x0) {
                iVar3 = (**(code **)(piVar5 + 0xc))(param_1,iVar3,__ptr,local_48);
                if (iVar3 < 0) {
                  uVar6 = 0xfffffffa;
                  free(__ptr);
                  pcVar4 = *(code **)(param_1 + 0x2a0);
                  goto joined_r0x00104dbf;
                }
                break;
              }
              if (0 < *(int *)(param_1 + 0x28c)) {
                __printf_chk(1,"DEBUG(%i/%i):",1);
                piVar2 = piVar5 + 1;
                iVar3 = iVar3 + 1;
                piVar5 = piVar5 + 0xe;
                __printf_chk(1,"No handler for %s: %u bytes",piVar2,local_48);
                putchar(10);
                if (iVar3 == 0x21) break;
                goto LAB_00104c86;
              }
            }
            iVar3 = iVar3 + 1;
            piVar5 = piVar5 + 0xe;
          } while (iVar3 != 0x21);
          free(__ptr);
        }
        uVar6 = 0;
        if (*(code **)(param_1 + 0x2a0) != (code *)0x0) {
          (**(code **)(param_1 + 0x2a0))(lVar1);
        }
        goto LAB_00104e79;
      }
      uVar6 = 0xfffffffc;
      puts("ERROR: Unable to retrieve key.");
      pcVar4 = *(code **)(param_1 + 0x2a0);
    }
  }
joined_r0x00104dbf:
  if (pcVar4 != (code *)0x0) {
    (*pcVar4)(lVar1);
  }
LAB_00104e79:
  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
    return uVar6;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void TNEFParseFile(undefined8 param_1,long param_2)

{
  long in_FS_OFFSET;
  undefined8 local_38;
  undefined8 local_30;
  int local_28;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  local_28 = *(int *)(param_2 + 0x28c);
  if (0 < local_28) {
    __printf_chk(1,"Attempting to parse %s...\n",param_1);
    local_28 = *(int *)(param_2 + 0x28c);
  }
  *(undefined8 **)(param_2 + 0x2a8) = &local_38;
  *(code **)(param_2 + 0x290) = TNEFFile_Open;
  local_30 = 0;
  *(code **)(param_2 + 0x298) = TNEFFile_Read;
  *(code **)(param_2 + 0x2a0) = TNEFFile_Close;
  local_38 = param_1;
  TNEFParse(param_2);
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void TNEFParseMemory(undefined8 param_1,undefined8 param_2,long param_3)

{
  long in_FS_OFFSET;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  int local_30;
  long local_20;
  
  local_30 = *(int *)(param_3 + 0x28c);
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  if (0 < local_30) {
    __printf_chk(1,"DEBUG(%i/%i): %s\n",1,local_30,"Attempting to parse memory block...\n");
    local_30 = *(int *)(param_3 + 0x28c);
  }
  *(undefined8 **)(param_3 + 0x2a8) = &local_48;
  *(code **)(param_3 + 0x290) = TNEFMemory_Open;
  *(code **)(param_3 + 0x298) = TNEFMemory_Read;
  *(code **)(param_3 + 0x2a0) = TNEFMemory_Close;
  local_48 = param_1;
  local_40 = param_1;
  local_38 = param_2;
  TNEFParse(param_3);
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined8 MAPIFindUserProp(int *param_1,int param_2)

{
  int *piVar1;
  int *piVar2;
  
  if ((param_1 != (int *)0x0) && (*param_1 != 0)) {
    piVar2 = *(int **)(param_1 + 2);
    piVar1 = piVar2 + (ulong)(*param_1 - 1) * 0xc + 0xc;
    do {
      if ((piVar2[5] == param_2) && (*piVar2 == 1)) {
        return *(undefined8 *)(piVar2 + 10);
      }
      piVar2 = piVar2 + 0xc;
    } while (piVar2 != piVar1);
  }
  return 0xffffffffffffffff;
}



undefined8 MAPIFindProperty(int *param_1,int param_2)

{
  int *piVar1;
  int *piVar2;
  
  if ((param_1 != (int *)0x0) && (*param_1 != 0)) {
    piVar2 = *(int **)(param_1 + 2);
    piVar1 = piVar2 + (ulong)(*param_1 - 1) * 0xc + 0xc;
    do {
      if ((piVar2[5] == param_2) && (*piVar2 == 0)) {
        return *(undefined8 *)(piVar2 + 10);
      }
      piVar2 = piVar2 + 0xc;
    } while (piVar2 != piVar1);
  }
  return 0xffffffffffffffff;
}



undefined8 MAPISysTimetoDTR(ulong *param_1,ushort *param_2)

{
  uint uVar1;
  uint uVar2;
  ulong uVar3;
  ulong uVar4;
  int iVar5;
  ulong uVar6;
  int iVar7;
  ushort uVar8;
  long in_FS_OFFSET;
  uint local_48 [14];
  long local_10;
  
  uVar6 = *param_1;
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_48[0] = 0x1f;
  local_48[1] = 0x1c;
  local_48[2] = 0x1f;
  local_48[3] = 0x1e;
  local_48[4] = 0x1f;
  local_48[5] = 0x1e;
  local_48[6] = 0x1f;
  local_48[7] = 0x1f;
  local_48[8] = 0x1e;
  local_48[9] = 0x1f;
  local_48[10] = 0x1e;
  local_48[0xb] = 0x1f;
  uVar3 = uVar6 / 10000000;
  uVar4 = uVar3 / 0x3c;
  param_2[5] = (short)uVar3 + ((short)(uVar4 << 4) - (short)uVar4) * -4;
  uVar3 = uVar4 / 0x3c;
  param_2[4] = (short)uVar4 + ((short)(uVar3 << 4) - (short)uVar3) * -4;
  uVar4 = uVar3 / 0x18;
  param_2[3] = (short)uVar3 + (short)uVar4 * -0x18;
  if (uVar6 < 0x11ed178c6c000) {
    iVar5 = 1;
    *param_2 = 0x641;
  }
  else {
    uVar4 = uVar4 - 0x16d;
    uVar6 = 2;
    uVar8 = 0x642;
    *param_2 = 0x642;
    iVar7 = 0x16d;
    while( true ) {
      iVar5 = (int)(uVar6 * 0x24924925 >> 0x20);
      iVar5 = (int)uVar6 + (((uint)((int)uVar6 - iVar5) >> 1) + iVar5 >> 2) * -7;
      if (uVar4 < (ulong)(long)iVar7) break;
      uVar8 = uVar8 + 1;
      uVar4 = uVar4 - (long)iVar7;
      uVar6 = (ulong)(iVar5 + 1);
      iVar7 = 0x16d;
      *param_2 = uVar8;
      if (((uVar8 & 3) == 0) &&
         ((0x28f < (ushort)((ushort)(uVar8 * 0x5c29) >> 2 | uVar8 * 0x4000) ||
          ((ushort)((ushort)(uVar8 * 0x5c29) >> 4 | uVar8 * -0x7000) < 0xa4)))) {
        uVar6 = (ulong)(iVar5 + 2);
        iVar7 = 0x16e;
      }
    }
    if ((uVar8 & 3) == 0) {
      local_48[0] = 0x1f;
      local_48[1] = 0x1d;
    }
  }
  uVar1 = (uint)uVar4;
  uVar6 = uVar4 & 0xffffffff;
  param_2[6] = (short)(iVar5 + uVar1) + (short)((iVar5 + uVar1) / 7) * -7;
  if (uVar4 < 0x20) {
    uVar8 = 1;
  }
  else {
    uVar8 = 1;
    uVar2 = 0x1f;
    do {
      uVar1 = (int)uVar6 - uVar2;
      uVar6 = (ulong)uVar1;
      uVar3 = (ulong)uVar8;
      uVar8 = uVar8 + 1;
      uVar2 = local_48[uVar3];
    } while (uVar2 < uVar1);
  }
  param_2[1] = uVar8;
  param_2[2] = (short)uVar1 + 1;
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



bool IsCompressedRTF(long *param_1)

{
  int iVar1;
  
  iVar1 = SwapDWord(*param_1 + 8,4);
  return iVar1 == 0x75465a4c || iVar1 == 0x414c454d;
}



void * DecompressRTF(long *param_1,uint *param_2)

{
  uint uVar1;
  byte bVar2;
  undefined uVar3;
  long lVar4;
  undefined8 uVar5;
  undefined8 uVar6;
  undefined8 uVar7;
  undefined8 uVar8;
  undefined8 uVar9;
  undefined8 uVar10;
  undefined8 uVar11;
  undefined8 uVar12;
  undefined8 uVar13;
  undefined8 uVar14;
  undefined8 uVar15;
  undefined8 uVar16;
  undefined8 uVar17;
  undefined8 uVar18;
  int iVar19;
  uint uVar20;
  int iVar21;
  uint uVar22;
  undefined8 *__ptr;
  undefined8 *__ptr_00;
  void *__dest;
  byte bVar23;
  uint uVar24;
  ulong uVar25;
  undefined *puVar26;
  ulong uVar27;
  uint uVar28;
  uint uVar29;
  uint uVar30;
  uint uVar31;
  
  __ptr = (undefined8 *)calloc(0xd0,1);
  lVar4 = *param_1;
  *__ptr = 0x615c316674725c7b;
  __ptr[1] = 0x5c63616d5c69736e;
  __ptr[2] = 0x65645c3066666564;
  __ptr[3] = 0x7b30323762617466;
  __ptr[4] = 0x6c6274746e6f665c;
  __ptr[5] = 0x665c30665c7b7d3b;
  __ptr[6] = 0x6f72665c206c696e;
  __ptr[7] = 0x7773665c206e616d;
  __ptr[8] = 0x6f6d665c20737369;
  __ptr[9] = 0x73665c206e726564;
  __ptr[10] = 0x665c207470697263;
  __ptr[0xb] = 0x534d20726f636564;
  __ptr[0xc] = 0x655320736e615320;
  __ptr[0xd] = 0x6f626d7953666972;
  __ptr[0xe] = 0x69546c616972416c;
  __ptr[0xf] = 0x2077654e2073656d;
  __ptr[0x10] = 0x756f436e616d6f52;
  __ptr[0x11] = 0x6f635c7b72656972;
  __ptr[0x12] = 0x725c6c6274726f6c;
  __ptr[0x13] = 0x656572675c306465;
  __ptr[0x14] = 0x3065756c625c306e;
  __ptr[0x15] = 0x5c207261705c0d0a;
  __ptr[0x16] = 0x616c705c64726170;
  __ptr[0x17] = 0x73665c30665c6e69;
  __ptr[0x18] = 0x755c695c625c3032;
  *(undefined4 *)(__ptr + 0x19) = 0x6261745c;
  *(undefined2 *)((long)__ptr + 0xcc) = 0x745c;
  *(undefined *)((long)__ptr + 0xce) = 0x78;
  iVar19 = SwapDWord(lVar4,4);
  uVar20 = SwapDWord(lVar4 + 4,4);
  iVar21 = SwapDWord(lVar4 + 8,4);
  if (*(int *)(param_1 + 1) + -4 == iVar19) {
    if (iVar21 != 0x414c454d) {
      if (iVar21 == 0x75465a4c) {
        uVar28 = uVar20 + 0xcf;
        __ptr_00 = (undefined8 *)calloc((ulong)uVar28,1);
        uVar5 = __ptr[1];
        uVar6 = __ptr[2];
        uVar7 = __ptr[3];
        uVar8 = __ptr[4];
        uVar9 = __ptr[5];
        uVar10 = __ptr[6];
        uVar11 = __ptr[7];
        uVar12 = __ptr[8];
        uVar13 = __ptr[9];
        *__ptr_00 = *__ptr;
        __ptr_00[1] = uVar5;
        uVar5 = __ptr[10];
        uVar14 = __ptr[0xb];
        __ptr_00[2] = uVar6;
        __ptr_00[3] = uVar7;
        uVar6 = __ptr[0xc];
        uVar7 = __ptr[0xd];
        uVar15 = __ptr[0xe];
        uVar16 = __ptr[0xf];
        __ptr_00[4] = uVar8;
        __ptr_00[5] = uVar9;
        uVar8 = __ptr[0x10];
        uVar9 = __ptr[0x11];
        uVar17 = __ptr[0x12];
        uVar18 = __ptr[0x13];
        __ptr_00[6] = uVar10;
        __ptr_00[7] = uVar11;
        uVar10 = __ptr[0x14];
        uVar11 = __ptr[0x15];
        __ptr_00[8] = uVar12;
        __ptr_00[9] = uVar13;
        uVar12 = __ptr[0x16];
        uVar13 = __ptr[0x17];
        __ptr_00[10] = uVar5;
        __ptr_00[0xb] = uVar14;
        __ptr_00[0xc] = uVar6;
        __ptr_00[0xd] = uVar7;
        __ptr_00[0xe] = uVar15;
        __ptr_00[0xf] = uVar16;
        __ptr_00[0x10] = uVar8;
        __ptr_00[0x11] = uVar9;
        __ptr_00[0x12] = uVar17;
        __ptr_00[0x13] = uVar18;
        __ptr_00[0x14] = uVar10;
        __ptr_00[0x15] = uVar11;
        __ptr_00[0x16] = uVar12;
        __ptr_00[0x17] = uVar13;
        __ptr_00[0x18] = __ptr[0x18];
        *(undefined4 *)(__ptr_00 + 0x19) = *(undefined4 *)(__ptr + 0x19);
        *(undefined2 *)((long)__ptr_00 + 0xcc) = *(undefined2 *)((long)__ptr + 0xcc);
        *(undefined *)((long)__ptr_00 + 0xce) = *(undefined *)((long)__ptr + 0xce);
        if (0xcf < uVar28) {
          uVar30 = 0;
          uVar31 = 0;
          uVar22 = 0xcf;
          uVar25 = 0x10;
          do {
            while( true ) {
              uVar24 = (uint)uVar25;
              uVar29 = uVar24 + 1;
              bVar2 = *(byte *)(lVar4 + uVar25);
              if ((uVar30 & 7) == 0) break;
              uVar31 = (int)uVar31 >> 1;
              uVar25 = (ulong)uVar29;
              bVar23 = bVar2;
              uVar29 = uVar24;
              if ((uVar31 & 1) == 0) goto LAB_001056f4;
LAB_0010572a:
              iVar19 = (*(byte *)(lVar4 + uVar25) & 0xf) + 2;
              uVar24 = ((int)(uint)*(byte *)(lVar4 + uVar25) >> 4 | (uint)bVar23 << 4) +
                       (uVar22 & 0xfffff000);
              if (uVar22 <= uVar24) {
                uVar24 = uVar24 - 0x1000;
              }
              if ((int)uVar24 < (int)(uVar24 + iVar19)) {
                uVar1 = iVar19 + uVar22;
                puVar26 = (undefined *)((long)(int)uVar24 + (long)__ptr_00);
                do {
                  uVar3 = *puVar26;
                  uVar25 = (ulong)uVar22;
                  uVar22 = uVar22 + 1;
                  puVar26 = puVar26 + 1;
                  *(undefined *)((long)__ptr_00 + uVar25) = uVar3;
                } while (uVar1 != uVar22);
              }
              uVar25 = (ulong)(uVar29 + 2);
              uVar30 = uVar30 + 1;
              if (uVar28 <= uVar22) goto LAB_0010579d;
            }
            uVar31 = (uint)bVar2;
            uVar25 = (ulong)(uVar24 + 2);
            bVar23 = *(byte *)(lVar4 + (ulong)uVar29);
            if ((bVar2 & 1) != 0) goto LAB_0010572a;
LAB_001056f4:
            uVar27 = (ulong)uVar22;
            uVar22 = uVar22 + 1;
            uVar30 = uVar30 + 1;
            *(byte *)((long)__ptr_00 + uVar27) = bVar23;
          } while (uVar22 < uVar28);
        }
LAB_0010579d:
        __dest = calloc((ulong)uVar20,1);
        memcpy(__dest,(void *)((long)__ptr_00 + 0xcf),(ulong)uVar20);
        free(__ptr_00);
        *param_2 = uVar20;
        free(__ptr);
        return __dest;
      }
      __printf_chk(1,"Unknown compression type (magic number %x)\n",iVar21);
    }
    free(__ptr);
  }
  else {
    __printf_chk(1," Size Mismatch: %u != %i\n",iVar19);
    free(__ptr);
  }
  return (void *)0x0;
}



void MAPIPrint(uint *param_1)

{
  undefined *puVar1;
  undefined8 uVar2;
  bool bVar3;
  uint uVar4;
  int iVar5;
  size_t sVar6;
  ushort **ppuVar7;
  uint *puVar8;
  uint uVar9;
  int *piVar10;
  long lVar11;
  long *plVar12;
  long lVar13;
  ulong uVar14;
  long in_FS_OFFSET;
  ulong local_90;
  undefined8 local_66;
  undefined2 local_5e;
  undefined2 local_5c;
  undefined2 local_5a;
  char *local_58;
  undefined local_50 [16];
  long local_40;
  
  local_40 = *(long *)(in_FS_OFFSET + 0x28);
  if (*param_1 != 0) {
    local_90 = 0;
    do {
      piVar10 = (int *)(local_90 * 0x30 + *(long *)(param_1 + 2));
      __printf_chk(1,"   #%i: Type: [",local_90 & 0xffffffff);
      switch(*(short *)(piVar10 + 5)) {
      case 0:
        __printf_chk(1,"  NONE   ");
        break;
      case 1:
        __printf_chk(1,"  NULL   ");
        break;
      case 2:
        __printf_chk(1,&DAT_00107356);
        break;
      case 3:
        __printf_chk(1,"  LONG   ");
        break;
      case 4:
        __printf_chk(1,"   R4    ");
        break;
      case 5:
        __printf_chk(1," DOUBLE  ");
        break;
      case 6:
        __printf_chk(1,"CURRENCY ");
        break;
      case 7:
        __printf_chk(1,"APP TIME ");
        break;
      case 8:
      case 9:
      case 0xc:
      case 0xe:
      case 0xf:
      case 0x10:
      case 0x11:
      case 0x12:
      case 0x13:
      case 0x15:
      case 0x16:
      case 0x17:
      case 0x18:
      case 0x19:
      case 0x1a:
      case 0x1b:
      case 0x1c:
      case 0x1d:
      case 0x20:
      case 0x21:
      case 0x22:
      case 0x23:
      case 0x24:
      case 0x25:
      case 0x26:
      case 0x27:
      case 0x28:
      case 0x29:
      case 0x2a:
      case 0x2b:
      case 0x2c:
      case 0x2d:
      case 0x2e:
      case 0x2f:
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x3a:
      case 0x3b:
      case 0x3c:
      case 0x3d:
      case 0x3e:
      case 0x3f:
      case 0x41:
      case 0x42:
      case 0x43:
      case 0x44:
      case 0x45:
      case 0x46:
      case 0x47:
switchD_001058a0_caseD_8:
        __printf_chk(1,&DAT_001073ec);
        break;
      case 10:
        __printf_chk(1,"  ERROR  ");
        break;
      case 0xb:
        __printf_chk(1," BOOLEAN ");
        break;
      case 0xd:
        __printf_chk(1," OBJECT  ");
        break;
      case 0x14:
        __printf_chk(1,"   I8    ");
        break;
      case 0x1e:
        __printf_chk(1," STRING8 ");
        break;
      case 0x1f:
        __printf_chk(1," UNICODE ");
        break;
      case 0x40:
        __printf_chk(1,"SYS TIME ");
        break;
      case 0x48:
        __printf_chk(1,"OLE GUID ");
        break;
      default:
        if (*(short *)(piVar10 + 5) != 0x102) goto switchD_001058a0_caseD_8;
        __printf_chk(1," BINARY  ");
      }
      __printf_chk(1,"]  Code: [");
      if (*piVar10 == 1) {
        __printf_chk(1,"UD:x%04x",*(undefined2 *)((long)piVar10 + 0x16));
      }
      else {
        puVar8 = &MPList;
        bVar3 = false;
        do {
          while ((*puVar8 != (uint)*(ushort *)((long)piVar10 + 0x16) || (bVar3))) {
            puVar8 = puVar8 + 0x21;
            if (puVar8 == &TNEFList) goto LAB_00105942;
          }
          __printf_chk(1,"%s",puVar8 + 1);
          puVar8 = puVar8 + 0x21;
          bVar3 = true;
        } while (puVar8 != &TNEFList);
LAB_00105942:
        if (!bVar3) {
          __printf_chk(1,"0x%04x",*(undefined2 *)((long)piVar10 + 0x16));
        }
      }
      puts("]");
      if (0 < piVar10[7]) {
        lVar11 = 0;
        do {
          lVar13 = lVar11 + 1;
          __printf_chk(1,"    Name: %s\n",*(undefined8 *)(lVar11 * 0x10 + *(long *)(piVar10 + 8)));
          lVar11 = lVar13;
        } while ((int)lVar13 < piVar10[7]);
      }
      uVar9 = piVar10[6];
      if (uVar9 != 0) {
        uVar14 = 0;
        do {
          plVar12 = (long *)(uVar14 * 0x10 + *(long *)(piVar10 + 10));
          if (uVar9 == 1) {
            __printf_chk(1,&DAT_0010735b);
          }
          else {
            __printf_chk(1,"    [%i/%u] ",uVar14 & 0xffffffff);
          }
          __printf_chk(1,"Size: %i",*(undefined4 *)(plVar12 + 1));
          uVar9 = piVar10[5];
          uVar4 = uVar9 & 0xffff;
          if (0x1e < (ushort)uVar9) {
            if (uVar4 == 0x48) {
              lVar11 = 0;
              __printf_chk(1,"    Value: ");
              __printf_chk(1,"[HEX: ");
              do {
                puVar1 = (undefined *)(*plVar12 + lVar11);
                lVar11 = lVar11 + 1;
                __printf_chk(1," %02x",*puVar1);
              } while (lVar11 != 0x10);
LAB_00105cd2:
              puts("]");
            }
            else if (uVar4 == 0x102) {
              iVar5 = IsCompressedRTF(plVar12);
              if (iVar5 != 1) {
                __printf_chk(1,"    Value: [");
                if (0 < *(int *)(plVar12 + 1)) {
                  ppuVar7 = __ctype_b_loc();
                  lVar11 = 0;
                  do {
                    uVar9 = (uint)*(byte *)(*plVar12 + lVar11);
                    if ((*(byte *)((long)*ppuVar7 + (ulong)*(byte *)(*plVar12 + lVar11) * 2 + 1) &
                        0x40) == 0) {
                      uVar9 = 0x2e;
                    }
                    putchar(uVar9);
                    lVar11 = lVar11 + 1;
                  } while ((int)lVar11 < *(int *)(plVar12 + 1));
                  goto LAB_00105d6f;
                }
                goto LAB_00105cd2;
              }
              __printf_chk(1,"    Detected Compressed RTF. ");
              puts("Decompressed text follows");
              puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
              local_58 = (char *)DecompressRTF(plVar12,local_50);
              if (local_58 != (char *)0x0) {
                puts(local_58);
                free(local_58);
              }
              puts("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
            }
            else {
              if (uVar4 != 0x40) goto switchD_00105a04_caseD_0;
              lVar11 = 0;
              MAPISysTimetoDTR(*plVar12,&local_66);
              __printf_chk(1,"    Value: ");
              uVar2 = *(undefined8 *)*plVar12;
              TNEFPrintDate(local_66,(ulong)CONCAT24(local_5a,CONCAT22(local_5c,local_5e)));
              __printf_chk(1,&DAT_0010743e);
              do {
                puVar1 = (undefined *)(*plVar12 + lVar11);
                lVar11 = lVar11 + 1;
                __printf_chk(1," %02x",*puVar1);
              } while (lVar11 != 8);
              __printf_chk(1,"] (%llu)\n",uVar2);
            }
            goto LAB_00105a40;
          }
          if ((uVar9 & 0xfffe) == 0) {
switchD_00105a04_caseD_0:
            __printf_chk(1,"    Value: [%s]\n",*plVar12);
          }
          else {
            switch(uVar4) {
            default:
              goto switchD_00105a04_caseD_0;
            case 2:
              __printf_chk(1,"    Value: %hi\n",(int)*(short *)*plVar12);
              break;
            case 3:
              __printf_chk(1,"    Value: %li\n",*(undefined8 *)*plVar12);
              break;
            case 0xb:
              if (*(char *)**(undefined8 **)(piVar10 + 10) == '\0') {
                puts("    Value: False");
              }
              else {
                puts("    Value: True");
              }
              break;
            case 0xd:
              putchar(10);
              break;
            case 0x1e:
              __printf_chk(1,"    Value: [%s]\n",*plVar12);
              sVar6 = strlen((char *)*plVar12);
              if (sVar6 != (long)(*(int *)(plVar12 + 1) + -1)) {
                __printf_chk(1,"Detected Hidden data: [");
                if (*(int *)(plVar12 + 1) < 1) goto LAB_00105cd2;
                ppuVar7 = __ctype_b_loc();
                lVar11 = 0;
                do {
                  uVar9 = (uint)*(byte *)(*plVar12 + lVar11);
                  if ((*(byte *)((long)*ppuVar7 + (ulong)*(byte *)(*plVar12 + lVar11) * 2 + 1) &
                      0x40) == 0) {
                    uVar9 = 0x2e;
                  }
                  putchar(uVar9);
                  lVar11 = lVar11 + 1;
                } while ((int)lVar11 < *(int *)(plVar12 + 1));
LAB_00105d6f:
                puts("]");
              }
            }
          }
LAB_00105a40:
          uVar14 = uVar14 + 1;
          uVar9 = piVar10[6];
        } while ((uint)uVar14 < uVar9);
      }
      local_90 = local_90 + 1;
    } while ((uint)local_90 < *param_1);
  }
  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



undefined8 TNEFMapiProperties(long param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4)

{
  TNEFFillMapi(param_1,param_3,param_4,param_1 + 0x1f8);
  if (*(int *)(param_1 + 0x28c) < 3) {
    return 0;
  }
  MAPIPrint(param_1 + 0x1f8);
  return 0;
}



void _DT_FINI(void)

{
  return;
}


